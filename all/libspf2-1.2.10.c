/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_20 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_20 __in6_u ;
};
#line 252 "/usr/include/arpa/nameser.h"
enum __ns_type {
    ns_t_invalid = 0,
    ns_t_a = 1,
    ns_t_ns = 2,
    ns_t_md = 3,
    ns_t_mf = 4,
    ns_t_cname = 5,
    ns_t_soa = 6,
    ns_t_mb = 7,
    ns_t_mg = 8,
    ns_t_mr = 9,
    ns_t_null = 10,
    ns_t_wks = 11,
    ns_t_ptr = 12,
    ns_t_hinfo = 13,
    ns_t_minfo = 14,
    ns_t_mx = 15,
    ns_t_txt = 16,
    ns_t_rp = 17,
    ns_t_afsdb = 18,
    ns_t_x25 = 19,
    ns_t_isdn = 20,
    ns_t_rt = 21,
    ns_t_nsap = 22,
    ns_t_nsap_ptr = 23,
    ns_t_sig = 24,
    ns_t_key = 25,
    ns_t_px = 26,
    ns_t_gpos = 27,
    ns_t_aaaa = 28,
    ns_t_loc = 29,
    ns_t_nxt = 30,
    ns_t_eid = 31,
    ns_t_nimloc = 32,
    ns_t_srv = 33,
    ns_t_atma = 34,
    ns_t_naptr = 35,
    ns_t_kx = 36,
    ns_t_cert = 37,
    ns_t_a6 = 38,
    ns_t_dname = 39,
    ns_t_sink = 40,
    ns_t_opt = 41,
    ns_t_apl = 42,
    ns_t_tkey = 249,
    ns_t_tsig = 250,
    ns_t_ixfr = 251,
    ns_t_axfr = 252,
    ns_t_mailb = 253,
    ns_t_maila = 254,
    ns_t_any = 255,
    ns_t_zxfr = 256,
    ns_t_max = 65536
} ;
#line 252 "/usr/include/arpa/nameser.h"
typedef enum __ns_type ns_type;
#line 19 "../../src/include/spf_server.h"
struct SPF_server_struct;
#line 19 "../../src/include/spf_server.h"
typedef struct SPF_server_struct SPF_server_t;
#line 22 "../../src/include/spf_record.h"
struct SPF_record_struct;
#line 22 "../../src/include/spf_record.h"
typedef struct SPF_record_struct SPF_record_t;
#line 23
struct SPF_macro_struct;
#line 23 "../../src/include/spf_record.h"
typedef struct SPF_macro_struct SPF_macro_t;
#line 78 "../../src/include/spf_response.h"
enum SPF_result_enum {
    SPF_RESULT_INVALID = 0,
    SPF_RESULT_NEUTRAL = 1,
    SPF_RESULT_PASS = 2,
    SPF_RESULT_FAIL = 3,
    SPF_RESULT_SOFTFAIL = 4,
    SPF_RESULT_NONE = 5,
    SPF_RESULT_TEMPERROR = 6,
    SPF_RESULT_PERMERROR = 7
} ;
#line 78 "../../src/include/spf_response.h"
typedef enum SPF_result_enum SPF_result_t;
#line 99
enum SPF_reason_enum {
    SPF_REASON_NONE = 0,
    SPF_REASON_FAILURE = 1,
    SPF_REASON_LOCALHOST = 2,
    SPF_REASON_LOCAL_POLICY = 3,
    SPF_REASON_MECH = 4,
    SPF_REASON_DEFAULT = 5,
    SPF_REASON_2MX = 6
} ;
#line 99 "../../src/include/spf_response.h"
typedef enum SPF_reason_enum SPF_reason_t;
#line 118
enum SPF_errcode_t {
    SPF_E_SUCCESS = 0,
    SPF_E_NO_MEMORY = 1,
    SPF_E_NOT_SPF = 2,
    SPF_E_SYNTAX = 3,
    SPF_E_MOD_W_PREF = 4,
    SPF_E_INVALID_CHAR = 5,
    SPF_E_UNKNOWN_MECH = 6,
    SPF_E_INVALID_OPT = 7,
    SPF_E_INVALID_CIDR = 8,
    SPF_E_MISSING_OPT = 9,
    SPF_E_INTERNAL_ERROR = 10,
    SPF_E_INVALID_ESC = 11,
    SPF_E_INVALID_VAR = 12,
    SPF_E_BIG_SUBDOM = 13,
    SPF_E_INVALID_DELIM = 14,
    SPF_E_BIG_STRING = 15,
    SPF_E_BIG_MECH = 16,
    SPF_E_BIG_MOD = 17,
    SPF_E_BIG_DNS = 18,
    SPF_E_INVALID_IP4 = 19,
    SPF_E_INVALID_IP6 = 20,
    SPF_E_INVALID_PREFIX = 21,
    SPF_E_RESULT_UNKNOWN = 22,
    SPF_E_UNINIT_VAR = 23,
    SPF_E_MOD_NOT_FOUND = 24,
    SPF_E_NOT_CONFIG = 25,
    SPF_E_DNS_ERROR = 26,
    SPF_E_BAD_HOST_IP = 27,
    SPF_E_BAD_HOST_TLD = 28,
    SPF_E_MECH_AFTER_ALL = 29,
    SPF_E_INCLUDE_RETURNED_NONE = 30,
    SPF_E_RECURSIVE = 31,
    SPF_E_MULTIPLE_RECORDS = 32
} ;
#line 118 "../../src/include/spf_response.h"
typedef enum SPF_errcode_t SPF_errcode_t;
#line 156 "../../src/include/spf_response.h"
struct SPF_error_struct {
   SPF_errcode_t code ;
   char *message ;
   char is_error ;
};
#line 156 "../../src/include/spf_response.h"
typedef struct SPF_error_struct SPF_error_t;
#line 164
struct SPF_response_struct;
#line 164 "../../src/include/spf_response.h"
typedef struct SPF_response_struct SPF_response_t;
#line 19 "../../src/include/spf_request.h"
struct SPF_request_struct;
#line 19 "../../src/include/spf_request.h"
typedef struct SPF_request_struct SPF_request_t;
#line 23 "../../src/include/spf_request.h"
struct SPF_request_struct {
   SPF_server_t *spf_server ;
   int client_ver ;
   struct in_addr ipv4 ;
   struct in6_addr ipv6 ;
   char *env_from ;
   char *helo_dom ;
   char *rcpt_to_dom ;
   char use_local_policy ;
   char use_helo ;
   char *env_from_lp ;
   char *env_from_dp ;
   char *client_dom ;
   char const   *cur_dom ;
};
#line 169 "../../src/include/spf_response.h"
struct SPF_response_struct {
   SPF_request_t *spf_request ;
   SPF_record_t *spf_record_exp ;
   SPF_result_t result ;
   SPF_reason_t reason ;
   SPF_errcode_t err ;
   char *received_spf ;
   char *received_spf_value ;
   char *header_comment ;
   char *smtp_comment ;
   char *explanation ;
   SPF_error_t *errors ;
   unsigned short errors_size ;
   unsigned short errors_length ;
   unsigned short num_errors ;
   int num_dns_mech ;
};
#line 103 "../../src/include/spf_record.h"
struct SPF_data_str_struct {
   unsigned char parm_type ;
   unsigned char len ;
   unsigned char __unused0 ;
   unsigned char __unused1 ;
};
#line 103 "../../src/include/spf_record.h"
typedef struct SPF_data_str_struct SPF_data_str_t;
#line 114 "../../src/include/spf_record.h"
struct SPF_data_var_struct {
   unsigned char parm_type ;
   unsigned char num_rhs ;
   unsigned short rev : 1 ;
   unsigned short url_encode : 1 ;
   unsigned short delim_dot : 1 ;
   unsigned short delim_dash : 1 ;
   unsigned short delim_plus : 1 ;
   unsigned short delim_equal : 1 ;
   unsigned short delim_bar : 1 ;
   unsigned short delim_under : 1 ;
};
#line 114 "../../src/include/spf_record.h"
typedef struct SPF_data_var_struct SPF_data_var_t;
#line 129 "../../src/include/spf_record.h"
struct SPF_data_cidr_struct {
   unsigned char parm_type ;
   unsigned char ipv4 ;
   unsigned char ipv6 ;
   unsigned char __unused0 ;
};
#line 129 "../../src/include/spf_record.h"
typedef struct SPF_data_cidr_struct SPF_data_cidr_t;
#line 140 "../../src/include/spf_record.h"
union SPF_data_union {
   SPF_data_var_t dv ;
   SPF_data_str_t ds ;
   SPF_data_cidr_t dc ;
};
#line 140 "../../src/include/spf_record.h"
typedef union SPF_data_union SPF_data_t;
#line 173 "../../src/include/spf_record.h"
struct SPF_mech_struct {
   unsigned char prefix_type ;
   unsigned char mech_type ;
   unsigned short mech_len ;
};
#line 173 "../../src/include/spf_record.h"
typedef struct SPF_mech_struct SPF_mech_t;
#line 186 "../../src/include/spf_record.h"
struct SPF_mod_struct {
   unsigned short name_len ;
   unsigned short data_len ;
};
#line 186 "../../src/include/spf_record.h"
typedef struct SPF_mod_struct SPF_mod_t;
#line 200 "../../src/include/spf_record.h"
struct SPF_record_struct {
   SPF_server_t *spf_server ;
   unsigned char version ;
   unsigned char num_mech ;
   unsigned char num_mod ;
   unsigned char num_dns_mech ;
   SPF_mech_t *mech_first ;
   size_t mech_size ;
   size_t mech_len ;
   SPF_mod_t *mod_first ;
   size_t mod_size ;
   size_t mod_len ;
};
#line 220 "../../src/include/spf_record.h"
struct SPF_macro_struct {
   size_t macro_len ;
};
#line 79 "../../src/include/spf_dns.h"
typedef int SPF_dns_stat_t;
#line 81
struct SPF_dns_server_struct;
#line 81 "../../src/include/spf_dns.h"
typedef struct SPF_dns_server_struct SPF_dns_server_t;
#line 30 "../../src/include/spf_dns_rr.h"
union __anonunion_SPF_dns_rr_data_t_59 {
   struct in_addr a ;
   char ptr[1] ;
   char mx[1] ;
   char txt[1] ;
   struct in6_addr aaaa ;
};
#line 30 "../../src/include/spf_dns_rr.h"
typedef union __anonunion_SPF_dns_rr_data_t_59 SPF_dns_rr_data_t;
#line 49 "../../src/include/spf_dns_rr.h"
struct SPF_dns_rr_struct {
   char *domain ;
   size_t domain_buf_len ;
   ns_type rr_type ;
   int num_rr ;
   SPF_dns_rr_data_t **rr ;
   size_t *rr_buf_len ;
   int rr_buf_num ;
   time_t ttl ;
   time_t utc_ttl ;
   SPF_dns_stat_t herrno ;
   void *hook ;
   SPF_dns_server_t *source ;
};
#line 49 "../../src/include/spf_dns_rr.h"
typedef struct SPF_dns_rr_struct SPF_dns_rr_t;
#line 106 "../../src/include/spf_dns.h"
struct SPF_dns_server_struct {
   void (*destroy)(SPF_dns_server_t *spf_dns_server ) ;
   SPF_dns_rr_t *(*lookup)(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                           ns_type ns_type , int should_cache ) ;
   SPF_errcode_t (*get_spf)(SPF_server_t *spf_server , SPF_request_t *spf_request ,
                            SPF_response_t *spf_response , SPF_record_t **spf_recordp ) ;
   SPF_errcode_t (*get_exp)(SPF_server_t *spf_server , char const   *domain , char **buf ,
                            size_t *buf_len ) ;
   int (*add_cache)(SPF_server_t *spf_server , SPF_dns_rr_t spfrr ) ;
   SPF_dns_server_t *layer_below ;
   char const   *name ;
   int debug ;
   void *hook ;
};
#line 55 "../../src/include/spf_server.h"
struct SPF_server_struct {
   SPF_dns_server_t *resolver ;
   SPF_record_t *local_policy ;
   SPF_macro_t *explanation ;
   char *rec_dom ;
   int max_dns_mech ;
   int max_dns_ptr ;
   int max_dns_mx ;
   int sanitize ;
   int debug ;
   int destroy_resolver ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 71 "../../src/include/spf_server.h"
enum SPF_server_dnstype_enum {
    SPF_DNS_RESOLV = 0,
    SPF_DNS_CACHE = 1,
    SPF_DNS_ZONE = 2
} ;
#line 71 "../../src/include/spf_server.h"
typedef enum SPF_server_dnstype_enum SPF_server_dnstype_t;
#line 312 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
struct SPF_client_options_struct {
   char *localpolicy ;
   char const   *explanation ;
   char const   *fallback ;
   char const   *rec_dom ;
   int use_trusted ;
   int max_lookup ;
   int sanitize ;
   int debug ;
};
#line 312 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
typedef struct SPF_client_options_struct SPF_client_options_t;
#line 325 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
struct SPF_client_request_struct {
   char *ip ;
   char *sender ;
   char *helo ;
   char *rcpt_to ;
};
#line 325 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
typedef struct SPF_client_request_struct SPF_client_request_t;
#line 73 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
struct __anonstruct_SPF_dns_zone_config_t_59 {
   SPF_dns_rr_t **zone ;
   int num_zone ;
   int zone_buf_len ;
   SPF_dns_rr_t *nxdomain ;
};
#line 73 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
typedef struct __anonstruct_SPF_dns_zone_config_t_59 SPF_dns_zone_config_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 146 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/arpa_nameser.h"
enum __ns_sect {
    ns_s_qd = 0,
    ns_s_zn = 0,
    ns_s_an = 1,
    ns_s_pr = 1,
    ns_s_ns = 2,
    ns_s_ud = 2,
    ns_s_ar = 3,
    ns_s_max = 4
} ;
#line 146 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/arpa_nameser.h"
typedef enum __ns_sect ns_sect;
#line 162 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/arpa_nameser.h"
struct __ns_msg {
   u_char const   *_msg ;
   u_char const   *_eom ;
   u_int16_t _id ;
   u_int16_t _flags ;
   u_int16_t _counts[4] ;
   u_char const   *_sections[4] ;
   ns_sect _sect ;
   int _rrnum ;
   u_char const   *_msg_ptr ;
};
#line 162 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/arpa_nameser.h"
typedef struct __ns_msg ns_msg;
#line 172 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/arpa_nameser.h"
struct _ns_flagdata {
   int mask ;
   int shift ;
};
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 186 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/arpa_nameser.h"
struct __ns_rr {
   char name[1025] ;
   u_int16_t type ;
   u_int16_t rr_class ;
   u_int32_t ttl ;
   u_int16_t rdlength ;
   u_char const   *rdata ;
};
#line 186 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/arpa_nameser.h"
typedef struct __ns_rr ns_rr;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 154 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
union __anonunion_tmp_58 {
   struct in_addr ipv4 ;
   unsigned char x[4] ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_4 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_4 pthread_mutex_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_5 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_5 pthread_mutexattr_t;
#line 82 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
struct _SPF_dns_cache_bucket_t {
   struct _SPF_dns_cache_bucket_t *next ;
   SPF_dns_rr_t *rr ;
};
#line 82 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
typedef struct _SPF_dns_cache_bucket_t SPF_dns_cache_bucket_t;
#line 88 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
struct __anonstruct_SPF_dns_cache_config_t_71 {
   SPF_dns_cache_bucket_t **cache ;
   int cache_size ;
   pthread_mutex_t cache_lock ;
   int hash_mask ;
   int max_hash_len ;
   time_t min_ttl ;
   time_t err_ttl ;
   time_t txt_ttl ;
   time_t rdns_ttl ;
   int conserve_cache ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
typedef struct __anonstruct_SPF_dns_cache_config_t_71 SPF_dns_cache_config_t;
#line 48 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
struct __anonstruct_SPF_dns_test_data_t_54 {
   char const   *domain ;
   int rr_type ;
   SPF_dns_stat_t herrno ;
   char const   *data ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
typedef struct __anonstruct_SPF_dns_test_data_t_54 SPF_dns_test_data_t;
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
enum SPF_cidr_enum {
    CIDR_NONE = 0,
    CIDR_OPTIONAL = 1,
    CIDR_ONLY = 2
} ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
typedef enum SPF_cidr_enum SPF_cidr_t;
#line 52
enum SPF_domspec_enum {
    DOMSPEC_NONE = 0,
    DOMSPEC_OPTIONAL = 1,
    DOMSPEC_REQUIRED = 2
} ;
#line 52 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
typedef enum SPF_domspec_enum SPF_domspec_t;
#line 69 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
struct SPF_mechtype_struct {
   unsigned char mech_type ;
   unsigned char is_dns_mech ;
   SPF_domspec_t has_domainspec ;
   SPF_cidr_t has_cidr ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
typedef struct SPF_mechtype_struct SPF_mechtype_t;
#line 831 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_60 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 989 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_61 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 1504 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_62 {
   double d ;
   long l ;
   char buf[sizeof(SPF_macro_t ) + 511UL] ;
} __attribute__((__aligned__(4))) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 163 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 321 "/usr/include/arpa/nameser.h"
enum __ns_class {
    ns_c_invalid = 0,
    ns_c_in = 1,
    ns_c_2 = 2,
    ns_c_chaos = 3,
    ns_c_hs = 4,
    ns_c_none = 254,
    ns_c_any = 255,
    ns_c_max = 65536
} ;
#line 321 "/usr/include/arpa/nameser.h"
typedef enum __ns_class ns_class;
#line 71 "/usr/include/resolv.h"
enum __anonenum_res_sendhookact_57 {
    res_goahead = 0,
    res_nextns = 1,
    res_modified = 2,
    res_done = 3,
    res_error = 4
} ;
#line 71 "/usr/include/resolv.h"
typedef enum __anonenum_res_sendhookact_57 res_sendhookact;
#line 104 "/usr/include/resolv.h"
struct __anonstruct_sort_list_58 {
   struct in_addr addr ;
   u_int32_t mask ;
};
#line 104 "/usr/include/resolv.h"
struct __anonstruct__ext_60 {
   u_int16_t nscount ;
   u_int16_t nsmap[3] ;
   int nssocks[3] ;
   u_int16_t nscount6 ;
   u_int16_t nsinit ;
   struct sockaddr_in6 *nsaddrs[3] ;
   unsigned int _initstamp[2] ;
};
#line 104 "/usr/include/resolv.h"
union __anonunion__u_59 {
   char pad[52] ;
   struct __anonstruct__ext_60 _ext ;
};
#line 104 "/usr/include/resolv.h"
struct __res_state {
   int retrans ;
   int retry ;
   u_long options ;
   int nscount ;
   struct sockaddr_in nsaddr_list[3] ;
   u_short id ;
   char *dnsrch[7] ;
   char defdname[256] ;
   u_long pfcode ;
   unsigned int ndots : 4 ;
   unsigned int nsort : 4 ;
   unsigned int ipv6_unavail : 1 ;
   unsigned int unused : 23 ;
   struct __anonstruct_sort_list_58 sort_list[10] ;
   res_sendhookact (*qhook)(struct sockaddr_in * const  *__ns , u_char const   **__query ,
                            int *__querylen , u_char *__ans , int __anssiz , int *__resplen ) ;
   res_sendhookact (*rhook)(struct sockaddr_in  const  *__ns , u_char const   *__query ,
                            int __querylen , u_char *__ans , int __anssiz , int *__resplen ) ;
   int res_h_errno ;
   int _vcsock ;
   u_int _flags ;
   union __anonunion__u_59 _u ;
};
#line 151 "/usr/include/resolv.h"
typedef struct __res_state *res_state;
#line 176 "/usr/include/resolv.h"
struct res_sym {
   int number ;
   char *name ;
   char *humanname ;
};
#line 831 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_60___0 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 989 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_61___0 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 1504 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_62___0 {
   double d ;
   long l ;
   char buf[sizeof(SPF_macro_t ) + 511UL] ;
} __attribute__((__aligned__(4))) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
union __anonunion_tmp_58___0 {
   struct in_addr ipv4 ;
   unsigned char x[4] ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_un;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 133 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
struct _config_t {
   int tcpport ;
   int udpport ;
   char *path ;
   uid_t pathuser ;
   gid_t pathgroup ;
   int pathmode ;
   uid_t setuser ;
   gid_t setgroup ;
   int debug ;
   int sec_mx ;
   char *fallback ;
   char *rec_dom ;
   int sanitize ;
   int max_lookup ;
   char *localpolicy ;
   int use_trusted ;
   char *explanation ;
};
#line 133 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
typedef struct _config_t config_t;
#line 164 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
union __anonunion_addr_80 {
   struct sockaddr_in in ;
   struct sockaddr_un un ;
};
#line 164 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
struct _request_t {
   int sock ;
   union __anonunion_addr_80 addr ;
   socklen_t addrlen ;
   char *data ;
   int datalen ;
   char *ip ;
   char *helo ;
   char *sender ;
   char *rcpt_to ;
   SPF_errcode_t spf_err ;
   SPF_request_t *spf_request ;
   SPF_response_t *spf_response ;
   char fmt[4096] ;
   int fmtlen ;
};
#line 164 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
typedef struct _request_t request_t;
#line 188 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
struct _state_t {
   int sock_udp ;
   int sock_tcp ;
   int sock_unix ;
};
#line 188 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
typedef struct _state_t state_t;
#line 831 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_60___1 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 989 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_61___1 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 1504 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_62___1 {
   double d ;
   long l ;
   char buf[sizeof(SPF_macro_t ) + 511UL] ;
} __attribute__((__aligned__(4))) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
union __anonunion_tmp_58___1 {
   struct in_addr ipv4 ;
   unsigned char x[4] ;
};
#line 154 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
union __anonunion_tmp_58___2 {
   struct in_addr ipv4 ;
   unsigned char x[4] ;
};
#line 831 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_60___2 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 989 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_61___2 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 1504 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_62___2 {
   double d ;
   long l ;
   char buf[sizeof(SPF_macro_t ) + 511UL] ;
} __attribute__((__aligned__(4))) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
union __anonunion_tmp_58___3 {
   struct in_addr ipv4 ;
   unsigned char x[4] ;
};
#line 831 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_60___3 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 989 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_61___3 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 1504 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_62___3 {
   double d ;
   long l ;
   char buf[sizeof(SPF_macro_t ) + 511UL] ;
} __attribute__((__aligned__(4))) ;
#line 831 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_60___4 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 989 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_61___4 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 1504 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_62___4 {
   double d ;
   long l ;
   char buf[sizeof(SPF_macro_t ) + 511UL] ;
} __attribute__((__aligned__(4))) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
union __anonunion_tmp_58___4 {
   struct in_addr ipv4 ;
   unsigned char x[4] ;
};
#line 154 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
union __anonunion_tmp_58___5 {
   struct in_addr ipv4 ;
   unsigned char x[4] ;
};
#line 831 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_60___5 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 989 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_61___5 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 1504 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_62___5 {
   double d ;
   long l ;
   char buf[sizeof(SPF_macro_t ) + 511UL] ;
} __attribute__((__aligned__(4))) ;
#line 831 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_60___6 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 989 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_61___6 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 1504 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_62___6 {
   double d ;
   long l ;
   char buf[sizeof(SPF_macro_t ) + 511UL] ;
} __attribute__((__aligned__(4))) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
union __anonunion_tmp_58___6 {
   struct in_addr ipv4 ;
   unsigned char x[4] ;
};
#line 154 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
union __anonunion_tmp_58___7 {
   struct in_addr ipv4 ;
   unsigned char x[4] ;
};
#line 831 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_60___7 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 989 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_61___7 {
   double d ;
   long l ;
   char buf[4096] ;
} __attribute__((__aligned__(4))) ;
#line 1504 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
union __anonunion_u_62___7 {
   double d ;
   long l ;
   char buf[sizeof(SPF_macro_t ) + 511UL] ;
} __attribute__((__aligned__(4))) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 268 "../../src/include/spf_record.h"
SPF_errcode_t SPF_record_stringify(SPF_record_t *spf_record , char **bufp , size_t *buflenp ) ;
#line 41 "../../src/include/spf_log.h"
 __attribute__((__noreturn__)) void ( /* format attribute */  SPF_errorx)(char const   *file ,
                                                                          int line ,
                                                                          char const   *format 
                                                                          , ...) ;
#line 56
void ( /* format attribute */  SPF_debugx)(char const   *file , int line , char const   *format 
                                           , ...) ;
#line 74 "../../src/include/spf_internal.h"
__inline static size_t _align_sz(size_t s ) 
{ 


  {
#line 75
  return (s + (3UL - ((s - 1UL) & 3UL)));
}
}
#line 76 "../../src/include/spf_internal.h"
__inline static char *_align_ptr(char *s ) 
{ 


  {
#line 77
  return (s + (3UL - (((size_t )s - 1UL) & 3UL)));
}
}
#line 87 "../../src/include/spf_internal.h"
__inline static size_t SPF_mech_data_len(SPF_mech_t *mech ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 88
  if ((int )mech->mech_type == 5) {
#line 88
    tmp___0 = sizeof(struct in_addr );
  } else {
#line 88
    if ((int )mech->mech_type == 6) {
#line 88
      tmp = sizeof(struct in6_addr );
    } else {
#line 88
      tmp = (unsigned long )mech->mech_len;
    }
#line 88
    tmp___0 = tmp;
  }
#line 88
  return (tmp___0);
}
}
#line 93 "../../src/include/spf_internal.h"
__inline static SPF_mech_t *SPF_mech_next(SPF_mech_t *mech ) 
{ 
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 94
  tmp = SPF_mech_data_len(mech);
#line 94
  tmp___0 = _align_ptr(((char *)mech + sizeof(SPF_mech_t )) + tmp);
  }
#line 94
  return ((SPF_mech_t *)tmp___0);
}
}
#line 97 "../../src/include/spf_internal.h"
__inline static SPF_data_t *SPF_mech_data(SPF_mech_t *mech ) 
{ 


  {
#line 98
  return ((SPF_data_t *)((char *)mech + sizeof(SPF_mech_t )));
}
}
#line 99 "../../src/include/spf_internal.h"
__inline static SPF_data_t *SPF_mech_end_data(SPF_mech_t *mech ) 
{ 
  SPF_data_t *tmp ;
  size_t tmp___0 ;

  {
  {
#line 100
  tmp = SPF_mech_data(mech);
#line 100
  tmp___0 = SPF_mech_data_len(mech);
  }
#line 100
  return ((SPF_data_t *)((char *)tmp + tmp___0));
}
}
#line 102 "../../src/include/spf_internal.h"
__inline static struct in_addr *SPF_mech_ip4_data(SPF_mech_t *mech ) 
{ 


  {
#line 103
  return ((struct in_addr *)((char *)mech + sizeof(SPF_mech_t )));
}
}
#line 104 "../../src/include/spf_internal.h"
__inline static struct in6_addr *SPF_mech_ip6_data(SPF_mech_t *mech ) 
{ 


  {
#line 105
  return ((struct in6_addr *)((char *)mech + sizeof(SPF_mech_t )));
}
}
#line 107 "../../src/include/spf_internal.h"
__inline static size_t SPF_data_len(SPF_data_t *data ) 
{ 
  int tmp ;

  {
#line 108
  if ((int )data->ds.parm_type == 12) {
#line 108
    tmp = (int )data->ds.len;
  } else {
#line 108
    tmp = 0;
  }
#line 108
  return (sizeof(SPF_data_t ) + (unsigned long )tmp);
}
}
#line 110 "../../src/include/spf_internal.h"
__inline static SPF_data_t *SPF_data_next(SPF_data_t *data ) 
{ 
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 111
  tmp = SPF_data_len(data);
#line 111
  tmp___0 = _align_ptr((char *)data + tmp);
  }
#line 111
  return ((SPF_data_t *)tmp___0);
}
}
#line 114 "../../src/include/spf_internal.h"
__inline static char *SPF_data_str(SPF_data_t *data ) 
{ 


  {
#line 115
  return ((char *)data + sizeof(SPF_data_t ));
}
}
#line 117 "../../src/include/spf_internal.h"
__inline static size_t SPF_mod_len(SPF_mod_t *mod ) 
{ 
  size_t tmp ;

  {
  {
#line 118
  tmp = _align_sz(sizeof(SPF_mod_t ) + (unsigned long )mod->name_len);
  }
#line 118
  return (tmp + (size_t )mod->data_len);
}
}
#line 119 "../../src/include/spf_internal.h"
__inline static SPF_mod_t *SPF_mod_next(SPF_mod_t *mod ) 
{ 
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 120
  tmp = SPF_mod_len(mod);
#line 120
  tmp___0 = _align_ptr((char *)mod + tmp);
  }
#line 120
  return ((SPF_mod_t *)tmp___0);
}
}
#line 123 "../../src/include/spf_internal.h"
__inline static char *SPF_mod_name(SPF_mod_t *mod ) 
{ 


  {
#line 124
  return ((char *)mod + sizeof(SPF_mod_t ));
}
}
#line 125 "../../src/include/spf_internal.h"
__inline static SPF_data_t *SPF_mod_data(SPF_mod_t *mod ) 
{ 
  char *tmp ;

  {
  {
#line 126
  tmp = _align_ptr(((char *)mod + sizeof(SPF_mod_t )) + (int )mod->name_len);
  }
#line 126
  return ((SPF_data_t *)tmp);
}
}
#line 129 "../../src/include/spf_internal.h"
__inline static SPF_data_t *SPF_mod_end_data(SPF_mod_t *mod ) 
{ 
  SPF_data_t *tmp ;

  {
  {
#line 130
  tmp = SPF_mod_data(mod);
  }
#line 130
  return ((SPF_data_t *)((char *)tmp + (int )mod->data_len));
}
}
#line 148
SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_recalloc)(char **bufp ,
                                                                      size_t *buflenp ,
                                                                      size_t buflen ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c"
static SPF_errcode_t SPF_record_stringify_data(SPF_data_t *data , SPF_data_t *data_end ,
                                               char **p_p , char *p_end , int is_mod ,
                                               int cidr_ok , int debug ) 
{ 
  char *p ;
  size_t len ;
  SPF_data_t *cidr_data ;
  char *s ;
  char *tmp ;
  char *s_end ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 48
  p = *p_p;
#line 54
  if (debug) {
    {
#line 55
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
               55, " string data: Building");
    }
  }
#line 57
  if (p_end - p <= 0L) {
#line 58
    return ((SPF_errcode_t )10);
  }
#line 60
  cidr_data = (SPF_data_t *)((void *)0);
#line 61
  if ((unsigned long )data < (unsigned long )data_end) {
#line 61
    if ((int )data->dc.parm_type == 11) {
#line 63
      if (debug) {
        {
#line 64
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   64, " string data: Found a CIDR at %p", data);
        }
      }
#line 65
      if (! cidr_ok) {
#line 66
        return ((SPF_errcode_t )10);
      }
      {
#line 68
      cidr_data = data;
#line 69
      data = SPF_data_next(data);
      }
    }
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )data < (unsigned long )data_end)) {
#line 73
      goto while_break;
    }
#line 75
    if (debug) {
      {
#line 76
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 77, " string data: Handling data type %d at %p", (int )data->ds.parm_type,
                 data);
      }
    }
#line 78
    if ((int )data->ds.parm_type == 12) {
      {
#line 80
      tmp = SPF_data_str(data);
#line 80
      s = tmp;
#line 81
      s_end = s + (int )data->ds.len;
      }
#line 82
      if (debug) {
        {
#line 83
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   84, " string data: String is [%d] \'%*.*s\'", (int )data->ds.len,
                   (int )data->ds.len, (int )data->ds.len, s);
        }
      }
#line 86
      if (p_end - (p + (int )data->ds.len) <= 0L) {
#line 87
        return ((SPF_errcode_t )10);
      }
      {
#line 89
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 89
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 89
          goto while_break___0;
        }
#line 90
        if ((int )*s == 32) {
#line 91
          tmp___0 = p;
#line 91
          p ++;
#line 91
          *tmp___0 = (char )'%';
#line 92
          tmp___1 = p;
#line 92
          p ++;
#line 92
          *tmp___1 = (char )'_';
#line 93
          s ++;
        } else
#line 95
        if ((int )*s == 37) {
#line 96
          tmp___2 = p;
#line 96
          p ++;
#line 96
          *tmp___2 = (char )'%';
#line 97
          s ++;
#line 98
          if ((int )*(s + 0) == 50) {
#line 98
            if ((int )*(s + 1) == 48) {
#line 99
              tmp___3 = p;
#line 99
              p ++;
#line 99
              *tmp___3 = (char )'-';
#line 100
              s += 2;
            } else {
#line 103
              tmp___4 = p;
#line 103
              p ++;
#line 103
              *tmp___4 = (char )'%';
            }
          } else {
#line 103
            tmp___4 = p;
#line 103
            p ++;
#line 103
            *tmp___4 = (char )'%';
          }
        } else {
#line 108
          tmp___5 = p;
#line 108
          p ++;
#line 108
          tmp___6 = s;
#line 108
          s ++;
#line 108
          *tmp___5 = *tmp___6;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 112
      if (p_end - p <= 0L) {
#line 113
        return ((SPF_errcode_t )10);
      }
    } else
#line 115
    if ((int )data->dc.parm_type == 11) {
#line 117
      return ((SPF_errcode_t )8);
    } else {
      {
#line 120
      tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%%{");
#line 120
      len = (size_t )tmp___7;
#line 121
      p += len;
      }
#line 122
      if (p_end - p <= 0L) {
#line 122
        return ((SPF_errcode_t )10);
      }
#line 125
      if (p_end - p <= 1L) {
#line 125
        return ((SPF_errcode_t )10);
      }
      {
#line 128
      if ((int )data->dv.parm_type == 0) {
#line 128
        goto case_0;
      }
#line 132
      if ((int )data->dv.parm_type == 1) {
#line 132
        goto case_1;
      }
#line 136
      if ((int )data->dv.parm_type == 2) {
#line 136
        goto case_2;
      }
#line 140
      if ((int )data->dv.parm_type == 3) {
#line 140
        goto case_3;
      }
#line 144
      if ((int )data->dv.parm_type == 4) {
#line 144
        goto case_4;
      }
#line 148
      if ((int )data->dv.parm_type == 5) {
#line 148
        goto case_5;
      }
#line 152
      if ((int )data->dv.parm_type == 6) {
#line 152
        goto case_6;
      }
#line 158
      if ((int )data->dv.parm_type == 7) {
#line 158
        goto case_7;
      }
#line 162
      if ((int )data->dv.parm_type == 8) {
#line 162
        goto case_8;
      }
#line 166
      if ((int )data->dv.parm_type == 9) {
#line 166
        goto case_9;
      }
#line 170
      if ((int )data->dv.parm_type == 10) {
#line 170
        goto case_10;
      }
#line 174
      goto switch_default;
      case_0: /* CIL Label */ 
#line 129
      *p = (char )'l';
#line 130
      goto switch_break;
      case_1: /* CIL Label */ 
#line 133
      *p = (char )'s';
#line 134
      goto switch_break;
      case_2: /* CIL Label */ 
#line 137
      *p = (char )'o';
#line 138
      goto switch_break;
      case_3: /* CIL Label */ 
#line 141
      *p = (char )'d';
#line 142
      goto switch_break;
      case_4: /* CIL Label */ 
#line 145
      *p = (char )'i';
#line 146
      goto switch_break;
      case_5: /* CIL Label */ 
#line 149
      *p = (char )'c';
#line 150
      goto switch_break;
      case_6: /* CIL Label */ 
#line 153
      if (! is_mod) {
#line 154
        return ((SPF_errcode_t )12);
      }
#line 155
      *p = (char )'t';
#line 156
      goto switch_break;
      case_7: /* CIL Label */ 
#line 159
      *p = (char )'p';
#line 160
      goto switch_break;
      case_8: /* CIL Label */ 
#line 163
      *p = (char )'v';
#line 164
      goto switch_break;
      case_9: /* CIL Label */ 
#line 167
      *p = (char )'h';
#line 168
      goto switch_break;
      case_10: /* CIL Label */ 
#line 171
      *p = (char )'r';
#line 172
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 175
      return ((SPF_errcode_t )12);
#line 176
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 178
      if (data->dv.url_encode) {
        {
#line 179
        tmp___8 = toupper((int )*p);
#line 179
        *p = (char )tmp___8;
        }
      }
#line 180
      p ++;
#line 181
      if (p_end - p <= 0L) {
#line 181
        return ((SPF_errcode_t )10);
      }
#line 184
      if (data->dv.num_rhs) {
        {
#line 186
        tmp___9 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%d",
                           (int )data->dv.num_rhs);
#line 186
        len = (size_t )tmp___9;
#line 187
        p += len;
        }
#line 188
        if (p_end - p <= 0L) {
#line 188
          return ((SPF_errcode_t )10);
        }
      }
#line 192
      if (p_end - p <= 8L) {
#line 192
        return ((SPF_errcode_t )10);
      }
#line 193
      if (data->dv.rev) {
#line 194
        tmp___10 = p;
#line 194
        p ++;
#line 194
        *tmp___10 = (char )'r';
      }
#line 196
      if (data->dv.delim_dot) {
#line 196
        if (data->dv.delim_dash) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_plus) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_equal) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_bar) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_under) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        }
      }
#line 205
      if (data->dv.delim_dash) {
#line 206
        tmp___12 = p;
#line 206
        p ++;
#line 206
        *tmp___12 = (char )'-';
      }
#line 207
      if (data->dv.delim_plus) {
#line 208
        tmp___13 = p;
#line 208
        p ++;
#line 208
        *tmp___13 = (char )'+';
      }
#line 209
      if (data->dv.delim_equal) {
#line 210
        tmp___14 = p;
#line 210
        p ++;
#line 210
        *tmp___14 = (char )'=';
      }
#line 211
      if (data->dv.delim_bar) {
#line 212
        tmp___15 = p;
#line 212
        p ++;
#line 212
        *tmp___15 = (char )'|';
      }
#line 213
      if (data->dv.delim_under) {
#line 214
        tmp___16 = p;
#line 214
        p ++;
#line 214
        *tmp___16 = (char )'_';
      }
#line 216
      tmp___17 = p;
#line 216
      p ++;
#line 216
      *tmp___17 = (char )'}';
#line 217
      if (p_end - p <= 0L) {
#line 217
        return ((SPF_errcode_t )10);
      }
    }
    {
#line 73
    data = SPF_data_next(data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (cidr_data) {
#line 224
    if (cidr_data->dc.ipv4) {
      {
#line 226
      tmp___18 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"/%d",
                          (int )cidr_data->dc.ipv4);
#line 226
      len = (size_t )tmp___18;
#line 227
      p += len;
      }
#line 228
      if (p_end - p <= 0L) {
#line 228
        return ((SPF_errcode_t )10);
      }
    }
#line 231
    if (cidr_data->dc.ipv6) {
      {
#line 233
      tmp___19 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"//%d",
                          (int )cidr_data->dc.ipv6);
#line 233
      len = (size_t )tmp___19;
#line 234
      p += len;
      }
#line 235
      if (p_end - p <= 0L) {
#line 235
        return ((SPF_errcode_t )10);
      }
    }
  }
#line 239
  *p_p = p;
#line 240
  return ((SPF_errcode_t )0);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c"
SPF_errcode_t SPF_record_stringify(SPF_record_t *spf_record , char **bufp , size_t *buflenp ) 
{ 
  int i ;
  SPF_mech_t *mech ;
  SPF_mod_t *mod ;
  SPF_data_t *data ;
  SPF_data_t *data_end ;
  size_t len ;
  char const   *p_err ;
  char *p ;
  char *p_end ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  int cidr_ok ;
  SPF_errcode_t err ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct in_addr *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct in6_addr *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  SPF_data_t *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;

  {
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 265
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 265, "%s", "spf_record is NULL");
      }
    }
#line 265
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  len = ((sizeof("v=spf1") + spf_record->mech_len * 4UL) + spf_record->mod_len * 4UL) + sizeof("\000");
#line 286
  err = SPF_recalloc(bufp, buflenp, len);
  }
#line 287
  if ((unsigned int )err != 0U) {
#line 288
    return (err);
  }
#line 290
  p = *bufp;
#line 291
  p_end = *bufp + *buflenp;
#line 293
  if ((spf_record->spf_server)->debug) {
    {
#line 294
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
               294, "stringify: Buffer length is %lu\n", *buflenp);
    }
  }
  {
#line 300
  tmp = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"v=spf%d",
                 (int )spf_record->version);
#line 300
  len = (size_t )tmp;
#line 301
  p += len;
  }
#line 302
  if (p_end - p <= 0L) {
#line 303
    return ((SPF_errcode_t )10);
  }
#line 310
  mech = spf_record->mech_first;
#line 311
  i = 0;
  {
#line 311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 311
    if (! (i < (int )spf_record->num_mech)) {
#line 311
      goto while_break___0;
    }
#line 312
    if ((spf_record->spf_server)->debug) {
      {
#line 313
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 314, "stringify: Handling mechanism %d/%d at %p", i, (int )spf_record->num_mech,
                 mech);
      }
    }
#line 315
    if (p_end - p <= 1L) {
#line 315
      return ((SPF_errcode_t )10);
    }
#line 316
    tmp___0 = p;
#line 316
    p ++;
#line 316
    *tmp___0 = (char )' ';
#line 319
    if (p_end - p <= 1L) {
#line 319
      return ((SPF_errcode_t )10);
    }
    {
#line 322
    if ((int )mech->prefix_type == 2) {
#line 322
      goto case_2;
    }
#line 326
    if ((int )mech->prefix_type == 3) {
#line 326
      goto case_3;
    }
#line 330
    if ((int )mech->prefix_type == 4) {
#line 330
      goto case_4;
    }
#line 334
    if ((int )mech->prefix_type == 1) {
#line 334
      goto case_1;
    }
#line 338
    if ((int )mech->prefix_type == 7) {
#line 338
      goto case_7;
    }
#line 342
    goto switch_default;
    case_2: /* CIL Label */ 
#line 324
    goto switch_break;
    case_3: /* CIL Label */ 
#line 327
    tmp___1 = p;
#line 327
    p ++;
#line 327
    *tmp___1 = (char )'-';
#line 328
    goto switch_break;
    case_4: /* CIL Label */ 
#line 331
    tmp___2 = p;
#line 331
    p ++;
#line 331
    *tmp___2 = (char )'~';
#line 332
    goto switch_break;
    case_1: /* CIL Label */ 
#line 335
    tmp___3 = p;
#line 335
    p ++;
#line 335
    *tmp___3 = (char )'?';
#line 336
    goto switch_break;
    case_7: /* CIL Label */ 
#line 339
    return ((SPF_errcode_t )22);
#line 340
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 343
    return ((SPF_errcode_t )21);
#line 344
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 347
    if ((spf_record->spf_server)->debug) {
      {
#line 348
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 348, "Mechanism type is %d", (int )mech->mech_type);
      }
    }
    {
#line 352
    if ((int )mech->mech_type == 1) {
#line 352
      goto case_1___0;
    }
#line 356
    if ((int )mech->mech_type == 2) {
#line 356
      goto case_2___0;
    }
#line 360
    if ((int )mech->mech_type == 3) {
#line 360
      goto case_3___0;
    }
#line 364
    if ((int )mech->mech_type == 4) {
#line 364
      goto case_4___0;
    }
#line 368
    if ((int )mech->mech_type == 5) {
#line 368
      goto case_5;
    }
#line 380
    if ((int )mech->mech_type == 6) {
#line 380
      goto case_6;
    }
#line 392
    if ((int )mech->mech_type == 7) {
#line 392
      goto case_7___0;
    }
#line 396
    if ((int )mech->mech_type == 8) {
#line 396
      goto case_8;
    }
#line 400
    if ((int )mech->mech_type == 9) {
#line 400
      goto case_9;
    }
#line 404
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 353
    tmp___4 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"a");
#line 353
    len = (size_t )tmp___4;
    }
#line 354
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 357
    tmp___5 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"mx");
#line 357
    len = (size_t )tmp___5;
    }
#line 358
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 361
    tmp___6 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"ptr");
#line 361
    len = (size_t )tmp___6;
    }
#line 362
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 365
    tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"include");
#line 365
    len = (size_t )tmp___7;
    }
#line 366
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 369
    tmp___8 = SPF_mech_ip4_data(mech);
#line 369
    p_err = inet_ntop(2, (void const   */* __restrict  */)tmp___8, (char */* __restrict  */)(ip4_buf),
                      (socklen_t )sizeof(ip4_buf));
    }
#line 371
    if ((unsigned long )p_err == (unsigned long )((void *)0)) {
#line 372
      return ((SPF_errcode_t )10);
    }
#line 373
    if (mech->mech_len) {
      {
#line 374
      tmp___9 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"ip4:%s/%d",
                         ip4_buf, (int )mech->mech_len);
#line 374
      len = (size_t )tmp___9;
      }
    } else {
      {
#line 377
      tmp___10 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"ip4:%s",
                          ip4_buf);
#line 377
      len = (size_t )tmp___10;
      }
    }
#line 378
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 381
    tmp___11 = SPF_mech_ip6_data(mech);
#line 381
    p_err = inet_ntop(10, (void const   */* __restrict  */)tmp___11, (char */* __restrict  */)(ip6_buf),
                      (socklen_t )sizeof(ip6_buf));
    }
#line 383
    if ((unsigned long )p_err == (unsigned long )((void *)0)) {
#line 384
      return ((SPF_errcode_t )10);
    }
#line 385
    if (mech->mech_len) {
      {
#line 386
      tmp___12 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"ip6:%s/%d",
                          ip6_buf, (int )mech->mech_len);
#line 386
      len = (size_t )tmp___12;
      }
    } else {
      {
#line 389
      tmp___13 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"ip6:%s",
                          ip6_buf);
#line 389
      len = (size_t )tmp___13;
      }
    }
#line 390
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
    {
#line 393
    tmp___14 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"exists");
#line 393
    len = (size_t )tmp___14;
    }
#line 394
    goto switch_break___0;
    case_8: /* CIL Label */ 
    {
#line 397
    tmp___15 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"all");
#line 397
    len = (size_t )tmp___15;
    }
#line 398
    goto switch_break___0;
    case_9: /* CIL Label */ 
    {
#line 401
    tmp___16 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"redirect");
#line 401
    len = (size_t )tmp___16;
    }
#line 402
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 405
    return ((SPF_errcode_t )6);
#line 406
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 408
    p += len;
#line 409
    if (p_end - p <= 0L) {
#line 409
      return ((SPF_errcode_t )10);
    }
#line 411
    if ((spf_record->spf_server)->debug) {
      {
#line 412
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 412, "stringify: Buffer so far is %s", p);
      }
    }
#line 414
    if ((int )mech->mech_type != 5) {
#line 414
      if ((int )mech->mech_type != 6) {
        {
#line 416
        data = SPF_mech_data(mech);
#line 417
        data_end = SPF_mech_end_data(mech);
#line 419
        tmp___18 = SPF_mech_data_len(mech);
        }
#line 419
        if (tmp___18 > 0UL) {
#line 419
          if ((int )data->dc.parm_type != 11) {
#line 425
            tmp___17 = p;
#line 425
            p ++;
#line 425
            *tmp___17 = (char )':';
          } else {
            {
#line 419
            tmp___19 = SPF_data_next(data);
            }
#line 419
            if ((unsigned long )tmp___19 < (unsigned long )data_end) {
#line 425
              tmp___17 = p;
#line 425
              p ++;
#line 425
              *tmp___17 = (char )':';
            }
          }
        }
#line 428
        if ((int )mech->mech_type == 1) {
#line 428
          tmp___20 = 1;
        } else
#line 428
        if ((int )mech->mech_type == 2) {
#line 428
          tmp___20 = 1;
        } else {
#line 428
          tmp___20 = 0;
        }
        {
#line 428
        cidr_ok = tmp___20;
#line 429
        err = SPF_record_stringify_data(data, data_end, & p, p_end, 0, cidr_ok, (spf_record->spf_server)->debug);
        }
#line 434
        if ((unsigned int )err != 0U) {
#line 435
          return (err);
        }
      }
    }
    {
#line 438
    mech = SPF_mech_next(mech);
#line 311
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 446
  mod = spf_record->mod_first;
#line 447
  i = 0;
  {
#line 447
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 447
    if (! (i < (int )spf_record->num_mod)) {
#line 447
      goto while_break___1;
    }
#line 449
    if ((spf_record->spf_server)->debug) {
      {
#line 450
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 451, "stringify: Handling modifier %d/%d at %p", i, (int )spf_record->num_mod,
                 mod);
      }
    }
#line 452
    if (p_end - p <= 1L) {
#line 452
      return ((SPF_errcode_t )10);
    }
    {
#line 453
    tmp___21 = p;
#line 453
    p ++;
#line 453
    *tmp___21 = (char )' ';
#line 455
    tmp___22 = SPF_mod_name(mod);
#line 455
    tmp___23 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%.*s=",
                        (int )mod->name_len, tmp___22);
#line 455
    len = (size_t )tmp___23;
#line 457
    p += len;
    }
#line 458
    if (p_end - p <= 0L) {
#line 458
      return ((SPF_errcode_t )10);
    }
    {
#line 460
    data = SPF_mod_data(mod);
#line 461
    data_end = SPF_mod_end_data(mod);
#line 463
    err = SPF_record_stringify_data(data, data_end, & p, p_end, 1, 1, (spf_record->spf_server)->debug);
    }
#line 468
    if ((unsigned int )err != 0U) {
#line 469
      return (err);
    }
    {
#line 472
    mod = SPF_mod_next(mod);
#line 447
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 477
  tmp___24 = p;
#line 477
  p ++;
#line 477
  *tmp___24 = (char )'\000';
#line 479
  return ((SPF_errcode_t )0);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 67 "../../src/include/spf_request.h"
char const   *SPF_request_get_rec_dom(SPF_request_t *sr ) ;
#line 69
char const   *SPF_request_get_client_dom(SPF_request_t *sr ) ;
#line 261 "../../src/include/spf_record.h"
SPF_errcode_t SPF_record_expand_data(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                                     SPF_response_t *spf_response , SPF_data_t *data ,
                                     size_t data_len , char **bufp , size_t *buflenp ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv4[8]  = 
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
  {      (char const   )'i',      (char const   )'n',      (char const   )'-',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv6[4]  = {      (char const   )'i',      (char const   )'p',      (char const   )'6',      (char const   )'\000'};
#line 64 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
__inline static int SPF_delim_valid(SPF_data_t *d , char c ) 
{ 
  int tmp ;

  {
#line 67
  if (d->dv.delim_dot) {
#line 67
    if ((int )c == 46) {
#line 67
      tmp = 1;
    } else {
#line 67
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 67
  if (d->dv.delim_dash) {
#line 67
    if ((int )c == 45) {
#line 67
      tmp = 1;
    } else {
#line 67
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 67
  if (d->dv.delim_plus) {
#line 67
    if ((int )c == 43) {
#line 67
      tmp = 1;
    } else {
#line 67
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 67
  if (d->dv.delim_equal) {
#line 67
    if ((int )c == 61) {
#line 67
      tmp = 1;
    } else {
#line 67
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 67
  if (d->dv.delim_bar) {
#line 67
    if ((int )c == 124) {
#line 67
      tmp = 1;
    } else {
#line 67
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 67
  if (d->dv.delim_under) {
#line 67
    if ((int )c == 95) {
#line 67
      tmp = 1;
    } else {
#line 67
      tmp = 0;
    }
  } else {
#line 67
    tmp = 0;
  }
#line 67
  return (tmp);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
SPF_errcode_t SPF_record_expand_data(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                                     SPF_response_t *spf_response , SPF_data_t *data ,
                                     size_t data_len , char **bufp , size_t *buflenp ) 
{ 
  SPF_data_t *d ;
  SPF_data_t *data_end ;
  size_t len ;
  char const   *p_err ;
  char *p ;
  char *p_end ;
  char const   *p_read ;
  char const   *p_read_end ;
  char *p_write ;
  char *p2 ;
  char *p2_end ;
  char const   *var ;
  char *munged_var ;
  char *url_var ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char ip6_rbuf[sizeof(struct in6_addr ) * 4UL + 1UL] ;
  char time_buf[sizeof("4294967296")] ;
  int num_found ;
  int i ;
  size_t buflen ;
  int compute_length ;
  SPF_errcode_t err ;
  char *tmp ;
  int tmp___0 ;
  time_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  unsigned short const   **tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;

  {
#line 99
  munged_var = (char *)((void *)0);
#line 100
  url_var = (char *)((void *)0);
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 120
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c",
                 120, "%s", "spf_server is NULL");
      }
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      {
#line 121
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c",
                 121, "%s", "data is NULL");
      }
    }
#line 121
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 122
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 122
    if ((unsigned long )bufp == (unsigned long )((void *)0)) {
      {
#line 122
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c",
                 122, "%s", "bufp is NULL");
      }
    }
#line 122
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 123
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 123
    if ((unsigned long )buflenp == (unsigned long )((void *)0)) {
      {
#line 123
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c",
                 123, "%s", "buflenp is NULL");
      }
    }
#line 123
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 125
  buflen = (size_t )1;
#line 126
  compute_length = 1;
#line 127
  p = (char *)((void *)0);
#line 128
  p_end = (char *)((void *)0);
#line 131
  data_end = (SPF_data_t *)((char *)data + data_len);
  top: 
#line 140
  d = data;
  {
#line 140
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )d < (unsigned long )data_end)) {
#line 140
      goto while_break___3;
    }
#line 144
    if ((int )d->dc.parm_type == 11) {
#line 145
      goto __Cont;
    }
#line 147
    if ((int )d->ds.parm_type == 12) {
#line 148
      if (compute_length) {
#line 149
        buflen += (size_t )d->ds.len;
#line 150
        goto __Cont;
      }
#line 153
      if (p_end - (p + (int )d->ds.len) <= 0L) {
        {
#line 154
        SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c",
                   155, "%s", "Failed to allocate enough memory to expand string.");
        }
      }
      {
#line 156
      tmp = SPF_data_str(d);
#line 156
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)tmp, (size_t )d->ds.len);
#line 157
      p += (int )d->ds.len;
      }
#line 158
      goto __Cont;
    }
#line 163
    var = (char const   *)((void *)0);
    {
#line 165
    if ((int )d->dv.parm_type == 0) {
#line 165
      goto case_0;
    }
#line 169
    if ((int )d->dv.parm_type == 1) {
#line 169
      goto case_1;
    }
#line 173
    if ((int )d->dv.parm_type == 2) {
#line 173
      goto case_2;
    }
#line 177
    if ((int )d->dv.parm_type == 3) {
#line 177
      goto case_3;
    }
#line 181
    if ((int )d->dv.parm_type == 4) {
#line 181
      goto case_4;
    }
#line 211
    if ((int )d->dv.parm_type == 5) {
#line 211
      goto case_5;
    }
#line 231
    if ((int )d->dv.parm_type == 6) {
#line 231
      goto case_6;
    }
#line 243
    if ((int )d->dv.parm_type == 7) {
#line 243
      goto case_7;
    }
#line 249
    if ((int )d->dv.parm_type == 8) {
#line 249
      goto case_8;
    }
#line 256
    if ((int )d->dv.parm_type == 9) {
#line 256
      goto case_9;
    }
#line 260
    if ((int )d->dv.parm_type == 10) {
#line 260
      goto case_10;
    }
#line 264
    goto switch_default;
    case_0: /* CIL Label */ 
#line 166
    var = (char const   *)spf_request->env_from_lp;
#line 167
    goto switch_break;
    case_1: /* CIL Label */ 
#line 170
    var = (char const   *)spf_request->env_from;
#line 171
    goto switch_break;
    case_2: /* CIL Label */ 
#line 174
    var = (char const   *)spf_request->env_from_dp;
#line 175
    goto switch_break;
    case_3: /* CIL Label */ 
#line 178
    var = spf_request->cur_dom;
#line 179
    goto switch_break;
    case_4: /* CIL Label */ 
#line 182
    if (compute_length) {
#line 183
      len = sizeof(ip6_rbuf);
#line 184
      if (d->dv.url_encode) {
#line 185
        len *= 3UL;
      }
#line 186
      buflen += len;
#line 187
      goto __Cont;
    }
#line 189
    if (spf_request->client_ver == 2) {
      {
#line 190
      p_err = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4),
                        (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
#line 192
      var = (char const   *)(ip4_buf);
      }
    } else
#line 194
    if (spf_request->client_ver == 10) {
#line 195
      p2 = ip6_rbuf;
#line 196
      p2_end = p2 + sizeof(ip6_rbuf);
#line 198
      i = 0;
      {
#line 198
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 198
        if (! ((long )i < (long )(sizeof(spf_request->ipv6.__in6_u.__u6_addr8) / sizeof(spf_request->ipv6.__in6_u.__u6_addr8[0])))) {
#line 198
          goto while_break___4;
        }
        {
#line 199
        tmp___0 = snprintf((char */* __restrict  */)p2, (size_t )(p2_end - p2), (char const   */* __restrict  */)"%.1x.%.1x.",
                           (int )spf_request->ipv6.__in6_u.__u6_addr8[i] >> 4, (int )spf_request->ipv6.__in6_u.__u6_addr8[i] & 15);
#line 199
        p2 += tmp___0;
#line 198
        i ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 205
      ip6_rbuf[sizeof(struct in6_addr ) * 4UL - 1UL] = (char )'\000';
#line 207
      var = (char const   *)(ip6_rbuf);
    }
#line 209
    goto switch_break;
    case_5: /* CIL Label */ 
#line 212
    if (compute_length) {
#line 213
      len = sizeof(ip6_rbuf);
#line 214
      if (d->dv.url_encode) {
#line 215
        len *= 3UL;
      }
#line 216
      buflen += len;
#line 217
      goto __Cont;
    }
#line 219
    if (spf_request->client_ver == 2) {
      {
#line 220
      p_err = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4),
                        (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
#line 222
      var = (char const   *)(ip4_buf);
      }
    } else
#line 224
    if (spf_request->client_ver == 10) {
      {
#line 225
      p_err = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6),
                        (char */* __restrict  */)(ip6_buf), (socklen_t )sizeof(ip6_buf));
#line 227
      var = (char const   *)(ip6_buf);
      }
    }
#line 229
    goto switch_break;
    case_6: /* CIL Label */ 
#line 232
    if (compute_length) {
#line 233
      len = sizeof(time_buf);
#line 235
      buflen += len;
#line 236
      goto __Cont;
    }
    {
#line 238
    tmp___1 = time((time_t *)((void *)0));
#line 238
    snprintf((char */* __restrict  */)(time_buf), sizeof(time_buf), (char const   */* __restrict  */)"%ld",
             tmp___1);
#line 240
    var = (char const   *)(time_buf);
    }
#line 241
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 244
    var = SPF_request_get_client_dom(spf_request);
    }
#line 245
    if (! var) {
#line 246
      return ((SPF_errcode_t )1);
    }
#line 247
    goto switch_break;
    case_8: /* CIL Label */ 
#line 250
    if (spf_request->client_ver == 2) {
#line 251
      var = client_ver_ipv4;
    } else
#line 252
    if (spf_request->client_ver == 10) {
#line 253
      var = client_ver_ipv6;
    }
#line 254
    goto switch_break;
    case_9: /* CIL Label */ 
#line 257
    var = (char const   *)spf_request->helo_dom;
#line 258
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 261
    var = SPF_request_get_rec_dom(spf_request);
    }
#line 262
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 268
    return ((SPF_errcode_t )12);
#line 269
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 272
    if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 273
      return ((SPF_errcode_t )23);
    }
    {
#line 275
    len = strlen(var);
    }
#line 276
    if (compute_length) {
#line 277
      if (d->dv.url_encode) {
#line 278
        len *= 3UL;
      }
#line 279
      buflen += len;
#line 280
      goto __Cont;
    }
    {
#line 284
    tmp___2 = malloc(len + 1UL);
#line 284
    munged_var = (char *)tmp___2;
    }
#line 285
    if ((unsigned long )munged_var == (unsigned long )((void *)0)) {
#line 286
      return ((SPF_errcode_t )1);
    }
    {
#line 287
    memset((void *)munged_var, 0, len + 1UL);
#line 289
    p_read_end = var + len;
#line 290
    p_write = munged_var;
    }
#line 296
    if (d->dv.rev) {
#line 297
      p_read = p_read_end - 1;
      {
#line 299
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 299
        if (! ((unsigned long )p_read >= (unsigned long )var)) {
#line 299
          goto while_break___5;
        }
        {
#line 300
        tmp___4 = SPF_delim_valid(d, (char )*p_read);
        }
#line 300
        if (tmp___4) {
          {
#line 303
          len = (size_t )((p_read_end - p_read) - 1L);
#line 304
          memcpy((void */* __restrict  */)p_write, (void const   */* __restrict  */)(p_read + 1),
                 len);
#line 305
          p_write += len;
#line 306
          tmp___3 = p_write;
#line 306
          p_write ++;
#line 306
          *tmp___3 = (char )'.';
#line 308
          p_read_end = p_read;
          }
        }
#line 310
        p_read --;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 316
      if ((unsigned long )p_read_end >= (unsigned long )p_read) {
        {
#line 317
        len = (size_t )((p_read_end - p_read) - 1L);
#line 318
        memcpy((void */* __restrict  */)p_write, (void const   */* __restrict  */)(p_read + 1),
               len);
#line 319
        p_write += len;
#line 320
        tmp___5 = p_write;
#line 320
        p_write ++;
#line 320
        *tmp___5 = (char )'.';
        }
      }
#line 324
      p_write --;
#line 325
      *p_write = (char )'\000';
    } else {
#line 328
      p_read = var;
      {
#line 330
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 330
        if (! ((unsigned long )p_read < (unsigned long )p_read_end)) {
#line 330
          goto while_break___6;
        }
        {
#line 331
        tmp___8 = SPF_delim_valid(d, (char )*p_read);
        }
#line 331
        if (tmp___8) {
#line 332
          tmp___6 = p_write;
#line 332
          p_write ++;
#line 332
          *tmp___6 = (char )'.';
        } else {
#line 334
          tmp___7 = p_write;
#line 334
          p_write ++;
#line 334
          *tmp___7 = (char )*p_read;
        }
#line 335
        p_read ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 338
      *p_write = (char )'\000';
    }
#line 346
    if ((int )d->dv.num_rhs > 0) {
#line 347
      p_read_end = (char const   *)(munged_var + len);
#line 348
      p_write = (munged_var + len) - 1;
#line 349
      num_found = 0;
      {
#line 350
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 350
        if (! ((unsigned long )p_write > (unsigned long )munged_var)) {
#line 350
          goto while_break___7;
        }
#line 351
        if ((int )*p_write == 46) {
#line 352
          num_found ++;
        }
#line 353
        if (num_found == (int )d->dv.num_rhs) {
#line 354
          goto while_break___7;
        }
#line 355
        p_write --;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 357
      p_write ++;
#line 359
      len = (size_t )(p_read_end - (char const   *)p_write);
#line 360
      memmove((void *)munged_var, (void const   *)p_write, len + 1UL);
      }
    }
#line 363
    var = (char const   *)munged_var;
#line 368
    if (d->dv.url_encode) {
      {
#line 369
      tmp___9 = malloc(len * 3UL + 1UL);
#line 369
      url_var = (char *)tmp___9;
      }
#line 370
      if ((unsigned long )url_var == (unsigned long )((void *)0)) {
#line 371
        if (munged_var) {
          {
#line 372
          free((void *)munged_var);
          }
        }
#line 373
        return ((SPF_errcode_t )1);
      }
#line 376
      p_read = var;
#line 377
      p_write = url_var;
      {
#line 380
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 380
        if (! ((int const   )*p_read != 0)) {
#line 380
          goto while_break___8;
        }
        {
#line 382
        tmp___14 = __ctype_b_loc();
        }
#line 382
        if ((int const   )*(*tmp___14 + (int )((unsigned char )*p_read)) & 8) {
#line 383
          tmp___10 = p_write;
#line 383
          p_write ++;
#line 383
          tmp___11 = p_read;
#line 383
          p_read ++;
#line 383
          *tmp___10 = (char )*tmp___11;
        } else {
          {
#line 396
          if ((int const   )*p_read == 41) {
#line 396
            goto case_41;
          }
#line 396
          if ((int const   )*p_read == 40) {
#line 396
            goto case_41;
          }
#line 396
          if ((int const   )*p_read == 39) {
#line 396
            goto case_41;
          }
#line 396
          if ((int const   )*p_read == 42) {
#line 396
            goto case_41;
          }
#line 396
          if ((int const   )*p_read == 126) {
#line 396
            goto case_41;
          }
#line 396
          if ((int const   )*p_read == 33) {
#line 396
            goto case_41;
          }
#line 396
          if ((int const   )*p_read == 46) {
#line 396
            goto case_41;
          }
#line 396
          if ((int const   )*p_read == 95) {
#line 396
            goto case_41;
          }
#line 396
          if ((int const   )*p_read == 45) {
#line 396
            goto case_41;
          }
#line 400
          goto switch_default___0;
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_42: /* CIL Label */ 
          case_126: /* CIL Label */ 
          case_33: /* CIL Label */ 
          case_46: /* CIL Label */ 
          case_95: /* CIL Label */ 
          case_45: /* CIL Label */ 
#line 397
          tmp___12 = p_write;
#line 397
          p_write ++;
#line 397
          tmp___13 = p_read;
#line 397
          p_read ++;
#line 397
          *tmp___12 = (char )*tmp___13;
#line 398
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
          {
#line 404
          sprintf((char */* __restrict  */)p_write, (char const   */* __restrict  */)"%%%02x",
                  (int const   )*p_read);
#line 405
          p_write += 3;
#line 406
          p_read ++;
          }
#line 407
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 411
      *p_write = (char )'\000';
#line 413
      var = (char const   *)url_var;
#line 414
      len = (size_t )(p_write - url_var);
    }
    {
#line 419
    tmp___15 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s",
                        var);
#line 419
    len = (size_t )tmp___15;
#line 420
    p += len;
    }
#line 421
    if (p_end - p <= 0L) {
#line 422
      if (munged_var) {
        {
#line 423
        free((void *)munged_var);
        }
      }
#line 424
      if (url_var) {
        {
#line 425
        free((void *)url_var);
        }
      }
#line 426
      return ((SPF_errcode_t )10);
    }
#line 429
    if (munged_var) {
      {
#line 430
      free((void *)munged_var);
      }
    }
#line 431
    munged_var = (char *)((void *)0);
#line 432
    if (url_var) {
      {
#line 433
      free((void *)url_var);
      }
    }
#line 434
    url_var = (char *)((void *)0);
    __Cont: /* CIL Label */ 
    {
#line 140
    d = SPF_data_next(d);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 440
  if (compute_length) {
    {
#line 441
    compute_length = 0;
#line 443
    err = SPF_recalloc(bufp, buflenp, buflen);
    }
#line 444
    if ((unsigned int )err != 0U) {
#line 445
      return (err);
    }
#line 446
    p = *bufp;
#line 447
    p_end = *bufp + *buflenp;
#line 448
    goto top;
  }
#line 451
  tmp___16 = p;
#line 451
  p ++;
#line 451
  *tmp___16 = (char )'\000';
#line 453
  return ((SPF_errcode_t )0);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 177
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long_only)(int ___argc ,
                                                                                       char * const  *___argv ,
                                                                                       char const   *__shortopts ,
                                                                                       struct option  const  *__longopts ,
                                                                                       int *__longind ) ;
#line 53 "../../src/include/spf_request.h"
SPF_request_t *SPF_request_new(SPF_server_t *spf_server___1 ) ;
#line 54
void SPF_request_free(SPF_request_t *sr ) ;
#line 59
SPF_errcode_t SPF_request_set_ipv4_str(SPF_request_t *sr , char const   *astr ) ;
#line 61
SPF_errcode_t SPF_request_set_ipv6_str(SPF_request_t *sr , char const   *astr ) ;
#line 63
SPF_errcode_t SPF_request_set_helo_dom(SPF_request_t *sr , char const   *dom ) ;
#line 65
int SPF_request_set_env_from(SPF_request_t *sr , char const   *from ) ;
#line 72
SPF_errcode_t SPF_request_query_mailfrom(SPF_request_t *spf_request , SPF_response_t **spf_responsep ) ;
#line 74
SPF_errcode_t SPF_request_query_rcptto(SPF_request_t *spf_request , SPF_response_t **spf_responsep ,
                                       char const   *rcpt_to ) ;
#line 77
SPF_errcode_t SPF_request_query_fallback(SPF_request_t *spf_request , SPF_response_t **spf_responsep ,
                                         char const   *record ) ;
#line 197 "../../src/include/spf_response.h"
void SPF_response_free(SPF_response_t *rp ) ;
#line 198
SPF_response_t *SPF_response_combine(SPF_response_t *main___0 , SPF_response_t *r2mx ) ;
#line 202
SPF_result_t SPF_response_result(SPF_response_t *rp ) ;
#line 203
SPF_reason_t SPF_response_reason(SPF_response_t *rp ) ;
#line 204
SPF_errcode_t SPF_response_errcode(SPF_response_t *rp ) ;
#line 205
char const   *SPF_response_get_received_spf(SPF_response_t *rp ) ;
#line 207
char const   *SPF_response_get_header_comment(SPF_response_t *rp ) ;
#line 208
char const   *SPF_response_get_smtp_comment(SPF_response_t *rp ) ;
#line 212
int SPF_response_messages(SPF_response_t *rp ) ;
#line 218
SPF_error_t *SPF_response_message(SPF_response_t *rp , int idx ) ;
#line 221
char const   *SPF_error_message(SPF_error_t *err ) ;
#line 222
char SPF_error_errorp(SPF_error_t *err ) ;
#line 76 "../../src/include/spf_server.h"
SPF_server_t *SPF_server_new(SPF_server_dnstype_t dnstype , int debug ) ;
#line 78
void SPF_server_free(SPF_server_t *sp ) ;
#line 79
SPF_errcode_t SPF_server_set_rec_dom(SPF_server_t *sp , char const   *dom ) ;
#line 81
SPF_errcode_t SPF_server_set_sanitize(SPF_server_t *sp , int sanitize ) ;
#line 83
SPF_errcode_t SPF_server_set_explanation(SPF_server_t *sp , char const   *exp , SPF_response_t **spf_responsep ) ;
#line 85
SPF_errcode_t SPF_server_set_localpolicy(SPF_server_t *sp , char const   *policy ,
                                         int use_default_whitelist , SPF_response_t **spf_responsep ) ;
#line 103
SPF_errcode_t SPF_server_set_max_dns_mech(SPF_server_t *s , int n ) ;
#line 74 "../../src/include/spf.h"
char const   *SPF_strerror(SPF_errcode_t spf_c_err ) ;
#line 78
char const   *SPF_strresult(SPF_result_t result ) ;
#line 80
char const   *SPF_strreason(SPF_reason_t reason ) ;
#line 87
void SPF_get_lib_version(int *major , int *minor , int *patch ) ;
#line 145 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
static struct option long_options[19]  = 
#line 145 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
  {      {"file", 1, (int *)0, 'f'}, 
        {"ip", 1, (int *)0, 'i'}, 
        {"sender", 1, (int *)0, 's'}, 
        {"helo", 1, (int *)0, 'h'}, 
        {"rcpt-to", 1, (int *)0, 'r'}, 
        {"debug", 2, (int *)0, 'd'}, 
        {"local", 1, (int *)0, 'l'}, 
        {"trusted", 1, (int *)0, 't'}, 
        {"guess", 1, (int *)0, 'g'}, 
        {"default-explanation", 1, (int *)0, 'e'}, 
        {"max-lookup", 1, (int *)0, 'm'}, 
        {"sanitize", 1, (int *)0, 'c'}, 
        {"name", 1, (int *)0, 'n'}, 
        {"override", 1, (int *)0, 'a'}, 
        {"fallback", 1, (int *)0, 'z'}, 
        {"keep-comments", 0, (int *)0, 'k'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"help", 0, (int *)0, '?'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 171 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
static void unimplemented(char const   flag ) 
{ 
  struct option *opt ;
  int i ;

  {
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    opt = & long_options[i];
#line 177
    if (! opt->name) {
#line 177
      goto while_break;
    }
#line 178
    if ((int const   )flag == (int const   )opt->val) {
      {
#line 179
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unimplemented option: -%s or -%c\n",
              opt->name, (int const   )flag);
      }
#line 181
      return;
    }
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unimplemented option: -%c\n",
          (int const   )flag);
  }
#line 186
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
static void usage___0(void) 
{ 


  {
  {
#line 192
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:\n\nspfquery [control options | data options] ...\n\nUse the -help option for more information\n");
  }
#line 200
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
static void help(void) 
{ 


  {
  {
#line 205
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:\n\nspfquery [control options | data options] ...\n\nValid data options are:\n    -file <filename>           read spf data from a file.  Use \'-\'\n                               to read from stdin.\n\n    -ip <IP address>           The IP address that is sending email\n    -sender <email address>    The email address used as the\n                               envelope-from.  If no username (local\n                               part) is given, \'postmaster\' will be\n                               assumed.\n    -helo <domain name>        The domain name given on the SMTP HELO\n                               command.  This is only needed if the\n                               -sender option is not given.\n    -rcpt-to <email addresses> A comma separated lists of email addresses\n                               that will have email from their secondary\n                               MXes automatically allowed.\n\nThe data options are required.  The -file option conflicts with all\nthe other data options.  The -helo and -rcpt-to are optional.\n\n\nValid control options are:\n    -debug [debug level]       debug level.\n    -local <SPF mechanisms>    Local policy for whitelisting.\n    -trusted <0|1>             Should trusted-forwarder.org be checked?\n    -guess <SPF mechanisms>    Default checks if no SPF record is found.\n    -default-explanation <str> Default explanation string to use.\n    -max-lookup <number>       Maximum number of DNS lookups to allow\n    -sanitize <0|1>            Clean up invalid characters in output?\n    -name <domain name>        The name of the system doing the SPF\n                               checking\n    -override <...>            Override SPF records for domains\n    -fallback <...>            Fallback SPF records for domains\n\n    -keep-comments             Print comments found when reading\n                               from a file.\n    -version                   Print version of spfquery.\n    -help                      Print out these options.\n\nExamples:\n\nspfquery -ip=11.22.33.44 -sender=user@aol.com -helo=spammer.tld\nspfquery -f test_data\necho \"127.0.0.1 myname@mydomain.com helohost.com\" | spfquery -f -\n");
  }
#line 255
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
static void response_print_errors(char const   *context , SPF_response_t *spf_response ,
                                  SPF_errcode_t err ) 
{ 
  SPF_error_t *spf_error ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___2 ;
  char tmp___3 ;
  char const   *tmp___5 ;
  char tmp___6 ;
  int tmp___7 ;

  {
  {
#line 265
  printf((char const   */* __restrict  */)"StartError\n");
  }
#line 267
  if ((unsigned long )context != (unsigned long )((void *)0)) {
    {
#line 268
    printf((char const   */* __restrict  */)"Context: %s\n", context);
    }
  }
#line 269
  if ((unsigned int )err != 0U) {
    {
#line 270
    tmp = SPF_strerror(err);
#line 270
    printf((char const   */* __restrict  */)"ErrorCode: (%d) %s\n", (unsigned int )err,
           tmp);
    }
  }
#line 272
  if ((unsigned long )spf_response != (unsigned long )((void *)0)) {
#line 273
    i = 0;
    {
#line 273
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 273
      tmp___7 = SPF_response_messages(spf_response);
      }
#line 273
      if (! (i < tmp___7)) {
#line 273
        goto while_break;
      }
      {
#line 274
      spf_error = SPF_response_message(spf_response, i);
#line 275
      tmp___0 = SPF_error_message(spf_error);
#line 275
      tmp___3 = SPF_error_errorp(spf_error);
      }
#line 275
      if (tmp___3) {
#line 275
        if (! err) {
#line 275
          tmp___2 = "[UNRETURNED] ";
        } else {
#line 275
          tmp___2 = "";
        }
      } else {
#line 275
        tmp___2 = "";
      }
      {
#line 275
      tmp___6 = SPF_error_errorp(spf_error);
      }
#line 275
      if (tmp___6) {
#line 275
        tmp___5 = "Error";
      } else {
#line 275
        tmp___5 = "Warning";
      }
      {
#line 275
      printf((char const   */* __restrict  */)"%s: %s%s\n", tmp___5, tmp___2, tmp___0);
#line 273
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 286
    printf((char const   */* __restrict  */)"libspf2 gave a NULL spf_response\n");
    }
  }
  {
#line 288
  printf((char const   */* __restrict  */)"EndError\n");
  }
#line 289
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
static void response_print(char const   *context , SPF_response_t *spf_response ) 
{ 
  SPF_result_t tmp ;
  char const   *tmp___0 ;
  SPF_reason_t tmp___1 ;
  char const   *tmp___2 ;
  SPF_errcode_t tmp___3 ;
  char const   *tmp___4 ;
  SPF_errcode_t tmp___5 ;

  {
  {
#line 294
  printf((char const   */* __restrict  */)"--vv--\n");
#line 295
  printf((char const   */* __restrict  */)"Context: %s\n", context);
  }
#line 296
  if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
    {
#line 297
    printf((char const   */* __restrict  */)"NULL RESPONSE!\n");
    }
  } else {
    {
#line 300
    tmp = SPF_response_result(spf_response);
#line 300
    tmp___0 = SPF_strresult(tmp);
#line 300
    printf((char const   */* __restrict  */)"Response result: %s\n", tmp___0);
#line 302
    tmp___1 = SPF_response_reason(spf_response);
#line 302
    tmp___2 = SPF_strreason(tmp___1);
#line 302
    printf((char const   */* __restrict  */)"Response reason: %s\n", tmp___2);
#line 304
    tmp___3 = SPF_response_errcode(spf_response);
#line 304
    tmp___4 = SPF_strerror(tmp___3);
#line 304
    printf((char const   */* __restrict  */)"Response err: %s\n", tmp___4);
#line 306
    tmp___5 = SPF_response_errcode(spf_response);
#line 306
    response_print_errors((char const   *)((void *)0), spf_response, tmp___5);
    }
  }
  {
#line 309
  printf((char const   */* __restrict  */)"--^^--\n");
  }
#line 310
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
int main(int argc , char **argv ) 
{ 
  SPF_client_options_t *opts ;
  SPF_client_request_t *req ;
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_response_t *spf_response ;
  SPF_response_t *spf_response_2mx ;
  SPF_response_t *spf_response_fallback ;
  SPF_errcode_t err ;
  char *opt_file ;
  int opt_keep_comments ;
  FILE *fin ;
  char in_line[4096] ;
  char *p ;
  char *p_end ;
  int done_once ;
  int major ;
  int minor ;
  int patch ;
  int res ;
  int c ;
  char const   *partial_result ;
  char *result ;
  int result_len ;
  void *tmp ;
  void *tmp___0 ;
  int option_index ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  SPF_errcode_t tmp___16 ;
  SPF_errcode_t tmp___17 ;
  SPF_errcode_t tmp___18 ;
  int tmp___19 ;
  SPF_result_t tmp___20 ;
  size_t tmp___21 ;
  void *tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  SPF_result_t tmp___28 ;
  size_t tmp___29 ;
  void *tmp___30 ;
  size_t tmp___31 ;
  void *tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  SPF_result_t tmp___35 ;
  SPF_result_t tmp___36 ;
  size_t tmp___37 ;
  void *tmp___38 ;
  size_t tmp___39 ;
  void *tmp___40 ;
  size_t tmp___41 ;
  size_t tmp___42 ;
  char const   *tmp___44 ;
  char const   *tmp___45 ;
  char const   *tmp___46 ;
  char const   *tmp___48 ;
  char const   *tmp___49 ;
  char const   *tmp___50 ;
  char const   *tmp___52 ;
  char const   *tmp___53 ;
  char const   *tmp___54 ;
  SPF_result_t tmp___55 ;

  {
  {
#line 338
  spf_server___1 = (SPF_server_t *)((void *)0);
#line 339
  spf_request = (SPF_request_t *)((void *)0);
#line 340
  spf_response = (SPF_response_t *)((void *)0);
#line 341
  spf_response_2mx = (SPF_response_t *)((void *)0);
#line 342
  spf_response_fallback = (SPF_response_t *)((void *)0);
#line 345
  opt_file = (char *)((void *)0);
#line 346
  opt_keep_comments = 0;
#line 354
  res = 0;
#line 358
  result = (char *)((void *)0);
#line 359
  result_len = 0;
#line 361
  tmp = malloc(sizeof(SPF_client_options_t ));
#line 361
  opts = (SPF_client_options_t *)tmp;
#line 362
  memset((void *)opts, 0, sizeof(SPF_client_options_t ));
#line 364
  tmp___0 = malloc(sizeof(SPF_client_request_t ));
#line 364
  req = (SPF_client_request_t *)tmp___0;
#line 365
  memset((void *)req, 0, sizeof(SPF_client_request_t ));
#line 367
  opts->rec_dom = "spfquery";
  }
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    c = getopt_long_only(argc, (char * const  *)argv, "f:i:s:h:r:lt::gemcnd::kz:a:v",
                         (struct option  const  *)(long_options), & option_index);
    }
#line 386
    if (c == -1) {
#line 387
      goto while_break;
    }
    {
#line 390
    if (c == 102) {
#line 390
      goto case_102;
    }
#line 395
    if (c == 105) {
#line 395
      goto case_105;
    }
#line 399
    if (c == 115) {
#line 399
      goto case_115;
    }
#line 403
    if (c == 104) {
#line 403
      goto case_104;
    }
#line 407
    if (c == 114) {
#line 407
      goto case_114;
    }
#line 412
    if (c == 108) {
#line 412
      goto case_108;
    }
#line 416
    if (c == 116) {
#line 416
      goto case_116;
    }
#line 423
    if (c == 103) {
#line 423
      goto case_103;
    }
#line 427
    if (c == 101) {
#line 427
      goto case_101;
    }
#line 431
    if (c == 109) {
#line 431
      goto case_109;
    }
#line 435
    if (c == 99) {
#line 435
      goto case_99;
    }
#line 439
    if (c == 110) {
#line 439
      goto case_110;
    }
#line 443
    if (c == 97) {
#line 443
      goto case_97;
    }
#line 447
    if (c == 122) {
#line 447
      goto case_122;
    }
#line 452
    if (c == 118) {
#line 452
      goto case_118;
    }
#line 468
    if (c == 63) {
#line 468
      goto case_63;
    }
#line 468
    if (c == 0) {
#line 468
      goto case_63;
    }
#line 473
    if (c == 107) {
#line 473
      goto case_107;
    }
#line 477
    if (c == 100) {
#line 477
      goto case_100;
    }
#line 484
    goto switch_default;
    case_102: /* CIL Label */ 
#line 391
    opt_file = optarg;
#line 392
    goto switch_break;
    case_105: /* CIL Label */ 
#line 396
    req->ip = optarg;
#line 397
    goto switch_break;
    case_115: /* CIL Label */ 
#line 400
    req->sender = optarg;
#line 401
    goto switch_break;
    case_104: /* CIL Label */ 
#line 404
    req->helo = optarg;
#line 405
    goto switch_break;
    case_114: /* CIL Label */ 
#line 408
    req->rcpt_to = optarg;
#line 409
    goto switch_break;
    case_108: /* CIL Label */ 
#line 413
    opts->localpolicy = optarg;
#line 414
    goto switch_break;
    case_116: /* CIL Label */ 
#line 417
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
#line 418
      opts->use_trusted = 1;
    } else {
      {
#line 420
      opts->use_trusted = atoi((char const   *)optarg);
      }
    }
#line 421
    goto switch_break;
    case_103: /* CIL Label */ 
#line 424
    opts->fallback = (char const   *)optarg;
#line 425
    goto switch_break;
    case_101: /* CIL Label */ 
#line 428
    opts->explanation = (char const   *)optarg;
#line 429
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 432
    opts->max_lookup = atoi((char const   *)optarg);
    }
#line 433
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 436
    opts->sanitize = atoi((char const   *)optarg);
    }
#line 437
    goto switch_break;
    case_110: /* CIL Label */ 
#line 440
    opts->rec_dom = (char const   *)optarg;
#line 441
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 444
    unimplemented((char const   )'a');
    }
#line 445
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 448
    unimplemented((char const   )'z');
    }
#line 449
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 453
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spfquery version information:\n");
#line 454
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SPF test system version: %s\n",
            "3.0");
#line 456
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Compiled with SPF library version: %d.%d.%d\n",
            1, 2, 10);
#line 459
    SPF_get_lib_version(& major, & minor, & patch);
#line 460
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Running with SPF library version: %d.%d.%d\n",
            major, minor, patch);
#line 462
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 463
    usage___0();
    }
    {
#line 464
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 464
      res = 255;
#line 464
      goto error;
#line 464
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 465
    goto switch_break;
    case_63: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 469
    help();
    }
    {
#line 470
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 470
      res = 255;
#line 470
      goto error;
#line 470
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 471
    goto switch_break;
    case_107: /* CIL Label */ 
#line 474
    opt_keep_comments = 1;
#line 475
    goto switch_break;
    case_100: /* CIL Label */ 
#line 478
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
#line 479
      opts->debug = 1;
    } else {
      {
#line 481
      opts->debug = atoi((char const   *)optarg);
      }
    }
#line 482
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 485
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: getopt returned character code 0%o ??\n",
            c);
    }
    {
#line 486
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 486
      res = 255;
#line 486
      goto error;
#line 486
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  if (optind != argc) {
    {
#line 491
    help();
    }
    {
#line 492
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 492
      res = 255;
#line 492
      goto error;
#line 492
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 499
  spf_server___1 = SPF_server_new((SPF_server_dnstype_t )1, opts->debug);
  }
#line 501
  if (opts->rec_dom) {
    {
#line 502
    SPF_server_set_rec_dom(spf_server___1, opts->rec_dom);
    }
  }
#line 503
  if (opts->sanitize) {
    {
#line 504
    SPF_server_set_sanitize(spf_server___1, opts->sanitize);
    }
  }
#line 505
  if (opts->max_lookup) {
    {
#line 506
    SPF_server_set_max_dns_mech(spf_server___1, opts->max_lookup);
    }
  }
#line 508
  if (opts->localpolicy) {
    {
#line 509
    err = SPF_server_set_localpolicy(spf_server___1, (char const   *)opts->localpolicy,
                                     opts->use_trusted, & spf_response);
    }
#line 510
    if (err) {
      {
#line 511
      response_print_errors("Error setting local policy", spf_response, err);
      }
      {
#line 513
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 513
        res = 255;
#line 513
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 515
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 515
      if (spf_response) {
        {
#line 515
        SPF_response_free(spf_response);
        }
      }
#line 515
      spf_response = (SPF_response_t *)((void *)0);
#line 515
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 519
  if (opts->explanation) {
    {
#line 520
    err = SPF_server_set_explanation(spf_server___1, opts->explanation, & spf_response);
    }
#line 521
    if (err) {
      {
#line 522
      response_print_errors("Error setting default explanation", spf_response, err);
      }
      {
#line 524
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 524
        res = 255;
#line 524
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 526
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 526
      if (spf_response) {
        {
#line 526
        SPF_response_free(spf_response);
        }
      }
#line 526
      spf_response = (SPF_response_t *)((void *)0);
#line 526
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 533
  if (opt_file) {
    {
#line 537
    tmp___1 = strcmp((char const   *)opt_file, "-");
    }
#line 537
    if (tmp___1 == 0) {
#line 538
      fin = stdin;
    } else {
      {
#line 540
      fin = fopen((char const   */* __restrict  */)opt_file, (char const   */* __restrict  */)"r");
      }
    }
#line 542
    if (! fin) {
      {
#line 543
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open: %s\n",
              opt_file);
      }
      {
#line 544
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 544
        res = 255;
#line 544
        goto error;
#line 544
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  } else {
#line 548
    fin = (FILE *)((void *)0);
#line 550
    if ((unsigned long )req->ip == (unsigned long )((void *)0)) {
#line 550
      goto _L;
    } else
#line 550
    if ((unsigned long )req->sender == (unsigned long )((void *)0)) {
#line 550
      if ((unsigned long )req->helo == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
        {
#line 552
        usage___0();
        }
        {
#line 553
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 553
          res = 255;
#line 553
          goto error;
#line 553
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
    }
  }
#line 557
  done_once = 0;
  {
#line 559
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 560
    if (fin) {
      {
#line 561
      tmp___2 = fgets((char */* __restrict  */)(in_line), (int )sizeof(in_line), (FILE */* __restrict  */)fin);
      }
#line 561
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 562
        goto while_break___10;
      }
      {
#line 564
      tmp___3 = strcspn((char const   *)(in_line), "\r\n");
#line 564
      in_line[tmp___3] = (char )'\000';
#line 565
      p = in_line;
#line 567
      tmp___4 = strspn((char const   *)p, " \t\n");
#line 567
      p += tmp___4;
      }
#line 569
      if ((int )*p == 0) {
#line 569
        goto _L___0;
      } else
#line 569
      if ((int )*p == 35) {
        _L___0: /* CIL Label */ 
#line 570
        if (opt_keep_comments) {
          {
#line 571
          printf((char const   */* __restrict  */)"%s\n", in_line);
          }
        }
#line 572
        goto while_continue___10;
      }
      {
#line 575
      req->ip = p;
#line 576
      tmp___5 = strcspn((char const   *)p, " \t\n");
#line 576
      p += tmp___5;
#line 577
      tmp___6 = p;
#line 577
      p ++;
#line 577
      *tmp___6 = (char )'\000';
#line 579
      tmp___7 = strspn((char const   *)p, " \t\n");
#line 579
      p += tmp___7;
#line 580
      req->sender = p;
#line 581
      tmp___8 = strcspn((char const   *)p, " \t\n");
#line 581
      p += tmp___8;
#line 582
      tmp___9 = p;
#line 582
      p ++;
#line 582
      *tmp___9 = (char )'\000';
#line 584
      tmp___10 = strspn((char const   *)p, " \t\n");
#line 584
      p += tmp___10;
#line 585
      req->helo = p;
#line 586
      tmp___11 = strcspn((char const   *)p, " \t\n");
#line 586
      p += tmp___11;
#line 587
      tmp___12 = p;
#line 587
      p ++;
#line 587
      *tmp___12 = (char )'\000';
#line 589
      tmp___13 = strspn((char const   *)p, " \t\n");
#line 589
      p += tmp___13;
#line 590
      req->rcpt_to = p;
#line 591
      tmp___14 = strcspn((char const   *)p, " \t\n");
#line 591
      p += tmp___14;
#line 592
      tmp___15 = p;
#line 592
      p ++;
#line 592
      *tmp___15 = (char )'\000';
      }
    } else {
#line 595
      if (done_once) {
#line 596
        goto while_break___10;
      }
#line 597
      done_once = 1;
    }
    {
#line 601
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 601
      if (spf_request) {
        {
#line 601
        SPF_request_free(spf_request);
        }
      }
#line 601
      spf_request = (SPF_request_t *)((void *)0);
#line 601
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 602
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 602
      if (spf_response) {
        {
#line 602
        SPF_response_free(spf_response);
        }
      }
#line 602
      spf_response = (SPF_response_t *)((void *)0);
#line 602
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 604
    spf_request = SPF_request_new(spf_server___1);
#line 606
    tmp___16 = SPF_request_set_ipv4_str(spf_request, (char const   *)req->ip);
    }
#line 606
    if (tmp___16) {
      {
#line 606
      tmp___17 = SPF_request_set_ipv6_str(spf_request, (char const   *)req->ip);
      }
#line 606
      if (tmp___17) {
        {
#line 608
        printf((char const   */* __restrict  */)"Invalid IP address.\n");
        }
        {
#line 609
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 609
          res = 255;
#line 609
          goto __Cont;
          __Cont: /* CIL Label */ 
#line 609
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
    }
#line 612
    if (req->helo) {
      {
#line 613
      tmp___18 = SPF_request_set_helo_dom(spf_request, (char const   *)req->helo);
      }
#line 613
      if (tmp___18) {
        {
#line 614
        printf((char const   */* __restrict  */)"Invalid HELO domain.\n");
        }
        {
#line 615
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 615
          res = 255;
#line 615
          goto __Cont___0;
          __Cont___0: /* CIL Label */ 
#line 615
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
    }
    {
#line 619
    tmp___19 = SPF_request_set_env_from(spf_request, (char const   *)req->sender);
    }
#line 619
    if (tmp___19) {
      {
#line 620
      printf((char const   */* __restrict  */)"Invalid envelope from address.\n");
      }
      {
#line 621
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 621
        res = 255;
#line 621
        goto __Cont___1;
        __Cont___1: /* CIL Label */ 
#line 621
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
    }
    {
#line 624
    err = SPF_request_query_mailfrom(spf_request, & spf_response);
    }
#line 625
    if (opts->debug) {
      {
#line 626
      response_print("Main query", spf_response);
      }
    }
#line 627
    if (err) {
      {
#line 628
      response_print_errors("Failed to query MAIL-FROM", spf_response, err);
      }
      {
#line 630
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 630
        res = 255;
#line 630
        goto __Cont___2;
        __Cont___2: /* CIL Label */ 
#line 630
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
#line 633
    if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 634
      *(result + 0) = (char )'\000';
    }
    {
#line 635
    while (1) {
      while_continue___17: /* CIL Label */ ;
      {
#line 635
      tmp___20 = SPF_response_result(spf_response);
#line 635
      partial_result = SPF_strresult(tmp___20);
      }
      {
#line 635
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 635
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 635
          tmp___21 = strlen(partial_result);
#line 635
          result_len = (int )(256UL + tmp___21);
#line 635
          tmp___22 = malloc((size_t )result_len);
#line 635
          result = (char *)tmp___22;
#line 635
          *(result + 0) = (char )'\000';
          }
        } else {
          {
#line 635
          tmp___25 = strlen((char const   *)result);
#line 635
          tmp___26 = strlen(partial_result);
          }
#line 635
          if (tmp___25 + tmp___26 >= (size_t )result_len) {
            {
#line 635
            tmp___23 = strlen(partial_result);
#line 635
            result_len = (int )((size_t )((result_len + (result_len >> 1)) + 8) + tmp___23);
#line 635
            tmp___24 = realloc((void *)result, (size_t )result_len);
#line 635
            result = (char *)tmp___24;
            }
          }
        }
#line 635
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 635
      strcat((char */* __restrict  */)result, (char const   */* __restrict  */)partial_result);
      }
#line 635
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 637
    if ((unsigned long )req->rcpt_to != (unsigned long )((void *)0)) {
#line 637
      if ((int )*(req->rcpt_to) != 0) {
        {
#line 638
        p = req->rcpt_to;
#line 639
        tmp___27 = strcspn((char const   *)p, ",;");
#line 639
        p_end = p + tmp___27;
        }
        {
#line 642
        while (1) {
          while_continue___19: /* CIL Label */ ;
          {
#line 642
          tmp___35 = SPF_response_result(spf_response);
          }
#line 642
          if (! ((unsigned int )tmp___35 != 2U)) {
#line 642
            goto while_break___19;
          }
#line 643
          if (*p_end) {
#line 644
            *p_end = (char )'\000';
          } else {
#line 646
            p_end = (char *)((void *)0);
          }
          {
#line 648
          err = SPF_request_query_rcptto(spf_request, & spf_response_2mx, (char const   *)p);
          }
#line 650
          if (opts->debug) {
            {
#line 651
            response_print("2mx query", spf_response_2mx);
            }
          }
#line 652
          if (err) {
            {
#line 653
            response_print_errors("Failed to query RCPT-TO", spf_response, err);
            }
            {
#line 655
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 655
              res = 255;
#line 655
              goto __Cont___3;
              __Cont___3: /* CIL Label */ 
#line 655
              goto while_break___20;
            }
            while_break___20: /* CIL Label */ ;
            }
          }
          {
#line 659
          while (1) {
            while_continue___21: /* CIL Label */ ;
            {
#line 659
            tmp___28 = SPF_response_result(spf_response_2mx);
#line 659
            partial_result = SPF_strresult(tmp___28);
            }
            {
#line 659
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 659
              if ((unsigned long )result == (unsigned long )((void *)0)) {
                {
#line 659
                tmp___29 = strlen(partial_result);
#line 659
                result_len = (int )(256UL + tmp___29);
#line 659
                tmp___30 = malloc((size_t )result_len);
#line 659
                result = (char *)tmp___30;
#line 659
                *(result + 0) = (char )'\000';
                }
              } else {
                {
#line 659
                tmp___33 = strlen((char const   *)result);
#line 659
                tmp___34 = strlen(partial_result);
                }
#line 659
                if (tmp___33 + tmp___34 >= (size_t )result_len) {
                  {
#line 659
                  tmp___31 = strlen(partial_result);
#line 659
                  result_len = (int )((size_t )((result_len + (result_len >> 1)) + 8) + tmp___31);
#line 659
                  tmp___32 = realloc((void *)result, (size_t )result_len);
#line 659
                  result = (char *)tmp___32;
                  }
                }
              }
#line 659
              goto while_break___22;
            }
            while_break___22: /* CIL Label */ ;
            }
            {
#line 659
            strcat((char */* __restrict  */)result, (char const   */* __restrict  */)partial_result);
            }
#line 659
            goto while_break___21;
          }
          while_break___21: /* CIL Label */ ;
          }
          {
#line 661
          spf_response = SPF_response_combine(spf_response, spf_response_2mx);
          }
#line 664
          if (! p_end) {
#line 665
            goto while_break___19;
          }
#line 666
          p = p_end + 1;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
    }
#line 671
    if (opts->fallback) {
      {
#line 672
      err = SPF_request_query_fallback(spf_request, & spf_response_fallback, opts->fallback);
      }
#line 674
      if (opts->debug) {
        {
#line 675
        response_print("fallback query", spf_response_fallback);
        }
      }
#line 676
      if (err) {
        {
#line 677
        response_print_errors("Failed to query best-guess", spf_response_fallback,
                              err);
        }
        {
#line 679
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 679
          res = 255;
#line 679
          goto __Cont___4;
          __Cont___4: /* CIL Label */ 
#line 679
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
      {
#line 683
      while (1) {
        while_continue___24: /* CIL Label */ ;
        {
#line 683
        tmp___36 = SPF_response_result(spf_response_fallback);
#line 683
        partial_result = SPF_strresult(tmp___36);
        }
        {
#line 683
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 683
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            {
#line 683
            tmp___37 = strlen(partial_result);
#line 683
            result_len = (int )(256UL + tmp___37);
#line 683
            tmp___38 = malloc((size_t )result_len);
#line 683
            result = (char *)tmp___38;
#line 683
            *(result + 0) = (char )'\000';
            }
          } else {
            {
#line 683
            tmp___41 = strlen((char const   *)result);
#line 683
            tmp___42 = strlen(partial_result);
            }
#line 683
            if (tmp___41 + tmp___42 >= (size_t )result_len) {
              {
#line 683
              tmp___39 = strlen(partial_result);
#line 683
              result_len = (int )((size_t )((result_len + (result_len >> 1)) + 8) + tmp___39);
#line 683
              tmp___40 = realloc((void *)result, (size_t )result_len);
#line 683
              result = (char *)tmp___40;
              }
            }
          }
#line 683
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
        {
#line 683
        strcat((char */* __restrict  */)result, (char const   */* __restrict  */)partial_result);
        }
#line 683
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
      {
#line 685
      spf_response = SPF_response_combine(spf_response, spf_response_fallback);
      }
    }
    {
#line 689
    tmp___46 = SPF_response_get_received_spf(spf_response);
    }
#line 689
    if (tmp___46) {
      {
#line 689
      tmp___44 = SPF_response_get_received_spf(spf_response);
#line 689
      tmp___45 = tmp___44;
      }
    } else {
#line 689
      tmp___45 = "";
    }
    {
#line 689
    tmp___50 = SPF_response_get_header_comment(spf_response);
    }
#line 689
    if (tmp___50) {
      {
#line 689
      tmp___48 = SPF_response_get_header_comment(spf_response);
#line 689
      tmp___49 = tmp___48;
      }
    } else {
#line 689
      tmp___49 = "";
    }
    {
#line 689
    tmp___54 = SPF_response_get_smtp_comment(spf_response);
    }
#line 689
    if (tmp___54) {
      {
#line 689
      tmp___52 = SPF_response_get_smtp_comment(spf_response);
#line 689
      tmp___53 = tmp___52;
      }
    } else {
#line 689
      tmp___53 = "";
    }
    {
#line 689
    printf((char const   */* __restrict  */)"%s\n%s\n%s\n%s\n", result, tmp___53,
           tmp___49, tmp___45);
#line 696
    tmp___55 = SPF_response_result(spf_response);
#line 696
    res = (int )tmp___55;
#line 698
    fflush(stdout);
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  error: 
  {
#line 702
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 702
    if (result) {
      {
#line 702
      free((void *)result);
      }
    }
#line 702
    result = (char *)((void *)0);
#line 702
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
  {
#line 703
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 703
    if (spf_response) {
      {
#line 703
      SPF_response_free(spf_response);
      }
    }
#line 703
    spf_response = (SPF_response_t *)((void *)0);
#line 703
    goto while_break___27;
  }
  while_break___27: /* CIL Label */ ;
  }
  {
#line 704
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 704
    if (spf_request) {
      {
#line 704
      SPF_request_free(spf_request);
      }
    }
#line 704
    spf_request = (SPF_request_t *)((void *)0);
#line 704
    goto while_break___28;
  }
  while_break___28: /* CIL Label */ ;
  }
  {
#line 705
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 705
    if (spf_server___1) {
      {
#line 705
      SPF_server_free(spf_server___1);
      }
    }
#line 705
    spf_server___1 = (SPF_server_t *)((void *)0);
#line 705
    goto while_break___29;
  }
  while_break___29: /* CIL Label */ ;
  }
  {
#line 707
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 707
    if (req) {
      {
#line 707
      free((void *)req);
      }
    }
#line 707
    req = (SPF_client_request_t *)((void *)0);
#line 707
    goto while_break___30;
  }
  while_break___30: /* CIL Label */ ;
  }
  {
#line 708
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 708
    if (opts) {
      {
#line 708
      free((void *)opts);
      }
    }
#line 708
    opts = (SPF_client_options_t *)((void *)0);
#line 708
    goto while_break___31;
  }
  while_break___31: /* CIL Label */ ;
  }
#line 714
  return (res);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_strerror.c"
char const   *SPF_strerror(SPF_errcode_t spf_c_err ) 
{ 


  {
  {
#line 37
  if ((unsigned int )spf_c_err == 0U) {
#line 37
    goto case_0;
  }
#line 41
  if ((unsigned int )spf_c_err == 1U) {
#line 41
    goto case_1;
  }
#line 45
  if ((unsigned int )spf_c_err == 2U) {
#line 45
    goto case_2;
  }
#line 49
  if ((unsigned int )spf_c_err == 3U) {
#line 49
    goto case_3;
  }
#line 53
  if ((unsigned int )spf_c_err == 4U) {
#line 53
    goto case_4;
  }
#line 57
  if ((unsigned int )spf_c_err == 5U) {
#line 57
    goto case_5;
  }
#line 61
  if ((unsigned int )spf_c_err == 6U) {
#line 61
    goto case_6;
  }
#line 65
  if ((unsigned int )spf_c_err == 7U) {
#line 65
    goto case_7;
  }
#line 69
  if ((unsigned int )spf_c_err == 8U) {
#line 69
    goto case_8;
  }
#line 73
  if ((unsigned int )spf_c_err == 9U) {
#line 73
    goto case_9;
  }
#line 77
  if ((unsigned int )spf_c_err == 10U) {
#line 77
    goto case_10;
  }
#line 81
  if ((unsigned int )spf_c_err == 11U) {
#line 81
    goto case_11;
  }
#line 85
  if ((unsigned int )spf_c_err == 12U) {
#line 85
    goto case_12;
  }
#line 89
  if ((unsigned int )spf_c_err == 13U) {
#line 89
    goto case_13;
  }
#line 93
  if ((unsigned int )spf_c_err == 14U) {
#line 93
    goto case_14;
  }
#line 97
  if ((unsigned int )spf_c_err == 15U) {
#line 97
    goto case_15;
  }
#line 101
  if ((unsigned int )spf_c_err == 16U) {
#line 101
    goto case_16;
  }
#line 105
  if ((unsigned int )spf_c_err == 17U) {
#line 105
    goto case_17;
  }
#line 109
  if ((unsigned int )spf_c_err == 18U) {
#line 109
    goto case_18;
  }
#line 113
  if ((unsigned int )spf_c_err == 19U) {
#line 113
    goto case_19;
  }
#line 117
  if ((unsigned int )spf_c_err == 20U) {
#line 117
    goto case_20;
  }
#line 121
  if ((unsigned int )spf_c_err == 21U) {
#line 121
    goto case_21;
  }
#line 125
  if ((unsigned int )spf_c_err == 22U) {
#line 125
    goto case_22;
  }
#line 129
  if ((unsigned int )spf_c_err == 23U) {
#line 129
    goto case_23;
  }
#line 133
  if ((unsigned int )spf_c_err == 24U) {
#line 133
    goto case_24;
  }
#line 137
  if ((unsigned int )spf_c_err == 25U) {
#line 137
    goto case_25;
  }
#line 141
  if ((unsigned int )spf_c_err == 26U) {
#line 141
    goto case_26;
  }
#line 145
  if ((unsigned int )spf_c_err == 27U) {
#line 145
    goto case_27;
  }
#line 149
  if ((unsigned int )spf_c_err == 28U) {
#line 149
    goto case_28;
  }
#line 153
  if ((unsigned int )spf_c_err == 29U) {
#line 153
    goto case_29;
  }
#line 157
  if ((unsigned int )spf_c_err == 30U) {
#line 157
    goto case_30;
  }
#line 161
  if ((unsigned int )spf_c_err == 31U) {
#line 161
    goto case_31;
  }
#line 165
  if ((unsigned int )spf_c_err == 32U) {
#line 165
    goto case_32;
  }
#line 169
  goto switch_default;
  case_0: /* CIL Label */ 
#line 38
  return ("No errors");
#line 39
  goto switch_break;
  case_1: /* CIL Label */ 
#line 42
  return ("Out of memory");
#line 43
  goto switch_break;
  case_2: /* CIL Label */ 
#line 46
  return ("Could not find a valid SPF record");
#line 47
  goto switch_break;
  case_3: /* CIL Label */ 
#line 50
  return ("Syntax error");
#line 51
  goto switch_break;
  case_4: /* CIL Label */ 
#line 54
  return ("Modifiers can not have prefixes");
#line 55
  goto switch_break;
  case_5: /* CIL Label */ 
#line 58
  return ("Invalid character found");
#line 59
  goto switch_break;
  case_6: /* CIL Label */ 
#line 62
  return ("Unknown mechanism found");
#line 63
  goto switch_break;
  case_7: /* CIL Label */ 
#line 66
  return ("Invalid option found");
#line 67
  goto switch_break;
  case_8: /* CIL Label */ 
#line 70
  return ("Invalid CIDR length");
#line 71
  goto switch_break;
  case_9: /* CIL Label */ 
#line 74
  return ("Required option is missing");
#line 75
  goto switch_break;
  case_10: /* CIL Label */ 
#line 78
  return ("Internal programming error");
#line 79
  goto switch_break;
  case_11: /* CIL Label */ 
#line 82
  return ("Invalid %-escape character");
#line 83
  goto switch_break;
  case_12: /* CIL Label */ 
#line 86
  return ("Invalid macro variable");
#line 87
  goto switch_break;
  case_13: /* CIL Label */ 
#line 90
  return ("Subdomain truncation depth too large");
#line 91
  goto switch_break;
  case_14: /* CIL Label */ 
#line 94
  return ("Invalid delimiter character");
#line 95
  goto switch_break;
  case_15: /* CIL Label */ 
#line 98
  return ("Option string too long");
#line 99
  goto switch_break;
  case_16: /* CIL Label */ 
#line 102
  return ("Too many mechanisms");
#line 103
  goto switch_break;
  case_17: /* CIL Label */ 
#line 106
  return ("Too many modifiers");
#line 107
  goto switch_break;
  case_18: /* CIL Label */ 
#line 110
  return ("Mechanisms used too many DNS lookups");
#line 111
  goto switch_break;
  case_19: /* CIL Label */ 
#line 114
  return ("Invalid IPv4 address literal");
#line 115
  goto switch_break;
  case_20: /* CIL Label */ 
#line 118
  return ("Invalid IPv6 address literal");
#line 119
  goto switch_break;
  case_21: /* CIL Label */ 
#line 122
  return ("Invalid mechanism prefix");
#line 123
  goto switch_break;
  case_22: /* CIL Label */ 
#line 126
  return ("SPF result is \"unknown\"");
#line 127
  goto switch_break;
  case_23: /* CIL Label */ 
#line 130
  return ("Uninitialized variable");
#line 131
  goto switch_break;
  case_24: /* CIL Label */ 
#line 134
  return ("Modifier not found");
#line 135
  goto switch_break;
  case_25: /* CIL Label */ 
#line 138
  return ("Not configured");
#line 139
  goto switch_break;
  case_26: /* CIL Label */ 
#line 142
  return ("DNS lookup failure");
#line 143
  goto switch_break;
  case_27: /* CIL Label */ 
#line 146
  return ("Invalid hostname (possibly an IP address?)");
#line 147
  goto switch_break;
  case_28: /* CIL Label */ 
#line 150
  return ("Hostname has a missing or invalid TLD");
#line 151
  goto switch_break;
  case_29: /* CIL Label */ 
#line 154
  return ("Mechanisms found after the \"all:\" mechanism will be ignored");
#line 155
  goto switch_break;
  case_30: /* CIL Label */ 
#line 158
  return ("include: mechanism returned \'none\'");
#line 159
  goto switch_break;
  case_31: /* CIL Label */ 
#line 162
  return ("include: or redirect= caused unlimited recursion");
#line 163
  goto switch_break;
  case_32: /* CIL Label */ 
#line 166
  return ("Multiple SPF or TXT records for domain.");
#line 167
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 170
  return ("Unknown SPF error code");
#line 171
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 174
  return ((char const   *)0);
}
}
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 87 "../../src/include/spf_log.h"
 __attribute__((__noreturn__)) void SPF_error_stdio(char const   *file , int line ,
                                                    char const   *errmsg ) ;
#line 88
void SPF_warning_stdio(char const   *file , int line , char const   *errmsg ) ;
#line 89
void SPF_info_stdio(char const   *file  __attribute__((__unused__)) , int line  __attribute__((__unused__)) ,
                    char const   *errmsg ) ;
#line 90
void SPF_debug_stdio(char const   *file , int line , char const   *errmsg ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_stdio.c"
 __attribute__((__noreturn__)) void SPF_error_stdio(char const   *file , int line ,
                                                    char const   *errmsg ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_stdio.c"
void SPF_error_stdio(char const   *file , int line , char const   *errmsg ) 
{ 
  char buf[128] ;

  {
#line 37
  if (file) {
    {
#line 38
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s:%d",
             file, line);
#line 39
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-20s Error: %s\n",
            buf, errmsg);
    }
  } else {
    {
#line 42
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: %s\n",
            errmsg);
    }
  }
  {
#line 44
  abort();
  }
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_stdio.c"
void SPF_warning_stdio(char const   *file , int line , char const   *errmsg ) 
{ 
  char buf[128] ;

  {
#line 51
  if (file) {
    {
#line 52
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s:%d",
             file, line);
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-20s Warning: %s\n",
            buf, errmsg);
    }
  } else {
    {
#line 56
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: %s\n",
            errmsg);
    }
  }
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_stdio.c"
void SPF_info_stdio(char const   *file  __attribute__((__unused__)) , int line  __attribute__((__unused__)) ,
                    char const   *errmsg ) 
{ 


  {
  {
#line 63
  printf((char const   */* __restrict  */)"%s\n", errmsg);
  }
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_stdio.c"
void SPF_debug_stdio(char const   *file , int line , char const   *errmsg ) 
{ 
  char buf[128] ;

  {
#line 70
  if (file) {
    {
#line 71
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s:%d",
             file, line);
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-20s Debug: %s\n",
            buf, errmsg);
    }
  } else {
    {
#line 75
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Debug: %s\n",
            errmsg);
    }
  }
#line 77
  return;
}
}
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 74 "../../src/include/spf_dns_rr.h"
void SPF_dns_rr_free(SPF_dns_rr_t *spfrr ) ;
#line 75
SPF_dns_rr_t *SPF_dns_rr_new_init(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                  ns_type rr_type , int ttl , SPF_dns_stat_t herrno ) ;
#line 82
SPF_errcode_t SPF_dns_rr_buf_realloc(SPF_dns_rr_t *spfrr , int idx , size_t len ) ;
#line 84
SPF_errcode_t SPF_dns_rr_dup(SPF_dns_rr_t **dstp , SPF_dns_rr_t *src ) ;
#line 130 "../../src/include/spf_dns.h"
SPF_dns_rr_t *SPF_dns_lookup(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                             ns_type rr_type , int should_cache ) ;
#line 70 "../../src/include/spf_dns_zone.h"
SPF_dns_server_t *SPF_dns_zone_new(SPF_dns_server_t *layer_below , char const   *name ,
                                   int debug ) ;
#line 79
SPF_errcode_t SPF_dns_zone_add_str(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                   ns_type rr_type , SPF_dns_stat_t herrno , char const   *data ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
__inline static SPF_dns_zone_config_t *SPF_voidp2spfhook(void *hook ) 
{ 


  {
#line 84
  return ((SPF_dns_zone_config_t *)hook);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_find(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                       ns_type rr_type , int exact ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;
  int tmp ;
  size_t domain_len ;
  size_t tmp___0 ;
  size_t zdomain_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 103
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 105
  if (spf_dns_server->debug) {
    {
#line 106
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
               106, "zone: Searching for RR %s (%d)", domain, (unsigned int )rr_type);
    }
  }
#line 110
  if (exact) {
#line 110
    goto _L;
  } else {
    {
#line 110
    tmp___6 = strncmp(domain, "*.", (size_t )2);
    }
#line 110
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
#line 111
      i = 0;
      {
#line 111
      while (1) {
        while_continue: /* CIL Label */ ;
#line 111
        if (! (i < spfhook->num_zone)) {
#line 111
          goto while_break;
        }
#line 112
        if ((unsigned int )(*(spfhook->zone + i))->rr_type == (unsigned int )rr_type) {
          {
#line 112
          tmp = strcasecmp((char const   *)(*(spfhook->zone + i))->domain, domain);
          }
#line 112
          if (tmp == 0) {
#line 114
            return (*(spfhook->zone + i));
          }
        }
#line 111
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 116
      if (spf_dns_server->debug) {
        {
#line 117
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   117, "zone: Exact not found");
        }
      }
    } else {
      {
#line 121
      tmp___0 = strlen(domain);
#line 121
      domain_len = tmp___0;
      }
#line 125
      if (domain_len) {
#line 125
        if ((int const   )*(domain + (domain_len - 1UL)) == 46) {
#line 126
          domain_len --;
        }
      }
#line 128
      i = 0;
      {
#line 128
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 128
        if (! (i < spfhook->num_zone)) {
#line 128
          goto while_break___0;
        }
#line 129
        if ((unsigned int )(*(spfhook->zone + i))->rr_type != (unsigned int )rr_type) {
#line 129
          if ((unsigned int )(*(spfhook->zone + i))->rr_type != 255U) {
#line 131
            if (spf_dns_server->debug) {
              {
#line 132
              SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                         133, "zone: Ignoring record rrtype %d", (unsigned int )(*(spfhook->zone + i))->rr_type);
              }
            }
#line 134
            goto __Cont;
          }
        }
        {
#line 137
        tmp___5 = strncmp((char const   *)(*(spfhook->zone + i))->domain, "*.", (size_t )2);
        }
#line 137
        if (tmp___5 == 0) {
          {
#line 138
          tmp___1 = strlen((char const   *)(*(spfhook->zone + i))->domain);
#line 138
          zdomain_len = tmp___1 - 2UL;
          }
#line 139
          if (zdomain_len <= domain_len) {
            {
#line 139
            tmp___2 = strncasecmp((char const   *)((*(spfhook->zone + i))->domain + 2),
                                  domain + (domain_len - zdomain_len), zdomain_len);
            }
#line 139
            if (tmp___2 == 0) {
#line 144
              return (*(spfhook->zone + i));
            }
          }
        } else {
          {
#line 146
          tmp___3 = strncasecmp((char const   *)(*(spfhook->zone + i))->domain, domain,
                                domain_len);
          }
#line 146
          if (tmp___3 == 0) {
            {
#line 146
            tmp___4 = strlen((char const   *)(*(spfhook->zone + i))->domain);
            }
#line 146
            if (tmp___4 == domain_len) {
#line 151
              return (*(spfhook->zone + i));
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 128
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 154
      if (spf_dns_server->debug) {
        {
#line 155
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   155, "zone: Non-exact not found");
        }
      }
    }
  }
#line 158
  return ((SPF_dns_rr_t *)((void *)0));
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_lookup(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                         ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  SPF_dns_rr_t *spfrr ;
  SPF_dns_rr_t *tmp ;

  {
  {
#line 170
  spfrr = SPF_dns_zone_find(spf_dns_server, domain, rr_type, 0);
  }
#line 171
  if (spfrr) {
    {
#line 172
    SPF_dns_rr_dup(& spfrr, spfrr);
    }
#line 173
    return (spfrr);
  }
#line 176
  if (spf_dns_server->layer_below) {
    {
#line 177
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 177
    return (tmp);
  }
  {
#line 181
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
#line 182
  SPF_dns_rr_dup(& spfrr, spfhook->nxdomain);
  }
#line 184
  return (spfrr);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
SPF_errcode_t SPF_dns_zone_add_str(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                   ns_type rr_type , SPF_dns_stat_t herrno , char const   *data ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  SPF_dns_rr_t *spfrr ;
  int err ;
  int cnt ;
  int new_len ;
  SPF_dns_rr_t **new_zone ;
  int i ;
  void *tmp ;
  SPF_errcode_t __err ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t __err___0 ;
  SPF_errcode_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  SPF_errcode_t __err___1 ;
  size_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  SPF_errcode_t __err___2 ;
  size_t tmp___6 ;
  SPF_errcode_t tmp___7 ;
  SPF_errcode_t __err___3 ;
  size_t tmp___8 ;
  SPF_errcode_t tmp___9 ;

  {
#line 199
  if ((unsigned int )rr_type == 255U) {
#line 200
    if (data) {
      {
#line 201
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                 201, "%s", "RR type ANY can not have data.");
      }
    }
#line 202
    if (herrno == 0) {
      {
#line 203
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                 203, "%s", "RR type ANY must return a DNS error code.");
      }
    }
  }
  {
#line 206
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
#line 209
  spfrr = SPF_dns_zone_find(spf_dns_server, domain, rr_type, 1);
  }
#line 212
  if ((unsigned long )spfrr == (unsigned long )((void *)0)) {
#line 214
    if (spfhook->num_zone == spfhook->zone_buf_len) {
      {
#line 219
      new_len = (spfhook->zone_buf_len + (spfhook->zone_buf_len >> 2)) + 4;
#line 221
      tmp = realloc((void *)spfhook->zone, (unsigned long )new_len * sizeof(*new_zone));
#line 221
      new_zone = (SPF_dns_rr_t **)tmp;
      }
#line 223
      if ((unsigned long )new_zone == (unsigned long )((void *)0)) {
#line 224
        return ((SPF_errcode_t )1);
      }
#line 226
      i = spfhook->zone_buf_len;
      {
#line 226
      while (1) {
        while_continue: /* CIL Label */ ;
#line 226
        if (! (i < new_len)) {
#line 226
          goto while_break;
        }
#line 227
        *(new_zone + i) = (SPF_dns_rr_t *)((void *)0);
#line 226
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 229
      spfhook->zone_buf_len = new_len;
#line 230
      spfhook->zone = new_zone;
    }
    {
#line 234
    spfrr = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 86400, herrno);
    }
#line 236
    if ((unsigned long )spfrr == (unsigned long )((void *)0)) {
#line 237
      return ((SPF_errcode_t )1);
    }
#line 238
    *(spfhook->zone + spfhook->num_zone) = spfrr;
#line 239
    (spfhook->num_zone) ++;
#line 242
    if (herrno != 0) {
#line 243
      return ((SPF_errcode_t )0);
    }
  }
#line 254
  cnt = spfrr->num_rr;
  {
#line 257
  if ((unsigned int )rr_type == 1U) {
#line 257
    goto case_1;
  }
#line 264
  if ((unsigned int )rr_type == 28U) {
#line 264
    goto case_28;
  }
#line 271
  if ((unsigned int )rr_type == 15U) {
#line 271
    goto case_15;
  }
#line 281
  if ((unsigned int )rr_type == 99U) {
#line 281
    goto case_99;
  }
#line 281
  if ((unsigned int )rr_type == 16U) {
#line 281
    goto case_99;
  }
#line 286
  if ((unsigned int )rr_type == 12U) {
#line 286
    goto case_12;
  }
#line 291
  if ((unsigned int )rr_type == 255U) {
#line 291
    goto case_255;
  }
#line 299
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 258
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 258
    tmp___0 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->a));
#line 258
    __err = tmp___0;
    }
#line 258
    if ((unsigned int )__err != 0U) {
#line 258
      return (__err);
    }
#line 258
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 259
  err = inet_pton(2, (char const   */* __restrict  */)data, (void */* __restrict  */)(& (*(spfrr->rr + cnt))->a));
  }
#line 260
  if (err <= 0) {
#line 261
    return ((SPF_errcode_t )19);
  }
#line 262
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 265
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 265
    tmp___1 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->aaaa));
#line 265
    __err___0 = tmp___1;
    }
#line 265
    if ((unsigned int )__err___0 != 0U) {
#line 265
      return (__err___0);
    }
#line 265
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 266
  err = inet_pton(10, (char const   */* __restrict  */)data, (void */* __restrict  */)(& (*(spfrr->rr + cnt))->aaaa));
  }
#line 267
  if (err <= 0) {
#line 268
    return ((SPF_errcode_t )20);
  }
#line 269
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 274
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 274
    tmp___2 = __ctype_b_loc();
    }
#line 274
    if (! ((int const   )*(*tmp___2 + (int )*data) & 2048)) {
#line 274
      goto while_break___2;
    }
#line 274
    data ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 275
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 275
    tmp___3 = __ctype_b_loc();
    }
#line 275
    if (! ((int const   )*(*tmp___3 + (int )*data) & 8192)) {
#line 275
      goto while_break___3;
    }
#line 275
    data ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 276
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 276
    tmp___4 = strlen(data);
#line 276
    tmp___5 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___4 + 1UL);
#line 276
    __err___1 = tmp___5;
    }
#line 276
    if ((unsigned int )__err___1 != 0U) {
#line 276
      return (__err___1);
    }
#line 276
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 277
  strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->mx), (char const   */* __restrict  */)data);
  }
#line 278
  goto switch_break;
  case_99: /* CIL Label */ 
  case_16: /* CIL Label */ 
  {
#line 282
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 282
    tmp___6 = strlen(data);
#line 282
    tmp___7 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___6 + 1UL);
#line 282
    __err___2 = tmp___7;
    }
#line 282
    if ((unsigned int )__err___2 != 0U) {
#line 282
      return (__err___2);
    }
#line 282
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 283
  strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->txt), (char const   */* __restrict  */)data);
  }
#line 284
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 287
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 287
    tmp___8 = strlen(data);
#line 287
    tmp___9 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___8 + 1UL);
#line 287
    __err___3 = tmp___9;
    }
#line 287
    if ((unsigned int )__err___3 != 0U) {
#line 287
      return (__err___3);
    }
#line 287
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 288
  strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->ptr), (char const   */* __restrict  */)data);
  }
#line 289
  goto switch_break;
  case_255: /* CIL Label */ 
#line 292
  if (data) {
    {
#line 293
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
               293, "%s", "RR type ANY can not have data.");
    }
  }
#line 294
  if (herrno == 0) {
    {
#line 295
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
               295, "%s", "RR type ANY must return a DNS error code.");
    }
  }
  {
#line 296
  SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
             296, "%s", "RR type ANY can not have multiple RR.");
  }
#line 297
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 300
  SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
             300, "%s", "Invalid RR type");
  }
#line 301
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 304
  spfrr->num_rr = cnt + 1;
#line 306
  return ((SPF_errcode_t )0);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static void SPF_dns_zone_free(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 317
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                 317, "%s", "spf_dns_server is NULL");
      }
    }
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 320
  if (spfhook) {
#line 321
    if (spfhook->zone) {
#line 322
      i = 0;
      {
#line 322
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 322
        if (! (i < spfhook->zone_buf_len)) {
#line 322
          goto while_break___0;
        }
#line 323
        if (*(spfhook->zone + i)) {
          {
#line 324
          SPF_dns_rr_free(*(spfhook->zone + i));
          }
        }
#line 322
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 326
      free((void *)spfhook->zone);
      }
    }
#line 328
    if (spfhook->nxdomain) {
      {
#line 329
      SPF_dns_rr_free(spfhook->nxdomain);
      }
    }
    {
#line 330
    free((void *)spfhook);
    }
  }
  {
#line 333
  free((void *)spf_dns_server);
  }
#line 334
  return;
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
SPF_dns_server_t *SPF_dns_zone_new(SPF_dns_server_t *layer_below , char const   *name ,
                                   int debug ) 
{ 
  SPF_dns_server_t *spf_dns_server ;
  SPF_dns_zone_config_t *spfhook ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 343
  tmp = malloc(sizeof(SPF_dns_server_t ));
#line 343
  spf_dns_server = (SPF_dns_server_t *)tmp;
  }
#line 344
  if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
#line 345
    return ((SPF_dns_server_t *)((void *)0));
  }
  {
#line 346
  memset((void *)spf_dns_server, 0, sizeof(SPF_dns_server_t ));
#line 348
  spf_dns_server->hook = malloc(sizeof(SPF_dns_zone_config_t ));
  }
#line 349
  if ((unsigned long )spf_dns_server->hook == (unsigned long )((void *)0)) {
    {
#line 350
    free((void *)spf_dns_server);
    }
#line 351
    return ((SPF_dns_server_t *)((void *)0));
  }
  {
#line 353
  memset(spf_dns_server->hook, 0, sizeof(SPF_dns_zone_config_t ));
  }
#line 355
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 356
    name = "zone";
  }
  {
#line 358
  spf_dns_server->destroy = & SPF_dns_zone_free;
#line 359
  spf_dns_server->lookup = & SPF_dns_zone_lookup;
#line 360
  spf_dns_server->get_spf = (SPF_errcode_t (*)(SPF_server_t *spf_server , SPF_request_t *spf_request ,
                                               SPF_response_t *spf_response , SPF_record_t **spf_recordp ))((void *)0);
#line 361
  spf_dns_server->get_exp = (SPF_errcode_t (*)(SPF_server_t *spf_server , char const   *domain ,
                                               char **buf , size_t *buf_len ))((void *)0);
#line 362
  spf_dns_server->add_cache = (int (*)(SPF_server_t *spf_server , SPF_dns_rr_t spfrr ))((void *)0);
#line 363
  spf_dns_server->layer_below = layer_below;
#line 364
  spf_dns_server->name = name;
#line 365
  spf_dns_server->debug = debug;
#line 367
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
#line 369
  spfhook->zone_buf_len = 32;
#line 370
  spfhook->num_zone = 0;
#line 371
  tmp___0 = calloc((size_t )spfhook->zone_buf_len, sizeof(*(spfhook->zone)));
#line 371
  spfhook->zone = (SPF_dns_rr_t **)tmp___0;
  }
#line 373
  if ((unsigned long )spfhook->zone == (unsigned long )((void *)0)) {
    {
#line 374
    free((void *)spfhook);
#line 375
    free((void *)spf_dns_server);
    }
#line 376
    return ((SPF_dns_server_t *)((void *)0));
  }
  {
#line 380
  spfhook->nxdomain = SPF_dns_rr_new_init(spf_dns_server, "", (ns_type )255, 86400,
                                          1);
  }
#line 382
  if ((unsigned long )spfhook->nxdomain == (unsigned long )((void *)0)) {
    {
#line 383
    free((void *)spfhook->zone);
#line 384
    free((void *)spfhook);
#line 385
    free((void *)spf_dns_server);
    }
#line 386
    return ((SPF_dns_server_t *)((void *)0));
  }
#line 389
  return (spf_dns_server);
}
}
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 196 "../../src/include/spf_response.h"
SPF_response_t *SPF_response_new(SPF_request_t *spf_request ) ;
#line 234
SPF_errcode_t SPF_response_add_error(SPF_response_t *rp , SPF_errcode_t code , char const   *format 
                                     , ...) ;
#line 230 "../../src/include/spf_record.h"
void SPF_record_free(SPF_record_t *rp ) ;
#line 231
void SPF_macro_free(SPF_macro_t *mac ) ;
#line 246
SPF_errcode_t SPF_record_compile(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                 SPF_record_t **spf_recordp , char const   *record ) ;
#line 250
SPF_errcode_t SPF_record_compile_macro(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                       SPF_macro_t **spf_macrop , char const   *record ) ;
#line 129 "../../src/include/spf_dns.h"
void SPF_dns_free(SPF_dns_server_t *spf_dns_server ) ;
#line 77 "../../src/include/spf_server.h"
SPF_server_t *SPF_server_new_dns(SPF_dns_server_t *dns , int debug ) ;
#line 89
SPF_errcode_t SPF_server_get_record(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                                    SPF_response_t *spf_response , SPF_record_t **spf_recordp ) ;
#line 103
int SPF_server_get_max_dns_mech(SPF_server_t *s ) ;
#line 104
SPF_errcode_t SPF_server_set_max_dns_ptr(SPF_server_t *s , int n ) ;
#line 104
int SPF_server_get_max_dns_ptr(SPF_server_t *s ) ;
#line 105
SPF_errcode_t SPF_server_set_max_dns_mx(SPF_server_t *s , int n ) ;
#line 105
int SPF_server_get_max_dns_mx(SPF_server_t *s ) ;
#line 43 "../../src/include/spf_dns_resolv.h"
SPF_dns_server_t *SPF_dns_resolv_new(SPF_dns_server_t *layer_below , char const   *name ,
                                     int debug ) ;
#line 57 "../../src/include/spf_dns_cache.h"
SPF_dns_server_t *SPF_dns_cache_new(SPF_dns_server_t *layer_below , char const   *name ,
                                    int debug , int cache_bits ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_server_set_rec_dom_ghbn)(SPF_server_t *sp ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 70
  tmp = malloc((size_t )64);
#line 70
  sp->rec_dom = (char *)tmp;
  }
#line 71
  if (! sp->rec_dom) {
#line 72
    return ((SPF_errcode_t )1);
  }
  {
#line 77
  tmp___0 = gethostname(sp->rec_dom, (size_t )64);
  }
#line 77
  if (tmp___0 < 0) {
#line 79
    return ((SPF_errcode_t )10);
  }
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static void SPF_server_new_common_pre(SPF_server_t *sp , int debug ) 
{ 
  SPF_errcode_t err ;

  {
  {
#line 89
  memset((void *)sp, 0, sizeof(SPF_server_t ));
#line 91
  sp->max_dns_mech = 10;
#line 92
  sp->max_dns_ptr = 10;
#line 93
  sp->max_dns_mx = 10;
#line 94
  sp->debug = debug;
#line 96
  err = SPF_server_set_rec_dom_ghbn(sp);
  }
#line 97
  if ((unsigned int )err != 0U) {
    {
#line 98
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               98, "%s", "Failed to set rec_dom using gethostname()");
    }
  }
#line 99
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static void SPF_server_new_common_post(SPF_server_t *sp ) 
{ 
  SPF_response_t *spf_response ;
  SPF_errcode_t err ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 107
  spf_response = (SPF_response_t *)((void *)0);
#line 108
  err = SPF_server_set_explanation(sp, "Please%_see%_http://www.openspf.org/Why?id=%{S}&ip=%{C}&receiver=%{R}",
                                   & spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
    {
#line 111
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               111, "Error code %d compiling default explanation", (unsigned int )err);
    }
  }
#line 112
  if (spf_response) {
    {
#line 114
    tmp = SPF_response_messages(spf_response);
    }
#line 114
    if (tmp > 0) {
      {
#line 115
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 115, "%s", "Response errors compiling default explanation");
      }
    }
    {
#line 116
    SPF_response_free(spf_response);
    }
  }
  {
#line 119
  spf_response = (SPF_response_t *)((void *)0);
#line 120
  err = SPF_server_set_localpolicy(sp, "", 0, & spf_response);
  }
#line 121
  if ((unsigned int )err != 0U) {
    {
#line 122
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               122, "Error code %d compiling default whitelist", (unsigned int )err);
    }
  }
#line 123
  if (spf_response) {
    {
#line 125
    tmp___0 = SPF_response_messages(spf_response);
    }
#line 125
    if (tmp___0 > 0) {
      {
#line 126
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 126, "%s", "Response errors compiling default whitelist");
      }
    }
    {
#line 127
    SPF_response_free(spf_response);
    }
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
SPF_server_t *SPF_server_new(SPF_server_dnstype_t dnstype , int debug ) 
{ 
  SPF_dns_server_t *dc_r ;
  SPF_dns_server_t *dc_c ;
  SPF_dns_server_t *dc_z ;
  SPF_server_t *sp ;
  void *tmp ;

  {
  {
#line 139
  tmp = malloc(sizeof(SPF_server_t ));
#line 139
  sp = (SPF_server_t *)tmp;
  }
#line 140
  if (! sp) {
#line 141
    return (sp);
  }
  {
#line 142
  SPF_server_new_common_pre(sp, debug);
#line 143
  sp->destroy_resolver = 1;
  }
  {
#line 146
  if ((unsigned int )dnstype == 0U) {
#line 146
    goto case_0;
  }
#line 153
  if ((unsigned int )dnstype == 1U) {
#line 153
    goto case_1;
  }
#line 163
  if ((unsigned int )dnstype == 2U) {
#line 163
    goto case_2;
  }
#line 170
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 147
  dc_r = SPF_dns_resolv_new((SPF_dns_server_t *)((void *)0), (char const   *)((void *)0),
                            debug);
  }
#line 148
  if ((unsigned long )dc_r == (unsigned long )((void *)0)) {
    {
#line 149
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               149, "%s", "Failed to create DNS resolver");
    }
  }
#line 150
  sp->resolver = dc_r;
#line 151
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 154
  dc_r = SPF_dns_resolv_new((SPF_dns_server_t *)((void *)0), (char const   *)((void *)0),
                            debug);
  }
#line 155
  if ((unsigned long )dc_r == (unsigned long )((void *)0)) {
    {
#line 156
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               156, "%s", "Failed to create DNS resolver");
    }
  }
  {
#line 157
  dc_c = SPF_dns_cache_new(dc_r, (char const   *)((void *)0), debug, 8);
  }
#line 158
  if ((unsigned long )dc_c == (unsigned long )((void *)0)) {
    {
#line 159
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               159, "%s", "Failed to create DNS cache");
    }
  }
#line 160
  sp->resolver = dc_c;
#line 161
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 164
  dc_z = SPF_dns_zone_new((SPF_dns_server_t *)((void *)0), (char const   *)((void *)0),
                          debug);
  }
#line 165
  if ((unsigned long )dc_z == (unsigned long )((void *)0)) {
    {
#line 166
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               166, "%s", "Failed to create DNS zone");
    }
  }
#line 167
  sp->resolver = dc_z;
#line 168
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 171
  SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
             171, "Unknown DNS type %d", (unsigned int )dnstype);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 174
  SPF_server_new_common_post(sp);
  }
#line 176
  return (sp);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
SPF_server_t *SPF_server_new_dns(SPF_dns_server_t *dns , int debug ) 
{ 
  SPF_server_t *sp ;
  void *tmp ;

  {
  {
#line 184
  tmp = malloc(sizeof(SPF_server_t ));
#line 184
  sp = (SPF_server_t *)tmp;
  }
#line 185
  if (! sp) {
#line 186
    return (sp);
  }
  {
#line 187
  SPF_server_new_common_pre(sp, debug);
#line 188
  sp->destroy_resolver = 0;
#line 189
  sp->resolver = dns;
#line 190
  SPF_server_new_common_post(sp);
  }
#line 191
  return (sp);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
void SPF_server_free(SPF_server_t *sp ) 
{ 


  {
#line 202
  if (sp->resolver) {
#line 202
    if (sp->destroy_resolver) {
      {
#line 203
      SPF_dns_free(sp->resolver);
      }
    }
  }
#line 204
  if (sp->local_policy) {
    {
#line 205
    SPF_record_free(sp->local_policy);
    }
  }
#line 206
  if (sp->explanation) {
    {
#line 207
    SPF_macro_free(sp->explanation);
    }
  }
#line 208
  if (sp->rec_dom) {
    {
#line 209
    free((void *)sp->rec_dom);
    }
  }
  {
#line 211
  free((void *)sp);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
SPF_errcode_t SPF_server_set_rec_dom(SPF_server_t *sp , char const   *dom ) 
{ 
  SPF_errcode_t tmp ;

  {
#line 217
  if (sp->rec_dom) {
    {
#line 218
    free((void *)sp->rec_dom);
    }
  }
#line 219
  if ((unsigned long )dom == (unsigned long )((void *)0)) {
    {
#line 220
    tmp = SPF_server_set_rec_dom_ghbn(sp);
    }
#line 220
    return (tmp);
  }
  {
#line 221
  sp->rec_dom = strdup(dom);
  }
#line 222
  if (! sp->rec_dom) {
#line 223
    return ((SPF_errcode_t )1);
  }
#line 224
  return ((SPF_errcode_t )0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
SPF_errcode_t SPF_server_set_sanitize(SPF_server_t *sp , int sanitize ) 
{ 


  {
#line 230
  sp->sanitize = sanitize;
#line 231
  return ((SPF_errcode_t )0);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
SPF_errcode_t SPF_server_set_explanation(SPF_server_t *sp , char const   *exp , SPF_response_t **spf_responsep ) 
{ 
  SPF_macro_t *spf_macro ;
  SPF_errcode_t err ;

  {
#line 238
  spf_macro = (SPF_macro_t *)((void *)0);
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if ((unsigned long )exp == (unsigned long )((void *)0)) {
      {
#line 241
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 241, "%s", "exp is NULL");
      }
    }
#line 241
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  if (! *spf_responsep) {
    {
#line 245
    *spf_responsep = SPF_response_new((SPF_request_t *)((void *)0));
    }
#line 246
    if (! *spf_responsep) {
#line 247
      return ((SPF_errcode_t )1);
    }
  }
  {
#line 250
  err = SPF_record_compile_macro(sp, *spf_responsep, & spf_macro, exp);
  }
#line 251
  if ((unsigned int )err == 0U) {
#line 252
    if (sp->explanation) {
      {
#line 253
      SPF_macro_free(sp->explanation);
      }
    }
#line 254
    sp->explanation = spf_macro;
  } else {
    {
#line 257
    SPF_response_add_error(*spf_responsep, err, "Failed to compile explanation \'%s\'",
                           exp);
    }
#line 259
    if (spf_macro) {
      {
#line 260
      SPF_macro_free(spf_macro);
      }
    }
  }
#line 263
  return (err);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
SPF_errcode_t SPF_server_set_localpolicy(SPF_server_t *sp , char const   *policy ,
                                         int use_default_whitelist , SPF_response_t **spf_responsep ) 
{ 
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  char *record ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 271
  spf_record = (SPF_record_t *)((void *)0);
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if ((unsigned long )policy == (unsigned long )((void *)0)) {
      {
#line 276
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 276, "%s", "policy is NULL");
      }
    }
#line 276
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  if (! *spf_responsep) {
    {
#line 280
    *spf_responsep = SPF_response_new((SPF_request_t *)((void *)0));
    }
#line 281
    if (! *spf_responsep) {
#line 282
      return ((SPF_errcode_t )1);
    }
  }
  {
#line 285
  tmp = strlen(policy);
#line 285
  len = (sizeof("v=spf1") + tmp) + 20UL;
  }
#line 286
  if (use_default_whitelist) {
#line 287
    len += sizeof("include:spf.trusted-forwarder.org");
  }
  {
#line 288
  tmp___0 = malloc(len);
#line 288
  record = (char *)tmp___0;
  }
#line 289
  if (! record) {
#line 290
    return ((SPF_errcode_t )1);
  }
#line 291
  if (use_default_whitelist) {
    {
#line 292
    snprintf((char */* __restrict  */)record, len, (char const   */* __restrict  */)"%s %s %s",
             "v=spf1", policy, "include:spf.trusted-forwarder.org");
    }
  } else {
    {
#line 295
    snprintf((char */* __restrict  */)record, len, (char const   */* __restrict  */)"%s %s",
             "v=spf1", policy);
    }
  }
  {
#line 297
  err = SPF_record_compile(sp, *spf_responsep, & spf_record, (char const   *)record);
  }
#line 298
  if ((unsigned int )err == 0U) {
#line 299
    if (sp->local_policy) {
      {
#line 300
      SPF_record_free(sp->local_policy);
      }
    }
#line 301
    sp->local_policy = spf_record;
  } else {
    {
#line 304
    SPF_response_add_error(*spf_responsep, err, "Failed to compile local policy \'%s\'",
                           policy);
    }
#line 306
    if (spf_record) {
      {
#line 307
      SPF_record_free(spf_record);
      }
    }
  }
  {
#line 310
  free((void *)record);
  }
#line 312
  return (err);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
SPF_errcode_t SPF_server_get_record(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                                    SPF_response_t *spf_response , SPF_record_t **spf_recordp ) 
{ 
  SPF_dns_server_t *resolver ;
  SPF_dns_rr_t *rr_txt ;
  SPF_errcode_t err ;
  SPF_dns_stat_t herrno ;
  char const   *domain ;
  ns_type rr_type ;
  int num_found ;
  int idx_found ;
  int i ;
  SPF_errcode_t tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;
  SPF_errcode_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  char e ;
  int tmp___6 ;
  SPF_errcode_t tmp___7 ;
  SPF_errcode_t tmp___8 ;
  SPF_errcode_t tmp___9 ;

  {
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 332
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 332, "%s", "spf_server is NULL");
      }
    }
#line 332
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 333
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 333
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 333, "%s", "spf_request is NULL");
      }
    }
#line 333
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 334
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 334
    if ((unsigned long )spf_server___1->resolver == (unsigned long )((void *)0)) {
      {
#line 334
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 334, "%s", "spf_server->resolver is NULL");
      }
    }
#line 334
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 335
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 335
    if ((unsigned long )spf_recordp == (unsigned long )((void *)0)) {
      {
#line 335
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 335, "%s", "spf_recordp is NULL");
      }
    }
#line 335
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 337
  domain = spf_request->cur_dom;
  {
#line 338
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 338
    if ((unsigned long )domain == (unsigned long )((void *)0)) {
      {
#line 338
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 338, "%s", "domain is NULL");
      }
    }
#line 338
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 340
  *spf_recordp = (SPF_record_t *)((void *)0);
#line 342
  resolver = spf_server___1->resolver;
#line 344
  if (resolver->get_spf) {
    {
#line 345
    tmp = (*(resolver->get_spf))(spf_server___1, spf_request, spf_response, spf_recordp);
    }
#line 345
    return (tmp);
  }
#line 349
  rr_type = (ns_type )99;
  retry: 
  {
#line 351
  rr_txt = SPF_dns_lookup(resolver, domain, rr_type, 1);
  }
  {
#line 354
  if (rr_txt->herrno == 1) {
#line 354
    goto case_1;
  }
#line 368
  if (rr_txt->herrno == 4) {
#line 368
    goto case_4;
  }
#line 382
  if (rr_txt->herrno == 2) {
#line 382
    goto case_2;
  }
#line 390
  if (rr_txt->herrno == 3) {
#line 390
    goto case_3;
  }
#line 398
  if (rr_txt->herrno == 0) {
#line 398
    goto case_0;
  }
#line 403
  goto switch_default;
  case_1: /* CIL Label */ 
#line 355
  if (spf_server___1->debug > 0) {
    {
#line 356
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               356, "get_record(%s): HOST_NOT_FOUND", domain);
    }
  }
  {
#line 357
  SPF_dns_rr_free(rr_txt);
  }
#line 358
  if ((unsigned int )rr_type == 99U) {
#line 359
    rr_type = (ns_type )16;
#line 360
    goto retry;
  }
  {
#line 362
  spf_response->result = (SPF_result_t )5;
#line 363
  spf_response->reason = (SPF_reason_t )1;
#line 364
  tmp___0 = SPF_response_add_error(spf_response, (SPF_errcode_t )2, "Host \'%s\' not found.",
                                   domain);
  }
#line 364
  return (tmp___0);
  case_4: /* CIL Label */ 
#line 369
  if (spf_server___1->debug > 0) {
    {
#line 370
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               370, "get_record(%s): NO_DATA", domain);
    }
  }
  {
#line 371
  SPF_dns_rr_free(rr_txt);
  }
#line 372
  if ((unsigned int )rr_type == 99U) {
#line 373
    rr_type = (ns_type )16;
#line 374
    goto retry;
  }
  {
#line 376
  spf_response->result = (SPF_result_t )5;
#line 377
  spf_response->reason = (SPF_reason_t )1;
#line 378
  tmp___1 = SPF_response_add_error(spf_response, (SPF_errcode_t )2, "No DNS data for \'%s\'.",
                                   domain);
  }
#line 378
  return (tmp___1);
  case_2: /* CIL Label */ 
#line 383
  if (spf_server___1->debug > 0) {
    {
#line 384
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               384, "get_record(%s): TRY_AGAIN", domain);
    }
  }
  {
#line 385
  SPF_dns_rr_free(rr_txt);
#line 386
  tmp___2 = SPF_response_add_error(spf_response, (SPF_errcode_t )26, "Temporary DNS failure for \'%s\'.",
                                   domain);
  }
#line 386
  return (tmp___2);
  case_3: /* CIL Label */ 
#line 391
  if (spf_server___1->debug > 0) {
    {
#line 392
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               392, "get_record(%s): NO_RECOERY", domain);
    }
  }
  {
#line 393
  SPF_dns_rr_free(rr_txt);
#line 394
  tmp___3 = SPF_response_add_error(spf_response, (SPF_errcode_t )26, "Unrecoverable DNS failure for \'%s\'.",
                                   domain);
  }
#line 394
  return (tmp___3);
  case_0: /* CIL Label */ 
#line 399
  if (spf_server___1->debug > 0) {
    {
#line 400
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               400, "get_record(%s): NETDB_SUCCESS", domain);
    }
  }
#line 401
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 404
  if (spf_server___1->debug > 0) {
    {
#line 405
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               405, "get_record(%s): UNKNOWN_ERROR", domain);
    }
  }
  {
#line 406
  herrno = rr_txt->herrno;
#line 407
  SPF_dns_rr_free(rr_txt);
#line 408
  tmp___4 = SPF_response_add_error(spf_response, (SPF_errcode_t )26, "Unknown DNS failure for \'%s\': %d.",
                                   domain, herrno);
  }
#line 408
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
#line 414
  if (rr_txt->num_rr == 0) {
    {
#line 415
    SPF_dns_rr_free(rr_txt);
    }
#line 416
    if ((unsigned int )rr_type == 99U) {
#line 417
      rr_type = (ns_type )16;
#line 418
      goto retry;
    }
    {
#line 420
    tmp___5 = SPF_response_add_error(spf_response, (SPF_errcode_t )2, "No TXT records returned from DNS lookup for \'%s\'",
                                     domain);
    }
#line 420
    return (tmp___5);
  }
#line 426
  idx_found = 0;
#line 429
  num_found = 0;
#line 430
  i = 0;
  {
#line 430
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 430
    if (! (i < rr_txt->num_rr)) {
#line 430
      goto while_break___4;
    }
    {
#line 436
    tmp___6 = strncasecmp((char const   *)((*(rr_txt->rr + i))->txt), "v=spf1", sizeof("v=spf1") - 1UL);
    }
#line 436
    if (tmp___6 == 0) {
#line 438
      e = (*(rr_txt->rr + i))->txt[sizeof("v=spf1") - 1UL];
#line 439
      if ((int )e == 32) {
#line 439
        goto _L;
      } else
#line 439
      if ((int )e == 0) {
        _L: /* CIL Label */ 
#line 440
        if (spf_server___1->debug > 0) {
          {
#line 441
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                     441, "found SPF record: %s", (*(rr_txt->rr + i))->txt);
          }
        }
#line 442
        num_found ++;
#line 443
        idx_found = i;
      }
    }
#line 430
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 448
  if (num_found == 0) {
    {
#line 449
    SPF_dns_rr_free(rr_txt);
    }
#line 450
    if ((unsigned int )rr_type == 99U) {
#line 451
      rr_type = (ns_type )16;
#line 452
      goto retry;
    }
    {
#line 454
    spf_response->result = (SPF_result_t )5;
#line 455
    spf_response->reason = (SPF_reason_t )1;
#line 456
    tmp___7 = SPF_response_add_error(spf_response, (SPF_errcode_t )2, "No SPF records for \'%s\'",
                                     domain);
    }
#line 456
    return (tmp___7);
  }
#line 459
  if (num_found > 1) {
    {
#line 460
    SPF_dns_rr_free(rr_txt);
#line 463
    spf_response->result = (SPF_result_t )7;
#line 464
    spf_response->reason = (SPF_reason_t )1;
#line 465
    tmp___8 = SPF_response_add_error(spf_response, (SPF_errcode_t )32, "Multiple SPF records for \'%s\'",
                                     domain);
    }
#line 465
    return (tmp___8);
  }
  {
#line 470
  err = SPF_record_compile(spf_server___1, spf_response, spf_recordp, (char const   *)((*(rr_txt->rr + idx_found))->txt));
#line 473
  SPF_dns_rr_free(rr_txt);
  }
#line 476
  if ((unsigned int )err != 0U) {
    {
#line 477
    tmp___9 = SPF_response_add_error(spf_response, (SPF_errcode_t )2, "Failed to compile SPF record for \'%s\'",
                                     domain);
    }
#line 477
    return (tmp___9);
  }
#line 480
  return ((SPF_errcode_t )0);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
SPF_errcode_t SPF_server_set_max_dns_mech(SPF_server_t *s , int n ) 
{ 


  {
#line 501
  s->max_dns_mech = n;
#line 501
  return ((SPF_errcode_t )0);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
int SPF_server_get_max_dns_mech(SPF_server_t *s ) 
{ 


  {
#line 501
  return (s->max_dns_mech);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
SPF_errcode_t SPF_server_set_max_dns_ptr(SPF_server_t *s , int n ) 
{ 


  {
#line 502
  s->max_dns_ptr = n;
#line 502
  return ((SPF_errcode_t )0);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
int SPF_server_get_max_dns_ptr(SPF_server_t *s ) 
{ 


  {
#line 502
  return (s->max_dns_ptr);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
SPF_errcode_t SPF_server_set_max_dns_mx(SPF_server_t *s , int n ) 
{ 


  {
#line 503
  s->max_dns_mx = n;
#line 503
  return ((SPF_errcode_t )0);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
int SPF_server_get_max_dns_mx(SPF_server_t *s ) 
{ 


  {
#line 503
  return (s->max_dns_mx);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/arpa_nameser.h"
u_int __ns_get16(u_char const   *src ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_get16.c"
u_int __ns_get16(u_char const   *src ) 
{ 
  u_int dst ;
  register u_char const   *t_cp ;

  {
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    t_cp = src;
#line 20
    dst = (u_int )(((int )((u_int16_t )*(t_cp + 0)) << 8) | (int )((u_int16_t )*(t_cp + 1)));
#line 20
    src += 2;
#line 20
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 21
  return (dst);
}
}
#line 578 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/arpa_nameser.h"
int __ns_name_ntol(u_char const   *src , u_char *dst , size_t dstsiz ) ;
#line 579
int __ns_name_ntop(u_char const   *src , char *dst , size_t dstsiz ) ;
#line 580
int __ns_name_pton(char const   *src , u_char *dst , size_t dstsiz ) ;
#line 581
int __ns_name_unpack(u_char const   *msg , u_char const   *eom , u_char const   *src ,
                     u_char *dst , size_t dstsiz ) ;
#line 583
int __ns_name_pack(u_char const   *src , u_char *dst , int dstsiz , u_char const   **dnptrs ,
                   u_char const   **lastdnptr ) ;
#line 585
int __ns_name_uncompress(u_char const   *msg , u_char const   *eom , u_char const   *src ,
                         char *dst , size_t dstsiz ) ;
#line 587
int __ns_name_compress(char const   *src , u_char *dst , size_t dstsiz , u_char const   **dnptrs ,
                       u_char const   **lastdnptr ) ;
#line 589
int __ns_name_skip(u_char const   **ptrptr , u_char const   *eom ) ;
#line 590
void __ns_name_rollback(u_char const   *src , u_char const   **dnptrs , u_char const   **lastdnptr ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static char const   digits[11]  = 
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 63 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static char const   digitvalue[256]  = 
#line 63
  {      (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )0,      (char const   )1,      (char const   )2,      (char const   )3, 
        (char const   )4,      (char const   )5,      (char const   )6,      (char const   )7, 
        (char const   )8,      (char const   )9,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )13,      (char const   )14,      (char const   )15,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )13,      (char const   )14,      (char const   )15,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1};
#line 84
static int special(int ch ) ;
#line 85
static int printable(int ch ) ;
#line 86
static int dn_find(u_char const   *domain , u_char const   *msg , u_char const   * const  *dnptrs ,
                   u_char const   * const  *lastdnptr ) ;
#line 89
static int encode_bitsring(char const   **bp , char const   *end , char **labelp ,
                           char **dst , char const   *eom ) ;
#line 91
static int labellen(u_char const   *lp ) ;
#line 92
static int decode_bitstring(char const   **cpp , char *dn , char const   *eom ) ;
#line 105 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
int __ns_name_ntop(u_char const   *src , char *dst , size_t dstsiz ) 
{ 
  u_char const   *cp ;
  char *dn ;
  char *eom ;
  u_char c ;
  u_int n ;
  int l ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int m ;
  int *tmp___4 ;
  int *tmp___5 ;
  u_char const   *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  u_char const   *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;

  {
#line 114
  cp = src;
#line 115
  dn = dst;
#line 116
  eom = dst + dstsiz;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    tmp___19 = cp;
#line 118
    cp ++;
#line 118
    n = (u_int )*tmp___19;
#line 118
    if (! (n != 0U)) {
#line 118
      goto while_break;
    }
#line 119
    if ((n & 192U) == 192U) {
      {
#line 121
      tmp = __errno_location();
#line 121
      *tmp = 90;
      }
#line 122
      return (-1);
    }
#line 124
    if ((unsigned long )dn != (unsigned long )dst) {
#line 125
      if ((unsigned long )dn >= (unsigned long )eom) {
        {
#line 126
        tmp___0 = __errno_location();
#line 126
        *tmp___0 = 90;
        }
#line 127
        return (-1);
      }
#line 129
      tmp___1 = dn;
#line 129
      dn ++;
#line 129
      *tmp___1 = (char )'.';
    }
    {
#line 131
    l = labellen(cp - 1);
    }
#line 131
    if (l < 0) {
      {
#line 132
      tmp___2 = __errno_location();
#line 132
      *tmp___2 = 90;
      }
#line 133
      return (-1);
    }
#line 135
    if ((unsigned long )(dn + l) >= (unsigned long )eom) {
      {
#line 136
      tmp___3 = __errno_location();
#line 136
      *tmp___3 = 90;
      }
#line 137
      return (-1);
    }
#line 139
    if ((n & 192U) == 64U) {
#line 142
      if (n != 65U) {
        {
#line 144
        tmp___4 = __errno_location();
#line 144
        *tmp___4 = 22;
        }
#line 145
        return (-1);
      }
      {
#line 147
      m = decode_bitstring((char const   **)(& cp), dn, (char const   *)eom);
      }
#line 147
      if (m < 0) {
        {
#line 149
        tmp___5 = __errno_location();
#line 149
        *tmp___5 = 90;
        }
#line 150
        return (-1);
      }
#line 152
      dn += m;
#line 153
      goto while_continue;
    }
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 155
      if (! (l > 0)) {
#line 155
        goto while_break___0;
      }
      {
#line 156
      tmp___6 = cp;
#line 156
      cp ++;
#line 156
      c = (u_char )*tmp___6;
#line 157
      tmp___18 = special((int )c);
      }
#line 157
      if (tmp___18) {
#line 158
        if ((unsigned long )(dn + 1) >= (unsigned long )eom) {
          {
#line 159
          tmp___7 = __errno_location();
#line 159
          *tmp___7 = 90;
          }
#line 160
          return (-1);
        }
#line 162
        tmp___8 = dn;
#line 162
        dn ++;
#line 162
        *tmp___8 = (char )'\\';
#line 163
        tmp___9 = dn;
#line 163
        dn ++;
#line 163
        *tmp___9 = (char )c;
      } else {
        {
#line 164
        tmp___17 = printable((int )c);
        }
#line 164
        if (tmp___17) {
#line 174
          if ((unsigned long )dn >= (unsigned long )eom) {
            {
#line 175
            tmp___15 = __errno_location();
#line 175
            *tmp___15 = 90;
            }
#line 176
            return (-1);
          }
#line 178
          tmp___16 = dn;
#line 178
          dn ++;
#line 178
          *tmp___16 = (char )c;
        } else {
#line 165
          if ((unsigned long )(dn + 3) >= (unsigned long )eom) {
            {
#line 166
            tmp___10 = __errno_location();
#line 166
            *tmp___10 = 90;
            }
#line 167
            return (-1);
          }
#line 169
          tmp___11 = dn;
#line 169
          dn ++;
#line 169
          *tmp___11 = (char )'\\';
#line 170
          tmp___12 = dn;
#line 170
          dn ++;
#line 170
          *tmp___12 = (char )digits[(int )c / 100];
#line 171
          tmp___13 = dn;
#line 171
          dn ++;
#line 171
          *tmp___13 = (char )digits[((int )c % 100) / 10];
#line 172
          tmp___14 = dn;
#line 172
          dn ++;
#line 172
          *tmp___14 = (char )digits[(int )c % 10];
        }
      }
#line 155
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  if ((unsigned long )dn == (unsigned long )dst) {
#line 183
    if ((unsigned long )dn >= (unsigned long )eom) {
      {
#line 184
      tmp___20 = __errno_location();
#line 184
      *tmp___20 = 90;
      }
#line 185
      return (-1);
    }
#line 187
    tmp___21 = dn;
#line 187
    dn ++;
#line 187
    *tmp___21 = (char )'.';
  }
#line 189
  if ((unsigned long )dn >= (unsigned long )eom) {
    {
#line 190
    tmp___22 = __errno_location();
#line 190
    *tmp___22 = 90;
    }
#line 191
    return (-1);
  }
#line 193
  tmp___23 = dn;
#line 193
  dn ++;
#line 193
  *tmp___23 = (char )'\000';
#line 194
  return ((int )(dn - dst));
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
int __ns_name_pton(char const   *src , u_char *dst , size_t dstsiz ) 
{ 
  u_char *label ;
  u_char *bp ;
  u_char *eom ;
  int c ;
  int n ;
  int escaped ;
  int e ;
  char *cp ;
  u_char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  u_char *tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  u_char *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  u_char *tmp___16 ;
  int *tmp___17 ;
  u_char *tmp___18 ;
  char const   *tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  int *tmp___22 ;
  u_char *tmp___23 ;
  int *tmp___24 ;

  {
#line 212
  e = 0;
#line 215
  escaped = 0;
#line 216
  bp = dst;
#line 217
  eom = dst + dstsiz;
#line 218
  tmp = bp;
#line 218
  bp ++;
#line 218
  label = tmp;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    tmp___19 = src;
#line 220
    src ++;
#line 220
    c = (int )*tmp___19;
#line 220
    if (! (c != 0)) {
#line 220
      goto while_break;
    }
#line 221
    if (escaped) {
#line 222
      if (c == 91) {
        {
#line 223
        cp = strchr(src, ']');
        }
#line 223
        if ((unsigned long )cp == (unsigned long )((void *)0)) {
          {
#line 224
          tmp___0 = __errno_location();
#line 224
          *tmp___0 = 22;
          }
#line 225
          return (-1);
        }
        {
#line 227
        e = encode_bitsring(& src, (char const   *)(cp + 2), (char **)(& label), (char **)(& bp),
                            (char const   *)eom);
        }
#line 227
        if (e != 0) {
          {
#line 233
          tmp___1 = __errno_location();
#line 233
          *tmp___1 = e;
          }
#line 234
          return (-1);
        }
#line 236
        escaped = 0;
#line 237
        tmp___2 = bp;
#line 237
        bp ++;
#line 237
        label = tmp___2;
#line 238
        tmp___4 = src;
#line 238
        src ++;
#line 238
        c = (int )*tmp___4;
#line 238
        if (c == 0) {
#line 239
          goto done;
        } else
#line 240
        if (c != 46) {
          {
#line 241
          tmp___3 = __errno_location();
#line 241
          *tmp___3 = 22;
          }
#line 242
          return (-1);
        }
#line 244
        goto while_continue;
      } else {
        {
#line 246
        cp = strchr(digits, c);
        }
#line 246
        if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 247
          n = (int )((cp - (char *)(digits)) * 100L);
#line 248
          tmp___6 = src;
#line 248
          src ++;
#line 248
          c = (int )*tmp___6;
#line 248
          if (c == 0) {
            {
#line 250
            tmp___5 = __errno_location();
#line 250
            *tmp___5 = 90;
            }
#line 251
            return (-1);
          } else {
            {
#line 248
            cp = strchr(digits, c);
            }
#line 248
            if ((unsigned long )cp == (unsigned long )((void *)0)) {
              {
#line 250
              tmp___5 = __errno_location();
#line 250
              *tmp___5 = 90;
              }
#line 251
              return (-1);
            }
          }
#line 253
          n = (int )((long )n + (cp - (char *)(digits)) * 10L);
#line 254
          tmp___8 = src;
#line 254
          src ++;
#line 254
          c = (int )*tmp___8;
#line 254
          if (c == 0) {
            {
#line 256
            tmp___7 = __errno_location();
#line 256
            *tmp___7 = 90;
            }
#line 257
            return (-1);
          } else {
            {
#line 254
            cp = strchr(digits, c);
            }
#line 254
            if ((unsigned long )cp == (unsigned long )((void *)0)) {
              {
#line 256
              tmp___7 = __errno_location();
#line 256
              *tmp___7 = 90;
              }
#line 257
              return (-1);
            }
          }
#line 259
          n = (int )((long )n + (cp - (char *)(digits)));
#line 260
          if (n > 255) {
            {
#line 261
            tmp___9 = __errno_location();
#line 261
            *tmp___9 = 90;
            }
#line 262
            return (-1);
          }
#line 264
          c = n;
        }
      }
#line 266
      escaped = 0;
    } else
#line 267
    if (c == 92) {
#line 268
      escaped = 1;
#line 269
      goto while_continue;
    } else
#line 270
    if (c == 46) {
#line 271
      c = (int )((bp - label) - 1L);
#line 272
      if ((c & 192) != 0) {
        {
#line 273
        tmp___10 = __errno_location();
#line 273
        *tmp___10 = 90;
        }
#line 274
        return (-1);
      }
#line 276
      if ((unsigned long )label >= (unsigned long )eom) {
        {
#line 277
        tmp___11 = __errno_location();
#line 277
        *tmp___11 = 90;
        }
#line 278
        return (-1);
      }
#line 280
      *label = (u_char )c;
#line 282
      if ((int const   )*src == 0) {
#line 283
        if (c != 0) {
#line 284
          if ((unsigned long )bp >= (unsigned long )eom) {
            {
#line 285
            tmp___12 = __errno_location();
#line 285
            *tmp___12 = 90;
            }
#line 286
            return (-1);
          }
#line 288
          tmp___13 = bp;
#line 288
          bp ++;
#line 288
          *tmp___13 = (u_char )'\000';
        }
#line 290
        if (bp - dst > 255L) {
          {
#line 291
          tmp___14 = __errno_location();
#line 291
          *tmp___14 = 90;
          }
#line 292
          return (-1);
        }
#line 294
        return (1);
      }
#line 296
      if (c == 0) {
        {
#line 297
        tmp___15 = __errno_location();
#line 297
        *tmp___15 = 90;
        }
#line 298
        return (-1);
      } else
#line 296
      if ((int const   )*src == 46) {
        {
#line 297
        tmp___15 = __errno_location();
#line 297
        *tmp___15 = 90;
        }
#line 298
        return (-1);
      }
#line 300
      tmp___16 = bp;
#line 300
      bp ++;
#line 300
      label = tmp___16;
#line 301
      goto while_continue;
    }
#line 303
    if ((unsigned long )bp >= (unsigned long )eom) {
      {
#line 304
      tmp___17 = __errno_location();
#line 304
      *tmp___17 = 90;
      }
#line 305
      return (-1);
    }
#line 307
    tmp___18 = bp;
#line 307
    bp ++;
#line 307
    *tmp___18 = (u_char )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  c = (int )((bp - label) - 1L);
#line 310
  if ((c & 192) != 0) {
    {
#line 311
    tmp___20 = __errno_location();
#line 311
    *tmp___20 = 90;
    }
#line 312
    return (-1);
  }
  done: 
#line 315
  if ((unsigned long )label >= (unsigned long )eom) {
    {
#line 316
    tmp___21 = __errno_location();
#line 316
    *tmp___21 = 90;
    }
#line 317
    return (-1);
  }
#line 319
  *label = (u_char )c;
#line 320
  if (c != 0) {
#line 321
    if ((unsigned long )bp >= (unsigned long )eom) {
      {
#line 322
      tmp___22 = __errno_location();
#line 322
      *tmp___22 = 90;
      }
#line 323
      return (-1);
    }
#line 325
    tmp___23 = bp;
#line 325
    bp ++;
#line 325
    *tmp___23 = (u_char )0;
  }
#line 327
  if (bp - dst > 255L) {
    {
#line 328
    tmp___24 = __errno_location();
#line 328
    *tmp___24 = 90;
    }
#line 329
    return (-1);
  }
#line 331
  return (0);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
int __ns_name_ntol(u_char const   *src , u_char *dst , size_t dstsiz ) 
{ 
  u_char const   *cp ;
  u_char *dn ;
  u_char *eom ;
  u_char c ;
  u_int n ;
  int l ;
  int *tmp ;
  int *tmp___0 ;
  u_char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  u_char const   *tmp___4 ;
  u_char *tmp___5 ;
  int tmp___6 ;
  u_char *tmp___7 ;
  unsigned short const   **tmp___8 ;
  u_char const   *tmp___9 ;
  u_char *tmp___10 ;

  {
#line 352
  cp = src;
#line 353
  dn = dst;
#line 354
  eom = dst + dstsiz;
#line 356
  if ((unsigned long )dn >= (unsigned long )eom) {
    {
#line 357
    tmp = __errno_location();
#line 357
    *tmp = 90;
    }
#line 358
    return (-1);
  }
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    tmp___9 = cp;
#line 360
    cp ++;
#line 360
    n = (u_int )*tmp___9;
#line 360
    if (! (n != 0U)) {
#line 360
      goto while_break;
    }
#line 361
    if ((n & 192U) == 192U) {
      {
#line 363
      tmp___0 = __errno_location();
#line 363
      *tmp___0 = 90;
      }
#line 364
      return (-1);
    }
    {
#line 366
    tmp___1 = dn;
#line 366
    dn ++;
#line 366
    *tmp___1 = (u_char )n;
#line 367
    l = labellen(cp - 1);
    }
#line 367
    if (l < 0) {
      {
#line 368
      tmp___2 = __errno_location();
#line 368
      *tmp___2 = 90;
      }
#line 369
      return (-1);
    }
#line 371
    if ((unsigned long )(dn + l) >= (unsigned long )eom) {
      {
#line 372
      tmp___3 = __errno_location();
#line 372
      *tmp___3 = 90;
      }
#line 373
      return (-1);
    }
    {
#line 375
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 375
      if (! (l > 0)) {
#line 375
        goto while_break___0;
      }
      {
#line 376
      tmp___4 = cp;
#line 376
      cp ++;
#line 376
      c = (u_char )*tmp___4;
#line 377
      tmp___8 = __ctype_b_loc();
      }
#line 377
      if ((int const   )*(*tmp___8 + (int )c) & 256) {
        {
#line 378
        tmp___5 = dn;
#line 378
        dn ++;
#line 378
        tmp___6 = tolower((int )c);
#line 378
        *tmp___5 = (u_char )tmp___6;
        }
      } else {
#line 380
        tmp___7 = dn;
#line 380
        dn ++;
#line 380
        *tmp___7 = c;
      }
#line 375
      l --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  tmp___10 = dn;
#line 383
  dn ++;
#line 383
  *tmp___10 = (u_char )'\000';
#line 384
  return ((int )(dn - dst));
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
int __ns_name_unpack(u_char const   *msg , u_char const   *eom , u_char const   *src ,
                     u_char *dst , size_t dstsiz ) 
{ 
  u_char const   *srcp ;
  u_char const   *dstlim ;
  u_char *dstp ;
  int n ;
  int len ;
  int checked ;
  int l ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  u_char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  u_char const   *tmp___7 ;

  {
#line 401
  len = -1;
#line 402
  checked = 0;
#line 403
  dstp = dst;
#line 404
  srcp = src;
#line 405
  dstlim = (u_char const   *)(dst + dstsiz);
#line 406
  if ((unsigned long )srcp < (unsigned long )msg) {
    {
#line 407
    tmp = __errno_location();
#line 407
    *tmp = 90;
    }
#line 408
    return (-1);
  } else
#line 406
  if ((unsigned long )srcp >= (unsigned long )eom) {
    {
#line 407
    tmp = __errno_location();
#line 407
    *tmp = 90;
    }
#line 408
    return (-1);
  }
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    tmp___7 = srcp;
#line 411
    srcp ++;
#line 411
    n = (int )*tmp___7;
#line 411
    if (! (n != 0)) {
#line 411
      goto while_break;
    }
    {
#line 415
    if ((n & 192) == 64) {
#line 415
      goto case_64;
    }
#line 415
    if ((n & 192) == 0) {
#line 415
      goto case_64;
    }
#line 432
    if ((n & 192) == 192) {
#line 432
      goto case_192;
    }
#line 456
    goto switch_default;
    case_64: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 417
    l = labellen(srcp - 1);
    }
#line 417
    if (l < 0) {
      {
#line 418
      tmp___0 = __errno_location();
#line 418
      *tmp___0 = 90;
      }
#line 419
      return (-1);
    }
#line 421
    if ((unsigned long )((dstp + l) + 1) >= (unsigned long )dstlim) {
      {
#line 422
      tmp___1 = __errno_location();
#line 422
      *tmp___1 = 90;
      }
#line 423
      return (-1);
    } else
#line 421
    if ((unsigned long )(srcp + l) >= (unsigned long )eom) {
      {
#line 422
      tmp___1 = __errno_location();
#line 422
      *tmp___1 = 90;
      }
#line 423
      return (-1);
    }
    {
#line 425
    checked += l + 1;
#line 426
    tmp___2 = dstp;
#line 426
    dstp ++;
#line 426
    *tmp___2 = (u_char )n;
#line 427
    memcpy((void */* __restrict  */)dstp, (void const   */* __restrict  */)srcp, (size_t )l);
#line 428
    dstp += l;
#line 429
    srcp += l;
    }
#line 430
    goto switch_break;
    case_192: /* CIL Label */ 
#line 433
    if ((unsigned long )srcp >= (unsigned long )eom) {
      {
#line 434
      tmp___3 = __errno_location();
#line 434
      *tmp___3 = 90;
      }
#line 435
      return (-1);
    }
#line 437
    if (len < 0) {
#line 438
      len = (int )((srcp - src) + 1L);
    }
#line 439
    srcp = msg + (((n & 63) << 8) | (int )((int const   )*srcp & 255));
#line 440
    if ((unsigned long )srcp < (unsigned long )msg) {
      {
#line 441
      tmp___4 = __errno_location();
#line 441
      *tmp___4 = 90;
      }
#line 442
      return (-1);
    } else
#line 440
    if ((unsigned long )srcp >= (unsigned long )eom) {
      {
#line 441
      tmp___4 = __errno_location();
#line 441
      *tmp___4 = 90;
      }
#line 442
      return (-1);
    }
#line 444
    checked += 2;
#line 450
    if ((long )checked >= eom - msg) {
      {
#line 451
      tmp___5 = __errno_location();
#line 451
      *tmp___5 = 90;
      }
#line 452
      return (-1);
    }
#line 454
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 457
    tmp___6 = __errno_location();
#line 457
    *tmp___6 = 90;
    }
#line 458
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  *dstp = (u_char )'\000';
#line 462
  if (len < 0) {
#line 463
    len = (int )(srcp - src);
  }
#line 464
  return (len);
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
int __ns_name_pack(u_char const   *src , u_char *dst , int dstsiz , u_char const   **dnptrs ,
                   u_char const   **lastdnptr ) 
{ 
  u_char *dstp ;
  u_char const   **cpp ;
  u_char const   **lpp ;
  u_char const   *eob ;
  u_char const   *msg ;
  u_char const   *srcp ;
  int n ;
  int l ;
  int first ;
  u_char const   **tmp ;
  int l0 ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char const   **tmp___5 ;
  int *tmp___6 ;

  {
#line 491
  first = 1;
#line 493
  srcp = src;
#line 494
  dstp = dst;
#line 495
  eob = (u_char const   *)(dstp + dstsiz);
#line 496
  cpp = (u_char const   **)((void *)0);
#line 496
  lpp = cpp;
#line 497
  if ((unsigned long )dnptrs != (unsigned long )((void *)0)) {
#line 498
    tmp = dnptrs;
#line 498
    dnptrs ++;
#line 498
    msg = *tmp;
#line 498
    if ((unsigned long )msg != (unsigned long )((void *)0)) {
#line 499
      cpp = dnptrs;
      {
#line 499
      while (1) {
        while_continue: /* CIL Label */ ;
#line 499
        if (! ((unsigned long )*cpp != (unsigned long )((void *)0))) {
#line 499
          goto while_break;
        }
#line 499
        cpp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 501
      lpp = cpp;
    }
  } else {
#line 504
    msg = (u_char const   *)((void *)0);
  }
#line 507
  l = 0;
  {
#line 508
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 511
    n = (int )*srcp;
#line 512
    if ((n & 192) == 192) {
      {
#line 513
      tmp___0 = __errno_location();
#line 513
      *tmp___0 = 90;
      }
#line 514
      return (-1);
    }
    {
#line 516
    l0 = labellen(srcp);
    }
#line 516
    if (l0 < 0) {
      {
#line 517
      tmp___1 = __errno_location();
#line 517
      *tmp___1 = 22;
      }
#line 518
      return (-1);
    }
#line 520
    l += l0 + 1;
#line 521
    if (l > 255) {
      {
#line 522
      tmp___2 = __errno_location();
#line 522
      *tmp___2 = 90;
      }
#line 523
      return (-1);
    }
#line 525
    srcp += l0 + 1;
#line 508
    if (! (n != 0)) {
#line 508
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 529
  srcp = src;
  {
#line 530
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 532
    n = (int )*srcp;
#line 533
    if (n != 0) {
#line 533
      if ((unsigned long )msg != (unsigned long )((void *)0)) {
        {
#line 534
        l = dn_find(srcp, msg, (u_char const   * const  *)dnptrs, (u_char const   * const  *)lpp);
        }
#line 536
        if (l >= 0) {
#line 537
          if ((unsigned long )(dstp + 1) >= (unsigned long )eob) {
#line 538
            goto cleanup;
          }
#line 540
          tmp___3 = dstp;
#line 540
          dstp ++;
#line 540
          *tmp___3 = (u_char )((l >> 8) | 192);
#line 541
          tmp___4 = dstp;
#line 541
          dstp ++;
#line 541
          *tmp___4 = (u_char )(l % 256);
#line 542
          return ((int )(dstp - dst));
        }
#line 545
        if ((unsigned long )lastdnptr != (unsigned long )((void *)0)) {
#line 545
          if ((unsigned long )cpp < (unsigned long )(lastdnptr - 1)) {
#line 545
            if (dstp - (u_char *)msg < 16384L) {
#line 545
              if (first) {
#line 547
                tmp___5 = cpp;
#line 547
                cpp ++;
#line 547
                *tmp___5 = (u_char const   *)dstp;
#line 548
                *cpp = (u_char const   *)((void *)0);
#line 549
                first = 0;
              }
            }
          }
        }
      }
    }
#line 553
    if ((n & 192) == 192) {
#line 555
      goto cleanup;
    }
    {
#line 557
    n = labellen(srcp);
    }
#line 558
    if ((unsigned long )((dstp + 1) + n) >= (unsigned long )eob) {
#line 559
      goto cleanup;
    }
    {
#line 561
    memcpy((void */* __restrict  */)dstp, (void const   */* __restrict  */)srcp, (size_t )(n + 1));
#line 562
    srcp += n + 1;
#line 563
    dstp += n + 1;
    }
#line 530
    if (! (n != 0)) {
#line 530
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 566
  if ((unsigned long )dstp > (unsigned long )eob) {
    cleanup: 
#line 568
    if ((unsigned long )msg != (unsigned long )((void *)0)) {
#line 569
      *lpp = (u_char const   *)((void *)0);
    }
    {
#line 570
    tmp___6 = __errno_location();
#line 570
    *tmp___6 = 90;
    }
#line 571
    return (-1);
  }
#line 573
  return ((int )(dstp - dst));
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
int __ns_name_uncompress(u_char const   *msg , u_char const   *eom , u_char const   *src ,
                         char *dst , size_t dstsiz ) 
{ 
  u_char tmp[255] ;
  int n ;
  int tmp___0 ;

  {
  {
#line 591
  n = __ns_name_unpack(msg, eom, src, tmp, sizeof(tmp));
  }
#line 591
  if (n == -1) {
#line 592
    return (-1);
  }
  {
#line 593
  tmp___0 = __ns_name_ntop((u_char const   *)(tmp), dst, dstsiz);
  }
#line 593
  if (tmp___0 == -1) {
#line 594
    return (-1);
  }
#line 595
  return (n);
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
int __ns_name_compress(char const   *src , u_char *dst , size_t dstsiz , u_char const   **dnptrs ,
                       u_char const   **lastdnptr ) 
{ 
  u_char tmp[255] ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 618
  tmp___0 = __ns_name_pton(src, tmp, sizeof(tmp));
  }
#line 618
  if (tmp___0 == -1) {
#line 619
    return (-1);
  }
  {
#line 620
  tmp___1 = __ns_name_pack((u_char const   *)(tmp), dst, (int )dstsiz, dnptrs, lastdnptr);
  }
#line 620
  return (tmp___1);
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
void __ns_name_rollback(u_char const   *src , u_char const   **dnptrs , u_char const   **lastdnptr ) 
{ 


  {
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if ((unsigned long )dnptrs < (unsigned long )lastdnptr) {
#line 631
      if (! ((unsigned long )*dnptrs != (unsigned long )((void *)0))) {
#line 631
        goto while_break;
      }
    } else {
#line 631
      goto while_break;
    }
#line 632
    if ((unsigned long )*dnptrs >= (unsigned long )src) {
#line 633
      *dnptrs = (u_char const   *)((void *)0);
#line 634
      goto while_break;
    }
#line 636
    dnptrs ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 638
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
int __ns_name_skip(u_char const   **ptrptr , u_char const   *eom ) 
{ 
  u_char const   *cp ;
  u_int n ;
  int l ;
  int *tmp ;
  int *tmp___0 ;
  u_char const   *tmp___1 ;
  int *tmp___2 ;

  {
#line 653
  cp = *ptrptr;
  {
#line 654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 654
    if ((unsigned long )cp < (unsigned long )eom) {
#line 654
      tmp___1 = cp;
#line 654
      cp ++;
#line 654
      n = (u_int )*tmp___1;
#line 654
      if (! (n != 0U)) {
#line 654
        goto while_break;
      }
    } else {
#line 654
      goto while_break;
    }
    {
#line 657
    if ((n & 192U) == 0U) {
#line 657
      goto case_0;
    }
#line 660
    if ((n & 192U) == 64U) {
#line 660
      goto case_64;
    }
#line 667
    if ((n & 192U) == 192U) {
#line 667
      goto case_192;
    }
#line 670
    goto switch_default;
    case_0: /* CIL Label */ 
#line 658
    cp += n;
#line 659
    goto while_continue;
    case_64: /* CIL Label */ 
    {
#line 661
    l = labellen(cp - 1);
    }
#line 661
    if (l < 0) {
      {
#line 662
      tmp = __errno_location();
#line 662
      *tmp = 90;
      }
#line 663
      return (-1);
    }
#line 665
    cp += l;
#line 666
    goto while_continue;
    case_192: /* CIL Label */ 
#line 668
    cp ++;
#line 669
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 671
    tmp___0 = __errno_location();
#line 671
    *tmp___0 = 90;
    }
#line 672
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 674
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 676
  if ((unsigned long )cp > (unsigned long )eom) {
    {
#line 677
    tmp___2 = __errno_location();
#line 677
    *tmp___2 = 90;
    }
#line 678
    return (-1);
  }
#line 680
  *ptrptr = cp;
#line 681
  return (0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int special(int ch ) 
{ 


  {
  {
#line 704
  if (ch == 36) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 64) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 41) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 40) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 92) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 59) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 46) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 34) {
#line 704
    goto case_36;
  }
#line 706
  goto switch_default;
  case_36: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_34: /* CIL Label */ 
#line 705
  return (1);
  switch_default: /* CIL Label */ 
#line 707
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int printable(int ch ) 
{ 
  int tmp ;

  {
#line 720
  if (ch > 32) {
#line 720
    if (ch < 127) {
#line 720
      tmp = 1;
    } else {
#line 720
      tmp = 0;
    }
  } else {
#line 720
    tmp = 0;
  }
#line 720
  return (tmp);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int mklower(int ch ) 
{ 


  {
#line 729
  if (ch >= 65) {
#line 729
    if (ch <= 90) {
#line 730
      return (ch + 32);
    }
  }
#line 731
  return (ch);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int dn_find(u_char const   *domain , u_char const   *msg , u_char const   * const  *dnptrs ,
                   u_char const   * const  *lastdnptr ) 
{ 
  u_char const   *dn ;
  u_char const   *cp ;
  u_char const   *sp ;
  u_char const   * const  *cpp ;
  u_int n ;
  int tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  int tmp___2 ;
  u_char const   *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  u_char const   *tmp___6 ;
  int *tmp___7 ;

  {
#line 752
  cpp = dnptrs;
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! ((unsigned long )cpp < (unsigned long )lastdnptr)) {
#line 752
      goto while_break;
    }
#line 753
    sp = (u_char const   *)*cpp;
    {
#line 760
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 760
      if ((int const   )*sp != 0) {
#line 760
        if (((int const   )*sp & 192) == 0) {
#line 760
          if (! (sp - msg < 16384L)) {
#line 760
            goto while_break___0;
          }
        } else {
#line 760
          goto while_break___0;
        }
      } else {
#line 760
        goto while_break___0;
      }
#line 762
      dn = domain;
#line 763
      cp = sp;
      {
#line 764
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 764
        tmp___6 = cp;
#line 764
        cp ++;
#line 764
        n = (u_int )*tmp___6;
#line 764
        if (! (n != 0U)) {
#line 764
          goto while_break___1;
        }
        {
#line 769
        if ((n & 192U) == 0U) {
#line 769
          goto case_0;
        }
#line 785
        if ((n & 192U) == 192U) {
#line 785
          goto case_192;
        }
#line 789
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 770
        tmp = labellen(cp - 1);
#line 770
        n = (u_int )tmp;
#line 772
        tmp___0 = dn;
#line 772
        dn ++;
        }
#line 772
        if (n != (u_int )*tmp___0) {
#line 773
          goto next;
        }
        {
#line 775
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 775
          if (! (n > 0U)) {
#line 775
            goto while_break___2;
          }
          {
#line 776
          tmp___1 = dn;
#line 776
          dn ++;
#line 776
          tmp___2 = mklower((int )*tmp___1);
#line 776
          tmp___3 = cp;
#line 776
          cp ++;
#line 776
          tmp___4 = mklower((int )*tmp___3);
          }
#line 776
          if (tmp___2 != tmp___4) {
#line 778
            goto next;
          }
#line 775
          n --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 780
        if ((int const   )*dn == 0) {
#line 780
          if ((int const   )*cp == 0) {
#line 781
            return ((int )(sp - msg));
          }
        }
#line 782
        if (*dn) {
#line 783
          goto while_continue___1;
        }
#line 784
        goto next;
        case_192: /* CIL Label */ 
#line 786
        cp = msg + (((n & 63U) << 8) | (unsigned int )*cp);
#line 787
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 790
        tmp___5 = __errno_location();
#line 790
        *tmp___5 = 90;
        }
#line 791
        return (-1);
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      next: 
#line 795
      sp += (int const   )*sp + 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 752
    cpp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 798
  tmp___7 = __errno_location();
#line 798
  *tmp___7 = 2;
  }
#line 799
  return (-1);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int decode_bitstring(char const   **cpp , char *dn , char const   *eom ) 
{ 
  char const   *cp ;
  char *beg ;
  char tc ;
  int b ;
  int blen ;
  int plen ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 805
  cp = *cpp;
#line 806
  beg = dn;
#line 809
  blen = (int )((int const   )*cp & 255);
#line 809
  if (blen == 0) {
#line 810
    blen = 256;
  }
#line 811
  plen = (blen + 3) / 4;
#line 812
  if (blen > 99) {
#line 812
    tmp___0 = 3;
  } else {
#line 812
    if (blen > 9) {
#line 812
      tmp = 2;
    } else {
#line 812
      tmp = 1;
    }
#line 812
    tmp___0 = tmp;
  }
#line 812
  plen = (int )((unsigned long )plen + (sizeof("\\[x/]") + (unsigned long )tmp___0));
#line 813
  if ((unsigned long )(dn + plen) >= (unsigned long )eom) {
#line 814
    return (-1);
  }
  {
#line 816
  cp ++;
#line 817
  tmp___1 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"\\[x");
#line 817
  i = (int )((size_t )tmp___1);
  }
#line 818
  if (i < 0) {
#line 819
    return (-1);
  }
#line 820
  dn += i;
#line 821
  b = blen;
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! (b > 7)) {
#line 821
      goto while_break;
    }
    {
#line 822
    tmp___2 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%02x",
                      (int const   )*cp & 255);
#line 822
    i = (int )((size_t )tmp___2);
    }
#line 823
    if (i < 0) {
#line 824
      return (-1);
    }
#line 825
    dn += i;
#line 821
    b -= 8;
#line 821
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 827
  if (b > 4) {
    {
#line 828
    tmp___3 = cp;
#line 828
    cp ++;
#line 828
    tc = (char )*tmp___3;
#line 829
    tmp___4 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%02x",
                      (int )tc & (255 << (8 - b)));
#line 829
    i = (int )((size_t )tmp___4);
    }
#line 830
    if (i < 0) {
#line 831
      return (-1);
    }
#line 832
    dn += i;
  } else
#line 833
  if (b > 0) {
    {
#line 834
    tmp___5 = cp;
#line 834
    cp ++;
#line 834
    tc = (char )*tmp___5;
#line 835
    tmp___6 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%1x",
                      (((int )tc >> 4) & 15) & (15 << (4 - b)));
#line 835
    i = (int )((size_t )tmp___6);
    }
#line 837
    if (i < 0) {
#line 838
      return (-1);
    }
#line 839
    dn += i;
  }
  {
#line 841
  tmp___7 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"/%d]",
                    blen);
#line 841
  i = (int )((size_t )tmp___7);
  }
#line 842
  if (i < 0) {
#line 843
    return (-1);
  }
#line 844
  dn += i;
#line 846
  *cpp = cp;
#line 847
  return ((int )(dn - beg));
}
}
#line 850 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int encode_bitsring(char const   **bp , char const   *end , char **labelp ,
                           char **dst , char const   *eom ) 
{ 
  int afterslash ;
  char const   *cp ;
  char *tp ;
  char c ;
  char const   *beg_blen ;
  char *end_blen ;
  int value ;
  int count ;
  int tbcount ;
  int blen ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  int traillen ;

  {
#line 854
  afterslash = 0;
#line 855
  cp = *bp;
#line 858
  end_blen = (char *)((void *)0);
#line 859
  value = 0;
#line 859
  count = 0;
#line 859
  tbcount = 0;
#line 859
  blen = 0;
#line 861
  end_blen = (char *)((void *)0);
#line 861
  beg_blen = (char const   *)end_blen;
#line 864
  if (end - cp < 2L) {
#line 865
    return (22);
  }
#line 868
  tmp = cp;
#line 868
  cp ++;
#line 868
  if ((int const   )*tmp != 120) {
#line 869
    return (22);
  }
  {
#line 870
  tmp___0 = __ctype_b_loc();
  }
#line 870
  if (! ((int const   )*(*tmp___0 + (int )((int const   )*cp & 255)) & 4096)) {
#line 871
    return (22);
  }
#line 873
  tp = *dst + 1;
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    if ((unsigned long )cp < (unsigned long )end) {
#line 873
      if (! ((unsigned long )tp < (unsigned long )eom)) {
#line 873
        goto while_break;
      }
    } else {
#line 873
      goto while_break;
    }
#line 874
    c = (char )*cp;
    {
#line 875
    if ((int )c == 93) {
#line 875
      goto case_93;
    }
#line 887
    if ((int )c == 47) {
#line 887
      goto case_47;
    }
#line 890
    goto switch_default;
    case_93: /* CIL Label */ 
#line 876
    if (afterslash) {
#line 877
      if ((unsigned long )beg_blen == (unsigned long )((void *)0)) {
#line 878
        return (22);
      }
      {
#line 879
      tmp___1 = strtol((char const   */* __restrict  */)beg_blen, (char **/* __restrict  */)(& end_blen),
                       10);
#line 879
      blen = (int )tmp___1;
      }
#line 880
      if ((int )*end_blen != 93) {
#line 881
        return (22);
      }
    }
#line 883
    if (count) {
#line 884
      tmp___2 = tp;
#line 884
      tp ++;
#line 884
      *tmp___2 = (char )((value << 4) & 255);
    }
#line 885
    cp ++;
#line 886
    goto done;
    case_47: /* CIL Label */ 
#line 888
    afterslash = 1;
#line 889
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 891
    if (afterslash) {
      {
#line 892
      tmp___3 = __ctype_b_loc();
      }
#line 892
      if (! ((int const   )*(*tmp___3 + ((int )c & 255)) & 2048)) {
#line 893
        return (22);
      }
#line 894
      if ((unsigned long )beg_blen == (unsigned long )((void *)0)) {
#line 896
        if ((int )c == 48) {
#line 898
          return (22);
        }
#line 900
        beg_blen = cp;
      }
    } else {
      {
#line 903
      tmp___4 = __ctype_b_loc();
      }
#line 903
      if (! ((int const   )*(*tmp___4 + ((int )c & 255)) & 4096)) {
#line 904
        return (22);
      }
#line 905
      value <<= 4;
#line 906
      value += (int )digitvalue[(int )c];
#line 907
      count += 4;
#line 908
      tbcount += 4;
#line 909
      if (tbcount > 256) {
#line 910
        return (22);
      }
#line 911
      if (count == 8) {
#line 912
        tmp___5 = tp;
#line 912
        tp ++;
#line 912
        *tmp___5 = (char )value;
#line 913
        count = 0;
      }
    }
#line 916
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 873
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 920
  if ((unsigned long )cp >= (unsigned long )end) {
#line 921
    return (90);
  } else
#line 920
  if ((unsigned long )tp >= (unsigned long )eom) {
#line 921
    return (90);
  }
#line 931
  if (blen > 0) {
#line 934
    if (((blen + 3) & -4) != tbcount) {
#line 935
      return (22);
    }
#line 936
    traillen = tbcount - blen;
#line 937
    if (((value << (8 - traillen)) & 255) != 0) {
#line 938
      return (22);
    }
  } else {
#line 941
    blen = tbcount;
  }
#line 942
  if (blen == 256) {
#line 943
    blen = 0;
  }
#line 946
  *(*labelp) = (char)65;
#line 947
  *(*dst) = (char )blen;
#line 949
  *bp = cp;
#line 950
  *dst = tp;
#line 952
  return (0);
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int labellen(u_char const   *lp ) 
{ 
  int bitlen ;
  u_char l ;

  {
#line 959
  l = (u_char )*lp;
#line 961
  if (((int )l & 192) == 192) {
#line 963
    return (-1);
  }
#line 966
  if (((int )l & 192) == 64) {
#line 967
    if ((int )l == 65) {
#line 968
      bitlen = (int )*(lp + 1);
#line 968
      if (bitlen == 0) {
#line 969
        bitlen = 256;
      }
#line 970
      return ((bitlen + 7) / 8 + 1);
    }
#line 972
    return (-1);
  }
#line 974
  return ((int )l);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/arpa_nameser.h"
struct _ns_flagdata _ns_flagdata[16] ;
#line 561
int __ns_msg_getflag(ns_msg handle , int flag ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_msg_getflag.c"
int __ns_msg_getflag(ns_msg handle , int flag ) 
{ 


  {
#line 16
  return (((int )handle._flags & _ns_flagdata[flag].mask) >> _ns_flagdata[flag].shift);
}
}
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 374
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 55 "../../src/include/spf_request.h"
SPF_errcode_t SPF_request_set_ipv4(SPF_request_t *sr , struct in_addr addr ) ;
#line 57
SPF_errcode_t SPF_request_set_ipv6(SPF_request_t *sr , struct in6_addr addr ) ;
#line 70
int SPF_request_is_loopback(SPF_request_t *sr ) ;
#line 91
SPF_errcode_t SPF_i_done(SPF_response_t *spf_response , SPF_result_t result , SPF_reason_t reason ,
                         SPF_errcode_t err ) ;
#line 214 "../../src/include/spf_response.h"
int SPF_response_errors(SPF_response_t *rp ) ;
#line 255 "../../src/include/spf_record.h"
SPF_errcode_t SPF_record_interpret(SPF_record_t *spf_record , SPF_request_t *spf_request ,
                                   SPF_response_t *spf_response , int depth ) ;
#line 148 "../../src/include/spf_dns.h"
char *SPF_dns_get_client_dom(SPF_dns_server_t *spf_dns_server , SPF_request_t *sr ) ;
#line 51 "../../src/include/spf_log.h"
void ( /* format attribute */  SPF_infox)(char const   *file , int line , char const   *format 
                                          , ...) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
SPF_request_t *SPF_request_new(SPF_server_t *spf_server___1 ) 
{ 
  SPF_request_t *sr ;
  void *tmp ;

  {
  {
#line 45
  tmp = malloc(sizeof(SPF_request_t ));
#line 45
  sr = (SPF_request_t *)tmp;
  }
#line 46
  if (! sr) {
#line 47
    return (sr);
  }
  {
#line 48
  memset((void *)sr, 0, sizeof(SPF_request_t ));
#line 50
  sr->spf_server = spf_server___1;
#line 51
  sr->client_ver = 0;
#line 52
  sr->ipv4.s_addr = htonl((in_addr_t )0);
#line 53
  sr->ipv6 = (struct in6_addr )in6addr_any;
  }
#line 55
  return (sr);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
void SPF_request_free(SPF_request_t *sr ) 
{ 


  {
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if ((unsigned long )sr == (unsigned long )((void *)0)) {
      {
#line 61
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
                 61, "%s", "sr is NULL");
      }
    }
#line 61
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 62
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 62
    if (sr->client_dom) {
      {
#line 62
      free((void *)sr->client_dom);
      }
    }
#line 62
    sr->client_dom = (char *)((void *)0);
#line 62
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 63
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 63
    if (sr->helo_dom) {
      {
#line 63
      free((void *)sr->helo_dom);
      }
    }
#line 63
    sr->helo_dom = (char *)((void *)0);
#line 63
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 64
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 64
    if (sr->env_from) {
      {
#line 64
      free((void *)sr->env_from);
      }
    }
#line 64
    sr->env_from = (char *)((void *)0);
#line 64
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 65
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 65
    if (sr->env_from_lp) {
      {
#line 65
      free((void *)sr->env_from_lp);
      }
    }
#line 65
    sr->env_from_lp = (char *)((void *)0);
#line 65
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 66
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 66
    if (sr->env_from_dp) {
      {
#line 66
      free((void *)sr->env_from_dp);
      }
    }
#line 66
    sr->env_from_dp = (char *)((void *)0);
#line 66
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 67
  free((void *)sr);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
SPF_errcode_t SPF_request_set_ipv4(SPF_request_t *sr , struct in_addr addr ) 
{ 


  {
#line 73
  if (sr->client_dom) {
    {
#line 74
    free((void *)sr->client_dom);
#line 75
    sr->client_dom = (char *)((void *)0);
    }
  }
#line 77
  sr->client_ver = 2;
#line 78
  sr->ipv4 = addr;
#line 79
  return ((SPF_errcode_t )0);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
SPF_errcode_t SPF_request_set_ipv6(SPF_request_t *sr , struct in6_addr addr ) 
{ 


  {
#line 85
  if (sr->client_dom) {
    {
#line 86
    free((void *)sr->client_dom);
#line 87
    sr->client_dom = (char *)((void *)0);
    }
  }
#line 89
  sr->client_ver = 10;
#line 90
  sr->ipv6 = addr;
#line 91
  return ((SPF_errcode_t )0);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
SPF_errcode_t SPF_request_set_ipv4_str(SPF_request_t *sr , char const   *astr ) 
{ 
  struct in_addr addr ;
  int tmp ;
  SPF_errcode_t tmp___0 ;

  {
#line 98
  if ((unsigned long )astr == (unsigned long )((void *)0)) {
#line 99
    astr = "0.0.0.0";
  }
  {
#line 100
  tmp = inet_pton(2, (char const   */* __restrict  */)astr, (void */* __restrict  */)(& addr));
  }
#line 100
  if (tmp <= 0) {
#line 101
    return ((SPF_errcode_t )19);
  }
  {
#line 102
  tmp___0 = SPF_request_set_ipv4(sr, addr);
  }
#line 102
  return (tmp___0);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
SPF_errcode_t SPF_request_set_ipv6_str(SPF_request_t *sr , char const   *astr ) 
{ 
  struct in6_addr addr ;
  int tmp ;
  SPF_errcode_t tmp___0 ;

  {
#line 109
  if ((unsigned long )astr == (unsigned long )((void *)0)) {
#line 110
    astr = "::";
  }
  {
#line 111
  tmp = inet_pton(10, (char const   */* __restrict  */)astr, (void */* __restrict  */)(& addr));
  }
#line 111
  if (tmp <= 0) {
#line 112
    return ((SPF_errcode_t )20);
  }
  {
#line 113
  tmp___0 = SPF_request_set_ipv6(sr, addr);
  }
#line 113
  return (tmp___0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
SPF_errcode_t SPF_request_set_helo_dom(SPF_request_t *sr , char const   *dom ) 
{ 
  int tmp ;

  {
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if ((unsigned long )dom == (unsigned long )((void *)0)) {
      {
#line 119
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
                 119, "%s", "dom is NULL");
      }
    }
#line 119
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (sr->helo_dom) {
      {
#line 120
      free((void *)sr->helo_dom);
      }
    }
#line 120
    sr->helo_dom = (char *)((void *)0);
#line 120
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 121
  sr->helo_dom = strdup(dom);
  }
#line 122
  if (! sr->helo_dom) {
#line 123
    return ((SPF_errcode_t )1);
  }
#line 125
  if ((unsigned long )sr->env_from == (unsigned long )((void *)0)) {
    {
#line 126
    tmp = SPF_request_set_env_from(sr, dom);
    }
#line 126
    return ((SPF_errcode_t )tmp);
  }
#line 127
  return ((SPF_errcode_t )0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
char const   *SPF_request_get_rec_dom(SPF_request_t *sr ) 
{ 
  SPF_server_t *spf_server___1 ;

  {
#line 134
  spf_server___1 = sr->spf_server;
#line 135
  return ((char const   *)spf_server___1->rec_dom);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
int SPF_request_set_env_from(SPF_request_t *sr , char const   *from ) 
{ 
  char *cp ;
  size_t len ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if ((unsigned long )from == (unsigned long )((void *)0)) {
      {
#line 144
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
                 144, "%s", "from is NULL");
      }
    }
#line 144
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 145
    if (sr->env_from) {
      {
#line 145
      free((void *)sr->env_from);
      }
    }
#line 145
    sr->env_from = (char *)((void *)0);
#line 145
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 146
    if (sr->env_from_lp) {
      {
#line 146
      free((void *)sr->env_from_lp);
      }
    }
#line 146
    sr->env_from_lp = (char *)((void *)0);
#line 146
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 147
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 147
    if (sr->env_from_dp) {
      {
#line 147
      free((void *)sr->env_from_dp);
      }
    }
#line 147
    sr->env_from_dp = (char *)((void *)0);
#line 147
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 149
  if ((int const   )*from == 0) {
#line 149
    if ((unsigned long )sr->helo_dom != (unsigned long )((void *)0)) {
#line 150
      from = (char const   *)sr->helo_dom;
    }
  }
  {
#line 151
  cp = strrchr(from, '@');
  }
#line 152
  if (cp) {
#line 152
    if ((unsigned long )cp != (unsigned long )from) {
      {
#line 153
      sr->env_from = strdup(from);
      }
#line 154
      if (! sr->env_from) {
#line 155
        return (1);
      }
      {
#line 157
      len = (size_t )(cp - (char *)from);
#line 158
      tmp = malloc(len + 1UL);
#line 158
      sr->env_from_lp = (char *)tmp;
      }
#line 159
      if (! sr->env_from_lp) {
        {
#line 160
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 160
          if (sr->env_from) {
            {
#line 160
            free((void *)sr->env_from);
            }
          }
#line 160
          sr->env_from = (char *)((void *)0);
#line 160
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 161
        return (1);
      }
      {
#line 163
      strncpy((char */* __restrict  */)sr->env_from_lp, (char const   */* __restrict  */)from,
              len);
#line 164
      *(sr->env_from_lp + len) = (char )'\000';
#line 165
      sr->env_from_dp = strdup((char const   *)(cp + 1));
      }
#line 166
      if (! sr->env_from_dp) {
        {
#line 167
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 167
          if (sr->env_from) {
            {
#line 167
            free((void *)sr->env_from);
            }
          }
#line 167
          sr->env_from = (char *)((void *)0);
#line 167
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 168
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 168
          if (sr->env_from_lp) {
            {
#line 168
            free((void *)sr->env_from_lp);
            }
          }
#line 168
          sr->env_from_lp = (char *)((void *)0);
#line 168
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 169
        return (1);
      }
    } else {
#line 152
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 173
    if ((unsigned long )cp == (unsigned long )from) {
#line 173
      from ++;
    }
    {
#line 174
    tmp___0 = strlen(from);
#line 174
    len = sizeof("postmaster@") + tmp___0;
#line 175
    tmp___1 = malloc(len + 1UL);
#line 175
    sr->env_from = (char *)tmp___1;
    }
#line 176
    if (! sr->env_from) {
#line 177
      return (1);
    }
    {
#line 178
    sprintf((char */* __restrict  */)sr->env_from, (char const   */* __restrict  */)"postmaster@%s",
            from);
#line 179
    sr->env_from_lp = strdup("postmaster");
    }
#line 180
    if (! sr->env_from_lp) {
      {
#line 181
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 181
        if (sr->env_from) {
          {
#line 181
          free((void *)sr->env_from);
          }
        }
#line 181
        sr->env_from = (char *)((void *)0);
#line 181
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 182
      return (1);
    }
    {
#line 184
    sr->env_from_dp = strdup(from);
    }
#line 185
    if (! sr->env_from_dp) {
      {
#line 186
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 186
        if (sr->env_from) {
          {
#line 186
          free((void *)sr->env_from);
          }
        }
#line 186
        sr->env_from = (char *)((void *)0);
#line 186
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 187
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 187
        if (sr->env_from_lp) {
          {
#line 187
          free((void *)sr->env_from_lp);
          }
        }
#line 187
        sr->env_from_lp = (char *)((void *)0);
#line 187
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 188
      return (1);
    }
  }
#line 192
  return (0);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
char const   *SPF_request_get_client_dom(SPF_request_t *sr ) 
{ 
  SPF_server_t *spf_server___1 ;

  {
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if ((unsigned long )sr == (unsigned long )((void *)0)) {
      {
#line 200
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
                 200, "%s", "sr is NULL");
      }
    }
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  spf_server___1 = sr->spf_server;
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 202
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 202
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
                 202, "%s", "spf_server is NULL");
      }
    }
#line 202
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 204
  if ((unsigned long )sr->client_dom == (unsigned long )((void *)0)) {
    {
#line 205
    sr->client_dom = SPF_dns_get_client_dom(spf_server___1->resolver, sr);
    }
  }
#line 208
  return ((char const   *)sr->client_dom);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
int SPF_request_is_loopback(SPF_request_t *sr ) 
{ 
  uint32_t tmp ;
  struct in6_addr  const  *__a ;
  uint32_t tmp___0 ;
  int tmp___1 ;

  {
#line 214
  if (sr->client_ver == 2) {
    {
#line 215
    tmp = ntohl(sr->ipv4.s_addr);
    }
#line 215
    if ((tmp & 4278190080U) == (unsigned int )(127 << 24)) {
#line 217
      return (1);
    }
  } else
#line 220
  if (sr->client_ver == 10) {
#line 221
    __a = (struct in6_addr  const  *)(& sr->ipv6);
#line 221
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 221
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 221
        if (__a->__in6_u.__u6_addr32[2] == 0U) {
          {
#line 221
          tmp___0 = htonl((uint32_t )1);
          }
#line 221
          if (__a->__in6_u.__u6_addr32[3] == tmp___0) {
#line 221
            tmp___1 = 1;
          } else {
#line 221
            tmp___1 = 0;
          }
        } else {
#line 221
          tmp___1 = 0;
        }
      } else {
#line 221
        tmp___1 = 0;
      }
    } else {
#line 221
      tmp___1 = 0;
    }
#line 221
    if (tmp___1) {
#line 222
      return (1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
static SPF_errcode_t SPF_request_prepare(SPF_request_t *sr ) 
{ 


  {
#line 230
  if (sr->use_helo) {
#line 231
    sr->cur_dom = (char const   *)sr->helo_dom;
  } else {
#line 233
    sr->cur_dom = (char const   *)sr->env_from_dp;
  }
#line 234
  return ((SPF_errcode_t )0);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
static SPF_errcode_t SPF_request_query_record(SPF_request_t *spf_request , SPF_response_t *spf_response ,
                                              SPF_record_t *spf_record , SPF_errcode_t err ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 246
  if ((unsigned int )err != 0U) {
#line 247
    if (spf_record) {
      {
#line 248
      SPF_record_free(spf_record);
      }
    }
#line 249
    return (err);
  }
  {
#line 252
  tmp___0 = SPF_response_errors(spf_response);
  }
#line 252
  if (tmp___0 > 0) {
    {
#line 253
    tmp = SPF_response_errors(spf_response);
#line 253
    SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
              255, "Warning: %d errors in response, but no error code. Evaluating.",
              tmp);
    }
  }
  {
#line 257
  spf_response->spf_record_exp = spf_record;
#line 258
  err = SPF_record_interpret(spf_record, spf_request, spf_response, 0);
#line 260
  SPF_record_free(spf_record);
  }
#line 262
  return (err);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
SPF_errcode_t SPF_request_query_mailfrom(SPF_request_t *spf_request , SPF_response_t **spf_responsep ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  SPF_errcode_t tmp ;
  int tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 276
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
                 276, "%s", "spf_request is NULL");
      }
    }
#line 276
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  spf_server___1 = spf_request->spf_server;
  {
#line 278
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 278
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 278
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
                 278, "%s", "spf_server is NULL");
      }
    }
#line 278
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 280
  *spf_responsep = SPF_response_new(spf_request);
  }
#line 281
  if (! *spf_responsep) {
#line 282
    return ((SPF_errcode_t )1);
  }
  {
#line 285
  tmp___0 = SPF_request_is_loopback(spf_request);
  }
#line 285
  if (tmp___0) {
    {
#line 286
    tmp = SPF_i_done(*spf_responsep, (SPF_result_t )2, (SPF_reason_t )2, (SPF_errcode_t )0);
    }
#line 286
    return (tmp);
  }
  {
#line 289
  SPF_request_prepare(spf_request);
#line 291
  err = SPF_server_get_record(spf_server___1, spf_request, *spf_responsep, & spf_record);
#line 293
  tmp___1 = SPF_request_query_record(spf_request, *spf_responsep, spf_record, err);
  }
#line 293
  return (tmp___1);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
SPF_errcode_t SPF_request_query_fallback(SPF_request_t *spf_request , SPF_response_t **spf_responsep ,
                                         char const   *record ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  SPF_errcode_t tmp ;
  int tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 307
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
                 307, "%s", "spf_request is NULL");
      }
    }
#line 307
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  spf_server___1 = spf_request->spf_server;
  {
#line 309
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 309
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 309
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
                 309, "%s", "spf_server is NULL");
      }
    }
#line 309
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 311
  *spf_responsep = SPF_response_new(spf_request);
  }
#line 312
  if (! *spf_responsep) {
#line 313
    return ((SPF_errcode_t )1);
  }
  {
#line 316
  tmp___0 = SPF_request_is_loopback(spf_request);
  }
#line 316
  if (tmp___0) {
    {
#line 317
    tmp = SPF_i_done(*spf_responsep, (SPF_result_t )2, (SPF_reason_t )2, (SPF_errcode_t )0);
    }
#line 317
    return (tmp);
  }
  {
#line 320
  SPF_request_prepare(spf_request);
#line 322
  err = SPF_record_compile(spf_server___1, *spf_responsep, & spf_record, record);
#line 325
  tmp___1 = SPF_request_query_record(spf_request, *spf_responsep, spf_record, err);
  }
#line 325
  return (tmp___1);
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
SPF_errcode_t SPF_request_query_rcptto(SPF_request_t *spf_request , SPF_response_t **spf_responsep ,
                                       char const   *rcpt_to ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  char const   *rcpt_to_dom ;
  char *record ;
  size_t len ;
  SPF_errcode_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  SPF_errcode_t tmp___4 ;

  {
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 350
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
                 350, "%s", "spf_request is NULL");
      }
    }
#line 350
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  spf_server___1 = spf_request->spf_server;
  {
#line 352
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 352
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 352
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
                 352, "%s", "spf_server is NULL");
      }
    }
#line 352
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 354
  *spf_responsep = SPF_response_new(spf_request);
  }
#line 355
  if (! *spf_responsep) {
#line 356
    return ((SPF_errcode_t )1);
  }
  {
#line 359
  tmp___0 = SPF_request_is_loopback(spf_request);
  }
#line 359
  if (tmp___0) {
    {
#line 360
    tmp = SPF_i_done(*spf_responsep, (SPF_result_t )2, (SPF_reason_t )2, (SPF_errcode_t )0);
    }
#line 360
    return (tmp);
  }
  {
#line 363
  tmp___1 = strchr(rcpt_to, '@');
#line 363
  rcpt_to_dom = (char const   *)tmp___1;
  }
#line 364
  if ((unsigned long )rcpt_to_dom == (unsigned long )((void *)0)) {
#line 365
    rcpt_to_dom = rcpt_to;
  }
  {
#line 366
  spf_request->cur_dom = rcpt_to_dom;
#line 368
  tmp___2 = strlen(rcpt_to_dom);
#line 368
  len = (sizeof("v=spf1") + 64UL) + tmp___2;
#line 369
  tmp___3 = malloc(len);
#line 369
  record = (char *)tmp___3;
  }
#line 370
  if (! record) {
#line 371
    return ((SPF_errcode_t )1);
  }
  {
#line 372
  snprintf((char */* __restrict  */)record, len, (char const   */* __restrict  */)"v=spf1 mx:%s",
           rcpt_to_dom);
#line 373
  err = SPF_record_compile(spf_server___1, *spf_responsep, & spf_record, (char const   *)record);
#line 376
  free((void *)record);
#line 377
  tmp___4 = SPF_request_query_record(spf_request, *spf_responsep, spf_record, err);
  }
#line 377
  return (tmp___4);
}
}
#line 83 "../../src/include/spf_request.h"
SPF_errcode_t SPF_request_get_exp(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                                  SPF_response_t *spf_response , SPF_record_t *spf_record ,
                                  char **bufp , size_t *buflenp ) ;
#line 245 "../../src/include/spf_response.h"
SPF_errcode_t SPF_response_add_warn(SPF_response_t *rp , SPF_errcode_t code , char const   *format 
                                    , ...) ;
#line 238 "../../src/include/spf_record.h"
SPF_errcode_t SPF_record_find_mod_value(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                                        SPF_response_t *spf_response , SPF_record_t *spf_record ,
                                        char const   *mod_name , char **bufp , size_t *buflenp ) ;
#line 46 "../../src/include/spf_log.h"
void ( /* format attribute */  SPF_warningx)(char const   *file , int line , char const   *format 
                                             , ...) ;
#line 134 "../../src/include/spf_internal.h"
__inline static SPF_data_t *SPF_macro_data(SPF_macro_t *mac ) 
{ 


  {
#line 135
  return ((SPF_data_t *)((char *)mac + sizeof(SPF_macro_t )));
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c"
static SPF_errcode_t SPF_server_get_default_explanation(SPF_server_t *spf_server___1 ,
                                                        SPF_request_t *spf_request ,
                                                        SPF_response_t *spf_response ,
                                                        char **bufp , size_t *buflenp ) 
{ 
  SPF_errcode_t err ;
  SPF_macro_t *spf_macro ;
  SPF_data_t *tmp ;
  size_t len ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  spf_macro = spf_server___1->explanation;
#line 56
  if ((unsigned long )spf_macro != (unsigned long )((void *)0)) {
    {
#line 57
    tmp = SPF_macro_data(spf_macro);
#line 57
    err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, tmp, spf_macro->macro_len,
                                 bufp, buflenp);
    }
#line 61
    return (err);
  } else {
#line 64
    len = sizeof("SPF failure: no explanation available") + 1UL;
#line 65
    if (*buflenp < len) {
      {
#line 66
      tmp___1 = realloc((void *)*bufp, len);
#line 66
      tmp___0 = (char *)tmp___1;
      }
#line 67
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 68
        return ((SPF_errcode_t )1);
      }
#line 69
      *bufp = tmp___0;
#line 70
      *buflenp = len;
    }
    {
#line 72
    strcpy((char */* __restrict  */)*bufp, (char const   */* __restrict  */)"SPF failure: no explanation available");
    }
#line 73
    return ((SPF_errcode_t )0);
  }
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c"
SPF_errcode_t SPF_request_get_exp(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                                  SPF_response_t *spf_response , SPF_record_t *spf_record ,
                                  char **bufp , size_t *buflenp ) 
{ 
  SPF_macro_t *spf_macro ;
  SPF_dns_server_t *resolver ;
  SPF_dns_rr_t *rr_txt ;
  SPF_errcode_t err ;
  char const   *domain ;
  SPF_errcode_t tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;
  SPF_errcode_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  SPF_errcode_t tmp___6 ;
  SPF_errcode_t tmp___7 ;
  SPF_errcode_t tmp___8 ;
  SPF_data_t *tmp___9 ;

  {
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 101
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c",
                 101, "%s", "spf_server is NULL");
      }
    }
#line 101
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 102
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 102
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c",
                 102, "%s", "spf_request is NULL");
      }
    }
#line 102
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 103
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 103
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 103
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c",
                 103, "%s", "spf_response is NULL");
      }
    }
#line 103
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 104
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 104
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 104
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c",
                 104, "%s", "spf_record is NULL");
      }
    }
#line 104
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 105
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 105
    if ((unsigned long )bufp == (unsigned long )((void *)0)) {
      {
#line 105
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c",
                 105, "%s", "bufp is NULL");
      }
    }
#line 105
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 106
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 106
    if ((unsigned long )buflenp == (unsigned long )((void *)0)) {
      {
#line 106
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c",
                 106, "%s", "buflenp is NULL");
      }
    }
#line 106
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 108
  domain = spf_request->cur_dom;
#line 110
  if ((unsigned long )domain == (unsigned long )((void *)0)) {
    {
#line 111
    tmp = SPF_response_add_warn(spf_response, (SPF_errcode_t )25, "Could not identify current domain for explanation");
    }
#line 111
    return (tmp);
  }
  {
#line 118
  err = SPF_record_find_mod_value(spf_server___1, spf_request, spf_response, spf_record,
                                  "exp-text", bufp, buflenp);
  }
#line 121
  if ((unsigned int )err == 0U) {
#line 122
    return (err);
  }
  {
#line 129
  err = SPF_record_find_mod_value(spf_server___1, spf_request, spf_response, spf_record,
                                  "exp", bufp, buflenp);
  }
#line 132
  if ((unsigned int )err != 0U) {
    {
#line 136
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 136
      tmp___0 = SPF_server_get_default_explanation(spf_server___1, spf_request, spf_response,
                                                   bufp, buflenp);
      }
#line 136
      return (tmp___0);
#line 136
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 139
  if ((unsigned long )*bufp == (unsigned long )((void *)0)) {
#line 139
    goto _L;
  } else
#line 139
  if ((int )*(*bufp + 0) == 0) {
    _L: /* CIL Label */ 
    {
#line 143
    SPF_response_add_warn(spf_response, (SPF_errcode_t )2, "Explanation is blank!");
    }
    {
#line 145
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 145
      tmp___1 = SPF_server_get_default_explanation(spf_server___1, spf_request, spf_response,
                                                   bufp, buflenp);
      }
#line 145
      return (tmp___1);
#line 145
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 153
  resolver = spf_server___1->resolver;
#line 155
  if (resolver->get_exp) {
    {
#line 156
    tmp___2 = (*(resolver->get_exp))(spf_server___1, (char const   *)*bufp, bufp,
                                     buflenp);
    }
#line 156
    return (tmp___2);
  }
  {
#line 158
  rr_txt = SPF_dns_lookup(resolver, (char const   *)*bufp, (ns_type )16, 1);
  }
#line 159
  if ((unsigned long )rr_txt == (unsigned long )((void *)0)) {
    {
#line 160
    SPF_dns_rr_free(rr_txt);
    }
    {
#line 161
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 161
      tmp___3 = SPF_server_get_default_explanation(spf_server___1, spf_request, spf_response,
                                                   bufp, buflenp);
      }
#line 161
      return (tmp___3);
#line 161
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 166
  if (rr_txt->herrno == 4) {
#line 166
    goto case_4;
  }
#line 166
  if (rr_txt->herrno == 1) {
#line 166
    goto case_4;
  }
#line 171
  if (rr_txt->herrno == 2) {
#line 171
    goto case_2;
  }
#line 176
  if (rr_txt->herrno == 0) {
#line 176
    goto case_0;
  }
#line 179
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 167
  SPF_dns_rr_free(rr_txt);
  }
  {
#line 168
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 168
    tmp___4 = SPF_server_get_default_explanation(spf_server___1, spf_request, spf_response,
                                                 bufp, buflenp);
    }
#line 168
    return (tmp___4);
#line 168
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 169
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 172
  SPF_dns_rr_free(rr_txt);
  }
  {
#line 173
  while (1) {
    while_continue___9: /* CIL Label */ ;
    {
#line 173
    tmp___5 = SPF_server_get_default_explanation(spf_server___1, spf_request, spf_response,
                                                 bufp, buflenp);
    }
#line 173
    return (tmp___5);
#line 173
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 174
  goto switch_break;
  case_0: /* CIL Label */ 
#line 177
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 180
  SPF_warningx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c",
               180, "%s", "Unknown DNS lookup error code");
#line 181
  SPF_dns_rr_free(rr_txt);
  }
  {
#line 182
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 182
    tmp___6 = SPF_server_get_default_explanation(spf_server___1, spf_request, spf_response,
                                                 bufp, buflenp);
    }
#line 182
    return (tmp___6);
#line 182
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 183
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 186
  if (rr_txt->num_rr == 0) {
    {
#line 187
    SPF_response_add_warn(spf_response, (SPF_errcode_t )2, "No TXT records returned from DNS lookup");
    }
    {
#line 189
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 189
      tmp___7 = SPF_server_get_default_explanation(spf_server___1, spf_request, spf_response,
                                                   bufp, buflenp);
      }
#line 189
      return (tmp___7);
#line 189
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  {
#line 200
  spf_macro = (SPF_macro_t *)((void *)0);
#line 201
  err = SPF_record_compile_macro(spf_server___1, spf_response, & spf_macro, (char const   *)((*(rr_txt->rr + 0))->txt));
  }
#line 203
  if ((unsigned int )err != 0U) {
#line 204
    if (spf_macro) {
      {
#line 205
      SPF_macro_free(spf_macro);
      }
    }
    {
#line 206
    SPF_dns_rr_free(rr_txt);
    }
    {
#line 207
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 207
      tmp___8 = SPF_server_get_default_explanation(spf_server___1, spf_request, spf_response,
                                                   bufp, buflenp);
      }
#line 207
      return (tmp___8);
#line 207
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
  }
  {
#line 210
  tmp___9 = SPF_macro_data(spf_macro);
#line 210
  err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, tmp___9,
                               spf_macro->macro_len, bufp, buflenp);
#line 214
  SPF_macro_free(spf_macro);
#line 215
  SPF_dns_rr_free(rr_txt);
  }
#line 217
  return (err);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/arpa_nameser.h"
extern int __dn_expand(u_char const   * , u_char const   * , u_char const   * , char * ,
                       int  ) ;
#line 68
extern int __dn_skipname(u_char const   * , u_char const   * ) ;
#line 566
int __ns_initparse(u_char const   *msg , int msglen , ns_msg *handle ) ;
#line 567
int __ns_skiprr(u_char const   *ptr , u_char const   *eom , ns_sect section , int count ) ;
#line 568
int __ns_parserr(ns_msg *handle , ns_sect section , int rrnum , ns_rr *rr ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
static void setsection(ns_msg *msg , ns_sect sect ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
struct _ns_flagdata _ns_flagdata[16]  = 
#line 56
  {      {32768, 15}, 
        {30720, 11}, 
        {1024, 10}, 
        {512, 9}, 
        {256, 8}, 
        {128, 7}, 
        {64, 6}, 
        {32, 5}, 
        {16, 4}, 
        {15, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}, 
        {0, 0}};
#line 75 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
int __ns_skiprr(u_char const   *ptr , u_char const   *eom , ns_sect section , int count ) 
{ 
  u_char const   *optr ;
  int b ;
  int rdlength ;
  int *tmp ;
  int *tmp___0 ;
  register u_char const   *t_cp ;
  int *tmp___1 ;

  {
#line 77
  optr = ptr;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (count > 0)) {
#line 79
      goto while_break;
    }
    {
#line 82
    b = __dn_skipname(ptr, eom);
    }
#line 83
    if (b < 0) {
      {
#line 84
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 84
        tmp = __errno_location();
#line 84
        *tmp = 90;
        }
#line 84
        return (-1);
#line 84
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 85
    ptr += (b + 2) + 2;
#line 86
    if ((unsigned int )section != 0U) {
#line 87
      if ((unsigned long )((ptr + 4) + 2) > (unsigned long )eom) {
        {
#line 88
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 88
          tmp___0 = __errno_location();
#line 88
          *tmp___0 = 90;
          }
#line 88
          return (-1);
#line 88
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 89
      ptr += 4;
      {
#line 90
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 90
        t_cp = ptr;
#line 90
        rdlength = ((int )((u_int16_t )*(t_cp + 0)) << 8) | (int )((u_int16_t )*(t_cp + 1));
#line 90
        ptr += 2;
#line 90
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 91
      ptr += rdlength;
    }
#line 79
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if ((unsigned long )ptr > (unsigned long )eom) {
    {
#line 95
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 95
      tmp___1 = __errno_location();
#line 95
      *tmp___1 = 90;
      }
#line 95
      return (-1);
#line 95
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 96
  return ((int )(ptr - optr));
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
int __ns_initparse(u_char const   *msg , int msglen , ns_msg *handle ) 
{ 
  u_char const   *eom ;
  int i ;
  int *tmp ;
  register u_char const   *t_cp ;
  int *tmp___0 ;
  register u_char const   *t_cp___0 ;
  int *tmp___1 ;
  register u_char const   *t_cp___1 ;
  int b ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 101
  eom = msg + msglen;
#line 104
  memset((void *)handle, 94, sizeof(*handle));
#line 105
  handle->_msg = msg;
#line 106
  handle->_eom = eom;
  }
#line 107
  if ((unsigned long )(msg + 2) > (unsigned long )eom) {
    {
#line 108
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 108
      tmp = __errno_location();
#line 108
      *tmp = 90;
      }
#line 108
      return (-1);
#line 108
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    t_cp = msg;
#line 109
    handle->_id = (u_int16_t )(((int )((u_int16_t )*(t_cp + 0)) << 8) | (int )((u_int16_t )*(t_cp + 1)));
#line 109
    msg += 2;
#line 109
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 110
  if ((unsigned long )(msg + 2) > (unsigned long )eom) {
    {
#line 111
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 111
      tmp___0 = __errno_location();
#line 111
      *tmp___0 = 90;
      }
#line 111
      return (-1);
#line 111
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 112
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 112
    t_cp___0 = msg;
#line 112
    handle->_flags = (u_int16_t )(((int )((u_int16_t )*(t_cp___0 + 0)) << 8) | (int )((u_int16_t )*(t_cp___0 + 1)));
#line 112
    msg += 2;
#line 112
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 113
    if (! (i < 4)) {
#line 113
      goto while_break___3;
    }
#line 114
    if ((unsigned long )(msg + 2) > (unsigned long )eom) {
      {
#line 115
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 115
        tmp___1 = __errno_location();
#line 115
        *tmp___1 = 90;
        }
#line 115
        return (-1);
#line 115
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 116
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 116
      t_cp___1 = msg;
#line 116
      handle->_counts[i] = (u_int16_t )(((int )((u_int16_t )*(t_cp___1 + 0)) << 8) | (int )((u_int16_t )*(t_cp___1 + 1)));
#line 116
      msg += 2;
#line 116
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 113
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 118
    if (! (i < 4)) {
#line 118
      goto while_break___6;
    }
#line 119
    if ((int )handle->_counts[i] == 0) {
#line 120
      handle->_sections[i] = (u_char const   *)((void *)0);
    } else {
      {
#line 122
      tmp___2 = __ns_skiprr(msg, eom, (ns_sect )i, (int )handle->_counts[i]);
#line 122
      b = tmp___2;
      }
#line 125
      if (b < 0) {
#line 126
        return (-1);
      }
#line 127
      handle->_sections[i] = msg;
#line 128
      msg += b;
    }
#line 118
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 130
  if ((unsigned long )msg != (unsigned long )eom) {
    {
#line 131
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 131
      tmp___3 = __errno_location();
#line 131
      *tmp___3 = 90;
      }
#line 131
      return (-1);
#line 131
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 132
  setsection(handle, (ns_sect )4);
  }
#line 133
  return (0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
int __ns_parserr(ns_msg *handle , ns_sect section , int rrnum , ns_rr *rr ) 
{ 
  int b ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register u_char const   *t_cp ;
  register u_char const   *t_cp___0 ;
  int *tmp___3 ;
  register u_char const   *t_cp___1 ;
  register u_char const   *t_cp___2 ;
  int *tmp___4 ;

  {
#line 142
  tmp = (int )section;
#line 142
  if (tmp < 0) {
#line 142
    goto _L;
  } else
#line 142
  if ((unsigned int )section >= 4U) {
    _L: /* CIL Label */ 
    {
#line 143
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 143
      tmp___0 = __errno_location();
#line 143
      *tmp___0 = 19;
      }
#line 143
      return (-1);
#line 143
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 144
  if ((unsigned int )section != (unsigned int )handle->_sect) {
    {
#line 145
    setsection(handle, section);
    }
  }
#line 148
  if (rrnum == -1) {
#line 149
    rrnum = handle->_rrnum;
  }
#line 150
  if (rrnum < 0) {
#line 150
    goto _L___0;
  } else
#line 150
  if (rrnum >= (int )handle->_counts[(int )section]) {
    _L___0: /* CIL Label */ 
    {
#line 151
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 151
      tmp___1 = __errno_location();
#line 151
      *tmp___1 = 19;
      }
#line 151
      return (-1);
#line 151
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 152
  if (rrnum < handle->_rrnum) {
    {
#line 153
    setsection(handle, section);
    }
  }
#line 154
  if (rrnum > handle->_rrnum) {
    {
#line 155
    b = __ns_skiprr(handle->_msg_ptr, handle->_eom, section, rrnum - handle->_rrnum);
    }
#line 158
    if (b < 0) {
#line 159
      return (-1);
    }
#line 160
    handle->_msg_ptr += b;
#line 161
    handle->_rrnum = rrnum;
  }
  {
#line 165
  b = __dn_expand(handle->_msg, handle->_eom, handle->_msg_ptr, rr->name, 1025);
  }
#line 167
  if (b < 0) {
#line 168
    return (-1);
  }
#line 169
  handle->_msg_ptr += b;
#line 170
  if ((unsigned long )((handle->_msg_ptr + 2) + 2) > (unsigned long )handle->_eom) {
    {
#line 171
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 171
      tmp___2 = __errno_location();
#line 171
      *tmp___2 = 90;
      }
#line 171
      return (-1);
#line 171
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 172
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 172
    t_cp = handle->_msg_ptr;
#line 172
    rr->type = (u_int16_t )(((int )((u_int16_t )*(t_cp + 0)) << 8) | (int )((u_int16_t )*(t_cp + 1)));
#line 172
    handle->_msg_ptr += 2;
#line 172
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 173
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 173
    t_cp___0 = handle->_msg_ptr;
#line 173
    rr->rr_class = (u_int16_t )(((int )((u_int16_t )*(t_cp___0 + 0)) << 8) | (int )((u_int16_t )*(t_cp___0 + 1)));
#line 173
    handle->_msg_ptr += 2;
#line 173
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 174
  if ((unsigned int )section == 0U) {
#line 175
    rr->ttl = (u_int32_t )0;
#line 176
    rr->rdlength = (u_int16_t )0;
#line 177
    rr->rdata = (u_char const   *)((void *)0);
  } else {
#line 179
    if ((unsigned long )((handle->_msg_ptr + 4) + 2) > (unsigned long )handle->_eom) {
      {
#line 180
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 180
        tmp___3 = __errno_location();
#line 180
        *tmp___3 = 90;
        }
#line 180
        return (-1);
#line 180
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 181
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 181
      t_cp___1 = handle->_msg_ptr;
#line 181
      rr->ttl = ((((u_int32_t )*(t_cp___1 + 0) << 24) | ((u_int32_t )*(t_cp___1 + 1) << 16)) | ((u_int32_t )*(t_cp___1 + 2) << 8)) | (u_int32_t )*(t_cp___1 + 3);
#line 181
      handle->_msg_ptr += 4;
#line 181
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 182
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 182
      t_cp___2 = handle->_msg_ptr;
#line 182
      rr->rdlength = (u_int16_t )(((int )((u_int16_t )*(t_cp___2 + 0)) << 8) | (int )((u_int16_t )*(t_cp___2 + 1)));
#line 182
      handle->_msg_ptr += 2;
#line 182
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 183
    if ((unsigned long )(handle->_msg_ptr + (int )rr->rdlength) > (unsigned long )handle->_eom) {
      {
#line 184
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 184
        tmp___4 = __errno_location();
#line 184
        *tmp___4 = 90;
        }
#line 184
        return (-1);
#line 184
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 185
    rr->rdata = handle->_msg_ptr;
#line 186
    handle->_msg_ptr += (int )rr->rdlength;
  }
#line 188
  (handle->_rrnum) ++;
#line 188
  if (handle->_rrnum > (int )handle->_counts[(int )section]) {
    {
#line 189
    setsection(handle, (ns_sect )((int )section + 1));
    }
  }
#line 192
  return (0);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
static void setsection(ns_msg *msg , ns_sect sect ) 
{ 


  {
#line 199
  msg->_sect = sect;
#line 200
  if ((unsigned int )sect == 4U) {
#line 201
    msg->_rrnum = -1;
#line 202
    msg->_msg_ptr = (u_char const   *)((void *)0);
  } else {
#line 204
    msg->_rrnum = 0;
#line 205
    msg->_msg_ptr = msg->_sections[(int )sect];
  }
#line 207
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 42 "../../src/include/spf_log.h"
void SPF_errorx2(char const   *format  , ...) ;
#line 43
 __attribute__((__noreturn__)) void ( /* format attribute */  SPF_errorv)(char const   *file ,
                                                                          int line ,
                                                                          char const   *format ,
                                                                          va_list ap ) ;
#line 47
void SPF_warningx2(char const   *format  , ...) ;
#line 48
void ( /* format attribute */  SPF_warningv)(char const   *file , int line , char const   *format ,
                                             va_list ap ) ;
#line 52
void SPF_infox2(char const   *format  , ...) ;
#line 53
void ( /* format attribute */  SPF_infov)(char const   *file , int line , char const   *format ,
                                          va_list ap ) ;
#line 57
void SPF_debugx2(char const   *format  , ...) ;
#line 58
void ( /* format attribute */  SPF_debugv)(char const   *file , int line , char const   *format ,
                                           va_list ap ) ;
#line 113
 __attribute__((__noreturn__)) void (*SPF_error_handler)(char const   * , int  , char const   * ) ;
#line 114
void (*SPF_warning_handler)(char const   * , int  , char const   * ) ;
#line 115
void (*SPF_info_handler)(char const   * , int  , char const   * ) ;
#line 116
void (*SPF_debug_handler)(char const   * , int  , char const   * ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
 __attribute__((__noreturn__)) void ( /* format attribute */  SPF_errorx)(char const   *file ,
                                                                          int line ,
                                                                          char const   *format 
                                                                          , ...) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
void ( /* format attribute */  SPF_errorx)(char const   *file , int line , char const   *format 
                                           , ...) 
{ 
  char errmsg[800] ;
  va_list ap ;

  {
#line 40
  if ((unsigned long )SPF_error_handler == (unsigned long )((void *)0)) {
    {
#line 41
    abort();
    }
  }
  {
#line 43
  __builtin_va_start(ap, format);
#line 44
  vsnprintf((char */* __restrict  */)(errmsg), sizeof(errmsg), (char const   */* __restrict  */)format,
            ap);
#line 45
  __builtin_va_end(ap);
#line 47
  (*SPF_error_handler)(file, line, (char const   *)(errmsg));
#line 48
  abort();
  }
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
void ( /* format attribute */  SPF_warningx)(char const   *file , int line , char const   *format 
                                             , ...) 
{ 
  char errmsg[800] ;
  va_list ap ;

  {
#line 58
  if ((unsigned long )SPF_warning_handler == (unsigned long )((void *)0)) {
#line 59
    return;
  }
  {
#line 61
  __builtin_va_start(ap, format);
#line 62
  vsnprintf((char */* __restrict  */)(errmsg), sizeof(errmsg), (char const   */* __restrict  */)format,
            ap);
#line 63
  __builtin_va_end(ap);
#line 65
  (*SPF_warning_handler)(file, line, (char const   *)(errmsg));
  }
#line 66
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
void ( /* format attribute */  SPF_infox)(char const   *file , int line , char const   *format 
                                          , ...) 
{ 
  char errmsg[800] ;
  va_list ap ;

  {
#line 75
  if ((unsigned long )SPF_info_handler == (unsigned long )((void *)0)) {
#line 76
    return;
  }
  {
#line 78
  __builtin_va_start(ap, format);
#line 79
  vsnprintf((char */* __restrict  */)(errmsg), sizeof(errmsg), (char const   */* __restrict  */)format,
            ap);
#line 80
  __builtin_va_end(ap);
#line 82
  (*SPF_info_handler)(file, line, (char const   *)(errmsg));
  }
#line 83
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
void ( /* format attribute */  SPF_debugx)(char const   *file , int line , char const   *format 
                                           , ...) 
{ 
  char errmsg[800] ;
  va_list ap ;

  {
#line 92
  if ((unsigned long )SPF_debug_handler == (unsigned long )((void *)0)) {
#line 93
    return;
  }
  {
#line 95
  __builtin_va_start(ap, format);
#line 96
  vsnprintf((char */* __restrict  */)(errmsg), sizeof(errmsg), (char const   */* __restrict  */)format,
            ap);
#line 97
  __builtin_va_end(ap);
#line 99
  (*SPF_debug_handler)(file, line, (char const   *)(errmsg));
  }
#line 100
  return;
}
}
#line 108
 __attribute__((__noreturn__)) void ( /* format attribute */  SPF_errorv)(char const   *file ,
                                                                          int line ,
                                                                          char const   *format ,
                                                                          va_list ap ) ;
#line 108 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
void ( /* format attribute */  SPF_errorv)(char const   *file , int line , char const   *format ,
                                           va_list ap ) 
{ 
  char errmsg[800] ;

  {
#line 113
  if ((unsigned long )SPF_error_handler == (unsigned long )((void *)0)) {
    {
#line 114
    abort();
    }
  }
  {
#line 116
  vsnprintf((char */* __restrict  */)(errmsg), sizeof(errmsg), (char const   */* __restrict  */)format,
            ap);
#line 117
  (*SPF_error_handler)(file, line, (char const   *)(errmsg));
#line 119
  abort();
  }
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
void ( /* format attribute */  SPF_warningv)(char const   *file , int line , char const   *format ,
                                             va_list ap ) 
{ 
  char errmsg[800] ;

  {
#line 128
  if ((unsigned long )SPF_warning_handler == (unsigned long )((void *)0)) {
#line 129
    return;
  }
  {
#line 131
  vsnprintf((char */* __restrict  */)(errmsg), sizeof(errmsg), (char const   */* __restrict  */)format,
            ap);
#line 132
  (*SPF_warning_handler)(file, line, (char const   *)(errmsg));
  }
#line 133
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
void ( /* format attribute */  SPF_infov)(char const   *file , int line , char const   *format ,
                                          va_list ap ) 
{ 
  char errmsg[800] ;

  {
#line 141
  if ((unsigned long )SPF_info_handler == (unsigned long )((void *)0)) {
#line 142
    return;
  }
  {
#line 144
  vsnprintf((char */* __restrict  */)(errmsg), sizeof(errmsg), (char const   */* __restrict  */)format,
            ap);
#line 145
  (*SPF_info_handler)(file, line, (char const   *)(errmsg));
  }
#line 146
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
void ( /* format attribute */  SPF_debugv)(char const   *file , int line , char const   *format ,
                                           va_list ap ) 
{ 
  char errmsg[800] ;

  {
#line 154
  if ((unsigned long )SPF_debug_handler == (unsigned long )((void *)0)) {
#line 155
    return;
  }
  {
#line 157
  vsnprintf((char */* __restrict  */)(errmsg), sizeof(errmsg), (char const   */* __restrict  */)format,
            ap);
#line 158
  (*SPF_debug_handler)(file, line, (char const   *)(errmsg));
  }
#line 159
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
void SPF_errorx2(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 170
  __builtin_va_start(ap, format);
#line 171
  SPF_errorv((char const   *)((void *)0), 0, format, ap);
#line 172
  __builtin_va_end(ap);
  }
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
void SPF_warningx2(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 179
  __builtin_va_start(ap, format);
#line 180
  SPF_warningv((char const   *)((void *)0), 0, format, ap);
#line 181
  __builtin_va_end(ap);
  }
#line 182
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
void SPF_infox2(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 188
  __builtin_va_start(ap, format);
#line 189
  SPF_infov((char const   *)((void *)0), 0, format, ap);
#line 190
  __builtin_va_end(ap);
  }
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log.c"
void SPF_debugx2(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 197
  __builtin_va_start(ap, format);
#line 198
  SPF_debugv((char const   *)((void *)0), 0, format, ap);
#line 199
  __builtin_va_end(ap);
  }
#line 200
  return;
}
}
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 95 "../../src/include/spf_log.h"
 __attribute__((__noreturn__)) void SPF_error_syslog(char const   *file , int line ,
                                                     char const   *errmsg ) ;
#line 96
void SPF_warning_syslog(char const   *file , int line , char const   *errmsg ) ;
#line 97
void SPF_info_syslog(char const   *file  __attribute__((__unused__)) , int line  __attribute__((__unused__)) ,
                     char const   *errmsg ) ;
#line 98
void SPF_debug_syslog(char const   *file , int line , char const   *errmsg ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_syslog.c"
 __attribute__((__noreturn__)) void SPF_error_syslog(char const   *file , int line ,
                                                     char const   *errmsg ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_syslog.c"
void SPF_error_syslog(char const   *file , int line , char const   *errmsg ) 
{ 
  char buf[128] ;

  {
#line 41
  if (file) {
    {
#line 42
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s:%d",
             file, line);
#line 43
    syslog((2 << 3) | 3, "%-20s %s", buf, errmsg);
    }
  } else {
    {
#line 46
    syslog((2 << 3) | 3, "%s", errmsg);
    }
  }
  {
#line 48
  abort();
  }
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_syslog.c"
void SPF_warning_syslog(char const   *file , int line , char const   *errmsg ) 
{ 
  char buf[128] ;

  {
#line 55
  if (file) {
    {
#line 56
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s:%d",
             file, line);
#line 57
    syslog((2 << 3) | 4, "%-20s %s", buf, errmsg);
    }
  } else {
    {
#line 60
    syslog((2 << 3) | 4, "%s", errmsg);
    }
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_syslog.c"
void SPF_info_syslog(char const   *file  __attribute__((__unused__)) , int line  __attribute__((__unused__)) ,
                     char const   *errmsg ) 
{ 


  {
  {
#line 67
  syslog((2 << 3) | 6, "%s", errmsg);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_syslog.c"
void SPF_debug_syslog(char const   *file , int line , char const   *errmsg ) 
{ 
  char buf[128] ;
  unsigned int tmp ;

  {
#line 73
  buf[0] = (char )'\000';
#line 73
  tmp = 1U;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (tmp >= 128U) {
#line 73
      goto while_break;
    }
#line 73
    buf[tmp] = (char)0;
#line 73
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  if (file) {
    {
#line 75
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s:%d",
             file, line);
#line 76
    syslog((2 << 3) | 7, "%-20s %s", buf, errmsg);
    }
  } else {
    {
#line 79
    syslog((2 << 3) | 7, "%s", errmsg);
    }
  }
#line 81
  return;
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 133 "../../src/include/spf_dns.h"
SPF_dns_rr_t *SPF_dns_rlookup(SPF_dns_server_t *spf_dns_server , struct in_addr ipv4 ,
                              ns_type rr_type , int should_cache ) ;
#line 136
SPF_dns_rr_t *SPF_dns_rlookup6(SPF_dns_server_t *spf_dns_server , struct in6_addr ipv6 ,
                               ns_type rr_type , int should_cache ) ;
#line 138 "../../src/include/spf_internal.h"
char *SPF_sanitize(SPF_server_t *spf_server___1 , char *str ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_explanation(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  char *buf ;
  size_t buflen ;
  void *tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 53
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 53, "%s", "spf_response is NULL");
      }
    }
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  spf_request = spf_response->spf_request;
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 55
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 55, "%s", "spf_request is NULL");
      }
    }
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  spf_server___1 = spf_request->spf_server;
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 57
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 57
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 57, "%s", "spf_server is NULL");
      }
    }
#line 57
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  spf_record = spf_response->spf_record_exp;
  {
#line 60
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 60
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 60
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 60, "%s", "spf_record is NULL");
      }
    }
#line 60
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 62
  if (spf_response->explanation) {
    {
#line 63
    free((void *)spf_response->explanation);
    }
  }
  {
#line 64
  spf_response->explanation = (char *)((void *)0);
#line 66
  buflen = (size_t )321;
#line 67
  tmp = malloc(buflen);
#line 67
  buf = (char *)tmp;
  }
#line 68
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 69
    return ((SPF_errcode_t )1);
  }
  {
#line 70
  memset((void *)buf, '\000', buflen);
#line 72
  err = SPF_request_get_exp(spf_server___1, spf_request, spf_response, spf_record,
                            & buf, & buflen);
  }
#line 74
  if ((unsigned int )err != 0U) {
    {
#line 75
    free((void *)buf);
    }
#line 76
    return (err);
  }
#line 79
  spf_response->explanation = buf;
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_smtp_comment(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_errcode_t err ;
  char buf[320] ;
  char const   *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 92
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 92, "%s", "spf_response is NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  spf_request = spf_response->spf_request;
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 94, "%s", "spf_request is NULL");
      }
    }
#line 94
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  spf_server___1 = spf_request->spf_server;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 96, "%s", "spf_server is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  if (spf_response->smtp_comment) {
    {
#line 99
    free((void *)spf_response->smtp_comment);
    }
  }
#line 100
  spf_response->smtp_comment = (char *)((void *)0);
  {
#line 107
  if ((unsigned int )spf_response->result == 5U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 1U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 4U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 3U) {
#line 107
    goto case_5;
  }
#line 129
  goto switch_default;
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 109
  err = SPF_i_set_explanation(spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
#line 111
    return (err);
  }
  {
#line 113
  memset((void *)(buf), '\000', sizeof(buf));
#line 114
  tmp = SPF_strreason(spf_response->reason);
#line 114
  snprintf((char */* __restrict  */)(buf), (size_t )320, (char const   */* __restrict  */)"%s : Reason: %s",
           spf_response->explanation, tmp);
#line 117
  buf[319] = (char )'\000';
#line 120
  spf_response->smtp_comment = strdup((char const   *)(buf));
  }
#line 121
  if (! spf_response->smtp_comment) {
#line 122
    return ((SPF_errcode_t )1);
  }
#line 124
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 130
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 133
  return ((SPF_errcode_t )0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_header_comment(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char *spf_source ;
  size_t len ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  char *sender_dom ;
  char *p ;
  char *p_end ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 153
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 153, "%s", "spf_response is NULL");
      }
    }
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  spf_request = spf_response->spf_request;
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 155
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 155, "%s", "spf_request is NULL");
      }
    }
#line 155
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 156
  spf_server___1 = spf_request->spf_server;
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 157
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 157, "%s", "spf_server is NULL");
      }
    }
#line 157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 159
  if (spf_response->header_comment) {
    {
#line 160
    free((void *)spf_response->header_comment);
    }
  }
#line 161
  spf_response->header_comment = (char *)((void *)0);
#line 164
  sender_dom = spf_request->env_from_dp;
#line 165
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
#line 166
    sender_dom = spf_request->helo_dom;
  }
#line 168
  if ((unsigned int )spf_response->reason == 3U) {
    {
#line 169
    spf_source = strdup("local policy");
    }
  } else
#line 171
  if ((unsigned int )spf_response->reason == 6U) {
#line 172
    if ((unsigned long )spf_request->rcpt_to_dom == (unsigned long )((void *)0)) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    } else
#line 172
    if ((int )*(spf_request->rcpt_to_dom + 0) == 0) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    }
    {
#line 175
    spf_source = strdup((char const   *)spf_request->rcpt_to_dom);
    }
  } else
#line 177
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
    {
#line 178
    spf_source = strdup("unknown domain");
    }
  } else {
    {
#line 181
    tmp = strlen((char const   *)sender_dom);
#line 181
    len = tmp + sizeof("domain of ");
#line 182
    tmp___0 = malloc(len);
#line 182
    spf_source = (char *)tmp___0;
    }
#line 183
    if (spf_source) {
      {
#line 184
      snprintf((char */* __restrict  */)spf_source, len, (char const   */* __restrict  */)"domain of %s",
               sender_dom);
      }
    }
  }
#line 187
  if ((unsigned long )spf_source == (unsigned long )((void *)0)) {
#line 188
    return ((SPF_errcode_t )10);
  }
#line 190
  ip = (char const   *)((void *)0);
#line 191
  if (spf_request->client_ver == 2) {
    {
#line 192
    ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                   (socklen_t )sizeof(ip4_buf));
    }
  } else
#line 195
  if (spf_request->client_ver == 10) {
    {
#line 196
    ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                   (socklen_t )sizeof(ip6_buf));
    }
  }
#line 199
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 200
    ip = "(unknown ip address)";
  }
  {
#line 202
  tmp___1 = SPF_request_get_rec_dom(spf_request);
#line 202
  tmp___2 = strlen(tmp___1);
#line 202
  tmp___3 = strlen((char const   *)spf_source);
#line 202
  tmp___4 = strlen(ip);
#line 202
  len = ((tmp___2 + tmp___3) + tmp___4) + 80UL;
#line 203
  tmp___5 = malloc(len);
#line 203
  buf = (char *)tmp___5;
  }
#line 204
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 205
    free((void *)spf_source);
    }
#line 206
    return ((SPF_errcode_t )10);
  }
  {
#line 209
  p = buf;
#line 210
  p_end = p + len;
#line 213
  tmp___6 = SPF_request_get_rec_dom(spf_request);
#line 213
  tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s: ",
                     tmp___6);
#line 213
  p += tmp___7;
  }
  {
#line 217
  if ((unsigned int )spf_response->result == 2U) {
#line 217
    goto case_2;
  }
#line 228
  if ((unsigned int )spf_response->result == 3U) {
#line 228
    goto case_3;
  }
#line 233
  if ((unsigned int )spf_response->result == 4U) {
#line 233
    goto case_4;
  }
#line 238
  if ((unsigned int )spf_response->result == 7U) {
#line 238
    goto case_7;
  }
#line 243
  if ((unsigned int )spf_response->result == 1U) {
#line 243
    goto case_1;
  }
#line 247
  if ((unsigned int )spf_response->result == 5U) {
#line 247
    goto case_5;
  }
#line 252
  if ((unsigned int )spf_response->result == 6U) {
#line 252
    goto case_6;
  }
#line 258
  goto switch_default;
  case_2: /* CIL Label */ 
#line 218
  if ((unsigned int )spf_response->reason == 2U) {
    {
#line 219
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"localhost is always allowed.");
    }
  } else
#line 220
  if ((unsigned int )spf_response->reason == 6U) {
    {
#line 221
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"message received from %s which is an MX secondary for %s.",
             ip, spf_source);
    }
  } else {
    {
#line 224
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s designates %s as permitted sender",
             spf_source, ip);
    }
  }
#line 226
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 229
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 231
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 234
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"transitioning %s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 236
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 239
  tmp___8 = SPF_strerror(spf_response->err);
#line 239
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error in processing during lookup of %s: %s",
           spf_source, tmp___8);
  }
#line 241
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 244
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s is neither permitted nor denied by %s",
           ip, spf_source);
  }
#line 246
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 248
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not provide an SPF record",
           spf_source);
  }
#line 250
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 253
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"encountered temporary error during SPF processing of %s",
           spf_source);
  }
#line 255
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 259
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error: unknown SPF result %d encountered while checking %s for %s",
           (unsigned int )spf_response->result, ip, spf_source);
  }
#line 261
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 264
  if (spf_source) {
    {
#line 265
    free((void *)spf_source);
    }
  }
  {
#line 267
  spf_response->header_comment = SPF_sanitize(spf_server___1, buf);
  }
#line 269
  return ((SPF_errcode_t )0);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_received_spf(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  size_t buflen ;
  char *buf_value ;
  char *p ;
  char *p_end ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 282
  buflen = (size_t )480;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 287
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 287, "%s", "spf_response is NULL");
      }
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  spf_request = spf_response->spf_request;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 289
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 289, "%s", "spf_request is NULL");
      }
    }
#line 289
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  spf_server___1 = spf_request->spf_server;
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 291
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 291
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 291, "%s", "spf_server is NULL");
      }
    }
#line 291
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 293
  if (spf_response->received_spf) {
    {
#line 294
    free((void *)spf_response->received_spf);
    }
  }
  {
#line 295
  spf_response->received_spf = (char *)((void *)0);
#line 297
  tmp = malloc(buflen);
#line 297
  buf = (char *)tmp;
  }
#line 298
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 299
    return ((SPF_errcode_t )10);
  }
  {
#line 301
  p = buf;
#line 302
  p_end = p + buflen;
#line 306
  tmp___0 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"Received-SPF: ");
#line 306
  p += tmp___0;
#line 307
  buf_value = p;
  }
  {
#line 309
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 310
    tmp___1 = SPF_strresult(spf_response->result);
#line 310
    tmp___2 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s (%s)",
                       tmp___1, spf_response->header_comment);
#line 310
    p += tmp___2;
    }
#line 313
    if (p_end - p <= 0L) {
#line 313
      goto while_break___2;
    }
#line 318
    ip = (char const   *)((void *)0);
#line 319
    if (spf_request->client_ver == 2) {
      {
#line 320
      ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                     (socklen_t )sizeof(ip4_buf));
      }
    } else
#line 323
    if (spf_request->client_ver == 10) {
      {
#line 324
      ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                     (socklen_t )sizeof(ip6_buf));
      }
    }
#line 328
    if ((unsigned long )ip != (unsigned long )((void *)0)) {
      {
#line 329
      tmp___3 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" client-ip=%s;",
                         ip);
#line 329
      p += tmp___3;
      }
#line 330
      if (p_end - p <= 0L) {
#line 330
        goto while_break___2;
      }
    }
#line 335
    if ((unsigned long )spf_request->env_from != (unsigned long )((void *)0)) {
      {
#line 336
      tmp___4 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" envelope-from=%s;",
                         spf_request->env_from);
#line 336
      p += tmp___4;
      }
#line 337
      if (p_end - p <= 0L) {
#line 337
        goto while_break___2;
      }
    }
#line 342
    if ((unsigned long )spf_request->helo_dom != (unsigned long )((void *)0)) {
      {
#line 343
      tmp___5 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" helo=%s;",
                         spf_request->helo_dom);
#line 343
      p += tmp___5;
      }
#line 344
      if (p_end - p <= 0L) {
#line 344
        goto while_break___2;
      }
    }
#line 309
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 366
  spf_response->received_spf = SPF_sanitize(spf_server___1, buf);
#line 367
  spf_response->received_spf_value = buf_value;
  }
#line 369
  return ((SPF_errcode_t )0);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
SPF_errcode_t SPF_i_done(SPF_response_t *spf_response , SPF_result_t result , SPF_reason_t reason ,
                         SPF_errcode_t err ) 
{ 
  SPF_request_t *spf_request ;
  SPF_server_t *spf_server___1 ;

  {
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 394
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 394, "%s", "spf_response is NULL");
      }
    }
#line 394
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  spf_request = spf_response->spf_request;
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 396
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 396, "%s", "spf_request is NULL");
      }
    }
#line 396
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 397
  spf_server___1 = spf_request->spf_server;
  {
#line 398
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 398
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 398
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 398, "%s", "spf_server is NULL");
      }
    }
#line 398
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 400
  spf_response->result = result;
#line 401
  spf_response->reason = reason;
#line 402
  spf_response->err = err;
#line 404
  SPF_i_set_smtp_comment(spf_response);
#line 405
  SPF_i_set_header_comment(spf_response);
#line 406
  SPF_i_set_received_spf(spf_response);
  }
#line 408
  return (err);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_mech_cidr(SPF_request_t *spf_request , SPF_mech_t *mech ) 
{ 
  SPF_data_t *data ;
  SPF_data_t *tmp ;

  {
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if ((unsigned long )mech == (unsigned long )((void *)0)) {
      {
#line 428
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 428, "%s", "mech is NULL");
      }
    }
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  if ((int )mech->mech_type == 6) {
#line 433
    goto case_6;
  }
#line 433
  if ((int )mech->mech_type == 5) {
#line 433
    goto case_6;
  }
#line 438
  if ((int )mech->mech_type == 2) {
#line 438
    goto case_2;
  }
#line 438
  if ((int )mech->mech_type == 1) {
#line 438
    goto case_2;
  }
#line 430
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 434
  return ((int )mech->mech_len);
#line 435
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 439
  data = SPF_mech_data(mech);
#line 441
  tmp = SPF_mech_end_data(mech);
  }
#line 441
  if ((unsigned long )data < (unsigned long )tmp) {
#line 441
    if ((int )data->dc.parm_type == 11) {
#line 444
      if (spf_request->client_ver == 2) {
#line 445
        return ((int )data->dc.ipv4);
      } else
#line 446
      if (spf_request->client_ver == 10) {
#line 447
        return ((int )data->dc.ipv6);
      }
    }
  }
#line 449
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 452
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip4(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                           SPF_mech_t *mech , struct in_addr ipv4 ) 
{ 
  char src_ip4_buf[16] ;
  char dst_ip4_buf[16] ;
  char mask_ip4_buf[16] ;
  struct in_addr src_ipv4 ;
  int cidr ;
  int mask ;
  uint32_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 471
  if (spf_request->client_ver != 2) {
#line 472
    return (0);
  }
  {
#line 474
  src_ipv4 = spf_request->ipv4;
#line 476
  cidr = SPF_i_mech_cidr(spf_request, mech);
  }
#line 477
  if (cidr == 0) {
#line 478
    cidr = 32;
  }
  {
#line 479
  mask = (int )(4294967295U << (32 - cidr));
#line 480
  tmp = htonl((uint32_t )mask);
#line 480
  mask = (int )tmp;
  }
#line 482
  if (spf_server___1->debug) {
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 483
      tmp___0 = inet_ntop(2, (void const   */* __restrict  */)(& src_ipv4.s_addr),
                          (char */* __restrict  */)(src_ip4_buf), (socklen_t )sizeof(src_ip4_buf));
      }
#line 483
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 483
        snprintf((char */* __restrict  */)(src_ip4_buf), sizeof(src_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 483
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 485
      tmp___1 = inet_ntop(2, (void const   */* __restrict  */)(& ipv4.s_addr), (char */* __restrict  */)(dst_ip4_buf),
                          (socklen_t )sizeof(dst_ip4_buf));
      }
#line 485
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 485
        snprintf((char */* __restrict  */)(dst_ip4_buf), sizeof(dst_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 487
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 487
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& mask), (char */* __restrict  */)(mask_ip4_buf),
                          (socklen_t )sizeof(mask_ip4_buf));
      }
#line 487
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
#line 487
        snprintf((char */* __restrict  */)(mask_ip4_buf), sizeof(mask_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 487
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 489
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               491, "ip_match:  %s == %s  (/%d %s):  %d", src_ip4_buf, dst_ip4_buf,
               cidr, mask_ip4_buf, (src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
    }
  }
#line 494
  return ((src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip6(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                           SPF_mech_t *mech , struct in6_addr ipv6 ) 
{ 
  char src_ip6_buf[46] ;
  char dst_ip6_buf[46] ;
  struct in6_addr src_ipv6 ;
  int cidr ;
  int cidr_save ;
  int mask ;
  int i ;
  int match ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 512
  if (spf_request->client_ver != 10) {
#line 513
    return (0);
  }
  {
#line 515
  src_ipv6 = spf_request->ipv6;
#line 517
  cidr = SPF_i_mech_cidr(spf_request, mech);
  }
#line 518
  if (cidr == 0) {
#line 519
    cidr = 128;
  }
#line 520
  cidr_save = cidr;
#line 522
  match = 1;
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if ((long )i < (long )(sizeof(ipv6.__in6_u.__u6_addr8) / sizeof(ipv6.__in6_u.__u6_addr8[0]))) {
#line 523
      if (! match) {
#line 523
        goto while_break;
      }
    } else {
#line 523
      goto while_break;
    }
#line 525
    if (cidr > 8) {
#line 526
      mask = 255;
    } else
#line 527
    if (cidr > 0) {
#line 528
      mask = (255 << (8 - cidr)) & 255;
    } else {
#line 530
      goto while_break;
    }
#line 531
    cidr -= 8;
#line 533
    match = ((int )src_ipv6.__in6_u.__u6_addr8[i] & mask) == ((int )ipv6.__in6_u.__u6_addr8[i] & mask);
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (spf_server___1->debug) {
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 537
      tmp = inet_ntop(10, (void const   */* __restrict  */)(& src_ipv6.__in6_u.__u6_addr8),
                      (char */* __restrict  */)(src_ip6_buf), (socklen_t )sizeof(src_ip6_buf));
      }
#line 537
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 537
        snprintf((char */* __restrict  */)(src_ip6_buf), sizeof(src_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 537
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 539
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 539
      tmp___0 = inet_ntop(10, (void const   */* __restrict  */)(& ipv6.__in6_u.__u6_addr8),
                          (char */* __restrict  */)(dst_ip6_buf), (socklen_t )sizeof(dst_ip6_buf));
      }
#line 539
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 539
        snprintf((char */* __restrict  */)(dst_ip6_buf), sizeof(dst_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 539
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 541
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               542, "ip_match:  %s == %s  (/%d):  %d", src_ip6_buf, dst_ip6_buf, cidr_save,
               match);
    }
  }
#line 545
  return (match);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_domain(SPF_server_t *spf_server___1 , char const   *hostname ,
                              char const   *domain ) 
{ 
  char const   *hp ;
  size_t hlen ;
  size_t dlen ;
  int tmp ;
  int tmp___0 ;

  {
#line 556
  if (spf_server___1->debug) {
    {
#line 557
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               557, "%s ?=? %s", hostname, domain);
    }
  }
  {
#line 559
  hlen = strlen(hostname);
#line 560
  dlen = strlen(domain);
  }
#line 563
  if (dlen > hlen) {
#line 564
    return (0);
  }
#line 567
  if (dlen == hlen) {
    {
#line 568
    tmp = strcasecmp(hostname, domain);
    }
#line 568
    return (tmp == 0);
  }
#line 571
  hp = hostname + (hlen - dlen);
#line 573
  if ((int const   )*(hp - 1) != 46) {
#line 574
    return (0);
  }
  {
#line 576
  tmp___0 = strcasecmp(hp, domain);
  }
#line 576
  return (tmp___0 == 0);
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
SPF_errcode_t SPF_record_interpret(SPF_record_t *spf_record , SPF_request_t *spf_request ,
                                   SPF_response_t *spf_response , int depth ) 
{ 
  SPF_server_t *spf_server___1 ;
  int i ;
  int j ;
  int m ;
  SPF_mech_t *mech ;
  SPF_data_t *data ;
  SPF_data_t *data_end ;
  SPF_mech_t *local_policy ;
  int found_all ;
  char *buf ;
  size_t buf_len ;
  ns_type fetch_ns_type ;
  char const   *lookup ;
  SPF_dns_rr_t *rr_a ;
  SPF_dns_rr_t *rr_aaaa ;
  SPF_dns_rr_t *rr_ptr ;
  SPF_dns_rr_t *rr_mx ;
  SPF_errcode_t err ;
  SPF_dns_server_t *resolver ;
  SPF_record_t *spf_record_subr ;
  SPF_response_t *save_spf_response ;
  SPF_response_t *spf_response_subr ;
  char const   *save_cur_dom ;
  struct in_addr addr4 ;
  struct in6_addr addr6 ;
  int max_ptr ;
  int max_mx ;
  int max_exceeded ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  SPF_errcode_t tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;
  SPF_errcode_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  SPF_errcode_t tmp___6 ;
  int tmp___7 ;
  SPF_errcode_t tmp___8 ;
  int tmp___9 ;
  SPF_errcode_t tmp___10 ;
  SPF_errcode_t tmp___11 ;
  SPF_errcode_t tmp___12 ;
  SPF_errcode_t tmp___13 ;
  SPF_errcode_t tmp___14 ;
  int tmp___15 ;
  SPF_errcode_t tmp___16 ;
  int tmp___17 ;
  SPF_errcode_t tmp___18 ;
  SPF_errcode_t tmp___19 ;
  SPF_errcode_t tmp___20 ;
  char const   *tmp___21 ;
  SPF_errcode_t tmp___22 ;
  SPF_errcode_t tmp___23 ;
  char const   *tmp___24 ;
  SPF_errcode_t tmp___25 ;
  int tmp___26 ;
  SPF_errcode_t tmp___27 ;
  char const   *tmp___28 ;
  SPF_errcode_t tmp___29 ;
  SPF_errcode_t tmp___30 ;
  char const   *tmp___31 ;
  SPF_errcode_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  SPF_errcode_t tmp___35 ;
  size_t tmp___36 ;
  SPF_data_t *tmp___37 ;
  SPF_errcode_t tmp___38 ;
  SPF_errcode_t tmp___39 ;
  SPF_errcode_t tmp___40 ;
  int tmp___41 ;
  char const   *tmp___42 ;
  SPF_errcode_t tmp___43 ;
  SPF_errcode_t tmp___44 ;
  SPF_errcode_t tmp___45 ;
  char const   *tmp___46 ;
  char const   *tmp___47 ;
  char const   *tmp___48 ;
  SPF_result_t tmp___49 ;
  SPF_errcode_t tmp___50 ;
  SPF_errcode_t tmp___51 ;
  SPF_errcode_t tmp___52 ;
  SPF_errcode_t tmp___53 ;
  struct in_addr *tmp___54 ;
  SPF_errcode_t tmp___55 ;
  int tmp___56 ;
  struct in6_addr *tmp___57 ;
  SPF_errcode_t tmp___58 ;
  int tmp___59 ;
  size_t tmp___60 ;
  SPF_data_t *tmp___61 ;
  SPF_errcode_t tmp___62 ;
  SPF_errcode_t tmp___63 ;
  SPF_errcode_t tmp___64 ;
  SPF_errcode_t tmp___65 ;
  SPF_errcode_t tmp___66 ;
  SPF_errcode_t tmp___67 ;
  char const   *tmp___68 ;
  char const   *tmp___69 ;
  char const   *tmp___70 ;
  SPF_errcode_t tmp___71 ;

  {
#line 602
  buf = (char *)((void *)0);
#line 603
  buf_len = (size_t )0;
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 637
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 637, "%s", "spf_record is NULL");
      }
    }
#line 637
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 638
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 638
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 638
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 638, "%s", "spf_request is NULL");
      }
    }
#line 638
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 639
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 639
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 639
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 639, "%s", "spf_response is NULL");
      }
    }
#line 639
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 640
  spf_server___1 = spf_record->spf_server;
  {
#line 641
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 641
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 641
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 641, "%s", "spf_server is NULL");
      }
    }
#line 641
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 643
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 643
    if ((unsigned long )spf_response->spf_record_exp == (unsigned long )((void *)0)) {
      {
#line 643
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 643, "%s", "spf_response->spf_record_exp is NULL");
      }
    }
#line 643
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 645
  if (depth > 20) {
    {
#line 646
    tmp = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, (SPF_errcode_t )31);
    }
#line 646
    return (tmp);
  }
#line 648
  if (spf_request->client_ver != 2) {
#line 648
    if (spf_request->client_ver != 10) {
      {
#line 649
      tmp___0 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, (SPF_errcode_t )25);
      }
#line 649
      return (tmp___0);
    }
  }
#line 651
  if ((unsigned long )spf_request->cur_dom == (unsigned long )((void *)0)) {
    {
#line 652
    tmp___1 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, (SPF_errcode_t )25);
    }
#line 652
    return (tmp___1);
  }
#line 669
  local_policy = (SPF_mech_t *)((void *)0);
#line 671
  if (spf_request->use_local_policy) {
#line 688
    if (spf_server___1->local_policy) {
#line 689
      mech = spf_record->mech_first;
#line 691
      found_all = 0;
#line 692
      m = 0;
      {
#line 692
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 692
        if (! (m < (int )spf_record->num_mech)) {
#line 692
          goto while_break___4;
        }
#line 694
        if ((int )mech->mech_type == 8) {
#line 694
          if ((int )mech->prefix_type == 3) {
#line 700
            found_all = 1;
          } else
#line 694
          if ((int )mech->prefix_type == 7) {
#line 700
            found_all = 1;
          } else
#line 694
          if ((int )mech->prefix_type == 4) {
#line 700
            found_all = 1;
          }
        }
#line 702
        if ((int )mech->prefix_type != 3) {
#line 702
          if ((int )mech->prefix_type != 4) {
#line 705
            local_policy = mech;
          }
        }
        {
#line 707
        mech = SPF_mech_next(mech);
#line 692
        m ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 710
      if (! found_all) {
#line 711
        local_policy = (SPF_mech_t *)((void *)0);
      }
    }
  }
#line 753
  resolver = spf_server___1->resolver;
#line 755
  mech = spf_record->mech_first;
#line 756
  m = 0;
  {
#line 756
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 756
    if (! (m < (int )spf_record->num_mech)) {
#line 756
      goto while_break___5;
    }
#line 760
    if (spf_response->num_dns_mech > spf_server___1->max_dns_mech) {
      {
#line 761
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 761
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 761
          free((void *)buf);
#line 761
          buf = (char *)((void *)0);
          }
        }
#line 761
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 762
      tmp___2 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, (SPF_errcode_t )18);
      }
#line 762
      return (tmp___2);
    }
    {
#line 765
    data = SPF_mech_data(mech);
#line 766
    data_end = SPF_mech_end_data(mech);
    }
    {
#line 769
    if ((int )mech->mech_type == 1) {
#line 769
      goto case_1;
    }
#line 815
    if ((int )mech->mech_type == 2) {
#line 815
      goto case_2;
    }
#line 899
    if ((int )mech->mech_type == 3) {
#line 899
      goto case_3;
    }
#line 1051
    if ((int )mech->mech_type == 9) {
#line 1051
      goto case_9;
    }
#line 1051
    if ((int )mech->mech_type == 4) {
#line 1051
      goto case_9;
    }
#line 1198
    if ((int )mech->mech_type == 5) {
#line 1198
      goto case_5___0;
    }
#line 1206
    if ((int )mech->mech_type == 6) {
#line 1206
      goto case_6___0;
    }
#line 1214
    if ((int )mech->mech_type == 7) {
#line 1214
      goto case_7___0;
    }
#line 1247
    if ((int )mech->mech_type == 8) {
#line 1247
      goto case_8;
    }
#line 1254
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 770
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 770
      (spf_response->num_dns_mech) ++;
#line 770
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 771
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 771
      if ((unsigned long )data < (unsigned long )data_end) {
#line 771
        if ((int )data->dc.parm_type == 11) {
          {
#line 771
          data = SPF_data_next(data);
          }
        }
      }
#line 771
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 772
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 772
      if ((unsigned long )data == (unsigned long )data_end) {
#line 772
        lookup = spf_request->cur_dom;
      } else {
        {
#line 772
        err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, data,
                                     (size_t )((char *)data_end - (char *)data), & buf,
                                     & buf_len);
        }
#line 772
        if ((unsigned int )err == 1U) {
          {
#line 772
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 772
            if ((unsigned long )buf != (unsigned long )((void *)0)) {
              {
#line 772
              free((void *)buf);
#line 772
              buf = (char *)((void *)0);
              }
            }
#line 772
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 772
          tmp___3 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0, err);
          }
#line 772
          return (tmp___3);
        }
#line 772
        if (err) {
          {
#line 772
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 772
            if ((unsigned long )buf != (unsigned long )((void *)0)) {
              {
#line 772
              free((void *)buf);
#line 772
              buf = (char *)((void *)0);
              }
            }
#line 772
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 772
          tmp___4 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, err);
          }
#line 772
          return (tmp___4);
        }
#line 772
        lookup = (char const   *)buf;
      }
#line 772
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 774
    if (spf_request->client_ver == 2) {
#line 775
      fetch_ns_type = (ns_type )1;
    } else {
#line 777
      fetch_ns_type = (ns_type )28;
    }
    {
#line 779
    rr_a = SPF_dns_lookup(resolver, lookup, fetch_ns_type, 1);
    }
#line 781
    if (spf_server___1->debug) {
      {
#line 782
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 783, "found %d A records for %s  (herrno: %d)", rr_a->num_rr, lookup,
                 rr_a->herrno);
      }
    }
#line 785
    if (rr_a->herrno == 2) {
      {
#line 786
      SPF_dns_rr_free(rr_a);
      }
      {
#line 787
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 787
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 787
          free((void *)buf);
#line 787
          buf = (char *)((void *)0);
          }
        }
#line 787
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 788
      tmp___5 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0, (SPF_errcode_t )26);
      }
#line 788
      return (tmp___5);
    }
#line 791
    i = 0;
    {
#line 791
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 791
      if (! (i < rr_a->num_rr)) {
#line 791
        goto while_break___13;
      }
#line 793
      if ((unsigned int )rr_a->rr_type != (unsigned int )fetch_ns_type) {
#line 794
        goto __Cont;
      }
#line 796
      if (spf_request->client_ver == 2) {
        {
#line 797
        tmp___7 = SPF_i_match_ip4(spf_server___1, spf_request, mech, (*(rr_a->rr + i))->a);
        }
#line 797
        if (tmp___7) {
          {
#line 798
          SPF_dns_rr_free(rr_a);
          }
          {
#line 799
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 799
            if ((unsigned long )buf != (unsigned long )((void *)0)) {
              {
#line 799
              free((void *)buf);
#line 799
              buf = (char *)((void *)0);
              }
            }
#line 799
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
          {
#line 800
          tmp___6 = SPF_i_done(spf_response, (SPF_result_t )mech->prefix_type, (SPF_reason_t )4,
                               (SPF_errcode_t )0);
          }
#line 800
          return (tmp___6);
        }
      } else {
        {
#line 804
        tmp___9 = SPF_i_match_ip6(spf_server___1, spf_request, mech, (*(rr_a->rr + i))->aaaa);
        }
#line 804
        if (tmp___9) {
          {
#line 805
          SPF_dns_rr_free(rr_a);
          }
          {
#line 806
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 806
            if ((unsigned long )buf != (unsigned long )((void *)0)) {
              {
#line 806
              free((void *)buf);
#line 806
              buf = (char *)((void *)0);
              }
            }
#line 806
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
          {
#line 807
          tmp___8 = SPF_i_done(spf_response, (SPF_result_t )mech->prefix_type, (SPF_reason_t )4,
                               (SPF_errcode_t )0);
          }
#line 807
          return (tmp___8);
        }
      }
      __Cont: /* CIL Label */ 
#line 791
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 812
    SPF_dns_rr_free(rr_a);
    }
#line 813
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 816
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 816
      (spf_response->num_dns_mech) ++;
#line 816
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 817
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 817
      if ((unsigned long )data < (unsigned long )data_end) {
#line 817
        if ((int )data->dc.parm_type == 11) {
          {
#line 817
          data = SPF_data_next(data);
          }
        }
      }
#line 817
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 818
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 818
      if ((unsigned long )data == (unsigned long )data_end) {
#line 818
        lookup = spf_request->cur_dom;
      } else {
        {
#line 818
        err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, data,
                                     (size_t )((char *)data_end - (char *)data), & buf,
                                     & buf_len);
        }
#line 818
        if ((unsigned int )err == 1U) {
          {
#line 818
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 818
            if ((unsigned long )buf != (unsigned long )((void *)0)) {
              {
#line 818
              free((void *)buf);
#line 818
              buf = (char *)((void *)0);
              }
            }
#line 818
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
          {
#line 818
          tmp___10 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0,
                                err);
          }
#line 818
          return (tmp___10);
        }
#line 818
        if (err) {
          {
#line 818
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 818
            if ((unsigned long )buf != (unsigned long )((void *)0)) {
              {
#line 818
              free((void *)buf);
#line 818
              buf = (char *)((void *)0);
              }
            }
#line 818
            goto while_break___20;
          }
          while_break___20: /* CIL Label */ ;
          }
          {
#line 818
          tmp___11 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0,
                                err);
          }
#line 818
          return (tmp___11);
        }
#line 818
        lookup = (char const   *)buf;
      }
#line 818
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 820
    rr_mx = SPF_dns_lookup(resolver, lookup, (ns_type )15, 1);
    }
#line 822
    if (spf_server___1->debug) {
      {
#line 823
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 824, "found %d MX records for %s  (herrno: %d)", rr_mx->num_rr, lookup,
                 rr_mx->herrno);
      }
    }
#line 826
    if (rr_mx->herrno == 2) {
      {
#line 827
      SPF_dns_rr_free(rr_mx);
      }
      {
#line 828
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 828
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 828
          free((void *)buf);
#line 828
          buf = (char *)((void *)0);
          }
        }
#line 828
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
      {
#line 829
      tmp___12 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0, (SPF_errcode_t )26);
      }
#line 829
      return (tmp___12);
    }
#line 833
    max_mx = rr_mx->num_rr;
#line 834
    max_exceeded = 0;
#line 835
    if (max_mx > spf_server___1->max_dns_mx) {
      {
#line 836
      max_exceeded = 1;
#line 837
      max_mx = SPF_server_get_max_dns_mx(spf_server___1);
      }
    }
#line 840
    j = 0;
    {
#line 840
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 840
      if (! (j < max_mx)) {
#line 840
        goto while_break___22;
      }
#line 842
      if ((unsigned int )rr_mx->rr_type != 15U) {
#line 843
        goto __Cont___0;
      }
#line 845
      if (spf_request->client_ver == 2) {
#line 846
        fetch_ns_type = (ns_type )1;
      } else {
#line 848
        fetch_ns_type = (ns_type )28;
      }
      {
#line 850
      rr_a = SPF_dns_lookup(resolver, (char const   *)((*(rr_mx->rr + j))->mx), fetch_ns_type,
                            1);
      }
#line 853
      if (spf_server___1->debug) {
        {
#line 854
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                   855, "%d: found %d A records for %s  (herrno: %d)", j, rr_a->num_rr,
                   (*(rr_mx->rr + j))->mx, rr_a->herrno);
        }
      }
#line 856
      if (rr_a->herrno == 2) {
        {
#line 857
        SPF_dns_rr_free(rr_mx);
#line 858
        SPF_dns_rr_free(rr_a);
        }
        {
#line 859
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 859
          if ((unsigned long )buf != (unsigned long )((void *)0)) {
            {
#line 859
            free((void *)buf);
#line 859
            buf = (char *)((void *)0);
            }
          }
#line 859
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
        {
#line 860
        tmp___13 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0, (SPF_errcode_t )26);
        }
#line 860
        return (tmp___13);
      }
#line 863
      i = 0;
      {
#line 863
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 863
        if (! (i < rr_a->num_rr)) {
#line 863
          goto while_break___24;
        }
#line 865
        if ((unsigned int )rr_a->rr_type != (unsigned int )fetch_ns_type) {
#line 866
          goto __Cont___1;
        }
#line 868
        if (spf_request->client_ver == 2) {
          {
#line 869
          tmp___15 = SPF_i_match_ip4(spf_server___1, spf_request, mech, (*(rr_a->rr + i))->a);
          }
#line 869
          if (tmp___15) {
            {
#line 871
            SPF_dns_rr_free(rr_mx);
#line 872
            SPF_dns_rr_free(rr_a);
            }
            {
#line 873
            while (1) {
              while_continue___25: /* CIL Label */ ;
#line 873
              if ((unsigned long )buf != (unsigned long )((void *)0)) {
                {
#line 873
                free((void *)buf);
#line 873
                buf = (char *)((void *)0);
                }
              }
#line 873
              goto while_break___25;
            }
            while_break___25: /* CIL Label */ ;
            }
            {
#line 874
            tmp___14 = SPF_i_done(spf_response, (SPF_result_t )mech->prefix_type,
                                  (SPF_reason_t )4, (SPF_errcode_t )0);
            }
#line 874
            return (tmp___14);
          }
        } else {
          {
#line 879
          tmp___17 = SPF_i_match_ip6(spf_server___1, spf_request, mech, (*(rr_a->rr + i))->aaaa);
          }
#line 879
          if (tmp___17) {
            {
#line 881
            SPF_dns_rr_free(rr_mx);
#line 882
            SPF_dns_rr_free(rr_a);
            }
            {
#line 883
            while (1) {
              while_continue___26: /* CIL Label */ ;
#line 883
              if ((unsigned long )buf != (unsigned long )((void *)0)) {
                {
#line 883
                free((void *)buf);
#line 883
                buf = (char *)((void *)0);
                }
              }
#line 883
              goto while_break___26;
            }
            while_break___26: /* CIL Label */ ;
            }
            {
#line 884
            tmp___16 = SPF_i_done(spf_response, (SPF_result_t )mech->prefix_type,
                                  (SPF_reason_t )4, (SPF_errcode_t )0);
            }
#line 884
            return (tmp___16);
          }
        }
        __Cont___1: /* CIL Label */ 
#line 863
        i ++;
      }
      while_break___24: /* CIL Label */ ;
      }
      {
#line 889
      SPF_dns_rr_free(rr_a);
      }
      __Cont___0: /* CIL Label */ 
#line 840
      j ++;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 892
    SPF_dns_rr_free(rr_mx);
    }
#line 893
    if (max_exceeded) {
      {
#line 894
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 894
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 894
          free((void *)buf);
#line 894
          buf = (char *)((void *)0);
          }
        }
#line 894
        goto while_break___27;
      }
      while_break___27: /* CIL Label */ ;
      }
      {
#line 895
      tmp___18 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, (SPF_errcode_t )18);
      }
#line 895
      return (tmp___18);
    }
#line 897
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 900
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 900
      (spf_response->num_dns_mech) ++;
#line 900
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 901
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 901
      if ((unsigned long )data == (unsigned long )data_end) {
#line 901
        lookup = spf_request->cur_dom;
      } else {
        {
#line 901
        err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, data,
                                     (size_t )((char *)data_end - (char *)data), & buf,
                                     & buf_len);
        }
#line 901
        if ((unsigned int )err == 1U) {
          {
#line 901
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 901
            if ((unsigned long )buf != (unsigned long )((void *)0)) {
              {
#line 901
              free((void *)buf);
#line 901
              buf = (char *)((void *)0);
              }
            }
#line 901
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 901
          tmp___19 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0,
                                err);
          }
#line 901
          return (tmp___19);
        }
#line 901
        if (err) {
          {
#line 901
          while (1) {
            while_continue___31: /* CIL Label */ ;
#line 901
            if ((unsigned long )buf != (unsigned long )((void *)0)) {
              {
#line 901
              free((void *)buf);
#line 901
              buf = (char *)((void *)0);
              }
            }
#line 901
            goto while_break___31;
          }
          while_break___31: /* CIL Label */ ;
          }
          {
#line 901
          tmp___20 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0,
                                err);
          }
#line 901
          return (tmp___20);
        }
#line 901
        lookup = (char const   *)buf;
      }
#line 901
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
#line 903
    if (spf_request->client_ver == 2) {
      {
#line 904
      rr_ptr = SPF_dns_rlookup(resolver, spf_request->ipv4, (ns_type )12, 1);
      }
#line 907
      if (spf_server___1->debug) {
        {
#line 908
        while (1) {
          while_continue___32: /* CIL Label */ ;
          {
#line 908
          tmp___21 = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4.s_addr),
                               (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
          }
#line 908
          if ((unsigned long )tmp___21 == (unsigned long )((void *)0)) {
            {
#line 908
            snprintf((char */* __restrict  */)(ip4_buf), sizeof(ip4_buf), (char const   */* __restrict  */)"ip-error");
            }
          }
#line 908
          goto while_break___32;
        }
        while_break___32: /* CIL Label */ ;
        }
        {
#line 910
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                   911, "got %d PTR records for %s (herrno: %d)", rr_ptr->num_rr,
                   ip4_buf, rr_ptr->herrno);
        }
      }
#line 914
      if (rr_ptr->herrno == 2) {
        {
#line 915
        SPF_dns_rr_free(rr_ptr);
        }
        {
#line 916
        while (1) {
          while_continue___33: /* CIL Label */ ;
#line 916
          if ((unsigned long )buf != (unsigned long )((void *)0)) {
            {
#line 916
            free((void *)buf);
#line 916
            buf = (char *)((void *)0);
            }
          }
#line 916
          goto while_break___33;
        }
        while_break___33: /* CIL Label */ ;
        }
        {
#line 917
        tmp___22 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0, (SPF_errcode_t )26);
        }
#line 917
        return (tmp___22);
      }
#line 922
      max_ptr = rr_ptr->num_rr;
#line 923
      max_exceeded = 0;
#line 924
      if (max_ptr > spf_server___1->max_dns_ptr) {
        {
#line 925
        max_exceeded = 1;
#line 926
        max_ptr = SPF_server_get_max_dns_ptr(spf_server___1);
        }
      }
#line 929
      i = 0;
      {
#line 929
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 929
        if (! (i < max_ptr)) {
#line 929
          goto while_break___34;
        }
        {
#line 932
        rr_a = SPF_dns_lookup(resolver, (char const   *)((*(rr_ptr->rr + i))->ptr),
                              (ns_type )1, 1);
        }
#line 935
        if (spf_server___1->debug) {
          {
#line 936
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                     937, "%d:  found %d A records for %s  (herrno: %d)", i, rr_a->num_rr,
                     (*(rr_ptr->rr + i))->ptr, rr_a->herrno);
          }
        }
#line 938
        if (rr_a->herrno == 2) {
          {
#line 939
          SPF_dns_rr_free(rr_ptr);
#line 940
          SPF_dns_rr_free(rr_a);
          }
          {
#line 941
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 941
            if ((unsigned long )buf != (unsigned long )((void *)0)) {
              {
#line 941
              free((void *)buf);
#line 941
              buf = (char *)((void *)0);
              }
            }
#line 941
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
          {
#line 942
          tmp___23 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0,
                                (SPF_errcode_t )26);
          }
#line 942
          return (tmp___23);
        }
#line 945
        j = 0;
        {
#line 945
        while (1) {
          while_continue___36: /* CIL Label */ ;
#line 945
          if (! (j < rr_a->num_rr)) {
#line 945
            goto while_break___36;
          }
#line 948
          if (spf_server___1->debug) {
            {
#line 949
            while (1) {
              while_continue___37: /* CIL Label */ ;
              {
#line 949
              tmp___24 = inet_ntop(2, (void const   */* __restrict  */)(& (*(rr_a->rr + j))->a.s_addr),
                                   (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
              }
#line 949
              if ((unsigned long )tmp___24 == (unsigned long )((void *)0)) {
                {
#line 949
                snprintf((char */* __restrict  */)(ip4_buf), sizeof(ip4_buf), (char const   */* __restrict  */)"ip-error");
                }
              }
#line 949
              goto while_break___37;
            }
            while_break___37: /* CIL Label */ ;
            }
            {
#line 951
            SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                       952, "%d: %d:  found %s", i, j, ip4_buf);
            }
          }
#line 955
          if ((*(rr_a->rr + j))->a.s_addr == spf_request->ipv4.s_addr) {
            {
#line 957
            tmp___26 = SPF_i_match_domain(spf_server___1, (char const   *)((*(rr_ptr->rr + i))->ptr),
                                          lookup);
            }
#line 957
            if (tmp___26) {
              {
#line 959
              SPF_dns_rr_free(rr_ptr);
#line 960
              SPF_dns_rr_free(rr_a);
              }
              {
#line 961
              while (1) {
                while_continue___38: /* CIL Label */ ;
#line 961
                if ((unsigned long )buf != (unsigned long )((void *)0)) {
                  {
#line 961
                  free((void *)buf);
#line 961
                  buf = (char *)((void *)0);
                  }
                }
#line 961
                goto while_break___38;
              }
              while_break___38: /* CIL Label */ ;
              }
              {
#line 962
              tmp___25 = SPF_i_done(spf_response, (SPF_result_t )mech->prefix_type,
                                    (SPF_reason_t )4, (SPF_errcode_t )0);
              }
#line 962
              return (tmp___25);
            }
          }
#line 945
          j ++;
        }
        while_break___36: /* CIL Label */ ;
        }
        {
#line 966
        SPF_dns_rr_free(rr_a);
#line 929
        i ++;
        }
      }
      while_break___34: /* CIL Label */ ;
      }
      {
#line 968
      SPF_dns_rr_free(rr_ptr);
      }
#line 970
      if (max_exceeded) {
        {
#line 971
        while (1) {
          while_continue___39: /* CIL Label */ ;
#line 971
          if ((unsigned long )buf != (unsigned long )((void *)0)) {
            {
#line 971
            free((void *)buf);
#line 971
            buf = (char *)((void *)0);
            }
          }
#line 971
          goto while_break___39;
        }
        while_break___39: /* CIL Label */ ;
        }
        {
#line 972
        tmp___27 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, (SPF_errcode_t )18);
        }
#line 972
        return (tmp___27);
      }
    } else
#line 976
    if (spf_request->client_ver == 10) {
      {
#line 977
      rr_ptr = SPF_dns_rlookup6(resolver, spf_request->ipv6, (ns_type )12, 1);
      }
#line 980
      if (spf_server___1->debug) {
        {
#line 981
        while (1) {
          while_continue___40: /* CIL Label */ ;
          {
#line 981
          tmp___28 = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6.__in6_u.__u6_addr8),
                               (char */* __restrict  */)(ip6_buf), (socklen_t )sizeof(ip6_buf));
          }
#line 981
          if ((unsigned long )tmp___28 == (unsigned long )((void *)0)) {
            {
#line 981
            snprintf((char */* __restrict  */)(ip6_buf), sizeof(ip6_buf), (char const   */* __restrict  */)"ip-error");
            }
          }
#line 981
          goto while_break___40;
        }
        while_break___40: /* CIL Label */ ;
        }
        {
#line 983
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                   984, "found %d PTR records for %s  (herrno: %d)", rr_ptr->num_rr,
                   ip6_buf, rr_ptr->herrno);
        }
      }
#line 986
      if (rr_ptr->herrno == 2) {
        {
#line 987
        SPF_dns_rr_free(rr_ptr);
        }
        {
#line 988
        while (1) {
          while_continue___41: /* CIL Label */ ;
#line 988
          if ((unsigned long )buf != (unsigned long )((void *)0)) {
            {
#line 988
            free((void *)buf);
#line 988
            buf = (char *)((void *)0);
            }
          }
#line 988
          goto while_break___41;
        }
        while_break___41: /* CIL Label */ ;
        }
        {
#line 989
        tmp___29 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0, (SPF_errcode_t )26);
        }
#line 989
        return (tmp___29);
      }
#line 993
      max_ptr = rr_ptr->num_rr;
#line 994
      max_exceeded = 0;
#line 995
      if (max_ptr > spf_server___1->max_dns_ptr) {
        {
#line 996
        max_ptr = SPF_server_get_max_dns_ptr(spf_server___1);
#line 997
        max_exceeded = 1;
        }
      }
#line 1000
      i = 0;
      {
#line 1000
      while (1) {
        while_continue___42: /* CIL Label */ ;
#line 1000
        if (! (i < max_ptr)) {
#line 1000
          goto while_break___42;
        }
        {
#line 1003
        rr_aaaa = SPF_dns_lookup(resolver, (char const   *)((*(rr_ptr->rr + i))->ptr),
                                 (ns_type )28, 1);
        }
#line 1006
        if (spf_server___1->debug) {
          {
#line 1007
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                     1008, "%d:  found %d AAAA records for %s  (herrno: %d)", i, rr_aaaa->num_rr,
                     (*(rr_ptr->rr + i))->ptr, rr_aaaa->herrno);
          }
        }
#line 1009
        if (rr_aaaa->herrno == 2) {
          {
#line 1010
          SPF_dns_rr_free(rr_ptr);
#line 1011
          SPF_dns_rr_free(rr_aaaa);
          }
          {
#line 1012
          while (1) {
            while_continue___43: /* CIL Label */ ;
#line 1012
            if ((unsigned long )buf != (unsigned long )((void *)0)) {
              {
#line 1012
              free((void *)buf);
#line 1012
              buf = (char *)((void *)0);
              }
            }
#line 1012
            goto while_break___43;
          }
          while_break___43: /* CIL Label */ ;
          }
          {
#line 1013
          tmp___30 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0,
                                (SPF_errcode_t )26);
          }
#line 1013
          return (tmp___30);
        }
#line 1016
        j = 0;
        {
#line 1016
        while (1) {
          while_continue___44: /* CIL Label */ ;
#line 1016
          if (! (j < rr_aaaa->num_rr)) {
#line 1016
            goto while_break___44;
          }
#line 1018
          if (spf_server___1->debug) {
            {
#line 1019
            while (1) {
              while_continue___45: /* CIL Label */ ;
              {
#line 1019
              tmp___31 = inet_ntop(10, (void const   */* __restrict  */)(& (*(rr_aaaa->rr + j))->aaaa.__in6_u.__u6_addr8),
                                   (char */* __restrict  */)(ip6_buf), (socklen_t )sizeof(ip6_buf));
              }
#line 1019
              if ((unsigned long )tmp___31 == (unsigned long )((void *)0)) {
                {
#line 1019
                snprintf((char */* __restrict  */)(ip6_buf), sizeof(ip6_buf), (char const   */* __restrict  */)"ip-error");
                }
              }
#line 1019
              goto while_break___45;
            }
            while_break___45: /* CIL Label */ ;
            }
            {
#line 1021
            SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                       1022, "%d: %d:  found %s", i, j, ip6_buf);
            }
          }
          {
#line 1025
          tmp___34 = memcmp((void const   *)(& (*(rr_aaaa->rr + j))->aaaa), (void const   *)(& spf_request->ipv6),
                            sizeof(spf_request->ipv6));
          }
#line 1025
          if (tmp___34 == 0) {
            {
#line 1028
            tmp___33 = SPF_i_match_domain(spf_server___1, (char const   *)((*(rr_ptr->rr + i))->ptr),
                                          lookup);
            }
#line 1028
            if (tmp___33) {
              {
#line 1030
              SPF_dns_rr_free(rr_ptr);
#line 1031
              SPF_dns_rr_free(rr_aaaa);
              }
              {
#line 1032
              while (1) {
                while_continue___46: /* CIL Label */ ;
#line 1032
                if ((unsigned long )buf != (unsigned long )((void *)0)) {
                  {
#line 1032
                  free((void *)buf);
#line 1032
                  buf = (char *)((void *)0);
                  }
                }
#line 1032
                goto while_break___46;
              }
              while_break___46: /* CIL Label */ ;
              }
              {
#line 1033
              tmp___32 = SPF_i_done(spf_response, (SPF_result_t )mech->prefix_type,
                                    (SPF_reason_t )4, (SPF_errcode_t )0);
              }
#line 1033
              return (tmp___32);
            }
          }
#line 1016
          j ++;
        }
        while_break___44: /* CIL Label */ ;
        }
        {
#line 1037
        SPF_dns_rr_free(rr_aaaa);
#line 1000
        i ++;
        }
      }
      while_break___42: /* CIL Label */ ;
      }
      {
#line 1039
      SPF_dns_rr_free(rr_ptr);
      }
#line 1041
      if (max_exceeded) {
        {
#line 1042
        while (1) {
          while_continue___47: /* CIL Label */ ;
#line 1042
          if ((unsigned long )buf != (unsigned long )((void *)0)) {
            {
#line 1042
            free((void *)buf);
#line 1042
            buf = (char *)((void *)0);
            }
          }
#line 1042
          goto while_break___47;
        }
        while_break___47: /* CIL Label */ ;
        }
        {
#line 1043
        tmp___35 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, (SPF_errcode_t )18);
        }
#line 1043
        return (tmp___35);
      }
    }
#line 1048
    goto switch_break;
    case_9: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 1052
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 1052
      (spf_response->num_dns_mech) ++;
#line 1052
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 1054
    tmp___36 = SPF_mech_data_len(mech);
#line 1054
    tmp___37 = SPF_mech_data(mech);
#line 1054
    err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, tmp___37,
                                 tmp___36, & buf, & buf_len);
    }
#line 1058
    if ((unsigned int )err == 1U) {
      {
#line 1059
      while (1) {
        while_continue___49: /* CIL Label */ ;
#line 1059
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1059
          free((void *)buf);
#line 1059
          buf = (char *)((void *)0);
          }
        }
#line 1059
        goto while_break___49;
      }
      while_break___49: /* CIL Label */ ;
      }
      {
#line 1060
      tmp___38 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0, err);
      }
#line 1060
      return (tmp___38);
    }
#line 1062
    if (err) {
      {
#line 1063
      while (1) {
        while_continue___50: /* CIL Label */ ;
#line 1063
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1063
          free((void *)buf);
#line 1063
          buf = (char *)((void *)0);
          }
        }
#line 1063
        goto while_break___50;
      }
      while_break___50: /* CIL Label */ ;
      }
      {
#line 1064
      tmp___39 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, err);
      }
#line 1064
      return (tmp___39);
    }
    {
#line 1066
    lookup = (char const   *)buf;
#line 1069
    tmp___41 = strcmp(lookup, spf_request->cur_dom);
    }
#line 1069
    if (tmp___41 == 0) {
      {
#line 1070
      while (1) {
        while_continue___51: /* CIL Label */ ;
#line 1070
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1070
          free((void *)buf);
#line 1070
          buf = (char *)((void *)0);
          }
        }
#line 1070
        goto while_break___51;
      }
      while_break___51: /* CIL Label */ ;
      }
      {
#line 1071
      tmp___40 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, (SPF_errcode_t )31);
      }
#line 1071
      return (tmp___40);
    }
    {
#line 1078
    spf_record_subr = (SPF_record_t *)((void *)0);
#line 1080
    save_cur_dom = spf_request->cur_dom;
#line 1081
    spf_request->cur_dom = lookup;
#line 1082
    err = SPF_server_get_record(spf_server___1, spf_request, spf_response, & spf_record_subr);
    }
#line 1085
    if (spf_server___1->debug > 0) {
      {
#line 1086
      tmp___42 = SPF_strerror(err);
#line 1086
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 1087, "include/redirect:  got SPF record:  %s", tmp___42);
      }
    }
#line 1089
    if ((unsigned int )err != 0U) {
#line 1090
      spf_request->cur_dom = save_cur_dom;
#line 1091
      if (spf_record_subr) {
        {
#line 1092
        SPF_record_free(spf_record_subr);
        }
      }
      {
#line 1093
      while (1) {
        while_continue___52: /* CIL Label */ ;
#line 1093
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1093
          free((void *)buf);
#line 1093
          buf = (char *)((void *)0);
          }
        }
#line 1093
        goto while_break___52;
      }
      while_break___52: /* CIL Label */ ;
      }
#line 1094
      if ((unsigned int )err == 26U) {
        {
#line 1095
        tmp___43 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0, err);
        }
#line 1095
        return (tmp___43);
      } else {
        {
#line 1097
        tmp___44 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, err);
        }
#line 1097
        return (tmp___44);
      }
    }
    {
#line 1100
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 1100
      if ((unsigned long )spf_record_subr == (unsigned long )((void *)0)) {
        {
#line 1100
        SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                   1100, "%s", "spf_record_subr is NULL");
        }
      }
#line 1100
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
#line 1106
    if ((int )mech->mech_type == 9) {
#line 1107
      save_spf_response = (SPF_response_t *)((void *)0);
#line 1108
      if ((unsigned long )spf_response->spf_record_exp == (unsigned long )spf_record) {
#line 1109
        spf_response->spf_record_exp = spf_record_subr;
      }
      {
#line 1110
      while (1) {
        while_continue___54: /* CIL Label */ ;
#line 1110
        if ((unsigned long )spf_response->spf_record_exp == (unsigned long )((void *)0)) {
          {
#line 1110
          SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                     1110, "%s", "spf_response->spf_record_exp is NULL");
          }
        }
#line 1110
        goto while_break___54;
      }
      while_break___54: /* CIL Label */ ;
      }
    } else {
      {
#line 1113
      save_spf_response = spf_response;
#line 1114
      spf_response = SPF_response_new(spf_request);
      }
#line 1115
      if (! spf_response) {
#line 1116
        if (spf_record_subr) {
          {
#line 1117
          SPF_record_free(spf_record_subr);
          }
        }
        {
#line 1118
        while (1) {
          while_continue___55: /* CIL Label */ ;
#line 1118
          if ((unsigned long )buf != (unsigned long )((void *)0)) {
            {
#line 1118
            free((void *)buf);
#line 1118
            buf = (char *)((void *)0);
            }
          }
#line 1118
          goto while_break___55;
        }
        while_break___55: /* CIL Label */ ;
        }
        {
#line 1119
        tmp___45 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0, (SPF_errcode_t )1);
        }
#line 1119
        return (tmp___45);
      }
#line 1121
      spf_response->spf_record_exp = spf_record;
      {
#line 1122
      while (1) {
        while_continue___56: /* CIL Label */ ;
#line 1122
        if ((unsigned long )spf_response->spf_record_exp == (unsigned long )((void *)0)) {
          {
#line 1122
          SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                     1122, "%s", "spf_response->spf_record_exp is NULL");
          }
        }
#line 1122
        goto while_break___56;
      }
      while_break___56: /* CIL Label */ ;
      }
    }
    {
#line 1127
    err = SPF_record_interpret(spf_record_subr, spf_request, spf_response, depth + 1);
#line 1129
    spf_request->cur_dom = save_cur_dom;
#line 1136
    SPF_record_free(spf_record_subr);
#line 1137
    spf_record_subr = (SPF_record_t *)((void *)0);
    }
#line 1139
    if (spf_server___1->debug > 0) {
      {
#line 1140
      tmp___46 = SPF_strreason(spf_response->reason);
#line 1140
      tmp___47 = SPF_strresult(spf_response->result);
#line 1140
      tmp___48 = SPF_strerror(err);
#line 1140
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 1143, "include/redirect:  executed SPF record:  %s  result: %s  reason: %s",
                 tmp___48, tmp___47, tmp___46);
      }
    }
#line 1144
    if ((int )mech->mech_type == 9) {
      {
#line 1145
      while (1) {
        while_continue___57: /* CIL Label */ ;
#line 1145
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1145
          free((void *)buf);
#line 1145
          buf = (char *)((void *)0);
          }
        }
#line 1145
        goto while_break___57;
      }
      while_break___57: /* CIL Label */ ;
      }
#line 1146
      return (err);
    } else {
      {
#line 1150
      spf_response_subr = spf_response;
#line 1151
      spf_response = save_spf_response;
#line 1152
      save_spf_response = (SPF_response_t *)((void *)0);
#line 1155
      tmp___49 = SPF_response_result(spf_response_subr);
      }
      {
#line 1156
      if ((unsigned int )tmp___49 == 2U) {
#line 1156
        goto case_2___0;
      }
#line 1164
      if ((unsigned int )tmp___49 == 1U) {
#line 1164
        goto case_1___0;
      }
#line 1164
      if ((unsigned int )tmp___49 == 4U) {
#line 1164
        goto case_1___0;
      }
#line 1164
      if ((unsigned int )tmp___49 == 3U) {
#line 1164
        goto case_1___0;
      }
#line 1169
      if ((unsigned int )tmp___49 == 6U) {
#line 1169
        goto case_6;
      }
#line 1176
      if ((unsigned int )tmp___49 == 5U) {
#line 1176
        goto case_5;
      }
#line 1182
      if ((unsigned int )tmp___49 == 0U) {
#line 1182
        goto case_0;
      }
#line 1182
      if ((unsigned int )tmp___49 == 7U) {
#line 1182
        goto case_0;
      }
#line 1155
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 1158
      while (1) {
        while_continue___58: /* CIL Label */ ;
#line 1158
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1158
          free((void *)buf);
#line 1158
          buf = (char *)((void *)0);
          }
        }
#line 1158
        goto while_break___58;
      }
      while_break___58: /* CIL Label */ ;
      }
      {
#line 1159
      SPF_response_free(spf_response_subr);
#line 1160
      tmp___50 = SPF_i_done(spf_response, (SPF_result_t )mech->prefix_type, (SPF_reason_t )4,
                            (SPF_errcode_t )0);
      }
#line 1160
      return (tmp___50);
      case_1___0: /* CIL Label */ 
      case_4___0: /* CIL Label */ 
      case_3___0: /* CIL Label */ 
      {
#line 1166
      SPF_response_free(spf_response_subr);
      }
#line 1167
      goto switch_break___0;
      case_6: /* CIL Label */ 
      {
#line 1171
      err = SPF_response_errcode(spf_response_subr);
      }
      {
#line 1172
      while (1) {
        while_continue___59: /* CIL Label */ ;
#line 1172
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1172
          free((void *)buf);
#line 1172
          buf = (char *)((void *)0);
          }
        }
#line 1172
        goto while_break___59;
      }
      while_break___59: /* CIL Label */ ;
      }
      {
#line 1173
      SPF_response_free(spf_response_subr);
#line 1174
      tmp___51 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0, err);
      }
#line 1174
      return (tmp___51);
      case_5: /* CIL Label */ 
      {
#line 1178
      while (1) {
        while_continue___60: /* CIL Label */ ;
#line 1178
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1178
          free((void *)buf);
#line 1178
          buf = (char *)((void *)0);
          }
        }
#line 1178
        goto while_break___60;
      }
      while_break___60: /* CIL Label */ ;
      }
      {
#line 1179
      SPF_response_free(spf_response_subr);
#line 1180
      tmp___52 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, (SPF_errcode_t )30);
      }
#line 1180
      return (tmp___52);
      case_0: /* CIL Label */ 
      case_7: /* CIL Label */ 
      {
#line 1184
      err = SPF_response_errcode(spf_response_subr);
      }
      {
#line 1185
      while (1) {
        while_continue___61: /* CIL Label */ ;
#line 1185
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1185
          free((void *)buf);
#line 1185
          buf = (char *)((void *)0);
          }
        }
#line 1185
        goto while_break___61;
      }
      while_break___61: /* CIL Label */ ;
      }
      {
#line 1186
      SPF_response_free(spf_response_subr);
#line 1187
      tmp___53 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, err);
      }
#line 1187
      return (tmp___53);
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1196
    goto switch_break;
    case_5___0: /* CIL Label */ 
    {
#line 1199
    tmp___54 = SPF_mech_ip4_data(mech);
#line 1199
    memcpy((void */* __restrict  */)(& addr4), (void const   */* __restrict  */)tmp___54,
           sizeof(addr4));
#line 1200
    tmp___56 = SPF_i_match_ip4(spf_server___1, spf_request, mech, addr4);
    }
#line 1200
    if (tmp___56) {
      {
#line 1201
      while (1) {
        while_continue___62: /* CIL Label */ ;
#line 1201
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1201
          free((void *)buf);
#line 1201
          buf = (char *)((void *)0);
          }
        }
#line 1201
        goto while_break___62;
      }
      while_break___62: /* CIL Label */ ;
      }
      {
#line 1202
      tmp___55 = SPF_i_done(spf_response, (SPF_result_t )mech->prefix_type, (SPF_reason_t )4,
                            (SPF_errcode_t )0);
      }
#line 1202
      return (tmp___55);
    }
#line 1204
    goto switch_break;
    case_6___0: /* CIL Label */ 
    {
#line 1207
    tmp___57 = SPF_mech_ip6_data(mech);
#line 1207
    memcpy((void */* __restrict  */)(& addr6), (void const   */* __restrict  */)tmp___57,
           sizeof(addr6));
#line 1208
    tmp___59 = SPF_i_match_ip6(spf_server___1, spf_request, mech, addr6);
    }
#line 1208
    if (tmp___59) {
      {
#line 1209
      while (1) {
        while_continue___63: /* CIL Label */ ;
#line 1209
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1209
          free((void *)buf);
#line 1209
          buf = (char *)((void *)0);
          }
        }
#line 1209
        goto while_break___63;
      }
      while_break___63: /* CIL Label */ ;
      }
      {
#line 1210
      tmp___58 = SPF_i_done(spf_response, (SPF_result_t )mech->prefix_type, (SPF_reason_t )4,
                            (SPF_errcode_t )0);
      }
#line 1210
      return (tmp___58);
    }
#line 1212
    goto switch_break;
    case_7___0: /* CIL Label */ 
    {
#line 1215
    while (1) {
      while_continue___64: /* CIL Label */ ;
#line 1215
      (spf_response->num_dns_mech) ++;
#line 1215
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
    {
#line 1217
    tmp___60 = SPF_mech_data_len(mech);
#line 1217
    tmp___61 = SPF_mech_data(mech);
#line 1217
    err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, tmp___61,
                                 tmp___60, & buf, & buf_len);
    }
#line 1221
    if ((unsigned int )err != 0U) {
      {
#line 1222
      while (1) {
        while_continue___65: /* CIL Label */ ;
#line 1222
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1222
          free((void *)buf);
#line 1222
          buf = (char *)((void *)0);
          }
        }
#line 1222
        goto while_break___65;
      }
      while_break___65: /* CIL Label */ ;
      }
      {
#line 1223
      tmp___62 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0, err);
      }
#line 1223
      return (tmp___62);
    }
    {
#line 1225
    lookup = (char const   *)buf;
#line 1227
    rr_a = SPF_dns_lookup(resolver, lookup, (ns_type )1, 0);
    }
#line 1229
    if (spf_server___1->debug) {
      {
#line 1230
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 1231, "found %d A records for %s  (herrno: %d)", rr_a->num_rr, lookup,
                 rr_a->herrno);
      }
    }
#line 1233
    if (rr_a->herrno == 2) {
      {
#line 1234
      SPF_dns_rr_free(rr_a);
      }
      {
#line 1235
      while (1) {
        while_continue___66: /* CIL Label */ ;
#line 1235
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1235
          free((void *)buf);
#line 1235
          buf = (char *)((void *)0);
          }
        }
#line 1235
        goto while_break___66;
      }
      while_break___66: /* CIL Label */ ;
      }
      {
#line 1236
      tmp___63 = SPF_i_done(spf_response, (SPF_result_t )6, (SPF_reason_t )0, (SPF_errcode_t )26);
      }
#line 1236
      return (tmp___63);
    }
#line 1238
    if (rr_a->num_rr > 0) {
      {
#line 1239
      SPF_dns_rr_free(rr_a);
      }
      {
#line 1240
      while (1) {
        while_continue___67: /* CIL Label */ ;
#line 1240
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          {
#line 1240
          free((void *)buf);
#line 1240
          buf = (char *)((void *)0);
          }
        }
#line 1240
        goto while_break___67;
      }
      while_break___67: /* CIL Label */ ;
      }
      {
#line 1241
      tmp___64 = SPF_i_done(spf_response, (SPF_result_t )mech->prefix_type, (SPF_reason_t )4,
                            (SPF_errcode_t )0);
      }
#line 1241
      return (tmp___64);
    }
    {
#line 1244
    SPF_dns_rr_free(rr_a);
    }
#line 1245
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 1248
    while (1) {
      while_continue___68: /* CIL Label */ ;
#line 1248
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        {
#line 1248
        free((void *)buf);
#line 1248
        buf = (char *)((void *)0);
        }
      }
#line 1248
      goto while_break___68;
    }
    while_break___68: /* CIL Label */ ;
    }
#line 1249
    if ((int )mech->prefix_type == 7) {
      {
#line 1250
      tmp___65 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, (SPF_errcode_t )6);
      }
#line 1250
      return (tmp___65);
    }
    {
#line 1251
    tmp___66 = SPF_i_done(spf_response, (SPF_result_t )mech->prefix_type, (SPF_reason_t )4,
                          (SPF_errcode_t )0);
    }
#line 1251
    return (tmp___66);
#line 1252
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1255
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 1255
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        {
#line 1255
        free((void *)buf);
#line 1255
        buf = (char *)((void *)0);
        }
      }
#line 1255
      goto while_break___69;
    }
    while_break___69: /* CIL Label */ ;
    }
    {
#line 1256
    tmp___67 = SPF_i_done(spf_response, (SPF_result_t )7, (SPF_reason_t )0, (SPF_errcode_t )6);
    }
#line 1256
    return (tmp___67);
#line 1257
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1264
    if ((unsigned long )mech == (unsigned long )local_policy) {
      {
#line 1265
      err = SPF_record_interpret(spf_server___1->local_policy, spf_request, spf_response,
                                 depth + 1);
      }
#line 1268
      if (spf_server___1->debug > 0) {
        {
#line 1269
        tmp___68 = SPF_strreason(spf_response->reason);
#line 1269
        tmp___69 = SPF_strresult(spf_response->result);
#line 1269
        tmp___70 = SPF_strerror(err);
#line 1269
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                   1272, "local_policy:  executed SPF record:  %s  result: %s  reason: %s",
                   tmp___70, tmp___69, tmp___68);
        }
      }
#line 1274
      if ((unsigned int )spf_response->result != 0U) {
        {
#line 1275
        while (1) {
          while_continue___70: /* CIL Label */ ;
#line 1275
          if ((unsigned long )buf != (unsigned long )((void *)0)) {
            {
#line 1275
            free((void *)buf);
#line 1275
            buf = (char *)((void *)0);
            }
          }
#line 1275
          goto while_break___70;
        }
        while_break___70: /* CIL Label */ ;
        }
#line 1276
        return (err);
      }
    }
    {
#line 1280
    mech = SPF_mech_next(mech);
#line 756
    m ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1283
  while (1) {
    while_continue___71: /* CIL Label */ ;
#line 1283
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      {
#line 1283
      free((void *)buf);
#line 1283
      buf = (char *)((void *)0);
      }
    }
#line 1283
    goto while_break___71;
  }
  while_break___71: /* CIL Label */ ;
  }
  {
#line 1285
  tmp___71 = SPF_i_done(spf_response, (SPF_result_t )1, (SPF_reason_t )5, (SPF_errcode_t )0);
  }
#line 1285
  return (tmp___71);
}
}
#line 89 "../../src/include/spf.h"
char const   *SPF_strrrtype(ns_type rr_type ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_pre(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                              ns_type rr_type , int should_cache ) 
{ 
  char const   *tmp ;

  {
#line 51
  if (spf_dns_server->debug) {
    {
#line 52
    tmp = SPF_strrrtype(rr_type);
#line 52
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               54, "DNS[%s] lookup: %s %s (%d)", spf_dns_server->name, domain, tmp,
               (unsigned int )rr_type);
    }
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_post(SPF_dns_server_t *spf_dns_server , SPF_dns_rr_t *spfrr ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 61
  if (spf_dns_server->debug) {
    {
#line 66
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               66, "DNS[%s] found record", spf_dns_server->name);
#line 67
    tmp = SPF_strrrtype(spfrr->rr_type);
#line 67
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               69, "    DOMAIN: %s  TYPE: %s (%d)", spfrr->domain, tmp, (unsigned int )spfrr->rr_type);
    }
#line 70
    if (spfrr->source) {
#line 70
      if ((spfrr->source)->name) {
#line 70
        tmp___0 = (spfrr->source)->name;
      } else {
#line 70
        tmp___0 = "(unnamed source)";
      }
#line 70
      tmp___1 = tmp___0;
    } else {
#line 70
      tmp___1 = "(null source)";
    }
    {
#line 70
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               76, "    TTL: %ld  RR found: %d  herrno: %d  source: %s", spfrr->ttl,
               spfrr->num_rr, spfrr->herrno, tmp___1);
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! (i < spfrr->num_rr)) {
#line 77
        goto while_break;
      }
      {
#line 79
      if ((unsigned int )spfrr->rr_type == 1U) {
#line 79
        goto case_1;
      }
#line 85
      if ((unsigned int )spfrr->rr_type == 12U) {
#line 85
        goto case_12;
      }
#line 89
      if ((unsigned int )spfrr->rr_type == 15U) {
#line 89
        goto case_15;
      }
#line 93
      if ((unsigned int )spfrr->rr_type == 16U) {
#line 93
        goto case_16;
      }
#line 97
      if ((unsigned int )spfrr->rr_type == 99U) {
#line 97
        goto case_99;
      }
#line 101
      if ((unsigned int )spfrr->rr_type == 28U) {
#line 101
        goto case_28;
      }
#line 107
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 80
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->a),
                          (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
#line 80
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 82, "    - A: %s", tmp___2);
      }
#line 83
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 86
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 86, "    - PTR: %s", (*(spfrr->rr + i))->ptr);
      }
#line 87
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 90
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 90, "    - MX: %s", (*(spfrr->rr + i))->mx);
      }
#line 91
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 94
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 94, "    - TXT: %s", (*(spfrr->rr + i))->txt);
      }
#line 95
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 98
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 98, "    - SPF: %s", (*(spfrr->rr + i))->txt);
      }
#line 99
      goto switch_break;
      case_28: /* CIL Label */ 
      {
#line 102
      tmp___3 = inet_ntop(10, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->aaaa),
                          (char */* __restrict  */)(ip6_buf), (socklen_t )sizeof(ip6_buf));
#line 102
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 104, "    - AAAA: %s", tmp___3);
      }
#line 105
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 108
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 108, "    - Unknown RR type");
      }
#line 109
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 77
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 113
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
void SPF_dns_free(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_server_t *layer_below ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 120
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 120, "%s", "spf_dns_server is NULL");
      }
    }
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  layer_below = spf_dns_server->layer_below;
#line 125
  if (spf_dns_server->destroy) {
    {
#line 126
    (*(spf_dns_server->destroy))(spf_dns_server);
    }
#line 127
    if ((unsigned long )layer_below != (unsigned long )((void *)0)) {
      {
#line 128
      SPF_dns_free(layer_below);
      }
    }
  }
#line 130
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
SPF_dns_rr_t *SPF_dns_lookup(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_rr_t *spfrr ;

  {
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 138
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 138, "%s", "spf_dns_server is NULL");
      }
    }
#line 138
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  SPF_dns_debug_pre(spf_dns_server, domain, rr_type, should_cache);
  }
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 140
    if ((unsigned long )spf_dns_server->lookup == (unsigned long )((void *)0)) {
      {
#line 140
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 140, "%s", "spf_dns_server->lookup is NULL");
      }
    }
#line 140
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 141
  spfrr = (*(spf_dns_server->lookup))(spf_dns_server, domain, rr_type, should_cache);
  }
#line 143
  if ((unsigned long )spfrr == (unsigned long )((void *)0)) {
    {
#line 144
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               144, "%s", "SPF DNS layer return NULL during a lookup.");
    }
  }
  {
#line 145
  SPF_dns_debug_post(spf_dns_server, spfrr);
  }
#line 146
  return (spfrr);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
SPF_dns_rr_t *SPF_dns_rlookup(SPF_dns_server_t *spf_dns_server , struct in_addr ipv4 ,
                              ns_type rr_type , int should_cache ) 
{ 
  char domain[sizeof("111.222.333.444.in-addr.arpa")] ;
  union __anonunion_tmp_58 tmp ;
  SPF_dns_rr_t *tmp___0 ;

  {
  {
#line 162
  tmp.ipv4 = ipv4;
#line 164
  snprintf((char */* __restrict  */)(domain), sizeof(domain), (char const   */* __restrict  */)"%d.%d.%d.%d.in-addr.arpa",
           (int )tmp.x[3], (int )tmp.x[2], (int )tmp.x[1], (int )tmp.x[0]);
#line 167
  tmp___0 = SPF_dns_lookup(spf_dns_server, (char const   *)(domain), rr_type, should_cache);
  }
#line 167
  return (tmp___0);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
SPF_dns_rr_t *SPF_dns_rlookup6(SPF_dns_server_t *spf_dns_server , struct in6_addr ipv6 ,
                               ns_type rr_type , int should_cache ) 
{ 
  char domain[(sizeof(struct in6_addr ) * 4UL + sizeof(".ip6.arpa")) + 1UL] ;
  char *p ;
  char *p_end ;
  int i ;
  int tmp ;
  int tmp___0 ;
  SPF_dns_rr_t *tmp___1 ;

  {
#line 178
  p = domain;
#line 179
  p_end = p + sizeof(domain);
#line 181
  i = (int )(sizeof(struct in6_addr ) - 1UL);
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i >= 0)) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%.1x.%.1x.",
                   (int )ipv6.__in6_u.__u6_addr8[i] & 15, (int )ipv6.__in6_u.__u6_addr8[i] >> 4);
#line 182
    p += tmp;
#line 181
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  tmp___0 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"ip6.arpa");
#line 188
  p += tmp___0;
#line 190
  tmp___1 = SPF_dns_lookup(spf_dns_server, (char const   *)(domain), rr_type, should_cache);
  }
#line 190
  return (tmp___1);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
char *SPF_dns_get_client_dom(SPF_dns_server_t *spf_dns_server , SPF_request_t *sr ) 
{ 
  char *client_dom ;
  SPF_dns_rr_t *rr_ptr ;
  SPF_dns_rr_t *rr_a ;
  SPF_dns_rr_t *rr_aaaa ;
  int i ;
  int j ;
  int max_ptr ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 218
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 218, "%s", "spf_dns_server is NULL");
      }
    }
#line 218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 219
    if ((unsigned long )sr == (unsigned long )((void *)0)) {
      {
#line 219
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 219, "%s", "sr is NULL");
      }
    }
#line 219
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 238
  if (sr->client_ver == 2) {
    {
#line 239
    rr_ptr = SPF_dns_rlookup(spf_dns_server, sr->ipv4, (ns_type )12, 0);
#line 241
    max_ptr = rr_ptr->num_rr;
    }
#line 249
    if (max_ptr > 10) {
#line 250
      max_ptr = 10;
    }
#line 252
    i = 0;
    {
#line 252
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 252
      if (! (i < max_ptr)) {
#line 252
        goto while_break___1;
      }
      {
#line 253
      rr_a = SPF_dns_lookup(spf_dns_server, (char const   *)((*(rr_ptr->rr + i))->ptr),
                            (ns_type )1, 0);
#line 255
      j = 0;
      }
      {
#line 255
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 255
        if (! (j < rr_a->num_rr)) {
#line 255
          goto while_break___2;
        }
#line 256
        if ((*(rr_a->rr + j))->a.s_addr == sr->ipv4.s_addr) {
          {
#line 257
          client_dom = strdup((char const   *)((*(rr_ptr->rr + i))->ptr));
#line 258
          SPF_dns_rr_free(rr_ptr);
#line 259
          SPF_dns_rr_free(rr_a);
          }
#line 260
          return (client_dom);
        }
#line 255
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 263
      SPF_dns_rr_free(rr_a);
#line 252
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 265
    SPF_dns_rr_free(rr_ptr);
    }
  } else
#line 268
  if (sr->client_ver == 10) {
    {
#line 269
    rr_ptr = SPF_dns_rlookup6(spf_dns_server, sr->ipv6, (ns_type )12, 0);
#line 271
    max_ptr = rr_ptr->num_rr;
    }
#line 279
    if (max_ptr > 10) {
#line 280
      max_ptr = 10;
    }
#line 282
    i = 0;
    {
#line 282
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 282
      if (! (i < max_ptr)) {
#line 282
        goto while_break___3;
      }
      {
#line 283
      rr_aaaa = SPF_dns_lookup(spf_dns_server, (char const   *)((*(rr_ptr->rr + i))->ptr),
                               (ns_type )28, 0);
#line 285
      j = 0;
      }
      {
#line 285
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 285
        if (! (j < rr_aaaa->num_rr)) {
#line 285
          goto while_break___4;
        }
        {
#line 286
        tmp = memcmp((void const   *)(& (*(rr_aaaa->rr + j))->aaaa), (void const   *)(& sr->ipv6),
                     sizeof(sr->ipv6));
        }
#line 286
        if (tmp == 0) {
          {
#line 288
          client_dom = strdup((char const   *)((*(rr_ptr->rr + i))->ptr));
#line 289
          SPF_dns_rr_free(rr_ptr);
#line 290
          SPF_dns_rr_free(rr_aaaa);
          }
#line 291
          return (client_dom);
        }
#line 285
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 294
      SPF_dns_rr_free(rr_aaaa);
#line 282
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 296
    SPF_dns_rr_free(rr_ptr);
    }
  }
  {
#line 299
  tmp___0 = strdup("unknown");
  }
#line 299
  return (tmp___0);
}
}
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 760 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 765
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 79 "../../src/include/spf_dns_rr.h"
SPF_dns_rr_t *SPF_dns_rr_new_nxdomain(SPF_dns_server_t *spf_dns_server , char const   *domain ) ;
#line 98 "../../src/include/spf_dns_cache.h"
void SPF_dns_cache_set_ttl(SPF_dns_server_t *spf_dns_server , time_t min_ttl , time_t err_ttl ,
                           time_t txt_ttl , time_t rdns_ttl ) ;
#line 118
void SPF_dns_set_conserve_cache(SPF_dns_server_t *spf_dns_server , int conserve_cache ) ;
#line 113 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
__inline static SPF_dns_cache_config_t *SPF_voidp2spfhook___0(void *hook ) 
{ 


  {
#line 114
  return ((SPF_dns_cache_config_t *)hook);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
unsigned int const   crc_32_tab[256]  = 
#line 162
  {      (unsigned int const   )0L,      (unsigned int const   )1996959894L,      (unsigned int const   )3993919788L,      (unsigned int const   )2567524794L, 
        (unsigned int const   )124634137L,      (unsigned int const   )1886057615L,      (unsigned int const   )3915621685L,      (unsigned int const   )2657392035L, 
        (unsigned int const   )249268274L,      (unsigned int const   )2044508324L,      (unsigned int const   )3772115230L,      (unsigned int const   )2547177864L, 
        (unsigned int const   )162941995L,      (unsigned int const   )2125561021L,      (unsigned int const   )3887607047L,      (unsigned int const   )2428444049L, 
        (unsigned int const   )498536548L,      (unsigned int const   )1789927666L,      (unsigned int const   )4089016648L,      (unsigned int const   )2227061214L, 
        (unsigned int const   )450548861L,      (unsigned int const   )1843258603L,      (unsigned int const   )4107580753L,      (unsigned int const   )2211677639L, 
        (unsigned int const   )325883990L,      (unsigned int const   )1684777152L,      (unsigned int const   )4251122042L,      (unsigned int const   )2321926636L, 
        (unsigned int const   )335633487L,      (unsigned int const   )1661365465L,      (unsigned int const   )4195302755L,      (unsigned int const   )2366115317L, 
        (unsigned int const   )997073096L,      (unsigned int const   )1281953886L,      (unsigned int const   )3579855332L,      (unsigned int const   )2724688242L, 
        (unsigned int const   )1006888145L,      (unsigned int const   )1258607687L,      (unsigned int const   )3524101629L,      (unsigned int const   )2768942443L, 
        (unsigned int const   )901097722L,      (unsigned int const   )1119000684L,      (unsigned int const   )3686517206L,      (unsigned int const   )2898065728L, 
        (unsigned int const   )853044451L,      (unsigned int const   )1172266101L,      (unsigned int const   )3705015759L,      (unsigned int const   )2882616665L, 
        (unsigned int const   )651767980L,      (unsigned int const   )1373503546L,      (unsigned int const   )3369554304L,      (unsigned int const   )3218104598L, 
        (unsigned int const   )565507253L,      (unsigned int const   )1454621731L,      (unsigned int const   )3485111705L,      (unsigned int const   )3099436303L, 
        (unsigned int const   )671266974L,      (unsigned int const   )1594198024L,      (unsigned int const   )3322730930L,      (unsigned int const   )2970347812L, 
        (unsigned int const   )795835527L,      (unsigned int const   )1483230225L,      (unsigned int const   )3244367275L,      (unsigned int const   )3060149565L, 
        (unsigned int const   )1994146192L,      (unsigned int const   )31158534L,      (unsigned int const   )2563907772L,      (unsigned int const   )4023717930L, 
        (unsigned int const   )1907459465L,      (unsigned int const   )112637215L,      (unsigned int const   )2680153253L,      (unsigned int const   )3904427059L, 
        (unsigned int const   )2013776290L,      (unsigned int const   )251722036L,      (unsigned int const   )2517215374L,      (unsigned int const   )3775830040L, 
        (unsigned int const   )2137656763L,      (unsigned int const   )141376813L,      (unsigned int const   )2439277719L,      (unsigned int const   )3865271297L, 
        (unsigned int const   )1802195444L,      (unsigned int const   )476864866L,      (unsigned int const   )2238001368L,      (unsigned int const   )4066508878L, 
        (unsigned int const   )1812370925L,      (unsigned int const   )453092731L,      (unsigned int const   )2181625025L,      (unsigned int const   )4111451223L, 
        (unsigned int const   )1706088902L,      (unsigned int const   )314042704L,      (unsigned int const   )2344532202L,      (unsigned int const   )4240017532L, 
        (unsigned int const   )1658658271L,      (unsigned int const   )366619977L,      (unsigned int const   )2362670323L,      (unsigned int const   )4224994405L, 
        (unsigned int const   )1303535960L,      (unsigned int const   )984961486L,      (unsigned int const   )2747007092L,      (unsigned int const   )3569037538L, 
        (unsigned int const   )1256170817L,      (unsigned int const   )1037604311L,      (unsigned int const   )2765210733L,      (unsigned int const   )3554079995L, 
        (unsigned int const   )1131014506L,      (unsigned int const   )879679996L,      (unsigned int const   )2909243462L,      (unsigned int const   )3663771856L, 
        (unsigned int const   )1141124467L,      (unsigned int const   )855842277L,      (unsigned int const   )2852801631L,      (unsigned int const   )3708648649L, 
        (unsigned int const   )1342533948L,      (unsigned int const   )654459306L,      (unsigned int const   )3188396048L,      (unsigned int const   )3373015174L, 
        (unsigned int const   )1466479909L,      (unsigned int const   )544179635L,      (unsigned int const   )3110523913L,      (unsigned int const   )3462522015L, 
        (unsigned int const   )1591671054L,      (unsigned int const   )702138776L,      (unsigned int const   )2966460450L,      (unsigned int const   )3352799412L, 
        (unsigned int const   )1504918807L,      (unsigned int const   )783551873L,      (unsigned int const   )3082640443L,      (unsigned int const   )3233442989L, 
        (unsigned int const   )3988292384L,      (unsigned int const   )2596254646L,      (unsigned int const   )62317068L,      (unsigned int const   )1957810842L, 
        (unsigned int const   )3939845945L,      (unsigned int const   )2647816111L,      (unsigned int const   )81470997L,      (unsigned int const   )1943803523L, 
        (unsigned int const   )3814918930L,      (unsigned int const   )2489596804L,      (unsigned int const   )225274430L,      (unsigned int const   )2053790376L, 
        (unsigned int const   )3826175755L,      (unsigned int const   )2466906013L,      (unsigned int const   )167816743L,      (unsigned int const   )2097651377L, 
        (unsigned int const   )4027552580L,      (unsigned int const   )2265490386L,      (unsigned int const   )503444072L,      (unsigned int const   )1762050814L, 
        (unsigned int const   )4150417245L,      (unsigned int const   )2154129355L,      (unsigned int const   )426522225L,      (unsigned int const   )1852507879L, 
        (unsigned int const   )4275313526L,      (unsigned int const   )2312317920L,      (unsigned int const   )282753626L,      (unsigned int const   )1742555852L, 
        (unsigned int const   )4189708143L,      (unsigned int const   )2394877945L,      (unsigned int const   )397917763L,      (unsigned int const   )1622183637L, 
        (unsigned int const   )3604390888L,      (unsigned int const   )2714866558L,      (unsigned int const   )953729732L,      (unsigned int const   )1340076626L, 
        (unsigned int const   )3518719985L,      (unsigned int const   )2797360999L,      (unsigned int const   )1068828381L,      (unsigned int const   )1219638859L, 
        (unsigned int const   )3624741850L,      (unsigned int const   )2936675148L,      (unsigned int const   )906185462L,      (unsigned int const   )1090812512L, 
        (unsigned int const   )3747672003L,      (unsigned int const   )2825379669L,      (unsigned int const   )829329135L,      (unsigned int const   )1181335161L, 
        (unsigned int const   )3412177804L,      (unsigned int const   )3160834842L,      (unsigned int const   )628085408L,      (unsigned int const   )1382605366L, 
        (unsigned int const   )3423369109L,      (unsigned int const   )3138078467L,      (unsigned int const   )570562233L,      (unsigned int const   )1426400815L, 
        (unsigned int const   )3317316542L,      (unsigned int const   )2998733608L,      (unsigned int const   )733239954L,      (unsigned int const   )1555261956L, 
        (unsigned int const   )3268935591L,      (unsigned int const   )3050360625L,      (unsigned int const   )752459403L,      (unsigned int const   )1541320221L, 
        (unsigned int const   )2607071920L,      (unsigned int const   )3965973030L,      (unsigned int const   )1969922972L,      (unsigned int const   )40735498L, 
        (unsigned int const   )2617837225L,      (unsigned int const   )3943577151L,      (unsigned int const   )1913087877L,      (unsigned int const   )83908371L, 
        (unsigned int const   )2512341634L,      (unsigned int const   )3803740692L,      (unsigned int const   )2075208622L,      (unsigned int const   )213261112L, 
        (unsigned int const   )2463272603L,      (unsigned int const   )3855990285L,      (unsigned int const   )2094854071L,      (unsigned int const   )198958881L, 
        (unsigned int const   )2262029012L,      (unsigned int const   )4057260610L,      (unsigned int const   )1759359992L,      (unsigned int const   )534414190L, 
        (unsigned int const   )2176718541L,      (unsigned int const   )4139329115L,      (unsigned int const   )1873836001L,      (unsigned int const   )414664567L, 
        (unsigned int const   )2282248934L,      (unsigned int const   )4279200368L,      (unsigned int const   )1711684554L,      (unsigned int const   )285281116L, 
        (unsigned int const   )2405801727L,      (unsigned int const   )4167216745L,      (unsigned int const   )1634467795L,      (unsigned int const   )376229701L, 
        (unsigned int const   )2685067896L,      (unsigned int const   )3608007406L,      (unsigned int const   )1308918612L,      (unsigned int const   )956543938L, 
        (unsigned int const   )2808555105L,      (unsigned int const   )3495958263L,      (unsigned int const   )1231636301L,      (unsigned int const   )1047427035L, 
        (unsigned int const   )2932959818L,      (unsigned int const   )3654703836L,      (unsigned int const   )1088359270L,      (unsigned int const   )936918000L, 
        (unsigned int const   )2847714899L,      (unsigned int const   )3736837829L,      (unsigned int const   )1202900863L,      (unsigned int const   )817233897L, 
        (unsigned int const   )3183342108L,      (unsigned int const   )3401237130L,      (unsigned int const   )1404277552L,      (unsigned int const   )615818150L, 
        (unsigned int const   )3134207493L,      (unsigned int const   )3453421203L,      (unsigned int const   )1423857449L,      (unsigned int const   )601450431L, 
        (unsigned int const   )3009837614L,      (unsigned int const   )3294710456L,      (unsigned int const   )1567103746L,      (unsigned int const   )711928724L, 
        (unsigned int const   )3020668471L,      (unsigned int const   )3272380065L,      (unsigned int const   )1510334235L,      (unsigned int const   )755167117L};
#line 217 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
__inline static int crc32str(unsigned int accum , char const   *str , int max_hash_len ) 
{ 


  {
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if ((int const   )*str != 0) {
#line 220
      if (! (max_hash_len > 0)) {
#line 220
        goto while_break;
      }
    } else {
#line 220
      goto while_break;
    }
#line 221
    if ((int const   )*str == 46) {
#line 222
      goto __Cont;
    }
#line 224
    accum = (unsigned int )(crc_32_tab[(int )((unsigned char )accum) ^ (int )((unsigned char )*str)] ^ (unsigned int const   )((unsigned char )(accum >> 8)));
#line 227
    max_hash_len --;
    __Cont: /* CIL Label */ 
#line 220
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return ((int )accum);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_cache_bucket_t *SPF_dns_cache_bucket_find(SPF_dns_cache_config_t *spfhook ,
                                                         char const   *domain , ns_type rr_type ,
                                                         int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  SPF_dns_rr_t *rr ;
  time_t now ;
  int tmp ;

  {
  {
#line 247
  bucket = *(spfhook->cache + idx);
#line 248
  prev = (SPF_dns_cache_bucket_t *)((void *)0);
#line 249
  time(& now);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
#line 252
    rr = bucket->rr;
#line 254
    if (rr->utc_ttl < now) {
#line 256
      if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 257
        prev->next = bucket->next;
      } else {
#line 259
        *(spfhook->cache + idx) = bucket->next;
      }
#line 261
      if (bucket->rr) {
        {
#line 262
        SPF_dns_rr_free(bucket->rr);
        }
      }
      {
#line 263
      free((void *)bucket);
#line 265
      bucket = prev;
      }
    } else
#line 267
    if (! ((unsigned int )rr->rr_type != (unsigned int )rr_type)) {
      {
#line 270
      tmp = strcmp((char const   *)rr->domain, domain);
      }
#line 270
      if (! (tmp != 0)) {
#line 275
        if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 276
          prev->next = bucket->next;
#line 277
          bucket->next = *(spfhook->cache + idx);
#line 278
          *(spfhook->cache + idx) = bucket;
        }
#line 280
        return (bucket);
      }
    }
#line 283
    prev = bucket;
#line 284
    if ((unsigned long )bucket == (unsigned long )((void *)0)) {
#line 285
      bucket = *(spfhook->cache + idx);
    } else {
#line 287
      bucket = bucket->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return ((SPF_dns_cache_bucket_t *)((void *)0));
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_bucket_add(SPF_dns_cache_config_t *spfhook , SPF_dns_rr_t *rr ,
                                              int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  void *tmp ;

  {
  {
#line 300
  tmp = malloc(sizeof(SPF_dns_cache_bucket_t ));
#line 300
  bucket = (SPF_dns_cache_bucket_t *)tmp;
  }
#line 302
  if (! bucket) {
#line 303
    return ((SPF_errcode_t )1);
  }
#line 304
  bucket->next = *(spfhook->cache + idx);
#line 305
  *(spfhook->cache + idx) = bucket;
#line 306
  bucket->rr = rr;
#line 307
  return ((SPF_errcode_t )0);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_rr_fixup(SPF_dns_cache_config_t *spfhook , SPF_dns_rr_t *cached_rr ,
                                            char const   *domain , ns_type rr_type ) 
{ 
  char *p ;
  char *new_domain ;
  size_t new_len ;
  size_t tmp ;
  void *tmp___0 ;
  time_t tmp___1 ;

  {
#line 322
  if ((unsigned int )cached_rr->rr_type == 255U) {
#line 323
    cached_rr->rr_type = rr_type;
  }
#line 326
  if ((unsigned long )cached_rr->domain == (unsigned long )((void *)0)) {
#line 326
    goto _L;
  } else
#line 326
  if ((int )*(cached_rr->domain + 0) != 0) {
    _L: /* CIL Label */ 
    {
#line 328
    tmp = strlen(domain);
#line 328
    new_len = tmp + 1UL;
    }
#line 330
    if (cached_rr->domain_buf_len < new_len) {
      {
#line 331
      tmp___0 = realloc((void *)cached_rr->domain, new_len);
#line 331
      new_domain = (char *)tmp___0;
      }
#line 332
      if ((unsigned long )new_domain == (unsigned long )((void *)0)) {
#line 333
        return ((SPF_errcode_t )1);
      }
#line 334
      cached_rr->domain = new_domain;
#line 335
      cached_rr->domain_buf_len = new_len;
    }
    {
#line 337
    strcpy((char */* __restrict  */)cached_rr->domain, (char const   */* __restrict  */)domain);
    }
  }
#line 341
  if (cached_rr->ttl < spfhook->min_ttl) {
#line 342
    cached_rr->ttl = spfhook->min_ttl;
  }
#line 344
  if (cached_rr->ttl < spfhook->txt_ttl) {
#line 344
    if ((unsigned int )cached_rr->rr_type == 16U) {
#line 346
      cached_rr->ttl = spfhook->txt_ttl;
    }
  }
#line 348
  if (cached_rr->ttl < spfhook->err_ttl) {
#line 348
    if (cached_rr->herrno != 0) {
#line 350
      cached_rr->ttl = spfhook->err_ttl;
    }
  }
#line 352
  if (cached_rr->ttl < spfhook->rdns_ttl) {
    {
#line 353
    p = strstr((char const   *)cached_rr->domain, ".arpa");
    }
#line 354
    if (p) {
#line 354
      if ((int )*(p + (sizeof(".arpa") - 1UL)) == 0) {
#line 355
        cached_rr->ttl = spfhook->rdns_ttl;
      }
    }
  }
  {
#line 358
  tmp___1 = time((time_t *)((void *)0));
#line 358
  cached_rr->utc_ttl = cached_rr->ttl + tmp___1;
  }
#line 360
  return ((SPF_errcode_t )0);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_rr_t *SPF_dns_cache_lookup(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                          ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_rr_t *cached_rr ;
  SPF_dns_rr_t *rr ;
  int idx ;
  SPF_errcode_t tmp ;
  SPF_dns_rr_t *tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;

  {
  {
#line 377
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
#line 381
  idx = crc32str(0U, domain, spfhook->max_hash_len);
#line 382
  idx &= spfhook->cache_size - 1;
#line 384
  pthread_mutex_lock(& spfhook->cache_lock);
#line 386
  bucket = SPF_dns_cache_bucket_find(spfhook, domain, rr_type, idx);
  }
#line 387
  if ((unsigned long )bucket != (unsigned long )((void *)0)) {
#line 388
    if ((unsigned long )bucket->rr != (unsigned long )((void *)0)) {
      {
#line 389
      tmp = SPF_dns_rr_dup(& rr, bucket->rr);
      }
#line 389
      if ((unsigned int )tmp == 0U) {
        {
#line 390
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 391
        return (rr);
      } else
#line 393
      if ((unsigned long )rr != (unsigned long )((void *)0)) {
        {
#line 394
        SPF_dns_rr_free(rr);
        }
      }
    }
  }
  {
#line 401
  bucket = (SPF_dns_cache_bucket_t *)((void *)0);
#line 403
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 405
  if (! spf_dns_server->layer_below) {
    {
#line 406
    tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
    }
#line 406
    return (tmp___0);
  }
  {
#line 408
  rr = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
  }
#line 410
  if (spfhook->conserve_cache) {
#line 410
    if (! should_cache) {
#line 411
      return (rr);
    }
  }
  {
#line 413
  pthread_mutex_lock(& spfhook->cache_lock);
#line 415
  tmp___3 = SPF_dns_rr_dup(& cached_rr, rr);
  }
#line 415
  if ((unsigned int )tmp___3 == 0U) {
    {
#line 416
    tmp___2 = SPF_dns_cache_rr_fixup(spfhook, cached_rr, domain, rr_type);
    }
#line 416
    if ((unsigned int )tmp___2 == 0U) {
      {
#line 417
      tmp___1 = SPF_dns_cache_bucket_add(spfhook, cached_rr, idx);
      }
#line 417
      if ((unsigned int )tmp___1 == 0U) {
        {
#line 418
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 419
        return (rr);
      }
    }
  }
  {
#line 424
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 426
  if (cached_rr) {
    {
#line 427
    SPF_dns_rr_free(cached_rr);
    }
  }
#line 429
  return (rr);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static void SPF_dns_cache_free(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  int i ;

  {
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 442
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
                 442, "%s", "spf_dns_server is NULL");
      }
    }
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
  }
#line 445
  if (spfhook) {
    {
#line 446
    pthread_mutex_lock(& spfhook->cache_lock);
    }
#line 448
    if (spfhook->cache) {
#line 449
      i = 0;
      {
#line 449
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 449
        if (! (i < spfhook->cache_size)) {
#line 449
          goto while_break___0;
        }
#line 450
        bucket = *(spfhook->cache + i);
        {
#line 451
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 451
          if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 451
            goto while_break___1;
          }
#line 452
          prev = bucket;
#line 453
          bucket = bucket->next;
#line 456
          if (prev->rr) {
            {
#line 457
            SPF_dns_rr_free(prev->rr);
            }
          }
          {
#line 458
          free((void *)prev);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 449
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 461
      free((void *)spfhook->cache);
#line 462
      spfhook->cache = (SPF_dns_cache_bucket_t **)((void *)0);
      }
    }
    {
#line 465
    pthread_mutex_unlock(& spfhook->cache_lock);
#line 476
    pthread_mutex_destroy(& spfhook->cache_lock);
#line 478
    free((void *)spfhook);
    }
  }
  {
#line 481
  free((void *)spf_dns_server);
  }
#line 482
  return;
}
}
#line 486 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
SPF_dns_server_t *SPF_dns_cache_new(SPF_dns_server_t *layer_below , char const   *name ,
                                    int debug , int cache_bits ) 
{ 
  SPF_dns_server_t *spf_dns_server ;
  SPF_dns_cache_config_t *spfhook ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if ((unsigned long )layer_below == (unsigned long )((void *)0)) {
      {
#line 493
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
                 493, "%s", "layer_below is NULL");
      }
    }
#line 493
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  if (cache_bits < 1) {
    {
#line 496
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
               496, "%s", "cache bits out of range (1..16).");
    }
  } else
#line 495
  if (cache_bits > 16) {
    {
#line 496
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
               496, "%s", "cache bits out of range (1..16).");
    }
  }
  {
#line 499
  tmp = malloc(sizeof(SPF_dns_server_t ));
#line 499
  spf_dns_server = (SPF_dns_server_t *)tmp;
  }
#line 500
  if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
#line 501
    return ((SPF_dns_server_t *)((void *)0));
  }
  {
#line 502
  memset((void *)spf_dns_server, 0, sizeof(SPF_dns_server_t ));
#line 504
  spf_dns_server->hook = malloc(sizeof(SPF_dns_cache_config_t ));
  }
#line 505
  if ((unsigned long )spf_dns_server->hook == (unsigned long )((void *)0)) {
    {
#line 506
    free((void *)spf_dns_server);
    }
#line 507
    return ((SPF_dns_server_t *)((void *)0));
  }
  {
#line 509
  memset(spf_dns_server->hook, 0, sizeof(SPF_dns_cache_config_t ));
  }
#line 511
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 512
    name = "cache";
  }
  {
#line 514
  spf_dns_server->destroy = & SPF_dns_cache_free;
#line 515
  spf_dns_server->lookup = & SPF_dns_cache_lookup;
#line 516
  spf_dns_server->get_spf = (SPF_errcode_t (*)(SPF_server_t *spf_server , SPF_request_t *spf_request ,
                                               SPF_response_t *spf_response , SPF_record_t **spf_recordp ))((void *)0);
#line 517
  spf_dns_server->get_exp = (SPF_errcode_t (*)(SPF_server_t *spf_server , char const   *domain ,
                                               char **buf , size_t *buf_len ))((void *)0);
#line 518
  spf_dns_server->add_cache = (int (*)(SPF_server_t *spf_server , SPF_dns_rr_t spfrr ))((void *)0);
#line 519
  spf_dns_server->layer_below = layer_below;
#line 520
  spf_dns_server->name = name;
#line 521
  spf_dns_server->debug = debug;
#line 523
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
#line 525
  spfhook->cache_size = 1 << cache_bits;
#line 526
  spfhook->hash_mask = spfhook->cache_size - 1;
  }
#line 527
  if (cache_bits > 4) {
#line 527
    spfhook->max_hash_len = cache_bits * 2;
  } else {
#line 527
    spfhook->max_hash_len = 8;
  }
  {
#line 529
  tmp___0 = calloc((size_t )spfhook->cache_size, sizeof(*(spfhook->cache)));
#line 529
  spfhook->cache = (SPF_dns_cache_bucket_t **)tmp___0;
#line 537
  spfhook->min_ttl = (time_t )30;
#line 538
  spfhook->err_ttl = (time_t )1800;
#line 539
  spfhook->txt_ttl = (time_t )1800;
#line 540
  spfhook->rdns_ttl = (time_t )1800;
#line 541
  spfhook->conserve_cache = cache_bits < 12;
  }
#line 543
  if ((unsigned long )spfhook->cache == (unsigned long )((void *)0)) {
    {
#line 544
    free((void *)spfhook);
#line 545
    free((void *)spf_dns_server);
    }
#line 546
    return ((SPF_dns_server_t *)((void *)0));
  }
  {
#line 549
  pthread_mutex_init(& spfhook->cache_lock, (pthread_mutexattr_t const   *)((void *)0));
  }
#line 551
  return (spf_dns_server);
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
void SPF_dns_cache_set_ttl(SPF_dns_server_t *spf_dns_server , time_t min_ttl , time_t err_ttl ,
                           time_t txt_ttl , time_t rdns_ttl ) 
{ 
  SPF_dns_cache_config_t *spfhook ;

  {
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 561
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
                 561, "%s", "spf_dns_server is NULL");
      }
    }
#line 561
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 563
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
  }
#line 565
  if ((unsigned long )spfhook != (unsigned long )((void *)0)) {
    {
#line 566
    pthread_mutex_lock(& spfhook->cache_lock);
#line 567
    spfhook->min_ttl = min_ttl;
#line 568
    spfhook->err_ttl = err_ttl;
#line 569
    spfhook->txt_ttl = txt_ttl;
#line 570
    spfhook->rdns_ttl = rdns_ttl;
#line 571
    pthread_mutex_unlock(& spfhook->cache_lock);
    }
  }
#line 573
  return;
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
void SPF_dns_set_conserve_cache(SPF_dns_server_t *spf_dns_server , int conserve_cache ) 
{ 
  SPF_dns_cache_config_t *spfhook ;

  {
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 582
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
                 582, "%s", "spf_dns_server is NULL");
      }
    }
#line 582
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 584
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
  }
#line 587
  if ((unsigned long )spfhook != (unsigned long )((void *)0)) {
#line 588
    spfhook->conserve_cache = conserve_cache;
  }
#line 589
  return;
}
}
#line 46 "../../src/include/spf_dns_test.h"
SPF_dns_server_t *SPF_dns_test_new(SPF_dns_server_t *layer_below , char const   *name ,
                                   int debug ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
static SPF_dns_test_data_t const   SPF_dns_db[175]  = 
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
  {      {"localhost", 1, 0, "127.0.0.1"}, 
        {"example.com", 1, 0, "192.0.2.3"}, 
        {"example.com", 15, 0, "mx.example.org"}, 
        {"example.com", 16, 0, "v=spf1 mx -all"}, 
        {"3.2.0.192.in-addr.arpa", 12, 0, "mx.example.org"}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}, 
        {"noexist.example.com", 1, 1, (char const   *)((void *)0)}, 
        {"mx.example.org", 1, 0, "192.0.2.3"}, 
        {"mx.example.org", 28, 0, "5f05:2000:80ad:5800::1"}, 
        {"email.example.com", 16, 0, "v=spf1 -all"}, 
        {"*.example.com", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.org", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.net", 255, 1, (char const   *)((void *)0)}, 
        {"01.spf1-test.mailzone.com", 16, 0, "v=spf1                                                             "}, 
        {"02.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             -all       "}, 
        {"03.spf1-test.mailzone.com", 16, 0, "v=spf1                                             ~all"}, 
        {"05.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             default=deny   "}, 
        {"06.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             ?all "}, 
        {"07.spf1-test.mailzone.com", 16, 0, "v=spf2                                             default=bogus   "}, 
        {"08.spf1-test.mailzone.com",
      16, 0, "v=spf1                       -all      ?all  "}, 
        {"09.spf1-test.mailzone.com", 16, 0, "v=spf1    scope=header-from scope=envelope         -all  "}, 
        {"10.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx                                          -all"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"11.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"13.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"20.spf1-test.mailzone.com", 1, 0, "192.0.2.120"}, 
        {"20.spf1-test.mailzone.com", 16, 0, "v=spf1 a                                           -all"}, 
        {"21.spf1-test.mailzone.com",
      16, 0, "v=spf1   a:spf1-test.mailzone.com                            -all"}, 
        {"21.spf1-test.mailzone.com",
      1, 0, "192.0.2.121"}, 
        {"22.spf1-test.mailzone.com", 16, 0, "v=spf1 a a:spf1-test.mailzone.com                            -all"}, 
        {"22.spf1-test.mailzone.com",
      1, 0, "192.0.2.122"}, 
        {"30.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr                                         -all"}, 
        {"30.spf1-test.mailzone.com",
      1, 0, "208.210.124.130"}, 
        {"31.spf1-test.mailzone.com", 16, 0, "v=spf1     ptr:spf1-test.mailzone.com                        -all"}, 
        {"31.spf1-test.mailzone.com",
      1, 0, "208.210.124.131"}, 
        {"32.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr ptr:spf1-test.mailzone.com                        -all"}, 
        {"32.spf1-test.mailzone.com",
      1, 0, "208.210.124.132"}, 
        {"40.spf1-test.mailzone.com", 16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d}                    -all"}, 
        {"41.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.spf1-test.mailzone.com            -all"}, 
        {"42.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d} exists:%{ir}.%{v}._spf.%{d3} -all"}, 
        {"45.spf1-test.mailzone.com",
      16, 0, "v=spf1 -a a:spf1-test.mailzone.com                           -all"}, 
        {"45.spf1-test.mailzone.com",
      1, 0, "192.0.2.147"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.145"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.146"}, 
        {"50.spf1-test.mailzone.com", 16, 0, "v=spf1 include                                     -all"}, 
        {"51.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"52.spf1-test.mailzone.com", 16, 0, "v=spf1 include:53.spf1-test.mailzone.com                  -all"}, 
        {"53.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"54.spf1-test.mailzone.com", 16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"55.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:56.spf1-test.mailzone.com                  -all"}, 
        {"57.spf1-test.mailzone.com", 16, 0, "v=spf1 include:spf1-test.mailzone.com         -all"}, 
        {"58.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:59.spf1-test.mailzone.com                  -all"}, 
        {"59.spf1-test.mailzone.com", 16, 0, "v=spf1 include:58.spf1-test.mailzone.com                  -all"}, 
        {"70.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{lr+=}.lp._spf.spf1-test.mailzone.com -all"}, 
        {"80.spf1-test.mailzone.com", 16, 0, "v=spf1 a mx exists:%{ir}.%{v}._spf.80.spf1-test.mailzone.com ptr -all"}, 
        {"80.spf1-test.mailzone.com",
      1, 0, "208.210.124.180"}, 
        {"90.spf1-test.mailzone.com", 16, 0, "v=spf1  ip4:192.0.2.128/25 -all"}, 
        {"91.spf1-test.mailzone.com", 16, 0, "v=spf1 -ip4:192.0.2.128/25 ip4:192.0.2.0/24 -all"}, 
        {"92.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?ip4:192.0.2.192/26 ip4:192.0.2.128/25 -ip4:192.0.2.0/24 -all"}, 
        {"95.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -all"}, 
        {"96.spf1-test.mailzone.com", 16, 0, "v=spf1 -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"97.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"98.spf1-test.mailzone.com",
      16, 0, "v=spf1 a/26 mx/26 -all"}, 
        {"98.spf1-test.mailzone.com", 15, 0, "80.spf1-test.mailzone.com"}, 
        {"98.spf1-test.mailzone.com", 1, 0, "192.0.2.98"}, 
        {"99.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp=99txt.spf1-test.mailzone.com moo"}, 
        {"99txt.spf1-test.mailzone.com",
      16, 0, "u=%{u} s=%{s} d=%{d} t=%{t} h=%{h} i=%{i} %% U=%{U} S=%{S} D=%{D} T=%{T} H=%{H} I=%{I} %% moo"}, 
        {"100.spf1-test.mailzone.com",
      16, 0, "v=spf1      redirect=98.spf1-test.mailzone.com"}, 
        {"101.spf1-test.mailzone.com", 16, 0, "v=spf1 -all redirect=98.spf1-test.mailzone.com"}, 
        {"102.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?all redirect=98.spf1-test.mailzone.com"}, 
        {"103.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=98.%{d3}"}, 
        {"104.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=105.%{d3}"}, 
        {"105.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=106.%{d3}"}, 
        {"106.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=107.%{d3}"}, 
        {"107.spf1-test.mailzone.com", 16, 0, "v=spf1       include:104.%{d3}"}, 
        {"110.spf1-test.mailzone.com", 16, 0, "v=spf1 some:unrecognized=mechanism some=unrecognized:modifier -all"}, 
        {"111.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx -a gpg ~all exp=111txt.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"111txt.2.0.192.in-addr._spf.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"112.spf1-test.mailzone.com",
      16, 0, "v=spf1 a mp3 ~all"}, 
        {"112.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"113.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3: ~all"}, 
        {"113.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114.spf1-test.mailzone.com", 16, 0, "v=spf1 mx -a gpg=test ~all exp=114txt.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com",
      15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114txt.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"115.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3=yes -all"}, 
        {"115.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"116.spf1-test.mailzone.com", 16, 0, "v=spf1 redirect=116rdr.spf1-test.mailzone.com a"}, 
        {"116.spf1-test.mailzone.com",
      1, 0, "192.0.2.200"}, 
        {"116rdr.spf1-test.mailzone.com", 16, 0, "v=spf1 -all"}, 
        {"117.spf1-test.mailzone.com", 16, 0, " v=spf1 +all"}, 
        {"118.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp="}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.10"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.11"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.12"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.13"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.20"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.21"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.22"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.23"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.30"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.31"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.32"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.33"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.40"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.41"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.42"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.43"}, 
        {"56.spf1-test.mailzone.com", 16, 4, (char const   *)((void *)0)}, 
        {"80.spf1-test.mailzone.com", 15, 4, (char const   *)((void *)0)}, 
        {"servfail.spf1-test.mailzone.com", 16, 2, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 1, 0, "208.210.124.192"}, 
        {"spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"fallback-relay.spf1-test.mailzone.com", 15, 0, "mx04.spf1-test.mailzone.com"}, 
        {"www1.cnn.com",
      1, 0, "64.236.24.4"}, 
        {"4.24.236.64.in-addr.arpa", 12, 0, "www1.cnn.com"}, 
        {"130.124.210.208.in-addr.arpa", 12, 0, "30.spf1-test.mailzone.com"}, 
        {"131.124.210.208.in-addr.arpa", 12, 0, "31.spf1-test.mailzone.com"}, 
        {"192.124.210.208.in-addr.arpa", 12, 0, "spf1-test.mailzone.com"}, 
        {"100.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"110.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"111.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"101.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"130.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"131.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"80.2.0.192.in-addr._spf.80.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"96.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"97.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com",
      1, 0, "127.0.0.2"}, 
        {"bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"postmaster.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"2.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.joe.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"102.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"110.2.0.192.in-addr._spf.42.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"131.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"4.24.236.64.in-addr._spf.80.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"droid.lp._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"joe-2.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"moe-1.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"unknown.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"180.124.210.208.in-addr.arpa",
      12, 0, "80.spf1-test.mailzone.com"}, 
        {"80.spf1-test.mailzone.com.whitelist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.124.210.208.in-addr.arpa",
      12, 0, "pobox-gw.icgroup.com"}, 
        {"pobox-gw.icgroup.com", 1, 0, "208.210.124.1"}, 
        {"pobox-gw.icgroup.com.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com",
      16, 1, (char const   *)((void *)0)}, 
        {"spf.trusted-forwarder.org", 16, 0, "v=spf1 exists:%{ir}.wl.trusted-forwarder.org exists:%{p}.wl.trusted-forwarder.org"}, 
        {"*.spf1-text.mailzone.com",
      255, 1, (char const   *)((void *)0)}, 
        {"cat.com", 16, 4, (char const   *)((void *)0)}, 
        {"bar.com", 16, 4, (char const   *)((void *)0)}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}};
#line 436 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
SPF_dns_server_t *SPF_dns_test_new(SPF_dns_server_t *layer_below , char const   *name ,
                                   int debug ) 
{ 
  SPF_dns_server_t *spf_dns_server ;
  int i ;
  SPF_errcode_t tmp ;

  {
#line 443
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 444
    name = "test";
  }
  {
#line 445
  spf_dns_server = SPF_dns_zone_new(layer_below, name, debug);
  }
#line 446
  if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
#line 447
    return ((SPF_dns_server_t *)((void *)0));
  }
#line 449
  i = 0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! ((long )i < (long )(sizeof(SPF_dns_db) / sizeof(SPF_dns_db[0])))) {
#line 449
      goto while_break;
    }
    {
#line 450
    tmp = SPF_dns_zone_add_str(spf_dns_server, (char const   *)SPF_dns_db[i].domain,
                               (ns_type )SPF_dns_db[i].rr_type, (SPF_dns_stat_t )SPF_dns_db[i].herrno,
                               (char const   *)SPF_dns_db[i].data);
    }
#line 450
    if ((unsigned int )tmp != 0U) {
      {
#line 455
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c",
                 455, "%s", "Could not create test zone");
      }
    }
#line 449
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  return (spf_dns_server);
}
}
#line 51 "../../src/include/spf_dns_null.h"
SPF_dns_server_t *SPF_dns_null_new(SPF_dns_server_t *spf_dns_server_below , char const   *name ,
                                   int debug ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static SPF_dns_rr_t *SPF_dns_null_lookup(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                         ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_rr_t *tmp ;
  SPF_dns_rr_t *tmp___0 ;

  {
#line 45
  if (spf_dns_server->layer_below) {
    {
#line 46
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 46
    return (tmp);
  }
  {
#line 48
  tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
  }
#line 48
  return (tmp___0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static void SPF_dns_null_free(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 54
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c",
                 54, "%s", "spf_dns_server is NULL");
      }
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  free((void *)spf_dns_server);
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
SPF_dns_server_t *SPF_dns_null_new(SPF_dns_server_t *spf_dns_server_below , char const   *name ,
                                   int debug ) 
{ 
  SPF_dns_server_t *spf_dns_server ;
  void *tmp ;

  {
  {
#line 64
  tmp = malloc(sizeof(SPF_dns_server_t ));
#line 64
  spf_dns_server = (SPF_dns_server_t *)tmp;
  }
#line 65
  if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
#line 66
    return ((SPF_dns_server_t *)((void *)0));
  }
  {
#line 67
  memset((void *)spf_dns_server, 0, sizeof(SPF_dns_server_t ));
  }
#line 69
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 70
    name = "null";
  }
#line 72
  spf_dns_server->destroy = & SPF_dns_null_free;
#line 73
  spf_dns_server->lookup = & SPF_dns_null_lookup;
#line 74
  spf_dns_server->get_spf = (SPF_errcode_t (*)(SPF_server_t *spf_server , SPF_request_t *spf_request ,
                                               SPF_response_t *spf_response , SPF_record_t **spf_recordp ))((void *)0);
#line 75
  spf_dns_server->get_exp = (SPF_errcode_t (*)(SPF_server_t *spf_server , char const   *domain ,
                                               char **buf , size_t *buf_len ))((void *)0);
#line 76
  spf_dns_server->add_cache = (int (*)(SPF_server_t *spf_server , SPF_dns_rr_t spfrr ))((void *)0);
#line 77
  spf_dns_server->layer_below = spf_dns_server_below;
#line 78
  spf_dns_server->name = name;
#line 79
  spf_dns_server->debug = debug;
#line 81
  return (spf_dns_server);
}
}
#line 206 "../../src/include/spf_response.h"
char const   *SPF_response_get_received_spf_value(SPF_response_t *rp ) ;
#line 209
char const   *SPF_response_get_explanation(SPF_response_t *rp ) ;
#line 216
int SPF_response_warnings(SPF_response_t *rp ) ;
#line 220
SPF_errcode_t SPF_error_code(SPF_error_t *err ) ;
#line 226
SPF_errcode_t SPF_response_add_error_ptr(SPF_response_t *rp , SPF_errcode_t code ,
                                         char const   *text , char const   *tptr ,
                                         char const   *format  , ...) ;
#line 230
SPF_errcode_t SPF_response_add_error_idx(SPF_response_t *rp , SPF_errcode_t code ,
                                         char const   *text , int idx , char const   *format 
                                         , ...) ;
#line 237
SPF_errcode_t SPF_response_add_warn_ptr(SPF_response_t *rp , SPF_errcode_t code ,
                                        char const   *text , char const   *tptr ,
                                        char const   *format  , ...) ;
#line 241
SPF_errcode_t SPF_response_add_warn_idx(SPF_response_t *rp , SPF_errcode_t code ,
                                        char const   *text , int idx , char const   *format 
                                        , ...) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_response_t *SPF_response_new(SPF_request_t *spf_request ) 
{ 
  SPF_response_t *rp ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(sizeof(SPF_response_t ));
#line 41
  rp = (SPF_response_t *)tmp;
  }
#line 42
  if (! rp) {
#line 43
    return (rp);
  }
  {
#line 44
  memset((void *)rp, 0, sizeof(SPF_response_t ));
#line 46
  rp->spf_request = spf_request;
#line 47
  rp->result = (SPF_result_t )0;
  }
#line 49
  return (rp);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
void SPF_response_free(SPF_response_t *rp ) 
{ 
  int i ;

  {
#line 57
  if (rp->received_spf) {
    {
#line 58
    free((void *)rp->received_spf);
    }
  }
#line 60
  if (rp->header_comment) {
    {
#line 61
    free((void *)rp->header_comment);
    }
  }
#line 62
  if (rp->smtp_comment) {
    {
#line 63
    free((void *)rp->smtp_comment);
    }
  }
#line 64
  if (rp->explanation) {
    {
#line 65
    free((void *)rp->explanation);
    }
  }
#line 67
  if (rp->errors) {
#line 68
    i = 0;
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      if (! (i < (int )rp->errors_length)) {
#line 68
        goto while_break;
      }
      {
#line 69
      free((void *)(rp->errors + i)->message);
#line 68
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 71
    free((void *)rp->errors);
    }
  }
  {
#line 74
  free((void *)rp);
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
static SPF_response_t *SPF_response_choose(SPF_response_t *yes , SPF_response_t *no ) 
{ 


  {
  {
#line 80
  SPF_response_free(no);
  }
#line 81
  return (yes);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_response_t *SPF_response_combine(SPF_response_t *main___0 , SPF_response_t *r2mx ) 
{ 
  SPF_result_t tmp ;
  SPF_response_t *tmp___0 ;
  SPF_response_t *tmp___1 ;
  SPF_result_t tmp___2 ;
  SPF_response_t *tmp___3 ;
  SPF_response_t *tmp___4 ;
  SPF_response_t *tmp___5 ;
  SPF_result_t tmp___6 ;
  SPF_response_t *tmp___7 ;
  SPF_response_t *tmp___8 ;

  {
  {
#line 92
  tmp = SPF_response_result(main___0);
  }
  {
#line 93
  if ((unsigned int )tmp == 0U) {
#line 93
    goto case_0;
  }
#line 97
  if ((unsigned int )tmp == 2U) {
#line 97
    goto case_2;
  }
#line 101
  if ((unsigned int )tmp == 1U) {
#line 101
    goto case_1;
  }
#line 112
  if ((unsigned int )tmp == 3U) {
#line 112
    goto case_3;
  }
#line 119
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 95
  tmp___0 = SPF_response_choose(r2mx, main___0);
  }
#line 95
  return (tmp___0);
  case_2: /* CIL Label */ 
  {
#line 99
  tmp___1 = SPF_response_choose(main___0, r2mx);
  }
#line 99
  return (tmp___1);
  case_1: /* CIL Label */ 
  {
#line 103
  tmp___2 = SPF_response_result(r2mx);
  }
  {
#line 104
  if ((unsigned int )tmp___2 == 2U) {
#line 104
    goto case_2___0;
  }
#line 107
  goto switch_default;
  case_2___0: /* CIL Label */ 
  {
#line 106
  tmp___3 = SPF_response_choose(r2mx, main___0);
  }
#line 106
  return (tmp___3);
  switch_default: /* CIL Label */ 
  {
#line 109
  tmp___4 = SPF_response_choose(main___0, r2mx);
  }
#line 109
  return (tmp___4);
  switch_break___0: /* CIL Label */ ;
  }
  case_3: /* CIL Label */ 
  {
#line 114
  tmp___5 = SPF_response_choose(r2mx, main___0);
  }
#line 114
  return (tmp___5);
  switch_default___0: /* CIL Label */ 
  {
#line 121
  tmp___6 = SPF_response_result(r2mx);
  }
  {
#line 124
  if ((unsigned int )tmp___6 == 4U) {
#line 124
    goto case_4;
  }
#line 124
  if ((unsigned int )tmp___6 == 1U) {
#line 124
    goto case_4;
  }
#line 124
  if ((unsigned int )tmp___6 == 2U) {
#line 124
    goto case_4;
  }
#line 127
  goto switch_default___1;
  case_4: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  case_2___1: /* CIL Label */ 
  {
#line 126
  tmp___7 = SPF_response_choose(r2mx, main___0);
  }
#line 126
  return (tmp___7);
  switch_default___1: /* CIL Label */ 
  {
#line 129
  tmp___8 = SPF_response_choose(main___0, r2mx);
  }
#line 129
  return (tmp___8);
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_result_t SPF_response_result(SPF_response_t *rp ) 
{ 


  {
#line 137
  return (rp->result);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_reason_t SPF_response_reason(SPF_response_t *rp ) 
{ 


  {
#line 143
  return (rp->reason);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_errcode_t SPF_response_errcode(SPF_response_t *rp ) 
{ 


  {
#line 149
  return (rp->err);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
char const   *SPF_response_get_received_spf(SPF_response_t *rp ) 
{ 


  {
#line 155
  return ((char const   *)rp->received_spf);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
char const   *SPF_response_get_received_spf_value(SPF_response_t *rp ) 
{ 


  {
#line 161
  return ((char const   *)rp->received_spf_value);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
char const   *SPF_response_get_header_comment(SPF_response_t *rp ) 
{ 


  {
#line 167
  return ((char const   *)rp->header_comment);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
char const   *SPF_response_get_smtp_comment(SPF_response_t *rp ) 
{ 


  {
#line 173
  return ((char const   *)rp->smtp_comment);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
char const   *SPF_response_get_explanation(SPF_response_t *rp ) 
{ 


  {
#line 179
  return ((char const   *)rp->explanation);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
static SPF_errcode_t SPF_response_add_error_v(SPF_response_t *rp , SPF_errcode_t code ,
                                              int is_error , char const   *text ,
                                              int idx , char const   *format , va_list ap ) 
{ 
  SPF_error_t *tmp ;
  char buf[4096] ;
  int size ;
  void *tmp___0 ;

  {
#line 198
  if (! format) {
    {
#line 199
    format = SPF_strerror(code);
    }
  }
  {
#line 200
  size = vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
                   ap);
  }
#line 201
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
#line 202
    snprintf((char */* __restrict  */)(& buf[size]), sizeof(buf) - (unsigned long )size,
             (char const   */* __restrict  */)" near \'%.12s\'", text + idx);
    }
  }
#line 205
  buf[4095] = (char )'\000';
#line 207
  if ((int )rp->errors_length == (int )rp->errors_size) {
    {
#line 208
    size = ((int )rp->errors_size + (int )rp->errors_size / 4) + 4;
#line 209
    tmp___0 = realloc((void *)rp->errors, (unsigned long )size * sizeof(SPF_error_t ));
#line 209
    tmp = (SPF_error_t *)tmp___0;
    }
#line 210
    if (! tmp) {
      {
#line 211
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c",
                 211, "%s", "Failed to allocate memory for extra response error");
      }
#line 212
      return (code);
    }
#line 214
    rp->errors = tmp;
#line 215
    rp->errors_size = (unsigned short )size;
  }
  {
#line 218
  (rp->errors + rp->errors_length)->code = code;
#line 219
  (rp->errors + rp->errors_length)->is_error = (char )is_error;
#line 221
  (rp->errors + rp->errors_length)->message = strdup((char const   *)(buf));
#line 222
  rp->errors_length = (unsigned short )((int )rp->errors_length + 1);
  }
#line 224
  return (code);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_errcode_t SPF_response_add_error_ptr(SPF_response_t *rp , SPF_errcode_t code ,
                                         char const   *text , char const   *tptr ,
                                         char const   *format  , ...) 
{ 
  va_list ap ;
  long tmp ;
  char const   *tmp___0 ;

  {
  {
#line 243
  __builtin_va_start(ap, format);
  }
#line 243
  if (text) {
#line 243
    tmp = tptr - text;
  } else {
#line 243
    tmp = 0L;
  }
#line 243
  if (text) {
#line 243
    tmp___0 = text;
  } else {
#line 243
    tmp___0 = tptr;
  }
  {
#line 243
  SPF_response_add_error_v(rp, code, 1, tmp___0, (int )tmp, format, ap);
#line 243
  rp->num_errors = (unsigned short )((int )rp->num_errors + 1);
#line 243
  __builtin_va_end(ap);
  }
#line 243
  return (code);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_errcode_t SPF_response_add_error_idx(SPF_response_t *rp , SPF_errcode_t code ,
                                         char const   *text , int idx , char const   *format 
                                         , ...) 
{ 
  va_list ap ;

  {
  {
#line 252
  __builtin_va_start(ap, format);
#line 252
  SPF_response_add_error_v(rp, code, 1, text, idx, format, ap);
#line 252
  rp->num_errors = (unsigned short )((int )rp->num_errors + 1);
#line 252
  __builtin_va_end(ap);
  }
#line 252
  return (code);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_errcode_t SPF_response_add_error(SPF_response_t *rp , SPF_errcode_t code , char const   *format 
                                     , ...) 
{ 
  va_list ap ;

  {
  {
#line 260
  __builtin_va_start(ap, format);
#line 260
  SPF_response_add_error_v(rp, code, 1, (char const   *)((void *)0), 0, format, ap);
#line 260
  rp->num_errors = (unsigned short )((int )rp->num_errors + 1);
#line 260
  __builtin_va_end(ap);
  }
#line 260
  return (code);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_errcode_t SPF_response_add_warn_ptr(SPF_response_t *rp , SPF_errcode_t code ,
                                        char const   *text , char const   *tptr ,
                                        char const   *format  , ...) 
{ 
  va_list ap ;
  long tmp ;
  char const   *tmp___0 ;

  {
  {
#line 269
  __builtin_va_start(ap, format);
  }
#line 269
  if (text) {
#line 269
    tmp = tptr - text;
  } else {
#line 269
    tmp = 0L;
  }
#line 269
  if (text) {
#line 269
    tmp___0 = text;
  } else {
#line 269
    tmp___0 = tptr;
  }
  {
#line 269
  SPF_response_add_error_v(rp, code, 0, tmp___0, (int )tmp, format, ap);
#line 269
  __builtin_va_end(ap);
  }
#line 269
  return (code);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_errcode_t SPF_response_add_warn_idx(SPF_response_t *rp , SPF_errcode_t code ,
                                        char const   *text , int idx , char const   *format 
                                        , ...) 
{ 
  va_list ap ;

  {
  {
#line 278
  __builtin_va_start(ap, format);
#line 278
  SPF_response_add_error_v(rp, code, 0, text, idx, format, ap);
#line 278
  __builtin_va_end(ap);
  }
#line 278
  return (code);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_errcode_t SPF_response_add_warn(SPF_response_t *rp , SPF_errcode_t code , char const   *format 
                                    , ...) 
{ 
  va_list ap ;

  {
  {
#line 286
  __builtin_va_start(ap, format);
#line 286
  SPF_response_add_error_v(rp, code, 0, (char const   *)((void *)0), 0, format, ap);
#line 286
  __builtin_va_end(ap);
  }
#line 286
  return (code);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
int SPF_response_messages(SPF_response_t *rp ) 
{ 


  {
#line 292
  return ((int )rp->errors_length);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
int SPF_response_errors(SPF_response_t *rp ) 
{ 


  {
#line 298
  return ((int )rp->num_errors);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
int SPF_response_warnings(SPF_response_t *rp ) 
{ 


  {
#line 304
  return ((int )rp->errors_length - (int )rp->num_errors);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_error_t *SPF_response_message(SPF_response_t *rp , int idx ) 
{ 


  {
#line 310
  return (rp->errors + idx);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
SPF_errcode_t SPF_error_code(SPF_error_t *err ) 
{ 


  {
#line 316
  return (err->code);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
char const   *SPF_error_message(SPF_error_t *err ) 
{ 


  {
#line 322
  return ((char const   *)err->message);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
char SPF_error_errorp(SPF_error_t *err ) 
{ 


  {
#line 328
  return (err->is_error);
}
}
#line 73 "../../src/include/spf_dns_rr.h"
SPF_dns_rr_t *SPF_dns_rr_new(void) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_rr.c"
SPF_dns_rr_t *SPF_dns_rr_new_nxdomain(SPF_dns_server_t *spf_dns_server , char const   *domain ) 
{ 
  SPF_dns_rr_t *tmp ;

  {
  {
#line 56
  tmp = SPF_dns_rr_new_init(spf_dns_server, domain, (ns_type )255, 0, 1);
  }
#line 56
  return (tmp);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_rr.c"
SPF_dns_rr_t *SPF_dns_rr_new_init(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                  ns_type rr_type , int ttl , SPF_dns_stat_t herrno ) 
{ 
  SPF_dns_rr_t *spfrr ;
  size_t tmp ;

  {
  {
#line 68
  spfrr = SPF_dns_rr_new();
  }
#line 69
  if ((unsigned long )spfrr == (unsigned long )((void *)0)) {
#line 70
    return (spfrr);
  }
#line 72
  spfrr->source = spf_dns_server;
#line 73
  if (domain) {
#line 73
    if ((int const   )*(domain + 0) != 0) {
      {
#line 74
      spfrr->domain = strdup(domain);
      }
#line 75
      if ((unsigned long )spfrr->domain == (unsigned long )((void *)0)) {
        {
#line 76
        SPF_dns_rr_free(spfrr);
        }
#line 77
        return ((SPF_dns_rr_t *)((void *)0));
      }
      {
#line 79
      tmp = strlen(domain);
#line 79
      spfrr->domain_buf_len = tmp + 1UL;
      }
    } else {
#line 82
      spfrr->domain = (char *)((void *)0);
#line 83
      spfrr->domain_buf_len = (size_t )0;
    }
  } else {
#line 82
    spfrr->domain = (char *)((void *)0);
#line 83
    spfrr->domain_buf_len = (size_t )0;
  }
#line 85
  spfrr->rr_type = rr_type;
#line 86
  spfrr->ttl = (time_t )ttl;
#line 87
  spfrr->herrno = herrno;
#line 89
  return (spfrr);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_rr.c"
SPF_dns_rr_t *SPF_dns_rr_new(void) 
{ 
  SPF_dns_rr_t *spfrr ;
  void *tmp ;

  {
  {
#line 97
  tmp = malloc(sizeof(SPF_dns_rr_t ));
#line 97
  spfrr = (SPF_dns_rr_t *)tmp;
  }
#line 98
  if ((unsigned long )spfrr == (unsigned long )((void *)0)) {
#line 99
    return (spfrr);
  }
  {
#line 100
  memset((void *)spfrr, 0, sizeof(SPF_dns_rr_t ));
#line 102
  spfrr->domain = (char *)((void *)0);
#line 103
  spfrr->domain_buf_len = (size_t )0;
#line 104
  spfrr->rr_type = (ns_type )0;
#line 105
  spfrr->num_rr = 0;
#line 106
  spfrr->ttl = (time_t )0;
#line 107
  spfrr->utc_ttl = (time_t )0;
#line 108
  spfrr->herrno = 1;
  }
#line 110
  return (spfrr);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_rr.c"
void SPF_dns_rr_free(SPF_dns_rr_t *spfrr ) 
{ 
  int i ;

  {
#line 118
  if (spfrr->domain) {
    {
#line 119
    free((void *)spfrr->domain);
    }
  }
#line 120
  if (spfrr->rr) {
#line 121
    i = 0;
    {
#line 121
    while (1) {
      while_continue: /* CIL Label */ ;
#line 121
      if (! (i < spfrr->rr_buf_num)) {
#line 121
        goto while_break;
      }
#line 122
      if (*(spfrr->rr + i)) {
        {
#line 123
        free((void *)*(spfrr->rr + i));
        }
      }
#line 121
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 124
    free((void *)spfrr->rr);
    }
  }
#line 126
  if (spfrr->rr_buf_len) {
    {
#line 127
    free((void *)spfrr->rr_buf_len);
    }
  }
#line 128
  if (spfrr->hook) {
    {
#line 129
    free(spfrr->hook);
    }
  }
  {
#line 130
  free((void *)spfrr);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_rr.c"
SPF_errcode_t SPF_dns_rr_buf_realloc(SPF_dns_rr_t *spfrr , int idx , size_t len ) 
{ 
  SPF_dns_rr_data_t **new_data ;
  size_t *new_buf_len ;
  int new_num ;
  void *new_rr ;
  int j ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 142
  if (spfrr->rr_buf_num <= idx) {
    {
#line 144
    new_num = spfrr->rr_buf_num + ((idx + (idx >> 2)) + 4);
#line 146
    tmp = realloc((void *)spfrr->rr, (unsigned long )new_num * sizeof(*new_data));
#line 146
    new_data = (SPF_dns_rr_data_t **)tmp;
    }
#line 148
    if ((unsigned long )new_data == (unsigned long )((void *)0)) {
#line 149
      return ((SPF_errcode_t )1);
    }
    {
#line 150
    spfrr->rr = new_data;
#line 152
    tmp___0 = realloc((void *)spfrr->rr_buf_len, (unsigned long )new_num * sizeof(*new_buf_len));
#line 152
    new_buf_len = (size_t *)tmp___0;
    }
#line 154
    if ((unsigned long )new_buf_len == (unsigned long )((void *)0)) {
#line 155
      return ((SPF_errcode_t )1);
    }
#line 156
    spfrr->rr_buf_len = new_buf_len;
#line 158
    j = spfrr->rr_buf_num;
    {
#line 158
    while (1) {
      while_continue: /* CIL Label */ ;
#line 158
      if (! (j < new_num)) {
#line 158
        goto while_break;
      }
#line 159
      *(spfrr->rr + j) = (SPF_dns_rr_data_t *)((void *)0);
#line 160
      *(spfrr->rr_buf_len + j) = (size_t )0;
#line 158
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 163
    spfrr->rr_buf_num = new_num;
  }
#line 166
  if (len < sizeof(SPF_dns_rr_data_t )) {
#line 167
    len = sizeof(SPF_dns_rr_data_t );
  }
#line 168
  if (*(spfrr->rr_buf_len + idx) >= len) {
#line 169
    return ((SPF_errcode_t )0);
  }
  {
#line 171
  new_rr = realloc((void *)*(spfrr->rr + idx), len);
  }
#line 172
  if ((unsigned long )new_rr == (unsigned long )((void *)0)) {
#line 173
    return ((SPF_errcode_t )1);
  }
#line 174
  *(spfrr->rr + idx) = (SPF_dns_rr_data_t *)new_rr;
#line 175
  *(spfrr->rr_buf_len + idx) = len;
#line 177
  return ((SPF_errcode_t )0);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_rr.c"
SPF_errcode_t SPF_dns_rr_dup(SPF_dns_rr_t **dstp , SPF_dns_rr_t *src ) 
{ 
  SPF_dns_rr_t *dst ;
  SPF_errcode_t err ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if ((unsigned long )src == (unsigned long )((void *)0)) {
      {
#line 195
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_rr.c",
                 195, "%s", "src is NULL");
      }
    }
#line 195
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 196
    if ((unsigned long )dstp == (unsigned long )((void *)0)) {
      {
#line 196
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_rr.c",
                 196, "%s", "dstp is NULL");
      }
    }
#line 196
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  dst = SPF_dns_rr_new_init(src->source, (char const   *)src->domain, src->rr_type,
                            (int )src->ttl, src->herrno);
  }
#line 199
  if (! dst) {
#line 200
    *dstp = (SPF_dns_rr_t *)((void *)0);
#line 201
    return ((SPF_errcode_t )1);
  }
#line 203
  *dstp = dst;
#line 205
  dst->utc_ttl = src->utc_ttl;
#line 206
  dst->num_rr = src->num_rr;
#line 213
  i = dst->num_rr - 1;
  {
#line 213
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 213
    if (! (i >= 0)) {
#line 213
      goto while_break___1;
    }
    {
#line 215
    if ((unsigned int )dst->rr_type == 1U) {
#line 215
      goto case_1;
    }
#line 220
    if ((unsigned int )dst->rr_type == 12U) {
#line 220
      goto case_12;
    }
#line 225
    if ((unsigned int )dst->rr_type == 15U) {
#line 225
      goto case_15;
    }
#line 231
    if ((unsigned int )dst->rr_type == 99U) {
#line 231
      goto case_99;
    }
#line 231
    if ((unsigned int )dst->rr_type == 16U) {
#line 231
      goto case_99;
    }
#line 236
    if ((unsigned int )dst->rr_type == 28U) {
#line 236
      goto case_28;
    }
#line 241
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 216
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 216
      err = SPF_dns_rr_buf_realloc(dst, i, sizeof(SPF_dns_rr_data_t ));
      }
#line 216
      if (err) {
#line 216
        return (err);
      }
#line 216
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 217
    (*(dst->rr + i))->a = (*(src->rr + i))->a;
#line 218
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 221
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 221
      tmp = strlen((char const   *)((*(src->rr + i))->ptr));
#line 221
      err = SPF_dns_rr_buf_realloc(dst, i, tmp + 1UL);
      }
#line 221
      if (err) {
#line 221
        return (err);
      }
#line 221
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 222
    strcpy((char */* __restrict  */)((*(dst->rr + i))->ptr), (char const   */* __restrict  */)((*(src->rr + i))->ptr));
    }
#line 223
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 226
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 226
      tmp___0 = strlen((char const   *)((*(src->rr + i))->mx));
#line 226
      err = SPF_dns_rr_buf_realloc(dst, i, tmp___0 + 1UL);
      }
#line 226
      if (err) {
#line 226
        return (err);
      }
#line 226
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 227
    strcpy((char */* __restrict  */)((*(dst->rr + i))->mx), (char const   */* __restrict  */)((*(src->rr + i))->mx));
    }
#line 228
    goto switch_break;
    case_99: /* CIL Label */ 
    case_16: /* CIL Label */ 
    {
#line 232
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 232
      tmp___1 = strlen((char const   *)((*(src->rr + i))->txt));
#line 232
      err = SPF_dns_rr_buf_realloc(dst, i, tmp___1 + 1UL);
      }
#line 232
      if (err) {
#line 232
        return (err);
      }
#line 232
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 233
    strcpy((char */* __restrict  */)((*(dst->rr + i))->txt), (char const   */* __restrict  */)((*(src->rr + i))->txt));
    }
#line 234
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 237
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 237
      err = SPF_dns_rr_buf_realloc(dst, i, sizeof(SPF_dns_rr_data_t ));
      }
#line 237
      if (err) {
#line 237
        return (err);
      }
#line 237
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 238
    (*(dst->rr + i))->aaaa = (*(src->rr + i))->aaaa;
#line 239
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 242
    SPF_warningx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_rr.c",
                 243, "Attempt to dup unknown rr type %d", (unsigned int )dst->rr_type);
    }
#line 244
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 213
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 248
  return ((SPF_errcode_t )0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_utils.c"
void SPF_get_lib_version(int *major , int *minor , int *patch ) 
{ 


  {
#line 40
  *major = 1;
#line 41
  *minor = 2;
#line 42
  *patch = 10;
#line 43
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_utils.c"
char *SPF_sanitize(SPF_server_t *spf_server___1 , char *str ) 
{ 
  char *p ;
  unsigned short const   **tmp ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 58
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_utils.c",
                 58, "%s", "spf_server is NULL");
      }
    }
#line 58
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  if (! spf_server___1->sanitize) {
#line 61
    return (str);
  }
#line 63
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 64
    return (str);
  }
#line 66
  p = str;
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 66
    if (! ((int )*p != 0)) {
#line 66
      goto while_break___0;
    }
    {
#line 67
    tmp = __ctype_b_loc();
    }
#line 67
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 16384)) {
#line 68
      *p = (char )'?';
    }
#line 66
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 70
  return (str);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_utils.c"
char const   *SPF_strresult(SPF_result_t result ) 
{ 


  {
  {
#line 84
  if ((unsigned int )result == 0U) {
#line 84
    goto case_0;
  }
#line 88
  if ((unsigned int )result == 2U) {
#line 88
    goto case_2;
  }
#line 92
  if ((unsigned int )result == 3U) {
#line 92
    goto case_3;
  }
#line 96
  if ((unsigned int )result == 4U) {
#line 96
    goto case_4;
  }
#line 100
  if ((unsigned int )result == 1U) {
#line 100
    goto case_1;
  }
#line 104
  if ((unsigned int )result == 7U) {
#line 104
    goto case_7;
  }
#line 108
  if ((unsigned int )result == 6U) {
#line 108
    goto case_6;
  }
#line 112
  if ((unsigned int )result == 5U) {
#line 112
    goto case_5;
  }
#line 116
  goto switch_default;
  case_0: /* CIL Label */ 
#line 85
  return ("(invalid)");
#line 86
  goto switch_break;
  case_2: /* CIL Label */ 
#line 89
  return ("pass");
#line 90
  goto switch_break;
  case_3: /* CIL Label */ 
#line 93
  return ("fail");
#line 94
  goto switch_break;
  case_4: /* CIL Label */ 
#line 97
  return ("softfail");
#line 98
  goto switch_break;
  case_1: /* CIL Label */ 
#line 101
  return ("neutral");
#line 102
  goto switch_break;
  case_7: /* CIL Label */ 
#line 105
  return ("permerror");
#line 106
  goto switch_break;
  case_6: /* CIL Label */ 
#line 109
  return ("temperror");
#line 110
  goto switch_break;
  case_5: /* CIL Label */ 
#line 113
  return ("none");
#line 114
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 117
  return ("(error: unknown result)");
#line 118
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 120
  return ((char const   *)0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_utils.c"
char const   *SPF_strreason(SPF_reason_t reason ) 
{ 


  {
  {
#line 131
  if ((unsigned int )reason == 0U) {
#line 131
    goto case_0;
  }
#line 135
  if ((unsigned int )reason == 2U) {
#line 135
    goto case_2;
  }
#line 139
  if ((unsigned int )reason == 3U) {
#line 139
    goto case_3;
  }
#line 143
  if ((unsigned int )reason == 4U) {
#line 143
    goto case_4;
  }
#line 147
  if ((unsigned int )reason == 5U) {
#line 147
    goto case_5;
  }
#line 151
  if ((unsigned int )reason == 6U) {
#line 151
    goto case_6;
  }
#line 155
  goto switch_default;
  case_0: /* CIL Label */ 
#line 132
  return ("none");
#line 133
  goto switch_break;
  case_2: /* CIL Label */ 
#line 136
  return ("localhost");
#line 137
  goto switch_break;
  case_3: /* CIL Label */ 
#line 140
  return ("local policy");
#line 141
  goto switch_break;
  case_4: /* CIL Label */ 
#line 144
  return ("mechanism");
#line 145
  goto switch_break;
  case_5: /* CIL Label */ 
#line 148
  return ("default");
#line 149
  goto switch_break;
  case_6: /* CIL Label */ 
#line 152
  return ("secondary MX");
#line 153
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 156
  return ("(invalid reason)");
#line 157
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 160
  return ((char const   *)0);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_utils.c"
char const   *SPF_strrrtype(ns_type rr_type ) 
{ 


  {
  {
#line 166
  if ((unsigned int )rr_type == 1U) {
#line 166
    goto case_1;
  }
#line 167
  if ((unsigned int )rr_type == 28U) {
#line 167
    goto case_28;
  }
#line 168
  if ((unsigned int )rr_type == 255U) {
#line 168
    goto case_255;
  }
#line 169
  if ((unsigned int )rr_type == 0U) {
#line 169
    goto case_0;
  }
#line 170
  if ((unsigned int )rr_type == 15U) {
#line 170
    goto case_15;
  }
#line 171
  if ((unsigned int )rr_type == 12U) {
#line 171
    goto case_12;
  }
#line 172
  if ((unsigned int )rr_type == 99U) {
#line 172
    goto case_99;
  }
#line 173
  if ((unsigned int )rr_type == 16U) {
#line 173
    goto case_16;
  }
#line 174
  goto switch_default;
  case_1: /* CIL Label */ 
#line 166
  return ("A");
  case_28: /* CIL Label */ 
#line 167
  return ("AAAA");
  case_255: /* CIL Label */ 
#line 168
  return ("ANY");
  case_0: /* CIL Label */ 
#line 169
  return ("BAD");
  case_15: /* CIL Label */ 
#line 170
  return ("MX");
  case_12: /* CIL Label */ 
#line 171
  return ("PTR");
  case_99: /* CIL Label */ 
#line 172
  return ("SPF");
  case_16: /* CIL Label */ 
#line 173
  return ("TXT");
  switch_default: /* CIL Label */ 
#line 174
  return ("??");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_utils.c"
SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_recalloc)(char **bufp ,
                                                                      size_t *buflenp ,
                                                                      size_t buflen ) 
{ 
  char *buf ;
  void *tmp ;

  {
#line 192
  if (*buflenp < buflen) {
#line 193
    if (buflen < 64UL) {
#line 194
      buflen = (size_t )64;
    }
    {
#line 195
    tmp = realloc((void *)*bufp, buflen);
#line 195
    buf = (char *)tmp;
    }
#line 196
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 197
      return ((SPF_errcode_t )1);
    }
#line 200
    *bufp = buf;
#line 201
    *buflenp = buflen;
  } else {
    {
#line 204
    while (1) {
      while_continue: /* CIL Label */ ;
#line 204
      if ((unsigned long )*bufp == (unsigned long )((void *)0)) {
        {
#line 204
        SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_utils.c",
                   204, "%s", "*bufp is NULL");
        }
      }
#line 204
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 207
  memset((void *)*bufp, '\000', *buflenp);
  }
#line 208
  return ((SPF_errcode_t )0);
}
}
#line 228 "../../src/include/spf_record.h"
SPF_record_t *SPF_record_new(SPF_server_t *spf_server___1 , char const   *text ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   spf_mechtypes[10]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
  {      {(unsigned char)0, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)1, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)2, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)3, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )0}, 
        {(unsigned char)4, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)5, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)6, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)7, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)8, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)9, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}};
#line 94 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   *SPF_mechtype_find(int mech_type ) 
{ 
  size_t i ;

  {
#line 98
  i = (size_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < sizeof(spf_mechtypes) / sizeof(spf_mechtypes[0]))) {
#line 98
      goto while_break;
    }
#line 99
    if ((int const   )spf_mechtypes[i].mech_type == (int const   )mech_type) {
#line 100
      return (& spf_mechtypes[i]);
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((SPF_mechtype_t const   *)((void *)0));
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static int ( __attribute__((__warn_unused_result__)) SPF_c_ensure_capacity)(void **datap ,
                                                                            size_t *sizep ,
                                                                            size_t length ) 
{ 
  size_t size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 109
  size = *sizep;
#line 110
  if (length > size) {
#line 111
    size = length + length / 4UL;
  }
#line 112
  if (size > *sizep) {
    {
#line 113
    tmp___0 = realloc(*datap, size);
#line 113
    tmp = tmp___0;
    }
#line 114
    if (! tmp) {
#line 115
      return (-1);
    }
#line 117
    *datap = tmp;
#line 118
    *sizep = size;
  }
#line 120
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip6(SPF_response_t *spf_response , unsigned char *maskp ,
                                          char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 144
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 144
  mask = (int )tmp;
  }
#line 146
  if (mask > 128) {
    {
#line 147
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (>128)");
    }
#line 147
    return (tmp___0);
  } else
#line 151
  if (mask == 0) {
    {
#line 152
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (=0)");
    }
#line 152
    return (tmp___1);
  } else
#line 156
  if (mask == 128) {
#line 157
    mask = 0;
  }
#line 160
  *maskp = (unsigned char )mask;
#line 162
  return ((SPF_errcode_t )0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip4(SPF_response_t *spf_response , unsigned char *maskp ,
                                          char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 186
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 186
  mask = (int )tmp;
  }
#line 188
  if (mask > 32) {
    {
#line 189
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (>32)");
    }
#line 189
    return (tmp___0);
  } else
#line 193
  if (mask == 0) {
    {
#line 194
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (=0)");
    }
#line 194
    return (tmp___1);
  } else
#line 198
  if (mask == 32) {
#line 199
    mask = 0;
  }
#line 202
  *maskp = (unsigned char )mask;
#line 204
  return ((SPF_errcode_t )0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr(SPF_response_t *spf_response , SPF_data_cidr_t *data ,
                                      char const   *src , size_t *src_len ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 220
  memset((void *)data, 0, sizeof(SPF_data_cidr_t ));
#line 221
  data->parm_type = (unsigned char)11;
#line 227
  idx = *src_len - 1UL;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (idx > 0UL) {
      {
#line 228
      tmp = __ctype_b_loc();
      }
#line 228
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 228
        goto while_break;
      }
    } else {
#line 228
      goto while_break;
    }
#line 229
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (idx < *src_len - 1UL) {
#line 236
    if ((int const   )*(src + idx) == 47) {
#line 237
      if (idx > 0UL) {
#line 237
        if ((int const   )*(src + (idx - 1UL)) == 47) {
          {
#line 239
          err = SPF_c_parse_cidr_ip6(spf_response, & data->ipv6, src + idx);
          }
#line 240
          if (err) {
#line 241
            return (err);
          }
#line 243
          *src_len = idx - 1UL;
#line 244
          idx = *src_len - 1UL;
          {
#line 245
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 245
            if (idx > 0UL) {
              {
#line 245
              tmp___0 = __ctype_b_loc();
              }
#line 245
              if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 245
                goto while_break___0;
              }
            } else {
#line 245
              goto while_break___0;
            }
#line 246
            idx --;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 249
          if (idx < *src_len - 1UL) {
#line 249
            if ((int const   )*(src + idx) == 47) {
              {
#line 253
              err = SPF_c_parse_cidr_ip4(spf_response, & data->ipv4, src + idx);
              }
#line 254
              if (err) {
#line 255
                return (err);
              }
#line 256
              *src_len = idx;
            }
          }
        } else {
#line 237
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 261
        err = SPF_c_parse_cidr_ip4(spf_response, & data->ipv4, src + idx);
        }
#line 262
        if (err) {
#line 263
          return (err);
        }
#line 264
        *src_len = idx;
      }
    }
  }
#line 268
  return ((SPF_errcode_t )0);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_var(SPF_response_t *spf_response , SPF_data_var_t *data ,
                                     char const   *src , int is_mod ) 
{ 
  char const   *token ;
  char const   *p ;
  char c ;
  int val ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;
  SPF_errcode_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  SPF_errcode_t tmp___6 ;
  SPF_errcode_t tmp___7 ;

  {
  {
#line 280
  memset((void *)data, 0, sizeof(SPF_data_var_t ));
#line 282
  p = src;
#line 285
  c = (char )*p;
#line 286
  tmp___0 = __ctype_b_loc();
  }
#line 286
  if ((int const   )*(*tmp___0 + (int )((unsigned char )c)) & 256) {
    {
#line 288
    data->url_encode = (unsigned short)1;
#line 289
    tmp = tolower((int )c);
#line 289
    c = (char )tmp;
    }
  } else {
#line 292
    data->url_encode = (unsigned short)0;
  }
  {
#line 302
  if ((int )c == 108) {
#line 302
    goto case_108;
  }
#line 306
  if ((int )c == 115) {
#line 306
    goto case_115;
  }
#line 310
  if ((int )c == 111) {
#line 310
    goto case_111;
  }
#line 314
  if ((int )c == 100) {
#line 314
    goto case_100;
  }
#line 318
  if ((int )c == 105) {
#line 318
    goto case_105;
  }
#line 322
  if ((int )c == 99) {
#line 322
    goto case_99;
  }
#line 327
  if ((int )c == 116) {
#line 327
    goto case_116;
  }
#line 332
  if ((int )c == 112) {
#line 332
    goto case_112;
  }
#line 336
  if ((int )c == 118) {
#line 336
    goto case_118;
  }
#line 340
  if ((int )c == 104) {
#line 340
    goto case_104;
  }
#line 344
  if ((int )c == 114) {
#line 344
    goto case_114;
  }
#line 349
  goto switch_default;
  case_108: /* CIL Label */ 
#line 303
  data->parm_type = (unsigned char)0;
#line 304
  goto switch_break;
  case_115: /* CIL Label */ 
#line 307
  data->parm_type = (unsigned char)1;
#line 308
  goto switch_break;
  case_111: /* CIL Label */ 
#line 311
  data->parm_type = (unsigned char)2;
#line 312
  goto switch_break;
  case_100: /* CIL Label */ 
#line 315
  data->parm_type = (unsigned char)3;
#line 316
  goto switch_break;
  case_105: /* CIL Label */ 
#line 319
  data->parm_type = (unsigned char)4;
#line 320
  goto switch_break;
  case_99: /* CIL Label */ 
#line 323
  if (! is_mod) {
    {
#line 323
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 323
    return (tmp___1);
  }
#line 324
  data->parm_type = (unsigned char)5;
#line 325
  goto switch_break;
  case_116: /* CIL Label */ 
#line 328
  if (! is_mod) {
    {
#line 328
    tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 328
    return (tmp___2);
  }
#line 329
  data->parm_type = (unsigned char)6;
#line 330
  goto switch_break;
  case_112: /* CIL Label */ 
#line 333
  data->parm_type = (unsigned char)7;
#line 334
  goto switch_break;
  case_118: /* CIL Label */ 
#line 337
  data->parm_type = (unsigned char)8;
#line 338
  goto switch_break;
  case_104: /* CIL Label */ 
#line 341
  data->parm_type = (unsigned char)9;
#line 342
  goto switch_break;
  case_114: /* CIL Label */ 
#line 345
  if (! is_mod) {
    {
#line 345
    tmp___3 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 345
    return (tmp___3);
  }
#line 346
  data->parm_type = (unsigned char)10;
#line 347
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 350
  tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                       p, "Unknown variable \'%c\'", (int )c);
  }
#line 350
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
#line 354
  p ++;
#line 355
  token = p;
#line 358
  val = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 359
    tmp___5 = __ctype_b_loc();
    }
#line 359
    if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*p)) & 2048)) {
#line 359
      goto while_break;
    }
#line 361
    val *= 10;
#line 362
    val += (int )((int const   )*p - 48);
#line 363
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (val > 128) {
    {
#line 366
    tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                         token, "Subdomain truncation depth too large");
    }
#line 366
    return (tmp___6);
  } else
#line 365
  if (val <= 0) {
#line 365
    if ((unsigned long )p != (unsigned long )token) {
      {
#line 366
      tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                           token, "Subdomain truncation depth too large");
      }
#line 366
      return (tmp___6);
    }
  }
#line 369
  data->num_rhs = (unsigned char )val;
#line 370
  token = p;
#line 373
  if ((int const   )*p == 114) {
#line 375
    data->rev = (unsigned short)1;
#line 376
    p ++;
  } else {
#line 379
    data->rev = (unsigned short)0;
  }
#line 380
  token = p;
#line 384
  data->delim_dot = (unsigned short)0;
#line 385
  data->delim_dash = (unsigned short)0;
#line 386
  data->delim_plus = (unsigned short)0;
#line 387
  data->delim_equal = (unsigned short)0;
#line 388
  data->delim_bar = (unsigned short)0;
#line 389
  data->delim_under = (unsigned short)0;
#line 392
  if ((int const   )*p == 125) {
#line 393
    data->delim_dot = (unsigned short)1;
  }
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! ((int const   )*p != 125)) {
#line 396
      goto while_break___0;
    }
#line 398
    token = p;
    {
#line 401
    if ((int const   )*p == 46) {
#line 401
      goto case_46;
    }
#line 405
    if ((int const   )*p == 45) {
#line 405
      goto case_45;
    }
#line 409
    if ((int const   )*p == 43) {
#line 409
      goto case_43;
    }
#line 413
    if ((int const   )*p == 61) {
#line 413
      goto case_61;
    }
#line 417
    if ((int const   )*p == 124) {
#line 417
      goto case_124;
    }
#line 421
    if ((int const   )*p == 95) {
#line 421
      goto case_95;
    }
#line 425
    goto switch_default___0;
    case_46: /* CIL Label */ 
#line 402
    data->delim_dot = (unsigned short)1;
#line 403
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 406
    data->delim_dash = (unsigned short)1;
#line 407
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 410
    data->delim_plus = (unsigned short)1;
#line 411
    goto switch_break___0;
    case_61: /* CIL Label */ 
#line 414
    data->delim_equal = (unsigned short)1;
#line 415
    goto switch_break___0;
    case_124: /* CIL Label */ 
#line 418
    data->delim_bar = (unsigned short)1;
#line 419
    goto switch_break___0;
    case_95: /* CIL Label */ 
#line 422
    data->delim_under = (unsigned short)1;
#line 423
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 426
    tmp___7 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )14, (char const   *)((void *)0),
                                         p, "Invalid delimiter \'%c\'", (int const   )*p);
    }
#line 426
    return (tmp___7);
    switch_break___0: /* CIL Label */ ;
    }
#line 430
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 432
  p ++;
#line 433
  token = p;
#line 436
  return ((SPF_errcode_t )0);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_macro(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                       SPF_data_t *data , size_t *data_used , size_t data_avail ,
                                       char const   *src , size_t src_len , SPF_errcode_t big_err ,
                                       int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  size_t len ;
  char *dst ;
  size_t ds_avail ;
  size_t ds_len ;
  SPF_errcode_t tmp ;
  SPF_errcode_t tmp___0 ;
  char *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  char *tmp___3 ;
  SPF_errcode_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  SPF_errcode_t tmp___8 ;
  char *tmp___9 ;
  SPF_errcode_t tmp___10 ;
  SPF_errcode_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  SPF_errcode_t tmp___15 ;
  SPF_errcode_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  SPF_errcode_t tmp___19 ;
  SPF_errcode_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
#line 522
  if (spf_server___1->debug) {
    {
#line 523
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               523, "Parsing macro starting at %s", src);
    }
  }
#line 534
  idx = (size_t )0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 538
    data->ds.parm_type = (unsigned char)12;
#line 538
    data->ds.len = (unsigned char)0;
#line 538
    data->ds.__unused0 = (unsigned char)186;
#line 538
    data->ds.__unused1 = (unsigned char)190;
#line 538
    dst = SPF_data_str(data);
#line 538
    ds_avail = data_avail - *data_used;
#line 538
    ds_len = (size_t )0;
    }
#line 538
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 541
    if (! (idx < src_len)) {
#line 541
      goto while_break___0;
    }
#line 542
    if (spf_server___1->debug > 3) {
      {
#line 543
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 543, "Current data is at %p", data);
      }
    }
    {
#line 546
    len = strcspn(src + idx, " %");
    }
#line 547
    if (len > 0UL) {
#line 549
      if (idx + len > src_len) {
#line 550
        len = src_len - idx;
      }
#line 551
      if (spf_server___1->debug > 3) {
        {
#line 552
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                   554, "Adding string literal (%lu): \'%*.*s\'", len, (int )len,
                   (int )len, src + idx);
        }
      }
      {
#line 556
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 556
        if (ds_len + len > ds_avail) {
          {
#line 556
          tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                           src, "String literal fragment too long (%d chars, %d max)",
                                           ds_len, ds_avail);
          }
#line 556
          return (tmp);
        }
#line 556
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 557
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(src + idx),
             len);
#line 558
      ds_len += len;
#line 559
      dst += len;
#line 560
      idx += len;
      }
    }
#line 568
    if (idx == src_len) {
#line 569
      goto while_break___0;
    }
#line 576
    idx ++;
    {
#line 578
    if ((int const   )*(src + idx) == 37) {
#line 578
      goto case_37;
    }
#line 587
    if ((int const   )*(src + idx) == 95) {
#line 587
      goto case_95;
    }
#line 596
    if ((int const   )*(src + idx) == 45) {
#line 596
      goto case_45;
    }
#line 617
    if ((int const   )*(src + idx) == 123) {
#line 617
      goto case_123;
    }
#line 605
    goto switch_default;
    case_37: /* CIL Label */ 
#line 579
    if (spf_server___1->debug > 3) {
      {
#line 580
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 580, "Adding literal %%");
      }
    }
    {
#line 581
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 581
      if (ds_len + 1UL > ds_avail) {
        {
#line 581
        tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 581
        return (tmp___0);
      }
#line 581
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 582
    tmp___1 = dst;
#line 582
    dst ++;
#line 582
    *tmp___1 = (char )'%';
#line 583
    ds_len ++;
#line 584
    idx ++;
#line 585
    goto switch_break;
    case_95: /* CIL Label */ 
#line 588
    if (spf_server___1->debug > 3) {
      {
#line 589
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 589, "Adding literal space");
      }
    }
    {
#line 590
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 590
      if (ds_len + 1UL > ds_avail) {
        {
#line 590
        tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 590
        return (tmp___2);
      }
#line 590
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 591
    tmp___3 = dst;
#line 591
    dst ++;
#line 591
    *tmp___3 = (char )' ';
#line 592
    ds_len ++;
#line 593
    idx ++;
#line 594
    goto switch_break;
    case_45: /* CIL Label */ 
#line 597
    if (spf_server___1->debug > 3) {
      {
#line 598
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 598, "Adding escaped space");
      }
    }
    {
#line 599
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 599
      if (ds_len + 3UL > ds_avail) {
        {
#line 599
        tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 599
        return (tmp___4);
      }
#line 599
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 600
    tmp___5 = dst;
#line 600
    dst ++;
#line 600
    *tmp___5 = (char )'%';
#line 600
    tmp___6 = dst;
#line 600
    dst ++;
#line 600
    *tmp___6 = (char )'2';
#line 600
    tmp___7 = dst;
#line 600
    dst ++;
#line 600
    *tmp___7 = (char )'0';
#line 601
    ds_len += 3UL;
#line 602
    idx ++;
#line 603
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 606
    if (spf_server___1->debug > 3) {
      {
#line 607
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 608, "Adding illegal %%-follower \'%c\' at %d", (int const   )*(src + idx),
                 idx);
      }
    }
    {
#line 612
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 612
      if (ds_len + 1UL > ds_avail) {
        {
#line 612
        tmp___8 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 612
        return (tmp___8);
      }
#line 612
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 613
    tmp___9 = dst;
#line 613
    dst ++;
#line 613
    *tmp___9 = (char )'%';
#line 614
    ds_len ++;
#line 615
    goto switch_break;
    case_123: /* CIL Label */ 
    {
#line 618
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 618
      if (ds_len > 0UL) {
#line 618
        if (ds_len > 255UL) {
          {
#line 618
          tmp___10 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15,
                                                (char const   *)((void *)0), src,
                                                "String literal too long (%d chars, %d max)",
                                                ds_len, 255);
          }
#line 618
          return (tmp___10);
        }
#line 618
        data->ds.len = (unsigned char )ds_len;
#line 618
        len = sizeof(*data) + ds_len;
        {
#line 618
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 618
          tmp___12 = _align_sz(len);
          }
#line 618
          if (*data_used + tmp___12 > data_avail) {
            {
#line 618
            tmp___11 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                  src, "SPF domainspec too long (%d chars, %d max)",
                                                  *data_used + len, data_avail);
            }
#line 618
            return (tmp___11);
          }
          {
#line 618
          tmp___13 = _align_sz(len);
#line 618
          *data_used += tmp___13;
          }
#line 618
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 618
        data = SPF_data_next(data);
#line 618
        ds_len = (size_t )0;
        }
      }
#line 618
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 619
    if (spf_server___1->debug > 3) {
      {
#line 620
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 620, "Adding macro, data is at %p", data);
      }
    }
    {
#line 623
    idx ++;
#line 624
    err = SPF_c_parse_var(spf_response, & data->dv, src + idx, is_mod);
    }
#line 625
    if ((unsigned int )err != 0U) {
#line 626
      return (err);
    }
    {
#line 627
    tmp___14 = strcspn(src + idx, "} ");
#line 627
    idx += tmp___14;
    }
#line 628
    if ((int const   )*(src + idx) == 125) {
#line 629
      idx ++;
    } else
#line 630
    if ((int const   )*(src + idx) == 32) {
      {
#line 631
      tmp___15 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, src,
                                            src + idx, "Unterminated variable?");
      }
#line 631
      return (tmp___15);
    }
    {
#line 637
    len = SPF_data_len(data);
    }
    {
#line 638
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 638
      tmp___17 = _align_sz(len);
      }
#line 638
      if (*data_used + tmp___17 > data_avail) {
        {
#line 638
        tmp___16 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                              src, "SPF domainspec too long (%d chars, %d max)",
                                              *data_used + len, data_avail);
        }
#line 638
        return (tmp___16);
      }
      {
#line 638
      tmp___18 = _align_sz(len);
#line 638
      *data_used += tmp___18;
      }
#line 638
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 639
    data = SPF_data_next(data);
    }
#line 640
    if (spf_server___1->debug > 3) {
      {
#line 641
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 641, "Next data is at %p", data);
      }
    }
    {
#line 643
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 643
      data->ds.parm_type = (unsigned char)12;
#line 643
      data->ds.len = (unsigned char)0;
#line 643
      data->ds.__unused0 = (unsigned char)186;
#line 643
      data->ds.__unused1 = (unsigned char)190;
#line 643
      dst = SPF_data_str(data);
#line 643
      ds_avail = data_avail - *data_used;
#line 643
      ds_len = (size_t )0;
      }
#line 643
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 649
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 649
    if (ds_len > 0UL) {
#line 649
      if (ds_len > 255UL) {
        {
#line 649
        tmp___19 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                              src, "String literal too long (%d chars, %d max)",
                                              ds_len, 255);
        }
#line 649
        return (tmp___19);
      }
#line 649
      data->ds.len = (unsigned char )ds_len;
#line 649
      len = sizeof(*data) + ds_len;
      {
#line 649
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 649
        tmp___21 = _align_sz(len);
        }
#line 649
        if (*data_used + tmp___21 > data_avail) {
          {
#line 649
          tmp___20 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                src, "SPF domainspec too long (%d chars, %d max)",
                                                *data_used + len, data_avail);
          }
#line 649
          return (tmp___20);
        }
        {
#line 649
        tmp___22 = _align_sz(len);
#line 649
        *data_used += tmp___22;
        }
#line 649
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 649
      data = SPF_data_next(data);
#line 649
      ds_len = (size_t )0;
      }
    }
#line 649
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 651
  return ((SPF_errcode_t )0);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_domainspec(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                            SPF_data_t *data , size_t *data_used ,
                                            size_t data_avail , char const   *src ,
                                            size_t src_len , SPF_errcode_t big_err ,
                                            SPF_cidr_t cidr_ok , int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  SPF_errcode_t tmp___6 ;

  {
#line 682
  if (spf_server___1->debug) {
#line 683
    if ((unsigned int )cidr_ok == 1U) {
#line 683
      tmp___1 = "optional";
    } else {
#line 683
      if ((unsigned int )cidr_ok == 2U) {
#line 683
        tmp___0 = "only";
      } else {
#line 683
        if ((unsigned int )cidr_ok == 0U) {
#line 683
          tmp = "forbidden";
        } else {
#line 683
          tmp = "ERROR!";
        }
#line 683
        tmp___0 = tmp;
      }
#line 683
      tmp___1 = tmp___0;
    }
    {
#line 683
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               689, "Parsing domainspec starting at %s, cidr is %s", src, tmp___1);
    }
  }
#line 694
  if ((unsigned int )cidr_ok == 1U) {
#line 694
    goto _L___0;
  } else
#line 694
  if ((unsigned int )cidr_ok == 2U) {
    _L___0: /* CIL Label */ 
    {
#line 695
    err = SPF_c_parse_cidr(spf_response, & data->dc, src, & src_len);
    }
#line 696
    if ((unsigned int )err != 0U) {
#line 697
      return (err);
    }
#line 698
    if ((int )data->dc.ipv4 != 0) {
#line 698
      goto _L;
    } else
#line 698
    if ((int )data->dc.ipv6 != 0) {
      _L: /* CIL Label */ 
      {
#line 699
      len = SPF_data_len(data);
      }
      {
#line 700
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 700
        tmp___3 = _align_sz(len);
        }
#line 700
        if (*data_used + tmp___3 > data_avail) {
          {
#line 700
          tmp___2 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                               src, "SPF domainspec too long (%d chars, %d max)",
                                               *data_used + len, data_avail);
          }
#line 700
          return (tmp___2);
        }
        {
#line 700
        tmp___4 = _align_sz(len);
#line 700
        *data_used += tmp___4;
        }
#line 700
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 701
      data = SPF_data_next(data);
      }
    }
#line 704
    if ((unsigned int )cidr_ok == 2U) {
#line 704
      if (src_len > 0UL) {
        {
#line 708
        tmp___5 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                             src, "Invalid CIDR after mechanism");
        }
#line 708
        return (tmp___5);
      }
    }
  }
  {
#line 715
  tmp___6 = SPF_c_parse_macro(spf_server___1, spf_response, data, data_used, data_avail,
                              src, src_len, big_err, is_mod);
  }
#line 715
  return (tmp___6);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip4(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                     char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  SPF_errcode_t err ;
  unsigned char mask ;
  struct in_addr *addr ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 739
  start ++;
#line 740
  len = strcspn(start, " ");
#line 741
  end = start + len;
#line 742
  p = end - 1;
#line 744
  mask = (unsigned char)0;
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 745
    tmp = __ctype_b_loc();
    }
#line 745
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 745
      goto while_break;
    }
#line 746
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 747
    if ((int const   )*p == 47) {
      {
#line 748
      err = SPF_c_parse_cidr_ip4(spf_response, & mask, p);
      }
#line 749
      if (err) {
#line 750
        return (err);
      }
#line 751
      end = p;
    }
  }
#line 753
  mech->mech_len = (unsigned short )mask;
#line 755
  len = (size_t )(end - start);
#line 756
  if (len > sizeof(buf) - 1UL) {
#line 757
    return ((SPF_errcode_t )19);
  }
  {
#line 759
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 760
  buf[len] = (char )'\000';
#line 761
  addr = SPF_mech_ip4_data(mech);
#line 762
  tmp___0 = inet_pton(2, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
#line 762
  err = (SPF_errcode_t )tmp___0;
  }
#line 763
  if ((unsigned int )err <= 0U) {
    {
#line 764
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )19, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 764
    return (tmp___1);
  }
#line 767
  return ((SPF_errcode_t )0);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip6(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                     char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  int err ;
  unsigned char mask ;
  struct in6_addr *addr ;
  unsigned short const   **tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 788
  start ++;
#line 789
  len = strcspn(start, " ");
#line 790
  end = start + len;
#line 791
  p = end - 1;
#line 793
  mask = (unsigned char)0;
  }
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 794
    tmp = __ctype_b_loc();
    }
#line 794
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 794
      goto while_break;
    }
#line 795
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 796
    if ((int const   )*p == 47) {
      {
#line 797
      tmp___0 = SPF_c_parse_cidr_ip6(spf_response, & mask, p);
#line 797
      err = (int )tmp___0;
      }
#line 798
      if (err) {
#line 799
        return ((SPF_errcode_t )err);
      }
#line 800
      end = p;
    }
  }
#line 802
  mech->mech_len = (unsigned short )mask;
#line 804
  len = (size_t )(end - start);
#line 805
  if (len > sizeof(buf) - 1UL) {
#line 806
    return ((SPF_errcode_t )20);
  }
  {
#line 808
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 809
  buf[len] = (char )'\000';
#line 810
  addr = SPF_mech_ip6_data(mech);
#line 811
  err = inet_pton(10, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
  }
#line 812
  if (err <= 0) {
    {
#line 813
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )20, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 813
    return (tmp___1);
  }
#line 816
  return ((SPF_errcode_t )0);
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mech_add)(SPF_server_t *spf_server___1 ,
                                                                               SPF_record_t *spf_record ,
                                                                               SPF_response_t *spf_response ,
                                                                               SPF_mechtype_t const   *mechtype ,
                                                                               int prefix ,
                                                                               char const   **mech_value ) 
{ 
  union __anonunion_u_60 u ;
  SPF_mech_t *spf_mechanism ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  SPF_errcode_t tmp ;
  int tmp___0 ;

  {
  {
#line 834
  spf_mechanism = (SPF_mech_t *)(u.buf);
#line 842
  memset((void *)(u.buf), 'B', sizeof(u.buf));
#line 843
  memset((void *)spf_mechanism, 0, sizeof(SPF_mech_t ));
  }
#line 845
  if (spf_server___1->debug) {
    {
#line 846
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               847, "SPF_c_mech_add: type=%d, value=%s", (int const   )mechtype->mech_type,
               *mech_value);
    }
  }
#line 849
  spf_mechanism->prefix_type = (unsigned char )prefix;
#line 850
  spf_mechanism->mech_type = (unsigned char )mechtype->mech_type;
#line 851
  spf_mechanism->mech_len = (unsigned short)0;
#line 853
  len = sizeof(SPF_mech_t );
#line 855
  if (spf_record->mech_len + len > 511UL) {
#line 856
    return ((SPF_errcode_t )16);
  }
  {
#line 858
  data = SPF_mech_data(spf_mechanism);
#line 859
  data_len = (size_t )0;
#line 861
  src_len = strcspn(*mech_value, " ");
  }
  {
#line 865
  if ((int const   )mechtype->mech_type == 5) {
#line 865
    goto case_5;
  }
#line 878
  if ((int const   )mechtype->mech_type == 6) {
#line 878
    goto case_6;
  }
#line 891
  goto switch_default;
  case_5: /* CIL Label */ 
#line 866
  if ((int const   )*(*mech_value) == 58) {
    {
#line 867
    err = SPF_c_parse_ip4(spf_response, spf_mechanism, *mech_value);
#line 868
    data_len = sizeof(struct in_addr );
    }
  } else {
    {
#line 871
    err = (SPF_errcode_t )9;
#line 872
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 876
  goto switch_break;
  case_6: /* CIL Label */ 
#line 879
  if ((int const   )*(*mech_value) == 58) {
    {
#line 880
    err = SPF_c_parse_ip6(spf_response, spf_mechanism, *mech_value);
#line 881
    data_len = sizeof(struct in6_addr );
    }
  } else {
    {
#line 884
    err = (SPF_errcode_t )9;
#line 885
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 889
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 892
  if ((int const   )*(*mech_value) == 58) {
#line 892
    goto _L___0;
  } else
#line 892
  if ((int const   )*(*mech_value) == 61) {
    _L___0: /* CIL Label */ 
#line 893
    if ((unsigned int const   )mechtype->has_domainspec == 0U) {
      {
#line 894
      err = (SPF_errcode_t )7;
#line 895
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a value.");
      }
    } else {
      {
#line 900
      (*mech_value) ++;
#line 900
      src_len --;
#line 901
      err = SPF_c_parse_domainspec(spf_server___1, spf_response, data, & data_len,
                                   (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                   (SPF_cidr_t )mechtype->has_cidr, 0);
      }
    }
  } else
#line 909
  if ((int const   )*(*mech_value) == 47) {
#line 910
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 911
      err = (SPF_errcode_t )9;
#line 912
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else
#line 916
    if ((unsigned int const   )mechtype->has_cidr == 0U) {
      {
#line 917
      err = (SPF_errcode_t )8;
#line 918
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a CIDR.");
      }
    } else {
      {
#line 923
      err = SPF_c_parse_domainspec(spf_server___1, spf_response, data, & data_len,
                                   (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                   (SPF_cidr_t )2, 0);
      }
    }
  } else
#line 931
  if ((int const   )*(*mech_value) == 32) {
#line 931
    goto _L;
  } else
#line 931
  if ((int const   )*(*mech_value) == 0) {
    _L: /* CIL Label */ 
#line 932
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 933
      err = (SPF_errcode_t )9;
#line 934
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else {
#line 939
      err = (SPF_errcode_t )0;
    }
  } else {
    {
#line 943
    err = (SPF_errcode_t )3;
#line 944
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Unknown character \'%c\' after mechanism.", (int const   )*(*mech_value));
    }
  }
#line 951
  spf_mechanism->mech_len = (unsigned short )data_len;
#line 952
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 955
  len += data_len;
#line 958
  if ((unsigned int )err == 0U) {
#line 959
    if (mechtype->is_dns_mech) {
#line 960
      spf_record->num_dns_mech = (unsigned char )((int )spf_record->num_dns_mech + 1);
    }
    {
#line 961
    tmp___0 = SPF_c_ensure_capacity((void **)(& spf_record->mech_first), & spf_record->mech_size,
                                    spf_record->mech_len + len);
    }
#line 961
    if (tmp___0 < 0) {
      {
#line 964
      tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                       (char const   *)((void *)0), "Failed to allocate memory for mechanism");
      }
#line 964
      return (tmp);
    }
    {
#line 968
    memcpy((void */* __restrict  */)((char *)spf_record->mech_first + spf_record->mech_len),
           (void const   */* __restrict  */)spf_mechanism, len);
#line 971
    spf_record->mech_len += len;
#line 972
    spf_record->num_mech = (unsigned char )((int )spf_record->num_mech + 1);
    }
  }
#line 975
  *mech_value += src_len;
#line 977
  return (err);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mod_add)(SPF_server_t *spf_server___1 ,
                                                                              SPF_record_t *spf_record ,
                                                                              SPF_response_t *spf_response ,
                                                                              char const   *mod_name ,
                                                                              size_t name_len ,
                                                                              char const   **mod_value ) 
{ 
  union __anonunion_u_61 u ;
  SPF_mod_t *spf_modifier ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  char *tmp ;
  SPF_errcode_t tmp___0 ;
  int tmp___1 ;

  {
#line 992
  spf_modifier = (SPF_mod_t *)(u.buf);
#line 1000
  if (spf_server___1->debug) {
    {
#line 1001
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               1002, "Adding modifier name=%lu@%s, value=%s", name_len, mod_name,
               *mod_value);
    }
  }
  {
#line 1004
  memset((void *)(u.buf), 'A', sizeof(u.buf));
#line 1005
  memset((void *)spf_modifier, 0, sizeof(SPF_mod_t ));
  }
#line 1007
  if (name_len > 511UL) {
#line 1008
    return ((SPF_errcode_t )17);
  }
  {
#line 1010
  spf_modifier->name_len = (unsigned short )name_len;
#line 1011
  spf_modifier->data_len = (unsigned short)0;
#line 1014
  len = _align_sz(sizeof(SPF_mod_t ) + name_len);
  }
#line 1016
  if (spf_record->mod_len + len > 511UL) {
#line 1017
    return ((SPF_errcode_t )17);
  }
  {
#line 1019
  tmp = SPF_mod_name(spf_modifier);
#line 1019
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)mod_name,
         name_len);
#line 1021
  data = SPF_mod_data(spf_modifier);
#line 1022
  data_len = (size_t )0;
#line 1024
  src_len = strcspn(*mod_value, " ");
#line 1026
  err = SPF_c_parse_macro(spf_server___1, spf_response, data, & data_len, (size_t )511,
                          *mod_value, src_len, (SPF_errcode_t )17, 1);
#line 1032
  spf_modifier->data_len = (unsigned short )data_len;
#line 1033
  len += data_len;
  }
#line 1036
  if ((unsigned int )err == 0U) {
    {
#line 1037
    tmp___1 = SPF_c_ensure_capacity((void **)(& spf_record->mod_first), & spf_record->mod_size,
                                    spf_record->mod_len + len);
    }
#line 1037
    if (tmp___1 < 0) {
      {
#line 1040
      tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                           (char const   *)((void *)0), "Failed to allocate memory for modifier");
      }
#line 1040
      return (tmp___0);
    }
    {
#line 1044
    memcpy((void */* __restrict  */)((char *)spf_record->mod_first + spf_record->mod_len),
           (void const   */* __restrict  */)spf_modifier, len);
#line 1047
    spf_record->mod_len += len;
#line 1048
    spf_record->num_mod = (unsigned char )((int )spf_record->num_mod + 1);
    }
  }
#line 1051
  return (err);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static void SPF_record_lint(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                            SPF_record_t *spf_record ) 
{ 
  SPF_data_t *d ;
  SPF_data_t *data_end ;
  char *s ;
  char *s_end ;
  int found_non_ip ;
  int found_valid_tld ;
  SPF_mech_t *mech ;
  SPF_data_t *data ;
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1075
  mech = spf_record->mech_first;
#line 1076
  i = 0;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (i < (int )spf_record->num_mech)) {
#line 1076
      goto while_break;
    }
#line 1081
    if ((int )mech->mech_type == 8) {
#line 1081
      goto _L;
    } else
#line 1081
    if ((int )mech->mech_type == 9) {
      _L: /* CIL Label */ 
#line 1081
      if (i != (int )spf_record->num_mech - 1) {
        {
#line 1085
        SPF_response_add_warn(spf_response, (SPF_errcode_t )29, "Mechanisms found after the \"all:\" mechanism will be ignored.");
        }
      }
    }
#line 1098
    if ((int )mech->mech_type == 5) {
#line 1100
      goto __Cont;
    } else
#line 1098
    if ((int )mech->mech_type == 6) {
#line 1100
      goto __Cont;
    }
    {
#line 1102
    data = SPF_mech_data(mech);
#line 1103
    data_end = SPF_mech_end_data(mech);
    }
#line 1104
    if ((unsigned long )data == (unsigned long )data_end) {
#line 1105
      goto __Cont;
    }
#line 1107
    if ((int )data->dc.parm_type == 11) {
      {
#line 1109
      data = SPF_data_next(data);
      }
#line 1110
      if ((unsigned long )data == (unsigned long )data_end) {
#line 1111
        goto __Cont;
      }
    }
#line 1115
    found_valid_tld = 0;
#line 1116
    found_non_ip = 0;
#line 1118
    d = data;
    {
#line 1118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1118
      if (! ((unsigned long )d < (unsigned long )data_end)) {
#line 1118
        goto while_break___0;
      }
      {
#line 1122
      if ((int )d->dv.parm_type == 11) {
#line 1122
        goto case_11;
      }
#line 1128
      if ((int )d->dv.parm_type == 0) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 5) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 4) {
#line 1128
        goto case_0;
      }
#line 1132
      if ((int )d->dv.parm_type == 12) {
#line 1132
        goto case_12;
      }
#line 1148
      goto switch_default;
      case_11: /* CIL Label */ 
      {
#line 1123
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1123, "%s", "Multiple CIDR parameters found");
      }
#line 1124
      goto switch_break;
      case_0: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 1129
      found_valid_tld = 0;
#line 1130
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 1133
      found_valid_tld = 0;
#line 1135
      s = SPF_data_str(d);
#line 1136
      s_end = s + (int )d->ds.len;
      }
      {
#line 1137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1137
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 1137
          goto while_break___1;
        }
        {
#line 1138
        tmp = __ctype_b_loc();
        }
#line 1138
        if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 2048)) {
#line 1138
          if ((int )*s != 46) {
#line 1138
            if ((int )*s != 58) {
#line 1139
              found_non_ip = 1;
            }
          }
        }
#line 1141
        if ((int )*s == 46) {
#line 1142
          found_valid_tld = 1;
        } else {
          {
#line 1143
          tmp___0 = __ctype_b_loc();
          }
#line 1143
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 1024)) {
#line 1144
            found_valid_tld = 0;
          }
        }
#line 1137
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1146
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1149
      found_non_ip = 1;
#line 1150
      found_valid_tld = 1;
#line 1152
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1118
      d = SPF_data_next(d);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1156
    if (! found_valid_tld) {
#line 1156
      goto _L___0;
    } else
#line 1156
    if (! found_non_ip) {
      _L___0: /* CIL Label */ 
#line 1157
      if (! found_non_ip) {
        {
#line 1158
        SPF_response_add_warn(spf_response, (SPF_errcode_t )27, "Invalid hostname (an IP address?)");
        }
      } else
#line 1160
      if (! found_valid_tld) {
        {
#line 1161
        SPF_response_add_warn(spf_response, (SPF_errcode_t )28, "Hostname has a missing or invalid TLD");
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 1076
    i ++;
#line 1076
    mech = SPF_mech_next(mech);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1168
  return;
}
}
#line 1179 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
SPF_errcode_t SPF_record_compile(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                 SPF_record_t **spf_recordp , char const   *record ) 
{ 
  SPF_mechtype_t const   *mechtype ;
  SPF_record_t *spf_record ;
  SPF_error_t *spf_error ;
  SPF_errcode_t err ;
  char const   *name_start ;
  size_t name_len ;
  char const   *val_start ;
  char const   *val_end ;
  int prefix ;
  char const   *p ;
  int i ;
  SPF_errcode_t tmp ;
  int tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  SPF_errcode_t tmp___17 ;
  int tmp___18 ;
  SPF_errcode_t tmp___19 ;
  char tmp___20 ;
  int tmp___21 ;
  SPF_errcode_t tmp___22 ;
  int tmp___23 ;

  {
  {
#line 1205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1205
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 1205
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1205, "%s", "spf_server is NULL");
      }
    }
#line 1205
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1206
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1206
    if ((unsigned long )spf_recordp == (unsigned long )((void *)0)) {
      {
#line 1206
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1206, "%s", "spf_recordp is NULL");
      }
    }
#line 1206
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1207
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1207
    if ((unsigned long )record == (unsigned long )((void *)0)) {
      {
#line 1207
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1207, "%s", "record is NULL");
      }
    }
#line 1207
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1209
  if (spf_server___1->debug) {
    {
#line 1210
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               1210, "Compiling record %s", record);
    }
  }
  {
#line 1216
  *spf_recordp = (SPF_record_t *)((void *)0);
#line 1221
  p = record;
#line 1223
  tmp___0 = strncasecmp(p, "v=spf1", sizeof("v=spf1") - 1UL);
  }
#line 1223
  if (tmp___0 != 0) {
    {
#line 1224
    tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )2, (char const   *)((void *)0),
                                     p, "Could not find a valid SPF record");
    }
#line 1224
    return (tmp);
  }
#line 1227
  p += sizeof("v=spf1") - 1UL;
#line 1229
  if ((int const   )*p != 0) {
#line 1229
    if ((int const   )*p != 32) {
      {
#line 1230
      tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )2, (char const   *)((void *)0),
                                           p, "Could not find a valid SPF record");
      }
#line 1230
      return (tmp___1);
    }
  }
  {
#line 1234
  spf_record = SPF_record_new(spf_server___1, record);
  }
#line 1235
  if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
    {
#line 1236
    *spf_recordp = (SPF_record_t *)((void *)0);
#line 1237
    tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                         p, "Failed to allocate an SPF record");
    }
#line 1237
    return (tmp___2);
  }
#line 1241
  spf_record->version = (unsigned char)1;
#line 1242
  *spf_recordp = spf_record;
  {
#line 1247
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1247
    if (! ((int const   )*p != 0)) {
#line 1247
      goto while_break___2;
    }
    {
#line 1250
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1250
      if (! ((int const   )*p == 32)) {
#line 1250
        goto while_break___3;
      }
#line 1251
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1253
    if ((int const   )*p == 0) {
#line 1254
      goto while_break___2;
    }
#line 1257
    prefix = 7;
    {
#line 1259
    if ((int const   )*p == 43) {
#line 1259
      goto case_43;
    }
#line 1264
    if ((int const   )*p == 45) {
#line 1264
      goto case_45;
    }
#line 1269
    if ((int const   )*p == 126) {
#line 1269
      goto case_126;
    }
#line 1274
    if ((int const   )*p == 63) {
#line 1274
      goto case_63;
    }
#line 1279
    goto switch_default;
    case_43: /* CIL Label */ 
#line 1260
    prefix = 2;
#line 1261
    p ++;
#line 1262
    goto switch_break;
    case_45: /* CIL Label */ 
#line 1265
    prefix = 3;
#line 1266
    p ++;
#line 1267
    goto switch_break;
    case_126: /* CIL Label */ 
#line 1270
    prefix = 4;
#line 1271
    p ++;
#line 1272
    goto switch_break;
    case_63: /* CIL Label */ 
#line 1275
    prefix = 1;
#line 1276
    p ++;
#line 1277
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1280
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1280
      tmp___3 = __ctype_b_loc();
      }
#line 1280
      if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*p)) & 4)) {
#line 1280
        goto while_break___4;
      }
      {
#line 1281
      SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )21, (char const   *)((void *)0),
                                 p, "Invalid prefix \'%c\'", (int const   )*p);
#line 1284
      p ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1286
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1289
    name_start = p;
#line 1290
    tmp___4 = strcspn(p, " ");
#line 1290
    val_end = name_start + tmp___4;
#line 1293
    tmp___6 = __ctype_b_loc();
    }
#line 1293
    if (! ((int const   )*(*tmp___6 + (int )((unsigned char )*p)) & 1024)) {
      {
#line 1295
      SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )5, (char const   *)((void *)0),
                                 p, "Invalid character at start of mechanism");
#line 1298
      tmp___5 = strcspn(p, " ");
#line 1298
      p += tmp___5;
      }
#line 1299
      goto while_continue___2;
    }
    {
#line 1301
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1301
      tmp___7 = __ctype_b_loc();
      }
#line 1301
      if (! ((int const   )*(*tmp___7 + (int )((unsigned char )*p)) & 8)) {
#line 1301
        if (! ((int const   )*p == 95)) {
#line 1301
          if (! ((int const   )*p == 45)) {
#line 1301
            goto while_break___5;
          }
        }
      }
#line 1302
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1311
    name_len = (size_t )(p - name_start);
#line 1313
    if (spf_server___1->debug) {
      {
#line 1314
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1314, "Name starts at  %s", name_start);
      }
    }
    {
#line 1321
    if ((int const   )*p == 0) {
#line 1321
      goto compile_mech;
    }
#line 1321
    if ((int const   )*p == 32) {
#line 1321
      goto compile_mech;
    }
#line 1321
    if ((int const   )*p == 47) {
#line 1321
      goto compile_mech;
    }
#line 1321
    if ((int const   )*p == 58) {
#line 1321
      goto compile_mech;
    }
#line 1423
    if ((int const   )*p == 61) {
#line 1423
      goto case_61;
    }
#line 1462
    goto switch_default___0;
    compile_mech: 
    case_0: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_47: /* CIL Label */ 
    case_58: /* CIL Label */ 
#line 1329
    if (prefix == 7) {
#line 1330
      prefix = 2;
    }
#line 1332
    if (name_len == sizeof("a") - 1UL) {
      {
#line 1332
      tmp___16 = strncasecmp(name_start, "a", name_len);
      }
#line 1332
      if (tmp___16 == 0) {
        {
#line 1333
        mechtype = SPF_mechtype_find(1);
        }
      } else {
#line 1332
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 1334
    if (name_len == sizeof("mx") - 1UL) {
      {
#line 1334
      tmp___15 = strncasecmp(name_start, "mx", name_len);
      }
#line 1334
      if (tmp___15 == 0) {
        {
#line 1335
        mechtype = SPF_mechtype_find(2);
        }
      } else {
#line 1334
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 1336
    if (name_len == sizeof("ptr") - 1UL) {
      {
#line 1336
      tmp___14 = strncasecmp(name_start, "ptr", name_len);
      }
#line 1336
      if (tmp___14 == 0) {
        {
#line 1337
        mechtype = SPF_mechtype_find(3);
        }
      } else {
#line 1336
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1338
    if (name_len == sizeof("include") - 1UL) {
      {
#line 1338
      tmp___13 = strncasecmp(name_start, "include", name_len);
      }
#line 1338
      if (tmp___13 == 0) {
        {
#line 1339
        mechtype = SPF_mechtype_find(4);
        }
      } else {
#line 1338
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1340
    if (name_len == sizeof("ip4") - 1UL) {
      {
#line 1340
      tmp___12 = strncasecmp(name_start, "ip4", name_len);
      }
#line 1340
      if (tmp___12 == 0) {
        {
#line 1341
        mechtype = SPF_mechtype_find(5);
        }
      } else {
#line 1340
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1342
    if (name_len == sizeof("ip6") - 1UL) {
      {
#line 1342
      tmp___11 = strncasecmp(name_start, "ip6", name_len);
      }
#line 1342
      if (tmp___11 == 0) {
        {
#line 1343
        mechtype = SPF_mechtype_find(6);
        }
      } else {
#line 1342
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1344
    if (name_len == sizeof("exists") - 1UL) {
      {
#line 1344
      tmp___10 = strncasecmp(name_start, "exists", name_len);
      }
#line 1344
      if (tmp___10 == 0) {
        {
#line 1345
        mechtype = SPF_mechtype_find(7);
        }
      } else {
#line 1344
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1346
    if (name_len == sizeof("all") - 1UL) {
      {
#line 1346
      tmp___9 = strncasecmp(name_start, "all", name_len);
      }
#line 1346
      if (tmp___9 == 0) {
        {
#line 1347
        mechtype = SPF_mechtype_find(8);
        }
      } else {
#line 1346
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1387
    if (name_len == sizeof("redirect") - 1UL) {
      {
#line 1387
      tmp___8 = strncasecmp(name_start, "redirect", name_len);
      }
#line 1387
      if (tmp___8 == 0) {
        {
#line 1388
        mechtype = SPF_mechtype_find(9);
        }
      } else {
        {
#line 1391
        SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )6, (char const   *)((void *)0),
                                   name_start, "Unknown mechanism found");
#line 1394
        p = val_end;
        }
#line 1395
        goto while_continue___2;
      }
    } else {
      {
#line 1391
      SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )6, (char const   *)((void *)0),
                                 name_start, "Unknown mechanism found");
#line 1394
      p = val_end;
      }
#line 1395
      goto while_continue___2;
    }
#line 1398
    if ((unsigned long )mechtype == (unsigned long )((void *)0)) {
      {
#line 1399
      tmp___17 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )10, (char const   *)((void *)0),
                                            name_start, "Failed to find specification for a recognised mechanism");
      }
#line 1399
      return (tmp___17);
    }
#line 1406
    if (spf_server___1->debug) {
      {
#line 1407
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1408, "Adding mechanism type %d", (int )mechtype->mech_type);
      }
    }
    {
#line 1410
    val_start = p;
#line 1411
    err = SPF_c_mech_add(spf_server___1, spf_record, spf_response, mechtype, prefix,
                         & val_start);
    }
#line 1414
    if ((unsigned int )err == 1U) {
#line 1415
      return (err);
    }
#line 1420
    p = val_end;
#line 1421
    goto switch_break___0;
    case_61: /* CIL Label */ 
#line 1430
    if (prefix != 7) {
      {
#line 1431
      SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )4, (char const   *)((void *)0),
                                 name_start, "Modifiers may not have prefixes");
      }
    }
    {
#line 1434
    prefix = 7;
#line 1447
    tmp___18 = strncasecmp(name_start, "redirect=", sizeof("redirect=") - 1UL);
    }
#line 1447
    if (tmp___18 == 0) {
#line 1448
      goto compile_mech;
    }
    {
#line 1450
    p ++;
#line 1451
    val_start = p;
#line 1452
    err = SPF_c_mod_add(spf_server___1, spf_record, spf_response, name_start, name_len,
                        & val_start);
    }
#line 1455
    if ((unsigned int )err == 1U) {
#line 1456
      return (err);
    }
#line 1458
    p = val_end;
#line 1459
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 1463
    SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )5, (char const   *)((void *)0),
                               p, "Invalid character in middle of mechanism");
#line 1466
    p = val_end;
    }
#line 1467
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1475
  SPF_record_lint(spf_server___1, spf_response, spf_record);
#line 1484
  tmp___23 = SPF_response_errors(spf_response);
  }
#line 1484
  if (tmp___23 > 0) {
#line 1485
    i = 0;
    {
#line 1485
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 1485
      tmp___21 = SPF_response_messages(spf_response);
      }
#line 1485
      if (! (i < tmp___21)) {
#line 1485
        goto while_break___6;
      }
      {
#line 1486
      spf_error = SPF_response_message(spf_response, i);
#line 1487
      tmp___20 = SPF_error_errorp(spf_error);
      }
#line 1487
      if (tmp___20) {
        {
#line 1488
        tmp___19 = SPF_error_code(spf_error);
        }
#line 1488
        return (tmp___19);
      }
#line 1485
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 1490
    tmp___22 = SPF_response_add_error(spf_response, (SPF_errcode_t )10, "Response has errors but can\'t find one!");
    }
#line 1490
    return (tmp___22);
  }
#line 1495
  return ((SPF_errcode_t )0);
}
}
#line 1498 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
SPF_errcode_t SPF_record_compile_macro(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                       SPF_macro_t **spf_macrop , char const   *record ) 
{ 
  union __anonunion_u_62 u ;
  SPF_macro_t *spf_macro ;
  SPF_data_t *data ;
  SPF_errcode_t err ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 1507
  spf_macro = (SPF_macro_t *)(u.buf);
#line 1512
  data = SPF_macro_data(spf_macro);
#line 1513
  spf_macro->macro_len = (size_t )0;
#line 1515
  tmp = strlen(record);
#line 1515
  err = SPF_c_parse_macro(spf_server___1, spf_response, data, & spf_macro->macro_len,
                          (size_t )511, record, tmp, (SPF_errcode_t )17, 1);
  }
#line 1519
  if ((unsigned int )err != 0U) {
#line 1520
    return (err);
  }
  {
#line 1523
  size = sizeof(SPF_macro_t ) + spf_macro->macro_len;
#line 1524
  tmp___0 = malloc(size);
#line 1524
  *spf_macrop = (SPF_macro_t *)tmp___0;
  }
#line 1525
  if (! *spf_macrop) {
#line 1526
    return ((SPF_errcode_t )1);
  }
  {
#line 1527
  memcpy((void */* __restrict  */)*spf_macrop, (void const   */* __restrict  */)(u.buf),
         size);
  }
#line 1529
  return ((SPF_errcode_t )0);
}
}
#line 267 "../../src/include/spf_record.h"
SPF_errcode_t SPF_record_print(SPF_record_t *spf_record ) ;
#line 140 "../../src/include/spf_internal.h"
void SPF_print_sizeof(void) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_print.c"
SPF_errcode_t SPF_record_print(SPF_record_t *spf_record ) 
{ 
  char *prt_buf ;
  size_t prt_len ;
  int err ;
  SPF_errcode_t tmp ;
  char const   *tmp___0 ;

  {
#line 47
  prt_buf = (char *)((void *)0);
#line 48
  prt_len = (size_t )0;
#line 51
  if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
    {
#line 52
    SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_print.c",
              52, "%s", "SPF header: <null record>");
#line 53
    SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_print.c",
              53, "%s", "Unknown");
    }
#line 54
    return ((SPF_errcode_t )0);
  }
  {
#line 57
  SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_print.c",
            63, "SPF header:  version: %d  mech %d/%u  mod %d/%u  len=%u", (int )spf_record->version,
            (int )spf_record->num_mech, (unsigned int )spf_record->mech_len, (int )spf_record->num_mod,
            (unsigned int )spf_record->mod_len, (unsigned int )((sizeof(SPF_record_t ) + spf_record->mech_len) + spf_record->mod_len));
#line 65
  tmp = SPF_record_stringify(spf_record, & prt_buf, & prt_len);
#line 65
  err = (int )tmp;
  }
#line 66
  if (err == 22) {
    {
#line 67
    SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_print.c",
              67, "%s", "Unknown");
    }
  } else
#line 68
  if (err) {
    {
#line 69
    tmp___0 = SPF_strerror((SPF_errcode_t )err);
#line 69
    SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_print.c",
              69, "SPF_record_stringify error: %s (%d)", tmp___0, err);
    }
  } else {
    {
#line 71
    SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_print.c",
              71, "SPF record:  %s", prt_buf);
    }
  }
#line 73
  if (prt_buf) {
    {
#line 74
    free((void *)prt_buf);
    }
  }
#line 75
  return ((SPF_errcode_t )0);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_print.c"
void SPF_print_sizeof(void) 
{ 


  {
  {
#line 85
  SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_print.c",
            85, "sizeof(SPF_mech_t)=%lu", sizeof(SPF_mech_t ));
#line 86
  SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_print.c",
            86, "sizeof(SPF_data_t)=%lu", sizeof(SPF_data_t ));
#line 87
  SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_print.c",
            87, "sizeof(SPF_mod_t)=%lu", sizeof(SPF_mod_t ));
  }
#line 88
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c"
SPF_record_t *SPF_record_new(SPF_server_t *spf_server___1 , char const   *text ) 
{ 
  SPF_record_t *rp ;
  void *tmp ;

  {
  {
#line 52
  tmp = malloc(sizeof(SPF_record_t ));
#line 52
  rp = (SPF_record_t *)tmp;
  }
#line 53
  if (! rp) {
#line 54
    return (rp);
  }
  {
#line 55
  memset((void *)rp, 0, sizeof(SPF_record_t ));
#line 57
  rp->spf_server = spf_server___1;
  }
#line 59
  return (rp);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c"
void SPF_record_free(SPF_record_t *rp ) 
{ 


  {
#line 65
  if (rp->mech_first) {
    {
#line 66
    free((void *)rp->mech_first);
    }
  }
#line 67
  if (rp->mod_first) {
    {
#line 68
    free((void *)rp->mod_first);
    }
  }
  {
#line 69
  free((void *)rp);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c"
void SPF_macro_free(SPF_macro_t *mac ) 
{ 


  {
  {
#line 75
  free((void *)mac);
  }
#line 76
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c"
static SPF_errcode_t SPF_record_find_mod_data(SPF_record_t *spf_record , char const   *mod_name ,
                                              SPF_data_t **datap , size_t *datalenp ) 
{ 
  SPF_mod_t *mod ;
  size_t name_len ;
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 89
  name_len = strlen(mod_name);
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 94, "%s", "spf_record is NULL");
      }
    }
#line 94
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if ((unsigned long )mod_name == (unsigned long )((void *)0)) {
      {
#line 95
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 95, "%s", "mod_name is NULL");
      }
    }
#line 95
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )datap == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 96, "%s", "datap is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 97
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 97
    if ((unsigned long )datalenp == (unsigned long )((void *)0)) {
      {
#line 97
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 97, "%s", "datalenp is NULL");
      }
    }
#line 97
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 103
  mod = spf_record->mod_first;
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 104
    if (! (i < (int )spf_record->num_mod)) {
#line 104
      goto while_break___3;
    }
#line 105
    if (name_len == (size_t )mod->name_len) {
      {
#line 105
      tmp = SPF_mod_name(mod);
#line 105
      tmp___0 = strncasecmp((char const   *)tmp, mod_name, name_len);
      }
#line 105
      if (tmp___0 == 0) {
        {
#line 108
        *datap = SPF_mod_data(mod);
#line 109
        *datalenp = (size_t )mod->data_len;
        }
#line 111
        return ((SPF_errcode_t )0);
      }
    }
    {
#line 114
    mod = SPF_mod_next(mod);
#line 104
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 117
  return ((SPF_errcode_t )24);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c"
SPF_errcode_t SPF_record_find_mod_value(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                                        SPF_response_t *spf_response , SPF_record_t *spf_record ,
                                        char const   *mod_name , char **bufp , size_t *buflenp ) 
{ 
  SPF_data_t *data ;
  size_t data_len ;
  SPF_errcode_t err ;
  SPF_errcode_t tmp ;

  {
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 140
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 140, "%s", "spf_record is NULL");
      }
    }
#line 140
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 141
    if ((unsigned long )mod_name == (unsigned long )((void *)0)) {
      {
#line 141
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 141, "%s", "mod_name is NULL");
      }
    }
#line 141
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 142
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 142
    if ((unsigned long )bufp == (unsigned long )((void *)0)) {
      {
#line 142
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 142, "%s", "bufp is NULL");
      }
    }
#line 142
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 143
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 143
    if ((unsigned long )buflenp == (unsigned long )((void *)0)) {
      {
#line 143
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 143, "%s", "buflenp is NULL");
      }
    }
#line 143
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 145
  err = SPF_record_find_mod_data(spf_record, mod_name, & data, & data_len);
  }
#line 147
  if (err) {
#line 148
    return (err);
  }
  {
#line 150
  tmp = SPF_record_expand_data(spf_server___1, spf_request, spf_response, data, data_len,
                               bufp, buflenp);
  }
#line 150
  return (tmp);
}
}
#line 472 "/usr/include/arpa/nameser.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ns_msg_getflag)(ns_msg  ,
                                                                                     int  ) ;
#line 473
extern  __attribute__((__nothrow__)) u_int ( __attribute__((__leaf__)) ns_get16)(u_char const   * ) ;
#line 477
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ns_initparse)(u_char const   * ,
                                                                                   int  ,
                                                                                   ns_msg * ) ;
#line 480
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ns_parserr)(ns_msg * ,
                                                                                 ns_sect  ,
                                                                                 int  ,
                                                                                 ns_rr * ) ;
#line 498
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ns_name_uncompress)(u_char const   * ,
                                                                                         u_char const   * ,
                                                                                         u_char const   * ,
                                                                                         char * ,
                                                                                         size_t  ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 366 "/usr/include/resolv.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_ninit)(res_state  ) ;
#line 374
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_nquery)(res_state  ,
                                                                                   char const   * ,
                                                                                   int  ,
                                                                                   int  ,
                                                                                   u_char * ,
                                                                                   int  ) ;
#line 385
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) __res_nclose)(res_state  ) ;
#line 95 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) hstrerror)(int __err_num ) ;
#line 505 "/usr/include/pthread.h"
extern int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *__once_control ,
                                                             void (*__init_routine)(void) ) ;
#line 1122
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_key_create)(pthread_key_t *__key ,
                                                                                                         void (*__destr_function)(void * ) ) ;
#line 1130
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) pthread_getspecific)(pthread_key_t __key ) ;
#line 1133
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_setspecific)(pthread_key_t __key ,
                                                                                          void const   *__pointer ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static struct res_sym  const  ns_sects[4]  = {      {0, (char *)"QUESTION", (char *)"Question"}, 
        {1, (char *)"ANSWER", (char *)"Answer"}, 
        {2, (char *)"AUTHORITY", (char *)"Authority"}, 
        {3, (char *)"ADDITIONAL", (char *)"Additional"}};
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static int const   num_ns_sect  =    (int const   )(sizeof(ns_sects) / sizeof(ns_sects[0]));
#line 89 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_once_t res_state_control  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_key_t res_state_key  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_thread_term(void *arg ) 
{ 


  {
  {
#line 98
  __res_nclose((struct __res_state *)arg);
#line 100
  free(arg);
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_init_key(void) 
{ 


  {
  {
#line 106
  pthread_key_create(& res_state_key, & SPF_dns_resolv_thread_term);
  }
#line 107
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_debug(SPF_dns_server_t *spf_dns_server , ns_rr rr , u_char const   *responsebuf ,
                                 size_t responselen , u_char const   *rdata , size_t rdlen ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char name_buf[1025] ;
  int prio ;
  int err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  u_int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 123
  if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 123
    goto case_1;
  }
#line 132
  if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 132
    goto case_28;
  }
#line 141
  if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 141
    goto case_2;
  }
#line 153
  if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 153
    goto case_5;
  }
#line 165
  if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 165
    goto case_15;
  }
#line 182
  if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 182
    goto case_16;
  }
#line 193
  if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 193
    goto case_12;
  }
#line 205
  goto switch_default;
  case_1: /* CIL Label */ 
#line 124
  if (rdlen != 4UL) {
    {
#line 125
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               125, "A: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 127
    tmp = inet_ntop(2, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip4_buf),
                    (socklen_t )sizeof(ip4_buf));
#line 127
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               129, "A: %s", tmp);
    }
  }
#line 130
  goto switch_break;
  case_28: /* CIL Label */ 
#line 133
  if (rdlen != 16UL) {
    {
#line 134
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               134, "AAAA: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 136
    tmp___0 = inet_ntop(10, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip6_buf),
                        (socklen_t )sizeof(ip6_buf));
#line 136
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               138, "AAAA: %s", tmp___0);
    }
  }
#line 139
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 142
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 146
  if (err < 0) {
    {
#line 147
    tmp___1 = __errno_location();
#line 147
    tmp___2 = __errno_location();
#line 147
    tmp___3 = strerror(*tmp___2);
#line 147
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               148, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___3,
               *tmp___1);
    }
  } else {
    {
#line 150
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               150, "NS: %s", name_buf);
    }
  }
#line 151
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 154
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 158
  if (err < 0) {
    {
#line 159
    tmp___4 = __errno_location();
#line 159
    tmp___5 = __errno_location();
#line 159
    tmp___6 = strerror(*tmp___5);
#line 159
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               160, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___6,
               *tmp___4);
    }
  } else {
    {
#line 162
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               162, "CNAME: %s", name_buf);
    }
  }
#line 163
  goto switch_break;
  case_15: /* CIL Label */ 
#line 166
  if (rdlen < 2UL) {
    {
#line 167
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               167, "MX: rdlen too short: %lu", rdlen);
    }
#line 168
    goto switch_break;
  }
  {
#line 170
  tmp___7 = ns_get16(rdata);
#line 170
  prio = (int )tmp___7;
#line 171
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata + 2, name_buf,
                           sizeof(name_buf));
  }
#line 175
  if (err < 0) {
    {
#line 176
    tmp___8 = __errno_location();
#line 176
    tmp___9 = __errno_location();
#line 176
    tmp___10 = strerror(*tmp___9);
#line 176
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               177, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___10,
               *tmp___8);
    }
  } else {
    {
#line 179
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               179, "MX: %d %s", prio, name_buf);
    }
  }
#line 180
  goto switch_break;
  case_16: /* CIL Label */ 
#line 183
  if (rdlen < 1UL) {
    {
#line 184
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               184, "TXT: rdlen too short: %lu", rdlen);
    }
#line 185
    goto switch_break;
  }
  {
#line 189
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             190, "TXT: (%lu) \"%.*s\"", rdlen, (int )rdlen - 1, rdata + 1);
  }
#line 191
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 194
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 198
  if (err < 0) {
    {
#line 199
    tmp___11 = __errno_location();
#line 199
    tmp___12 = __errno_location();
#line 199
    tmp___13 = strerror(*tmp___12);
#line 199
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               200, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___13,
               *tmp___11);
    }
  } else {
    {
#line 202
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               202, "PTR: %s", name_buf);
    }
  }
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 206
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             206, "not parsed:  type: %d", (unsigned int )((ns_type )((int )rr.type)));
  }
#line 207
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static SPF_dns_rr_t *SPF_dns_resolv_lookup(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                           ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_rr_t *spfrr ;
  int err ;
  int i ;
  int nrec ;
  int cnt ;
  u_char *responsebuf ;
  size_t responselen ;
  ns_msg ns_handle ;
  ns_rr rr ;
  int ns_sect___0 ;
  char name_buf[1025] ;
  size_t rdlen ;
  u_char const   *rdata ;
  void *res_spec ;
  struct __res_state *res_state___0 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int dns_len ;
  char const   *tmp___2 ;
  SPF_dns_rr_t *tmp___3 ;
  SPF_dns_rr_t *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  SPF_errcode_t tmp___20 ;
  SPF_errcode_t tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  SPF_errcode_t tmp___26 ;
  u_char *src ;
  u_char *dst ;
  size_t len ;
  SPF_errcode_t tmp___27 ;
  SPF_errcode_t tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  SPF_errcode_t tmp___33 ;

  {
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 247
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 247, "%s", "spf_dns_server is NULL");
      }
    }
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  res_spec = pthread_getspecific(res_state_key);
  }
#line 252
  if ((unsigned long )res_spec == (unsigned long )((void *)0)) {
    {
#line 253
    tmp = malloc(sizeof(struct __res_state ));
#line 253
    res_state___0 = (struct __res_state *)tmp;
    }
#line 257
    if (! res_state___0) {
      {
#line 258
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 259, "Failed to allocate %lu bytes for res_state", sizeof(struct __res_state ));
      }
    }
    {
#line 260
    memset((void *)res_state___0, 0, sizeof(struct __res_state ));
#line 261
    tmp___0 = __res_ninit(res_state___0);
    }
#line 261
    if (tmp___0 != 0) {
      {
#line 262
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 262, "%s", "Failed to call res_ninit()");
      }
    }
    {
#line 263
    pthread_setspecific(res_state_key, (void const   *)((void *)res_state___0));
    }
  } else {
#line 266
    res_state___0 = (struct __res_state *)res_spec;
  }
  {
#line 270
  responselen = (size_t )2048;
#line 271
  tmp___1 = malloc(responselen);
#line 271
  responsebuf = (u_char *)tmp___1;
  }
#line 272
  if (! responsebuf) {
#line 273
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 274
  memset((void *)responsebuf, 0, responselen);
  }
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 297
    dns_len = __res_nquery(res_state___0, domain, 1, (int )rr_type, responsebuf, (int )responselen);
    }
#line 304
    if (dns_len < 0) {
      {
#line 307
      free((void *)responsebuf);
      }
#line 308
      if (spf_dns_server->debug) {
        {
#line 309
        tmp___2 = hstrerror(res_state___0->res_h_errno);
#line 309
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   311, "query failed: err = %d  %s (%d): %s", dns_len, tmp___2, res_state___0->res_h_errno,
                   domain);
        }
      }
#line 312
      if (res_state___0->res_h_errno == 1) {
#line 312
        if ((unsigned long )spf_dns_server->layer_below != (unsigned long )((void *)0)) {
          {
#line 314
          tmp___3 = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
          }
#line 314
          return (tmp___3);
        }
      }
      {
#line 317
      tmp___4 = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, res_state___0->res_h_errno);
      }
#line 317
      return (tmp___4);
    } else
#line 320
    if ((size_t )dns_len > responselen) {
      {
#line 323
      responselen = (size_t )(dns_len + (dns_len >> 1));
#line 332
      tmp___5 = realloc((void *)responsebuf, responselen);
      }
#line 333
      if (! tmp___5) {
        {
#line 334
        free((void *)responsebuf);
        }
#line 335
        return ((SPF_dns_rr_t *)((void *)0));
      }
#line 337
      responsebuf = (u_char *)tmp___5;
    } else {
#line 341
      responselen = (size_t )dns_len;
#line 342
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 351
  spfrr = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, 0);
  }
#line 353
  if (! spfrr) {
    {
#line 354
    free((void *)responsebuf);
    }
#line 355
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 358
  err = ns_initparse((u_char const   *)responsebuf, (int )responselen, & ns_handle);
  }
#line 360
  if (err < 0) {
#line 361
    if (spf_dns_server->debug) {
      {
#line 362
      tmp___6 = __errno_location();
#line 362
      tmp___7 = __errno_location();
#line 362
      tmp___8 = strerror(*tmp___7);
#line 362
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 363, "ns_initparse failed: err = %d  %s (%d)", err, tmp___8, *tmp___6);
      }
    }
    {
#line 364
    free((void *)responsebuf);
#line 367
    spfrr->herrno = 3;
    }
#line 368
    return (spfrr);
  }
#line 372
  if (spf_dns_server->debug > 1) {
    {
#line 373
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               373, "msg id:             %d", (int )ns_handle._id);
#line 374
    tmp___9 = ns_msg_getflag(ns_handle, 0);
#line 374
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               374, "ns_f_qr quest/resp: %d", tmp___9);
#line 375
    tmp___10 = ns_msg_getflag(ns_handle, 1);
#line 375
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               375, "ns_f_opcode:        %d", tmp___10);
#line 376
    tmp___11 = ns_msg_getflag(ns_handle, 2);
#line 376
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               376, "ns_f_aa auth ans:   %d", tmp___11);
#line 377
    tmp___12 = ns_msg_getflag(ns_handle, 3);
#line 377
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               377, "ns_f_tc truncated:  %d", tmp___12);
#line 378
    tmp___13 = ns_msg_getflag(ns_handle, 4);
#line 378
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               378, "ns_f_rd rec desire: %d", tmp___13);
#line 379
    tmp___14 = ns_msg_getflag(ns_handle, 5);
#line 379
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               379, "ns_f_ra rec avail:  %d", tmp___14);
#line 380
    tmp___15 = ns_msg_getflag(ns_handle, 9);
#line 380
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               380, "ns_f_rcode:         %d", tmp___15);
    }
  }
#line 385
  ns_sect___0 = 0;
  {
#line 385
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 385
    if (! (ns_sect___0 < (int )num_ns_sect)) {
#line 385
      goto while_break___1;
    }
#line 391
    if (ns_sects[ns_sect___0].number != 1) {
#line 391
      if (spf_dns_server->debug <= 1) {
#line 392
        goto __Cont;
      }
    }
#line 394
    nrec = (int )ns_handle._counts[ns_sects[ns_sect___0].number];
#line 396
    if (spf_dns_server->debug > 1) {
      {
#line 397
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 397, "%s:  %d", ns_sects[ns_sect___0].name, nrec);
      }
    }
#line 399
    spfrr->num_rr = 0;
#line 400
    cnt = 0;
#line 401
    i = 0;
    {
#line 401
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 401
      if (! (i < nrec)) {
#line 401
        goto while_break___2;
      }
      {
#line 402
      err = ns_parserr(& ns_handle, (ns_sect )ns_sects[ns_sect___0].number, i, & rr);
      }
#line 403
      if (err < 0) {
#line 404
        if (spf_dns_server->debug > 1) {
          {
#line 405
          tmp___16 = __errno_location();
#line 405
          tmp___17 = __errno_location();
#line 405
          tmp___18 = strerror(*tmp___17);
#line 405
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     406, "ns_parserr failed: err = %d  %s (%d)", err, tmp___18, *tmp___16);
          }
        }
        {
#line 407
        free((void *)responsebuf);
#line 410
        spfrr->herrno = 3;
        }
#line 411
        return (spfrr);
      }
#line 414
      rdlen = (size_t )((int )rr.rdlength);
#line 415
      if (spf_dns_server->debug > 1) {
#line 416
        if ((int )rr.name[0] != 0) {
#line 416
          tmp___19 = (char const   *)(rr.name);
        } else {
#line 416
          tmp___19 = ".";
        }
        {
#line 416
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   418, "name: %s  type: %d  class: %d  ttl: %d  rdlen: %lu", tmp___19,
                   (unsigned int )((ns_type )((int )rr.type)), (unsigned int )((ns_class )((int )rr.rr_class)),
                   rr.ttl, rdlen);
        }
      }
#line 420
      if (rdlen <= 0UL) {
#line 421
        goto __Cont___0;
      }
#line 423
      rdata = rr.rdata + 0;
#line 425
      if (spf_dns_server->debug > 1) {
        {
#line 426
        SPF_dns_resolv_debug(spf_dns_server, rr, (u_char const   *)responsebuf, responselen,
                             rdata, rdlen);
        }
      }
#line 430
      if (ns_sects[ns_sect___0].number != 1) {
#line 431
        goto __Cont___0;
      }
#line 434
      if ((unsigned int )((ns_type )((int )rr.type)) != (unsigned int )spfrr->rr_type) {
#line 434
        if ((unsigned int )((ns_type )((int )rr.type)) != 5U) {
          {
#line 435
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     436, "unexpected rr type: %d   expected: %d", (unsigned int )((ns_type )((int )rr.type)),
                     (unsigned int )rr_type);
          }
#line 437
          goto __Cont___0;
        }
      }
      {
#line 441
      if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 441
        goto case_1;
      }
#line 458
      if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 458
        goto case_28;
      }
#line 475
      if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 475
        goto case_2;
      }
#line 478
      if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 478
        goto case_5;
      }
#line 482
      if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 482
        goto case_15;
      }
#line 513
      if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 513
        goto case_16;
      }
#line 562
      if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 562
        goto case_12;
      }
#line 588
      goto switch_default;
      case_1: /* CIL Label */ 
#line 442
      if (rdlen != 4UL) {
        {
#line 444
        free((void *)responsebuf);
        }
#line 445
        return (spfrr);
      }
      {
#line 447
      tmp___20 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->a));
      }
#line 447
      if ((unsigned int )tmp___20 != 0U) {
        {
#line 449
        free((void *)responsebuf);
        }
#line 452
        return (spfrr);
      }
      {
#line 454
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->a), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->a));
#line 455
      cnt ++;
      }
#line 456
      goto switch_break;
      case_28: /* CIL Label */ 
#line 459
      if (rdlen != 16UL) {
        {
#line 461
        free((void *)responsebuf);
        }
#line 462
        return (spfrr);
      }
      {
#line 464
      tmp___21 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->aaaa));
      }
#line 464
      if ((unsigned int )tmp___21 != 0U) {
        {
#line 466
        free((void *)responsebuf);
        }
#line 469
        return (spfrr);
      }
      {
#line 471
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->aaaa), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->aaaa));
#line 472
      cnt ++;
      }
#line 473
      goto switch_break;
      case_2: /* CIL Label */ 
#line 476
      goto switch_break;
      case_5: /* CIL Label */ 
#line 480
      goto switch_break;
      case_15: /* CIL Label */ 
#line 483
      if (rdlen < 2UL) {
        {
#line 485
        free((void *)responsebuf);
        }
#line 486
        return (spfrr);
      }
      {
#line 488
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata + 2, name_buf, sizeof(name_buf));
      }
#line 492
      if (err < 0) {
#line 493
        if (spf_dns_server->debug > 1) {
          {
#line 494
          tmp___22 = __errno_location();
#line 494
          tmp___23 = __errno_location();
#line 494
          tmp___24 = strerror(*tmp___23);
#line 494
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     495, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___24,
                     *tmp___22);
          }
        }
        {
#line 496
        free((void *)responsebuf);
        }
#line 499
        return (spfrr);
      }
      {
#line 502
      tmp___25 = strlen((char const   *)(name_buf));
#line 502
      tmp___26 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___25 + 1UL);
      }
#line 502
      if ((unsigned int )tmp___26 != 0U) {
        {
#line 504
        free((void *)responsebuf);
        }
#line 507
        return (spfrr);
      }
      {
#line 509
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->mx), (char const   */* __restrict  */)(name_buf));
#line 510
      cnt ++;
      }
#line 511
      goto switch_break;
      case_16: /* CIL Label */ 
#line 514
      if (rdlen > 1UL) {
        {
#line 520
        tmp___27 = SPF_dns_rr_buf_realloc(spfrr, cnt, rdlen);
        }
#line 520
        if ((unsigned int )tmp___27 != 0U) {
          {
#line 521
          free((void *)responsebuf);
          }
#line 524
          return (spfrr);
        }
#line 527
        dst = (u_char *)((*(spfrr->rr + cnt))->txt);
#line 528
        src = (u_char *)rdata;
#line 529
        len = (size_t )0;
        {
#line 530
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 530
          if (! (rdlen > 0UL)) {
#line 530
            goto while_break___3;
          }
#line 532
          len = (size_t )*src;
#line 533
          src ++;
#line 534
          rdlen --;
#line 538
          if (len > rdlen) {
#line 539
            len = rdlen;
          }
          {
#line 540
          memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src,
                 len);
#line 543
          src += len;
#line 544
          dst += len;
#line 545
          rdlen -= len;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 547
        *dst = (u_char )'\000';
      } else {
        {
#line 550
        tmp___28 = SPF_dns_rr_buf_realloc(spfrr, cnt, (size_t )1);
        }
#line 550
        if ((unsigned int )tmp___28 != 0U) {
          {
#line 551
          free((void *)responsebuf);
          }
#line 554
          return (spfrr);
        }
#line 556
        (*(spfrr->rr + cnt))->txt[0] = (char )'\000';
      }
#line 559
      cnt ++;
#line 560
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 563
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata, name_buf, sizeof(name_buf));
      }
#line 567
      if (err < 0) {
#line 568
        if (spf_dns_server->debug > 1) {
          {
#line 569
          tmp___29 = __errno_location();
#line 569
          tmp___30 = __errno_location();
#line 569
          tmp___31 = strerror(*tmp___30);
#line 569
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     570, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___31,
                     *tmp___29);
          }
        }
        {
#line 571
        free((void *)responsebuf);
        }
#line 574
        return (spfrr);
      }
      {
#line 577
      tmp___32 = strlen((char const   *)(name_buf));
#line 577
      tmp___33 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___32 + 1UL);
      }
#line 577
      if ((unsigned int )tmp___33 != 0U) {
        {
#line 579
        free((void *)responsebuf);
        }
#line 582
        return (spfrr);
      }
      {
#line 584
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->ptr), (char const   */* __restrict  */)(name_buf));
#line 585
      cnt ++;
      }
#line 586
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 589
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 401
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 593
    spfrr->num_rr = cnt;
    __Cont: /* CIL Label */ 
#line 385
    ns_sect___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 596
  if (spfrr->num_rr == 0) {
#line 597
    spfrr->herrno = 4;
  }
  {
#line 599
  free((void *)responsebuf);
  }
#line 600
  return (spfrr);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_free(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 607
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 607, "%s", "spf_dns_server is NULL");
      }
    }
#line 607
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  free((void *)spf_dns_server);
  }
#line 614
  return;
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
SPF_dns_server_t *SPF_dns_resolv_new(SPF_dns_server_t *layer_below , char const   *name ,
                                     int debug ) 
{ 
  SPF_dns_server_t *spf_dns_server ;
  void *tmp ;

  {
  {
#line 623
  pthread_once(& res_state_control, & SPF_dns_resolv_init_key);
#line 631
  tmp = malloc(sizeof(SPF_dns_server_t ));
#line 631
  spf_dns_server = (SPF_dns_server_t *)tmp;
  }
#line 632
  if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
#line 633
    return ((SPF_dns_server_t *)((void *)0));
  }
  {
#line 634
  memset((void *)spf_dns_server, 0, sizeof(SPF_dns_server_t ));
  }
#line 636
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 637
    name = "resolv";
  }
#line 639
  spf_dns_server->destroy = & SPF_dns_resolv_free;
#line 640
  spf_dns_server->lookup = & SPF_dns_resolv_lookup;
#line 641
  spf_dns_server->get_spf = (SPF_errcode_t (*)(SPF_server_t *spf_server , SPF_request_t *spf_request ,
                                               SPF_response_t *spf_response , SPF_record_t **spf_recordp ))((void *)0);
#line 642
  spf_dns_server->get_exp = (SPF_errcode_t (*)(SPF_server_t *spf_server , char const   *domain ,
                                               char **buf , size_t *buf_len ))((void *)0);
#line 643
  spf_dns_server->add_cache = (int (*)(SPF_server_t *spf_server , SPF_dns_rr_t spfrr ))((void *)0);
#line 644
  spf_dns_server->layer_below = layer_below;
#line 645
  spf_dns_server->name = name;
#line 646
  spf_dns_server->debug = debug;
#line 648
  return (spf_dns_server);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_default.c"
 __attribute__((__noreturn__)) void (*SPF_error_handler)(char const   * , int  , char const   * )  =    & SPF_error_stdio;
#line 30 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_default.c"
void (*SPF_warning_handler)(char const   * , int  , char const   * )  =    & SPF_warning_stdio;
#line 31 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_default.c"
void (*SPF_info_handler)(char const   * , int  , char const   * )  =    & SPF_info_stdio;
#line 32 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_log_default.c"
void (*SPF_debug_handler)(char const   * , int  , char const   * )  =    & SPF_debug_stdio;
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
static SPF_dns_test_data_t const   SPF_dns_db___0[175]  = 
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
  {      {"localhost", 1, 0, "127.0.0.1"}, 
        {"example.com", 1, 0, "192.0.2.3"}, 
        {"example.com", 15, 0, "mx.example.org"}, 
        {"example.com", 16, 0, "v=spf1 mx -all"}, 
        {"3.2.0.192.in-addr.arpa", 12, 0, "mx.example.org"}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}, 
        {"noexist.example.com", 1, 1, (char const   *)((void *)0)}, 
        {"mx.example.org", 1, 0, "192.0.2.3"}, 
        {"mx.example.org", 28, 0, "5f05:2000:80ad:5800::1"}, 
        {"email.example.com", 16, 0, "v=spf1 -all"}, 
        {"*.example.com", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.org", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.net", 255, 1, (char const   *)((void *)0)}, 
        {"01.spf1-test.mailzone.com", 16, 0, "v=spf1                                                             "}, 
        {"02.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             -all       "}, 
        {"03.spf1-test.mailzone.com", 16, 0, "v=spf1                                             ~all"}, 
        {"05.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             default=deny   "}, 
        {"06.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             ?all "}, 
        {"07.spf1-test.mailzone.com", 16, 0, "v=spf2                                             default=bogus   "}, 
        {"08.spf1-test.mailzone.com",
      16, 0, "v=spf1                       -all      ?all  "}, 
        {"09.spf1-test.mailzone.com", 16, 0, "v=spf1    scope=header-from scope=envelope         -all  "}, 
        {"10.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx                                          -all"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"11.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"13.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"20.spf1-test.mailzone.com", 1, 0, "192.0.2.120"}, 
        {"20.spf1-test.mailzone.com", 16, 0, "v=spf1 a                                           -all"}, 
        {"21.spf1-test.mailzone.com",
      16, 0, "v=spf1   a:spf1-test.mailzone.com                            -all"}, 
        {"21.spf1-test.mailzone.com",
      1, 0, "192.0.2.121"}, 
        {"22.spf1-test.mailzone.com", 16, 0, "v=spf1 a a:spf1-test.mailzone.com                            -all"}, 
        {"22.spf1-test.mailzone.com",
      1, 0, "192.0.2.122"}, 
        {"30.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr                                         -all"}, 
        {"30.spf1-test.mailzone.com",
      1, 0, "208.210.124.130"}, 
        {"31.spf1-test.mailzone.com", 16, 0, "v=spf1     ptr:spf1-test.mailzone.com                        -all"}, 
        {"31.spf1-test.mailzone.com",
      1, 0, "208.210.124.131"}, 
        {"32.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr ptr:spf1-test.mailzone.com                        -all"}, 
        {"32.spf1-test.mailzone.com",
      1, 0, "208.210.124.132"}, 
        {"40.spf1-test.mailzone.com", 16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d}                    -all"}, 
        {"41.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.spf1-test.mailzone.com            -all"}, 
        {"42.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d} exists:%{ir}.%{v}._spf.%{d3} -all"}, 
        {"45.spf1-test.mailzone.com",
      16, 0, "v=spf1 -a a:spf1-test.mailzone.com                           -all"}, 
        {"45.spf1-test.mailzone.com",
      1, 0, "192.0.2.147"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.145"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.146"}, 
        {"50.spf1-test.mailzone.com", 16, 0, "v=spf1 include                                     -all"}, 
        {"51.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"52.spf1-test.mailzone.com", 16, 0, "v=spf1 include:53.spf1-test.mailzone.com                  -all"}, 
        {"53.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"54.spf1-test.mailzone.com", 16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"55.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:56.spf1-test.mailzone.com                  -all"}, 
        {"57.spf1-test.mailzone.com", 16, 0, "v=spf1 include:spf1-test.mailzone.com         -all"}, 
        {"58.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:59.spf1-test.mailzone.com                  -all"}, 
        {"59.spf1-test.mailzone.com", 16, 0, "v=spf1 include:58.spf1-test.mailzone.com                  -all"}, 
        {"70.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{lr+=}.lp._spf.spf1-test.mailzone.com -all"}, 
        {"80.spf1-test.mailzone.com", 16, 0, "v=spf1 a mx exists:%{ir}.%{v}._spf.80.spf1-test.mailzone.com ptr -all"}, 
        {"80.spf1-test.mailzone.com",
      1, 0, "208.210.124.180"}, 
        {"90.spf1-test.mailzone.com", 16, 0, "v=spf1  ip4:192.0.2.128/25 -all"}, 
        {"91.spf1-test.mailzone.com", 16, 0, "v=spf1 -ip4:192.0.2.128/25 ip4:192.0.2.0/24 -all"}, 
        {"92.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?ip4:192.0.2.192/26 ip4:192.0.2.128/25 -ip4:192.0.2.0/24 -all"}, 
        {"95.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -all"}, 
        {"96.spf1-test.mailzone.com", 16, 0, "v=spf1 -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"97.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"98.spf1-test.mailzone.com",
      16, 0, "v=spf1 a/26 mx/26 -all"}, 
        {"98.spf1-test.mailzone.com", 15, 0, "80.spf1-test.mailzone.com"}, 
        {"98.spf1-test.mailzone.com", 1, 0, "192.0.2.98"}, 
        {"99.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp=99txt.spf1-test.mailzone.com moo"}, 
        {"99txt.spf1-test.mailzone.com",
      16, 0, "u=%{u} s=%{s} d=%{d} t=%{t} h=%{h} i=%{i} %% U=%{U} S=%{S} D=%{D} T=%{T} H=%{H} I=%{I} %% moo"}, 
        {"100.spf1-test.mailzone.com",
      16, 0, "v=spf1      redirect=98.spf1-test.mailzone.com"}, 
        {"101.spf1-test.mailzone.com", 16, 0, "v=spf1 -all redirect=98.spf1-test.mailzone.com"}, 
        {"102.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?all redirect=98.spf1-test.mailzone.com"}, 
        {"103.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=98.%{d3}"}, 
        {"104.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=105.%{d3}"}, 
        {"105.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=106.%{d3}"}, 
        {"106.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=107.%{d3}"}, 
        {"107.spf1-test.mailzone.com", 16, 0, "v=spf1       include:104.%{d3}"}, 
        {"110.spf1-test.mailzone.com", 16, 0, "v=spf1 some:unrecognized=mechanism some=unrecognized:modifier -all"}, 
        {"111.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx -a gpg ~all exp=111txt.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"111txt.2.0.192.in-addr._spf.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"112.spf1-test.mailzone.com",
      16, 0, "v=spf1 a mp3 ~all"}, 
        {"112.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"113.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3: ~all"}, 
        {"113.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114.spf1-test.mailzone.com", 16, 0, "v=spf1 mx -a gpg=test ~all exp=114txt.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com",
      15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114txt.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"115.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3=yes -all"}, 
        {"115.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"116.spf1-test.mailzone.com", 16, 0, "v=spf1 redirect=116rdr.spf1-test.mailzone.com a"}, 
        {"116.spf1-test.mailzone.com",
      1, 0, "192.0.2.200"}, 
        {"116rdr.spf1-test.mailzone.com", 16, 0, "v=spf1 -all"}, 
        {"117.spf1-test.mailzone.com", 16, 0, " v=spf1 +all"}, 
        {"118.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp="}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.10"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.11"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.12"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.13"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.20"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.21"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.22"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.23"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.30"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.31"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.32"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.33"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.40"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.41"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.42"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.43"}, 
        {"56.spf1-test.mailzone.com", 16, 4, (char const   *)((void *)0)}, 
        {"80.spf1-test.mailzone.com", 15, 4, (char const   *)((void *)0)}, 
        {"servfail.spf1-test.mailzone.com", 16, 2, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 1, 0, "208.210.124.192"}, 
        {"spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"fallback-relay.spf1-test.mailzone.com", 15, 0, "mx04.spf1-test.mailzone.com"}, 
        {"www1.cnn.com",
      1, 0, "64.236.24.4"}, 
        {"4.24.236.64.in-addr.arpa", 12, 0, "www1.cnn.com"}, 
        {"130.124.210.208.in-addr.arpa", 12, 0, "30.spf1-test.mailzone.com"}, 
        {"131.124.210.208.in-addr.arpa", 12, 0, "31.spf1-test.mailzone.com"}, 
        {"192.124.210.208.in-addr.arpa", 12, 0, "spf1-test.mailzone.com"}, 
        {"100.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"110.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"111.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"101.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"130.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"131.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"80.2.0.192.in-addr._spf.80.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"96.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"97.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com",
      1, 0, "127.0.0.2"}, 
        {"bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"postmaster.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"2.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.joe.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"102.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"110.2.0.192.in-addr._spf.42.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"131.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"4.24.236.64.in-addr._spf.80.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"droid.lp._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"joe-2.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"moe-1.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"unknown.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"180.124.210.208.in-addr.arpa",
      12, 0, "80.spf1-test.mailzone.com"}, 
        {"80.spf1-test.mailzone.com.whitelist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.124.210.208.in-addr.arpa",
      12, 0, "pobox-gw.icgroup.com"}, 
        {"pobox-gw.icgroup.com", 1, 0, "208.210.124.1"}, 
        {"pobox-gw.icgroup.com.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com",
      16, 1, (char const   *)((void *)0)}, 
        {"spf.trusted-forwarder.org", 16, 0, "v=spf1 exists:%{ir}.wl.trusted-forwarder.org exists:%{p}.wl.trusted-forwarder.org"}, 
        {"*.spf1-text.mailzone.com",
      255, 1, (char const   *)((void *)0)}, 
        {"cat.com", 16, 4, (char const   *)((void *)0)}, 
        {"bar.com", 16, 4, (char const   *)((void *)0)}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}};
#line 145 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
static struct option long_options___0[19]  = 
#line 145 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
  {      {"file", 1, (int *)0, 'f'}, 
        {"ip", 1, (int *)0, 'i'}, 
        {"sender", 1, (int *)0, 's'}, 
        {"helo", 1, (int *)0, 'h'}, 
        {"rcpt-to", 1, (int *)0, 'r'}, 
        {"debug", 2, (int *)0, 'd'}, 
        {"local", 1, (int *)0, 'l'}, 
        {"trusted", 1, (int *)0, 't'}, 
        {"guess", 1, (int *)0, 'g'}, 
        {"default-explanation", 1, (int *)0, 'e'}, 
        {"max-lookup", 1, (int *)0, 'm'}, 
        {"sanitize", 1, (int *)0, 'c'}, 
        {"name", 1, (int *)0, 'n'}, 
        {"override", 1, (int *)0, 'a'}, 
        {"fallback", 1, (int *)0, 'z'}, 
        {"keep-comments", 0, (int *)0, 'k'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"help", 0, (int *)0, '?'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 171 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
static void unimplemented___0(char const   flag ) 
{ 
  struct option *opt ;
  int i ;

  {
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    opt = & long_options___0[i];
#line 177
    if (! opt->name) {
#line 177
      goto while_break;
    }
#line 178
    if ((int const   )flag == (int const   )opt->val) {
      {
#line 179
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unimplemented option: -%s or -%c\n",
              opt->name, (int const   )flag);
      }
#line 181
      return;
    }
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unimplemented option: -%c\n",
          (int const   )flag);
  }
#line 186
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
static void usage___1(void) 
{ 


  {
  {
#line 192
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:\n\nspfquery [control options | data options] ...\n\nUse the -help option for more information\n");
  }
#line 200
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
static void help___0(void) 
{ 


  {
  {
#line 205
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:\n\nspfquery [control options | data options] ...\n\nValid data options are:\n    -file <filename>           read spf data from a file.  Use \'-\'\n                               to read from stdin.\n\n    -ip <IP address>           The IP address that is sending email\n    -sender <email address>    The email address used as the\n                               envelope-from.  If no username (local\n                               part) is given, \'postmaster\' will be\n                               assumed.\n    -helo <domain name>        The domain name given on the SMTP HELO\n                               command.  This is only needed if the\n                               -sender option is not given.\n    -rcpt-to <email addresses> A comma separated lists of email addresses\n                               that will have email from their secondary\n                               MXes automatically allowed.\n\nThe data options are required.  The -file option conflicts with all\nthe other data options.  The -helo and -rcpt-to are optional.\n\n\nValid control options are:\n    -debug [debug level]       debug level.\n    -local <SPF mechanisms>    Local policy for whitelisting.\n    -trusted <0|1>             Should trusted-forwarder.org be checked?\n    -guess <SPF mechanisms>    Default checks if no SPF record is found.\n    -default-explanation <str> Default explanation string to use.\n    -max-lookup <number>       Maximum number of DNS lookups to allow\n    -sanitize <0|1>            Clean up invalid characters in output?\n    -name <domain name>        The name of the system doing the SPF\n                               checking\n    -override <...>            Override SPF records for domains\n    -fallback <...>            Fallback SPF records for domains\n\n    -keep-comments             Print comments found when reading\n                               from a file.\n    -version                   Print version of spfquery.\n    -help                      Print out these options.\n\nExamples:\n\nspfquery -ip=11.22.33.44 -sender=user@aol.com -helo=spammer.tld\nspfquery -f test_data\necho \"127.0.0.1 myname@mydomain.com helohost.com\" | spfquery -f -\n");
  }
#line 255
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
static void response_print_errors___0(char const   *context , SPF_response_t *spf_response ,
                                      SPF_errcode_t err ) 
{ 
  SPF_error_t *spf_error ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___2 ;
  char tmp___3 ;
  char const   *tmp___5 ;
  char tmp___6 ;
  int tmp___7 ;

  {
  {
#line 265
  printf((char const   */* __restrict  */)"StartError\n");
  }
#line 267
  if ((unsigned long )context != (unsigned long )((void *)0)) {
    {
#line 268
    printf((char const   */* __restrict  */)"Context: %s\n", context);
    }
  }
#line 269
  if ((unsigned int )err != 0U) {
    {
#line 270
    tmp = SPF_strerror(err);
#line 270
    printf((char const   */* __restrict  */)"ErrorCode: (%d) %s\n", (unsigned int )err,
           tmp);
    }
  }
#line 272
  if ((unsigned long )spf_response != (unsigned long )((void *)0)) {
#line 273
    i = 0;
    {
#line 273
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 273
      tmp___7 = SPF_response_messages(spf_response);
      }
#line 273
      if (! (i < tmp___7)) {
#line 273
        goto while_break;
      }
      {
#line 274
      spf_error = SPF_response_message(spf_response, i);
#line 275
      tmp___0 = SPF_error_message(spf_error);
#line 275
      tmp___3 = SPF_error_errorp(spf_error);
      }
#line 275
      if (tmp___3) {
#line 275
        if (! err) {
#line 275
          tmp___2 = "[UNRETURNED] ";
        } else {
#line 275
          tmp___2 = "";
        }
      } else {
#line 275
        tmp___2 = "";
      }
      {
#line 275
      tmp___6 = SPF_error_errorp(spf_error);
      }
#line 275
      if (tmp___6) {
#line 275
        tmp___5 = "Error";
      } else {
#line 275
        tmp___5 = "Warning";
      }
      {
#line 275
      printf((char const   */* __restrict  */)"%s: %s%s\n", tmp___5, tmp___2, tmp___0);
#line 273
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 286
    printf((char const   */* __restrict  */)"libspf2 gave a NULL spf_response\n");
    }
  }
  {
#line 288
  printf((char const   */* __restrict  */)"EndError\n");
  }
#line 289
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfquery/spfquery.c"
static void response_print___0(char const   *context , SPF_response_t *spf_response ) 
{ 
  SPF_result_t tmp ;
  char const   *tmp___0 ;
  SPF_reason_t tmp___1 ;
  char const   *tmp___2 ;
  SPF_errcode_t tmp___3 ;
  char const   *tmp___4 ;
  SPF_errcode_t tmp___5 ;

  {
  {
#line 294
  printf((char const   */* __restrict  */)"--vv--\n");
#line 295
  printf((char const   */* __restrict  */)"Context: %s\n", context);
  }
#line 296
  if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
    {
#line 297
    printf((char const   */* __restrict  */)"NULL RESPONSE!\n");
    }
  } else {
    {
#line 300
    tmp = SPF_response_result(spf_response);
#line 300
    tmp___0 = SPF_strresult(tmp);
#line 300
    printf((char const   */* __restrict  */)"Response result: %s\n", tmp___0);
#line 302
    tmp___1 = SPF_response_reason(spf_response);
#line 302
    tmp___2 = SPF_strreason(tmp___1);
#line 302
    printf((char const   */* __restrict  */)"Response reason: %s\n", tmp___2);
#line 304
    tmp___3 = SPF_response_errcode(spf_response);
#line 304
    tmp___4 = SPF_strerror(tmp___3);
#line 304
    printf((char const   */* __restrict  */)"Response err: %s\n", tmp___4);
#line 306
    tmp___5 = SPF_response_errcode(spf_response);
#line 306
    response_print_errors___0((char const   *)((void *)0), spf_response, tmp___5);
    }
  }
  {
#line 309
  printf((char const   */* __restrict  */)"--^^--\n");
  }
#line 310
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static SPF_dns_rr_t *SPF_dns_null_lookup___0(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_rr_t *tmp ;
  SPF_dns_rr_t *tmp___0 ;

  {
#line 45
  if (spf_dns_server->layer_below) {
    {
#line 46
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 46
    return (tmp);
  }
  {
#line 48
  tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
  }
#line 48
  return (tmp___0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static void SPF_dns_null_free___0(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 54
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c",
                 54, "%s", "spf_dns_server is NULL");
      }
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  free((void *)spf_dns_server);
  }
#line 56
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_explanation___0(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  char *buf ;
  size_t buflen ;
  void *tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 53
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 53, "%s", "spf_response is NULL");
      }
    }
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  spf_request = spf_response->spf_request;
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 55
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 55, "%s", "spf_request is NULL");
      }
    }
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  spf_server___1 = spf_request->spf_server;
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 57
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 57
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 57, "%s", "spf_server is NULL");
      }
    }
#line 57
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  spf_record = spf_response->spf_record_exp;
  {
#line 60
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 60
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 60
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 60, "%s", "spf_record is NULL");
      }
    }
#line 60
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 62
  if (spf_response->explanation) {
    {
#line 63
    free((void *)spf_response->explanation);
    }
  }
  {
#line 64
  spf_response->explanation = (char *)((void *)0);
#line 66
  buflen = (size_t )321;
#line 67
  tmp = malloc(buflen);
#line 67
  buf = (char *)tmp;
  }
#line 68
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 69
    return ((SPF_errcode_t )1);
  }
  {
#line 70
  memset((void *)buf, '\000', buflen);
#line 72
  err = SPF_request_get_exp(spf_server___1, spf_request, spf_response, spf_record,
                            & buf, & buflen);
  }
#line 74
  if ((unsigned int )err != 0U) {
    {
#line 75
    free((void *)buf);
    }
#line 76
    return (err);
  }
#line 79
  spf_response->explanation = buf;
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_smtp_comment___0(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_errcode_t err ;
  char buf[320] ;
  char const   *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 92
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 92, "%s", "spf_response is NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  spf_request = spf_response->spf_request;
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 94, "%s", "spf_request is NULL");
      }
    }
#line 94
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  spf_server___1 = spf_request->spf_server;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 96, "%s", "spf_server is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  if (spf_response->smtp_comment) {
    {
#line 99
    free((void *)spf_response->smtp_comment);
    }
  }
#line 100
  spf_response->smtp_comment = (char *)((void *)0);
  {
#line 107
  if ((unsigned int )spf_response->result == 5U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 1U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 4U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 3U) {
#line 107
    goto case_5;
  }
#line 129
  goto switch_default;
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 109
  err = SPF_i_set_explanation___0(spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
#line 111
    return (err);
  }
  {
#line 113
  memset((void *)(buf), '\000', sizeof(buf));
#line 114
  tmp = SPF_strreason(spf_response->reason);
#line 114
  snprintf((char */* __restrict  */)(buf), (size_t )320, (char const   */* __restrict  */)"%s : Reason: %s",
           spf_response->explanation, tmp);
#line 117
  buf[319] = (char )'\000';
#line 120
  spf_response->smtp_comment = strdup((char const   *)(buf));
  }
#line 121
  if (! spf_response->smtp_comment) {
#line 122
    return ((SPF_errcode_t )1);
  }
#line 124
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 130
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 133
  return ((SPF_errcode_t )0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_header_comment___0(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char *spf_source ;
  size_t len ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  char *sender_dom ;
  char *p ;
  char *p_end ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 153
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 153, "%s", "spf_response is NULL");
      }
    }
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  spf_request = spf_response->spf_request;
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 155
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 155, "%s", "spf_request is NULL");
      }
    }
#line 155
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 156
  spf_server___1 = spf_request->spf_server;
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 157
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 157, "%s", "spf_server is NULL");
      }
    }
#line 157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 159
  if (spf_response->header_comment) {
    {
#line 160
    free((void *)spf_response->header_comment);
    }
  }
#line 161
  spf_response->header_comment = (char *)((void *)0);
#line 164
  sender_dom = spf_request->env_from_dp;
#line 165
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
#line 166
    sender_dom = spf_request->helo_dom;
  }
#line 168
  if ((unsigned int )spf_response->reason == 3U) {
    {
#line 169
    spf_source = strdup("local policy");
    }
  } else
#line 171
  if ((unsigned int )spf_response->reason == 6U) {
#line 172
    if ((unsigned long )spf_request->rcpt_to_dom == (unsigned long )((void *)0)) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    } else
#line 172
    if ((int )*(spf_request->rcpt_to_dom + 0) == 0) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    }
    {
#line 175
    spf_source = strdup((char const   *)spf_request->rcpt_to_dom);
    }
  } else
#line 177
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
    {
#line 178
    spf_source = strdup("unknown domain");
    }
  } else {
    {
#line 181
    tmp = strlen((char const   *)sender_dom);
#line 181
    len = tmp + sizeof("domain of ");
#line 182
    tmp___0 = malloc(len);
#line 182
    spf_source = (char *)tmp___0;
    }
#line 183
    if (spf_source) {
      {
#line 184
      snprintf((char */* __restrict  */)spf_source, len, (char const   */* __restrict  */)"domain of %s",
               sender_dom);
      }
    }
  }
#line 187
  if ((unsigned long )spf_source == (unsigned long )((void *)0)) {
#line 188
    return ((SPF_errcode_t )10);
  }
#line 190
  ip = (char const   *)((void *)0);
#line 191
  if (spf_request->client_ver == 2) {
    {
#line 192
    ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                   (socklen_t )sizeof(ip4_buf));
    }
  } else
#line 195
  if (spf_request->client_ver == 10) {
    {
#line 196
    ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                   (socklen_t )sizeof(ip6_buf));
    }
  }
#line 199
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 200
    ip = "(unknown ip address)";
  }
  {
#line 202
  tmp___1 = SPF_request_get_rec_dom(spf_request);
#line 202
  tmp___2 = strlen(tmp___1);
#line 202
  tmp___3 = strlen((char const   *)spf_source);
#line 202
  tmp___4 = strlen(ip);
#line 202
  len = ((tmp___2 + tmp___3) + tmp___4) + 80UL;
#line 203
  tmp___5 = malloc(len);
#line 203
  buf = (char *)tmp___5;
  }
#line 204
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 205
    free((void *)spf_source);
    }
#line 206
    return ((SPF_errcode_t )10);
  }
  {
#line 209
  p = buf;
#line 210
  p_end = p + len;
#line 213
  tmp___6 = SPF_request_get_rec_dom(spf_request);
#line 213
  tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s: ",
                     tmp___6);
#line 213
  p += tmp___7;
  }
  {
#line 217
  if ((unsigned int )spf_response->result == 2U) {
#line 217
    goto case_2;
  }
#line 228
  if ((unsigned int )spf_response->result == 3U) {
#line 228
    goto case_3;
  }
#line 233
  if ((unsigned int )spf_response->result == 4U) {
#line 233
    goto case_4;
  }
#line 238
  if ((unsigned int )spf_response->result == 7U) {
#line 238
    goto case_7;
  }
#line 243
  if ((unsigned int )spf_response->result == 1U) {
#line 243
    goto case_1;
  }
#line 247
  if ((unsigned int )spf_response->result == 5U) {
#line 247
    goto case_5;
  }
#line 252
  if ((unsigned int )spf_response->result == 6U) {
#line 252
    goto case_6;
  }
#line 258
  goto switch_default;
  case_2: /* CIL Label */ 
#line 218
  if ((unsigned int )spf_response->reason == 2U) {
    {
#line 219
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"localhost is always allowed.");
    }
  } else
#line 220
  if ((unsigned int )spf_response->reason == 6U) {
    {
#line 221
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"message received from %s which is an MX secondary for %s.",
             ip, spf_source);
    }
  } else {
    {
#line 224
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s designates %s as permitted sender",
             spf_source, ip);
    }
  }
#line 226
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 229
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 231
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 234
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"transitioning %s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 236
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 239
  tmp___8 = SPF_strerror(spf_response->err);
#line 239
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error in processing during lookup of %s: %s",
           spf_source, tmp___8);
  }
#line 241
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 244
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s is neither permitted nor denied by %s",
           ip, spf_source);
  }
#line 246
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 248
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not provide an SPF record",
           spf_source);
  }
#line 250
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 253
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"encountered temporary error during SPF processing of %s",
           spf_source);
  }
#line 255
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 259
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error: unknown SPF result %d encountered while checking %s for %s",
           (unsigned int )spf_response->result, ip, spf_source);
  }
#line 261
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 264
  if (spf_source) {
    {
#line 265
    free((void *)spf_source);
    }
  }
  {
#line 267
  spf_response->header_comment = SPF_sanitize(spf_server___1, buf);
  }
#line 269
  return ((SPF_errcode_t )0);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_received_spf___0(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  size_t buflen ;
  char *buf_value ;
  char *p ;
  char *p_end ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 282
  buflen = (size_t )480;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 287
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 287, "%s", "spf_response is NULL");
      }
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  spf_request = spf_response->spf_request;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 289
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 289, "%s", "spf_request is NULL");
      }
    }
#line 289
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  spf_server___1 = spf_request->spf_server;
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 291
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 291
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 291, "%s", "spf_server is NULL");
      }
    }
#line 291
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 293
  if (spf_response->received_spf) {
    {
#line 294
    free((void *)spf_response->received_spf);
    }
  }
  {
#line 295
  spf_response->received_spf = (char *)((void *)0);
#line 297
  tmp = malloc(buflen);
#line 297
  buf = (char *)tmp;
  }
#line 298
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 299
    return ((SPF_errcode_t )10);
  }
  {
#line 301
  p = buf;
#line 302
  p_end = p + buflen;
#line 306
  tmp___0 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"Received-SPF: ");
#line 306
  p += tmp___0;
#line 307
  buf_value = p;
  }
  {
#line 309
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 310
    tmp___1 = SPF_strresult(spf_response->result);
#line 310
    tmp___2 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s (%s)",
                       tmp___1, spf_response->header_comment);
#line 310
    p += tmp___2;
    }
#line 313
    if (p_end - p <= 0L) {
#line 313
      goto while_break___2;
    }
#line 318
    ip = (char const   *)((void *)0);
#line 319
    if (spf_request->client_ver == 2) {
      {
#line 320
      ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                     (socklen_t )sizeof(ip4_buf));
      }
    } else
#line 323
    if (spf_request->client_ver == 10) {
      {
#line 324
      ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                     (socklen_t )sizeof(ip6_buf));
      }
    }
#line 328
    if ((unsigned long )ip != (unsigned long )((void *)0)) {
      {
#line 329
      tmp___3 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" client-ip=%s;",
                         ip);
#line 329
      p += tmp___3;
      }
#line 330
      if (p_end - p <= 0L) {
#line 330
        goto while_break___2;
      }
    }
#line 335
    if ((unsigned long )spf_request->env_from != (unsigned long )((void *)0)) {
      {
#line 336
      tmp___4 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" envelope-from=%s;",
                         spf_request->env_from);
#line 336
      p += tmp___4;
      }
#line 337
      if (p_end - p <= 0L) {
#line 337
        goto while_break___2;
      }
    }
#line 342
    if ((unsigned long )spf_request->helo_dom != (unsigned long )((void *)0)) {
      {
#line 343
      tmp___5 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" helo=%s;",
                         spf_request->helo_dom);
#line 343
      p += tmp___5;
      }
#line 344
      if (p_end - p <= 0L) {
#line 344
        goto while_break___2;
      }
    }
#line 309
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 366
  spf_response->received_spf = SPF_sanitize(spf_server___1, buf);
#line 367
  spf_response->received_spf_value = buf_value;
  }
#line 369
  return ((SPF_errcode_t )0);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_mech_cidr___0(SPF_request_t *spf_request , SPF_mech_t *mech ) 
{ 
  SPF_data_t *data ;
  SPF_data_t *tmp ;

  {
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if ((unsigned long )mech == (unsigned long )((void *)0)) {
      {
#line 428
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 428, "%s", "mech is NULL");
      }
    }
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  if ((int )mech->mech_type == 6) {
#line 433
    goto case_6;
  }
#line 433
  if ((int )mech->mech_type == 5) {
#line 433
    goto case_6;
  }
#line 438
  if ((int )mech->mech_type == 2) {
#line 438
    goto case_2;
  }
#line 438
  if ((int )mech->mech_type == 1) {
#line 438
    goto case_2;
  }
#line 430
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 434
  return ((int )mech->mech_len);
#line 435
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 439
  data = SPF_mech_data(mech);
#line 441
  tmp = SPF_mech_end_data(mech);
  }
#line 441
  if ((unsigned long )data < (unsigned long )tmp) {
#line 441
    if ((int )data->dc.parm_type == 11) {
#line 444
      if (spf_request->client_ver == 2) {
#line 445
        return ((int )data->dc.ipv4);
      } else
#line 446
      if (spf_request->client_ver == 10) {
#line 447
        return ((int )data->dc.ipv6);
      }
    }
  }
#line 449
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 452
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip4___0(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in_addr ipv4 ) 
{ 
  char src_ip4_buf[16] ;
  char dst_ip4_buf[16] ;
  char mask_ip4_buf[16] ;
  struct in_addr src_ipv4 ;
  int cidr ;
  int mask ;
  uint32_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 471
  if (spf_request->client_ver != 2) {
#line 472
    return (0);
  }
  {
#line 474
  src_ipv4 = spf_request->ipv4;
#line 476
  cidr = SPF_i_mech_cidr___0(spf_request, mech);
  }
#line 477
  if (cidr == 0) {
#line 478
    cidr = 32;
  }
  {
#line 479
  mask = (int )(4294967295U << (32 - cidr));
#line 480
  tmp = htonl((uint32_t )mask);
#line 480
  mask = (int )tmp;
  }
#line 482
  if (spf_server___1->debug) {
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 483
      tmp___0 = inet_ntop(2, (void const   */* __restrict  */)(& src_ipv4.s_addr),
                          (char */* __restrict  */)(src_ip4_buf), (socklen_t )sizeof(src_ip4_buf));
      }
#line 483
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 483
        snprintf((char */* __restrict  */)(src_ip4_buf), sizeof(src_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 483
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 485
      tmp___1 = inet_ntop(2, (void const   */* __restrict  */)(& ipv4.s_addr), (char */* __restrict  */)(dst_ip4_buf),
                          (socklen_t )sizeof(dst_ip4_buf));
      }
#line 485
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 485
        snprintf((char */* __restrict  */)(dst_ip4_buf), sizeof(dst_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 487
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 487
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& mask), (char */* __restrict  */)(mask_ip4_buf),
                          (socklen_t )sizeof(mask_ip4_buf));
      }
#line 487
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
#line 487
        snprintf((char */* __restrict  */)(mask_ip4_buf), sizeof(mask_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 487
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 489
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               491, "ip_match:  %s == %s  (/%d %s):  %d", src_ip4_buf, dst_ip4_buf,
               cidr, mask_ip4_buf, (src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
    }
  }
#line 494
  return ((src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip6___0(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in6_addr ipv6 ) 
{ 
  char src_ip6_buf[46] ;
  char dst_ip6_buf[46] ;
  struct in6_addr src_ipv6 ;
  int cidr ;
  int cidr_save ;
  int mask ;
  int i ;
  int match ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 512
  if (spf_request->client_ver != 10) {
#line 513
    return (0);
  }
  {
#line 515
  src_ipv6 = spf_request->ipv6;
#line 517
  cidr = SPF_i_mech_cidr___0(spf_request, mech);
  }
#line 518
  if (cidr == 0) {
#line 519
    cidr = 128;
  }
#line 520
  cidr_save = cidr;
#line 522
  match = 1;
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if ((long )i < (long )(sizeof(ipv6.__in6_u.__u6_addr8) / sizeof(ipv6.__in6_u.__u6_addr8[0]))) {
#line 523
      if (! match) {
#line 523
        goto while_break;
      }
    } else {
#line 523
      goto while_break;
    }
#line 525
    if (cidr > 8) {
#line 526
      mask = 255;
    } else
#line 527
    if (cidr > 0) {
#line 528
      mask = (255 << (8 - cidr)) & 255;
    } else {
#line 530
      goto while_break;
    }
#line 531
    cidr -= 8;
#line 533
    match = ((int )src_ipv6.__in6_u.__u6_addr8[i] & mask) == ((int )ipv6.__in6_u.__u6_addr8[i] & mask);
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (spf_server___1->debug) {
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 537
      tmp = inet_ntop(10, (void const   */* __restrict  */)(& src_ipv6.__in6_u.__u6_addr8),
                      (char */* __restrict  */)(src_ip6_buf), (socklen_t )sizeof(src_ip6_buf));
      }
#line 537
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 537
        snprintf((char */* __restrict  */)(src_ip6_buf), sizeof(src_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 537
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 539
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 539
      tmp___0 = inet_ntop(10, (void const   */* __restrict  */)(& ipv6.__in6_u.__u6_addr8),
                          (char */* __restrict  */)(dst_ip6_buf), (socklen_t )sizeof(dst_ip6_buf));
      }
#line 539
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 539
        snprintf((char */* __restrict  */)(dst_ip6_buf), sizeof(dst_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 539
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 541
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               542, "ip_match:  %s == %s  (/%d):  %d", src_ip6_buf, dst_ip6_buf, cidr_save,
               match);
    }
  }
#line 545
  return (match);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_domain___0(SPF_server_t *spf_server___1 , char const   *hostname ,
                                  char const   *domain ) 
{ 
  char const   *hp ;
  size_t hlen ;
  size_t dlen ;
  int tmp ;
  int tmp___0 ;

  {
#line 556
  if (spf_server___1->debug) {
    {
#line 557
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               557, "%s ?=? %s", hostname, domain);
    }
  }
  {
#line 559
  hlen = strlen(hostname);
#line 560
  dlen = strlen(domain);
  }
#line 563
  if (dlen > hlen) {
#line 564
    return (0);
  }
#line 567
  if (dlen == hlen) {
    {
#line 568
    tmp = strcasecmp(hostname, domain);
    }
#line 568
    return (tmp == 0);
  }
#line 571
  hp = hostname + (hlen - dlen);
#line 573
  if ((int const   )*(hp - 1) != 46) {
#line 574
    return (0);
  }
  {
#line 576
  tmp___0 = strcasecmp(hp, domain);
  }
#line 576
  return (tmp___0 == 0);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   spf_mechtypes___0[10]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
  {      {(unsigned char)0, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)1, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)2, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)3, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )0}, 
        {(unsigned char)4, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)5, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)6, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)7, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)8, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)9, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}};
#line 94 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   *SPF_mechtype_find___0(int mech_type ) 
{ 
  size_t i ;

  {
#line 98
  i = (size_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < sizeof(spf_mechtypes___0) / sizeof(spf_mechtypes___0[0]))) {
#line 98
      goto while_break;
    }
#line 99
    if ((int const   )spf_mechtypes___0[i].mech_type == (int const   )mech_type) {
#line 100
      return (& spf_mechtypes___0[i]);
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((SPF_mechtype_t const   *)((void *)0));
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static int ( __attribute__((__warn_unused_result__)) SPF_c_ensure_capacity___0)(void **datap ,
                                                                                size_t *sizep ,
                                                                                size_t length ) 
{ 
  size_t size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 109
  size = *sizep;
#line 110
  if (length > size) {
#line 111
    size = length + length / 4UL;
  }
#line 112
  if (size > *sizep) {
    {
#line 113
    tmp___0 = realloc(*datap, size);
#line 113
    tmp = tmp___0;
    }
#line 114
    if (! tmp) {
#line 115
      return (-1);
    }
#line 117
    *datap = tmp;
#line 118
    *sizep = size;
  }
#line 120
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip6___0(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 144
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 144
  mask = (int )tmp;
  }
#line 146
  if (mask > 128) {
    {
#line 147
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (>128)");
    }
#line 147
    return (tmp___0);
  } else
#line 151
  if (mask == 0) {
    {
#line 152
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (=0)");
    }
#line 152
    return (tmp___1);
  } else
#line 156
  if (mask == 128) {
#line 157
    mask = 0;
  }
#line 160
  *maskp = (unsigned char )mask;
#line 162
  return ((SPF_errcode_t )0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip4___0(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 186
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 186
  mask = (int )tmp;
  }
#line 188
  if (mask > 32) {
    {
#line 189
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (>32)");
    }
#line 189
    return (tmp___0);
  } else
#line 193
  if (mask == 0) {
    {
#line 194
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (=0)");
    }
#line 194
    return (tmp___1);
  } else
#line 198
  if (mask == 32) {
#line 199
    mask = 0;
  }
#line 202
  *maskp = (unsigned char )mask;
#line 204
  return ((SPF_errcode_t )0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr___0(SPF_response_t *spf_response , SPF_data_cidr_t *data ,
                                          char const   *src , size_t *src_len ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 220
  memset((void *)data, 0, sizeof(SPF_data_cidr_t ));
#line 221
  data->parm_type = (unsigned char)11;
#line 227
  idx = *src_len - 1UL;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (idx > 0UL) {
      {
#line 228
      tmp = __ctype_b_loc();
      }
#line 228
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 228
        goto while_break;
      }
    } else {
#line 228
      goto while_break;
    }
#line 229
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (idx < *src_len - 1UL) {
#line 236
    if ((int const   )*(src + idx) == 47) {
#line 237
      if (idx > 0UL) {
#line 237
        if ((int const   )*(src + (idx - 1UL)) == 47) {
          {
#line 239
          err = SPF_c_parse_cidr_ip6___0(spf_response, & data->ipv6, src + idx);
          }
#line 240
          if (err) {
#line 241
            return (err);
          }
#line 243
          *src_len = idx - 1UL;
#line 244
          idx = *src_len - 1UL;
          {
#line 245
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 245
            if (idx > 0UL) {
              {
#line 245
              tmp___0 = __ctype_b_loc();
              }
#line 245
              if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 245
                goto while_break___0;
              }
            } else {
#line 245
              goto while_break___0;
            }
#line 246
            idx --;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 249
          if (idx < *src_len - 1UL) {
#line 249
            if ((int const   )*(src + idx) == 47) {
              {
#line 253
              err = SPF_c_parse_cidr_ip4___0(spf_response, & data->ipv4, src + idx);
              }
#line 254
              if (err) {
#line 255
                return (err);
              }
#line 256
              *src_len = idx;
            }
          }
        } else {
#line 237
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 261
        err = SPF_c_parse_cidr_ip4___0(spf_response, & data->ipv4, src + idx);
        }
#line 262
        if (err) {
#line 263
          return (err);
        }
#line 264
        *src_len = idx;
      }
    }
  }
#line 268
  return ((SPF_errcode_t )0);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_var___0(SPF_response_t *spf_response , SPF_data_var_t *data ,
                                         char const   *src , int is_mod ) 
{ 
  char const   *token ;
  char const   *p ;
  char c ;
  int val ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;
  SPF_errcode_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  SPF_errcode_t tmp___6 ;
  SPF_errcode_t tmp___7 ;

  {
  {
#line 280
  memset((void *)data, 0, sizeof(SPF_data_var_t ));
#line 282
  p = src;
#line 285
  c = (char )*p;
#line 286
  tmp___0 = __ctype_b_loc();
  }
#line 286
  if ((int const   )*(*tmp___0 + (int )((unsigned char )c)) & 256) {
    {
#line 288
    data->url_encode = (unsigned short)1;
#line 289
    tmp = tolower((int )c);
#line 289
    c = (char )tmp;
    }
  } else {
#line 292
    data->url_encode = (unsigned short)0;
  }
  {
#line 302
  if ((int )c == 108) {
#line 302
    goto case_108;
  }
#line 306
  if ((int )c == 115) {
#line 306
    goto case_115;
  }
#line 310
  if ((int )c == 111) {
#line 310
    goto case_111;
  }
#line 314
  if ((int )c == 100) {
#line 314
    goto case_100;
  }
#line 318
  if ((int )c == 105) {
#line 318
    goto case_105;
  }
#line 322
  if ((int )c == 99) {
#line 322
    goto case_99;
  }
#line 327
  if ((int )c == 116) {
#line 327
    goto case_116;
  }
#line 332
  if ((int )c == 112) {
#line 332
    goto case_112;
  }
#line 336
  if ((int )c == 118) {
#line 336
    goto case_118;
  }
#line 340
  if ((int )c == 104) {
#line 340
    goto case_104;
  }
#line 344
  if ((int )c == 114) {
#line 344
    goto case_114;
  }
#line 349
  goto switch_default;
  case_108: /* CIL Label */ 
#line 303
  data->parm_type = (unsigned char)0;
#line 304
  goto switch_break;
  case_115: /* CIL Label */ 
#line 307
  data->parm_type = (unsigned char)1;
#line 308
  goto switch_break;
  case_111: /* CIL Label */ 
#line 311
  data->parm_type = (unsigned char)2;
#line 312
  goto switch_break;
  case_100: /* CIL Label */ 
#line 315
  data->parm_type = (unsigned char)3;
#line 316
  goto switch_break;
  case_105: /* CIL Label */ 
#line 319
  data->parm_type = (unsigned char)4;
#line 320
  goto switch_break;
  case_99: /* CIL Label */ 
#line 323
  if (! is_mod) {
    {
#line 323
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 323
    return (tmp___1);
  }
#line 324
  data->parm_type = (unsigned char)5;
#line 325
  goto switch_break;
  case_116: /* CIL Label */ 
#line 328
  if (! is_mod) {
    {
#line 328
    tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 328
    return (tmp___2);
  }
#line 329
  data->parm_type = (unsigned char)6;
#line 330
  goto switch_break;
  case_112: /* CIL Label */ 
#line 333
  data->parm_type = (unsigned char)7;
#line 334
  goto switch_break;
  case_118: /* CIL Label */ 
#line 337
  data->parm_type = (unsigned char)8;
#line 338
  goto switch_break;
  case_104: /* CIL Label */ 
#line 341
  data->parm_type = (unsigned char)9;
#line 342
  goto switch_break;
  case_114: /* CIL Label */ 
#line 345
  if (! is_mod) {
    {
#line 345
    tmp___3 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 345
    return (tmp___3);
  }
#line 346
  data->parm_type = (unsigned char)10;
#line 347
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 350
  tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                       p, "Unknown variable \'%c\'", (int )c);
  }
#line 350
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
#line 354
  p ++;
#line 355
  token = p;
#line 358
  val = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 359
    tmp___5 = __ctype_b_loc();
    }
#line 359
    if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*p)) & 2048)) {
#line 359
      goto while_break;
    }
#line 361
    val *= 10;
#line 362
    val += (int )((int const   )*p - 48);
#line 363
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (val > 128) {
    {
#line 366
    tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                         token, "Subdomain truncation depth too large");
    }
#line 366
    return (tmp___6);
  } else
#line 365
  if (val <= 0) {
#line 365
    if ((unsigned long )p != (unsigned long )token) {
      {
#line 366
      tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                           token, "Subdomain truncation depth too large");
      }
#line 366
      return (tmp___6);
    }
  }
#line 369
  data->num_rhs = (unsigned char )val;
#line 370
  token = p;
#line 373
  if ((int const   )*p == 114) {
#line 375
    data->rev = (unsigned short)1;
#line 376
    p ++;
  } else {
#line 379
    data->rev = (unsigned short)0;
  }
#line 380
  token = p;
#line 384
  data->delim_dot = (unsigned short)0;
#line 385
  data->delim_dash = (unsigned short)0;
#line 386
  data->delim_plus = (unsigned short)0;
#line 387
  data->delim_equal = (unsigned short)0;
#line 388
  data->delim_bar = (unsigned short)0;
#line 389
  data->delim_under = (unsigned short)0;
#line 392
  if ((int const   )*p == 125) {
#line 393
    data->delim_dot = (unsigned short)1;
  }
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! ((int const   )*p != 125)) {
#line 396
      goto while_break___0;
    }
#line 398
    token = p;
    {
#line 401
    if ((int const   )*p == 46) {
#line 401
      goto case_46;
    }
#line 405
    if ((int const   )*p == 45) {
#line 405
      goto case_45;
    }
#line 409
    if ((int const   )*p == 43) {
#line 409
      goto case_43;
    }
#line 413
    if ((int const   )*p == 61) {
#line 413
      goto case_61;
    }
#line 417
    if ((int const   )*p == 124) {
#line 417
      goto case_124;
    }
#line 421
    if ((int const   )*p == 95) {
#line 421
      goto case_95;
    }
#line 425
    goto switch_default___0;
    case_46: /* CIL Label */ 
#line 402
    data->delim_dot = (unsigned short)1;
#line 403
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 406
    data->delim_dash = (unsigned short)1;
#line 407
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 410
    data->delim_plus = (unsigned short)1;
#line 411
    goto switch_break___0;
    case_61: /* CIL Label */ 
#line 414
    data->delim_equal = (unsigned short)1;
#line 415
    goto switch_break___0;
    case_124: /* CIL Label */ 
#line 418
    data->delim_bar = (unsigned short)1;
#line 419
    goto switch_break___0;
    case_95: /* CIL Label */ 
#line 422
    data->delim_under = (unsigned short)1;
#line 423
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 426
    tmp___7 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )14, (char const   *)((void *)0),
                                         p, "Invalid delimiter \'%c\'", (int const   )*p);
    }
#line 426
    return (tmp___7);
    switch_break___0: /* CIL Label */ ;
    }
#line 430
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 432
  p ++;
#line 433
  token = p;
#line 436
  return ((SPF_errcode_t )0);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_macro___0(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                           SPF_data_t *data , size_t *data_used ,
                                           size_t data_avail , char const   *src ,
                                           size_t src_len , SPF_errcode_t big_err ,
                                           int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  size_t len ;
  char *dst ;
  size_t ds_avail ;
  size_t ds_len ;
  SPF_errcode_t tmp ;
  SPF_errcode_t tmp___0 ;
  char *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  char *tmp___3 ;
  SPF_errcode_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  SPF_errcode_t tmp___8 ;
  char *tmp___9 ;
  SPF_errcode_t tmp___10 ;
  SPF_errcode_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  SPF_errcode_t tmp___15 ;
  SPF_errcode_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  SPF_errcode_t tmp___19 ;
  SPF_errcode_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
#line 522
  if (spf_server___1->debug) {
    {
#line 523
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               523, "Parsing macro starting at %s", src);
    }
  }
#line 534
  idx = (size_t )0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 538
    data->ds.parm_type = (unsigned char)12;
#line 538
    data->ds.len = (unsigned char)0;
#line 538
    data->ds.__unused0 = (unsigned char)186;
#line 538
    data->ds.__unused1 = (unsigned char)190;
#line 538
    dst = SPF_data_str(data);
#line 538
    ds_avail = data_avail - *data_used;
#line 538
    ds_len = (size_t )0;
    }
#line 538
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 541
    if (! (idx < src_len)) {
#line 541
      goto while_break___0;
    }
#line 542
    if (spf_server___1->debug > 3) {
      {
#line 543
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 543, "Current data is at %p", data);
      }
    }
    {
#line 546
    len = strcspn(src + idx, " %");
    }
#line 547
    if (len > 0UL) {
#line 549
      if (idx + len > src_len) {
#line 550
        len = src_len - idx;
      }
#line 551
      if (spf_server___1->debug > 3) {
        {
#line 552
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                   554, "Adding string literal (%lu): \'%*.*s\'", len, (int )len,
                   (int )len, src + idx);
        }
      }
      {
#line 556
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 556
        if (ds_len + len > ds_avail) {
          {
#line 556
          tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                           src, "String literal fragment too long (%d chars, %d max)",
                                           ds_len, ds_avail);
          }
#line 556
          return (tmp);
        }
#line 556
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 557
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(src + idx),
             len);
#line 558
      ds_len += len;
#line 559
      dst += len;
#line 560
      idx += len;
      }
    }
#line 568
    if (idx == src_len) {
#line 569
      goto while_break___0;
    }
#line 576
    idx ++;
    {
#line 578
    if ((int const   )*(src + idx) == 37) {
#line 578
      goto case_37;
    }
#line 587
    if ((int const   )*(src + idx) == 95) {
#line 587
      goto case_95;
    }
#line 596
    if ((int const   )*(src + idx) == 45) {
#line 596
      goto case_45;
    }
#line 617
    if ((int const   )*(src + idx) == 123) {
#line 617
      goto case_123;
    }
#line 605
    goto switch_default;
    case_37: /* CIL Label */ 
#line 579
    if (spf_server___1->debug > 3) {
      {
#line 580
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 580, "Adding literal %%");
      }
    }
    {
#line 581
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 581
      if (ds_len + 1UL > ds_avail) {
        {
#line 581
        tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 581
        return (tmp___0);
      }
#line 581
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 582
    tmp___1 = dst;
#line 582
    dst ++;
#line 582
    *tmp___1 = (char )'%';
#line 583
    ds_len ++;
#line 584
    idx ++;
#line 585
    goto switch_break;
    case_95: /* CIL Label */ 
#line 588
    if (spf_server___1->debug > 3) {
      {
#line 589
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 589, "Adding literal space");
      }
    }
    {
#line 590
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 590
      if (ds_len + 1UL > ds_avail) {
        {
#line 590
        tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 590
        return (tmp___2);
      }
#line 590
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 591
    tmp___3 = dst;
#line 591
    dst ++;
#line 591
    *tmp___3 = (char )' ';
#line 592
    ds_len ++;
#line 593
    idx ++;
#line 594
    goto switch_break;
    case_45: /* CIL Label */ 
#line 597
    if (spf_server___1->debug > 3) {
      {
#line 598
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 598, "Adding escaped space");
      }
    }
    {
#line 599
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 599
      if (ds_len + 3UL > ds_avail) {
        {
#line 599
        tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 599
        return (tmp___4);
      }
#line 599
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 600
    tmp___5 = dst;
#line 600
    dst ++;
#line 600
    *tmp___5 = (char )'%';
#line 600
    tmp___6 = dst;
#line 600
    dst ++;
#line 600
    *tmp___6 = (char )'2';
#line 600
    tmp___7 = dst;
#line 600
    dst ++;
#line 600
    *tmp___7 = (char )'0';
#line 601
    ds_len += 3UL;
#line 602
    idx ++;
#line 603
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 606
    if (spf_server___1->debug > 3) {
      {
#line 607
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 608, "Adding illegal %%-follower \'%c\' at %d", (int const   )*(src + idx),
                 idx);
      }
    }
    {
#line 612
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 612
      if (ds_len + 1UL > ds_avail) {
        {
#line 612
        tmp___8 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 612
        return (tmp___8);
      }
#line 612
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 613
    tmp___9 = dst;
#line 613
    dst ++;
#line 613
    *tmp___9 = (char )'%';
#line 614
    ds_len ++;
#line 615
    goto switch_break;
    case_123: /* CIL Label */ 
    {
#line 618
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 618
      if (ds_len > 0UL) {
#line 618
        if (ds_len > 255UL) {
          {
#line 618
          tmp___10 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15,
                                                (char const   *)((void *)0), src,
                                                "String literal too long (%d chars, %d max)",
                                                ds_len, 255);
          }
#line 618
          return (tmp___10);
        }
#line 618
        data->ds.len = (unsigned char )ds_len;
#line 618
        len = sizeof(*data) + ds_len;
        {
#line 618
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 618
          tmp___12 = _align_sz(len);
          }
#line 618
          if (*data_used + tmp___12 > data_avail) {
            {
#line 618
            tmp___11 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                  src, "SPF domainspec too long (%d chars, %d max)",
                                                  *data_used + len, data_avail);
            }
#line 618
            return (tmp___11);
          }
          {
#line 618
          tmp___13 = _align_sz(len);
#line 618
          *data_used += tmp___13;
          }
#line 618
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 618
        data = SPF_data_next(data);
#line 618
        ds_len = (size_t )0;
        }
      }
#line 618
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 619
    if (spf_server___1->debug > 3) {
      {
#line 620
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 620, "Adding macro, data is at %p", data);
      }
    }
    {
#line 623
    idx ++;
#line 624
    err = SPF_c_parse_var___0(spf_response, & data->dv, src + idx, is_mod);
    }
#line 625
    if ((unsigned int )err != 0U) {
#line 626
      return (err);
    }
    {
#line 627
    tmp___14 = strcspn(src + idx, "} ");
#line 627
    idx += tmp___14;
    }
#line 628
    if ((int const   )*(src + idx) == 125) {
#line 629
      idx ++;
    } else
#line 630
    if ((int const   )*(src + idx) == 32) {
      {
#line 631
      tmp___15 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, src,
                                            src + idx, "Unterminated variable?");
      }
#line 631
      return (tmp___15);
    }
    {
#line 637
    len = SPF_data_len(data);
    }
    {
#line 638
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 638
      tmp___17 = _align_sz(len);
      }
#line 638
      if (*data_used + tmp___17 > data_avail) {
        {
#line 638
        tmp___16 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                              src, "SPF domainspec too long (%d chars, %d max)",
                                              *data_used + len, data_avail);
        }
#line 638
        return (tmp___16);
      }
      {
#line 638
      tmp___18 = _align_sz(len);
#line 638
      *data_used += tmp___18;
      }
#line 638
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 639
    data = SPF_data_next(data);
    }
#line 640
    if (spf_server___1->debug > 3) {
      {
#line 641
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 641, "Next data is at %p", data);
      }
    }
    {
#line 643
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 643
      data->ds.parm_type = (unsigned char)12;
#line 643
      data->ds.len = (unsigned char)0;
#line 643
      data->ds.__unused0 = (unsigned char)186;
#line 643
      data->ds.__unused1 = (unsigned char)190;
#line 643
      dst = SPF_data_str(data);
#line 643
      ds_avail = data_avail - *data_used;
#line 643
      ds_len = (size_t )0;
      }
#line 643
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 649
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 649
    if (ds_len > 0UL) {
#line 649
      if (ds_len > 255UL) {
        {
#line 649
        tmp___19 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                              src, "String literal too long (%d chars, %d max)",
                                              ds_len, 255);
        }
#line 649
        return (tmp___19);
      }
#line 649
      data->ds.len = (unsigned char )ds_len;
#line 649
      len = sizeof(*data) + ds_len;
      {
#line 649
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 649
        tmp___21 = _align_sz(len);
        }
#line 649
        if (*data_used + tmp___21 > data_avail) {
          {
#line 649
          tmp___20 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                src, "SPF domainspec too long (%d chars, %d max)",
                                                *data_used + len, data_avail);
          }
#line 649
          return (tmp___20);
        }
        {
#line 649
        tmp___22 = _align_sz(len);
#line 649
        *data_used += tmp___22;
        }
#line 649
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 649
      data = SPF_data_next(data);
#line 649
      ds_len = (size_t )0;
      }
    }
#line 649
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 651
  return ((SPF_errcode_t )0);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_domainspec___0(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                                SPF_data_t *data , size_t *data_used ,
                                                size_t data_avail , char const   *src ,
                                                size_t src_len , SPF_errcode_t big_err ,
                                                SPF_cidr_t cidr_ok , int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  SPF_errcode_t tmp___6 ;

  {
#line 682
  if (spf_server___1->debug) {
#line 683
    if ((unsigned int )cidr_ok == 1U) {
#line 683
      tmp___1 = "optional";
    } else {
#line 683
      if ((unsigned int )cidr_ok == 2U) {
#line 683
        tmp___0 = "only";
      } else {
#line 683
        if ((unsigned int )cidr_ok == 0U) {
#line 683
          tmp = "forbidden";
        } else {
#line 683
          tmp = "ERROR!";
        }
#line 683
        tmp___0 = tmp;
      }
#line 683
      tmp___1 = tmp___0;
    }
    {
#line 683
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               689, "Parsing domainspec starting at %s, cidr is %s", src, tmp___1);
    }
  }
#line 694
  if ((unsigned int )cidr_ok == 1U) {
#line 694
    goto _L___0;
  } else
#line 694
  if ((unsigned int )cidr_ok == 2U) {
    _L___0: /* CIL Label */ 
    {
#line 695
    err = SPF_c_parse_cidr___0(spf_response, & data->dc, src, & src_len);
    }
#line 696
    if ((unsigned int )err != 0U) {
#line 697
      return (err);
    }
#line 698
    if ((int )data->dc.ipv4 != 0) {
#line 698
      goto _L;
    } else
#line 698
    if ((int )data->dc.ipv6 != 0) {
      _L: /* CIL Label */ 
      {
#line 699
      len = SPF_data_len(data);
      }
      {
#line 700
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 700
        tmp___3 = _align_sz(len);
        }
#line 700
        if (*data_used + tmp___3 > data_avail) {
          {
#line 700
          tmp___2 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                               src, "SPF domainspec too long (%d chars, %d max)",
                                               *data_used + len, data_avail);
          }
#line 700
          return (tmp___2);
        }
        {
#line 700
        tmp___4 = _align_sz(len);
#line 700
        *data_used += tmp___4;
        }
#line 700
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 701
      data = SPF_data_next(data);
      }
    }
#line 704
    if ((unsigned int )cidr_ok == 2U) {
#line 704
      if (src_len > 0UL) {
        {
#line 708
        tmp___5 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                             src, "Invalid CIDR after mechanism");
        }
#line 708
        return (tmp___5);
      }
    }
  }
  {
#line 715
  tmp___6 = SPF_c_parse_macro___0(spf_server___1, spf_response, data, data_used, data_avail,
                                  src, src_len, big_err, is_mod);
  }
#line 715
  return (tmp___6);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip4___0(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  SPF_errcode_t err ;
  unsigned char mask ;
  struct in_addr *addr ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 739
  start ++;
#line 740
  len = strcspn(start, " ");
#line 741
  end = start + len;
#line 742
  p = end - 1;
#line 744
  mask = (unsigned char)0;
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 745
    tmp = __ctype_b_loc();
    }
#line 745
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 745
      goto while_break;
    }
#line 746
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 747
    if ((int const   )*p == 47) {
      {
#line 748
      err = SPF_c_parse_cidr_ip4___0(spf_response, & mask, p);
      }
#line 749
      if (err) {
#line 750
        return (err);
      }
#line 751
      end = p;
    }
  }
#line 753
  mech->mech_len = (unsigned short )mask;
#line 755
  len = (size_t )(end - start);
#line 756
  if (len > sizeof(buf) - 1UL) {
#line 757
    return ((SPF_errcode_t )19);
  }
  {
#line 759
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 760
  buf[len] = (char )'\000';
#line 761
  addr = SPF_mech_ip4_data(mech);
#line 762
  tmp___0 = inet_pton(2, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
#line 762
  err = (SPF_errcode_t )tmp___0;
  }
#line 763
  if ((unsigned int )err <= 0U) {
    {
#line 764
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )19, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 764
    return (tmp___1);
  }
#line 767
  return ((SPF_errcode_t )0);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip6___0(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  int err ;
  unsigned char mask ;
  struct in6_addr *addr ;
  unsigned short const   **tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 788
  start ++;
#line 789
  len = strcspn(start, " ");
#line 790
  end = start + len;
#line 791
  p = end - 1;
#line 793
  mask = (unsigned char)0;
  }
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 794
    tmp = __ctype_b_loc();
    }
#line 794
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 794
      goto while_break;
    }
#line 795
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 796
    if ((int const   )*p == 47) {
      {
#line 797
      tmp___0 = SPF_c_parse_cidr_ip6___0(spf_response, & mask, p);
#line 797
      err = (int )tmp___0;
      }
#line 798
      if (err) {
#line 799
        return ((SPF_errcode_t )err);
      }
#line 800
      end = p;
    }
  }
#line 802
  mech->mech_len = (unsigned short )mask;
#line 804
  len = (size_t )(end - start);
#line 805
  if (len > sizeof(buf) - 1UL) {
#line 806
    return ((SPF_errcode_t )20);
  }
  {
#line 808
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 809
  buf[len] = (char )'\000';
#line 810
  addr = SPF_mech_ip6_data(mech);
#line 811
  err = inet_pton(10, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
  }
#line 812
  if (err <= 0) {
    {
#line 813
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )20, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 813
    return (tmp___1);
  }
#line 816
  return ((SPF_errcode_t )0);
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mech_add___0)(SPF_server_t *spf_server___1 ,
                                                                                   SPF_record_t *spf_record ,
                                                                                   SPF_response_t *spf_response ,
                                                                                   SPF_mechtype_t const   *mechtype ,
                                                                                   int prefix ,
                                                                                   char const   **mech_value ) 
{ 
  union __anonunion_u_60___0 u ;
  SPF_mech_t *spf_mechanism ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  SPF_errcode_t tmp ;
  int tmp___0 ;

  {
  {
#line 834
  spf_mechanism = (SPF_mech_t *)(u.buf);
#line 842
  memset((void *)(u.buf), 'B', sizeof(u.buf));
#line 843
  memset((void *)spf_mechanism, 0, sizeof(SPF_mech_t ));
  }
#line 845
  if (spf_server___1->debug) {
    {
#line 846
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               847, "SPF_c_mech_add: type=%d, value=%s", (int const   )mechtype->mech_type,
               *mech_value);
    }
  }
#line 849
  spf_mechanism->prefix_type = (unsigned char )prefix;
#line 850
  spf_mechanism->mech_type = (unsigned char )mechtype->mech_type;
#line 851
  spf_mechanism->mech_len = (unsigned short)0;
#line 853
  len = sizeof(SPF_mech_t );
#line 855
  if (spf_record->mech_len + len > 511UL) {
#line 856
    return ((SPF_errcode_t )16);
  }
  {
#line 858
  data = SPF_mech_data(spf_mechanism);
#line 859
  data_len = (size_t )0;
#line 861
  src_len = strcspn(*mech_value, " ");
  }
  {
#line 865
  if ((int const   )mechtype->mech_type == 5) {
#line 865
    goto case_5;
  }
#line 878
  if ((int const   )mechtype->mech_type == 6) {
#line 878
    goto case_6;
  }
#line 891
  goto switch_default;
  case_5: /* CIL Label */ 
#line 866
  if ((int const   )*(*mech_value) == 58) {
    {
#line 867
    err = SPF_c_parse_ip4___0(spf_response, spf_mechanism, *mech_value);
#line 868
    data_len = sizeof(struct in_addr );
    }
  } else {
    {
#line 871
    err = (SPF_errcode_t )9;
#line 872
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 876
  goto switch_break;
  case_6: /* CIL Label */ 
#line 879
  if ((int const   )*(*mech_value) == 58) {
    {
#line 880
    err = SPF_c_parse_ip6___0(spf_response, spf_mechanism, *mech_value);
#line 881
    data_len = sizeof(struct in6_addr );
    }
  } else {
    {
#line 884
    err = (SPF_errcode_t )9;
#line 885
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 889
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 892
  if ((int const   )*(*mech_value) == 58) {
#line 892
    goto _L___0;
  } else
#line 892
  if ((int const   )*(*mech_value) == 61) {
    _L___0: /* CIL Label */ 
#line 893
    if ((unsigned int const   )mechtype->has_domainspec == 0U) {
      {
#line 894
      err = (SPF_errcode_t )7;
#line 895
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a value.");
      }
    } else {
      {
#line 900
      (*mech_value) ++;
#line 900
      src_len --;
#line 901
      err = SPF_c_parse_domainspec___0(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )mechtype->has_cidr, 0);
      }
    }
  } else
#line 909
  if ((int const   )*(*mech_value) == 47) {
#line 910
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 911
      err = (SPF_errcode_t )9;
#line 912
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else
#line 916
    if ((unsigned int const   )mechtype->has_cidr == 0U) {
      {
#line 917
      err = (SPF_errcode_t )8;
#line 918
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a CIDR.");
      }
    } else {
      {
#line 923
      err = SPF_c_parse_domainspec___0(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )2, 0);
      }
    }
  } else
#line 931
  if ((int const   )*(*mech_value) == 32) {
#line 931
    goto _L;
  } else
#line 931
  if ((int const   )*(*mech_value) == 0) {
    _L: /* CIL Label */ 
#line 932
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 933
      err = (SPF_errcode_t )9;
#line 934
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else {
#line 939
      err = (SPF_errcode_t )0;
    }
  } else {
    {
#line 943
    err = (SPF_errcode_t )3;
#line 944
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Unknown character \'%c\' after mechanism.", (int const   )*(*mech_value));
    }
  }
#line 951
  spf_mechanism->mech_len = (unsigned short )data_len;
#line 952
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 955
  len += data_len;
#line 958
  if ((unsigned int )err == 0U) {
#line 959
    if (mechtype->is_dns_mech) {
#line 960
      spf_record->num_dns_mech = (unsigned char )((int )spf_record->num_dns_mech + 1);
    }
    {
#line 961
    tmp___0 = SPF_c_ensure_capacity___0((void **)(& spf_record->mech_first), & spf_record->mech_size,
                                        spf_record->mech_len + len);
    }
#line 961
    if (tmp___0 < 0) {
      {
#line 964
      tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                       (char const   *)((void *)0), "Failed to allocate memory for mechanism");
      }
#line 964
      return (tmp);
    }
    {
#line 968
    memcpy((void */* __restrict  */)((char *)spf_record->mech_first + spf_record->mech_len),
           (void const   */* __restrict  */)spf_mechanism, len);
#line 971
    spf_record->mech_len += len;
#line 972
    spf_record->num_mech = (unsigned char )((int )spf_record->num_mech + 1);
    }
  }
#line 975
  *mech_value += src_len;
#line 977
  return (err);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mod_add___0)(SPF_server_t *spf_server___1 ,
                                                                                  SPF_record_t *spf_record ,
                                                                                  SPF_response_t *spf_response ,
                                                                                  char const   *mod_name ,
                                                                                  size_t name_len ,
                                                                                  char const   **mod_value ) 
{ 
  union __anonunion_u_61___0 u ;
  SPF_mod_t *spf_modifier ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  char *tmp ;
  SPF_errcode_t tmp___0 ;
  int tmp___1 ;

  {
#line 992
  spf_modifier = (SPF_mod_t *)(u.buf);
#line 1000
  if (spf_server___1->debug) {
    {
#line 1001
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               1002, "Adding modifier name=%lu@%s, value=%s", name_len, mod_name,
               *mod_value);
    }
  }
  {
#line 1004
  memset((void *)(u.buf), 'A', sizeof(u.buf));
#line 1005
  memset((void *)spf_modifier, 0, sizeof(SPF_mod_t ));
  }
#line 1007
  if (name_len > 511UL) {
#line 1008
    return ((SPF_errcode_t )17);
  }
  {
#line 1010
  spf_modifier->name_len = (unsigned short )name_len;
#line 1011
  spf_modifier->data_len = (unsigned short)0;
#line 1014
  len = _align_sz(sizeof(SPF_mod_t ) + name_len);
  }
#line 1016
  if (spf_record->mod_len + len > 511UL) {
#line 1017
    return ((SPF_errcode_t )17);
  }
  {
#line 1019
  tmp = SPF_mod_name(spf_modifier);
#line 1019
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)mod_name,
         name_len);
#line 1021
  data = SPF_mod_data(spf_modifier);
#line 1022
  data_len = (size_t )0;
#line 1024
  src_len = strcspn(*mod_value, " ");
#line 1026
  err = SPF_c_parse_macro___0(spf_server___1, spf_response, data, & data_len, (size_t )511,
                              *mod_value, src_len, (SPF_errcode_t )17, 1);
#line 1032
  spf_modifier->data_len = (unsigned short )data_len;
#line 1033
  len += data_len;
  }
#line 1036
  if ((unsigned int )err == 0U) {
    {
#line 1037
    tmp___1 = SPF_c_ensure_capacity___0((void **)(& spf_record->mod_first), & spf_record->mod_size,
                                        spf_record->mod_len + len);
    }
#line 1037
    if (tmp___1 < 0) {
      {
#line 1040
      tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                           (char const   *)((void *)0), "Failed to allocate memory for modifier");
      }
#line 1040
      return (tmp___0);
    }
    {
#line 1044
    memcpy((void */* __restrict  */)((char *)spf_record->mod_first + spf_record->mod_len),
           (void const   */* __restrict  */)spf_modifier, len);
#line 1047
    spf_record->mod_len += len;
#line 1048
    spf_record->num_mod = (unsigned char )((int )spf_record->num_mod + 1);
    }
  }
#line 1051
  return (err);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static void SPF_record_lint___0(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                SPF_record_t *spf_record ) 
{ 
  SPF_data_t *d ;
  SPF_data_t *data_end ;
  char *s ;
  char *s_end ;
  int found_non_ip ;
  int found_valid_tld ;
  SPF_mech_t *mech ;
  SPF_data_t *data ;
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1075
  mech = spf_record->mech_first;
#line 1076
  i = 0;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (i < (int )spf_record->num_mech)) {
#line 1076
      goto while_break;
    }
#line 1081
    if ((int )mech->mech_type == 8) {
#line 1081
      goto _L;
    } else
#line 1081
    if ((int )mech->mech_type == 9) {
      _L: /* CIL Label */ 
#line 1081
      if (i != (int )spf_record->num_mech - 1) {
        {
#line 1085
        SPF_response_add_warn(spf_response, (SPF_errcode_t )29, "Mechanisms found after the \"all:\" mechanism will be ignored.");
        }
      }
    }
#line 1098
    if ((int )mech->mech_type == 5) {
#line 1100
      goto __Cont;
    } else
#line 1098
    if ((int )mech->mech_type == 6) {
#line 1100
      goto __Cont;
    }
    {
#line 1102
    data = SPF_mech_data(mech);
#line 1103
    data_end = SPF_mech_end_data(mech);
    }
#line 1104
    if ((unsigned long )data == (unsigned long )data_end) {
#line 1105
      goto __Cont;
    }
#line 1107
    if ((int )data->dc.parm_type == 11) {
      {
#line 1109
      data = SPF_data_next(data);
      }
#line 1110
      if ((unsigned long )data == (unsigned long )data_end) {
#line 1111
        goto __Cont;
      }
    }
#line 1115
    found_valid_tld = 0;
#line 1116
    found_non_ip = 0;
#line 1118
    d = data;
    {
#line 1118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1118
      if (! ((unsigned long )d < (unsigned long )data_end)) {
#line 1118
        goto while_break___0;
      }
      {
#line 1122
      if ((int )d->dv.parm_type == 11) {
#line 1122
        goto case_11;
      }
#line 1128
      if ((int )d->dv.parm_type == 0) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 5) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 4) {
#line 1128
        goto case_0;
      }
#line 1132
      if ((int )d->dv.parm_type == 12) {
#line 1132
        goto case_12;
      }
#line 1148
      goto switch_default;
      case_11: /* CIL Label */ 
      {
#line 1123
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1123, "%s", "Multiple CIDR parameters found");
      }
#line 1124
      goto switch_break;
      case_0: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 1129
      found_valid_tld = 0;
#line 1130
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 1133
      found_valid_tld = 0;
#line 1135
      s = SPF_data_str(d);
#line 1136
      s_end = s + (int )d->ds.len;
      }
      {
#line 1137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1137
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 1137
          goto while_break___1;
        }
        {
#line 1138
        tmp = __ctype_b_loc();
        }
#line 1138
        if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 2048)) {
#line 1138
          if ((int )*s != 46) {
#line 1138
            if ((int )*s != 58) {
#line 1139
              found_non_ip = 1;
            }
          }
        }
#line 1141
        if ((int )*s == 46) {
#line 1142
          found_valid_tld = 1;
        } else {
          {
#line 1143
          tmp___0 = __ctype_b_loc();
          }
#line 1143
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 1024)) {
#line 1144
            found_valid_tld = 0;
          }
        }
#line 1137
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1146
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1149
      found_non_ip = 1;
#line 1150
      found_valid_tld = 1;
#line 1152
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1118
      d = SPF_data_next(d);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1156
    if (! found_valid_tld) {
#line 1156
      goto _L___0;
    } else
#line 1156
    if (! found_non_ip) {
      _L___0: /* CIL Label */ 
#line 1157
      if (! found_non_ip) {
        {
#line 1158
        SPF_response_add_warn(spf_response, (SPF_errcode_t )27, "Invalid hostname (an IP address?)");
        }
      } else
#line 1160
      if (! found_valid_tld) {
        {
#line 1161
        SPF_response_add_warn(spf_response, (SPF_errcode_t )28, "Hostname has a missing or invalid TLD");
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 1076
    i ++;
#line 1076
    mech = SPF_mech_next(mech);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1168
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv4___0[8]  = 
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
  {      (char const   )'i',      (char const   )'n',      (char const   )'-',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv6___0[4]  = {      (char const   )'i',      (char const   )'p',      (char const   )'6',      (char const   )'\000'};
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c"
static SPF_errcode_t SPF_record_stringify_data___0(SPF_data_t *data , SPF_data_t *data_end ,
                                                   char **p_p , char *p_end , int is_mod ,
                                                   int cidr_ok , int debug ) 
{ 
  char *p ;
  size_t len ;
  SPF_data_t *cidr_data ;
  char *s ;
  char *tmp ;
  char *s_end ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 48
  p = *p_p;
#line 54
  if (debug) {
    {
#line 55
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
               55, " string data: Building");
    }
  }
#line 57
  if (p_end - p <= 0L) {
#line 58
    return ((SPF_errcode_t )10);
  }
#line 60
  cidr_data = (SPF_data_t *)((void *)0);
#line 61
  if ((unsigned long )data < (unsigned long )data_end) {
#line 61
    if ((int )data->dc.parm_type == 11) {
#line 63
      if (debug) {
        {
#line 64
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   64, " string data: Found a CIDR at %p", data);
        }
      }
#line 65
      if (! cidr_ok) {
#line 66
        return ((SPF_errcode_t )10);
      }
      {
#line 68
      cidr_data = data;
#line 69
      data = SPF_data_next(data);
      }
    }
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )data < (unsigned long )data_end)) {
#line 73
      goto while_break;
    }
#line 75
    if (debug) {
      {
#line 76
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 77, " string data: Handling data type %d at %p", (int )data->ds.parm_type,
                 data);
      }
    }
#line 78
    if ((int )data->ds.parm_type == 12) {
      {
#line 80
      tmp = SPF_data_str(data);
#line 80
      s = tmp;
#line 81
      s_end = s + (int )data->ds.len;
      }
#line 82
      if (debug) {
        {
#line 83
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   84, " string data: String is [%d] \'%*.*s\'", (int )data->ds.len,
                   (int )data->ds.len, (int )data->ds.len, s);
        }
      }
#line 86
      if (p_end - (p + (int )data->ds.len) <= 0L) {
#line 87
        return ((SPF_errcode_t )10);
      }
      {
#line 89
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 89
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 89
          goto while_break___0;
        }
#line 90
        if ((int )*s == 32) {
#line 91
          tmp___0 = p;
#line 91
          p ++;
#line 91
          *tmp___0 = (char )'%';
#line 92
          tmp___1 = p;
#line 92
          p ++;
#line 92
          *tmp___1 = (char )'_';
#line 93
          s ++;
        } else
#line 95
        if ((int )*s == 37) {
#line 96
          tmp___2 = p;
#line 96
          p ++;
#line 96
          *tmp___2 = (char )'%';
#line 97
          s ++;
#line 98
          if ((int )*(s + 0) == 50) {
#line 98
            if ((int )*(s + 1) == 48) {
#line 99
              tmp___3 = p;
#line 99
              p ++;
#line 99
              *tmp___3 = (char )'-';
#line 100
              s += 2;
            } else {
#line 103
              tmp___4 = p;
#line 103
              p ++;
#line 103
              *tmp___4 = (char )'%';
            }
          } else {
#line 103
            tmp___4 = p;
#line 103
            p ++;
#line 103
            *tmp___4 = (char )'%';
          }
        } else {
#line 108
          tmp___5 = p;
#line 108
          p ++;
#line 108
          tmp___6 = s;
#line 108
          s ++;
#line 108
          *tmp___5 = *tmp___6;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 112
      if (p_end - p <= 0L) {
#line 113
        return ((SPF_errcode_t )10);
      }
    } else
#line 115
    if ((int )data->dc.parm_type == 11) {
#line 117
      return ((SPF_errcode_t )8);
    } else {
      {
#line 120
      tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%%{");
#line 120
      len = (size_t )tmp___7;
#line 121
      p += len;
      }
#line 122
      if (p_end - p <= 0L) {
#line 122
        return ((SPF_errcode_t )10);
      }
#line 125
      if (p_end - p <= 1L) {
#line 125
        return ((SPF_errcode_t )10);
      }
      {
#line 128
      if ((int )data->dv.parm_type == 0) {
#line 128
        goto case_0;
      }
#line 132
      if ((int )data->dv.parm_type == 1) {
#line 132
        goto case_1;
      }
#line 136
      if ((int )data->dv.parm_type == 2) {
#line 136
        goto case_2;
      }
#line 140
      if ((int )data->dv.parm_type == 3) {
#line 140
        goto case_3;
      }
#line 144
      if ((int )data->dv.parm_type == 4) {
#line 144
        goto case_4;
      }
#line 148
      if ((int )data->dv.parm_type == 5) {
#line 148
        goto case_5;
      }
#line 152
      if ((int )data->dv.parm_type == 6) {
#line 152
        goto case_6;
      }
#line 158
      if ((int )data->dv.parm_type == 7) {
#line 158
        goto case_7;
      }
#line 162
      if ((int )data->dv.parm_type == 8) {
#line 162
        goto case_8;
      }
#line 166
      if ((int )data->dv.parm_type == 9) {
#line 166
        goto case_9;
      }
#line 170
      if ((int )data->dv.parm_type == 10) {
#line 170
        goto case_10;
      }
#line 174
      goto switch_default;
      case_0: /* CIL Label */ 
#line 129
      *p = (char )'l';
#line 130
      goto switch_break;
      case_1: /* CIL Label */ 
#line 133
      *p = (char )'s';
#line 134
      goto switch_break;
      case_2: /* CIL Label */ 
#line 137
      *p = (char )'o';
#line 138
      goto switch_break;
      case_3: /* CIL Label */ 
#line 141
      *p = (char )'d';
#line 142
      goto switch_break;
      case_4: /* CIL Label */ 
#line 145
      *p = (char )'i';
#line 146
      goto switch_break;
      case_5: /* CIL Label */ 
#line 149
      *p = (char )'c';
#line 150
      goto switch_break;
      case_6: /* CIL Label */ 
#line 153
      if (! is_mod) {
#line 154
        return ((SPF_errcode_t )12);
      }
#line 155
      *p = (char )'t';
#line 156
      goto switch_break;
      case_7: /* CIL Label */ 
#line 159
      *p = (char )'p';
#line 160
      goto switch_break;
      case_8: /* CIL Label */ 
#line 163
      *p = (char )'v';
#line 164
      goto switch_break;
      case_9: /* CIL Label */ 
#line 167
      *p = (char )'h';
#line 168
      goto switch_break;
      case_10: /* CIL Label */ 
#line 171
      *p = (char )'r';
#line 172
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 175
      return ((SPF_errcode_t )12);
#line 176
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 178
      if (data->dv.url_encode) {
        {
#line 179
        tmp___8 = toupper((int )*p);
#line 179
        *p = (char )tmp___8;
        }
      }
#line 180
      p ++;
#line 181
      if (p_end - p <= 0L) {
#line 181
        return ((SPF_errcode_t )10);
      }
#line 184
      if (data->dv.num_rhs) {
        {
#line 186
        tmp___9 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%d",
                           (int )data->dv.num_rhs);
#line 186
        len = (size_t )tmp___9;
#line 187
        p += len;
        }
#line 188
        if (p_end - p <= 0L) {
#line 188
          return ((SPF_errcode_t )10);
        }
      }
#line 192
      if (p_end - p <= 8L) {
#line 192
        return ((SPF_errcode_t )10);
      }
#line 193
      if (data->dv.rev) {
#line 194
        tmp___10 = p;
#line 194
        p ++;
#line 194
        *tmp___10 = (char )'r';
      }
#line 196
      if (data->dv.delim_dot) {
#line 196
        if (data->dv.delim_dash) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_plus) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_equal) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_bar) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_under) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        }
      }
#line 205
      if (data->dv.delim_dash) {
#line 206
        tmp___12 = p;
#line 206
        p ++;
#line 206
        *tmp___12 = (char )'-';
      }
#line 207
      if (data->dv.delim_plus) {
#line 208
        tmp___13 = p;
#line 208
        p ++;
#line 208
        *tmp___13 = (char )'+';
      }
#line 209
      if (data->dv.delim_equal) {
#line 210
        tmp___14 = p;
#line 210
        p ++;
#line 210
        *tmp___14 = (char )'=';
      }
#line 211
      if (data->dv.delim_bar) {
#line 212
        tmp___15 = p;
#line 212
        p ++;
#line 212
        *tmp___15 = (char )'|';
      }
#line 213
      if (data->dv.delim_under) {
#line 214
        tmp___16 = p;
#line 214
        p ++;
#line 214
        *tmp___16 = (char )'_';
      }
#line 216
      tmp___17 = p;
#line 216
      p ++;
#line 216
      *tmp___17 = (char )'}';
#line 217
      if (p_end - p <= 0L) {
#line 217
        return ((SPF_errcode_t )10);
      }
    }
    {
#line 73
    data = SPF_data_next(data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (cidr_data) {
#line 224
    if (cidr_data->dc.ipv4) {
      {
#line 226
      tmp___18 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"/%d",
                          (int )cidr_data->dc.ipv4);
#line 226
      len = (size_t )tmp___18;
#line 227
      p += len;
      }
#line 228
      if (p_end - p <= 0L) {
#line 228
        return ((SPF_errcode_t )10);
      }
    }
#line 231
    if (cidr_data->dc.ipv6) {
      {
#line 233
      tmp___19 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"//%d",
                          (int )cidr_data->dc.ipv6);
#line 233
      len = (size_t )tmp___19;
#line 234
      p += len;
      }
#line 235
      if (p_end - p <= 0L) {
#line 235
        return ((SPF_errcode_t )10);
      }
    }
  }
#line 239
  *p_p = p;
#line 240
  return ((SPF_errcode_t )0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_pre___0(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                  ns_type rr_type , int should_cache ) 
{ 
  char const   *tmp ;

  {
#line 51
  if (spf_dns_server->debug) {
    {
#line 52
    tmp = SPF_strrrtype(rr_type);
#line 52
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               54, "DNS[%s] lookup: %s %s (%d)", spf_dns_server->name, domain, tmp,
               (unsigned int )rr_type);
    }
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_post___0(SPF_dns_server_t *spf_dns_server , SPF_dns_rr_t *spfrr ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 61
  if (spf_dns_server->debug) {
    {
#line 66
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               66, "DNS[%s] found record", spf_dns_server->name);
#line 67
    tmp = SPF_strrrtype(spfrr->rr_type);
#line 67
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               69, "    DOMAIN: %s  TYPE: %s (%d)", spfrr->domain, tmp, (unsigned int )spfrr->rr_type);
    }
#line 70
    if (spfrr->source) {
#line 70
      if ((spfrr->source)->name) {
#line 70
        tmp___0 = (spfrr->source)->name;
      } else {
#line 70
        tmp___0 = "(unnamed source)";
      }
#line 70
      tmp___1 = tmp___0;
    } else {
#line 70
      tmp___1 = "(null source)";
    }
    {
#line 70
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               76, "    TTL: %ld  RR found: %d  herrno: %d  source: %s", spfrr->ttl,
               spfrr->num_rr, spfrr->herrno, tmp___1);
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! (i < spfrr->num_rr)) {
#line 77
        goto while_break;
      }
      {
#line 79
      if ((unsigned int )spfrr->rr_type == 1U) {
#line 79
        goto case_1;
      }
#line 85
      if ((unsigned int )spfrr->rr_type == 12U) {
#line 85
        goto case_12;
      }
#line 89
      if ((unsigned int )spfrr->rr_type == 15U) {
#line 89
        goto case_15;
      }
#line 93
      if ((unsigned int )spfrr->rr_type == 16U) {
#line 93
        goto case_16;
      }
#line 97
      if ((unsigned int )spfrr->rr_type == 99U) {
#line 97
        goto case_99;
      }
#line 101
      if ((unsigned int )spfrr->rr_type == 28U) {
#line 101
        goto case_28;
      }
#line 107
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 80
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->a),
                          (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
#line 80
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 82, "    - A: %s", tmp___2);
      }
#line 83
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 86
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 86, "    - PTR: %s", (*(spfrr->rr + i))->ptr);
      }
#line 87
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 90
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 90, "    - MX: %s", (*(spfrr->rr + i))->mx);
      }
#line 91
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 94
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 94, "    - TXT: %s", (*(spfrr->rr + i))->txt);
      }
#line 95
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 98
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 98, "    - SPF: %s", (*(spfrr->rr + i))->txt);
      }
#line 99
      goto switch_break;
      case_28: /* CIL Label */ 
      {
#line 102
      tmp___3 = inet_ntop(10, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->aaaa),
                          (char */* __restrict  */)(ip6_buf), (socklen_t )sizeof(ip6_buf));
#line 102
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 104, "    - AAAA: %s", tmp___3);
      }
#line 105
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 108
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 108, "    - Unknown RR type");
      }
#line 109
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 77
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 113
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_cache_bucket_t *SPF_dns_cache_bucket_find___0(SPF_dns_cache_config_t *spfhook ,
                                                             char const   *domain ,
                                                             ns_type rr_type , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  SPF_dns_rr_t *rr ;
  time_t now ;
  int tmp ;

  {
  {
#line 247
  bucket = *(spfhook->cache + idx);
#line 248
  prev = (SPF_dns_cache_bucket_t *)((void *)0);
#line 249
  time(& now);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
#line 252
    rr = bucket->rr;
#line 254
    if (rr->utc_ttl < now) {
#line 256
      if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 257
        prev->next = bucket->next;
      } else {
#line 259
        *(spfhook->cache + idx) = bucket->next;
      }
#line 261
      if (bucket->rr) {
        {
#line 262
        SPF_dns_rr_free(bucket->rr);
        }
      }
      {
#line 263
      free((void *)bucket);
#line 265
      bucket = prev;
      }
    } else
#line 267
    if (! ((unsigned int )rr->rr_type != (unsigned int )rr_type)) {
      {
#line 270
      tmp = strcmp((char const   *)rr->domain, domain);
      }
#line 270
      if (! (tmp != 0)) {
#line 275
        if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 276
          prev->next = bucket->next;
#line 277
          bucket->next = *(spfhook->cache + idx);
#line 278
          *(spfhook->cache + idx) = bucket;
        }
#line 280
        return (bucket);
      }
    }
#line 283
    prev = bucket;
#line 284
    if ((unsigned long )bucket == (unsigned long )((void *)0)) {
#line 285
      bucket = *(spfhook->cache + idx);
    } else {
#line 287
      bucket = bucket->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return ((SPF_dns_cache_bucket_t *)((void *)0));
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_bucket_add___0(SPF_dns_cache_config_t *spfhook ,
                                                  SPF_dns_rr_t *rr , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  void *tmp ;

  {
  {
#line 300
  tmp = malloc(sizeof(SPF_dns_cache_bucket_t ));
#line 300
  bucket = (SPF_dns_cache_bucket_t *)tmp;
  }
#line 302
  if (! bucket) {
#line 303
    return ((SPF_errcode_t )1);
  }
#line 304
  bucket->next = *(spfhook->cache + idx);
#line 305
  *(spfhook->cache + idx) = bucket;
#line 306
  bucket->rr = rr;
#line 307
  return ((SPF_errcode_t )0);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_rr_fixup___0(SPF_dns_cache_config_t *spfhook ,
                                                SPF_dns_rr_t *cached_rr , char const   *domain ,
                                                ns_type rr_type ) 
{ 
  char *p ;
  char *new_domain ;
  size_t new_len ;
  size_t tmp ;
  void *tmp___0 ;
  time_t tmp___1 ;

  {
#line 322
  if ((unsigned int )cached_rr->rr_type == 255U) {
#line 323
    cached_rr->rr_type = rr_type;
  }
#line 326
  if ((unsigned long )cached_rr->domain == (unsigned long )((void *)0)) {
#line 326
    goto _L;
  } else
#line 326
  if ((int )*(cached_rr->domain + 0) != 0) {
    _L: /* CIL Label */ 
    {
#line 328
    tmp = strlen(domain);
#line 328
    new_len = tmp + 1UL;
    }
#line 330
    if (cached_rr->domain_buf_len < new_len) {
      {
#line 331
      tmp___0 = realloc((void *)cached_rr->domain, new_len);
#line 331
      new_domain = (char *)tmp___0;
      }
#line 332
      if ((unsigned long )new_domain == (unsigned long )((void *)0)) {
#line 333
        return ((SPF_errcode_t )1);
      }
#line 334
      cached_rr->domain = new_domain;
#line 335
      cached_rr->domain_buf_len = new_len;
    }
    {
#line 337
    strcpy((char */* __restrict  */)cached_rr->domain, (char const   */* __restrict  */)domain);
    }
  }
#line 341
  if (cached_rr->ttl < spfhook->min_ttl) {
#line 342
    cached_rr->ttl = spfhook->min_ttl;
  }
#line 344
  if (cached_rr->ttl < spfhook->txt_ttl) {
#line 344
    if ((unsigned int )cached_rr->rr_type == 16U) {
#line 346
      cached_rr->ttl = spfhook->txt_ttl;
    }
  }
#line 348
  if (cached_rr->ttl < spfhook->err_ttl) {
#line 348
    if (cached_rr->herrno != 0) {
#line 350
      cached_rr->ttl = spfhook->err_ttl;
    }
  }
#line 352
  if (cached_rr->ttl < spfhook->rdns_ttl) {
    {
#line 353
    p = strstr((char const   *)cached_rr->domain, ".arpa");
    }
#line 354
    if (p) {
#line 354
      if ((int )*(p + (sizeof(".arpa") - 1UL)) == 0) {
#line 355
        cached_rr->ttl = spfhook->rdns_ttl;
      }
    }
  }
  {
#line 358
  tmp___1 = time((time_t *)((void *)0));
#line 358
  cached_rr->utc_ttl = cached_rr->ttl + tmp___1;
  }
#line 360
  return ((SPF_errcode_t )0);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_rr_t *SPF_dns_cache_lookup___0(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                              ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_rr_t *cached_rr ;
  SPF_dns_rr_t *rr ;
  int idx ;
  SPF_errcode_t tmp ;
  SPF_dns_rr_t *tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;

  {
  {
#line 377
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
#line 381
  idx = crc32str(0U, domain, spfhook->max_hash_len);
#line 382
  idx &= spfhook->cache_size - 1;
#line 384
  pthread_mutex_lock(& spfhook->cache_lock);
#line 386
  bucket = SPF_dns_cache_bucket_find___0(spfhook, domain, rr_type, idx);
  }
#line 387
  if ((unsigned long )bucket != (unsigned long )((void *)0)) {
#line 388
    if ((unsigned long )bucket->rr != (unsigned long )((void *)0)) {
      {
#line 389
      tmp = SPF_dns_rr_dup(& rr, bucket->rr);
      }
#line 389
      if ((unsigned int )tmp == 0U) {
        {
#line 390
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 391
        return (rr);
      } else
#line 393
      if ((unsigned long )rr != (unsigned long )((void *)0)) {
        {
#line 394
        SPF_dns_rr_free(rr);
        }
      }
    }
  }
  {
#line 401
  bucket = (SPF_dns_cache_bucket_t *)((void *)0);
#line 403
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 405
  if (! spf_dns_server->layer_below) {
    {
#line 406
    tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
    }
#line 406
    return (tmp___0);
  }
  {
#line 408
  rr = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
  }
#line 410
  if (spfhook->conserve_cache) {
#line 410
    if (! should_cache) {
#line 411
      return (rr);
    }
  }
  {
#line 413
  pthread_mutex_lock(& spfhook->cache_lock);
#line 415
  tmp___3 = SPF_dns_rr_dup(& cached_rr, rr);
  }
#line 415
  if ((unsigned int )tmp___3 == 0U) {
    {
#line 416
    tmp___2 = SPF_dns_cache_rr_fixup___0(spfhook, cached_rr, domain, rr_type);
    }
#line 416
    if ((unsigned int )tmp___2 == 0U) {
      {
#line 417
      tmp___1 = SPF_dns_cache_bucket_add___0(spfhook, cached_rr, idx);
      }
#line 417
      if ((unsigned int )tmp___1 == 0U) {
        {
#line 418
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 419
        return (rr);
      }
    }
  }
  {
#line 424
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 426
  if (cached_rr) {
    {
#line 427
    SPF_dns_rr_free(cached_rr);
    }
  }
#line 429
  return (rr);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static void SPF_dns_cache_free___0(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  int i ;

  {
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 442
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
                 442, "%s", "spf_dns_server is NULL");
      }
    }
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
  }
#line 445
  if (spfhook) {
    {
#line 446
    pthread_mutex_lock(& spfhook->cache_lock);
    }
#line 448
    if (spfhook->cache) {
#line 449
      i = 0;
      {
#line 449
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 449
        if (! (i < spfhook->cache_size)) {
#line 449
          goto while_break___0;
        }
#line 450
        bucket = *(spfhook->cache + i);
        {
#line 451
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 451
          if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 451
            goto while_break___1;
          }
#line 452
          prev = bucket;
#line 453
          bucket = bucket->next;
#line 456
          if (prev->rr) {
            {
#line 457
            SPF_dns_rr_free(prev->rr);
            }
          }
          {
#line 458
          free((void *)prev);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 449
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 461
      free((void *)spfhook->cache);
#line 462
      spfhook->cache = (SPF_dns_cache_bucket_t **)((void *)0);
      }
    }
    {
#line 465
    pthread_mutex_unlock(& spfhook->cache_lock);
#line 476
    pthread_mutex_destroy(& spfhook->cache_lock);
#line 478
    free((void *)spfhook);
    }
  }
  {
#line 481
  free((void *)spf_dns_server);
  }
#line 482
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_find___0(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                           ns_type rr_type , int exact ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;
  int tmp ;
  size_t domain_len ;
  size_t tmp___0 ;
  size_t zdomain_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 103
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 105
  if (spf_dns_server->debug) {
    {
#line 106
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
               106, "zone: Searching for RR %s (%d)", domain, (unsigned int )rr_type);
    }
  }
#line 110
  if (exact) {
#line 110
    goto _L;
  } else {
    {
#line 110
    tmp___6 = strncmp(domain, "*.", (size_t )2);
    }
#line 110
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
#line 111
      i = 0;
      {
#line 111
      while (1) {
        while_continue: /* CIL Label */ ;
#line 111
        if (! (i < spfhook->num_zone)) {
#line 111
          goto while_break;
        }
#line 112
        if ((unsigned int )(*(spfhook->zone + i))->rr_type == (unsigned int )rr_type) {
          {
#line 112
          tmp = strcasecmp((char const   *)(*(spfhook->zone + i))->domain, domain);
          }
#line 112
          if (tmp == 0) {
#line 114
            return (*(spfhook->zone + i));
          }
        }
#line 111
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 116
      if (spf_dns_server->debug) {
        {
#line 117
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   117, "zone: Exact not found");
        }
      }
    } else {
      {
#line 121
      tmp___0 = strlen(domain);
#line 121
      domain_len = tmp___0;
      }
#line 125
      if (domain_len) {
#line 125
        if ((int const   )*(domain + (domain_len - 1UL)) == 46) {
#line 126
          domain_len --;
        }
      }
#line 128
      i = 0;
      {
#line 128
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 128
        if (! (i < spfhook->num_zone)) {
#line 128
          goto while_break___0;
        }
#line 129
        if ((unsigned int )(*(spfhook->zone + i))->rr_type != (unsigned int )rr_type) {
#line 129
          if ((unsigned int )(*(spfhook->zone + i))->rr_type != 255U) {
#line 131
            if (spf_dns_server->debug) {
              {
#line 132
              SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                         133, "zone: Ignoring record rrtype %d", (unsigned int )(*(spfhook->zone + i))->rr_type);
              }
            }
#line 134
            goto __Cont;
          }
        }
        {
#line 137
        tmp___5 = strncmp((char const   *)(*(spfhook->zone + i))->domain, "*.", (size_t )2);
        }
#line 137
        if (tmp___5 == 0) {
          {
#line 138
          tmp___1 = strlen((char const   *)(*(spfhook->zone + i))->domain);
#line 138
          zdomain_len = tmp___1 - 2UL;
          }
#line 139
          if (zdomain_len <= domain_len) {
            {
#line 139
            tmp___2 = strncasecmp((char const   *)((*(spfhook->zone + i))->domain + 2),
                                  domain + (domain_len - zdomain_len), zdomain_len);
            }
#line 139
            if (tmp___2 == 0) {
#line 144
              return (*(spfhook->zone + i));
            }
          }
        } else {
          {
#line 146
          tmp___3 = strncasecmp((char const   *)(*(spfhook->zone + i))->domain, domain,
                                domain_len);
          }
#line 146
          if (tmp___3 == 0) {
            {
#line 146
            tmp___4 = strlen((char const   *)(*(spfhook->zone + i))->domain);
            }
#line 146
            if (tmp___4 == domain_len) {
#line 151
              return (*(spfhook->zone + i));
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 128
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 154
      if (spf_dns_server->debug) {
        {
#line 155
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   155, "zone: Non-exact not found");
        }
      }
    }
  }
#line 158
  return ((SPF_dns_rr_t *)((void *)0));
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_lookup___0(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  SPF_dns_rr_t *spfrr ;
  SPF_dns_rr_t *tmp ;

  {
  {
#line 170
  spfrr = SPF_dns_zone_find___0(spf_dns_server, domain, rr_type, 0);
  }
#line 171
  if (spfrr) {
    {
#line 172
    SPF_dns_rr_dup(& spfrr, spfrr);
    }
#line 173
    return (spfrr);
  }
#line 176
  if (spf_dns_server->layer_below) {
    {
#line 177
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 177
    return (tmp);
  }
  {
#line 181
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
#line 182
  SPF_dns_rr_dup(& spfrr, spfhook->nxdomain);
  }
#line 184
  return (spfrr);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static void SPF_dns_zone_free___0(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 317
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                 317, "%s", "spf_dns_server is NULL");
      }
    }
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 320
  if (spfhook) {
#line 321
    if (spfhook->zone) {
#line 322
      i = 0;
      {
#line 322
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 322
        if (! (i < spfhook->zone_buf_len)) {
#line 322
          goto while_break___0;
        }
#line 323
        if (*(spfhook->zone + i)) {
          {
#line 324
          SPF_dns_rr_free(*(spfhook->zone + i));
          }
        }
#line 322
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 326
      free((void *)spfhook->zone);
      }
    }
#line 328
    if (spfhook->nxdomain) {
      {
#line 329
      SPF_dns_rr_free(spfhook->nxdomain);
      }
    }
    {
#line 330
    free((void *)spfhook);
    }
  }
  {
#line 333
  free((void *)spf_dns_server);
  }
#line 334
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static struct res_sym  const  ns_sects___0[4]  = {      {0, (char *)"QUESTION", (char *)"Question"}, 
        {1, (char *)"ANSWER", (char *)"Answer"}, 
        {2, (char *)"AUTHORITY", (char *)"Authority"}, 
        {3, (char *)"ADDITIONAL", (char *)"Additional"}};
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static int const   num_ns_sect___0  =    (int const   )(sizeof(ns_sects___0) / sizeof(ns_sects___0[0]));
#line 89 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_once_t res_state_control___0  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_key_t res_state_key___0  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_thread_term___0(void *arg ) 
{ 


  {
  {
#line 98
  __res_nclose((struct __res_state *)arg);
#line 100
  free(arg);
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_init_key___0(void) 
{ 


  {
  {
#line 106
  pthread_key_create(& res_state_key___0, & SPF_dns_resolv_thread_term___0);
  }
#line 107
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_debug___0(SPF_dns_server_t *spf_dns_server , ns_rr rr ,
                                     u_char const   *responsebuf , size_t responselen ,
                                     u_char const   *rdata , size_t rdlen ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char name_buf[1025] ;
  int prio ;
  int err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  u_int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 123
  if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 123
    goto case_1;
  }
#line 132
  if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 132
    goto case_28;
  }
#line 141
  if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 141
    goto case_2;
  }
#line 153
  if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 153
    goto case_5;
  }
#line 165
  if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 165
    goto case_15;
  }
#line 182
  if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 182
    goto case_16;
  }
#line 193
  if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 193
    goto case_12;
  }
#line 205
  goto switch_default;
  case_1: /* CIL Label */ 
#line 124
  if (rdlen != 4UL) {
    {
#line 125
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               125, "A: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 127
    tmp = inet_ntop(2, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip4_buf),
                    (socklen_t )sizeof(ip4_buf));
#line 127
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               129, "A: %s", tmp);
    }
  }
#line 130
  goto switch_break;
  case_28: /* CIL Label */ 
#line 133
  if (rdlen != 16UL) {
    {
#line 134
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               134, "AAAA: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 136
    tmp___0 = inet_ntop(10, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip6_buf),
                        (socklen_t )sizeof(ip6_buf));
#line 136
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               138, "AAAA: %s", tmp___0);
    }
  }
#line 139
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 142
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 146
  if (err < 0) {
    {
#line 147
    tmp___1 = __errno_location();
#line 147
    tmp___2 = __errno_location();
#line 147
    tmp___3 = strerror(*tmp___2);
#line 147
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               148, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___3,
               *tmp___1);
    }
  } else {
    {
#line 150
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               150, "NS: %s", name_buf);
    }
  }
#line 151
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 154
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 158
  if (err < 0) {
    {
#line 159
    tmp___4 = __errno_location();
#line 159
    tmp___5 = __errno_location();
#line 159
    tmp___6 = strerror(*tmp___5);
#line 159
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               160, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___6,
               *tmp___4);
    }
  } else {
    {
#line 162
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               162, "CNAME: %s", name_buf);
    }
  }
#line 163
  goto switch_break;
  case_15: /* CIL Label */ 
#line 166
  if (rdlen < 2UL) {
    {
#line 167
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               167, "MX: rdlen too short: %lu", rdlen);
    }
#line 168
    goto switch_break;
  }
  {
#line 170
  tmp___7 = ns_get16(rdata);
#line 170
  prio = (int )tmp___7;
#line 171
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata + 2, name_buf,
                           sizeof(name_buf));
  }
#line 175
  if (err < 0) {
    {
#line 176
    tmp___8 = __errno_location();
#line 176
    tmp___9 = __errno_location();
#line 176
    tmp___10 = strerror(*tmp___9);
#line 176
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               177, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___10,
               *tmp___8);
    }
  } else {
    {
#line 179
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               179, "MX: %d %s", prio, name_buf);
    }
  }
#line 180
  goto switch_break;
  case_16: /* CIL Label */ 
#line 183
  if (rdlen < 1UL) {
    {
#line 184
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               184, "TXT: rdlen too short: %lu", rdlen);
    }
#line 185
    goto switch_break;
  }
  {
#line 189
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             190, "TXT: (%lu) \"%.*s\"", rdlen, (int )rdlen - 1, rdata + 1);
  }
#line 191
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 194
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 198
  if (err < 0) {
    {
#line 199
    tmp___11 = __errno_location();
#line 199
    tmp___12 = __errno_location();
#line 199
    tmp___13 = strerror(*tmp___12);
#line 199
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               200, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___13,
               *tmp___11);
    }
  } else {
    {
#line 202
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               202, "PTR: %s", name_buf);
    }
  }
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 206
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             206, "not parsed:  type: %d", (unsigned int )((ns_type )((int )rr.type)));
  }
#line 207
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static SPF_dns_rr_t *SPF_dns_resolv_lookup___0(SPF_dns_server_t *spf_dns_server ,
                                               char const   *domain , ns_type rr_type ,
                                               int should_cache ) 
{ 
  SPF_dns_rr_t *spfrr ;
  int err ;
  int i ;
  int nrec ;
  int cnt ;
  u_char *responsebuf ;
  size_t responselen ;
  ns_msg ns_handle ;
  ns_rr rr ;
  int ns_sect___0 ;
  char name_buf[1025] ;
  size_t rdlen ;
  u_char const   *rdata ;
  void *res_spec ;
  struct __res_state *res_state___0 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int dns_len ;
  char const   *tmp___2 ;
  SPF_dns_rr_t *tmp___3 ;
  SPF_dns_rr_t *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  SPF_errcode_t tmp___20 ;
  SPF_errcode_t tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  SPF_errcode_t tmp___26 ;
  u_char *src ;
  u_char *dst ;
  size_t len ;
  SPF_errcode_t tmp___27 ;
  SPF_errcode_t tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  SPF_errcode_t tmp___33 ;

  {
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 247
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 247, "%s", "spf_dns_server is NULL");
      }
    }
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  res_spec = pthread_getspecific(res_state_key___0);
  }
#line 252
  if ((unsigned long )res_spec == (unsigned long )((void *)0)) {
    {
#line 253
    tmp = malloc(sizeof(struct __res_state ));
#line 253
    res_state___0 = (struct __res_state *)tmp;
    }
#line 257
    if (! res_state___0) {
      {
#line 258
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 259, "Failed to allocate %lu bytes for res_state", sizeof(struct __res_state ));
      }
    }
    {
#line 260
    memset((void *)res_state___0, 0, sizeof(struct __res_state ));
#line 261
    tmp___0 = __res_ninit(res_state___0);
    }
#line 261
    if (tmp___0 != 0) {
      {
#line 262
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 262, "%s", "Failed to call res_ninit()");
      }
    }
    {
#line 263
    pthread_setspecific(res_state_key___0, (void const   *)((void *)res_state___0));
    }
  } else {
#line 266
    res_state___0 = (struct __res_state *)res_spec;
  }
  {
#line 270
  responselen = (size_t )2048;
#line 271
  tmp___1 = malloc(responselen);
#line 271
  responsebuf = (u_char *)tmp___1;
  }
#line 272
  if (! responsebuf) {
#line 273
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 274
  memset((void *)responsebuf, 0, responselen);
  }
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 297
    dns_len = __res_nquery(res_state___0, domain, 1, (int )rr_type, responsebuf, (int )responselen);
    }
#line 304
    if (dns_len < 0) {
      {
#line 307
      free((void *)responsebuf);
      }
#line 308
      if (spf_dns_server->debug) {
        {
#line 309
        tmp___2 = hstrerror(res_state___0->res_h_errno);
#line 309
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   311, "query failed: err = %d  %s (%d): %s", dns_len, tmp___2, res_state___0->res_h_errno,
                   domain);
        }
      }
#line 312
      if (res_state___0->res_h_errno == 1) {
#line 312
        if ((unsigned long )spf_dns_server->layer_below != (unsigned long )((void *)0)) {
          {
#line 314
          tmp___3 = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
          }
#line 314
          return (tmp___3);
        }
      }
      {
#line 317
      tmp___4 = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, res_state___0->res_h_errno);
      }
#line 317
      return (tmp___4);
    } else
#line 320
    if ((size_t )dns_len > responselen) {
      {
#line 323
      responselen = (size_t )(dns_len + (dns_len >> 1));
#line 332
      tmp___5 = realloc((void *)responsebuf, responselen);
      }
#line 333
      if (! tmp___5) {
        {
#line 334
        free((void *)responsebuf);
        }
#line 335
        return ((SPF_dns_rr_t *)((void *)0));
      }
#line 337
      responsebuf = (u_char *)tmp___5;
    } else {
#line 341
      responselen = (size_t )dns_len;
#line 342
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 351
  spfrr = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, 0);
  }
#line 353
  if (! spfrr) {
    {
#line 354
    free((void *)responsebuf);
    }
#line 355
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 358
  err = ns_initparse((u_char const   *)responsebuf, (int )responselen, & ns_handle);
  }
#line 360
  if (err < 0) {
#line 361
    if (spf_dns_server->debug) {
      {
#line 362
      tmp___6 = __errno_location();
#line 362
      tmp___7 = __errno_location();
#line 362
      tmp___8 = strerror(*tmp___7);
#line 362
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 363, "ns_initparse failed: err = %d  %s (%d)", err, tmp___8, *tmp___6);
      }
    }
    {
#line 364
    free((void *)responsebuf);
#line 367
    spfrr->herrno = 3;
    }
#line 368
    return (spfrr);
  }
#line 372
  if (spf_dns_server->debug > 1) {
    {
#line 373
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               373, "msg id:             %d", (int )ns_handle._id);
#line 374
    tmp___9 = ns_msg_getflag(ns_handle, 0);
#line 374
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               374, "ns_f_qr quest/resp: %d", tmp___9);
#line 375
    tmp___10 = ns_msg_getflag(ns_handle, 1);
#line 375
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               375, "ns_f_opcode:        %d", tmp___10);
#line 376
    tmp___11 = ns_msg_getflag(ns_handle, 2);
#line 376
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               376, "ns_f_aa auth ans:   %d", tmp___11);
#line 377
    tmp___12 = ns_msg_getflag(ns_handle, 3);
#line 377
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               377, "ns_f_tc truncated:  %d", tmp___12);
#line 378
    tmp___13 = ns_msg_getflag(ns_handle, 4);
#line 378
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               378, "ns_f_rd rec desire: %d", tmp___13);
#line 379
    tmp___14 = ns_msg_getflag(ns_handle, 5);
#line 379
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               379, "ns_f_ra rec avail:  %d", tmp___14);
#line 380
    tmp___15 = ns_msg_getflag(ns_handle, 9);
#line 380
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               380, "ns_f_rcode:         %d", tmp___15);
    }
  }
#line 385
  ns_sect___0 = 0;
  {
#line 385
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 385
    if (! (ns_sect___0 < (int )num_ns_sect___0)) {
#line 385
      goto while_break___1;
    }
#line 391
    if (ns_sects___0[ns_sect___0].number != 1) {
#line 391
      if (spf_dns_server->debug <= 1) {
#line 392
        goto __Cont;
      }
    }
#line 394
    nrec = (int )ns_handle._counts[ns_sects___0[ns_sect___0].number];
#line 396
    if (spf_dns_server->debug > 1) {
      {
#line 397
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 397, "%s:  %d", ns_sects___0[ns_sect___0].name, nrec);
      }
    }
#line 399
    spfrr->num_rr = 0;
#line 400
    cnt = 0;
#line 401
    i = 0;
    {
#line 401
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 401
      if (! (i < nrec)) {
#line 401
        goto while_break___2;
      }
      {
#line 402
      err = ns_parserr(& ns_handle, (ns_sect )ns_sects___0[ns_sect___0].number, i,
                       & rr);
      }
#line 403
      if (err < 0) {
#line 404
        if (spf_dns_server->debug > 1) {
          {
#line 405
          tmp___16 = __errno_location();
#line 405
          tmp___17 = __errno_location();
#line 405
          tmp___18 = strerror(*tmp___17);
#line 405
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     406, "ns_parserr failed: err = %d  %s (%d)", err, tmp___18, *tmp___16);
          }
        }
        {
#line 407
        free((void *)responsebuf);
#line 410
        spfrr->herrno = 3;
        }
#line 411
        return (spfrr);
      }
#line 414
      rdlen = (size_t )((int )rr.rdlength);
#line 415
      if (spf_dns_server->debug > 1) {
#line 416
        if ((int )rr.name[0] != 0) {
#line 416
          tmp___19 = (char const   *)(rr.name);
        } else {
#line 416
          tmp___19 = ".";
        }
        {
#line 416
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   418, "name: %s  type: %d  class: %d  ttl: %d  rdlen: %lu", tmp___19,
                   (unsigned int )((ns_type )((int )rr.type)), (unsigned int )((ns_class )((int )rr.rr_class)),
                   rr.ttl, rdlen);
        }
      }
#line 420
      if (rdlen <= 0UL) {
#line 421
        goto __Cont___0;
      }
#line 423
      rdata = rr.rdata + 0;
#line 425
      if (spf_dns_server->debug > 1) {
        {
#line 426
        SPF_dns_resolv_debug___0(spf_dns_server, rr, (u_char const   *)responsebuf,
                                 responselen, rdata, rdlen);
        }
      }
#line 430
      if (ns_sects___0[ns_sect___0].number != 1) {
#line 431
        goto __Cont___0;
      }
#line 434
      if ((unsigned int )((ns_type )((int )rr.type)) != (unsigned int )spfrr->rr_type) {
#line 434
        if ((unsigned int )((ns_type )((int )rr.type)) != 5U) {
          {
#line 435
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     436, "unexpected rr type: %d   expected: %d", (unsigned int )((ns_type )((int )rr.type)),
                     (unsigned int )rr_type);
          }
#line 437
          goto __Cont___0;
        }
      }
      {
#line 441
      if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 441
        goto case_1;
      }
#line 458
      if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 458
        goto case_28;
      }
#line 475
      if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 475
        goto case_2;
      }
#line 478
      if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 478
        goto case_5;
      }
#line 482
      if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 482
        goto case_15;
      }
#line 513
      if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 513
        goto case_16;
      }
#line 562
      if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 562
        goto case_12;
      }
#line 588
      goto switch_default;
      case_1: /* CIL Label */ 
#line 442
      if (rdlen != 4UL) {
        {
#line 444
        free((void *)responsebuf);
        }
#line 445
        return (spfrr);
      }
      {
#line 447
      tmp___20 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->a));
      }
#line 447
      if ((unsigned int )tmp___20 != 0U) {
        {
#line 449
        free((void *)responsebuf);
        }
#line 452
        return (spfrr);
      }
      {
#line 454
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->a), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->a));
#line 455
      cnt ++;
      }
#line 456
      goto switch_break;
      case_28: /* CIL Label */ 
#line 459
      if (rdlen != 16UL) {
        {
#line 461
        free((void *)responsebuf);
        }
#line 462
        return (spfrr);
      }
      {
#line 464
      tmp___21 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->aaaa));
      }
#line 464
      if ((unsigned int )tmp___21 != 0U) {
        {
#line 466
        free((void *)responsebuf);
        }
#line 469
        return (spfrr);
      }
      {
#line 471
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->aaaa), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->aaaa));
#line 472
      cnt ++;
      }
#line 473
      goto switch_break;
      case_2: /* CIL Label */ 
#line 476
      goto switch_break;
      case_5: /* CIL Label */ 
#line 480
      goto switch_break;
      case_15: /* CIL Label */ 
#line 483
      if (rdlen < 2UL) {
        {
#line 485
        free((void *)responsebuf);
        }
#line 486
        return (spfrr);
      }
      {
#line 488
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata + 2, name_buf, sizeof(name_buf));
      }
#line 492
      if (err < 0) {
#line 493
        if (spf_dns_server->debug > 1) {
          {
#line 494
          tmp___22 = __errno_location();
#line 494
          tmp___23 = __errno_location();
#line 494
          tmp___24 = strerror(*tmp___23);
#line 494
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     495, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___24,
                     *tmp___22);
          }
        }
        {
#line 496
        free((void *)responsebuf);
        }
#line 499
        return (spfrr);
      }
      {
#line 502
      tmp___25 = strlen((char const   *)(name_buf));
#line 502
      tmp___26 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___25 + 1UL);
      }
#line 502
      if ((unsigned int )tmp___26 != 0U) {
        {
#line 504
        free((void *)responsebuf);
        }
#line 507
        return (spfrr);
      }
      {
#line 509
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->mx), (char const   */* __restrict  */)(name_buf));
#line 510
      cnt ++;
      }
#line 511
      goto switch_break;
      case_16: /* CIL Label */ 
#line 514
      if (rdlen > 1UL) {
        {
#line 520
        tmp___27 = SPF_dns_rr_buf_realloc(spfrr, cnt, rdlen);
        }
#line 520
        if ((unsigned int )tmp___27 != 0U) {
          {
#line 521
          free((void *)responsebuf);
          }
#line 524
          return (spfrr);
        }
#line 527
        dst = (u_char *)((*(spfrr->rr + cnt))->txt);
#line 528
        src = (u_char *)rdata;
#line 529
        len = (size_t )0;
        {
#line 530
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 530
          if (! (rdlen > 0UL)) {
#line 530
            goto while_break___3;
          }
#line 532
          len = (size_t )*src;
#line 533
          src ++;
#line 534
          rdlen --;
#line 538
          if (len > rdlen) {
#line 539
            len = rdlen;
          }
          {
#line 540
          memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src,
                 len);
#line 543
          src += len;
#line 544
          dst += len;
#line 545
          rdlen -= len;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 547
        *dst = (u_char )'\000';
      } else {
        {
#line 550
        tmp___28 = SPF_dns_rr_buf_realloc(spfrr, cnt, (size_t )1);
        }
#line 550
        if ((unsigned int )tmp___28 != 0U) {
          {
#line 551
          free((void *)responsebuf);
          }
#line 554
          return (spfrr);
        }
#line 556
        (*(spfrr->rr + cnt))->txt[0] = (char )'\000';
      }
#line 559
      cnt ++;
#line 560
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 563
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata, name_buf, sizeof(name_buf));
      }
#line 567
      if (err < 0) {
#line 568
        if (spf_dns_server->debug > 1) {
          {
#line 569
          tmp___29 = __errno_location();
#line 569
          tmp___30 = __errno_location();
#line 569
          tmp___31 = strerror(*tmp___30);
#line 569
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     570, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___31,
                     *tmp___29);
          }
        }
        {
#line 571
        free((void *)responsebuf);
        }
#line 574
        return (spfrr);
      }
      {
#line 577
      tmp___32 = strlen((char const   *)(name_buf));
#line 577
      tmp___33 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___32 + 1UL);
      }
#line 577
      if ((unsigned int )tmp___33 != 0U) {
        {
#line 579
        free((void *)responsebuf);
        }
#line 582
        return (spfrr);
      }
      {
#line 584
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->ptr), (char const   */* __restrict  */)(name_buf));
#line 585
      cnt ++;
      }
#line 586
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 589
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 401
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 593
    spfrr->num_rr = cnt;
    __Cont: /* CIL Label */ 
#line 385
    ns_sect___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 596
  if (spfrr->num_rr == 0) {
#line 597
    spfrr->herrno = 4;
  }
  {
#line 599
  free((void *)responsebuf);
  }
#line 600
  return (spfrr);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_free___0(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 607
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 607, "%s", "spf_dns_server is NULL");
      }
    }
#line 607
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  free((void *)spf_dns_server);
  }
#line 614
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c"
static SPF_errcode_t SPF_server_get_default_explanation___0(SPF_server_t *spf_server___1 ,
                                                            SPF_request_t *spf_request ,
                                                            SPF_response_t *spf_response ,
                                                            char **bufp , size_t *buflenp ) 
{ 
  SPF_errcode_t err ;
  SPF_macro_t *spf_macro ;
  SPF_data_t *tmp ;
  size_t len ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  spf_macro = spf_server___1->explanation;
#line 56
  if ((unsigned long )spf_macro != (unsigned long )((void *)0)) {
    {
#line 57
    tmp = SPF_macro_data(spf_macro);
#line 57
    err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, tmp, spf_macro->macro_len,
                                 bufp, buflenp);
    }
#line 61
    return (err);
  } else {
#line 64
    len = sizeof("SPF failure: no explanation available") + 1UL;
#line 65
    if (*buflenp < len) {
      {
#line 66
      tmp___1 = realloc((void *)*bufp, len);
#line 66
      tmp___0 = (char *)tmp___1;
      }
#line 67
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 68
        return ((SPF_errcode_t )1);
      }
#line 69
      *bufp = tmp___0;
#line 70
      *buflenp = len;
    }
    {
#line 72
    strcpy((char */* __restrict  */)*bufp, (char const   */* __restrict  */)"SPF failure: no explanation available");
    }
#line 73
    return ((SPF_errcode_t )0);
  }
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
static SPF_dns_test_data_t const   SPF_dns_db___1[175]  = 
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
  {      {"localhost", 1, 0, "127.0.0.1"}, 
        {"example.com", 1, 0, "192.0.2.3"}, 
        {"example.com", 15, 0, "mx.example.org"}, 
        {"example.com", 16, 0, "v=spf1 mx -all"}, 
        {"3.2.0.192.in-addr.arpa", 12, 0, "mx.example.org"}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}, 
        {"noexist.example.com", 1, 1, (char const   *)((void *)0)}, 
        {"mx.example.org", 1, 0, "192.0.2.3"}, 
        {"mx.example.org", 28, 0, "5f05:2000:80ad:5800::1"}, 
        {"email.example.com", 16, 0, "v=spf1 -all"}, 
        {"*.example.com", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.org", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.net", 255, 1, (char const   *)((void *)0)}, 
        {"01.spf1-test.mailzone.com", 16, 0, "v=spf1                                                             "}, 
        {"02.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             -all       "}, 
        {"03.spf1-test.mailzone.com", 16, 0, "v=spf1                                             ~all"}, 
        {"05.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             default=deny   "}, 
        {"06.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             ?all "}, 
        {"07.spf1-test.mailzone.com", 16, 0, "v=spf2                                             default=bogus   "}, 
        {"08.spf1-test.mailzone.com",
      16, 0, "v=spf1                       -all      ?all  "}, 
        {"09.spf1-test.mailzone.com", 16, 0, "v=spf1    scope=header-from scope=envelope         -all  "}, 
        {"10.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx                                          -all"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"11.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"13.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"20.spf1-test.mailzone.com", 1, 0, "192.0.2.120"}, 
        {"20.spf1-test.mailzone.com", 16, 0, "v=spf1 a                                           -all"}, 
        {"21.spf1-test.mailzone.com",
      16, 0, "v=spf1   a:spf1-test.mailzone.com                            -all"}, 
        {"21.spf1-test.mailzone.com",
      1, 0, "192.0.2.121"}, 
        {"22.spf1-test.mailzone.com", 16, 0, "v=spf1 a a:spf1-test.mailzone.com                            -all"}, 
        {"22.spf1-test.mailzone.com",
      1, 0, "192.0.2.122"}, 
        {"30.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr                                         -all"}, 
        {"30.spf1-test.mailzone.com",
      1, 0, "208.210.124.130"}, 
        {"31.spf1-test.mailzone.com", 16, 0, "v=spf1     ptr:spf1-test.mailzone.com                        -all"}, 
        {"31.spf1-test.mailzone.com",
      1, 0, "208.210.124.131"}, 
        {"32.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr ptr:spf1-test.mailzone.com                        -all"}, 
        {"32.spf1-test.mailzone.com",
      1, 0, "208.210.124.132"}, 
        {"40.spf1-test.mailzone.com", 16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d}                    -all"}, 
        {"41.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.spf1-test.mailzone.com            -all"}, 
        {"42.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d} exists:%{ir}.%{v}._spf.%{d3} -all"}, 
        {"45.spf1-test.mailzone.com",
      16, 0, "v=spf1 -a a:spf1-test.mailzone.com                           -all"}, 
        {"45.spf1-test.mailzone.com",
      1, 0, "192.0.2.147"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.145"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.146"}, 
        {"50.spf1-test.mailzone.com", 16, 0, "v=spf1 include                                     -all"}, 
        {"51.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"52.spf1-test.mailzone.com", 16, 0, "v=spf1 include:53.spf1-test.mailzone.com                  -all"}, 
        {"53.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"54.spf1-test.mailzone.com", 16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"55.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:56.spf1-test.mailzone.com                  -all"}, 
        {"57.spf1-test.mailzone.com", 16, 0, "v=spf1 include:spf1-test.mailzone.com         -all"}, 
        {"58.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:59.spf1-test.mailzone.com                  -all"}, 
        {"59.spf1-test.mailzone.com", 16, 0, "v=spf1 include:58.spf1-test.mailzone.com                  -all"}, 
        {"70.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{lr+=}.lp._spf.spf1-test.mailzone.com -all"}, 
        {"80.spf1-test.mailzone.com", 16, 0, "v=spf1 a mx exists:%{ir}.%{v}._spf.80.spf1-test.mailzone.com ptr -all"}, 
        {"80.spf1-test.mailzone.com",
      1, 0, "208.210.124.180"}, 
        {"90.spf1-test.mailzone.com", 16, 0, "v=spf1  ip4:192.0.2.128/25 -all"}, 
        {"91.spf1-test.mailzone.com", 16, 0, "v=spf1 -ip4:192.0.2.128/25 ip4:192.0.2.0/24 -all"}, 
        {"92.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?ip4:192.0.2.192/26 ip4:192.0.2.128/25 -ip4:192.0.2.0/24 -all"}, 
        {"95.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -all"}, 
        {"96.spf1-test.mailzone.com", 16, 0, "v=spf1 -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"97.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"98.spf1-test.mailzone.com",
      16, 0, "v=spf1 a/26 mx/26 -all"}, 
        {"98.spf1-test.mailzone.com", 15, 0, "80.spf1-test.mailzone.com"}, 
        {"98.spf1-test.mailzone.com", 1, 0, "192.0.2.98"}, 
        {"99.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp=99txt.spf1-test.mailzone.com moo"}, 
        {"99txt.spf1-test.mailzone.com",
      16, 0, "u=%{u} s=%{s} d=%{d} t=%{t} h=%{h} i=%{i} %% U=%{U} S=%{S} D=%{D} T=%{T} H=%{H} I=%{I} %% moo"}, 
        {"100.spf1-test.mailzone.com",
      16, 0, "v=spf1      redirect=98.spf1-test.mailzone.com"}, 
        {"101.spf1-test.mailzone.com", 16, 0, "v=spf1 -all redirect=98.spf1-test.mailzone.com"}, 
        {"102.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?all redirect=98.spf1-test.mailzone.com"}, 
        {"103.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=98.%{d3}"}, 
        {"104.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=105.%{d3}"}, 
        {"105.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=106.%{d3}"}, 
        {"106.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=107.%{d3}"}, 
        {"107.spf1-test.mailzone.com", 16, 0, "v=spf1       include:104.%{d3}"}, 
        {"110.spf1-test.mailzone.com", 16, 0, "v=spf1 some:unrecognized=mechanism some=unrecognized:modifier -all"}, 
        {"111.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx -a gpg ~all exp=111txt.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"111txt.2.0.192.in-addr._spf.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"112.spf1-test.mailzone.com",
      16, 0, "v=spf1 a mp3 ~all"}, 
        {"112.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"113.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3: ~all"}, 
        {"113.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114.spf1-test.mailzone.com", 16, 0, "v=spf1 mx -a gpg=test ~all exp=114txt.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com",
      15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114txt.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"115.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3=yes -all"}, 
        {"115.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"116.spf1-test.mailzone.com", 16, 0, "v=spf1 redirect=116rdr.spf1-test.mailzone.com a"}, 
        {"116.spf1-test.mailzone.com",
      1, 0, "192.0.2.200"}, 
        {"116rdr.spf1-test.mailzone.com", 16, 0, "v=spf1 -all"}, 
        {"117.spf1-test.mailzone.com", 16, 0, " v=spf1 +all"}, 
        {"118.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp="}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.10"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.11"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.12"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.13"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.20"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.21"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.22"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.23"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.30"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.31"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.32"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.33"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.40"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.41"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.42"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.43"}, 
        {"56.spf1-test.mailzone.com", 16, 4, (char const   *)((void *)0)}, 
        {"80.spf1-test.mailzone.com", 15, 4, (char const   *)((void *)0)}, 
        {"servfail.spf1-test.mailzone.com", 16, 2, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 1, 0, "208.210.124.192"}, 
        {"spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"fallback-relay.spf1-test.mailzone.com", 15, 0, "mx04.spf1-test.mailzone.com"}, 
        {"www1.cnn.com",
      1, 0, "64.236.24.4"}, 
        {"4.24.236.64.in-addr.arpa", 12, 0, "www1.cnn.com"}, 
        {"130.124.210.208.in-addr.arpa", 12, 0, "30.spf1-test.mailzone.com"}, 
        {"131.124.210.208.in-addr.arpa", 12, 0, "31.spf1-test.mailzone.com"}, 
        {"192.124.210.208.in-addr.arpa", 12, 0, "spf1-test.mailzone.com"}, 
        {"100.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"110.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"111.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"101.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"130.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"131.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"80.2.0.192.in-addr._spf.80.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"96.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"97.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com",
      1, 0, "127.0.0.2"}, 
        {"bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"postmaster.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"2.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.joe.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"102.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"110.2.0.192.in-addr._spf.42.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"131.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"4.24.236.64.in-addr._spf.80.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"droid.lp._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"joe-2.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"moe-1.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"unknown.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"180.124.210.208.in-addr.arpa",
      12, 0, "80.spf1-test.mailzone.com"}, 
        {"80.spf1-test.mailzone.com.whitelist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.124.210.208.in-addr.arpa",
      12, 0, "pobox-gw.icgroup.com"}, 
        {"pobox-gw.icgroup.com", 1, 0, "208.210.124.1"}, 
        {"pobox-gw.icgroup.com.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com",
      16, 1, (char const   *)((void *)0)}, 
        {"spf.trusted-forwarder.org", 16, 0, "v=spf1 exists:%{ir}.wl.trusted-forwarder.org exists:%{p}.wl.trusted-forwarder.org"}, 
        {"*.spf1-text.mailzone.com",
      255, 1, (char const   *)((void *)0)}, 
        {"cat.com", 16, 4, (char const   *)((void *)0)}, 
        {"bar.com", 16, 4, (char const   *)((void *)0)}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}};
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 105 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 111
extern struct group *getgrnam(char const   *__name ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 298
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 301
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_destroy)(pthread_attr_t *__attr ) ;
#line 310
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                                                  int __detachstate ) ;
#line 195 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static SPF_server_t *spf_server  ;
#line 196 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static config_t spfd_config  ;
#line 197 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static state_t spfd_state  ;
#line 199 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void response_print_errors___1(char const   *context , SPF_response_t *spf_response ,
                                      SPF_errcode_t err ) 
{ 
  SPF_error_t *spf_error ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___2 ;
  char tmp___3 ;
  char const   *tmp___5 ;
  char tmp___6 ;
  int tmp___7 ;

  {
#line 206
  if ((unsigned long )context != (unsigned long )((void *)0)) {
    {
#line 207
    printf((char const   */* __restrict  */)"Context: %s\n", context);
    }
  }
#line 208
  if ((unsigned int )err != 0U) {
    {
#line 209
    tmp = SPF_strerror(err);
#line 209
    printf((char const   */* __restrict  */)"ErrorCode: (%d) %s\n", (unsigned int )err,
           tmp);
    }
  }
#line 211
  if ((unsigned long )spf_response != (unsigned long )((void *)0)) {
#line 212
    i = 0;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 212
      tmp___7 = SPF_response_messages(spf_response);
      }
#line 212
      if (! (i < tmp___7)) {
#line 212
        goto while_break;
      }
      {
#line 213
      spf_error = SPF_response_message(spf_response, i);
#line 214
      tmp___0 = SPF_error_message(spf_error);
#line 214
      tmp___3 = SPF_error_errorp(spf_error);
      }
#line 214
      if (tmp___3) {
#line 214
        if (! err) {
#line 214
          tmp___2 = "[UNRETURNED] ";
        } else {
#line 214
          tmp___2 = "";
        }
      } else {
#line 214
        tmp___2 = "";
      }
      {
#line 214
      tmp___6 = SPF_error_errorp(spf_error);
      }
#line 214
      if (tmp___6) {
#line 214
        tmp___5 = "Error";
      } else {
#line 214
        tmp___5 = "Warning";
      }
      {
#line 214
      printf((char const   */* __restrict  */)"%s: %s%s\n", tmp___5, tmp___2, tmp___0);
#line 212
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 223
    printf((char const   */* __restrict  */)"Error: libspf2 gave a NULL spf_response");
    }
  }
#line 225
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static char const   *request_check(request_t *req ) 
{ 
  char const   *msg ;

  {
#line 251
  msg = (char const   *)((void *)0);
#line 252
  if (! req->ip) {
#line 253
    msg = "No IP address given";
  } else
#line 254
  if (! req->sender) {
#line 255
    msg = "No sender address given";
  } else {
#line 257
    return ((char const   *)((void *)0));
  }
  {
#line 258
  snprintf((char */* __restrict  */)(req->fmt), (size_t )4095, (char const   */* __restrict  */)"result=unknown\nreason=%s\n",
           msg);
  }
#line 262
  return (msg);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void request_query(request_t *req ) 
{ 
  SPF_request_t *spf_request ;
  SPF_response_t *spf_response ;
  SPF_response_t *spf_response_2mx ;
  SPF_errcode_t err ;
  char *p ;
  char *p_end ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  SPF_result_t tmp___2 ;

  {
  {
#line 268
  spf_request = (SPF_request_t *)((void *)0);
#line 269
  spf_response = (SPF_response_t *)((void *)0);
#line 270
  spf_response_2mx = (SPF_response_t *)((void *)0);
#line 279
  spf_request = SPF_request_new(spf_server);
#line 281
  tmp = strchr((char const   *)req->ip, ':');
  }
#line 281
  if (tmp) {
    {
#line 282
    err = SPF_request_set_ipv6_str(spf_request, (char const   *)req->ip);
    }
#line 282
    if (err) {
      {
#line 283
      while (1) {
        while_continue: /* CIL Label */ ;
#line 283
        goto fail;
#line 283
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 287
    err = SPF_request_set_ipv4_str(spf_request, (char const   *)req->ip);
    }
#line 287
    if (err) {
      {
#line 288
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 288
        goto fail;
#line 288
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 292
  if (req->helo) {
    {
#line 293
    err = SPF_request_set_helo_dom(spf_request, (char const   *)req->helo);
    }
#line 293
    if (err) {
      {
#line 294
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 294
        goto fail;
#line 294
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 299
  if (req->sender) {
    {
#line 300
    tmp___0 = SPF_request_set_env_from(spf_request, (char const   *)req->sender);
#line 300
    err = (SPF_errcode_t )tmp___0;
    }
#line 300
    if (err) {
      {
#line 301
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 301
        goto fail;
#line 301
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 308
  err = SPF_request_query_mailfrom(spf_request, & spf_response);
  }
#line 308
  if (err) {
    {
#line 309
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 309
      goto fail;
#line 309
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 312
  if (spfd_config.sec_mx) {
#line 313
    if (req->rcpt_to) {
#line 313
      if (*(req->rcpt_to)) {
        {
#line 314
        p = req->rcpt_to;
#line 315
        tmp___1 = strcspn((char const   *)p, " ,;");
#line 315
        p_end = p + tmp___1;
        }
        {
#line 316
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 316
          tmp___2 = SPF_response_result(spf_response);
          }
#line 316
          if (! ((unsigned int )tmp___2 != 2U)) {
#line 316
            goto while_break___4;
          }
#line 317
          if (*p_end) {
#line 318
            *p_end = (char )'\000';
          } else {
#line 320
            p_end = (char *)((void *)0);
          }
          {
#line 321
          err = SPF_request_query_rcptto(spf_request, & spf_response_2mx, (char const   *)p);
          }
#line 321
          if (err) {
            {
#line 323
            response_print_errors___1("Failed to query based on 2mx recipient", spf_response_2mx,
                                      err);
            }
            {
#line 325
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 325
              if (spf_response_2mx) {
                {
#line 325
                SPF_response_free(spf_response_2mx);
                }
              }
#line 325
              spf_response_2mx = (SPF_response_t *)((void *)0);
#line 325
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
          } else {
            {
#line 328
            spf_response = SPF_response_combine(spf_response, spf_response_2mx);
#line 330
            spf_response_2mx = (SPF_response_t *)((void *)0);
            }
          }
#line 333
          if (! p_end) {
#line 334
            goto while_break___4;
          }
#line 335
          p = p_end + 1;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
  }
#line 340
  if (spfd_config.fallback) {
    {
#line 341
    err = SPF_request_query_fallback(spf_request, & spf_response, (char const   *)spfd_config.fallback);
    }
#line 341
    if (err) {
      {
#line 343
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 343
        goto fail;
#line 343
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
  }
#line 347
  goto ok;
  fail: 
#line 350
  req->spf_err = err;
  {
#line 351
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 351
    if (spf_response) {
      {
#line 351
      SPF_response_free(spf_response);
      }
    }
#line 351
    spf_response = (SPF_response_t *)((void *)0);
#line 351
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 352
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 352
    if (spf_request) {
      {
#line 352
      SPF_request_free(spf_request);
      }
    }
#line 352
    spf_request = (SPF_request_t *)((void *)0);
#line 352
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  ok: 
#line 358
  req->spf_response = spf_response;
#line 359
  req->spf_request = spf_request;
#line 360
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
__inline static char const   *W(char const   *c ) 
{ 


  {
#line 366
  if (c) {
#line 367
    return (c);
  }
#line 368
  return ("(null)");
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void request_format(request_t *req ) 
{ 
  SPF_response_t *spf_response ;
  SPF_errcode_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  SPF_reason_t tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  SPF_result_t tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
#line 376
  spf_response = req->spf_response;
#line 378
  if (spf_response) {
    {
#line 379
    tmp = SPF_response_errcode(spf_response);
#line 379
    tmp___0 = SPF_strerror(tmp);
#line 379
    tmp___1 = W(tmp___0);
#line 379
    tmp___2 = SPF_response_get_header_comment(spf_response);
#line 379
    tmp___3 = W(tmp___2);
#line 379
    tmp___4 = SPF_response_get_smtp_comment(spf_response);
#line 379
    tmp___5 = W(tmp___4);
#line 379
    tmp___6 = SPF_response_reason(spf_response);
#line 379
    tmp___7 = SPF_strreason(tmp___6);
#line 379
    tmp___8 = W(tmp___7);
#line 379
    tmp___9 = SPF_response_result(spf_response);
#line 379
    tmp___10 = SPF_strresult(tmp___9);
#line 379
    tmp___11 = W(tmp___10);
#line 379
    req->fmtlen = snprintf((char */* __restrict  */)(req->fmt), (size_t )4095, (char const   */* __restrict  */)"ip=%s\nsender=%s\nresult=%s\nreason=%s\nsmtp_comment=%s\nheader_comment=%s\nerror=%s\n",
                           req->ip, req->sender, tmp___11, tmp___8, tmp___5, tmp___3,
                           tmp___1);
    }
  } else {
    {
#line 396
    tmp___12 = SPF_strerror(req->spf_err);
#line 396
    req->fmtlen = snprintf((char */* __restrict  */)(req->fmt), (size_t )4095, (char const   */* __restrict  */)"ip=%s\nsender=%s\nresult=unknown\nerror=%s\n",
                           req->ip, req->sender, tmp___12);
    }
  }
#line 406
  req->fmt[4095] = (char )'\000';
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void request_handle(request_t *req ) 
{ 
  char const   *tmp ;

  {
  {
#line 412
  printf((char const   */* __restrict  */)"| %s\n", req->sender);
#line 412
  fflush(stdout);
#line 413
  tmp = request_check(req);
  }
#line 413
  if (! tmp) {
    {
#line 414
    request_query(req);
#line 415
    request_format(req);
    }
  }
#line 418
  return;
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static struct option  const  longopts[10]  = 
#line 420
  {      {"debug", 1, (int *)((void *)0), 'd'}, 
        {"tcpport", 1, (int *)((void *)0), 't'}, 
        {"udpport", 1, (int *)((void *)0), 'p'}, 
        {"path", 1, (int *)((void *)0), 'f'}, 
        {"pathuser", 1, (int *)((void *)0), 'x'}, 
        {"pathgroup", 1, (int *)((void *)0), 'y'}, 
        {"pathmode", 1, (int *)((void *)0), 'm'}, 
        {"setuser", 1, (int *)((void *)0), 'u'}, 
        {"setgroup", 1, (int *)((void *)0), 'g'}, 
        {"help", 0, (int *)((void *)0), 'h'}};
#line 441 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static char const   *shortopts  =    "d:t:p:f:x:y:m:u:g:h:";
#line 443 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
void usage(void) 
{ 


  {
  {
#line 444
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Flags\n");
#line 445
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-tcpport\n");
#line 446
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-udpport\n");
#line 447
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-path\n");
#line 449
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-pathuser\n");
#line 452
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-pathgroup\n");
#line 454
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-pathmode\n");
#line 456
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-setuser\n");
#line 459
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-setgroup\n");
#line 461
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-help\n");
  }
#line 463
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static gid_t daemon_get_user(char const   *arg ) 
{ 
  struct passwd *pwd ;
  long tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 472
  tmp___0 = __ctype_b_loc();
  }
#line 472
  if ((int const   )*(*tmp___0 + (int )*(arg + 0)) & 2048) {
    {
#line 473
    tmp = atol(arg);
#line 473
    pwd = getpwuid((__uid_t )tmp);
    }
  } else {
    {
#line 475
    pwd = getpwnam(arg);
    }
  }
#line 476
  if ((unsigned long )pwd == (unsigned long )((void *)0)) {
    {
#line 477
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to find user %s\n",
            arg);
    }
    {
#line 478
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 478
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Unknown user");
#line 478
      exit(1);
      }
#line 478
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 480
  return (pwd->pw_uid);
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static gid_t daemon_get_group(char const   *arg ) 
{ 
  struct group *grp ;
  long tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 489
  tmp___0 = __ctype_b_loc();
  }
#line 489
  if ((int const   )*(*tmp___0 + (int )*(arg + 0)) & 2048) {
    {
#line 490
    tmp = atol(arg);
#line 490
    grp = getgrgid((__gid_t )tmp);
    }
  } else {
    {
#line 492
    grp = getgrnam(arg);
    }
  }
#line 493
  if ((unsigned long )grp == (unsigned long )((void *)0)) {
    {
#line 494
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to find user %s\n",
            arg);
    }
    {
#line 495
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 495
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Unknown group");
#line 495
      exit(1);
      }
#line 495
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 497
  return (grp->gr_gid);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void daemon_config(int argc , char **argv ) 
{ 
  int idx ;
  char c ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 507
  memset((void *)(& spfd_config), 0, sizeof(spfd_config));
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 509
    tmp___3 = getopt_long(argc, (char * const  *)argv, shortopts, longopts, & idx);
#line 509
    c = (char )tmp___3;
    }
#line 509
    if (! ((int )c != -1)) {
#line 509
      goto while_break;
    }
    {
#line 513
    if ((int )c == 116) {
#line 513
      goto case_116;
    }
#line 516
    if ((int )c == 112) {
#line 516
      goto case_112;
    }
#line 519
    if ((int )c == 102) {
#line 519
      goto case_102;
    }
#line 523
    if ((int )c == 100) {
#line 523
      goto case_100;
    }
#line 528
    if ((int )c == 120) {
#line 528
      goto case_120;
    }
#line 533
    if ((int )c == 121) {
#line 533
      goto case_121;
    }
#line 538
    if ((int )c == 109) {
#line 538
      goto case_109;
    }
#line 543
    if ((int )c == 117) {
#line 543
      goto case_117;
    }
#line 548
    if ((int )c == 103) {
#line 548
      goto case_103;
    }
#line 554
    if ((int )c == 63) {
#line 554
      goto case_63;
    }
#line 554
    if ((int )c == 0) {
#line 554
      goto case_63;
    }
#line 558
    if ((int )c == 104) {
#line 558
      goto case_104;
    }
#line 563
    goto switch_default;
    case_116: /* CIL Label */ 
    {
#line 514
    tmp = atol((char const   *)optarg);
#line 514
    spfd_config.tcpport = (int )tmp;
    }
#line 515
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 517
    tmp___0 = atol((char const   *)optarg);
#line 517
    spfd_config.udpport = (int )tmp___0;
    }
#line 518
    goto switch_break;
    case_102: /* CIL Label */ 
#line 520
    spfd_config.path = optarg;
#line 521
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 524
    tmp___1 = atol((char const   *)optarg);
#line 524
    spfd_config.debug = (int )tmp___1;
    }
#line 525
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 529
    spfd_config.pathuser = daemon_get_user((char const   *)optarg);
    }
#line 530
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 534
    spfd_config.pathgroup = daemon_get_group((char const   *)optarg);
    }
#line 535
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 539
    tmp___2 = atol((char const   *)optarg);
#line 539
    spfd_config.pathmode = (int )tmp___2;
    }
#line 540
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 544
    spfd_config.setuser = daemon_get_user((char const   *)optarg);
    }
#line 545
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 549
    spfd_config.setgroup = daemon_get_group((char const   *)optarg);
    }
#line 550
    goto switch_break;
    case_63: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 555
    usage();
    }
    {
#line 556
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 556
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Invalid argument");
#line 556
      exit(1);
      }
#line 556
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 557
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 559
    usage();
    }
    {
#line 560
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 560
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "");
#line 560
      exit(1);
      }
#line 560
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 561
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 564
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: getopt returned character code 0%o ??\n",
            (int )c);
    }
    {
#line 565
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 565
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "WHAT?");
#line 565
      exit(1);
      }
#line 565
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  return;
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static int daemon_bind_inet_udp(void) 
{ 
  struct sockaddr_in addr ;
  int sock ;
  int tmp ;

  {
  {
#line 576
  sock = socket(2, 2, 0);
  }
#line 576
  if (sock < 0) {
    {
#line 577
    perror("socket");
    }
    {
#line 578
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 578
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to create socket");
#line 578
      exit(1);
      }
#line 578
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 580
  memset((void *)(& addr), 0, sizeof(addr));
#line 581
  addr.sin_family = (sa_family_t )2;
#line 582
  addr.sin_port = htons((uint16_t )spfd_config.udpport);
#line 583
  addr.sin_addr.s_addr = (in_addr_t )0;
#line 584
  tmp = bind(sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
             (socklen_t )sizeof(addr));
  }
#line 584
  if (tmp < 0) {
    {
#line 585
    perror("bind");
    }
    {
#line 586
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 586
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to bind socket");
#line 586
      exit(1);
      }
#line 586
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 589
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accepting datagrams on %d\n",
          spfd_config.udpport);
  }
#line 591
  return (sock);
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static int daemon_bind_inet_tcp(void) 
{ 
  struct sockaddr_in addr ;
  int sock ;
  int optval ;
  size_t optlen ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 603
  sock = socket(2, 1, 0);
  }
#line 603
  if (sock < 0) {
    {
#line 604
    perror("socket");
    }
    {
#line 605
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 605
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to create socket");
#line 605
      exit(1);
      }
#line 605
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 608
  optval = 1;
#line 609
  optlen = sizeof(int );
#line 610
  setsockopt(sock, 1, 2, (void const   *)(& optval), (socklen_t )optlen);
#line 612
  memset((void *)(& addr), 0, sizeof(addr));
#line 613
  addr.sin_family = (sa_family_t )2;
#line 614
  addr.sin_port = htons((uint16_t )spfd_config.tcpport);
#line 615
  addr.sin_addr.s_addr = (in_addr_t )0;
#line 616
  tmp = bind(sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
             (socklen_t )sizeof(addr));
  }
#line 616
  if (tmp < 0) {
    {
#line 617
    perror("bind");
    }
    {
#line 618
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 618
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to bind socket");
#line 618
      exit(1);
      }
#line 618
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 621
  tmp___0 = listen(sock, 5);
  }
#line 621
  if (tmp___0 < 0) {
    {
#line 622
    perror("listen");
    }
    {
#line 623
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 623
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to listen on socket");
#line 623
      exit(1);
      }
#line 623
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 626
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accepting connections on %d\n",
          spfd_config.tcpport);
  }
#line 628
  return (sock);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static int daemon_bind_unix(void) 
{ 
  struct sockaddr_un addr ;
  int sock ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 637
  sock = socket(1, 1, 0);
  }
#line 637
  if (sock < 0) {
    {
#line 638
    perror("socket");
    }
    {
#line 639
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 639
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to create socket");
#line 639
      exit(1);
      }
#line 639
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 641
  memset((void *)(& addr), 0, sizeof(addr));
#line 642
  addr.sun_family = (sa_family_t )1;
#line 643
  strncpy((char */* __restrict  */)(addr.sun_path), (char const   */* __restrict  */)spfd_config.path,
          sizeof(addr.sun_path) - 1UL);
#line 644
  tmp___0 = unlink((char const   *)spfd_config.path);
  }
#line 644
  if (tmp___0 < 0) {
    {
#line 645
    tmp = __errno_location();
    }
#line 645
    if (*tmp != 2) {
      {
#line 646
      perror("unlink");
      }
      {
#line 647
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 647
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                "Failed to unlink socket");
#line 647
        exit(1);
        }
#line 647
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 650
  tmp___1 = bind(sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
                 (socklen_t )sizeof(addr));
  }
#line 650
  if (tmp___1 < 0) {
    {
#line 651
    perror("bind");
    }
    {
#line 652
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 652
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to bind socket");
#line 652
      exit(1);
      }
#line 652
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 654
  tmp___2 = listen(sock, 5);
  }
#line 654
  if (tmp___2 < 0) {
    {
#line 655
    perror("listen");
    }
    {
#line 656
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 656
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to listen on socket");
#line 656
      exit(1);
      }
#line 656
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 659
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accepting connections on %s\n",
          spfd_config.path);
  }
#line 661
  return (sock);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void daemon_init(void) 
{ 
  SPF_response_t *spf_response ;
  SPF_errcode_t err ;

  {
  {
#line 667
  spf_response = (SPF_response_t *)((void *)0);
#line 670
  memset((void *)(& spfd_state), 0, sizeof(spfd_state));
#line 672
  spf_server = SPF_server_new((SPF_server_dnstype_t )1, spfd_config.debug);
  }
#line 674
  if (spfd_config.rec_dom) {
    {
#line 675
    err = SPF_server_set_rec_dom(spf_server, (char const   *)spfd_config.rec_dom);
    }
#line 675
    if (err) {
      {
#line 677
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 677
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                "Failed to set receiving domain name");
#line 677
        exit(1);
        }
#line 677
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 681
  if (spfd_config.sanitize) {
    {
#line 682
    err = SPF_server_set_sanitize(spf_server, spfd_config.sanitize);
    }
#line 682
    if (err) {
      {
#line 684
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 684
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                "Failed to set server sanitize flag");
#line 684
        exit(1);
        }
#line 684
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 688
  if (spfd_config.max_lookup) {
    {
#line 689
    err = SPF_server_set_max_dns_mech(spf_server, spfd_config.max_lookup);
    }
#line 689
    if (err) {
      {
#line 691
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 691
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                "Failed to set maximum DNS requests");
#line 691
        exit(1);
        }
#line 691
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 695
  if (spfd_config.localpolicy) {
    {
#line 696
    err = SPF_server_set_localpolicy(spf_server, (char const   *)spfd_config.localpolicy,
                                     spfd_config.use_trusted, & spf_response);
    }
#line 696
    if (err) {
      {
#line 700
      response_print_errors___1("Compiling local policy", spf_response, err);
      }
      {
#line 702
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 702
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                "Failed to set local policy");
#line 702
        exit(1);
        }
#line 702
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 704
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 704
      if (spf_response) {
        {
#line 704
        SPF_response_free(spf_response);
        }
      }
#line 704
      spf_response = (SPF_response_t *)((void *)0);
#line 704
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 707
  if (spfd_config.explanation) {
    {
#line 708
    err = SPF_server_set_explanation(spf_server, (char const   *)spfd_config.explanation,
                                     & spf_response);
    }
#line 708
    if (err) {
      {
#line 711
      response_print_errors___1("Setting default explanation", spf_response, err);
      }
      {
#line 713
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 713
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                "Failed to set default explanation");
#line 713
        exit(1);
        }
#line 713
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 715
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 715
      if (spf_response) {
        {
#line 715
        SPF_response_free(spf_response);
        }
      }
#line 715
      spf_response = (SPF_response_t *)((void *)0);
#line 715
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 718
  if (spfd_config.udpport) {
    {
#line 719
    spfd_state.sock_udp = daemon_bind_inet_udp();
    }
  }
#line 720
  if (spfd_config.tcpport) {
    {
#line 721
    spfd_state.sock_tcp = daemon_bind_inet_tcp();
    }
  }
#line 722
  if (spfd_config.path) {
    {
#line 723
    spfd_state.sock_unix = daemon_bind_unix();
    }
  }
#line 725
  return;
}
}
#line 729 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static char **find_field(request_t *req , char const   *key ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 734
  tmp = strcmp(key, "ip");
  }
#line 734
  if (tmp == 0) {
#line 735
    return (& req->ip);
  }
  {
#line 736
  tmp___0 = strcmp(key, "helo");
  }
#line 736
  if (tmp___0 == 0) {
#line 737
    return (& req->helo);
  }
  {
#line 738
  tmp___1 = strcmp(key, "sender");
  }
#line 738
  if (tmp___1 == 0) {
#line 739
    return (& req->sender);
  }
  {
#line 740
  tmp___2 = strcmp(key, "rcpt");
  }
#line 740
  if (tmp___2 == 0) {
#line 741
    return (& req->rcpt_to);
  }
  {
#line 742
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid key %s\n",
          key);
  }
#line 743
  return ((char **)((void *)0));
}
}
#line 747 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void *handle_datagram(void *arg ) 
{ 
  request_t *req ;
  char **fp ;
  char *key ;
  char *value ;
  char *end ;
  int err ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 757
  req = (request_t *)arg;
#line 758
  key = req->data;
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
#line 762
    if (! ((unsigned long )key < (unsigned long )(req->data + req->datalen))) {
#line 762
      goto while_break;
    }
    {
#line 763
    tmp = strcspn((char const   *)key, "\r\n");
#line 763
    end = key + tmp;
#line 764
    *end = (char )'\000';
#line 765
    value = strchr((char const   *)key, '=');
    }
#line 768
    if (! value) {
#line 769
      goto while_continue;
    }
    {
#line 771
    tmp___0 = value;
#line 771
    value ++;
#line 771
    *tmp___0 = (char )'\000';
#line 772
    fp = find_field(req, (char const   *)key);
    }
#line 773
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 774
      *fp = value;
    }
#line 778
    key = end + 1;
    {
#line 779
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 779
      if (! ((unsigned long )key < (unsigned long )(req->data + req->datalen))) {
#line 779
        goto while_break___0;
      }
      {
#line 780
      tmp___1 = strchr("\r\n", (int )*key);
      }
#line 780
      if (tmp___1) {
#line 781
        key ++;
      } else {
#line 783
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 787
  request_handle(req);
#line 795
  printf((char const   */* __restrict  */)"- %s\n", req->sender);
#line 795
  fflush(stdout);
#line 796
  tmp___2 = sendto(req->sock, (void const   *)(req->fmt), (size_t )req->fmtlen, 0,
                   (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& req->addr.in)),
                   req->addrlen);
#line 796
  err = (int )tmp___2;
  }
#line 798
  if (err == -1) {
    {
#line 799
    perror("sendto");
    }
  }
  {
#line 801
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 801
    if (req->spf_response) {
      {
#line 801
      SPF_response_free(req->spf_response);
      }
    }
#line 801
    req->spf_response = (SPF_response_t *)((void *)0);
#line 801
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 802
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 802
    if (req->spf_request) {
      {
#line 802
      SPF_request_free(req->spf_request);
      }
    }
#line 802
    req->spf_request = (SPF_request_t *)((void *)0);
#line 802
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 804
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 804
    if (req->data) {
      {
#line 804
      free((void *)req->data);
      }
    }
#line 804
    req->data = (char *)((void *)0);
#line 804
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 805
  free(arg);
  }
#line 806
  return ((void *)0);
}
}
#line 810 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void *handle_stream(void *arg ) 
{ 
  request_t *req ;
  char **fp ;
  FILE *stream ;
  char key[8192] ;
  char *value ;
  char *end ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 820
  req = (request_t *)arg;
#line 821
  stream = fdopen(req->sock, "r");
  }
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 824
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 824
      tmp___2 = fgets((char */* __restrict  */)(key), 8192, (FILE */* __restrict  */)stream);
      }
#line 824
      if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 824
        goto while_break___0;
      }
      {
#line 825
      tmp = strcspn((char const   *)(key), "\r\n");
#line 825
      key[tmp] = (char )'\000';
      }
#line 828
      if ((int )key[0] == 0) {
#line 829
        goto while_break___0;
      }
      {
#line 831
      tmp___0 = strcspn((char const   *)(key), "\r\n");
#line 831
      end = key + tmp___0;
#line 832
      *end = (char )'\000';
#line 833
      value = strchr((char const   *)(key), '=');
      }
#line 835
      if (! value) {
#line 836
        goto while_continue___0;
      }
      {
#line 838
      tmp___1 = value;
#line 838
      value ++;
#line 838
      *tmp___1 = (char )'\000';
#line 839
      fp = find_field(req, (char const   *)(key));
      }
#line 840
      if ((unsigned long )fp != (unsigned long )((void *)0)) {
        {
#line 841
        *fp = strdup((char const   *)value);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 846
    request_handle(req);
#line 848
    printf((char const   */* __restrict  */)"- %s\n", req->sender);
#line 848
    fflush(stdout);
#line 849
    send(req->sock, (void const   *)(req->fmt), (size_t )req->fmtlen, 0);
    }
    {
#line 851
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 851
      if (req->ip) {
        {
#line 851
        free((void *)req->ip);
        }
      }
#line 851
      req->ip = (char *)((void *)0);
#line 851
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 852
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 852
      if (req->helo) {
        {
#line 852
        free((void *)req->helo);
        }
      }
#line 852
      req->helo = (char *)((void *)0);
#line 852
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 853
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 853
      if (req->sender) {
        {
#line 853
        free((void *)req->sender);
        }
      }
#line 853
      req->sender = (char *)((void *)0);
#line 853
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 854
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 854
      if (req->rcpt_to) {
        {
#line 854
        free((void *)req->rcpt_to);
        }
      }
#line 854
      req->rcpt_to = (char *)((void *)0);
#line 854
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 823
    tmp___3 = feof(stream);
    }
#line 823
    if (tmp___3) {
#line 823
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 857
  free(arg);
  }
#line 858
  return ((void *)0);
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void daemon_main(void) 
{ 
  pthread_attr_t attr ;
  pthread_t th ;
  request_t *req ;
  char buf[4096] ;
  fd_set rfd ;
  fd_set sfd ;
  int maxfd ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 874
  pthread_attr_init(& attr);
#line 875
  pthread_attr_setdetachstate(& attr, 1);
  }
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfd.fds_bits[0]): "memory");
#line 877
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 878
  maxfd = 0;
#line 880
  if (spfd_state.sock_udp) {
#line 882
    rfd.fds_bits[spfd_state.sock_udp / (8 * (int )sizeof(__fd_mask ))] |= 1L << spfd_state.sock_udp % (8 * (int )sizeof(__fd_mask ));
#line 883
    if (spfd_state.sock_udp > maxfd) {
#line 884
      maxfd = spfd_state.sock_udp;
    }
  }
#line 886
  if (spfd_state.sock_tcp) {
#line 888
    rfd.fds_bits[spfd_state.sock_tcp / (8 * (int )sizeof(__fd_mask ))] |= 1L << spfd_state.sock_tcp % (8 * (int )sizeof(__fd_mask ));
#line 889
    if (spfd_state.sock_tcp > maxfd) {
#line 890
      maxfd = spfd_state.sock_tcp;
    }
  }
#line 892
  if (spfd_state.sock_unix) {
#line 894
    rfd.fds_bits[spfd_state.sock_unix / (8 * (int )sizeof(__fd_mask ))] |= 1L << spfd_state.sock_unix % (8 * (int )sizeof(__fd_mask ));
#line 895
    if (spfd_state.sock_unix > maxfd) {
#line 896
      maxfd = spfd_state.sock_unix;
    }
  }
  {
#line 902
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 903
    memcpy((void */* __restrict  */)(& sfd), (void const   */* __restrict  */)(& rfd),
           sizeof(rfd));
#line 904
    tmp = select(maxfd + 1, (fd_set */* __restrict  */)(& sfd), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 904
    if (tmp == -1) {
#line 905
      goto while_break___0;
    }
#line 907
    if (spfd_state.sock_udp) {
#line 908
      if ((sfd.fds_bits[spfd_state.sock_udp / (8 * (int )sizeof(__fd_mask ))] & (1L << spfd_state.sock_udp % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 909
        tmp___0 = calloc((size_t )1, sizeof(request_t ));
#line 909
        req = (request_t *)tmp___0;
#line 910
        req->addrlen = (socklen_t )sizeof(req->addr);
#line 912
        req->sock = spfd_state.sock_udp;
#line 913
        tmp___1 = recvfrom(spfd_state.sock_udp, (void */* __restrict  */)(buf), (size_t )4095,
                           0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& req->addr.in)),
                           (socklen_t */* __restrict  */)(& req->addrlen));
#line 913
        req->datalen = (int )tmp___1;
        }
#line 915
        if (req->datalen >= 0) {
          {
#line 916
          buf[req->datalen] = (char )'\000';
#line 917
          req->data = strdup((char const   *)(buf));
#line 918
          pthread_create((pthread_t */* __restrict  */)(& th), (pthread_attr_t const   */* __restrict  */)(& attr),
                         & handle_datagram, (void */* __restrict  */)req);
          }
        } else {
          {
#line 921
          free((void *)req);
          }
        }
      }
    }
#line 925
    if (spfd_state.sock_tcp) {
#line 926
      if ((sfd.fds_bits[spfd_state.sock_tcp / (8 * (int )sizeof(__fd_mask ))] & (1L << spfd_state.sock_tcp % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 927
        tmp___2 = calloc((size_t )1, sizeof(request_t ));
#line 927
        req = (request_t *)tmp___2;
#line 928
        req->addrlen = (socklen_t )sizeof(req->addr);
#line 930
        req->sock = accept(spfd_state.sock_tcp, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& req->addr.in)),
                           (socklen_t */* __restrict  */)(& req->addrlen));
        }
#line 932
        if (req->sock >= 0) {
          {
#line 933
          pthread_create((pthread_t */* __restrict  */)(& th), (pthread_attr_t const   */* __restrict  */)(& attr),
                         & handle_stream, (void */* __restrict  */)req);
          }
        } else {
          {
#line 935
          free((void *)req);
          }
        }
      }
    }
#line 938
    if (spfd_state.sock_unix) {
#line 939
      if ((sfd.fds_bits[spfd_state.sock_unix / (8 * (int )sizeof(__fd_mask ))] & (1L << spfd_state.sock_unix % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 940
        tmp___3 = calloc((size_t )1, sizeof(request_t ));
#line 940
        req = (request_t *)tmp___3;
#line 941
        req->addrlen = (socklen_t )sizeof(req->addr);
#line 943
        req->sock = accept(spfd_state.sock_unix, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& req->addr.un)),
                           (socklen_t */* __restrict  */)(& req->addrlen));
        }
#line 945
        if (req->sock >= 0) {
          {
#line 946
          pthread_create((pthread_t */* __restrict  */)(& th), (pthread_attr_t const   */* __restrict  */)(& attr),
                         & handle_stream, (void */* __restrict  */)req);
          }
        } else {
          {
#line 948
          free((void *)req);
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 953
  pthread_attr_destroy(& attr);
  }
#line 954
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static SPF_dns_rr_t *SPF_dns_null_lookup___1(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_rr_t *tmp ;
  SPF_dns_rr_t *tmp___0 ;

  {
#line 45
  if (spf_dns_server->layer_below) {
    {
#line 46
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 46
    return (tmp);
  }
  {
#line 48
  tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
  }
#line 48
  return (tmp___0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static void SPF_dns_null_free___1(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 54
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c",
                 54, "%s", "spf_dns_server is NULL");
      }
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  free((void *)spf_dns_server);
  }
#line 56
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_explanation___1(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  char *buf ;
  size_t buflen ;
  void *tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 53
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 53, "%s", "spf_response is NULL");
      }
    }
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  spf_request = spf_response->spf_request;
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 55
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 55, "%s", "spf_request is NULL");
      }
    }
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  spf_server___1 = spf_request->spf_server;
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 57
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 57
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 57, "%s", "spf_server is NULL");
      }
    }
#line 57
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  spf_record = spf_response->spf_record_exp;
  {
#line 60
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 60
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 60
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 60, "%s", "spf_record is NULL");
      }
    }
#line 60
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 62
  if (spf_response->explanation) {
    {
#line 63
    free((void *)spf_response->explanation);
    }
  }
  {
#line 64
  spf_response->explanation = (char *)((void *)0);
#line 66
  buflen = (size_t )321;
#line 67
  tmp = malloc(buflen);
#line 67
  buf = (char *)tmp;
  }
#line 68
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 69
    return ((SPF_errcode_t )1);
  }
  {
#line 70
  memset((void *)buf, '\000', buflen);
#line 72
  err = SPF_request_get_exp(spf_server___1, spf_request, spf_response, spf_record,
                            & buf, & buflen);
  }
#line 74
  if ((unsigned int )err != 0U) {
    {
#line 75
    free((void *)buf);
    }
#line 76
    return (err);
  }
#line 79
  spf_response->explanation = buf;
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_smtp_comment___1(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_errcode_t err ;
  char buf[320] ;
  char const   *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 92
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 92, "%s", "spf_response is NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  spf_request = spf_response->spf_request;
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 94, "%s", "spf_request is NULL");
      }
    }
#line 94
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  spf_server___1 = spf_request->spf_server;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 96, "%s", "spf_server is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  if (spf_response->smtp_comment) {
    {
#line 99
    free((void *)spf_response->smtp_comment);
    }
  }
#line 100
  spf_response->smtp_comment = (char *)((void *)0);
  {
#line 107
  if ((unsigned int )spf_response->result == 5U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 1U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 4U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 3U) {
#line 107
    goto case_5;
  }
#line 129
  goto switch_default;
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 109
  err = SPF_i_set_explanation___1(spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
#line 111
    return (err);
  }
  {
#line 113
  memset((void *)(buf), '\000', sizeof(buf));
#line 114
  tmp = SPF_strreason(spf_response->reason);
#line 114
  snprintf((char */* __restrict  */)(buf), (size_t )320, (char const   */* __restrict  */)"%s : Reason: %s",
           spf_response->explanation, tmp);
#line 117
  buf[319] = (char )'\000';
#line 120
  spf_response->smtp_comment = strdup((char const   *)(buf));
  }
#line 121
  if (! spf_response->smtp_comment) {
#line 122
    return ((SPF_errcode_t )1);
  }
#line 124
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 130
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 133
  return ((SPF_errcode_t )0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_header_comment___1(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char *spf_source ;
  size_t len ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  char *sender_dom ;
  char *p ;
  char *p_end ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 153
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 153, "%s", "spf_response is NULL");
      }
    }
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  spf_request = spf_response->spf_request;
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 155
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 155, "%s", "spf_request is NULL");
      }
    }
#line 155
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 156
  spf_server___1 = spf_request->spf_server;
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 157
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 157, "%s", "spf_server is NULL");
      }
    }
#line 157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 159
  if (spf_response->header_comment) {
    {
#line 160
    free((void *)spf_response->header_comment);
    }
  }
#line 161
  spf_response->header_comment = (char *)((void *)0);
#line 164
  sender_dom = spf_request->env_from_dp;
#line 165
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
#line 166
    sender_dom = spf_request->helo_dom;
  }
#line 168
  if ((unsigned int )spf_response->reason == 3U) {
    {
#line 169
    spf_source = strdup("local policy");
    }
  } else
#line 171
  if ((unsigned int )spf_response->reason == 6U) {
#line 172
    if ((unsigned long )spf_request->rcpt_to_dom == (unsigned long )((void *)0)) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    } else
#line 172
    if ((int )*(spf_request->rcpt_to_dom + 0) == 0) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    }
    {
#line 175
    spf_source = strdup((char const   *)spf_request->rcpt_to_dom);
    }
  } else
#line 177
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
    {
#line 178
    spf_source = strdup("unknown domain");
    }
  } else {
    {
#line 181
    tmp = strlen((char const   *)sender_dom);
#line 181
    len = tmp + sizeof("domain of ");
#line 182
    tmp___0 = malloc(len);
#line 182
    spf_source = (char *)tmp___0;
    }
#line 183
    if (spf_source) {
      {
#line 184
      snprintf((char */* __restrict  */)spf_source, len, (char const   */* __restrict  */)"domain of %s",
               sender_dom);
      }
    }
  }
#line 187
  if ((unsigned long )spf_source == (unsigned long )((void *)0)) {
#line 188
    return ((SPF_errcode_t )10);
  }
#line 190
  ip = (char const   *)((void *)0);
#line 191
  if (spf_request->client_ver == 2) {
    {
#line 192
    ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                   (socklen_t )sizeof(ip4_buf));
    }
  } else
#line 195
  if (spf_request->client_ver == 10) {
    {
#line 196
    ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                   (socklen_t )sizeof(ip6_buf));
    }
  }
#line 199
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 200
    ip = "(unknown ip address)";
  }
  {
#line 202
  tmp___1 = SPF_request_get_rec_dom(spf_request);
#line 202
  tmp___2 = strlen(tmp___1);
#line 202
  tmp___3 = strlen((char const   *)spf_source);
#line 202
  tmp___4 = strlen(ip);
#line 202
  len = ((tmp___2 + tmp___3) + tmp___4) + 80UL;
#line 203
  tmp___5 = malloc(len);
#line 203
  buf = (char *)tmp___5;
  }
#line 204
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 205
    free((void *)spf_source);
    }
#line 206
    return ((SPF_errcode_t )10);
  }
  {
#line 209
  p = buf;
#line 210
  p_end = p + len;
#line 213
  tmp___6 = SPF_request_get_rec_dom(spf_request);
#line 213
  tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s: ",
                     tmp___6);
#line 213
  p += tmp___7;
  }
  {
#line 217
  if ((unsigned int )spf_response->result == 2U) {
#line 217
    goto case_2;
  }
#line 228
  if ((unsigned int )spf_response->result == 3U) {
#line 228
    goto case_3;
  }
#line 233
  if ((unsigned int )spf_response->result == 4U) {
#line 233
    goto case_4;
  }
#line 238
  if ((unsigned int )spf_response->result == 7U) {
#line 238
    goto case_7;
  }
#line 243
  if ((unsigned int )spf_response->result == 1U) {
#line 243
    goto case_1;
  }
#line 247
  if ((unsigned int )spf_response->result == 5U) {
#line 247
    goto case_5;
  }
#line 252
  if ((unsigned int )spf_response->result == 6U) {
#line 252
    goto case_6;
  }
#line 258
  goto switch_default;
  case_2: /* CIL Label */ 
#line 218
  if ((unsigned int )spf_response->reason == 2U) {
    {
#line 219
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"localhost is always allowed.");
    }
  } else
#line 220
  if ((unsigned int )spf_response->reason == 6U) {
    {
#line 221
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"message received from %s which is an MX secondary for %s.",
             ip, spf_source);
    }
  } else {
    {
#line 224
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s designates %s as permitted sender",
             spf_source, ip);
    }
  }
#line 226
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 229
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 231
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 234
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"transitioning %s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 236
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 239
  tmp___8 = SPF_strerror(spf_response->err);
#line 239
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error in processing during lookup of %s: %s",
           spf_source, tmp___8);
  }
#line 241
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 244
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s is neither permitted nor denied by %s",
           ip, spf_source);
  }
#line 246
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 248
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not provide an SPF record",
           spf_source);
  }
#line 250
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 253
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"encountered temporary error during SPF processing of %s",
           spf_source);
  }
#line 255
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 259
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error: unknown SPF result %d encountered while checking %s for %s",
           (unsigned int )spf_response->result, ip, spf_source);
  }
#line 261
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 264
  if (spf_source) {
    {
#line 265
    free((void *)spf_source);
    }
  }
  {
#line 267
  spf_response->header_comment = SPF_sanitize(spf_server___1, buf);
  }
#line 269
  return ((SPF_errcode_t )0);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_received_spf___1(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  size_t buflen ;
  char *buf_value ;
  char *p ;
  char *p_end ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 282
  buflen = (size_t )480;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 287
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 287, "%s", "spf_response is NULL");
      }
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  spf_request = spf_response->spf_request;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 289
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 289, "%s", "spf_request is NULL");
      }
    }
#line 289
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  spf_server___1 = spf_request->spf_server;
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 291
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 291
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 291, "%s", "spf_server is NULL");
      }
    }
#line 291
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 293
  if (spf_response->received_spf) {
    {
#line 294
    free((void *)spf_response->received_spf);
    }
  }
  {
#line 295
  spf_response->received_spf = (char *)((void *)0);
#line 297
  tmp = malloc(buflen);
#line 297
  buf = (char *)tmp;
  }
#line 298
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 299
    return ((SPF_errcode_t )10);
  }
  {
#line 301
  p = buf;
#line 302
  p_end = p + buflen;
#line 306
  tmp___0 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"Received-SPF: ");
#line 306
  p += tmp___0;
#line 307
  buf_value = p;
  }
  {
#line 309
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 310
    tmp___1 = SPF_strresult(spf_response->result);
#line 310
    tmp___2 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s (%s)",
                       tmp___1, spf_response->header_comment);
#line 310
    p += tmp___2;
    }
#line 313
    if (p_end - p <= 0L) {
#line 313
      goto while_break___2;
    }
#line 318
    ip = (char const   *)((void *)0);
#line 319
    if (spf_request->client_ver == 2) {
      {
#line 320
      ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                     (socklen_t )sizeof(ip4_buf));
      }
    } else
#line 323
    if (spf_request->client_ver == 10) {
      {
#line 324
      ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                     (socklen_t )sizeof(ip6_buf));
      }
    }
#line 328
    if ((unsigned long )ip != (unsigned long )((void *)0)) {
      {
#line 329
      tmp___3 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" client-ip=%s;",
                         ip);
#line 329
      p += tmp___3;
      }
#line 330
      if (p_end - p <= 0L) {
#line 330
        goto while_break___2;
      }
    }
#line 335
    if ((unsigned long )spf_request->env_from != (unsigned long )((void *)0)) {
      {
#line 336
      tmp___4 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" envelope-from=%s;",
                         spf_request->env_from);
#line 336
      p += tmp___4;
      }
#line 337
      if (p_end - p <= 0L) {
#line 337
        goto while_break___2;
      }
    }
#line 342
    if ((unsigned long )spf_request->helo_dom != (unsigned long )((void *)0)) {
      {
#line 343
      tmp___5 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" helo=%s;",
                         spf_request->helo_dom);
#line 343
      p += tmp___5;
      }
#line 344
      if (p_end - p <= 0L) {
#line 344
        goto while_break___2;
      }
    }
#line 309
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 366
  spf_response->received_spf = SPF_sanitize(spf_server___1, buf);
#line 367
  spf_response->received_spf_value = buf_value;
  }
#line 369
  return ((SPF_errcode_t )0);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_mech_cidr___1(SPF_request_t *spf_request , SPF_mech_t *mech ) 
{ 
  SPF_data_t *data ;
  SPF_data_t *tmp ;

  {
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if ((unsigned long )mech == (unsigned long )((void *)0)) {
      {
#line 428
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 428, "%s", "mech is NULL");
      }
    }
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  if ((int )mech->mech_type == 6) {
#line 433
    goto case_6;
  }
#line 433
  if ((int )mech->mech_type == 5) {
#line 433
    goto case_6;
  }
#line 438
  if ((int )mech->mech_type == 2) {
#line 438
    goto case_2;
  }
#line 438
  if ((int )mech->mech_type == 1) {
#line 438
    goto case_2;
  }
#line 430
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 434
  return ((int )mech->mech_len);
#line 435
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 439
  data = SPF_mech_data(mech);
#line 441
  tmp = SPF_mech_end_data(mech);
  }
#line 441
  if ((unsigned long )data < (unsigned long )tmp) {
#line 441
    if ((int )data->dc.parm_type == 11) {
#line 444
      if (spf_request->client_ver == 2) {
#line 445
        return ((int )data->dc.ipv4);
      } else
#line 446
      if (spf_request->client_ver == 10) {
#line 447
        return ((int )data->dc.ipv6);
      }
    }
  }
#line 449
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 452
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip4___1(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in_addr ipv4 ) 
{ 
  char src_ip4_buf[16] ;
  char dst_ip4_buf[16] ;
  char mask_ip4_buf[16] ;
  struct in_addr src_ipv4 ;
  int cidr ;
  int mask ;
  uint32_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 471
  if (spf_request->client_ver != 2) {
#line 472
    return (0);
  }
  {
#line 474
  src_ipv4 = spf_request->ipv4;
#line 476
  cidr = SPF_i_mech_cidr___1(spf_request, mech);
  }
#line 477
  if (cidr == 0) {
#line 478
    cidr = 32;
  }
  {
#line 479
  mask = (int )(4294967295U << (32 - cidr));
#line 480
  tmp = htonl((uint32_t )mask);
#line 480
  mask = (int )tmp;
  }
#line 482
  if (spf_server___1->debug) {
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 483
      tmp___0 = inet_ntop(2, (void const   */* __restrict  */)(& src_ipv4.s_addr),
                          (char */* __restrict  */)(src_ip4_buf), (socklen_t )sizeof(src_ip4_buf));
      }
#line 483
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 483
        snprintf((char */* __restrict  */)(src_ip4_buf), sizeof(src_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 483
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 485
      tmp___1 = inet_ntop(2, (void const   */* __restrict  */)(& ipv4.s_addr), (char */* __restrict  */)(dst_ip4_buf),
                          (socklen_t )sizeof(dst_ip4_buf));
      }
#line 485
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 485
        snprintf((char */* __restrict  */)(dst_ip4_buf), sizeof(dst_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 487
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 487
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& mask), (char */* __restrict  */)(mask_ip4_buf),
                          (socklen_t )sizeof(mask_ip4_buf));
      }
#line 487
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
#line 487
        snprintf((char */* __restrict  */)(mask_ip4_buf), sizeof(mask_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 487
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 489
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               491, "ip_match:  %s == %s  (/%d %s):  %d", src_ip4_buf, dst_ip4_buf,
               cidr, mask_ip4_buf, (src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
    }
  }
#line 494
  return ((src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip6___1(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in6_addr ipv6 ) 
{ 
  char src_ip6_buf[46] ;
  char dst_ip6_buf[46] ;
  struct in6_addr src_ipv6 ;
  int cidr ;
  int cidr_save ;
  int mask ;
  int i ;
  int match ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 512
  if (spf_request->client_ver != 10) {
#line 513
    return (0);
  }
  {
#line 515
  src_ipv6 = spf_request->ipv6;
#line 517
  cidr = SPF_i_mech_cidr___1(spf_request, mech);
  }
#line 518
  if (cidr == 0) {
#line 519
    cidr = 128;
  }
#line 520
  cidr_save = cidr;
#line 522
  match = 1;
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if ((long )i < (long )(sizeof(ipv6.__in6_u.__u6_addr8) / sizeof(ipv6.__in6_u.__u6_addr8[0]))) {
#line 523
      if (! match) {
#line 523
        goto while_break;
      }
    } else {
#line 523
      goto while_break;
    }
#line 525
    if (cidr > 8) {
#line 526
      mask = 255;
    } else
#line 527
    if (cidr > 0) {
#line 528
      mask = (255 << (8 - cidr)) & 255;
    } else {
#line 530
      goto while_break;
    }
#line 531
    cidr -= 8;
#line 533
    match = ((int )src_ipv6.__in6_u.__u6_addr8[i] & mask) == ((int )ipv6.__in6_u.__u6_addr8[i] & mask);
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (spf_server___1->debug) {
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 537
      tmp = inet_ntop(10, (void const   */* __restrict  */)(& src_ipv6.__in6_u.__u6_addr8),
                      (char */* __restrict  */)(src_ip6_buf), (socklen_t )sizeof(src_ip6_buf));
      }
#line 537
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 537
        snprintf((char */* __restrict  */)(src_ip6_buf), sizeof(src_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 537
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 539
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 539
      tmp___0 = inet_ntop(10, (void const   */* __restrict  */)(& ipv6.__in6_u.__u6_addr8),
                          (char */* __restrict  */)(dst_ip6_buf), (socklen_t )sizeof(dst_ip6_buf));
      }
#line 539
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 539
        snprintf((char */* __restrict  */)(dst_ip6_buf), sizeof(dst_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 539
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 541
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               542, "ip_match:  %s == %s  (/%d):  %d", src_ip6_buf, dst_ip6_buf, cidr_save,
               match);
    }
  }
#line 545
  return (match);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_domain___1(SPF_server_t *spf_server___1 , char const   *hostname ,
                                  char const   *domain ) 
{ 
  char const   *hp ;
  size_t hlen ;
  size_t dlen ;
  int tmp ;
  int tmp___0 ;

  {
#line 556
  if (spf_server___1->debug) {
    {
#line 557
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               557, "%s ?=? %s", hostname, domain);
    }
  }
  {
#line 559
  hlen = strlen(hostname);
#line 560
  dlen = strlen(domain);
  }
#line 563
  if (dlen > hlen) {
#line 564
    return (0);
  }
#line 567
  if (dlen == hlen) {
    {
#line 568
    tmp = strcasecmp(hostname, domain);
    }
#line 568
    return (tmp == 0);
  }
#line 571
  hp = hostname + (hlen - dlen);
#line 573
  if ((int const   )*(hp - 1) != 46) {
#line 574
    return (0);
  }
  {
#line 576
  tmp___0 = strcasecmp(hp, domain);
  }
#line 576
  return (tmp___0 == 0);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   spf_mechtypes___1[10]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
  {      {(unsigned char)0, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)1, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)2, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)3, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )0}, 
        {(unsigned char)4, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)5, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)6, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)7, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)8, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)9, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}};
#line 94 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   *SPF_mechtype_find___1(int mech_type ) 
{ 
  size_t i ;

  {
#line 98
  i = (size_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < sizeof(spf_mechtypes___1) / sizeof(spf_mechtypes___1[0]))) {
#line 98
      goto while_break;
    }
#line 99
    if ((int const   )spf_mechtypes___1[i].mech_type == (int const   )mech_type) {
#line 100
      return (& spf_mechtypes___1[i]);
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((SPF_mechtype_t const   *)((void *)0));
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static int ( __attribute__((__warn_unused_result__)) SPF_c_ensure_capacity___1)(void **datap ,
                                                                                size_t *sizep ,
                                                                                size_t length ) 
{ 
  size_t size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 109
  size = *sizep;
#line 110
  if (length > size) {
#line 111
    size = length + length / 4UL;
  }
#line 112
  if (size > *sizep) {
    {
#line 113
    tmp___0 = realloc(*datap, size);
#line 113
    tmp = tmp___0;
    }
#line 114
    if (! tmp) {
#line 115
      return (-1);
    }
#line 117
    *datap = tmp;
#line 118
    *sizep = size;
  }
#line 120
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip6___1(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 144
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 144
  mask = (int )tmp;
  }
#line 146
  if (mask > 128) {
    {
#line 147
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (>128)");
    }
#line 147
    return (tmp___0);
  } else
#line 151
  if (mask == 0) {
    {
#line 152
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (=0)");
    }
#line 152
    return (tmp___1);
  } else
#line 156
  if (mask == 128) {
#line 157
    mask = 0;
  }
#line 160
  *maskp = (unsigned char )mask;
#line 162
  return ((SPF_errcode_t )0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip4___1(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 186
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 186
  mask = (int )tmp;
  }
#line 188
  if (mask > 32) {
    {
#line 189
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (>32)");
    }
#line 189
    return (tmp___0);
  } else
#line 193
  if (mask == 0) {
    {
#line 194
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (=0)");
    }
#line 194
    return (tmp___1);
  } else
#line 198
  if (mask == 32) {
#line 199
    mask = 0;
  }
#line 202
  *maskp = (unsigned char )mask;
#line 204
  return ((SPF_errcode_t )0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr___1(SPF_response_t *spf_response , SPF_data_cidr_t *data ,
                                          char const   *src , size_t *src_len ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 220
  memset((void *)data, 0, sizeof(SPF_data_cidr_t ));
#line 221
  data->parm_type = (unsigned char)11;
#line 227
  idx = *src_len - 1UL;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (idx > 0UL) {
      {
#line 228
      tmp = __ctype_b_loc();
      }
#line 228
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 228
        goto while_break;
      }
    } else {
#line 228
      goto while_break;
    }
#line 229
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (idx < *src_len - 1UL) {
#line 236
    if ((int const   )*(src + idx) == 47) {
#line 237
      if (idx > 0UL) {
#line 237
        if ((int const   )*(src + (idx - 1UL)) == 47) {
          {
#line 239
          err = SPF_c_parse_cidr_ip6___1(spf_response, & data->ipv6, src + idx);
          }
#line 240
          if (err) {
#line 241
            return (err);
          }
#line 243
          *src_len = idx - 1UL;
#line 244
          idx = *src_len - 1UL;
          {
#line 245
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 245
            if (idx > 0UL) {
              {
#line 245
              tmp___0 = __ctype_b_loc();
              }
#line 245
              if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 245
                goto while_break___0;
              }
            } else {
#line 245
              goto while_break___0;
            }
#line 246
            idx --;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 249
          if (idx < *src_len - 1UL) {
#line 249
            if ((int const   )*(src + idx) == 47) {
              {
#line 253
              err = SPF_c_parse_cidr_ip4___1(spf_response, & data->ipv4, src + idx);
              }
#line 254
              if (err) {
#line 255
                return (err);
              }
#line 256
              *src_len = idx;
            }
          }
        } else {
#line 237
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 261
        err = SPF_c_parse_cidr_ip4___1(spf_response, & data->ipv4, src + idx);
        }
#line 262
        if (err) {
#line 263
          return (err);
        }
#line 264
        *src_len = idx;
      }
    }
  }
#line 268
  return ((SPF_errcode_t )0);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_var___1(SPF_response_t *spf_response , SPF_data_var_t *data ,
                                         char const   *src , int is_mod ) 
{ 
  char const   *token ;
  char const   *p ;
  char c ;
  int val ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;
  SPF_errcode_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  SPF_errcode_t tmp___6 ;
  SPF_errcode_t tmp___7 ;

  {
  {
#line 280
  memset((void *)data, 0, sizeof(SPF_data_var_t ));
#line 282
  p = src;
#line 285
  c = (char )*p;
#line 286
  tmp___0 = __ctype_b_loc();
  }
#line 286
  if ((int const   )*(*tmp___0 + (int )((unsigned char )c)) & 256) {
    {
#line 288
    data->url_encode = (unsigned short)1;
#line 289
    tmp = tolower((int )c);
#line 289
    c = (char )tmp;
    }
  } else {
#line 292
    data->url_encode = (unsigned short)0;
  }
  {
#line 302
  if ((int )c == 108) {
#line 302
    goto case_108;
  }
#line 306
  if ((int )c == 115) {
#line 306
    goto case_115;
  }
#line 310
  if ((int )c == 111) {
#line 310
    goto case_111;
  }
#line 314
  if ((int )c == 100) {
#line 314
    goto case_100;
  }
#line 318
  if ((int )c == 105) {
#line 318
    goto case_105;
  }
#line 322
  if ((int )c == 99) {
#line 322
    goto case_99;
  }
#line 327
  if ((int )c == 116) {
#line 327
    goto case_116;
  }
#line 332
  if ((int )c == 112) {
#line 332
    goto case_112;
  }
#line 336
  if ((int )c == 118) {
#line 336
    goto case_118;
  }
#line 340
  if ((int )c == 104) {
#line 340
    goto case_104;
  }
#line 344
  if ((int )c == 114) {
#line 344
    goto case_114;
  }
#line 349
  goto switch_default;
  case_108: /* CIL Label */ 
#line 303
  data->parm_type = (unsigned char)0;
#line 304
  goto switch_break;
  case_115: /* CIL Label */ 
#line 307
  data->parm_type = (unsigned char)1;
#line 308
  goto switch_break;
  case_111: /* CIL Label */ 
#line 311
  data->parm_type = (unsigned char)2;
#line 312
  goto switch_break;
  case_100: /* CIL Label */ 
#line 315
  data->parm_type = (unsigned char)3;
#line 316
  goto switch_break;
  case_105: /* CIL Label */ 
#line 319
  data->parm_type = (unsigned char)4;
#line 320
  goto switch_break;
  case_99: /* CIL Label */ 
#line 323
  if (! is_mod) {
    {
#line 323
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 323
    return (tmp___1);
  }
#line 324
  data->parm_type = (unsigned char)5;
#line 325
  goto switch_break;
  case_116: /* CIL Label */ 
#line 328
  if (! is_mod) {
    {
#line 328
    tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 328
    return (tmp___2);
  }
#line 329
  data->parm_type = (unsigned char)6;
#line 330
  goto switch_break;
  case_112: /* CIL Label */ 
#line 333
  data->parm_type = (unsigned char)7;
#line 334
  goto switch_break;
  case_118: /* CIL Label */ 
#line 337
  data->parm_type = (unsigned char)8;
#line 338
  goto switch_break;
  case_104: /* CIL Label */ 
#line 341
  data->parm_type = (unsigned char)9;
#line 342
  goto switch_break;
  case_114: /* CIL Label */ 
#line 345
  if (! is_mod) {
    {
#line 345
    tmp___3 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 345
    return (tmp___3);
  }
#line 346
  data->parm_type = (unsigned char)10;
#line 347
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 350
  tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                       p, "Unknown variable \'%c\'", (int )c);
  }
#line 350
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
#line 354
  p ++;
#line 355
  token = p;
#line 358
  val = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 359
    tmp___5 = __ctype_b_loc();
    }
#line 359
    if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*p)) & 2048)) {
#line 359
      goto while_break;
    }
#line 361
    val *= 10;
#line 362
    val += (int )((int const   )*p - 48);
#line 363
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (val > 128) {
    {
#line 366
    tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                         token, "Subdomain truncation depth too large");
    }
#line 366
    return (tmp___6);
  } else
#line 365
  if (val <= 0) {
#line 365
    if ((unsigned long )p != (unsigned long )token) {
      {
#line 366
      tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                           token, "Subdomain truncation depth too large");
      }
#line 366
      return (tmp___6);
    }
  }
#line 369
  data->num_rhs = (unsigned char )val;
#line 370
  token = p;
#line 373
  if ((int const   )*p == 114) {
#line 375
    data->rev = (unsigned short)1;
#line 376
    p ++;
  } else {
#line 379
    data->rev = (unsigned short)0;
  }
#line 380
  token = p;
#line 384
  data->delim_dot = (unsigned short)0;
#line 385
  data->delim_dash = (unsigned short)0;
#line 386
  data->delim_plus = (unsigned short)0;
#line 387
  data->delim_equal = (unsigned short)0;
#line 388
  data->delim_bar = (unsigned short)0;
#line 389
  data->delim_under = (unsigned short)0;
#line 392
  if ((int const   )*p == 125) {
#line 393
    data->delim_dot = (unsigned short)1;
  }
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! ((int const   )*p != 125)) {
#line 396
      goto while_break___0;
    }
#line 398
    token = p;
    {
#line 401
    if ((int const   )*p == 46) {
#line 401
      goto case_46;
    }
#line 405
    if ((int const   )*p == 45) {
#line 405
      goto case_45;
    }
#line 409
    if ((int const   )*p == 43) {
#line 409
      goto case_43;
    }
#line 413
    if ((int const   )*p == 61) {
#line 413
      goto case_61;
    }
#line 417
    if ((int const   )*p == 124) {
#line 417
      goto case_124;
    }
#line 421
    if ((int const   )*p == 95) {
#line 421
      goto case_95;
    }
#line 425
    goto switch_default___0;
    case_46: /* CIL Label */ 
#line 402
    data->delim_dot = (unsigned short)1;
#line 403
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 406
    data->delim_dash = (unsigned short)1;
#line 407
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 410
    data->delim_plus = (unsigned short)1;
#line 411
    goto switch_break___0;
    case_61: /* CIL Label */ 
#line 414
    data->delim_equal = (unsigned short)1;
#line 415
    goto switch_break___0;
    case_124: /* CIL Label */ 
#line 418
    data->delim_bar = (unsigned short)1;
#line 419
    goto switch_break___0;
    case_95: /* CIL Label */ 
#line 422
    data->delim_under = (unsigned short)1;
#line 423
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 426
    tmp___7 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )14, (char const   *)((void *)0),
                                         p, "Invalid delimiter \'%c\'", (int const   )*p);
    }
#line 426
    return (tmp___7);
    switch_break___0: /* CIL Label */ ;
    }
#line 430
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 432
  p ++;
#line 433
  token = p;
#line 436
  return ((SPF_errcode_t )0);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_macro___1(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                           SPF_data_t *data , size_t *data_used ,
                                           size_t data_avail , char const   *src ,
                                           size_t src_len , SPF_errcode_t big_err ,
                                           int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  size_t len ;
  char *dst ;
  size_t ds_avail ;
  size_t ds_len ;
  SPF_errcode_t tmp ;
  SPF_errcode_t tmp___0 ;
  char *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  char *tmp___3 ;
  SPF_errcode_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  SPF_errcode_t tmp___8 ;
  char *tmp___9 ;
  SPF_errcode_t tmp___10 ;
  SPF_errcode_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  SPF_errcode_t tmp___15 ;
  SPF_errcode_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  SPF_errcode_t tmp___19 ;
  SPF_errcode_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
#line 522
  if (spf_server___1->debug) {
    {
#line 523
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               523, "Parsing macro starting at %s", src);
    }
  }
#line 534
  idx = (size_t )0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 538
    data->ds.parm_type = (unsigned char)12;
#line 538
    data->ds.len = (unsigned char)0;
#line 538
    data->ds.__unused0 = (unsigned char)186;
#line 538
    data->ds.__unused1 = (unsigned char)190;
#line 538
    dst = SPF_data_str(data);
#line 538
    ds_avail = data_avail - *data_used;
#line 538
    ds_len = (size_t )0;
    }
#line 538
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 541
    if (! (idx < src_len)) {
#line 541
      goto while_break___0;
    }
#line 542
    if (spf_server___1->debug > 3) {
      {
#line 543
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 543, "Current data is at %p", data);
      }
    }
    {
#line 546
    len = strcspn(src + idx, " %");
    }
#line 547
    if (len > 0UL) {
#line 549
      if (idx + len > src_len) {
#line 550
        len = src_len - idx;
      }
#line 551
      if (spf_server___1->debug > 3) {
        {
#line 552
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                   554, "Adding string literal (%lu): \'%*.*s\'", len, (int )len,
                   (int )len, src + idx);
        }
      }
      {
#line 556
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 556
        if (ds_len + len > ds_avail) {
          {
#line 556
          tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                           src, "String literal fragment too long (%d chars, %d max)",
                                           ds_len, ds_avail);
          }
#line 556
          return (tmp);
        }
#line 556
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 557
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(src + idx),
             len);
#line 558
      ds_len += len;
#line 559
      dst += len;
#line 560
      idx += len;
      }
    }
#line 568
    if (idx == src_len) {
#line 569
      goto while_break___0;
    }
#line 576
    idx ++;
    {
#line 578
    if ((int const   )*(src + idx) == 37) {
#line 578
      goto case_37;
    }
#line 587
    if ((int const   )*(src + idx) == 95) {
#line 587
      goto case_95;
    }
#line 596
    if ((int const   )*(src + idx) == 45) {
#line 596
      goto case_45;
    }
#line 617
    if ((int const   )*(src + idx) == 123) {
#line 617
      goto case_123;
    }
#line 605
    goto switch_default;
    case_37: /* CIL Label */ 
#line 579
    if (spf_server___1->debug > 3) {
      {
#line 580
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 580, "Adding literal %%");
      }
    }
    {
#line 581
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 581
      if (ds_len + 1UL > ds_avail) {
        {
#line 581
        tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 581
        return (tmp___0);
      }
#line 581
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 582
    tmp___1 = dst;
#line 582
    dst ++;
#line 582
    *tmp___1 = (char )'%';
#line 583
    ds_len ++;
#line 584
    idx ++;
#line 585
    goto switch_break;
    case_95: /* CIL Label */ 
#line 588
    if (spf_server___1->debug > 3) {
      {
#line 589
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 589, "Adding literal space");
      }
    }
    {
#line 590
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 590
      if (ds_len + 1UL > ds_avail) {
        {
#line 590
        tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 590
        return (tmp___2);
      }
#line 590
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 591
    tmp___3 = dst;
#line 591
    dst ++;
#line 591
    *tmp___3 = (char )' ';
#line 592
    ds_len ++;
#line 593
    idx ++;
#line 594
    goto switch_break;
    case_45: /* CIL Label */ 
#line 597
    if (spf_server___1->debug > 3) {
      {
#line 598
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 598, "Adding escaped space");
      }
    }
    {
#line 599
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 599
      if (ds_len + 3UL > ds_avail) {
        {
#line 599
        tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 599
        return (tmp___4);
      }
#line 599
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 600
    tmp___5 = dst;
#line 600
    dst ++;
#line 600
    *tmp___5 = (char )'%';
#line 600
    tmp___6 = dst;
#line 600
    dst ++;
#line 600
    *tmp___6 = (char )'2';
#line 600
    tmp___7 = dst;
#line 600
    dst ++;
#line 600
    *tmp___7 = (char )'0';
#line 601
    ds_len += 3UL;
#line 602
    idx ++;
#line 603
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 606
    if (spf_server___1->debug > 3) {
      {
#line 607
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 608, "Adding illegal %%-follower \'%c\' at %d", (int const   )*(src + idx),
                 idx);
      }
    }
    {
#line 612
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 612
      if (ds_len + 1UL > ds_avail) {
        {
#line 612
        tmp___8 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 612
        return (tmp___8);
      }
#line 612
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 613
    tmp___9 = dst;
#line 613
    dst ++;
#line 613
    *tmp___9 = (char )'%';
#line 614
    ds_len ++;
#line 615
    goto switch_break;
    case_123: /* CIL Label */ 
    {
#line 618
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 618
      if (ds_len > 0UL) {
#line 618
        if (ds_len > 255UL) {
          {
#line 618
          tmp___10 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15,
                                                (char const   *)((void *)0), src,
                                                "String literal too long (%d chars, %d max)",
                                                ds_len, 255);
          }
#line 618
          return (tmp___10);
        }
#line 618
        data->ds.len = (unsigned char )ds_len;
#line 618
        len = sizeof(*data) + ds_len;
        {
#line 618
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 618
          tmp___12 = _align_sz(len);
          }
#line 618
          if (*data_used + tmp___12 > data_avail) {
            {
#line 618
            tmp___11 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                  src, "SPF domainspec too long (%d chars, %d max)",
                                                  *data_used + len, data_avail);
            }
#line 618
            return (tmp___11);
          }
          {
#line 618
          tmp___13 = _align_sz(len);
#line 618
          *data_used += tmp___13;
          }
#line 618
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 618
        data = SPF_data_next(data);
#line 618
        ds_len = (size_t )0;
        }
      }
#line 618
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 619
    if (spf_server___1->debug > 3) {
      {
#line 620
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 620, "Adding macro, data is at %p", data);
      }
    }
    {
#line 623
    idx ++;
#line 624
    err = SPF_c_parse_var___1(spf_response, & data->dv, src + idx, is_mod);
    }
#line 625
    if ((unsigned int )err != 0U) {
#line 626
      return (err);
    }
    {
#line 627
    tmp___14 = strcspn(src + idx, "} ");
#line 627
    idx += tmp___14;
    }
#line 628
    if ((int const   )*(src + idx) == 125) {
#line 629
      idx ++;
    } else
#line 630
    if ((int const   )*(src + idx) == 32) {
      {
#line 631
      tmp___15 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, src,
                                            src + idx, "Unterminated variable?");
      }
#line 631
      return (tmp___15);
    }
    {
#line 637
    len = SPF_data_len(data);
    }
    {
#line 638
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 638
      tmp___17 = _align_sz(len);
      }
#line 638
      if (*data_used + tmp___17 > data_avail) {
        {
#line 638
        tmp___16 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                              src, "SPF domainspec too long (%d chars, %d max)",
                                              *data_used + len, data_avail);
        }
#line 638
        return (tmp___16);
      }
      {
#line 638
      tmp___18 = _align_sz(len);
#line 638
      *data_used += tmp___18;
      }
#line 638
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 639
    data = SPF_data_next(data);
    }
#line 640
    if (spf_server___1->debug > 3) {
      {
#line 641
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 641, "Next data is at %p", data);
      }
    }
    {
#line 643
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 643
      data->ds.parm_type = (unsigned char)12;
#line 643
      data->ds.len = (unsigned char)0;
#line 643
      data->ds.__unused0 = (unsigned char)186;
#line 643
      data->ds.__unused1 = (unsigned char)190;
#line 643
      dst = SPF_data_str(data);
#line 643
      ds_avail = data_avail - *data_used;
#line 643
      ds_len = (size_t )0;
      }
#line 643
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 649
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 649
    if (ds_len > 0UL) {
#line 649
      if (ds_len > 255UL) {
        {
#line 649
        tmp___19 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                              src, "String literal too long (%d chars, %d max)",
                                              ds_len, 255);
        }
#line 649
        return (tmp___19);
      }
#line 649
      data->ds.len = (unsigned char )ds_len;
#line 649
      len = sizeof(*data) + ds_len;
      {
#line 649
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 649
        tmp___21 = _align_sz(len);
        }
#line 649
        if (*data_used + tmp___21 > data_avail) {
          {
#line 649
          tmp___20 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                src, "SPF domainspec too long (%d chars, %d max)",
                                                *data_used + len, data_avail);
          }
#line 649
          return (tmp___20);
        }
        {
#line 649
        tmp___22 = _align_sz(len);
#line 649
        *data_used += tmp___22;
        }
#line 649
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 649
      data = SPF_data_next(data);
#line 649
      ds_len = (size_t )0;
      }
    }
#line 649
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 651
  return ((SPF_errcode_t )0);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_domainspec___1(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                                SPF_data_t *data , size_t *data_used ,
                                                size_t data_avail , char const   *src ,
                                                size_t src_len , SPF_errcode_t big_err ,
                                                SPF_cidr_t cidr_ok , int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  SPF_errcode_t tmp___6 ;

  {
#line 682
  if (spf_server___1->debug) {
#line 683
    if ((unsigned int )cidr_ok == 1U) {
#line 683
      tmp___1 = "optional";
    } else {
#line 683
      if ((unsigned int )cidr_ok == 2U) {
#line 683
        tmp___0 = "only";
      } else {
#line 683
        if ((unsigned int )cidr_ok == 0U) {
#line 683
          tmp = "forbidden";
        } else {
#line 683
          tmp = "ERROR!";
        }
#line 683
        tmp___0 = tmp;
      }
#line 683
      tmp___1 = tmp___0;
    }
    {
#line 683
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               689, "Parsing domainspec starting at %s, cidr is %s", src, tmp___1);
    }
  }
#line 694
  if ((unsigned int )cidr_ok == 1U) {
#line 694
    goto _L___0;
  } else
#line 694
  if ((unsigned int )cidr_ok == 2U) {
    _L___0: /* CIL Label */ 
    {
#line 695
    err = SPF_c_parse_cidr___1(spf_response, & data->dc, src, & src_len);
    }
#line 696
    if ((unsigned int )err != 0U) {
#line 697
      return (err);
    }
#line 698
    if ((int )data->dc.ipv4 != 0) {
#line 698
      goto _L;
    } else
#line 698
    if ((int )data->dc.ipv6 != 0) {
      _L: /* CIL Label */ 
      {
#line 699
      len = SPF_data_len(data);
      }
      {
#line 700
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 700
        tmp___3 = _align_sz(len);
        }
#line 700
        if (*data_used + tmp___3 > data_avail) {
          {
#line 700
          tmp___2 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                               src, "SPF domainspec too long (%d chars, %d max)",
                                               *data_used + len, data_avail);
          }
#line 700
          return (tmp___2);
        }
        {
#line 700
        tmp___4 = _align_sz(len);
#line 700
        *data_used += tmp___4;
        }
#line 700
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 701
      data = SPF_data_next(data);
      }
    }
#line 704
    if ((unsigned int )cidr_ok == 2U) {
#line 704
      if (src_len > 0UL) {
        {
#line 708
        tmp___5 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                             src, "Invalid CIDR after mechanism");
        }
#line 708
        return (tmp___5);
      }
    }
  }
  {
#line 715
  tmp___6 = SPF_c_parse_macro___1(spf_server___1, spf_response, data, data_used, data_avail,
                                  src, src_len, big_err, is_mod);
  }
#line 715
  return (tmp___6);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip4___1(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  SPF_errcode_t err ;
  unsigned char mask ;
  struct in_addr *addr ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 739
  start ++;
#line 740
  len = strcspn(start, " ");
#line 741
  end = start + len;
#line 742
  p = end - 1;
#line 744
  mask = (unsigned char)0;
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 745
    tmp = __ctype_b_loc();
    }
#line 745
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 745
      goto while_break;
    }
#line 746
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 747
    if ((int const   )*p == 47) {
      {
#line 748
      err = SPF_c_parse_cidr_ip4___1(spf_response, & mask, p);
      }
#line 749
      if (err) {
#line 750
        return (err);
      }
#line 751
      end = p;
    }
  }
#line 753
  mech->mech_len = (unsigned short )mask;
#line 755
  len = (size_t )(end - start);
#line 756
  if (len > sizeof(buf) - 1UL) {
#line 757
    return ((SPF_errcode_t )19);
  }
  {
#line 759
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 760
  buf[len] = (char )'\000';
#line 761
  addr = SPF_mech_ip4_data(mech);
#line 762
  tmp___0 = inet_pton(2, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
#line 762
  err = (SPF_errcode_t )tmp___0;
  }
#line 763
  if ((unsigned int )err <= 0U) {
    {
#line 764
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )19, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 764
    return (tmp___1);
  }
#line 767
  return ((SPF_errcode_t )0);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip6___1(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  int err ;
  unsigned char mask ;
  struct in6_addr *addr ;
  unsigned short const   **tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 788
  start ++;
#line 789
  len = strcspn(start, " ");
#line 790
  end = start + len;
#line 791
  p = end - 1;
#line 793
  mask = (unsigned char)0;
  }
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 794
    tmp = __ctype_b_loc();
    }
#line 794
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 794
      goto while_break;
    }
#line 795
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 796
    if ((int const   )*p == 47) {
      {
#line 797
      tmp___0 = SPF_c_parse_cidr_ip6___1(spf_response, & mask, p);
#line 797
      err = (int )tmp___0;
      }
#line 798
      if (err) {
#line 799
        return ((SPF_errcode_t )err);
      }
#line 800
      end = p;
    }
  }
#line 802
  mech->mech_len = (unsigned short )mask;
#line 804
  len = (size_t )(end - start);
#line 805
  if (len > sizeof(buf) - 1UL) {
#line 806
    return ((SPF_errcode_t )20);
  }
  {
#line 808
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 809
  buf[len] = (char )'\000';
#line 810
  addr = SPF_mech_ip6_data(mech);
#line 811
  err = inet_pton(10, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
  }
#line 812
  if (err <= 0) {
    {
#line 813
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )20, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 813
    return (tmp___1);
  }
#line 816
  return ((SPF_errcode_t )0);
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mech_add___1)(SPF_server_t *spf_server___1 ,
                                                                                   SPF_record_t *spf_record ,
                                                                                   SPF_response_t *spf_response ,
                                                                                   SPF_mechtype_t const   *mechtype ,
                                                                                   int prefix ,
                                                                                   char const   **mech_value ) 
{ 
  union __anonunion_u_60___1 u ;
  SPF_mech_t *spf_mechanism ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  SPF_errcode_t tmp ;
  int tmp___0 ;

  {
  {
#line 834
  spf_mechanism = (SPF_mech_t *)(u.buf);
#line 842
  memset((void *)(u.buf), 'B', sizeof(u.buf));
#line 843
  memset((void *)spf_mechanism, 0, sizeof(SPF_mech_t ));
  }
#line 845
  if (spf_server___1->debug) {
    {
#line 846
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               847, "SPF_c_mech_add: type=%d, value=%s", (int const   )mechtype->mech_type,
               *mech_value);
    }
  }
#line 849
  spf_mechanism->prefix_type = (unsigned char )prefix;
#line 850
  spf_mechanism->mech_type = (unsigned char )mechtype->mech_type;
#line 851
  spf_mechanism->mech_len = (unsigned short)0;
#line 853
  len = sizeof(SPF_mech_t );
#line 855
  if (spf_record->mech_len + len > 511UL) {
#line 856
    return ((SPF_errcode_t )16);
  }
  {
#line 858
  data = SPF_mech_data(spf_mechanism);
#line 859
  data_len = (size_t )0;
#line 861
  src_len = strcspn(*mech_value, " ");
  }
  {
#line 865
  if ((int const   )mechtype->mech_type == 5) {
#line 865
    goto case_5;
  }
#line 878
  if ((int const   )mechtype->mech_type == 6) {
#line 878
    goto case_6;
  }
#line 891
  goto switch_default;
  case_5: /* CIL Label */ 
#line 866
  if ((int const   )*(*mech_value) == 58) {
    {
#line 867
    err = SPF_c_parse_ip4___1(spf_response, spf_mechanism, *mech_value);
#line 868
    data_len = sizeof(struct in_addr );
    }
  } else {
    {
#line 871
    err = (SPF_errcode_t )9;
#line 872
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 876
  goto switch_break;
  case_6: /* CIL Label */ 
#line 879
  if ((int const   )*(*mech_value) == 58) {
    {
#line 880
    err = SPF_c_parse_ip6___1(spf_response, spf_mechanism, *mech_value);
#line 881
    data_len = sizeof(struct in6_addr );
    }
  } else {
    {
#line 884
    err = (SPF_errcode_t )9;
#line 885
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 889
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 892
  if ((int const   )*(*mech_value) == 58) {
#line 892
    goto _L___0;
  } else
#line 892
  if ((int const   )*(*mech_value) == 61) {
    _L___0: /* CIL Label */ 
#line 893
    if ((unsigned int const   )mechtype->has_domainspec == 0U) {
      {
#line 894
      err = (SPF_errcode_t )7;
#line 895
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a value.");
      }
    } else {
      {
#line 900
      (*mech_value) ++;
#line 900
      src_len --;
#line 901
      err = SPF_c_parse_domainspec___1(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )mechtype->has_cidr, 0);
      }
    }
  } else
#line 909
  if ((int const   )*(*mech_value) == 47) {
#line 910
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 911
      err = (SPF_errcode_t )9;
#line 912
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else
#line 916
    if ((unsigned int const   )mechtype->has_cidr == 0U) {
      {
#line 917
      err = (SPF_errcode_t )8;
#line 918
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a CIDR.");
      }
    } else {
      {
#line 923
      err = SPF_c_parse_domainspec___1(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )2, 0);
      }
    }
  } else
#line 931
  if ((int const   )*(*mech_value) == 32) {
#line 931
    goto _L;
  } else
#line 931
  if ((int const   )*(*mech_value) == 0) {
    _L: /* CIL Label */ 
#line 932
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 933
      err = (SPF_errcode_t )9;
#line 934
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else {
#line 939
      err = (SPF_errcode_t )0;
    }
  } else {
    {
#line 943
    err = (SPF_errcode_t )3;
#line 944
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Unknown character \'%c\' after mechanism.", (int const   )*(*mech_value));
    }
  }
#line 951
  spf_mechanism->mech_len = (unsigned short )data_len;
#line 952
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 955
  len += data_len;
#line 958
  if ((unsigned int )err == 0U) {
#line 959
    if (mechtype->is_dns_mech) {
#line 960
      spf_record->num_dns_mech = (unsigned char )((int )spf_record->num_dns_mech + 1);
    }
    {
#line 961
    tmp___0 = SPF_c_ensure_capacity___1((void **)(& spf_record->mech_first), & spf_record->mech_size,
                                        spf_record->mech_len + len);
    }
#line 961
    if (tmp___0 < 0) {
      {
#line 964
      tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                       (char const   *)((void *)0), "Failed to allocate memory for mechanism");
      }
#line 964
      return (tmp);
    }
    {
#line 968
    memcpy((void */* __restrict  */)((char *)spf_record->mech_first + spf_record->mech_len),
           (void const   */* __restrict  */)spf_mechanism, len);
#line 971
    spf_record->mech_len += len;
#line 972
    spf_record->num_mech = (unsigned char )((int )spf_record->num_mech + 1);
    }
  }
#line 975
  *mech_value += src_len;
#line 977
  return (err);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mod_add___1)(SPF_server_t *spf_server___1 ,
                                                                                  SPF_record_t *spf_record ,
                                                                                  SPF_response_t *spf_response ,
                                                                                  char const   *mod_name ,
                                                                                  size_t name_len ,
                                                                                  char const   **mod_value ) 
{ 
  union __anonunion_u_61___1 u ;
  SPF_mod_t *spf_modifier ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  char *tmp ;
  SPF_errcode_t tmp___0 ;
  int tmp___1 ;

  {
#line 992
  spf_modifier = (SPF_mod_t *)(u.buf);
#line 1000
  if (spf_server___1->debug) {
    {
#line 1001
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               1002, "Adding modifier name=%lu@%s, value=%s", name_len, mod_name,
               *mod_value);
    }
  }
  {
#line 1004
  memset((void *)(u.buf), 'A', sizeof(u.buf));
#line 1005
  memset((void *)spf_modifier, 0, sizeof(SPF_mod_t ));
  }
#line 1007
  if (name_len > 511UL) {
#line 1008
    return ((SPF_errcode_t )17);
  }
  {
#line 1010
  spf_modifier->name_len = (unsigned short )name_len;
#line 1011
  spf_modifier->data_len = (unsigned short)0;
#line 1014
  len = _align_sz(sizeof(SPF_mod_t ) + name_len);
  }
#line 1016
  if (spf_record->mod_len + len > 511UL) {
#line 1017
    return ((SPF_errcode_t )17);
  }
  {
#line 1019
  tmp = SPF_mod_name(spf_modifier);
#line 1019
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)mod_name,
         name_len);
#line 1021
  data = SPF_mod_data(spf_modifier);
#line 1022
  data_len = (size_t )0;
#line 1024
  src_len = strcspn(*mod_value, " ");
#line 1026
  err = SPF_c_parse_macro___1(spf_server___1, spf_response, data, & data_len, (size_t )511,
                              *mod_value, src_len, (SPF_errcode_t )17, 1);
#line 1032
  spf_modifier->data_len = (unsigned short )data_len;
#line 1033
  len += data_len;
  }
#line 1036
  if ((unsigned int )err == 0U) {
    {
#line 1037
    tmp___1 = SPF_c_ensure_capacity___1((void **)(& spf_record->mod_first), & spf_record->mod_size,
                                        spf_record->mod_len + len);
    }
#line 1037
    if (tmp___1 < 0) {
      {
#line 1040
      tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                           (char const   *)((void *)0), "Failed to allocate memory for modifier");
      }
#line 1040
      return (tmp___0);
    }
    {
#line 1044
    memcpy((void */* __restrict  */)((char *)spf_record->mod_first + spf_record->mod_len),
           (void const   */* __restrict  */)spf_modifier, len);
#line 1047
    spf_record->mod_len += len;
#line 1048
    spf_record->num_mod = (unsigned char )((int )spf_record->num_mod + 1);
    }
  }
#line 1051
  return (err);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static void SPF_record_lint___1(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                SPF_record_t *spf_record ) 
{ 
  SPF_data_t *d ;
  SPF_data_t *data_end ;
  char *s ;
  char *s_end ;
  int found_non_ip ;
  int found_valid_tld ;
  SPF_mech_t *mech ;
  SPF_data_t *data ;
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1075
  mech = spf_record->mech_first;
#line 1076
  i = 0;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (i < (int )spf_record->num_mech)) {
#line 1076
      goto while_break;
    }
#line 1081
    if ((int )mech->mech_type == 8) {
#line 1081
      goto _L;
    } else
#line 1081
    if ((int )mech->mech_type == 9) {
      _L: /* CIL Label */ 
#line 1081
      if (i != (int )spf_record->num_mech - 1) {
        {
#line 1085
        SPF_response_add_warn(spf_response, (SPF_errcode_t )29, "Mechanisms found after the \"all:\" mechanism will be ignored.");
        }
      }
    }
#line 1098
    if ((int )mech->mech_type == 5) {
#line 1100
      goto __Cont;
    } else
#line 1098
    if ((int )mech->mech_type == 6) {
#line 1100
      goto __Cont;
    }
    {
#line 1102
    data = SPF_mech_data(mech);
#line 1103
    data_end = SPF_mech_end_data(mech);
    }
#line 1104
    if ((unsigned long )data == (unsigned long )data_end) {
#line 1105
      goto __Cont;
    }
#line 1107
    if ((int )data->dc.parm_type == 11) {
      {
#line 1109
      data = SPF_data_next(data);
      }
#line 1110
      if ((unsigned long )data == (unsigned long )data_end) {
#line 1111
        goto __Cont;
      }
    }
#line 1115
    found_valid_tld = 0;
#line 1116
    found_non_ip = 0;
#line 1118
    d = data;
    {
#line 1118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1118
      if (! ((unsigned long )d < (unsigned long )data_end)) {
#line 1118
        goto while_break___0;
      }
      {
#line 1122
      if ((int )d->dv.parm_type == 11) {
#line 1122
        goto case_11;
      }
#line 1128
      if ((int )d->dv.parm_type == 0) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 5) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 4) {
#line 1128
        goto case_0;
      }
#line 1132
      if ((int )d->dv.parm_type == 12) {
#line 1132
        goto case_12;
      }
#line 1148
      goto switch_default;
      case_11: /* CIL Label */ 
      {
#line 1123
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1123, "%s", "Multiple CIDR parameters found");
      }
#line 1124
      goto switch_break;
      case_0: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 1129
      found_valid_tld = 0;
#line 1130
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 1133
      found_valid_tld = 0;
#line 1135
      s = SPF_data_str(d);
#line 1136
      s_end = s + (int )d->ds.len;
      }
      {
#line 1137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1137
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 1137
          goto while_break___1;
        }
        {
#line 1138
        tmp = __ctype_b_loc();
        }
#line 1138
        if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 2048)) {
#line 1138
          if ((int )*s != 46) {
#line 1138
            if ((int )*s != 58) {
#line 1139
              found_non_ip = 1;
            }
          }
        }
#line 1141
        if ((int )*s == 46) {
#line 1142
          found_valid_tld = 1;
        } else {
          {
#line 1143
          tmp___0 = __ctype_b_loc();
          }
#line 1143
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 1024)) {
#line 1144
            found_valid_tld = 0;
          }
        }
#line 1137
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1146
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1149
      found_non_ip = 1;
#line 1150
      found_valid_tld = 1;
#line 1152
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1118
      d = SPF_data_next(d);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1156
    if (! found_valid_tld) {
#line 1156
      goto _L___0;
    } else
#line 1156
    if (! found_non_ip) {
      _L___0: /* CIL Label */ 
#line 1157
      if (! found_non_ip) {
        {
#line 1158
        SPF_response_add_warn(spf_response, (SPF_errcode_t )27, "Invalid hostname (an IP address?)");
        }
      } else
#line 1160
      if (! found_valid_tld) {
        {
#line 1161
        SPF_response_add_warn(spf_response, (SPF_errcode_t )28, "Hostname has a missing or invalid TLD");
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 1076
    i ++;
#line 1076
    mech = SPF_mech_next(mech);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1168
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv4___1[8]  = 
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
  {      (char const   )'i',      (char const   )'n',      (char const   )'-',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv6___1[4]  = {      (char const   )'i',      (char const   )'p',      (char const   )'6',      (char const   )'\000'};
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c"
static SPF_errcode_t SPF_record_stringify_data___1(SPF_data_t *data , SPF_data_t *data_end ,
                                                   char **p_p , char *p_end , int is_mod ,
                                                   int cidr_ok , int debug ) 
{ 
  char *p ;
  size_t len ;
  SPF_data_t *cidr_data ;
  char *s ;
  char *tmp ;
  char *s_end ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 48
  p = *p_p;
#line 54
  if (debug) {
    {
#line 55
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
               55, " string data: Building");
    }
  }
#line 57
  if (p_end - p <= 0L) {
#line 58
    return ((SPF_errcode_t )10);
  }
#line 60
  cidr_data = (SPF_data_t *)((void *)0);
#line 61
  if ((unsigned long )data < (unsigned long )data_end) {
#line 61
    if ((int )data->dc.parm_type == 11) {
#line 63
      if (debug) {
        {
#line 64
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   64, " string data: Found a CIDR at %p", data);
        }
      }
#line 65
      if (! cidr_ok) {
#line 66
        return ((SPF_errcode_t )10);
      }
      {
#line 68
      cidr_data = data;
#line 69
      data = SPF_data_next(data);
      }
    }
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )data < (unsigned long )data_end)) {
#line 73
      goto while_break;
    }
#line 75
    if (debug) {
      {
#line 76
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 77, " string data: Handling data type %d at %p", (int )data->ds.parm_type,
                 data);
      }
    }
#line 78
    if ((int )data->ds.parm_type == 12) {
      {
#line 80
      tmp = SPF_data_str(data);
#line 80
      s = tmp;
#line 81
      s_end = s + (int )data->ds.len;
      }
#line 82
      if (debug) {
        {
#line 83
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   84, " string data: String is [%d] \'%*.*s\'", (int )data->ds.len,
                   (int )data->ds.len, (int )data->ds.len, s);
        }
      }
#line 86
      if (p_end - (p + (int )data->ds.len) <= 0L) {
#line 87
        return ((SPF_errcode_t )10);
      }
      {
#line 89
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 89
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 89
          goto while_break___0;
        }
#line 90
        if ((int )*s == 32) {
#line 91
          tmp___0 = p;
#line 91
          p ++;
#line 91
          *tmp___0 = (char )'%';
#line 92
          tmp___1 = p;
#line 92
          p ++;
#line 92
          *tmp___1 = (char )'_';
#line 93
          s ++;
        } else
#line 95
        if ((int )*s == 37) {
#line 96
          tmp___2 = p;
#line 96
          p ++;
#line 96
          *tmp___2 = (char )'%';
#line 97
          s ++;
#line 98
          if ((int )*(s + 0) == 50) {
#line 98
            if ((int )*(s + 1) == 48) {
#line 99
              tmp___3 = p;
#line 99
              p ++;
#line 99
              *tmp___3 = (char )'-';
#line 100
              s += 2;
            } else {
#line 103
              tmp___4 = p;
#line 103
              p ++;
#line 103
              *tmp___4 = (char )'%';
            }
          } else {
#line 103
            tmp___4 = p;
#line 103
            p ++;
#line 103
            *tmp___4 = (char )'%';
          }
        } else {
#line 108
          tmp___5 = p;
#line 108
          p ++;
#line 108
          tmp___6 = s;
#line 108
          s ++;
#line 108
          *tmp___5 = *tmp___6;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 112
      if (p_end - p <= 0L) {
#line 113
        return ((SPF_errcode_t )10);
      }
    } else
#line 115
    if ((int )data->dc.parm_type == 11) {
#line 117
      return ((SPF_errcode_t )8);
    } else {
      {
#line 120
      tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%%{");
#line 120
      len = (size_t )tmp___7;
#line 121
      p += len;
      }
#line 122
      if (p_end - p <= 0L) {
#line 122
        return ((SPF_errcode_t )10);
      }
#line 125
      if (p_end - p <= 1L) {
#line 125
        return ((SPF_errcode_t )10);
      }
      {
#line 128
      if ((int )data->dv.parm_type == 0) {
#line 128
        goto case_0;
      }
#line 132
      if ((int )data->dv.parm_type == 1) {
#line 132
        goto case_1;
      }
#line 136
      if ((int )data->dv.parm_type == 2) {
#line 136
        goto case_2;
      }
#line 140
      if ((int )data->dv.parm_type == 3) {
#line 140
        goto case_3;
      }
#line 144
      if ((int )data->dv.parm_type == 4) {
#line 144
        goto case_4;
      }
#line 148
      if ((int )data->dv.parm_type == 5) {
#line 148
        goto case_5;
      }
#line 152
      if ((int )data->dv.parm_type == 6) {
#line 152
        goto case_6;
      }
#line 158
      if ((int )data->dv.parm_type == 7) {
#line 158
        goto case_7;
      }
#line 162
      if ((int )data->dv.parm_type == 8) {
#line 162
        goto case_8;
      }
#line 166
      if ((int )data->dv.parm_type == 9) {
#line 166
        goto case_9;
      }
#line 170
      if ((int )data->dv.parm_type == 10) {
#line 170
        goto case_10;
      }
#line 174
      goto switch_default;
      case_0: /* CIL Label */ 
#line 129
      *p = (char )'l';
#line 130
      goto switch_break;
      case_1: /* CIL Label */ 
#line 133
      *p = (char )'s';
#line 134
      goto switch_break;
      case_2: /* CIL Label */ 
#line 137
      *p = (char )'o';
#line 138
      goto switch_break;
      case_3: /* CIL Label */ 
#line 141
      *p = (char )'d';
#line 142
      goto switch_break;
      case_4: /* CIL Label */ 
#line 145
      *p = (char )'i';
#line 146
      goto switch_break;
      case_5: /* CIL Label */ 
#line 149
      *p = (char )'c';
#line 150
      goto switch_break;
      case_6: /* CIL Label */ 
#line 153
      if (! is_mod) {
#line 154
        return ((SPF_errcode_t )12);
      }
#line 155
      *p = (char )'t';
#line 156
      goto switch_break;
      case_7: /* CIL Label */ 
#line 159
      *p = (char )'p';
#line 160
      goto switch_break;
      case_8: /* CIL Label */ 
#line 163
      *p = (char )'v';
#line 164
      goto switch_break;
      case_9: /* CIL Label */ 
#line 167
      *p = (char )'h';
#line 168
      goto switch_break;
      case_10: /* CIL Label */ 
#line 171
      *p = (char )'r';
#line 172
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 175
      return ((SPF_errcode_t )12);
#line 176
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 178
      if (data->dv.url_encode) {
        {
#line 179
        tmp___8 = toupper((int )*p);
#line 179
        *p = (char )tmp___8;
        }
      }
#line 180
      p ++;
#line 181
      if (p_end - p <= 0L) {
#line 181
        return ((SPF_errcode_t )10);
      }
#line 184
      if (data->dv.num_rhs) {
        {
#line 186
        tmp___9 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%d",
                           (int )data->dv.num_rhs);
#line 186
        len = (size_t )tmp___9;
#line 187
        p += len;
        }
#line 188
        if (p_end - p <= 0L) {
#line 188
          return ((SPF_errcode_t )10);
        }
      }
#line 192
      if (p_end - p <= 8L) {
#line 192
        return ((SPF_errcode_t )10);
      }
#line 193
      if (data->dv.rev) {
#line 194
        tmp___10 = p;
#line 194
        p ++;
#line 194
        *tmp___10 = (char )'r';
      }
#line 196
      if (data->dv.delim_dot) {
#line 196
        if (data->dv.delim_dash) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_plus) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_equal) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_bar) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_under) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        }
      }
#line 205
      if (data->dv.delim_dash) {
#line 206
        tmp___12 = p;
#line 206
        p ++;
#line 206
        *tmp___12 = (char )'-';
      }
#line 207
      if (data->dv.delim_plus) {
#line 208
        tmp___13 = p;
#line 208
        p ++;
#line 208
        *tmp___13 = (char )'+';
      }
#line 209
      if (data->dv.delim_equal) {
#line 210
        tmp___14 = p;
#line 210
        p ++;
#line 210
        *tmp___14 = (char )'=';
      }
#line 211
      if (data->dv.delim_bar) {
#line 212
        tmp___15 = p;
#line 212
        p ++;
#line 212
        *tmp___15 = (char )'|';
      }
#line 213
      if (data->dv.delim_under) {
#line 214
        tmp___16 = p;
#line 214
        p ++;
#line 214
        *tmp___16 = (char )'_';
      }
#line 216
      tmp___17 = p;
#line 216
      p ++;
#line 216
      *tmp___17 = (char )'}';
#line 217
      if (p_end - p <= 0L) {
#line 217
        return ((SPF_errcode_t )10);
      }
    }
    {
#line 73
    data = SPF_data_next(data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (cidr_data) {
#line 224
    if (cidr_data->dc.ipv4) {
      {
#line 226
      tmp___18 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"/%d",
                          (int )cidr_data->dc.ipv4);
#line 226
      len = (size_t )tmp___18;
#line 227
      p += len;
      }
#line 228
      if (p_end - p <= 0L) {
#line 228
        return ((SPF_errcode_t )10);
      }
    }
#line 231
    if (cidr_data->dc.ipv6) {
      {
#line 233
      tmp___19 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"//%d",
                          (int )cidr_data->dc.ipv6);
#line 233
      len = (size_t )tmp___19;
#line 234
      p += len;
      }
#line 235
      if (p_end - p <= 0L) {
#line 235
        return ((SPF_errcode_t )10);
      }
    }
  }
#line 239
  *p_p = p;
#line 240
  return ((SPF_errcode_t )0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_pre___1(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                  ns_type rr_type , int should_cache ) 
{ 
  char const   *tmp ;

  {
#line 51
  if (spf_dns_server->debug) {
    {
#line 52
    tmp = SPF_strrrtype(rr_type);
#line 52
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               54, "DNS[%s] lookup: %s %s (%d)", spf_dns_server->name, domain, tmp,
               (unsigned int )rr_type);
    }
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_post___1(SPF_dns_server_t *spf_dns_server , SPF_dns_rr_t *spfrr ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 61
  if (spf_dns_server->debug) {
    {
#line 66
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               66, "DNS[%s] found record", spf_dns_server->name);
#line 67
    tmp = SPF_strrrtype(spfrr->rr_type);
#line 67
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               69, "    DOMAIN: %s  TYPE: %s (%d)", spfrr->domain, tmp, (unsigned int )spfrr->rr_type);
    }
#line 70
    if (spfrr->source) {
#line 70
      if ((spfrr->source)->name) {
#line 70
        tmp___0 = (spfrr->source)->name;
      } else {
#line 70
        tmp___0 = "(unnamed source)";
      }
#line 70
      tmp___1 = tmp___0;
    } else {
#line 70
      tmp___1 = "(null source)";
    }
    {
#line 70
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               76, "    TTL: %ld  RR found: %d  herrno: %d  source: %s", spfrr->ttl,
               spfrr->num_rr, spfrr->herrno, tmp___1);
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! (i < spfrr->num_rr)) {
#line 77
        goto while_break;
      }
      {
#line 79
      if ((unsigned int )spfrr->rr_type == 1U) {
#line 79
        goto case_1;
      }
#line 85
      if ((unsigned int )spfrr->rr_type == 12U) {
#line 85
        goto case_12;
      }
#line 89
      if ((unsigned int )spfrr->rr_type == 15U) {
#line 89
        goto case_15;
      }
#line 93
      if ((unsigned int )spfrr->rr_type == 16U) {
#line 93
        goto case_16;
      }
#line 97
      if ((unsigned int )spfrr->rr_type == 99U) {
#line 97
        goto case_99;
      }
#line 101
      if ((unsigned int )spfrr->rr_type == 28U) {
#line 101
        goto case_28;
      }
#line 107
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 80
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->a),
                          (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
#line 80
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 82, "    - A: %s", tmp___2);
      }
#line 83
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 86
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 86, "    - PTR: %s", (*(spfrr->rr + i))->ptr);
      }
#line 87
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 90
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 90, "    - MX: %s", (*(spfrr->rr + i))->mx);
      }
#line 91
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 94
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 94, "    - TXT: %s", (*(spfrr->rr + i))->txt);
      }
#line 95
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 98
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 98, "    - SPF: %s", (*(spfrr->rr + i))->txt);
      }
#line 99
      goto switch_break;
      case_28: /* CIL Label */ 
      {
#line 102
      tmp___3 = inet_ntop(10, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->aaaa),
                          (char */* __restrict  */)(ip6_buf), (socklen_t )sizeof(ip6_buf));
#line 102
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 104, "    - AAAA: %s", tmp___3);
      }
#line 105
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 108
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 108, "    - Unknown RR type");
      }
#line 109
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 77
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 113
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_cache_bucket_t *SPF_dns_cache_bucket_find___1(SPF_dns_cache_config_t *spfhook ,
                                                             char const   *domain ,
                                                             ns_type rr_type , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  SPF_dns_rr_t *rr ;
  time_t now ;
  int tmp ;

  {
  {
#line 247
  bucket = *(spfhook->cache + idx);
#line 248
  prev = (SPF_dns_cache_bucket_t *)((void *)0);
#line 249
  time(& now);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
#line 252
    rr = bucket->rr;
#line 254
    if (rr->utc_ttl < now) {
#line 256
      if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 257
        prev->next = bucket->next;
      } else {
#line 259
        *(spfhook->cache + idx) = bucket->next;
      }
#line 261
      if (bucket->rr) {
        {
#line 262
        SPF_dns_rr_free(bucket->rr);
        }
      }
      {
#line 263
      free((void *)bucket);
#line 265
      bucket = prev;
      }
    } else
#line 267
    if (! ((unsigned int )rr->rr_type != (unsigned int )rr_type)) {
      {
#line 270
      tmp = strcmp((char const   *)rr->domain, domain);
      }
#line 270
      if (! (tmp != 0)) {
#line 275
        if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 276
          prev->next = bucket->next;
#line 277
          bucket->next = *(spfhook->cache + idx);
#line 278
          *(spfhook->cache + idx) = bucket;
        }
#line 280
        return (bucket);
      }
    }
#line 283
    prev = bucket;
#line 284
    if ((unsigned long )bucket == (unsigned long )((void *)0)) {
#line 285
      bucket = *(spfhook->cache + idx);
    } else {
#line 287
      bucket = bucket->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return ((SPF_dns_cache_bucket_t *)((void *)0));
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_bucket_add___1(SPF_dns_cache_config_t *spfhook ,
                                                  SPF_dns_rr_t *rr , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  void *tmp ;

  {
  {
#line 300
  tmp = malloc(sizeof(SPF_dns_cache_bucket_t ));
#line 300
  bucket = (SPF_dns_cache_bucket_t *)tmp;
  }
#line 302
  if (! bucket) {
#line 303
    return ((SPF_errcode_t )1);
  }
#line 304
  bucket->next = *(spfhook->cache + idx);
#line 305
  *(spfhook->cache + idx) = bucket;
#line 306
  bucket->rr = rr;
#line 307
  return ((SPF_errcode_t )0);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_rr_fixup___1(SPF_dns_cache_config_t *spfhook ,
                                                SPF_dns_rr_t *cached_rr , char const   *domain ,
                                                ns_type rr_type ) 
{ 
  char *p ;
  char *new_domain ;
  size_t new_len ;
  size_t tmp ;
  void *tmp___0 ;
  time_t tmp___1 ;

  {
#line 322
  if ((unsigned int )cached_rr->rr_type == 255U) {
#line 323
    cached_rr->rr_type = rr_type;
  }
#line 326
  if ((unsigned long )cached_rr->domain == (unsigned long )((void *)0)) {
#line 326
    goto _L;
  } else
#line 326
  if ((int )*(cached_rr->domain + 0) != 0) {
    _L: /* CIL Label */ 
    {
#line 328
    tmp = strlen(domain);
#line 328
    new_len = tmp + 1UL;
    }
#line 330
    if (cached_rr->domain_buf_len < new_len) {
      {
#line 331
      tmp___0 = realloc((void *)cached_rr->domain, new_len);
#line 331
      new_domain = (char *)tmp___0;
      }
#line 332
      if ((unsigned long )new_domain == (unsigned long )((void *)0)) {
#line 333
        return ((SPF_errcode_t )1);
      }
#line 334
      cached_rr->domain = new_domain;
#line 335
      cached_rr->domain_buf_len = new_len;
    }
    {
#line 337
    strcpy((char */* __restrict  */)cached_rr->domain, (char const   */* __restrict  */)domain);
    }
  }
#line 341
  if (cached_rr->ttl < spfhook->min_ttl) {
#line 342
    cached_rr->ttl = spfhook->min_ttl;
  }
#line 344
  if (cached_rr->ttl < spfhook->txt_ttl) {
#line 344
    if ((unsigned int )cached_rr->rr_type == 16U) {
#line 346
      cached_rr->ttl = spfhook->txt_ttl;
    }
  }
#line 348
  if (cached_rr->ttl < spfhook->err_ttl) {
#line 348
    if (cached_rr->herrno != 0) {
#line 350
      cached_rr->ttl = spfhook->err_ttl;
    }
  }
#line 352
  if (cached_rr->ttl < spfhook->rdns_ttl) {
    {
#line 353
    p = strstr((char const   *)cached_rr->domain, ".arpa");
    }
#line 354
    if (p) {
#line 354
      if ((int )*(p + (sizeof(".arpa") - 1UL)) == 0) {
#line 355
        cached_rr->ttl = spfhook->rdns_ttl;
      }
    }
  }
  {
#line 358
  tmp___1 = time((time_t *)((void *)0));
#line 358
  cached_rr->utc_ttl = cached_rr->ttl + tmp___1;
  }
#line 360
  return ((SPF_errcode_t )0);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_rr_t *SPF_dns_cache_lookup___1(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                              ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_rr_t *cached_rr ;
  SPF_dns_rr_t *rr ;
  int idx ;
  SPF_errcode_t tmp ;
  SPF_dns_rr_t *tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;

  {
  {
#line 377
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
#line 381
  idx = crc32str(0U, domain, spfhook->max_hash_len);
#line 382
  idx &= spfhook->cache_size - 1;
#line 384
  pthread_mutex_lock(& spfhook->cache_lock);
#line 386
  bucket = SPF_dns_cache_bucket_find___1(spfhook, domain, rr_type, idx);
  }
#line 387
  if ((unsigned long )bucket != (unsigned long )((void *)0)) {
#line 388
    if ((unsigned long )bucket->rr != (unsigned long )((void *)0)) {
      {
#line 389
      tmp = SPF_dns_rr_dup(& rr, bucket->rr);
      }
#line 389
      if ((unsigned int )tmp == 0U) {
        {
#line 390
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 391
        return (rr);
      } else
#line 393
      if ((unsigned long )rr != (unsigned long )((void *)0)) {
        {
#line 394
        SPF_dns_rr_free(rr);
        }
      }
    }
  }
  {
#line 401
  bucket = (SPF_dns_cache_bucket_t *)((void *)0);
#line 403
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 405
  if (! spf_dns_server->layer_below) {
    {
#line 406
    tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
    }
#line 406
    return (tmp___0);
  }
  {
#line 408
  rr = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
  }
#line 410
  if (spfhook->conserve_cache) {
#line 410
    if (! should_cache) {
#line 411
      return (rr);
    }
  }
  {
#line 413
  pthread_mutex_lock(& spfhook->cache_lock);
#line 415
  tmp___3 = SPF_dns_rr_dup(& cached_rr, rr);
  }
#line 415
  if ((unsigned int )tmp___3 == 0U) {
    {
#line 416
    tmp___2 = SPF_dns_cache_rr_fixup___1(spfhook, cached_rr, domain, rr_type);
    }
#line 416
    if ((unsigned int )tmp___2 == 0U) {
      {
#line 417
      tmp___1 = SPF_dns_cache_bucket_add___1(spfhook, cached_rr, idx);
      }
#line 417
      if ((unsigned int )tmp___1 == 0U) {
        {
#line 418
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 419
        return (rr);
      }
    }
  }
  {
#line 424
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 426
  if (cached_rr) {
    {
#line 427
    SPF_dns_rr_free(cached_rr);
    }
  }
#line 429
  return (rr);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static void SPF_dns_cache_free___1(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  int i ;

  {
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 442
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
                 442, "%s", "spf_dns_server is NULL");
      }
    }
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
  }
#line 445
  if (spfhook) {
    {
#line 446
    pthread_mutex_lock(& spfhook->cache_lock);
    }
#line 448
    if (spfhook->cache) {
#line 449
      i = 0;
      {
#line 449
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 449
        if (! (i < spfhook->cache_size)) {
#line 449
          goto while_break___0;
        }
#line 450
        bucket = *(spfhook->cache + i);
        {
#line 451
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 451
          if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 451
            goto while_break___1;
          }
#line 452
          prev = bucket;
#line 453
          bucket = bucket->next;
#line 456
          if (prev->rr) {
            {
#line 457
            SPF_dns_rr_free(prev->rr);
            }
          }
          {
#line 458
          free((void *)prev);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 449
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 461
      free((void *)spfhook->cache);
#line 462
      spfhook->cache = (SPF_dns_cache_bucket_t **)((void *)0);
      }
    }
    {
#line 465
    pthread_mutex_unlock(& spfhook->cache_lock);
#line 476
    pthread_mutex_destroy(& spfhook->cache_lock);
#line 478
    free((void *)spfhook);
    }
  }
  {
#line 481
  free((void *)spf_dns_server);
  }
#line 482
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_find___1(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                           ns_type rr_type , int exact ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;
  int tmp ;
  size_t domain_len ;
  size_t tmp___0 ;
  size_t zdomain_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 103
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 105
  if (spf_dns_server->debug) {
    {
#line 106
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
               106, "zone: Searching for RR %s (%d)", domain, (unsigned int )rr_type);
    }
  }
#line 110
  if (exact) {
#line 110
    goto _L;
  } else {
    {
#line 110
    tmp___6 = strncmp(domain, "*.", (size_t )2);
    }
#line 110
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
#line 111
      i = 0;
      {
#line 111
      while (1) {
        while_continue: /* CIL Label */ ;
#line 111
        if (! (i < spfhook->num_zone)) {
#line 111
          goto while_break;
        }
#line 112
        if ((unsigned int )(*(spfhook->zone + i))->rr_type == (unsigned int )rr_type) {
          {
#line 112
          tmp = strcasecmp((char const   *)(*(spfhook->zone + i))->domain, domain);
          }
#line 112
          if (tmp == 0) {
#line 114
            return (*(spfhook->zone + i));
          }
        }
#line 111
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 116
      if (spf_dns_server->debug) {
        {
#line 117
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   117, "zone: Exact not found");
        }
      }
    } else {
      {
#line 121
      tmp___0 = strlen(domain);
#line 121
      domain_len = tmp___0;
      }
#line 125
      if (domain_len) {
#line 125
        if ((int const   )*(domain + (domain_len - 1UL)) == 46) {
#line 126
          domain_len --;
        }
      }
#line 128
      i = 0;
      {
#line 128
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 128
        if (! (i < spfhook->num_zone)) {
#line 128
          goto while_break___0;
        }
#line 129
        if ((unsigned int )(*(spfhook->zone + i))->rr_type != (unsigned int )rr_type) {
#line 129
          if ((unsigned int )(*(spfhook->zone + i))->rr_type != 255U) {
#line 131
            if (spf_dns_server->debug) {
              {
#line 132
              SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                         133, "zone: Ignoring record rrtype %d", (unsigned int )(*(spfhook->zone + i))->rr_type);
              }
            }
#line 134
            goto __Cont;
          }
        }
        {
#line 137
        tmp___5 = strncmp((char const   *)(*(spfhook->zone + i))->domain, "*.", (size_t )2);
        }
#line 137
        if (tmp___5 == 0) {
          {
#line 138
          tmp___1 = strlen((char const   *)(*(spfhook->zone + i))->domain);
#line 138
          zdomain_len = tmp___1 - 2UL;
          }
#line 139
          if (zdomain_len <= domain_len) {
            {
#line 139
            tmp___2 = strncasecmp((char const   *)((*(spfhook->zone + i))->domain + 2),
                                  domain + (domain_len - zdomain_len), zdomain_len);
            }
#line 139
            if (tmp___2 == 0) {
#line 144
              return (*(spfhook->zone + i));
            }
          }
        } else {
          {
#line 146
          tmp___3 = strncasecmp((char const   *)(*(spfhook->zone + i))->domain, domain,
                                domain_len);
          }
#line 146
          if (tmp___3 == 0) {
            {
#line 146
            tmp___4 = strlen((char const   *)(*(spfhook->zone + i))->domain);
            }
#line 146
            if (tmp___4 == domain_len) {
#line 151
              return (*(spfhook->zone + i));
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 128
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 154
      if (spf_dns_server->debug) {
        {
#line 155
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   155, "zone: Non-exact not found");
        }
      }
    }
  }
#line 158
  return ((SPF_dns_rr_t *)((void *)0));
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_lookup___1(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  SPF_dns_rr_t *spfrr ;
  SPF_dns_rr_t *tmp ;

  {
  {
#line 170
  spfrr = SPF_dns_zone_find___1(spf_dns_server, domain, rr_type, 0);
  }
#line 171
  if (spfrr) {
    {
#line 172
    SPF_dns_rr_dup(& spfrr, spfrr);
    }
#line 173
    return (spfrr);
  }
#line 176
  if (spf_dns_server->layer_below) {
    {
#line 177
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 177
    return (tmp);
  }
  {
#line 181
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
#line 182
  SPF_dns_rr_dup(& spfrr, spfhook->nxdomain);
  }
#line 184
  return (spfrr);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static void SPF_dns_zone_free___1(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 317
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                 317, "%s", "spf_dns_server is NULL");
      }
    }
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 320
  if (spfhook) {
#line 321
    if (spfhook->zone) {
#line 322
      i = 0;
      {
#line 322
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 322
        if (! (i < spfhook->zone_buf_len)) {
#line 322
          goto while_break___0;
        }
#line 323
        if (*(spfhook->zone + i)) {
          {
#line 324
          SPF_dns_rr_free(*(spfhook->zone + i));
          }
        }
#line 322
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 326
      free((void *)spfhook->zone);
      }
    }
#line 328
    if (spfhook->nxdomain) {
      {
#line 329
      SPF_dns_rr_free(spfhook->nxdomain);
      }
    }
    {
#line 330
    free((void *)spfhook);
    }
  }
  {
#line 333
  free((void *)spf_dns_server);
  }
#line 334
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static struct res_sym  const  ns_sects___1[4]  = {      {0, (char *)"QUESTION", (char *)"Question"}, 
        {1, (char *)"ANSWER", (char *)"Answer"}, 
        {2, (char *)"AUTHORITY", (char *)"Authority"}, 
        {3, (char *)"ADDITIONAL", (char *)"Additional"}};
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static int const   num_ns_sect___1  =    (int const   )(sizeof(ns_sects___1) / sizeof(ns_sects___1[0]));
#line 89 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_once_t res_state_control___1  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_key_t res_state_key___1  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_thread_term___1(void *arg ) 
{ 


  {
  {
#line 98
  __res_nclose((struct __res_state *)arg);
#line 100
  free(arg);
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_init_key___1(void) 
{ 


  {
  {
#line 106
  pthread_key_create(& res_state_key___1, & SPF_dns_resolv_thread_term___1);
  }
#line 107
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_debug___1(SPF_dns_server_t *spf_dns_server , ns_rr rr ,
                                     u_char const   *responsebuf , size_t responselen ,
                                     u_char const   *rdata , size_t rdlen ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char name_buf[1025] ;
  int prio ;
  int err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  u_int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 123
  if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 123
    goto case_1;
  }
#line 132
  if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 132
    goto case_28;
  }
#line 141
  if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 141
    goto case_2;
  }
#line 153
  if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 153
    goto case_5;
  }
#line 165
  if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 165
    goto case_15;
  }
#line 182
  if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 182
    goto case_16;
  }
#line 193
  if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 193
    goto case_12;
  }
#line 205
  goto switch_default;
  case_1: /* CIL Label */ 
#line 124
  if (rdlen != 4UL) {
    {
#line 125
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               125, "A: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 127
    tmp = inet_ntop(2, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip4_buf),
                    (socklen_t )sizeof(ip4_buf));
#line 127
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               129, "A: %s", tmp);
    }
  }
#line 130
  goto switch_break;
  case_28: /* CIL Label */ 
#line 133
  if (rdlen != 16UL) {
    {
#line 134
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               134, "AAAA: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 136
    tmp___0 = inet_ntop(10, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip6_buf),
                        (socklen_t )sizeof(ip6_buf));
#line 136
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               138, "AAAA: %s", tmp___0);
    }
  }
#line 139
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 142
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 146
  if (err < 0) {
    {
#line 147
    tmp___1 = __errno_location();
#line 147
    tmp___2 = __errno_location();
#line 147
    tmp___3 = strerror(*tmp___2);
#line 147
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               148, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___3,
               *tmp___1);
    }
  } else {
    {
#line 150
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               150, "NS: %s", name_buf);
    }
  }
#line 151
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 154
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 158
  if (err < 0) {
    {
#line 159
    tmp___4 = __errno_location();
#line 159
    tmp___5 = __errno_location();
#line 159
    tmp___6 = strerror(*tmp___5);
#line 159
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               160, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___6,
               *tmp___4);
    }
  } else {
    {
#line 162
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               162, "CNAME: %s", name_buf);
    }
  }
#line 163
  goto switch_break;
  case_15: /* CIL Label */ 
#line 166
  if (rdlen < 2UL) {
    {
#line 167
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               167, "MX: rdlen too short: %lu", rdlen);
    }
#line 168
    goto switch_break;
  }
  {
#line 170
  tmp___7 = ns_get16(rdata);
#line 170
  prio = (int )tmp___7;
#line 171
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata + 2, name_buf,
                           sizeof(name_buf));
  }
#line 175
  if (err < 0) {
    {
#line 176
    tmp___8 = __errno_location();
#line 176
    tmp___9 = __errno_location();
#line 176
    tmp___10 = strerror(*tmp___9);
#line 176
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               177, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___10,
               *tmp___8);
    }
  } else {
    {
#line 179
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               179, "MX: %d %s", prio, name_buf);
    }
  }
#line 180
  goto switch_break;
  case_16: /* CIL Label */ 
#line 183
  if (rdlen < 1UL) {
    {
#line 184
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               184, "TXT: rdlen too short: %lu", rdlen);
    }
#line 185
    goto switch_break;
  }
  {
#line 189
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             190, "TXT: (%lu) \"%.*s\"", rdlen, (int )rdlen - 1, rdata + 1);
  }
#line 191
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 194
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 198
  if (err < 0) {
    {
#line 199
    tmp___11 = __errno_location();
#line 199
    tmp___12 = __errno_location();
#line 199
    tmp___13 = strerror(*tmp___12);
#line 199
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               200, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___13,
               *tmp___11);
    }
  } else {
    {
#line 202
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               202, "PTR: %s", name_buf);
    }
  }
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 206
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             206, "not parsed:  type: %d", (unsigned int )((ns_type )((int )rr.type)));
  }
#line 207
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static SPF_dns_rr_t *SPF_dns_resolv_lookup___1(SPF_dns_server_t *spf_dns_server ,
                                               char const   *domain , ns_type rr_type ,
                                               int should_cache ) 
{ 
  SPF_dns_rr_t *spfrr ;
  int err ;
  int i ;
  int nrec ;
  int cnt ;
  u_char *responsebuf ;
  size_t responselen ;
  ns_msg ns_handle ;
  ns_rr rr ;
  int ns_sect___0 ;
  char name_buf[1025] ;
  size_t rdlen ;
  u_char const   *rdata ;
  void *res_spec ;
  struct __res_state *res_state___0 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int dns_len ;
  char const   *tmp___2 ;
  SPF_dns_rr_t *tmp___3 ;
  SPF_dns_rr_t *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  SPF_errcode_t tmp___20 ;
  SPF_errcode_t tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  SPF_errcode_t tmp___26 ;
  u_char *src ;
  u_char *dst ;
  size_t len ;
  SPF_errcode_t tmp___27 ;
  SPF_errcode_t tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  SPF_errcode_t tmp___33 ;

  {
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 247
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 247, "%s", "spf_dns_server is NULL");
      }
    }
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  res_spec = pthread_getspecific(res_state_key___1);
  }
#line 252
  if ((unsigned long )res_spec == (unsigned long )((void *)0)) {
    {
#line 253
    tmp = malloc(sizeof(struct __res_state ));
#line 253
    res_state___0 = (struct __res_state *)tmp;
    }
#line 257
    if (! res_state___0) {
      {
#line 258
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 259, "Failed to allocate %lu bytes for res_state", sizeof(struct __res_state ));
      }
    }
    {
#line 260
    memset((void *)res_state___0, 0, sizeof(struct __res_state ));
#line 261
    tmp___0 = __res_ninit(res_state___0);
    }
#line 261
    if (tmp___0 != 0) {
      {
#line 262
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 262, "%s", "Failed to call res_ninit()");
      }
    }
    {
#line 263
    pthread_setspecific(res_state_key___1, (void const   *)((void *)res_state___0));
    }
  } else {
#line 266
    res_state___0 = (struct __res_state *)res_spec;
  }
  {
#line 270
  responselen = (size_t )2048;
#line 271
  tmp___1 = malloc(responselen);
#line 271
  responsebuf = (u_char *)tmp___1;
  }
#line 272
  if (! responsebuf) {
#line 273
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 274
  memset((void *)responsebuf, 0, responselen);
  }
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 297
    dns_len = __res_nquery(res_state___0, domain, 1, (int )rr_type, responsebuf, (int )responselen);
    }
#line 304
    if (dns_len < 0) {
      {
#line 307
      free((void *)responsebuf);
      }
#line 308
      if (spf_dns_server->debug) {
        {
#line 309
        tmp___2 = hstrerror(res_state___0->res_h_errno);
#line 309
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   311, "query failed: err = %d  %s (%d): %s", dns_len, tmp___2, res_state___0->res_h_errno,
                   domain);
        }
      }
#line 312
      if (res_state___0->res_h_errno == 1) {
#line 312
        if ((unsigned long )spf_dns_server->layer_below != (unsigned long )((void *)0)) {
          {
#line 314
          tmp___3 = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
          }
#line 314
          return (tmp___3);
        }
      }
      {
#line 317
      tmp___4 = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, res_state___0->res_h_errno);
      }
#line 317
      return (tmp___4);
    } else
#line 320
    if ((size_t )dns_len > responselen) {
      {
#line 323
      responselen = (size_t )(dns_len + (dns_len >> 1));
#line 332
      tmp___5 = realloc((void *)responsebuf, responselen);
      }
#line 333
      if (! tmp___5) {
        {
#line 334
        free((void *)responsebuf);
        }
#line 335
        return ((SPF_dns_rr_t *)((void *)0));
      }
#line 337
      responsebuf = (u_char *)tmp___5;
    } else {
#line 341
      responselen = (size_t )dns_len;
#line 342
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 351
  spfrr = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, 0);
  }
#line 353
  if (! spfrr) {
    {
#line 354
    free((void *)responsebuf);
    }
#line 355
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 358
  err = ns_initparse((u_char const   *)responsebuf, (int )responselen, & ns_handle);
  }
#line 360
  if (err < 0) {
#line 361
    if (spf_dns_server->debug) {
      {
#line 362
      tmp___6 = __errno_location();
#line 362
      tmp___7 = __errno_location();
#line 362
      tmp___8 = strerror(*tmp___7);
#line 362
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 363, "ns_initparse failed: err = %d  %s (%d)", err, tmp___8, *tmp___6);
      }
    }
    {
#line 364
    free((void *)responsebuf);
#line 367
    spfrr->herrno = 3;
    }
#line 368
    return (spfrr);
  }
#line 372
  if (spf_dns_server->debug > 1) {
    {
#line 373
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               373, "msg id:             %d", (int )ns_handle._id);
#line 374
    tmp___9 = ns_msg_getflag(ns_handle, 0);
#line 374
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               374, "ns_f_qr quest/resp: %d", tmp___9);
#line 375
    tmp___10 = ns_msg_getflag(ns_handle, 1);
#line 375
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               375, "ns_f_opcode:        %d", tmp___10);
#line 376
    tmp___11 = ns_msg_getflag(ns_handle, 2);
#line 376
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               376, "ns_f_aa auth ans:   %d", tmp___11);
#line 377
    tmp___12 = ns_msg_getflag(ns_handle, 3);
#line 377
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               377, "ns_f_tc truncated:  %d", tmp___12);
#line 378
    tmp___13 = ns_msg_getflag(ns_handle, 4);
#line 378
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               378, "ns_f_rd rec desire: %d", tmp___13);
#line 379
    tmp___14 = ns_msg_getflag(ns_handle, 5);
#line 379
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               379, "ns_f_ra rec avail:  %d", tmp___14);
#line 380
    tmp___15 = ns_msg_getflag(ns_handle, 9);
#line 380
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               380, "ns_f_rcode:         %d", tmp___15);
    }
  }
#line 385
  ns_sect___0 = 0;
  {
#line 385
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 385
    if (! (ns_sect___0 < (int )num_ns_sect___1)) {
#line 385
      goto while_break___1;
    }
#line 391
    if (ns_sects___1[ns_sect___0].number != 1) {
#line 391
      if (spf_dns_server->debug <= 1) {
#line 392
        goto __Cont;
      }
    }
#line 394
    nrec = (int )ns_handle._counts[ns_sects___1[ns_sect___0].number];
#line 396
    if (spf_dns_server->debug > 1) {
      {
#line 397
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 397, "%s:  %d", ns_sects___1[ns_sect___0].name, nrec);
      }
    }
#line 399
    spfrr->num_rr = 0;
#line 400
    cnt = 0;
#line 401
    i = 0;
    {
#line 401
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 401
      if (! (i < nrec)) {
#line 401
        goto while_break___2;
      }
      {
#line 402
      err = ns_parserr(& ns_handle, (ns_sect )ns_sects___1[ns_sect___0].number, i,
                       & rr);
      }
#line 403
      if (err < 0) {
#line 404
        if (spf_dns_server->debug > 1) {
          {
#line 405
          tmp___16 = __errno_location();
#line 405
          tmp___17 = __errno_location();
#line 405
          tmp___18 = strerror(*tmp___17);
#line 405
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     406, "ns_parserr failed: err = %d  %s (%d)", err, tmp___18, *tmp___16);
          }
        }
        {
#line 407
        free((void *)responsebuf);
#line 410
        spfrr->herrno = 3;
        }
#line 411
        return (spfrr);
      }
#line 414
      rdlen = (size_t )((int )rr.rdlength);
#line 415
      if (spf_dns_server->debug > 1) {
#line 416
        if ((int )rr.name[0] != 0) {
#line 416
          tmp___19 = (char const   *)(rr.name);
        } else {
#line 416
          tmp___19 = ".";
        }
        {
#line 416
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   418, "name: %s  type: %d  class: %d  ttl: %d  rdlen: %lu", tmp___19,
                   (unsigned int )((ns_type )((int )rr.type)), (unsigned int )((ns_class )((int )rr.rr_class)),
                   rr.ttl, rdlen);
        }
      }
#line 420
      if (rdlen <= 0UL) {
#line 421
        goto __Cont___0;
      }
#line 423
      rdata = rr.rdata + 0;
#line 425
      if (spf_dns_server->debug > 1) {
        {
#line 426
        SPF_dns_resolv_debug___1(spf_dns_server, rr, (u_char const   *)responsebuf,
                                 responselen, rdata, rdlen);
        }
      }
#line 430
      if (ns_sects___1[ns_sect___0].number != 1) {
#line 431
        goto __Cont___0;
      }
#line 434
      if ((unsigned int )((ns_type )((int )rr.type)) != (unsigned int )spfrr->rr_type) {
#line 434
        if ((unsigned int )((ns_type )((int )rr.type)) != 5U) {
          {
#line 435
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     436, "unexpected rr type: %d   expected: %d", (unsigned int )((ns_type )((int )rr.type)),
                     (unsigned int )rr_type);
          }
#line 437
          goto __Cont___0;
        }
      }
      {
#line 441
      if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 441
        goto case_1;
      }
#line 458
      if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 458
        goto case_28;
      }
#line 475
      if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 475
        goto case_2;
      }
#line 478
      if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 478
        goto case_5;
      }
#line 482
      if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 482
        goto case_15;
      }
#line 513
      if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 513
        goto case_16;
      }
#line 562
      if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 562
        goto case_12;
      }
#line 588
      goto switch_default;
      case_1: /* CIL Label */ 
#line 442
      if (rdlen != 4UL) {
        {
#line 444
        free((void *)responsebuf);
        }
#line 445
        return (spfrr);
      }
      {
#line 447
      tmp___20 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->a));
      }
#line 447
      if ((unsigned int )tmp___20 != 0U) {
        {
#line 449
        free((void *)responsebuf);
        }
#line 452
        return (spfrr);
      }
      {
#line 454
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->a), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->a));
#line 455
      cnt ++;
      }
#line 456
      goto switch_break;
      case_28: /* CIL Label */ 
#line 459
      if (rdlen != 16UL) {
        {
#line 461
        free((void *)responsebuf);
        }
#line 462
        return (spfrr);
      }
      {
#line 464
      tmp___21 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->aaaa));
      }
#line 464
      if ((unsigned int )tmp___21 != 0U) {
        {
#line 466
        free((void *)responsebuf);
        }
#line 469
        return (spfrr);
      }
      {
#line 471
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->aaaa), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->aaaa));
#line 472
      cnt ++;
      }
#line 473
      goto switch_break;
      case_2: /* CIL Label */ 
#line 476
      goto switch_break;
      case_5: /* CIL Label */ 
#line 480
      goto switch_break;
      case_15: /* CIL Label */ 
#line 483
      if (rdlen < 2UL) {
        {
#line 485
        free((void *)responsebuf);
        }
#line 486
        return (spfrr);
      }
      {
#line 488
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata + 2, name_buf, sizeof(name_buf));
      }
#line 492
      if (err < 0) {
#line 493
        if (spf_dns_server->debug > 1) {
          {
#line 494
          tmp___22 = __errno_location();
#line 494
          tmp___23 = __errno_location();
#line 494
          tmp___24 = strerror(*tmp___23);
#line 494
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     495, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___24,
                     *tmp___22);
          }
        }
        {
#line 496
        free((void *)responsebuf);
        }
#line 499
        return (spfrr);
      }
      {
#line 502
      tmp___25 = strlen((char const   *)(name_buf));
#line 502
      tmp___26 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___25 + 1UL);
      }
#line 502
      if ((unsigned int )tmp___26 != 0U) {
        {
#line 504
        free((void *)responsebuf);
        }
#line 507
        return (spfrr);
      }
      {
#line 509
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->mx), (char const   */* __restrict  */)(name_buf));
#line 510
      cnt ++;
      }
#line 511
      goto switch_break;
      case_16: /* CIL Label */ 
#line 514
      if (rdlen > 1UL) {
        {
#line 520
        tmp___27 = SPF_dns_rr_buf_realloc(spfrr, cnt, rdlen);
        }
#line 520
        if ((unsigned int )tmp___27 != 0U) {
          {
#line 521
          free((void *)responsebuf);
          }
#line 524
          return (spfrr);
        }
#line 527
        dst = (u_char *)((*(spfrr->rr + cnt))->txt);
#line 528
        src = (u_char *)rdata;
#line 529
        len = (size_t )0;
        {
#line 530
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 530
          if (! (rdlen > 0UL)) {
#line 530
            goto while_break___3;
          }
#line 532
          len = (size_t )*src;
#line 533
          src ++;
#line 534
          rdlen --;
#line 538
          if (len > rdlen) {
#line 539
            len = rdlen;
          }
          {
#line 540
          memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src,
                 len);
#line 543
          src += len;
#line 544
          dst += len;
#line 545
          rdlen -= len;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 547
        *dst = (u_char )'\000';
      } else {
        {
#line 550
        tmp___28 = SPF_dns_rr_buf_realloc(spfrr, cnt, (size_t )1);
        }
#line 550
        if ((unsigned int )tmp___28 != 0U) {
          {
#line 551
          free((void *)responsebuf);
          }
#line 554
          return (spfrr);
        }
#line 556
        (*(spfrr->rr + cnt))->txt[0] = (char )'\000';
      }
#line 559
      cnt ++;
#line 560
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 563
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata, name_buf, sizeof(name_buf));
      }
#line 567
      if (err < 0) {
#line 568
        if (spf_dns_server->debug > 1) {
          {
#line 569
          tmp___29 = __errno_location();
#line 569
          tmp___30 = __errno_location();
#line 569
          tmp___31 = strerror(*tmp___30);
#line 569
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     570, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___31,
                     *tmp___29);
          }
        }
        {
#line 571
        free((void *)responsebuf);
        }
#line 574
        return (spfrr);
      }
      {
#line 577
      tmp___32 = strlen((char const   *)(name_buf));
#line 577
      tmp___33 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___32 + 1UL);
      }
#line 577
      if ((unsigned int )tmp___33 != 0U) {
        {
#line 579
        free((void *)responsebuf);
        }
#line 582
        return (spfrr);
      }
      {
#line 584
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->ptr), (char const   */* __restrict  */)(name_buf));
#line 585
      cnt ++;
      }
#line 586
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 589
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 401
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 593
    spfrr->num_rr = cnt;
    __Cont: /* CIL Label */ 
#line 385
    ns_sect___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 596
  if (spfrr->num_rr == 0) {
#line 597
    spfrr->herrno = 4;
  }
  {
#line 599
  free((void *)responsebuf);
  }
#line 600
  return (spfrr);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_free___1(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 607
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 607, "%s", "spf_dns_server is NULL");
      }
    }
#line 607
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  free((void *)spf_dns_server);
  }
#line 614
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c"
static SPF_errcode_t SPF_server_get_default_explanation___1(SPF_server_t *spf_server___1 ,
                                                            SPF_request_t *spf_request ,
                                                            SPF_response_t *spf_response ,
                                                            char **bufp , size_t *buflenp ) 
{ 
  SPF_errcode_t err ;
  SPF_macro_t *spf_macro ;
  SPF_data_t *tmp ;
  size_t len ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  spf_macro = spf_server___1->explanation;
#line 56
  if ((unsigned long )spf_macro != (unsigned long )((void *)0)) {
    {
#line 57
    tmp = SPF_macro_data(spf_macro);
#line 57
    err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, tmp, spf_macro->macro_len,
                                 bufp, buflenp);
    }
#line 61
    return (err);
  } else {
#line 64
    len = sizeof("SPF failure: no explanation available") + 1UL;
#line 65
    if (*buflenp < len) {
      {
#line 66
      tmp___1 = realloc((void *)*bufp, len);
#line 66
      tmp___0 = (char *)tmp___1;
      }
#line 67
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 68
        return ((SPF_errcode_t )1);
      }
#line 69
      *bufp = tmp___0;
#line 70
      *buflenp = len;
    }
    {
#line 72
    strcpy((char */* __restrict  */)*bufp, (char const   */* __restrict  */)"SPF failure: no explanation available");
    }
#line 73
    return ((SPF_errcode_t )0);
  }
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c"
static SPF_errcode_t SPF_record_stringify_data___2(SPF_data_t *data , SPF_data_t *data_end ,
                                                   char **p_p , char *p_end , int is_mod ,
                                                   int cidr_ok , int debug ) 
{ 
  char *p ;
  size_t len ;
  SPF_data_t *cidr_data ;
  char *s ;
  char *tmp ;
  char *s_end ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 48
  p = *p_p;
#line 54
  if (debug) {
    {
#line 55
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
               55, " string data: Building");
    }
  }
#line 57
  if (p_end - p <= 0L) {
#line 58
    return ((SPF_errcode_t )10);
  }
#line 60
  cidr_data = (SPF_data_t *)((void *)0);
#line 61
  if ((unsigned long )data < (unsigned long )data_end) {
#line 61
    if ((int )data->dc.parm_type == 11) {
#line 63
      if (debug) {
        {
#line 64
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   64, " string data: Found a CIDR at %p", data);
        }
      }
#line 65
      if (! cidr_ok) {
#line 66
        return ((SPF_errcode_t )10);
      }
      {
#line 68
      cidr_data = data;
#line 69
      data = SPF_data_next(data);
      }
    }
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )data < (unsigned long )data_end)) {
#line 73
      goto while_break;
    }
#line 75
    if (debug) {
      {
#line 76
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 77, " string data: Handling data type %d at %p", (int )data->ds.parm_type,
                 data);
      }
    }
#line 78
    if ((int )data->ds.parm_type == 12) {
      {
#line 80
      tmp = SPF_data_str(data);
#line 80
      s = tmp;
#line 81
      s_end = s + (int )data->ds.len;
      }
#line 82
      if (debug) {
        {
#line 83
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   84, " string data: String is [%d] \'%*.*s\'", (int )data->ds.len,
                   (int )data->ds.len, (int )data->ds.len, s);
        }
      }
#line 86
      if (p_end - (p + (int )data->ds.len) <= 0L) {
#line 87
        return ((SPF_errcode_t )10);
      }
      {
#line 89
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 89
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 89
          goto while_break___0;
        }
#line 90
        if ((int )*s == 32) {
#line 91
          tmp___0 = p;
#line 91
          p ++;
#line 91
          *tmp___0 = (char )'%';
#line 92
          tmp___1 = p;
#line 92
          p ++;
#line 92
          *tmp___1 = (char )'_';
#line 93
          s ++;
        } else
#line 95
        if ((int )*s == 37) {
#line 96
          tmp___2 = p;
#line 96
          p ++;
#line 96
          *tmp___2 = (char )'%';
#line 97
          s ++;
#line 98
          if ((int )*(s + 0) == 50) {
#line 98
            if ((int )*(s + 1) == 48) {
#line 99
              tmp___3 = p;
#line 99
              p ++;
#line 99
              *tmp___3 = (char )'-';
#line 100
              s += 2;
            } else {
#line 103
              tmp___4 = p;
#line 103
              p ++;
#line 103
              *tmp___4 = (char )'%';
            }
          } else {
#line 103
            tmp___4 = p;
#line 103
            p ++;
#line 103
            *tmp___4 = (char )'%';
          }
        } else {
#line 108
          tmp___5 = p;
#line 108
          p ++;
#line 108
          tmp___6 = s;
#line 108
          s ++;
#line 108
          *tmp___5 = *tmp___6;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 112
      if (p_end - p <= 0L) {
#line 113
        return ((SPF_errcode_t )10);
      }
    } else
#line 115
    if ((int )data->dc.parm_type == 11) {
#line 117
      return ((SPF_errcode_t )8);
    } else {
      {
#line 120
      tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%%{");
#line 120
      len = (size_t )tmp___7;
#line 121
      p += len;
      }
#line 122
      if (p_end - p <= 0L) {
#line 122
        return ((SPF_errcode_t )10);
      }
#line 125
      if (p_end - p <= 1L) {
#line 125
        return ((SPF_errcode_t )10);
      }
      {
#line 128
      if ((int )data->dv.parm_type == 0) {
#line 128
        goto case_0;
      }
#line 132
      if ((int )data->dv.parm_type == 1) {
#line 132
        goto case_1;
      }
#line 136
      if ((int )data->dv.parm_type == 2) {
#line 136
        goto case_2;
      }
#line 140
      if ((int )data->dv.parm_type == 3) {
#line 140
        goto case_3;
      }
#line 144
      if ((int )data->dv.parm_type == 4) {
#line 144
        goto case_4;
      }
#line 148
      if ((int )data->dv.parm_type == 5) {
#line 148
        goto case_5;
      }
#line 152
      if ((int )data->dv.parm_type == 6) {
#line 152
        goto case_6;
      }
#line 158
      if ((int )data->dv.parm_type == 7) {
#line 158
        goto case_7;
      }
#line 162
      if ((int )data->dv.parm_type == 8) {
#line 162
        goto case_8;
      }
#line 166
      if ((int )data->dv.parm_type == 9) {
#line 166
        goto case_9;
      }
#line 170
      if ((int )data->dv.parm_type == 10) {
#line 170
        goto case_10;
      }
#line 174
      goto switch_default;
      case_0: /* CIL Label */ 
#line 129
      *p = (char )'l';
#line 130
      goto switch_break;
      case_1: /* CIL Label */ 
#line 133
      *p = (char )'s';
#line 134
      goto switch_break;
      case_2: /* CIL Label */ 
#line 137
      *p = (char )'o';
#line 138
      goto switch_break;
      case_3: /* CIL Label */ 
#line 141
      *p = (char )'d';
#line 142
      goto switch_break;
      case_4: /* CIL Label */ 
#line 145
      *p = (char )'i';
#line 146
      goto switch_break;
      case_5: /* CIL Label */ 
#line 149
      *p = (char )'c';
#line 150
      goto switch_break;
      case_6: /* CIL Label */ 
#line 153
      if (! is_mod) {
#line 154
        return ((SPF_errcode_t )12);
      }
#line 155
      *p = (char )'t';
#line 156
      goto switch_break;
      case_7: /* CIL Label */ 
#line 159
      *p = (char )'p';
#line 160
      goto switch_break;
      case_8: /* CIL Label */ 
#line 163
      *p = (char )'v';
#line 164
      goto switch_break;
      case_9: /* CIL Label */ 
#line 167
      *p = (char )'h';
#line 168
      goto switch_break;
      case_10: /* CIL Label */ 
#line 171
      *p = (char )'r';
#line 172
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 175
      return ((SPF_errcode_t )12);
#line 176
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 178
      if (data->dv.url_encode) {
        {
#line 179
        tmp___8 = toupper((int )*p);
#line 179
        *p = (char )tmp___8;
        }
      }
#line 180
      p ++;
#line 181
      if (p_end - p <= 0L) {
#line 181
        return ((SPF_errcode_t )10);
      }
#line 184
      if (data->dv.num_rhs) {
        {
#line 186
        tmp___9 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%d",
                           (int )data->dv.num_rhs);
#line 186
        len = (size_t )tmp___9;
#line 187
        p += len;
        }
#line 188
        if (p_end - p <= 0L) {
#line 188
          return ((SPF_errcode_t )10);
        }
      }
#line 192
      if (p_end - p <= 8L) {
#line 192
        return ((SPF_errcode_t )10);
      }
#line 193
      if (data->dv.rev) {
#line 194
        tmp___10 = p;
#line 194
        p ++;
#line 194
        *tmp___10 = (char )'r';
      }
#line 196
      if (data->dv.delim_dot) {
#line 196
        if (data->dv.delim_dash) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_plus) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_equal) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_bar) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_under) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        }
      }
#line 205
      if (data->dv.delim_dash) {
#line 206
        tmp___12 = p;
#line 206
        p ++;
#line 206
        *tmp___12 = (char )'-';
      }
#line 207
      if (data->dv.delim_plus) {
#line 208
        tmp___13 = p;
#line 208
        p ++;
#line 208
        *tmp___13 = (char )'+';
      }
#line 209
      if (data->dv.delim_equal) {
#line 210
        tmp___14 = p;
#line 210
        p ++;
#line 210
        *tmp___14 = (char )'=';
      }
#line 211
      if (data->dv.delim_bar) {
#line 212
        tmp___15 = p;
#line 212
        p ++;
#line 212
        *tmp___15 = (char )'|';
      }
#line 213
      if (data->dv.delim_under) {
#line 214
        tmp___16 = p;
#line 214
        p ++;
#line 214
        *tmp___16 = (char )'_';
      }
#line 216
      tmp___17 = p;
#line 216
      p ++;
#line 216
      *tmp___17 = (char )'}';
#line 217
      if (p_end - p <= 0L) {
#line 217
        return ((SPF_errcode_t )10);
      }
    }
    {
#line 73
    data = SPF_data_next(data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (cidr_data) {
#line 224
    if (cidr_data->dc.ipv4) {
      {
#line 226
      tmp___18 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"/%d",
                          (int )cidr_data->dc.ipv4);
#line 226
      len = (size_t )tmp___18;
#line 227
      p += len;
      }
#line 228
      if (p_end - p <= 0L) {
#line 228
        return ((SPF_errcode_t )10);
      }
    }
#line 231
    if (cidr_data->dc.ipv6) {
      {
#line 233
      tmp___19 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"//%d",
                          (int )cidr_data->dc.ipv6);
#line 233
      len = (size_t )tmp___19;
#line 234
      p += len;
      }
#line 235
      if (p_end - p <= 0L) {
#line 235
        return ((SPF_errcode_t )10);
      }
    }
  }
#line 239
  *p_p = p;
#line 240
  return ((SPF_errcode_t )0);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv4___2[8]  = 
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
  {      (char const   )'i',      (char const   )'n',      (char const   )'-',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv6___2[4]  = {      (char const   )'i',      (char const   )'p',      (char const   )'6',      (char const   )'\000'};
#line 195 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static SPF_server_t *spf_server___0  ;
#line 196 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static config_t spfd_config___0  ;
#line 197 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static state_t spfd_state___0  ;
#line 199 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void response_print_errors___2(char const   *context , SPF_response_t *spf_response ,
                                      SPF_errcode_t err ) 
{ 
  SPF_error_t *spf_error ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___2 ;
  char tmp___3 ;
  char const   *tmp___5 ;
  char tmp___6 ;
  int tmp___7 ;

  {
#line 206
  if ((unsigned long )context != (unsigned long )((void *)0)) {
    {
#line 207
    printf((char const   */* __restrict  */)"Context: %s\n", context);
    }
  }
#line 208
  if ((unsigned int )err != 0U) {
    {
#line 209
    tmp = SPF_strerror(err);
#line 209
    printf((char const   */* __restrict  */)"ErrorCode: (%d) %s\n", (unsigned int )err,
           tmp);
    }
  }
#line 211
  if ((unsigned long )spf_response != (unsigned long )((void *)0)) {
#line 212
    i = 0;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 212
      tmp___7 = SPF_response_messages(spf_response);
      }
#line 212
      if (! (i < tmp___7)) {
#line 212
        goto while_break;
      }
      {
#line 213
      spf_error = SPF_response_message(spf_response, i);
#line 214
      tmp___0 = SPF_error_message(spf_error);
#line 214
      tmp___3 = SPF_error_errorp(spf_error);
      }
#line 214
      if (tmp___3) {
#line 214
        if (! err) {
#line 214
          tmp___2 = "[UNRETURNED] ";
        } else {
#line 214
          tmp___2 = "";
        }
      } else {
#line 214
        tmp___2 = "";
      }
      {
#line 214
      tmp___6 = SPF_error_errorp(spf_error);
      }
#line 214
      if (tmp___6) {
#line 214
        tmp___5 = "Error";
      } else {
#line 214
        tmp___5 = "Warning";
      }
      {
#line 214
      printf((char const   */* __restrict  */)"%s: %s%s\n", tmp___5, tmp___2, tmp___0);
#line 212
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 223
    printf((char const   */* __restrict  */)"Error: libspf2 gave a NULL spf_response");
    }
  }
#line 225
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static char const   *request_check___0(request_t *req ) 
{ 
  char const   *msg ;

  {
#line 251
  msg = (char const   *)((void *)0);
#line 252
  if (! req->ip) {
#line 253
    msg = "No IP address given";
  } else
#line 254
  if (! req->sender) {
#line 255
    msg = "No sender address given";
  } else {
#line 257
    return ((char const   *)((void *)0));
  }
  {
#line 258
  snprintf((char */* __restrict  */)(req->fmt), (size_t )4095, (char const   */* __restrict  */)"result=unknown\nreason=%s\n",
           msg);
  }
#line 262
  return (msg);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void request_query___0(request_t *req ) 
{ 
  SPF_request_t *spf_request ;
  SPF_response_t *spf_response ;
  SPF_response_t *spf_response_2mx ;
  SPF_errcode_t err ;
  char *p ;
  char *p_end ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  SPF_result_t tmp___2 ;

  {
  {
#line 268
  spf_request = (SPF_request_t *)((void *)0);
#line 269
  spf_response = (SPF_response_t *)((void *)0);
#line 270
  spf_response_2mx = (SPF_response_t *)((void *)0);
#line 279
  spf_request = SPF_request_new(spf_server___0);
#line 281
  tmp = strchr((char const   *)req->ip, ':');
  }
#line 281
  if (tmp) {
    {
#line 282
    err = SPF_request_set_ipv6_str(spf_request, (char const   *)req->ip);
    }
#line 282
    if (err) {
      {
#line 283
      while (1) {
        while_continue: /* CIL Label */ ;
#line 283
        goto fail;
#line 283
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 287
    err = SPF_request_set_ipv4_str(spf_request, (char const   *)req->ip);
    }
#line 287
    if (err) {
      {
#line 288
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 288
        goto fail;
#line 288
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 292
  if (req->helo) {
    {
#line 293
    err = SPF_request_set_helo_dom(spf_request, (char const   *)req->helo);
    }
#line 293
    if (err) {
      {
#line 294
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 294
        goto fail;
#line 294
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 299
  if (req->sender) {
    {
#line 300
    tmp___0 = SPF_request_set_env_from(spf_request, (char const   *)req->sender);
#line 300
    err = (SPF_errcode_t )tmp___0;
    }
#line 300
    if (err) {
      {
#line 301
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 301
        goto fail;
#line 301
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 308
  err = SPF_request_query_mailfrom(spf_request, & spf_response);
  }
#line 308
  if (err) {
    {
#line 309
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 309
      goto fail;
#line 309
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 312
  if (spfd_config___0.sec_mx) {
#line 313
    if (req->rcpt_to) {
#line 313
      if (*(req->rcpt_to)) {
        {
#line 314
        p = req->rcpt_to;
#line 315
        tmp___1 = strcspn((char const   *)p, " ,;");
#line 315
        p_end = p + tmp___1;
        }
        {
#line 316
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 316
          tmp___2 = SPF_response_result(spf_response);
          }
#line 316
          if (! ((unsigned int )tmp___2 != 2U)) {
#line 316
            goto while_break___4;
          }
#line 317
          if (*p_end) {
#line 318
            *p_end = (char )'\000';
          } else {
#line 320
            p_end = (char *)((void *)0);
          }
          {
#line 321
          err = SPF_request_query_rcptto(spf_request, & spf_response_2mx, (char const   *)p);
          }
#line 321
          if (err) {
            {
#line 323
            response_print_errors___2("Failed to query based on 2mx recipient", spf_response_2mx,
                                      err);
            }
            {
#line 325
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 325
              if (spf_response_2mx) {
                {
#line 325
                SPF_response_free(spf_response_2mx);
                }
              }
#line 325
              spf_response_2mx = (SPF_response_t *)((void *)0);
#line 325
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
          } else {
            {
#line 328
            spf_response = SPF_response_combine(spf_response, spf_response_2mx);
#line 330
            spf_response_2mx = (SPF_response_t *)((void *)0);
            }
          }
#line 333
          if (! p_end) {
#line 334
            goto while_break___4;
          }
#line 335
          p = p_end + 1;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
  }
#line 340
  if (spfd_config___0.fallback) {
    {
#line 341
    err = SPF_request_query_fallback(spf_request, & spf_response, (char const   *)spfd_config___0.fallback);
    }
#line 341
    if (err) {
      {
#line 343
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 343
        goto fail;
#line 343
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
  }
#line 347
  goto ok;
  fail: 
#line 350
  req->spf_err = err;
  {
#line 351
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 351
    if (spf_response) {
      {
#line 351
      SPF_response_free(spf_response);
      }
    }
#line 351
    spf_response = (SPF_response_t *)((void *)0);
#line 351
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 352
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 352
    if (spf_request) {
      {
#line 352
      SPF_request_free(spf_request);
      }
    }
#line 352
    spf_request = (SPF_request_t *)((void *)0);
#line 352
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  ok: 
#line 358
  req->spf_response = spf_response;
#line 359
  req->spf_request = spf_request;
#line 360
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void request_format___0(request_t *req ) 
{ 
  SPF_response_t *spf_response ;
  SPF_errcode_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  SPF_reason_t tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  SPF_result_t tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
#line 376
  spf_response = req->spf_response;
#line 378
  if (spf_response) {
    {
#line 379
    tmp = SPF_response_errcode(spf_response);
#line 379
    tmp___0 = SPF_strerror(tmp);
#line 379
    tmp___1 = W(tmp___0);
#line 379
    tmp___2 = SPF_response_get_header_comment(spf_response);
#line 379
    tmp___3 = W(tmp___2);
#line 379
    tmp___4 = SPF_response_get_smtp_comment(spf_response);
#line 379
    tmp___5 = W(tmp___4);
#line 379
    tmp___6 = SPF_response_reason(spf_response);
#line 379
    tmp___7 = SPF_strreason(tmp___6);
#line 379
    tmp___8 = W(tmp___7);
#line 379
    tmp___9 = SPF_response_result(spf_response);
#line 379
    tmp___10 = SPF_strresult(tmp___9);
#line 379
    tmp___11 = W(tmp___10);
#line 379
    req->fmtlen = snprintf((char */* __restrict  */)(req->fmt), (size_t )4095, (char const   */* __restrict  */)"ip=%s\nsender=%s\nresult=%s\nreason=%s\nsmtp_comment=%s\nheader_comment=%s\nerror=%s\n",
                           req->ip, req->sender, tmp___11, tmp___8, tmp___5, tmp___3,
                           tmp___1);
    }
  } else {
    {
#line 396
    tmp___12 = SPF_strerror(req->spf_err);
#line 396
    req->fmtlen = snprintf((char */* __restrict  */)(req->fmt), (size_t )4095, (char const   */* __restrict  */)"ip=%s\nsender=%s\nresult=unknown\nerror=%s\n",
                           req->ip, req->sender, tmp___12);
    }
  }
#line 406
  req->fmt[4095] = (char )'\000';
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void request_handle___0(request_t *req ) 
{ 
  char const   *tmp ;

  {
  {
#line 412
  printf((char const   */* __restrict  */)"| %s\n", req->sender);
#line 412
  fflush(stdout);
#line 413
  tmp = request_check___0(req);
  }
#line 413
  if (! tmp) {
    {
#line 414
    request_query___0(req);
#line 415
    request_format___0(req);
    }
  }
#line 418
  return;
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static struct option  const  longopts___0[10]  = 
#line 420
  {      {"debug", 1, (int *)((void *)0), 'd'}, 
        {"tcpport", 1, (int *)((void *)0), 't'}, 
        {"udpport", 1, (int *)((void *)0), 'p'}, 
        {"path", 1, (int *)((void *)0), 'f'}, 
        {"pathuser", 1, (int *)((void *)0), 'x'}, 
        {"pathgroup", 1, (int *)((void *)0), 'y'}, 
        {"pathmode", 1, (int *)((void *)0), 'm'}, 
        {"setuser", 1, (int *)((void *)0), 'u'}, 
        {"setgroup", 1, (int *)((void *)0), 'g'}, 
        {"help", 0, (int *)((void *)0), 'h'}};
#line 441 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static char const   *shortopts___0  =    "d:t:p:f:x:y:m:u:g:h:";
#line 468 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static gid_t daemon_get_user___0(char const   *arg ) 
{ 
  struct passwd *pwd ;
  long tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 472
  tmp___0 = __ctype_b_loc();
  }
#line 472
  if ((int const   )*(*tmp___0 + (int )*(arg + 0)) & 2048) {
    {
#line 473
    tmp = atol(arg);
#line 473
    pwd = getpwuid((__uid_t )tmp);
    }
  } else {
    {
#line 475
    pwd = getpwnam(arg);
    }
  }
#line 476
  if ((unsigned long )pwd == (unsigned long )((void *)0)) {
    {
#line 477
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to find user %s\n",
            arg);
    }
    {
#line 478
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 478
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Unknown user");
#line 478
      exit(1);
      }
#line 478
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 480
  return (pwd->pw_uid);
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static gid_t daemon_get_group___0(char const   *arg ) 
{ 
  struct group *grp ;
  long tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 489
  tmp___0 = __ctype_b_loc();
  }
#line 489
  if ((int const   )*(*tmp___0 + (int )*(arg + 0)) & 2048) {
    {
#line 490
    tmp = atol(arg);
#line 490
    grp = getgrgid((__gid_t )tmp);
    }
  } else {
    {
#line 492
    grp = getgrnam(arg);
    }
  }
#line 493
  if ((unsigned long )grp == (unsigned long )((void *)0)) {
    {
#line 494
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to find user %s\n",
            arg);
    }
    {
#line 495
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 495
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Unknown group");
#line 495
      exit(1);
      }
#line 495
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 497
  return (grp->gr_gid);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void daemon_config___0(int argc , char **argv ) 
{ 
  int idx ;
  char c ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 507
  memset((void *)(& spfd_config___0), 0, sizeof(spfd_config___0));
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 509
    tmp___3 = getopt_long(argc, (char * const  *)argv, shortopts___0, longopts___0,
                          & idx);
#line 509
    c = (char )tmp___3;
    }
#line 509
    if (! ((int )c != -1)) {
#line 509
      goto while_break;
    }
    {
#line 513
    if ((int )c == 116) {
#line 513
      goto case_116;
    }
#line 516
    if ((int )c == 112) {
#line 516
      goto case_112;
    }
#line 519
    if ((int )c == 102) {
#line 519
      goto case_102;
    }
#line 523
    if ((int )c == 100) {
#line 523
      goto case_100;
    }
#line 528
    if ((int )c == 120) {
#line 528
      goto case_120;
    }
#line 533
    if ((int )c == 121) {
#line 533
      goto case_121;
    }
#line 538
    if ((int )c == 109) {
#line 538
      goto case_109;
    }
#line 543
    if ((int )c == 117) {
#line 543
      goto case_117;
    }
#line 548
    if ((int )c == 103) {
#line 548
      goto case_103;
    }
#line 554
    if ((int )c == 63) {
#line 554
      goto case_63;
    }
#line 554
    if ((int )c == 0) {
#line 554
      goto case_63;
    }
#line 558
    if ((int )c == 104) {
#line 558
      goto case_104;
    }
#line 563
    goto switch_default;
    case_116: /* CIL Label */ 
    {
#line 514
    tmp = atol((char const   *)optarg);
#line 514
    spfd_config___0.tcpport = (int )tmp;
    }
#line 515
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 517
    tmp___0 = atol((char const   *)optarg);
#line 517
    spfd_config___0.udpport = (int )tmp___0;
    }
#line 518
    goto switch_break;
    case_102: /* CIL Label */ 
#line 520
    spfd_config___0.path = optarg;
#line 521
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 524
    tmp___1 = atol((char const   *)optarg);
#line 524
    spfd_config___0.debug = (int )tmp___1;
    }
#line 525
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 529
    spfd_config___0.pathuser = daemon_get_user___0((char const   *)optarg);
    }
#line 530
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 534
    spfd_config___0.pathgroup = daemon_get_group___0((char const   *)optarg);
    }
#line 535
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 539
    tmp___2 = atol((char const   *)optarg);
#line 539
    spfd_config___0.pathmode = (int )tmp___2;
    }
#line 540
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 544
    spfd_config___0.setuser = daemon_get_user___0((char const   *)optarg);
    }
#line 545
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 549
    spfd_config___0.setgroup = daemon_get_group___0((char const   *)optarg);
    }
#line 550
    goto switch_break;
    case_63: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 555
    usage();
    }
    {
#line 556
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 556
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Invalid argument");
#line 556
      exit(1);
      }
#line 556
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 557
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 559
    usage();
    }
    {
#line 560
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 560
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "");
#line 560
      exit(1);
      }
#line 560
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 561
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 564
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: getopt returned character code 0%o ??\n",
            (int )c);
    }
    {
#line 565
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 565
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "WHAT?");
#line 565
      exit(1);
      }
#line 565
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  return;
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static int daemon_bind_inet_udp___0(void) 
{ 
  struct sockaddr_in addr ;
  int sock ;
  int tmp ;

  {
  {
#line 576
  sock = socket(2, 2, 0);
  }
#line 576
  if (sock < 0) {
    {
#line 577
    perror("socket");
    }
    {
#line 578
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 578
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to create socket");
#line 578
      exit(1);
      }
#line 578
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 580
  memset((void *)(& addr), 0, sizeof(addr));
#line 581
  addr.sin_family = (sa_family_t )2;
#line 582
  addr.sin_port = htons((uint16_t )spfd_config___0.udpport);
#line 583
  addr.sin_addr.s_addr = (in_addr_t )0;
#line 584
  tmp = bind(sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
             (socklen_t )sizeof(addr));
  }
#line 584
  if (tmp < 0) {
    {
#line 585
    perror("bind");
    }
    {
#line 586
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 586
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to bind socket");
#line 586
      exit(1);
      }
#line 586
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 589
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accepting datagrams on %d\n",
          spfd_config___0.udpport);
  }
#line 591
  return (sock);
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static int daemon_bind_inet_tcp___0(void) 
{ 
  struct sockaddr_in addr ;
  int sock ;
  int optval ;
  size_t optlen ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 603
  sock = socket(2, 1, 0);
  }
#line 603
  if (sock < 0) {
    {
#line 604
    perror("socket");
    }
    {
#line 605
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 605
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to create socket");
#line 605
      exit(1);
      }
#line 605
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 608
  optval = 1;
#line 609
  optlen = sizeof(int );
#line 610
  setsockopt(sock, 1, 2, (void const   *)(& optval), (socklen_t )optlen);
#line 612
  memset((void *)(& addr), 0, sizeof(addr));
#line 613
  addr.sin_family = (sa_family_t )2;
#line 614
  addr.sin_port = htons((uint16_t )spfd_config___0.tcpport);
#line 615
  addr.sin_addr.s_addr = (in_addr_t )0;
#line 616
  tmp = bind(sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
             (socklen_t )sizeof(addr));
  }
#line 616
  if (tmp < 0) {
    {
#line 617
    perror("bind");
    }
    {
#line 618
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 618
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to bind socket");
#line 618
      exit(1);
      }
#line 618
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 621
  tmp___0 = listen(sock, 5);
  }
#line 621
  if (tmp___0 < 0) {
    {
#line 622
    perror("listen");
    }
    {
#line 623
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 623
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to listen on socket");
#line 623
      exit(1);
      }
#line 623
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 626
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accepting connections on %d\n",
          spfd_config___0.tcpport);
  }
#line 628
  return (sock);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static int daemon_bind_unix___0(void) 
{ 
  struct sockaddr_un addr ;
  int sock ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 637
  sock = socket(1, 1, 0);
  }
#line 637
  if (sock < 0) {
    {
#line 638
    perror("socket");
    }
    {
#line 639
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 639
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to create socket");
#line 639
      exit(1);
      }
#line 639
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 641
  memset((void *)(& addr), 0, sizeof(addr));
#line 642
  addr.sun_family = (sa_family_t )1;
#line 643
  strncpy((char */* __restrict  */)(addr.sun_path), (char const   */* __restrict  */)spfd_config___0.path,
          sizeof(addr.sun_path) - 1UL);
#line 644
  tmp___0 = unlink((char const   *)spfd_config___0.path);
  }
#line 644
  if (tmp___0 < 0) {
    {
#line 645
    tmp = __errno_location();
    }
#line 645
    if (*tmp != 2) {
      {
#line 646
      perror("unlink");
      }
      {
#line 647
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 647
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                "Failed to unlink socket");
#line 647
        exit(1);
        }
#line 647
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 650
  tmp___1 = bind(sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
                 (socklen_t )sizeof(addr));
  }
#line 650
  if (tmp___1 < 0) {
    {
#line 651
    perror("bind");
    }
    {
#line 652
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 652
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to bind socket");
#line 652
      exit(1);
      }
#line 652
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 654
  tmp___2 = listen(sock, 5);
  }
#line 654
  if (tmp___2 < 0) {
    {
#line 655
    perror("listen");
    }
    {
#line 656
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 656
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              "Failed to listen on socket");
#line 656
      exit(1);
      }
#line 656
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 659
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accepting connections on %s\n",
          spfd_config___0.path);
  }
#line 661
  return (sock);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void daemon_init___0(void) 
{ 
  SPF_response_t *spf_response ;
  SPF_errcode_t err ;

  {
  {
#line 667
  spf_response = (SPF_response_t *)((void *)0);
#line 670
  memset((void *)(& spfd_state___0), 0, sizeof(spfd_state___0));
#line 672
  spf_server___0 = SPF_server_new((SPF_server_dnstype_t )1, spfd_config___0.debug);
  }
#line 674
  if (spfd_config___0.rec_dom) {
    {
#line 675
    err = SPF_server_set_rec_dom(spf_server___0, (char const   *)spfd_config___0.rec_dom);
    }
#line 675
    if (err) {
      {
#line 677
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 677
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                "Failed to set receiving domain name");
#line 677
        exit(1);
        }
#line 677
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 681
  if (spfd_config___0.sanitize) {
    {
#line 682
    err = SPF_server_set_sanitize(spf_server___0, spfd_config___0.sanitize);
    }
#line 682
    if (err) {
      {
#line 684
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 684
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                "Failed to set server sanitize flag");
#line 684
        exit(1);
        }
#line 684
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 688
  if (spfd_config___0.max_lookup) {
    {
#line 689
    err = SPF_server_set_max_dns_mech(spf_server___0, spfd_config___0.max_lookup);
    }
#line 689
    if (err) {
      {
#line 691
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 691
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                "Failed to set maximum DNS requests");
#line 691
        exit(1);
        }
#line 691
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 695
  if (spfd_config___0.localpolicy) {
    {
#line 696
    err = SPF_server_set_localpolicy(spf_server___0, (char const   *)spfd_config___0.localpolicy,
                                     spfd_config___0.use_trusted, & spf_response);
    }
#line 696
    if (err) {
      {
#line 700
      response_print_errors___2("Compiling local policy", spf_response, err);
      }
      {
#line 702
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 702
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                "Failed to set local policy");
#line 702
        exit(1);
        }
#line 702
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 704
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 704
      if (spf_response) {
        {
#line 704
        SPF_response_free(spf_response);
        }
      }
#line 704
      spf_response = (SPF_response_t *)((void *)0);
#line 704
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 707
  if (spfd_config___0.explanation) {
    {
#line 708
    err = SPF_server_set_explanation(spf_server___0, (char const   *)spfd_config___0.explanation,
                                     & spf_response);
    }
#line 708
    if (err) {
      {
#line 711
      response_print_errors___2("Setting default explanation", spf_response, err);
      }
      {
#line 713
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 713
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                "Failed to set default explanation");
#line 713
        exit(1);
        }
#line 713
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 715
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 715
      if (spf_response) {
        {
#line 715
        SPF_response_free(spf_response);
        }
      }
#line 715
      spf_response = (SPF_response_t *)((void *)0);
#line 715
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 718
  if (spfd_config___0.udpport) {
    {
#line 719
    spfd_state___0.sock_udp = daemon_bind_inet_udp___0();
    }
  }
#line 720
  if (spfd_config___0.tcpport) {
    {
#line 721
    spfd_state___0.sock_tcp = daemon_bind_inet_tcp___0();
    }
  }
#line 722
  if (spfd_config___0.path) {
    {
#line 723
    spfd_state___0.sock_unix = daemon_bind_unix___0();
    }
  }
#line 725
  return;
}
}
#line 729 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static char **find_field___0(request_t *req , char const   *key ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 734
  tmp = strcmp(key, "ip");
  }
#line 734
  if (tmp == 0) {
#line 735
    return (& req->ip);
  }
  {
#line 736
  tmp___0 = strcmp(key, "helo");
  }
#line 736
  if (tmp___0 == 0) {
#line 737
    return (& req->helo);
  }
  {
#line 738
  tmp___1 = strcmp(key, "sender");
  }
#line 738
  if (tmp___1 == 0) {
#line 739
    return (& req->sender);
  }
  {
#line 740
  tmp___2 = strcmp(key, "rcpt");
  }
#line 740
  if (tmp___2 == 0) {
#line 741
    return (& req->rcpt_to);
  }
  {
#line 742
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid key %s\n",
          key);
  }
#line 743
  return ((char **)((void *)0));
}
}
#line 747 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void *handle_datagram___0(void *arg ) 
{ 
  request_t *req ;
  char **fp ;
  char *key ;
  char *value ;
  char *end ;
  int err ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 757
  req = (request_t *)arg;
#line 758
  key = req->data;
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
#line 762
    if (! ((unsigned long )key < (unsigned long )(req->data + req->datalen))) {
#line 762
      goto while_break;
    }
    {
#line 763
    tmp = strcspn((char const   *)key, "\r\n");
#line 763
    end = key + tmp;
#line 764
    *end = (char )'\000';
#line 765
    value = strchr((char const   *)key, '=');
    }
#line 768
    if (! value) {
#line 769
      goto while_continue;
    }
    {
#line 771
    tmp___0 = value;
#line 771
    value ++;
#line 771
    *tmp___0 = (char )'\000';
#line 772
    fp = find_field___0(req, (char const   *)key);
    }
#line 773
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 774
      *fp = value;
    }
#line 778
    key = end + 1;
    {
#line 779
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 779
      if (! ((unsigned long )key < (unsigned long )(req->data + req->datalen))) {
#line 779
        goto while_break___0;
      }
      {
#line 780
      tmp___1 = strchr("\r\n", (int )*key);
      }
#line 780
      if (tmp___1) {
#line 781
        key ++;
      } else {
#line 783
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 787
  request_handle___0(req);
#line 795
  printf((char const   */* __restrict  */)"- %s\n", req->sender);
#line 795
  fflush(stdout);
#line 796
  tmp___2 = sendto(req->sock, (void const   *)(req->fmt), (size_t )req->fmtlen, 0,
                   (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& req->addr.in)),
                   req->addrlen);
#line 796
  err = (int )tmp___2;
  }
#line 798
  if (err == -1) {
    {
#line 799
    perror("sendto");
    }
  }
  {
#line 801
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 801
    if (req->spf_response) {
      {
#line 801
      SPF_response_free(req->spf_response);
      }
    }
#line 801
    req->spf_response = (SPF_response_t *)((void *)0);
#line 801
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 802
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 802
    if (req->spf_request) {
      {
#line 802
      SPF_request_free(req->spf_request);
      }
    }
#line 802
    req->spf_request = (SPF_request_t *)((void *)0);
#line 802
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 804
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 804
    if (req->data) {
      {
#line 804
      free((void *)req->data);
      }
    }
#line 804
    req->data = (char *)((void *)0);
#line 804
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 805
  free(arg);
  }
#line 806
  return ((void *)0);
}
}
#line 810 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void *handle_stream___0(void *arg ) 
{ 
  request_t *req ;
  char **fp ;
  FILE *stream ;
  char key[8192] ;
  char *value ;
  char *end ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 820
  req = (request_t *)arg;
#line 821
  stream = fdopen(req->sock, "r");
  }
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 824
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 824
      tmp___2 = fgets((char */* __restrict  */)(key), 8192, (FILE */* __restrict  */)stream);
      }
#line 824
      if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 824
        goto while_break___0;
      }
      {
#line 825
      tmp = strcspn((char const   *)(key), "\r\n");
#line 825
      key[tmp] = (char )'\000';
      }
#line 828
      if ((int )key[0] == 0) {
#line 829
        goto while_break___0;
      }
      {
#line 831
      tmp___0 = strcspn((char const   *)(key), "\r\n");
#line 831
      end = key + tmp___0;
#line 832
      *end = (char )'\000';
#line 833
      value = strchr((char const   *)(key), '=');
      }
#line 835
      if (! value) {
#line 836
        goto while_continue___0;
      }
      {
#line 838
      tmp___1 = value;
#line 838
      value ++;
#line 838
      *tmp___1 = (char )'\000';
#line 839
      fp = find_field___0(req, (char const   *)(key));
      }
#line 840
      if ((unsigned long )fp != (unsigned long )((void *)0)) {
        {
#line 841
        *fp = strdup((char const   *)value);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 846
    request_handle___0(req);
#line 848
    printf((char const   */* __restrict  */)"- %s\n", req->sender);
#line 848
    fflush(stdout);
#line 849
    send(req->sock, (void const   *)(req->fmt), (size_t )req->fmtlen, 0);
    }
    {
#line 851
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 851
      if (req->ip) {
        {
#line 851
        free((void *)req->ip);
        }
      }
#line 851
      req->ip = (char *)((void *)0);
#line 851
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 852
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 852
      if (req->helo) {
        {
#line 852
        free((void *)req->helo);
        }
      }
#line 852
      req->helo = (char *)((void *)0);
#line 852
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 853
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 853
      if (req->sender) {
        {
#line 853
        free((void *)req->sender);
        }
      }
#line 853
      req->sender = (char *)((void *)0);
#line 853
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 854
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 854
      if (req->rcpt_to) {
        {
#line 854
        free((void *)req->rcpt_to);
        }
      }
#line 854
      req->rcpt_to = (char *)((void *)0);
#line 854
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 823
    tmp___3 = feof(stream);
    }
#line 823
    if (tmp___3) {
#line 823
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 857
  free(arg);
  }
#line 858
  return ((void *)0);
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spfd/spfd.c"
static void daemon_main___0(void) 
{ 
  pthread_attr_t attr ;
  pthread_t th ;
  request_t *req ;
  char buf[4096] ;
  fd_set rfd ;
  fd_set sfd ;
  int maxfd ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 874
  pthread_attr_init(& attr);
#line 875
  pthread_attr_setdetachstate(& attr, 1);
  }
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfd.fds_bits[0]): "memory");
#line 877
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 878
  maxfd = 0;
#line 880
  if (spfd_state___0.sock_udp) {
#line 882
    rfd.fds_bits[spfd_state___0.sock_udp / (8 * (int )sizeof(__fd_mask ))] |= 1L << spfd_state___0.sock_udp % (8 * (int )sizeof(__fd_mask ));
#line 883
    if (spfd_state___0.sock_udp > maxfd) {
#line 884
      maxfd = spfd_state___0.sock_udp;
    }
  }
#line 886
  if (spfd_state___0.sock_tcp) {
#line 888
    rfd.fds_bits[spfd_state___0.sock_tcp / (8 * (int )sizeof(__fd_mask ))] |= 1L << spfd_state___0.sock_tcp % (8 * (int )sizeof(__fd_mask ));
#line 889
    if (spfd_state___0.sock_tcp > maxfd) {
#line 890
      maxfd = spfd_state___0.sock_tcp;
    }
  }
#line 892
  if (spfd_state___0.sock_unix) {
#line 894
    rfd.fds_bits[spfd_state___0.sock_unix / (8 * (int )sizeof(__fd_mask ))] |= 1L << spfd_state___0.sock_unix % (8 * (int )sizeof(__fd_mask ));
#line 895
    if (spfd_state___0.sock_unix > maxfd) {
#line 896
      maxfd = spfd_state___0.sock_unix;
    }
  }
  {
#line 902
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 903
    memcpy((void */* __restrict  */)(& sfd), (void const   */* __restrict  */)(& rfd),
           sizeof(rfd));
#line 904
    tmp = select(maxfd + 1, (fd_set */* __restrict  */)(& sfd), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 904
    if (tmp == -1) {
#line 905
      goto while_break___0;
    }
#line 907
    if (spfd_state___0.sock_udp) {
#line 908
      if ((sfd.fds_bits[spfd_state___0.sock_udp / (8 * (int )sizeof(__fd_mask ))] & (1L << spfd_state___0.sock_udp % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 909
        tmp___0 = calloc((size_t )1, sizeof(request_t ));
#line 909
        req = (request_t *)tmp___0;
#line 910
        req->addrlen = (socklen_t )sizeof(req->addr);
#line 912
        req->sock = spfd_state___0.sock_udp;
#line 913
        tmp___1 = recvfrom(spfd_state___0.sock_udp, (void */* __restrict  */)(buf),
                           (size_t )4095, 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& req->addr.in)),
                           (socklen_t */* __restrict  */)(& req->addrlen));
#line 913
        req->datalen = (int )tmp___1;
        }
#line 915
        if (req->datalen >= 0) {
          {
#line 916
          buf[req->datalen] = (char )'\000';
#line 917
          req->data = strdup((char const   *)(buf));
#line 918
          pthread_create((pthread_t */* __restrict  */)(& th), (pthread_attr_t const   */* __restrict  */)(& attr),
                         & handle_datagram___0, (void */* __restrict  */)req);
          }
        } else {
          {
#line 921
          free((void *)req);
          }
        }
      }
    }
#line 925
    if (spfd_state___0.sock_tcp) {
#line 926
      if ((sfd.fds_bits[spfd_state___0.sock_tcp / (8 * (int )sizeof(__fd_mask ))] & (1L << spfd_state___0.sock_tcp % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 927
        tmp___2 = calloc((size_t )1, sizeof(request_t ));
#line 927
        req = (request_t *)tmp___2;
#line 928
        req->addrlen = (socklen_t )sizeof(req->addr);
#line 930
        req->sock = accept(spfd_state___0.sock_tcp, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& req->addr.in)),
                           (socklen_t */* __restrict  */)(& req->addrlen));
        }
#line 932
        if (req->sock >= 0) {
          {
#line 933
          pthread_create((pthread_t */* __restrict  */)(& th), (pthread_attr_t const   */* __restrict  */)(& attr),
                         & handle_stream___0, (void */* __restrict  */)req);
          }
        } else {
          {
#line 935
          free((void *)req);
          }
        }
      }
    }
#line 938
    if (spfd_state___0.sock_unix) {
#line 939
      if ((sfd.fds_bits[spfd_state___0.sock_unix / (8 * (int )sizeof(__fd_mask ))] & (1L << spfd_state___0.sock_unix % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 940
        tmp___3 = calloc((size_t )1, sizeof(request_t ));
#line 940
        req = (request_t *)tmp___3;
#line 941
        req->addrlen = (socklen_t )sizeof(req->addr);
#line 943
        req->sock = accept(spfd_state___0.sock_unix, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& req->addr.un)),
                           (socklen_t */* __restrict  */)(& req->addrlen));
        }
#line 945
        if (req->sock >= 0) {
          {
#line 946
          pthread_create((pthread_t */* __restrict  */)(& th), (pthread_attr_t const   */* __restrict  */)(& attr),
                         & handle_stream___0, (void */* __restrict  */)req);
          }
        } else {
          {
#line 948
          free((void *)req);
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 953
  pthread_attr_destroy(& attr);
  }
#line 954
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_find___2(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                           ns_type rr_type , int exact ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;
  int tmp ;
  size_t domain_len ;
  size_t tmp___0 ;
  size_t zdomain_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 103
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 105
  if (spf_dns_server->debug) {
    {
#line 106
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
               106, "zone: Searching for RR %s (%d)", domain, (unsigned int )rr_type);
    }
  }
#line 110
  if (exact) {
#line 110
    goto _L;
  } else {
    {
#line 110
    tmp___6 = strncmp(domain, "*.", (size_t )2);
    }
#line 110
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
#line 111
      i = 0;
      {
#line 111
      while (1) {
        while_continue: /* CIL Label */ ;
#line 111
        if (! (i < spfhook->num_zone)) {
#line 111
          goto while_break;
        }
#line 112
        if ((unsigned int )(*(spfhook->zone + i))->rr_type == (unsigned int )rr_type) {
          {
#line 112
          tmp = strcasecmp((char const   *)(*(spfhook->zone + i))->domain, domain);
          }
#line 112
          if (tmp == 0) {
#line 114
            return (*(spfhook->zone + i));
          }
        }
#line 111
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 116
      if (spf_dns_server->debug) {
        {
#line 117
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   117, "zone: Exact not found");
        }
      }
    } else {
      {
#line 121
      tmp___0 = strlen(domain);
#line 121
      domain_len = tmp___0;
      }
#line 125
      if (domain_len) {
#line 125
        if ((int const   )*(domain + (domain_len - 1UL)) == 46) {
#line 126
          domain_len --;
        }
      }
#line 128
      i = 0;
      {
#line 128
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 128
        if (! (i < spfhook->num_zone)) {
#line 128
          goto while_break___0;
        }
#line 129
        if ((unsigned int )(*(spfhook->zone + i))->rr_type != (unsigned int )rr_type) {
#line 129
          if ((unsigned int )(*(spfhook->zone + i))->rr_type != 255U) {
#line 131
            if (spf_dns_server->debug) {
              {
#line 132
              SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                         133, "zone: Ignoring record rrtype %d", (unsigned int )(*(spfhook->zone + i))->rr_type);
              }
            }
#line 134
            goto __Cont;
          }
        }
        {
#line 137
        tmp___5 = strncmp((char const   *)(*(spfhook->zone + i))->domain, "*.", (size_t )2);
        }
#line 137
        if (tmp___5 == 0) {
          {
#line 138
          tmp___1 = strlen((char const   *)(*(spfhook->zone + i))->domain);
#line 138
          zdomain_len = tmp___1 - 2UL;
          }
#line 139
          if (zdomain_len <= domain_len) {
            {
#line 139
            tmp___2 = strncasecmp((char const   *)((*(spfhook->zone + i))->domain + 2),
                                  domain + (domain_len - zdomain_len), zdomain_len);
            }
#line 139
            if (tmp___2 == 0) {
#line 144
              return (*(spfhook->zone + i));
            }
          }
        } else {
          {
#line 146
          tmp___3 = strncasecmp((char const   *)(*(spfhook->zone + i))->domain, domain,
                                domain_len);
          }
#line 146
          if (tmp___3 == 0) {
            {
#line 146
            tmp___4 = strlen((char const   *)(*(spfhook->zone + i))->domain);
            }
#line 146
            if (tmp___4 == domain_len) {
#line 151
              return (*(spfhook->zone + i));
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 128
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 154
      if (spf_dns_server->debug) {
        {
#line 155
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   155, "zone: Non-exact not found");
        }
      }
    }
  }
#line 158
  return ((SPF_dns_rr_t *)((void *)0));
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_lookup___2(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  SPF_dns_rr_t *spfrr ;
  SPF_dns_rr_t *tmp ;

  {
  {
#line 170
  spfrr = SPF_dns_zone_find___2(spf_dns_server, domain, rr_type, 0);
  }
#line 171
  if (spfrr) {
    {
#line 172
    SPF_dns_rr_dup(& spfrr, spfrr);
    }
#line 173
    return (spfrr);
  }
#line 176
  if (spf_dns_server->layer_below) {
    {
#line 177
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 177
    return (tmp);
  }
  {
#line 181
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
#line 182
  SPF_dns_rr_dup(& spfrr, spfhook->nxdomain);
  }
#line 184
  return (spfrr);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static void SPF_dns_zone_free___2(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 317
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                 317, "%s", "spf_dns_server is NULL");
      }
    }
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 320
  if (spfhook) {
#line 321
    if (spfhook->zone) {
#line 322
      i = 0;
      {
#line 322
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 322
        if (! (i < spfhook->zone_buf_len)) {
#line 322
          goto while_break___0;
        }
#line 323
        if (*(spfhook->zone + i)) {
          {
#line 324
          SPF_dns_rr_free(*(spfhook->zone + i));
          }
        }
#line 322
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 326
      free((void *)spfhook->zone);
      }
    }
#line 328
    if (spfhook->nxdomain) {
      {
#line 329
      SPF_dns_rr_free(spfhook->nxdomain);
      }
    }
    {
#line 330
    free((void *)spfhook);
    }
  }
  {
#line 333
  free((void *)spf_dns_server);
  }
#line 334
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_server_set_rec_dom_ghbn___0)(SPF_server_t *sp ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 70
  tmp = malloc((size_t )64);
#line 70
  sp->rec_dom = (char *)tmp;
  }
#line 71
  if (! sp->rec_dom) {
#line 72
    return ((SPF_errcode_t )1);
  }
  {
#line 77
  tmp___0 = gethostname(sp->rec_dom, (size_t )64);
  }
#line 77
  if (tmp___0 < 0) {
#line 79
    return ((SPF_errcode_t )10);
  }
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static void SPF_server_new_common_pre___0(SPF_server_t *sp , int debug ) 
{ 
  SPF_errcode_t err ;

  {
  {
#line 89
  memset((void *)sp, 0, sizeof(SPF_server_t ));
#line 91
  sp->max_dns_mech = 10;
#line 92
  sp->max_dns_ptr = 10;
#line 93
  sp->max_dns_mx = 10;
#line 94
  sp->debug = debug;
#line 96
  err = SPF_server_set_rec_dom_ghbn___0(sp);
  }
#line 97
  if ((unsigned int )err != 0U) {
    {
#line 98
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               98, "%s", "Failed to set rec_dom using gethostname()");
    }
  }
#line 99
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static void SPF_server_new_common_post___0(SPF_server_t *sp ) 
{ 
  SPF_response_t *spf_response ;
  SPF_errcode_t err ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 107
  spf_response = (SPF_response_t *)((void *)0);
#line 108
  err = SPF_server_set_explanation(sp, "Please%_see%_http://www.openspf.org/Why?id=%{S}&ip=%{C}&receiver=%{R}",
                                   & spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
    {
#line 111
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               111, "Error code %d compiling default explanation", (unsigned int )err);
    }
  }
#line 112
  if (spf_response) {
    {
#line 114
    tmp = SPF_response_messages(spf_response);
    }
#line 114
    if (tmp > 0) {
      {
#line 115
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 115, "%s", "Response errors compiling default explanation");
      }
    }
    {
#line 116
    SPF_response_free(spf_response);
    }
  }
  {
#line 119
  spf_response = (SPF_response_t *)((void *)0);
#line 120
  err = SPF_server_set_localpolicy(sp, "", 0, & spf_response);
  }
#line 121
  if ((unsigned int )err != 0U) {
    {
#line 122
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               122, "Error code %d compiling default whitelist", (unsigned int )err);
    }
  }
#line 123
  if (spf_response) {
    {
#line 125
    tmp___0 = SPF_response_messages(spf_response);
    }
#line 125
    if (tmp___0 > 0) {
      {
#line 126
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 126, "%s", "Response errors compiling default whitelist");
      }
    }
    {
#line 127
    SPF_response_free(spf_response);
    }
  }
#line 129
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static char const   digits___0[11]  = 
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 63 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static char const   digitvalue___0[256]  = 
#line 63
  {      (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )0,      (char const   )1,      (char const   )2,      (char const   )3, 
        (char const   )4,      (char const   )5,      (char const   )6,      (char const   )7, 
        (char const   )8,      (char const   )9,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )13,      (char const   )14,      (char const   )15,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )13,      (char const   )14,      (char const   )15,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1};
#line 84
static int special___0(int ch ) ;
#line 85
static int printable___0(int ch ) ;
#line 86
static int dn_find___0(u_char const   *domain , u_char const   *msg , u_char const   * const  *dnptrs ,
                       u_char const   * const  *lastdnptr ) ;
#line 89
static int encode_bitsring___0(char const   **bp , char const   *end , char **labelp ,
                               char **dst , char const   *eom ) ;
#line 91
static int labellen___0(u_char const   *lp ) ;
#line 92
static int decode_bitstring___0(char const   **cpp , char *dn , char const   *eom ) ;
#line 693 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int special___0(int ch ) 
{ 


  {
  {
#line 704
  if (ch == 36) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 64) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 41) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 40) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 92) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 59) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 46) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 34) {
#line 704
    goto case_36;
  }
#line 706
  goto switch_default;
  case_36: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_34: /* CIL Label */ 
#line 705
  return (1);
  switch_default: /* CIL Label */ 
#line 707
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int printable___0(int ch ) 
{ 
  int tmp ;

  {
#line 720
  if (ch > 32) {
#line 720
    if (ch < 127) {
#line 720
      tmp = 1;
    } else {
#line 720
      tmp = 0;
    }
  } else {
#line 720
    tmp = 0;
  }
#line 720
  return (tmp);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int mklower___0(int ch ) 
{ 


  {
#line 729
  if (ch >= 65) {
#line 729
    if (ch <= 90) {
#line 730
      return (ch + 32);
    }
  }
#line 731
  return (ch);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int dn_find___0(u_char const   *domain , u_char const   *msg , u_char const   * const  *dnptrs ,
                       u_char const   * const  *lastdnptr ) 
{ 
  u_char const   *dn ;
  u_char const   *cp ;
  u_char const   *sp ;
  u_char const   * const  *cpp ;
  u_int n ;
  int tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  int tmp___2 ;
  u_char const   *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  u_char const   *tmp___6 ;
  int *tmp___7 ;

  {
#line 752
  cpp = dnptrs;
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! ((unsigned long )cpp < (unsigned long )lastdnptr)) {
#line 752
      goto while_break;
    }
#line 753
    sp = (u_char const   *)*cpp;
    {
#line 760
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 760
      if ((int const   )*sp != 0) {
#line 760
        if (((int const   )*sp & 192) == 0) {
#line 760
          if (! (sp - msg < 16384L)) {
#line 760
            goto while_break___0;
          }
        } else {
#line 760
          goto while_break___0;
        }
      } else {
#line 760
        goto while_break___0;
      }
#line 762
      dn = domain;
#line 763
      cp = sp;
      {
#line 764
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 764
        tmp___6 = cp;
#line 764
        cp ++;
#line 764
        n = (u_int )*tmp___6;
#line 764
        if (! (n != 0U)) {
#line 764
          goto while_break___1;
        }
        {
#line 769
        if ((n & 192U) == 0U) {
#line 769
          goto case_0;
        }
#line 785
        if ((n & 192U) == 192U) {
#line 785
          goto case_192;
        }
#line 789
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 770
        tmp = labellen___0(cp - 1);
#line 770
        n = (u_int )tmp;
#line 772
        tmp___0 = dn;
#line 772
        dn ++;
        }
#line 772
        if (n != (u_int )*tmp___0) {
#line 773
          goto next;
        }
        {
#line 775
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 775
          if (! (n > 0U)) {
#line 775
            goto while_break___2;
          }
          {
#line 776
          tmp___1 = dn;
#line 776
          dn ++;
#line 776
          tmp___2 = mklower___0((int )*tmp___1);
#line 776
          tmp___3 = cp;
#line 776
          cp ++;
#line 776
          tmp___4 = mklower___0((int )*tmp___3);
          }
#line 776
          if (tmp___2 != tmp___4) {
#line 778
            goto next;
          }
#line 775
          n --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 780
        if ((int const   )*dn == 0) {
#line 780
          if ((int const   )*cp == 0) {
#line 781
            return ((int )(sp - msg));
          }
        }
#line 782
        if (*dn) {
#line 783
          goto while_continue___1;
        }
#line 784
        goto next;
        case_192: /* CIL Label */ 
#line 786
        cp = msg + (((n & 63U) << 8) | (unsigned int )*cp);
#line 787
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 790
        tmp___5 = __errno_location();
#line 790
        *tmp___5 = 90;
        }
#line 791
        return (-1);
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      next: 
#line 795
      sp += (int const   )*sp + 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 752
    cpp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 798
  tmp___7 = __errno_location();
#line 798
  *tmp___7 = 2;
  }
#line 799
  return (-1);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int decode_bitstring___0(char const   **cpp , char *dn , char const   *eom ) 
{ 
  char const   *cp ;
  char *beg ;
  char tc ;
  int b ;
  int blen ;
  int plen ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 805
  cp = *cpp;
#line 806
  beg = dn;
#line 809
  blen = (int )((int const   )*cp & 255);
#line 809
  if (blen == 0) {
#line 810
    blen = 256;
  }
#line 811
  plen = (blen + 3) / 4;
#line 812
  if (blen > 99) {
#line 812
    tmp___0 = 3;
  } else {
#line 812
    if (blen > 9) {
#line 812
      tmp = 2;
    } else {
#line 812
      tmp = 1;
    }
#line 812
    tmp___0 = tmp;
  }
#line 812
  plen = (int )((unsigned long )plen + (sizeof("\\[x/]") + (unsigned long )tmp___0));
#line 813
  if ((unsigned long )(dn + plen) >= (unsigned long )eom) {
#line 814
    return (-1);
  }
  {
#line 816
  cp ++;
#line 817
  tmp___1 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"\\[x");
#line 817
  i = (int )((size_t )tmp___1);
  }
#line 818
  if (i < 0) {
#line 819
    return (-1);
  }
#line 820
  dn += i;
#line 821
  b = blen;
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! (b > 7)) {
#line 821
      goto while_break;
    }
    {
#line 822
    tmp___2 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%02x",
                      (int const   )*cp & 255);
#line 822
    i = (int )((size_t )tmp___2);
    }
#line 823
    if (i < 0) {
#line 824
      return (-1);
    }
#line 825
    dn += i;
#line 821
    b -= 8;
#line 821
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 827
  if (b > 4) {
    {
#line 828
    tmp___3 = cp;
#line 828
    cp ++;
#line 828
    tc = (char )*tmp___3;
#line 829
    tmp___4 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%02x",
                      (int )tc & (255 << (8 - b)));
#line 829
    i = (int )((size_t )tmp___4);
    }
#line 830
    if (i < 0) {
#line 831
      return (-1);
    }
#line 832
    dn += i;
  } else
#line 833
  if (b > 0) {
    {
#line 834
    tmp___5 = cp;
#line 834
    cp ++;
#line 834
    tc = (char )*tmp___5;
#line 835
    tmp___6 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%1x",
                      (((int )tc >> 4) & 15) & (15 << (4 - b)));
#line 835
    i = (int )((size_t )tmp___6);
    }
#line 837
    if (i < 0) {
#line 838
      return (-1);
    }
#line 839
    dn += i;
  }
  {
#line 841
  tmp___7 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"/%d]",
                    blen);
#line 841
  i = (int )((size_t )tmp___7);
  }
#line 842
  if (i < 0) {
#line 843
    return (-1);
  }
#line 844
  dn += i;
#line 846
  *cpp = cp;
#line 847
  return ((int )(dn - beg));
}
}
#line 850 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int encode_bitsring___0(char const   **bp , char const   *end , char **labelp ,
                               char **dst , char const   *eom ) 
{ 
  int afterslash ;
  char const   *cp ;
  char *tp ;
  char c ;
  char const   *beg_blen ;
  char *end_blen ;
  int value ;
  int count ;
  int tbcount ;
  int blen ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  int traillen ;

  {
#line 854
  afterslash = 0;
#line 855
  cp = *bp;
#line 858
  end_blen = (char *)((void *)0);
#line 859
  value = 0;
#line 859
  count = 0;
#line 859
  tbcount = 0;
#line 859
  blen = 0;
#line 861
  end_blen = (char *)((void *)0);
#line 861
  beg_blen = (char const   *)end_blen;
#line 864
  if (end - cp < 2L) {
#line 865
    return (22);
  }
#line 868
  tmp = cp;
#line 868
  cp ++;
#line 868
  if ((int const   )*tmp != 120) {
#line 869
    return (22);
  }
  {
#line 870
  tmp___0 = __ctype_b_loc();
  }
#line 870
  if (! ((int const   )*(*tmp___0 + (int )((int const   )*cp & 255)) & 4096)) {
#line 871
    return (22);
  }
#line 873
  tp = *dst + 1;
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    if ((unsigned long )cp < (unsigned long )end) {
#line 873
      if (! ((unsigned long )tp < (unsigned long )eom)) {
#line 873
        goto while_break;
      }
    } else {
#line 873
      goto while_break;
    }
#line 874
    c = (char )*cp;
    {
#line 875
    if ((int )c == 93) {
#line 875
      goto case_93;
    }
#line 887
    if ((int )c == 47) {
#line 887
      goto case_47;
    }
#line 890
    goto switch_default;
    case_93: /* CIL Label */ 
#line 876
    if (afterslash) {
#line 877
      if ((unsigned long )beg_blen == (unsigned long )((void *)0)) {
#line 878
        return (22);
      }
      {
#line 879
      tmp___1 = strtol((char const   */* __restrict  */)beg_blen, (char **/* __restrict  */)(& end_blen),
                       10);
#line 879
      blen = (int )tmp___1;
      }
#line 880
      if ((int )*end_blen != 93) {
#line 881
        return (22);
      }
    }
#line 883
    if (count) {
#line 884
      tmp___2 = tp;
#line 884
      tp ++;
#line 884
      *tmp___2 = (char )((value << 4) & 255);
    }
#line 885
    cp ++;
#line 886
    goto done;
    case_47: /* CIL Label */ 
#line 888
    afterslash = 1;
#line 889
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 891
    if (afterslash) {
      {
#line 892
      tmp___3 = __ctype_b_loc();
      }
#line 892
      if (! ((int const   )*(*tmp___3 + ((int )c & 255)) & 2048)) {
#line 893
        return (22);
      }
#line 894
      if ((unsigned long )beg_blen == (unsigned long )((void *)0)) {
#line 896
        if ((int )c == 48) {
#line 898
          return (22);
        }
#line 900
        beg_blen = cp;
      }
    } else {
      {
#line 903
      tmp___4 = __ctype_b_loc();
      }
#line 903
      if (! ((int const   )*(*tmp___4 + ((int )c & 255)) & 4096)) {
#line 904
        return (22);
      }
#line 905
      value <<= 4;
#line 906
      value += (int )digitvalue___0[(int )c];
#line 907
      count += 4;
#line 908
      tbcount += 4;
#line 909
      if (tbcount > 256) {
#line 910
        return (22);
      }
#line 911
      if (count == 8) {
#line 912
        tmp___5 = tp;
#line 912
        tp ++;
#line 912
        *tmp___5 = (char )value;
#line 913
        count = 0;
      }
    }
#line 916
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 873
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 920
  if ((unsigned long )cp >= (unsigned long )end) {
#line 921
    return (90);
  } else
#line 920
  if ((unsigned long )tp >= (unsigned long )eom) {
#line 921
    return (90);
  }
#line 931
  if (blen > 0) {
#line 934
    if (((blen + 3) & -4) != tbcount) {
#line 935
      return (22);
    }
#line 936
    traillen = tbcount - blen;
#line 937
    if (((value << (8 - traillen)) & 255) != 0) {
#line 938
      return (22);
    }
  } else {
#line 941
    blen = tbcount;
  }
#line 942
  if (blen == 256) {
#line 943
    blen = 0;
  }
#line 946
  *(*labelp) = (char)65;
#line 947
  *(*dst) = (char )blen;
#line 949
  *bp = cp;
#line 950
  *dst = tp;
#line 952
  return (0);
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int labellen___0(u_char const   *lp ) 
{ 
  int bitlen ;
  u_char l ;

  {
#line 959
  l = (u_char )*lp;
#line 961
  if (((int )l & 192) == 192) {
#line 963
    return (-1);
  }
#line 966
  if (((int )l & 192) == 64) {
#line 967
    if ((int )l == 65) {
#line 968
      bitlen = (int )*(lp + 1);
#line 968
      if (bitlen == 0) {
#line 969
        bitlen = 256;
      }
#line 970
      return ((bitlen + 7) / 8 + 1);
    }
#line 972
    return (-1);
  }
#line 974
  return ((int )l);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
static SPF_errcode_t SPF_request_prepare___0(SPF_request_t *sr ) 
{ 


  {
#line 230
  if (sr->use_helo) {
#line 231
    sr->cur_dom = (char const   *)sr->helo_dom;
  } else {
#line 233
    sr->cur_dom = (char const   *)sr->env_from_dp;
  }
#line 234
  return ((SPF_errcode_t )0);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
static SPF_errcode_t SPF_request_query_record___0(SPF_request_t *spf_request , SPF_response_t *spf_response ,
                                                  SPF_record_t *spf_record , SPF_errcode_t err ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 246
  if ((unsigned int )err != 0U) {
#line 247
    if (spf_record) {
      {
#line 248
      SPF_record_free(spf_record);
      }
    }
#line 249
    return (err);
  }
  {
#line 252
  tmp___0 = SPF_response_errors(spf_response);
  }
#line 252
  if (tmp___0 > 0) {
    {
#line 253
    tmp = SPF_response_errors(spf_response);
#line 253
    SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
              255, "Warning: %d errors in response, but no error code. Evaluating.",
              tmp);
    }
  }
  {
#line 257
  spf_response->spf_record_exp = spf_record;
#line 258
  err = SPF_record_interpret(spf_record, spf_request, spf_response, 0);
#line 260
  SPF_record_free(spf_record);
  }
#line 262
  return (err);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c"
static SPF_errcode_t SPF_server_get_default_explanation___2(SPF_server_t *spf_server___1 ,
                                                            SPF_request_t *spf_request ,
                                                            SPF_response_t *spf_response ,
                                                            char **bufp , size_t *buflenp ) 
{ 
  SPF_errcode_t err ;
  SPF_macro_t *spf_macro ;
  SPF_data_t *tmp ;
  size_t len ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  spf_macro = spf_server___1->explanation;
#line 56
  if ((unsigned long )spf_macro != (unsigned long )((void *)0)) {
    {
#line 57
    tmp = SPF_macro_data(spf_macro);
#line 57
    err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, tmp, spf_macro->macro_len,
                                 bufp, buflenp);
    }
#line 61
    return (err);
  } else {
#line 64
    len = sizeof("SPF failure: no explanation available") + 1UL;
#line 65
    if (*buflenp < len) {
      {
#line 66
      tmp___1 = realloc((void *)*bufp, len);
#line 66
      tmp___0 = (char *)tmp___1;
      }
#line 67
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 68
        return ((SPF_errcode_t )1);
      }
#line 69
      *bufp = tmp___0;
#line 70
      *buflenp = len;
    }
    {
#line 72
    strcpy((char */* __restrict  */)*bufp, (char const   */* __restrict  */)"SPF failure: no explanation available");
    }
#line 73
    return ((SPF_errcode_t )0);
  }
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
static void setsection___0(ns_msg *msg , ns_sect sect ) ;
#line 197 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
static void setsection___0(ns_msg *msg , ns_sect sect ) 
{ 


  {
#line 199
  msg->_sect = sect;
#line 200
  if ((unsigned int )sect == 4U) {
#line 201
    msg->_rrnum = -1;
#line 202
    msg->_msg_ptr = (u_char const   *)((void *)0);
  } else {
#line 204
    msg->_rrnum = 0;
#line 205
    msg->_msg_ptr = msg->_sections[(int )sect];
  }
#line 207
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_explanation___2(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  char *buf ;
  size_t buflen ;
  void *tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 53
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 53, "%s", "spf_response is NULL");
      }
    }
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  spf_request = spf_response->spf_request;
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 55
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 55, "%s", "spf_request is NULL");
      }
    }
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  spf_server___1 = spf_request->spf_server;
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 57
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 57
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 57, "%s", "spf_server is NULL");
      }
    }
#line 57
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  spf_record = spf_response->spf_record_exp;
  {
#line 60
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 60
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 60
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 60, "%s", "spf_record is NULL");
      }
    }
#line 60
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 62
  if (spf_response->explanation) {
    {
#line 63
    free((void *)spf_response->explanation);
    }
  }
  {
#line 64
  spf_response->explanation = (char *)((void *)0);
#line 66
  buflen = (size_t )321;
#line 67
  tmp = malloc(buflen);
#line 67
  buf = (char *)tmp;
  }
#line 68
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 69
    return ((SPF_errcode_t )1);
  }
  {
#line 70
  memset((void *)buf, '\000', buflen);
#line 72
  err = SPF_request_get_exp(spf_server___1, spf_request, spf_response, spf_record,
                            & buf, & buflen);
  }
#line 74
  if ((unsigned int )err != 0U) {
    {
#line 75
    free((void *)buf);
    }
#line 76
    return (err);
  }
#line 79
  spf_response->explanation = buf;
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_smtp_comment___2(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_errcode_t err ;
  char buf[320] ;
  char const   *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 92
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 92, "%s", "spf_response is NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  spf_request = spf_response->spf_request;
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 94, "%s", "spf_request is NULL");
      }
    }
#line 94
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  spf_server___1 = spf_request->spf_server;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 96, "%s", "spf_server is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  if (spf_response->smtp_comment) {
    {
#line 99
    free((void *)spf_response->smtp_comment);
    }
  }
#line 100
  spf_response->smtp_comment = (char *)((void *)0);
  {
#line 107
  if ((unsigned int )spf_response->result == 5U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 1U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 4U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 3U) {
#line 107
    goto case_5;
  }
#line 129
  goto switch_default;
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 109
  err = SPF_i_set_explanation___2(spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
#line 111
    return (err);
  }
  {
#line 113
  memset((void *)(buf), '\000', sizeof(buf));
#line 114
  tmp = SPF_strreason(spf_response->reason);
#line 114
  snprintf((char */* __restrict  */)(buf), (size_t )320, (char const   */* __restrict  */)"%s : Reason: %s",
           spf_response->explanation, tmp);
#line 117
  buf[319] = (char )'\000';
#line 120
  spf_response->smtp_comment = strdup((char const   *)(buf));
  }
#line 121
  if (! spf_response->smtp_comment) {
#line 122
    return ((SPF_errcode_t )1);
  }
#line 124
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 130
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 133
  return ((SPF_errcode_t )0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_header_comment___2(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char *spf_source ;
  size_t len ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  char *sender_dom ;
  char *p ;
  char *p_end ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 153
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 153, "%s", "spf_response is NULL");
      }
    }
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  spf_request = spf_response->spf_request;
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 155
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 155, "%s", "spf_request is NULL");
      }
    }
#line 155
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 156
  spf_server___1 = spf_request->spf_server;
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 157
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 157, "%s", "spf_server is NULL");
      }
    }
#line 157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 159
  if (spf_response->header_comment) {
    {
#line 160
    free((void *)spf_response->header_comment);
    }
  }
#line 161
  spf_response->header_comment = (char *)((void *)0);
#line 164
  sender_dom = spf_request->env_from_dp;
#line 165
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
#line 166
    sender_dom = spf_request->helo_dom;
  }
#line 168
  if ((unsigned int )spf_response->reason == 3U) {
    {
#line 169
    spf_source = strdup("local policy");
    }
  } else
#line 171
  if ((unsigned int )spf_response->reason == 6U) {
#line 172
    if ((unsigned long )spf_request->rcpt_to_dom == (unsigned long )((void *)0)) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    } else
#line 172
    if ((int )*(spf_request->rcpt_to_dom + 0) == 0) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    }
    {
#line 175
    spf_source = strdup((char const   *)spf_request->rcpt_to_dom);
    }
  } else
#line 177
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
    {
#line 178
    spf_source = strdup("unknown domain");
    }
  } else {
    {
#line 181
    tmp = strlen((char const   *)sender_dom);
#line 181
    len = tmp + sizeof("domain of ");
#line 182
    tmp___0 = malloc(len);
#line 182
    spf_source = (char *)tmp___0;
    }
#line 183
    if (spf_source) {
      {
#line 184
      snprintf((char */* __restrict  */)spf_source, len, (char const   */* __restrict  */)"domain of %s",
               sender_dom);
      }
    }
  }
#line 187
  if ((unsigned long )spf_source == (unsigned long )((void *)0)) {
#line 188
    return ((SPF_errcode_t )10);
  }
#line 190
  ip = (char const   *)((void *)0);
#line 191
  if (spf_request->client_ver == 2) {
    {
#line 192
    ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                   (socklen_t )sizeof(ip4_buf));
    }
  } else
#line 195
  if (spf_request->client_ver == 10) {
    {
#line 196
    ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                   (socklen_t )sizeof(ip6_buf));
    }
  }
#line 199
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 200
    ip = "(unknown ip address)";
  }
  {
#line 202
  tmp___1 = SPF_request_get_rec_dom(spf_request);
#line 202
  tmp___2 = strlen(tmp___1);
#line 202
  tmp___3 = strlen((char const   *)spf_source);
#line 202
  tmp___4 = strlen(ip);
#line 202
  len = ((tmp___2 + tmp___3) + tmp___4) + 80UL;
#line 203
  tmp___5 = malloc(len);
#line 203
  buf = (char *)tmp___5;
  }
#line 204
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 205
    free((void *)spf_source);
    }
#line 206
    return ((SPF_errcode_t )10);
  }
  {
#line 209
  p = buf;
#line 210
  p_end = p + len;
#line 213
  tmp___6 = SPF_request_get_rec_dom(spf_request);
#line 213
  tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s: ",
                     tmp___6);
#line 213
  p += tmp___7;
  }
  {
#line 217
  if ((unsigned int )spf_response->result == 2U) {
#line 217
    goto case_2;
  }
#line 228
  if ((unsigned int )spf_response->result == 3U) {
#line 228
    goto case_3;
  }
#line 233
  if ((unsigned int )spf_response->result == 4U) {
#line 233
    goto case_4;
  }
#line 238
  if ((unsigned int )spf_response->result == 7U) {
#line 238
    goto case_7;
  }
#line 243
  if ((unsigned int )spf_response->result == 1U) {
#line 243
    goto case_1;
  }
#line 247
  if ((unsigned int )spf_response->result == 5U) {
#line 247
    goto case_5;
  }
#line 252
  if ((unsigned int )spf_response->result == 6U) {
#line 252
    goto case_6;
  }
#line 258
  goto switch_default;
  case_2: /* CIL Label */ 
#line 218
  if ((unsigned int )spf_response->reason == 2U) {
    {
#line 219
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"localhost is always allowed.");
    }
  } else
#line 220
  if ((unsigned int )spf_response->reason == 6U) {
    {
#line 221
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"message received from %s which is an MX secondary for %s.",
             ip, spf_source);
    }
  } else {
    {
#line 224
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s designates %s as permitted sender",
             spf_source, ip);
    }
  }
#line 226
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 229
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 231
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 234
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"transitioning %s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 236
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 239
  tmp___8 = SPF_strerror(spf_response->err);
#line 239
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error in processing during lookup of %s: %s",
           spf_source, tmp___8);
  }
#line 241
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 244
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s is neither permitted nor denied by %s",
           ip, spf_source);
  }
#line 246
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 248
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not provide an SPF record",
           spf_source);
  }
#line 250
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 253
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"encountered temporary error during SPF processing of %s",
           spf_source);
  }
#line 255
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 259
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error: unknown SPF result %d encountered while checking %s for %s",
           (unsigned int )spf_response->result, ip, spf_source);
  }
#line 261
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 264
  if (spf_source) {
    {
#line 265
    free((void *)spf_source);
    }
  }
  {
#line 267
  spf_response->header_comment = SPF_sanitize(spf_server___1, buf);
  }
#line 269
  return ((SPF_errcode_t )0);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_received_spf___2(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  size_t buflen ;
  char *buf_value ;
  char *p ;
  char *p_end ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 282
  buflen = (size_t )480;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 287
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 287, "%s", "spf_response is NULL");
      }
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  spf_request = spf_response->spf_request;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 289
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 289, "%s", "spf_request is NULL");
      }
    }
#line 289
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  spf_server___1 = spf_request->spf_server;
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 291
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 291
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 291, "%s", "spf_server is NULL");
      }
    }
#line 291
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 293
  if (spf_response->received_spf) {
    {
#line 294
    free((void *)spf_response->received_spf);
    }
  }
  {
#line 295
  spf_response->received_spf = (char *)((void *)0);
#line 297
  tmp = malloc(buflen);
#line 297
  buf = (char *)tmp;
  }
#line 298
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 299
    return ((SPF_errcode_t )10);
  }
  {
#line 301
  p = buf;
#line 302
  p_end = p + buflen;
#line 306
  tmp___0 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"Received-SPF: ");
#line 306
  p += tmp___0;
#line 307
  buf_value = p;
  }
  {
#line 309
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 310
    tmp___1 = SPF_strresult(spf_response->result);
#line 310
    tmp___2 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s (%s)",
                       tmp___1, spf_response->header_comment);
#line 310
    p += tmp___2;
    }
#line 313
    if (p_end - p <= 0L) {
#line 313
      goto while_break___2;
    }
#line 318
    ip = (char const   *)((void *)0);
#line 319
    if (spf_request->client_ver == 2) {
      {
#line 320
      ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                     (socklen_t )sizeof(ip4_buf));
      }
    } else
#line 323
    if (spf_request->client_ver == 10) {
      {
#line 324
      ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                     (socklen_t )sizeof(ip6_buf));
      }
    }
#line 328
    if ((unsigned long )ip != (unsigned long )((void *)0)) {
      {
#line 329
      tmp___3 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" client-ip=%s;",
                         ip);
#line 329
      p += tmp___3;
      }
#line 330
      if (p_end - p <= 0L) {
#line 330
        goto while_break___2;
      }
    }
#line 335
    if ((unsigned long )spf_request->env_from != (unsigned long )((void *)0)) {
      {
#line 336
      tmp___4 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" envelope-from=%s;",
                         spf_request->env_from);
#line 336
      p += tmp___4;
      }
#line 337
      if (p_end - p <= 0L) {
#line 337
        goto while_break___2;
      }
    }
#line 342
    if ((unsigned long )spf_request->helo_dom != (unsigned long )((void *)0)) {
      {
#line 343
      tmp___5 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" helo=%s;",
                         spf_request->helo_dom);
#line 343
      p += tmp___5;
      }
#line 344
      if (p_end - p <= 0L) {
#line 344
        goto while_break___2;
      }
    }
#line 309
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 366
  spf_response->received_spf = SPF_sanitize(spf_server___1, buf);
#line 367
  spf_response->received_spf_value = buf_value;
  }
#line 369
  return ((SPF_errcode_t )0);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_mech_cidr___2(SPF_request_t *spf_request , SPF_mech_t *mech ) 
{ 
  SPF_data_t *data ;
  SPF_data_t *tmp ;

  {
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if ((unsigned long )mech == (unsigned long )((void *)0)) {
      {
#line 428
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 428, "%s", "mech is NULL");
      }
    }
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  if ((int )mech->mech_type == 6) {
#line 433
    goto case_6;
  }
#line 433
  if ((int )mech->mech_type == 5) {
#line 433
    goto case_6;
  }
#line 438
  if ((int )mech->mech_type == 2) {
#line 438
    goto case_2;
  }
#line 438
  if ((int )mech->mech_type == 1) {
#line 438
    goto case_2;
  }
#line 430
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 434
  return ((int )mech->mech_len);
#line 435
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 439
  data = SPF_mech_data(mech);
#line 441
  tmp = SPF_mech_end_data(mech);
  }
#line 441
  if ((unsigned long )data < (unsigned long )tmp) {
#line 441
    if ((int )data->dc.parm_type == 11) {
#line 444
      if (spf_request->client_ver == 2) {
#line 445
        return ((int )data->dc.ipv4);
      } else
#line 446
      if (spf_request->client_ver == 10) {
#line 447
        return ((int )data->dc.ipv6);
      }
    }
  }
#line 449
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 452
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip4___2(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in_addr ipv4 ) 
{ 
  char src_ip4_buf[16] ;
  char dst_ip4_buf[16] ;
  char mask_ip4_buf[16] ;
  struct in_addr src_ipv4 ;
  int cidr ;
  int mask ;
  uint32_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 471
  if (spf_request->client_ver != 2) {
#line 472
    return (0);
  }
  {
#line 474
  src_ipv4 = spf_request->ipv4;
#line 476
  cidr = SPF_i_mech_cidr___2(spf_request, mech);
  }
#line 477
  if (cidr == 0) {
#line 478
    cidr = 32;
  }
  {
#line 479
  mask = (int )(4294967295U << (32 - cidr));
#line 480
  tmp = htonl((uint32_t )mask);
#line 480
  mask = (int )tmp;
  }
#line 482
  if (spf_server___1->debug) {
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 483
      tmp___0 = inet_ntop(2, (void const   */* __restrict  */)(& src_ipv4.s_addr),
                          (char */* __restrict  */)(src_ip4_buf), (socklen_t )sizeof(src_ip4_buf));
      }
#line 483
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 483
        snprintf((char */* __restrict  */)(src_ip4_buf), sizeof(src_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 483
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 485
      tmp___1 = inet_ntop(2, (void const   */* __restrict  */)(& ipv4.s_addr), (char */* __restrict  */)(dst_ip4_buf),
                          (socklen_t )sizeof(dst_ip4_buf));
      }
#line 485
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 485
        snprintf((char */* __restrict  */)(dst_ip4_buf), sizeof(dst_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 487
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 487
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& mask), (char */* __restrict  */)(mask_ip4_buf),
                          (socklen_t )sizeof(mask_ip4_buf));
      }
#line 487
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
#line 487
        snprintf((char */* __restrict  */)(mask_ip4_buf), sizeof(mask_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 487
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 489
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               491, "ip_match:  %s == %s  (/%d %s):  %d", src_ip4_buf, dst_ip4_buf,
               cidr, mask_ip4_buf, (src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
    }
  }
#line 494
  return ((src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip6___2(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in6_addr ipv6 ) 
{ 
  char src_ip6_buf[46] ;
  char dst_ip6_buf[46] ;
  struct in6_addr src_ipv6 ;
  int cidr ;
  int cidr_save ;
  int mask ;
  int i ;
  int match ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 512
  if (spf_request->client_ver != 10) {
#line 513
    return (0);
  }
  {
#line 515
  src_ipv6 = spf_request->ipv6;
#line 517
  cidr = SPF_i_mech_cidr___2(spf_request, mech);
  }
#line 518
  if (cidr == 0) {
#line 519
    cidr = 128;
  }
#line 520
  cidr_save = cidr;
#line 522
  match = 1;
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if ((long )i < (long )(sizeof(ipv6.__in6_u.__u6_addr8) / sizeof(ipv6.__in6_u.__u6_addr8[0]))) {
#line 523
      if (! match) {
#line 523
        goto while_break;
      }
    } else {
#line 523
      goto while_break;
    }
#line 525
    if (cidr > 8) {
#line 526
      mask = 255;
    } else
#line 527
    if (cidr > 0) {
#line 528
      mask = (255 << (8 - cidr)) & 255;
    } else {
#line 530
      goto while_break;
    }
#line 531
    cidr -= 8;
#line 533
    match = ((int )src_ipv6.__in6_u.__u6_addr8[i] & mask) == ((int )ipv6.__in6_u.__u6_addr8[i] & mask);
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (spf_server___1->debug) {
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 537
      tmp = inet_ntop(10, (void const   */* __restrict  */)(& src_ipv6.__in6_u.__u6_addr8),
                      (char */* __restrict  */)(src_ip6_buf), (socklen_t )sizeof(src_ip6_buf));
      }
#line 537
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 537
        snprintf((char */* __restrict  */)(src_ip6_buf), sizeof(src_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 537
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 539
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 539
      tmp___0 = inet_ntop(10, (void const   */* __restrict  */)(& ipv6.__in6_u.__u6_addr8),
                          (char */* __restrict  */)(dst_ip6_buf), (socklen_t )sizeof(dst_ip6_buf));
      }
#line 539
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 539
        snprintf((char */* __restrict  */)(dst_ip6_buf), sizeof(dst_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 539
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 541
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               542, "ip_match:  %s == %s  (/%d):  %d", src_ip6_buf, dst_ip6_buf, cidr_save,
               match);
    }
  }
#line 545
  return (match);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_domain___2(SPF_server_t *spf_server___1 , char const   *hostname ,
                                  char const   *domain ) 
{ 
  char const   *hp ;
  size_t hlen ;
  size_t dlen ;
  int tmp ;
  int tmp___0 ;

  {
#line 556
  if (spf_server___1->debug) {
    {
#line 557
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               557, "%s ?=? %s", hostname, domain);
    }
  }
  {
#line 559
  hlen = strlen(hostname);
#line 560
  dlen = strlen(domain);
  }
#line 563
  if (dlen > hlen) {
#line 564
    return (0);
  }
#line 567
  if (dlen == hlen) {
    {
#line 568
    tmp = strcasecmp(hostname, domain);
    }
#line 568
    return (tmp == 0);
  }
#line 571
  hp = hostname + (hlen - dlen);
#line 573
  if ((int const   )*(hp - 1) != 46) {
#line 574
    return (0);
  }
  {
#line 576
  tmp___0 = strcasecmp(hp, domain);
  }
#line 576
  return (tmp___0 == 0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_pre___2(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                  ns_type rr_type , int should_cache ) 
{ 
  char const   *tmp ;

  {
#line 51
  if (spf_dns_server->debug) {
    {
#line 52
    tmp = SPF_strrrtype(rr_type);
#line 52
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               54, "DNS[%s] lookup: %s %s (%d)", spf_dns_server->name, domain, tmp,
               (unsigned int )rr_type);
    }
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_post___2(SPF_dns_server_t *spf_dns_server , SPF_dns_rr_t *spfrr ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 61
  if (spf_dns_server->debug) {
    {
#line 66
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               66, "DNS[%s] found record", spf_dns_server->name);
#line 67
    tmp = SPF_strrrtype(spfrr->rr_type);
#line 67
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               69, "    DOMAIN: %s  TYPE: %s (%d)", spfrr->domain, tmp, (unsigned int )spfrr->rr_type);
    }
#line 70
    if (spfrr->source) {
#line 70
      if ((spfrr->source)->name) {
#line 70
        tmp___0 = (spfrr->source)->name;
      } else {
#line 70
        tmp___0 = "(unnamed source)";
      }
#line 70
      tmp___1 = tmp___0;
    } else {
#line 70
      tmp___1 = "(null source)";
    }
    {
#line 70
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               76, "    TTL: %ld  RR found: %d  herrno: %d  source: %s", spfrr->ttl,
               spfrr->num_rr, spfrr->herrno, tmp___1);
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! (i < spfrr->num_rr)) {
#line 77
        goto while_break;
      }
      {
#line 79
      if ((unsigned int )spfrr->rr_type == 1U) {
#line 79
        goto case_1;
      }
#line 85
      if ((unsigned int )spfrr->rr_type == 12U) {
#line 85
        goto case_12;
      }
#line 89
      if ((unsigned int )spfrr->rr_type == 15U) {
#line 89
        goto case_15;
      }
#line 93
      if ((unsigned int )spfrr->rr_type == 16U) {
#line 93
        goto case_16;
      }
#line 97
      if ((unsigned int )spfrr->rr_type == 99U) {
#line 97
        goto case_99;
      }
#line 101
      if ((unsigned int )spfrr->rr_type == 28U) {
#line 101
        goto case_28;
      }
#line 107
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 80
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->a),
                          (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
#line 80
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 82, "    - A: %s", tmp___2);
      }
#line 83
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 86
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 86, "    - PTR: %s", (*(spfrr->rr + i))->ptr);
      }
#line 87
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 90
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 90, "    - MX: %s", (*(spfrr->rr + i))->mx);
      }
#line 91
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 94
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 94, "    - TXT: %s", (*(spfrr->rr + i))->txt);
      }
#line 95
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 98
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 98, "    - SPF: %s", (*(spfrr->rr + i))->txt);
      }
#line 99
      goto switch_break;
      case_28: /* CIL Label */ 
      {
#line 102
      tmp___3 = inet_ntop(10, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->aaaa),
                          (char */* __restrict  */)(ip6_buf), (socklen_t )sizeof(ip6_buf));
#line 102
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 104, "    - AAAA: %s", tmp___3);
      }
#line 105
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 108
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 108, "    - Unknown RR type");
      }
#line 109
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 77
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 113
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_cache_bucket_t *SPF_dns_cache_bucket_find___2(SPF_dns_cache_config_t *spfhook ,
                                                             char const   *domain ,
                                                             ns_type rr_type , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  SPF_dns_rr_t *rr ;
  time_t now ;
  int tmp ;

  {
  {
#line 247
  bucket = *(spfhook->cache + idx);
#line 248
  prev = (SPF_dns_cache_bucket_t *)((void *)0);
#line 249
  time(& now);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
#line 252
    rr = bucket->rr;
#line 254
    if (rr->utc_ttl < now) {
#line 256
      if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 257
        prev->next = bucket->next;
      } else {
#line 259
        *(spfhook->cache + idx) = bucket->next;
      }
#line 261
      if (bucket->rr) {
        {
#line 262
        SPF_dns_rr_free(bucket->rr);
        }
      }
      {
#line 263
      free((void *)bucket);
#line 265
      bucket = prev;
      }
    } else
#line 267
    if (! ((unsigned int )rr->rr_type != (unsigned int )rr_type)) {
      {
#line 270
      tmp = strcmp((char const   *)rr->domain, domain);
      }
#line 270
      if (! (tmp != 0)) {
#line 275
        if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 276
          prev->next = bucket->next;
#line 277
          bucket->next = *(spfhook->cache + idx);
#line 278
          *(spfhook->cache + idx) = bucket;
        }
#line 280
        return (bucket);
      }
    }
#line 283
    prev = bucket;
#line 284
    if ((unsigned long )bucket == (unsigned long )((void *)0)) {
#line 285
      bucket = *(spfhook->cache + idx);
    } else {
#line 287
      bucket = bucket->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return ((SPF_dns_cache_bucket_t *)((void *)0));
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_bucket_add___2(SPF_dns_cache_config_t *spfhook ,
                                                  SPF_dns_rr_t *rr , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  void *tmp ;

  {
  {
#line 300
  tmp = malloc(sizeof(SPF_dns_cache_bucket_t ));
#line 300
  bucket = (SPF_dns_cache_bucket_t *)tmp;
  }
#line 302
  if (! bucket) {
#line 303
    return ((SPF_errcode_t )1);
  }
#line 304
  bucket->next = *(spfhook->cache + idx);
#line 305
  *(spfhook->cache + idx) = bucket;
#line 306
  bucket->rr = rr;
#line 307
  return ((SPF_errcode_t )0);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_rr_fixup___2(SPF_dns_cache_config_t *spfhook ,
                                                SPF_dns_rr_t *cached_rr , char const   *domain ,
                                                ns_type rr_type ) 
{ 
  char *p ;
  char *new_domain ;
  size_t new_len ;
  size_t tmp ;
  void *tmp___0 ;
  time_t tmp___1 ;

  {
#line 322
  if ((unsigned int )cached_rr->rr_type == 255U) {
#line 323
    cached_rr->rr_type = rr_type;
  }
#line 326
  if ((unsigned long )cached_rr->domain == (unsigned long )((void *)0)) {
#line 326
    goto _L;
  } else
#line 326
  if ((int )*(cached_rr->domain + 0) != 0) {
    _L: /* CIL Label */ 
    {
#line 328
    tmp = strlen(domain);
#line 328
    new_len = tmp + 1UL;
    }
#line 330
    if (cached_rr->domain_buf_len < new_len) {
      {
#line 331
      tmp___0 = realloc((void *)cached_rr->domain, new_len);
#line 331
      new_domain = (char *)tmp___0;
      }
#line 332
      if ((unsigned long )new_domain == (unsigned long )((void *)0)) {
#line 333
        return ((SPF_errcode_t )1);
      }
#line 334
      cached_rr->domain = new_domain;
#line 335
      cached_rr->domain_buf_len = new_len;
    }
    {
#line 337
    strcpy((char */* __restrict  */)cached_rr->domain, (char const   */* __restrict  */)domain);
    }
  }
#line 341
  if (cached_rr->ttl < spfhook->min_ttl) {
#line 342
    cached_rr->ttl = spfhook->min_ttl;
  }
#line 344
  if (cached_rr->ttl < spfhook->txt_ttl) {
#line 344
    if ((unsigned int )cached_rr->rr_type == 16U) {
#line 346
      cached_rr->ttl = spfhook->txt_ttl;
    }
  }
#line 348
  if (cached_rr->ttl < spfhook->err_ttl) {
#line 348
    if (cached_rr->herrno != 0) {
#line 350
      cached_rr->ttl = spfhook->err_ttl;
    }
  }
#line 352
  if (cached_rr->ttl < spfhook->rdns_ttl) {
    {
#line 353
    p = strstr((char const   *)cached_rr->domain, ".arpa");
    }
#line 354
    if (p) {
#line 354
      if ((int )*(p + (sizeof(".arpa") - 1UL)) == 0) {
#line 355
        cached_rr->ttl = spfhook->rdns_ttl;
      }
    }
  }
  {
#line 358
  tmp___1 = time((time_t *)((void *)0));
#line 358
  cached_rr->utc_ttl = cached_rr->ttl + tmp___1;
  }
#line 360
  return ((SPF_errcode_t )0);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_rr_t *SPF_dns_cache_lookup___2(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                              ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_rr_t *cached_rr ;
  SPF_dns_rr_t *rr ;
  int idx ;
  SPF_errcode_t tmp ;
  SPF_dns_rr_t *tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;

  {
  {
#line 377
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
#line 381
  idx = crc32str(0U, domain, spfhook->max_hash_len);
#line 382
  idx &= spfhook->cache_size - 1;
#line 384
  pthread_mutex_lock(& spfhook->cache_lock);
#line 386
  bucket = SPF_dns_cache_bucket_find___2(spfhook, domain, rr_type, idx);
  }
#line 387
  if ((unsigned long )bucket != (unsigned long )((void *)0)) {
#line 388
    if ((unsigned long )bucket->rr != (unsigned long )((void *)0)) {
      {
#line 389
      tmp = SPF_dns_rr_dup(& rr, bucket->rr);
      }
#line 389
      if ((unsigned int )tmp == 0U) {
        {
#line 390
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 391
        return (rr);
      } else
#line 393
      if ((unsigned long )rr != (unsigned long )((void *)0)) {
        {
#line 394
        SPF_dns_rr_free(rr);
        }
      }
    }
  }
  {
#line 401
  bucket = (SPF_dns_cache_bucket_t *)((void *)0);
#line 403
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 405
  if (! spf_dns_server->layer_below) {
    {
#line 406
    tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
    }
#line 406
    return (tmp___0);
  }
  {
#line 408
  rr = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
  }
#line 410
  if (spfhook->conserve_cache) {
#line 410
    if (! should_cache) {
#line 411
      return (rr);
    }
  }
  {
#line 413
  pthread_mutex_lock(& spfhook->cache_lock);
#line 415
  tmp___3 = SPF_dns_rr_dup(& cached_rr, rr);
  }
#line 415
  if ((unsigned int )tmp___3 == 0U) {
    {
#line 416
    tmp___2 = SPF_dns_cache_rr_fixup___2(spfhook, cached_rr, domain, rr_type);
    }
#line 416
    if ((unsigned int )tmp___2 == 0U) {
      {
#line 417
      tmp___1 = SPF_dns_cache_bucket_add___2(spfhook, cached_rr, idx);
      }
#line 417
      if ((unsigned int )tmp___1 == 0U) {
        {
#line 418
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 419
        return (rr);
      }
    }
  }
  {
#line 424
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 426
  if (cached_rr) {
    {
#line 427
    SPF_dns_rr_free(cached_rr);
    }
  }
#line 429
  return (rr);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static void SPF_dns_cache_free___2(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  int i ;

  {
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 442
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
                 442, "%s", "spf_dns_server is NULL");
      }
    }
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
  }
#line 445
  if (spfhook) {
    {
#line 446
    pthread_mutex_lock(& spfhook->cache_lock);
    }
#line 448
    if (spfhook->cache) {
#line 449
      i = 0;
      {
#line 449
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 449
        if (! (i < spfhook->cache_size)) {
#line 449
          goto while_break___0;
        }
#line 450
        bucket = *(spfhook->cache + i);
        {
#line 451
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 451
          if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 451
            goto while_break___1;
          }
#line 452
          prev = bucket;
#line 453
          bucket = bucket->next;
#line 456
          if (prev->rr) {
            {
#line 457
            SPF_dns_rr_free(prev->rr);
            }
          }
          {
#line 458
          free((void *)prev);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 449
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 461
      free((void *)spfhook->cache);
#line 462
      spfhook->cache = (SPF_dns_cache_bucket_t **)((void *)0);
      }
    }
    {
#line 465
    pthread_mutex_unlock(& spfhook->cache_lock);
#line 476
    pthread_mutex_destroy(& spfhook->cache_lock);
#line 478
    free((void *)spfhook);
    }
  }
  {
#line 481
  free((void *)spf_dns_server);
  }
#line 482
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
static SPF_dns_test_data_t const   SPF_dns_db___2[175]  = 
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
  {      {"localhost", 1, 0, "127.0.0.1"}, 
        {"example.com", 1, 0, "192.0.2.3"}, 
        {"example.com", 15, 0, "mx.example.org"}, 
        {"example.com", 16, 0, "v=spf1 mx -all"}, 
        {"3.2.0.192.in-addr.arpa", 12, 0, "mx.example.org"}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}, 
        {"noexist.example.com", 1, 1, (char const   *)((void *)0)}, 
        {"mx.example.org", 1, 0, "192.0.2.3"}, 
        {"mx.example.org", 28, 0, "5f05:2000:80ad:5800::1"}, 
        {"email.example.com", 16, 0, "v=spf1 -all"}, 
        {"*.example.com", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.org", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.net", 255, 1, (char const   *)((void *)0)}, 
        {"01.spf1-test.mailzone.com", 16, 0, "v=spf1                                                             "}, 
        {"02.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             -all       "}, 
        {"03.spf1-test.mailzone.com", 16, 0, "v=spf1                                             ~all"}, 
        {"05.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             default=deny   "}, 
        {"06.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             ?all "}, 
        {"07.spf1-test.mailzone.com", 16, 0, "v=spf2                                             default=bogus   "}, 
        {"08.spf1-test.mailzone.com",
      16, 0, "v=spf1                       -all      ?all  "}, 
        {"09.spf1-test.mailzone.com", 16, 0, "v=spf1    scope=header-from scope=envelope         -all  "}, 
        {"10.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx                                          -all"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"11.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"13.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"20.spf1-test.mailzone.com", 1, 0, "192.0.2.120"}, 
        {"20.spf1-test.mailzone.com", 16, 0, "v=spf1 a                                           -all"}, 
        {"21.spf1-test.mailzone.com",
      16, 0, "v=spf1   a:spf1-test.mailzone.com                            -all"}, 
        {"21.spf1-test.mailzone.com",
      1, 0, "192.0.2.121"}, 
        {"22.spf1-test.mailzone.com", 16, 0, "v=spf1 a a:spf1-test.mailzone.com                            -all"}, 
        {"22.spf1-test.mailzone.com",
      1, 0, "192.0.2.122"}, 
        {"30.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr                                         -all"}, 
        {"30.spf1-test.mailzone.com",
      1, 0, "208.210.124.130"}, 
        {"31.spf1-test.mailzone.com", 16, 0, "v=spf1     ptr:spf1-test.mailzone.com                        -all"}, 
        {"31.spf1-test.mailzone.com",
      1, 0, "208.210.124.131"}, 
        {"32.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr ptr:spf1-test.mailzone.com                        -all"}, 
        {"32.spf1-test.mailzone.com",
      1, 0, "208.210.124.132"}, 
        {"40.spf1-test.mailzone.com", 16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d}                    -all"}, 
        {"41.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.spf1-test.mailzone.com            -all"}, 
        {"42.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d} exists:%{ir}.%{v}._spf.%{d3} -all"}, 
        {"45.spf1-test.mailzone.com",
      16, 0, "v=spf1 -a a:spf1-test.mailzone.com                           -all"}, 
        {"45.spf1-test.mailzone.com",
      1, 0, "192.0.2.147"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.145"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.146"}, 
        {"50.spf1-test.mailzone.com", 16, 0, "v=spf1 include                                     -all"}, 
        {"51.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"52.spf1-test.mailzone.com", 16, 0, "v=spf1 include:53.spf1-test.mailzone.com                  -all"}, 
        {"53.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"54.spf1-test.mailzone.com", 16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"55.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:56.spf1-test.mailzone.com                  -all"}, 
        {"57.spf1-test.mailzone.com", 16, 0, "v=spf1 include:spf1-test.mailzone.com         -all"}, 
        {"58.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:59.spf1-test.mailzone.com                  -all"}, 
        {"59.spf1-test.mailzone.com", 16, 0, "v=spf1 include:58.spf1-test.mailzone.com                  -all"}, 
        {"70.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{lr+=}.lp._spf.spf1-test.mailzone.com -all"}, 
        {"80.spf1-test.mailzone.com", 16, 0, "v=spf1 a mx exists:%{ir}.%{v}._spf.80.spf1-test.mailzone.com ptr -all"}, 
        {"80.spf1-test.mailzone.com",
      1, 0, "208.210.124.180"}, 
        {"90.spf1-test.mailzone.com", 16, 0, "v=spf1  ip4:192.0.2.128/25 -all"}, 
        {"91.spf1-test.mailzone.com", 16, 0, "v=spf1 -ip4:192.0.2.128/25 ip4:192.0.2.0/24 -all"}, 
        {"92.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?ip4:192.0.2.192/26 ip4:192.0.2.128/25 -ip4:192.0.2.0/24 -all"}, 
        {"95.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -all"}, 
        {"96.spf1-test.mailzone.com", 16, 0, "v=spf1 -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"97.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"98.spf1-test.mailzone.com",
      16, 0, "v=spf1 a/26 mx/26 -all"}, 
        {"98.spf1-test.mailzone.com", 15, 0, "80.spf1-test.mailzone.com"}, 
        {"98.spf1-test.mailzone.com", 1, 0, "192.0.2.98"}, 
        {"99.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp=99txt.spf1-test.mailzone.com moo"}, 
        {"99txt.spf1-test.mailzone.com",
      16, 0, "u=%{u} s=%{s} d=%{d} t=%{t} h=%{h} i=%{i} %% U=%{U} S=%{S} D=%{D} T=%{T} H=%{H} I=%{I} %% moo"}, 
        {"100.spf1-test.mailzone.com",
      16, 0, "v=spf1      redirect=98.spf1-test.mailzone.com"}, 
        {"101.spf1-test.mailzone.com", 16, 0, "v=spf1 -all redirect=98.spf1-test.mailzone.com"}, 
        {"102.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?all redirect=98.spf1-test.mailzone.com"}, 
        {"103.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=98.%{d3}"}, 
        {"104.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=105.%{d3}"}, 
        {"105.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=106.%{d3}"}, 
        {"106.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=107.%{d3}"}, 
        {"107.spf1-test.mailzone.com", 16, 0, "v=spf1       include:104.%{d3}"}, 
        {"110.spf1-test.mailzone.com", 16, 0, "v=spf1 some:unrecognized=mechanism some=unrecognized:modifier -all"}, 
        {"111.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx -a gpg ~all exp=111txt.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"111txt.2.0.192.in-addr._spf.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"112.spf1-test.mailzone.com",
      16, 0, "v=spf1 a mp3 ~all"}, 
        {"112.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"113.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3: ~all"}, 
        {"113.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114.spf1-test.mailzone.com", 16, 0, "v=spf1 mx -a gpg=test ~all exp=114txt.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com",
      15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114txt.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"115.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3=yes -all"}, 
        {"115.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"116.spf1-test.mailzone.com", 16, 0, "v=spf1 redirect=116rdr.spf1-test.mailzone.com a"}, 
        {"116.spf1-test.mailzone.com",
      1, 0, "192.0.2.200"}, 
        {"116rdr.spf1-test.mailzone.com", 16, 0, "v=spf1 -all"}, 
        {"117.spf1-test.mailzone.com", 16, 0, " v=spf1 +all"}, 
        {"118.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp="}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.10"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.11"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.12"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.13"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.20"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.21"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.22"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.23"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.30"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.31"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.32"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.33"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.40"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.41"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.42"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.43"}, 
        {"56.spf1-test.mailzone.com", 16, 4, (char const   *)((void *)0)}, 
        {"80.spf1-test.mailzone.com", 15, 4, (char const   *)((void *)0)}, 
        {"servfail.spf1-test.mailzone.com", 16, 2, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 1, 0, "208.210.124.192"}, 
        {"spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"fallback-relay.spf1-test.mailzone.com", 15, 0, "mx04.spf1-test.mailzone.com"}, 
        {"www1.cnn.com",
      1, 0, "64.236.24.4"}, 
        {"4.24.236.64.in-addr.arpa", 12, 0, "www1.cnn.com"}, 
        {"130.124.210.208.in-addr.arpa", 12, 0, "30.spf1-test.mailzone.com"}, 
        {"131.124.210.208.in-addr.arpa", 12, 0, "31.spf1-test.mailzone.com"}, 
        {"192.124.210.208.in-addr.arpa", 12, 0, "spf1-test.mailzone.com"}, 
        {"100.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"110.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"111.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"101.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"130.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"131.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"80.2.0.192.in-addr._spf.80.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"96.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"97.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com",
      1, 0, "127.0.0.2"}, 
        {"bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"postmaster.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"2.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.joe.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"102.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"110.2.0.192.in-addr._spf.42.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"131.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"4.24.236.64.in-addr._spf.80.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"droid.lp._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"joe-2.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"moe-1.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"unknown.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"180.124.210.208.in-addr.arpa",
      12, 0, "80.spf1-test.mailzone.com"}, 
        {"80.spf1-test.mailzone.com.whitelist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.124.210.208.in-addr.arpa",
      12, 0, "pobox-gw.icgroup.com"}, 
        {"pobox-gw.icgroup.com", 1, 0, "208.210.124.1"}, 
        {"pobox-gw.icgroup.com.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com",
      16, 1, (char const   *)((void *)0)}, 
        {"spf.trusted-forwarder.org", 16, 0, "v=spf1 exists:%{ir}.wl.trusted-forwarder.org exists:%{p}.wl.trusted-forwarder.org"}, 
        {"*.spf1-text.mailzone.com",
      255, 1, (char const   *)((void *)0)}, 
        {"cat.com", 16, 4, (char const   *)((void *)0)}, 
        {"bar.com", 16, 4, (char const   *)((void *)0)}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}};
#line 41 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static SPF_dns_rr_t *SPF_dns_null_lookup___2(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_rr_t *tmp ;
  SPF_dns_rr_t *tmp___0 ;

  {
#line 45
  if (spf_dns_server->layer_below) {
    {
#line 46
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 46
    return (tmp);
  }
  {
#line 48
  tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
  }
#line 48
  return (tmp___0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static void SPF_dns_null_free___2(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 54
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c",
                 54, "%s", "spf_dns_server is NULL");
      }
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  free((void *)spf_dns_server);
  }
#line 56
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
static SPF_response_t *SPF_response_choose___0(SPF_response_t *yes , SPF_response_t *no ) 
{ 


  {
  {
#line 80
  SPF_response_free(no);
  }
#line 81
  return (yes);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
static SPF_errcode_t SPF_response_add_error_v___0(SPF_response_t *rp , SPF_errcode_t code ,
                                                  int is_error , char const   *text ,
                                                  int idx , char const   *format ,
                                                  va_list ap ) 
{ 
  SPF_error_t *tmp ;
  char buf[4096] ;
  int size ;
  void *tmp___0 ;

  {
#line 198
  if (! format) {
    {
#line 199
    format = SPF_strerror(code);
    }
  }
  {
#line 200
  size = vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
                   ap);
  }
#line 201
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
#line 202
    snprintf((char */* __restrict  */)(& buf[size]), sizeof(buf) - (unsigned long )size,
             (char const   */* __restrict  */)" near \'%.12s\'", text + idx);
    }
  }
#line 205
  buf[4095] = (char )'\000';
#line 207
  if ((int )rp->errors_length == (int )rp->errors_size) {
    {
#line 208
    size = ((int )rp->errors_size + (int )rp->errors_size / 4) + 4;
#line 209
    tmp___0 = realloc((void *)rp->errors, (unsigned long )size * sizeof(SPF_error_t ));
#line 209
    tmp = (SPF_error_t *)tmp___0;
    }
#line 210
    if (! tmp) {
      {
#line 211
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c",
                 211, "%s", "Failed to allocate memory for extra response error");
      }
#line 212
      return (code);
    }
#line 214
    rp->errors = tmp;
#line 215
    rp->errors_size = (unsigned short )size;
  }
  {
#line 218
  (rp->errors + rp->errors_length)->code = code;
#line 219
  (rp->errors + rp->errors_length)->is_error = (char )is_error;
#line 221
  (rp->errors + rp->errors_length)->message = strdup((char const   *)(buf));
#line 222
  rp->errors_length = (unsigned short )((int )rp->errors_length + 1);
  }
#line 224
  return (code);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   spf_mechtypes___2[10]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
  {      {(unsigned char)0, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)1, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)2, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)3, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )0}, 
        {(unsigned char)4, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)5, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)6, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)7, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)8, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)9, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}};
#line 94 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   *SPF_mechtype_find___2(int mech_type ) 
{ 
  size_t i ;

  {
#line 98
  i = (size_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < sizeof(spf_mechtypes___2) / sizeof(spf_mechtypes___2[0]))) {
#line 98
      goto while_break;
    }
#line 99
    if ((int const   )spf_mechtypes___2[i].mech_type == (int const   )mech_type) {
#line 100
      return (& spf_mechtypes___2[i]);
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((SPF_mechtype_t const   *)((void *)0));
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static int ( __attribute__((__warn_unused_result__)) SPF_c_ensure_capacity___2)(void **datap ,
                                                                                size_t *sizep ,
                                                                                size_t length ) 
{ 
  size_t size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 109
  size = *sizep;
#line 110
  if (length > size) {
#line 111
    size = length + length / 4UL;
  }
#line 112
  if (size > *sizep) {
    {
#line 113
    tmp___0 = realloc(*datap, size);
#line 113
    tmp = tmp___0;
    }
#line 114
    if (! tmp) {
#line 115
      return (-1);
    }
#line 117
    *datap = tmp;
#line 118
    *sizep = size;
  }
#line 120
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip6___2(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 144
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 144
  mask = (int )tmp;
  }
#line 146
  if (mask > 128) {
    {
#line 147
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (>128)");
    }
#line 147
    return (tmp___0);
  } else
#line 151
  if (mask == 0) {
    {
#line 152
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (=0)");
    }
#line 152
    return (tmp___1);
  } else
#line 156
  if (mask == 128) {
#line 157
    mask = 0;
  }
#line 160
  *maskp = (unsigned char )mask;
#line 162
  return ((SPF_errcode_t )0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip4___2(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 186
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 186
  mask = (int )tmp;
  }
#line 188
  if (mask > 32) {
    {
#line 189
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (>32)");
    }
#line 189
    return (tmp___0);
  } else
#line 193
  if (mask == 0) {
    {
#line 194
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (=0)");
    }
#line 194
    return (tmp___1);
  } else
#line 198
  if (mask == 32) {
#line 199
    mask = 0;
  }
#line 202
  *maskp = (unsigned char )mask;
#line 204
  return ((SPF_errcode_t )0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr___2(SPF_response_t *spf_response , SPF_data_cidr_t *data ,
                                          char const   *src , size_t *src_len ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 220
  memset((void *)data, 0, sizeof(SPF_data_cidr_t ));
#line 221
  data->parm_type = (unsigned char)11;
#line 227
  idx = *src_len - 1UL;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (idx > 0UL) {
      {
#line 228
      tmp = __ctype_b_loc();
      }
#line 228
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 228
        goto while_break;
      }
    } else {
#line 228
      goto while_break;
    }
#line 229
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (idx < *src_len - 1UL) {
#line 236
    if ((int const   )*(src + idx) == 47) {
#line 237
      if (idx > 0UL) {
#line 237
        if ((int const   )*(src + (idx - 1UL)) == 47) {
          {
#line 239
          err = SPF_c_parse_cidr_ip6___2(spf_response, & data->ipv6, src + idx);
          }
#line 240
          if (err) {
#line 241
            return (err);
          }
#line 243
          *src_len = idx - 1UL;
#line 244
          idx = *src_len - 1UL;
          {
#line 245
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 245
            if (idx > 0UL) {
              {
#line 245
              tmp___0 = __ctype_b_loc();
              }
#line 245
              if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 245
                goto while_break___0;
              }
            } else {
#line 245
              goto while_break___0;
            }
#line 246
            idx --;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 249
          if (idx < *src_len - 1UL) {
#line 249
            if ((int const   )*(src + idx) == 47) {
              {
#line 253
              err = SPF_c_parse_cidr_ip4___2(spf_response, & data->ipv4, src + idx);
              }
#line 254
              if (err) {
#line 255
                return (err);
              }
#line 256
              *src_len = idx;
            }
          }
        } else {
#line 237
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 261
        err = SPF_c_parse_cidr_ip4___2(spf_response, & data->ipv4, src + idx);
        }
#line 262
        if (err) {
#line 263
          return (err);
        }
#line 264
        *src_len = idx;
      }
    }
  }
#line 268
  return ((SPF_errcode_t )0);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_var___2(SPF_response_t *spf_response , SPF_data_var_t *data ,
                                         char const   *src , int is_mod ) 
{ 
  char const   *token ;
  char const   *p ;
  char c ;
  int val ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;
  SPF_errcode_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  SPF_errcode_t tmp___6 ;
  SPF_errcode_t tmp___7 ;

  {
  {
#line 280
  memset((void *)data, 0, sizeof(SPF_data_var_t ));
#line 282
  p = src;
#line 285
  c = (char )*p;
#line 286
  tmp___0 = __ctype_b_loc();
  }
#line 286
  if ((int const   )*(*tmp___0 + (int )((unsigned char )c)) & 256) {
    {
#line 288
    data->url_encode = (unsigned short)1;
#line 289
    tmp = tolower((int )c);
#line 289
    c = (char )tmp;
    }
  } else {
#line 292
    data->url_encode = (unsigned short)0;
  }
  {
#line 302
  if ((int )c == 108) {
#line 302
    goto case_108;
  }
#line 306
  if ((int )c == 115) {
#line 306
    goto case_115;
  }
#line 310
  if ((int )c == 111) {
#line 310
    goto case_111;
  }
#line 314
  if ((int )c == 100) {
#line 314
    goto case_100;
  }
#line 318
  if ((int )c == 105) {
#line 318
    goto case_105;
  }
#line 322
  if ((int )c == 99) {
#line 322
    goto case_99;
  }
#line 327
  if ((int )c == 116) {
#line 327
    goto case_116;
  }
#line 332
  if ((int )c == 112) {
#line 332
    goto case_112;
  }
#line 336
  if ((int )c == 118) {
#line 336
    goto case_118;
  }
#line 340
  if ((int )c == 104) {
#line 340
    goto case_104;
  }
#line 344
  if ((int )c == 114) {
#line 344
    goto case_114;
  }
#line 349
  goto switch_default;
  case_108: /* CIL Label */ 
#line 303
  data->parm_type = (unsigned char)0;
#line 304
  goto switch_break;
  case_115: /* CIL Label */ 
#line 307
  data->parm_type = (unsigned char)1;
#line 308
  goto switch_break;
  case_111: /* CIL Label */ 
#line 311
  data->parm_type = (unsigned char)2;
#line 312
  goto switch_break;
  case_100: /* CIL Label */ 
#line 315
  data->parm_type = (unsigned char)3;
#line 316
  goto switch_break;
  case_105: /* CIL Label */ 
#line 319
  data->parm_type = (unsigned char)4;
#line 320
  goto switch_break;
  case_99: /* CIL Label */ 
#line 323
  if (! is_mod) {
    {
#line 323
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 323
    return (tmp___1);
  }
#line 324
  data->parm_type = (unsigned char)5;
#line 325
  goto switch_break;
  case_116: /* CIL Label */ 
#line 328
  if (! is_mod) {
    {
#line 328
    tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 328
    return (tmp___2);
  }
#line 329
  data->parm_type = (unsigned char)6;
#line 330
  goto switch_break;
  case_112: /* CIL Label */ 
#line 333
  data->parm_type = (unsigned char)7;
#line 334
  goto switch_break;
  case_118: /* CIL Label */ 
#line 337
  data->parm_type = (unsigned char)8;
#line 338
  goto switch_break;
  case_104: /* CIL Label */ 
#line 341
  data->parm_type = (unsigned char)9;
#line 342
  goto switch_break;
  case_114: /* CIL Label */ 
#line 345
  if (! is_mod) {
    {
#line 345
    tmp___3 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 345
    return (tmp___3);
  }
#line 346
  data->parm_type = (unsigned char)10;
#line 347
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 350
  tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                       p, "Unknown variable \'%c\'", (int )c);
  }
#line 350
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
#line 354
  p ++;
#line 355
  token = p;
#line 358
  val = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 359
    tmp___5 = __ctype_b_loc();
    }
#line 359
    if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*p)) & 2048)) {
#line 359
      goto while_break;
    }
#line 361
    val *= 10;
#line 362
    val += (int )((int const   )*p - 48);
#line 363
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (val > 128) {
    {
#line 366
    tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                         token, "Subdomain truncation depth too large");
    }
#line 366
    return (tmp___6);
  } else
#line 365
  if (val <= 0) {
#line 365
    if ((unsigned long )p != (unsigned long )token) {
      {
#line 366
      tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                           token, "Subdomain truncation depth too large");
      }
#line 366
      return (tmp___6);
    }
  }
#line 369
  data->num_rhs = (unsigned char )val;
#line 370
  token = p;
#line 373
  if ((int const   )*p == 114) {
#line 375
    data->rev = (unsigned short)1;
#line 376
    p ++;
  } else {
#line 379
    data->rev = (unsigned short)0;
  }
#line 380
  token = p;
#line 384
  data->delim_dot = (unsigned short)0;
#line 385
  data->delim_dash = (unsigned short)0;
#line 386
  data->delim_plus = (unsigned short)0;
#line 387
  data->delim_equal = (unsigned short)0;
#line 388
  data->delim_bar = (unsigned short)0;
#line 389
  data->delim_under = (unsigned short)0;
#line 392
  if ((int const   )*p == 125) {
#line 393
    data->delim_dot = (unsigned short)1;
  }
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! ((int const   )*p != 125)) {
#line 396
      goto while_break___0;
    }
#line 398
    token = p;
    {
#line 401
    if ((int const   )*p == 46) {
#line 401
      goto case_46;
    }
#line 405
    if ((int const   )*p == 45) {
#line 405
      goto case_45;
    }
#line 409
    if ((int const   )*p == 43) {
#line 409
      goto case_43;
    }
#line 413
    if ((int const   )*p == 61) {
#line 413
      goto case_61;
    }
#line 417
    if ((int const   )*p == 124) {
#line 417
      goto case_124;
    }
#line 421
    if ((int const   )*p == 95) {
#line 421
      goto case_95;
    }
#line 425
    goto switch_default___0;
    case_46: /* CIL Label */ 
#line 402
    data->delim_dot = (unsigned short)1;
#line 403
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 406
    data->delim_dash = (unsigned short)1;
#line 407
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 410
    data->delim_plus = (unsigned short)1;
#line 411
    goto switch_break___0;
    case_61: /* CIL Label */ 
#line 414
    data->delim_equal = (unsigned short)1;
#line 415
    goto switch_break___0;
    case_124: /* CIL Label */ 
#line 418
    data->delim_bar = (unsigned short)1;
#line 419
    goto switch_break___0;
    case_95: /* CIL Label */ 
#line 422
    data->delim_under = (unsigned short)1;
#line 423
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 426
    tmp___7 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )14, (char const   *)((void *)0),
                                         p, "Invalid delimiter \'%c\'", (int const   )*p);
    }
#line 426
    return (tmp___7);
    switch_break___0: /* CIL Label */ ;
    }
#line 430
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 432
  p ++;
#line 433
  token = p;
#line 436
  return ((SPF_errcode_t )0);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_macro___2(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                           SPF_data_t *data , size_t *data_used ,
                                           size_t data_avail , char const   *src ,
                                           size_t src_len , SPF_errcode_t big_err ,
                                           int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  size_t len ;
  char *dst ;
  size_t ds_avail ;
  size_t ds_len ;
  SPF_errcode_t tmp ;
  SPF_errcode_t tmp___0 ;
  char *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  char *tmp___3 ;
  SPF_errcode_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  SPF_errcode_t tmp___8 ;
  char *tmp___9 ;
  SPF_errcode_t tmp___10 ;
  SPF_errcode_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  SPF_errcode_t tmp___15 ;
  SPF_errcode_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  SPF_errcode_t tmp___19 ;
  SPF_errcode_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
#line 522
  if (spf_server___1->debug) {
    {
#line 523
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               523, "Parsing macro starting at %s", src);
    }
  }
#line 534
  idx = (size_t )0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 538
    data->ds.parm_type = (unsigned char)12;
#line 538
    data->ds.len = (unsigned char)0;
#line 538
    data->ds.__unused0 = (unsigned char)186;
#line 538
    data->ds.__unused1 = (unsigned char)190;
#line 538
    dst = SPF_data_str(data);
#line 538
    ds_avail = data_avail - *data_used;
#line 538
    ds_len = (size_t )0;
    }
#line 538
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 541
    if (! (idx < src_len)) {
#line 541
      goto while_break___0;
    }
#line 542
    if (spf_server___1->debug > 3) {
      {
#line 543
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 543, "Current data is at %p", data);
      }
    }
    {
#line 546
    len = strcspn(src + idx, " %");
    }
#line 547
    if (len > 0UL) {
#line 549
      if (idx + len > src_len) {
#line 550
        len = src_len - idx;
      }
#line 551
      if (spf_server___1->debug > 3) {
        {
#line 552
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                   554, "Adding string literal (%lu): \'%*.*s\'", len, (int )len,
                   (int )len, src + idx);
        }
      }
      {
#line 556
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 556
        if (ds_len + len > ds_avail) {
          {
#line 556
          tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                           src, "String literal fragment too long (%d chars, %d max)",
                                           ds_len, ds_avail);
          }
#line 556
          return (tmp);
        }
#line 556
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 557
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(src + idx),
             len);
#line 558
      ds_len += len;
#line 559
      dst += len;
#line 560
      idx += len;
      }
    }
#line 568
    if (idx == src_len) {
#line 569
      goto while_break___0;
    }
#line 576
    idx ++;
    {
#line 578
    if ((int const   )*(src + idx) == 37) {
#line 578
      goto case_37;
    }
#line 587
    if ((int const   )*(src + idx) == 95) {
#line 587
      goto case_95;
    }
#line 596
    if ((int const   )*(src + idx) == 45) {
#line 596
      goto case_45;
    }
#line 617
    if ((int const   )*(src + idx) == 123) {
#line 617
      goto case_123;
    }
#line 605
    goto switch_default;
    case_37: /* CIL Label */ 
#line 579
    if (spf_server___1->debug > 3) {
      {
#line 580
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 580, "Adding literal %%");
      }
    }
    {
#line 581
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 581
      if (ds_len + 1UL > ds_avail) {
        {
#line 581
        tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 581
        return (tmp___0);
      }
#line 581
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 582
    tmp___1 = dst;
#line 582
    dst ++;
#line 582
    *tmp___1 = (char )'%';
#line 583
    ds_len ++;
#line 584
    idx ++;
#line 585
    goto switch_break;
    case_95: /* CIL Label */ 
#line 588
    if (spf_server___1->debug > 3) {
      {
#line 589
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 589, "Adding literal space");
      }
    }
    {
#line 590
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 590
      if (ds_len + 1UL > ds_avail) {
        {
#line 590
        tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 590
        return (tmp___2);
      }
#line 590
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 591
    tmp___3 = dst;
#line 591
    dst ++;
#line 591
    *tmp___3 = (char )' ';
#line 592
    ds_len ++;
#line 593
    idx ++;
#line 594
    goto switch_break;
    case_45: /* CIL Label */ 
#line 597
    if (spf_server___1->debug > 3) {
      {
#line 598
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 598, "Adding escaped space");
      }
    }
    {
#line 599
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 599
      if (ds_len + 3UL > ds_avail) {
        {
#line 599
        tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 599
        return (tmp___4);
      }
#line 599
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 600
    tmp___5 = dst;
#line 600
    dst ++;
#line 600
    *tmp___5 = (char )'%';
#line 600
    tmp___6 = dst;
#line 600
    dst ++;
#line 600
    *tmp___6 = (char )'2';
#line 600
    tmp___7 = dst;
#line 600
    dst ++;
#line 600
    *tmp___7 = (char )'0';
#line 601
    ds_len += 3UL;
#line 602
    idx ++;
#line 603
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 606
    if (spf_server___1->debug > 3) {
      {
#line 607
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 608, "Adding illegal %%-follower \'%c\' at %d", (int const   )*(src + idx),
                 idx);
      }
    }
    {
#line 612
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 612
      if (ds_len + 1UL > ds_avail) {
        {
#line 612
        tmp___8 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 612
        return (tmp___8);
      }
#line 612
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 613
    tmp___9 = dst;
#line 613
    dst ++;
#line 613
    *tmp___9 = (char )'%';
#line 614
    ds_len ++;
#line 615
    goto switch_break;
    case_123: /* CIL Label */ 
    {
#line 618
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 618
      if (ds_len > 0UL) {
#line 618
        if (ds_len > 255UL) {
          {
#line 618
          tmp___10 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15,
                                                (char const   *)((void *)0), src,
                                                "String literal too long (%d chars, %d max)",
                                                ds_len, 255);
          }
#line 618
          return (tmp___10);
        }
#line 618
        data->ds.len = (unsigned char )ds_len;
#line 618
        len = sizeof(*data) + ds_len;
        {
#line 618
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 618
          tmp___12 = _align_sz(len);
          }
#line 618
          if (*data_used + tmp___12 > data_avail) {
            {
#line 618
            tmp___11 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                  src, "SPF domainspec too long (%d chars, %d max)",
                                                  *data_used + len, data_avail);
            }
#line 618
            return (tmp___11);
          }
          {
#line 618
          tmp___13 = _align_sz(len);
#line 618
          *data_used += tmp___13;
          }
#line 618
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 618
        data = SPF_data_next(data);
#line 618
        ds_len = (size_t )0;
        }
      }
#line 618
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 619
    if (spf_server___1->debug > 3) {
      {
#line 620
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 620, "Adding macro, data is at %p", data);
      }
    }
    {
#line 623
    idx ++;
#line 624
    err = SPF_c_parse_var___2(spf_response, & data->dv, src + idx, is_mod);
    }
#line 625
    if ((unsigned int )err != 0U) {
#line 626
      return (err);
    }
    {
#line 627
    tmp___14 = strcspn(src + idx, "} ");
#line 627
    idx += tmp___14;
    }
#line 628
    if ((int const   )*(src + idx) == 125) {
#line 629
      idx ++;
    } else
#line 630
    if ((int const   )*(src + idx) == 32) {
      {
#line 631
      tmp___15 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, src,
                                            src + idx, "Unterminated variable?");
      }
#line 631
      return (tmp___15);
    }
    {
#line 637
    len = SPF_data_len(data);
    }
    {
#line 638
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 638
      tmp___17 = _align_sz(len);
      }
#line 638
      if (*data_used + tmp___17 > data_avail) {
        {
#line 638
        tmp___16 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                              src, "SPF domainspec too long (%d chars, %d max)",
                                              *data_used + len, data_avail);
        }
#line 638
        return (tmp___16);
      }
      {
#line 638
      tmp___18 = _align_sz(len);
#line 638
      *data_used += tmp___18;
      }
#line 638
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 639
    data = SPF_data_next(data);
    }
#line 640
    if (spf_server___1->debug > 3) {
      {
#line 641
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 641, "Next data is at %p", data);
      }
    }
    {
#line 643
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 643
      data->ds.parm_type = (unsigned char)12;
#line 643
      data->ds.len = (unsigned char)0;
#line 643
      data->ds.__unused0 = (unsigned char)186;
#line 643
      data->ds.__unused1 = (unsigned char)190;
#line 643
      dst = SPF_data_str(data);
#line 643
      ds_avail = data_avail - *data_used;
#line 643
      ds_len = (size_t )0;
      }
#line 643
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 649
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 649
    if (ds_len > 0UL) {
#line 649
      if (ds_len > 255UL) {
        {
#line 649
        tmp___19 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                              src, "String literal too long (%d chars, %d max)",
                                              ds_len, 255);
        }
#line 649
        return (tmp___19);
      }
#line 649
      data->ds.len = (unsigned char )ds_len;
#line 649
      len = sizeof(*data) + ds_len;
      {
#line 649
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 649
        tmp___21 = _align_sz(len);
        }
#line 649
        if (*data_used + tmp___21 > data_avail) {
          {
#line 649
          tmp___20 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                src, "SPF domainspec too long (%d chars, %d max)",
                                                *data_used + len, data_avail);
          }
#line 649
          return (tmp___20);
        }
        {
#line 649
        tmp___22 = _align_sz(len);
#line 649
        *data_used += tmp___22;
        }
#line 649
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 649
      data = SPF_data_next(data);
#line 649
      ds_len = (size_t )0;
      }
    }
#line 649
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 651
  return ((SPF_errcode_t )0);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_domainspec___2(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                                SPF_data_t *data , size_t *data_used ,
                                                size_t data_avail , char const   *src ,
                                                size_t src_len , SPF_errcode_t big_err ,
                                                SPF_cidr_t cidr_ok , int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  SPF_errcode_t tmp___6 ;

  {
#line 682
  if (spf_server___1->debug) {
#line 683
    if ((unsigned int )cidr_ok == 1U) {
#line 683
      tmp___1 = "optional";
    } else {
#line 683
      if ((unsigned int )cidr_ok == 2U) {
#line 683
        tmp___0 = "only";
      } else {
#line 683
        if ((unsigned int )cidr_ok == 0U) {
#line 683
          tmp = "forbidden";
        } else {
#line 683
          tmp = "ERROR!";
        }
#line 683
        tmp___0 = tmp;
      }
#line 683
      tmp___1 = tmp___0;
    }
    {
#line 683
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               689, "Parsing domainspec starting at %s, cidr is %s", src, tmp___1);
    }
  }
#line 694
  if ((unsigned int )cidr_ok == 1U) {
#line 694
    goto _L___0;
  } else
#line 694
  if ((unsigned int )cidr_ok == 2U) {
    _L___0: /* CIL Label */ 
    {
#line 695
    err = SPF_c_parse_cidr___2(spf_response, & data->dc, src, & src_len);
    }
#line 696
    if ((unsigned int )err != 0U) {
#line 697
      return (err);
    }
#line 698
    if ((int )data->dc.ipv4 != 0) {
#line 698
      goto _L;
    } else
#line 698
    if ((int )data->dc.ipv6 != 0) {
      _L: /* CIL Label */ 
      {
#line 699
      len = SPF_data_len(data);
      }
      {
#line 700
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 700
        tmp___3 = _align_sz(len);
        }
#line 700
        if (*data_used + tmp___3 > data_avail) {
          {
#line 700
          tmp___2 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                               src, "SPF domainspec too long (%d chars, %d max)",
                                               *data_used + len, data_avail);
          }
#line 700
          return (tmp___2);
        }
        {
#line 700
        tmp___4 = _align_sz(len);
#line 700
        *data_used += tmp___4;
        }
#line 700
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 701
      data = SPF_data_next(data);
      }
    }
#line 704
    if ((unsigned int )cidr_ok == 2U) {
#line 704
      if (src_len > 0UL) {
        {
#line 708
        tmp___5 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                             src, "Invalid CIDR after mechanism");
        }
#line 708
        return (tmp___5);
      }
    }
  }
  {
#line 715
  tmp___6 = SPF_c_parse_macro___2(spf_server___1, spf_response, data, data_used, data_avail,
                                  src, src_len, big_err, is_mod);
  }
#line 715
  return (tmp___6);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip4___2(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  SPF_errcode_t err ;
  unsigned char mask ;
  struct in_addr *addr ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 739
  start ++;
#line 740
  len = strcspn(start, " ");
#line 741
  end = start + len;
#line 742
  p = end - 1;
#line 744
  mask = (unsigned char)0;
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 745
    tmp = __ctype_b_loc();
    }
#line 745
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 745
      goto while_break;
    }
#line 746
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 747
    if ((int const   )*p == 47) {
      {
#line 748
      err = SPF_c_parse_cidr_ip4___2(spf_response, & mask, p);
      }
#line 749
      if (err) {
#line 750
        return (err);
      }
#line 751
      end = p;
    }
  }
#line 753
  mech->mech_len = (unsigned short )mask;
#line 755
  len = (size_t )(end - start);
#line 756
  if (len > sizeof(buf) - 1UL) {
#line 757
    return ((SPF_errcode_t )19);
  }
  {
#line 759
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 760
  buf[len] = (char )'\000';
#line 761
  addr = SPF_mech_ip4_data(mech);
#line 762
  tmp___0 = inet_pton(2, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
#line 762
  err = (SPF_errcode_t )tmp___0;
  }
#line 763
  if ((unsigned int )err <= 0U) {
    {
#line 764
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )19, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 764
    return (tmp___1);
  }
#line 767
  return ((SPF_errcode_t )0);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip6___2(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  int err ;
  unsigned char mask ;
  struct in6_addr *addr ;
  unsigned short const   **tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 788
  start ++;
#line 789
  len = strcspn(start, " ");
#line 790
  end = start + len;
#line 791
  p = end - 1;
#line 793
  mask = (unsigned char)0;
  }
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 794
    tmp = __ctype_b_loc();
    }
#line 794
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 794
      goto while_break;
    }
#line 795
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 796
    if ((int const   )*p == 47) {
      {
#line 797
      tmp___0 = SPF_c_parse_cidr_ip6___2(spf_response, & mask, p);
#line 797
      err = (int )tmp___0;
      }
#line 798
      if (err) {
#line 799
        return ((SPF_errcode_t )err);
      }
#line 800
      end = p;
    }
  }
#line 802
  mech->mech_len = (unsigned short )mask;
#line 804
  len = (size_t )(end - start);
#line 805
  if (len > sizeof(buf) - 1UL) {
#line 806
    return ((SPF_errcode_t )20);
  }
  {
#line 808
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 809
  buf[len] = (char )'\000';
#line 810
  addr = SPF_mech_ip6_data(mech);
#line 811
  err = inet_pton(10, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
  }
#line 812
  if (err <= 0) {
    {
#line 813
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )20, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 813
    return (tmp___1);
  }
#line 816
  return ((SPF_errcode_t )0);
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mech_add___2)(SPF_server_t *spf_server___1 ,
                                                                                   SPF_record_t *spf_record ,
                                                                                   SPF_response_t *spf_response ,
                                                                                   SPF_mechtype_t const   *mechtype ,
                                                                                   int prefix ,
                                                                                   char const   **mech_value ) 
{ 
  union __anonunion_u_60___2 u ;
  SPF_mech_t *spf_mechanism ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  SPF_errcode_t tmp ;
  int tmp___0 ;

  {
  {
#line 834
  spf_mechanism = (SPF_mech_t *)(u.buf);
#line 842
  memset((void *)(u.buf), 'B', sizeof(u.buf));
#line 843
  memset((void *)spf_mechanism, 0, sizeof(SPF_mech_t ));
  }
#line 845
  if (spf_server___1->debug) {
    {
#line 846
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               847, "SPF_c_mech_add: type=%d, value=%s", (int const   )mechtype->mech_type,
               *mech_value);
    }
  }
#line 849
  spf_mechanism->prefix_type = (unsigned char )prefix;
#line 850
  spf_mechanism->mech_type = (unsigned char )mechtype->mech_type;
#line 851
  spf_mechanism->mech_len = (unsigned short)0;
#line 853
  len = sizeof(SPF_mech_t );
#line 855
  if (spf_record->mech_len + len > 511UL) {
#line 856
    return ((SPF_errcode_t )16);
  }
  {
#line 858
  data = SPF_mech_data(spf_mechanism);
#line 859
  data_len = (size_t )0;
#line 861
  src_len = strcspn(*mech_value, " ");
  }
  {
#line 865
  if ((int const   )mechtype->mech_type == 5) {
#line 865
    goto case_5;
  }
#line 878
  if ((int const   )mechtype->mech_type == 6) {
#line 878
    goto case_6;
  }
#line 891
  goto switch_default;
  case_5: /* CIL Label */ 
#line 866
  if ((int const   )*(*mech_value) == 58) {
    {
#line 867
    err = SPF_c_parse_ip4___2(spf_response, spf_mechanism, *mech_value);
#line 868
    data_len = sizeof(struct in_addr );
    }
  } else {
    {
#line 871
    err = (SPF_errcode_t )9;
#line 872
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 876
  goto switch_break;
  case_6: /* CIL Label */ 
#line 879
  if ((int const   )*(*mech_value) == 58) {
    {
#line 880
    err = SPF_c_parse_ip6___2(spf_response, spf_mechanism, *mech_value);
#line 881
    data_len = sizeof(struct in6_addr );
    }
  } else {
    {
#line 884
    err = (SPF_errcode_t )9;
#line 885
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 889
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 892
  if ((int const   )*(*mech_value) == 58) {
#line 892
    goto _L___0;
  } else
#line 892
  if ((int const   )*(*mech_value) == 61) {
    _L___0: /* CIL Label */ 
#line 893
    if ((unsigned int const   )mechtype->has_domainspec == 0U) {
      {
#line 894
      err = (SPF_errcode_t )7;
#line 895
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a value.");
      }
    } else {
      {
#line 900
      (*mech_value) ++;
#line 900
      src_len --;
#line 901
      err = SPF_c_parse_domainspec___2(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )mechtype->has_cidr, 0);
      }
    }
  } else
#line 909
  if ((int const   )*(*mech_value) == 47) {
#line 910
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 911
      err = (SPF_errcode_t )9;
#line 912
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else
#line 916
    if ((unsigned int const   )mechtype->has_cidr == 0U) {
      {
#line 917
      err = (SPF_errcode_t )8;
#line 918
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a CIDR.");
      }
    } else {
      {
#line 923
      err = SPF_c_parse_domainspec___2(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )2, 0);
      }
    }
  } else
#line 931
  if ((int const   )*(*mech_value) == 32) {
#line 931
    goto _L;
  } else
#line 931
  if ((int const   )*(*mech_value) == 0) {
    _L: /* CIL Label */ 
#line 932
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 933
      err = (SPF_errcode_t )9;
#line 934
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else {
#line 939
      err = (SPF_errcode_t )0;
    }
  } else {
    {
#line 943
    err = (SPF_errcode_t )3;
#line 944
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Unknown character \'%c\' after mechanism.", (int const   )*(*mech_value));
    }
  }
#line 951
  spf_mechanism->mech_len = (unsigned short )data_len;
#line 952
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 955
  len += data_len;
#line 958
  if ((unsigned int )err == 0U) {
#line 959
    if (mechtype->is_dns_mech) {
#line 960
      spf_record->num_dns_mech = (unsigned char )((int )spf_record->num_dns_mech + 1);
    }
    {
#line 961
    tmp___0 = SPF_c_ensure_capacity___2((void **)(& spf_record->mech_first), & spf_record->mech_size,
                                        spf_record->mech_len + len);
    }
#line 961
    if (tmp___0 < 0) {
      {
#line 964
      tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                       (char const   *)((void *)0), "Failed to allocate memory for mechanism");
      }
#line 964
      return (tmp);
    }
    {
#line 968
    memcpy((void */* __restrict  */)((char *)spf_record->mech_first + spf_record->mech_len),
           (void const   */* __restrict  */)spf_mechanism, len);
#line 971
    spf_record->mech_len += len;
#line 972
    spf_record->num_mech = (unsigned char )((int )spf_record->num_mech + 1);
    }
  }
#line 975
  *mech_value += src_len;
#line 977
  return (err);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mod_add___2)(SPF_server_t *spf_server___1 ,
                                                                                  SPF_record_t *spf_record ,
                                                                                  SPF_response_t *spf_response ,
                                                                                  char const   *mod_name ,
                                                                                  size_t name_len ,
                                                                                  char const   **mod_value ) 
{ 
  union __anonunion_u_61___2 u ;
  SPF_mod_t *spf_modifier ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  char *tmp ;
  SPF_errcode_t tmp___0 ;
  int tmp___1 ;

  {
#line 992
  spf_modifier = (SPF_mod_t *)(u.buf);
#line 1000
  if (spf_server___1->debug) {
    {
#line 1001
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               1002, "Adding modifier name=%lu@%s, value=%s", name_len, mod_name,
               *mod_value);
    }
  }
  {
#line 1004
  memset((void *)(u.buf), 'A', sizeof(u.buf));
#line 1005
  memset((void *)spf_modifier, 0, sizeof(SPF_mod_t ));
  }
#line 1007
  if (name_len > 511UL) {
#line 1008
    return ((SPF_errcode_t )17);
  }
  {
#line 1010
  spf_modifier->name_len = (unsigned short )name_len;
#line 1011
  spf_modifier->data_len = (unsigned short)0;
#line 1014
  len = _align_sz(sizeof(SPF_mod_t ) + name_len);
  }
#line 1016
  if (spf_record->mod_len + len > 511UL) {
#line 1017
    return ((SPF_errcode_t )17);
  }
  {
#line 1019
  tmp = SPF_mod_name(spf_modifier);
#line 1019
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)mod_name,
         name_len);
#line 1021
  data = SPF_mod_data(spf_modifier);
#line 1022
  data_len = (size_t )0;
#line 1024
  src_len = strcspn(*mod_value, " ");
#line 1026
  err = SPF_c_parse_macro___2(spf_server___1, spf_response, data, & data_len, (size_t )511,
                              *mod_value, src_len, (SPF_errcode_t )17, 1);
#line 1032
  spf_modifier->data_len = (unsigned short )data_len;
#line 1033
  len += data_len;
  }
#line 1036
  if ((unsigned int )err == 0U) {
    {
#line 1037
    tmp___1 = SPF_c_ensure_capacity___2((void **)(& spf_record->mod_first), & spf_record->mod_size,
                                        spf_record->mod_len + len);
    }
#line 1037
    if (tmp___1 < 0) {
      {
#line 1040
      tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                           (char const   *)((void *)0), "Failed to allocate memory for modifier");
      }
#line 1040
      return (tmp___0);
    }
    {
#line 1044
    memcpy((void */* __restrict  */)((char *)spf_record->mod_first + spf_record->mod_len),
           (void const   */* __restrict  */)spf_modifier, len);
#line 1047
    spf_record->mod_len += len;
#line 1048
    spf_record->num_mod = (unsigned char )((int )spf_record->num_mod + 1);
    }
  }
#line 1051
  return (err);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static void SPF_record_lint___2(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                SPF_record_t *spf_record ) 
{ 
  SPF_data_t *d ;
  SPF_data_t *data_end ;
  char *s ;
  char *s_end ;
  int found_non_ip ;
  int found_valid_tld ;
  SPF_mech_t *mech ;
  SPF_data_t *data ;
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1075
  mech = spf_record->mech_first;
#line 1076
  i = 0;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (i < (int )spf_record->num_mech)) {
#line 1076
      goto while_break;
    }
#line 1081
    if ((int )mech->mech_type == 8) {
#line 1081
      goto _L;
    } else
#line 1081
    if ((int )mech->mech_type == 9) {
      _L: /* CIL Label */ 
#line 1081
      if (i != (int )spf_record->num_mech - 1) {
        {
#line 1085
        SPF_response_add_warn(spf_response, (SPF_errcode_t )29, "Mechanisms found after the \"all:\" mechanism will be ignored.");
        }
      }
    }
#line 1098
    if ((int )mech->mech_type == 5) {
#line 1100
      goto __Cont;
    } else
#line 1098
    if ((int )mech->mech_type == 6) {
#line 1100
      goto __Cont;
    }
    {
#line 1102
    data = SPF_mech_data(mech);
#line 1103
    data_end = SPF_mech_end_data(mech);
    }
#line 1104
    if ((unsigned long )data == (unsigned long )data_end) {
#line 1105
      goto __Cont;
    }
#line 1107
    if ((int )data->dc.parm_type == 11) {
      {
#line 1109
      data = SPF_data_next(data);
      }
#line 1110
      if ((unsigned long )data == (unsigned long )data_end) {
#line 1111
        goto __Cont;
      }
    }
#line 1115
    found_valid_tld = 0;
#line 1116
    found_non_ip = 0;
#line 1118
    d = data;
    {
#line 1118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1118
      if (! ((unsigned long )d < (unsigned long )data_end)) {
#line 1118
        goto while_break___0;
      }
      {
#line 1122
      if ((int )d->dv.parm_type == 11) {
#line 1122
        goto case_11;
      }
#line 1128
      if ((int )d->dv.parm_type == 0) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 5) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 4) {
#line 1128
        goto case_0;
      }
#line 1132
      if ((int )d->dv.parm_type == 12) {
#line 1132
        goto case_12;
      }
#line 1148
      goto switch_default;
      case_11: /* CIL Label */ 
      {
#line 1123
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1123, "%s", "Multiple CIDR parameters found");
      }
#line 1124
      goto switch_break;
      case_0: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 1129
      found_valid_tld = 0;
#line 1130
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 1133
      found_valid_tld = 0;
#line 1135
      s = SPF_data_str(d);
#line 1136
      s_end = s + (int )d->ds.len;
      }
      {
#line 1137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1137
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 1137
          goto while_break___1;
        }
        {
#line 1138
        tmp = __ctype_b_loc();
        }
#line 1138
        if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 2048)) {
#line 1138
          if ((int )*s != 46) {
#line 1138
            if ((int )*s != 58) {
#line 1139
              found_non_ip = 1;
            }
          }
        }
#line 1141
        if ((int )*s == 46) {
#line 1142
          found_valid_tld = 1;
        } else {
          {
#line 1143
          tmp___0 = __ctype_b_loc();
          }
#line 1143
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 1024)) {
#line 1144
            found_valid_tld = 0;
          }
        }
#line 1137
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1146
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1149
      found_non_ip = 1;
#line 1150
      found_valid_tld = 1;
#line 1152
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1118
      d = SPF_data_next(d);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1156
    if (! found_valid_tld) {
#line 1156
      goto _L___0;
    } else
#line 1156
    if (! found_non_ip) {
      _L___0: /* CIL Label */ 
#line 1157
      if (! found_non_ip) {
        {
#line 1158
        SPF_response_add_warn(spf_response, (SPF_errcode_t )27, "Invalid hostname (an IP address?)");
        }
      } else
#line 1160
      if (! found_valid_tld) {
        {
#line 1161
        SPF_response_add_warn(spf_response, (SPF_errcode_t )28, "Hostname has a missing or invalid TLD");
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 1076
    i ++;
#line 1076
    mech = SPF_mech_next(mech);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1168
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c"
static SPF_errcode_t SPF_record_find_mod_data___0(SPF_record_t *spf_record , char const   *mod_name ,
                                                  SPF_data_t **datap , size_t *datalenp ) 
{ 
  SPF_mod_t *mod ;
  size_t name_len ;
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 89
  name_len = strlen(mod_name);
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 94, "%s", "spf_record is NULL");
      }
    }
#line 94
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if ((unsigned long )mod_name == (unsigned long )((void *)0)) {
      {
#line 95
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 95, "%s", "mod_name is NULL");
      }
    }
#line 95
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )datap == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 96, "%s", "datap is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 97
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 97
    if ((unsigned long )datalenp == (unsigned long )((void *)0)) {
      {
#line 97
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 97, "%s", "datalenp is NULL");
      }
    }
#line 97
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 103
  mod = spf_record->mod_first;
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 104
    if (! (i < (int )spf_record->num_mod)) {
#line 104
      goto while_break___3;
    }
#line 105
    if (name_len == (size_t )mod->name_len) {
      {
#line 105
      tmp = SPF_mod_name(mod);
#line 105
      tmp___0 = strncasecmp((char const   *)tmp, mod_name, name_len);
      }
#line 105
      if (tmp___0 == 0) {
        {
#line 108
        *datap = SPF_mod_data(mod);
#line 109
        *datalenp = (size_t )mod->data_len;
        }
#line 111
        return ((SPF_errcode_t )0);
      }
    }
    {
#line 114
    mod = SPF_mod_next(mod);
#line 104
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 117
  return ((SPF_errcode_t )24);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static struct res_sym  const  ns_sects___2[4]  = {      {0, (char *)"QUESTION", (char *)"Question"}, 
        {1, (char *)"ANSWER", (char *)"Answer"}, 
        {2, (char *)"AUTHORITY", (char *)"Authority"}, 
        {3, (char *)"ADDITIONAL", (char *)"Additional"}};
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static int const   num_ns_sect___2  =    (int const   )(sizeof(ns_sects___2) / sizeof(ns_sects___2[0]));
#line 89 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_once_t res_state_control___2  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_key_t res_state_key___2  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_thread_term___2(void *arg ) 
{ 


  {
  {
#line 98
  __res_nclose((struct __res_state *)arg);
#line 100
  free(arg);
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_init_key___2(void) 
{ 


  {
  {
#line 106
  pthread_key_create(& res_state_key___2, & SPF_dns_resolv_thread_term___2);
  }
#line 107
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_debug___2(SPF_dns_server_t *spf_dns_server , ns_rr rr ,
                                     u_char const   *responsebuf , size_t responselen ,
                                     u_char const   *rdata , size_t rdlen ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char name_buf[1025] ;
  int prio ;
  int err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  u_int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 123
  if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 123
    goto case_1;
  }
#line 132
  if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 132
    goto case_28;
  }
#line 141
  if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 141
    goto case_2;
  }
#line 153
  if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 153
    goto case_5;
  }
#line 165
  if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 165
    goto case_15;
  }
#line 182
  if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 182
    goto case_16;
  }
#line 193
  if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 193
    goto case_12;
  }
#line 205
  goto switch_default;
  case_1: /* CIL Label */ 
#line 124
  if (rdlen != 4UL) {
    {
#line 125
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               125, "A: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 127
    tmp = inet_ntop(2, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip4_buf),
                    (socklen_t )sizeof(ip4_buf));
#line 127
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               129, "A: %s", tmp);
    }
  }
#line 130
  goto switch_break;
  case_28: /* CIL Label */ 
#line 133
  if (rdlen != 16UL) {
    {
#line 134
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               134, "AAAA: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 136
    tmp___0 = inet_ntop(10, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip6_buf),
                        (socklen_t )sizeof(ip6_buf));
#line 136
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               138, "AAAA: %s", tmp___0);
    }
  }
#line 139
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 142
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 146
  if (err < 0) {
    {
#line 147
    tmp___1 = __errno_location();
#line 147
    tmp___2 = __errno_location();
#line 147
    tmp___3 = strerror(*tmp___2);
#line 147
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               148, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___3,
               *tmp___1);
    }
  } else {
    {
#line 150
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               150, "NS: %s", name_buf);
    }
  }
#line 151
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 154
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 158
  if (err < 0) {
    {
#line 159
    tmp___4 = __errno_location();
#line 159
    tmp___5 = __errno_location();
#line 159
    tmp___6 = strerror(*tmp___5);
#line 159
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               160, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___6,
               *tmp___4);
    }
  } else {
    {
#line 162
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               162, "CNAME: %s", name_buf);
    }
  }
#line 163
  goto switch_break;
  case_15: /* CIL Label */ 
#line 166
  if (rdlen < 2UL) {
    {
#line 167
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               167, "MX: rdlen too short: %lu", rdlen);
    }
#line 168
    goto switch_break;
  }
  {
#line 170
  tmp___7 = ns_get16(rdata);
#line 170
  prio = (int )tmp___7;
#line 171
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata + 2, name_buf,
                           sizeof(name_buf));
  }
#line 175
  if (err < 0) {
    {
#line 176
    tmp___8 = __errno_location();
#line 176
    tmp___9 = __errno_location();
#line 176
    tmp___10 = strerror(*tmp___9);
#line 176
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               177, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___10,
               *tmp___8);
    }
  } else {
    {
#line 179
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               179, "MX: %d %s", prio, name_buf);
    }
  }
#line 180
  goto switch_break;
  case_16: /* CIL Label */ 
#line 183
  if (rdlen < 1UL) {
    {
#line 184
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               184, "TXT: rdlen too short: %lu", rdlen);
    }
#line 185
    goto switch_break;
  }
  {
#line 189
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             190, "TXT: (%lu) \"%.*s\"", rdlen, (int )rdlen - 1, rdata + 1);
  }
#line 191
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 194
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 198
  if (err < 0) {
    {
#line 199
    tmp___11 = __errno_location();
#line 199
    tmp___12 = __errno_location();
#line 199
    tmp___13 = strerror(*tmp___12);
#line 199
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               200, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___13,
               *tmp___11);
    }
  } else {
    {
#line 202
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               202, "PTR: %s", name_buf);
    }
  }
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 206
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             206, "not parsed:  type: %d", (unsigned int )((ns_type )((int )rr.type)));
  }
#line 207
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static SPF_dns_rr_t *SPF_dns_resolv_lookup___2(SPF_dns_server_t *spf_dns_server ,
                                               char const   *domain , ns_type rr_type ,
                                               int should_cache ) 
{ 
  SPF_dns_rr_t *spfrr ;
  int err ;
  int i ;
  int nrec ;
  int cnt ;
  u_char *responsebuf ;
  size_t responselen ;
  ns_msg ns_handle ;
  ns_rr rr ;
  int ns_sect___0 ;
  char name_buf[1025] ;
  size_t rdlen ;
  u_char const   *rdata ;
  void *res_spec ;
  struct __res_state *res_state___0 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int dns_len ;
  char const   *tmp___2 ;
  SPF_dns_rr_t *tmp___3 ;
  SPF_dns_rr_t *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  SPF_errcode_t tmp___20 ;
  SPF_errcode_t tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  SPF_errcode_t tmp___26 ;
  u_char *src ;
  u_char *dst ;
  size_t len ;
  SPF_errcode_t tmp___27 ;
  SPF_errcode_t tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  SPF_errcode_t tmp___33 ;

  {
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 247
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 247, "%s", "spf_dns_server is NULL");
      }
    }
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  res_spec = pthread_getspecific(res_state_key___2);
  }
#line 252
  if ((unsigned long )res_spec == (unsigned long )((void *)0)) {
    {
#line 253
    tmp = malloc(sizeof(struct __res_state ));
#line 253
    res_state___0 = (struct __res_state *)tmp;
    }
#line 257
    if (! res_state___0) {
      {
#line 258
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 259, "Failed to allocate %lu bytes for res_state", sizeof(struct __res_state ));
      }
    }
    {
#line 260
    memset((void *)res_state___0, 0, sizeof(struct __res_state ));
#line 261
    tmp___0 = __res_ninit(res_state___0);
    }
#line 261
    if (tmp___0 != 0) {
      {
#line 262
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 262, "%s", "Failed to call res_ninit()");
      }
    }
    {
#line 263
    pthread_setspecific(res_state_key___2, (void const   *)((void *)res_state___0));
    }
  } else {
#line 266
    res_state___0 = (struct __res_state *)res_spec;
  }
  {
#line 270
  responselen = (size_t )2048;
#line 271
  tmp___1 = malloc(responselen);
#line 271
  responsebuf = (u_char *)tmp___1;
  }
#line 272
  if (! responsebuf) {
#line 273
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 274
  memset((void *)responsebuf, 0, responselen);
  }
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 297
    dns_len = __res_nquery(res_state___0, domain, 1, (int )rr_type, responsebuf, (int )responselen);
    }
#line 304
    if (dns_len < 0) {
      {
#line 307
      free((void *)responsebuf);
      }
#line 308
      if (spf_dns_server->debug) {
        {
#line 309
        tmp___2 = hstrerror(res_state___0->res_h_errno);
#line 309
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   311, "query failed: err = %d  %s (%d): %s", dns_len, tmp___2, res_state___0->res_h_errno,
                   domain);
        }
      }
#line 312
      if (res_state___0->res_h_errno == 1) {
#line 312
        if ((unsigned long )spf_dns_server->layer_below != (unsigned long )((void *)0)) {
          {
#line 314
          tmp___3 = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
          }
#line 314
          return (tmp___3);
        }
      }
      {
#line 317
      tmp___4 = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, res_state___0->res_h_errno);
      }
#line 317
      return (tmp___4);
    } else
#line 320
    if ((size_t )dns_len > responselen) {
      {
#line 323
      responselen = (size_t )(dns_len + (dns_len >> 1));
#line 332
      tmp___5 = realloc((void *)responsebuf, responselen);
      }
#line 333
      if (! tmp___5) {
        {
#line 334
        free((void *)responsebuf);
        }
#line 335
        return ((SPF_dns_rr_t *)((void *)0));
      }
#line 337
      responsebuf = (u_char *)tmp___5;
    } else {
#line 341
      responselen = (size_t )dns_len;
#line 342
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 351
  spfrr = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, 0);
  }
#line 353
  if (! spfrr) {
    {
#line 354
    free((void *)responsebuf);
    }
#line 355
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 358
  err = ns_initparse((u_char const   *)responsebuf, (int )responselen, & ns_handle);
  }
#line 360
  if (err < 0) {
#line 361
    if (spf_dns_server->debug) {
      {
#line 362
      tmp___6 = __errno_location();
#line 362
      tmp___7 = __errno_location();
#line 362
      tmp___8 = strerror(*tmp___7);
#line 362
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 363, "ns_initparse failed: err = %d  %s (%d)", err, tmp___8, *tmp___6);
      }
    }
    {
#line 364
    free((void *)responsebuf);
#line 367
    spfrr->herrno = 3;
    }
#line 368
    return (spfrr);
  }
#line 372
  if (spf_dns_server->debug > 1) {
    {
#line 373
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               373, "msg id:             %d", (int )ns_handle._id);
#line 374
    tmp___9 = ns_msg_getflag(ns_handle, 0);
#line 374
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               374, "ns_f_qr quest/resp: %d", tmp___9);
#line 375
    tmp___10 = ns_msg_getflag(ns_handle, 1);
#line 375
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               375, "ns_f_opcode:        %d", tmp___10);
#line 376
    tmp___11 = ns_msg_getflag(ns_handle, 2);
#line 376
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               376, "ns_f_aa auth ans:   %d", tmp___11);
#line 377
    tmp___12 = ns_msg_getflag(ns_handle, 3);
#line 377
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               377, "ns_f_tc truncated:  %d", tmp___12);
#line 378
    tmp___13 = ns_msg_getflag(ns_handle, 4);
#line 378
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               378, "ns_f_rd rec desire: %d", tmp___13);
#line 379
    tmp___14 = ns_msg_getflag(ns_handle, 5);
#line 379
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               379, "ns_f_ra rec avail:  %d", tmp___14);
#line 380
    tmp___15 = ns_msg_getflag(ns_handle, 9);
#line 380
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               380, "ns_f_rcode:         %d", tmp___15);
    }
  }
#line 385
  ns_sect___0 = 0;
  {
#line 385
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 385
    if (! (ns_sect___0 < (int )num_ns_sect___2)) {
#line 385
      goto while_break___1;
    }
#line 391
    if (ns_sects___2[ns_sect___0].number != 1) {
#line 391
      if (spf_dns_server->debug <= 1) {
#line 392
        goto __Cont;
      }
    }
#line 394
    nrec = (int )ns_handle._counts[ns_sects___2[ns_sect___0].number];
#line 396
    if (spf_dns_server->debug > 1) {
      {
#line 397
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 397, "%s:  %d", ns_sects___2[ns_sect___0].name, nrec);
      }
    }
#line 399
    spfrr->num_rr = 0;
#line 400
    cnt = 0;
#line 401
    i = 0;
    {
#line 401
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 401
      if (! (i < nrec)) {
#line 401
        goto while_break___2;
      }
      {
#line 402
      err = ns_parserr(& ns_handle, (ns_sect )ns_sects___2[ns_sect___0].number, i,
                       & rr);
      }
#line 403
      if (err < 0) {
#line 404
        if (spf_dns_server->debug > 1) {
          {
#line 405
          tmp___16 = __errno_location();
#line 405
          tmp___17 = __errno_location();
#line 405
          tmp___18 = strerror(*tmp___17);
#line 405
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     406, "ns_parserr failed: err = %d  %s (%d)", err, tmp___18, *tmp___16);
          }
        }
        {
#line 407
        free((void *)responsebuf);
#line 410
        spfrr->herrno = 3;
        }
#line 411
        return (spfrr);
      }
#line 414
      rdlen = (size_t )((int )rr.rdlength);
#line 415
      if (spf_dns_server->debug > 1) {
#line 416
        if ((int )rr.name[0] != 0) {
#line 416
          tmp___19 = (char const   *)(rr.name);
        } else {
#line 416
          tmp___19 = ".";
        }
        {
#line 416
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   418, "name: %s  type: %d  class: %d  ttl: %d  rdlen: %lu", tmp___19,
                   (unsigned int )((ns_type )((int )rr.type)), (unsigned int )((ns_class )((int )rr.rr_class)),
                   rr.ttl, rdlen);
        }
      }
#line 420
      if (rdlen <= 0UL) {
#line 421
        goto __Cont___0;
      }
#line 423
      rdata = rr.rdata + 0;
#line 425
      if (spf_dns_server->debug > 1) {
        {
#line 426
        SPF_dns_resolv_debug___2(spf_dns_server, rr, (u_char const   *)responsebuf,
                                 responselen, rdata, rdlen);
        }
      }
#line 430
      if (ns_sects___2[ns_sect___0].number != 1) {
#line 431
        goto __Cont___0;
      }
#line 434
      if ((unsigned int )((ns_type )((int )rr.type)) != (unsigned int )spfrr->rr_type) {
#line 434
        if ((unsigned int )((ns_type )((int )rr.type)) != 5U) {
          {
#line 435
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     436, "unexpected rr type: %d   expected: %d", (unsigned int )((ns_type )((int )rr.type)),
                     (unsigned int )rr_type);
          }
#line 437
          goto __Cont___0;
        }
      }
      {
#line 441
      if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 441
        goto case_1;
      }
#line 458
      if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 458
        goto case_28;
      }
#line 475
      if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 475
        goto case_2;
      }
#line 478
      if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 478
        goto case_5;
      }
#line 482
      if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 482
        goto case_15;
      }
#line 513
      if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 513
        goto case_16;
      }
#line 562
      if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 562
        goto case_12;
      }
#line 588
      goto switch_default;
      case_1: /* CIL Label */ 
#line 442
      if (rdlen != 4UL) {
        {
#line 444
        free((void *)responsebuf);
        }
#line 445
        return (spfrr);
      }
      {
#line 447
      tmp___20 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->a));
      }
#line 447
      if ((unsigned int )tmp___20 != 0U) {
        {
#line 449
        free((void *)responsebuf);
        }
#line 452
        return (spfrr);
      }
      {
#line 454
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->a), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->a));
#line 455
      cnt ++;
      }
#line 456
      goto switch_break;
      case_28: /* CIL Label */ 
#line 459
      if (rdlen != 16UL) {
        {
#line 461
        free((void *)responsebuf);
        }
#line 462
        return (spfrr);
      }
      {
#line 464
      tmp___21 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->aaaa));
      }
#line 464
      if ((unsigned int )tmp___21 != 0U) {
        {
#line 466
        free((void *)responsebuf);
        }
#line 469
        return (spfrr);
      }
      {
#line 471
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->aaaa), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->aaaa));
#line 472
      cnt ++;
      }
#line 473
      goto switch_break;
      case_2: /* CIL Label */ 
#line 476
      goto switch_break;
      case_5: /* CIL Label */ 
#line 480
      goto switch_break;
      case_15: /* CIL Label */ 
#line 483
      if (rdlen < 2UL) {
        {
#line 485
        free((void *)responsebuf);
        }
#line 486
        return (spfrr);
      }
      {
#line 488
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata + 2, name_buf, sizeof(name_buf));
      }
#line 492
      if (err < 0) {
#line 493
        if (spf_dns_server->debug > 1) {
          {
#line 494
          tmp___22 = __errno_location();
#line 494
          tmp___23 = __errno_location();
#line 494
          tmp___24 = strerror(*tmp___23);
#line 494
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     495, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___24,
                     *tmp___22);
          }
        }
        {
#line 496
        free((void *)responsebuf);
        }
#line 499
        return (spfrr);
      }
      {
#line 502
      tmp___25 = strlen((char const   *)(name_buf));
#line 502
      tmp___26 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___25 + 1UL);
      }
#line 502
      if ((unsigned int )tmp___26 != 0U) {
        {
#line 504
        free((void *)responsebuf);
        }
#line 507
        return (spfrr);
      }
      {
#line 509
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->mx), (char const   */* __restrict  */)(name_buf));
#line 510
      cnt ++;
      }
#line 511
      goto switch_break;
      case_16: /* CIL Label */ 
#line 514
      if (rdlen > 1UL) {
        {
#line 520
        tmp___27 = SPF_dns_rr_buf_realloc(spfrr, cnt, rdlen);
        }
#line 520
        if ((unsigned int )tmp___27 != 0U) {
          {
#line 521
          free((void *)responsebuf);
          }
#line 524
          return (spfrr);
        }
#line 527
        dst = (u_char *)((*(spfrr->rr + cnt))->txt);
#line 528
        src = (u_char *)rdata;
#line 529
        len = (size_t )0;
        {
#line 530
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 530
          if (! (rdlen > 0UL)) {
#line 530
            goto while_break___3;
          }
#line 532
          len = (size_t )*src;
#line 533
          src ++;
#line 534
          rdlen --;
#line 538
          if (len > rdlen) {
#line 539
            len = rdlen;
          }
          {
#line 540
          memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src,
                 len);
#line 543
          src += len;
#line 544
          dst += len;
#line 545
          rdlen -= len;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 547
        *dst = (u_char )'\000';
      } else {
        {
#line 550
        tmp___28 = SPF_dns_rr_buf_realloc(spfrr, cnt, (size_t )1);
        }
#line 550
        if ((unsigned int )tmp___28 != 0U) {
          {
#line 551
          free((void *)responsebuf);
          }
#line 554
          return (spfrr);
        }
#line 556
        (*(spfrr->rr + cnt))->txt[0] = (char )'\000';
      }
#line 559
      cnt ++;
#line 560
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 563
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata, name_buf, sizeof(name_buf));
      }
#line 567
      if (err < 0) {
#line 568
        if (spf_dns_server->debug > 1) {
          {
#line 569
          tmp___29 = __errno_location();
#line 569
          tmp___30 = __errno_location();
#line 569
          tmp___31 = strerror(*tmp___30);
#line 569
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     570, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___31,
                     *tmp___29);
          }
        }
        {
#line 571
        free((void *)responsebuf);
        }
#line 574
        return (spfrr);
      }
      {
#line 577
      tmp___32 = strlen((char const   *)(name_buf));
#line 577
      tmp___33 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___32 + 1UL);
      }
#line 577
      if ((unsigned int )tmp___33 != 0U) {
        {
#line 579
        free((void *)responsebuf);
        }
#line 582
        return (spfrr);
      }
      {
#line 584
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->ptr), (char const   */* __restrict  */)(name_buf));
#line 585
      cnt ++;
      }
#line 586
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 589
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 401
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 593
    spfrr->num_rr = cnt;
    __Cont: /* CIL Label */ 
#line 385
    ns_sect___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 596
  if (spfrr->num_rr == 0) {
#line 597
    spfrr->herrno = 4;
  }
  {
#line 599
  free((void *)responsebuf);
  }
#line 600
  return (spfrr);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_free___2(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 607
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 607, "%s", "spf_dns_server is NULL");
      }
    }
#line 607
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  free((void *)spf_dns_server);
  }
#line 614
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c"
static SPF_errcode_t SPF_record_stringify_data___3(SPF_data_t *data , SPF_data_t *data_end ,
                                                   char **p_p , char *p_end , int is_mod ,
                                                   int cidr_ok , int debug ) 
{ 
  char *p ;
  size_t len ;
  SPF_data_t *cidr_data ;
  char *s ;
  char *tmp ;
  char *s_end ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 48
  p = *p_p;
#line 54
  if (debug) {
    {
#line 55
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
               55, " string data: Building");
    }
  }
#line 57
  if (p_end - p <= 0L) {
#line 58
    return ((SPF_errcode_t )10);
  }
#line 60
  cidr_data = (SPF_data_t *)((void *)0);
#line 61
  if ((unsigned long )data < (unsigned long )data_end) {
#line 61
    if ((int )data->dc.parm_type == 11) {
#line 63
      if (debug) {
        {
#line 64
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   64, " string data: Found a CIDR at %p", data);
        }
      }
#line 65
      if (! cidr_ok) {
#line 66
        return ((SPF_errcode_t )10);
      }
      {
#line 68
      cidr_data = data;
#line 69
      data = SPF_data_next(data);
      }
    }
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )data < (unsigned long )data_end)) {
#line 73
      goto while_break;
    }
#line 75
    if (debug) {
      {
#line 76
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 77, " string data: Handling data type %d at %p", (int )data->ds.parm_type,
                 data);
      }
    }
#line 78
    if ((int )data->ds.parm_type == 12) {
      {
#line 80
      tmp = SPF_data_str(data);
#line 80
      s = tmp;
#line 81
      s_end = s + (int )data->ds.len;
      }
#line 82
      if (debug) {
        {
#line 83
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   84, " string data: String is [%d] \'%*.*s\'", (int )data->ds.len,
                   (int )data->ds.len, (int )data->ds.len, s);
        }
      }
#line 86
      if (p_end - (p + (int )data->ds.len) <= 0L) {
#line 87
        return ((SPF_errcode_t )10);
      }
      {
#line 89
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 89
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 89
          goto while_break___0;
        }
#line 90
        if ((int )*s == 32) {
#line 91
          tmp___0 = p;
#line 91
          p ++;
#line 91
          *tmp___0 = (char )'%';
#line 92
          tmp___1 = p;
#line 92
          p ++;
#line 92
          *tmp___1 = (char )'_';
#line 93
          s ++;
        } else
#line 95
        if ((int )*s == 37) {
#line 96
          tmp___2 = p;
#line 96
          p ++;
#line 96
          *tmp___2 = (char )'%';
#line 97
          s ++;
#line 98
          if ((int )*(s + 0) == 50) {
#line 98
            if ((int )*(s + 1) == 48) {
#line 99
              tmp___3 = p;
#line 99
              p ++;
#line 99
              *tmp___3 = (char )'-';
#line 100
              s += 2;
            } else {
#line 103
              tmp___4 = p;
#line 103
              p ++;
#line 103
              *tmp___4 = (char )'%';
            }
          } else {
#line 103
            tmp___4 = p;
#line 103
            p ++;
#line 103
            *tmp___4 = (char )'%';
          }
        } else {
#line 108
          tmp___5 = p;
#line 108
          p ++;
#line 108
          tmp___6 = s;
#line 108
          s ++;
#line 108
          *tmp___5 = *tmp___6;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 112
      if (p_end - p <= 0L) {
#line 113
        return ((SPF_errcode_t )10);
      }
    } else
#line 115
    if ((int )data->dc.parm_type == 11) {
#line 117
      return ((SPF_errcode_t )8);
    } else {
      {
#line 120
      tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%%{");
#line 120
      len = (size_t )tmp___7;
#line 121
      p += len;
      }
#line 122
      if (p_end - p <= 0L) {
#line 122
        return ((SPF_errcode_t )10);
      }
#line 125
      if (p_end - p <= 1L) {
#line 125
        return ((SPF_errcode_t )10);
      }
      {
#line 128
      if ((int )data->dv.parm_type == 0) {
#line 128
        goto case_0;
      }
#line 132
      if ((int )data->dv.parm_type == 1) {
#line 132
        goto case_1;
      }
#line 136
      if ((int )data->dv.parm_type == 2) {
#line 136
        goto case_2;
      }
#line 140
      if ((int )data->dv.parm_type == 3) {
#line 140
        goto case_3;
      }
#line 144
      if ((int )data->dv.parm_type == 4) {
#line 144
        goto case_4;
      }
#line 148
      if ((int )data->dv.parm_type == 5) {
#line 148
        goto case_5;
      }
#line 152
      if ((int )data->dv.parm_type == 6) {
#line 152
        goto case_6;
      }
#line 158
      if ((int )data->dv.parm_type == 7) {
#line 158
        goto case_7;
      }
#line 162
      if ((int )data->dv.parm_type == 8) {
#line 162
        goto case_8;
      }
#line 166
      if ((int )data->dv.parm_type == 9) {
#line 166
        goto case_9;
      }
#line 170
      if ((int )data->dv.parm_type == 10) {
#line 170
        goto case_10;
      }
#line 174
      goto switch_default;
      case_0: /* CIL Label */ 
#line 129
      *p = (char )'l';
#line 130
      goto switch_break;
      case_1: /* CIL Label */ 
#line 133
      *p = (char )'s';
#line 134
      goto switch_break;
      case_2: /* CIL Label */ 
#line 137
      *p = (char )'o';
#line 138
      goto switch_break;
      case_3: /* CIL Label */ 
#line 141
      *p = (char )'d';
#line 142
      goto switch_break;
      case_4: /* CIL Label */ 
#line 145
      *p = (char )'i';
#line 146
      goto switch_break;
      case_5: /* CIL Label */ 
#line 149
      *p = (char )'c';
#line 150
      goto switch_break;
      case_6: /* CIL Label */ 
#line 153
      if (! is_mod) {
#line 154
        return ((SPF_errcode_t )12);
      }
#line 155
      *p = (char )'t';
#line 156
      goto switch_break;
      case_7: /* CIL Label */ 
#line 159
      *p = (char )'p';
#line 160
      goto switch_break;
      case_8: /* CIL Label */ 
#line 163
      *p = (char )'v';
#line 164
      goto switch_break;
      case_9: /* CIL Label */ 
#line 167
      *p = (char )'h';
#line 168
      goto switch_break;
      case_10: /* CIL Label */ 
#line 171
      *p = (char )'r';
#line 172
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 175
      return ((SPF_errcode_t )12);
#line 176
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 178
      if (data->dv.url_encode) {
        {
#line 179
        tmp___8 = toupper((int )*p);
#line 179
        *p = (char )tmp___8;
        }
      }
#line 180
      p ++;
#line 181
      if (p_end - p <= 0L) {
#line 181
        return ((SPF_errcode_t )10);
      }
#line 184
      if (data->dv.num_rhs) {
        {
#line 186
        tmp___9 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%d",
                           (int )data->dv.num_rhs);
#line 186
        len = (size_t )tmp___9;
#line 187
        p += len;
        }
#line 188
        if (p_end - p <= 0L) {
#line 188
          return ((SPF_errcode_t )10);
        }
      }
#line 192
      if (p_end - p <= 8L) {
#line 192
        return ((SPF_errcode_t )10);
      }
#line 193
      if (data->dv.rev) {
#line 194
        tmp___10 = p;
#line 194
        p ++;
#line 194
        *tmp___10 = (char )'r';
      }
#line 196
      if (data->dv.delim_dot) {
#line 196
        if (data->dv.delim_dash) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_plus) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_equal) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_bar) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_under) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        }
      }
#line 205
      if (data->dv.delim_dash) {
#line 206
        tmp___12 = p;
#line 206
        p ++;
#line 206
        *tmp___12 = (char )'-';
      }
#line 207
      if (data->dv.delim_plus) {
#line 208
        tmp___13 = p;
#line 208
        p ++;
#line 208
        *tmp___13 = (char )'+';
      }
#line 209
      if (data->dv.delim_equal) {
#line 210
        tmp___14 = p;
#line 210
        p ++;
#line 210
        *tmp___14 = (char )'=';
      }
#line 211
      if (data->dv.delim_bar) {
#line 212
        tmp___15 = p;
#line 212
        p ++;
#line 212
        *tmp___15 = (char )'|';
      }
#line 213
      if (data->dv.delim_under) {
#line 214
        tmp___16 = p;
#line 214
        p ++;
#line 214
        *tmp___16 = (char )'_';
      }
#line 216
      tmp___17 = p;
#line 216
      p ++;
#line 216
      *tmp___17 = (char )'}';
#line 217
      if (p_end - p <= 0L) {
#line 217
        return ((SPF_errcode_t )10);
      }
    }
    {
#line 73
    data = SPF_data_next(data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (cidr_data) {
#line 224
    if (cidr_data->dc.ipv4) {
      {
#line 226
      tmp___18 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"/%d",
                          (int )cidr_data->dc.ipv4);
#line 226
      len = (size_t )tmp___18;
#line 227
      p += len;
      }
#line 228
      if (p_end - p <= 0L) {
#line 228
        return ((SPF_errcode_t )10);
      }
    }
#line 231
    if (cidr_data->dc.ipv6) {
      {
#line 233
      tmp___19 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"//%d",
                          (int )cidr_data->dc.ipv6);
#line 233
      len = (size_t )tmp___19;
#line 234
      p += len;
      }
#line 235
      if (p_end - p <= 0L) {
#line 235
        return ((SPF_errcode_t )10);
      }
    }
  }
#line 239
  *p_p = p;
#line 240
  return ((SPF_errcode_t )0);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv4___3[8]  = 
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
  {      (char const   )'i',      (char const   )'n',      (char const   )'-',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv6___3[4]  = {      (char const   )'i',      (char const   )'p',      (char const   )'6',      (char const   )'\000'};
#line 95 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_find___3(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                           ns_type rr_type , int exact ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;
  int tmp ;
  size_t domain_len ;
  size_t tmp___0 ;
  size_t zdomain_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 103
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 105
  if (spf_dns_server->debug) {
    {
#line 106
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
               106, "zone: Searching for RR %s (%d)", domain, (unsigned int )rr_type);
    }
  }
#line 110
  if (exact) {
#line 110
    goto _L;
  } else {
    {
#line 110
    tmp___6 = strncmp(domain, "*.", (size_t )2);
    }
#line 110
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
#line 111
      i = 0;
      {
#line 111
      while (1) {
        while_continue: /* CIL Label */ ;
#line 111
        if (! (i < spfhook->num_zone)) {
#line 111
          goto while_break;
        }
#line 112
        if ((unsigned int )(*(spfhook->zone + i))->rr_type == (unsigned int )rr_type) {
          {
#line 112
          tmp = strcasecmp((char const   *)(*(spfhook->zone + i))->domain, domain);
          }
#line 112
          if (tmp == 0) {
#line 114
            return (*(spfhook->zone + i));
          }
        }
#line 111
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 116
      if (spf_dns_server->debug) {
        {
#line 117
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   117, "zone: Exact not found");
        }
      }
    } else {
      {
#line 121
      tmp___0 = strlen(domain);
#line 121
      domain_len = tmp___0;
      }
#line 125
      if (domain_len) {
#line 125
        if ((int const   )*(domain + (domain_len - 1UL)) == 46) {
#line 126
          domain_len --;
        }
      }
#line 128
      i = 0;
      {
#line 128
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 128
        if (! (i < spfhook->num_zone)) {
#line 128
          goto while_break___0;
        }
#line 129
        if ((unsigned int )(*(spfhook->zone + i))->rr_type != (unsigned int )rr_type) {
#line 129
          if ((unsigned int )(*(spfhook->zone + i))->rr_type != 255U) {
#line 131
            if (spf_dns_server->debug) {
              {
#line 132
              SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                         133, "zone: Ignoring record rrtype %d", (unsigned int )(*(spfhook->zone + i))->rr_type);
              }
            }
#line 134
            goto __Cont;
          }
        }
        {
#line 137
        tmp___5 = strncmp((char const   *)(*(spfhook->zone + i))->domain, "*.", (size_t )2);
        }
#line 137
        if (tmp___5 == 0) {
          {
#line 138
          tmp___1 = strlen((char const   *)(*(spfhook->zone + i))->domain);
#line 138
          zdomain_len = tmp___1 - 2UL;
          }
#line 139
          if (zdomain_len <= domain_len) {
            {
#line 139
            tmp___2 = strncasecmp((char const   *)((*(spfhook->zone + i))->domain + 2),
                                  domain + (domain_len - zdomain_len), zdomain_len);
            }
#line 139
            if (tmp___2 == 0) {
#line 144
              return (*(spfhook->zone + i));
            }
          }
        } else {
          {
#line 146
          tmp___3 = strncasecmp((char const   *)(*(spfhook->zone + i))->domain, domain,
                                domain_len);
          }
#line 146
          if (tmp___3 == 0) {
            {
#line 146
            tmp___4 = strlen((char const   *)(*(spfhook->zone + i))->domain);
            }
#line 146
            if (tmp___4 == domain_len) {
#line 151
              return (*(spfhook->zone + i));
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 128
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 154
      if (spf_dns_server->debug) {
        {
#line 155
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   155, "zone: Non-exact not found");
        }
      }
    }
  }
#line 158
  return ((SPF_dns_rr_t *)((void *)0));
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_lookup___3(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  SPF_dns_rr_t *spfrr ;
  SPF_dns_rr_t *tmp ;

  {
  {
#line 170
  spfrr = SPF_dns_zone_find___3(spf_dns_server, domain, rr_type, 0);
  }
#line 171
  if (spfrr) {
    {
#line 172
    SPF_dns_rr_dup(& spfrr, spfrr);
    }
#line 173
    return (spfrr);
  }
#line 176
  if (spf_dns_server->layer_below) {
    {
#line 177
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 177
    return (tmp);
  }
  {
#line 181
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
#line 182
  SPF_dns_rr_dup(& spfrr, spfhook->nxdomain);
  }
#line 184
  return (spfrr);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static void SPF_dns_zone_free___3(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 317
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                 317, "%s", "spf_dns_server is NULL");
      }
    }
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 320
  if (spfhook) {
#line 321
    if (spfhook->zone) {
#line 322
      i = 0;
      {
#line 322
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 322
        if (! (i < spfhook->zone_buf_len)) {
#line 322
          goto while_break___0;
        }
#line 323
        if (*(spfhook->zone + i)) {
          {
#line 324
          SPF_dns_rr_free(*(spfhook->zone + i));
          }
        }
#line 322
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 326
      free((void *)spfhook->zone);
      }
    }
#line 328
    if (spfhook->nxdomain) {
      {
#line 329
      SPF_dns_rr_free(spfhook->nxdomain);
      }
    }
    {
#line 330
    free((void *)spfhook);
    }
  }
  {
#line 333
  free((void *)spf_dns_server);
  }
#line 334
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_server_set_rec_dom_ghbn___1)(SPF_server_t *sp ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 70
  tmp = malloc((size_t )64);
#line 70
  sp->rec_dom = (char *)tmp;
  }
#line 71
  if (! sp->rec_dom) {
#line 72
    return ((SPF_errcode_t )1);
  }
  {
#line 77
  tmp___0 = gethostname(sp->rec_dom, (size_t )64);
  }
#line 77
  if (tmp___0 < 0) {
#line 79
    return ((SPF_errcode_t )10);
  }
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static void SPF_server_new_common_pre___1(SPF_server_t *sp , int debug ) 
{ 
  SPF_errcode_t err ;

  {
  {
#line 89
  memset((void *)sp, 0, sizeof(SPF_server_t ));
#line 91
  sp->max_dns_mech = 10;
#line 92
  sp->max_dns_ptr = 10;
#line 93
  sp->max_dns_mx = 10;
#line 94
  sp->debug = debug;
#line 96
  err = SPF_server_set_rec_dom_ghbn___1(sp);
  }
#line 97
  if ((unsigned int )err != 0U) {
    {
#line 98
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               98, "%s", "Failed to set rec_dom using gethostname()");
    }
  }
#line 99
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static void SPF_server_new_common_post___1(SPF_server_t *sp ) 
{ 
  SPF_response_t *spf_response ;
  SPF_errcode_t err ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 107
  spf_response = (SPF_response_t *)((void *)0);
#line 108
  err = SPF_server_set_explanation(sp, "Please%_see%_http://www.openspf.org/Why?id=%{S}&ip=%{C}&receiver=%{R}",
                                   & spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
    {
#line 111
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               111, "Error code %d compiling default explanation", (unsigned int )err);
    }
  }
#line 112
  if (spf_response) {
    {
#line 114
    tmp = SPF_response_messages(spf_response);
    }
#line 114
    if (tmp > 0) {
      {
#line 115
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 115, "%s", "Response errors compiling default explanation");
      }
    }
    {
#line 116
    SPF_response_free(spf_response);
    }
  }
  {
#line 119
  spf_response = (SPF_response_t *)((void *)0);
#line 120
  err = SPF_server_set_localpolicy(sp, "", 0, & spf_response);
  }
#line 121
  if ((unsigned int )err != 0U) {
    {
#line 122
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               122, "Error code %d compiling default whitelist", (unsigned int )err);
    }
  }
#line 123
  if (spf_response) {
    {
#line 125
    tmp___0 = SPF_response_messages(spf_response);
    }
#line 125
    if (tmp___0 > 0) {
      {
#line 126
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 126, "%s", "Response errors compiling default whitelist");
      }
    }
    {
#line 127
    SPF_response_free(spf_response);
    }
  }
#line 129
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static char const   digits___1[11]  = 
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 63 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static char const   digitvalue___1[256]  = 
#line 63
  {      (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )0,      (char const   )1,      (char const   )2,      (char const   )3, 
        (char const   )4,      (char const   )5,      (char const   )6,      (char const   )7, 
        (char const   )8,      (char const   )9,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )13,      (char const   )14,      (char const   )15,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )13,      (char const   )14,      (char const   )15,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1};
#line 84
static int special___1(int ch ) ;
#line 85
static int printable___1(int ch ) ;
#line 86
static int dn_find___1(u_char const   *domain , u_char const   *msg , u_char const   * const  *dnptrs ,
                       u_char const   * const  *lastdnptr ) ;
#line 89
static int encode_bitsring___1(char const   **bp , char const   *end , char **labelp ,
                               char **dst , char const   *eom ) ;
#line 91
static int labellen___1(u_char const   *lp ) ;
#line 92
static int decode_bitstring___1(char const   **cpp , char *dn , char const   *eom ) ;
#line 693 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int special___1(int ch ) 
{ 


  {
  {
#line 704
  if (ch == 36) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 64) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 41) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 40) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 92) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 59) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 46) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 34) {
#line 704
    goto case_36;
  }
#line 706
  goto switch_default;
  case_36: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_34: /* CIL Label */ 
#line 705
  return (1);
  switch_default: /* CIL Label */ 
#line 707
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int printable___1(int ch ) 
{ 
  int tmp ;

  {
#line 720
  if (ch > 32) {
#line 720
    if (ch < 127) {
#line 720
      tmp = 1;
    } else {
#line 720
      tmp = 0;
    }
  } else {
#line 720
    tmp = 0;
  }
#line 720
  return (tmp);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int mklower___1(int ch ) 
{ 


  {
#line 729
  if (ch >= 65) {
#line 729
    if (ch <= 90) {
#line 730
      return (ch + 32);
    }
  }
#line 731
  return (ch);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int dn_find___1(u_char const   *domain , u_char const   *msg , u_char const   * const  *dnptrs ,
                       u_char const   * const  *lastdnptr ) 
{ 
  u_char const   *dn ;
  u_char const   *cp ;
  u_char const   *sp ;
  u_char const   * const  *cpp ;
  u_int n ;
  int tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  int tmp___2 ;
  u_char const   *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  u_char const   *tmp___6 ;
  int *tmp___7 ;

  {
#line 752
  cpp = dnptrs;
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! ((unsigned long )cpp < (unsigned long )lastdnptr)) {
#line 752
      goto while_break;
    }
#line 753
    sp = (u_char const   *)*cpp;
    {
#line 760
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 760
      if ((int const   )*sp != 0) {
#line 760
        if (((int const   )*sp & 192) == 0) {
#line 760
          if (! (sp - msg < 16384L)) {
#line 760
            goto while_break___0;
          }
        } else {
#line 760
          goto while_break___0;
        }
      } else {
#line 760
        goto while_break___0;
      }
#line 762
      dn = domain;
#line 763
      cp = sp;
      {
#line 764
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 764
        tmp___6 = cp;
#line 764
        cp ++;
#line 764
        n = (u_int )*tmp___6;
#line 764
        if (! (n != 0U)) {
#line 764
          goto while_break___1;
        }
        {
#line 769
        if ((n & 192U) == 0U) {
#line 769
          goto case_0;
        }
#line 785
        if ((n & 192U) == 192U) {
#line 785
          goto case_192;
        }
#line 789
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 770
        tmp = labellen___1(cp - 1);
#line 770
        n = (u_int )tmp;
#line 772
        tmp___0 = dn;
#line 772
        dn ++;
        }
#line 772
        if (n != (u_int )*tmp___0) {
#line 773
          goto next;
        }
        {
#line 775
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 775
          if (! (n > 0U)) {
#line 775
            goto while_break___2;
          }
          {
#line 776
          tmp___1 = dn;
#line 776
          dn ++;
#line 776
          tmp___2 = mklower___1((int )*tmp___1);
#line 776
          tmp___3 = cp;
#line 776
          cp ++;
#line 776
          tmp___4 = mklower___1((int )*tmp___3);
          }
#line 776
          if (tmp___2 != tmp___4) {
#line 778
            goto next;
          }
#line 775
          n --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 780
        if ((int const   )*dn == 0) {
#line 780
          if ((int const   )*cp == 0) {
#line 781
            return ((int )(sp - msg));
          }
        }
#line 782
        if (*dn) {
#line 783
          goto while_continue___1;
        }
#line 784
        goto next;
        case_192: /* CIL Label */ 
#line 786
        cp = msg + (((n & 63U) << 8) | (unsigned int )*cp);
#line 787
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 790
        tmp___5 = __errno_location();
#line 790
        *tmp___5 = 90;
        }
#line 791
        return (-1);
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      next: 
#line 795
      sp += (int const   )*sp + 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 752
    cpp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 798
  tmp___7 = __errno_location();
#line 798
  *tmp___7 = 2;
  }
#line 799
  return (-1);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int decode_bitstring___1(char const   **cpp , char *dn , char const   *eom ) 
{ 
  char const   *cp ;
  char *beg ;
  char tc ;
  int b ;
  int blen ;
  int plen ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 805
  cp = *cpp;
#line 806
  beg = dn;
#line 809
  blen = (int )((int const   )*cp & 255);
#line 809
  if (blen == 0) {
#line 810
    blen = 256;
  }
#line 811
  plen = (blen + 3) / 4;
#line 812
  if (blen > 99) {
#line 812
    tmp___0 = 3;
  } else {
#line 812
    if (blen > 9) {
#line 812
      tmp = 2;
    } else {
#line 812
      tmp = 1;
    }
#line 812
    tmp___0 = tmp;
  }
#line 812
  plen = (int )((unsigned long )plen + (sizeof("\\[x/]") + (unsigned long )tmp___0));
#line 813
  if ((unsigned long )(dn + plen) >= (unsigned long )eom) {
#line 814
    return (-1);
  }
  {
#line 816
  cp ++;
#line 817
  tmp___1 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"\\[x");
#line 817
  i = (int )((size_t )tmp___1);
  }
#line 818
  if (i < 0) {
#line 819
    return (-1);
  }
#line 820
  dn += i;
#line 821
  b = blen;
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! (b > 7)) {
#line 821
      goto while_break;
    }
    {
#line 822
    tmp___2 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%02x",
                      (int const   )*cp & 255);
#line 822
    i = (int )((size_t )tmp___2);
    }
#line 823
    if (i < 0) {
#line 824
      return (-1);
    }
#line 825
    dn += i;
#line 821
    b -= 8;
#line 821
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 827
  if (b > 4) {
    {
#line 828
    tmp___3 = cp;
#line 828
    cp ++;
#line 828
    tc = (char )*tmp___3;
#line 829
    tmp___4 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%02x",
                      (int )tc & (255 << (8 - b)));
#line 829
    i = (int )((size_t )tmp___4);
    }
#line 830
    if (i < 0) {
#line 831
      return (-1);
    }
#line 832
    dn += i;
  } else
#line 833
  if (b > 0) {
    {
#line 834
    tmp___5 = cp;
#line 834
    cp ++;
#line 834
    tc = (char )*tmp___5;
#line 835
    tmp___6 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%1x",
                      (((int )tc >> 4) & 15) & (15 << (4 - b)));
#line 835
    i = (int )((size_t )tmp___6);
    }
#line 837
    if (i < 0) {
#line 838
      return (-1);
    }
#line 839
    dn += i;
  }
  {
#line 841
  tmp___7 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"/%d]",
                    blen);
#line 841
  i = (int )((size_t )tmp___7);
  }
#line 842
  if (i < 0) {
#line 843
    return (-1);
  }
#line 844
  dn += i;
#line 846
  *cpp = cp;
#line 847
  return ((int )(dn - beg));
}
}
#line 850 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int encode_bitsring___1(char const   **bp , char const   *end , char **labelp ,
                               char **dst , char const   *eom ) 
{ 
  int afterslash ;
  char const   *cp ;
  char *tp ;
  char c ;
  char const   *beg_blen ;
  char *end_blen ;
  int value ;
  int count ;
  int tbcount ;
  int blen ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  int traillen ;

  {
#line 854
  afterslash = 0;
#line 855
  cp = *bp;
#line 858
  end_blen = (char *)((void *)0);
#line 859
  value = 0;
#line 859
  count = 0;
#line 859
  tbcount = 0;
#line 859
  blen = 0;
#line 861
  end_blen = (char *)((void *)0);
#line 861
  beg_blen = (char const   *)end_blen;
#line 864
  if (end - cp < 2L) {
#line 865
    return (22);
  }
#line 868
  tmp = cp;
#line 868
  cp ++;
#line 868
  if ((int const   )*tmp != 120) {
#line 869
    return (22);
  }
  {
#line 870
  tmp___0 = __ctype_b_loc();
  }
#line 870
  if (! ((int const   )*(*tmp___0 + (int )((int const   )*cp & 255)) & 4096)) {
#line 871
    return (22);
  }
#line 873
  tp = *dst + 1;
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    if ((unsigned long )cp < (unsigned long )end) {
#line 873
      if (! ((unsigned long )tp < (unsigned long )eom)) {
#line 873
        goto while_break;
      }
    } else {
#line 873
      goto while_break;
    }
#line 874
    c = (char )*cp;
    {
#line 875
    if ((int )c == 93) {
#line 875
      goto case_93;
    }
#line 887
    if ((int )c == 47) {
#line 887
      goto case_47;
    }
#line 890
    goto switch_default;
    case_93: /* CIL Label */ 
#line 876
    if (afterslash) {
#line 877
      if ((unsigned long )beg_blen == (unsigned long )((void *)0)) {
#line 878
        return (22);
      }
      {
#line 879
      tmp___1 = strtol((char const   */* __restrict  */)beg_blen, (char **/* __restrict  */)(& end_blen),
                       10);
#line 879
      blen = (int )tmp___1;
      }
#line 880
      if ((int )*end_blen != 93) {
#line 881
        return (22);
      }
    }
#line 883
    if (count) {
#line 884
      tmp___2 = tp;
#line 884
      tp ++;
#line 884
      *tmp___2 = (char )((value << 4) & 255);
    }
#line 885
    cp ++;
#line 886
    goto done;
    case_47: /* CIL Label */ 
#line 888
    afterslash = 1;
#line 889
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 891
    if (afterslash) {
      {
#line 892
      tmp___3 = __ctype_b_loc();
      }
#line 892
      if (! ((int const   )*(*tmp___3 + ((int )c & 255)) & 2048)) {
#line 893
        return (22);
      }
#line 894
      if ((unsigned long )beg_blen == (unsigned long )((void *)0)) {
#line 896
        if ((int )c == 48) {
#line 898
          return (22);
        }
#line 900
        beg_blen = cp;
      }
    } else {
      {
#line 903
      tmp___4 = __ctype_b_loc();
      }
#line 903
      if (! ((int const   )*(*tmp___4 + ((int )c & 255)) & 4096)) {
#line 904
        return (22);
      }
#line 905
      value <<= 4;
#line 906
      value += (int )digitvalue___1[(int )c];
#line 907
      count += 4;
#line 908
      tbcount += 4;
#line 909
      if (tbcount > 256) {
#line 910
        return (22);
      }
#line 911
      if (count == 8) {
#line 912
        tmp___5 = tp;
#line 912
        tp ++;
#line 912
        *tmp___5 = (char )value;
#line 913
        count = 0;
      }
    }
#line 916
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 873
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 920
  if ((unsigned long )cp >= (unsigned long )end) {
#line 921
    return (90);
  } else
#line 920
  if ((unsigned long )tp >= (unsigned long )eom) {
#line 921
    return (90);
  }
#line 931
  if (blen > 0) {
#line 934
    if (((blen + 3) & -4) != tbcount) {
#line 935
      return (22);
    }
#line 936
    traillen = tbcount - blen;
#line 937
    if (((value << (8 - traillen)) & 255) != 0) {
#line 938
      return (22);
    }
  } else {
#line 941
    blen = tbcount;
  }
#line 942
  if (blen == 256) {
#line 943
    blen = 0;
  }
#line 946
  *(*labelp) = (char)65;
#line 947
  *(*dst) = (char )blen;
#line 949
  *bp = cp;
#line 950
  *dst = tp;
#line 952
  return (0);
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int labellen___1(u_char const   *lp ) 
{ 
  int bitlen ;
  u_char l ;

  {
#line 959
  l = (u_char )*lp;
#line 961
  if (((int )l & 192) == 192) {
#line 963
    return (-1);
  }
#line 966
  if (((int )l & 192) == 64) {
#line 967
    if ((int )l == 65) {
#line 968
      bitlen = (int )*(lp + 1);
#line 968
      if (bitlen == 0) {
#line 969
        bitlen = 256;
      }
#line 970
      return ((bitlen + 7) / 8 + 1);
    }
#line 972
    return (-1);
  }
#line 974
  return ((int )l);
}
}
#line 150 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spf_example/spf_example.c"
static void usage___2(void) 
{ 


  {
  {
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:\n\nspf_example [options]\n\nValid data options are:\n    -i <IP address>            The IP address that is sending email\n    -s <email address>         The email address used as the\n                               envelope-from.  If no username (local\n                               part) is given, \'postmaster\' will be\n                               assumed.\n    -r <email address>         [optional] The email address used as\n                               the envelope-to email address, for\n                               secondary-MX checking.\n    -h <domain name>           The domain name given on the SMTP HELO\n                               command.  This is only needed if the\n                               -sender option is not given.\n    -d [debug level]           debug level.\n");
  }
#line 105
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
static SPF_errcode_t SPF_request_prepare___1(SPF_request_t *sr ) 
{ 


  {
#line 230
  if (sr->use_helo) {
#line 231
    sr->cur_dom = (char const   *)sr->helo_dom;
  } else {
#line 233
    sr->cur_dom = (char const   *)sr->env_from_dp;
  }
#line 234
  return ((SPF_errcode_t )0);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
static SPF_errcode_t SPF_request_query_record___1(SPF_request_t *spf_request , SPF_response_t *spf_response ,
                                                  SPF_record_t *spf_record , SPF_errcode_t err ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 246
  if ((unsigned int )err != 0U) {
#line 247
    if (spf_record) {
      {
#line 248
      SPF_record_free(spf_record);
      }
    }
#line 249
    return (err);
  }
  {
#line 252
  tmp___0 = SPF_response_errors(spf_response);
  }
#line 252
  if (tmp___0 > 0) {
    {
#line 253
    tmp = SPF_response_errors(spf_response);
#line 253
    SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
              255, "Warning: %d errors in response, but no error code. Evaluating.",
              tmp);
    }
  }
  {
#line 257
  spf_response->spf_record_exp = spf_record;
#line 258
  err = SPF_record_interpret(spf_record, spf_request, spf_response, 0);
#line 260
  SPF_record_free(spf_record);
  }
#line 262
  return (err);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c"
static SPF_errcode_t SPF_server_get_default_explanation___3(SPF_server_t *spf_server___1 ,
                                                            SPF_request_t *spf_request ,
                                                            SPF_response_t *spf_response ,
                                                            char **bufp , size_t *buflenp ) 
{ 
  SPF_errcode_t err ;
  SPF_macro_t *spf_macro ;
  SPF_data_t *tmp ;
  size_t len ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  spf_macro = spf_server___1->explanation;
#line 56
  if ((unsigned long )spf_macro != (unsigned long )((void *)0)) {
    {
#line 57
    tmp = SPF_macro_data(spf_macro);
#line 57
    err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, tmp, spf_macro->macro_len,
                                 bufp, buflenp);
    }
#line 61
    return (err);
  } else {
#line 64
    len = sizeof("SPF failure: no explanation available") + 1UL;
#line 65
    if (*buflenp < len) {
      {
#line 66
      tmp___1 = realloc((void *)*bufp, len);
#line 66
      tmp___0 = (char *)tmp___1;
      }
#line 67
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 68
        return ((SPF_errcode_t )1);
      }
#line 69
      *bufp = tmp___0;
#line 70
      *buflenp = len;
    }
    {
#line 72
    strcpy((char */* __restrict  */)*bufp, (char const   */* __restrict  */)"SPF failure: no explanation available");
    }
#line 73
    return ((SPF_errcode_t )0);
  }
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
static void setsection___1(ns_msg *msg , ns_sect sect ) ;
#line 197 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
static void setsection___1(ns_msg *msg , ns_sect sect ) 
{ 


  {
#line 199
  msg->_sect = sect;
#line 200
  if ((unsigned int )sect == 4U) {
#line 201
    msg->_rrnum = -1;
#line 202
    msg->_msg_ptr = (u_char const   *)((void *)0);
  } else {
#line 204
    msg->_rrnum = 0;
#line 205
    msg->_msg_ptr = msg->_sections[(int )sect];
  }
#line 207
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_explanation___3(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  char *buf ;
  size_t buflen ;
  void *tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 53
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 53, "%s", "spf_response is NULL");
      }
    }
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  spf_request = spf_response->spf_request;
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 55
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 55, "%s", "spf_request is NULL");
      }
    }
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  spf_server___1 = spf_request->spf_server;
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 57
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 57
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 57, "%s", "spf_server is NULL");
      }
    }
#line 57
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  spf_record = spf_response->spf_record_exp;
  {
#line 60
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 60
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 60
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 60, "%s", "spf_record is NULL");
      }
    }
#line 60
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 62
  if (spf_response->explanation) {
    {
#line 63
    free((void *)spf_response->explanation);
    }
  }
  {
#line 64
  spf_response->explanation = (char *)((void *)0);
#line 66
  buflen = (size_t )321;
#line 67
  tmp = malloc(buflen);
#line 67
  buf = (char *)tmp;
  }
#line 68
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 69
    return ((SPF_errcode_t )1);
  }
  {
#line 70
  memset((void *)buf, '\000', buflen);
#line 72
  err = SPF_request_get_exp(spf_server___1, spf_request, spf_response, spf_record,
                            & buf, & buflen);
  }
#line 74
  if ((unsigned int )err != 0U) {
    {
#line 75
    free((void *)buf);
    }
#line 76
    return (err);
  }
#line 79
  spf_response->explanation = buf;
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_smtp_comment___3(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_errcode_t err ;
  char buf[320] ;
  char const   *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 92
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 92, "%s", "spf_response is NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  spf_request = spf_response->spf_request;
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 94, "%s", "spf_request is NULL");
      }
    }
#line 94
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  spf_server___1 = spf_request->spf_server;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 96, "%s", "spf_server is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  if (spf_response->smtp_comment) {
    {
#line 99
    free((void *)spf_response->smtp_comment);
    }
  }
#line 100
  spf_response->smtp_comment = (char *)((void *)0);
  {
#line 107
  if ((unsigned int )spf_response->result == 5U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 1U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 4U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 3U) {
#line 107
    goto case_5;
  }
#line 129
  goto switch_default;
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 109
  err = SPF_i_set_explanation___3(spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
#line 111
    return (err);
  }
  {
#line 113
  memset((void *)(buf), '\000', sizeof(buf));
#line 114
  tmp = SPF_strreason(spf_response->reason);
#line 114
  snprintf((char */* __restrict  */)(buf), (size_t )320, (char const   */* __restrict  */)"%s : Reason: %s",
           spf_response->explanation, tmp);
#line 117
  buf[319] = (char )'\000';
#line 120
  spf_response->smtp_comment = strdup((char const   *)(buf));
  }
#line 121
  if (! spf_response->smtp_comment) {
#line 122
    return ((SPF_errcode_t )1);
  }
#line 124
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 130
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 133
  return ((SPF_errcode_t )0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_header_comment___3(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char *spf_source ;
  size_t len ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  char *sender_dom ;
  char *p ;
  char *p_end ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 153
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 153, "%s", "spf_response is NULL");
      }
    }
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  spf_request = spf_response->spf_request;
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 155
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 155, "%s", "spf_request is NULL");
      }
    }
#line 155
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 156
  spf_server___1 = spf_request->spf_server;
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 157
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 157, "%s", "spf_server is NULL");
      }
    }
#line 157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 159
  if (spf_response->header_comment) {
    {
#line 160
    free((void *)spf_response->header_comment);
    }
  }
#line 161
  spf_response->header_comment = (char *)((void *)0);
#line 164
  sender_dom = spf_request->env_from_dp;
#line 165
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
#line 166
    sender_dom = spf_request->helo_dom;
  }
#line 168
  if ((unsigned int )spf_response->reason == 3U) {
    {
#line 169
    spf_source = strdup("local policy");
    }
  } else
#line 171
  if ((unsigned int )spf_response->reason == 6U) {
#line 172
    if ((unsigned long )spf_request->rcpt_to_dom == (unsigned long )((void *)0)) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    } else
#line 172
    if ((int )*(spf_request->rcpt_to_dom + 0) == 0) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    }
    {
#line 175
    spf_source = strdup((char const   *)spf_request->rcpt_to_dom);
    }
  } else
#line 177
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
    {
#line 178
    spf_source = strdup("unknown domain");
    }
  } else {
    {
#line 181
    tmp = strlen((char const   *)sender_dom);
#line 181
    len = tmp + sizeof("domain of ");
#line 182
    tmp___0 = malloc(len);
#line 182
    spf_source = (char *)tmp___0;
    }
#line 183
    if (spf_source) {
      {
#line 184
      snprintf((char */* __restrict  */)spf_source, len, (char const   */* __restrict  */)"domain of %s",
               sender_dom);
      }
    }
  }
#line 187
  if ((unsigned long )spf_source == (unsigned long )((void *)0)) {
#line 188
    return ((SPF_errcode_t )10);
  }
#line 190
  ip = (char const   *)((void *)0);
#line 191
  if (spf_request->client_ver == 2) {
    {
#line 192
    ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                   (socklen_t )sizeof(ip4_buf));
    }
  } else
#line 195
  if (spf_request->client_ver == 10) {
    {
#line 196
    ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                   (socklen_t )sizeof(ip6_buf));
    }
  }
#line 199
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 200
    ip = "(unknown ip address)";
  }
  {
#line 202
  tmp___1 = SPF_request_get_rec_dom(spf_request);
#line 202
  tmp___2 = strlen(tmp___1);
#line 202
  tmp___3 = strlen((char const   *)spf_source);
#line 202
  tmp___4 = strlen(ip);
#line 202
  len = ((tmp___2 + tmp___3) + tmp___4) + 80UL;
#line 203
  tmp___5 = malloc(len);
#line 203
  buf = (char *)tmp___5;
  }
#line 204
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 205
    free((void *)spf_source);
    }
#line 206
    return ((SPF_errcode_t )10);
  }
  {
#line 209
  p = buf;
#line 210
  p_end = p + len;
#line 213
  tmp___6 = SPF_request_get_rec_dom(spf_request);
#line 213
  tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s: ",
                     tmp___6);
#line 213
  p += tmp___7;
  }
  {
#line 217
  if ((unsigned int )spf_response->result == 2U) {
#line 217
    goto case_2;
  }
#line 228
  if ((unsigned int )spf_response->result == 3U) {
#line 228
    goto case_3;
  }
#line 233
  if ((unsigned int )spf_response->result == 4U) {
#line 233
    goto case_4;
  }
#line 238
  if ((unsigned int )spf_response->result == 7U) {
#line 238
    goto case_7;
  }
#line 243
  if ((unsigned int )spf_response->result == 1U) {
#line 243
    goto case_1;
  }
#line 247
  if ((unsigned int )spf_response->result == 5U) {
#line 247
    goto case_5;
  }
#line 252
  if ((unsigned int )spf_response->result == 6U) {
#line 252
    goto case_6;
  }
#line 258
  goto switch_default;
  case_2: /* CIL Label */ 
#line 218
  if ((unsigned int )spf_response->reason == 2U) {
    {
#line 219
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"localhost is always allowed.");
    }
  } else
#line 220
  if ((unsigned int )spf_response->reason == 6U) {
    {
#line 221
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"message received from %s which is an MX secondary for %s.",
             ip, spf_source);
    }
  } else {
    {
#line 224
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s designates %s as permitted sender",
             spf_source, ip);
    }
  }
#line 226
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 229
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 231
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 234
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"transitioning %s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 236
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 239
  tmp___8 = SPF_strerror(spf_response->err);
#line 239
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error in processing during lookup of %s: %s",
           spf_source, tmp___8);
  }
#line 241
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 244
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s is neither permitted nor denied by %s",
           ip, spf_source);
  }
#line 246
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 248
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not provide an SPF record",
           spf_source);
  }
#line 250
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 253
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"encountered temporary error during SPF processing of %s",
           spf_source);
  }
#line 255
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 259
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error: unknown SPF result %d encountered while checking %s for %s",
           (unsigned int )spf_response->result, ip, spf_source);
  }
#line 261
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 264
  if (spf_source) {
    {
#line 265
    free((void *)spf_source);
    }
  }
  {
#line 267
  spf_response->header_comment = SPF_sanitize(spf_server___1, buf);
  }
#line 269
  return ((SPF_errcode_t )0);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_received_spf___3(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  size_t buflen ;
  char *buf_value ;
  char *p ;
  char *p_end ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 282
  buflen = (size_t )480;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 287
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 287, "%s", "spf_response is NULL");
      }
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  spf_request = spf_response->spf_request;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 289
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 289, "%s", "spf_request is NULL");
      }
    }
#line 289
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  spf_server___1 = spf_request->spf_server;
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 291
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 291
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 291, "%s", "spf_server is NULL");
      }
    }
#line 291
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 293
  if (spf_response->received_spf) {
    {
#line 294
    free((void *)spf_response->received_spf);
    }
  }
  {
#line 295
  spf_response->received_spf = (char *)((void *)0);
#line 297
  tmp = malloc(buflen);
#line 297
  buf = (char *)tmp;
  }
#line 298
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 299
    return ((SPF_errcode_t )10);
  }
  {
#line 301
  p = buf;
#line 302
  p_end = p + buflen;
#line 306
  tmp___0 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"Received-SPF: ");
#line 306
  p += tmp___0;
#line 307
  buf_value = p;
  }
  {
#line 309
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 310
    tmp___1 = SPF_strresult(spf_response->result);
#line 310
    tmp___2 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s (%s)",
                       tmp___1, spf_response->header_comment);
#line 310
    p += tmp___2;
    }
#line 313
    if (p_end - p <= 0L) {
#line 313
      goto while_break___2;
    }
#line 318
    ip = (char const   *)((void *)0);
#line 319
    if (spf_request->client_ver == 2) {
      {
#line 320
      ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                     (socklen_t )sizeof(ip4_buf));
      }
    } else
#line 323
    if (spf_request->client_ver == 10) {
      {
#line 324
      ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                     (socklen_t )sizeof(ip6_buf));
      }
    }
#line 328
    if ((unsigned long )ip != (unsigned long )((void *)0)) {
      {
#line 329
      tmp___3 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" client-ip=%s;",
                         ip);
#line 329
      p += tmp___3;
      }
#line 330
      if (p_end - p <= 0L) {
#line 330
        goto while_break___2;
      }
    }
#line 335
    if ((unsigned long )spf_request->env_from != (unsigned long )((void *)0)) {
      {
#line 336
      tmp___4 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" envelope-from=%s;",
                         spf_request->env_from);
#line 336
      p += tmp___4;
      }
#line 337
      if (p_end - p <= 0L) {
#line 337
        goto while_break___2;
      }
    }
#line 342
    if ((unsigned long )spf_request->helo_dom != (unsigned long )((void *)0)) {
      {
#line 343
      tmp___5 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" helo=%s;",
                         spf_request->helo_dom);
#line 343
      p += tmp___5;
      }
#line 344
      if (p_end - p <= 0L) {
#line 344
        goto while_break___2;
      }
    }
#line 309
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 366
  spf_response->received_spf = SPF_sanitize(spf_server___1, buf);
#line 367
  spf_response->received_spf_value = buf_value;
  }
#line 369
  return ((SPF_errcode_t )0);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_mech_cidr___3(SPF_request_t *spf_request , SPF_mech_t *mech ) 
{ 
  SPF_data_t *data ;
  SPF_data_t *tmp ;

  {
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if ((unsigned long )mech == (unsigned long )((void *)0)) {
      {
#line 428
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 428, "%s", "mech is NULL");
      }
    }
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  if ((int )mech->mech_type == 6) {
#line 433
    goto case_6;
  }
#line 433
  if ((int )mech->mech_type == 5) {
#line 433
    goto case_6;
  }
#line 438
  if ((int )mech->mech_type == 2) {
#line 438
    goto case_2;
  }
#line 438
  if ((int )mech->mech_type == 1) {
#line 438
    goto case_2;
  }
#line 430
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 434
  return ((int )mech->mech_len);
#line 435
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 439
  data = SPF_mech_data(mech);
#line 441
  tmp = SPF_mech_end_data(mech);
  }
#line 441
  if ((unsigned long )data < (unsigned long )tmp) {
#line 441
    if ((int )data->dc.parm_type == 11) {
#line 444
      if (spf_request->client_ver == 2) {
#line 445
        return ((int )data->dc.ipv4);
      } else
#line 446
      if (spf_request->client_ver == 10) {
#line 447
        return ((int )data->dc.ipv6);
      }
    }
  }
#line 449
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 452
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip4___3(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in_addr ipv4 ) 
{ 
  char src_ip4_buf[16] ;
  char dst_ip4_buf[16] ;
  char mask_ip4_buf[16] ;
  struct in_addr src_ipv4 ;
  int cidr ;
  int mask ;
  uint32_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 471
  if (spf_request->client_ver != 2) {
#line 472
    return (0);
  }
  {
#line 474
  src_ipv4 = spf_request->ipv4;
#line 476
  cidr = SPF_i_mech_cidr___3(spf_request, mech);
  }
#line 477
  if (cidr == 0) {
#line 478
    cidr = 32;
  }
  {
#line 479
  mask = (int )(4294967295U << (32 - cidr));
#line 480
  tmp = htonl((uint32_t )mask);
#line 480
  mask = (int )tmp;
  }
#line 482
  if (spf_server___1->debug) {
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 483
      tmp___0 = inet_ntop(2, (void const   */* __restrict  */)(& src_ipv4.s_addr),
                          (char */* __restrict  */)(src_ip4_buf), (socklen_t )sizeof(src_ip4_buf));
      }
#line 483
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 483
        snprintf((char */* __restrict  */)(src_ip4_buf), sizeof(src_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 483
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 485
      tmp___1 = inet_ntop(2, (void const   */* __restrict  */)(& ipv4.s_addr), (char */* __restrict  */)(dst_ip4_buf),
                          (socklen_t )sizeof(dst_ip4_buf));
      }
#line 485
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 485
        snprintf((char */* __restrict  */)(dst_ip4_buf), sizeof(dst_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 487
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 487
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& mask), (char */* __restrict  */)(mask_ip4_buf),
                          (socklen_t )sizeof(mask_ip4_buf));
      }
#line 487
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
#line 487
        snprintf((char */* __restrict  */)(mask_ip4_buf), sizeof(mask_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 487
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 489
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               491, "ip_match:  %s == %s  (/%d %s):  %d", src_ip4_buf, dst_ip4_buf,
               cidr, mask_ip4_buf, (src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
    }
  }
#line 494
  return ((src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip6___3(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in6_addr ipv6 ) 
{ 
  char src_ip6_buf[46] ;
  char dst_ip6_buf[46] ;
  struct in6_addr src_ipv6 ;
  int cidr ;
  int cidr_save ;
  int mask ;
  int i ;
  int match ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 512
  if (spf_request->client_ver != 10) {
#line 513
    return (0);
  }
  {
#line 515
  src_ipv6 = spf_request->ipv6;
#line 517
  cidr = SPF_i_mech_cidr___3(spf_request, mech);
  }
#line 518
  if (cidr == 0) {
#line 519
    cidr = 128;
  }
#line 520
  cidr_save = cidr;
#line 522
  match = 1;
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if ((long )i < (long )(sizeof(ipv6.__in6_u.__u6_addr8) / sizeof(ipv6.__in6_u.__u6_addr8[0]))) {
#line 523
      if (! match) {
#line 523
        goto while_break;
      }
    } else {
#line 523
      goto while_break;
    }
#line 525
    if (cidr > 8) {
#line 526
      mask = 255;
    } else
#line 527
    if (cidr > 0) {
#line 528
      mask = (255 << (8 - cidr)) & 255;
    } else {
#line 530
      goto while_break;
    }
#line 531
    cidr -= 8;
#line 533
    match = ((int )src_ipv6.__in6_u.__u6_addr8[i] & mask) == ((int )ipv6.__in6_u.__u6_addr8[i] & mask);
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (spf_server___1->debug) {
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 537
      tmp = inet_ntop(10, (void const   */* __restrict  */)(& src_ipv6.__in6_u.__u6_addr8),
                      (char */* __restrict  */)(src_ip6_buf), (socklen_t )sizeof(src_ip6_buf));
      }
#line 537
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 537
        snprintf((char */* __restrict  */)(src_ip6_buf), sizeof(src_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 537
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 539
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 539
      tmp___0 = inet_ntop(10, (void const   */* __restrict  */)(& ipv6.__in6_u.__u6_addr8),
                          (char */* __restrict  */)(dst_ip6_buf), (socklen_t )sizeof(dst_ip6_buf));
      }
#line 539
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 539
        snprintf((char */* __restrict  */)(dst_ip6_buf), sizeof(dst_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 539
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 541
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               542, "ip_match:  %s == %s  (/%d):  %d", src_ip6_buf, dst_ip6_buf, cidr_save,
               match);
    }
  }
#line 545
  return (match);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_domain___3(SPF_server_t *spf_server___1 , char const   *hostname ,
                                  char const   *domain ) 
{ 
  char const   *hp ;
  size_t hlen ;
  size_t dlen ;
  int tmp ;
  int tmp___0 ;

  {
#line 556
  if (spf_server___1->debug) {
    {
#line 557
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               557, "%s ?=? %s", hostname, domain);
    }
  }
  {
#line 559
  hlen = strlen(hostname);
#line 560
  dlen = strlen(domain);
  }
#line 563
  if (dlen > hlen) {
#line 564
    return (0);
  }
#line 567
  if (dlen == hlen) {
    {
#line 568
    tmp = strcasecmp(hostname, domain);
    }
#line 568
    return (tmp == 0);
  }
#line 571
  hp = hostname + (hlen - dlen);
#line 573
  if ((int const   )*(hp - 1) != 46) {
#line 574
    return (0);
  }
  {
#line 576
  tmp___0 = strcasecmp(hp, domain);
  }
#line 576
  return (tmp___0 == 0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_pre___3(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                  ns_type rr_type , int should_cache ) 
{ 
  char const   *tmp ;

  {
#line 51
  if (spf_dns_server->debug) {
    {
#line 52
    tmp = SPF_strrrtype(rr_type);
#line 52
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               54, "DNS[%s] lookup: %s %s (%d)", spf_dns_server->name, domain, tmp,
               (unsigned int )rr_type);
    }
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_post___3(SPF_dns_server_t *spf_dns_server , SPF_dns_rr_t *spfrr ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 61
  if (spf_dns_server->debug) {
    {
#line 66
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               66, "DNS[%s] found record", spf_dns_server->name);
#line 67
    tmp = SPF_strrrtype(spfrr->rr_type);
#line 67
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               69, "    DOMAIN: %s  TYPE: %s (%d)", spfrr->domain, tmp, (unsigned int )spfrr->rr_type);
    }
#line 70
    if (spfrr->source) {
#line 70
      if ((spfrr->source)->name) {
#line 70
        tmp___0 = (spfrr->source)->name;
      } else {
#line 70
        tmp___0 = "(unnamed source)";
      }
#line 70
      tmp___1 = tmp___0;
    } else {
#line 70
      tmp___1 = "(null source)";
    }
    {
#line 70
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               76, "    TTL: %ld  RR found: %d  herrno: %d  source: %s", spfrr->ttl,
               spfrr->num_rr, spfrr->herrno, tmp___1);
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! (i < spfrr->num_rr)) {
#line 77
        goto while_break;
      }
      {
#line 79
      if ((unsigned int )spfrr->rr_type == 1U) {
#line 79
        goto case_1;
      }
#line 85
      if ((unsigned int )spfrr->rr_type == 12U) {
#line 85
        goto case_12;
      }
#line 89
      if ((unsigned int )spfrr->rr_type == 15U) {
#line 89
        goto case_15;
      }
#line 93
      if ((unsigned int )spfrr->rr_type == 16U) {
#line 93
        goto case_16;
      }
#line 97
      if ((unsigned int )spfrr->rr_type == 99U) {
#line 97
        goto case_99;
      }
#line 101
      if ((unsigned int )spfrr->rr_type == 28U) {
#line 101
        goto case_28;
      }
#line 107
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 80
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->a),
                          (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
#line 80
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 82, "    - A: %s", tmp___2);
      }
#line 83
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 86
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 86, "    - PTR: %s", (*(spfrr->rr + i))->ptr);
      }
#line 87
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 90
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 90, "    - MX: %s", (*(spfrr->rr + i))->mx);
      }
#line 91
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 94
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 94, "    - TXT: %s", (*(spfrr->rr + i))->txt);
      }
#line 95
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 98
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 98, "    - SPF: %s", (*(spfrr->rr + i))->txt);
      }
#line 99
      goto switch_break;
      case_28: /* CIL Label */ 
      {
#line 102
      tmp___3 = inet_ntop(10, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->aaaa),
                          (char */* __restrict  */)(ip6_buf), (socklen_t )sizeof(ip6_buf));
#line 102
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 104, "    - AAAA: %s", tmp___3);
      }
#line 105
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 108
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 108, "    - Unknown RR type");
      }
#line 109
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 77
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 113
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_cache_bucket_t *SPF_dns_cache_bucket_find___3(SPF_dns_cache_config_t *spfhook ,
                                                             char const   *domain ,
                                                             ns_type rr_type , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  SPF_dns_rr_t *rr ;
  time_t now ;
  int tmp ;

  {
  {
#line 247
  bucket = *(spfhook->cache + idx);
#line 248
  prev = (SPF_dns_cache_bucket_t *)((void *)0);
#line 249
  time(& now);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
#line 252
    rr = bucket->rr;
#line 254
    if (rr->utc_ttl < now) {
#line 256
      if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 257
        prev->next = bucket->next;
      } else {
#line 259
        *(spfhook->cache + idx) = bucket->next;
      }
#line 261
      if (bucket->rr) {
        {
#line 262
        SPF_dns_rr_free(bucket->rr);
        }
      }
      {
#line 263
      free((void *)bucket);
#line 265
      bucket = prev;
      }
    } else
#line 267
    if (! ((unsigned int )rr->rr_type != (unsigned int )rr_type)) {
      {
#line 270
      tmp = strcmp((char const   *)rr->domain, domain);
      }
#line 270
      if (! (tmp != 0)) {
#line 275
        if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 276
          prev->next = bucket->next;
#line 277
          bucket->next = *(spfhook->cache + idx);
#line 278
          *(spfhook->cache + idx) = bucket;
        }
#line 280
        return (bucket);
      }
    }
#line 283
    prev = bucket;
#line 284
    if ((unsigned long )bucket == (unsigned long )((void *)0)) {
#line 285
      bucket = *(spfhook->cache + idx);
    } else {
#line 287
      bucket = bucket->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return ((SPF_dns_cache_bucket_t *)((void *)0));
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_bucket_add___3(SPF_dns_cache_config_t *spfhook ,
                                                  SPF_dns_rr_t *rr , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  void *tmp ;

  {
  {
#line 300
  tmp = malloc(sizeof(SPF_dns_cache_bucket_t ));
#line 300
  bucket = (SPF_dns_cache_bucket_t *)tmp;
  }
#line 302
  if (! bucket) {
#line 303
    return ((SPF_errcode_t )1);
  }
#line 304
  bucket->next = *(spfhook->cache + idx);
#line 305
  *(spfhook->cache + idx) = bucket;
#line 306
  bucket->rr = rr;
#line 307
  return ((SPF_errcode_t )0);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_rr_fixup___3(SPF_dns_cache_config_t *spfhook ,
                                                SPF_dns_rr_t *cached_rr , char const   *domain ,
                                                ns_type rr_type ) 
{ 
  char *p ;
  char *new_domain ;
  size_t new_len ;
  size_t tmp ;
  void *tmp___0 ;
  time_t tmp___1 ;

  {
#line 322
  if ((unsigned int )cached_rr->rr_type == 255U) {
#line 323
    cached_rr->rr_type = rr_type;
  }
#line 326
  if ((unsigned long )cached_rr->domain == (unsigned long )((void *)0)) {
#line 326
    goto _L;
  } else
#line 326
  if ((int )*(cached_rr->domain + 0) != 0) {
    _L: /* CIL Label */ 
    {
#line 328
    tmp = strlen(domain);
#line 328
    new_len = tmp + 1UL;
    }
#line 330
    if (cached_rr->domain_buf_len < new_len) {
      {
#line 331
      tmp___0 = realloc((void *)cached_rr->domain, new_len);
#line 331
      new_domain = (char *)tmp___0;
      }
#line 332
      if ((unsigned long )new_domain == (unsigned long )((void *)0)) {
#line 333
        return ((SPF_errcode_t )1);
      }
#line 334
      cached_rr->domain = new_domain;
#line 335
      cached_rr->domain_buf_len = new_len;
    }
    {
#line 337
    strcpy((char */* __restrict  */)cached_rr->domain, (char const   */* __restrict  */)domain);
    }
  }
#line 341
  if (cached_rr->ttl < spfhook->min_ttl) {
#line 342
    cached_rr->ttl = spfhook->min_ttl;
  }
#line 344
  if (cached_rr->ttl < spfhook->txt_ttl) {
#line 344
    if ((unsigned int )cached_rr->rr_type == 16U) {
#line 346
      cached_rr->ttl = spfhook->txt_ttl;
    }
  }
#line 348
  if (cached_rr->ttl < spfhook->err_ttl) {
#line 348
    if (cached_rr->herrno != 0) {
#line 350
      cached_rr->ttl = spfhook->err_ttl;
    }
  }
#line 352
  if (cached_rr->ttl < spfhook->rdns_ttl) {
    {
#line 353
    p = strstr((char const   *)cached_rr->domain, ".arpa");
    }
#line 354
    if (p) {
#line 354
      if ((int )*(p + (sizeof(".arpa") - 1UL)) == 0) {
#line 355
        cached_rr->ttl = spfhook->rdns_ttl;
      }
    }
  }
  {
#line 358
  tmp___1 = time((time_t *)((void *)0));
#line 358
  cached_rr->utc_ttl = cached_rr->ttl + tmp___1;
  }
#line 360
  return ((SPF_errcode_t )0);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_rr_t *SPF_dns_cache_lookup___3(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                              ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_rr_t *cached_rr ;
  SPF_dns_rr_t *rr ;
  int idx ;
  SPF_errcode_t tmp ;
  SPF_dns_rr_t *tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;

  {
  {
#line 377
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
#line 381
  idx = crc32str(0U, domain, spfhook->max_hash_len);
#line 382
  idx &= spfhook->cache_size - 1;
#line 384
  pthread_mutex_lock(& spfhook->cache_lock);
#line 386
  bucket = SPF_dns_cache_bucket_find___3(spfhook, domain, rr_type, idx);
  }
#line 387
  if ((unsigned long )bucket != (unsigned long )((void *)0)) {
#line 388
    if ((unsigned long )bucket->rr != (unsigned long )((void *)0)) {
      {
#line 389
      tmp = SPF_dns_rr_dup(& rr, bucket->rr);
      }
#line 389
      if ((unsigned int )tmp == 0U) {
        {
#line 390
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 391
        return (rr);
      } else
#line 393
      if ((unsigned long )rr != (unsigned long )((void *)0)) {
        {
#line 394
        SPF_dns_rr_free(rr);
        }
      }
    }
  }
  {
#line 401
  bucket = (SPF_dns_cache_bucket_t *)((void *)0);
#line 403
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 405
  if (! spf_dns_server->layer_below) {
    {
#line 406
    tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
    }
#line 406
    return (tmp___0);
  }
  {
#line 408
  rr = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
  }
#line 410
  if (spfhook->conserve_cache) {
#line 410
    if (! should_cache) {
#line 411
      return (rr);
    }
  }
  {
#line 413
  pthread_mutex_lock(& spfhook->cache_lock);
#line 415
  tmp___3 = SPF_dns_rr_dup(& cached_rr, rr);
  }
#line 415
  if ((unsigned int )tmp___3 == 0U) {
    {
#line 416
    tmp___2 = SPF_dns_cache_rr_fixup___3(spfhook, cached_rr, domain, rr_type);
    }
#line 416
    if ((unsigned int )tmp___2 == 0U) {
      {
#line 417
      tmp___1 = SPF_dns_cache_bucket_add___3(spfhook, cached_rr, idx);
      }
#line 417
      if ((unsigned int )tmp___1 == 0U) {
        {
#line 418
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 419
        return (rr);
      }
    }
  }
  {
#line 424
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 426
  if (cached_rr) {
    {
#line 427
    SPF_dns_rr_free(cached_rr);
    }
  }
#line 429
  return (rr);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static void SPF_dns_cache_free___3(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  int i ;

  {
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 442
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
                 442, "%s", "spf_dns_server is NULL");
      }
    }
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
  }
#line 445
  if (spfhook) {
    {
#line 446
    pthread_mutex_lock(& spfhook->cache_lock);
    }
#line 448
    if (spfhook->cache) {
#line 449
      i = 0;
      {
#line 449
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 449
        if (! (i < spfhook->cache_size)) {
#line 449
          goto while_break___0;
        }
#line 450
        bucket = *(spfhook->cache + i);
        {
#line 451
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 451
          if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 451
            goto while_break___1;
          }
#line 452
          prev = bucket;
#line 453
          bucket = bucket->next;
#line 456
          if (prev->rr) {
            {
#line 457
            SPF_dns_rr_free(prev->rr);
            }
          }
          {
#line 458
          free((void *)prev);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 449
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 461
      free((void *)spfhook->cache);
#line 462
      spfhook->cache = (SPF_dns_cache_bucket_t **)((void *)0);
      }
    }
    {
#line 465
    pthread_mutex_unlock(& spfhook->cache_lock);
#line 476
    pthread_mutex_destroy(& spfhook->cache_lock);
#line 478
    free((void *)spfhook);
    }
  }
  {
#line 481
  free((void *)spf_dns_server);
  }
#line 482
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
static SPF_dns_test_data_t const   SPF_dns_db___3[175]  = 
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
  {      {"localhost", 1, 0, "127.0.0.1"}, 
        {"example.com", 1, 0, "192.0.2.3"}, 
        {"example.com", 15, 0, "mx.example.org"}, 
        {"example.com", 16, 0, "v=spf1 mx -all"}, 
        {"3.2.0.192.in-addr.arpa", 12, 0, "mx.example.org"}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}, 
        {"noexist.example.com", 1, 1, (char const   *)((void *)0)}, 
        {"mx.example.org", 1, 0, "192.0.2.3"}, 
        {"mx.example.org", 28, 0, "5f05:2000:80ad:5800::1"}, 
        {"email.example.com", 16, 0, "v=spf1 -all"}, 
        {"*.example.com", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.org", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.net", 255, 1, (char const   *)((void *)0)}, 
        {"01.spf1-test.mailzone.com", 16, 0, "v=spf1                                                             "}, 
        {"02.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             -all       "}, 
        {"03.spf1-test.mailzone.com", 16, 0, "v=spf1                                             ~all"}, 
        {"05.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             default=deny   "}, 
        {"06.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             ?all "}, 
        {"07.spf1-test.mailzone.com", 16, 0, "v=spf2                                             default=bogus   "}, 
        {"08.spf1-test.mailzone.com",
      16, 0, "v=spf1                       -all      ?all  "}, 
        {"09.spf1-test.mailzone.com", 16, 0, "v=spf1    scope=header-from scope=envelope         -all  "}, 
        {"10.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx                                          -all"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"11.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"13.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"20.spf1-test.mailzone.com", 1, 0, "192.0.2.120"}, 
        {"20.spf1-test.mailzone.com", 16, 0, "v=spf1 a                                           -all"}, 
        {"21.spf1-test.mailzone.com",
      16, 0, "v=spf1   a:spf1-test.mailzone.com                            -all"}, 
        {"21.spf1-test.mailzone.com",
      1, 0, "192.0.2.121"}, 
        {"22.spf1-test.mailzone.com", 16, 0, "v=spf1 a a:spf1-test.mailzone.com                            -all"}, 
        {"22.spf1-test.mailzone.com",
      1, 0, "192.0.2.122"}, 
        {"30.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr                                         -all"}, 
        {"30.spf1-test.mailzone.com",
      1, 0, "208.210.124.130"}, 
        {"31.spf1-test.mailzone.com", 16, 0, "v=spf1     ptr:spf1-test.mailzone.com                        -all"}, 
        {"31.spf1-test.mailzone.com",
      1, 0, "208.210.124.131"}, 
        {"32.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr ptr:spf1-test.mailzone.com                        -all"}, 
        {"32.spf1-test.mailzone.com",
      1, 0, "208.210.124.132"}, 
        {"40.spf1-test.mailzone.com", 16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d}                    -all"}, 
        {"41.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.spf1-test.mailzone.com            -all"}, 
        {"42.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d} exists:%{ir}.%{v}._spf.%{d3} -all"}, 
        {"45.spf1-test.mailzone.com",
      16, 0, "v=spf1 -a a:spf1-test.mailzone.com                           -all"}, 
        {"45.spf1-test.mailzone.com",
      1, 0, "192.0.2.147"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.145"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.146"}, 
        {"50.spf1-test.mailzone.com", 16, 0, "v=spf1 include                                     -all"}, 
        {"51.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"52.spf1-test.mailzone.com", 16, 0, "v=spf1 include:53.spf1-test.mailzone.com                  -all"}, 
        {"53.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"54.spf1-test.mailzone.com", 16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"55.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:56.spf1-test.mailzone.com                  -all"}, 
        {"57.spf1-test.mailzone.com", 16, 0, "v=spf1 include:spf1-test.mailzone.com         -all"}, 
        {"58.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:59.spf1-test.mailzone.com                  -all"}, 
        {"59.spf1-test.mailzone.com", 16, 0, "v=spf1 include:58.spf1-test.mailzone.com                  -all"}, 
        {"70.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{lr+=}.lp._spf.spf1-test.mailzone.com -all"}, 
        {"80.spf1-test.mailzone.com", 16, 0, "v=spf1 a mx exists:%{ir}.%{v}._spf.80.spf1-test.mailzone.com ptr -all"}, 
        {"80.spf1-test.mailzone.com",
      1, 0, "208.210.124.180"}, 
        {"90.spf1-test.mailzone.com", 16, 0, "v=spf1  ip4:192.0.2.128/25 -all"}, 
        {"91.spf1-test.mailzone.com", 16, 0, "v=spf1 -ip4:192.0.2.128/25 ip4:192.0.2.0/24 -all"}, 
        {"92.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?ip4:192.0.2.192/26 ip4:192.0.2.128/25 -ip4:192.0.2.0/24 -all"}, 
        {"95.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -all"}, 
        {"96.spf1-test.mailzone.com", 16, 0, "v=spf1 -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"97.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"98.spf1-test.mailzone.com",
      16, 0, "v=spf1 a/26 mx/26 -all"}, 
        {"98.spf1-test.mailzone.com", 15, 0, "80.spf1-test.mailzone.com"}, 
        {"98.spf1-test.mailzone.com", 1, 0, "192.0.2.98"}, 
        {"99.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp=99txt.spf1-test.mailzone.com moo"}, 
        {"99txt.spf1-test.mailzone.com",
      16, 0, "u=%{u} s=%{s} d=%{d} t=%{t} h=%{h} i=%{i} %% U=%{U} S=%{S} D=%{D} T=%{T} H=%{H} I=%{I} %% moo"}, 
        {"100.spf1-test.mailzone.com",
      16, 0, "v=spf1      redirect=98.spf1-test.mailzone.com"}, 
        {"101.spf1-test.mailzone.com", 16, 0, "v=spf1 -all redirect=98.spf1-test.mailzone.com"}, 
        {"102.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?all redirect=98.spf1-test.mailzone.com"}, 
        {"103.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=98.%{d3}"}, 
        {"104.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=105.%{d3}"}, 
        {"105.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=106.%{d3}"}, 
        {"106.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=107.%{d3}"}, 
        {"107.spf1-test.mailzone.com", 16, 0, "v=spf1       include:104.%{d3}"}, 
        {"110.spf1-test.mailzone.com", 16, 0, "v=spf1 some:unrecognized=mechanism some=unrecognized:modifier -all"}, 
        {"111.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx -a gpg ~all exp=111txt.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"111txt.2.0.192.in-addr._spf.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"112.spf1-test.mailzone.com",
      16, 0, "v=spf1 a mp3 ~all"}, 
        {"112.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"113.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3: ~all"}, 
        {"113.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114.spf1-test.mailzone.com", 16, 0, "v=spf1 mx -a gpg=test ~all exp=114txt.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com",
      15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114txt.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"115.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3=yes -all"}, 
        {"115.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"116.spf1-test.mailzone.com", 16, 0, "v=spf1 redirect=116rdr.spf1-test.mailzone.com a"}, 
        {"116.spf1-test.mailzone.com",
      1, 0, "192.0.2.200"}, 
        {"116rdr.spf1-test.mailzone.com", 16, 0, "v=spf1 -all"}, 
        {"117.spf1-test.mailzone.com", 16, 0, " v=spf1 +all"}, 
        {"118.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp="}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.10"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.11"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.12"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.13"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.20"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.21"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.22"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.23"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.30"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.31"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.32"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.33"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.40"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.41"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.42"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.43"}, 
        {"56.spf1-test.mailzone.com", 16, 4, (char const   *)((void *)0)}, 
        {"80.spf1-test.mailzone.com", 15, 4, (char const   *)((void *)0)}, 
        {"servfail.spf1-test.mailzone.com", 16, 2, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 1, 0, "208.210.124.192"}, 
        {"spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"fallback-relay.spf1-test.mailzone.com", 15, 0, "mx04.spf1-test.mailzone.com"}, 
        {"www1.cnn.com",
      1, 0, "64.236.24.4"}, 
        {"4.24.236.64.in-addr.arpa", 12, 0, "www1.cnn.com"}, 
        {"130.124.210.208.in-addr.arpa", 12, 0, "30.spf1-test.mailzone.com"}, 
        {"131.124.210.208.in-addr.arpa", 12, 0, "31.spf1-test.mailzone.com"}, 
        {"192.124.210.208.in-addr.arpa", 12, 0, "spf1-test.mailzone.com"}, 
        {"100.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"110.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"111.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"101.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"130.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"131.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"80.2.0.192.in-addr._spf.80.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"96.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"97.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com",
      1, 0, "127.0.0.2"}, 
        {"bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"postmaster.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"2.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.joe.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"102.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"110.2.0.192.in-addr._spf.42.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"131.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"4.24.236.64.in-addr._spf.80.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"droid.lp._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"joe-2.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"moe-1.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"unknown.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"180.124.210.208.in-addr.arpa",
      12, 0, "80.spf1-test.mailzone.com"}, 
        {"80.spf1-test.mailzone.com.whitelist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.124.210.208.in-addr.arpa",
      12, 0, "pobox-gw.icgroup.com"}, 
        {"pobox-gw.icgroup.com", 1, 0, "208.210.124.1"}, 
        {"pobox-gw.icgroup.com.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com",
      16, 1, (char const   *)((void *)0)}, 
        {"spf.trusted-forwarder.org", 16, 0, "v=spf1 exists:%{ir}.wl.trusted-forwarder.org exists:%{p}.wl.trusted-forwarder.org"}, 
        {"*.spf1-text.mailzone.com",
      255, 1, (char const   *)((void *)0)}, 
        {"cat.com", 16, 4, (char const   *)((void *)0)}, 
        {"bar.com", 16, 4, (char const   *)((void *)0)}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}};
#line 41 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static SPF_dns_rr_t *SPF_dns_null_lookup___3(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_rr_t *tmp ;
  SPF_dns_rr_t *tmp___0 ;

  {
#line 45
  if (spf_dns_server->layer_below) {
    {
#line 46
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 46
    return (tmp);
  }
  {
#line 48
  tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
  }
#line 48
  return (tmp___0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static void SPF_dns_null_free___3(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 54
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c",
                 54, "%s", "spf_dns_server is NULL");
      }
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  free((void *)spf_dns_server);
  }
#line 56
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
static SPF_response_t *SPF_response_choose___1(SPF_response_t *yes , SPF_response_t *no ) 
{ 


  {
  {
#line 80
  SPF_response_free(no);
  }
#line 81
  return (yes);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
static SPF_errcode_t SPF_response_add_error_v___1(SPF_response_t *rp , SPF_errcode_t code ,
                                                  int is_error , char const   *text ,
                                                  int idx , char const   *format ,
                                                  va_list ap ) 
{ 
  SPF_error_t *tmp ;
  char buf[4096] ;
  int size ;
  void *tmp___0 ;

  {
#line 198
  if (! format) {
    {
#line 199
    format = SPF_strerror(code);
    }
  }
  {
#line 200
  size = vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
                   ap);
  }
#line 201
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
#line 202
    snprintf((char */* __restrict  */)(& buf[size]), sizeof(buf) - (unsigned long )size,
             (char const   */* __restrict  */)" near \'%.12s\'", text + idx);
    }
  }
#line 205
  buf[4095] = (char )'\000';
#line 207
  if ((int )rp->errors_length == (int )rp->errors_size) {
    {
#line 208
    size = ((int )rp->errors_size + (int )rp->errors_size / 4) + 4;
#line 209
    tmp___0 = realloc((void *)rp->errors, (unsigned long )size * sizeof(SPF_error_t ));
#line 209
    tmp = (SPF_error_t *)tmp___0;
    }
#line 210
    if (! tmp) {
      {
#line 211
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c",
                 211, "%s", "Failed to allocate memory for extra response error");
      }
#line 212
      return (code);
    }
#line 214
    rp->errors = tmp;
#line 215
    rp->errors_size = (unsigned short )size;
  }
  {
#line 218
  (rp->errors + rp->errors_length)->code = code;
#line 219
  (rp->errors + rp->errors_length)->is_error = (char )is_error;
#line 221
  (rp->errors + rp->errors_length)->message = strdup((char const   *)(buf));
#line 222
  rp->errors_length = (unsigned short )((int )rp->errors_length + 1);
  }
#line 224
  return (code);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   spf_mechtypes___3[10]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
  {      {(unsigned char)0, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)1, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)2, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)3, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )0}, 
        {(unsigned char)4, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)5, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)6, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)7, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)8, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)9, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}};
#line 94 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   *SPF_mechtype_find___3(int mech_type ) 
{ 
  size_t i ;

  {
#line 98
  i = (size_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < sizeof(spf_mechtypes___3) / sizeof(spf_mechtypes___3[0]))) {
#line 98
      goto while_break;
    }
#line 99
    if ((int const   )spf_mechtypes___3[i].mech_type == (int const   )mech_type) {
#line 100
      return (& spf_mechtypes___3[i]);
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((SPF_mechtype_t const   *)((void *)0));
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static int ( __attribute__((__warn_unused_result__)) SPF_c_ensure_capacity___3)(void **datap ,
                                                                                size_t *sizep ,
                                                                                size_t length ) 
{ 
  size_t size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 109
  size = *sizep;
#line 110
  if (length > size) {
#line 111
    size = length + length / 4UL;
  }
#line 112
  if (size > *sizep) {
    {
#line 113
    tmp___0 = realloc(*datap, size);
#line 113
    tmp = tmp___0;
    }
#line 114
    if (! tmp) {
#line 115
      return (-1);
    }
#line 117
    *datap = tmp;
#line 118
    *sizep = size;
  }
#line 120
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip6___3(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 144
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 144
  mask = (int )tmp;
  }
#line 146
  if (mask > 128) {
    {
#line 147
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (>128)");
    }
#line 147
    return (tmp___0);
  } else
#line 151
  if (mask == 0) {
    {
#line 152
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (=0)");
    }
#line 152
    return (tmp___1);
  } else
#line 156
  if (mask == 128) {
#line 157
    mask = 0;
  }
#line 160
  *maskp = (unsigned char )mask;
#line 162
  return ((SPF_errcode_t )0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip4___3(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 186
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 186
  mask = (int )tmp;
  }
#line 188
  if (mask > 32) {
    {
#line 189
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (>32)");
    }
#line 189
    return (tmp___0);
  } else
#line 193
  if (mask == 0) {
    {
#line 194
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (=0)");
    }
#line 194
    return (tmp___1);
  } else
#line 198
  if (mask == 32) {
#line 199
    mask = 0;
  }
#line 202
  *maskp = (unsigned char )mask;
#line 204
  return ((SPF_errcode_t )0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr___3(SPF_response_t *spf_response , SPF_data_cidr_t *data ,
                                          char const   *src , size_t *src_len ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 220
  memset((void *)data, 0, sizeof(SPF_data_cidr_t ));
#line 221
  data->parm_type = (unsigned char)11;
#line 227
  idx = *src_len - 1UL;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (idx > 0UL) {
      {
#line 228
      tmp = __ctype_b_loc();
      }
#line 228
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 228
        goto while_break;
      }
    } else {
#line 228
      goto while_break;
    }
#line 229
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (idx < *src_len - 1UL) {
#line 236
    if ((int const   )*(src + idx) == 47) {
#line 237
      if (idx > 0UL) {
#line 237
        if ((int const   )*(src + (idx - 1UL)) == 47) {
          {
#line 239
          err = SPF_c_parse_cidr_ip6___3(spf_response, & data->ipv6, src + idx);
          }
#line 240
          if (err) {
#line 241
            return (err);
          }
#line 243
          *src_len = idx - 1UL;
#line 244
          idx = *src_len - 1UL;
          {
#line 245
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 245
            if (idx > 0UL) {
              {
#line 245
              tmp___0 = __ctype_b_loc();
              }
#line 245
              if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 245
                goto while_break___0;
              }
            } else {
#line 245
              goto while_break___0;
            }
#line 246
            idx --;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 249
          if (idx < *src_len - 1UL) {
#line 249
            if ((int const   )*(src + idx) == 47) {
              {
#line 253
              err = SPF_c_parse_cidr_ip4___3(spf_response, & data->ipv4, src + idx);
              }
#line 254
              if (err) {
#line 255
                return (err);
              }
#line 256
              *src_len = idx;
            }
          }
        } else {
#line 237
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 261
        err = SPF_c_parse_cidr_ip4___3(spf_response, & data->ipv4, src + idx);
        }
#line 262
        if (err) {
#line 263
          return (err);
        }
#line 264
        *src_len = idx;
      }
    }
  }
#line 268
  return ((SPF_errcode_t )0);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_var___3(SPF_response_t *spf_response , SPF_data_var_t *data ,
                                         char const   *src , int is_mod ) 
{ 
  char const   *token ;
  char const   *p ;
  char c ;
  int val ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;
  SPF_errcode_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  SPF_errcode_t tmp___6 ;
  SPF_errcode_t tmp___7 ;

  {
  {
#line 280
  memset((void *)data, 0, sizeof(SPF_data_var_t ));
#line 282
  p = src;
#line 285
  c = (char )*p;
#line 286
  tmp___0 = __ctype_b_loc();
  }
#line 286
  if ((int const   )*(*tmp___0 + (int )((unsigned char )c)) & 256) {
    {
#line 288
    data->url_encode = (unsigned short)1;
#line 289
    tmp = tolower((int )c);
#line 289
    c = (char )tmp;
    }
  } else {
#line 292
    data->url_encode = (unsigned short)0;
  }
  {
#line 302
  if ((int )c == 108) {
#line 302
    goto case_108;
  }
#line 306
  if ((int )c == 115) {
#line 306
    goto case_115;
  }
#line 310
  if ((int )c == 111) {
#line 310
    goto case_111;
  }
#line 314
  if ((int )c == 100) {
#line 314
    goto case_100;
  }
#line 318
  if ((int )c == 105) {
#line 318
    goto case_105;
  }
#line 322
  if ((int )c == 99) {
#line 322
    goto case_99;
  }
#line 327
  if ((int )c == 116) {
#line 327
    goto case_116;
  }
#line 332
  if ((int )c == 112) {
#line 332
    goto case_112;
  }
#line 336
  if ((int )c == 118) {
#line 336
    goto case_118;
  }
#line 340
  if ((int )c == 104) {
#line 340
    goto case_104;
  }
#line 344
  if ((int )c == 114) {
#line 344
    goto case_114;
  }
#line 349
  goto switch_default;
  case_108: /* CIL Label */ 
#line 303
  data->parm_type = (unsigned char)0;
#line 304
  goto switch_break;
  case_115: /* CIL Label */ 
#line 307
  data->parm_type = (unsigned char)1;
#line 308
  goto switch_break;
  case_111: /* CIL Label */ 
#line 311
  data->parm_type = (unsigned char)2;
#line 312
  goto switch_break;
  case_100: /* CIL Label */ 
#line 315
  data->parm_type = (unsigned char)3;
#line 316
  goto switch_break;
  case_105: /* CIL Label */ 
#line 319
  data->parm_type = (unsigned char)4;
#line 320
  goto switch_break;
  case_99: /* CIL Label */ 
#line 323
  if (! is_mod) {
    {
#line 323
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 323
    return (tmp___1);
  }
#line 324
  data->parm_type = (unsigned char)5;
#line 325
  goto switch_break;
  case_116: /* CIL Label */ 
#line 328
  if (! is_mod) {
    {
#line 328
    tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 328
    return (tmp___2);
  }
#line 329
  data->parm_type = (unsigned char)6;
#line 330
  goto switch_break;
  case_112: /* CIL Label */ 
#line 333
  data->parm_type = (unsigned char)7;
#line 334
  goto switch_break;
  case_118: /* CIL Label */ 
#line 337
  data->parm_type = (unsigned char)8;
#line 338
  goto switch_break;
  case_104: /* CIL Label */ 
#line 341
  data->parm_type = (unsigned char)9;
#line 342
  goto switch_break;
  case_114: /* CIL Label */ 
#line 345
  if (! is_mod) {
    {
#line 345
    tmp___3 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 345
    return (tmp___3);
  }
#line 346
  data->parm_type = (unsigned char)10;
#line 347
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 350
  tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                       p, "Unknown variable \'%c\'", (int )c);
  }
#line 350
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
#line 354
  p ++;
#line 355
  token = p;
#line 358
  val = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 359
    tmp___5 = __ctype_b_loc();
    }
#line 359
    if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*p)) & 2048)) {
#line 359
      goto while_break;
    }
#line 361
    val *= 10;
#line 362
    val += (int )((int const   )*p - 48);
#line 363
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (val > 128) {
    {
#line 366
    tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                         token, "Subdomain truncation depth too large");
    }
#line 366
    return (tmp___6);
  } else
#line 365
  if (val <= 0) {
#line 365
    if ((unsigned long )p != (unsigned long )token) {
      {
#line 366
      tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                           token, "Subdomain truncation depth too large");
      }
#line 366
      return (tmp___6);
    }
  }
#line 369
  data->num_rhs = (unsigned char )val;
#line 370
  token = p;
#line 373
  if ((int const   )*p == 114) {
#line 375
    data->rev = (unsigned short)1;
#line 376
    p ++;
  } else {
#line 379
    data->rev = (unsigned short)0;
  }
#line 380
  token = p;
#line 384
  data->delim_dot = (unsigned short)0;
#line 385
  data->delim_dash = (unsigned short)0;
#line 386
  data->delim_plus = (unsigned short)0;
#line 387
  data->delim_equal = (unsigned short)0;
#line 388
  data->delim_bar = (unsigned short)0;
#line 389
  data->delim_under = (unsigned short)0;
#line 392
  if ((int const   )*p == 125) {
#line 393
    data->delim_dot = (unsigned short)1;
  }
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! ((int const   )*p != 125)) {
#line 396
      goto while_break___0;
    }
#line 398
    token = p;
    {
#line 401
    if ((int const   )*p == 46) {
#line 401
      goto case_46;
    }
#line 405
    if ((int const   )*p == 45) {
#line 405
      goto case_45;
    }
#line 409
    if ((int const   )*p == 43) {
#line 409
      goto case_43;
    }
#line 413
    if ((int const   )*p == 61) {
#line 413
      goto case_61;
    }
#line 417
    if ((int const   )*p == 124) {
#line 417
      goto case_124;
    }
#line 421
    if ((int const   )*p == 95) {
#line 421
      goto case_95;
    }
#line 425
    goto switch_default___0;
    case_46: /* CIL Label */ 
#line 402
    data->delim_dot = (unsigned short)1;
#line 403
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 406
    data->delim_dash = (unsigned short)1;
#line 407
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 410
    data->delim_plus = (unsigned short)1;
#line 411
    goto switch_break___0;
    case_61: /* CIL Label */ 
#line 414
    data->delim_equal = (unsigned short)1;
#line 415
    goto switch_break___0;
    case_124: /* CIL Label */ 
#line 418
    data->delim_bar = (unsigned short)1;
#line 419
    goto switch_break___0;
    case_95: /* CIL Label */ 
#line 422
    data->delim_under = (unsigned short)1;
#line 423
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 426
    tmp___7 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )14, (char const   *)((void *)0),
                                         p, "Invalid delimiter \'%c\'", (int const   )*p);
    }
#line 426
    return (tmp___7);
    switch_break___0: /* CIL Label */ ;
    }
#line 430
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 432
  p ++;
#line 433
  token = p;
#line 436
  return ((SPF_errcode_t )0);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_macro___3(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                           SPF_data_t *data , size_t *data_used ,
                                           size_t data_avail , char const   *src ,
                                           size_t src_len , SPF_errcode_t big_err ,
                                           int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  size_t len ;
  char *dst ;
  size_t ds_avail ;
  size_t ds_len ;
  SPF_errcode_t tmp ;
  SPF_errcode_t tmp___0 ;
  char *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  char *tmp___3 ;
  SPF_errcode_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  SPF_errcode_t tmp___8 ;
  char *tmp___9 ;
  SPF_errcode_t tmp___10 ;
  SPF_errcode_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  SPF_errcode_t tmp___15 ;
  SPF_errcode_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  SPF_errcode_t tmp___19 ;
  SPF_errcode_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
#line 522
  if (spf_server___1->debug) {
    {
#line 523
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               523, "Parsing macro starting at %s", src);
    }
  }
#line 534
  idx = (size_t )0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 538
    data->ds.parm_type = (unsigned char)12;
#line 538
    data->ds.len = (unsigned char)0;
#line 538
    data->ds.__unused0 = (unsigned char)186;
#line 538
    data->ds.__unused1 = (unsigned char)190;
#line 538
    dst = SPF_data_str(data);
#line 538
    ds_avail = data_avail - *data_used;
#line 538
    ds_len = (size_t )0;
    }
#line 538
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 541
    if (! (idx < src_len)) {
#line 541
      goto while_break___0;
    }
#line 542
    if (spf_server___1->debug > 3) {
      {
#line 543
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 543, "Current data is at %p", data);
      }
    }
    {
#line 546
    len = strcspn(src + idx, " %");
    }
#line 547
    if (len > 0UL) {
#line 549
      if (idx + len > src_len) {
#line 550
        len = src_len - idx;
      }
#line 551
      if (spf_server___1->debug > 3) {
        {
#line 552
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                   554, "Adding string literal (%lu): \'%*.*s\'", len, (int )len,
                   (int )len, src + idx);
        }
      }
      {
#line 556
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 556
        if (ds_len + len > ds_avail) {
          {
#line 556
          tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                           src, "String literal fragment too long (%d chars, %d max)",
                                           ds_len, ds_avail);
          }
#line 556
          return (tmp);
        }
#line 556
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 557
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(src + idx),
             len);
#line 558
      ds_len += len;
#line 559
      dst += len;
#line 560
      idx += len;
      }
    }
#line 568
    if (idx == src_len) {
#line 569
      goto while_break___0;
    }
#line 576
    idx ++;
    {
#line 578
    if ((int const   )*(src + idx) == 37) {
#line 578
      goto case_37;
    }
#line 587
    if ((int const   )*(src + idx) == 95) {
#line 587
      goto case_95;
    }
#line 596
    if ((int const   )*(src + idx) == 45) {
#line 596
      goto case_45;
    }
#line 617
    if ((int const   )*(src + idx) == 123) {
#line 617
      goto case_123;
    }
#line 605
    goto switch_default;
    case_37: /* CIL Label */ 
#line 579
    if (spf_server___1->debug > 3) {
      {
#line 580
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 580, "Adding literal %%");
      }
    }
    {
#line 581
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 581
      if (ds_len + 1UL > ds_avail) {
        {
#line 581
        tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 581
        return (tmp___0);
      }
#line 581
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 582
    tmp___1 = dst;
#line 582
    dst ++;
#line 582
    *tmp___1 = (char )'%';
#line 583
    ds_len ++;
#line 584
    idx ++;
#line 585
    goto switch_break;
    case_95: /* CIL Label */ 
#line 588
    if (spf_server___1->debug > 3) {
      {
#line 589
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 589, "Adding literal space");
      }
    }
    {
#line 590
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 590
      if (ds_len + 1UL > ds_avail) {
        {
#line 590
        tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 590
        return (tmp___2);
      }
#line 590
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 591
    tmp___3 = dst;
#line 591
    dst ++;
#line 591
    *tmp___3 = (char )' ';
#line 592
    ds_len ++;
#line 593
    idx ++;
#line 594
    goto switch_break;
    case_45: /* CIL Label */ 
#line 597
    if (spf_server___1->debug > 3) {
      {
#line 598
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 598, "Adding escaped space");
      }
    }
    {
#line 599
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 599
      if (ds_len + 3UL > ds_avail) {
        {
#line 599
        tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 599
        return (tmp___4);
      }
#line 599
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 600
    tmp___5 = dst;
#line 600
    dst ++;
#line 600
    *tmp___5 = (char )'%';
#line 600
    tmp___6 = dst;
#line 600
    dst ++;
#line 600
    *tmp___6 = (char )'2';
#line 600
    tmp___7 = dst;
#line 600
    dst ++;
#line 600
    *tmp___7 = (char )'0';
#line 601
    ds_len += 3UL;
#line 602
    idx ++;
#line 603
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 606
    if (spf_server___1->debug > 3) {
      {
#line 607
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 608, "Adding illegal %%-follower \'%c\' at %d", (int const   )*(src + idx),
                 idx);
      }
    }
    {
#line 612
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 612
      if (ds_len + 1UL > ds_avail) {
        {
#line 612
        tmp___8 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 612
        return (tmp___8);
      }
#line 612
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 613
    tmp___9 = dst;
#line 613
    dst ++;
#line 613
    *tmp___9 = (char )'%';
#line 614
    ds_len ++;
#line 615
    goto switch_break;
    case_123: /* CIL Label */ 
    {
#line 618
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 618
      if (ds_len > 0UL) {
#line 618
        if (ds_len > 255UL) {
          {
#line 618
          tmp___10 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15,
                                                (char const   *)((void *)0), src,
                                                "String literal too long (%d chars, %d max)",
                                                ds_len, 255);
          }
#line 618
          return (tmp___10);
        }
#line 618
        data->ds.len = (unsigned char )ds_len;
#line 618
        len = sizeof(*data) + ds_len;
        {
#line 618
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 618
          tmp___12 = _align_sz(len);
          }
#line 618
          if (*data_used + tmp___12 > data_avail) {
            {
#line 618
            tmp___11 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                  src, "SPF domainspec too long (%d chars, %d max)",
                                                  *data_used + len, data_avail);
            }
#line 618
            return (tmp___11);
          }
          {
#line 618
          tmp___13 = _align_sz(len);
#line 618
          *data_used += tmp___13;
          }
#line 618
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 618
        data = SPF_data_next(data);
#line 618
        ds_len = (size_t )0;
        }
      }
#line 618
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 619
    if (spf_server___1->debug > 3) {
      {
#line 620
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 620, "Adding macro, data is at %p", data);
      }
    }
    {
#line 623
    idx ++;
#line 624
    err = SPF_c_parse_var___3(spf_response, & data->dv, src + idx, is_mod);
    }
#line 625
    if ((unsigned int )err != 0U) {
#line 626
      return (err);
    }
    {
#line 627
    tmp___14 = strcspn(src + idx, "} ");
#line 627
    idx += tmp___14;
    }
#line 628
    if ((int const   )*(src + idx) == 125) {
#line 629
      idx ++;
    } else
#line 630
    if ((int const   )*(src + idx) == 32) {
      {
#line 631
      tmp___15 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, src,
                                            src + idx, "Unterminated variable?");
      }
#line 631
      return (tmp___15);
    }
    {
#line 637
    len = SPF_data_len(data);
    }
    {
#line 638
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 638
      tmp___17 = _align_sz(len);
      }
#line 638
      if (*data_used + tmp___17 > data_avail) {
        {
#line 638
        tmp___16 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                              src, "SPF domainspec too long (%d chars, %d max)",
                                              *data_used + len, data_avail);
        }
#line 638
        return (tmp___16);
      }
      {
#line 638
      tmp___18 = _align_sz(len);
#line 638
      *data_used += tmp___18;
      }
#line 638
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 639
    data = SPF_data_next(data);
    }
#line 640
    if (spf_server___1->debug > 3) {
      {
#line 641
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 641, "Next data is at %p", data);
      }
    }
    {
#line 643
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 643
      data->ds.parm_type = (unsigned char)12;
#line 643
      data->ds.len = (unsigned char)0;
#line 643
      data->ds.__unused0 = (unsigned char)186;
#line 643
      data->ds.__unused1 = (unsigned char)190;
#line 643
      dst = SPF_data_str(data);
#line 643
      ds_avail = data_avail - *data_used;
#line 643
      ds_len = (size_t )0;
      }
#line 643
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 649
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 649
    if (ds_len > 0UL) {
#line 649
      if (ds_len > 255UL) {
        {
#line 649
        tmp___19 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                              src, "String literal too long (%d chars, %d max)",
                                              ds_len, 255);
        }
#line 649
        return (tmp___19);
      }
#line 649
      data->ds.len = (unsigned char )ds_len;
#line 649
      len = sizeof(*data) + ds_len;
      {
#line 649
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 649
        tmp___21 = _align_sz(len);
        }
#line 649
        if (*data_used + tmp___21 > data_avail) {
          {
#line 649
          tmp___20 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                src, "SPF domainspec too long (%d chars, %d max)",
                                                *data_used + len, data_avail);
          }
#line 649
          return (tmp___20);
        }
        {
#line 649
        tmp___22 = _align_sz(len);
#line 649
        *data_used += tmp___22;
        }
#line 649
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 649
      data = SPF_data_next(data);
#line 649
      ds_len = (size_t )0;
      }
    }
#line 649
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 651
  return ((SPF_errcode_t )0);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_domainspec___3(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                                SPF_data_t *data , size_t *data_used ,
                                                size_t data_avail , char const   *src ,
                                                size_t src_len , SPF_errcode_t big_err ,
                                                SPF_cidr_t cidr_ok , int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  SPF_errcode_t tmp___6 ;

  {
#line 682
  if (spf_server___1->debug) {
#line 683
    if ((unsigned int )cidr_ok == 1U) {
#line 683
      tmp___1 = "optional";
    } else {
#line 683
      if ((unsigned int )cidr_ok == 2U) {
#line 683
        tmp___0 = "only";
      } else {
#line 683
        if ((unsigned int )cidr_ok == 0U) {
#line 683
          tmp = "forbidden";
        } else {
#line 683
          tmp = "ERROR!";
        }
#line 683
        tmp___0 = tmp;
      }
#line 683
      tmp___1 = tmp___0;
    }
    {
#line 683
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               689, "Parsing domainspec starting at %s, cidr is %s", src, tmp___1);
    }
  }
#line 694
  if ((unsigned int )cidr_ok == 1U) {
#line 694
    goto _L___0;
  } else
#line 694
  if ((unsigned int )cidr_ok == 2U) {
    _L___0: /* CIL Label */ 
    {
#line 695
    err = SPF_c_parse_cidr___3(spf_response, & data->dc, src, & src_len);
    }
#line 696
    if ((unsigned int )err != 0U) {
#line 697
      return (err);
    }
#line 698
    if ((int )data->dc.ipv4 != 0) {
#line 698
      goto _L;
    } else
#line 698
    if ((int )data->dc.ipv6 != 0) {
      _L: /* CIL Label */ 
      {
#line 699
      len = SPF_data_len(data);
      }
      {
#line 700
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 700
        tmp___3 = _align_sz(len);
        }
#line 700
        if (*data_used + tmp___3 > data_avail) {
          {
#line 700
          tmp___2 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                               src, "SPF domainspec too long (%d chars, %d max)",
                                               *data_used + len, data_avail);
          }
#line 700
          return (tmp___2);
        }
        {
#line 700
        tmp___4 = _align_sz(len);
#line 700
        *data_used += tmp___4;
        }
#line 700
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 701
      data = SPF_data_next(data);
      }
    }
#line 704
    if ((unsigned int )cidr_ok == 2U) {
#line 704
      if (src_len > 0UL) {
        {
#line 708
        tmp___5 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                             src, "Invalid CIDR after mechanism");
        }
#line 708
        return (tmp___5);
      }
    }
  }
  {
#line 715
  tmp___6 = SPF_c_parse_macro___3(spf_server___1, spf_response, data, data_used, data_avail,
                                  src, src_len, big_err, is_mod);
  }
#line 715
  return (tmp___6);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip4___3(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  SPF_errcode_t err ;
  unsigned char mask ;
  struct in_addr *addr ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 739
  start ++;
#line 740
  len = strcspn(start, " ");
#line 741
  end = start + len;
#line 742
  p = end - 1;
#line 744
  mask = (unsigned char)0;
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 745
    tmp = __ctype_b_loc();
    }
#line 745
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 745
      goto while_break;
    }
#line 746
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 747
    if ((int const   )*p == 47) {
      {
#line 748
      err = SPF_c_parse_cidr_ip4___3(spf_response, & mask, p);
      }
#line 749
      if (err) {
#line 750
        return (err);
      }
#line 751
      end = p;
    }
  }
#line 753
  mech->mech_len = (unsigned short )mask;
#line 755
  len = (size_t )(end - start);
#line 756
  if (len > sizeof(buf) - 1UL) {
#line 757
    return ((SPF_errcode_t )19);
  }
  {
#line 759
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 760
  buf[len] = (char )'\000';
#line 761
  addr = SPF_mech_ip4_data(mech);
#line 762
  tmp___0 = inet_pton(2, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
#line 762
  err = (SPF_errcode_t )tmp___0;
  }
#line 763
  if ((unsigned int )err <= 0U) {
    {
#line 764
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )19, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 764
    return (tmp___1);
  }
#line 767
  return ((SPF_errcode_t )0);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip6___3(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  int err ;
  unsigned char mask ;
  struct in6_addr *addr ;
  unsigned short const   **tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 788
  start ++;
#line 789
  len = strcspn(start, " ");
#line 790
  end = start + len;
#line 791
  p = end - 1;
#line 793
  mask = (unsigned char)0;
  }
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 794
    tmp = __ctype_b_loc();
    }
#line 794
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 794
      goto while_break;
    }
#line 795
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 796
    if ((int const   )*p == 47) {
      {
#line 797
      tmp___0 = SPF_c_parse_cidr_ip6___3(spf_response, & mask, p);
#line 797
      err = (int )tmp___0;
      }
#line 798
      if (err) {
#line 799
        return ((SPF_errcode_t )err);
      }
#line 800
      end = p;
    }
  }
#line 802
  mech->mech_len = (unsigned short )mask;
#line 804
  len = (size_t )(end - start);
#line 805
  if (len > sizeof(buf) - 1UL) {
#line 806
    return ((SPF_errcode_t )20);
  }
  {
#line 808
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 809
  buf[len] = (char )'\000';
#line 810
  addr = SPF_mech_ip6_data(mech);
#line 811
  err = inet_pton(10, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
  }
#line 812
  if (err <= 0) {
    {
#line 813
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )20, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 813
    return (tmp___1);
  }
#line 816
  return ((SPF_errcode_t )0);
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mech_add___3)(SPF_server_t *spf_server___1 ,
                                                                                   SPF_record_t *spf_record ,
                                                                                   SPF_response_t *spf_response ,
                                                                                   SPF_mechtype_t const   *mechtype ,
                                                                                   int prefix ,
                                                                                   char const   **mech_value ) 
{ 
  union __anonunion_u_60___3 u ;
  SPF_mech_t *spf_mechanism ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  SPF_errcode_t tmp ;
  int tmp___0 ;

  {
  {
#line 834
  spf_mechanism = (SPF_mech_t *)(u.buf);
#line 842
  memset((void *)(u.buf), 'B', sizeof(u.buf));
#line 843
  memset((void *)spf_mechanism, 0, sizeof(SPF_mech_t ));
  }
#line 845
  if (spf_server___1->debug) {
    {
#line 846
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               847, "SPF_c_mech_add: type=%d, value=%s", (int const   )mechtype->mech_type,
               *mech_value);
    }
  }
#line 849
  spf_mechanism->prefix_type = (unsigned char )prefix;
#line 850
  spf_mechanism->mech_type = (unsigned char )mechtype->mech_type;
#line 851
  spf_mechanism->mech_len = (unsigned short)0;
#line 853
  len = sizeof(SPF_mech_t );
#line 855
  if (spf_record->mech_len + len > 511UL) {
#line 856
    return ((SPF_errcode_t )16);
  }
  {
#line 858
  data = SPF_mech_data(spf_mechanism);
#line 859
  data_len = (size_t )0;
#line 861
  src_len = strcspn(*mech_value, " ");
  }
  {
#line 865
  if ((int const   )mechtype->mech_type == 5) {
#line 865
    goto case_5;
  }
#line 878
  if ((int const   )mechtype->mech_type == 6) {
#line 878
    goto case_6;
  }
#line 891
  goto switch_default;
  case_5: /* CIL Label */ 
#line 866
  if ((int const   )*(*mech_value) == 58) {
    {
#line 867
    err = SPF_c_parse_ip4___3(spf_response, spf_mechanism, *mech_value);
#line 868
    data_len = sizeof(struct in_addr );
    }
  } else {
    {
#line 871
    err = (SPF_errcode_t )9;
#line 872
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 876
  goto switch_break;
  case_6: /* CIL Label */ 
#line 879
  if ((int const   )*(*mech_value) == 58) {
    {
#line 880
    err = SPF_c_parse_ip6___3(spf_response, spf_mechanism, *mech_value);
#line 881
    data_len = sizeof(struct in6_addr );
    }
  } else {
    {
#line 884
    err = (SPF_errcode_t )9;
#line 885
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 889
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 892
  if ((int const   )*(*mech_value) == 58) {
#line 892
    goto _L___0;
  } else
#line 892
  if ((int const   )*(*mech_value) == 61) {
    _L___0: /* CIL Label */ 
#line 893
    if ((unsigned int const   )mechtype->has_domainspec == 0U) {
      {
#line 894
      err = (SPF_errcode_t )7;
#line 895
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a value.");
      }
    } else {
      {
#line 900
      (*mech_value) ++;
#line 900
      src_len --;
#line 901
      err = SPF_c_parse_domainspec___3(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )mechtype->has_cidr, 0);
      }
    }
  } else
#line 909
  if ((int const   )*(*mech_value) == 47) {
#line 910
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 911
      err = (SPF_errcode_t )9;
#line 912
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else
#line 916
    if ((unsigned int const   )mechtype->has_cidr == 0U) {
      {
#line 917
      err = (SPF_errcode_t )8;
#line 918
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a CIDR.");
      }
    } else {
      {
#line 923
      err = SPF_c_parse_domainspec___3(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )2, 0);
      }
    }
  } else
#line 931
  if ((int const   )*(*mech_value) == 32) {
#line 931
    goto _L;
  } else
#line 931
  if ((int const   )*(*mech_value) == 0) {
    _L: /* CIL Label */ 
#line 932
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 933
      err = (SPF_errcode_t )9;
#line 934
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else {
#line 939
      err = (SPF_errcode_t )0;
    }
  } else {
    {
#line 943
    err = (SPF_errcode_t )3;
#line 944
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Unknown character \'%c\' after mechanism.", (int const   )*(*mech_value));
    }
  }
#line 951
  spf_mechanism->mech_len = (unsigned short )data_len;
#line 952
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 955
  len += data_len;
#line 958
  if ((unsigned int )err == 0U) {
#line 959
    if (mechtype->is_dns_mech) {
#line 960
      spf_record->num_dns_mech = (unsigned char )((int )spf_record->num_dns_mech + 1);
    }
    {
#line 961
    tmp___0 = SPF_c_ensure_capacity___3((void **)(& spf_record->mech_first), & spf_record->mech_size,
                                        spf_record->mech_len + len);
    }
#line 961
    if (tmp___0 < 0) {
      {
#line 964
      tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                       (char const   *)((void *)0), "Failed to allocate memory for mechanism");
      }
#line 964
      return (tmp);
    }
    {
#line 968
    memcpy((void */* __restrict  */)((char *)spf_record->mech_first + spf_record->mech_len),
           (void const   */* __restrict  */)spf_mechanism, len);
#line 971
    spf_record->mech_len += len;
#line 972
    spf_record->num_mech = (unsigned char )((int )spf_record->num_mech + 1);
    }
  }
#line 975
  *mech_value += src_len;
#line 977
  return (err);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mod_add___3)(SPF_server_t *spf_server___1 ,
                                                                                  SPF_record_t *spf_record ,
                                                                                  SPF_response_t *spf_response ,
                                                                                  char const   *mod_name ,
                                                                                  size_t name_len ,
                                                                                  char const   **mod_value ) 
{ 
  union __anonunion_u_61___3 u ;
  SPF_mod_t *spf_modifier ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  char *tmp ;
  SPF_errcode_t tmp___0 ;
  int tmp___1 ;

  {
#line 992
  spf_modifier = (SPF_mod_t *)(u.buf);
#line 1000
  if (spf_server___1->debug) {
    {
#line 1001
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               1002, "Adding modifier name=%lu@%s, value=%s", name_len, mod_name,
               *mod_value);
    }
  }
  {
#line 1004
  memset((void *)(u.buf), 'A', sizeof(u.buf));
#line 1005
  memset((void *)spf_modifier, 0, sizeof(SPF_mod_t ));
  }
#line 1007
  if (name_len > 511UL) {
#line 1008
    return ((SPF_errcode_t )17);
  }
  {
#line 1010
  spf_modifier->name_len = (unsigned short )name_len;
#line 1011
  spf_modifier->data_len = (unsigned short)0;
#line 1014
  len = _align_sz(sizeof(SPF_mod_t ) + name_len);
  }
#line 1016
  if (spf_record->mod_len + len > 511UL) {
#line 1017
    return ((SPF_errcode_t )17);
  }
  {
#line 1019
  tmp = SPF_mod_name(spf_modifier);
#line 1019
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)mod_name,
         name_len);
#line 1021
  data = SPF_mod_data(spf_modifier);
#line 1022
  data_len = (size_t )0;
#line 1024
  src_len = strcspn(*mod_value, " ");
#line 1026
  err = SPF_c_parse_macro___3(spf_server___1, spf_response, data, & data_len, (size_t )511,
                              *mod_value, src_len, (SPF_errcode_t )17, 1);
#line 1032
  spf_modifier->data_len = (unsigned short )data_len;
#line 1033
  len += data_len;
  }
#line 1036
  if ((unsigned int )err == 0U) {
    {
#line 1037
    tmp___1 = SPF_c_ensure_capacity___3((void **)(& spf_record->mod_first), & spf_record->mod_size,
                                        spf_record->mod_len + len);
    }
#line 1037
    if (tmp___1 < 0) {
      {
#line 1040
      tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                           (char const   *)((void *)0), "Failed to allocate memory for modifier");
      }
#line 1040
      return (tmp___0);
    }
    {
#line 1044
    memcpy((void */* __restrict  */)((char *)spf_record->mod_first + spf_record->mod_len),
           (void const   */* __restrict  */)spf_modifier, len);
#line 1047
    spf_record->mod_len += len;
#line 1048
    spf_record->num_mod = (unsigned char )((int )spf_record->num_mod + 1);
    }
  }
#line 1051
  return (err);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static void SPF_record_lint___3(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                SPF_record_t *spf_record ) 
{ 
  SPF_data_t *d ;
  SPF_data_t *data_end ;
  char *s ;
  char *s_end ;
  int found_non_ip ;
  int found_valid_tld ;
  SPF_mech_t *mech ;
  SPF_data_t *data ;
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1075
  mech = spf_record->mech_first;
#line 1076
  i = 0;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (i < (int )spf_record->num_mech)) {
#line 1076
      goto while_break;
    }
#line 1081
    if ((int )mech->mech_type == 8) {
#line 1081
      goto _L;
    } else
#line 1081
    if ((int )mech->mech_type == 9) {
      _L: /* CIL Label */ 
#line 1081
      if (i != (int )spf_record->num_mech - 1) {
        {
#line 1085
        SPF_response_add_warn(spf_response, (SPF_errcode_t )29, "Mechanisms found after the \"all:\" mechanism will be ignored.");
        }
      }
    }
#line 1098
    if ((int )mech->mech_type == 5) {
#line 1100
      goto __Cont;
    } else
#line 1098
    if ((int )mech->mech_type == 6) {
#line 1100
      goto __Cont;
    }
    {
#line 1102
    data = SPF_mech_data(mech);
#line 1103
    data_end = SPF_mech_end_data(mech);
    }
#line 1104
    if ((unsigned long )data == (unsigned long )data_end) {
#line 1105
      goto __Cont;
    }
#line 1107
    if ((int )data->dc.parm_type == 11) {
      {
#line 1109
      data = SPF_data_next(data);
      }
#line 1110
      if ((unsigned long )data == (unsigned long )data_end) {
#line 1111
        goto __Cont;
      }
    }
#line 1115
    found_valid_tld = 0;
#line 1116
    found_non_ip = 0;
#line 1118
    d = data;
    {
#line 1118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1118
      if (! ((unsigned long )d < (unsigned long )data_end)) {
#line 1118
        goto while_break___0;
      }
      {
#line 1122
      if ((int )d->dv.parm_type == 11) {
#line 1122
        goto case_11;
      }
#line 1128
      if ((int )d->dv.parm_type == 0) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 5) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 4) {
#line 1128
        goto case_0;
      }
#line 1132
      if ((int )d->dv.parm_type == 12) {
#line 1132
        goto case_12;
      }
#line 1148
      goto switch_default;
      case_11: /* CIL Label */ 
      {
#line 1123
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1123, "%s", "Multiple CIDR parameters found");
      }
#line 1124
      goto switch_break;
      case_0: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 1129
      found_valid_tld = 0;
#line 1130
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 1133
      found_valid_tld = 0;
#line 1135
      s = SPF_data_str(d);
#line 1136
      s_end = s + (int )d->ds.len;
      }
      {
#line 1137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1137
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 1137
          goto while_break___1;
        }
        {
#line 1138
        tmp = __ctype_b_loc();
        }
#line 1138
        if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 2048)) {
#line 1138
          if ((int )*s != 46) {
#line 1138
            if ((int )*s != 58) {
#line 1139
              found_non_ip = 1;
            }
          }
        }
#line 1141
        if ((int )*s == 46) {
#line 1142
          found_valid_tld = 1;
        } else {
          {
#line 1143
          tmp___0 = __ctype_b_loc();
          }
#line 1143
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 1024)) {
#line 1144
            found_valid_tld = 0;
          }
        }
#line 1137
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1146
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1149
      found_non_ip = 1;
#line 1150
      found_valid_tld = 1;
#line 1152
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1118
      d = SPF_data_next(d);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1156
    if (! found_valid_tld) {
#line 1156
      goto _L___0;
    } else
#line 1156
    if (! found_non_ip) {
      _L___0: /* CIL Label */ 
#line 1157
      if (! found_non_ip) {
        {
#line 1158
        SPF_response_add_warn(spf_response, (SPF_errcode_t )27, "Invalid hostname (an IP address?)");
        }
      } else
#line 1160
      if (! found_valid_tld) {
        {
#line 1161
        SPF_response_add_warn(spf_response, (SPF_errcode_t )28, "Hostname has a missing or invalid TLD");
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 1076
    i ++;
#line 1076
    mech = SPF_mech_next(mech);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1168
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c"
static SPF_errcode_t SPF_record_find_mod_data___1(SPF_record_t *spf_record , char const   *mod_name ,
                                                  SPF_data_t **datap , size_t *datalenp ) 
{ 
  SPF_mod_t *mod ;
  size_t name_len ;
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 89
  name_len = strlen(mod_name);
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 94, "%s", "spf_record is NULL");
      }
    }
#line 94
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if ((unsigned long )mod_name == (unsigned long )((void *)0)) {
      {
#line 95
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 95, "%s", "mod_name is NULL");
      }
    }
#line 95
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )datap == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 96, "%s", "datap is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 97
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 97
    if ((unsigned long )datalenp == (unsigned long )((void *)0)) {
      {
#line 97
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 97, "%s", "datalenp is NULL");
      }
    }
#line 97
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 103
  mod = spf_record->mod_first;
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 104
    if (! (i < (int )spf_record->num_mod)) {
#line 104
      goto while_break___3;
    }
#line 105
    if (name_len == (size_t )mod->name_len) {
      {
#line 105
      tmp = SPF_mod_name(mod);
#line 105
      tmp___0 = strncasecmp((char const   *)tmp, mod_name, name_len);
      }
#line 105
      if (tmp___0 == 0) {
        {
#line 108
        *datap = SPF_mod_data(mod);
#line 109
        *datalenp = (size_t )mod->data_len;
        }
#line 111
        return ((SPF_errcode_t )0);
      }
    }
    {
#line 114
    mod = SPF_mod_next(mod);
#line 104
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 117
  return ((SPF_errcode_t )24);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static struct res_sym  const  ns_sects___3[4]  = {      {0, (char *)"QUESTION", (char *)"Question"}, 
        {1, (char *)"ANSWER", (char *)"Answer"}, 
        {2, (char *)"AUTHORITY", (char *)"Authority"}, 
        {3, (char *)"ADDITIONAL", (char *)"Additional"}};
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static int const   num_ns_sect___3  =    (int const   )(sizeof(ns_sects___3) / sizeof(ns_sects___3[0]));
#line 89 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_once_t res_state_control___3  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_key_t res_state_key___3  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_thread_term___3(void *arg ) 
{ 


  {
  {
#line 98
  __res_nclose((struct __res_state *)arg);
#line 100
  free(arg);
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_init_key___3(void) 
{ 


  {
  {
#line 106
  pthread_key_create(& res_state_key___3, & SPF_dns_resolv_thread_term___3);
  }
#line 107
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_debug___3(SPF_dns_server_t *spf_dns_server , ns_rr rr ,
                                     u_char const   *responsebuf , size_t responselen ,
                                     u_char const   *rdata , size_t rdlen ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char name_buf[1025] ;
  int prio ;
  int err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  u_int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 123
  if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 123
    goto case_1;
  }
#line 132
  if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 132
    goto case_28;
  }
#line 141
  if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 141
    goto case_2;
  }
#line 153
  if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 153
    goto case_5;
  }
#line 165
  if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 165
    goto case_15;
  }
#line 182
  if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 182
    goto case_16;
  }
#line 193
  if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 193
    goto case_12;
  }
#line 205
  goto switch_default;
  case_1: /* CIL Label */ 
#line 124
  if (rdlen != 4UL) {
    {
#line 125
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               125, "A: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 127
    tmp = inet_ntop(2, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip4_buf),
                    (socklen_t )sizeof(ip4_buf));
#line 127
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               129, "A: %s", tmp);
    }
  }
#line 130
  goto switch_break;
  case_28: /* CIL Label */ 
#line 133
  if (rdlen != 16UL) {
    {
#line 134
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               134, "AAAA: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 136
    tmp___0 = inet_ntop(10, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip6_buf),
                        (socklen_t )sizeof(ip6_buf));
#line 136
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               138, "AAAA: %s", tmp___0);
    }
  }
#line 139
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 142
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 146
  if (err < 0) {
    {
#line 147
    tmp___1 = __errno_location();
#line 147
    tmp___2 = __errno_location();
#line 147
    tmp___3 = strerror(*tmp___2);
#line 147
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               148, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___3,
               *tmp___1);
    }
  } else {
    {
#line 150
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               150, "NS: %s", name_buf);
    }
  }
#line 151
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 154
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 158
  if (err < 0) {
    {
#line 159
    tmp___4 = __errno_location();
#line 159
    tmp___5 = __errno_location();
#line 159
    tmp___6 = strerror(*tmp___5);
#line 159
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               160, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___6,
               *tmp___4);
    }
  } else {
    {
#line 162
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               162, "CNAME: %s", name_buf);
    }
  }
#line 163
  goto switch_break;
  case_15: /* CIL Label */ 
#line 166
  if (rdlen < 2UL) {
    {
#line 167
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               167, "MX: rdlen too short: %lu", rdlen);
    }
#line 168
    goto switch_break;
  }
  {
#line 170
  tmp___7 = ns_get16(rdata);
#line 170
  prio = (int )tmp___7;
#line 171
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata + 2, name_buf,
                           sizeof(name_buf));
  }
#line 175
  if (err < 0) {
    {
#line 176
    tmp___8 = __errno_location();
#line 176
    tmp___9 = __errno_location();
#line 176
    tmp___10 = strerror(*tmp___9);
#line 176
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               177, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___10,
               *tmp___8);
    }
  } else {
    {
#line 179
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               179, "MX: %d %s", prio, name_buf);
    }
  }
#line 180
  goto switch_break;
  case_16: /* CIL Label */ 
#line 183
  if (rdlen < 1UL) {
    {
#line 184
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               184, "TXT: rdlen too short: %lu", rdlen);
    }
#line 185
    goto switch_break;
  }
  {
#line 189
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             190, "TXT: (%lu) \"%.*s\"", rdlen, (int )rdlen - 1, rdata + 1);
  }
#line 191
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 194
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 198
  if (err < 0) {
    {
#line 199
    tmp___11 = __errno_location();
#line 199
    tmp___12 = __errno_location();
#line 199
    tmp___13 = strerror(*tmp___12);
#line 199
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               200, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___13,
               *tmp___11);
    }
  } else {
    {
#line 202
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               202, "PTR: %s", name_buf);
    }
  }
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 206
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             206, "not parsed:  type: %d", (unsigned int )((ns_type )((int )rr.type)));
  }
#line 207
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static SPF_dns_rr_t *SPF_dns_resolv_lookup___3(SPF_dns_server_t *spf_dns_server ,
                                               char const   *domain , ns_type rr_type ,
                                               int should_cache ) 
{ 
  SPF_dns_rr_t *spfrr ;
  int err ;
  int i ;
  int nrec ;
  int cnt ;
  u_char *responsebuf ;
  size_t responselen ;
  ns_msg ns_handle ;
  ns_rr rr ;
  int ns_sect___0 ;
  char name_buf[1025] ;
  size_t rdlen ;
  u_char const   *rdata ;
  void *res_spec ;
  struct __res_state *res_state___0 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int dns_len ;
  char const   *tmp___2 ;
  SPF_dns_rr_t *tmp___3 ;
  SPF_dns_rr_t *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  SPF_errcode_t tmp___20 ;
  SPF_errcode_t tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  SPF_errcode_t tmp___26 ;
  u_char *src ;
  u_char *dst ;
  size_t len ;
  SPF_errcode_t tmp___27 ;
  SPF_errcode_t tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  SPF_errcode_t tmp___33 ;

  {
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 247
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 247, "%s", "spf_dns_server is NULL");
      }
    }
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  res_spec = pthread_getspecific(res_state_key___3);
  }
#line 252
  if ((unsigned long )res_spec == (unsigned long )((void *)0)) {
    {
#line 253
    tmp = malloc(sizeof(struct __res_state ));
#line 253
    res_state___0 = (struct __res_state *)tmp;
    }
#line 257
    if (! res_state___0) {
      {
#line 258
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 259, "Failed to allocate %lu bytes for res_state", sizeof(struct __res_state ));
      }
    }
    {
#line 260
    memset((void *)res_state___0, 0, sizeof(struct __res_state ));
#line 261
    tmp___0 = __res_ninit(res_state___0);
    }
#line 261
    if (tmp___0 != 0) {
      {
#line 262
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 262, "%s", "Failed to call res_ninit()");
      }
    }
    {
#line 263
    pthread_setspecific(res_state_key___3, (void const   *)((void *)res_state___0));
    }
  } else {
#line 266
    res_state___0 = (struct __res_state *)res_spec;
  }
  {
#line 270
  responselen = (size_t )2048;
#line 271
  tmp___1 = malloc(responselen);
#line 271
  responsebuf = (u_char *)tmp___1;
  }
#line 272
  if (! responsebuf) {
#line 273
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 274
  memset((void *)responsebuf, 0, responselen);
  }
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 297
    dns_len = __res_nquery(res_state___0, domain, 1, (int )rr_type, responsebuf, (int )responselen);
    }
#line 304
    if (dns_len < 0) {
      {
#line 307
      free((void *)responsebuf);
      }
#line 308
      if (spf_dns_server->debug) {
        {
#line 309
        tmp___2 = hstrerror(res_state___0->res_h_errno);
#line 309
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   311, "query failed: err = %d  %s (%d): %s", dns_len, tmp___2, res_state___0->res_h_errno,
                   domain);
        }
      }
#line 312
      if (res_state___0->res_h_errno == 1) {
#line 312
        if ((unsigned long )spf_dns_server->layer_below != (unsigned long )((void *)0)) {
          {
#line 314
          tmp___3 = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
          }
#line 314
          return (tmp___3);
        }
      }
      {
#line 317
      tmp___4 = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, res_state___0->res_h_errno);
      }
#line 317
      return (tmp___4);
    } else
#line 320
    if ((size_t )dns_len > responselen) {
      {
#line 323
      responselen = (size_t )(dns_len + (dns_len >> 1));
#line 332
      tmp___5 = realloc((void *)responsebuf, responselen);
      }
#line 333
      if (! tmp___5) {
        {
#line 334
        free((void *)responsebuf);
        }
#line 335
        return ((SPF_dns_rr_t *)((void *)0));
      }
#line 337
      responsebuf = (u_char *)tmp___5;
    } else {
#line 341
      responselen = (size_t )dns_len;
#line 342
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 351
  spfrr = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, 0);
  }
#line 353
  if (! spfrr) {
    {
#line 354
    free((void *)responsebuf);
    }
#line 355
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 358
  err = ns_initparse((u_char const   *)responsebuf, (int )responselen, & ns_handle);
  }
#line 360
  if (err < 0) {
#line 361
    if (spf_dns_server->debug) {
      {
#line 362
      tmp___6 = __errno_location();
#line 362
      tmp___7 = __errno_location();
#line 362
      tmp___8 = strerror(*tmp___7);
#line 362
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 363, "ns_initparse failed: err = %d  %s (%d)", err, tmp___8, *tmp___6);
      }
    }
    {
#line 364
    free((void *)responsebuf);
#line 367
    spfrr->herrno = 3;
    }
#line 368
    return (spfrr);
  }
#line 372
  if (spf_dns_server->debug > 1) {
    {
#line 373
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               373, "msg id:             %d", (int )ns_handle._id);
#line 374
    tmp___9 = ns_msg_getflag(ns_handle, 0);
#line 374
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               374, "ns_f_qr quest/resp: %d", tmp___9);
#line 375
    tmp___10 = ns_msg_getflag(ns_handle, 1);
#line 375
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               375, "ns_f_opcode:        %d", tmp___10);
#line 376
    tmp___11 = ns_msg_getflag(ns_handle, 2);
#line 376
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               376, "ns_f_aa auth ans:   %d", tmp___11);
#line 377
    tmp___12 = ns_msg_getflag(ns_handle, 3);
#line 377
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               377, "ns_f_tc truncated:  %d", tmp___12);
#line 378
    tmp___13 = ns_msg_getflag(ns_handle, 4);
#line 378
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               378, "ns_f_rd rec desire: %d", tmp___13);
#line 379
    tmp___14 = ns_msg_getflag(ns_handle, 5);
#line 379
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               379, "ns_f_ra rec avail:  %d", tmp___14);
#line 380
    tmp___15 = ns_msg_getflag(ns_handle, 9);
#line 380
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               380, "ns_f_rcode:         %d", tmp___15);
    }
  }
#line 385
  ns_sect___0 = 0;
  {
#line 385
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 385
    if (! (ns_sect___0 < (int )num_ns_sect___3)) {
#line 385
      goto while_break___1;
    }
#line 391
    if (ns_sects___3[ns_sect___0].number != 1) {
#line 391
      if (spf_dns_server->debug <= 1) {
#line 392
        goto __Cont;
      }
    }
#line 394
    nrec = (int )ns_handle._counts[ns_sects___3[ns_sect___0].number];
#line 396
    if (spf_dns_server->debug > 1) {
      {
#line 397
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 397, "%s:  %d", ns_sects___3[ns_sect___0].name, nrec);
      }
    }
#line 399
    spfrr->num_rr = 0;
#line 400
    cnt = 0;
#line 401
    i = 0;
    {
#line 401
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 401
      if (! (i < nrec)) {
#line 401
        goto while_break___2;
      }
      {
#line 402
      err = ns_parserr(& ns_handle, (ns_sect )ns_sects___3[ns_sect___0].number, i,
                       & rr);
      }
#line 403
      if (err < 0) {
#line 404
        if (spf_dns_server->debug > 1) {
          {
#line 405
          tmp___16 = __errno_location();
#line 405
          tmp___17 = __errno_location();
#line 405
          tmp___18 = strerror(*tmp___17);
#line 405
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     406, "ns_parserr failed: err = %d  %s (%d)", err, tmp___18, *tmp___16);
          }
        }
        {
#line 407
        free((void *)responsebuf);
#line 410
        spfrr->herrno = 3;
        }
#line 411
        return (spfrr);
      }
#line 414
      rdlen = (size_t )((int )rr.rdlength);
#line 415
      if (spf_dns_server->debug > 1) {
#line 416
        if ((int )rr.name[0] != 0) {
#line 416
          tmp___19 = (char const   *)(rr.name);
        } else {
#line 416
          tmp___19 = ".";
        }
        {
#line 416
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   418, "name: %s  type: %d  class: %d  ttl: %d  rdlen: %lu", tmp___19,
                   (unsigned int )((ns_type )((int )rr.type)), (unsigned int )((ns_class )((int )rr.rr_class)),
                   rr.ttl, rdlen);
        }
      }
#line 420
      if (rdlen <= 0UL) {
#line 421
        goto __Cont___0;
      }
#line 423
      rdata = rr.rdata + 0;
#line 425
      if (spf_dns_server->debug > 1) {
        {
#line 426
        SPF_dns_resolv_debug___3(spf_dns_server, rr, (u_char const   *)responsebuf,
                                 responselen, rdata, rdlen);
        }
      }
#line 430
      if (ns_sects___3[ns_sect___0].number != 1) {
#line 431
        goto __Cont___0;
      }
#line 434
      if ((unsigned int )((ns_type )((int )rr.type)) != (unsigned int )spfrr->rr_type) {
#line 434
        if ((unsigned int )((ns_type )((int )rr.type)) != 5U) {
          {
#line 435
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     436, "unexpected rr type: %d   expected: %d", (unsigned int )((ns_type )((int )rr.type)),
                     (unsigned int )rr_type);
          }
#line 437
          goto __Cont___0;
        }
      }
      {
#line 441
      if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 441
        goto case_1;
      }
#line 458
      if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 458
        goto case_28;
      }
#line 475
      if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 475
        goto case_2;
      }
#line 478
      if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 478
        goto case_5;
      }
#line 482
      if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 482
        goto case_15;
      }
#line 513
      if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 513
        goto case_16;
      }
#line 562
      if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 562
        goto case_12;
      }
#line 588
      goto switch_default;
      case_1: /* CIL Label */ 
#line 442
      if (rdlen != 4UL) {
        {
#line 444
        free((void *)responsebuf);
        }
#line 445
        return (spfrr);
      }
      {
#line 447
      tmp___20 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->a));
      }
#line 447
      if ((unsigned int )tmp___20 != 0U) {
        {
#line 449
        free((void *)responsebuf);
        }
#line 452
        return (spfrr);
      }
      {
#line 454
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->a), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->a));
#line 455
      cnt ++;
      }
#line 456
      goto switch_break;
      case_28: /* CIL Label */ 
#line 459
      if (rdlen != 16UL) {
        {
#line 461
        free((void *)responsebuf);
        }
#line 462
        return (spfrr);
      }
      {
#line 464
      tmp___21 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->aaaa));
      }
#line 464
      if ((unsigned int )tmp___21 != 0U) {
        {
#line 466
        free((void *)responsebuf);
        }
#line 469
        return (spfrr);
      }
      {
#line 471
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->aaaa), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->aaaa));
#line 472
      cnt ++;
      }
#line 473
      goto switch_break;
      case_2: /* CIL Label */ 
#line 476
      goto switch_break;
      case_5: /* CIL Label */ 
#line 480
      goto switch_break;
      case_15: /* CIL Label */ 
#line 483
      if (rdlen < 2UL) {
        {
#line 485
        free((void *)responsebuf);
        }
#line 486
        return (spfrr);
      }
      {
#line 488
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata + 2, name_buf, sizeof(name_buf));
      }
#line 492
      if (err < 0) {
#line 493
        if (spf_dns_server->debug > 1) {
          {
#line 494
          tmp___22 = __errno_location();
#line 494
          tmp___23 = __errno_location();
#line 494
          tmp___24 = strerror(*tmp___23);
#line 494
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     495, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___24,
                     *tmp___22);
          }
        }
        {
#line 496
        free((void *)responsebuf);
        }
#line 499
        return (spfrr);
      }
      {
#line 502
      tmp___25 = strlen((char const   *)(name_buf));
#line 502
      tmp___26 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___25 + 1UL);
      }
#line 502
      if ((unsigned int )tmp___26 != 0U) {
        {
#line 504
        free((void *)responsebuf);
        }
#line 507
        return (spfrr);
      }
      {
#line 509
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->mx), (char const   */* __restrict  */)(name_buf));
#line 510
      cnt ++;
      }
#line 511
      goto switch_break;
      case_16: /* CIL Label */ 
#line 514
      if (rdlen > 1UL) {
        {
#line 520
        tmp___27 = SPF_dns_rr_buf_realloc(spfrr, cnt, rdlen);
        }
#line 520
        if ((unsigned int )tmp___27 != 0U) {
          {
#line 521
          free((void *)responsebuf);
          }
#line 524
          return (spfrr);
        }
#line 527
        dst = (u_char *)((*(spfrr->rr + cnt))->txt);
#line 528
        src = (u_char *)rdata;
#line 529
        len = (size_t )0;
        {
#line 530
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 530
          if (! (rdlen > 0UL)) {
#line 530
            goto while_break___3;
          }
#line 532
          len = (size_t )*src;
#line 533
          src ++;
#line 534
          rdlen --;
#line 538
          if (len > rdlen) {
#line 539
            len = rdlen;
          }
          {
#line 540
          memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src,
                 len);
#line 543
          src += len;
#line 544
          dst += len;
#line 545
          rdlen -= len;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 547
        *dst = (u_char )'\000';
      } else {
        {
#line 550
        tmp___28 = SPF_dns_rr_buf_realloc(spfrr, cnt, (size_t )1);
        }
#line 550
        if ((unsigned int )tmp___28 != 0U) {
          {
#line 551
          free((void *)responsebuf);
          }
#line 554
          return (spfrr);
        }
#line 556
        (*(spfrr->rr + cnt))->txt[0] = (char )'\000';
      }
#line 559
      cnt ++;
#line 560
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 563
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata, name_buf, sizeof(name_buf));
      }
#line 567
      if (err < 0) {
#line 568
        if (spf_dns_server->debug > 1) {
          {
#line 569
          tmp___29 = __errno_location();
#line 569
          tmp___30 = __errno_location();
#line 569
          tmp___31 = strerror(*tmp___30);
#line 569
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     570, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___31,
                     *tmp___29);
          }
        }
        {
#line 571
        free((void *)responsebuf);
        }
#line 574
        return (spfrr);
      }
      {
#line 577
      tmp___32 = strlen((char const   *)(name_buf));
#line 577
      tmp___33 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___32 + 1UL);
      }
#line 577
      if ((unsigned int )tmp___33 != 0U) {
        {
#line 579
        free((void *)responsebuf);
        }
#line 582
        return (spfrr);
      }
      {
#line 584
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->ptr), (char const   */* __restrict  */)(name_buf));
#line 585
      cnt ++;
      }
#line 586
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 589
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 401
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 593
    spfrr->num_rr = cnt;
    __Cont: /* CIL Label */ 
#line 385
    ns_sect___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 596
  if (spfrr->num_rr == 0) {
#line 597
    spfrr->herrno = 4;
  }
  {
#line 599
  free((void *)responsebuf);
  }
#line 600
  return (spfrr);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_free___3(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 607
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 607, "%s", "spf_dns_server is NULL");
      }
    }
#line 607
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  free((void *)spf_dns_server);
  }
#line 614
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
static SPF_dns_test_data_t const   SPF_dns_db___4[175]  = 
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
  {      {"localhost", 1, 0, "127.0.0.1"}, 
        {"example.com", 1, 0, "192.0.2.3"}, 
        {"example.com", 15, 0, "mx.example.org"}, 
        {"example.com", 16, 0, "v=spf1 mx -all"}, 
        {"3.2.0.192.in-addr.arpa", 12, 0, "mx.example.org"}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}, 
        {"noexist.example.com", 1, 1, (char const   *)((void *)0)}, 
        {"mx.example.org", 1, 0, "192.0.2.3"}, 
        {"mx.example.org", 28, 0, "5f05:2000:80ad:5800::1"}, 
        {"email.example.com", 16, 0, "v=spf1 -all"}, 
        {"*.example.com", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.org", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.net", 255, 1, (char const   *)((void *)0)}, 
        {"01.spf1-test.mailzone.com", 16, 0, "v=spf1                                                             "}, 
        {"02.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             -all       "}, 
        {"03.spf1-test.mailzone.com", 16, 0, "v=spf1                                             ~all"}, 
        {"05.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             default=deny   "}, 
        {"06.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             ?all "}, 
        {"07.spf1-test.mailzone.com", 16, 0, "v=spf2                                             default=bogus   "}, 
        {"08.spf1-test.mailzone.com",
      16, 0, "v=spf1                       -all      ?all  "}, 
        {"09.spf1-test.mailzone.com", 16, 0, "v=spf1    scope=header-from scope=envelope         -all  "}, 
        {"10.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx                                          -all"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"11.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"13.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"20.spf1-test.mailzone.com", 1, 0, "192.0.2.120"}, 
        {"20.spf1-test.mailzone.com", 16, 0, "v=spf1 a                                           -all"}, 
        {"21.spf1-test.mailzone.com",
      16, 0, "v=spf1   a:spf1-test.mailzone.com                            -all"}, 
        {"21.spf1-test.mailzone.com",
      1, 0, "192.0.2.121"}, 
        {"22.spf1-test.mailzone.com", 16, 0, "v=spf1 a a:spf1-test.mailzone.com                            -all"}, 
        {"22.spf1-test.mailzone.com",
      1, 0, "192.0.2.122"}, 
        {"30.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr                                         -all"}, 
        {"30.spf1-test.mailzone.com",
      1, 0, "208.210.124.130"}, 
        {"31.spf1-test.mailzone.com", 16, 0, "v=spf1     ptr:spf1-test.mailzone.com                        -all"}, 
        {"31.spf1-test.mailzone.com",
      1, 0, "208.210.124.131"}, 
        {"32.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr ptr:spf1-test.mailzone.com                        -all"}, 
        {"32.spf1-test.mailzone.com",
      1, 0, "208.210.124.132"}, 
        {"40.spf1-test.mailzone.com", 16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d}                    -all"}, 
        {"41.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.spf1-test.mailzone.com            -all"}, 
        {"42.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d} exists:%{ir}.%{v}._spf.%{d3} -all"}, 
        {"45.spf1-test.mailzone.com",
      16, 0, "v=spf1 -a a:spf1-test.mailzone.com                           -all"}, 
        {"45.spf1-test.mailzone.com",
      1, 0, "192.0.2.147"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.145"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.146"}, 
        {"50.spf1-test.mailzone.com", 16, 0, "v=spf1 include                                     -all"}, 
        {"51.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"52.spf1-test.mailzone.com", 16, 0, "v=spf1 include:53.spf1-test.mailzone.com                  -all"}, 
        {"53.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"54.spf1-test.mailzone.com", 16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"55.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:56.spf1-test.mailzone.com                  -all"}, 
        {"57.spf1-test.mailzone.com", 16, 0, "v=spf1 include:spf1-test.mailzone.com         -all"}, 
        {"58.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:59.spf1-test.mailzone.com                  -all"}, 
        {"59.spf1-test.mailzone.com", 16, 0, "v=spf1 include:58.spf1-test.mailzone.com                  -all"}, 
        {"70.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{lr+=}.lp._spf.spf1-test.mailzone.com -all"}, 
        {"80.spf1-test.mailzone.com", 16, 0, "v=spf1 a mx exists:%{ir}.%{v}._spf.80.spf1-test.mailzone.com ptr -all"}, 
        {"80.spf1-test.mailzone.com",
      1, 0, "208.210.124.180"}, 
        {"90.spf1-test.mailzone.com", 16, 0, "v=spf1  ip4:192.0.2.128/25 -all"}, 
        {"91.spf1-test.mailzone.com", 16, 0, "v=spf1 -ip4:192.0.2.128/25 ip4:192.0.2.0/24 -all"}, 
        {"92.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?ip4:192.0.2.192/26 ip4:192.0.2.128/25 -ip4:192.0.2.0/24 -all"}, 
        {"95.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -all"}, 
        {"96.spf1-test.mailzone.com", 16, 0, "v=spf1 -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"97.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"98.spf1-test.mailzone.com",
      16, 0, "v=spf1 a/26 mx/26 -all"}, 
        {"98.spf1-test.mailzone.com", 15, 0, "80.spf1-test.mailzone.com"}, 
        {"98.spf1-test.mailzone.com", 1, 0, "192.0.2.98"}, 
        {"99.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp=99txt.spf1-test.mailzone.com moo"}, 
        {"99txt.spf1-test.mailzone.com",
      16, 0, "u=%{u} s=%{s} d=%{d} t=%{t} h=%{h} i=%{i} %% U=%{U} S=%{S} D=%{D} T=%{T} H=%{H} I=%{I} %% moo"}, 
        {"100.spf1-test.mailzone.com",
      16, 0, "v=spf1      redirect=98.spf1-test.mailzone.com"}, 
        {"101.spf1-test.mailzone.com", 16, 0, "v=spf1 -all redirect=98.spf1-test.mailzone.com"}, 
        {"102.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?all redirect=98.spf1-test.mailzone.com"}, 
        {"103.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=98.%{d3}"}, 
        {"104.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=105.%{d3}"}, 
        {"105.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=106.%{d3}"}, 
        {"106.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=107.%{d3}"}, 
        {"107.spf1-test.mailzone.com", 16, 0, "v=spf1       include:104.%{d3}"}, 
        {"110.spf1-test.mailzone.com", 16, 0, "v=spf1 some:unrecognized=mechanism some=unrecognized:modifier -all"}, 
        {"111.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx -a gpg ~all exp=111txt.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"111txt.2.0.192.in-addr._spf.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"112.spf1-test.mailzone.com",
      16, 0, "v=spf1 a mp3 ~all"}, 
        {"112.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"113.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3: ~all"}, 
        {"113.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114.spf1-test.mailzone.com", 16, 0, "v=spf1 mx -a gpg=test ~all exp=114txt.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com",
      15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114txt.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"115.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3=yes -all"}, 
        {"115.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"116.spf1-test.mailzone.com", 16, 0, "v=spf1 redirect=116rdr.spf1-test.mailzone.com a"}, 
        {"116.spf1-test.mailzone.com",
      1, 0, "192.0.2.200"}, 
        {"116rdr.spf1-test.mailzone.com", 16, 0, "v=spf1 -all"}, 
        {"117.spf1-test.mailzone.com", 16, 0, " v=spf1 +all"}, 
        {"118.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp="}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.10"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.11"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.12"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.13"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.20"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.21"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.22"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.23"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.30"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.31"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.32"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.33"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.40"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.41"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.42"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.43"}, 
        {"56.spf1-test.mailzone.com", 16, 4, (char const   *)((void *)0)}, 
        {"80.spf1-test.mailzone.com", 15, 4, (char const   *)((void *)0)}, 
        {"servfail.spf1-test.mailzone.com", 16, 2, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 1, 0, "208.210.124.192"}, 
        {"spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"fallback-relay.spf1-test.mailzone.com", 15, 0, "mx04.spf1-test.mailzone.com"}, 
        {"www1.cnn.com",
      1, 0, "64.236.24.4"}, 
        {"4.24.236.64.in-addr.arpa", 12, 0, "www1.cnn.com"}, 
        {"130.124.210.208.in-addr.arpa", 12, 0, "30.spf1-test.mailzone.com"}, 
        {"131.124.210.208.in-addr.arpa", 12, 0, "31.spf1-test.mailzone.com"}, 
        {"192.124.210.208.in-addr.arpa", 12, 0, "spf1-test.mailzone.com"}, 
        {"100.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"110.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"111.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"101.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"130.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"131.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"80.2.0.192.in-addr._spf.80.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"96.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"97.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com",
      1, 0, "127.0.0.2"}, 
        {"bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"postmaster.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"2.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.joe.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"102.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"110.2.0.192.in-addr._spf.42.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"131.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"4.24.236.64.in-addr._spf.80.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"droid.lp._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"joe-2.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"moe-1.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"unknown.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"180.124.210.208.in-addr.arpa",
      12, 0, "80.spf1-test.mailzone.com"}, 
        {"80.spf1-test.mailzone.com.whitelist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.124.210.208.in-addr.arpa",
      12, 0, "pobox-gw.icgroup.com"}, 
        {"pobox-gw.icgroup.com", 1, 0, "208.210.124.1"}, 
        {"pobox-gw.icgroup.com.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com",
      16, 1, (char const   *)((void *)0)}, 
        {"spf.trusted-forwarder.org", 16, 0, "v=spf1 exists:%{ir}.wl.trusted-forwarder.org exists:%{p}.wl.trusted-forwarder.org"}, 
        {"*.spf1-text.mailzone.com",
      255, 1, (char const   *)((void *)0)}, 
        {"cat.com", 16, 4, (char const   *)((void *)0)}, 
        {"bar.com", 16, 4, (char const   *)((void *)0)}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}};
#line 41 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static SPF_dns_rr_t *SPF_dns_null_lookup___4(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_rr_t *tmp ;
  SPF_dns_rr_t *tmp___0 ;

  {
#line 45
  if (spf_dns_server->layer_below) {
    {
#line 46
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 46
    return (tmp);
  }
  {
#line 48
  tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
  }
#line 48
  return (tmp___0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static void SPF_dns_null_free___4(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 54
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c",
                 54, "%s", "spf_dns_server is NULL");
      }
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  free((void *)spf_dns_server);
  }
#line 56
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_explanation___4(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  char *buf ;
  size_t buflen ;
  void *tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 53
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 53, "%s", "spf_response is NULL");
      }
    }
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  spf_request = spf_response->spf_request;
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 55
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 55, "%s", "spf_request is NULL");
      }
    }
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  spf_server___1 = spf_request->spf_server;
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 57
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 57
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 57, "%s", "spf_server is NULL");
      }
    }
#line 57
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  spf_record = spf_response->spf_record_exp;
  {
#line 60
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 60
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 60
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 60, "%s", "spf_record is NULL");
      }
    }
#line 60
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 62
  if (spf_response->explanation) {
    {
#line 63
    free((void *)spf_response->explanation);
    }
  }
  {
#line 64
  spf_response->explanation = (char *)((void *)0);
#line 66
  buflen = (size_t )321;
#line 67
  tmp = malloc(buflen);
#line 67
  buf = (char *)tmp;
  }
#line 68
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 69
    return ((SPF_errcode_t )1);
  }
  {
#line 70
  memset((void *)buf, '\000', buflen);
#line 72
  err = SPF_request_get_exp(spf_server___1, spf_request, spf_response, spf_record,
                            & buf, & buflen);
  }
#line 74
  if ((unsigned int )err != 0U) {
    {
#line 75
    free((void *)buf);
    }
#line 76
    return (err);
  }
#line 79
  spf_response->explanation = buf;
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_smtp_comment___4(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_errcode_t err ;
  char buf[320] ;
  char const   *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 92
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 92, "%s", "spf_response is NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  spf_request = spf_response->spf_request;
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 94, "%s", "spf_request is NULL");
      }
    }
#line 94
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  spf_server___1 = spf_request->spf_server;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 96, "%s", "spf_server is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  if (spf_response->smtp_comment) {
    {
#line 99
    free((void *)spf_response->smtp_comment);
    }
  }
#line 100
  spf_response->smtp_comment = (char *)((void *)0);
  {
#line 107
  if ((unsigned int )spf_response->result == 5U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 1U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 4U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 3U) {
#line 107
    goto case_5;
  }
#line 129
  goto switch_default;
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 109
  err = SPF_i_set_explanation___4(spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
#line 111
    return (err);
  }
  {
#line 113
  memset((void *)(buf), '\000', sizeof(buf));
#line 114
  tmp = SPF_strreason(spf_response->reason);
#line 114
  snprintf((char */* __restrict  */)(buf), (size_t )320, (char const   */* __restrict  */)"%s : Reason: %s",
           spf_response->explanation, tmp);
#line 117
  buf[319] = (char )'\000';
#line 120
  spf_response->smtp_comment = strdup((char const   *)(buf));
  }
#line 121
  if (! spf_response->smtp_comment) {
#line 122
    return ((SPF_errcode_t )1);
  }
#line 124
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 130
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 133
  return ((SPF_errcode_t )0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_header_comment___4(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char *spf_source ;
  size_t len ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  char *sender_dom ;
  char *p ;
  char *p_end ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 153
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 153, "%s", "spf_response is NULL");
      }
    }
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  spf_request = spf_response->spf_request;
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 155
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 155, "%s", "spf_request is NULL");
      }
    }
#line 155
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 156
  spf_server___1 = spf_request->spf_server;
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 157
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 157, "%s", "spf_server is NULL");
      }
    }
#line 157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 159
  if (spf_response->header_comment) {
    {
#line 160
    free((void *)spf_response->header_comment);
    }
  }
#line 161
  spf_response->header_comment = (char *)((void *)0);
#line 164
  sender_dom = spf_request->env_from_dp;
#line 165
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
#line 166
    sender_dom = spf_request->helo_dom;
  }
#line 168
  if ((unsigned int )spf_response->reason == 3U) {
    {
#line 169
    spf_source = strdup("local policy");
    }
  } else
#line 171
  if ((unsigned int )spf_response->reason == 6U) {
#line 172
    if ((unsigned long )spf_request->rcpt_to_dom == (unsigned long )((void *)0)) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    } else
#line 172
    if ((int )*(spf_request->rcpt_to_dom + 0) == 0) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    }
    {
#line 175
    spf_source = strdup((char const   *)spf_request->rcpt_to_dom);
    }
  } else
#line 177
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
    {
#line 178
    spf_source = strdup("unknown domain");
    }
  } else {
    {
#line 181
    tmp = strlen((char const   *)sender_dom);
#line 181
    len = tmp + sizeof("domain of ");
#line 182
    tmp___0 = malloc(len);
#line 182
    spf_source = (char *)tmp___0;
    }
#line 183
    if (spf_source) {
      {
#line 184
      snprintf((char */* __restrict  */)spf_source, len, (char const   */* __restrict  */)"domain of %s",
               sender_dom);
      }
    }
  }
#line 187
  if ((unsigned long )spf_source == (unsigned long )((void *)0)) {
#line 188
    return ((SPF_errcode_t )10);
  }
#line 190
  ip = (char const   *)((void *)0);
#line 191
  if (spf_request->client_ver == 2) {
    {
#line 192
    ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                   (socklen_t )sizeof(ip4_buf));
    }
  } else
#line 195
  if (spf_request->client_ver == 10) {
    {
#line 196
    ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                   (socklen_t )sizeof(ip6_buf));
    }
  }
#line 199
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 200
    ip = "(unknown ip address)";
  }
  {
#line 202
  tmp___1 = SPF_request_get_rec_dom(spf_request);
#line 202
  tmp___2 = strlen(tmp___1);
#line 202
  tmp___3 = strlen((char const   *)spf_source);
#line 202
  tmp___4 = strlen(ip);
#line 202
  len = ((tmp___2 + tmp___3) + tmp___4) + 80UL;
#line 203
  tmp___5 = malloc(len);
#line 203
  buf = (char *)tmp___5;
  }
#line 204
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 205
    free((void *)spf_source);
    }
#line 206
    return ((SPF_errcode_t )10);
  }
  {
#line 209
  p = buf;
#line 210
  p_end = p + len;
#line 213
  tmp___6 = SPF_request_get_rec_dom(spf_request);
#line 213
  tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s: ",
                     tmp___6);
#line 213
  p += tmp___7;
  }
  {
#line 217
  if ((unsigned int )spf_response->result == 2U) {
#line 217
    goto case_2;
  }
#line 228
  if ((unsigned int )spf_response->result == 3U) {
#line 228
    goto case_3;
  }
#line 233
  if ((unsigned int )spf_response->result == 4U) {
#line 233
    goto case_4;
  }
#line 238
  if ((unsigned int )spf_response->result == 7U) {
#line 238
    goto case_7;
  }
#line 243
  if ((unsigned int )spf_response->result == 1U) {
#line 243
    goto case_1;
  }
#line 247
  if ((unsigned int )spf_response->result == 5U) {
#line 247
    goto case_5;
  }
#line 252
  if ((unsigned int )spf_response->result == 6U) {
#line 252
    goto case_6;
  }
#line 258
  goto switch_default;
  case_2: /* CIL Label */ 
#line 218
  if ((unsigned int )spf_response->reason == 2U) {
    {
#line 219
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"localhost is always allowed.");
    }
  } else
#line 220
  if ((unsigned int )spf_response->reason == 6U) {
    {
#line 221
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"message received from %s which is an MX secondary for %s.",
             ip, spf_source);
    }
  } else {
    {
#line 224
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s designates %s as permitted sender",
             spf_source, ip);
    }
  }
#line 226
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 229
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 231
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 234
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"transitioning %s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 236
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 239
  tmp___8 = SPF_strerror(spf_response->err);
#line 239
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error in processing during lookup of %s: %s",
           spf_source, tmp___8);
  }
#line 241
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 244
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s is neither permitted nor denied by %s",
           ip, spf_source);
  }
#line 246
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 248
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not provide an SPF record",
           spf_source);
  }
#line 250
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 253
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"encountered temporary error during SPF processing of %s",
           spf_source);
  }
#line 255
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 259
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error: unknown SPF result %d encountered while checking %s for %s",
           (unsigned int )spf_response->result, ip, spf_source);
  }
#line 261
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 264
  if (spf_source) {
    {
#line 265
    free((void *)spf_source);
    }
  }
  {
#line 267
  spf_response->header_comment = SPF_sanitize(spf_server___1, buf);
  }
#line 269
  return ((SPF_errcode_t )0);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_received_spf___4(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  size_t buflen ;
  char *buf_value ;
  char *p ;
  char *p_end ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 282
  buflen = (size_t )480;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 287
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 287, "%s", "spf_response is NULL");
      }
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  spf_request = spf_response->spf_request;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 289
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 289, "%s", "spf_request is NULL");
      }
    }
#line 289
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  spf_server___1 = spf_request->spf_server;
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 291
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 291
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 291, "%s", "spf_server is NULL");
      }
    }
#line 291
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 293
  if (spf_response->received_spf) {
    {
#line 294
    free((void *)spf_response->received_spf);
    }
  }
  {
#line 295
  spf_response->received_spf = (char *)((void *)0);
#line 297
  tmp = malloc(buflen);
#line 297
  buf = (char *)tmp;
  }
#line 298
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 299
    return ((SPF_errcode_t )10);
  }
  {
#line 301
  p = buf;
#line 302
  p_end = p + buflen;
#line 306
  tmp___0 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"Received-SPF: ");
#line 306
  p += tmp___0;
#line 307
  buf_value = p;
  }
  {
#line 309
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 310
    tmp___1 = SPF_strresult(spf_response->result);
#line 310
    tmp___2 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s (%s)",
                       tmp___1, spf_response->header_comment);
#line 310
    p += tmp___2;
    }
#line 313
    if (p_end - p <= 0L) {
#line 313
      goto while_break___2;
    }
#line 318
    ip = (char const   *)((void *)0);
#line 319
    if (spf_request->client_ver == 2) {
      {
#line 320
      ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                     (socklen_t )sizeof(ip4_buf));
      }
    } else
#line 323
    if (spf_request->client_ver == 10) {
      {
#line 324
      ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                     (socklen_t )sizeof(ip6_buf));
      }
    }
#line 328
    if ((unsigned long )ip != (unsigned long )((void *)0)) {
      {
#line 329
      tmp___3 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" client-ip=%s;",
                         ip);
#line 329
      p += tmp___3;
      }
#line 330
      if (p_end - p <= 0L) {
#line 330
        goto while_break___2;
      }
    }
#line 335
    if ((unsigned long )spf_request->env_from != (unsigned long )((void *)0)) {
      {
#line 336
      tmp___4 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" envelope-from=%s;",
                         spf_request->env_from);
#line 336
      p += tmp___4;
      }
#line 337
      if (p_end - p <= 0L) {
#line 337
        goto while_break___2;
      }
    }
#line 342
    if ((unsigned long )spf_request->helo_dom != (unsigned long )((void *)0)) {
      {
#line 343
      tmp___5 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" helo=%s;",
                         spf_request->helo_dom);
#line 343
      p += tmp___5;
      }
#line 344
      if (p_end - p <= 0L) {
#line 344
        goto while_break___2;
      }
    }
#line 309
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 366
  spf_response->received_spf = SPF_sanitize(spf_server___1, buf);
#line 367
  spf_response->received_spf_value = buf_value;
  }
#line 369
  return ((SPF_errcode_t )0);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_mech_cidr___4(SPF_request_t *spf_request , SPF_mech_t *mech ) 
{ 
  SPF_data_t *data ;
  SPF_data_t *tmp ;

  {
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if ((unsigned long )mech == (unsigned long )((void *)0)) {
      {
#line 428
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 428, "%s", "mech is NULL");
      }
    }
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  if ((int )mech->mech_type == 6) {
#line 433
    goto case_6;
  }
#line 433
  if ((int )mech->mech_type == 5) {
#line 433
    goto case_6;
  }
#line 438
  if ((int )mech->mech_type == 2) {
#line 438
    goto case_2;
  }
#line 438
  if ((int )mech->mech_type == 1) {
#line 438
    goto case_2;
  }
#line 430
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 434
  return ((int )mech->mech_len);
#line 435
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 439
  data = SPF_mech_data(mech);
#line 441
  tmp = SPF_mech_end_data(mech);
  }
#line 441
  if ((unsigned long )data < (unsigned long )tmp) {
#line 441
    if ((int )data->dc.parm_type == 11) {
#line 444
      if (spf_request->client_ver == 2) {
#line 445
        return ((int )data->dc.ipv4);
      } else
#line 446
      if (spf_request->client_ver == 10) {
#line 447
        return ((int )data->dc.ipv6);
      }
    }
  }
#line 449
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 452
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip4___4(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in_addr ipv4 ) 
{ 
  char src_ip4_buf[16] ;
  char dst_ip4_buf[16] ;
  char mask_ip4_buf[16] ;
  struct in_addr src_ipv4 ;
  int cidr ;
  int mask ;
  uint32_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 471
  if (spf_request->client_ver != 2) {
#line 472
    return (0);
  }
  {
#line 474
  src_ipv4 = spf_request->ipv4;
#line 476
  cidr = SPF_i_mech_cidr___4(spf_request, mech);
  }
#line 477
  if (cidr == 0) {
#line 478
    cidr = 32;
  }
  {
#line 479
  mask = (int )(4294967295U << (32 - cidr));
#line 480
  tmp = htonl((uint32_t )mask);
#line 480
  mask = (int )tmp;
  }
#line 482
  if (spf_server___1->debug) {
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 483
      tmp___0 = inet_ntop(2, (void const   */* __restrict  */)(& src_ipv4.s_addr),
                          (char */* __restrict  */)(src_ip4_buf), (socklen_t )sizeof(src_ip4_buf));
      }
#line 483
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 483
        snprintf((char */* __restrict  */)(src_ip4_buf), sizeof(src_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 483
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 485
      tmp___1 = inet_ntop(2, (void const   */* __restrict  */)(& ipv4.s_addr), (char */* __restrict  */)(dst_ip4_buf),
                          (socklen_t )sizeof(dst_ip4_buf));
      }
#line 485
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 485
        snprintf((char */* __restrict  */)(dst_ip4_buf), sizeof(dst_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 487
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 487
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& mask), (char */* __restrict  */)(mask_ip4_buf),
                          (socklen_t )sizeof(mask_ip4_buf));
      }
#line 487
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
#line 487
        snprintf((char */* __restrict  */)(mask_ip4_buf), sizeof(mask_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 487
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 489
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               491, "ip_match:  %s == %s  (/%d %s):  %d", src_ip4_buf, dst_ip4_buf,
               cidr, mask_ip4_buf, (src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
    }
  }
#line 494
  return ((src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip6___4(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in6_addr ipv6 ) 
{ 
  char src_ip6_buf[46] ;
  char dst_ip6_buf[46] ;
  struct in6_addr src_ipv6 ;
  int cidr ;
  int cidr_save ;
  int mask ;
  int i ;
  int match ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 512
  if (spf_request->client_ver != 10) {
#line 513
    return (0);
  }
  {
#line 515
  src_ipv6 = spf_request->ipv6;
#line 517
  cidr = SPF_i_mech_cidr___4(spf_request, mech);
  }
#line 518
  if (cidr == 0) {
#line 519
    cidr = 128;
  }
#line 520
  cidr_save = cidr;
#line 522
  match = 1;
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if ((long )i < (long )(sizeof(ipv6.__in6_u.__u6_addr8) / sizeof(ipv6.__in6_u.__u6_addr8[0]))) {
#line 523
      if (! match) {
#line 523
        goto while_break;
      }
    } else {
#line 523
      goto while_break;
    }
#line 525
    if (cidr > 8) {
#line 526
      mask = 255;
    } else
#line 527
    if (cidr > 0) {
#line 528
      mask = (255 << (8 - cidr)) & 255;
    } else {
#line 530
      goto while_break;
    }
#line 531
    cidr -= 8;
#line 533
    match = ((int )src_ipv6.__in6_u.__u6_addr8[i] & mask) == ((int )ipv6.__in6_u.__u6_addr8[i] & mask);
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (spf_server___1->debug) {
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 537
      tmp = inet_ntop(10, (void const   */* __restrict  */)(& src_ipv6.__in6_u.__u6_addr8),
                      (char */* __restrict  */)(src_ip6_buf), (socklen_t )sizeof(src_ip6_buf));
      }
#line 537
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 537
        snprintf((char */* __restrict  */)(src_ip6_buf), sizeof(src_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 537
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 539
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 539
      tmp___0 = inet_ntop(10, (void const   */* __restrict  */)(& ipv6.__in6_u.__u6_addr8),
                          (char */* __restrict  */)(dst_ip6_buf), (socklen_t )sizeof(dst_ip6_buf));
      }
#line 539
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 539
        snprintf((char */* __restrict  */)(dst_ip6_buf), sizeof(dst_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 539
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 541
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               542, "ip_match:  %s == %s  (/%d):  %d", src_ip6_buf, dst_ip6_buf, cidr_save,
               match);
    }
  }
#line 545
  return (match);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_domain___4(SPF_server_t *spf_server___1 , char const   *hostname ,
                                  char const   *domain ) 
{ 
  char const   *hp ;
  size_t hlen ;
  size_t dlen ;
  int tmp ;
  int tmp___0 ;

  {
#line 556
  if (spf_server___1->debug) {
    {
#line 557
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               557, "%s ?=? %s", hostname, domain);
    }
  }
  {
#line 559
  hlen = strlen(hostname);
#line 560
  dlen = strlen(domain);
  }
#line 563
  if (dlen > hlen) {
#line 564
    return (0);
  }
#line 567
  if (dlen == hlen) {
    {
#line 568
    tmp = strcasecmp(hostname, domain);
    }
#line 568
    return (tmp == 0);
  }
#line 571
  hp = hostname + (hlen - dlen);
#line 573
  if ((int const   )*(hp - 1) != 46) {
#line 574
    return (0);
  }
  {
#line 576
  tmp___0 = strcasecmp(hp, domain);
  }
#line 576
  return (tmp___0 == 0);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   spf_mechtypes___4[10]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
  {      {(unsigned char)0, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)1, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)2, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)3, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )0}, 
        {(unsigned char)4, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)5, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)6, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)7, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)8, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)9, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}};
#line 94 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   *SPF_mechtype_find___4(int mech_type ) 
{ 
  size_t i ;

  {
#line 98
  i = (size_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < sizeof(spf_mechtypes___4) / sizeof(spf_mechtypes___4[0]))) {
#line 98
      goto while_break;
    }
#line 99
    if ((int const   )spf_mechtypes___4[i].mech_type == (int const   )mech_type) {
#line 100
      return (& spf_mechtypes___4[i]);
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((SPF_mechtype_t const   *)((void *)0));
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static int ( __attribute__((__warn_unused_result__)) SPF_c_ensure_capacity___4)(void **datap ,
                                                                                size_t *sizep ,
                                                                                size_t length ) 
{ 
  size_t size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 109
  size = *sizep;
#line 110
  if (length > size) {
#line 111
    size = length + length / 4UL;
  }
#line 112
  if (size > *sizep) {
    {
#line 113
    tmp___0 = realloc(*datap, size);
#line 113
    tmp = tmp___0;
    }
#line 114
    if (! tmp) {
#line 115
      return (-1);
    }
#line 117
    *datap = tmp;
#line 118
    *sizep = size;
  }
#line 120
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip6___4(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 144
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 144
  mask = (int )tmp;
  }
#line 146
  if (mask > 128) {
    {
#line 147
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (>128)");
    }
#line 147
    return (tmp___0);
  } else
#line 151
  if (mask == 0) {
    {
#line 152
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (=0)");
    }
#line 152
    return (tmp___1);
  } else
#line 156
  if (mask == 128) {
#line 157
    mask = 0;
  }
#line 160
  *maskp = (unsigned char )mask;
#line 162
  return ((SPF_errcode_t )0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip4___4(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 186
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 186
  mask = (int )tmp;
  }
#line 188
  if (mask > 32) {
    {
#line 189
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (>32)");
    }
#line 189
    return (tmp___0);
  } else
#line 193
  if (mask == 0) {
    {
#line 194
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (=0)");
    }
#line 194
    return (tmp___1);
  } else
#line 198
  if (mask == 32) {
#line 199
    mask = 0;
  }
#line 202
  *maskp = (unsigned char )mask;
#line 204
  return ((SPF_errcode_t )0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr___4(SPF_response_t *spf_response , SPF_data_cidr_t *data ,
                                          char const   *src , size_t *src_len ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 220
  memset((void *)data, 0, sizeof(SPF_data_cidr_t ));
#line 221
  data->parm_type = (unsigned char)11;
#line 227
  idx = *src_len - 1UL;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (idx > 0UL) {
      {
#line 228
      tmp = __ctype_b_loc();
      }
#line 228
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 228
        goto while_break;
      }
    } else {
#line 228
      goto while_break;
    }
#line 229
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (idx < *src_len - 1UL) {
#line 236
    if ((int const   )*(src + idx) == 47) {
#line 237
      if (idx > 0UL) {
#line 237
        if ((int const   )*(src + (idx - 1UL)) == 47) {
          {
#line 239
          err = SPF_c_parse_cidr_ip6___4(spf_response, & data->ipv6, src + idx);
          }
#line 240
          if (err) {
#line 241
            return (err);
          }
#line 243
          *src_len = idx - 1UL;
#line 244
          idx = *src_len - 1UL;
          {
#line 245
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 245
            if (idx > 0UL) {
              {
#line 245
              tmp___0 = __ctype_b_loc();
              }
#line 245
              if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 245
                goto while_break___0;
              }
            } else {
#line 245
              goto while_break___0;
            }
#line 246
            idx --;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 249
          if (idx < *src_len - 1UL) {
#line 249
            if ((int const   )*(src + idx) == 47) {
              {
#line 253
              err = SPF_c_parse_cidr_ip4___4(spf_response, & data->ipv4, src + idx);
              }
#line 254
              if (err) {
#line 255
                return (err);
              }
#line 256
              *src_len = idx;
            }
          }
        } else {
#line 237
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 261
        err = SPF_c_parse_cidr_ip4___4(spf_response, & data->ipv4, src + idx);
        }
#line 262
        if (err) {
#line 263
          return (err);
        }
#line 264
        *src_len = idx;
      }
    }
  }
#line 268
  return ((SPF_errcode_t )0);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_var___4(SPF_response_t *spf_response , SPF_data_var_t *data ,
                                         char const   *src , int is_mod ) 
{ 
  char const   *token ;
  char const   *p ;
  char c ;
  int val ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;
  SPF_errcode_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  SPF_errcode_t tmp___6 ;
  SPF_errcode_t tmp___7 ;

  {
  {
#line 280
  memset((void *)data, 0, sizeof(SPF_data_var_t ));
#line 282
  p = src;
#line 285
  c = (char )*p;
#line 286
  tmp___0 = __ctype_b_loc();
  }
#line 286
  if ((int const   )*(*tmp___0 + (int )((unsigned char )c)) & 256) {
    {
#line 288
    data->url_encode = (unsigned short)1;
#line 289
    tmp = tolower((int )c);
#line 289
    c = (char )tmp;
    }
  } else {
#line 292
    data->url_encode = (unsigned short)0;
  }
  {
#line 302
  if ((int )c == 108) {
#line 302
    goto case_108;
  }
#line 306
  if ((int )c == 115) {
#line 306
    goto case_115;
  }
#line 310
  if ((int )c == 111) {
#line 310
    goto case_111;
  }
#line 314
  if ((int )c == 100) {
#line 314
    goto case_100;
  }
#line 318
  if ((int )c == 105) {
#line 318
    goto case_105;
  }
#line 322
  if ((int )c == 99) {
#line 322
    goto case_99;
  }
#line 327
  if ((int )c == 116) {
#line 327
    goto case_116;
  }
#line 332
  if ((int )c == 112) {
#line 332
    goto case_112;
  }
#line 336
  if ((int )c == 118) {
#line 336
    goto case_118;
  }
#line 340
  if ((int )c == 104) {
#line 340
    goto case_104;
  }
#line 344
  if ((int )c == 114) {
#line 344
    goto case_114;
  }
#line 349
  goto switch_default;
  case_108: /* CIL Label */ 
#line 303
  data->parm_type = (unsigned char)0;
#line 304
  goto switch_break;
  case_115: /* CIL Label */ 
#line 307
  data->parm_type = (unsigned char)1;
#line 308
  goto switch_break;
  case_111: /* CIL Label */ 
#line 311
  data->parm_type = (unsigned char)2;
#line 312
  goto switch_break;
  case_100: /* CIL Label */ 
#line 315
  data->parm_type = (unsigned char)3;
#line 316
  goto switch_break;
  case_105: /* CIL Label */ 
#line 319
  data->parm_type = (unsigned char)4;
#line 320
  goto switch_break;
  case_99: /* CIL Label */ 
#line 323
  if (! is_mod) {
    {
#line 323
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 323
    return (tmp___1);
  }
#line 324
  data->parm_type = (unsigned char)5;
#line 325
  goto switch_break;
  case_116: /* CIL Label */ 
#line 328
  if (! is_mod) {
    {
#line 328
    tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 328
    return (tmp___2);
  }
#line 329
  data->parm_type = (unsigned char)6;
#line 330
  goto switch_break;
  case_112: /* CIL Label */ 
#line 333
  data->parm_type = (unsigned char)7;
#line 334
  goto switch_break;
  case_118: /* CIL Label */ 
#line 337
  data->parm_type = (unsigned char)8;
#line 338
  goto switch_break;
  case_104: /* CIL Label */ 
#line 341
  data->parm_type = (unsigned char)9;
#line 342
  goto switch_break;
  case_114: /* CIL Label */ 
#line 345
  if (! is_mod) {
    {
#line 345
    tmp___3 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 345
    return (tmp___3);
  }
#line 346
  data->parm_type = (unsigned char)10;
#line 347
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 350
  tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                       p, "Unknown variable \'%c\'", (int )c);
  }
#line 350
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
#line 354
  p ++;
#line 355
  token = p;
#line 358
  val = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 359
    tmp___5 = __ctype_b_loc();
    }
#line 359
    if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*p)) & 2048)) {
#line 359
      goto while_break;
    }
#line 361
    val *= 10;
#line 362
    val += (int )((int const   )*p - 48);
#line 363
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (val > 128) {
    {
#line 366
    tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                         token, "Subdomain truncation depth too large");
    }
#line 366
    return (tmp___6);
  } else
#line 365
  if (val <= 0) {
#line 365
    if ((unsigned long )p != (unsigned long )token) {
      {
#line 366
      tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                           token, "Subdomain truncation depth too large");
      }
#line 366
      return (tmp___6);
    }
  }
#line 369
  data->num_rhs = (unsigned char )val;
#line 370
  token = p;
#line 373
  if ((int const   )*p == 114) {
#line 375
    data->rev = (unsigned short)1;
#line 376
    p ++;
  } else {
#line 379
    data->rev = (unsigned short)0;
  }
#line 380
  token = p;
#line 384
  data->delim_dot = (unsigned short)0;
#line 385
  data->delim_dash = (unsigned short)0;
#line 386
  data->delim_plus = (unsigned short)0;
#line 387
  data->delim_equal = (unsigned short)0;
#line 388
  data->delim_bar = (unsigned short)0;
#line 389
  data->delim_under = (unsigned short)0;
#line 392
  if ((int const   )*p == 125) {
#line 393
    data->delim_dot = (unsigned short)1;
  }
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! ((int const   )*p != 125)) {
#line 396
      goto while_break___0;
    }
#line 398
    token = p;
    {
#line 401
    if ((int const   )*p == 46) {
#line 401
      goto case_46;
    }
#line 405
    if ((int const   )*p == 45) {
#line 405
      goto case_45;
    }
#line 409
    if ((int const   )*p == 43) {
#line 409
      goto case_43;
    }
#line 413
    if ((int const   )*p == 61) {
#line 413
      goto case_61;
    }
#line 417
    if ((int const   )*p == 124) {
#line 417
      goto case_124;
    }
#line 421
    if ((int const   )*p == 95) {
#line 421
      goto case_95;
    }
#line 425
    goto switch_default___0;
    case_46: /* CIL Label */ 
#line 402
    data->delim_dot = (unsigned short)1;
#line 403
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 406
    data->delim_dash = (unsigned short)1;
#line 407
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 410
    data->delim_plus = (unsigned short)1;
#line 411
    goto switch_break___0;
    case_61: /* CIL Label */ 
#line 414
    data->delim_equal = (unsigned short)1;
#line 415
    goto switch_break___0;
    case_124: /* CIL Label */ 
#line 418
    data->delim_bar = (unsigned short)1;
#line 419
    goto switch_break___0;
    case_95: /* CIL Label */ 
#line 422
    data->delim_under = (unsigned short)1;
#line 423
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 426
    tmp___7 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )14, (char const   *)((void *)0),
                                         p, "Invalid delimiter \'%c\'", (int const   )*p);
    }
#line 426
    return (tmp___7);
    switch_break___0: /* CIL Label */ ;
    }
#line 430
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 432
  p ++;
#line 433
  token = p;
#line 436
  return ((SPF_errcode_t )0);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_macro___4(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                           SPF_data_t *data , size_t *data_used ,
                                           size_t data_avail , char const   *src ,
                                           size_t src_len , SPF_errcode_t big_err ,
                                           int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  size_t len ;
  char *dst ;
  size_t ds_avail ;
  size_t ds_len ;
  SPF_errcode_t tmp ;
  SPF_errcode_t tmp___0 ;
  char *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  char *tmp___3 ;
  SPF_errcode_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  SPF_errcode_t tmp___8 ;
  char *tmp___9 ;
  SPF_errcode_t tmp___10 ;
  SPF_errcode_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  SPF_errcode_t tmp___15 ;
  SPF_errcode_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  SPF_errcode_t tmp___19 ;
  SPF_errcode_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
#line 522
  if (spf_server___1->debug) {
    {
#line 523
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               523, "Parsing macro starting at %s", src);
    }
  }
#line 534
  idx = (size_t )0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 538
    data->ds.parm_type = (unsigned char)12;
#line 538
    data->ds.len = (unsigned char)0;
#line 538
    data->ds.__unused0 = (unsigned char)186;
#line 538
    data->ds.__unused1 = (unsigned char)190;
#line 538
    dst = SPF_data_str(data);
#line 538
    ds_avail = data_avail - *data_used;
#line 538
    ds_len = (size_t )0;
    }
#line 538
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 541
    if (! (idx < src_len)) {
#line 541
      goto while_break___0;
    }
#line 542
    if (spf_server___1->debug > 3) {
      {
#line 543
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 543, "Current data is at %p", data);
      }
    }
    {
#line 546
    len = strcspn(src + idx, " %");
    }
#line 547
    if (len > 0UL) {
#line 549
      if (idx + len > src_len) {
#line 550
        len = src_len - idx;
      }
#line 551
      if (spf_server___1->debug > 3) {
        {
#line 552
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                   554, "Adding string literal (%lu): \'%*.*s\'", len, (int )len,
                   (int )len, src + idx);
        }
      }
      {
#line 556
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 556
        if (ds_len + len > ds_avail) {
          {
#line 556
          tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                           src, "String literal fragment too long (%d chars, %d max)",
                                           ds_len, ds_avail);
          }
#line 556
          return (tmp);
        }
#line 556
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 557
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(src + idx),
             len);
#line 558
      ds_len += len;
#line 559
      dst += len;
#line 560
      idx += len;
      }
    }
#line 568
    if (idx == src_len) {
#line 569
      goto while_break___0;
    }
#line 576
    idx ++;
    {
#line 578
    if ((int const   )*(src + idx) == 37) {
#line 578
      goto case_37;
    }
#line 587
    if ((int const   )*(src + idx) == 95) {
#line 587
      goto case_95;
    }
#line 596
    if ((int const   )*(src + idx) == 45) {
#line 596
      goto case_45;
    }
#line 617
    if ((int const   )*(src + idx) == 123) {
#line 617
      goto case_123;
    }
#line 605
    goto switch_default;
    case_37: /* CIL Label */ 
#line 579
    if (spf_server___1->debug > 3) {
      {
#line 580
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 580, "Adding literal %%");
      }
    }
    {
#line 581
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 581
      if (ds_len + 1UL > ds_avail) {
        {
#line 581
        tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 581
        return (tmp___0);
      }
#line 581
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 582
    tmp___1 = dst;
#line 582
    dst ++;
#line 582
    *tmp___1 = (char )'%';
#line 583
    ds_len ++;
#line 584
    idx ++;
#line 585
    goto switch_break;
    case_95: /* CIL Label */ 
#line 588
    if (spf_server___1->debug > 3) {
      {
#line 589
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 589, "Adding literal space");
      }
    }
    {
#line 590
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 590
      if (ds_len + 1UL > ds_avail) {
        {
#line 590
        tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 590
        return (tmp___2);
      }
#line 590
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 591
    tmp___3 = dst;
#line 591
    dst ++;
#line 591
    *tmp___3 = (char )' ';
#line 592
    ds_len ++;
#line 593
    idx ++;
#line 594
    goto switch_break;
    case_45: /* CIL Label */ 
#line 597
    if (spf_server___1->debug > 3) {
      {
#line 598
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 598, "Adding escaped space");
      }
    }
    {
#line 599
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 599
      if (ds_len + 3UL > ds_avail) {
        {
#line 599
        tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 599
        return (tmp___4);
      }
#line 599
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 600
    tmp___5 = dst;
#line 600
    dst ++;
#line 600
    *tmp___5 = (char )'%';
#line 600
    tmp___6 = dst;
#line 600
    dst ++;
#line 600
    *tmp___6 = (char )'2';
#line 600
    tmp___7 = dst;
#line 600
    dst ++;
#line 600
    *tmp___7 = (char )'0';
#line 601
    ds_len += 3UL;
#line 602
    idx ++;
#line 603
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 606
    if (spf_server___1->debug > 3) {
      {
#line 607
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 608, "Adding illegal %%-follower \'%c\' at %d", (int const   )*(src + idx),
                 idx);
      }
    }
    {
#line 612
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 612
      if (ds_len + 1UL > ds_avail) {
        {
#line 612
        tmp___8 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 612
        return (tmp___8);
      }
#line 612
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 613
    tmp___9 = dst;
#line 613
    dst ++;
#line 613
    *tmp___9 = (char )'%';
#line 614
    ds_len ++;
#line 615
    goto switch_break;
    case_123: /* CIL Label */ 
    {
#line 618
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 618
      if (ds_len > 0UL) {
#line 618
        if (ds_len > 255UL) {
          {
#line 618
          tmp___10 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15,
                                                (char const   *)((void *)0), src,
                                                "String literal too long (%d chars, %d max)",
                                                ds_len, 255);
          }
#line 618
          return (tmp___10);
        }
#line 618
        data->ds.len = (unsigned char )ds_len;
#line 618
        len = sizeof(*data) + ds_len;
        {
#line 618
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 618
          tmp___12 = _align_sz(len);
          }
#line 618
          if (*data_used + tmp___12 > data_avail) {
            {
#line 618
            tmp___11 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                  src, "SPF domainspec too long (%d chars, %d max)",
                                                  *data_used + len, data_avail);
            }
#line 618
            return (tmp___11);
          }
          {
#line 618
          tmp___13 = _align_sz(len);
#line 618
          *data_used += tmp___13;
          }
#line 618
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 618
        data = SPF_data_next(data);
#line 618
        ds_len = (size_t )0;
        }
      }
#line 618
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 619
    if (spf_server___1->debug > 3) {
      {
#line 620
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 620, "Adding macro, data is at %p", data);
      }
    }
    {
#line 623
    idx ++;
#line 624
    err = SPF_c_parse_var___4(spf_response, & data->dv, src + idx, is_mod);
    }
#line 625
    if ((unsigned int )err != 0U) {
#line 626
      return (err);
    }
    {
#line 627
    tmp___14 = strcspn(src + idx, "} ");
#line 627
    idx += tmp___14;
    }
#line 628
    if ((int const   )*(src + idx) == 125) {
#line 629
      idx ++;
    } else
#line 630
    if ((int const   )*(src + idx) == 32) {
      {
#line 631
      tmp___15 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, src,
                                            src + idx, "Unterminated variable?");
      }
#line 631
      return (tmp___15);
    }
    {
#line 637
    len = SPF_data_len(data);
    }
    {
#line 638
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 638
      tmp___17 = _align_sz(len);
      }
#line 638
      if (*data_used + tmp___17 > data_avail) {
        {
#line 638
        tmp___16 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                              src, "SPF domainspec too long (%d chars, %d max)",
                                              *data_used + len, data_avail);
        }
#line 638
        return (tmp___16);
      }
      {
#line 638
      tmp___18 = _align_sz(len);
#line 638
      *data_used += tmp___18;
      }
#line 638
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 639
    data = SPF_data_next(data);
    }
#line 640
    if (spf_server___1->debug > 3) {
      {
#line 641
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 641, "Next data is at %p", data);
      }
    }
    {
#line 643
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 643
      data->ds.parm_type = (unsigned char)12;
#line 643
      data->ds.len = (unsigned char)0;
#line 643
      data->ds.__unused0 = (unsigned char)186;
#line 643
      data->ds.__unused1 = (unsigned char)190;
#line 643
      dst = SPF_data_str(data);
#line 643
      ds_avail = data_avail - *data_used;
#line 643
      ds_len = (size_t )0;
      }
#line 643
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 649
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 649
    if (ds_len > 0UL) {
#line 649
      if (ds_len > 255UL) {
        {
#line 649
        tmp___19 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                              src, "String literal too long (%d chars, %d max)",
                                              ds_len, 255);
        }
#line 649
        return (tmp___19);
      }
#line 649
      data->ds.len = (unsigned char )ds_len;
#line 649
      len = sizeof(*data) + ds_len;
      {
#line 649
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 649
        tmp___21 = _align_sz(len);
        }
#line 649
        if (*data_used + tmp___21 > data_avail) {
          {
#line 649
          tmp___20 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                src, "SPF domainspec too long (%d chars, %d max)",
                                                *data_used + len, data_avail);
          }
#line 649
          return (tmp___20);
        }
        {
#line 649
        tmp___22 = _align_sz(len);
#line 649
        *data_used += tmp___22;
        }
#line 649
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 649
      data = SPF_data_next(data);
#line 649
      ds_len = (size_t )0;
      }
    }
#line 649
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 651
  return ((SPF_errcode_t )0);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_domainspec___4(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                                SPF_data_t *data , size_t *data_used ,
                                                size_t data_avail , char const   *src ,
                                                size_t src_len , SPF_errcode_t big_err ,
                                                SPF_cidr_t cidr_ok , int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  SPF_errcode_t tmp___6 ;

  {
#line 682
  if (spf_server___1->debug) {
#line 683
    if ((unsigned int )cidr_ok == 1U) {
#line 683
      tmp___1 = "optional";
    } else {
#line 683
      if ((unsigned int )cidr_ok == 2U) {
#line 683
        tmp___0 = "only";
      } else {
#line 683
        if ((unsigned int )cidr_ok == 0U) {
#line 683
          tmp = "forbidden";
        } else {
#line 683
          tmp = "ERROR!";
        }
#line 683
        tmp___0 = tmp;
      }
#line 683
      tmp___1 = tmp___0;
    }
    {
#line 683
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               689, "Parsing domainspec starting at %s, cidr is %s", src, tmp___1);
    }
  }
#line 694
  if ((unsigned int )cidr_ok == 1U) {
#line 694
    goto _L___0;
  } else
#line 694
  if ((unsigned int )cidr_ok == 2U) {
    _L___0: /* CIL Label */ 
    {
#line 695
    err = SPF_c_parse_cidr___4(spf_response, & data->dc, src, & src_len);
    }
#line 696
    if ((unsigned int )err != 0U) {
#line 697
      return (err);
    }
#line 698
    if ((int )data->dc.ipv4 != 0) {
#line 698
      goto _L;
    } else
#line 698
    if ((int )data->dc.ipv6 != 0) {
      _L: /* CIL Label */ 
      {
#line 699
      len = SPF_data_len(data);
      }
      {
#line 700
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 700
        tmp___3 = _align_sz(len);
        }
#line 700
        if (*data_used + tmp___3 > data_avail) {
          {
#line 700
          tmp___2 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                               src, "SPF domainspec too long (%d chars, %d max)",
                                               *data_used + len, data_avail);
          }
#line 700
          return (tmp___2);
        }
        {
#line 700
        tmp___4 = _align_sz(len);
#line 700
        *data_used += tmp___4;
        }
#line 700
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 701
      data = SPF_data_next(data);
      }
    }
#line 704
    if ((unsigned int )cidr_ok == 2U) {
#line 704
      if (src_len > 0UL) {
        {
#line 708
        tmp___5 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                             src, "Invalid CIDR after mechanism");
        }
#line 708
        return (tmp___5);
      }
    }
  }
  {
#line 715
  tmp___6 = SPF_c_parse_macro___4(spf_server___1, spf_response, data, data_used, data_avail,
                                  src, src_len, big_err, is_mod);
  }
#line 715
  return (tmp___6);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip4___4(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  SPF_errcode_t err ;
  unsigned char mask ;
  struct in_addr *addr ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 739
  start ++;
#line 740
  len = strcspn(start, " ");
#line 741
  end = start + len;
#line 742
  p = end - 1;
#line 744
  mask = (unsigned char)0;
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 745
    tmp = __ctype_b_loc();
    }
#line 745
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 745
      goto while_break;
    }
#line 746
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 747
    if ((int const   )*p == 47) {
      {
#line 748
      err = SPF_c_parse_cidr_ip4___4(spf_response, & mask, p);
      }
#line 749
      if (err) {
#line 750
        return (err);
      }
#line 751
      end = p;
    }
  }
#line 753
  mech->mech_len = (unsigned short )mask;
#line 755
  len = (size_t )(end - start);
#line 756
  if (len > sizeof(buf) - 1UL) {
#line 757
    return ((SPF_errcode_t )19);
  }
  {
#line 759
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 760
  buf[len] = (char )'\000';
#line 761
  addr = SPF_mech_ip4_data(mech);
#line 762
  tmp___0 = inet_pton(2, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
#line 762
  err = (SPF_errcode_t )tmp___0;
  }
#line 763
  if ((unsigned int )err <= 0U) {
    {
#line 764
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )19, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 764
    return (tmp___1);
  }
#line 767
  return ((SPF_errcode_t )0);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip6___4(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  int err ;
  unsigned char mask ;
  struct in6_addr *addr ;
  unsigned short const   **tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 788
  start ++;
#line 789
  len = strcspn(start, " ");
#line 790
  end = start + len;
#line 791
  p = end - 1;
#line 793
  mask = (unsigned char)0;
  }
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 794
    tmp = __ctype_b_loc();
    }
#line 794
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 794
      goto while_break;
    }
#line 795
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 796
    if ((int const   )*p == 47) {
      {
#line 797
      tmp___0 = SPF_c_parse_cidr_ip6___4(spf_response, & mask, p);
#line 797
      err = (int )tmp___0;
      }
#line 798
      if (err) {
#line 799
        return ((SPF_errcode_t )err);
      }
#line 800
      end = p;
    }
  }
#line 802
  mech->mech_len = (unsigned short )mask;
#line 804
  len = (size_t )(end - start);
#line 805
  if (len > sizeof(buf) - 1UL) {
#line 806
    return ((SPF_errcode_t )20);
  }
  {
#line 808
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 809
  buf[len] = (char )'\000';
#line 810
  addr = SPF_mech_ip6_data(mech);
#line 811
  err = inet_pton(10, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
  }
#line 812
  if (err <= 0) {
    {
#line 813
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )20, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 813
    return (tmp___1);
  }
#line 816
  return ((SPF_errcode_t )0);
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mech_add___4)(SPF_server_t *spf_server___1 ,
                                                                                   SPF_record_t *spf_record ,
                                                                                   SPF_response_t *spf_response ,
                                                                                   SPF_mechtype_t const   *mechtype ,
                                                                                   int prefix ,
                                                                                   char const   **mech_value ) 
{ 
  union __anonunion_u_60___4 u ;
  SPF_mech_t *spf_mechanism ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  SPF_errcode_t tmp ;
  int tmp___0 ;

  {
  {
#line 834
  spf_mechanism = (SPF_mech_t *)(u.buf);
#line 842
  memset((void *)(u.buf), 'B', sizeof(u.buf));
#line 843
  memset((void *)spf_mechanism, 0, sizeof(SPF_mech_t ));
  }
#line 845
  if (spf_server___1->debug) {
    {
#line 846
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               847, "SPF_c_mech_add: type=%d, value=%s", (int const   )mechtype->mech_type,
               *mech_value);
    }
  }
#line 849
  spf_mechanism->prefix_type = (unsigned char )prefix;
#line 850
  spf_mechanism->mech_type = (unsigned char )mechtype->mech_type;
#line 851
  spf_mechanism->mech_len = (unsigned short)0;
#line 853
  len = sizeof(SPF_mech_t );
#line 855
  if (spf_record->mech_len + len > 511UL) {
#line 856
    return ((SPF_errcode_t )16);
  }
  {
#line 858
  data = SPF_mech_data(spf_mechanism);
#line 859
  data_len = (size_t )0;
#line 861
  src_len = strcspn(*mech_value, " ");
  }
  {
#line 865
  if ((int const   )mechtype->mech_type == 5) {
#line 865
    goto case_5;
  }
#line 878
  if ((int const   )mechtype->mech_type == 6) {
#line 878
    goto case_6;
  }
#line 891
  goto switch_default;
  case_5: /* CIL Label */ 
#line 866
  if ((int const   )*(*mech_value) == 58) {
    {
#line 867
    err = SPF_c_parse_ip4___4(spf_response, spf_mechanism, *mech_value);
#line 868
    data_len = sizeof(struct in_addr );
    }
  } else {
    {
#line 871
    err = (SPF_errcode_t )9;
#line 872
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 876
  goto switch_break;
  case_6: /* CIL Label */ 
#line 879
  if ((int const   )*(*mech_value) == 58) {
    {
#line 880
    err = SPF_c_parse_ip6___4(spf_response, spf_mechanism, *mech_value);
#line 881
    data_len = sizeof(struct in6_addr );
    }
  } else {
    {
#line 884
    err = (SPF_errcode_t )9;
#line 885
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 889
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 892
  if ((int const   )*(*mech_value) == 58) {
#line 892
    goto _L___0;
  } else
#line 892
  if ((int const   )*(*mech_value) == 61) {
    _L___0: /* CIL Label */ 
#line 893
    if ((unsigned int const   )mechtype->has_domainspec == 0U) {
      {
#line 894
      err = (SPF_errcode_t )7;
#line 895
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a value.");
      }
    } else {
      {
#line 900
      (*mech_value) ++;
#line 900
      src_len --;
#line 901
      err = SPF_c_parse_domainspec___4(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )mechtype->has_cidr, 0);
      }
    }
  } else
#line 909
  if ((int const   )*(*mech_value) == 47) {
#line 910
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 911
      err = (SPF_errcode_t )9;
#line 912
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else
#line 916
    if ((unsigned int const   )mechtype->has_cidr == 0U) {
      {
#line 917
      err = (SPF_errcode_t )8;
#line 918
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a CIDR.");
      }
    } else {
      {
#line 923
      err = SPF_c_parse_domainspec___4(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )2, 0);
      }
    }
  } else
#line 931
  if ((int const   )*(*mech_value) == 32) {
#line 931
    goto _L;
  } else
#line 931
  if ((int const   )*(*mech_value) == 0) {
    _L: /* CIL Label */ 
#line 932
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 933
      err = (SPF_errcode_t )9;
#line 934
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else {
#line 939
      err = (SPF_errcode_t )0;
    }
  } else {
    {
#line 943
    err = (SPF_errcode_t )3;
#line 944
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Unknown character \'%c\' after mechanism.", (int const   )*(*mech_value));
    }
  }
#line 951
  spf_mechanism->mech_len = (unsigned short )data_len;
#line 952
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 955
  len += data_len;
#line 958
  if ((unsigned int )err == 0U) {
#line 959
    if (mechtype->is_dns_mech) {
#line 960
      spf_record->num_dns_mech = (unsigned char )((int )spf_record->num_dns_mech + 1);
    }
    {
#line 961
    tmp___0 = SPF_c_ensure_capacity___4((void **)(& spf_record->mech_first), & spf_record->mech_size,
                                        spf_record->mech_len + len);
    }
#line 961
    if (tmp___0 < 0) {
      {
#line 964
      tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                       (char const   *)((void *)0), "Failed to allocate memory for mechanism");
      }
#line 964
      return (tmp);
    }
    {
#line 968
    memcpy((void */* __restrict  */)((char *)spf_record->mech_first + spf_record->mech_len),
           (void const   */* __restrict  */)spf_mechanism, len);
#line 971
    spf_record->mech_len += len;
#line 972
    spf_record->num_mech = (unsigned char )((int )spf_record->num_mech + 1);
    }
  }
#line 975
  *mech_value += src_len;
#line 977
  return (err);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mod_add___4)(SPF_server_t *spf_server___1 ,
                                                                                  SPF_record_t *spf_record ,
                                                                                  SPF_response_t *spf_response ,
                                                                                  char const   *mod_name ,
                                                                                  size_t name_len ,
                                                                                  char const   **mod_value ) 
{ 
  union __anonunion_u_61___4 u ;
  SPF_mod_t *spf_modifier ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  char *tmp ;
  SPF_errcode_t tmp___0 ;
  int tmp___1 ;

  {
#line 992
  spf_modifier = (SPF_mod_t *)(u.buf);
#line 1000
  if (spf_server___1->debug) {
    {
#line 1001
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               1002, "Adding modifier name=%lu@%s, value=%s", name_len, mod_name,
               *mod_value);
    }
  }
  {
#line 1004
  memset((void *)(u.buf), 'A', sizeof(u.buf));
#line 1005
  memset((void *)spf_modifier, 0, sizeof(SPF_mod_t ));
  }
#line 1007
  if (name_len > 511UL) {
#line 1008
    return ((SPF_errcode_t )17);
  }
  {
#line 1010
  spf_modifier->name_len = (unsigned short )name_len;
#line 1011
  spf_modifier->data_len = (unsigned short)0;
#line 1014
  len = _align_sz(sizeof(SPF_mod_t ) + name_len);
  }
#line 1016
  if (spf_record->mod_len + len > 511UL) {
#line 1017
    return ((SPF_errcode_t )17);
  }
  {
#line 1019
  tmp = SPF_mod_name(spf_modifier);
#line 1019
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)mod_name,
         name_len);
#line 1021
  data = SPF_mod_data(spf_modifier);
#line 1022
  data_len = (size_t )0;
#line 1024
  src_len = strcspn(*mod_value, " ");
#line 1026
  err = SPF_c_parse_macro___4(spf_server___1, spf_response, data, & data_len, (size_t )511,
                              *mod_value, src_len, (SPF_errcode_t )17, 1);
#line 1032
  spf_modifier->data_len = (unsigned short )data_len;
#line 1033
  len += data_len;
  }
#line 1036
  if ((unsigned int )err == 0U) {
    {
#line 1037
    tmp___1 = SPF_c_ensure_capacity___4((void **)(& spf_record->mod_first), & spf_record->mod_size,
                                        spf_record->mod_len + len);
    }
#line 1037
    if (tmp___1 < 0) {
      {
#line 1040
      tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                           (char const   *)((void *)0), "Failed to allocate memory for modifier");
      }
#line 1040
      return (tmp___0);
    }
    {
#line 1044
    memcpy((void */* __restrict  */)((char *)spf_record->mod_first + spf_record->mod_len),
           (void const   */* __restrict  */)spf_modifier, len);
#line 1047
    spf_record->mod_len += len;
#line 1048
    spf_record->num_mod = (unsigned char )((int )spf_record->num_mod + 1);
    }
  }
#line 1051
  return (err);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static void SPF_record_lint___4(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                SPF_record_t *spf_record ) 
{ 
  SPF_data_t *d ;
  SPF_data_t *data_end ;
  char *s ;
  char *s_end ;
  int found_non_ip ;
  int found_valid_tld ;
  SPF_mech_t *mech ;
  SPF_data_t *data ;
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1075
  mech = spf_record->mech_first;
#line 1076
  i = 0;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (i < (int )spf_record->num_mech)) {
#line 1076
      goto while_break;
    }
#line 1081
    if ((int )mech->mech_type == 8) {
#line 1081
      goto _L;
    } else
#line 1081
    if ((int )mech->mech_type == 9) {
      _L: /* CIL Label */ 
#line 1081
      if (i != (int )spf_record->num_mech - 1) {
        {
#line 1085
        SPF_response_add_warn(spf_response, (SPF_errcode_t )29, "Mechanisms found after the \"all:\" mechanism will be ignored.");
        }
      }
    }
#line 1098
    if ((int )mech->mech_type == 5) {
#line 1100
      goto __Cont;
    } else
#line 1098
    if ((int )mech->mech_type == 6) {
#line 1100
      goto __Cont;
    }
    {
#line 1102
    data = SPF_mech_data(mech);
#line 1103
    data_end = SPF_mech_end_data(mech);
    }
#line 1104
    if ((unsigned long )data == (unsigned long )data_end) {
#line 1105
      goto __Cont;
    }
#line 1107
    if ((int )data->dc.parm_type == 11) {
      {
#line 1109
      data = SPF_data_next(data);
      }
#line 1110
      if ((unsigned long )data == (unsigned long )data_end) {
#line 1111
        goto __Cont;
      }
    }
#line 1115
    found_valid_tld = 0;
#line 1116
    found_non_ip = 0;
#line 1118
    d = data;
    {
#line 1118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1118
      if (! ((unsigned long )d < (unsigned long )data_end)) {
#line 1118
        goto while_break___0;
      }
      {
#line 1122
      if ((int )d->dv.parm_type == 11) {
#line 1122
        goto case_11;
      }
#line 1128
      if ((int )d->dv.parm_type == 0) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 5) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 4) {
#line 1128
        goto case_0;
      }
#line 1132
      if ((int )d->dv.parm_type == 12) {
#line 1132
        goto case_12;
      }
#line 1148
      goto switch_default;
      case_11: /* CIL Label */ 
      {
#line 1123
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1123, "%s", "Multiple CIDR parameters found");
      }
#line 1124
      goto switch_break;
      case_0: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 1129
      found_valid_tld = 0;
#line 1130
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 1133
      found_valid_tld = 0;
#line 1135
      s = SPF_data_str(d);
#line 1136
      s_end = s + (int )d->ds.len;
      }
      {
#line 1137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1137
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 1137
          goto while_break___1;
        }
        {
#line 1138
        tmp = __ctype_b_loc();
        }
#line 1138
        if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 2048)) {
#line 1138
          if ((int )*s != 46) {
#line 1138
            if ((int )*s != 58) {
#line 1139
              found_non_ip = 1;
            }
          }
        }
#line 1141
        if ((int )*s == 46) {
#line 1142
          found_valid_tld = 1;
        } else {
          {
#line 1143
          tmp___0 = __ctype_b_loc();
          }
#line 1143
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 1024)) {
#line 1144
            found_valid_tld = 0;
          }
        }
#line 1137
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1146
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1149
      found_non_ip = 1;
#line 1150
      found_valid_tld = 1;
#line 1152
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1118
      d = SPF_data_next(d);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1156
    if (! found_valid_tld) {
#line 1156
      goto _L___0;
    } else
#line 1156
    if (! found_non_ip) {
      _L___0: /* CIL Label */ 
#line 1157
      if (! found_non_ip) {
        {
#line 1158
        SPF_response_add_warn(spf_response, (SPF_errcode_t )27, "Invalid hostname (an IP address?)");
        }
      } else
#line 1160
      if (! found_valid_tld) {
        {
#line 1161
        SPF_response_add_warn(spf_response, (SPF_errcode_t )28, "Hostname has a missing or invalid TLD");
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 1076
    i ++;
#line 1076
    mech = SPF_mech_next(mech);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1168
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv4___4[8]  = 
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
  {      (char const   )'i',      (char const   )'n',      (char const   )'-',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv6___4[4]  = {      (char const   )'i',      (char const   )'p',      (char const   )'6',      (char const   )'\000'};
#line 83 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spf_example/spf_example.c"
static void usage___3(void) 
{ 


  {
  {
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:\n\nspf_example [options]\n\nValid data options are:\n    -i <IP address>            The IP address that is sending email\n    -s <email address>         The email address used as the\n                               envelope-from.  If no username (local\n                               part) is given, \'postmaster\' will be\n                               assumed.\n    -r <email address>         [optional] The email address used as\n                               the envelope-to email address, for\n                               secondary-MX checking.\n    -h <domain name>           The domain name given on the SMTP HELO\n                               command.  This is only needed if the\n                               -sender option is not given.\n    -d [debug level]           debug level.\n");
  }
#line 105
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c"
static SPF_errcode_t SPF_record_stringify_data___4(SPF_data_t *data , SPF_data_t *data_end ,
                                                   char **p_p , char *p_end , int is_mod ,
                                                   int cidr_ok , int debug ) 
{ 
  char *p ;
  size_t len ;
  SPF_data_t *cidr_data ;
  char *s ;
  char *tmp ;
  char *s_end ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 48
  p = *p_p;
#line 54
  if (debug) {
    {
#line 55
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
               55, " string data: Building");
    }
  }
#line 57
  if (p_end - p <= 0L) {
#line 58
    return ((SPF_errcode_t )10);
  }
#line 60
  cidr_data = (SPF_data_t *)((void *)0);
#line 61
  if ((unsigned long )data < (unsigned long )data_end) {
#line 61
    if ((int )data->dc.parm_type == 11) {
#line 63
      if (debug) {
        {
#line 64
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   64, " string data: Found a CIDR at %p", data);
        }
      }
#line 65
      if (! cidr_ok) {
#line 66
        return ((SPF_errcode_t )10);
      }
      {
#line 68
      cidr_data = data;
#line 69
      data = SPF_data_next(data);
      }
    }
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )data < (unsigned long )data_end)) {
#line 73
      goto while_break;
    }
#line 75
    if (debug) {
      {
#line 76
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 77, " string data: Handling data type %d at %p", (int )data->ds.parm_type,
                 data);
      }
    }
#line 78
    if ((int )data->ds.parm_type == 12) {
      {
#line 80
      tmp = SPF_data_str(data);
#line 80
      s = tmp;
#line 81
      s_end = s + (int )data->ds.len;
      }
#line 82
      if (debug) {
        {
#line 83
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   84, " string data: String is [%d] \'%*.*s\'", (int )data->ds.len,
                   (int )data->ds.len, (int )data->ds.len, s);
        }
      }
#line 86
      if (p_end - (p + (int )data->ds.len) <= 0L) {
#line 87
        return ((SPF_errcode_t )10);
      }
      {
#line 89
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 89
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 89
          goto while_break___0;
        }
#line 90
        if ((int )*s == 32) {
#line 91
          tmp___0 = p;
#line 91
          p ++;
#line 91
          *tmp___0 = (char )'%';
#line 92
          tmp___1 = p;
#line 92
          p ++;
#line 92
          *tmp___1 = (char )'_';
#line 93
          s ++;
        } else
#line 95
        if ((int )*s == 37) {
#line 96
          tmp___2 = p;
#line 96
          p ++;
#line 96
          *tmp___2 = (char )'%';
#line 97
          s ++;
#line 98
          if ((int )*(s + 0) == 50) {
#line 98
            if ((int )*(s + 1) == 48) {
#line 99
              tmp___3 = p;
#line 99
              p ++;
#line 99
              *tmp___3 = (char )'-';
#line 100
              s += 2;
            } else {
#line 103
              tmp___4 = p;
#line 103
              p ++;
#line 103
              *tmp___4 = (char )'%';
            }
          } else {
#line 103
            tmp___4 = p;
#line 103
            p ++;
#line 103
            *tmp___4 = (char )'%';
          }
        } else {
#line 108
          tmp___5 = p;
#line 108
          p ++;
#line 108
          tmp___6 = s;
#line 108
          s ++;
#line 108
          *tmp___5 = *tmp___6;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 112
      if (p_end - p <= 0L) {
#line 113
        return ((SPF_errcode_t )10);
      }
    } else
#line 115
    if ((int )data->dc.parm_type == 11) {
#line 117
      return ((SPF_errcode_t )8);
    } else {
      {
#line 120
      tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%%{");
#line 120
      len = (size_t )tmp___7;
#line 121
      p += len;
      }
#line 122
      if (p_end - p <= 0L) {
#line 122
        return ((SPF_errcode_t )10);
      }
#line 125
      if (p_end - p <= 1L) {
#line 125
        return ((SPF_errcode_t )10);
      }
      {
#line 128
      if ((int )data->dv.parm_type == 0) {
#line 128
        goto case_0;
      }
#line 132
      if ((int )data->dv.parm_type == 1) {
#line 132
        goto case_1;
      }
#line 136
      if ((int )data->dv.parm_type == 2) {
#line 136
        goto case_2;
      }
#line 140
      if ((int )data->dv.parm_type == 3) {
#line 140
        goto case_3;
      }
#line 144
      if ((int )data->dv.parm_type == 4) {
#line 144
        goto case_4;
      }
#line 148
      if ((int )data->dv.parm_type == 5) {
#line 148
        goto case_5;
      }
#line 152
      if ((int )data->dv.parm_type == 6) {
#line 152
        goto case_6;
      }
#line 158
      if ((int )data->dv.parm_type == 7) {
#line 158
        goto case_7;
      }
#line 162
      if ((int )data->dv.parm_type == 8) {
#line 162
        goto case_8;
      }
#line 166
      if ((int )data->dv.parm_type == 9) {
#line 166
        goto case_9;
      }
#line 170
      if ((int )data->dv.parm_type == 10) {
#line 170
        goto case_10;
      }
#line 174
      goto switch_default;
      case_0: /* CIL Label */ 
#line 129
      *p = (char )'l';
#line 130
      goto switch_break;
      case_1: /* CIL Label */ 
#line 133
      *p = (char )'s';
#line 134
      goto switch_break;
      case_2: /* CIL Label */ 
#line 137
      *p = (char )'o';
#line 138
      goto switch_break;
      case_3: /* CIL Label */ 
#line 141
      *p = (char )'d';
#line 142
      goto switch_break;
      case_4: /* CIL Label */ 
#line 145
      *p = (char )'i';
#line 146
      goto switch_break;
      case_5: /* CIL Label */ 
#line 149
      *p = (char )'c';
#line 150
      goto switch_break;
      case_6: /* CIL Label */ 
#line 153
      if (! is_mod) {
#line 154
        return ((SPF_errcode_t )12);
      }
#line 155
      *p = (char )'t';
#line 156
      goto switch_break;
      case_7: /* CIL Label */ 
#line 159
      *p = (char )'p';
#line 160
      goto switch_break;
      case_8: /* CIL Label */ 
#line 163
      *p = (char )'v';
#line 164
      goto switch_break;
      case_9: /* CIL Label */ 
#line 167
      *p = (char )'h';
#line 168
      goto switch_break;
      case_10: /* CIL Label */ 
#line 171
      *p = (char )'r';
#line 172
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 175
      return ((SPF_errcode_t )12);
#line 176
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 178
      if (data->dv.url_encode) {
        {
#line 179
        tmp___8 = toupper((int )*p);
#line 179
        *p = (char )tmp___8;
        }
      }
#line 180
      p ++;
#line 181
      if (p_end - p <= 0L) {
#line 181
        return ((SPF_errcode_t )10);
      }
#line 184
      if (data->dv.num_rhs) {
        {
#line 186
        tmp___9 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%d",
                           (int )data->dv.num_rhs);
#line 186
        len = (size_t )tmp___9;
#line 187
        p += len;
        }
#line 188
        if (p_end - p <= 0L) {
#line 188
          return ((SPF_errcode_t )10);
        }
      }
#line 192
      if (p_end - p <= 8L) {
#line 192
        return ((SPF_errcode_t )10);
      }
#line 193
      if (data->dv.rev) {
#line 194
        tmp___10 = p;
#line 194
        p ++;
#line 194
        *tmp___10 = (char )'r';
      }
#line 196
      if (data->dv.delim_dot) {
#line 196
        if (data->dv.delim_dash) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_plus) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_equal) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_bar) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_under) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        }
      }
#line 205
      if (data->dv.delim_dash) {
#line 206
        tmp___12 = p;
#line 206
        p ++;
#line 206
        *tmp___12 = (char )'-';
      }
#line 207
      if (data->dv.delim_plus) {
#line 208
        tmp___13 = p;
#line 208
        p ++;
#line 208
        *tmp___13 = (char )'+';
      }
#line 209
      if (data->dv.delim_equal) {
#line 210
        tmp___14 = p;
#line 210
        p ++;
#line 210
        *tmp___14 = (char )'=';
      }
#line 211
      if (data->dv.delim_bar) {
#line 212
        tmp___15 = p;
#line 212
        p ++;
#line 212
        *tmp___15 = (char )'|';
      }
#line 213
      if (data->dv.delim_under) {
#line 214
        tmp___16 = p;
#line 214
        p ++;
#line 214
        *tmp___16 = (char )'_';
      }
#line 216
      tmp___17 = p;
#line 216
      p ++;
#line 216
      *tmp___17 = (char )'}';
#line 217
      if (p_end - p <= 0L) {
#line 217
        return ((SPF_errcode_t )10);
      }
    }
    {
#line 73
    data = SPF_data_next(data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (cidr_data) {
#line 224
    if (cidr_data->dc.ipv4) {
      {
#line 226
      tmp___18 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"/%d",
                          (int )cidr_data->dc.ipv4);
#line 226
      len = (size_t )tmp___18;
#line 227
      p += len;
      }
#line 228
      if (p_end - p <= 0L) {
#line 228
        return ((SPF_errcode_t )10);
      }
    }
#line 231
    if (cidr_data->dc.ipv6) {
      {
#line 233
      tmp___19 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"//%d",
                          (int )cidr_data->dc.ipv6);
#line 233
      len = (size_t )tmp___19;
#line 234
      p += len;
      }
#line 235
      if (p_end - p <= 0L) {
#line 235
        return ((SPF_errcode_t )10);
      }
    }
  }
#line 239
  *p_p = p;
#line 240
  return ((SPF_errcode_t )0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_pre___4(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                  ns_type rr_type , int should_cache ) 
{ 
  char const   *tmp ;

  {
#line 51
  if (spf_dns_server->debug) {
    {
#line 52
    tmp = SPF_strrrtype(rr_type);
#line 52
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               54, "DNS[%s] lookup: %s %s (%d)", spf_dns_server->name, domain, tmp,
               (unsigned int )rr_type);
    }
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_post___4(SPF_dns_server_t *spf_dns_server , SPF_dns_rr_t *spfrr ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 61
  if (spf_dns_server->debug) {
    {
#line 66
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               66, "DNS[%s] found record", spf_dns_server->name);
#line 67
    tmp = SPF_strrrtype(spfrr->rr_type);
#line 67
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               69, "    DOMAIN: %s  TYPE: %s (%d)", spfrr->domain, tmp, (unsigned int )spfrr->rr_type);
    }
#line 70
    if (spfrr->source) {
#line 70
      if ((spfrr->source)->name) {
#line 70
        tmp___0 = (spfrr->source)->name;
      } else {
#line 70
        tmp___0 = "(unnamed source)";
      }
#line 70
      tmp___1 = tmp___0;
    } else {
#line 70
      tmp___1 = "(null source)";
    }
    {
#line 70
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               76, "    TTL: %ld  RR found: %d  herrno: %d  source: %s", spfrr->ttl,
               spfrr->num_rr, spfrr->herrno, tmp___1);
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! (i < spfrr->num_rr)) {
#line 77
        goto while_break;
      }
      {
#line 79
      if ((unsigned int )spfrr->rr_type == 1U) {
#line 79
        goto case_1;
      }
#line 85
      if ((unsigned int )spfrr->rr_type == 12U) {
#line 85
        goto case_12;
      }
#line 89
      if ((unsigned int )spfrr->rr_type == 15U) {
#line 89
        goto case_15;
      }
#line 93
      if ((unsigned int )spfrr->rr_type == 16U) {
#line 93
        goto case_16;
      }
#line 97
      if ((unsigned int )spfrr->rr_type == 99U) {
#line 97
        goto case_99;
      }
#line 101
      if ((unsigned int )spfrr->rr_type == 28U) {
#line 101
        goto case_28;
      }
#line 107
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 80
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->a),
                          (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
#line 80
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 82, "    - A: %s", tmp___2);
      }
#line 83
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 86
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 86, "    - PTR: %s", (*(spfrr->rr + i))->ptr);
      }
#line 87
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 90
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 90, "    - MX: %s", (*(spfrr->rr + i))->mx);
      }
#line 91
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 94
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 94, "    - TXT: %s", (*(spfrr->rr + i))->txt);
      }
#line 95
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 98
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 98, "    - SPF: %s", (*(spfrr->rr + i))->txt);
      }
#line 99
      goto switch_break;
      case_28: /* CIL Label */ 
      {
#line 102
      tmp___3 = inet_ntop(10, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->aaaa),
                          (char */* __restrict  */)(ip6_buf), (socklen_t )sizeof(ip6_buf));
#line 102
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 104, "    - AAAA: %s", tmp___3);
      }
#line 105
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 108
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 108, "    - Unknown RR type");
      }
#line 109
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 77
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 113
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_cache_bucket_t *SPF_dns_cache_bucket_find___4(SPF_dns_cache_config_t *spfhook ,
                                                             char const   *domain ,
                                                             ns_type rr_type , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  SPF_dns_rr_t *rr ;
  time_t now ;
  int tmp ;

  {
  {
#line 247
  bucket = *(spfhook->cache + idx);
#line 248
  prev = (SPF_dns_cache_bucket_t *)((void *)0);
#line 249
  time(& now);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
#line 252
    rr = bucket->rr;
#line 254
    if (rr->utc_ttl < now) {
#line 256
      if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 257
        prev->next = bucket->next;
      } else {
#line 259
        *(spfhook->cache + idx) = bucket->next;
      }
#line 261
      if (bucket->rr) {
        {
#line 262
        SPF_dns_rr_free(bucket->rr);
        }
      }
      {
#line 263
      free((void *)bucket);
#line 265
      bucket = prev;
      }
    } else
#line 267
    if (! ((unsigned int )rr->rr_type != (unsigned int )rr_type)) {
      {
#line 270
      tmp = strcmp((char const   *)rr->domain, domain);
      }
#line 270
      if (! (tmp != 0)) {
#line 275
        if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 276
          prev->next = bucket->next;
#line 277
          bucket->next = *(spfhook->cache + idx);
#line 278
          *(spfhook->cache + idx) = bucket;
        }
#line 280
        return (bucket);
      }
    }
#line 283
    prev = bucket;
#line 284
    if ((unsigned long )bucket == (unsigned long )((void *)0)) {
#line 285
      bucket = *(spfhook->cache + idx);
    } else {
#line 287
      bucket = bucket->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return ((SPF_dns_cache_bucket_t *)((void *)0));
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_bucket_add___4(SPF_dns_cache_config_t *spfhook ,
                                                  SPF_dns_rr_t *rr , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  void *tmp ;

  {
  {
#line 300
  tmp = malloc(sizeof(SPF_dns_cache_bucket_t ));
#line 300
  bucket = (SPF_dns_cache_bucket_t *)tmp;
  }
#line 302
  if (! bucket) {
#line 303
    return ((SPF_errcode_t )1);
  }
#line 304
  bucket->next = *(spfhook->cache + idx);
#line 305
  *(spfhook->cache + idx) = bucket;
#line 306
  bucket->rr = rr;
#line 307
  return ((SPF_errcode_t )0);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_rr_fixup___4(SPF_dns_cache_config_t *spfhook ,
                                                SPF_dns_rr_t *cached_rr , char const   *domain ,
                                                ns_type rr_type ) 
{ 
  char *p ;
  char *new_domain ;
  size_t new_len ;
  size_t tmp ;
  void *tmp___0 ;
  time_t tmp___1 ;

  {
#line 322
  if ((unsigned int )cached_rr->rr_type == 255U) {
#line 323
    cached_rr->rr_type = rr_type;
  }
#line 326
  if ((unsigned long )cached_rr->domain == (unsigned long )((void *)0)) {
#line 326
    goto _L;
  } else
#line 326
  if ((int )*(cached_rr->domain + 0) != 0) {
    _L: /* CIL Label */ 
    {
#line 328
    tmp = strlen(domain);
#line 328
    new_len = tmp + 1UL;
    }
#line 330
    if (cached_rr->domain_buf_len < new_len) {
      {
#line 331
      tmp___0 = realloc((void *)cached_rr->domain, new_len);
#line 331
      new_domain = (char *)tmp___0;
      }
#line 332
      if ((unsigned long )new_domain == (unsigned long )((void *)0)) {
#line 333
        return ((SPF_errcode_t )1);
      }
#line 334
      cached_rr->domain = new_domain;
#line 335
      cached_rr->domain_buf_len = new_len;
    }
    {
#line 337
    strcpy((char */* __restrict  */)cached_rr->domain, (char const   */* __restrict  */)domain);
    }
  }
#line 341
  if (cached_rr->ttl < spfhook->min_ttl) {
#line 342
    cached_rr->ttl = spfhook->min_ttl;
  }
#line 344
  if (cached_rr->ttl < spfhook->txt_ttl) {
#line 344
    if ((unsigned int )cached_rr->rr_type == 16U) {
#line 346
      cached_rr->ttl = spfhook->txt_ttl;
    }
  }
#line 348
  if (cached_rr->ttl < spfhook->err_ttl) {
#line 348
    if (cached_rr->herrno != 0) {
#line 350
      cached_rr->ttl = spfhook->err_ttl;
    }
  }
#line 352
  if (cached_rr->ttl < spfhook->rdns_ttl) {
    {
#line 353
    p = strstr((char const   *)cached_rr->domain, ".arpa");
    }
#line 354
    if (p) {
#line 354
      if ((int )*(p + (sizeof(".arpa") - 1UL)) == 0) {
#line 355
        cached_rr->ttl = spfhook->rdns_ttl;
      }
    }
  }
  {
#line 358
  tmp___1 = time((time_t *)((void *)0));
#line 358
  cached_rr->utc_ttl = cached_rr->ttl + tmp___1;
  }
#line 360
  return ((SPF_errcode_t )0);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_rr_t *SPF_dns_cache_lookup___4(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                              ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_rr_t *cached_rr ;
  SPF_dns_rr_t *rr ;
  int idx ;
  SPF_errcode_t tmp ;
  SPF_dns_rr_t *tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;

  {
  {
#line 377
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
#line 381
  idx = crc32str(0U, domain, spfhook->max_hash_len);
#line 382
  idx &= spfhook->cache_size - 1;
#line 384
  pthread_mutex_lock(& spfhook->cache_lock);
#line 386
  bucket = SPF_dns_cache_bucket_find___4(spfhook, domain, rr_type, idx);
  }
#line 387
  if ((unsigned long )bucket != (unsigned long )((void *)0)) {
#line 388
    if ((unsigned long )bucket->rr != (unsigned long )((void *)0)) {
      {
#line 389
      tmp = SPF_dns_rr_dup(& rr, bucket->rr);
      }
#line 389
      if ((unsigned int )tmp == 0U) {
        {
#line 390
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 391
        return (rr);
      } else
#line 393
      if ((unsigned long )rr != (unsigned long )((void *)0)) {
        {
#line 394
        SPF_dns_rr_free(rr);
        }
      }
    }
  }
  {
#line 401
  bucket = (SPF_dns_cache_bucket_t *)((void *)0);
#line 403
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 405
  if (! spf_dns_server->layer_below) {
    {
#line 406
    tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
    }
#line 406
    return (tmp___0);
  }
  {
#line 408
  rr = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
  }
#line 410
  if (spfhook->conserve_cache) {
#line 410
    if (! should_cache) {
#line 411
      return (rr);
    }
  }
  {
#line 413
  pthread_mutex_lock(& spfhook->cache_lock);
#line 415
  tmp___3 = SPF_dns_rr_dup(& cached_rr, rr);
  }
#line 415
  if ((unsigned int )tmp___3 == 0U) {
    {
#line 416
    tmp___2 = SPF_dns_cache_rr_fixup___4(spfhook, cached_rr, domain, rr_type);
    }
#line 416
    if ((unsigned int )tmp___2 == 0U) {
      {
#line 417
      tmp___1 = SPF_dns_cache_bucket_add___4(spfhook, cached_rr, idx);
      }
#line 417
      if ((unsigned int )tmp___1 == 0U) {
        {
#line 418
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 419
        return (rr);
      }
    }
  }
  {
#line 424
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 426
  if (cached_rr) {
    {
#line 427
    SPF_dns_rr_free(cached_rr);
    }
  }
#line 429
  return (rr);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static void SPF_dns_cache_free___4(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  int i ;

  {
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 442
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
                 442, "%s", "spf_dns_server is NULL");
      }
    }
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
  }
#line 445
  if (spfhook) {
    {
#line 446
    pthread_mutex_lock(& spfhook->cache_lock);
    }
#line 448
    if (spfhook->cache) {
#line 449
      i = 0;
      {
#line 449
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 449
        if (! (i < spfhook->cache_size)) {
#line 449
          goto while_break___0;
        }
#line 450
        bucket = *(spfhook->cache + i);
        {
#line 451
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 451
          if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 451
            goto while_break___1;
          }
#line 452
          prev = bucket;
#line 453
          bucket = bucket->next;
#line 456
          if (prev->rr) {
            {
#line 457
            SPF_dns_rr_free(prev->rr);
            }
          }
          {
#line 458
          free((void *)prev);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 449
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 461
      free((void *)spfhook->cache);
#line 462
      spfhook->cache = (SPF_dns_cache_bucket_t **)((void *)0);
      }
    }
    {
#line 465
    pthread_mutex_unlock(& spfhook->cache_lock);
#line 476
    pthread_mutex_destroy(& spfhook->cache_lock);
#line 478
    free((void *)spfhook);
    }
  }
  {
#line 481
  free((void *)spf_dns_server);
  }
#line 482
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_find___4(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                           ns_type rr_type , int exact ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;
  int tmp ;
  size_t domain_len ;
  size_t tmp___0 ;
  size_t zdomain_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 103
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 105
  if (spf_dns_server->debug) {
    {
#line 106
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
               106, "zone: Searching for RR %s (%d)", domain, (unsigned int )rr_type);
    }
  }
#line 110
  if (exact) {
#line 110
    goto _L;
  } else {
    {
#line 110
    tmp___6 = strncmp(domain, "*.", (size_t )2);
    }
#line 110
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
#line 111
      i = 0;
      {
#line 111
      while (1) {
        while_continue: /* CIL Label */ ;
#line 111
        if (! (i < spfhook->num_zone)) {
#line 111
          goto while_break;
        }
#line 112
        if ((unsigned int )(*(spfhook->zone + i))->rr_type == (unsigned int )rr_type) {
          {
#line 112
          tmp = strcasecmp((char const   *)(*(spfhook->zone + i))->domain, domain);
          }
#line 112
          if (tmp == 0) {
#line 114
            return (*(spfhook->zone + i));
          }
        }
#line 111
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 116
      if (spf_dns_server->debug) {
        {
#line 117
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   117, "zone: Exact not found");
        }
      }
    } else {
      {
#line 121
      tmp___0 = strlen(domain);
#line 121
      domain_len = tmp___0;
      }
#line 125
      if (domain_len) {
#line 125
        if ((int const   )*(domain + (domain_len - 1UL)) == 46) {
#line 126
          domain_len --;
        }
      }
#line 128
      i = 0;
      {
#line 128
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 128
        if (! (i < spfhook->num_zone)) {
#line 128
          goto while_break___0;
        }
#line 129
        if ((unsigned int )(*(spfhook->zone + i))->rr_type != (unsigned int )rr_type) {
#line 129
          if ((unsigned int )(*(spfhook->zone + i))->rr_type != 255U) {
#line 131
            if (spf_dns_server->debug) {
              {
#line 132
              SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                         133, "zone: Ignoring record rrtype %d", (unsigned int )(*(spfhook->zone + i))->rr_type);
              }
            }
#line 134
            goto __Cont;
          }
        }
        {
#line 137
        tmp___5 = strncmp((char const   *)(*(spfhook->zone + i))->domain, "*.", (size_t )2);
        }
#line 137
        if (tmp___5 == 0) {
          {
#line 138
          tmp___1 = strlen((char const   *)(*(spfhook->zone + i))->domain);
#line 138
          zdomain_len = tmp___1 - 2UL;
          }
#line 139
          if (zdomain_len <= domain_len) {
            {
#line 139
            tmp___2 = strncasecmp((char const   *)((*(spfhook->zone + i))->domain + 2),
                                  domain + (domain_len - zdomain_len), zdomain_len);
            }
#line 139
            if (tmp___2 == 0) {
#line 144
              return (*(spfhook->zone + i));
            }
          }
        } else {
          {
#line 146
          tmp___3 = strncasecmp((char const   *)(*(spfhook->zone + i))->domain, domain,
                                domain_len);
          }
#line 146
          if (tmp___3 == 0) {
            {
#line 146
            tmp___4 = strlen((char const   *)(*(spfhook->zone + i))->domain);
            }
#line 146
            if (tmp___4 == domain_len) {
#line 151
              return (*(spfhook->zone + i));
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 128
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 154
      if (spf_dns_server->debug) {
        {
#line 155
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   155, "zone: Non-exact not found");
        }
      }
    }
  }
#line 158
  return ((SPF_dns_rr_t *)((void *)0));
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_lookup___4(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  SPF_dns_rr_t *spfrr ;
  SPF_dns_rr_t *tmp ;

  {
  {
#line 170
  spfrr = SPF_dns_zone_find___4(spf_dns_server, domain, rr_type, 0);
  }
#line 171
  if (spfrr) {
    {
#line 172
    SPF_dns_rr_dup(& spfrr, spfrr);
    }
#line 173
    return (spfrr);
  }
#line 176
  if (spf_dns_server->layer_below) {
    {
#line 177
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 177
    return (tmp);
  }
  {
#line 181
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
#line 182
  SPF_dns_rr_dup(& spfrr, spfhook->nxdomain);
  }
#line 184
  return (spfrr);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static void SPF_dns_zone_free___4(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 317
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                 317, "%s", "spf_dns_server is NULL");
      }
    }
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 320
  if (spfhook) {
#line 321
    if (spfhook->zone) {
#line 322
      i = 0;
      {
#line 322
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 322
        if (! (i < spfhook->zone_buf_len)) {
#line 322
          goto while_break___0;
        }
#line 323
        if (*(spfhook->zone + i)) {
          {
#line 324
          SPF_dns_rr_free(*(spfhook->zone + i));
          }
        }
#line 322
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 326
      free((void *)spfhook->zone);
      }
    }
#line 328
    if (spfhook->nxdomain) {
      {
#line 329
      SPF_dns_rr_free(spfhook->nxdomain);
      }
    }
    {
#line 330
    free((void *)spfhook);
    }
  }
  {
#line 333
  free((void *)spf_dns_server);
  }
#line 334
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static struct res_sym  const  ns_sects___4[4]  = {      {0, (char *)"QUESTION", (char *)"Question"}, 
        {1, (char *)"ANSWER", (char *)"Answer"}, 
        {2, (char *)"AUTHORITY", (char *)"Authority"}, 
        {3, (char *)"ADDITIONAL", (char *)"Additional"}};
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static int const   num_ns_sect___4  =    (int const   )(sizeof(ns_sects___4) / sizeof(ns_sects___4[0]));
#line 89 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_once_t res_state_control___4  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_key_t res_state_key___4  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_thread_term___4(void *arg ) 
{ 


  {
  {
#line 98
  __res_nclose((struct __res_state *)arg);
#line 100
  free(arg);
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_init_key___4(void) 
{ 


  {
  {
#line 106
  pthread_key_create(& res_state_key___4, & SPF_dns_resolv_thread_term___4);
  }
#line 107
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_debug___4(SPF_dns_server_t *spf_dns_server , ns_rr rr ,
                                     u_char const   *responsebuf , size_t responselen ,
                                     u_char const   *rdata , size_t rdlen ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char name_buf[1025] ;
  int prio ;
  int err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  u_int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 123
  if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 123
    goto case_1;
  }
#line 132
  if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 132
    goto case_28;
  }
#line 141
  if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 141
    goto case_2;
  }
#line 153
  if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 153
    goto case_5;
  }
#line 165
  if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 165
    goto case_15;
  }
#line 182
  if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 182
    goto case_16;
  }
#line 193
  if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 193
    goto case_12;
  }
#line 205
  goto switch_default;
  case_1: /* CIL Label */ 
#line 124
  if (rdlen != 4UL) {
    {
#line 125
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               125, "A: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 127
    tmp = inet_ntop(2, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip4_buf),
                    (socklen_t )sizeof(ip4_buf));
#line 127
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               129, "A: %s", tmp);
    }
  }
#line 130
  goto switch_break;
  case_28: /* CIL Label */ 
#line 133
  if (rdlen != 16UL) {
    {
#line 134
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               134, "AAAA: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 136
    tmp___0 = inet_ntop(10, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip6_buf),
                        (socklen_t )sizeof(ip6_buf));
#line 136
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               138, "AAAA: %s", tmp___0);
    }
  }
#line 139
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 142
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 146
  if (err < 0) {
    {
#line 147
    tmp___1 = __errno_location();
#line 147
    tmp___2 = __errno_location();
#line 147
    tmp___3 = strerror(*tmp___2);
#line 147
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               148, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___3,
               *tmp___1);
    }
  } else {
    {
#line 150
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               150, "NS: %s", name_buf);
    }
  }
#line 151
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 154
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 158
  if (err < 0) {
    {
#line 159
    tmp___4 = __errno_location();
#line 159
    tmp___5 = __errno_location();
#line 159
    tmp___6 = strerror(*tmp___5);
#line 159
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               160, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___6,
               *tmp___4);
    }
  } else {
    {
#line 162
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               162, "CNAME: %s", name_buf);
    }
  }
#line 163
  goto switch_break;
  case_15: /* CIL Label */ 
#line 166
  if (rdlen < 2UL) {
    {
#line 167
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               167, "MX: rdlen too short: %lu", rdlen);
    }
#line 168
    goto switch_break;
  }
  {
#line 170
  tmp___7 = ns_get16(rdata);
#line 170
  prio = (int )tmp___7;
#line 171
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata + 2, name_buf,
                           sizeof(name_buf));
  }
#line 175
  if (err < 0) {
    {
#line 176
    tmp___8 = __errno_location();
#line 176
    tmp___9 = __errno_location();
#line 176
    tmp___10 = strerror(*tmp___9);
#line 176
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               177, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___10,
               *tmp___8);
    }
  } else {
    {
#line 179
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               179, "MX: %d %s", prio, name_buf);
    }
  }
#line 180
  goto switch_break;
  case_16: /* CIL Label */ 
#line 183
  if (rdlen < 1UL) {
    {
#line 184
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               184, "TXT: rdlen too short: %lu", rdlen);
    }
#line 185
    goto switch_break;
  }
  {
#line 189
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             190, "TXT: (%lu) \"%.*s\"", rdlen, (int )rdlen - 1, rdata + 1);
  }
#line 191
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 194
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 198
  if (err < 0) {
    {
#line 199
    tmp___11 = __errno_location();
#line 199
    tmp___12 = __errno_location();
#line 199
    tmp___13 = strerror(*tmp___12);
#line 199
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               200, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___13,
               *tmp___11);
    }
  } else {
    {
#line 202
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               202, "PTR: %s", name_buf);
    }
  }
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 206
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             206, "not parsed:  type: %d", (unsigned int )((ns_type )((int )rr.type)));
  }
#line 207
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static SPF_dns_rr_t *SPF_dns_resolv_lookup___4(SPF_dns_server_t *spf_dns_server ,
                                               char const   *domain , ns_type rr_type ,
                                               int should_cache ) 
{ 
  SPF_dns_rr_t *spfrr ;
  int err ;
  int i ;
  int nrec ;
  int cnt ;
  u_char *responsebuf ;
  size_t responselen ;
  ns_msg ns_handle ;
  ns_rr rr ;
  int ns_sect___0 ;
  char name_buf[1025] ;
  size_t rdlen ;
  u_char const   *rdata ;
  void *res_spec ;
  struct __res_state *res_state___0 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int dns_len ;
  char const   *tmp___2 ;
  SPF_dns_rr_t *tmp___3 ;
  SPF_dns_rr_t *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  SPF_errcode_t tmp___20 ;
  SPF_errcode_t tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  SPF_errcode_t tmp___26 ;
  u_char *src ;
  u_char *dst ;
  size_t len ;
  SPF_errcode_t tmp___27 ;
  SPF_errcode_t tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  SPF_errcode_t tmp___33 ;

  {
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 247
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 247, "%s", "spf_dns_server is NULL");
      }
    }
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  res_spec = pthread_getspecific(res_state_key___4);
  }
#line 252
  if ((unsigned long )res_spec == (unsigned long )((void *)0)) {
    {
#line 253
    tmp = malloc(sizeof(struct __res_state ));
#line 253
    res_state___0 = (struct __res_state *)tmp;
    }
#line 257
    if (! res_state___0) {
      {
#line 258
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 259, "Failed to allocate %lu bytes for res_state", sizeof(struct __res_state ));
      }
    }
    {
#line 260
    memset((void *)res_state___0, 0, sizeof(struct __res_state ));
#line 261
    tmp___0 = __res_ninit(res_state___0);
    }
#line 261
    if (tmp___0 != 0) {
      {
#line 262
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 262, "%s", "Failed to call res_ninit()");
      }
    }
    {
#line 263
    pthread_setspecific(res_state_key___4, (void const   *)((void *)res_state___0));
    }
  } else {
#line 266
    res_state___0 = (struct __res_state *)res_spec;
  }
  {
#line 270
  responselen = (size_t )2048;
#line 271
  tmp___1 = malloc(responselen);
#line 271
  responsebuf = (u_char *)tmp___1;
  }
#line 272
  if (! responsebuf) {
#line 273
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 274
  memset((void *)responsebuf, 0, responselen);
  }
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 297
    dns_len = __res_nquery(res_state___0, domain, 1, (int )rr_type, responsebuf, (int )responselen);
    }
#line 304
    if (dns_len < 0) {
      {
#line 307
      free((void *)responsebuf);
      }
#line 308
      if (spf_dns_server->debug) {
        {
#line 309
        tmp___2 = hstrerror(res_state___0->res_h_errno);
#line 309
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   311, "query failed: err = %d  %s (%d): %s", dns_len, tmp___2, res_state___0->res_h_errno,
                   domain);
        }
      }
#line 312
      if (res_state___0->res_h_errno == 1) {
#line 312
        if ((unsigned long )spf_dns_server->layer_below != (unsigned long )((void *)0)) {
          {
#line 314
          tmp___3 = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
          }
#line 314
          return (tmp___3);
        }
      }
      {
#line 317
      tmp___4 = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, res_state___0->res_h_errno);
      }
#line 317
      return (tmp___4);
    } else
#line 320
    if ((size_t )dns_len > responselen) {
      {
#line 323
      responselen = (size_t )(dns_len + (dns_len >> 1));
#line 332
      tmp___5 = realloc((void *)responsebuf, responselen);
      }
#line 333
      if (! tmp___5) {
        {
#line 334
        free((void *)responsebuf);
        }
#line 335
        return ((SPF_dns_rr_t *)((void *)0));
      }
#line 337
      responsebuf = (u_char *)tmp___5;
    } else {
#line 341
      responselen = (size_t )dns_len;
#line 342
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 351
  spfrr = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, 0);
  }
#line 353
  if (! spfrr) {
    {
#line 354
    free((void *)responsebuf);
    }
#line 355
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 358
  err = ns_initparse((u_char const   *)responsebuf, (int )responselen, & ns_handle);
  }
#line 360
  if (err < 0) {
#line 361
    if (spf_dns_server->debug) {
      {
#line 362
      tmp___6 = __errno_location();
#line 362
      tmp___7 = __errno_location();
#line 362
      tmp___8 = strerror(*tmp___7);
#line 362
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 363, "ns_initparse failed: err = %d  %s (%d)", err, tmp___8, *tmp___6);
      }
    }
    {
#line 364
    free((void *)responsebuf);
#line 367
    spfrr->herrno = 3;
    }
#line 368
    return (spfrr);
  }
#line 372
  if (spf_dns_server->debug > 1) {
    {
#line 373
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               373, "msg id:             %d", (int )ns_handle._id);
#line 374
    tmp___9 = ns_msg_getflag(ns_handle, 0);
#line 374
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               374, "ns_f_qr quest/resp: %d", tmp___9);
#line 375
    tmp___10 = ns_msg_getflag(ns_handle, 1);
#line 375
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               375, "ns_f_opcode:        %d", tmp___10);
#line 376
    tmp___11 = ns_msg_getflag(ns_handle, 2);
#line 376
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               376, "ns_f_aa auth ans:   %d", tmp___11);
#line 377
    tmp___12 = ns_msg_getflag(ns_handle, 3);
#line 377
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               377, "ns_f_tc truncated:  %d", tmp___12);
#line 378
    tmp___13 = ns_msg_getflag(ns_handle, 4);
#line 378
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               378, "ns_f_rd rec desire: %d", tmp___13);
#line 379
    tmp___14 = ns_msg_getflag(ns_handle, 5);
#line 379
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               379, "ns_f_ra rec avail:  %d", tmp___14);
#line 380
    tmp___15 = ns_msg_getflag(ns_handle, 9);
#line 380
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               380, "ns_f_rcode:         %d", tmp___15);
    }
  }
#line 385
  ns_sect___0 = 0;
  {
#line 385
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 385
    if (! (ns_sect___0 < (int )num_ns_sect___4)) {
#line 385
      goto while_break___1;
    }
#line 391
    if (ns_sects___4[ns_sect___0].number != 1) {
#line 391
      if (spf_dns_server->debug <= 1) {
#line 392
        goto __Cont;
      }
    }
#line 394
    nrec = (int )ns_handle._counts[ns_sects___4[ns_sect___0].number];
#line 396
    if (spf_dns_server->debug > 1) {
      {
#line 397
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 397, "%s:  %d", ns_sects___4[ns_sect___0].name, nrec);
      }
    }
#line 399
    spfrr->num_rr = 0;
#line 400
    cnt = 0;
#line 401
    i = 0;
    {
#line 401
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 401
      if (! (i < nrec)) {
#line 401
        goto while_break___2;
      }
      {
#line 402
      err = ns_parserr(& ns_handle, (ns_sect )ns_sects___4[ns_sect___0].number, i,
                       & rr);
      }
#line 403
      if (err < 0) {
#line 404
        if (spf_dns_server->debug > 1) {
          {
#line 405
          tmp___16 = __errno_location();
#line 405
          tmp___17 = __errno_location();
#line 405
          tmp___18 = strerror(*tmp___17);
#line 405
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     406, "ns_parserr failed: err = %d  %s (%d)", err, tmp___18, *tmp___16);
          }
        }
        {
#line 407
        free((void *)responsebuf);
#line 410
        spfrr->herrno = 3;
        }
#line 411
        return (spfrr);
      }
#line 414
      rdlen = (size_t )((int )rr.rdlength);
#line 415
      if (spf_dns_server->debug > 1) {
#line 416
        if ((int )rr.name[0] != 0) {
#line 416
          tmp___19 = (char const   *)(rr.name);
        } else {
#line 416
          tmp___19 = ".";
        }
        {
#line 416
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   418, "name: %s  type: %d  class: %d  ttl: %d  rdlen: %lu", tmp___19,
                   (unsigned int )((ns_type )((int )rr.type)), (unsigned int )((ns_class )((int )rr.rr_class)),
                   rr.ttl, rdlen);
        }
      }
#line 420
      if (rdlen <= 0UL) {
#line 421
        goto __Cont___0;
      }
#line 423
      rdata = rr.rdata + 0;
#line 425
      if (spf_dns_server->debug > 1) {
        {
#line 426
        SPF_dns_resolv_debug___4(spf_dns_server, rr, (u_char const   *)responsebuf,
                                 responselen, rdata, rdlen);
        }
      }
#line 430
      if (ns_sects___4[ns_sect___0].number != 1) {
#line 431
        goto __Cont___0;
      }
#line 434
      if ((unsigned int )((ns_type )((int )rr.type)) != (unsigned int )spfrr->rr_type) {
#line 434
        if ((unsigned int )((ns_type )((int )rr.type)) != 5U) {
          {
#line 435
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     436, "unexpected rr type: %d   expected: %d", (unsigned int )((ns_type )((int )rr.type)),
                     (unsigned int )rr_type);
          }
#line 437
          goto __Cont___0;
        }
      }
      {
#line 441
      if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 441
        goto case_1;
      }
#line 458
      if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 458
        goto case_28;
      }
#line 475
      if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 475
        goto case_2;
      }
#line 478
      if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 478
        goto case_5;
      }
#line 482
      if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 482
        goto case_15;
      }
#line 513
      if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 513
        goto case_16;
      }
#line 562
      if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 562
        goto case_12;
      }
#line 588
      goto switch_default;
      case_1: /* CIL Label */ 
#line 442
      if (rdlen != 4UL) {
        {
#line 444
        free((void *)responsebuf);
        }
#line 445
        return (spfrr);
      }
      {
#line 447
      tmp___20 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->a));
      }
#line 447
      if ((unsigned int )tmp___20 != 0U) {
        {
#line 449
        free((void *)responsebuf);
        }
#line 452
        return (spfrr);
      }
      {
#line 454
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->a), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->a));
#line 455
      cnt ++;
      }
#line 456
      goto switch_break;
      case_28: /* CIL Label */ 
#line 459
      if (rdlen != 16UL) {
        {
#line 461
        free((void *)responsebuf);
        }
#line 462
        return (spfrr);
      }
      {
#line 464
      tmp___21 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->aaaa));
      }
#line 464
      if ((unsigned int )tmp___21 != 0U) {
        {
#line 466
        free((void *)responsebuf);
        }
#line 469
        return (spfrr);
      }
      {
#line 471
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->aaaa), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->aaaa));
#line 472
      cnt ++;
      }
#line 473
      goto switch_break;
      case_2: /* CIL Label */ 
#line 476
      goto switch_break;
      case_5: /* CIL Label */ 
#line 480
      goto switch_break;
      case_15: /* CIL Label */ 
#line 483
      if (rdlen < 2UL) {
        {
#line 485
        free((void *)responsebuf);
        }
#line 486
        return (spfrr);
      }
      {
#line 488
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata + 2, name_buf, sizeof(name_buf));
      }
#line 492
      if (err < 0) {
#line 493
        if (spf_dns_server->debug > 1) {
          {
#line 494
          tmp___22 = __errno_location();
#line 494
          tmp___23 = __errno_location();
#line 494
          tmp___24 = strerror(*tmp___23);
#line 494
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     495, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___24,
                     *tmp___22);
          }
        }
        {
#line 496
        free((void *)responsebuf);
        }
#line 499
        return (spfrr);
      }
      {
#line 502
      tmp___25 = strlen((char const   *)(name_buf));
#line 502
      tmp___26 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___25 + 1UL);
      }
#line 502
      if ((unsigned int )tmp___26 != 0U) {
        {
#line 504
        free((void *)responsebuf);
        }
#line 507
        return (spfrr);
      }
      {
#line 509
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->mx), (char const   */* __restrict  */)(name_buf));
#line 510
      cnt ++;
      }
#line 511
      goto switch_break;
      case_16: /* CIL Label */ 
#line 514
      if (rdlen > 1UL) {
        {
#line 520
        tmp___27 = SPF_dns_rr_buf_realloc(spfrr, cnt, rdlen);
        }
#line 520
        if ((unsigned int )tmp___27 != 0U) {
          {
#line 521
          free((void *)responsebuf);
          }
#line 524
          return (spfrr);
        }
#line 527
        dst = (u_char *)((*(spfrr->rr + cnt))->txt);
#line 528
        src = (u_char *)rdata;
#line 529
        len = (size_t )0;
        {
#line 530
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 530
          if (! (rdlen > 0UL)) {
#line 530
            goto while_break___3;
          }
#line 532
          len = (size_t )*src;
#line 533
          src ++;
#line 534
          rdlen --;
#line 538
          if (len > rdlen) {
#line 539
            len = rdlen;
          }
          {
#line 540
          memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src,
                 len);
#line 543
          src += len;
#line 544
          dst += len;
#line 545
          rdlen -= len;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 547
        *dst = (u_char )'\000';
      } else {
        {
#line 550
        tmp___28 = SPF_dns_rr_buf_realloc(spfrr, cnt, (size_t )1);
        }
#line 550
        if ((unsigned int )tmp___28 != 0U) {
          {
#line 551
          free((void *)responsebuf);
          }
#line 554
          return (spfrr);
        }
#line 556
        (*(spfrr->rr + cnt))->txt[0] = (char )'\000';
      }
#line 559
      cnt ++;
#line 560
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 563
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata, name_buf, sizeof(name_buf));
      }
#line 567
      if (err < 0) {
#line 568
        if (spf_dns_server->debug > 1) {
          {
#line 569
          tmp___29 = __errno_location();
#line 569
          tmp___30 = __errno_location();
#line 569
          tmp___31 = strerror(*tmp___30);
#line 569
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     570, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___31,
                     *tmp___29);
          }
        }
        {
#line 571
        free((void *)responsebuf);
        }
#line 574
        return (spfrr);
      }
      {
#line 577
      tmp___32 = strlen((char const   *)(name_buf));
#line 577
      tmp___33 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___32 + 1UL);
      }
#line 577
      if ((unsigned int )tmp___33 != 0U) {
        {
#line 579
        free((void *)responsebuf);
        }
#line 582
        return (spfrr);
      }
      {
#line 584
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->ptr), (char const   */* __restrict  */)(name_buf));
#line 585
      cnt ++;
      }
#line 586
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 589
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 401
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 593
    spfrr->num_rr = cnt;
    __Cont: /* CIL Label */ 
#line 385
    ns_sect___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 596
  if (spfrr->num_rr == 0) {
#line 597
    spfrr->herrno = 4;
  }
  {
#line 599
  free((void *)responsebuf);
  }
#line 600
  return (spfrr);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_free___4(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 607
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 607, "%s", "spf_dns_server is NULL");
      }
    }
#line 607
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  free((void *)spf_dns_server);
  }
#line 614
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c"
static SPF_errcode_t SPF_server_get_default_explanation___4(SPF_server_t *spf_server___1 ,
                                                            SPF_request_t *spf_request ,
                                                            SPF_response_t *spf_response ,
                                                            char **bufp , size_t *buflenp ) 
{ 
  SPF_errcode_t err ;
  SPF_macro_t *spf_macro ;
  SPF_data_t *tmp ;
  size_t len ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  spf_macro = spf_server___1->explanation;
#line 56
  if ((unsigned long )spf_macro != (unsigned long )((void *)0)) {
    {
#line 57
    tmp = SPF_macro_data(spf_macro);
#line 57
    err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, tmp, spf_macro->macro_len,
                                 bufp, buflenp);
    }
#line 61
    return (err);
  } else {
#line 64
    len = sizeof("SPF failure: no explanation available") + 1UL;
#line 65
    if (*buflenp < len) {
      {
#line 66
      tmp___1 = realloc((void *)*bufp, len);
#line 66
      tmp___0 = (char *)tmp___1;
      }
#line 67
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 68
        return ((SPF_errcode_t )1);
      }
#line 69
      *bufp = tmp___0;
#line 70
      *buflenp = len;
    }
    {
#line 72
    strcpy((char */* __restrict  */)*bufp, (char const   */* __restrict  */)"SPF failure: no explanation available");
    }
#line 73
    return ((SPF_errcode_t )0);
  }
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c"
static SPF_errcode_t SPF_record_stringify_data___5(SPF_data_t *data , SPF_data_t *data_end ,
                                                   char **p_p , char *p_end , int is_mod ,
                                                   int cidr_ok , int debug ) 
{ 
  char *p ;
  size_t len ;
  SPF_data_t *cidr_data ;
  char *s ;
  char *tmp ;
  char *s_end ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 48
  p = *p_p;
#line 54
  if (debug) {
    {
#line 55
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
               55, " string data: Building");
    }
  }
#line 57
  if (p_end - p <= 0L) {
#line 58
    return ((SPF_errcode_t )10);
  }
#line 60
  cidr_data = (SPF_data_t *)((void *)0);
#line 61
  if ((unsigned long )data < (unsigned long )data_end) {
#line 61
    if ((int )data->dc.parm_type == 11) {
#line 63
      if (debug) {
        {
#line 64
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   64, " string data: Found a CIDR at %p", data);
        }
      }
#line 65
      if (! cidr_ok) {
#line 66
        return ((SPF_errcode_t )10);
      }
      {
#line 68
      cidr_data = data;
#line 69
      data = SPF_data_next(data);
      }
    }
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )data < (unsigned long )data_end)) {
#line 73
      goto while_break;
    }
#line 75
    if (debug) {
      {
#line 76
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 77, " string data: Handling data type %d at %p", (int )data->ds.parm_type,
                 data);
      }
    }
#line 78
    if ((int )data->ds.parm_type == 12) {
      {
#line 80
      tmp = SPF_data_str(data);
#line 80
      s = tmp;
#line 81
      s_end = s + (int )data->ds.len;
      }
#line 82
      if (debug) {
        {
#line 83
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   84, " string data: String is [%d] \'%*.*s\'", (int )data->ds.len,
                   (int )data->ds.len, (int )data->ds.len, s);
        }
      }
#line 86
      if (p_end - (p + (int )data->ds.len) <= 0L) {
#line 87
        return ((SPF_errcode_t )10);
      }
      {
#line 89
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 89
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 89
          goto while_break___0;
        }
#line 90
        if ((int )*s == 32) {
#line 91
          tmp___0 = p;
#line 91
          p ++;
#line 91
          *tmp___0 = (char )'%';
#line 92
          tmp___1 = p;
#line 92
          p ++;
#line 92
          *tmp___1 = (char )'_';
#line 93
          s ++;
        } else
#line 95
        if ((int )*s == 37) {
#line 96
          tmp___2 = p;
#line 96
          p ++;
#line 96
          *tmp___2 = (char )'%';
#line 97
          s ++;
#line 98
          if ((int )*(s + 0) == 50) {
#line 98
            if ((int )*(s + 1) == 48) {
#line 99
              tmp___3 = p;
#line 99
              p ++;
#line 99
              *tmp___3 = (char )'-';
#line 100
              s += 2;
            } else {
#line 103
              tmp___4 = p;
#line 103
              p ++;
#line 103
              *tmp___4 = (char )'%';
            }
          } else {
#line 103
            tmp___4 = p;
#line 103
            p ++;
#line 103
            *tmp___4 = (char )'%';
          }
        } else {
#line 108
          tmp___5 = p;
#line 108
          p ++;
#line 108
          tmp___6 = s;
#line 108
          s ++;
#line 108
          *tmp___5 = *tmp___6;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 112
      if (p_end - p <= 0L) {
#line 113
        return ((SPF_errcode_t )10);
      }
    } else
#line 115
    if ((int )data->dc.parm_type == 11) {
#line 117
      return ((SPF_errcode_t )8);
    } else {
      {
#line 120
      tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%%{");
#line 120
      len = (size_t )tmp___7;
#line 121
      p += len;
      }
#line 122
      if (p_end - p <= 0L) {
#line 122
        return ((SPF_errcode_t )10);
      }
#line 125
      if (p_end - p <= 1L) {
#line 125
        return ((SPF_errcode_t )10);
      }
      {
#line 128
      if ((int )data->dv.parm_type == 0) {
#line 128
        goto case_0;
      }
#line 132
      if ((int )data->dv.parm_type == 1) {
#line 132
        goto case_1;
      }
#line 136
      if ((int )data->dv.parm_type == 2) {
#line 136
        goto case_2;
      }
#line 140
      if ((int )data->dv.parm_type == 3) {
#line 140
        goto case_3;
      }
#line 144
      if ((int )data->dv.parm_type == 4) {
#line 144
        goto case_4;
      }
#line 148
      if ((int )data->dv.parm_type == 5) {
#line 148
        goto case_5;
      }
#line 152
      if ((int )data->dv.parm_type == 6) {
#line 152
        goto case_6;
      }
#line 158
      if ((int )data->dv.parm_type == 7) {
#line 158
        goto case_7;
      }
#line 162
      if ((int )data->dv.parm_type == 8) {
#line 162
        goto case_8;
      }
#line 166
      if ((int )data->dv.parm_type == 9) {
#line 166
        goto case_9;
      }
#line 170
      if ((int )data->dv.parm_type == 10) {
#line 170
        goto case_10;
      }
#line 174
      goto switch_default;
      case_0: /* CIL Label */ 
#line 129
      *p = (char )'l';
#line 130
      goto switch_break;
      case_1: /* CIL Label */ 
#line 133
      *p = (char )'s';
#line 134
      goto switch_break;
      case_2: /* CIL Label */ 
#line 137
      *p = (char )'o';
#line 138
      goto switch_break;
      case_3: /* CIL Label */ 
#line 141
      *p = (char )'d';
#line 142
      goto switch_break;
      case_4: /* CIL Label */ 
#line 145
      *p = (char )'i';
#line 146
      goto switch_break;
      case_5: /* CIL Label */ 
#line 149
      *p = (char )'c';
#line 150
      goto switch_break;
      case_6: /* CIL Label */ 
#line 153
      if (! is_mod) {
#line 154
        return ((SPF_errcode_t )12);
      }
#line 155
      *p = (char )'t';
#line 156
      goto switch_break;
      case_7: /* CIL Label */ 
#line 159
      *p = (char )'p';
#line 160
      goto switch_break;
      case_8: /* CIL Label */ 
#line 163
      *p = (char )'v';
#line 164
      goto switch_break;
      case_9: /* CIL Label */ 
#line 167
      *p = (char )'h';
#line 168
      goto switch_break;
      case_10: /* CIL Label */ 
#line 171
      *p = (char )'r';
#line 172
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 175
      return ((SPF_errcode_t )12);
#line 176
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 178
      if (data->dv.url_encode) {
        {
#line 179
        tmp___8 = toupper((int )*p);
#line 179
        *p = (char )tmp___8;
        }
      }
#line 180
      p ++;
#line 181
      if (p_end - p <= 0L) {
#line 181
        return ((SPF_errcode_t )10);
      }
#line 184
      if (data->dv.num_rhs) {
        {
#line 186
        tmp___9 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%d",
                           (int )data->dv.num_rhs);
#line 186
        len = (size_t )tmp___9;
#line 187
        p += len;
        }
#line 188
        if (p_end - p <= 0L) {
#line 188
          return ((SPF_errcode_t )10);
        }
      }
#line 192
      if (p_end - p <= 8L) {
#line 192
        return ((SPF_errcode_t )10);
      }
#line 193
      if (data->dv.rev) {
#line 194
        tmp___10 = p;
#line 194
        p ++;
#line 194
        *tmp___10 = (char )'r';
      }
#line 196
      if (data->dv.delim_dot) {
#line 196
        if (data->dv.delim_dash) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_plus) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_equal) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_bar) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_under) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        }
      }
#line 205
      if (data->dv.delim_dash) {
#line 206
        tmp___12 = p;
#line 206
        p ++;
#line 206
        *tmp___12 = (char )'-';
      }
#line 207
      if (data->dv.delim_plus) {
#line 208
        tmp___13 = p;
#line 208
        p ++;
#line 208
        *tmp___13 = (char )'+';
      }
#line 209
      if (data->dv.delim_equal) {
#line 210
        tmp___14 = p;
#line 210
        p ++;
#line 210
        *tmp___14 = (char )'=';
      }
#line 211
      if (data->dv.delim_bar) {
#line 212
        tmp___15 = p;
#line 212
        p ++;
#line 212
        *tmp___15 = (char )'|';
      }
#line 213
      if (data->dv.delim_under) {
#line 214
        tmp___16 = p;
#line 214
        p ++;
#line 214
        *tmp___16 = (char )'_';
      }
#line 216
      tmp___17 = p;
#line 216
      p ++;
#line 216
      *tmp___17 = (char )'}';
#line 217
      if (p_end - p <= 0L) {
#line 217
        return ((SPF_errcode_t )10);
      }
    }
    {
#line 73
    data = SPF_data_next(data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (cidr_data) {
#line 224
    if (cidr_data->dc.ipv4) {
      {
#line 226
      tmp___18 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"/%d",
                          (int )cidr_data->dc.ipv4);
#line 226
      len = (size_t )tmp___18;
#line 227
      p += len;
      }
#line 228
      if (p_end - p <= 0L) {
#line 228
        return ((SPF_errcode_t )10);
      }
    }
#line 231
    if (cidr_data->dc.ipv6) {
      {
#line 233
      tmp___19 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"//%d",
                          (int )cidr_data->dc.ipv6);
#line 233
      len = (size_t )tmp___19;
#line 234
      p += len;
      }
#line 235
      if (p_end - p <= 0L) {
#line 235
        return ((SPF_errcode_t )10);
      }
    }
  }
#line 239
  *p_p = p;
#line 240
  return ((SPF_errcode_t )0);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv4___5[8]  = 
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
  {      (char const   )'i',      (char const   )'n',      (char const   )'-',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv6___5[4]  = {      (char const   )'i',      (char const   )'p',      (char const   )'6',      (char const   )'\000'};
#line 95 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_find___5(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                           ns_type rr_type , int exact ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;
  int tmp ;
  size_t domain_len ;
  size_t tmp___0 ;
  size_t zdomain_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 103
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 105
  if (spf_dns_server->debug) {
    {
#line 106
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
               106, "zone: Searching for RR %s (%d)", domain, (unsigned int )rr_type);
    }
  }
#line 110
  if (exact) {
#line 110
    goto _L;
  } else {
    {
#line 110
    tmp___6 = strncmp(domain, "*.", (size_t )2);
    }
#line 110
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
#line 111
      i = 0;
      {
#line 111
      while (1) {
        while_continue: /* CIL Label */ ;
#line 111
        if (! (i < spfhook->num_zone)) {
#line 111
          goto while_break;
        }
#line 112
        if ((unsigned int )(*(spfhook->zone + i))->rr_type == (unsigned int )rr_type) {
          {
#line 112
          tmp = strcasecmp((char const   *)(*(spfhook->zone + i))->domain, domain);
          }
#line 112
          if (tmp == 0) {
#line 114
            return (*(spfhook->zone + i));
          }
        }
#line 111
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 116
      if (spf_dns_server->debug) {
        {
#line 117
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   117, "zone: Exact not found");
        }
      }
    } else {
      {
#line 121
      tmp___0 = strlen(domain);
#line 121
      domain_len = tmp___0;
      }
#line 125
      if (domain_len) {
#line 125
        if ((int const   )*(domain + (domain_len - 1UL)) == 46) {
#line 126
          domain_len --;
        }
      }
#line 128
      i = 0;
      {
#line 128
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 128
        if (! (i < spfhook->num_zone)) {
#line 128
          goto while_break___0;
        }
#line 129
        if ((unsigned int )(*(spfhook->zone + i))->rr_type != (unsigned int )rr_type) {
#line 129
          if ((unsigned int )(*(spfhook->zone + i))->rr_type != 255U) {
#line 131
            if (spf_dns_server->debug) {
              {
#line 132
              SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                         133, "zone: Ignoring record rrtype %d", (unsigned int )(*(spfhook->zone + i))->rr_type);
              }
            }
#line 134
            goto __Cont;
          }
        }
        {
#line 137
        tmp___5 = strncmp((char const   *)(*(spfhook->zone + i))->domain, "*.", (size_t )2);
        }
#line 137
        if (tmp___5 == 0) {
          {
#line 138
          tmp___1 = strlen((char const   *)(*(spfhook->zone + i))->domain);
#line 138
          zdomain_len = tmp___1 - 2UL;
          }
#line 139
          if (zdomain_len <= domain_len) {
            {
#line 139
            tmp___2 = strncasecmp((char const   *)((*(spfhook->zone + i))->domain + 2),
                                  domain + (domain_len - zdomain_len), zdomain_len);
            }
#line 139
            if (tmp___2 == 0) {
#line 144
              return (*(spfhook->zone + i));
            }
          }
        } else {
          {
#line 146
          tmp___3 = strncasecmp((char const   *)(*(spfhook->zone + i))->domain, domain,
                                domain_len);
          }
#line 146
          if (tmp___3 == 0) {
            {
#line 146
            tmp___4 = strlen((char const   *)(*(spfhook->zone + i))->domain);
            }
#line 146
            if (tmp___4 == domain_len) {
#line 151
              return (*(spfhook->zone + i));
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 128
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 154
      if (spf_dns_server->debug) {
        {
#line 155
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   155, "zone: Non-exact not found");
        }
      }
    }
  }
#line 158
  return ((SPF_dns_rr_t *)((void *)0));
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_lookup___5(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  SPF_dns_rr_t *spfrr ;
  SPF_dns_rr_t *tmp ;

  {
  {
#line 170
  spfrr = SPF_dns_zone_find___5(spf_dns_server, domain, rr_type, 0);
  }
#line 171
  if (spfrr) {
    {
#line 172
    SPF_dns_rr_dup(& spfrr, spfrr);
    }
#line 173
    return (spfrr);
  }
#line 176
  if (spf_dns_server->layer_below) {
    {
#line 177
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 177
    return (tmp);
  }
  {
#line 181
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
#line 182
  SPF_dns_rr_dup(& spfrr, spfhook->nxdomain);
  }
#line 184
  return (spfrr);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static void SPF_dns_zone_free___5(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 317
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                 317, "%s", "spf_dns_server is NULL");
      }
    }
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 320
  if (spfhook) {
#line 321
    if (spfhook->zone) {
#line 322
      i = 0;
      {
#line 322
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 322
        if (! (i < spfhook->zone_buf_len)) {
#line 322
          goto while_break___0;
        }
#line 323
        if (*(spfhook->zone + i)) {
          {
#line 324
          SPF_dns_rr_free(*(spfhook->zone + i));
          }
        }
#line 322
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 326
      free((void *)spfhook->zone);
      }
    }
#line 328
    if (spfhook->nxdomain) {
      {
#line 329
      SPF_dns_rr_free(spfhook->nxdomain);
      }
    }
    {
#line 330
    free((void *)spfhook);
    }
  }
  {
#line 333
  free((void *)spf_dns_server);
  }
#line 334
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_server_set_rec_dom_ghbn___2)(SPF_server_t *sp ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 70
  tmp = malloc((size_t )64);
#line 70
  sp->rec_dom = (char *)tmp;
  }
#line 71
  if (! sp->rec_dom) {
#line 72
    return ((SPF_errcode_t )1);
  }
  {
#line 77
  tmp___0 = gethostname(sp->rec_dom, (size_t )64);
  }
#line 77
  if (tmp___0 < 0) {
#line 79
    return ((SPF_errcode_t )10);
  }
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static void SPF_server_new_common_pre___2(SPF_server_t *sp , int debug ) 
{ 
  SPF_errcode_t err ;

  {
  {
#line 89
  memset((void *)sp, 0, sizeof(SPF_server_t ));
#line 91
  sp->max_dns_mech = 10;
#line 92
  sp->max_dns_ptr = 10;
#line 93
  sp->max_dns_mx = 10;
#line 94
  sp->debug = debug;
#line 96
  err = SPF_server_set_rec_dom_ghbn___2(sp);
  }
#line 97
  if ((unsigned int )err != 0U) {
    {
#line 98
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               98, "%s", "Failed to set rec_dom using gethostname()");
    }
  }
#line 99
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static void SPF_server_new_common_post___2(SPF_server_t *sp ) 
{ 
  SPF_response_t *spf_response ;
  SPF_errcode_t err ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 107
  spf_response = (SPF_response_t *)((void *)0);
#line 108
  err = SPF_server_set_explanation(sp, "Please%_see%_http://www.openspf.org/Why?id=%{S}&ip=%{C}&receiver=%{R}",
                                   & spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
    {
#line 111
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               111, "Error code %d compiling default explanation", (unsigned int )err);
    }
  }
#line 112
  if (spf_response) {
    {
#line 114
    tmp = SPF_response_messages(spf_response);
    }
#line 114
    if (tmp > 0) {
      {
#line 115
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 115, "%s", "Response errors compiling default explanation");
      }
    }
    {
#line 116
    SPF_response_free(spf_response);
    }
  }
  {
#line 119
  spf_response = (SPF_response_t *)((void *)0);
#line 120
  err = SPF_server_set_localpolicy(sp, "", 0, & spf_response);
  }
#line 121
  if ((unsigned int )err != 0U) {
    {
#line 122
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               122, "Error code %d compiling default whitelist", (unsigned int )err);
    }
  }
#line 123
  if (spf_response) {
    {
#line 125
    tmp___0 = SPF_response_messages(spf_response);
    }
#line 125
    if (tmp___0 > 0) {
      {
#line 126
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 126, "%s", "Response errors compiling default whitelist");
      }
    }
    {
#line 127
    SPF_response_free(spf_response);
    }
  }
#line 129
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static char const   digits___2[11]  = 
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 63 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static char const   digitvalue___2[256]  = 
#line 63
  {      (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )0,      (char const   )1,      (char const   )2,      (char const   )3, 
        (char const   )4,      (char const   )5,      (char const   )6,      (char const   )7, 
        (char const   )8,      (char const   )9,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )13,      (char const   )14,      (char const   )15,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )13,      (char const   )14,      (char const   )15,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1};
#line 84
static int special___2(int ch ) ;
#line 85
static int printable___2(int ch ) ;
#line 86
static int dn_find___2(u_char const   *domain , u_char const   *msg , u_char const   * const  *dnptrs ,
                       u_char const   * const  *lastdnptr ) ;
#line 89
static int encode_bitsring___2(char const   **bp , char const   *end , char **labelp ,
                               char **dst , char const   *eom ) ;
#line 91
static int labellen___2(u_char const   *lp ) ;
#line 92
static int decode_bitstring___2(char const   **cpp , char *dn , char const   *eom ) ;
#line 693 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int special___2(int ch ) 
{ 


  {
  {
#line 704
  if (ch == 36) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 64) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 41) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 40) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 92) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 59) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 46) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 34) {
#line 704
    goto case_36;
  }
#line 706
  goto switch_default;
  case_36: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_34: /* CIL Label */ 
#line 705
  return (1);
  switch_default: /* CIL Label */ 
#line 707
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int printable___2(int ch ) 
{ 
  int tmp ;

  {
#line 720
  if (ch > 32) {
#line 720
    if (ch < 127) {
#line 720
      tmp = 1;
    } else {
#line 720
      tmp = 0;
    }
  } else {
#line 720
    tmp = 0;
  }
#line 720
  return (tmp);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int mklower___2(int ch ) 
{ 


  {
#line 729
  if (ch >= 65) {
#line 729
    if (ch <= 90) {
#line 730
      return (ch + 32);
    }
  }
#line 731
  return (ch);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int dn_find___2(u_char const   *domain , u_char const   *msg , u_char const   * const  *dnptrs ,
                       u_char const   * const  *lastdnptr ) 
{ 
  u_char const   *dn ;
  u_char const   *cp ;
  u_char const   *sp ;
  u_char const   * const  *cpp ;
  u_int n ;
  int tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  int tmp___2 ;
  u_char const   *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  u_char const   *tmp___6 ;
  int *tmp___7 ;

  {
#line 752
  cpp = dnptrs;
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! ((unsigned long )cpp < (unsigned long )lastdnptr)) {
#line 752
      goto while_break;
    }
#line 753
    sp = (u_char const   *)*cpp;
    {
#line 760
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 760
      if ((int const   )*sp != 0) {
#line 760
        if (((int const   )*sp & 192) == 0) {
#line 760
          if (! (sp - msg < 16384L)) {
#line 760
            goto while_break___0;
          }
        } else {
#line 760
          goto while_break___0;
        }
      } else {
#line 760
        goto while_break___0;
      }
#line 762
      dn = domain;
#line 763
      cp = sp;
      {
#line 764
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 764
        tmp___6 = cp;
#line 764
        cp ++;
#line 764
        n = (u_int )*tmp___6;
#line 764
        if (! (n != 0U)) {
#line 764
          goto while_break___1;
        }
        {
#line 769
        if ((n & 192U) == 0U) {
#line 769
          goto case_0;
        }
#line 785
        if ((n & 192U) == 192U) {
#line 785
          goto case_192;
        }
#line 789
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 770
        tmp = labellen___2(cp - 1);
#line 770
        n = (u_int )tmp;
#line 772
        tmp___0 = dn;
#line 772
        dn ++;
        }
#line 772
        if (n != (u_int )*tmp___0) {
#line 773
          goto next;
        }
        {
#line 775
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 775
          if (! (n > 0U)) {
#line 775
            goto while_break___2;
          }
          {
#line 776
          tmp___1 = dn;
#line 776
          dn ++;
#line 776
          tmp___2 = mklower___2((int )*tmp___1);
#line 776
          tmp___3 = cp;
#line 776
          cp ++;
#line 776
          tmp___4 = mklower___2((int )*tmp___3);
          }
#line 776
          if (tmp___2 != tmp___4) {
#line 778
            goto next;
          }
#line 775
          n --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 780
        if ((int const   )*dn == 0) {
#line 780
          if ((int const   )*cp == 0) {
#line 781
            return ((int )(sp - msg));
          }
        }
#line 782
        if (*dn) {
#line 783
          goto while_continue___1;
        }
#line 784
        goto next;
        case_192: /* CIL Label */ 
#line 786
        cp = msg + (((n & 63U) << 8) | (unsigned int )*cp);
#line 787
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 790
        tmp___5 = __errno_location();
#line 790
        *tmp___5 = 90;
        }
#line 791
        return (-1);
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      next: 
#line 795
      sp += (int const   )*sp + 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 752
    cpp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 798
  tmp___7 = __errno_location();
#line 798
  *tmp___7 = 2;
  }
#line 799
  return (-1);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int decode_bitstring___2(char const   **cpp , char *dn , char const   *eom ) 
{ 
  char const   *cp ;
  char *beg ;
  char tc ;
  int b ;
  int blen ;
  int plen ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 805
  cp = *cpp;
#line 806
  beg = dn;
#line 809
  blen = (int )((int const   )*cp & 255);
#line 809
  if (blen == 0) {
#line 810
    blen = 256;
  }
#line 811
  plen = (blen + 3) / 4;
#line 812
  if (blen > 99) {
#line 812
    tmp___0 = 3;
  } else {
#line 812
    if (blen > 9) {
#line 812
      tmp = 2;
    } else {
#line 812
      tmp = 1;
    }
#line 812
    tmp___0 = tmp;
  }
#line 812
  plen = (int )((unsigned long )plen + (sizeof("\\[x/]") + (unsigned long )tmp___0));
#line 813
  if ((unsigned long )(dn + plen) >= (unsigned long )eom) {
#line 814
    return (-1);
  }
  {
#line 816
  cp ++;
#line 817
  tmp___1 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"\\[x");
#line 817
  i = (int )((size_t )tmp___1);
  }
#line 818
  if (i < 0) {
#line 819
    return (-1);
  }
#line 820
  dn += i;
#line 821
  b = blen;
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! (b > 7)) {
#line 821
      goto while_break;
    }
    {
#line 822
    tmp___2 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%02x",
                      (int const   )*cp & 255);
#line 822
    i = (int )((size_t )tmp___2);
    }
#line 823
    if (i < 0) {
#line 824
      return (-1);
    }
#line 825
    dn += i;
#line 821
    b -= 8;
#line 821
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 827
  if (b > 4) {
    {
#line 828
    tmp___3 = cp;
#line 828
    cp ++;
#line 828
    tc = (char )*tmp___3;
#line 829
    tmp___4 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%02x",
                      (int )tc & (255 << (8 - b)));
#line 829
    i = (int )((size_t )tmp___4);
    }
#line 830
    if (i < 0) {
#line 831
      return (-1);
    }
#line 832
    dn += i;
  } else
#line 833
  if (b > 0) {
    {
#line 834
    tmp___5 = cp;
#line 834
    cp ++;
#line 834
    tc = (char )*tmp___5;
#line 835
    tmp___6 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%1x",
                      (((int )tc >> 4) & 15) & (15 << (4 - b)));
#line 835
    i = (int )((size_t )tmp___6);
    }
#line 837
    if (i < 0) {
#line 838
      return (-1);
    }
#line 839
    dn += i;
  }
  {
#line 841
  tmp___7 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"/%d]",
                    blen);
#line 841
  i = (int )((size_t )tmp___7);
  }
#line 842
  if (i < 0) {
#line 843
    return (-1);
  }
#line 844
  dn += i;
#line 846
  *cpp = cp;
#line 847
  return ((int )(dn - beg));
}
}
#line 850 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int encode_bitsring___2(char const   **bp , char const   *end , char **labelp ,
                               char **dst , char const   *eom ) 
{ 
  int afterslash ;
  char const   *cp ;
  char *tp ;
  char c ;
  char const   *beg_blen ;
  char *end_blen ;
  int value ;
  int count ;
  int tbcount ;
  int blen ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  int traillen ;

  {
#line 854
  afterslash = 0;
#line 855
  cp = *bp;
#line 858
  end_blen = (char *)((void *)0);
#line 859
  value = 0;
#line 859
  count = 0;
#line 859
  tbcount = 0;
#line 859
  blen = 0;
#line 861
  end_blen = (char *)((void *)0);
#line 861
  beg_blen = (char const   *)end_blen;
#line 864
  if (end - cp < 2L) {
#line 865
    return (22);
  }
#line 868
  tmp = cp;
#line 868
  cp ++;
#line 868
  if ((int const   )*tmp != 120) {
#line 869
    return (22);
  }
  {
#line 870
  tmp___0 = __ctype_b_loc();
  }
#line 870
  if (! ((int const   )*(*tmp___0 + (int )((int const   )*cp & 255)) & 4096)) {
#line 871
    return (22);
  }
#line 873
  tp = *dst + 1;
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    if ((unsigned long )cp < (unsigned long )end) {
#line 873
      if (! ((unsigned long )tp < (unsigned long )eom)) {
#line 873
        goto while_break;
      }
    } else {
#line 873
      goto while_break;
    }
#line 874
    c = (char )*cp;
    {
#line 875
    if ((int )c == 93) {
#line 875
      goto case_93;
    }
#line 887
    if ((int )c == 47) {
#line 887
      goto case_47;
    }
#line 890
    goto switch_default;
    case_93: /* CIL Label */ 
#line 876
    if (afterslash) {
#line 877
      if ((unsigned long )beg_blen == (unsigned long )((void *)0)) {
#line 878
        return (22);
      }
      {
#line 879
      tmp___1 = strtol((char const   */* __restrict  */)beg_blen, (char **/* __restrict  */)(& end_blen),
                       10);
#line 879
      blen = (int )tmp___1;
      }
#line 880
      if ((int )*end_blen != 93) {
#line 881
        return (22);
      }
    }
#line 883
    if (count) {
#line 884
      tmp___2 = tp;
#line 884
      tp ++;
#line 884
      *tmp___2 = (char )((value << 4) & 255);
    }
#line 885
    cp ++;
#line 886
    goto done;
    case_47: /* CIL Label */ 
#line 888
    afterslash = 1;
#line 889
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 891
    if (afterslash) {
      {
#line 892
      tmp___3 = __ctype_b_loc();
      }
#line 892
      if (! ((int const   )*(*tmp___3 + ((int )c & 255)) & 2048)) {
#line 893
        return (22);
      }
#line 894
      if ((unsigned long )beg_blen == (unsigned long )((void *)0)) {
#line 896
        if ((int )c == 48) {
#line 898
          return (22);
        }
#line 900
        beg_blen = cp;
      }
    } else {
      {
#line 903
      tmp___4 = __ctype_b_loc();
      }
#line 903
      if (! ((int const   )*(*tmp___4 + ((int )c & 255)) & 4096)) {
#line 904
        return (22);
      }
#line 905
      value <<= 4;
#line 906
      value += (int )digitvalue___2[(int )c];
#line 907
      count += 4;
#line 908
      tbcount += 4;
#line 909
      if (tbcount > 256) {
#line 910
        return (22);
      }
#line 911
      if (count == 8) {
#line 912
        tmp___5 = tp;
#line 912
        tp ++;
#line 912
        *tmp___5 = (char )value;
#line 913
        count = 0;
      }
    }
#line 916
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 873
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 920
  if ((unsigned long )cp >= (unsigned long )end) {
#line 921
    return (90);
  } else
#line 920
  if ((unsigned long )tp >= (unsigned long )eom) {
#line 921
    return (90);
  }
#line 931
  if (blen > 0) {
#line 934
    if (((blen + 3) & -4) != tbcount) {
#line 935
      return (22);
    }
#line 936
    traillen = tbcount - blen;
#line 937
    if (((value << (8 - traillen)) & 255) != 0) {
#line 938
      return (22);
    }
  } else {
#line 941
    blen = tbcount;
  }
#line 942
  if (blen == 256) {
#line 943
    blen = 0;
  }
#line 946
  *(*labelp) = (char)65;
#line 947
  *(*dst) = (char )blen;
#line 949
  *bp = cp;
#line 950
  *dst = tp;
#line 952
  return (0);
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int labellen___2(u_char const   *lp ) 
{ 
  int bitlen ;
  u_char l ;

  {
#line 959
  l = (u_char )*lp;
#line 961
  if (((int )l & 192) == 192) {
#line 963
    return (-1);
  }
#line 966
  if (((int )l & 192) == 64) {
#line 967
    if ((int )l == 65) {
#line 968
      bitlen = (int )*(lp + 1);
#line 968
      if (bitlen == 0) {
#line 969
        bitlen = 256;
      }
#line 970
      return ((bitlen + 7) / 8 + 1);
    }
#line 972
    return (-1);
  }
#line 974
  return ((int )l);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
static SPF_errcode_t SPF_request_prepare___2(SPF_request_t *sr ) 
{ 


  {
#line 230
  if (sr->use_helo) {
#line 231
    sr->cur_dom = (char const   *)sr->helo_dom;
  } else {
#line 233
    sr->cur_dom = (char const   *)sr->env_from_dp;
  }
#line 234
  return ((SPF_errcode_t )0);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
static SPF_errcode_t SPF_request_query_record___2(SPF_request_t *spf_request , SPF_response_t *spf_response ,
                                                  SPF_record_t *spf_record , SPF_errcode_t err ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 246
  if ((unsigned int )err != 0U) {
#line 247
    if (spf_record) {
      {
#line 248
      SPF_record_free(spf_record);
      }
    }
#line 249
    return (err);
  }
  {
#line 252
  tmp___0 = SPF_response_errors(spf_response);
  }
#line 252
  if (tmp___0 > 0) {
    {
#line 253
    tmp = SPF_response_errors(spf_response);
#line 253
    SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
              255, "Warning: %d errors in response, but no error code. Evaluating.",
              tmp);
    }
  }
  {
#line 257
  spf_response->spf_record_exp = spf_record;
#line 258
  err = SPF_record_interpret(spf_record, spf_request, spf_response, 0);
#line 260
  SPF_record_free(spf_record);
  }
#line 262
  return (err);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c"
static SPF_errcode_t SPF_server_get_default_explanation___5(SPF_server_t *spf_server___1 ,
                                                            SPF_request_t *spf_request ,
                                                            SPF_response_t *spf_response ,
                                                            char **bufp , size_t *buflenp ) 
{ 
  SPF_errcode_t err ;
  SPF_macro_t *spf_macro ;
  SPF_data_t *tmp ;
  size_t len ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  spf_macro = spf_server___1->explanation;
#line 56
  if ((unsigned long )spf_macro != (unsigned long )((void *)0)) {
    {
#line 57
    tmp = SPF_macro_data(spf_macro);
#line 57
    err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, tmp, spf_macro->macro_len,
                                 bufp, buflenp);
    }
#line 61
    return (err);
  } else {
#line 64
    len = sizeof("SPF failure: no explanation available") + 1UL;
#line 65
    if (*buflenp < len) {
      {
#line 66
      tmp___1 = realloc((void *)*bufp, len);
#line 66
      tmp___0 = (char *)tmp___1;
      }
#line 67
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 68
        return ((SPF_errcode_t )1);
      }
#line 69
      *bufp = tmp___0;
#line 70
      *buflenp = len;
    }
    {
#line 72
    strcpy((char */* __restrict  */)*bufp, (char const   */* __restrict  */)"SPF failure: no explanation available");
    }
#line 73
    return ((SPF_errcode_t )0);
  }
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
static void setsection___2(ns_msg *msg , ns_sect sect ) ;
#line 197 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
static void setsection___2(ns_msg *msg , ns_sect sect ) 
{ 


  {
#line 199
  msg->_sect = sect;
#line 200
  if ((unsigned int )sect == 4U) {
#line 201
    msg->_rrnum = -1;
#line 202
    msg->_msg_ptr = (u_char const   *)((void *)0);
  } else {
#line 204
    msg->_rrnum = 0;
#line 205
    msg->_msg_ptr = msg->_sections[(int )sect];
  }
#line 207
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_explanation___5(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  char *buf ;
  size_t buflen ;
  void *tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 53
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 53, "%s", "spf_response is NULL");
      }
    }
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  spf_request = spf_response->spf_request;
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 55
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 55, "%s", "spf_request is NULL");
      }
    }
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  spf_server___1 = spf_request->spf_server;
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 57
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 57
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 57, "%s", "spf_server is NULL");
      }
    }
#line 57
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  spf_record = spf_response->spf_record_exp;
  {
#line 60
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 60
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 60
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 60, "%s", "spf_record is NULL");
      }
    }
#line 60
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 62
  if (spf_response->explanation) {
    {
#line 63
    free((void *)spf_response->explanation);
    }
  }
  {
#line 64
  spf_response->explanation = (char *)((void *)0);
#line 66
  buflen = (size_t )321;
#line 67
  tmp = malloc(buflen);
#line 67
  buf = (char *)tmp;
  }
#line 68
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 69
    return ((SPF_errcode_t )1);
  }
  {
#line 70
  memset((void *)buf, '\000', buflen);
#line 72
  err = SPF_request_get_exp(spf_server___1, spf_request, spf_response, spf_record,
                            & buf, & buflen);
  }
#line 74
  if ((unsigned int )err != 0U) {
    {
#line 75
    free((void *)buf);
    }
#line 76
    return (err);
  }
#line 79
  spf_response->explanation = buf;
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_smtp_comment___5(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_errcode_t err ;
  char buf[320] ;
  char const   *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 92
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 92, "%s", "spf_response is NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  spf_request = spf_response->spf_request;
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 94, "%s", "spf_request is NULL");
      }
    }
#line 94
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  spf_server___1 = spf_request->spf_server;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 96, "%s", "spf_server is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  if (spf_response->smtp_comment) {
    {
#line 99
    free((void *)spf_response->smtp_comment);
    }
  }
#line 100
  spf_response->smtp_comment = (char *)((void *)0);
  {
#line 107
  if ((unsigned int )spf_response->result == 5U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 1U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 4U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 3U) {
#line 107
    goto case_5;
  }
#line 129
  goto switch_default;
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 109
  err = SPF_i_set_explanation___5(spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
#line 111
    return (err);
  }
  {
#line 113
  memset((void *)(buf), '\000', sizeof(buf));
#line 114
  tmp = SPF_strreason(spf_response->reason);
#line 114
  snprintf((char */* __restrict  */)(buf), (size_t )320, (char const   */* __restrict  */)"%s : Reason: %s",
           spf_response->explanation, tmp);
#line 117
  buf[319] = (char )'\000';
#line 120
  spf_response->smtp_comment = strdup((char const   *)(buf));
  }
#line 121
  if (! spf_response->smtp_comment) {
#line 122
    return ((SPF_errcode_t )1);
  }
#line 124
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 130
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 133
  return ((SPF_errcode_t )0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_header_comment___5(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char *spf_source ;
  size_t len ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  char *sender_dom ;
  char *p ;
  char *p_end ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 153
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 153, "%s", "spf_response is NULL");
      }
    }
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  spf_request = spf_response->spf_request;
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 155
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 155, "%s", "spf_request is NULL");
      }
    }
#line 155
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 156
  spf_server___1 = spf_request->spf_server;
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 157
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 157, "%s", "spf_server is NULL");
      }
    }
#line 157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 159
  if (spf_response->header_comment) {
    {
#line 160
    free((void *)spf_response->header_comment);
    }
  }
#line 161
  spf_response->header_comment = (char *)((void *)0);
#line 164
  sender_dom = spf_request->env_from_dp;
#line 165
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
#line 166
    sender_dom = spf_request->helo_dom;
  }
#line 168
  if ((unsigned int )spf_response->reason == 3U) {
    {
#line 169
    spf_source = strdup("local policy");
    }
  } else
#line 171
  if ((unsigned int )spf_response->reason == 6U) {
#line 172
    if ((unsigned long )spf_request->rcpt_to_dom == (unsigned long )((void *)0)) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    } else
#line 172
    if ((int )*(spf_request->rcpt_to_dom + 0) == 0) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    }
    {
#line 175
    spf_source = strdup((char const   *)spf_request->rcpt_to_dom);
    }
  } else
#line 177
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
    {
#line 178
    spf_source = strdup("unknown domain");
    }
  } else {
    {
#line 181
    tmp = strlen((char const   *)sender_dom);
#line 181
    len = tmp + sizeof("domain of ");
#line 182
    tmp___0 = malloc(len);
#line 182
    spf_source = (char *)tmp___0;
    }
#line 183
    if (spf_source) {
      {
#line 184
      snprintf((char */* __restrict  */)spf_source, len, (char const   */* __restrict  */)"domain of %s",
               sender_dom);
      }
    }
  }
#line 187
  if ((unsigned long )spf_source == (unsigned long )((void *)0)) {
#line 188
    return ((SPF_errcode_t )10);
  }
#line 190
  ip = (char const   *)((void *)0);
#line 191
  if (spf_request->client_ver == 2) {
    {
#line 192
    ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                   (socklen_t )sizeof(ip4_buf));
    }
  } else
#line 195
  if (spf_request->client_ver == 10) {
    {
#line 196
    ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                   (socklen_t )sizeof(ip6_buf));
    }
  }
#line 199
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 200
    ip = "(unknown ip address)";
  }
  {
#line 202
  tmp___1 = SPF_request_get_rec_dom(spf_request);
#line 202
  tmp___2 = strlen(tmp___1);
#line 202
  tmp___3 = strlen((char const   *)spf_source);
#line 202
  tmp___4 = strlen(ip);
#line 202
  len = ((tmp___2 + tmp___3) + tmp___4) + 80UL;
#line 203
  tmp___5 = malloc(len);
#line 203
  buf = (char *)tmp___5;
  }
#line 204
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 205
    free((void *)spf_source);
    }
#line 206
    return ((SPF_errcode_t )10);
  }
  {
#line 209
  p = buf;
#line 210
  p_end = p + len;
#line 213
  tmp___6 = SPF_request_get_rec_dom(spf_request);
#line 213
  tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s: ",
                     tmp___6);
#line 213
  p += tmp___7;
  }
  {
#line 217
  if ((unsigned int )spf_response->result == 2U) {
#line 217
    goto case_2;
  }
#line 228
  if ((unsigned int )spf_response->result == 3U) {
#line 228
    goto case_3;
  }
#line 233
  if ((unsigned int )spf_response->result == 4U) {
#line 233
    goto case_4;
  }
#line 238
  if ((unsigned int )spf_response->result == 7U) {
#line 238
    goto case_7;
  }
#line 243
  if ((unsigned int )spf_response->result == 1U) {
#line 243
    goto case_1;
  }
#line 247
  if ((unsigned int )spf_response->result == 5U) {
#line 247
    goto case_5;
  }
#line 252
  if ((unsigned int )spf_response->result == 6U) {
#line 252
    goto case_6;
  }
#line 258
  goto switch_default;
  case_2: /* CIL Label */ 
#line 218
  if ((unsigned int )spf_response->reason == 2U) {
    {
#line 219
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"localhost is always allowed.");
    }
  } else
#line 220
  if ((unsigned int )spf_response->reason == 6U) {
    {
#line 221
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"message received from %s which is an MX secondary for %s.",
             ip, spf_source);
    }
  } else {
    {
#line 224
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s designates %s as permitted sender",
             spf_source, ip);
    }
  }
#line 226
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 229
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 231
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 234
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"transitioning %s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 236
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 239
  tmp___8 = SPF_strerror(spf_response->err);
#line 239
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error in processing during lookup of %s: %s",
           spf_source, tmp___8);
  }
#line 241
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 244
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s is neither permitted nor denied by %s",
           ip, spf_source);
  }
#line 246
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 248
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not provide an SPF record",
           spf_source);
  }
#line 250
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 253
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"encountered temporary error during SPF processing of %s",
           spf_source);
  }
#line 255
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 259
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error: unknown SPF result %d encountered while checking %s for %s",
           (unsigned int )spf_response->result, ip, spf_source);
  }
#line 261
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 264
  if (spf_source) {
    {
#line 265
    free((void *)spf_source);
    }
  }
  {
#line 267
  spf_response->header_comment = SPF_sanitize(spf_server___1, buf);
  }
#line 269
  return ((SPF_errcode_t )0);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_received_spf___5(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  size_t buflen ;
  char *buf_value ;
  char *p ;
  char *p_end ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 282
  buflen = (size_t )480;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 287
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 287, "%s", "spf_response is NULL");
      }
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  spf_request = spf_response->spf_request;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 289
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 289, "%s", "spf_request is NULL");
      }
    }
#line 289
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  spf_server___1 = spf_request->spf_server;
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 291
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 291
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 291, "%s", "spf_server is NULL");
      }
    }
#line 291
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 293
  if (spf_response->received_spf) {
    {
#line 294
    free((void *)spf_response->received_spf);
    }
  }
  {
#line 295
  spf_response->received_spf = (char *)((void *)0);
#line 297
  tmp = malloc(buflen);
#line 297
  buf = (char *)tmp;
  }
#line 298
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 299
    return ((SPF_errcode_t )10);
  }
  {
#line 301
  p = buf;
#line 302
  p_end = p + buflen;
#line 306
  tmp___0 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"Received-SPF: ");
#line 306
  p += tmp___0;
#line 307
  buf_value = p;
  }
  {
#line 309
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 310
    tmp___1 = SPF_strresult(spf_response->result);
#line 310
    tmp___2 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s (%s)",
                       tmp___1, spf_response->header_comment);
#line 310
    p += tmp___2;
    }
#line 313
    if (p_end - p <= 0L) {
#line 313
      goto while_break___2;
    }
#line 318
    ip = (char const   *)((void *)0);
#line 319
    if (spf_request->client_ver == 2) {
      {
#line 320
      ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                     (socklen_t )sizeof(ip4_buf));
      }
    } else
#line 323
    if (spf_request->client_ver == 10) {
      {
#line 324
      ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                     (socklen_t )sizeof(ip6_buf));
      }
    }
#line 328
    if ((unsigned long )ip != (unsigned long )((void *)0)) {
      {
#line 329
      tmp___3 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" client-ip=%s;",
                         ip);
#line 329
      p += tmp___3;
      }
#line 330
      if (p_end - p <= 0L) {
#line 330
        goto while_break___2;
      }
    }
#line 335
    if ((unsigned long )spf_request->env_from != (unsigned long )((void *)0)) {
      {
#line 336
      tmp___4 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" envelope-from=%s;",
                         spf_request->env_from);
#line 336
      p += tmp___4;
      }
#line 337
      if (p_end - p <= 0L) {
#line 337
        goto while_break___2;
      }
    }
#line 342
    if ((unsigned long )spf_request->helo_dom != (unsigned long )((void *)0)) {
      {
#line 343
      tmp___5 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" helo=%s;",
                         spf_request->helo_dom);
#line 343
      p += tmp___5;
      }
#line 344
      if (p_end - p <= 0L) {
#line 344
        goto while_break___2;
      }
    }
#line 309
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 366
  spf_response->received_spf = SPF_sanitize(spf_server___1, buf);
#line 367
  spf_response->received_spf_value = buf_value;
  }
#line 369
  return ((SPF_errcode_t )0);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_mech_cidr___5(SPF_request_t *spf_request , SPF_mech_t *mech ) 
{ 
  SPF_data_t *data ;
  SPF_data_t *tmp ;

  {
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if ((unsigned long )mech == (unsigned long )((void *)0)) {
      {
#line 428
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 428, "%s", "mech is NULL");
      }
    }
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  if ((int )mech->mech_type == 6) {
#line 433
    goto case_6;
  }
#line 433
  if ((int )mech->mech_type == 5) {
#line 433
    goto case_6;
  }
#line 438
  if ((int )mech->mech_type == 2) {
#line 438
    goto case_2;
  }
#line 438
  if ((int )mech->mech_type == 1) {
#line 438
    goto case_2;
  }
#line 430
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 434
  return ((int )mech->mech_len);
#line 435
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 439
  data = SPF_mech_data(mech);
#line 441
  tmp = SPF_mech_end_data(mech);
  }
#line 441
  if ((unsigned long )data < (unsigned long )tmp) {
#line 441
    if ((int )data->dc.parm_type == 11) {
#line 444
      if (spf_request->client_ver == 2) {
#line 445
        return ((int )data->dc.ipv4);
      } else
#line 446
      if (spf_request->client_ver == 10) {
#line 447
        return ((int )data->dc.ipv6);
      }
    }
  }
#line 449
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 452
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip4___5(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in_addr ipv4 ) 
{ 
  char src_ip4_buf[16] ;
  char dst_ip4_buf[16] ;
  char mask_ip4_buf[16] ;
  struct in_addr src_ipv4 ;
  int cidr ;
  int mask ;
  uint32_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 471
  if (spf_request->client_ver != 2) {
#line 472
    return (0);
  }
  {
#line 474
  src_ipv4 = spf_request->ipv4;
#line 476
  cidr = SPF_i_mech_cidr___5(spf_request, mech);
  }
#line 477
  if (cidr == 0) {
#line 478
    cidr = 32;
  }
  {
#line 479
  mask = (int )(4294967295U << (32 - cidr));
#line 480
  tmp = htonl((uint32_t )mask);
#line 480
  mask = (int )tmp;
  }
#line 482
  if (spf_server___1->debug) {
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 483
      tmp___0 = inet_ntop(2, (void const   */* __restrict  */)(& src_ipv4.s_addr),
                          (char */* __restrict  */)(src_ip4_buf), (socklen_t )sizeof(src_ip4_buf));
      }
#line 483
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 483
        snprintf((char */* __restrict  */)(src_ip4_buf), sizeof(src_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 483
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 485
      tmp___1 = inet_ntop(2, (void const   */* __restrict  */)(& ipv4.s_addr), (char */* __restrict  */)(dst_ip4_buf),
                          (socklen_t )sizeof(dst_ip4_buf));
      }
#line 485
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 485
        snprintf((char */* __restrict  */)(dst_ip4_buf), sizeof(dst_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 487
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 487
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& mask), (char */* __restrict  */)(mask_ip4_buf),
                          (socklen_t )sizeof(mask_ip4_buf));
      }
#line 487
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
#line 487
        snprintf((char */* __restrict  */)(mask_ip4_buf), sizeof(mask_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 487
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 489
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               491, "ip_match:  %s == %s  (/%d %s):  %d", src_ip4_buf, dst_ip4_buf,
               cidr, mask_ip4_buf, (src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
    }
  }
#line 494
  return ((src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip6___5(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in6_addr ipv6 ) 
{ 
  char src_ip6_buf[46] ;
  char dst_ip6_buf[46] ;
  struct in6_addr src_ipv6 ;
  int cidr ;
  int cidr_save ;
  int mask ;
  int i ;
  int match ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 512
  if (spf_request->client_ver != 10) {
#line 513
    return (0);
  }
  {
#line 515
  src_ipv6 = spf_request->ipv6;
#line 517
  cidr = SPF_i_mech_cidr___5(spf_request, mech);
  }
#line 518
  if (cidr == 0) {
#line 519
    cidr = 128;
  }
#line 520
  cidr_save = cidr;
#line 522
  match = 1;
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if ((long )i < (long )(sizeof(ipv6.__in6_u.__u6_addr8) / sizeof(ipv6.__in6_u.__u6_addr8[0]))) {
#line 523
      if (! match) {
#line 523
        goto while_break;
      }
    } else {
#line 523
      goto while_break;
    }
#line 525
    if (cidr > 8) {
#line 526
      mask = 255;
    } else
#line 527
    if (cidr > 0) {
#line 528
      mask = (255 << (8 - cidr)) & 255;
    } else {
#line 530
      goto while_break;
    }
#line 531
    cidr -= 8;
#line 533
    match = ((int )src_ipv6.__in6_u.__u6_addr8[i] & mask) == ((int )ipv6.__in6_u.__u6_addr8[i] & mask);
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (spf_server___1->debug) {
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 537
      tmp = inet_ntop(10, (void const   */* __restrict  */)(& src_ipv6.__in6_u.__u6_addr8),
                      (char */* __restrict  */)(src_ip6_buf), (socklen_t )sizeof(src_ip6_buf));
      }
#line 537
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 537
        snprintf((char */* __restrict  */)(src_ip6_buf), sizeof(src_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 537
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 539
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 539
      tmp___0 = inet_ntop(10, (void const   */* __restrict  */)(& ipv6.__in6_u.__u6_addr8),
                          (char */* __restrict  */)(dst_ip6_buf), (socklen_t )sizeof(dst_ip6_buf));
      }
#line 539
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 539
        snprintf((char */* __restrict  */)(dst_ip6_buf), sizeof(dst_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 539
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 541
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               542, "ip_match:  %s == %s  (/%d):  %d", src_ip6_buf, dst_ip6_buf, cidr_save,
               match);
    }
  }
#line 545
  return (match);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_domain___5(SPF_server_t *spf_server___1 , char const   *hostname ,
                                  char const   *domain ) 
{ 
  char const   *hp ;
  size_t hlen ;
  size_t dlen ;
  int tmp ;
  int tmp___0 ;

  {
#line 556
  if (spf_server___1->debug) {
    {
#line 557
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               557, "%s ?=? %s", hostname, domain);
    }
  }
  {
#line 559
  hlen = strlen(hostname);
#line 560
  dlen = strlen(domain);
  }
#line 563
  if (dlen > hlen) {
#line 564
    return (0);
  }
#line 567
  if (dlen == hlen) {
    {
#line 568
    tmp = strcasecmp(hostname, domain);
    }
#line 568
    return (tmp == 0);
  }
#line 571
  hp = hostname + (hlen - dlen);
#line 573
  if ((int const   )*(hp - 1) != 46) {
#line 574
    return (0);
  }
  {
#line 576
  tmp___0 = strcasecmp(hp, domain);
  }
#line 576
  return (tmp___0 == 0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_pre___5(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                  ns_type rr_type , int should_cache ) 
{ 
  char const   *tmp ;

  {
#line 51
  if (spf_dns_server->debug) {
    {
#line 52
    tmp = SPF_strrrtype(rr_type);
#line 52
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               54, "DNS[%s] lookup: %s %s (%d)", spf_dns_server->name, domain, tmp,
               (unsigned int )rr_type);
    }
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_post___5(SPF_dns_server_t *spf_dns_server , SPF_dns_rr_t *spfrr ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 61
  if (spf_dns_server->debug) {
    {
#line 66
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               66, "DNS[%s] found record", spf_dns_server->name);
#line 67
    tmp = SPF_strrrtype(spfrr->rr_type);
#line 67
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               69, "    DOMAIN: %s  TYPE: %s (%d)", spfrr->domain, tmp, (unsigned int )spfrr->rr_type);
    }
#line 70
    if (spfrr->source) {
#line 70
      if ((spfrr->source)->name) {
#line 70
        tmp___0 = (spfrr->source)->name;
      } else {
#line 70
        tmp___0 = "(unnamed source)";
      }
#line 70
      tmp___1 = tmp___0;
    } else {
#line 70
      tmp___1 = "(null source)";
    }
    {
#line 70
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               76, "    TTL: %ld  RR found: %d  herrno: %d  source: %s", spfrr->ttl,
               spfrr->num_rr, spfrr->herrno, tmp___1);
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! (i < spfrr->num_rr)) {
#line 77
        goto while_break;
      }
      {
#line 79
      if ((unsigned int )spfrr->rr_type == 1U) {
#line 79
        goto case_1;
      }
#line 85
      if ((unsigned int )spfrr->rr_type == 12U) {
#line 85
        goto case_12;
      }
#line 89
      if ((unsigned int )spfrr->rr_type == 15U) {
#line 89
        goto case_15;
      }
#line 93
      if ((unsigned int )spfrr->rr_type == 16U) {
#line 93
        goto case_16;
      }
#line 97
      if ((unsigned int )spfrr->rr_type == 99U) {
#line 97
        goto case_99;
      }
#line 101
      if ((unsigned int )spfrr->rr_type == 28U) {
#line 101
        goto case_28;
      }
#line 107
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 80
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->a),
                          (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
#line 80
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 82, "    - A: %s", tmp___2);
      }
#line 83
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 86
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 86, "    - PTR: %s", (*(spfrr->rr + i))->ptr);
      }
#line 87
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 90
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 90, "    - MX: %s", (*(spfrr->rr + i))->mx);
      }
#line 91
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 94
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 94, "    - TXT: %s", (*(spfrr->rr + i))->txt);
      }
#line 95
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 98
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 98, "    - SPF: %s", (*(spfrr->rr + i))->txt);
      }
#line 99
      goto switch_break;
      case_28: /* CIL Label */ 
      {
#line 102
      tmp___3 = inet_ntop(10, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->aaaa),
                          (char */* __restrict  */)(ip6_buf), (socklen_t )sizeof(ip6_buf));
#line 102
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 104, "    - AAAA: %s", tmp___3);
      }
#line 105
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 108
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 108, "    - Unknown RR type");
      }
#line 109
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 77
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 113
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_cache_bucket_t *SPF_dns_cache_bucket_find___5(SPF_dns_cache_config_t *spfhook ,
                                                             char const   *domain ,
                                                             ns_type rr_type , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  SPF_dns_rr_t *rr ;
  time_t now ;
  int tmp ;

  {
  {
#line 247
  bucket = *(spfhook->cache + idx);
#line 248
  prev = (SPF_dns_cache_bucket_t *)((void *)0);
#line 249
  time(& now);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
#line 252
    rr = bucket->rr;
#line 254
    if (rr->utc_ttl < now) {
#line 256
      if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 257
        prev->next = bucket->next;
      } else {
#line 259
        *(spfhook->cache + idx) = bucket->next;
      }
#line 261
      if (bucket->rr) {
        {
#line 262
        SPF_dns_rr_free(bucket->rr);
        }
      }
      {
#line 263
      free((void *)bucket);
#line 265
      bucket = prev;
      }
    } else
#line 267
    if (! ((unsigned int )rr->rr_type != (unsigned int )rr_type)) {
      {
#line 270
      tmp = strcmp((char const   *)rr->domain, domain);
      }
#line 270
      if (! (tmp != 0)) {
#line 275
        if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 276
          prev->next = bucket->next;
#line 277
          bucket->next = *(spfhook->cache + idx);
#line 278
          *(spfhook->cache + idx) = bucket;
        }
#line 280
        return (bucket);
      }
    }
#line 283
    prev = bucket;
#line 284
    if ((unsigned long )bucket == (unsigned long )((void *)0)) {
#line 285
      bucket = *(spfhook->cache + idx);
    } else {
#line 287
      bucket = bucket->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return ((SPF_dns_cache_bucket_t *)((void *)0));
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_bucket_add___5(SPF_dns_cache_config_t *spfhook ,
                                                  SPF_dns_rr_t *rr , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  void *tmp ;

  {
  {
#line 300
  tmp = malloc(sizeof(SPF_dns_cache_bucket_t ));
#line 300
  bucket = (SPF_dns_cache_bucket_t *)tmp;
  }
#line 302
  if (! bucket) {
#line 303
    return ((SPF_errcode_t )1);
  }
#line 304
  bucket->next = *(spfhook->cache + idx);
#line 305
  *(spfhook->cache + idx) = bucket;
#line 306
  bucket->rr = rr;
#line 307
  return ((SPF_errcode_t )0);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_rr_fixup___5(SPF_dns_cache_config_t *spfhook ,
                                                SPF_dns_rr_t *cached_rr , char const   *domain ,
                                                ns_type rr_type ) 
{ 
  char *p ;
  char *new_domain ;
  size_t new_len ;
  size_t tmp ;
  void *tmp___0 ;
  time_t tmp___1 ;

  {
#line 322
  if ((unsigned int )cached_rr->rr_type == 255U) {
#line 323
    cached_rr->rr_type = rr_type;
  }
#line 326
  if ((unsigned long )cached_rr->domain == (unsigned long )((void *)0)) {
#line 326
    goto _L;
  } else
#line 326
  if ((int )*(cached_rr->domain + 0) != 0) {
    _L: /* CIL Label */ 
    {
#line 328
    tmp = strlen(domain);
#line 328
    new_len = tmp + 1UL;
    }
#line 330
    if (cached_rr->domain_buf_len < new_len) {
      {
#line 331
      tmp___0 = realloc((void *)cached_rr->domain, new_len);
#line 331
      new_domain = (char *)tmp___0;
      }
#line 332
      if ((unsigned long )new_domain == (unsigned long )((void *)0)) {
#line 333
        return ((SPF_errcode_t )1);
      }
#line 334
      cached_rr->domain = new_domain;
#line 335
      cached_rr->domain_buf_len = new_len;
    }
    {
#line 337
    strcpy((char */* __restrict  */)cached_rr->domain, (char const   */* __restrict  */)domain);
    }
  }
#line 341
  if (cached_rr->ttl < spfhook->min_ttl) {
#line 342
    cached_rr->ttl = spfhook->min_ttl;
  }
#line 344
  if (cached_rr->ttl < spfhook->txt_ttl) {
#line 344
    if ((unsigned int )cached_rr->rr_type == 16U) {
#line 346
      cached_rr->ttl = spfhook->txt_ttl;
    }
  }
#line 348
  if (cached_rr->ttl < spfhook->err_ttl) {
#line 348
    if (cached_rr->herrno != 0) {
#line 350
      cached_rr->ttl = spfhook->err_ttl;
    }
  }
#line 352
  if (cached_rr->ttl < spfhook->rdns_ttl) {
    {
#line 353
    p = strstr((char const   *)cached_rr->domain, ".arpa");
    }
#line 354
    if (p) {
#line 354
      if ((int )*(p + (sizeof(".arpa") - 1UL)) == 0) {
#line 355
        cached_rr->ttl = spfhook->rdns_ttl;
      }
    }
  }
  {
#line 358
  tmp___1 = time((time_t *)((void *)0));
#line 358
  cached_rr->utc_ttl = cached_rr->ttl + tmp___1;
  }
#line 360
  return ((SPF_errcode_t )0);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_rr_t *SPF_dns_cache_lookup___5(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                              ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_rr_t *cached_rr ;
  SPF_dns_rr_t *rr ;
  int idx ;
  SPF_errcode_t tmp ;
  SPF_dns_rr_t *tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;

  {
  {
#line 377
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
#line 381
  idx = crc32str(0U, domain, spfhook->max_hash_len);
#line 382
  idx &= spfhook->cache_size - 1;
#line 384
  pthread_mutex_lock(& spfhook->cache_lock);
#line 386
  bucket = SPF_dns_cache_bucket_find___5(spfhook, domain, rr_type, idx);
  }
#line 387
  if ((unsigned long )bucket != (unsigned long )((void *)0)) {
#line 388
    if ((unsigned long )bucket->rr != (unsigned long )((void *)0)) {
      {
#line 389
      tmp = SPF_dns_rr_dup(& rr, bucket->rr);
      }
#line 389
      if ((unsigned int )tmp == 0U) {
        {
#line 390
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 391
        return (rr);
      } else
#line 393
      if ((unsigned long )rr != (unsigned long )((void *)0)) {
        {
#line 394
        SPF_dns_rr_free(rr);
        }
      }
    }
  }
  {
#line 401
  bucket = (SPF_dns_cache_bucket_t *)((void *)0);
#line 403
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 405
  if (! spf_dns_server->layer_below) {
    {
#line 406
    tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
    }
#line 406
    return (tmp___0);
  }
  {
#line 408
  rr = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
  }
#line 410
  if (spfhook->conserve_cache) {
#line 410
    if (! should_cache) {
#line 411
      return (rr);
    }
  }
  {
#line 413
  pthread_mutex_lock(& spfhook->cache_lock);
#line 415
  tmp___3 = SPF_dns_rr_dup(& cached_rr, rr);
  }
#line 415
  if ((unsigned int )tmp___3 == 0U) {
    {
#line 416
    tmp___2 = SPF_dns_cache_rr_fixup___5(spfhook, cached_rr, domain, rr_type);
    }
#line 416
    if ((unsigned int )tmp___2 == 0U) {
      {
#line 417
      tmp___1 = SPF_dns_cache_bucket_add___5(spfhook, cached_rr, idx);
      }
#line 417
      if ((unsigned int )tmp___1 == 0U) {
        {
#line 418
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 419
        return (rr);
      }
    }
  }
  {
#line 424
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 426
  if (cached_rr) {
    {
#line 427
    SPF_dns_rr_free(cached_rr);
    }
  }
#line 429
  return (rr);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static void SPF_dns_cache_free___5(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  int i ;

  {
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 442
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
                 442, "%s", "spf_dns_server is NULL");
      }
    }
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
  }
#line 445
  if (spfhook) {
    {
#line 446
    pthread_mutex_lock(& spfhook->cache_lock);
    }
#line 448
    if (spfhook->cache) {
#line 449
      i = 0;
      {
#line 449
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 449
        if (! (i < spfhook->cache_size)) {
#line 449
          goto while_break___0;
        }
#line 450
        bucket = *(spfhook->cache + i);
        {
#line 451
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 451
          if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 451
            goto while_break___1;
          }
#line 452
          prev = bucket;
#line 453
          bucket = bucket->next;
#line 456
          if (prev->rr) {
            {
#line 457
            SPF_dns_rr_free(prev->rr);
            }
          }
          {
#line 458
          free((void *)prev);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 449
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 461
      free((void *)spfhook->cache);
#line 462
      spfhook->cache = (SPF_dns_cache_bucket_t **)((void *)0);
      }
    }
    {
#line 465
    pthread_mutex_unlock(& spfhook->cache_lock);
#line 476
    pthread_mutex_destroy(& spfhook->cache_lock);
#line 478
    free((void *)spfhook);
    }
  }
  {
#line 481
  free((void *)spf_dns_server);
  }
#line 482
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
static SPF_dns_test_data_t const   SPF_dns_db___5[175]  = 
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
  {      {"localhost", 1, 0, "127.0.0.1"}, 
        {"example.com", 1, 0, "192.0.2.3"}, 
        {"example.com", 15, 0, "mx.example.org"}, 
        {"example.com", 16, 0, "v=spf1 mx -all"}, 
        {"3.2.0.192.in-addr.arpa", 12, 0, "mx.example.org"}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}, 
        {"noexist.example.com", 1, 1, (char const   *)((void *)0)}, 
        {"mx.example.org", 1, 0, "192.0.2.3"}, 
        {"mx.example.org", 28, 0, "5f05:2000:80ad:5800::1"}, 
        {"email.example.com", 16, 0, "v=spf1 -all"}, 
        {"*.example.com", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.org", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.net", 255, 1, (char const   *)((void *)0)}, 
        {"01.spf1-test.mailzone.com", 16, 0, "v=spf1                                                             "}, 
        {"02.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             -all       "}, 
        {"03.spf1-test.mailzone.com", 16, 0, "v=spf1                                             ~all"}, 
        {"05.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             default=deny   "}, 
        {"06.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             ?all "}, 
        {"07.spf1-test.mailzone.com", 16, 0, "v=spf2                                             default=bogus   "}, 
        {"08.spf1-test.mailzone.com",
      16, 0, "v=spf1                       -all      ?all  "}, 
        {"09.spf1-test.mailzone.com", 16, 0, "v=spf1    scope=header-from scope=envelope         -all  "}, 
        {"10.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx                                          -all"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"11.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"13.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"20.spf1-test.mailzone.com", 1, 0, "192.0.2.120"}, 
        {"20.spf1-test.mailzone.com", 16, 0, "v=spf1 a                                           -all"}, 
        {"21.spf1-test.mailzone.com",
      16, 0, "v=spf1   a:spf1-test.mailzone.com                            -all"}, 
        {"21.spf1-test.mailzone.com",
      1, 0, "192.0.2.121"}, 
        {"22.spf1-test.mailzone.com", 16, 0, "v=spf1 a a:spf1-test.mailzone.com                            -all"}, 
        {"22.spf1-test.mailzone.com",
      1, 0, "192.0.2.122"}, 
        {"30.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr                                         -all"}, 
        {"30.spf1-test.mailzone.com",
      1, 0, "208.210.124.130"}, 
        {"31.spf1-test.mailzone.com", 16, 0, "v=spf1     ptr:spf1-test.mailzone.com                        -all"}, 
        {"31.spf1-test.mailzone.com",
      1, 0, "208.210.124.131"}, 
        {"32.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr ptr:spf1-test.mailzone.com                        -all"}, 
        {"32.spf1-test.mailzone.com",
      1, 0, "208.210.124.132"}, 
        {"40.spf1-test.mailzone.com", 16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d}                    -all"}, 
        {"41.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.spf1-test.mailzone.com            -all"}, 
        {"42.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d} exists:%{ir}.%{v}._spf.%{d3} -all"}, 
        {"45.spf1-test.mailzone.com",
      16, 0, "v=spf1 -a a:spf1-test.mailzone.com                           -all"}, 
        {"45.spf1-test.mailzone.com",
      1, 0, "192.0.2.147"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.145"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.146"}, 
        {"50.spf1-test.mailzone.com", 16, 0, "v=spf1 include                                     -all"}, 
        {"51.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"52.spf1-test.mailzone.com", 16, 0, "v=spf1 include:53.spf1-test.mailzone.com                  -all"}, 
        {"53.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"54.spf1-test.mailzone.com", 16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"55.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:56.spf1-test.mailzone.com                  -all"}, 
        {"57.spf1-test.mailzone.com", 16, 0, "v=spf1 include:spf1-test.mailzone.com         -all"}, 
        {"58.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:59.spf1-test.mailzone.com                  -all"}, 
        {"59.spf1-test.mailzone.com", 16, 0, "v=spf1 include:58.spf1-test.mailzone.com                  -all"}, 
        {"70.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{lr+=}.lp._spf.spf1-test.mailzone.com -all"}, 
        {"80.spf1-test.mailzone.com", 16, 0, "v=spf1 a mx exists:%{ir}.%{v}._spf.80.spf1-test.mailzone.com ptr -all"}, 
        {"80.spf1-test.mailzone.com",
      1, 0, "208.210.124.180"}, 
        {"90.spf1-test.mailzone.com", 16, 0, "v=spf1  ip4:192.0.2.128/25 -all"}, 
        {"91.spf1-test.mailzone.com", 16, 0, "v=spf1 -ip4:192.0.2.128/25 ip4:192.0.2.0/24 -all"}, 
        {"92.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?ip4:192.0.2.192/26 ip4:192.0.2.128/25 -ip4:192.0.2.0/24 -all"}, 
        {"95.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -all"}, 
        {"96.spf1-test.mailzone.com", 16, 0, "v=spf1 -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"97.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"98.spf1-test.mailzone.com",
      16, 0, "v=spf1 a/26 mx/26 -all"}, 
        {"98.spf1-test.mailzone.com", 15, 0, "80.spf1-test.mailzone.com"}, 
        {"98.spf1-test.mailzone.com", 1, 0, "192.0.2.98"}, 
        {"99.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp=99txt.spf1-test.mailzone.com moo"}, 
        {"99txt.spf1-test.mailzone.com",
      16, 0, "u=%{u} s=%{s} d=%{d} t=%{t} h=%{h} i=%{i} %% U=%{U} S=%{S} D=%{D} T=%{T} H=%{H} I=%{I} %% moo"}, 
        {"100.spf1-test.mailzone.com",
      16, 0, "v=spf1      redirect=98.spf1-test.mailzone.com"}, 
        {"101.spf1-test.mailzone.com", 16, 0, "v=spf1 -all redirect=98.spf1-test.mailzone.com"}, 
        {"102.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?all redirect=98.spf1-test.mailzone.com"}, 
        {"103.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=98.%{d3}"}, 
        {"104.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=105.%{d3}"}, 
        {"105.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=106.%{d3}"}, 
        {"106.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=107.%{d3}"}, 
        {"107.spf1-test.mailzone.com", 16, 0, "v=spf1       include:104.%{d3}"}, 
        {"110.spf1-test.mailzone.com", 16, 0, "v=spf1 some:unrecognized=mechanism some=unrecognized:modifier -all"}, 
        {"111.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx -a gpg ~all exp=111txt.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"111txt.2.0.192.in-addr._spf.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"112.spf1-test.mailzone.com",
      16, 0, "v=spf1 a mp3 ~all"}, 
        {"112.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"113.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3: ~all"}, 
        {"113.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114.spf1-test.mailzone.com", 16, 0, "v=spf1 mx -a gpg=test ~all exp=114txt.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com",
      15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114txt.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"115.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3=yes -all"}, 
        {"115.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"116.spf1-test.mailzone.com", 16, 0, "v=spf1 redirect=116rdr.spf1-test.mailzone.com a"}, 
        {"116.spf1-test.mailzone.com",
      1, 0, "192.0.2.200"}, 
        {"116rdr.spf1-test.mailzone.com", 16, 0, "v=spf1 -all"}, 
        {"117.spf1-test.mailzone.com", 16, 0, " v=spf1 +all"}, 
        {"118.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp="}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.10"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.11"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.12"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.13"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.20"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.21"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.22"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.23"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.30"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.31"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.32"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.33"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.40"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.41"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.42"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.43"}, 
        {"56.spf1-test.mailzone.com", 16, 4, (char const   *)((void *)0)}, 
        {"80.spf1-test.mailzone.com", 15, 4, (char const   *)((void *)0)}, 
        {"servfail.spf1-test.mailzone.com", 16, 2, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 1, 0, "208.210.124.192"}, 
        {"spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"fallback-relay.spf1-test.mailzone.com", 15, 0, "mx04.spf1-test.mailzone.com"}, 
        {"www1.cnn.com",
      1, 0, "64.236.24.4"}, 
        {"4.24.236.64.in-addr.arpa", 12, 0, "www1.cnn.com"}, 
        {"130.124.210.208.in-addr.arpa", 12, 0, "30.spf1-test.mailzone.com"}, 
        {"131.124.210.208.in-addr.arpa", 12, 0, "31.spf1-test.mailzone.com"}, 
        {"192.124.210.208.in-addr.arpa", 12, 0, "spf1-test.mailzone.com"}, 
        {"100.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"110.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"111.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"101.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"130.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"131.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"80.2.0.192.in-addr._spf.80.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"96.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"97.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com",
      1, 0, "127.0.0.2"}, 
        {"bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"postmaster.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"2.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.joe.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"102.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"110.2.0.192.in-addr._spf.42.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"131.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"4.24.236.64.in-addr._spf.80.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"droid.lp._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"joe-2.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"moe-1.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"unknown.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"180.124.210.208.in-addr.arpa",
      12, 0, "80.spf1-test.mailzone.com"}, 
        {"80.spf1-test.mailzone.com.whitelist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.124.210.208.in-addr.arpa",
      12, 0, "pobox-gw.icgroup.com"}, 
        {"pobox-gw.icgroup.com", 1, 0, "208.210.124.1"}, 
        {"pobox-gw.icgroup.com.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com",
      16, 1, (char const   *)((void *)0)}, 
        {"spf.trusted-forwarder.org", 16, 0, "v=spf1 exists:%{ir}.wl.trusted-forwarder.org exists:%{p}.wl.trusted-forwarder.org"}, 
        {"*.spf1-text.mailzone.com",
      255, 1, (char const   *)((void *)0)}, 
        {"cat.com", 16, 4, (char const   *)((void *)0)}, 
        {"bar.com", 16, 4, (char const   *)((void *)0)}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}};
#line 41 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static SPF_dns_rr_t *SPF_dns_null_lookup___5(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_rr_t *tmp ;
  SPF_dns_rr_t *tmp___0 ;

  {
#line 45
  if (spf_dns_server->layer_below) {
    {
#line 46
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 46
    return (tmp);
  }
  {
#line 48
  tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
  }
#line 48
  return (tmp___0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static void SPF_dns_null_free___5(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 54
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c",
                 54, "%s", "spf_dns_server is NULL");
      }
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  free((void *)spf_dns_server);
  }
#line 56
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
static SPF_response_t *SPF_response_choose___2(SPF_response_t *yes , SPF_response_t *no ) 
{ 


  {
  {
#line 80
  SPF_response_free(no);
  }
#line 81
  return (yes);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
static SPF_errcode_t SPF_response_add_error_v___2(SPF_response_t *rp , SPF_errcode_t code ,
                                                  int is_error , char const   *text ,
                                                  int idx , char const   *format ,
                                                  va_list ap ) 
{ 
  SPF_error_t *tmp ;
  char buf[4096] ;
  int size ;
  void *tmp___0 ;

  {
#line 198
  if (! format) {
    {
#line 199
    format = SPF_strerror(code);
    }
  }
  {
#line 200
  size = vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
                   ap);
  }
#line 201
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
#line 202
    snprintf((char */* __restrict  */)(& buf[size]), sizeof(buf) - (unsigned long )size,
             (char const   */* __restrict  */)" near \'%.12s\'", text + idx);
    }
  }
#line 205
  buf[4095] = (char )'\000';
#line 207
  if ((int )rp->errors_length == (int )rp->errors_size) {
    {
#line 208
    size = ((int )rp->errors_size + (int )rp->errors_size / 4) + 4;
#line 209
    tmp___0 = realloc((void *)rp->errors, (unsigned long )size * sizeof(SPF_error_t ));
#line 209
    tmp = (SPF_error_t *)tmp___0;
    }
#line 210
    if (! tmp) {
      {
#line 211
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c",
                 211, "%s", "Failed to allocate memory for extra response error");
      }
#line 212
      return (code);
    }
#line 214
    rp->errors = tmp;
#line 215
    rp->errors_size = (unsigned short )size;
  }
  {
#line 218
  (rp->errors + rp->errors_length)->code = code;
#line 219
  (rp->errors + rp->errors_length)->is_error = (char )is_error;
#line 221
  (rp->errors + rp->errors_length)->message = strdup((char const   *)(buf));
#line 222
  rp->errors_length = (unsigned short )((int )rp->errors_length + 1);
  }
#line 224
  return (code);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   spf_mechtypes___5[10]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
  {      {(unsigned char)0, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)1, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)2, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)3, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )0}, 
        {(unsigned char)4, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)5, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)6, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)7, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)8, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)9, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}};
#line 94 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   *SPF_mechtype_find___5(int mech_type ) 
{ 
  size_t i ;

  {
#line 98
  i = (size_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < sizeof(spf_mechtypes___5) / sizeof(spf_mechtypes___5[0]))) {
#line 98
      goto while_break;
    }
#line 99
    if ((int const   )spf_mechtypes___5[i].mech_type == (int const   )mech_type) {
#line 100
      return (& spf_mechtypes___5[i]);
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((SPF_mechtype_t const   *)((void *)0));
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static int ( __attribute__((__warn_unused_result__)) SPF_c_ensure_capacity___5)(void **datap ,
                                                                                size_t *sizep ,
                                                                                size_t length ) 
{ 
  size_t size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 109
  size = *sizep;
#line 110
  if (length > size) {
#line 111
    size = length + length / 4UL;
  }
#line 112
  if (size > *sizep) {
    {
#line 113
    tmp___0 = realloc(*datap, size);
#line 113
    tmp = tmp___0;
    }
#line 114
    if (! tmp) {
#line 115
      return (-1);
    }
#line 117
    *datap = tmp;
#line 118
    *sizep = size;
  }
#line 120
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip6___5(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 144
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 144
  mask = (int )tmp;
  }
#line 146
  if (mask > 128) {
    {
#line 147
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (>128)");
    }
#line 147
    return (tmp___0);
  } else
#line 151
  if (mask == 0) {
    {
#line 152
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (=0)");
    }
#line 152
    return (tmp___1);
  } else
#line 156
  if (mask == 128) {
#line 157
    mask = 0;
  }
#line 160
  *maskp = (unsigned char )mask;
#line 162
  return ((SPF_errcode_t )0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip4___5(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 186
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 186
  mask = (int )tmp;
  }
#line 188
  if (mask > 32) {
    {
#line 189
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (>32)");
    }
#line 189
    return (tmp___0);
  } else
#line 193
  if (mask == 0) {
    {
#line 194
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (=0)");
    }
#line 194
    return (tmp___1);
  } else
#line 198
  if (mask == 32) {
#line 199
    mask = 0;
  }
#line 202
  *maskp = (unsigned char )mask;
#line 204
  return ((SPF_errcode_t )0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr___5(SPF_response_t *spf_response , SPF_data_cidr_t *data ,
                                          char const   *src , size_t *src_len ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 220
  memset((void *)data, 0, sizeof(SPF_data_cidr_t ));
#line 221
  data->parm_type = (unsigned char)11;
#line 227
  idx = *src_len - 1UL;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (idx > 0UL) {
      {
#line 228
      tmp = __ctype_b_loc();
      }
#line 228
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 228
        goto while_break;
      }
    } else {
#line 228
      goto while_break;
    }
#line 229
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (idx < *src_len - 1UL) {
#line 236
    if ((int const   )*(src + idx) == 47) {
#line 237
      if (idx > 0UL) {
#line 237
        if ((int const   )*(src + (idx - 1UL)) == 47) {
          {
#line 239
          err = SPF_c_parse_cidr_ip6___5(spf_response, & data->ipv6, src + idx);
          }
#line 240
          if (err) {
#line 241
            return (err);
          }
#line 243
          *src_len = idx - 1UL;
#line 244
          idx = *src_len - 1UL;
          {
#line 245
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 245
            if (idx > 0UL) {
              {
#line 245
              tmp___0 = __ctype_b_loc();
              }
#line 245
              if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 245
                goto while_break___0;
              }
            } else {
#line 245
              goto while_break___0;
            }
#line 246
            idx --;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 249
          if (idx < *src_len - 1UL) {
#line 249
            if ((int const   )*(src + idx) == 47) {
              {
#line 253
              err = SPF_c_parse_cidr_ip4___5(spf_response, & data->ipv4, src + idx);
              }
#line 254
              if (err) {
#line 255
                return (err);
              }
#line 256
              *src_len = idx;
            }
          }
        } else {
#line 237
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 261
        err = SPF_c_parse_cidr_ip4___5(spf_response, & data->ipv4, src + idx);
        }
#line 262
        if (err) {
#line 263
          return (err);
        }
#line 264
        *src_len = idx;
      }
    }
  }
#line 268
  return ((SPF_errcode_t )0);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_var___5(SPF_response_t *spf_response , SPF_data_var_t *data ,
                                         char const   *src , int is_mod ) 
{ 
  char const   *token ;
  char const   *p ;
  char c ;
  int val ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;
  SPF_errcode_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  SPF_errcode_t tmp___6 ;
  SPF_errcode_t tmp___7 ;

  {
  {
#line 280
  memset((void *)data, 0, sizeof(SPF_data_var_t ));
#line 282
  p = src;
#line 285
  c = (char )*p;
#line 286
  tmp___0 = __ctype_b_loc();
  }
#line 286
  if ((int const   )*(*tmp___0 + (int )((unsigned char )c)) & 256) {
    {
#line 288
    data->url_encode = (unsigned short)1;
#line 289
    tmp = tolower((int )c);
#line 289
    c = (char )tmp;
    }
  } else {
#line 292
    data->url_encode = (unsigned short)0;
  }
  {
#line 302
  if ((int )c == 108) {
#line 302
    goto case_108;
  }
#line 306
  if ((int )c == 115) {
#line 306
    goto case_115;
  }
#line 310
  if ((int )c == 111) {
#line 310
    goto case_111;
  }
#line 314
  if ((int )c == 100) {
#line 314
    goto case_100;
  }
#line 318
  if ((int )c == 105) {
#line 318
    goto case_105;
  }
#line 322
  if ((int )c == 99) {
#line 322
    goto case_99;
  }
#line 327
  if ((int )c == 116) {
#line 327
    goto case_116;
  }
#line 332
  if ((int )c == 112) {
#line 332
    goto case_112;
  }
#line 336
  if ((int )c == 118) {
#line 336
    goto case_118;
  }
#line 340
  if ((int )c == 104) {
#line 340
    goto case_104;
  }
#line 344
  if ((int )c == 114) {
#line 344
    goto case_114;
  }
#line 349
  goto switch_default;
  case_108: /* CIL Label */ 
#line 303
  data->parm_type = (unsigned char)0;
#line 304
  goto switch_break;
  case_115: /* CIL Label */ 
#line 307
  data->parm_type = (unsigned char)1;
#line 308
  goto switch_break;
  case_111: /* CIL Label */ 
#line 311
  data->parm_type = (unsigned char)2;
#line 312
  goto switch_break;
  case_100: /* CIL Label */ 
#line 315
  data->parm_type = (unsigned char)3;
#line 316
  goto switch_break;
  case_105: /* CIL Label */ 
#line 319
  data->parm_type = (unsigned char)4;
#line 320
  goto switch_break;
  case_99: /* CIL Label */ 
#line 323
  if (! is_mod) {
    {
#line 323
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 323
    return (tmp___1);
  }
#line 324
  data->parm_type = (unsigned char)5;
#line 325
  goto switch_break;
  case_116: /* CIL Label */ 
#line 328
  if (! is_mod) {
    {
#line 328
    tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 328
    return (tmp___2);
  }
#line 329
  data->parm_type = (unsigned char)6;
#line 330
  goto switch_break;
  case_112: /* CIL Label */ 
#line 333
  data->parm_type = (unsigned char)7;
#line 334
  goto switch_break;
  case_118: /* CIL Label */ 
#line 337
  data->parm_type = (unsigned char)8;
#line 338
  goto switch_break;
  case_104: /* CIL Label */ 
#line 341
  data->parm_type = (unsigned char)9;
#line 342
  goto switch_break;
  case_114: /* CIL Label */ 
#line 345
  if (! is_mod) {
    {
#line 345
    tmp___3 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 345
    return (tmp___3);
  }
#line 346
  data->parm_type = (unsigned char)10;
#line 347
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 350
  tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                       p, "Unknown variable \'%c\'", (int )c);
  }
#line 350
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
#line 354
  p ++;
#line 355
  token = p;
#line 358
  val = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 359
    tmp___5 = __ctype_b_loc();
    }
#line 359
    if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*p)) & 2048)) {
#line 359
      goto while_break;
    }
#line 361
    val *= 10;
#line 362
    val += (int )((int const   )*p - 48);
#line 363
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (val > 128) {
    {
#line 366
    tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                         token, "Subdomain truncation depth too large");
    }
#line 366
    return (tmp___6);
  } else
#line 365
  if (val <= 0) {
#line 365
    if ((unsigned long )p != (unsigned long )token) {
      {
#line 366
      tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                           token, "Subdomain truncation depth too large");
      }
#line 366
      return (tmp___6);
    }
  }
#line 369
  data->num_rhs = (unsigned char )val;
#line 370
  token = p;
#line 373
  if ((int const   )*p == 114) {
#line 375
    data->rev = (unsigned short)1;
#line 376
    p ++;
  } else {
#line 379
    data->rev = (unsigned short)0;
  }
#line 380
  token = p;
#line 384
  data->delim_dot = (unsigned short)0;
#line 385
  data->delim_dash = (unsigned short)0;
#line 386
  data->delim_plus = (unsigned short)0;
#line 387
  data->delim_equal = (unsigned short)0;
#line 388
  data->delim_bar = (unsigned short)0;
#line 389
  data->delim_under = (unsigned short)0;
#line 392
  if ((int const   )*p == 125) {
#line 393
    data->delim_dot = (unsigned short)1;
  }
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! ((int const   )*p != 125)) {
#line 396
      goto while_break___0;
    }
#line 398
    token = p;
    {
#line 401
    if ((int const   )*p == 46) {
#line 401
      goto case_46;
    }
#line 405
    if ((int const   )*p == 45) {
#line 405
      goto case_45;
    }
#line 409
    if ((int const   )*p == 43) {
#line 409
      goto case_43;
    }
#line 413
    if ((int const   )*p == 61) {
#line 413
      goto case_61;
    }
#line 417
    if ((int const   )*p == 124) {
#line 417
      goto case_124;
    }
#line 421
    if ((int const   )*p == 95) {
#line 421
      goto case_95;
    }
#line 425
    goto switch_default___0;
    case_46: /* CIL Label */ 
#line 402
    data->delim_dot = (unsigned short)1;
#line 403
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 406
    data->delim_dash = (unsigned short)1;
#line 407
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 410
    data->delim_plus = (unsigned short)1;
#line 411
    goto switch_break___0;
    case_61: /* CIL Label */ 
#line 414
    data->delim_equal = (unsigned short)1;
#line 415
    goto switch_break___0;
    case_124: /* CIL Label */ 
#line 418
    data->delim_bar = (unsigned short)1;
#line 419
    goto switch_break___0;
    case_95: /* CIL Label */ 
#line 422
    data->delim_under = (unsigned short)1;
#line 423
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 426
    tmp___7 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )14, (char const   *)((void *)0),
                                         p, "Invalid delimiter \'%c\'", (int const   )*p);
    }
#line 426
    return (tmp___7);
    switch_break___0: /* CIL Label */ ;
    }
#line 430
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 432
  p ++;
#line 433
  token = p;
#line 436
  return ((SPF_errcode_t )0);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_macro___5(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                           SPF_data_t *data , size_t *data_used ,
                                           size_t data_avail , char const   *src ,
                                           size_t src_len , SPF_errcode_t big_err ,
                                           int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  size_t len ;
  char *dst ;
  size_t ds_avail ;
  size_t ds_len ;
  SPF_errcode_t tmp ;
  SPF_errcode_t tmp___0 ;
  char *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  char *tmp___3 ;
  SPF_errcode_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  SPF_errcode_t tmp___8 ;
  char *tmp___9 ;
  SPF_errcode_t tmp___10 ;
  SPF_errcode_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  SPF_errcode_t tmp___15 ;
  SPF_errcode_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  SPF_errcode_t tmp___19 ;
  SPF_errcode_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
#line 522
  if (spf_server___1->debug) {
    {
#line 523
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               523, "Parsing macro starting at %s", src);
    }
  }
#line 534
  idx = (size_t )0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 538
    data->ds.parm_type = (unsigned char)12;
#line 538
    data->ds.len = (unsigned char)0;
#line 538
    data->ds.__unused0 = (unsigned char)186;
#line 538
    data->ds.__unused1 = (unsigned char)190;
#line 538
    dst = SPF_data_str(data);
#line 538
    ds_avail = data_avail - *data_used;
#line 538
    ds_len = (size_t )0;
    }
#line 538
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 541
    if (! (idx < src_len)) {
#line 541
      goto while_break___0;
    }
#line 542
    if (spf_server___1->debug > 3) {
      {
#line 543
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 543, "Current data is at %p", data);
      }
    }
    {
#line 546
    len = strcspn(src + idx, " %");
    }
#line 547
    if (len > 0UL) {
#line 549
      if (idx + len > src_len) {
#line 550
        len = src_len - idx;
      }
#line 551
      if (spf_server___1->debug > 3) {
        {
#line 552
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                   554, "Adding string literal (%lu): \'%*.*s\'", len, (int )len,
                   (int )len, src + idx);
        }
      }
      {
#line 556
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 556
        if (ds_len + len > ds_avail) {
          {
#line 556
          tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                           src, "String literal fragment too long (%d chars, %d max)",
                                           ds_len, ds_avail);
          }
#line 556
          return (tmp);
        }
#line 556
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 557
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(src + idx),
             len);
#line 558
      ds_len += len;
#line 559
      dst += len;
#line 560
      idx += len;
      }
    }
#line 568
    if (idx == src_len) {
#line 569
      goto while_break___0;
    }
#line 576
    idx ++;
    {
#line 578
    if ((int const   )*(src + idx) == 37) {
#line 578
      goto case_37;
    }
#line 587
    if ((int const   )*(src + idx) == 95) {
#line 587
      goto case_95;
    }
#line 596
    if ((int const   )*(src + idx) == 45) {
#line 596
      goto case_45;
    }
#line 617
    if ((int const   )*(src + idx) == 123) {
#line 617
      goto case_123;
    }
#line 605
    goto switch_default;
    case_37: /* CIL Label */ 
#line 579
    if (spf_server___1->debug > 3) {
      {
#line 580
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 580, "Adding literal %%");
      }
    }
    {
#line 581
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 581
      if (ds_len + 1UL > ds_avail) {
        {
#line 581
        tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 581
        return (tmp___0);
      }
#line 581
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 582
    tmp___1 = dst;
#line 582
    dst ++;
#line 582
    *tmp___1 = (char )'%';
#line 583
    ds_len ++;
#line 584
    idx ++;
#line 585
    goto switch_break;
    case_95: /* CIL Label */ 
#line 588
    if (spf_server___1->debug > 3) {
      {
#line 589
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 589, "Adding literal space");
      }
    }
    {
#line 590
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 590
      if (ds_len + 1UL > ds_avail) {
        {
#line 590
        tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 590
        return (tmp___2);
      }
#line 590
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 591
    tmp___3 = dst;
#line 591
    dst ++;
#line 591
    *tmp___3 = (char )' ';
#line 592
    ds_len ++;
#line 593
    idx ++;
#line 594
    goto switch_break;
    case_45: /* CIL Label */ 
#line 597
    if (spf_server___1->debug > 3) {
      {
#line 598
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 598, "Adding escaped space");
      }
    }
    {
#line 599
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 599
      if (ds_len + 3UL > ds_avail) {
        {
#line 599
        tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 599
        return (tmp___4);
      }
#line 599
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 600
    tmp___5 = dst;
#line 600
    dst ++;
#line 600
    *tmp___5 = (char )'%';
#line 600
    tmp___6 = dst;
#line 600
    dst ++;
#line 600
    *tmp___6 = (char )'2';
#line 600
    tmp___7 = dst;
#line 600
    dst ++;
#line 600
    *tmp___7 = (char )'0';
#line 601
    ds_len += 3UL;
#line 602
    idx ++;
#line 603
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 606
    if (spf_server___1->debug > 3) {
      {
#line 607
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 608, "Adding illegal %%-follower \'%c\' at %d", (int const   )*(src + idx),
                 idx);
      }
    }
    {
#line 612
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 612
      if (ds_len + 1UL > ds_avail) {
        {
#line 612
        tmp___8 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 612
        return (tmp___8);
      }
#line 612
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 613
    tmp___9 = dst;
#line 613
    dst ++;
#line 613
    *tmp___9 = (char )'%';
#line 614
    ds_len ++;
#line 615
    goto switch_break;
    case_123: /* CIL Label */ 
    {
#line 618
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 618
      if (ds_len > 0UL) {
#line 618
        if (ds_len > 255UL) {
          {
#line 618
          tmp___10 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15,
                                                (char const   *)((void *)0), src,
                                                "String literal too long (%d chars, %d max)",
                                                ds_len, 255);
          }
#line 618
          return (tmp___10);
        }
#line 618
        data->ds.len = (unsigned char )ds_len;
#line 618
        len = sizeof(*data) + ds_len;
        {
#line 618
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 618
          tmp___12 = _align_sz(len);
          }
#line 618
          if (*data_used + tmp___12 > data_avail) {
            {
#line 618
            tmp___11 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                  src, "SPF domainspec too long (%d chars, %d max)",
                                                  *data_used + len, data_avail);
            }
#line 618
            return (tmp___11);
          }
          {
#line 618
          tmp___13 = _align_sz(len);
#line 618
          *data_used += tmp___13;
          }
#line 618
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 618
        data = SPF_data_next(data);
#line 618
        ds_len = (size_t )0;
        }
      }
#line 618
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 619
    if (spf_server___1->debug > 3) {
      {
#line 620
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 620, "Adding macro, data is at %p", data);
      }
    }
    {
#line 623
    idx ++;
#line 624
    err = SPF_c_parse_var___5(spf_response, & data->dv, src + idx, is_mod);
    }
#line 625
    if ((unsigned int )err != 0U) {
#line 626
      return (err);
    }
    {
#line 627
    tmp___14 = strcspn(src + idx, "} ");
#line 627
    idx += tmp___14;
    }
#line 628
    if ((int const   )*(src + idx) == 125) {
#line 629
      idx ++;
    } else
#line 630
    if ((int const   )*(src + idx) == 32) {
      {
#line 631
      tmp___15 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, src,
                                            src + idx, "Unterminated variable?");
      }
#line 631
      return (tmp___15);
    }
    {
#line 637
    len = SPF_data_len(data);
    }
    {
#line 638
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 638
      tmp___17 = _align_sz(len);
      }
#line 638
      if (*data_used + tmp___17 > data_avail) {
        {
#line 638
        tmp___16 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                              src, "SPF domainspec too long (%d chars, %d max)",
                                              *data_used + len, data_avail);
        }
#line 638
        return (tmp___16);
      }
      {
#line 638
      tmp___18 = _align_sz(len);
#line 638
      *data_used += tmp___18;
      }
#line 638
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 639
    data = SPF_data_next(data);
    }
#line 640
    if (spf_server___1->debug > 3) {
      {
#line 641
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 641, "Next data is at %p", data);
      }
    }
    {
#line 643
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 643
      data->ds.parm_type = (unsigned char)12;
#line 643
      data->ds.len = (unsigned char)0;
#line 643
      data->ds.__unused0 = (unsigned char)186;
#line 643
      data->ds.__unused1 = (unsigned char)190;
#line 643
      dst = SPF_data_str(data);
#line 643
      ds_avail = data_avail - *data_used;
#line 643
      ds_len = (size_t )0;
      }
#line 643
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 649
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 649
    if (ds_len > 0UL) {
#line 649
      if (ds_len > 255UL) {
        {
#line 649
        tmp___19 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                              src, "String literal too long (%d chars, %d max)",
                                              ds_len, 255);
        }
#line 649
        return (tmp___19);
      }
#line 649
      data->ds.len = (unsigned char )ds_len;
#line 649
      len = sizeof(*data) + ds_len;
      {
#line 649
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 649
        tmp___21 = _align_sz(len);
        }
#line 649
        if (*data_used + tmp___21 > data_avail) {
          {
#line 649
          tmp___20 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                src, "SPF domainspec too long (%d chars, %d max)",
                                                *data_used + len, data_avail);
          }
#line 649
          return (tmp___20);
        }
        {
#line 649
        tmp___22 = _align_sz(len);
#line 649
        *data_used += tmp___22;
        }
#line 649
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 649
      data = SPF_data_next(data);
#line 649
      ds_len = (size_t )0;
      }
    }
#line 649
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 651
  return ((SPF_errcode_t )0);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_domainspec___5(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                                SPF_data_t *data , size_t *data_used ,
                                                size_t data_avail , char const   *src ,
                                                size_t src_len , SPF_errcode_t big_err ,
                                                SPF_cidr_t cidr_ok , int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  SPF_errcode_t tmp___6 ;

  {
#line 682
  if (spf_server___1->debug) {
#line 683
    if ((unsigned int )cidr_ok == 1U) {
#line 683
      tmp___1 = "optional";
    } else {
#line 683
      if ((unsigned int )cidr_ok == 2U) {
#line 683
        tmp___0 = "only";
      } else {
#line 683
        if ((unsigned int )cidr_ok == 0U) {
#line 683
          tmp = "forbidden";
        } else {
#line 683
          tmp = "ERROR!";
        }
#line 683
        tmp___0 = tmp;
      }
#line 683
      tmp___1 = tmp___0;
    }
    {
#line 683
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               689, "Parsing domainspec starting at %s, cidr is %s", src, tmp___1);
    }
  }
#line 694
  if ((unsigned int )cidr_ok == 1U) {
#line 694
    goto _L___0;
  } else
#line 694
  if ((unsigned int )cidr_ok == 2U) {
    _L___0: /* CIL Label */ 
    {
#line 695
    err = SPF_c_parse_cidr___5(spf_response, & data->dc, src, & src_len);
    }
#line 696
    if ((unsigned int )err != 0U) {
#line 697
      return (err);
    }
#line 698
    if ((int )data->dc.ipv4 != 0) {
#line 698
      goto _L;
    } else
#line 698
    if ((int )data->dc.ipv6 != 0) {
      _L: /* CIL Label */ 
      {
#line 699
      len = SPF_data_len(data);
      }
      {
#line 700
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 700
        tmp___3 = _align_sz(len);
        }
#line 700
        if (*data_used + tmp___3 > data_avail) {
          {
#line 700
          tmp___2 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                               src, "SPF domainspec too long (%d chars, %d max)",
                                               *data_used + len, data_avail);
          }
#line 700
          return (tmp___2);
        }
        {
#line 700
        tmp___4 = _align_sz(len);
#line 700
        *data_used += tmp___4;
        }
#line 700
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 701
      data = SPF_data_next(data);
      }
    }
#line 704
    if ((unsigned int )cidr_ok == 2U) {
#line 704
      if (src_len > 0UL) {
        {
#line 708
        tmp___5 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                             src, "Invalid CIDR after mechanism");
        }
#line 708
        return (tmp___5);
      }
    }
  }
  {
#line 715
  tmp___6 = SPF_c_parse_macro___5(spf_server___1, spf_response, data, data_used, data_avail,
                                  src, src_len, big_err, is_mod);
  }
#line 715
  return (tmp___6);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip4___5(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  SPF_errcode_t err ;
  unsigned char mask ;
  struct in_addr *addr ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 739
  start ++;
#line 740
  len = strcspn(start, " ");
#line 741
  end = start + len;
#line 742
  p = end - 1;
#line 744
  mask = (unsigned char)0;
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 745
    tmp = __ctype_b_loc();
    }
#line 745
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 745
      goto while_break;
    }
#line 746
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 747
    if ((int const   )*p == 47) {
      {
#line 748
      err = SPF_c_parse_cidr_ip4___5(spf_response, & mask, p);
      }
#line 749
      if (err) {
#line 750
        return (err);
      }
#line 751
      end = p;
    }
  }
#line 753
  mech->mech_len = (unsigned short )mask;
#line 755
  len = (size_t )(end - start);
#line 756
  if (len > sizeof(buf) - 1UL) {
#line 757
    return ((SPF_errcode_t )19);
  }
  {
#line 759
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 760
  buf[len] = (char )'\000';
#line 761
  addr = SPF_mech_ip4_data(mech);
#line 762
  tmp___0 = inet_pton(2, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
#line 762
  err = (SPF_errcode_t )tmp___0;
  }
#line 763
  if ((unsigned int )err <= 0U) {
    {
#line 764
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )19, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 764
    return (tmp___1);
  }
#line 767
  return ((SPF_errcode_t )0);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip6___5(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  int err ;
  unsigned char mask ;
  struct in6_addr *addr ;
  unsigned short const   **tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 788
  start ++;
#line 789
  len = strcspn(start, " ");
#line 790
  end = start + len;
#line 791
  p = end - 1;
#line 793
  mask = (unsigned char)0;
  }
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 794
    tmp = __ctype_b_loc();
    }
#line 794
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 794
      goto while_break;
    }
#line 795
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 796
    if ((int const   )*p == 47) {
      {
#line 797
      tmp___0 = SPF_c_parse_cidr_ip6___5(spf_response, & mask, p);
#line 797
      err = (int )tmp___0;
      }
#line 798
      if (err) {
#line 799
        return ((SPF_errcode_t )err);
      }
#line 800
      end = p;
    }
  }
#line 802
  mech->mech_len = (unsigned short )mask;
#line 804
  len = (size_t )(end - start);
#line 805
  if (len > sizeof(buf) - 1UL) {
#line 806
    return ((SPF_errcode_t )20);
  }
  {
#line 808
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 809
  buf[len] = (char )'\000';
#line 810
  addr = SPF_mech_ip6_data(mech);
#line 811
  err = inet_pton(10, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
  }
#line 812
  if (err <= 0) {
    {
#line 813
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )20, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 813
    return (tmp___1);
  }
#line 816
  return ((SPF_errcode_t )0);
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mech_add___5)(SPF_server_t *spf_server___1 ,
                                                                                   SPF_record_t *spf_record ,
                                                                                   SPF_response_t *spf_response ,
                                                                                   SPF_mechtype_t const   *mechtype ,
                                                                                   int prefix ,
                                                                                   char const   **mech_value ) 
{ 
  union __anonunion_u_60___5 u ;
  SPF_mech_t *spf_mechanism ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  SPF_errcode_t tmp ;
  int tmp___0 ;

  {
  {
#line 834
  spf_mechanism = (SPF_mech_t *)(u.buf);
#line 842
  memset((void *)(u.buf), 'B', sizeof(u.buf));
#line 843
  memset((void *)spf_mechanism, 0, sizeof(SPF_mech_t ));
  }
#line 845
  if (spf_server___1->debug) {
    {
#line 846
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               847, "SPF_c_mech_add: type=%d, value=%s", (int const   )mechtype->mech_type,
               *mech_value);
    }
  }
#line 849
  spf_mechanism->prefix_type = (unsigned char )prefix;
#line 850
  spf_mechanism->mech_type = (unsigned char )mechtype->mech_type;
#line 851
  spf_mechanism->mech_len = (unsigned short)0;
#line 853
  len = sizeof(SPF_mech_t );
#line 855
  if (spf_record->mech_len + len > 511UL) {
#line 856
    return ((SPF_errcode_t )16);
  }
  {
#line 858
  data = SPF_mech_data(spf_mechanism);
#line 859
  data_len = (size_t )0;
#line 861
  src_len = strcspn(*mech_value, " ");
  }
  {
#line 865
  if ((int const   )mechtype->mech_type == 5) {
#line 865
    goto case_5;
  }
#line 878
  if ((int const   )mechtype->mech_type == 6) {
#line 878
    goto case_6;
  }
#line 891
  goto switch_default;
  case_5: /* CIL Label */ 
#line 866
  if ((int const   )*(*mech_value) == 58) {
    {
#line 867
    err = SPF_c_parse_ip4___5(spf_response, spf_mechanism, *mech_value);
#line 868
    data_len = sizeof(struct in_addr );
    }
  } else {
    {
#line 871
    err = (SPF_errcode_t )9;
#line 872
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 876
  goto switch_break;
  case_6: /* CIL Label */ 
#line 879
  if ((int const   )*(*mech_value) == 58) {
    {
#line 880
    err = SPF_c_parse_ip6___5(spf_response, spf_mechanism, *mech_value);
#line 881
    data_len = sizeof(struct in6_addr );
    }
  } else {
    {
#line 884
    err = (SPF_errcode_t )9;
#line 885
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 889
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 892
  if ((int const   )*(*mech_value) == 58) {
#line 892
    goto _L___0;
  } else
#line 892
  if ((int const   )*(*mech_value) == 61) {
    _L___0: /* CIL Label */ 
#line 893
    if ((unsigned int const   )mechtype->has_domainspec == 0U) {
      {
#line 894
      err = (SPF_errcode_t )7;
#line 895
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a value.");
      }
    } else {
      {
#line 900
      (*mech_value) ++;
#line 900
      src_len --;
#line 901
      err = SPF_c_parse_domainspec___5(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )mechtype->has_cidr, 0);
      }
    }
  } else
#line 909
  if ((int const   )*(*mech_value) == 47) {
#line 910
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 911
      err = (SPF_errcode_t )9;
#line 912
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else
#line 916
    if ((unsigned int const   )mechtype->has_cidr == 0U) {
      {
#line 917
      err = (SPF_errcode_t )8;
#line 918
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a CIDR.");
      }
    } else {
      {
#line 923
      err = SPF_c_parse_domainspec___5(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )2, 0);
      }
    }
  } else
#line 931
  if ((int const   )*(*mech_value) == 32) {
#line 931
    goto _L;
  } else
#line 931
  if ((int const   )*(*mech_value) == 0) {
    _L: /* CIL Label */ 
#line 932
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 933
      err = (SPF_errcode_t )9;
#line 934
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else {
#line 939
      err = (SPF_errcode_t )0;
    }
  } else {
    {
#line 943
    err = (SPF_errcode_t )3;
#line 944
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Unknown character \'%c\' after mechanism.", (int const   )*(*mech_value));
    }
  }
#line 951
  spf_mechanism->mech_len = (unsigned short )data_len;
#line 952
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 955
  len += data_len;
#line 958
  if ((unsigned int )err == 0U) {
#line 959
    if (mechtype->is_dns_mech) {
#line 960
      spf_record->num_dns_mech = (unsigned char )((int )spf_record->num_dns_mech + 1);
    }
    {
#line 961
    tmp___0 = SPF_c_ensure_capacity___5((void **)(& spf_record->mech_first), & spf_record->mech_size,
                                        spf_record->mech_len + len);
    }
#line 961
    if (tmp___0 < 0) {
      {
#line 964
      tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                       (char const   *)((void *)0), "Failed to allocate memory for mechanism");
      }
#line 964
      return (tmp);
    }
    {
#line 968
    memcpy((void */* __restrict  */)((char *)spf_record->mech_first + spf_record->mech_len),
           (void const   */* __restrict  */)spf_mechanism, len);
#line 971
    spf_record->mech_len += len;
#line 972
    spf_record->num_mech = (unsigned char )((int )spf_record->num_mech + 1);
    }
  }
#line 975
  *mech_value += src_len;
#line 977
  return (err);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mod_add___5)(SPF_server_t *spf_server___1 ,
                                                                                  SPF_record_t *spf_record ,
                                                                                  SPF_response_t *spf_response ,
                                                                                  char const   *mod_name ,
                                                                                  size_t name_len ,
                                                                                  char const   **mod_value ) 
{ 
  union __anonunion_u_61___5 u ;
  SPF_mod_t *spf_modifier ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  char *tmp ;
  SPF_errcode_t tmp___0 ;
  int tmp___1 ;

  {
#line 992
  spf_modifier = (SPF_mod_t *)(u.buf);
#line 1000
  if (spf_server___1->debug) {
    {
#line 1001
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               1002, "Adding modifier name=%lu@%s, value=%s", name_len, mod_name,
               *mod_value);
    }
  }
  {
#line 1004
  memset((void *)(u.buf), 'A', sizeof(u.buf));
#line 1005
  memset((void *)spf_modifier, 0, sizeof(SPF_mod_t ));
  }
#line 1007
  if (name_len > 511UL) {
#line 1008
    return ((SPF_errcode_t )17);
  }
  {
#line 1010
  spf_modifier->name_len = (unsigned short )name_len;
#line 1011
  spf_modifier->data_len = (unsigned short)0;
#line 1014
  len = _align_sz(sizeof(SPF_mod_t ) + name_len);
  }
#line 1016
  if (spf_record->mod_len + len > 511UL) {
#line 1017
    return ((SPF_errcode_t )17);
  }
  {
#line 1019
  tmp = SPF_mod_name(spf_modifier);
#line 1019
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)mod_name,
         name_len);
#line 1021
  data = SPF_mod_data(spf_modifier);
#line 1022
  data_len = (size_t )0;
#line 1024
  src_len = strcspn(*mod_value, " ");
#line 1026
  err = SPF_c_parse_macro___5(spf_server___1, spf_response, data, & data_len, (size_t )511,
                              *mod_value, src_len, (SPF_errcode_t )17, 1);
#line 1032
  spf_modifier->data_len = (unsigned short )data_len;
#line 1033
  len += data_len;
  }
#line 1036
  if ((unsigned int )err == 0U) {
    {
#line 1037
    tmp___1 = SPF_c_ensure_capacity___5((void **)(& spf_record->mod_first), & spf_record->mod_size,
                                        spf_record->mod_len + len);
    }
#line 1037
    if (tmp___1 < 0) {
      {
#line 1040
      tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                           (char const   *)((void *)0), "Failed to allocate memory for modifier");
      }
#line 1040
      return (tmp___0);
    }
    {
#line 1044
    memcpy((void */* __restrict  */)((char *)spf_record->mod_first + spf_record->mod_len),
           (void const   */* __restrict  */)spf_modifier, len);
#line 1047
    spf_record->mod_len += len;
#line 1048
    spf_record->num_mod = (unsigned char )((int )spf_record->num_mod + 1);
    }
  }
#line 1051
  return (err);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static void SPF_record_lint___5(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                SPF_record_t *spf_record ) 
{ 
  SPF_data_t *d ;
  SPF_data_t *data_end ;
  char *s ;
  char *s_end ;
  int found_non_ip ;
  int found_valid_tld ;
  SPF_mech_t *mech ;
  SPF_data_t *data ;
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1075
  mech = spf_record->mech_first;
#line 1076
  i = 0;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (i < (int )spf_record->num_mech)) {
#line 1076
      goto while_break;
    }
#line 1081
    if ((int )mech->mech_type == 8) {
#line 1081
      goto _L;
    } else
#line 1081
    if ((int )mech->mech_type == 9) {
      _L: /* CIL Label */ 
#line 1081
      if (i != (int )spf_record->num_mech - 1) {
        {
#line 1085
        SPF_response_add_warn(spf_response, (SPF_errcode_t )29, "Mechanisms found after the \"all:\" mechanism will be ignored.");
        }
      }
    }
#line 1098
    if ((int )mech->mech_type == 5) {
#line 1100
      goto __Cont;
    } else
#line 1098
    if ((int )mech->mech_type == 6) {
#line 1100
      goto __Cont;
    }
    {
#line 1102
    data = SPF_mech_data(mech);
#line 1103
    data_end = SPF_mech_end_data(mech);
    }
#line 1104
    if ((unsigned long )data == (unsigned long )data_end) {
#line 1105
      goto __Cont;
    }
#line 1107
    if ((int )data->dc.parm_type == 11) {
      {
#line 1109
      data = SPF_data_next(data);
      }
#line 1110
      if ((unsigned long )data == (unsigned long )data_end) {
#line 1111
        goto __Cont;
      }
    }
#line 1115
    found_valid_tld = 0;
#line 1116
    found_non_ip = 0;
#line 1118
    d = data;
    {
#line 1118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1118
      if (! ((unsigned long )d < (unsigned long )data_end)) {
#line 1118
        goto while_break___0;
      }
      {
#line 1122
      if ((int )d->dv.parm_type == 11) {
#line 1122
        goto case_11;
      }
#line 1128
      if ((int )d->dv.parm_type == 0) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 5) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 4) {
#line 1128
        goto case_0;
      }
#line 1132
      if ((int )d->dv.parm_type == 12) {
#line 1132
        goto case_12;
      }
#line 1148
      goto switch_default;
      case_11: /* CIL Label */ 
      {
#line 1123
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1123, "%s", "Multiple CIDR parameters found");
      }
#line 1124
      goto switch_break;
      case_0: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 1129
      found_valid_tld = 0;
#line 1130
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 1133
      found_valid_tld = 0;
#line 1135
      s = SPF_data_str(d);
#line 1136
      s_end = s + (int )d->ds.len;
      }
      {
#line 1137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1137
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 1137
          goto while_break___1;
        }
        {
#line 1138
        tmp = __ctype_b_loc();
        }
#line 1138
        if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 2048)) {
#line 1138
          if ((int )*s != 46) {
#line 1138
            if ((int )*s != 58) {
#line 1139
              found_non_ip = 1;
            }
          }
        }
#line 1141
        if ((int )*s == 46) {
#line 1142
          found_valid_tld = 1;
        } else {
          {
#line 1143
          tmp___0 = __ctype_b_loc();
          }
#line 1143
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 1024)) {
#line 1144
            found_valid_tld = 0;
          }
        }
#line 1137
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1146
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1149
      found_non_ip = 1;
#line 1150
      found_valid_tld = 1;
#line 1152
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1118
      d = SPF_data_next(d);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1156
    if (! found_valid_tld) {
#line 1156
      goto _L___0;
    } else
#line 1156
    if (! found_non_ip) {
      _L___0: /* CIL Label */ 
#line 1157
      if (! found_non_ip) {
        {
#line 1158
        SPF_response_add_warn(spf_response, (SPF_errcode_t )27, "Invalid hostname (an IP address?)");
        }
      } else
#line 1160
      if (! found_valid_tld) {
        {
#line 1161
        SPF_response_add_warn(spf_response, (SPF_errcode_t )28, "Hostname has a missing or invalid TLD");
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 1076
    i ++;
#line 1076
    mech = SPF_mech_next(mech);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1168
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c"
static SPF_errcode_t SPF_record_find_mod_data___2(SPF_record_t *spf_record , char const   *mod_name ,
                                                  SPF_data_t **datap , size_t *datalenp ) 
{ 
  SPF_mod_t *mod ;
  size_t name_len ;
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 89
  name_len = strlen(mod_name);
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 94, "%s", "spf_record is NULL");
      }
    }
#line 94
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if ((unsigned long )mod_name == (unsigned long )((void *)0)) {
      {
#line 95
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 95, "%s", "mod_name is NULL");
      }
    }
#line 95
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )datap == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 96, "%s", "datap is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 97
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 97
    if ((unsigned long )datalenp == (unsigned long )((void *)0)) {
      {
#line 97
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 97, "%s", "datalenp is NULL");
      }
    }
#line 97
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 103
  mod = spf_record->mod_first;
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 104
    if (! (i < (int )spf_record->num_mod)) {
#line 104
      goto while_break___3;
    }
#line 105
    if (name_len == (size_t )mod->name_len) {
      {
#line 105
      tmp = SPF_mod_name(mod);
#line 105
      tmp___0 = strncasecmp((char const   *)tmp, mod_name, name_len);
      }
#line 105
      if (tmp___0 == 0) {
        {
#line 108
        *datap = SPF_mod_data(mod);
#line 109
        *datalenp = (size_t )mod->data_len;
        }
#line 111
        return ((SPF_errcode_t )0);
      }
    }
    {
#line 114
    mod = SPF_mod_next(mod);
#line 104
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 117
  return ((SPF_errcode_t )24);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static struct res_sym  const  ns_sects___5[4]  = {      {0, (char *)"QUESTION", (char *)"Question"}, 
        {1, (char *)"ANSWER", (char *)"Answer"}, 
        {2, (char *)"AUTHORITY", (char *)"Authority"}, 
        {3, (char *)"ADDITIONAL", (char *)"Additional"}};
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static int const   num_ns_sect___5  =    (int const   )(sizeof(ns_sects___5) / sizeof(ns_sects___5[0]));
#line 89 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_once_t res_state_control___5  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_key_t res_state_key___5  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_thread_term___5(void *arg ) 
{ 


  {
  {
#line 98
  __res_nclose((struct __res_state *)arg);
#line 100
  free(arg);
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_init_key___5(void) 
{ 


  {
  {
#line 106
  pthread_key_create(& res_state_key___5, & SPF_dns_resolv_thread_term___5);
  }
#line 107
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_debug___5(SPF_dns_server_t *spf_dns_server , ns_rr rr ,
                                     u_char const   *responsebuf , size_t responselen ,
                                     u_char const   *rdata , size_t rdlen ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char name_buf[1025] ;
  int prio ;
  int err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  u_int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 123
  if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 123
    goto case_1;
  }
#line 132
  if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 132
    goto case_28;
  }
#line 141
  if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 141
    goto case_2;
  }
#line 153
  if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 153
    goto case_5;
  }
#line 165
  if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 165
    goto case_15;
  }
#line 182
  if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 182
    goto case_16;
  }
#line 193
  if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 193
    goto case_12;
  }
#line 205
  goto switch_default;
  case_1: /* CIL Label */ 
#line 124
  if (rdlen != 4UL) {
    {
#line 125
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               125, "A: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 127
    tmp = inet_ntop(2, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip4_buf),
                    (socklen_t )sizeof(ip4_buf));
#line 127
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               129, "A: %s", tmp);
    }
  }
#line 130
  goto switch_break;
  case_28: /* CIL Label */ 
#line 133
  if (rdlen != 16UL) {
    {
#line 134
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               134, "AAAA: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 136
    tmp___0 = inet_ntop(10, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip6_buf),
                        (socklen_t )sizeof(ip6_buf));
#line 136
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               138, "AAAA: %s", tmp___0);
    }
  }
#line 139
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 142
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 146
  if (err < 0) {
    {
#line 147
    tmp___1 = __errno_location();
#line 147
    tmp___2 = __errno_location();
#line 147
    tmp___3 = strerror(*tmp___2);
#line 147
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               148, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___3,
               *tmp___1);
    }
  } else {
    {
#line 150
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               150, "NS: %s", name_buf);
    }
  }
#line 151
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 154
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 158
  if (err < 0) {
    {
#line 159
    tmp___4 = __errno_location();
#line 159
    tmp___5 = __errno_location();
#line 159
    tmp___6 = strerror(*tmp___5);
#line 159
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               160, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___6,
               *tmp___4);
    }
  } else {
    {
#line 162
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               162, "CNAME: %s", name_buf);
    }
  }
#line 163
  goto switch_break;
  case_15: /* CIL Label */ 
#line 166
  if (rdlen < 2UL) {
    {
#line 167
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               167, "MX: rdlen too short: %lu", rdlen);
    }
#line 168
    goto switch_break;
  }
  {
#line 170
  tmp___7 = ns_get16(rdata);
#line 170
  prio = (int )tmp___7;
#line 171
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata + 2, name_buf,
                           sizeof(name_buf));
  }
#line 175
  if (err < 0) {
    {
#line 176
    tmp___8 = __errno_location();
#line 176
    tmp___9 = __errno_location();
#line 176
    tmp___10 = strerror(*tmp___9);
#line 176
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               177, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___10,
               *tmp___8);
    }
  } else {
    {
#line 179
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               179, "MX: %d %s", prio, name_buf);
    }
  }
#line 180
  goto switch_break;
  case_16: /* CIL Label */ 
#line 183
  if (rdlen < 1UL) {
    {
#line 184
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               184, "TXT: rdlen too short: %lu", rdlen);
    }
#line 185
    goto switch_break;
  }
  {
#line 189
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             190, "TXT: (%lu) \"%.*s\"", rdlen, (int )rdlen - 1, rdata + 1);
  }
#line 191
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 194
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 198
  if (err < 0) {
    {
#line 199
    tmp___11 = __errno_location();
#line 199
    tmp___12 = __errno_location();
#line 199
    tmp___13 = strerror(*tmp___12);
#line 199
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               200, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___13,
               *tmp___11);
    }
  } else {
    {
#line 202
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               202, "PTR: %s", name_buf);
    }
  }
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 206
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             206, "not parsed:  type: %d", (unsigned int )((ns_type )((int )rr.type)));
  }
#line 207
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static SPF_dns_rr_t *SPF_dns_resolv_lookup___5(SPF_dns_server_t *spf_dns_server ,
                                               char const   *domain , ns_type rr_type ,
                                               int should_cache ) 
{ 
  SPF_dns_rr_t *spfrr ;
  int err ;
  int i ;
  int nrec ;
  int cnt ;
  u_char *responsebuf ;
  size_t responselen ;
  ns_msg ns_handle ;
  ns_rr rr ;
  int ns_sect___0 ;
  char name_buf[1025] ;
  size_t rdlen ;
  u_char const   *rdata ;
  void *res_spec ;
  struct __res_state *res_state___0 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int dns_len ;
  char const   *tmp___2 ;
  SPF_dns_rr_t *tmp___3 ;
  SPF_dns_rr_t *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  SPF_errcode_t tmp___20 ;
  SPF_errcode_t tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  SPF_errcode_t tmp___26 ;
  u_char *src ;
  u_char *dst ;
  size_t len ;
  SPF_errcode_t tmp___27 ;
  SPF_errcode_t tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  SPF_errcode_t tmp___33 ;

  {
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 247
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 247, "%s", "spf_dns_server is NULL");
      }
    }
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  res_spec = pthread_getspecific(res_state_key___5);
  }
#line 252
  if ((unsigned long )res_spec == (unsigned long )((void *)0)) {
    {
#line 253
    tmp = malloc(sizeof(struct __res_state ));
#line 253
    res_state___0 = (struct __res_state *)tmp;
    }
#line 257
    if (! res_state___0) {
      {
#line 258
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 259, "Failed to allocate %lu bytes for res_state", sizeof(struct __res_state ));
      }
    }
    {
#line 260
    memset((void *)res_state___0, 0, sizeof(struct __res_state ));
#line 261
    tmp___0 = __res_ninit(res_state___0);
    }
#line 261
    if (tmp___0 != 0) {
      {
#line 262
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 262, "%s", "Failed to call res_ninit()");
      }
    }
    {
#line 263
    pthread_setspecific(res_state_key___5, (void const   *)((void *)res_state___0));
    }
  } else {
#line 266
    res_state___0 = (struct __res_state *)res_spec;
  }
  {
#line 270
  responselen = (size_t )2048;
#line 271
  tmp___1 = malloc(responselen);
#line 271
  responsebuf = (u_char *)tmp___1;
  }
#line 272
  if (! responsebuf) {
#line 273
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 274
  memset((void *)responsebuf, 0, responselen);
  }
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 297
    dns_len = __res_nquery(res_state___0, domain, 1, (int )rr_type, responsebuf, (int )responselen);
    }
#line 304
    if (dns_len < 0) {
      {
#line 307
      free((void *)responsebuf);
      }
#line 308
      if (spf_dns_server->debug) {
        {
#line 309
        tmp___2 = hstrerror(res_state___0->res_h_errno);
#line 309
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   311, "query failed: err = %d  %s (%d): %s", dns_len, tmp___2, res_state___0->res_h_errno,
                   domain);
        }
      }
#line 312
      if (res_state___0->res_h_errno == 1) {
#line 312
        if ((unsigned long )spf_dns_server->layer_below != (unsigned long )((void *)0)) {
          {
#line 314
          tmp___3 = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
          }
#line 314
          return (tmp___3);
        }
      }
      {
#line 317
      tmp___4 = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, res_state___0->res_h_errno);
      }
#line 317
      return (tmp___4);
    } else
#line 320
    if ((size_t )dns_len > responselen) {
      {
#line 323
      responselen = (size_t )(dns_len + (dns_len >> 1));
#line 332
      tmp___5 = realloc((void *)responsebuf, responselen);
      }
#line 333
      if (! tmp___5) {
        {
#line 334
        free((void *)responsebuf);
        }
#line 335
        return ((SPF_dns_rr_t *)((void *)0));
      }
#line 337
      responsebuf = (u_char *)tmp___5;
    } else {
#line 341
      responselen = (size_t )dns_len;
#line 342
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 351
  spfrr = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, 0);
  }
#line 353
  if (! spfrr) {
    {
#line 354
    free((void *)responsebuf);
    }
#line 355
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 358
  err = ns_initparse((u_char const   *)responsebuf, (int )responselen, & ns_handle);
  }
#line 360
  if (err < 0) {
#line 361
    if (spf_dns_server->debug) {
      {
#line 362
      tmp___6 = __errno_location();
#line 362
      tmp___7 = __errno_location();
#line 362
      tmp___8 = strerror(*tmp___7);
#line 362
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 363, "ns_initparse failed: err = %d  %s (%d)", err, tmp___8, *tmp___6);
      }
    }
    {
#line 364
    free((void *)responsebuf);
#line 367
    spfrr->herrno = 3;
    }
#line 368
    return (spfrr);
  }
#line 372
  if (spf_dns_server->debug > 1) {
    {
#line 373
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               373, "msg id:             %d", (int )ns_handle._id);
#line 374
    tmp___9 = ns_msg_getflag(ns_handle, 0);
#line 374
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               374, "ns_f_qr quest/resp: %d", tmp___9);
#line 375
    tmp___10 = ns_msg_getflag(ns_handle, 1);
#line 375
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               375, "ns_f_opcode:        %d", tmp___10);
#line 376
    tmp___11 = ns_msg_getflag(ns_handle, 2);
#line 376
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               376, "ns_f_aa auth ans:   %d", tmp___11);
#line 377
    tmp___12 = ns_msg_getflag(ns_handle, 3);
#line 377
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               377, "ns_f_tc truncated:  %d", tmp___12);
#line 378
    tmp___13 = ns_msg_getflag(ns_handle, 4);
#line 378
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               378, "ns_f_rd rec desire: %d", tmp___13);
#line 379
    tmp___14 = ns_msg_getflag(ns_handle, 5);
#line 379
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               379, "ns_f_ra rec avail:  %d", tmp___14);
#line 380
    tmp___15 = ns_msg_getflag(ns_handle, 9);
#line 380
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               380, "ns_f_rcode:         %d", tmp___15);
    }
  }
#line 385
  ns_sect___0 = 0;
  {
#line 385
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 385
    if (! (ns_sect___0 < (int )num_ns_sect___5)) {
#line 385
      goto while_break___1;
    }
#line 391
    if (ns_sects___5[ns_sect___0].number != 1) {
#line 391
      if (spf_dns_server->debug <= 1) {
#line 392
        goto __Cont;
      }
    }
#line 394
    nrec = (int )ns_handle._counts[ns_sects___5[ns_sect___0].number];
#line 396
    if (spf_dns_server->debug > 1) {
      {
#line 397
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 397, "%s:  %d", ns_sects___5[ns_sect___0].name, nrec);
      }
    }
#line 399
    spfrr->num_rr = 0;
#line 400
    cnt = 0;
#line 401
    i = 0;
    {
#line 401
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 401
      if (! (i < nrec)) {
#line 401
        goto while_break___2;
      }
      {
#line 402
      err = ns_parserr(& ns_handle, (ns_sect )ns_sects___5[ns_sect___0].number, i,
                       & rr);
      }
#line 403
      if (err < 0) {
#line 404
        if (spf_dns_server->debug > 1) {
          {
#line 405
          tmp___16 = __errno_location();
#line 405
          tmp___17 = __errno_location();
#line 405
          tmp___18 = strerror(*tmp___17);
#line 405
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     406, "ns_parserr failed: err = %d  %s (%d)", err, tmp___18, *tmp___16);
          }
        }
        {
#line 407
        free((void *)responsebuf);
#line 410
        spfrr->herrno = 3;
        }
#line 411
        return (spfrr);
      }
#line 414
      rdlen = (size_t )((int )rr.rdlength);
#line 415
      if (spf_dns_server->debug > 1) {
#line 416
        if ((int )rr.name[0] != 0) {
#line 416
          tmp___19 = (char const   *)(rr.name);
        } else {
#line 416
          tmp___19 = ".";
        }
        {
#line 416
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   418, "name: %s  type: %d  class: %d  ttl: %d  rdlen: %lu", tmp___19,
                   (unsigned int )((ns_type )((int )rr.type)), (unsigned int )((ns_class )((int )rr.rr_class)),
                   rr.ttl, rdlen);
        }
      }
#line 420
      if (rdlen <= 0UL) {
#line 421
        goto __Cont___0;
      }
#line 423
      rdata = rr.rdata + 0;
#line 425
      if (spf_dns_server->debug > 1) {
        {
#line 426
        SPF_dns_resolv_debug___5(spf_dns_server, rr, (u_char const   *)responsebuf,
                                 responselen, rdata, rdlen);
        }
      }
#line 430
      if (ns_sects___5[ns_sect___0].number != 1) {
#line 431
        goto __Cont___0;
      }
#line 434
      if ((unsigned int )((ns_type )((int )rr.type)) != (unsigned int )spfrr->rr_type) {
#line 434
        if ((unsigned int )((ns_type )((int )rr.type)) != 5U) {
          {
#line 435
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     436, "unexpected rr type: %d   expected: %d", (unsigned int )((ns_type )((int )rr.type)),
                     (unsigned int )rr_type);
          }
#line 437
          goto __Cont___0;
        }
      }
      {
#line 441
      if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 441
        goto case_1;
      }
#line 458
      if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 458
        goto case_28;
      }
#line 475
      if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 475
        goto case_2;
      }
#line 478
      if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 478
        goto case_5;
      }
#line 482
      if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 482
        goto case_15;
      }
#line 513
      if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 513
        goto case_16;
      }
#line 562
      if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 562
        goto case_12;
      }
#line 588
      goto switch_default;
      case_1: /* CIL Label */ 
#line 442
      if (rdlen != 4UL) {
        {
#line 444
        free((void *)responsebuf);
        }
#line 445
        return (spfrr);
      }
      {
#line 447
      tmp___20 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->a));
      }
#line 447
      if ((unsigned int )tmp___20 != 0U) {
        {
#line 449
        free((void *)responsebuf);
        }
#line 452
        return (spfrr);
      }
      {
#line 454
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->a), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->a));
#line 455
      cnt ++;
      }
#line 456
      goto switch_break;
      case_28: /* CIL Label */ 
#line 459
      if (rdlen != 16UL) {
        {
#line 461
        free((void *)responsebuf);
        }
#line 462
        return (spfrr);
      }
      {
#line 464
      tmp___21 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->aaaa));
      }
#line 464
      if ((unsigned int )tmp___21 != 0U) {
        {
#line 466
        free((void *)responsebuf);
        }
#line 469
        return (spfrr);
      }
      {
#line 471
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->aaaa), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->aaaa));
#line 472
      cnt ++;
      }
#line 473
      goto switch_break;
      case_2: /* CIL Label */ 
#line 476
      goto switch_break;
      case_5: /* CIL Label */ 
#line 480
      goto switch_break;
      case_15: /* CIL Label */ 
#line 483
      if (rdlen < 2UL) {
        {
#line 485
        free((void *)responsebuf);
        }
#line 486
        return (spfrr);
      }
      {
#line 488
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata + 2, name_buf, sizeof(name_buf));
      }
#line 492
      if (err < 0) {
#line 493
        if (spf_dns_server->debug > 1) {
          {
#line 494
          tmp___22 = __errno_location();
#line 494
          tmp___23 = __errno_location();
#line 494
          tmp___24 = strerror(*tmp___23);
#line 494
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     495, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___24,
                     *tmp___22);
          }
        }
        {
#line 496
        free((void *)responsebuf);
        }
#line 499
        return (spfrr);
      }
      {
#line 502
      tmp___25 = strlen((char const   *)(name_buf));
#line 502
      tmp___26 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___25 + 1UL);
      }
#line 502
      if ((unsigned int )tmp___26 != 0U) {
        {
#line 504
        free((void *)responsebuf);
        }
#line 507
        return (spfrr);
      }
      {
#line 509
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->mx), (char const   */* __restrict  */)(name_buf));
#line 510
      cnt ++;
      }
#line 511
      goto switch_break;
      case_16: /* CIL Label */ 
#line 514
      if (rdlen > 1UL) {
        {
#line 520
        tmp___27 = SPF_dns_rr_buf_realloc(spfrr, cnt, rdlen);
        }
#line 520
        if ((unsigned int )tmp___27 != 0U) {
          {
#line 521
          free((void *)responsebuf);
          }
#line 524
          return (spfrr);
        }
#line 527
        dst = (u_char *)((*(spfrr->rr + cnt))->txt);
#line 528
        src = (u_char *)rdata;
#line 529
        len = (size_t )0;
        {
#line 530
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 530
          if (! (rdlen > 0UL)) {
#line 530
            goto while_break___3;
          }
#line 532
          len = (size_t )*src;
#line 533
          src ++;
#line 534
          rdlen --;
#line 538
          if (len > rdlen) {
#line 539
            len = rdlen;
          }
          {
#line 540
          memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src,
                 len);
#line 543
          src += len;
#line 544
          dst += len;
#line 545
          rdlen -= len;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 547
        *dst = (u_char )'\000';
      } else {
        {
#line 550
        tmp___28 = SPF_dns_rr_buf_realloc(spfrr, cnt, (size_t )1);
        }
#line 550
        if ((unsigned int )tmp___28 != 0U) {
          {
#line 551
          free((void *)responsebuf);
          }
#line 554
          return (spfrr);
        }
#line 556
        (*(spfrr->rr + cnt))->txt[0] = (char )'\000';
      }
#line 559
      cnt ++;
#line 560
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 563
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata, name_buf, sizeof(name_buf));
      }
#line 567
      if (err < 0) {
#line 568
        if (spf_dns_server->debug > 1) {
          {
#line 569
          tmp___29 = __errno_location();
#line 569
          tmp___30 = __errno_location();
#line 569
          tmp___31 = strerror(*tmp___30);
#line 569
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     570, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___31,
                     *tmp___29);
          }
        }
        {
#line 571
        free((void *)responsebuf);
        }
#line 574
        return (spfrr);
      }
      {
#line 577
      tmp___32 = strlen((char const   *)(name_buf));
#line 577
      tmp___33 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___32 + 1UL);
      }
#line 577
      if ((unsigned int )tmp___33 != 0U) {
        {
#line 579
        free((void *)responsebuf);
        }
#line 582
        return (spfrr);
      }
      {
#line 584
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->ptr), (char const   */* __restrict  */)(name_buf));
#line 585
      cnt ++;
      }
#line 586
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 589
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 401
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 593
    spfrr->num_rr = cnt;
    __Cont: /* CIL Label */ 
#line 385
    ns_sect___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 596
  if (spfrr->num_rr == 0) {
#line 597
    spfrr->herrno = 4;
  }
  {
#line 599
  free((void *)responsebuf);
  }
#line 600
  return (spfrr);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_free___5(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 607
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 607, "%s", "spf_dns_server is NULL");
      }
    }
#line 607
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  free((void *)spf_dns_server);
  }
#line 614
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spftest/spftest.c"
static void usage___4(void) 
{ 


  {
  {
#line 78
  printf((char const   */* __restrict  */)"Usage: spftest [spf \"<spf record>\" | domain <domain name>\n");
#line 79
  printf((char const   */* __restrict  */)"                | ip <ip address> | exp \"<explanation string>\"\n");
#line 80
  printf((char const   */* __restrict  */)"                | version ]\n");
  }
#line 81
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
static SPF_dns_test_data_t const   SPF_dns_db___6[175]  = 
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
  {      {"localhost", 1, 0, "127.0.0.1"}, 
        {"example.com", 1, 0, "192.0.2.3"}, 
        {"example.com", 15, 0, "mx.example.org"}, 
        {"example.com", 16, 0, "v=spf1 mx -all"}, 
        {"3.2.0.192.in-addr.arpa", 12, 0, "mx.example.org"}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}, 
        {"noexist.example.com", 1, 1, (char const   *)((void *)0)}, 
        {"mx.example.org", 1, 0, "192.0.2.3"}, 
        {"mx.example.org", 28, 0, "5f05:2000:80ad:5800::1"}, 
        {"email.example.com", 16, 0, "v=spf1 -all"}, 
        {"*.example.com", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.org", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.net", 255, 1, (char const   *)((void *)0)}, 
        {"01.spf1-test.mailzone.com", 16, 0, "v=spf1                                                             "}, 
        {"02.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             -all       "}, 
        {"03.spf1-test.mailzone.com", 16, 0, "v=spf1                                             ~all"}, 
        {"05.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             default=deny   "}, 
        {"06.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             ?all "}, 
        {"07.spf1-test.mailzone.com", 16, 0, "v=spf2                                             default=bogus   "}, 
        {"08.spf1-test.mailzone.com",
      16, 0, "v=spf1                       -all      ?all  "}, 
        {"09.spf1-test.mailzone.com", 16, 0, "v=spf1    scope=header-from scope=envelope         -all  "}, 
        {"10.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx                                          -all"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"11.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"13.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"20.spf1-test.mailzone.com", 1, 0, "192.0.2.120"}, 
        {"20.spf1-test.mailzone.com", 16, 0, "v=spf1 a                                           -all"}, 
        {"21.spf1-test.mailzone.com",
      16, 0, "v=spf1   a:spf1-test.mailzone.com                            -all"}, 
        {"21.spf1-test.mailzone.com",
      1, 0, "192.0.2.121"}, 
        {"22.spf1-test.mailzone.com", 16, 0, "v=spf1 a a:spf1-test.mailzone.com                            -all"}, 
        {"22.spf1-test.mailzone.com",
      1, 0, "192.0.2.122"}, 
        {"30.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr                                         -all"}, 
        {"30.spf1-test.mailzone.com",
      1, 0, "208.210.124.130"}, 
        {"31.spf1-test.mailzone.com", 16, 0, "v=spf1     ptr:spf1-test.mailzone.com                        -all"}, 
        {"31.spf1-test.mailzone.com",
      1, 0, "208.210.124.131"}, 
        {"32.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr ptr:spf1-test.mailzone.com                        -all"}, 
        {"32.spf1-test.mailzone.com",
      1, 0, "208.210.124.132"}, 
        {"40.spf1-test.mailzone.com", 16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d}                    -all"}, 
        {"41.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.spf1-test.mailzone.com            -all"}, 
        {"42.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d} exists:%{ir}.%{v}._spf.%{d3} -all"}, 
        {"45.spf1-test.mailzone.com",
      16, 0, "v=spf1 -a a:spf1-test.mailzone.com                           -all"}, 
        {"45.spf1-test.mailzone.com",
      1, 0, "192.0.2.147"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.145"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.146"}, 
        {"50.spf1-test.mailzone.com", 16, 0, "v=spf1 include                                     -all"}, 
        {"51.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"52.spf1-test.mailzone.com", 16, 0, "v=spf1 include:53.spf1-test.mailzone.com                  -all"}, 
        {"53.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"54.spf1-test.mailzone.com", 16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"55.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:56.spf1-test.mailzone.com                  -all"}, 
        {"57.spf1-test.mailzone.com", 16, 0, "v=spf1 include:spf1-test.mailzone.com         -all"}, 
        {"58.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:59.spf1-test.mailzone.com                  -all"}, 
        {"59.spf1-test.mailzone.com", 16, 0, "v=spf1 include:58.spf1-test.mailzone.com                  -all"}, 
        {"70.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{lr+=}.lp._spf.spf1-test.mailzone.com -all"}, 
        {"80.spf1-test.mailzone.com", 16, 0, "v=spf1 a mx exists:%{ir}.%{v}._spf.80.spf1-test.mailzone.com ptr -all"}, 
        {"80.spf1-test.mailzone.com",
      1, 0, "208.210.124.180"}, 
        {"90.spf1-test.mailzone.com", 16, 0, "v=spf1  ip4:192.0.2.128/25 -all"}, 
        {"91.spf1-test.mailzone.com", 16, 0, "v=spf1 -ip4:192.0.2.128/25 ip4:192.0.2.0/24 -all"}, 
        {"92.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?ip4:192.0.2.192/26 ip4:192.0.2.128/25 -ip4:192.0.2.0/24 -all"}, 
        {"95.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -all"}, 
        {"96.spf1-test.mailzone.com", 16, 0, "v=spf1 -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"97.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"98.spf1-test.mailzone.com",
      16, 0, "v=spf1 a/26 mx/26 -all"}, 
        {"98.spf1-test.mailzone.com", 15, 0, "80.spf1-test.mailzone.com"}, 
        {"98.spf1-test.mailzone.com", 1, 0, "192.0.2.98"}, 
        {"99.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp=99txt.spf1-test.mailzone.com moo"}, 
        {"99txt.spf1-test.mailzone.com",
      16, 0, "u=%{u} s=%{s} d=%{d} t=%{t} h=%{h} i=%{i} %% U=%{U} S=%{S} D=%{D} T=%{T} H=%{H} I=%{I} %% moo"}, 
        {"100.spf1-test.mailzone.com",
      16, 0, "v=spf1      redirect=98.spf1-test.mailzone.com"}, 
        {"101.spf1-test.mailzone.com", 16, 0, "v=spf1 -all redirect=98.spf1-test.mailzone.com"}, 
        {"102.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?all redirect=98.spf1-test.mailzone.com"}, 
        {"103.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=98.%{d3}"}, 
        {"104.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=105.%{d3}"}, 
        {"105.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=106.%{d3}"}, 
        {"106.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=107.%{d3}"}, 
        {"107.spf1-test.mailzone.com", 16, 0, "v=spf1       include:104.%{d3}"}, 
        {"110.spf1-test.mailzone.com", 16, 0, "v=spf1 some:unrecognized=mechanism some=unrecognized:modifier -all"}, 
        {"111.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx -a gpg ~all exp=111txt.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"111txt.2.0.192.in-addr._spf.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"112.spf1-test.mailzone.com",
      16, 0, "v=spf1 a mp3 ~all"}, 
        {"112.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"113.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3: ~all"}, 
        {"113.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114.spf1-test.mailzone.com", 16, 0, "v=spf1 mx -a gpg=test ~all exp=114txt.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com",
      15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114txt.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"115.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3=yes -all"}, 
        {"115.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"116.spf1-test.mailzone.com", 16, 0, "v=spf1 redirect=116rdr.spf1-test.mailzone.com a"}, 
        {"116.spf1-test.mailzone.com",
      1, 0, "192.0.2.200"}, 
        {"116rdr.spf1-test.mailzone.com", 16, 0, "v=spf1 -all"}, 
        {"117.spf1-test.mailzone.com", 16, 0, " v=spf1 +all"}, 
        {"118.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp="}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.10"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.11"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.12"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.13"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.20"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.21"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.22"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.23"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.30"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.31"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.32"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.33"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.40"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.41"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.42"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.43"}, 
        {"56.spf1-test.mailzone.com", 16, 4, (char const   *)((void *)0)}, 
        {"80.spf1-test.mailzone.com", 15, 4, (char const   *)((void *)0)}, 
        {"servfail.spf1-test.mailzone.com", 16, 2, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 1, 0, "208.210.124.192"}, 
        {"spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"fallback-relay.spf1-test.mailzone.com", 15, 0, "mx04.spf1-test.mailzone.com"}, 
        {"www1.cnn.com",
      1, 0, "64.236.24.4"}, 
        {"4.24.236.64.in-addr.arpa", 12, 0, "www1.cnn.com"}, 
        {"130.124.210.208.in-addr.arpa", 12, 0, "30.spf1-test.mailzone.com"}, 
        {"131.124.210.208.in-addr.arpa", 12, 0, "31.spf1-test.mailzone.com"}, 
        {"192.124.210.208.in-addr.arpa", 12, 0, "spf1-test.mailzone.com"}, 
        {"100.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"110.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"111.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"101.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"130.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"131.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"80.2.0.192.in-addr._spf.80.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"96.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"97.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com",
      1, 0, "127.0.0.2"}, 
        {"bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"postmaster.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"2.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.joe.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"102.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"110.2.0.192.in-addr._spf.42.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"131.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"4.24.236.64.in-addr._spf.80.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"droid.lp._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"joe-2.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"moe-1.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"unknown.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"180.124.210.208.in-addr.arpa",
      12, 0, "80.spf1-test.mailzone.com"}, 
        {"80.spf1-test.mailzone.com.whitelist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.124.210.208.in-addr.arpa",
      12, 0, "pobox-gw.icgroup.com"}, 
        {"pobox-gw.icgroup.com", 1, 0, "208.210.124.1"}, 
        {"pobox-gw.icgroup.com.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com",
      16, 1, (char const   *)((void *)0)}, 
        {"spf.trusted-forwarder.org", 16, 0, "v=spf1 exists:%{ir}.wl.trusted-forwarder.org exists:%{p}.wl.trusted-forwarder.org"}, 
        {"*.spf1-text.mailzone.com",
      255, 1, (char const   *)((void *)0)}, 
        {"cat.com", 16, 4, (char const   *)((void *)0)}, 
        {"bar.com", 16, 4, (char const   *)((void *)0)}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}};
#line 41 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static SPF_dns_rr_t *SPF_dns_null_lookup___6(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_rr_t *tmp ;
  SPF_dns_rr_t *tmp___0 ;

  {
#line 45
  if (spf_dns_server->layer_below) {
    {
#line 46
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 46
    return (tmp);
  }
  {
#line 48
  tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
  }
#line 48
  return (tmp___0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static void SPF_dns_null_free___6(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 54
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c",
                 54, "%s", "spf_dns_server is NULL");
      }
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  free((void *)spf_dns_server);
  }
#line 56
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_explanation___6(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  char *buf ;
  size_t buflen ;
  void *tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 53
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 53, "%s", "spf_response is NULL");
      }
    }
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  spf_request = spf_response->spf_request;
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 55
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 55, "%s", "spf_request is NULL");
      }
    }
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  spf_server___1 = spf_request->spf_server;
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 57
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 57
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 57, "%s", "spf_server is NULL");
      }
    }
#line 57
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  spf_record = spf_response->spf_record_exp;
  {
#line 60
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 60
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 60
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 60, "%s", "spf_record is NULL");
      }
    }
#line 60
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 62
  if (spf_response->explanation) {
    {
#line 63
    free((void *)spf_response->explanation);
    }
  }
  {
#line 64
  spf_response->explanation = (char *)((void *)0);
#line 66
  buflen = (size_t )321;
#line 67
  tmp = malloc(buflen);
#line 67
  buf = (char *)tmp;
  }
#line 68
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 69
    return ((SPF_errcode_t )1);
  }
  {
#line 70
  memset((void *)buf, '\000', buflen);
#line 72
  err = SPF_request_get_exp(spf_server___1, spf_request, spf_response, spf_record,
                            & buf, & buflen);
  }
#line 74
  if ((unsigned int )err != 0U) {
    {
#line 75
    free((void *)buf);
    }
#line 76
    return (err);
  }
#line 79
  spf_response->explanation = buf;
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_smtp_comment___6(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_errcode_t err ;
  char buf[320] ;
  char const   *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 92
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 92, "%s", "spf_response is NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  spf_request = spf_response->spf_request;
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 94, "%s", "spf_request is NULL");
      }
    }
#line 94
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  spf_server___1 = spf_request->spf_server;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 96, "%s", "spf_server is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  if (spf_response->smtp_comment) {
    {
#line 99
    free((void *)spf_response->smtp_comment);
    }
  }
#line 100
  spf_response->smtp_comment = (char *)((void *)0);
  {
#line 107
  if ((unsigned int )spf_response->result == 5U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 1U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 4U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 3U) {
#line 107
    goto case_5;
  }
#line 129
  goto switch_default;
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 109
  err = SPF_i_set_explanation___6(spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
#line 111
    return (err);
  }
  {
#line 113
  memset((void *)(buf), '\000', sizeof(buf));
#line 114
  tmp = SPF_strreason(spf_response->reason);
#line 114
  snprintf((char */* __restrict  */)(buf), (size_t )320, (char const   */* __restrict  */)"%s : Reason: %s",
           spf_response->explanation, tmp);
#line 117
  buf[319] = (char )'\000';
#line 120
  spf_response->smtp_comment = strdup((char const   *)(buf));
  }
#line 121
  if (! spf_response->smtp_comment) {
#line 122
    return ((SPF_errcode_t )1);
  }
#line 124
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 130
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 133
  return ((SPF_errcode_t )0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_header_comment___6(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char *spf_source ;
  size_t len ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  char *sender_dom ;
  char *p ;
  char *p_end ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 153
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 153, "%s", "spf_response is NULL");
      }
    }
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  spf_request = spf_response->spf_request;
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 155
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 155, "%s", "spf_request is NULL");
      }
    }
#line 155
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 156
  spf_server___1 = spf_request->spf_server;
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 157
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 157, "%s", "spf_server is NULL");
      }
    }
#line 157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 159
  if (spf_response->header_comment) {
    {
#line 160
    free((void *)spf_response->header_comment);
    }
  }
#line 161
  spf_response->header_comment = (char *)((void *)0);
#line 164
  sender_dom = spf_request->env_from_dp;
#line 165
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
#line 166
    sender_dom = spf_request->helo_dom;
  }
#line 168
  if ((unsigned int )spf_response->reason == 3U) {
    {
#line 169
    spf_source = strdup("local policy");
    }
  } else
#line 171
  if ((unsigned int )spf_response->reason == 6U) {
#line 172
    if ((unsigned long )spf_request->rcpt_to_dom == (unsigned long )((void *)0)) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    } else
#line 172
    if ((int )*(spf_request->rcpt_to_dom + 0) == 0) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    }
    {
#line 175
    spf_source = strdup((char const   *)spf_request->rcpt_to_dom);
    }
  } else
#line 177
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
    {
#line 178
    spf_source = strdup("unknown domain");
    }
  } else {
    {
#line 181
    tmp = strlen((char const   *)sender_dom);
#line 181
    len = tmp + sizeof("domain of ");
#line 182
    tmp___0 = malloc(len);
#line 182
    spf_source = (char *)tmp___0;
    }
#line 183
    if (spf_source) {
      {
#line 184
      snprintf((char */* __restrict  */)spf_source, len, (char const   */* __restrict  */)"domain of %s",
               sender_dom);
      }
    }
  }
#line 187
  if ((unsigned long )spf_source == (unsigned long )((void *)0)) {
#line 188
    return ((SPF_errcode_t )10);
  }
#line 190
  ip = (char const   *)((void *)0);
#line 191
  if (spf_request->client_ver == 2) {
    {
#line 192
    ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                   (socklen_t )sizeof(ip4_buf));
    }
  } else
#line 195
  if (spf_request->client_ver == 10) {
    {
#line 196
    ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                   (socklen_t )sizeof(ip6_buf));
    }
  }
#line 199
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 200
    ip = "(unknown ip address)";
  }
  {
#line 202
  tmp___1 = SPF_request_get_rec_dom(spf_request);
#line 202
  tmp___2 = strlen(tmp___1);
#line 202
  tmp___3 = strlen((char const   *)spf_source);
#line 202
  tmp___4 = strlen(ip);
#line 202
  len = ((tmp___2 + tmp___3) + tmp___4) + 80UL;
#line 203
  tmp___5 = malloc(len);
#line 203
  buf = (char *)tmp___5;
  }
#line 204
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 205
    free((void *)spf_source);
    }
#line 206
    return ((SPF_errcode_t )10);
  }
  {
#line 209
  p = buf;
#line 210
  p_end = p + len;
#line 213
  tmp___6 = SPF_request_get_rec_dom(spf_request);
#line 213
  tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s: ",
                     tmp___6);
#line 213
  p += tmp___7;
  }
  {
#line 217
  if ((unsigned int )spf_response->result == 2U) {
#line 217
    goto case_2;
  }
#line 228
  if ((unsigned int )spf_response->result == 3U) {
#line 228
    goto case_3;
  }
#line 233
  if ((unsigned int )spf_response->result == 4U) {
#line 233
    goto case_4;
  }
#line 238
  if ((unsigned int )spf_response->result == 7U) {
#line 238
    goto case_7;
  }
#line 243
  if ((unsigned int )spf_response->result == 1U) {
#line 243
    goto case_1;
  }
#line 247
  if ((unsigned int )spf_response->result == 5U) {
#line 247
    goto case_5;
  }
#line 252
  if ((unsigned int )spf_response->result == 6U) {
#line 252
    goto case_6;
  }
#line 258
  goto switch_default;
  case_2: /* CIL Label */ 
#line 218
  if ((unsigned int )spf_response->reason == 2U) {
    {
#line 219
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"localhost is always allowed.");
    }
  } else
#line 220
  if ((unsigned int )spf_response->reason == 6U) {
    {
#line 221
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"message received from %s which is an MX secondary for %s.",
             ip, spf_source);
    }
  } else {
    {
#line 224
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s designates %s as permitted sender",
             spf_source, ip);
    }
  }
#line 226
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 229
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 231
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 234
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"transitioning %s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 236
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 239
  tmp___8 = SPF_strerror(spf_response->err);
#line 239
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error in processing during lookup of %s: %s",
           spf_source, tmp___8);
  }
#line 241
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 244
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s is neither permitted nor denied by %s",
           ip, spf_source);
  }
#line 246
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 248
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not provide an SPF record",
           spf_source);
  }
#line 250
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 253
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"encountered temporary error during SPF processing of %s",
           spf_source);
  }
#line 255
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 259
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error: unknown SPF result %d encountered while checking %s for %s",
           (unsigned int )spf_response->result, ip, spf_source);
  }
#line 261
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 264
  if (spf_source) {
    {
#line 265
    free((void *)spf_source);
    }
  }
  {
#line 267
  spf_response->header_comment = SPF_sanitize(spf_server___1, buf);
  }
#line 269
  return ((SPF_errcode_t )0);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_received_spf___6(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  size_t buflen ;
  char *buf_value ;
  char *p ;
  char *p_end ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 282
  buflen = (size_t )480;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 287
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 287, "%s", "spf_response is NULL");
      }
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  spf_request = spf_response->spf_request;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 289
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 289, "%s", "spf_request is NULL");
      }
    }
#line 289
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  spf_server___1 = spf_request->spf_server;
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 291
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 291
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 291, "%s", "spf_server is NULL");
      }
    }
#line 291
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 293
  if (spf_response->received_spf) {
    {
#line 294
    free((void *)spf_response->received_spf);
    }
  }
  {
#line 295
  spf_response->received_spf = (char *)((void *)0);
#line 297
  tmp = malloc(buflen);
#line 297
  buf = (char *)tmp;
  }
#line 298
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 299
    return ((SPF_errcode_t )10);
  }
  {
#line 301
  p = buf;
#line 302
  p_end = p + buflen;
#line 306
  tmp___0 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"Received-SPF: ");
#line 306
  p += tmp___0;
#line 307
  buf_value = p;
  }
  {
#line 309
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 310
    tmp___1 = SPF_strresult(spf_response->result);
#line 310
    tmp___2 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s (%s)",
                       tmp___1, spf_response->header_comment);
#line 310
    p += tmp___2;
    }
#line 313
    if (p_end - p <= 0L) {
#line 313
      goto while_break___2;
    }
#line 318
    ip = (char const   *)((void *)0);
#line 319
    if (spf_request->client_ver == 2) {
      {
#line 320
      ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                     (socklen_t )sizeof(ip4_buf));
      }
    } else
#line 323
    if (spf_request->client_ver == 10) {
      {
#line 324
      ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                     (socklen_t )sizeof(ip6_buf));
      }
    }
#line 328
    if ((unsigned long )ip != (unsigned long )((void *)0)) {
      {
#line 329
      tmp___3 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" client-ip=%s;",
                         ip);
#line 329
      p += tmp___3;
      }
#line 330
      if (p_end - p <= 0L) {
#line 330
        goto while_break___2;
      }
    }
#line 335
    if ((unsigned long )spf_request->env_from != (unsigned long )((void *)0)) {
      {
#line 336
      tmp___4 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" envelope-from=%s;",
                         spf_request->env_from);
#line 336
      p += tmp___4;
      }
#line 337
      if (p_end - p <= 0L) {
#line 337
        goto while_break___2;
      }
    }
#line 342
    if ((unsigned long )spf_request->helo_dom != (unsigned long )((void *)0)) {
      {
#line 343
      tmp___5 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" helo=%s;",
                         spf_request->helo_dom);
#line 343
      p += tmp___5;
      }
#line 344
      if (p_end - p <= 0L) {
#line 344
        goto while_break___2;
      }
    }
#line 309
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 366
  spf_response->received_spf = SPF_sanitize(spf_server___1, buf);
#line 367
  spf_response->received_spf_value = buf_value;
  }
#line 369
  return ((SPF_errcode_t )0);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_mech_cidr___6(SPF_request_t *spf_request , SPF_mech_t *mech ) 
{ 
  SPF_data_t *data ;
  SPF_data_t *tmp ;

  {
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if ((unsigned long )mech == (unsigned long )((void *)0)) {
      {
#line 428
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 428, "%s", "mech is NULL");
      }
    }
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  if ((int )mech->mech_type == 6) {
#line 433
    goto case_6;
  }
#line 433
  if ((int )mech->mech_type == 5) {
#line 433
    goto case_6;
  }
#line 438
  if ((int )mech->mech_type == 2) {
#line 438
    goto case_2;
  }
#line 438
  if ((int )mech->mech_type == 1) {
#line 438
    goto case_2;
  }
#line 430
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 434
  return ((int )mech->mech_len);
#line 435
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 439
  data = SPF_mech_data(mech);
#line 441
  tmp = SPF_mech_end_data(mech);
  }
#line 441
  if ((unsigned long )data < (unsigned long )tmp) {
#line 441
    if ((int )data->dc.parm_type == 11) {
#line 444
      if (spf_request->client_ver == 2) {
#line 445
        return ((int )data->dc.ipv4);
      } else
#line 446
      if (spf_request->client_ver == 10) {
#line 447
        return ((int )data->dc.ipv6);
      }
    }
  }
#line 449
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 452
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip4___6(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in_addr ipv4 ) 
{ 
  char src_ip4_buf[16] ;
  char dst_ip4_buf[16] ;
  char mask_ip4_buf[16] ;
  struct in_addr src_ipv4 ;
  int cidr ;
  int mask ;
  uint32_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 471
  if (spf_request->client_ver != 2) {
#line 472
    return (0);
  }
  {
#line 474
  src_ipv4 = spf_request->ipv4;
#line 476
  cidr = SPF_i_mech_cidr___6(spf_request, mech);
  }
#line 477
  if (cidr == 0) {
#line 478
    cidr = 32;
  }
  {
#line 479
  mask = (int )(4294967295U << (32 - cidr));
#line 480
  tmp = htonl((uint32_t )mask);
#line 480
  mask = (int )tmp;
  }
#line 482
  if (spf_server___1->debug) {
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 483
      tmp___0 = inet_ntop(2, (void const   */* __restrict  */)(& src_ipv4.s_addr),
                          (char */* __restrict  */)(src_ip4_buf), (socklen_t )sizeof(src_ip4_buf));
      }
#line 483
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 483
        snprintf((char */* __restrict  */)(src_ip4_buf), sizeof(src_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 483
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 485
      tmp___1 = inet_ntop(2, (void const   */* __restrict  */)(& ipv4.s_addr), (char */* __restrict  */)(dst_ip4_buf),
                          (socklen_t )sizeof(dst_ip4_buf));
      }
#line 485
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 485
        snprintf((char */* __restrict  */)(dst_ip4_buf), sizeof(dst_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 487
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 487
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& mask), (char */* __restrict  */)(mask_ip4_buf),
                          (socklen_t )sizeof(mask_ip4_buf));
      }
#line 487
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
#line 487
        snprintf((char */* __restrict  */)(mask_ip4_buf), sizeof(mask_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 487
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 489
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               491, "ip_match:  %s == %s  (/%d %s):  %d", src_ip4_buf, dst_ip4_buf,
               cidr, mask_ip4_buf, (src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
    }
  }
#line 494
  return ((src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip6___6(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in6_addr ipv6 ) 
{ 
  char src_ip6_buf[46] ;
  char dst_ip6_buf[46] ;
  struct in6_addr src_ipv6 ;
  int cidr ;
  int cidr_save ;
  int mask ;
  int i ;
  int match ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 512
  if (spf_request->client_ver != 10) {
#line 513
    return (0);
  }
  {
#line 515
  src_ipv6 = spf_request->ipv6;
#line 517
  cidr = SPF_i_mech_cidr___6(spf_request, mech);
  }
#line 518
  if (cidr == 0) {
#line 519
    cidr = 128;
  }
#line 520
  cidr_save = cidr;
#line 522
  match = 1;
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if ((long )i < (long )(sizeof(ipv6.__in6_u.__u6_addr8) / sizeof(ipv6.__in6_u.__u6_addr8[0]))) {
#line 523
      if (! match) {
#line 523
        goto while_break;
      }
    } else {
#line 523
      goto while_break;
    }
#line 525
    if (cidr > 8) {
#line 526
      mask = 255;
    } else
#line 527
    if (cidr > 0) {
#line 528
      mask = (255 << (8 - cidr)) & 255;
    } else {
#line 530
      goto while_break;
    }
#line 531
    cidr -= 8;
#line 533
    match = ((int )src_ipv6.__in6_u.__u6_addr8[i] & mask) == ((int )ipv6.__in6_u.__u6_addr8[i] & mask);
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (spf_server___1->debug) {
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 537
      tmp = inet_ntop(10, (void const   */* __restrict  */)(& src_ipv6.__in6_u.__u6_addr8),
                      (char */* __restrict  */)(src_ip6_buf), (socklen_t )sizeof(src_ip6_buf));
      }
#line 537
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 537
        snprintf((char */* __restrict  */)(src_ip6_buf), sizeof(src_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 537
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 539
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 539
      tmp___0 = inet_ntop(10, (void const   */* __restrict  */)(& ipv6.__in6_u.__u6_addr8),
                          (char */* __restrict  */)(dst_ip6_buf), (socklen_t )sizeof(dst_ip6_buf));
      }
#line 539
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 539
        snprintf((char */* __restrict  */)(dst_ip6_buf), sizeof(dst_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 539
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 541
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               542, "ip_match:  %s == %s  (/%d):  %d", src_ip6_buf, dst_ip6_buf, cidr_save,
               match);
    }
  }
#line 545
  return (match);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_domain___6(SPF_server_t *spf_server___1 , char const   *hostname ,
                                  char const   *domain ) 
{ 
  char const   *hp ;
  size_t hlen ;
  size_t dlen ;
  int tmp ;
  int tmp___0 ;

  {
#line 556
  if (spf_server___1->debug) {
    {
#line 557
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               557, "%s ?=? %s", hostname, domain);
    }
  }
  {
#line 559
  hlen = strlen(hostname);
#line 560
  dlen = strlen(domain);
  }
#line 563
  if (dlen > hlen) {
#line 564
    return (0);
  }
#line 567
  if (dlen == hlen) {
    {
#line 568
    tmp = strcasecmp(hostname, domain);
    }
#line 568
    return (tmp == 0);
  }
#line 571
  hp = hostname + (hlen - dlen);
#line 573
  if ((int const   )*(hp - 1) != 46) {
#line 574
    return (0);
  }
  {
#line 576
  tmp___0 = strcasecmp(hp, domain);
  }
#line 576
  return (tmp___0 == 0);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   spf_mechtypes___6[10]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
  {      {(unsigned char)0, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)1, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)2, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)3, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )0}, 
        {(unsigned char)4, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)5, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)6, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)7, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)8, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)9, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}};
#line 94 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   *SPF_mechtype_find___6(int mech_type ) 
{ 
  size_t i ;

  {
#line 98
  i = (size_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < sizeof(spf_mechtypes___6) / sizeof(spf_mechtypes___6[0]))) {
#line 98
      goto while_break;
    }
#line 99
    if ((int const   )spf_mechtypes___6[i].mech_type == (int const   )mech_type) {
#line 100
      return (& spf_mechtypes___6[i]);
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((SPF_mechtype_t const   *)((void *)0));
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static int ( __attribute__((__warn_unused_result__)) SPF_c_ensure_capacity___6)(void **datap ,
                                                                                size_t *sizep ,
                                                                                size_t length ) 
{ 
  size_t size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 109
  size = *sizep;
#line 110
  if (length > size) {
#line 111
    size = length + length / 4UL;
  }
#line 112
  if (size > *sizep) {
    {
#line 113
    tmp___0 = realloc(*datap, size);
#line 113
    tmp = tmp___0;
    }
#line 114
    if (! tmp) {
#line 115
      return (-1);
    }
#line 117
    *datap = tmp;
#line 118
    *sizep = size;
  }
#line 120
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip6___6(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 144
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 144
  mask = (int )tmp;
  }
#line 146
  if (mask > 128) {
    {
#line 147
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (>128)");
    }
#line 147
    return (tmp___0);
  } else
#line 151
  if (mask == 0) {
    {
#line 152
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (=0)");
    }
#line 152
    return (tmp___1);
  } else
#line 156
  if (mask == 128) {
#line 157
    mask = 0;
  }
#line 160
  *maskp = (unsigned char )mask;
#line 162
  return ((SPF_errcode_t )0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip4___6(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 186
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 186
  mask = (int )tmp;
  }
#line 188
  if (mask > 32) {
    {
#line 189
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (>32)");
    }
#line 189
    return (tmp___0);
  } else
#line 193
  if (mask == 0) {
    {
#line 194
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (=0)");
    }
#line 194
    return (tmp___1);
  } else
#line 198
  if (mask == 32) {
#line 199
    mask = 0;
  }
#line 202
  *maskp = (unsigned char )mask;
#line 204
  return ((SPF_errcode_t )0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr___6(SPF_response_t *spf_response , SPF_data_cidr_t *data ,
                                          char const   *src , size_t *src_len ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 220
  memset((void *)data, 0, sizeof(SPF_data_cidr_t ));
#line 221
  data->parm_type = (unsigned char)11;
#line 227
  idx = *src_len - 1UL;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (idx > 0UL) {
      {
#line 228
      tmp = __ctype_b_loc();
      }
#line 228
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 228
        goto while_break;
      }
    } else {
#line 228
      goto while_break;
    }
#line 229
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (idx < *src_len - 1UL) {
#line 236
    if ((int const   )*(src + idx) == 47) {
#line 237
      if (idx > 0UL) {
#line 237
        if ((int const   )*(src + (idx - 1UL)) == 47) {
          {
#line 239
          err = SPF_c_parse_cidr_ip6___6(spf_response, & data->ipv6, src + idx);
          }
#line 240
          if (err) {
#line 241
            return (err);
          }
#line 243
          *src_len = idx - 1UL;
#line 244
          idx = *src_len - 1UL;
          {
#line 245
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 245
            if (idx > 0UL) {
              {
#line 245
              tmp___0 = __ctype_b_loc();
              }
#line 245
              if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 245
                goto while_break___0;
              }
            } else {
#line 245
              goto while_break___0;
            }
#line 246
            idx --;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 249
          if (idx < *src_len - 1UL) {
#line 249
            if ((int const   )*(src + idx) == 47) {
              {
#line 253
              err = SPF_c_parse_cidr_ip4___6(spf_response, & data->ipv4, src + idx);
              }
#line 254
              if (err) {
#line 255
                return (err);
              }
#line 256
              *src_len = idx;
            }
          }
        } else {
#line 237
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 261
        err = SPF_c_parse_cidr_ip4___6(spf_response, & data->ipv4, src + idx);
        }
#line 262
        if (err) {
#line 263
          return (err);
        }
#line 264
        *src_len = idx;
      }
    }
  }
#line 268
  return ((SPF_errcode_t )0);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_var___6(SPF_response_t *spf_response , SPF_data_var_t *data ,
                                         char const   *src , int is_mod ) 
{ 
  char const   *token ;
  char const   *p ;
  char c ;
  int val ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;
  SPF_errcode_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  SPF_errcode_t tmp___6 ;
  SPF_errcode_t tmp___7 ;

  {
  {
#line 280
  memset((void *)data, 0, sizeof(SPF_data_var_t ));
#line 282
  p = src;
#line 285
  c = (char )*p;
#line 286
  tmp___0 = __ctype_b_loc();
  }
#line 286
  if ((int const   )*(*tmp___0 + (int )((unsigned char )c)) & 256) {
    {
#line 288
    data->url_encode = (unsigned short)1;
#line 289
    tmp = tolower((int )c);
#line 289
    c = (char )tmp;
    }
  } else {
#line 292
    data->url_encode = (unsigned short)0;
  }
  {
#line 302
  if ((int )c == 108) {
#line 302
    goto case_108;
  }
#line 306
  if ((int )c == 115) {
#line 306
    goto case_115;
  }
#line 310
  if ((int )c == 111) {
#line 310
    goto case_111;
  }
#line 314
  if ((int )c == 100) {
#line 314
    goto case_100;
  }
#line 318
  if ((int )c == 105) {
#line 318
    goto case_105;
  }
#line 322
  if ((int )c == 99) {
#line 322
    goto case_99;
  }
#line 327
  if ((int )c == 116) {
#line 327
    goto case_116;
  }
#line 332
  if ((int )c == 112) {
#line 332
    goto case_112;
  }
#line 336
  if ((int )c == 118) {
#line 336
    goto case_118;
  }
#line 340
  if ((int )c == 104) {
#line 340
    goto case_104;
  }
#line 344
  if ((int )c == 114) {
#line 344
    goto case_114;
  }
#line 349
  goto switch_default;
  case_108: /* CIL Label */ 
#line 303
  data->parm_type = (unsigned char)0;
#line 304
  goto switch_break;
  case_115: /* CIL Label */ 
#line 307
  data->parm_type = (unsigned char)1;
#line 308
  goto switch_break;
  case_111: /* CIL Label */ 
#line 311
  data->parm_type = (unsigned char)2;
#line 312
  goto switch_break;
  case_100: /* CIL Label */ 
#line 315
  data->parm_type = (unsigned char)3;
#line 316
  goto switch_break;
  case_105: /* CIL Label */ 
#line 319
  data->parm_type = (unsigned char)4;
#line 320
  goto switch_break;
  case_99: /* CIL Label */ 
#line 323
  if (! is_mod) {
    {
#line 323
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 323
    return (tmp___1);
  }
#line 324
  data->parm_type = (unsigned char)5;
#line 325
  goto switch_break;
  case_116: /* CIL Label */ 
#line 328
  if (! is_mod) {
    {
#line 328
    tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 328
    return (tmp___2);
  }
#line 329
  data->parm_type = (unsigned char)6;
#line 330
  goto switch_break;
  case_112: /* CIL Label */ 
#line 333
  data->parm_type = (unsigned char)7;
#line 334
  goto switch_break;
  case_118: /* CIL Label */ 
#line 337
  data->parm_type = (unsigned char)8;
#line 338
  goto switch_break;
  case_104: /* CIL Label */ 
#line 341
  data->parm_type = (unsigned char)9;
#line 342
  goto switch_break;
  case_114: /* CIL Label */ 
#line 345
  if (! is_mod) {
    {
#line 345
    tmp___3 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 345
    return (tmp___3);
  }
#line 346
  data->parm_type = (unsigned char)10;
#line 347
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 350
  tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                       p, "Unknown variable \'%c\'", (int )c);
  }
#line 350
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
#line 354
  p ++;
#line 355
  token = p;
#line 358
  val = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 359
    tmp___5 = __ctype_b_loc();
    }
#line 359
    if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*p)) & 2048)) {
#line 359
      goto while_break;
    }
#line 361
    val *= 10;
#line 362
    val += (int )((int const   )*p - 48);
#line 363
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (val > 128) {
    {
#line 366
    tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                         token, "Subdomain truncation depth too large");
    }
#line 366
    return (tmp___6);
  } else
#line 365
  if (val <= 0) {
#line 365
    if ((unsigned long )p != (unsigned long )token) {
      {
#line 366
      tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                           token, "Subdomain truncation depth too large");
      }
#line 366
      return (tmp___6);
    }
  }
#line 369
  data->num_rhs = (unsigned char )val;
#line 370
  token = p;
#line 373
  if ((int const   )*p == 114) {
#line 375
    data->rev = (unsigned short)1;
#line 376
    p ++;
  } else {
#line 379
    data->rev = (unsigned short)0;
  }
#line 380
  token = p;
#line 384
  data->delim_dot = (unsigned short)0;
#line 385
  data->delim_dash = (unsigned short)0;
#line 386
  data->delim_plus = (unsigned short)0;
#line 387
  data->delim_equal = (unsigned short)0;
#line 388
  data->delim_bar = (unsigned short)0;
#line 389
  data->delim_under = (unsigned short)0;
#line 392
  if ((int const   )*p == 125) {
#line 393
    data->delim_dot = (unsigned short)1;
  }
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! ((int const   )*p != 125)) {
#line 396
      goto while_break___0;
    }
#line 398
    token = p;
    {
#line 401
    if ((int const   )*p == 46) {
#line 401
      goto case_46;
    }
#line 405
    if ((int const   )*p == 45) {
#line 405
      goto case_45;
    }
#line 409
    if ((int const   )*p == 43) {
#line 409
      goto case_43;
    }
#line 413
    if ((int const   )*p == 61) {
#line 413
      goto case_61;
    }
#line 417
    if ((int const   )*p == 124) {
#line 417
      goto case_124;
    }
#line 421
    if ((int const   )*p == 95) {
#line 421
      goto case_95;
    }
#line 425
    goto switch_default___0;
    case_46: /* CIL Label */ 
#line 402
    data->delim_dot = (unsigned short)1;
#line 403
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 406
    data->delim_dash = (unsigned short)1;
#line 407
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 410
    data->delim_plus = (unsigned short)1;
#line 411
    goto switch_break___0;
    case_61: /* CIL Label */ 
#line 414
    data->delim_equal = (unsigned short)1;
#line 415
    goto switch_break___0;
    case_124: /* CIL Label */ 
#line 418
    data->delim_bar = (unsigned short)1;
#line 419
    goto switch_break___0;
    case_95: /* CIL Label */ 
#line 422
    data->delim_under = (unsigned short)1;
#line 423
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 426
    tmp___7 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )14, (char const   *)((void *)0),
                                         p, "Invalid delimiter \'%c\'", (int const   )*p);
    }
#line 426
    return (tmp___7);
    switch_break___0: /* CIL Label */ ;
    }
#line 430
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 432
  p ++;
#line 433
  token = p;
#line 436
  return ((SPF_errcode_t )0);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_macro___6(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                           SPF_data_t *data , size_t *data_used ,
                                           size_t data_avail , char const   *src ,
                                           size_t src_len , SPF_errcode_t big_err ,
                                           int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  size_t len ;
  char *dst ;
  size_t ds_avail ;
  size_t ds_len ;
  SPF_errcode_t tmp ;
  SPF_errcode_t tmp___0 ;
  char *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  char *tmp___3 ;
  SPF_errcode_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  SPF_errcode_t tmp___8 ;
  char *tmp___9 ;
  SPF_errcode_t tmp___10 ;
  SPF_errcode_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  SPF_errcode_t tmp___15 ;
  SPF_errcode_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  SPF_errcode_t tmp___19 ;
  SPF_errcode_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
#line 522
  if (spf_server___1->debug) {
    {
#line 523
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               523, "Parsing macro starting at %s", src);
    }
  }
#line 534
  idx = (size_t )0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 538
    data->ds.parm_type = (unsigned char)12;
#line 538
    data->ds.len = (unsigned char)0;
#line 538
    data->ds.__unused0 = (unsigned char)186;
#line 538
    data->ds.__unused1 = (unsigned char)190;
#line 538
    dst = SPF_data_str(data);
#line 538
    ds_avail = data_avail - *data_used;
#line 538
    ds_len = (size_t )0;
    }
#line 538
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 541
    if (! (idx < src_len)) {
#line 541
      goto while_break___0;
    }
#line 542
    if (spf_server___1->debug > 3) {
      {
#line 543
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 543, "Current data is at %p", data);
      }
    }
    {
#line 546
    len = strcspn(src + idx, " %");
    }
#line 547
    if (len > 0UL) {
#line 549
      if (idx + len > src_len) {
#line 550
        len = src_len - idx;
      }
#line 551
      if (spf_server___1->debug > 3) {
        {
#line 552
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                   554, "Adding string literal (%lu): \'%*.*s\'", len, (int )len,
                   (int )len, src + idx);
        }
      }
      {
#line 556
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 556
        if (ds_len + len > ds_avail) {
          {
#line 556
          tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                           src, "String literal fragment too long (%d chars, %d max)",
                                           ds_len, ds_avail);
          }
#line 556
          return (tmp);
        }
#line 556
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 557
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(src + idx),
             len);
#line 558
      ds_len += len;
#line 559
      dst += len;
#line 560
      idx += len;
      }
    }
#line 568
    if (idx == src_len) {
#line 569
      goto while_break___0;
    }
#line 576
    idx ++;
    {
#line 578
    if ((int const   )*(src + idx) == 37) {
#line 578
      goto case_37;
    }
#line 587
    if ((int const   )*(src + idx) == 95) {
#line 587
      goto case_95;
    }
#line 596
    if ((int const   )*(src + idx) == 45) {
#line 596
      goto case_45;
    }
#line 617
    if ((int const   )*(src + idx) == 123) {
#line 617
      goto case_123;
    }
#line 605
    goto switch_default;
    case_37: /* CIL Label */ 
#line 579
    if (spf_server___1->debug > 3) {
      {
#line 580
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 580, "Adding literal %%");
      }
    }
    {
#line 581
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 581
      if (ds_len + 1UL > ds_avail) {
        {
#line 581
        tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 581
        return (tmp___0);
      }
#line 581
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 582
    tmp___1 = dst;
#line 582
    dst ++;
#line 582
    *tmp___1 = (char )'%';
#line 583
    ds_len ++;
#line 584
    idx ++;
#line 585
    goto switch_break;
    case_95: /* CIL Label */ 
#line 588
    if (spf_server___1->debug > 3) {
      {
#line 589
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 589, "Adding literal space");
      }
    }
    {
#line 590
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 590
      if (ds_len + 1UL > ds_avail) {
        {
#line 590
        tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 590
        return (tmp___2);
      }
#line 590
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 591
    tmp___3 = dst;
#line 591
    dst ++;
#line 591
    *tmp___3 = (char )' ';
#line 592
    ds_len ++;
#line 593
    idx ++;
#line 594
    goto switch_break;
    case_45: /* CIL Label */ 
#line 597
    if (spf_server___1->debug > 3) {
      {
#line 598
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 598, "Adding escaped space");
      }
    }
    {
#line 599
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 599
      if (ds_len + 3UL > ds_avail) {
        {
#line 599
        tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 599
        return (tmp___4);
      }
#line 599
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 600
    tmp___5 = dst;
#line 600
    dst ++;
#line 600
    *tmp___5 = (char )'%';
#line 600
    tmp___6 = dst;
#line 600
    dst ++;
#line 600
    *tmp___6 = (char )'2';
#line 600
    tmp___7 = dst;
#line 600
    dst ++;
#line 600
    *tmp___7 = (char )'0';
#line 601
    ds_len += 3UL;
#line 602
    idx ++;
#line 603
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 606
    if (spf_server___1->debug > 3) {
      {
#line 607
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 608, "Adding illegal %%-follower \'%c\' at %d", (int const   )*(src + idx),
                 idx);
      }
    }
    {
#line 612
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 612
      if (ds_len + 1UL > ds_avail) {
        {
#line 612
        tmp___8 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 612
        return (tmp___8);
      }
#line 612
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 613
    tmp___9 = dst;
#line 613
    dst ++;
#line 613
    *tmp___9 = (char )'%';
#line 614
    ds_len ++;
#line 615
    goto switch_break;
    case_123: /* CIL Label */ 
    {
#line 618
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 618
      if (ds_len > 0UL) {
#line 618
        if (ds_len > 255UL) {
          {
#line 618
          tmp___10 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15,
                                                (char const   *)((void *)0), src,
                                                "String literal too long (%d chars, %d max)",
                                                ds_len, 255);
          }
#line 618
          return (tmp___10);
        }
#line 618
        data->ds.len = (unsigned char )ds_len;
#line 618
        len = sizeof(*data) + ds_len;
        {
#line 618
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 618
          tmp___12 = _align_sz(len);
          }
#line 618
          if (*data_used + tmp___12 > data_avail) {
            {
#line 618
            tmp___11 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                  src, "SPF domainspec too long (%d chars, %d max)",
                                                  *data_used + len, data_avail);
            }
#line 618
            return (tmp___11);
          }
          {
#line 618
          tmp___13 = _align_sz(len);
#line 618
          *data_used += tmp___13;
          }
#line 618
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 618
        data = SPF_data_next(data);
#line 618
        ds_len = (size_t )0;
        }
      }
#line 618
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 619
    if (spf_server___1->debug > 3) {
      {
#line 620
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 620, "Adding macro, data is at %p", data);
      }
    }
    {
#line 623
    idx ++;
#line 624
    err = SPF_c_parse_var___6(spf_response, & data->dv, src + idx, is_mod);
    }
#line 625
    if ((unsigned int )err != 0U) {
#line 626
      return (err);
    }
    {
#line 627
    tmp___14 = strcspn(src + idx, "} ");
#line 627
    idx += tmp___14;
    }
#line 628
    if ((int const   )*(src + idx) == 125) {
#line 629
      idx ++;
    } else
#line 630
    if ((int const   )*(src + idx) == 32) {
      {
#line 631
      tmp___15 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, src,
                                            src + idx, "Unterminated variable?");
      }
#line 631
      return (tmp___15);
    }
    {
#line 637
    len = SPF_data_len(data);
    }
    {
#line 638
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 638
      tmp___17 = _align_sz(len);
      }
#line 638
      if (*data_used + tmp___17 > data_avail) {
        {
#line 638
        tmp___16 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                              src, "SPF domainspec too long (%d chars, %d max)",
                                              *data_used + len, data_avail);
        }
#line 638
        return (tmp___16);
      }
      {
#line 638
      tmp___18 = _align_sz(len);
#line 638
      *data_used += tmp___18;
      }
#line 638
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 639
    data = SPF_data_next(data);
    }
#line 640
    if (spf_server___1->debug > 3) {
      {
#line 641
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 641, "Next data is at %p", data);
      }
    }
    {
#line 643
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 643
      data->ds.parm_type = (unsigned char)12;
#line 643
      data->ds.len = (unsigned char)0;
#line 643
      data->ds.__unused0 = (unsigned char)186;
#line 643
      data->ds.__unused1 = (unsigned char)190;
#line 643
      dst = SPF_data_str(data);
#line 643
      ds_avail = data_avail - *data_used;
#line 643
      ds_len = (size_t )0;
      }
#line 643
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 649
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 649
    if (ds_len > 0UL) {
#line 649
      if (ds_len > 255UL) {
        {
#line 649
        tmp___19 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                              src, "String literal too long (%d chars, %d max)",
                                              ds_len, 255);
        }
#line 649
        return (tmp___19);
      }
#line 649
      data->ds.len = (unsigned char )ds_len;
#line 649
      len = sizeof(*data) + ds_len;
      {
#line 649
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 649
        tmp___21 = _align_sz(len);
        }
#line 649
        if (*data_used + tmp___21 > data_avail) {
          {
#line 649
          tmp___20 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                src, "SPF domainspec too long (%d chars, %d max)",
                                                *data_used + len, data_avail);
          }
#line 649
          return (tmp___20);
        }
        {
#line 649
        tmp___22 = _align_sz(len);
#line 649
        *data_used += tmp___22;
        }
#line 649
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 649
      data = SPF_data_next(data);
#line 649
      ds_len = (size_t )0;
      }
    }
#line 649
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 651
  return ((SPF_errcode_t )0);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_domainspec___6(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                                SPF_data_t *data , size_t *data_used ,
                                                size_t data_avail , char const   *src ,
                                                size_t src_len , SPF_errcode_t big_err ,
                                                SPF_cidr_t cidr_ok , int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  SPF_errcode_t tmp___6 ;

  {
#line 682
  if (spf_server___1->debug) {
#line 683
    if ((unsigned int )cidr_ok == 1U) {
#line 683
      tmp___1 = "optional";
    } else {
#line 683
      if ((unsigned int )cidr_ok == 2U) {
#line 683
        tmp___0 = "only";
      } else {
#line 683
        if ((unsigned int )cidr_ok == 0U) {
#line 683
          tmp = "forbidden";
        } else {
#line 683
          tmp = "ERROR!";
        }
#line 683
        tmp___0 = tmp;
      }
#line 683
      tmp___1 = tmp___0;
    }
    {
#line 683
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               689, "Parsing domainspec starting at %s, cidr is %s", src, tmp___1);
    }
  }
#line 694
  if ((unsigned int )cidr_ok == 1U) {
#line 694
    goto _L___0;
  } else
#line 694
  if ((unsigned int )cidr_ok == 2U) {
    _L___0: /* CIL Label */ 
    {
#line 695
    err = SPF_c_parse_cidr___6(spf_response, & data->dc, src, & src_len);
    }
#line 696
    if ((unsigned int )err != 0U) {
#line 697
      return (err);
    }
#line 698
    if ((int )data->dc.ipv4 != 0) {
#line 698
      goto _L;
    } else
#line 698
    if ((int )data->dc.ipv6 != 0) {
      _L: /* CIL Label */ 
      {
#line 699
      len = SPF_data_len(data);
      }
      {
#line 700
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 700
        tmp___3 = _align_sz(len);
        }
#line 700
        if (*data_used + tmp___3 > data_avail) {
          {
#line 700
          tmp___2 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                               src, "SPF domainspec too long (%d chars, %d max)",
                                               *data_used + len, data_avail);
          }
#line 700
          return (tmp___2);
        }
        {
#line 700
        tmp___4 = _align_sz(len);
#line 700
        *data_used += tmp___4;
        }
#line 700
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 701
      data = SPF_data_next(data);
      }
    }
#line 704
    if ((unsigned int )cidr_ok == 2U) {
#line 704
      if (src_len > 0UL) {
        {
#line 708
        tmp___5 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                             src, "Invalid CIDR after mechanism");
        }
#line 708
        return (tmp___5);
      }
    }
  }
  {
#line 715
  tmp___6 = SPF_c_parse_macro___6(spf_server___1, spf_response, data, data_used, data_avail,
                                  src, src_len, big_err, is_mod);
  }
#line 715
  return (tmp___6);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip4___6(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  SPF_errcode_t err ;
  unsigned char mask ;
  struct in_addr *addr ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 739
  start ++;
#line 740
  len = strcspn(start, " ");
#line 741
  end = start + len;
#line 742
  p = end - 1;
#line 744
  mask = (unsigned char)0;
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 745
    tmp = __ctype_b_loc();
    }
#line 745
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 745
      goto while_break;
    }
#line 746
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 747
    if ((int const   )*p == 47) {
      {
#line 748
      err = SPF_c_parse_cidr_ip4___6(spf_response, & mask, p);
      }
#line 749
      if (err) {
#line 750
        return (err);
      }
#line 751
      end = p;
    }
  }
#line 753
  mech->mech_len = (unsigned short )mask;
#line 755
  len = (size_t )(end - start);
#line 756
  if (len > sizeof(buf) - 1UL) {
#line 757
    return ((SPF_errcode_t )19);
  }
  {
#line 759
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 760
  buf[len] = (char )'\000';
#line 761
  addr = SPF_mech_ip4_data(mech);
#line 762
  tmp___0 = inet_pton(2, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
#line 762
  err = (SPF_errcode_t )tmp___0;
  }
#line 763
  if ((unsigned int )err <= 0U) {
    {
#line 764
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )19, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 764
    return (tmp___1);
  }
#line 767
  return ((SPF_errcode_t )0);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip6___6(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  int err ;
  unsigned char mask ;
  struct in6_addr *addr ;
  unsigned short const   **tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 788
  start ++;
#line 789
  len = strcspn(start, " ");
#line 790
  end = start + len;
#line 791
  p = end - 1;
#line 793
  mask = (unsigned char)0;
  }
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 794
    tmp = __ctype_b_loc();
    }
#line 794
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 794
      goto while_break;
    }
#line 795
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 796
    if ((int const   )*p == 47) {
      {
#line 797
      tmp___0 = SPF_c_parse_cidr_ip6___6(spf_response, & mask, p);
#line 797
      err = (int )tmp___0;
      }
#line 798
      if (err) {
#line 799
        return ((SPF_errcode_t )err);
      }
#line 800
      end = p;
    }
  }
#line 802
  mech->mech_len = (unsigned short )mask;
#line 804
  len = (size_t )(end - start);
#line 805
  if (len > sizeof(buf) - 1UL) {
#line 806
    return ((SPF_errcode_t )20);
  }
  {
#line 808
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 809
  buf[len] = (char )'\000';
#line 810
  addr = SPF_mech_ip6_data(mech);
#line 811
  err = inet_pton(10, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
  }
#line 812
  if (err <= 0) {
    {
#line 813
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )20, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 813
    return (tmp___1);
  }
#line 816
  return ((SPF_errcode_t )0);
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mech_add___6)(SPF_server_t *spf_server___1 ,
                                                                                   SPF_record_t *spf_record ,
                                                                                   SPF_response_t *spf_response ,
                                                                                   SPF_mechtype_t const   *mechtype ,
                                                                                   int prefix ,
                                                                                   char const   **mech_value ) 
{ 
  union __anonunion_u_60___6 u ;
  SPF_mech_t *spf_mechanism ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  SPF_errcode_t tmp ;
  int tmp___0 ;

  {
  {
#line 834
  spf_mechanism = (SPF_mech_t *)(u.buf);
#line 842
  memset((void *)(u.buf), 'B', sizeof(u.buf));
#line 843
  memset((void *)spf_mechanism, 0, sizeof(SPF_mech_t ));
  }
#line 845
  if (spf_server___1->debug) {
    {
#line 846
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               847, "SPF_c_mech_add: type=%d, value=%s", (int const   )mechtype->mech_type,
               *mech_value);
    }
  }
#line 849
  spf_mechanism->prefix_type = (unsigned char )prefix;
#line 850
  spf_mechanism->mech_type = (unsigned char )mechtype->mech_type;
#line 851
  spf_mechanism->mech_len = (unsigned short)0;
#line 853
  len = sizeof(SPF_mech_t );
#line 855
  if (spf_record->mech_len + len > 511UL) {
#line 856
    return ((SPF_errcode_t )16);
  }
  {
#line 858
  data = SPF_mech_data(spf_mechanism);
#line 859
  data_len = (size_t )0;
#line 861
  src_len = strcspn(*mech_value, " ");
  }
  {
#line 865
  if ((int const   )mechtype->mech_type == 5) {
#line 865
    goto case_5;
  }
#line 878
  if ((int const   )mechtype->mech_type == 6) {
#line 878
    goto case_6;
  }
#line 891
  goto switch_default;
  case_5: /* CIL Label */ 
#line 866
  if ((int const   )*(*mech_value) == 58) {
    {
#line 867
    err = SPF_c_parse_ip4___6(spf_response, spf_mechanism, *mech_value);
#line 868
    data_len = sizeof(struct in_addr );
    }
  } else {
    {
#line 871
    err = (SPF_errcode_t )9;
#line 872
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 876
  goto switch_break;
  case_6: /* CIL Label */ 
#line 879
  if ((int const   )*(*mech_value) == 58) {
    {
#line 880
    err = SPF_c_parse_ip6___6(spf_response, spf_mechanism, *mech_value);
#line 881
    data_len = sizeof(struct in6_addr );
    }
  } else {
    {
#line 884
    err = (SPF_errcode_t )9;
#line 885
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 889
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 892
  if ((int const   )*(*mech_value) == 58) {
#line 892
    goto _L___0;
  } else
#line 892
  if ((int const   )*(*mech_value) == 61) {
    _L___0: /* CIL Label */ 
#line 893
    if ((unsigned int const   )mechtype->has_domainspec == 0U) {
      {
#line 894
      err = (SPF_errcode_t )7;
#line 895
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a value.");
      }
    } else {
      {
#line 900
      (*mech_value) ++;
#line 900
      src_len --;
#line 901
      err = SPF_c_parse_domainspec___6(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )mechtype->has_cidr, 0);
      }
    }
  } else
#line 909
  if ((int const   )*(*mech_value) == 47) {
#line 910
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 911
      err = (SPF_errcode_t )9;
#line 912
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else
#line 916
    if ((unsigned int const   )mechtype->has_cidr == 0U) {
      {
#line 917
      err = (SPF_errcode_t )8;
#line 918
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a CIDR.");
      }
    } else {
      {
#line 923
      err = SPF_c_parse_domainspec___6(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )2, 0);
      }
    }
  } else
#line 931
  if ((int const   )*(*mech_value) == 32) {
#line 931
    goto _L;
  } else
#line 931
  if ((int const   )*(*mech_value) == 0) {
    _L: /* CIL Label */ 
#line 932
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 933
      err = (SPF_errcode_t )9;
#line 934
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else {
#line 939
      err = (SPF_errcode_t )0;
    }
  } else {
    {
#line 943
    err = (SPF_errcode_t )3;
#line 944
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Unknown character \'%c\' after mechanism.", (int const   )*(*mech_value));
    }
  }
#line 951
  spf_mechanism->mech_len = (unsigned short )data_len;
#line 952
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 955
  len += data_len;
#line 958
  if ((unsigned int )err == 0U) {
#line 959
    if (mechtype->is_dns_mech) {
#line 960
      spf_record->num_dns_mech = (unsigned char )((int )spf_record->num_dns_mech + 1);
    }
    {
#line 961
    tmp___0 = SPF_c_ensure_capacity___6((void **)(& spf_record->mech_first), & spf_record->mech_size,
                                        spf_record->mech_len + len);
    }
#line 961
    if (tmp___0 < 0) {
      {
#line 964
      tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                       (char const   *)((void *)0), "Failed to allocate memory for mechanism");
      }
#line 964
      return (tmp);
    }
    {
#line 968
    memcpy((void */* __restrict  */)((char *)spf_record->mech_first + spf_record->mech_len),
           (void const   */* __restrict  */)spf_mechanism, len);
#line 971
    spf_record->mech_len += len;
#line 972
    spf_record->num_mech = (unsigned char )((int )spf_record->num_mech + 1);
    }
  }
#line 975
  *mech_value += src_len;
#line 977
  return (err);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mod_add___6)(SPF_server_t *spf_server___1 ,
                                                                                  SPF_record_t *spf_record ,
                                                                                  SPF_response_t *spf_response ,
                                                                                  char const   *mod_name ,
                                                                                  size_t name_len ,
                                                                                  char const   **mod_value ) 
{ 
  union __anonunion_u_61___6 u ;
  SPF_mod_t *spf_modifier ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  char *tmp ;
  SPF_errcode_t tmp___0 ;
  int tmp___1 ;

  {
#line 992
  spf_modifier = (SPF_mod_t *)(u.buf);
#line 1000
  if (spf_server___1->debug) {
    {
#line 1001
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               1002, "Adding modifier name=%lu@%s, value=%s", name_len, mod_name,
               *mod_value);
    }
  }
  {
#line 1004
  memset((void *)(u.buf), 'A', sizeof(u.buf));
#line 1005
  memset((void *)spf_modifier, 0, sizeof(SPF_mod_t ));
  }
#line 1007
  if (name_len > 511UL) {
#line 1008
    return ((SPF_errcode_t )17);
  }
  {
#line 1010
  spf_modifier->name_len = (unsigned short )name_len;
#line 1011
  spf_modifier->data_len = (unsigned short)0;
#line 1014
  len = _align_sz(sizeof(SPF_mod_t ) + name_len);
  }
#line 1016
  if (spf_record->mod_len + len > 511UL) {
#line 1017
    return ((SPF_errcode_t )17);
  }
  {
#line 1019
  tmp = SPF_mod_name(spf_modifier);
#line 1019
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)mod_name,
         name_len);
#line 1021
  data = SPF_mod_data(spf_modifier);
#line 1022
  data_len = (size_t )0;
#line 1024
  src_len = strcspn(*mod_value, " ");
#line 1026
  err = SPF_c_parse_macro___6(spf_server___1, spf_response, data, & data_len, (size_t )511,
                              *mod_value, src_len, (SPF_errcode_t )17, 1);
#line 1032
  spf_modifier->data_len = (unsigned short )data_len;
#line 1033
  len += data_len;
  }
#line 1036
  if ((unsigned int )err == 0U) {
    {
#line 1037
    tmp___1 = SPF_c_ensure_capacity___6((void **)(& spf_record->mod_first), & spf_record->mod_size,
                                        spf_record->mod_len + len);
    }
#line 1037
    if (tmp___1 < 0) {
      {
#line 1040
      tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                           (char const   *)((void *)0), "Failed to allocate memory for modifier");
      }
#line 1040
      return (tmp___0);
    }
    {
#line 1044
    memcpy((void */* __restrict  */)((char *)spf_record->mod_first + spf_record->mod_len),
           (void const   */* __restrict  */)spf_modifier, len);
#line 1047
    spf_record->mod_len += len;
#line 1048
    spf_record->num_mod = (unsigned char )((int )spf_record->num_mod + 1);
    }
  }
#line 1051
  return (err);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static void SPF_record_lint___6(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                SPF_record_t *spf_record ) 
{ 
  SPF_data_t *d ;
  SPF_data_t *data_end ;
  char *s ;
  char *s_end ;
  int found_non_ip ;
  int found_valid_tld ;
  SPF_mech_t *mech ;
  SPF_data_t *data ;
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1075
  mech = spf_record->mech_first;
#line 1076
  i = 0;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (i < (int )spf_record->num_mech)) {
#line 1076
      goto while_break;
    }
#line 1081
    if ((int )mech->mech_type == 8) {
#line 1081
      goto _L;
    } else
#line 1081
    if ((int )mech->mech_type == 9) {
      _L: /* CIL Label */ 
#line 1081
      if (i != (int )spf_record->num_mech - 1) {
        {
#line 1085
        SPF_response_add_warn(spf_response, (SPF_errcode_t )29, "Mechanisms found after the \"all:\" mechanism will be ignored.");
        }
      }
    }
#line 1098
    if ((int )mech->mech_type == 5) {
#line 1100
      goto __Cont;
    } else
#line 1098
    if ((int )mech->mech_type == 6) {
#line 1100
      goto __Cont;
    }
    {
#line 1102
    data = SPF_mech_data(mech);
#line 1103
    data_end = SPF_mech_end_data(mech);
    }
#line 1104
    if ((unsigned long )data == (unsigned long )data_end) {
#line 1105
      goto __Cont;
    }
#line 1107
    if ((int )data->dc.parm_type == 11) {
      {
#line 1109
      data = SPF_data_next(data);
      }
#line 1110
      if ((unsigned long )data == (unsigned long )data_end) {
#line 1111
        goto __Cont;
      }
    }
#line 1115
    found_valid_tld = 0;
#line 1116
    found_non_ip = 0;
#line 1118
    d = data;
    {
#line 1118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1118
      if (! ((unsigned long )d < (unsigned long )data_end)) {
#line 1118
        goto while_break___0;
      }
      {
#line 1122
      if ((int )d->dv.parm_type == 11) {
#line 1122
        goto case_11;
      }
#line 1128
      if ((int )d->dv.parm_type == 0) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 5) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 4) {
#line 1128
        goto case_0;
      }
#line 1132
      if ((int )d->dv.parm_type == 12) {
#line 1132
        goto case_12;
      }
#line 1148
      goto switch_default;
      case_11: /* CIL Label */ 
      {
#line 1123
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1123, "%s", "Multiple CIDR parameters found");
      }
#line 1124
      goto switch_break;
      case_0: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 1129
      found_valid_tld = 0;
#line 1130
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 1133
      found_valid_tld = 0;
#line 1135
      s = SPF_data_str(d);
#line 1136
      s_end = s + (int )d->ds.len;
      }
      {
#line 1137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1137
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 1137
          goto while_break___1;
        }
        {
#line 1138
        tmp = __ctype_b_loc();
        }
#line 1138
        if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 2048)) {
#line 1138
          if ((int )*s != 46) {
#line 1138
            if ((int )*s != 58) {
#line 1139
              found_non_ip = 1;
            }
          }
        }
#line 1141
        if ((int )*s == 46) {
#line 1142
          found_valid_tld = 1;
        } else {
          {
#line 1143
          tmp___0 = __ctype_b_loc();
          }
#line 1143
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 1024)) {
#line 1144
            found_valid_tld = 0;
          }
        }
#line 1137
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1146
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1149
      found_non_ip = 1;
#line 1150
      found_valid_tld = 1;
#line 1152
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1118
      d = SPF_data_next(d);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1156
    if (! found_valid_tld) {
#line 1156
      goto _L___0;
    } else
#line 1156
    if (! found_non_ip) {
      _L___0: /* CIL Label */ 
#line 1157
      if (! found_non_ip) {
        {
#line 1158
        SPF_response_add_warn(spf_response, (SPF_errcode_t )27, "Invalid hostname (an IP address?)");
        }
      } else
#line 1160
      if (! found_valid_tld) {
        {
#line 1161
        SPF_response_add_warn(spf_response, (SPF_errcode_t )28, "Hostname has a missing or invalid TLD");
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 1076
    i ++;
#line 1076
    mech = SPF_mech_next(mech);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1168
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv4___6[8]  = 
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
  {      (char const   )'i',      (char const   )'n',      (char const   )'-',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv6___6[4]  = {      (char const   )'i',      (char const   )'p',      (char const   )'6',      (char const   )'\000'};
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c"
static SPF_errcode_t SPF_record_stringify_data___6(SPF_data_t *data , SPF_data_t *data_end ,
                                                   char **p_p , char *p_end , int is_mod ,
                                                   int cidr_ok , int debug ) 
{ 
  char *p ;
  size_t len ;
  SPF_data_t *cidr_data ;
  char *s ;
  char *tmp ;
  char *s_end ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 48
  p = *p_p;
#line 54
  if (debug) {
    {
#line 55
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
               55, " string data: Building");
    }
  }
#line 57
  if (p_end - p <= 0L) {
#line 58
    return ((SPF_errcode_t )10);
  }
#line 60
  cidr_data = (SPF_data_t *)((void *)0);
#line 61
  if ((unsigned long )data < (unsigned long )data_end) {
#line 61
    if ((int )data->dc.parm_type == 11) {
#line 63
      if (debug) {
        {
#line 64
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   64, " string data: Found a CIDR at %p", data);
        }
      }
#line 65
      if (! cidr_ok) {
#line 66
        return ((SPF_errcode_t )10);
      }
      {
#line 68
      cidr_data = data;
#line 69
      data = SPF_data_next(data);
      }
    }
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )data < (unsigned long )data_end)) {
#line 73
      goto while_break;
    }
#line 75
    if (debug) {
      {
#line 76
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 77, " string data: Handling data type %d at %p", (int )data->ds.parm_type,
                 data);
      }
    }
#line 78
    if ((int )data->ds.parm_type == 12) {
      {
#line 80
      tmp = SPF_data_str(data);
#line 80
      s = tmp;
#line 81
      s_end = s + (int )data->ds.len;
      }
#line 82
      if (debug) {
        {
#line 83
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   84, " string data: String is [%d] \'%*.*s\'", (int )data->ds.len,
                   (int )data->ds.len, (int )data->ds.len, s);
        }
      }
#line 86
      if (p_end - (p + (int )data->ds.len) <= 0L) {
#line 87
        return ((SPF_errcode_t )10);
      }
      {
#line 89
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 89
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 89
          goto while_break___0;
        }
#line 90
        if ((int )*s == 32) {
#line 91
          tmp___0 = p;
#line 91
          p ++;
#line 91
          *tmp___0 = (char )'%';
#line 92
          tmp___1 = p;
#line 92
          p ++;
#line 92
          *tmp___1 = (char )'_';
#line 93
          s ++;
        } else
#line 95
        if ((int )*s == 37) {
#line 96
          tmp___2 = p;
#line 96
          p ++;
#line 96
          *tmp___2 = (char )'%';
#line 97
          s ++;
#line 98
          if ((int )*(s + 0) == 50) {
#line 98
            if ((int )*(s + 1) == 48) {
#line 99
              tmp___3 = p;
#line 99
              p ++;
#line 99
              *tmp___3 = (char )'-';
#line 100
              s += 2;
            } else {
#line 103
              tmp___4 = p;
#line 103
              p ++;
#line 103
              *tmp___4 = (char )'%';
            }
          } else {
#line 103
            tmp___4 = p;
#line 103
            p ++;
#line 103
            *tmp___4 = (char )'%';
          }
        } else {
#line 108
          tmp___5 = p;
#line 108
          p ++;
#line 108
          tmp___6 = s;
#line 108
          s ++;
#line 108
          *tmp___5 = *tmp___6;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 112
      if (p_end - p <= 0L) {
#line 113
        return ((SPF_errcode_t )10);
      }
    } else
#line 115
    if ((int )data->dc.parm_type == 11) {
#line 117
      return ((SPF_errcode_t )8);
    } else {
      {
#line 120
      tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%%{");
#line 120
      len = (size_t )tmp___7;
#line 121
      p += len;
      }
#line 122
      if (p_end - p <= 0L) {
#line 122
        return ((SPF_errcode_t )10);
      }
#line 125
      if (p_end - p <= 1L) {
#line 125
        return ((SPF_errcode_t )10);
      }
      {
#line 128
      if ((int )data->dv.parm_type == 0) {
#line 128
        goto case_0;
      }
#line 132
      if ((int )data->dv.parm_type == 1) {
#line 132
        goto case_1;
      }
#line 136
      if ((int )data->dv.parm_type == 2) {
#line 136
        goto case_2;
      }
#line 140
      if ((int )data->dv.parm_type == 3) {
#line 140
        goto case_3;
      }
#line 144
      if ((int )data->dv.parm_type == 4) {
#line 144
        goto case_4;
      }
#line 148
      if ((int )data->dv.parm_type == 5) {
#line 148
        goto case_5;
      }
#line 152
      if ((int )data->dv.parm_type == 6) {
#line 152
        goto case_6;
      }
#line 158
      if ((int )data->dv.parm_type == 7) {
#line 158
        goto case_7;
      }
#line 162
      if ((int )data->dv.parm_type == 8) {
#line 162
        goto case_8;
      }
#line 166
      if ((int )data->dv.parm_type == 9) {
#line 166
        goto case_9;
      }
#line 170
      if ((int )data->dv.parm_type == 10) {
#line 170
        goto case_10;
      }
#line 174
      goto switch_default;
      case_0: /* CIL Label */ 
#line 129
      *p = (char )'l';
#line 130
      goto switch_break;
      case_1: /* CIL Label */ 
#line 133
      *p = (char )'s';
#line 134
      goto switch_break;
      case_2: /* CIL Label */ 
#line 137
      *p = (char )'o';
#line 138
      goto switch_break;
      case_3: /* CIL Label */ 
#line 141
      *p = (char )'d';
#line 142
      goto switch_break;
      case_4: /* CIL Label */ 
#line 145
      *p = (char )'i';
#line 146
      goto switch_break;
      case_5: /* CIL Label */ 
#line 149
      *p = (char )'c';
#line 150
      goto switch_break;
      case_6: /* CIL Label */ 
#line 153
      if (! is_mod) {
#line 154
        return ((SPF_errcode_t )12);
      }
#line 155
      *p = (char )'t';
#line 156
      goto switch_break;
      case_7: /* CIL Label */ 
#line 159
      *p = (char )'p';
#line 160
      goto switch_break;
      case_8: /* CIL Label */ 
#line 163
      *p = (char )'v';
#line 164
      goto switch_break;
      case_9: /* CIL Label */ 
#line 167
      *p = (char )'h';
#line 168
      goto switch_break;
      case_10: /* CIL Label */ 
#line 171
      *p = (char )'r';
#line 172
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 175
      return ((SPF_errcode_t )12);
#line 176
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 178
      if (data->dv.url_encode) {
        {
#line 179
        tmp___8 = toupper((int )*p);
#line 179
        *p = (char )tmp___8;
        }
      }
#line 180
      p ++;
#line 181
      if (p_end - p <= 0L) {
#line 181
        return ((SPF_errcode_t )10);
      }
#line 184
      if (data->dv.num_rhs) {
        {
#line 186
        tmp___9 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%d",
                           (int )data->dv.num_rhs);
#line 186
        len = (size_t )tmp___9;
#line 187
        p += len;
        }
#line 188
        if (p_end - p <= 0L) {
#line 188
          return ((SPF_errcode_t )10);
        }
      }
#line 192
      if (p_end - p <= 8L) {
#line 192
        return ((SPF_errcode_t )10);
      }
#line 193
      if (data->dv.rev) {
#line 194
        tmp___10 = p;
#line 194
        p ++;
#line 194
        *tmp___10 = (char )'r';
      }
#line 196
      if (data->dv.delim_dot) {
#line 196
        if (data->dv.delim_dash) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_plus) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_equal) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_bar) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_under) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        }
      }
#line 205
      if (data->dv.delim_dash) {
#line 206
        tmp___12 = p;
#line 206
        p ++;
#line 206
        *tmp___12 = (char )'-';
      }
#line 207
      if (data->dv.delim_plus) {
#line 208
        tmp___13 = p;
#line 208
        p ++;
#line 208
        *tmp___13 = (char )'+';
      }
#line 209
      if (data->dv.delim_equal) {
#line 210
        tmp___14 = p;
#line 210
        p ++;
#line 210
        *tmp___14 = (char )'=';
      }
#line 211
      if (data->dv.delim_bar) {
#line 212
        tmp___15 = p;
#line 212
        p ++;
#line 212
        *tmp___15 = (char )'|';
      }
#line 213
      if (data->dv.delim_under) {
#line 214
        tmp___16 = p;
#line 214
        p ++;
#line 214
        *tmp___16 = (char )'_';
      }
#line 216
      tmp___17 = p;
#line 216
      p ++;
#line 216
      *tmp___17 = (char )'}';
#line 217
      if (p_end - p <= 0L) {
#line 217
        return ((SPF_errcode_t )10);
      }
    }
    {
#line 73
    data = SPF_data_next(data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (cidr_data) {
#line 224
    if (cidr_data->dc.ipv4) {
      {
#line 226
      tmp___18 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"/%d",
                          (int )cidr_data->dc.ipv4);
#line 226
      len = (size_t )tmp___18;
#line 227
      p += len;
      }
#line 228
      if (p_end - p <= 0L) {
#line 228
        return ((SPF_errcode_t )10);
      }
    }
#line 231
    if (cidr_data->dc.ipv6) {
      {
#line 233
      tmp___19 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"//%d",
                          (int )cidr_data->dc.ipv6);
#line 233
      len = (size_t )tmp___19;
#line 234
      p += len;
      }
#line 235
      if (p_end - p <= 0L) {
#line 235
        return ((SPF_errcode_t )10);
      }
    }
  }
#line 239
  *p_p = p;
#line 240
  return ((SPF_errcode_t )0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_pre___6(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                  ns_type rr_type , int should_cache ) 
{ 
  char const   *tmp ;

  {
#line 51
  if (spf_dns_server->debug) {
    {
#line 52
    tmp = SPF_strrrtype(rr_type);
#line 52
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               54, "DNS[%s] lookup: %s %s (%d)", spf_dns_server->name, domain, tmp,
               (unsigned int )rr_type);
    }
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_post___6(SPF_dns_server_t *spf_dns_server , SPF_dns_rr_t *spfrr ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 61
  if (spf_dns_server->debug) {
    {
#line 66
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               66, "DNS[%s] found record", spf_dns_server->name);
#line 67
    tmp = SPF_strrrtype(spfrr->rr_type);
#line 67
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               69, "    DOMAIN: %s  TYPE: %s (%d)", spfrr->domain, tmp, (unsigned int )spfrr->rr_type);
    }
#line 70
    if (spfrr->source) {
#line 70
      if ((spfrr->source)->name) {
#line 70
        tmp___0 = (spfrr->source)->name;
      } else {
#line 70
        tmp___0 = "(unnamed source)";
      }
#line 70
      tmp___1 = tmp___0;
    } else {
#line 70
      tmp___1 = "(null source)";
    }
    {
#line 70
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               76, "    TTL: %ld  RR found: %d  herrno: %d  source: %s", spfrr->ttl,
               spfrr->num_rr, spfrr->herrno, tmp___1);
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! (i < spfrr->num_rr)) {
#line 77
        goto while_break;
      }
      {
#line 79
      if ((unsigned int )spfrr->rr_type == 1U) {
#line 79
        goto case_1;
      }
#line 85
      if ((unsigned int )spfrr->rr_type == 12U) {
#line 85
        goto case_12;
      }
#line 89
      if ((unsigned int )spfrr->rr_type == 15U) {
#line 89
        goto case_15;
      }
#line 93
      if ((unsigned int )spfrr->rr_type == 16U) {
#line 93
        goto case_16;
      }
#line 97
      if ((unsigned int )spfrr->rr_type == 99U) {
#line 97
        goto case_99;
      }
#line 101
      if ((unsigned int )spfrr->rr_type == 28U) {
#line 101
        goto case_28;
      }
#line 107
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 80
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->a),
                          (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
#line 80
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 82, "    - A: %s", tmp___2);
      }
#line 83
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 86
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 86, "    - PTR: %s", (*(spfrr->rr + i))->ptr);
      }
#line 87
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 90
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 90, "    - MX: %s", (*(spfrr->rr + i))->mx);
      }
#line 91
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 94
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 94, "    - TXT: %s", (*(spfrr->rr + i))->txt);
      }
#line 95
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 98
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 98, "    - SPF: %s", (*(spfrr->rr + i))->txt);
      }
#line 99
      goto switch_break;
      case_28: /* CIL Label */ 
      {
#line 102
      tmp___3 = inet_ntop(10, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->aaaa),
                          (char */* __restrict  */)(ip6_buf), (socklen_t )sizeof(ip6_buf));
#line 102
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 104, "    - AAAA: %s", tmp___3);
      }
#line 105
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 108
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 108, "    - Unknown RR type");
      }
#line 109
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 77
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 113
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_cache_bucket_t *SPF_dns_cache_bucket_find___6(SPF_dns_cache_config_t *spfhook ,
                                                             char const   *domain ,
                                                             ns_type rr_type , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  SPF_dns_rr_t *rr ;
  time_t now ;
  int tmp ;

  {
  {
#line 247
  bucket = *(spfhook->cache + idx);
#line 248
  prev = (SPF_dns_cache_bucket_t *)((void *)0);
#line 249
  time(& now);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
#line 252
    rr = bucket->rr;
#line 254
    if (rr->utc_ttl < now) {
#line 256
      if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 257
        prev->next = bucket->next;
      } else {
#line 259
        *(spfhook->cache + idx) = bucket->next;
      }
#line 261
      if (bucket->rr) {
        {
#line 262
        SPF_dns_rr_free(bucket->rr);
        }
      }
      {
#line 263
      free((void *)bucket);
#line 265
      bucket = prev;
      }
    } else
#line 267
    if (! ((unsigned int )rr->rr_type != (unsigned int )rr_type)) {
      {
#line 270
      tmp = strcmp((char const   *)rr->domain, domain);
      }
#line 270
      if (! (tmp != 0)) {
#line 275
        if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 276
          prev->next = bucket->next;
#line 277
          bucket->next = *(spfhook->cache + idx);
#line 278
          *(spfhook->cache + idx) = bucket;
        }
#line 280
        return (bucket);
      }
    }
#line 283
    prev = bucket;
#line 284
    if ((unsigned long )bucket == (unsigned long )((void *)0)) {
#line 285
      bucket = *(spfhook->cache + idx);
    } else {
#line 287
      bucket = bucket->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return ((SPF_dns_cache_bucket_t *)((void *)0));
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_bucket_add___6(SPF_dns_cache_config_t *spfhook ,
                                                  SPF_dns_rr_t *rr , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  void *tmp ;

  {
  {
#line 300
  tmp = malloc(sizeof(SPF_dns_cache_bucket_t ));
#line 300
  bucket = (SPF_dns_cache_bucket_t *)tmp;
  }
#line 302
  if (! bucket) {
#line 303
    return ((SPF_errcode_t )1);
  }
#line 304
  bucket->next = *(spfhook->cache + idx);
#line 305
  *(spfhook->cache + idx) = bucket;
#line 306
  bucket->rr = rr;
#line 307
  return ((SPF_errcode_t )0);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_rr_fixup___6(SPF_dns_cache_config_t *spfhook ,
                                                SPF_dns_rr_t *cached_rr , char const   *domain ,
                                                ns_type rr_type ) 
{ 
  char *p ;
  char *new_domain ;
  size_t new_len ;
  size_t tmp ;
  void *tmp___0 ;
  time_t tmp___1 ;

  {
#line 322
  if ((unsigned int )cached_rr->rr_type == 255U) {
#line 323
    cached_rr->rr_type = rr_type;
  }
#line 326
  if ((unsigned long )cached_rr->domain == (unsigned long )((void *)0)) {
#line 326
    goto _L;
  } else
#line 326
  if ((int )*(cached_rr->domain + 0) != 0) {
    _L: /* CIL Label */ 
    {
#line 328
    tmp = strlen(domain);
#line 328
    new_len = tmp + 1UL;
    }
#line 330
    if (cached_rr->domain_buf_len < new_len) {
      {
#line 331
      tmp___0 = realloc((void *)cached_rr->domain, new_len);
#line 331
      new_domain = (char *)tmp___0;
      }
#line 332
      if ((unsigned long )new_domain == (unsigned long )((void *)0)) {
#line 333
        return ((SPF_errcode_t )1);
      }
#line 334
      cached_rr->domain = new_domain;
#line 335
      cached_rr->domain_buf_len = new_len;
    }
    {
#line 337
    strcpy((char */* __restrict  */)cached_rr->domain, (char const   */* __restrict  */)domain);
    }
  }
#line 341
  if (cached_rr->ttl < spfhook->min_ttl) {
#line 342
    cached_rr->ttl = spfhook->min_ttl;
  }
#line 344
  if (cached_rr->ttl < spfhook->txt_ttl) {
#line 344
    if ((unsigned int )cached_rr->rr_type == 16U) {
#line 346
      cached_rr->ttl = spfhook->txt_ttl;
    }
  }
#line 348
  if (cached_rr->ttl < spfhook->err_ttl) {
#line 348
    if (cached_rr->herrno != 0) {
#line 350
      cached_rr->ttl = spfhook->err_ttl;
    }
  }
#line 352
  if (cached_rr->ttl < spfhook->rdns_ttl) {
    {
#line 353
    p = strstr((char const   *)cached_rr->domain, ".arpa");
    }
#line 354
    if (p) {
#line 354
      if ((int )*(p + (sizeof(".arpa") - 1UL)) == 0) {
#line 355
        cached_rr->ttl = spfhook->rdns_ttl;
      }
    }
  }
  {
#line 358
  tmp___1 = time((time_t *)((void *)0));
#line 358
  cached_rr->utc_ttl = cached_rr->ttl + tmp___1;
  }
#line 360
  return ((SPF_errcode_t )0);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_rr_t *SPF_dns_cache_lookup___6(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                              ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_rr_t *cached_rr ;
  SPF_dns_rr_t *rr ;
  int idx ;
  SPF_errcode_t tmp ;
  SPF_dns_rr_t *tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;

  {
  {
#line 377
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
#line 381
  idx = crc32str(0U, domain, spfhook->max_hash_len);
#line 382
  idx &= spfhook->cache_size - 1;
#line 384
  pthread_mutex_lock(& spfhook->cache_lock);
#line 386
  bucket = SPF_dns_cache_bucket_find___6(spfhook, domain, rr_type, idx);
  }
#line 387
  if ((unsigned long )bucket != (unsigned long )((void *)0)) {
#line 388
    if ((unsigned long )bucket->rr != (unsigned long )((void *)0)) {
      {
#line 389
      tmp = SPF_dns_rr_dup(& rr, bucket->rr);
      }
#line 389
      if ((unsigned int )tmp == 0U) {
        {
#line 390
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 391
        return (rr);
      } else
#line 393
      if ((unsigned long )rr != (unsigned long )((void *)0)) {
        {
#line 394
        SPF_dns_rr_free(rr);
        }
      }
    }
  }
  {
#line 401
  bucket = (SPF_dns_cache_bucket_t *)((void *)0);
#line 403
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 405
  if (! spf_dns_server->layer_below) {
    {
#line 406
    tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
    }
#line 406
    return (tmp___0);
  }
  {
#line 408
  rr = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
  }
#line 410
  if (spfhook->conserve_cache) {
#line 410
    if (! should_cache) {
#line 411
      return (rr);
    }
  }
  {
#line 413
  pthread_mutex_lock(& spfhook->cache_lock);
#line 415
  tmp___3 = SPF_dns_rr_dup(& cached_rr, rr);
  }
#line 415
  if ((unsigned int )tmp___3 == 0U) {
    {
#line 416
    tmp___2 = SPF_dns_cache_rr_fixup___6(spfhook, cached_rr, domain, rr_type);
    }
#line 416
    if ((unsigned int )tmp___2 == 0U) {
      {
#line 417
      tmp___1 = SPF_dns_cache_bucket_add___6(spfhook, cached_rr, idx);
      }
#line 417
      if ((unsigned int )tmp___1 == 0U) {
        {
#line 418
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 419
        return (rr);
      }
    }
  }
  {
#line 424
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 426
  if (cached_rr) {
    {
#line 427
    SPF_dns_rr_free(cached_rr);
    }
  }
#line 429
  return (rr);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static void SPF_dns_cache_free___6(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  int i ;

  {
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 442
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
                 442, "%s", "spf_dns_server is NULL");
      }
    }
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
  }
#line 445
  if (spfhook) {
    {
#line 446
    pthread_mutex_lock(& spfhook->cache_lock);
    }
#line 448
    if (spfhook->cache) {
#line 449
      i = 0;
      {
#line 449
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 449
        if (! (i < spfhook->cache_size)) {
#line 449
          goto while_break___0;
        }
#line 450
        bucket = *(spfhook->cache + i);
        {
#line 451
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 451
          if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 451
            goto while_break___1;
          }
#line 452
          prev = bucket;
#line 453
          bucket = bucket->next;
#line 456
          if (prev->rr) {
            {
#line 457
            SPF_dns_rr_free(prev->rr);
            }
          }
          {
#line 458
          free((void *)prev);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 449
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 461
      free((void *)spfhook->cache);
#line 462
      spfhook->cache = (SPF_dns_cache_bucket_t **)((void *)0);
      }
    }
    {
#line 465
    pthread_mutex_unlock(& spfhook->cache_lock);
#line 476
    pthread_mutex_destroy(& spfhook->cache_lock);
#line 478
    free((void *)spfhook);
    }
  }
  {
#line 481
  free((void *)spf_dns_server);
  }
#line 482
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_find___6(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                           ns_type rr_type , int exact ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;
  int tmp ;
  size_t domain_len ;
  size_t tmp___0 ;
  size_t zdomain_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 103
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 105
  if (spf_dns_server->debug) {
    {
#line 106
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
               106, "zone: Searching for RR %s (%d)", domain, (unsigned int )rr_type);
    }
  }
#line 110
  if (exact) {
#line 110
    goto _L;
  } else {
    {
#line 110
    tmp___6 = strncmp(domain, "*.", (size_t )2);
    }
#line 110
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
#line 111
      i = 0;
      {
#line 111
      while (1) {
        while_continue: /* CIL Label */ ;
#line 111
        if (! (i < spfhook->num_zone)) {
#line 111
          goto while_break;
        }
#line 112
        if ((unsigned int )(*(spfhook->zone + i))->rr_type == (unsigned int )rr_type) {
          {
#line 112
          tmp = strcasecmp((char const   *)(*(spfhook->zone + i))->domain, domain);
          }
#line 112
          if (tmp == 0) {
#line 114
            return (*(spfhook->zone + i));
          }
        }
#line 111
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 116
      if (spf_dns_server->debug) {
        {
#line 117
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   117, "zone: Exact not found");
        }
      }
    } else {
      {
#line 121
      tmp___0 = strlen(domain);
#line 121
      domain_len = tmp___0;
      }
#line 125
      if (domain_len) {
#line 125
        if ((int const   )*(domain + (domain_len - 1UL)) == 46) {
#line 126
          domain_len --;
        }
      }
#line 128
      i = 0;
      {
#line 128
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 128
        if (! (i < spfhook->num_zone)) {
#line 128
          goto while_break___0;
        }
#line 129
        if ((unsigned int )(*(spfhook->zone + i))->rr_type != (unsigned int )rr_type) {
#line 129
          if ((unsigned int )(*(spfhook->zone + i))->rr_type != 255U) {
#line 131
            if (spf_dns_server->debug) {
              {
#line 132
              SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                         133, "zone: Ignoring record rrtype %d", (unsigned int )(*(spfhook->zone + i))->rr_type);
              }
            }
#line 134
            goto __Cont;
          }
        }
        {
#line 137
        tmp___5 = strncmp((char const   *)(*(spfhook->zone + i))->domain, "*.", (size_t )2);
        }
#line 137
        if (tmp___5 == 0) {
          {
#line 138
          tmp___1 = strlen((char const   *)(*(spfhook->zone + i))->domain);
#line 138
          zdomain_len = tmp___1 - 2UL;
          }
#line 139
          if (zdomain_len <= domain_len) {
            {
#line 139
            tmp___2 = strncasecmp((char const   *)((*(spfhook->zone + i))->domain + 2),
                                  domain + (domain_len - zdomain_len), zdomain_len);
            }
#line 139
            if (tmp___2 == 0) {
#line 144
              return (*(spfhook->zone + i));
            }
          }
        } else {
          {
#line 146
          tmp___3 = strncasecmp((char const   *)(*(spfhook->zone + i))->domain, domain,
                                domain_len);
          }
#line 146
          if (tmp___3 == 0) {
            {
#line 146
            tmp___4 = strlen((char const   *)(*(spfhook->zone + i))->domain);
            }
#line 146
            if (tmp___4 == domain_len) {
#line 151
              return (*(spfhook->zone + i));
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 128
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 154
      if (spf_dns_server->debug) {
        {
#line 155
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   155, "zone: Non-exact not found");
        }
      }
    }
  }
#line 158
  return ((SPF_dns_rr_t *)((void *)0));
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_lookup___6(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  SPF_dns_rr_t *spfrr ;
  SPF_dns_rr_t *tmp ;

  {
  {
#line 170
  spfrr = SPF_dns_zone_find___6(spf_dns_server, domain, rr_type, 0);
  }
#line 171
  if (spfrr) {
    {
#line 172
    SPF_dns_rr_dup(& spfrr, spfrr);
    }
#line 173
    return (spfrr);
  }
#line 176
  if (spf_dns_server->layer_below) {
    {
#line 177
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 177
    return (tmp);
  }
  {
#line 181
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
#line 182
  SPF_dns_rr_dup(& spfrr, spfhook->nxdomain);
  }
#line 184
  return (spfrr);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static void SPF_dns_zone_free___6(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 317
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                 317, "%s", "spf_dns_server is NULL");
      }
    }
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 320
  if (spfhook) {
#line 321
    if (spfhook->zone) {
#line 322
      i = 0;
      {
#line 322
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 322
        if (! (i < spfhook->zone_buf_len)) {
#line 322
          goto while_break___0;
        }
#line 323
        if (*(spfhook->zone + i)) {
          {
#line 324
          SPF_dns_rr_free(*(spfhook->zone + i));
          }
        }
#line 322
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 326
      free((void *)spfhook->zone);
      }
    }
#line 328
    if (spfhook->nxdomain) {
      {
#line 329
      SPF_dns_rr_free(spfhook->nxdomain);
      }
    }
    {
#line 330
    free((void *)spfhook);
    }
  }
  {
#line 333
  free((void *)spf_dns_server);
  }
#line 334
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static struct res_sym  const  ns_sects___6[4]  = {      {0, (char *)"QUESTION", (char *)"Question"}, 
        {1, (char *)"ANSWER", (char *)"Answer"}, 
        {2, (char *)"AUTHORITY", (char *)"Authority"}, 
        {3, (char *)"ADDITIONAL", (char *)"Additional"}};
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static int const   num_ns_sect___6  =    (int const   )(sizeof(ns_sects___6) / sizeof(ns_sects___6[0]));
#line 89 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_once_t res_state_control___6  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_key_t res_state_key___6  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_thread_term___6(void *arg ) 
{ 


  {
  {
#line 98
  __res_nclose((struct __res_state *)arg);
#line 100
  free(arg);
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_init_key___6(void) 
{ 


  {
  {
#line 106
  pthread_key_create(& res_state_key___6, & SPF_dns_resolv_thread_term___6);
  }
#line 107
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_debug___6(SPF_dns_server_t *spf_dns_server , ns_rr rr ,
                                     u_char const   *responsebuf , size_t responselen ,
                                     u_char const   *rdata , size_t rdlen ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char name_buf[1025] ;
  int prio ;
  int err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  u_int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 123
  if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 123
    goto case_1;
  }
#line 132
  if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 132
    goto case_28;
  }
#line 141
  if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 141
    goto case_2;
  }
#line 153
  if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 153
    goto case_5;
  }
#line 165
  if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 165
    goto case_15;
  }
#line 182
  if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 182
    goto case_16;
  }
#line 193
  if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 193
    goto case_12;
  }
#line 205
  goto switch_default;
  case_1: /* CIL Label */ 
#line 124
  if (rdlen != 4UL) {
    {
#line 125
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               125, "A: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 127
    tmp = inet_ntop(2, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip4_buf),
                    (socklen_t )sizeof(ip4_buf));
#line 127
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               129, "A: %s", tmp);
    }
  }
#line 130
  goto switch_break;
  case_28: /* CIL Label */ 
#line 133
  if (rdlen != 16UL) {
    {
#line 134
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               134, "AAAA: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 136
    tmp___0 = inet_ntop(10, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip6_buf),
                        (socklen_t )sizeof(ip6_buf));
#line 136
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               138, "AAAA: %s", tmp___0);
    }
  }
#line 139
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 142
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 146
  if (err < 0) {
    {
#line 147
    tmp___1 = __errno_location();
#line 147
    tmp___2 = __errno_location();
#line 147
    tmp___3 = strerror(*tmp___2);
#line 147
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               148, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___3,
               *tmp___1);
    }
  } else {
    {
#line 150
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               150, "NS: %s", name_buf);
    }
  }
#line 151
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 154
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 158
  if (err < 0) {
    {
#line 159
    tmp___4 = __errno_location();
#line 159
    tmp___5 = __errno_location();
#line 159
    tmp___6 = strerror(*tmp___5);
#line 159
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               160, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___6,
               *tmp___4);
    }
  } else {
    {
#line 162
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               162, "CNAME: %s", name_buf);
    }
  }
#line 163
  goto switch_break;
  case_15: /* CIL Label */ 
#line 166
  if (rdlen < 2UL) {
    {
#line 167
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               167, "MX: rdlen too short: %lu", rdlen);
    }
#line 168
    goto switch_break;
  }
  {
#line 170
  tmp___7 = ns_get16(rdata);
#line 170
  prio = (int )tmp___7;
#line 171
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata + 2, name_buf,
                           sizeof(name_buf));
  }
#line 175
  if (err < 0) {
    {
#line 176
    tmp___8 = __errno_location();
#line 176
    tmp___9 = __errno_location();
#line 176
    tmp___10 = strerror(*tmp___9);
#line 176
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               177, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___10,
               *tmp___8);
    }
  } else {
    {
#line 179
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               179, "MX: %d %s", prio, name_buf);
    }
  }
#line 180
  goto switch_break;
  case_16: /* CIL Label */ 
#line 183
  if (rdlen < 1UL) {
    {
#line 184
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               184, "TXT: rdlen too short: %lu", rdlen);
    }
#line 185
    goto switch_break;
  }
  {
#line 189
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             190, "TXT: (%lu) \"%.*s\"", rdlen, (int )rdlen - 1, rdata + 1);
  }
#line 191
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 194
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 198
  if (err < 0) {
    {
#line 199
    tmp___11 = __errno_location();
#line 199
    tmp___12 = __errno_location();
#line 199
    tmp___13 = strerror(*tmp___12);
#line 199
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               200, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___13,
               *tmp___11);
    }
  } else {
    {
#line 202
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               202, "PTR: %s", name_buf);
    }
  }
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 206
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             206, "not parsed:  type: %d", (unsigned int )((ns_type )((int )rr.type)));
  }
#line 207
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static SPF_dns_rr_t *SPF_dns_resolv_lookup___6(SPF_dns_server_t *spf_dns_server ,
                                               char const   *domain , ns_type rr_type ,
                                               int should_cache ) 
{ 
  SPF_dns_rr_t *spfrr ;
  int err ;
  int i ;
  int nrec ;
  int cnt ;
  u_char *responsebuf ;
  size_t responselen ;
  ns_msg ns_handle ;
  ns_rr rr ;
  int ns_sect___0 ;
  char name_buf[1025] ;
  size_t rdlen ;
  u_char const   *rdata ;
  void *res_spec ;
  struct __res_state *res_state___0 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int dns_len ;
  char const   *tmp___2 ;
  SPF_dns_rr_t *tmp___3 ;
  SPF_dns_rr_t *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  SPF_errcode_t tmp___20 ;
  SPF_errcode_t tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  SPF_errcode_t tmp___26 ;
  u_char *src ;
  u_char *dst ;
  size_t len ;
  SPF_errcode_t tmp___27 ;
  SPF_errcode_t tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  SPF_errcode_t tmp___33 ;

  {
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 247
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 247, "%s", "spf_dns_server is NULL");
      }
    }
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  res_spec = pthread_getspecific(res_state_key___6);
  }
#line 252
  if ((unsigned long )res_spec == (unsigned long )((void *)0)) {
    {
#line 253
    tmp = malloc(sizeof(struct __res_state ));
#line 253
    res_state___0 = (struct __res_state *)tmp;
    }
#line 257
    if (! res_state___0) {
      {
#line 258
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 259, "Failed to allocate %lu bytes for res_state", sizeof(struct __res_state ));
      }
    }
    {
#line 260
    memset((void *)res_state___0, 0, sizeof(struct __res_state ));
#line 261
    tmp___0 = __res_ninit(res_state___0);
    }
#line 261
    if (tmp___0 != 0) {
      {
#line 262
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 262, "%s", "Failed to call res_ninit()");
      }
    }
    {
#line 263
    pthread_setspecific(res_state_key___6, (void const   *)((void *)res_state___0));
    }
  } else {
#line 266
    res_state___0 = (struct __res_state *)res_spec;
  }
  {
#line 270
  responselen = (size_t )2048;
#line 271
  tmp___1 = malloc(responselen);
#line 271
  responsebuf = (u_char *)tmp___1;
  }
#line 272
  if (! responsebuf) {
#line 273
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 274
  memset((void *)responsebuf, 0, responselen);
  }
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 297
    dns_len = __res_nquery(res_state___0, domain, 1, (int )rr_type, responsebuf, (int )responselen);
    }
#line 304
    if (dns_len < 0) {
      {
#line 307
      free((void *)responsebuf);
      }
#line 308
      if (spf_dns_server->debug) {
        {
#line 309
        tmp___2 = hstrerror(res_state___0->res_h_errno);
#line 309
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   311, "query failed: err = %d  %s (%d): %s", dns_len, tmp___2, res_state___0->res_h_errno,
                   domain);
        }
      }
#line 312
      if (res_state___0->res_h_errno == 1) {
#line 312
        if ((unsigned long )spf_dns_server->layer_below != (unsigned long )((void *)0)) {
          {
#line 314
          tmp___3 = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
          }
#line 314
          return (tmp___3);
        }
      }
      {
#line 317
      tmp___4 = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, res_state___0->res_h_errno);
      }
#line 317
      return (tmp___4);
    } else
#line 320
    if ((size_t )dns_len > responselen) {
      {
#line 323
      responselen = (size_t )(dns_len + (dns_len >> 1));
#line 332
      tmp___5 = realloc((void *)responsebuf, responselen);
      }
#line 333
      if (! tmp___5) {
        {
#line 334
        free((void *)responsebuf);
        }
#line 335
        return ((SPF_dns_rr_t *)((void *)0));
      }
#line 337
      responsebuf = (u_char *)tmp___5;
    } else {
#line 341
      responselen = (size_t )dns_len;
#line 342
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 351
  spfrr = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, 0);
  }
#line 353
  if (! spfrr) {
    {
#line 354
    free((void *)responsebuf);
    }
#line 355
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 358
  err = ns_initparse((u_char const   *)responsebuf, (int )responselen, & ns_handle);
  }
#line 360
  if (err < 0) {
#line 361
    if (spf_dns_server->debug) {
      {
#line 362
      tmp___6 = __errno_location();
#line 362
      tmp___7 = __errno_location();
#line 362
      tmp___8 = strerror(*tmp___7);
#line 362
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 363, "ns_initparse failed: err = %d  %s (%d)", err, tmp___8, *tmp___6);
      }
    }
    {
#line 364
    free((void *)responsebuf);
#line 367
    spfrr->herrno = 3;
    }
#line 368
    return (spfrr);
  }
#line 372
  if (spf_dns_server->debug > 1) {
    {
#line 373
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               373, "msg id:             %d", (int )ns_handle._id);
#line 374
    tmp___9 = ns_msg_getflag(ns_handle, 0);
#line 374
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               374, "ns_f_qr quest/resp: %d", tmp___9);
#line 375
    tmp___10 = ns_msg_getflag(ns_handle, 1);
#line 375
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               375, "ns_f_opcode:        %d", tmp___10);
#line 376
    tmp___11 = ns_msg_getflag(ns_handle, 2);
#line 376
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               376, "ns_f_aa auth ans:   %d", tmp___11);
#line 377
    tmp___12 = ns_msg_getflag(ns_handle, 3);
#line 377
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               377, "ns_f_tc truncated:  %d", tmp___12);
#line 378
    tmp___13 = ns_msg_getflag(ns_handle, 4);
#line 378
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               378, "ns_f_rd rec desire: %d", tmp___13);
#line 379
    tmp___14 = ns_msg_getflag(ns_handle, 5);
#line 379
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               379, "ns_f_ra rec avail:  %d", tmp___14);
#line 380
    tmp___15 = ns_msg_getflag(ns_handle, 9);
#line 380
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               380, "ns_f_rcode:         %d", tmp___15);
    }
  }
#line 385
  ns_sect___0 = 0;
  {
#line 385
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 385
    if (! (ns_sect___0 < (int )num_ns_sect___6)) {
#line 385
      goto while_break___1;
    }
#line 391
    if (ns_sects___6[ns_sect___0].number != 1) {
#line 391
      if (spf_dns_server->debug <= 1) {
#line 392
        goto __Cont;
      }
    }
#line 394
    nrec = (int )ns_handle._counts[ns_sects___6[ns_sect___0].number];
#line 396
    if (spf_dns_server->debug > 1) {
      {
#line 397
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 397, "%s:  %d", ns_sects___6[ns_sect___0].name, nrec);
      }
    }
#line 399
    spfrr->num_rr = 0;
#line 400
    cnt = 0;
#line 401
    i = 0;
    {
#line 401
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 401
      if (! (i < nrec)) {
#line 401
        goto while_break___2;
      }
      {
#line 402
      err = ns_parserr(& ns_handle, (ns_sect )ns_sects___6[ns_sect___0].number, i,
                       & rr);
      }
#line 403
      if (err < 0) {
#line 404
        if (spf_dns_server->debug > 1) {
          {
#line 405
          tmp___16 = __errno_location();
#line 405
          tmp___17 = __errno_location();
#line 405
          tmp___18 = strerror(*tmp___17);
#line 405
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     406, "ns_parserr failed: err = %d  %s (%d)", err, tmp___18, *tmp___16);
          }
        }
        {
#line 407
        free((void *)responsebuf);
#line 410
        spfrr->herrno = 3;
        }
#line 411
        return (spfrr);
      }
#line 414
      rdlen = (size_t )((int )rr.rdlength);
#line 415
      if (spf_dns_server->debug > 1) {
#line 416
        if ((int )rr.name[0] != 0) {
#line 416
          tmp___19 = (char const   *)(rr.name);
        } else {
#line 416
          tmp___19 = ".";
        }
        {
#line 416
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   418, "name: %s  type: %d  class: %d  ttl: %d  rdlen: %lu", tmp___19,
                   (unsigned int )((ns_type )((int )rr.type)), (unsigned int )((ns_class )((int )rr.rr_class)),
                   rr.ttl, rdlen);
        }
      }
#line 420
      if (rdlen <= 0UL) {
#line 421
        goto __Cont___0;
      }
#line 423
      rdata = rr.rdata + 0;
#line 425
      if (spf_dns_server->debug > 1) {
        {
#line 426
        SPF_dns_resolv_debug___6(spf_dns_server, rr, (u_char const   *)responsebuf,
                                 responselen, rdata, rdlen);
        }
      }
#line 430
      if (ns_sects___6[ns_sect___0].number != 1) {
#line 431
        goto __Cont___0;
      }
#line 434
      if ((unsigned int )((ns_type )((int )rr.type)) != (unsigned int )spfrr->rr_type) {
#line 434
        if ((unsigned int )((ns_type )((int )rr.type)) != 5U) {
          {
#line 435
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     436, "unexpected rr type: %d   expected: %d", (unsigned int )((ns_type )((int )rr.type)),
                     (unsigned int )rr_type);
          }
#line 437
          goto __Cont___0;
        }
      }
      {
#line 441
      if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 441
        goto case_1;
      }
#line 458
      if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 458
        goto case_28;
      }
#line 475
      if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 475
        goto case_2;
      }
#line 478
      if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 478
        goto case_5;
      }
#line 482
      if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 482
        goto case_15;
      }
#line 513
      if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 513
        goto case_16;
      }
#line 562
      if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 562
        goto case_12;
      }
#line 588
      goto switch_default;
      case_1: /* CIL Label */ 
#line 442
      if (rdlen != 4UL) {
        {
#line 444
        free((void *)responsebuf);
        }
#line 445
        return (spfrr);
      }
      {
#line 447
      tmp___20 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->a));
      }
#line 447
      if ((unsigned int )tmp___20 != 0U) {
        {
#line 449
        free((void *)responsebuf);
        }
#line 452
        return (spfrr);
      }
      {
#line 454
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->a), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->a));
#line 455
      cnt ++;
      }
#line 456
      goto switch_break;
      case_28: /* CIL Label */ 
#line 459
      if (rdlen != 16UL) {
        {
#line 461
        free((void *)responsebuf);
        }
#line 462
        return (spfrr);
      }
      {
#line 464
      tmp___21 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->aaaa));
      }
#line 464
      if ((unsigned int )tmp___21 != 0U) {
        {
#line 466
        free((void *)responsebuf);
        }
#line 469
        return (spfrr);
      }
      {
#line 471
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->aaaa), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->aaaa));
#line 472
      cnt ++;
      }
#line 473
      goto switch_break;
      case_2: /* CIL Label */ 
#line 476
      goto switch_break;
      case_5: /* CIL Label */ 
#line 480
      goto switch_break;
      case_15: /* CIL Label */ 
#line 483
      if (rdlen < 2UL) {
        {
#line 485
        free((void *)responsebuf);
        }
#line 486
        return (spfrr);
      }
      {
#line 488
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata + 2, name_buf, sizeof(name_buf));
      }
#line 492
      if (err < 0) {
#line 493
        if (spf_dns_server->debug > 1) {
          {
#line 494
          tmp___22 = __errno_location();
#line 494
          tmp___23 = __errno_location();
#line 494
          tmp___24 = strerror(*tmp___23);
#line 494
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     495, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___24,
                     *tmp___22);
          }
        }
        {
#line 496
        free((void *)responsebuf);
        }
#line 499
        return (spfrr);
      }
      {
#line 502
      tmp___25 = strlen((char const   *)(name_buf));
#line 502
      tmp___26 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___25 + 1UL);
      }
#line 502
      if ((unsigned int )tmp___26 != 0U) {
        {
#line 504
        free((void *)responsebuf);
        }
#line 507
        return (spfrr);
      }
      {
#line 509
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->mx), (char const   */* __restrict  */)(name_buf));
#line 510
      cnt ++;
      }
#line 511
      goto switch_break;
      case_16: /* CIL Label */ 
#line 514
      if (rdlen > 1UL) {
        {
#line 520
        tmp___27 = SPF_dns_rr_buf_realloc(spfrr, cnt, rdlen);
        }
#line 520
        if ((unsigned int )tmp___27 != 0U) {
          {
#line 521
          free((void *)responsebuf);
          }
#line 524
          return (spfrr);
        }
#line 527
        dst = (u_char *)((*(spfrr->rr + cnt))->txt);
#line 528
        src = (u_char *)rdata;
#line 529
        len = (size_t )0;
        {
#line 530
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 530
          if (! (rdlen > 0UL)) {
#line 530
            goto while_break___3;
          }
#line 532
          len = (size_t )*src;
#line 533
          src ++;
#line 534
          rdlen --;
#line 538
          if (len > rdlen) {
#line 539
            len = rdlen;
          }
          {
#line 540
          memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src,
                 len);
#line 543
          src += len;
#line 544
          dst += len;
#line 545
          rdlen -= len;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 547
        *dst = (u_char )'\000';
      } else {
        {
#line 550
        tmp___28 = SPF_dns_rr_buf_realloc(spfrr, cnt, (size_t )1);
        }
#line 550
        if ((unsigned int )tmp___28 != 0U) {
          {
#line 551
          free((void *)responsebuf);
          }
#line 554
          return (spfrr);
        }
#line 556
        (*(spfrr->rr + cnt))->txt[0] = (char )'\000';
      }
#line 559
      cnt ++;
#line 560
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 563
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata, name_buf, sizeof(name_buf));
      }
#line 567
      if (err < 0) {
#line 568
        if (spf_dns_server->debug > 1) {
          {
#line 569
          tmp___29 = __errno_location();
#line 569
          tmp___30 = __errno_location();
#line 569
          tmp___31 = strerror(*tmp___30);
#line 569
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     570, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___31,
                     *tmp___29);
          }
        }
        {
#line 571
        free((void *)responsebuf);
        }
#line 574
        return (spfrr);
      }
      {
#line 577
      tmp___32 = strlen((char const   *)(name_buf));
#line 577
      tmp___33 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___32 + 1UL);
      }
#line 577
      if ((unsigned int )tmp___33 != 0U) {
        {
#line 579
        free((void *)responsebuf);
        }
#line 582
        return (spfrr);
      }
      {
#line 584
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->ptr), (char const   */* __restrict  */)(name_buf));
#line 585
      cnt ++;
      }
#line 586
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 589
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 401
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 593
    spfrr->num_rr = cnt;
    __Cont: /* CIL Label */ 
#line 385
    ns_sect___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 596
  if (spfrr->num_rr == 0) {
#line 597
    spfrr->herrno = 4;
  }
  {
#line 599
  free((void *)responsebuf);
  }
#line 600
  return (spfrr);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_free___6(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 607
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 607, "%s", "spf_dns_server is NULL");
      }
    }
#line 607
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  free((void *)spf_dns_server);
  }
#line 614
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c"
static SPF_errcode_t SPF_server_get_default_explanation___6(SPF_server_t *spf_server___1 ,
                                                            SPF_request_t *spf_request ,
                                                            SPF_response_t *spf_response ,
                                                            char **bufp , size_t *buflenp ) 
{ 
  SPF_errcode_t err ;
  SPF_macro_t *spf_macro ;
  SPF_data_t *tmp ;
  size_t len ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  spf_macro = spf_server___1->explanation;
#line 56
  if ((unsigned long )spf_macro != (unsigned long )((void *)0)) {
    {
#line 57
    tmp = SPF_macro_data(spf_macro);
#line 57
    err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, tmp, spf_macro->macro_len,
                                 bufp, buflenp);
    }
#line 61
    return (err);
  } else {
#line 64
    len = sizeof("SPF failure: no explanation available") + 1UL;
#line 65
    if (*buflenp < len) {
      {
#line 66
      tmp___1 = realloc((void *)*bufp, len);
#line 66
      tmp___0 = (char *)tmp___1;
      }
#line 67
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 68
        return ((SPF_errcode_t )1);
      }
#line 69
      *bufp = tmp___0;
#line 70
      *buflenp = len;
    }
    {
#line 72
    strcpy((char */* __restrict  */)*bufp, (char const   */* __restrict  */)"SPF failure: no explanation available");
    }
#line 73
    return ((SPF_errcode_t )0);
  }
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/spftest/spftest.c"
static void usage___5(void) 
{ 


  {
  {
#line 78
  printf((char const   */* __restrict  */)"Usage: spftest [spf \"<spf record>\" | domain <domain name>\n");
#line 79
  printf((char const   */* __restrict  */)"                | ip <ip address> | exp \"<explanation string>\"\n");
#line 80
  printf((char const   */* __restrict  */)"                | version ]\n");
  }
#line 81
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_find___7(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                           ns_type rr_type , int exact ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;
  int tmp ;
  size_t domain_len ;
  size_t tmp___0 ;
  size_t zdomain_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 103
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 105
  if (spf_dns_server->debug) {
    {
#line 106
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
               106, "zone: Searching for RR %s (%d)", domain, (unsigned int )rr_type);
    }
  }
#line 110
  if (exact) {
#line 110
    goto _L;
  } else {
    {
#line 110
    tmp___6 = strncmp(domain, "*.", (size_t )2);
    }
#line 110
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
#line 111
      i = 0;
      {
#line 111
      while (1) {
        while_continue: /* CIL Label */ ;
#line 111
        if (! (i < spfhook->num_zone)) {
#line 111
          goto while_break;
        }
#line 112
        if ((unsigned int )(*(spfhook->zone + i))->rr_type == (unsigned int )rr_type) {
          {
#line 112
          tmp = strcasecmp((char const   *)(*(spfhook->zone + i))->domain, domain);
          }
#line 112
          if (tmp == 0) {
#line 114
            return (*(spfhook->zone + i));
          }
        }
#line 111
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 116
      if (spf_dns_server->debug) {
        {
#line 117
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   117, "zone: Exact not found");
        }
      }
    } else {
      {
#line 121
      tmp___0 = strlen(domain);
#line 121
      domain_len = tmp___0;
      }
#line 125
      if (domain_len) {
#line 125
        if ((int const   )*(domain + (domain_len - 1UL)) == 46) {
#line 126
          domain_len --;
        }
      }
#line 128
      i = 0;
      {
#line 128
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 128
        if (! (i < spfhook->num_zone)) {
#line 128
          goto while_break___0;
        }
#line 129
        if ((unsigned int )(*(spfhook->zone + i))->rr_type != (unsigned int )rr_type) {
#line 129
          if ((unsigned int )(*(spfhook->zone + i))->rr_type != 255U) {
#line 131
            if (spf_dns_server->debug) {
              {
#line 132
              SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                         133, "zone: Ignoring record rrtype %d", (unsigned int )(*(spfhook->zone + i))->rr_type);
              }
            }
#line 134
            goto __Cont;
          }
        }
        {
#line 137
        tmp___5 = strncmp((char const   *)(*(spfhook->zone + i))->domain, "*.", (size_t )2);
        }
#line 137
        if (tmp___5 == 0) {
          {
#line 138
          tmp___1 = strlen((char const   *)(*(spfhook->zone + i))->domain);
#line 138
          zdomain_len = tmp___1 - 2UL;
          }
#line 139
          if (zdomain_len <= domain_len) {
            {
#line 139
            tmp___2 = strncasecmp((char const   *)((*(spfhook->zone + i))->domain + 2),
                                  domain + (domain_len - zdomain_len), zdomain_len);
            }
#line 139
            if (tmp___2 == 0) {
#line 144
              return (*(spfhook->zone + i));
            }
          }
        } else {
          {
#line 146
          tmp___3 = strncasecmp((char const   *)(*(spfhook->zone + i))->domain, domain,
                                domain_len);
          }
#line 146
          if (tmp___3 == 0) {
            {
#line 146
            tmp___4 = strlen((char const   *)(*(spfhook->zone + i))->domain);
            }
#line 146
            if (tmp___4 == domain_len) {
#line 151
              return (*(spfhook->zone + i));
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 128
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 154
      if (spf_dns_server->debug) {
        {
#line 155
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                   155, "zone: Non-exact not found");
        }
      }
    }
  }
#line 158
  return ((SPF_dns_rr_t *)((void *)0));
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static SPF_dns_rr_t *SPF_dns_zone_lookup___7(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  SPF_dns_rr_t *spfrr ;
  SPF_dns_rr_t *tmp ;

  {
  {
#line 170
  spfrr = SPF_dns_zone_find___7(spf_dns_server, domain, rr_type, 0);
  }
#line 171
  if (spfrr) {
    {
#line 172
    SPF_dns_rr_dup(& spfrr, spfrr);
    }
#line 173
    return (spfrr);
  }
#line 176
  if (spf_dns_server->layer_below) {
    {
#line 177
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 177
    return (tmp);
  }
  {
#line 181
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
#line 182
  SPF_dns_rr_dup(& spfrr, spfhook->nxdomain);
  }
#line 184
  return (spfrr);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c"
static void SPF_dns_zone_free___7(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_zone_config_t *spfhook ;
  int i ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 317
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_zone.c",
                 317, "%s", "spf_dns_server is NULL");
      }
    }
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
  }
#line 320
  if (spfhook) {
#line 321
    if (spfhook->zone) {
#line 322
      i = 0;
      {
#line 322
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 322
        if (! (i < spfhook->zone_buf_len)) {
#line 322
          goto while_break___0;
        }
#line 323
        if (*(spfhook->zone + i)) {
          {
#line 324
          SPF_dns_rr_free(*(spfhook->zone + i));
          }
        }
#line 322
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 326
      free((void *)spfhook->zone);
      }
    }
#line 328
    if (spfhook->nxdomain) {
      {
#line 329
      SPF_dns_rr_free(spfhook->nxdomain);
      }
    }
    {
#line 330
    free((void *)spfhook);
    }
  }
  {
#line 333
  free((void *)spf_dns_server);
  }
#line 334
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c"
static SPF_errcode_t SPF_record_stringify_data___7(SPF_data_t *data , SPF_data_t *data_end ,
                                                   char **p_p , char *p_end , int is_mod ,
                                                   int cidr_ok , int debug ) 
{ 
  char *p ;
  size_t len ;
  SPF_data_t *cidr_data ;
  char *s ;
  char *tmp ;
  char *s_end ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 48
  p = *p_p;
#line 54
  if (debug) {
    {
#line 55
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
               55, " string data: Building");
    }
  }
#line 57
  if (p_end - p <= 0L) {
#line 58
    return ((SPF_errcode_t )10);
  }
#line 60
  cidr_data = (SPF_data_t *)((void *)0);
#line 61
  if ((unsigned long )data < (unsigned long )data_end) {
#line 61
    if ((int )data->dc.parm_type == 11) {
#line 63
      if (debug) {
        {
#line 64
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   64, " string data: Found a CIDR at %p", data);
        }
      }
#line 65
      if (! cidr_ok) {
#line 66
        return ((SPF_errcode_t )10);
      }
      {
#line 68
      cidr_data = data;
#line 69
      data = SPF_data_next(data);
      }
    }
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )data < (unsigned long )data_end)) {
#line 73
      goto while_break;
    }
#line 75
    if (debug) {
      {
#line 76
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                 77, " string data: Handling data type %d at %p", (int )data->ds.parm_type,
                 data);
      }
    }
#line 78
    if ((int )data->ds.parm_type == 12) {
      {
#line 80
      tmp = SPF_data_str(data);
#line 80
      s = tmp;
#line 81
      s_end = s + (int )data->ds.len;
      }
#line 82
      if (debug) {
        {
#line 83
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_id2str.c",
                   84, " string data: String is [%d] \'%*.*s\'", (int )data->ds.len,
                   (int )data->ds.len, (int )data->ds.len, s);
        }
      }
#line 86
      if (p_end - (p + (int )data->ds.len) <= 0L) {
#line 87
        return ((SPF_errcode_t )10);
      }
      {
#line 89
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 89
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 89
          goto while_break___0;
        }
#line 90
        if ((int )*s == 32) {
#line 91
          tmp___0 = p;
#line 91
          p ++;
#line 91
          *tmp___0 = (char )'%';
#line 92
          tmp___1 = p;
#line 92
          p ++;
#line 92
          *tmp___1 = (char )'_';
#line 93
          s ++;
        } else
#line 95
        if ((int )*s == 37) {
#line 96
          tmp___2 = p;
#line 96
          p ++;
#line 96
          *tmp___2 = (char )'%';
#line 97
          s ++;
#line 98
          if ((int )*(s + 0) == 50) {
#line 98
            if ((int )*(s + 1) == 48) {
#line 99
              tmp___3 = p;
#line 99
              p ++;
#line 99
              *tmp___3 = (char )'-';
#line 100
              s += 2;
            } else {
#line 103
              tmp___4 = p;
#line 103
              p ++;
#line 103
              *tmp___4 = (char )'%';
            }
          } else {
#line 103
            tmp___4 = p;
#line 103
            p ++;
#line 103
            *tmp___4 = (char )'%';
          }
        } else {
#line 108
          tmp___5 = p;
#line 108
          p ++;
#line 108
          tmp___6 = s;
#line 108
          s ++;
#line 108
          *tmp___5 = *tmp___6;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 112
      if (p_end - p <= 0L) {
#line 113
        return ((SPF_errcode_t )10);
      }
    } else
#line 115
    if ((int )data->dc.parm_type == 11) {
#line 117
      return ((SPF_errcode_t )8);
    } else {
      {
#line 120
      tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%%{");
#line 120
      len = (size_t )tmp___7;
#line 121
      p += len;
      }
#line 122
      if (p_end - p <= 0L) {
#line 122
        return ((SPF_errcode_t )10);
      }
#line 125
      if (p_end - p <= 1L) {
#line 125
        return ((SPF_errcode_t )10);
      }
      {
#line 128
      if ((int )data->dv.parm_type == 0) {
#line 128
        goto case_0;
      }
#line 132
      if ((int )data->dv.parm_type == 1) {
#line 132
        goto case_1;
      }
#line 136
      if ((int )data->dv.parm_type == 2) {
#line 136
        goto case_2;
      }
#line 140
      if ((int )data->dv.parm_type == 3) {
#line 140
        goto case_3;
      }
#line 144
      if ((int )data->dv.parm_type == 4) {
#line 144
        goto case_4;
      }
#line 148
      if ((int )data->dv.parm_type == 5) {
#line 148
        goto case_5;
      }
#line 152
      if ((int )data->dv.parm_type == 6) {
#line 152
        goto case_6;
      }
#line 158
      if ((int )data->dv.parm_type == 7) {
#line 158
        goto case_7;
      }
#line 162
      if ((int )data->dv.parm_type == 8) {
#line 162
        goto case_8;
      }
#line 166
      if ((int )data->dv.parm_type == 9) {
#line 166
        goto case_9;
      }
#line 170
      if ((int )data->dv.parm_type == 10) {
#line 170
        goto case_10;
      }
#line 174
      goto switch_default;
      case_0: /* CIL Label */ 
#line 129
      *p = (char )'l';
#line 130
      goto switch_break;
      case_1: /* CIL Label */ 
#line 133
      *p = (char )'s';
#line 134
      goto switch_break;
      case_2: /* CIL Label */ 
#line 137
      *p = (char )'o';
#line 138
      goto switch_break;
      case_3: /* CIL Label */ 
#line 141
      *p = (char )'d';
#line 142
      goto switch_break;
      case_4: /* CIL Label */ 
#line 145
      *p = (char )'i';
#line 146
      goto switch_break;
      case_5: /* CIL Label */ 
#line 149
      *p = (char )'c';
#line 150
      goto switch_break;
      case_6: /* CIL Label */ 
#line 153
      if (! is_mod) {
#line 154
        return ((SPF_errcode_t )12);
      }
#line 155
      *p = (char )'t';
#line 156
      goto switch_break;
      case_7: /* CIL Label */ 
#line 159
      *p = (char )'p';
#line 160
      goto switch_break;
      case_8: /* CIL Label */ 
#line 163
      *p = (char )'v';
#line 164
      goto switch_break;
      case_9: /* CIL Label */ 
#line 167
      *p = (char )'h';
#line 168
      goto switch_break;
      case_10: /* CIL Label */ 
#line 171
      *p = (char )'r';
#line 172
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 175
      return ((SPF_errcode_t )12);
#line 176
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 178
      if (data->dv.url_encode) {
        {
#line 179
        tmp___8 = toupper((int )*p);
#line 179
        *p = (char )tmp___8;
        }
      }
#line 180
      p ++;
#line 181
      if (p_end - p <= 0L) {
#line 181
        return ((SPF_errcode_t )10);
      }
#line 184
      if (data->dv.num_rhs) {
        {
#line 186
        tmp___9 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%d",
                           (int )data->dv.num_rhs);
#line 186
        len = (size_t )tmp___9;
#line 187
        p += len;
        }
#line 188
        if (p_end - p <= 0L) {
#line 188
          return ((SPF_errcode_t )10);
        }
      }
#line 192
      if (p_end - p <= 8L) {
#line 192
        return ((SPF_errcode_t )10);
      }
#line 193
      if (data->dv.rev) {
#line 194
        tmp___10 = p;
#line 194
        p ++;
#line 194
        *tmp___10 = (char )'r';
      }
#line 196
      if (data->dv.delim_dot) {
#line 196
        if (data->dv.delim_dash) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_plus) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_equal) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_bar) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        } else
#line 196
        if (data->dv.delim_under) {
#line 204
          tmp___11 = p;
#line 204
          p ++;
#line 204
          *tmp___11 = (char )'.';
        }
      }
#line 205
      if (data->dv.delim_dash) {
#line 206
        tmp___12 = p;
#line 206
        p ++;
#line 206
        *tmp___12 = (char )'-';
      }
#line 207
      if (data->dv.delim_plus) {
#line 208
        tmp___13 = p;
#line 208
        p ++;
#line 208
        *tmp___13 = (char )'+';
      }
#line 209
      if (data->dv.delim_equal) {
#line 210
        tmp___14 = p;
#line 210
        p ++;
#line 210
        *tmp___14 = (char )'=';
      }
#line 211
      if (data->dv.delim_bar) {
#line 212
        tmp___15 = p;
#line 212
        p ++;
#line 212
        *tmp___15 = (char )'|';
      }
#line 213
      if (data->dv.delim_under) {
#line 214
        tmp___16 = p;
#line 214
        p ++;
#line 214
        *tmp___16 = (char )'_';
      }
#line 216
      tmp___17 = p;
#line 216
      p ++;
#line 216
      *tmp___17 = (char )'}';
#line 217
      if (p_end - p <= 0L) {
#line 217
        return ((SPF_errcode_t )10);
      }
    }
    {
#line 73
    data = SPF_data_next(data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (cidr_data) {
#line 224
    if (cidr_data->dc.ipv4) {
      {
#line 226
      tmp___18 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"/%d",
                          (int )cidr_data->dc.ipv4);
#line 226
      len = (size_t )tmp___18;
#line 227
      p += len;
      }
#line 228
      if (p_end - p <= 0L) {
#line 228
        return ((SPF_errcode_t )10);
      }
    }
#line 231
    if (cidr_data->dc.ipv6) {
      {
#line 233
      tmp___19 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"//%d",
                          (int )cidr_data->dc.ipv6);
#line 233
      len = (size_t )tmp___19;
#line 234
      p += len;
      }
#line 235
      if (p_end - p <= 0L) {
#line 235
        return ((SPF_errcode_t )10);
      }
    }
  }
#line 239
  *p_p = p;
#line 240
  return ((SPF_errcode_t )0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
static SPF_errcode_t SPF_request_prepare___3(SPF_request_t *sr ) 
{ 


  {
#line 230
  if (sr->use_helo) {
#line 231
    sr->cur_dom = (char const   *)sr->helo_dom;
  } else {
#line 233
    sr->cur_dom = (char const   *)sr->env_from_dp;
  }
#line 234
  return ((SPF_errcode_t )0);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c"
static SPF_errcode_t SPF_request_query_record___3(SPF_request_t *spf_request , SPF_response_t *spf_response ,
                                                  SPF_record_t *spf_record , SPF_errcode_t err ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 246
  if ((unsigned int )err != 0U) {
#line 247
    if (spf_record) {
      {
#line 248
      SPF_record_free(spf_record);
      }
    }
#line 249
    return (err);
  }
  {
#line 252
  tmp___0 = SPF_response_errors(spf_response);
  }
#line 252
  if (tmp___0 > 0) {
    {
#line 253
    tmp = SPF_response_errors(spf_response);
#line 253
    SPF_infox("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_request.c",
              255, "Warning: %d errors in response, but no error code. Evaluating.",
              tmp);
    }
  }
  {
#line 257
  spf_response->spf_record_exp = spf_record;
#line 258
  err = SPF_record_interpret(spf_record, spf_request, spf_response, 0);
#line 260
  SPF_record_free(spf_record);
  }
#line 262
  return (err);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static char const   digits___3[11]  = 
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 63 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static char const   digitvalue___3[256]  = 
#line 63
  {      (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )0,      (char const   )1,      (char const   )2,      (char const   )3, 
        (char const   )4,      (char const   )5,      (char const   )6,      (char const   )7, 
        (char const   )8,      (char const   )9,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )13,      (char const   )14,      (char const   )15,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )13,      (char const   )14,      (char const   )15,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1};
#line 84
static int special___3(int ch ) ;
#line 85
static int printable___3(int ch ) ;
#line 86
static int dn_find___3(u_char const   *domain , u_char const   *msg , u_char const   * const  *dnptrs ,
                       u_char const   * const  *lastdnptr ) ;
#line 89
static int encode_bitsring___3(char const   **bp , char const   *end , char **labelp ,
                               char **dst , char const   *eom ) ;
#line 91
static int labellen___3(u_char const   *lp ) ;
#line 92
static int decode_bitstring___3(char const   **cpp , char *dn , char const   *eom ) ;
#line 693 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int special___3(int ch ) 
{ 


  {
  {
#line 704
  if (ch == 36) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 64) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 41) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 40) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 92) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 59) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 46) {
#line 704
    goto case_36;
  }
#line 704
  if (ch == 34) {
#line 704
    goto case_36;
  }
#line 706
  goto switch_default;
  case_36: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_34: /* CIL Label */ 
#line 705
  return (1);
  switch_default: /* CIL Label */ 
#line 707
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int printable___3(int ch ) 
{ 
  int tmp ;

  {
#line 720
  if (ch > 32) {
#line 720
    if (ch < 127) {
#line 720
      tmp = 1;
    } else {
#line 720
      tmp = 0;
    }
  } else {
#line 720
    tmp = 0;
  }
#line 720
  return (tmp);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int mklower___3(int ch ) 
{ 


  {
#line 729
  if (ch >= 65) {
#line 729
    if (ch <= 90) {
#line 730
      return (ch + 32);
    }
  }
#line 731
  return (ch);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int dn_find___3(u_char const   *domain , u_char const   *msg , u_char const   * const  *dnptrs ,
                       u_char const   * const  *lastdnptr ) 
{ 
  u_char const   *dn ;
  u_char const   *cp ;
  u_char const   *sp ;
  u_char const   * const  *cpp ;
  u_int n ;
  int tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  int tmp___2 ;
  u_char const   *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  u_char const   *tmp___6 ;
  int *tmp___7 ;

  {
#line 752
  cpp = dnptrs;
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! ((unsigned long )cpp < (unsigned long )lastdnptr)) {
#line 752
      goto while_break;
    }
#line 753
    sp = (u_char const   *)*cpp;
    {
#line 760
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 760
      if ((int const   )*sp != 0) {
#line 760
        if (((int const   )*sp & 192) == 0) {
#line 760
          if (! (sp - msg < 16384L)) {
#line 760
            goto while_break___0;
          }
        } else {
#line 760
          goto while_break___0;
        }
      } else {
#line 760
        goto while_break___0;
      }
#line 762
      dn = domain;
#line 763
      cp = sp;
      {
#line 764
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 764
        tmp___6 = cp;
#line 764
        cp ++;
#line 764
        n = (u_int )*tmp___6;
#line 764
        if (! (n != 0U)) {
#line 764
          goto while_break___1;
        }
        {
#line 769
        if ((n & 192U) == 0U) {
#line 769
          goto case_0;
        }
#line 785
        if ((n & 192U) == 192U) {
#line 785
          goto case_192;
        }
#line 789
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 770
        tmp = labellen___3(cp - 1);
#line 770
        n = (u_int )tmp;
#line 772
        tmp___0 = dn;
#line 772
        dn ++;
        }
#line 772
        if (n != (u_int )*tmp___0) {
#line 773
          goto next;
        }
        {
#line 775
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 775
          if (! (n > 0U)) {
#line 775
            goto while_break___2;
          }
          {
#line 776
          tmp___1 = dn;
#line 776
          dn ++;
#line 776
          tmp___2 = mklower___3((int )*tmp___1);
#line 776
          tmp___3 = cp;
#line 776
          cp ++;
#line 776
          tmp___4 = mklower___3((int )*tmp___3);
          }
#line 776
          if (tmp___2 != tmp___4) {
#line 778
            goto next;
          }
#line 775
          n --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 780
        if ((int const   )*dn == 0) {
#line 780
          if ((int const   )*cp == 0) {
#line 781
            return ((int )(sp - msg));
          }
        }
#line 782
        if (*dn) {
#line 783
          goto while_continue___1;
        }
#line 784
        goto next;
        case_192: /* CIL Label */ 
#line 786
        cp = msg + (((n & 63U) << 8) | (unsigned int )*cp);
#line 787
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 790
        tmp___5 = __errno_location();
#line 790
        *tmp___5 = 90;
        }
#line 791
        return (-1);
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      next: 
#line 795
      sp += (int const   )*sp + 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 752
    cpp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 798
  tmp___7 = __errno_location();
#line 798
  *tmp___7 = 2;
  }
#line 799
  return (-1);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int decode_bitstring___3(char const   **cpp , char *dn , char const   *eom ) 
{ 
  char const   *cp ;
  char *beg ;
  char tc ;
  int b ;
  int blen ;
  int plen ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 805
  cp = *cpp;
#line 806
  beg = dn;
#line 809
  blen = (int )((int const   )*cp & 255);
#line 809
  if (blen == 0) {
#line 810
    blen = 256;
  }
#line 811
  plen = (blen + 3) / 4;
#line 812
  if (blen > 99) {
#line 812
    tmp___0 = 3;
  } else {
#line 812
    if (blen > 9) {
#line 812
      tmp = 2;
    } else {
#line 812
      tmp = 1;
    }
#line 812
    tmp___0 = tmp;
  }
#line 812
  plen = (int )((unsigned long )plen + (sizeof("\\[x/]") + (unsigned long )tmp___0));
#line 813
  if ((unsigned long )(dn + plen) >= (unsigned long )eom) {
#line 814
    return (-1);
  }
  {
#line 816
  cp ++;
#line 817
  tmp___1 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"\\[x");
#line 817
  i = (int )((size_t )tmp___1);
  }
#line 818
  if (i < 0) {
#line 819
    return (-1);
  }
#line 820
  dn += i;
#line 821
  b = blen;
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! (b > 7)) {
#line 821
      goto while_break;
    }
    {
#line 822
    tmp___2 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%02x",
                      (int const   )*cp & 255);
#line 822
    i = (int )((size_t )tmp___2);
    }
#line 823
    if (i < 0) {
#line 824
      return (-1);
    }
#line 825
    dn += i;
#line 821
    b -= 8;
#line 821
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 827
  if (b > 4) {
    {
#line 828
    tmp___3 = cp;
#line 828
    cp ++;
#line 828
    tc = (char )*tmp___3;
#line 829
    tmp___4 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%02x",
                      (int )tc & (255 << (8 - b)));
#line 829
    i = (int )((size_t )tmp___4);
    }
#line 830
    if (i < 0) {
#line 831
      return (-1);
    }
#line 832
    dn += i;
  } else
#line 833
  if (b > 0) {
    {
#line 834
    tmp___5 = cp;
#line 834
    cp ++;
#line 834
    tc = (char )*tmp___5;
#line 835
    tmp___6 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"%1x",
                      (((int )tc >> 4) & 15) & (15 << (4 - b)));
#line 835
    i = (int )((size_t )tmp___6);
    }
#line 837
    if (i < 0) {
#line 838
      return (-1);
    }
#line 839
    dn += i;
  }
  {
#line 841
  tmp___7 = sprintf((char */* __restrict  */)dn, (char const   */* __restrict  */)"/%d]",
                    blen);
#line 841
  i = (int )((size_t )tmp___7);
  }
#line 842
  if (i < 0) {
#line 843
    return (-1);
  }
#line 844
  dn += i;
#line 846
  *cpp = cp;
#line 847
  return ((int )(dn - beg));
}
}
#line 850 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int encode_bitsring___3(char const   **bp , char const   *end , char **labelp ,
                               char **dst , char const   *eom ) 
{ 
  int afterslash ;
  char const   *cp ;
  char *tp ;
  char c ;
  char const   *beg_blen ;
  char *end_blen ;
  int value ;
  int count ;
  int tbcount ;
  int blen ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  int traillen ;

  {
#line 854
  afterslash = 0;
#line 855
  cp = *bp;
#line 858
  end_blen = (char *)((void *)0);
#line 859
  value = 0;
#line 859
  count = 0;
#line 859
  tbcount = 0;
#line 859
  blen = 0;
#line 861
  end_blen = (char *)((void *)0);
#line 861
  beg_blen = (char const   *)end_blen;
#line 864
  if (end - cp < 2L) {
#line 865
    return (22);
  }
#line 868
  tmp = cp;
#line 868
  cp ++;
#line 868
  if ((int const   )*tmp != 120) {
#line 869
    return (22);
  }
  {
#line 870
  tmp___0 = __ctype_b_loc();
  }
#line 870
  if (! ((int const   )*(*tmp___0 + (int )((int const   )*cp & 255)) & 4096)) {
#line 871
    return (22);
  }
#line 873
  tp = *dst + 1;
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    if ((unsigned long )cp < (unsigned long )end) {
#line 873
      if (! ((unsigned long )tp < (unsigned long )eom)) {
#line 873
        goto while_break;
      }
    } else {
#line 873
      goto while_break;
    }
#line 874
    c = (char )*cp;
    {
#line 875
    if ((int )c == 93) {
#line 875
      goto case_93;
    }
#line 887
    if ((int )c == 47) {
#line 887
      goto case_47;
    }
#line 890
    goto switch_default;
    case_93: /* CIL Label */ 
#line 876
    if (afterslash) {
#line 877
      if ((unsigned long )beg_blen == (unsigned long )((void *)0)) {
#line 878
        return (22);
      }
      {
#line 879
      tmp___1 = strtol((char const   */* __restrict  */)beg_blen, (char **/* __restrict  */)(& end_blen),
                       10);
#line 879
      blen = (int )tmp___1;
      }
#line 880
      if ((int )*end_blen != 93) {
#line 881
        return (22);
      }
    }
#line 883
    if (count) {
#line 884
      tmp___2 = tp;
#line 884
      tp ++;
#line 884
      *tmp___2 = (char )((value << 4) & 255);
    }
#line 885
    cp ++;
#line 886
    goto done;
    case_47: /* CIL Label */ 
#line 888
    afterslash = 1;
#line 889
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 891
    if (afterslash) {
      {
#line 892
      tmp___3 = __ctype_b_loc();
      }
#line 892
      if (! ((int const   )*(*tmp___3 + ((int )c & 255)) & 2048)) {
#line 893
        return (22);
      }
#line 894
      if ((unsigned long )beg_blen == (unsigned long )((void *)0)) {
#line 896
        if ((int )c == 48) {
#line 898
          return (22);
        }
#line 900
        beg_blen = cp;
      }
    } else {
      {
#line 903
      tmp___4 = __ctype_b_loc();
      }
#line 903
      if (! ((int const   )*(*tmp___4 + ((int )c & 255)) & 4096)) {
#line 904
        return (22);
      }
#line 905
      value <<= 4;
#line 906
      value += (int )digitvalue___3[(int )c];
#line 907
      count += 4;
#line 908
      tbcount += 4;
#line 909
      if (tbcount > 256) {
#line 910
        return (22);
      }
#line 911
      if (count == 8) {
#line 912
        tmp___5 = tp;
#line 912
        tp ++;
#line 912
        *tmp___5 = (char )value;
#line 913
        count = 0;
      }
    }
#line 916
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 873
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 920
  if ((unsigned long )cp >= (unsigned long )end) {
#line 921
    return (90);
  } else
#line 920
  if ((unsigned long )tp >= (unsigned long )eom) {
#line 921
    return (90);
  }
#line 931
  if (blen > 0) {
#line 934
    if (((blen + 3) & -4) != tbcount) {
#line 935
      return (22);
    }
#line 936
    traillen = tbcount - blen;
#line 937
    if (((value << (8 - traillen)) & 255) != 0) {
#line 938
      return (22);
    }
  } else {
#line 941
    blen = tbcount;
  }
#line 942
  if (blen == 256) {
#line 943
    blen = 0;
  }
#line 946
  *(*labelp) = (char)65;
#line 947
  *(*dst) = (char )blen;
#line 949
  *bp = cp;
#line 950
  *dst = tp;
#line 952
  return (0);
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_name_uncompress.c"
static int labellen___3(u_char const   *lp ) 
{ 
  int bitlen ;
  u_char l ;

  {
#line 959
  l = (u_char )*lp;
#line 961
  if (((int )l & 192) == 192) {
#line 963
    return (-1);
  }
#line 966
  if (((int )l & 192) == 64) {
#line 967
    if ((int )l == 65) {
#line 968
      bitlen = (int )*(lp + 1);
#line 968
      if (bitlen == 0) {
#line 969
        bitlen = 256;
      }
#line 970
      return ((bitlen + 7) / 8 + 1);
    }
#line 972
    return (-1);
  }
#line 974
  return ((int )l);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv4___7[8]  = 
#line 60 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
  {      (char const   )'i',      (char const   )'n',      (char const   )'-',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_expand.c"
static char const   client_ver_ipv6___7[4]  = {      (char const   )'i',      (char const   )'p',      (char const   )'6',      (char const   )'\000'};
#line 238 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_cache_bucket_t *SPF_dns_cache_bucket_find___7(SPF_dns_cache_config_t *spfhook ,
                                                             char const   *domain ,
                                                             ns_type rr_type , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  SPF_dns_rr_t *rr ;
  time_t now ;
  int tmp ;

  {
  {
#line 247
  bucket = *(spfhook->cache + idx);
#line 248
  prev = (SPF_dns_cache_bucket_t *)((void *)0);
#line 249
  time(& now);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
#line 252
    rr = bucket->rr;
#line 254
    if (rr->utc_ttl < now) {
#line 256
      if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 257
        prev->next = bucket->next;
      } else {
#line 259
        *(spfhook->cache + idx) = bucket->next;
      }
#line 261
      if (bucket->rr) {
        {
#line 262
        SPF_dns_rr_free(bucket->rr);
        }
      }
      {
#line 263
      free((void *)bucket);
#line 265
      bucket = prev;
      }
    } else
#line 267
    if (! ((unsigned int )rr->rr_type != (unsigned int )rr_type)) {
      {
#line 270
      tmp = strcmp((char const   *)rr->domain, domain);
      }
#line 270
      if (! (tmp != 0)) {
#line 275
        if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 276
          prev->next = bucket->next;
#line 277
          bucket->next = *(spfhook->cache + idx);
#line 278
          *(spfhook->cache + idx) = bucket;
        }
#line 280
        return (bucket);
      }
    }
#line 283
    prev = bucket;
#line 284
    if ((unsigned long )bucket == (unsigned long )((void *)0)) {
#line 285
      bucket = *(spfhook->cache + idx);
    } else {
#line 287
      bucket = bucket->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return ((SPF_dns_cache_bucket_t *)((void *)0));
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_bucket_add___7(SPF_dns_cache_config_t *spfhook ,
                                                  SPF_dns_rr_t *rr , int idx ) 
{ 
  SPF_dns_cache_bucket_t *bucket ;
  void *tmp ;

  {
  {
#line 300
  tmp = malloc(sizeof(SPF_dns_cache_bucket_t ));
#line 300
  bucket = (SPF_dns_cache_bucket_t *)tmp;
  }
#line 302
  if (! bucket) {
#line 303
    return ((SPF_errcode_t )1);
  }
#line 304
  bucket->next = *(spfhook->cache + idx);
#line 305
  *(spfhook->cache + idx) = bucket;
#line 306
  bucket->rr = rr;
#line 307
  return ((SPF_errcode_t )0);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_errcode_t SPF_dns_cache_rr_fixup___7(SPF_dns_cache_config_t *spfhook ,
                                                SPF_dns_rr_t *cached_rr , char const   *domain ,
                                                ns_type rr_type ) 
{ 
  char *p ;
  char *new_domain ;
  size_t new_len ;
  size_t tmp ;
  void *tmp___0 ;
  time_t tmp___1 ;

  {
#line 322
  if ((unsigned int )cached_rr->rr_type == 255U) {
#line 323
    cached_rr->rr_type = rr_type;
  }
#line 326
  if ((unsigned long )cached_rr->domain == (unsigned long )((void *)0)) {
#line 326
    goto _L;
  } else
#line 326
  if ((int )*(cached_rr->domain + 0) != 0) {
    _L: /* CIL Label */ 
    {
#line 328
    tmp = strlen(domain);
#line 328
    new_len = tmp + 1UL;
    }
#line 330
    if (cached_rr->domain_buf_len < new_len) {
      {
#line 331
      tmp___0 = realloc((void *)cached_rr->domain, new_len);
#line 331
      new_domain = (char *)tmp___0;
      }
#line 332
      if ((unsigned long )new_domain == (unsigned long )((void *)0)) {
#line 333
        return ((SPF_errcode_t )1);
      }
#line 334
      cached_rr->domain = new_domain;
#line 335
      cached_rr->domain_buf_len = new_len;
    }
    {
#line 337
    strcpy((char */* __restrict  */)cached_rr->domain, (char const   */* __restrict  */)domain);
    }
  }
#line 341
  if (cached_rr->ttl < spfhook->min_ttl) {
#line 342
    cached_rr->ttl = spfhook->min_ttl;
  }
#line 344
  if (cached_rr->ttl < spfhook->txt_ttl) {
#line 344
    if ((unsigned int )cached_rr->rr_type == 16U) {
#line 346
      cached_rr->ttl = spfhook->txt_ttl;
    }
  }
#line 348
  if (cached_rr->ttl < spfhook->err_ttl) {
#line 348
    if (cached_rr->herrno != 0) {
#line 350
      cached_rr->ttl = spfhook->err_ttl;
    }
  }
#line 352
  if (cached_rr->ttl < spfhook->rdns_ttl) {
    {
#line 353
    p = strstr((char const   *)cached_rr->domain, ".arpa");
    }
#line 354
    if (p) {
#line 354
      if ((int )*(p + (sizeof(".arpa") - 1UL)) == 0) {
#line 355
        cached_rr->ttl = spfhook->rdns_ttl;
      }
    }
  }
  {
#line 358
  tmp___1 = time((time_t *)((void *)0));
#line 358
  cached_rr->utc_ttl = cached_rr->ttl + tmp___1;
  }
#line 360
  return ((SPF_errcode_t )0);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static SPF_dns_rr_t *SPF_dns_cache_lookup___7(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                              ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_rr_t *cached_rr ;
  SPF_dns_rr_t *rr ;
  int idx ;
  SPF_errcode_t tmp ;
  SPF_dns_rr_t *tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;

  {
  {
#line 377
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
#line 381
  idx = crc32str(0U, domain, spfhook->max_hash_len);
#line 382
  idx &= spfhook->cache_size - 1;
#line 384
  pthread_mutex_lock(& spfhook->cache_lock);
#line 386
  bucket = SPF_dns_cache_bucket_find___7(spfhook, domain, rr_type, idx);
  }
#line 387
  if ((unsigned long )bucket != (unsigned long )((void *)0)) {
#line 388
    if ((unsigned long )bucket->rr != (unsigned long )((void *)0)) {
      {
#line 389
      tmp = SPF_dns_rr_dup(& rr, bucket->rr);
      }
#line 389
      if ((unsigned int )tmp == 0U) {
        {
#line 390
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 391
        return (rr);
      } else
#line 393
      if ((unsigned long )rr != (unsigned long )((void *)0)) {
        {
#line 394
        SPF_dns_rr_free(rr);
        }
      }
    }
  }
  {
#line 401
  bucket = (SPF_dns_cache_bucket_t *)((void *)0);
#line 403
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 405
  if (! spf_dns_server->layer_below) {
    {
#line 406
    tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
    }
#line 406
    return (tmp___0);
  }
  {
#line 408
  rr = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
  }
#line 410
  if (spfhook->conserve_cache) {
#line 410
    if (! should_cache) {
#line 411
      return (rr);
    }
  }
  {
#line 413
  pthread_mutex_lock(& spfhook->cache_lock);
#line 415
  tmp___3 = SPF_dns_rr_dup(& cached_rr, rr);
  }
#line 415
  if ((unsigned int )tmp___3 == 0U) {
    {
#line 416
    tmp___2 = SPF_dns_cache_rr_fixup___7(spfhook, cached_rr, domain, rr_type);
    }
#line 416
    if ((unsigned int )tmp___2 == 0U) {
      {
#line 417
      tmp___1 = SPF_dns_cache_bucket_add___7(spfhook, cached_rr, idx);
      }
#line 417
      if ((unsigned int )tmp___1 == 0U) {
        {
#line 418
        pthread_mutex_unlock(& spfhook->cache_lock);
        }
#line 419
        return (rr);
      }
    }
  }
  {
#line 424
  pthread_mutex_unlock(& spfhook->cache_lock);
  }
#line 426
  if (cached_rr) {
    {
#line 427
    SPF_dns_rr_free(cached_rr);
    }
  }
#line 429
  return (rr);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c"
static void SPF_dns_cache_free___7(SPF_dns_server_t *spf_dns_server ) 
{ 
  SPF_dns_cache_config_t *spfhook ;
  SPF_dns_cache_bucket_t *bucket ;
  SPF_dns_cache_bucket_t *prev ;
  int i ;

  {
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 442
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_cache.c",
                 442, "%s", "spf_dns_server is NULL");
      }
    }
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  spfhook = SPF_voidp2spfhook___0(spf_dns_server->hook);
  }
#line 445
  if (spfhook) {
    {
#line 446
    pthread_mutex_lock(& spfhook->cache_lock);
    }
#line 448
    if (spfhook->cache) {
#line 449
      i = 0;
      {
#line 449
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 449
        if (! (i < spfhook->cache_size)) {
#line 449
          goto while_break___0;
        }
#line 450
        bucket = *(spfhook->cache + i);
        {
#line 451
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 451
          if (! ((unsigned long )bucket != (unsigned long )((void *)0))) {
#line 451
            goto while_break___1;
          }
#line 452
          prev = bucket;
#line 453
          bucket = bucket->next;
#line 456
          if (prev->rr) {
            {
#line 457
            SPF_dns_rr_free(prev->rr);
            }
          }
          {
#line 458
          free((void *)prev);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 449
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 461
      free((void *)spfhook->cache);
#line 462
      spfhook->cache = (SPF_dns_cache_bucket_t **)((void *)0);
      }
    }
    {
#line 465
    pthread_mutex_unlock(& spfhook->cache_lock);
#line 476
    pthread_mutex_destroy(& spfhook->cache_lock);
#line 478
    free((void *)spfhook);
    }
  }
  {
#line 481
  free((void *)spf_dns_server);
  }
#line 482
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_pre___7(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                  ns_type rr_type , int should_cache ) 
{ 
  char const   *tmp ;

  {
#line 51
  if (spf_dns_server->debug) {
    {
#line 52
    tmp = SPF_strrrtype(rr_type);
#line 52
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               54, "DNS[%s] lookup: %s %s (%d)", spf_dns_server->name, domain, tmp,
               (unsigned int )rr_type);
    }
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c"
static void SPF_dns_debug_post___7(SPF_dns_server_t *spf_dns_server , SPF_dns_rr_t *spfrr ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 61
  if (spf_dns_server->debug) {
    {
#line 66
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               66, "DNS[%s] found record", spf_dns_server->name);
#line 67
    tmp = SPF_strrrtype(spfrr->rr_type);
#line 67
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               69, "    DOMAIN: %s  TYPE: %s (%d)", spfrr->domain, tmp, (unsigned int )spfrr->rr_type);
    }
#line 70
    if (spfrr->source) {
#line 70
      if ((spfrr->source)->name) {
#line 70
        tmp___0 = (spfrr->source)->name;
      } else {
#line 70
        tmp___0 = "(unnamed source)";
      }
#line 70
      tmp___1 = tmp___0;
    } else {
#line 70
      tmp___1 = "(null source)";
    }
    {
#line 70
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
               76, "    TTL: %ld  RR found: %d  herrno: %d  source: %s", spfrr->ttl,
               spfrr->num_rr, spfrr->herrno, tmp___1);
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! (i < spfrr->num_rr)) {
#line 77
        goto while_break;
      }
      {
#line 79
      if ((unsigned int )spfrr->rr_type == 1U) {
#line 79
        goto case_1;
      }
#line 85
      if ((unsigned int )spfrr->rr_type == 12U) {
#line 85
        goto case_12;
      }
#line 89
      if ((unsigned int )spfrr->rr_type == 15U) {
#line 89
        goto case_15;
      }
#line 93
      if ((unsigned int )spfrr->rr_type == 16U) {
#line 93
        goto case_16;
      }
#line 97
      if ((unsigned int )spfrr->rr_type == 99U) {
#line 97
        goto case_99;
      }
#line 101
      if ((unsigned int )spfrr->rr_type == 28U) {
#line 101
        goto case_28;
      }
#line 107
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 80
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->a),
                          (char */* __restrict  */)(ip4_buf), (socklen_t )sizeof(ip4_buf));
#line 80
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 82, "    - A: %s", tmp___2);
      }
#line 83
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 86
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 86, "    - PTR: %s", (*(spfrr->rr + i))->ptr);
      }
#line 87
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 90
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 90, "    - MX: %s", (*(spfrr->rr + i))->mx);
      }
#line 91
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 94
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 94, "    - TXT: %s", (*(spfrr->rr + i))->txt);
      }
#line 95
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 98
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 98, "    - SPF: %s", (*(spfrr->rr + i))->txt);
      }
#line 99
      goto switch_break;
      case_28: /* CIL Label */ 
      {
#line 102
      tmp___3 = inet_ntop(10, (void const   */* __restrict  */)(& (*(spfrr->rr + i))->aaaa),
                          (char */* __restrict  */)(ip6_buf), (socklen_t )sizeof(ip6_buf));
#line 102
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 104, "    - AAAA: %s", tmp___3);
      }
#line 105
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 108
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns.c",
                 108, "    - Unknown RR type");
      }
#line 109
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 77
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 113
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static SPF_dns_rr_t *SPF_dns_null_lookup___7(SPF_dns_server_t *spf_dns_server , char const   *domain ,
                                             ns_type rr_type , int should_cache ) 
{ 
  SPF_dns_rr_t *tmp ;
  SPF_dns_rr_t *tmp___0 ;

  {
#line 45
  if (spf_dns_server->layer_below) {
    {
#line 46
    tmp = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    }
#line 46
    return (tmp);
  }
  {
#line 48
  tmp___0 = SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
  }
#line 48
  return (tmp___0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c"
static void SPF_dns_null_free___7(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 54
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_null.c",
                 54, "%s", "spf_dns_server is NULL");
      }
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  free((void *)spf_dns_server);
  }
#line 56
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c"
static SPF_errcode_t SPF_record_find_mod_data___3(SPF_record_t *spf_record , char const   *mod_name ,
                                                  SPF_data_t **datap , size_t *datalenp ) 
{ 
  SPF_mod_t *mod ;
  size_t name_len ;
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 89
  name_len = strlen(mod_name);
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 94, "%s", "spf_record is NULL");
      }
    }
#line 94
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if ((unsigned long )mod_name == (unsigned long )((void *)0)) {
      {
#line 95
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 95, "%s", "mod_name is NULL");
      }
    }
#line 95
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )datap == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 96, "%s", "datap is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 97
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 97
    if ((unsigned long )datalenp == (unsigned long )((void *)0)) {
      {
#line 97
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_record.c",
                 97, "%s", "datalenp is NULL");
      }
    }
#line 97
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 103
  mod = spf_record->mod_first;
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 104
    if (! (i < (int )spf_record->num_mod)) {
#line 104
      goto while_break___3;
    }
#line 105
    if (name_len == (size_t )mod->name_len) {
      {
#line 105
      tmp = SPF_mod_name(mod);
#line 105
      tmp___0 = strncasecmp((char const   *)tmp, mod_name, name_len);
      }
#line 105
      if (tmp___0 == 0) {
        {
#line 108
        *datap = SPF_mod_data(mod);
#line 109
        *datalenp = (size_t )mod->data_len;
        }
#line 111
        return ((SPF_errcode_t )0);
      }
    }
    {
#line 114
    mod = SPF_mod_next(mod);
#line 104
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 117
  return ((SPF_errcode_t )24);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_explanation___7(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_record_t *spf_record ;
  SPF_errcode_t err ;
  char *buf ;
  size_t buflen ;
  void *tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 53
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 53, "%s", "spf_response is NULL");
      }
    }
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  spf_request = spf_response->spf_request;
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 55
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 55, "%s", "spf_request is NULL");
      }
    }
#line 55
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  spf_server___1 = spf_request->spf_server;
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 57
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 57
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 57, "%s", "spf_server is NULL");
      }
    }
#line 57
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  spf_record = spf_response->spf_record_exp;
  {
#line 60
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 60
    if ((unsigned long )spf_record == (unsigned long )((void *)0)) {
      {
#line 60
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 60, "%s", "spf_record is NULL");
      }
    }
#line 60
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 62
  if (spf_response->explanation) {
    {
#line 63
    free((void *)spf_response->explanation);
    }
  }
  {
#line 64
  spf_response->explanation = (char *)((void *)0);
#line 66
  buflen = (size_t )321;
#line 67
  tmp = malloc(buflen);
#line 67
  buf = (char *)tmp;
  }
#line 68
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 69
    return ((SPF_errcode_t )1);
  }
  {
#line 70
  memset((void *)buf, '\000', buflen);
#line 72
  err = SPF_request_get_exp(spf_server___1, spf_request, spf_response, spf_record,
                            & buf, & buflen);
  }
#line 74
  if ((unsigned int )err != 0U) {
    {
#line 75
    free((void *)buf);
    }
#line 76
    return (err);
  }
#line 79
  spf_response->explanation = buf;
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_smtp_comment___7(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  SPF_errcode_t err ;
  char buf[320] ;
  char const   *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 92
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 92, "%s", "spf_response is NULL");
      }
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  spf_request = spf_response->spf_request;
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 94
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 94, "%s", "spf_request is NULL");
      }
    }
#line 94
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  spf_server___1 = spf_request->spf_server;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 96
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 96, "%s", "spf_server is NULL");
      }
    }
#line 96
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  if (spf_response->smtp_comment) {
    {
#line 99
    free((void *)spf_response->smtp_comment);
    }
  }
#line 100
  spf_response->smtp_comment = (char *)((void *)0);
  {
#line 107
  if ((unsigned int )spf_response->result == 5U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 1U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 4U) {
#line 107
    goto case_5;
  }
#line 107
  if ((unsigned int )spf_response->result == 3U) {
#line 107
    goto case_5;
  }
#line 129
  goto switch_default;
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 109
  err = SPF_i_set_explanation___7(spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
#line 111
    return (err);
  }
  {
#line 113
  memset((void *)(buf), '\000', sizeof(buf));
#line 114
  tmp = SPF_strreason(spf_response->reason);
#line 114
  snprintf((char */* __restrict  */)(buf), (size_t )320, (char const   */* __restrict  */)"%s : Reason: %s",
           spf_response->explanation, tmp);
#line 117
  buf[319] = (char )'\000';
#line 120
  spf_response->smtp_comment = strdup((char const   *)(buf));
  }
#line 121
  if (! spf_response->smtp_comment) {
#line 122
    return ((SPF_errcode_t )1);
  }
#line 124
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 130
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 133
  return ((SPF_errcode_t )0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_header_comment___7(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char *spf_source ;
  size_t len ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  char *sender_dom ;
  char *p ;
  char *p_end ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 153
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 153, "%s", "spf_response is NULL");
      }
    }
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  spf_request = spf_response->spf_request;
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 155
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 155, "%s", "spf_request is NULL");
      }
    }
#line 155
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 156
  spf_server___1 = spf_request->spf_server;
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 157
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 157, "%s", "spf_server is NULL");
      }
    }
#line 157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 159
  if (spf_response->header_comment) {
    {
#line 160
    free((void *)spf_response->header_comment);
    }
  }
#line 161
  spf_response->header_comment = (char *)((void *)0);
#line 164
  sender_dom = spf_request->env_from_dp;
#line 165
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
#line 166
    sender_dom = spf_request->helo_dom;
  }
#line 168
  if ((unsigned int )spf_response->reason == 3U) {
    {
#line 169
    spf_source = strdup("local policy");
    }
  } else
#line 171
  if ((unsigned int )spf_response->reason == 6U) {
#line 172
    if ((unsigned long )spf_request->rcpt_to_dom == (unsigned long )((void *)0)) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    } else
#line 172
    if ((int )*(spf_request->rcpt_to_dom + 0) == 0) {
      {
#line 173
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 173, "%s", "RCPT TO domain is NULL");
      }
    }
    {
#line 175
    spf_source = strdup((char const   *)spf_request->rcpt_to_dom);
    }
  } else
#line 177
  if ((unsigned long )sender_dom == (unsigned long )((void *)0)) {
    {
#line 178
    spf_source = strdup("unknown domain");
    }
  } else {
    {
#line 181
    tmp = strlen((char const   *)sender_dom);
#line 181
    len = tmp + sizeof("domain of ");
#line 182
    tmp___0 = malloc(len);
#line 182
    spf_source = (char *)tmp___0;
    }
#line 183
    if (spf_source) {
      {
#line 184
      snprintf((char */* __restrict  */)spf_source, len, (char const   */* __restrict  */)"domain of %s",
               sender_dom);
      }
    }
  }
#line 187
  if ((unsigned long )spf_source == (unsigned long )((void *)0)) {
#line 188
    return ((SPF_errcode_t )10);
  }
#line 190
  ip = (char const   *)((void *)0);
#line 191
  if (spf_request->client_ver == 2) {
    {
#line 192
    ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                   (socklen_t )sizeof(ip4_buf));
    }
  } else
#line 195
  if (spf_request->client_ver == 10) {
    {
#line 196
    ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                   (socklen_t )sizeof(ip6_buf));
    }
  }
#line 199
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 200
    ip = "(unknown ip address)";
  }
  {
#line 202
  tmp___1 = SPF_request_get_rec_dom(spf_request);
#line 202
  tmp___2 = strlen(tmp___1);
#line 202
  tmp___3 = strlen((char const   *)spf_source);
#line 202
  tmp___4 = strlen(ip);
#line 202
  len = ((tmp___2 + tmp___3) + tmp___4) + 80UL;
#line 203
  tmp___5 = malloc(len);
#line 203
  buf = (char *)tmp___5;
  }
#line 204
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 205
    free((void *)spf_source);
    }
#line 206
    return ((SPF_errcode_t )10);
  }
  {
#line 209
  p = buf;
#line 210
  p_end = p + len;
#line 213
  tmp___6 = SPF_request_get_rec_dom(spf_request);
#line 213
  tmp___7 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s: ",
                     tmp___6);
#line 213
  p += tmp___7;
  }
  {
#line 217
  if ((unsigned int )spf_response->result == 2U) {
#line 217
    goto case_2;
  }
#line 228
  if ((unsigned int )spf_response->result == 3U) {
#line 228
    goto case_3;
  }
#line 233
  if ((unsigned int )spf_response->result == 4U) {
#line 233
    goto case_4;
  }
#line 238
  if ((unsigned int )spf_response->result == 7U) {
#line 238
    goto case_7;
  }
#line 243
  if ((unsigned int )spf_response->result == 1U) {
#line 243
    goto case_1;
  }
#line 247
  if ((unsigned int )spf_response->result == 5U) {
#line 247
    goto case_5;
  }
#line 252
  if ((unsigned int )spf_response->result == 6U) {
#line 252
    goto case_6;
  }
#line 258
  goto switch_default;
  case_2: /* CIL Label */ 
#line 218
  if ((unsigned int )spf_response->reason == 2U) {
    {
#line 219
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"localhost is always allowed.");
    }
  } else
#line 220
  if ((unsigned int )spf_response->reason == 6U) {
    {
#line 221
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"message received from %s which is an MX secondary for %s.",
             ip, spf_source);
    }
  } else {
    {
#line 224
    snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s designates %s as permitted sender",
             spf_source, ip);
    }
  }
#line 226
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 229
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 231
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 234
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"transitioning %s does not designate %s as permitted sender",
           spf_source, ip);
  }
#line 236
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 239
  tmp___8 = SPF_strerror(spf_response->err);
#line 239
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error in processing during lookup of %s: %s",
           spf_source, tmp___8);
  }
#line 241
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 244
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s is neither permitted nor denied by %s",
           ip, spf_source);
  }
#line 246
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 248
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s does not provide an SPF record",
           spf_source);
  }
#line 250
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 253
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"encountered temporary error during SPF processing of %s",
           spf_source);
  }
#line 255
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 259
  snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"error: unknown SPF result %d encountered while checking %s for %s",
           (unsigned int )spf_response->result, ip, spf_source);
  }
#line 261
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 264
  if (spf_source) {
    {
#line 265
    free((void *)spf_source);
    }
  }
  {
#line 267
  spf_response->header_comment = SPF_sanitize(spf_server___1, buf);
  }
#line 269
  return ((SPF_errcode_t )0);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static SPF_errcode_t SPF_i_set_received_spf___7(SPF_response_t *spf_response ) 
{ 
  SPF_server_t *spf_server___1 ;
  SPF_request_t *spf_request ;
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char const   *ip ;
  char *buf ;
  size_t buflen ;
  char *buf_value ;
  char *p ;
  char *p_end ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 282
  buflen = (size_t )480;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if ((unsigned long )spf_response == (unsigned long )((void *)0)) {
      {
#line 287
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 287, "%s", "spf_response is NULL");
      }
    }
#line 287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  spf_request = spf_response->spf_request;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if ((unsigned long )spf_request == (unsigned long )((void *)0)) {
      {
#line 289
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 289, "%s", "spf_request is NULL");
      }
    }
#line 289
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  spf_server___1 = spf_request->spf_server;
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 291
    if ((unsigned long )spf_server___1 == (unsigned long )((void *)0)) {
      {
#line 291
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 291, "%s", "spf_server is NULL");
      }
    }
#line 291
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 293
  if (spf_response->received_spf) {
    {
#line 294
    free((void *)spf_response->received_spf);
    }
  }
  {
#line 295
  spf_response->received_spf = (char *)((void *)0);
#line 297
  tmp = malloc(buflen);
#line 297
  buf = (char *)tmp;
  }
#line 298
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 299
    return ((SPF_errcode_t )10);
  }
  {
#line 301
  p = buf;
#line 302
  p_end = p + buflen;
#line 306
  tmp___0 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"Received-SPF: ");
#line 306
  p += tmp___0;
#line 307
  buf_value = p;
  }
  {
#line 309
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 310
    tmp___1 = SPF_strresult(spf_response->result);
#line 310
    tmp___2 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)"%s (%s)",
                       tmp___1, spf_response->header_comment);
#line 310
    p += tmp___2;
    }
#line 313
    if (p_end - p <= 0L) {
#line 313
      goto while_break___2;
    }
#line 318
    ip = (char const   *)((void *)0);
#line 319
    if (spf_request->client_ver == 2) {
      {
#line 320
      ip = inet_ntop(2, (void const   */* __restrict  */)(& spf_request->ipv4), (char */* __restrict  */)(ip4_buf),
                     (socklen_t )sizeof(ip4_buf));
      }
    } else
#line 323
    if (spf_request->client_ver == 10) {
      {
#line 324
      ip = inet_ntop(10, (void const   */* __restrict  */)(& spf_request->ipv6), (char */* __restrict  */)(ip6_buf),
                     (socklen_t )sizeof(ip6_buf));
      }
    }
#line 328
    if ((unsigned long )ip != (unsigned long )((void *)0)) {
      {
#line 329
      tmp___3 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" client-ip=%s;",
                         ip);
#line 329
      p += tmp___3;
      }
#line 330
      if (p_end - p <= 0L) {
#line 330
        goto while_break___2;
      }
    }
#line 335
    if ((unsigned long )spf_request->env_from != (unsigned long )((void *)0)) {
      {
#line 336
      tmp___4 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" envelope-from=%s;",
                         spf_request->env_from);
#line 336
      p += tmp___4;
      }
#line 337
      if (p_end - p <= 0L) {
#line 337
        goto while_break___2;
      }
    }
#line 342
    if ((unsigned long )spf_request->helo_dom != (unsigned long )((void *)0)) {
      {
#line 343
      tmp___5 = snprintf((char */* __restrict  */)p, (size_t )(p_end - p), (char const   */* __restrict  */)" helo=%s;",
                         spf_request->helo_dom);
#line 343
      p += tmp___5;
      }
#line 344
      if (p_end - p <= 0L) {
#line 344
        goto while_break___2;
      }
    }
#line 309
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 366
  spf_response->received_spf = SPF_sanitize(spf_server___1, buf);
#line 367
  spf_response->received_spf_value = buf_value;
  }
#line 369
  return ((SPF_errcode_t )0);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_mech_cidr___7(SPF_request_t *spf_request , SPF_mech_t *mech ) 
{ 
  SPF_data_t *data ;
  SPF_data_t *tmp ;

  {
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if ((unsigned long )mech == (unsigned long )((void *)0)) {
      {
#line 428
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
                 428, "%s", "mech is NULL");
      }
    }
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  if ((int )mech->mech_type == 6) {
#line 433
    goto case_6;
  }
#line 433
  if ((int )mech->mech_type == 5) {
#line 433
    goto case_6;
  }
#line 438
  if ((int )mech->mech_type == 2) {
#line 438
    goto case_2;
  }
#line 438
  if ((int )mech->mech_type == 1) {
#line 438
    goto case_2;
  }
#line 430
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 434
  return ((int )mech->mech_len);
#line 435
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 439
  data = SPF_mech_data(mech);
#line 441
  tmp = SPF_mech_end_data(mech);
  }
#line 441
  if ((unsigned long )data < (unsigned long )tmp) {
#line 441
    if ((int )data->dc.parm_type == 11) {
#line 444
      if (spf_request->client_ver == 2) {
#line 445
        return ((int )data->dc.ipv4);
      } else
#line 446
      if (spf_request->client_ver == 10) {
#line 447
        return ((int )data->dc.ipv6);
      }
    }
  }
#line 449
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 452
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip4___7(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in_addr ipv4 ) 
{ 
  char src_ip4_buf[16] ;
  char dst_ip4_buf[16] ;
  char mask_ip4_buf[16] ;
  struct in_addr src_ipv4 ;
  int cidr ;
  int mask ;
  uint32_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 471
  if (spf_request->client_ver != 2) {
#line 472
    return (0);
  }
  {
#line 474
  src_ipv4 = spf_request->ipv4;
#line 476
  cidr = SPF_i_mech_cidr___7(spf_request, mech);
  }
#line 477
  if (cidr == 0) {
#line 478
    cidr = 32;
  }
  {
#line 479
  mask = (int )(4294967295U << (32 - cidr));
#line 480
  tmp = htonl((uint32_t )mask);
#line 480
  mask = (int )tmp;
  }
#line 482
  if (spf_server___1->debug) {
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 483
      tmp___0 = inet_ntop(2, (void const   */* __restrict  */)(& src_ipv4.s_addr),
                          (char */* __restrict  */)(src_ip4_buf), (socklen_t )sizeof(src_ip4_buf));
      }
#line 483
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 483
        snprintf((char */* __restrict  */)(src_ip4_buf), sizeof(src_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 483
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 485
      tmp___1 = inet_ntop(2, (void const   */* __restrict  */)(& ipv4.s_addr), (char */* __restrict  */)(dst_ip4_buf),
                          (socklen_t )sizeof(dst_ip4_buf));
      }
#line 485
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 485
        snprintf((char */* __restrict  */)(dst_ip4_buf), sizeof(dst_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 485
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 487
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 487
      tmp___2 = inet_ntop(2, (void const   */* __restrict  */)(& mask), (char */* __restrict  */)(mask_ip4_buf),
                          (socklen_t )sizeof(mask_ip4_buf));
      }
#line 487
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
#line 487
        snprintf((char */* __restrict  */)(mask_ip4_buf), sizeof(mask_ip4_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 487
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 489
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               491, "ip_match:  %s == %s  (/%d %s):  %d", src_ip4_buf, dst_ip4_buf,
               cidr, mask_ip4_buf, (src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
    }
  }
#line 494
  return ((src_ipv4.s_addr & (unsigned int )mask) == (ipv4.s_addr & (unsigned int )mask));
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_ip6___7(SPF_server_t *spf_server___1 , SPF_request_t *spf_request ,
                               SPF_mech_t *mech , struct in6_addr ipv6 ) 
{ 
  char src_ip6_buf[46] ;
  char dst_ip6_buf[46] ;
  struct in6_addr src_ipv6 ;
  int cidr ;
  int cidr_save ;
  int mask ;
  int i ;
  int match ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 512
  if (spf_request->client_ver != 10) {
#line 513
    return (0);
  }
  {
#line 515
  src_ipv6 = spf_request->ipv6;
#line 517
  cidr = SPF_i_mech_cidr___7(spf_request, mech);
  }
#line 518
  if (cidr == 0) {
#line 519
    cidr = 128;
  }
#line 520
  cidr_save = cidr;
#line 522
  match = 1;
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if ((long )i < (long )(sizeof(ipv6.__in6_u.__u6_addr8) / sizeof(ipv6.__in6_u.__u6_addr8[0]))) {
#line 523
      if (! match) {
#line 523
        goto while_break;
      }
    } else {
#line 523
      goto while_break;
    }
#line 525
    if (cidr > 8) {
#line 526
      mask = 255;
    } else
#line 527
    if (cidr > 0) {
#line 528
      mask = (255 << (8 - cidr)) & 255;
    } else {
#line 530
      goto while_break;
    }
#line 531
    cidr -= 8;
#line 533
    match = ((int )src_ipv6.__in6_u.__u6_addr8[i] & mask) == ((int )ipv6.__in6_u.__u6_addr8[i] & mask);
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (spf_server___1->debug) {
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 537
      tmp = inet_ntop(10, (void const   */* __restrict  */)(& src_ipv6.__in6_u.__u6_addr8),
                      (char */* __restrict  */)(src_ip6_buf), (socklen_t )sizeof(src_ip6_buf));
      }
#line 537
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 537
        snprintf((char */* __restrict  */)(src_ip6_buf), sizeof(src_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 537
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 539
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 539
      tmp___0 = inet_ntop(10, (void const   */* __restrict  */)(& ipv6.__in6_u.__u6_addr8),
                          (char */* __restrict  */)(dst_ip6_buf), (socklen_t )sizeof(dst_ip6_buf));
      }
#line 539
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 539
        snprintf((char */* __restrict  */)(dst_ip6_buf), sizeof(dst_ip6_buf), (char const   */* __restrict  */)"ip-error");
        }
      }
#line 539
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 541
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               542, "ip_match:  %s == %s  (/%d):  %d", src_ip6_buf, dst_ip6_buf, cidr_save,
               match);
    }
  }
#line 545
  return (match);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c"
static int SPF_i_match_domain___7(SPF_server_t *spf_server___1 , char const   *hostname ,
                                  char const   *domain ) 
{ 
  char const   *hp ;
  size_t hlen ;
  size_t dlen ;
  int tmp ;
  int tmp___0 ;

  {
#line 556
  if (spf_server___1->debug) {
    {
#line 557
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_interpret.c",
               557, "%s ?=? %s", hostname, domain);
    }
  }
  {
#line 559
  hlen = strlen(hostname);
#line 560
  dlen = strlen(domain);
  }
#line 563
  if (dlen > hlen) {
#line 564
    return (0);
  }
#line 567
  if (dlen == hlen) {
    {
#line 568
    tmp = strcasecmp(hostname, domain);
    }
#line 568
    return (tmp == 0);
  }
#line 571
  hp = hostname + (hlen - dlen);
#line 573
  if ((int const   )*(hp - 1) != 46) {
#line 574
    return (0);
  }
  {
#line 576
  tmp___0 = strcasecmp(hp, domain);
  }
#line 576
  return (tmp___0 == 0);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   spf_mechtypes___7[10]  = 
#line 78 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
  {      {(unsigned char)0, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)1, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)2, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )1}, 
        {(unsigned char)3, (unsigned char)1, (SPF_domspec_t )1, (SPF_cidr_t )0}, 
        {(unsigned char)4, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)5, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)6, (unsigned char)0, (SPF_domspec_t )2, (SPF_cidr_t )1}, 
        {(unsigned char)7, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}, 
        {(unsigned char)8, (unsigned char)0, (SPF_domspec_t )0, (SPF_cidr_t )0}, 
        {(unsigned char)9, (unsigned char)1, (SPF_domspec_t )2, (SPF_cidr_t )0}};
#line 94 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_mechtype_t const   *SPF_mechtype_find___7(int mech_type ) 
{ 
  size_t i ;

  {
#line 98
  i = (size_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < sizeof(spf_mechtypes___7) / sizeof(spf_mechtypes___7[0]))) {
#line 98
      goto while_break;
    }
#line 99
    if ((int const   )spf_mechtypes___7[i].mech_type == (int const   )mech_type) {
#line 100
      return (& spf_mechtypes___7[i]);
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((SPF_mechtype_t const   *)((void *)0));
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static int ( __attribute__((__warn_unused_result__)) SPF_c_ensure_capacity___7)(void **datap ,
                                                                                size_t *sizep ,
                                                                                size_t length ) 
{ 
  size_t size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 109
  size = *sizep;
#line 110
  if (length > size) {
#line 111
    size = length + length / 4UL;
  }
#line 112
  if (size > *sizep) {
    {
#line 113
    tmp___0 = realloc(*datap, size);
#line 113
    tmp = tmp___0;
    }
#line 114
    if (! tmp) {
#line 115
      return (-1);
    }
#line 117
    *datap = tmp;
#line 118
    *sizep = size;
  }
#line 120
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip6___7(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 144
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 144
  mask = (int )tmp;
  }
#line 146
  if (mask > 128) {
    {
#line 147
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (>128)");
    }
#line 147
    return (tmp___0);
  } else
#line 151
  if (mask == 0) {
    {
#line 152
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv6 CIDR netmask (=0)");
    }
#line 152
    return (tmp___1);
  } else
#line 156
  if (mask == 128) {
#line 157
    mask = 0;
  }
#line 160
  *maskp = (unsigned char )mask;
#line 162
  return ((SPF_errcode_t )0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr_ip4___7(SPF_response_t *spf_response , unsigned char *maskp ,
                                              char const   *src ) 
{ 
  int mask ;
  unsigned long tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 186
  tmp = strtoul((char const   */* __restrict  */)(src + 1), (char **/* __restrict  */)((void *)0),
                10);
#line 186
  mask = (int )tmp;
  }
#line 188
  if (mask > 32) {
    {
#line 189
    tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (>32)");
    }
#line 189
    return (tmp___0);
  } else
#line 193
  if (mask == 0) {
    {
#line 194
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                         src, "Invalid IPv4 CIDR netmask (=0)");
    }
#line 194
    return (tmp___1);
  } else
#line 198
  if (mask == 32) {
#line 199
    mask = 0;
  }
#line 202
  *maskp = (unsigned char )mask;
#line 204
  return ((SPF_errcode_t )0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_cidr___7(SPF_response_t *spf_response , SPF_data_cidr_t *data ,
                                          char const   *src , size_t *src_len ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 220
  memset((void *)data, 0, sizeof(SPF_data_cidr_t ));
#line 221
  data->parm_type = (unsigned char)11;
#line 227
  idx = *src_len - 1UL;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (idx > 0UL) {
      {
#line 228
      tmp = __ctype_b_loc();
      }
#line 228
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 228
        goto while_break;
      }
    } else {
#line 228
      goto while_break;
    }
#line 229
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (idx < *src_len - 1UL) {
#line 236
    if ((int const   )*(src + idx) == 47) {
#line 237
      if (idx > 0UL) {
#line 237
        if ((int const   )*(src + (idx - 1UL)) == 47) {
          {
#line 239
          err = SPF_c_parse_cidr_ip6___7(spf_response, & data->ipv6, src + idx);
          }
#line 240
          if (err) {
#line 241
            return (err);
          }
#line 243
          *src_len = idx - 1UL;
#line 244
          idx = *src_len - 1UL;
          {
#line 245
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 245
            if (idx > 0UL) {
              {
#line 245
              tmp___0 = __ctype_b_loc();
              }
#line 245
              if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(src + idx))) & 2048)) {
#line 245
                goto while_break___0;
              }
            } else {
#line 245
              goto while_break___0;
            }
#line 246
            idx --;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 249
          if (idx < *src_len - 1UL) {
#line 249
            if ((int const   )*(src + idx) == 47) {
              {
#line 253
              err = SPF_c_parse_cidr_ip4___7(spf_response, & data->ipv4, src + idx);
              }
#line 254
              if (err) {
#line 255
                return (err);
              }
#line 256
              *src_len = idx;
            }
          }
        } else {
#line 237
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 261
        err = SPF_c_parse_cidr_ip4___7(spf_response, & data->ipv4, src + idx);
        }
#line 262
        if (err) {
#line 263
          return (err);
        }
#line 264
        *src_len = idx;
      }
    }
  }
#line 268
  return ((SPF_errcode_t )0);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_var___7(SPF_response_t *spf_response , SPF_data_var_t *data ,
                                         char const   *src , int is_mod ) 
{ 
  char const   *token ;
  char const   *p ;
  char c ;
  int val ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  SPF_errcode_t tmp___1 ;
  SPF_errcode_t tmp___2 ;
  SPF_errcode_t tmp___3 ;
  SPF_errcode_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  SPF_errcode_t tmp___6 ;
  SPF_errcode_t tmp___7 ;

  {
  {
#line 280
  memset((void *)data, 0, sizeof(SPF_data_var_t ));
#line 282
  p = src;
#line 285
  c = (char )*p;
#line 286
  tmp___0 = __ctype_b_loc();
  }
#line 286
  if ((int const   )*(*tmp___0 + (int )((unsigned char )c)) & 256) {
    {
#line 288
    data->url_encode = (unsigned short)1;
#line 289
    tmp = tolower((int )c);
#line 289
    c = (char )tmp;
    }
  } else {
#line 292
    data->url_encode = (unsigned short)0;
  }
  {
#line 302
  if ((int )c == 108) {
#line 302
    goto case_108;
  }
#line 306
  if ((int )c == 115) {
#line 306
    goto case_115;
  }
#line 310
  if ((int )c == 111) {
#line 310
    goto case_111;
  }
#line 314
  if ((int )c == 100) {
#line 314
    goto case_100;
  }
#line 318
  if ((int )c == 105) {
#line 318
    goto case_105;
  }
#line 322
  if ((int )c == 99) {
#line 322
    goto case_99;
  }
#line 327
  if ((int )c == 116) {
#line 327
    goto case_116;
  }
#line 332
  if ((int )c == 112) {
#line 332
    goto case_112;
  }
#line 336
  if ((int )c == 118) {
#line 336
    goto case_118;
  }
#line 340
  if ((int )c == 104) {
#line 340
    goto case_104;
  }
#line 344
  if ((int )c == 114) {
#line 344
    goto case_114;
  }
#line 349
  goto switch_default;
  case_108: /* CIL Label */ 
#line 303
  data->parm_type = (unsigned char)0;
#line 304
  goto switch_break;
  case_115: /* CIL Label */ 
#line 307
  data->parm_type = (unsigned char)1;
#line 308
  goto switch_break;
  case_111: /* CIL Label */ 
#line 311
  data->parm_type = (unsigned char)2;
#line 312
  goto switch_break;
  case_100: /* CIL Label */ 
#line 315
  data->parm_type = (unsigned char)3;
#line 316
  goto switch_break;
  case_105: /* CIL Label */ 
#line 319
  data->parm_type = (unsigned char)4;
#line 320
  goto switch_break;
  case_99: /* CIL Label */ 
#line 323
  if (! is_mod) {
    {
#line 323
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 323
    return (tmp___1);
  }
#line 324
  data->parm_type = (unsigned char)5;
#line 325
  goto switch_break;
  case_116: /* CIL Label */ 
#line 328
  if (! is_mod) {
    {
#line 328
    tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 328
    return (tmp___2);
  }
#line 329
  data->parm_type = (unsigned char)6;
#line 330
  goto switch_break;
  case_112: /* CIL Label */ 
#line 333
  data->parm_type = (unsigned char)7;
#line 334
  goto switch_break;
  case_118: /* CIL Label */ 
#line 337
  data->parm_type = (unsigned char)8;
#line 338
  goto switch_break;
  case_104: /* CIL Label */ 
#line 341
  data->parm_type = (unsigned char)9;
#line 342
  goto switch_break;
  case_114: /* CIL Label */ 
#line 345
  if (! is_mod) {
    {
#line 345
    tmp___3 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                         p, "\'%c\' macro is only valid in modifiers",
                                         (int )c);
    }
#line 345
    return (tmp___3);
  }
#line 346
  data->parm_type = (unsigned char)10;
#line 347
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 350
  tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, (char const   *)((void *)0),
                                       p, "Unknown variable \'%c\'", (int )c);
  }
#line 350
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
#line 354
  p ++;
#line 355
  token = p;
#line 358
  val = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 359
    tmp___5 = __ctype_b_loc();
    }
#line 359
    if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*p)) & 2048)) {
#line 359
      goto while_break;
    }
#line 361
    val *= 10;
#line 362
    val += (int )((int const   )*p - 48);
#line 363
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (val > 128) {
    {
#line 366
    tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                         token, "Subdomain truncation depth too large");
    }
#line 366
    return (tmp___6);
  } else
#line 365
  if (val <= 0) {
#line 365
    if ((unsigned long )p != (unsigned long )token) {
      {
#line 366
      tmp___6 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )13, (char const   *)((void *)0),
                                           token, "Subdomain truncation depth too large");
      }
#line 366
      return (tmp___6);
    }
  }
#line 369
  data->num_rhs = (unsigned char )val;
#line 370
  token = p;
#line 373
  if ((int const   )*p == 114) {
#line 375
    data->rev = (unsigned short)1;
#line 376
    p ++;
  } else {
#line 379
    data->rev = (unsigned short)0;
  }
#line 380
  token = p;
#line 384
  data->delim_dot = (unsigned short)0;
#line 385
  data->delim_dash = (unsigned short)0;
#line 386
  data->delim_plus = (unsigned short)0;
#line 387
  data->delim_equal = (unsigned short)0;
#line 388
  data->delim_bar = (unsigned short)0;
#line 389
  data->delim_under = (unsigned short)0;
#line 392
  if ((int const   )*p == 125) {
#line 393
    data->delim_dot = (unsigned short)1;
  }
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! ((int const   )*p != 125)) {
#line 396
      goto while_break___0;
    }
#line 398
    token = p;
    {
#line 401
    if ((int const   )*p == 46) {
#line 401
      goto case_46;
    }
#line 405
    if ((int const   )*p == 45) {
#line 405
      goto case_45;
    }
#line 409
    if ((int const   )*p == 43) {
#line 409
      goto case_43;
    }
#line 413
    if ((int const   )*p == 61) {
#line 413
      goto case_61;
    }
#line 417
    if ((int const   )*p == 124) {
#line 417
      goto case_124;
    }
#line 421
    if ((int const   )*p == 95) {
#line 421
      goto case_95;
    }
#line 425
    goto switch_default___0;
    case_46: /* CIL Label */ 
#line 402
    data->delim_dot = (unsigned short)1;
#line 403
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 406
    data->delim_dash = (unsigned short)1;
#line 407
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 410
    data->delim_plus = (unsigned short)1;
#line 411
    goto switch_break___0;
    case_61: /* CIL Label */ 
#line 414
    data->delim_equal = (unsigned short)1;
#line 415
    goto switch_break___0;
    case_124: /* CIL Label */ 
#line 418
    data->delim_bar = (unsigned short)1;
#line 419
    goto switch_break___0;
    case_95: /* CIL Label */ 
#line 422
    data->delim_under = (unsigned short)1;
#line 423
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 426
    tmp___7 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )14, (char const   *)((void *)0),
                                         p, "Invalid delimiter \'%c\'", (int const   )*p);
    }
#line 426
    return (tmp___7);
    switch_break___0: /* CIL Label */ ;
    }
#line 430
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 432
  p ++;
#line 433
  token = p;
#line 436
  return ((SPF_errcode_t )0);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_macro___7(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                           SPF_data_t *data , size_t *data_used ,
                                           size_t data_avail , char const   *src ,
                                           size_t src_len , SPF_errcode_t big_err ,
                                           int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t idx ;
  size_t len ;
  char *dst ;
  size_t ds_avail ;
  size_t ds_len ;
  SPF_errcode_t tmp ;
  SPF_errcode_t tmp___0 ;
  char *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  char *tmp___3 ;
  SPF_errcode_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  SPF_errcode_t tmp___8 ;
  char *tmp___9 ;
  SPF_errcode_t tmp___10 ;
  SPF_errcode_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  SPF_errcode_t tmp___15 ;
  SPF_errcode_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  SPF_errcode_t tmp___19 ;
  SPF_errcode_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
#line 522
  if (spf_server___1->debug) {
    {
#line 523
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               523, "Parsing macro starting at %s", src);
    }
  }
#line 534
  idx = (size_t )0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 538
    data->ds.parm_type = (unsigned char)12;
#line 538
    data->ds.len = (unsigned char)0;
#line 538
    data->ds.__unused0 = (unsigned char)186;
#line 538
    data->ds.__unused1 = (unsigned char)190;
#line 538
    dst = SPF_data_str(data);
#line 538
    ds_avail = data_avail - *data_used;
#line 538
    ds_len = (size_t )0;
    }
#line 538
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 541
    if (! (idx < src_len)) {
#line 541
      goto while_break___0;
    }
#line 542
    if (spf_server___1->debug > 3) {
      {
#line 543
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 543, "Current data is at %p", data);
      }
    }
    {
#line 546
    len = strcspn(src + idx, " %");
    }
#line 547
    if (len > 0UL) {
#line 549
      if (idx + len > src_len) {
#line 550
        len = src_len - idx;
      }
#line 551
      if (spf_server___1->debug > 3) {
        {
#line 552
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                   554, "Adding string literal (%lu): \'%*.*s\'", len, (int )len,
                   (int )len, src + idx);
        }
      }
      {
#line 556
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 556
        if (ds_len + len > ds_avail) {
          {
#line 556
          tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                           src, "String literal fragment too long (%d chars, %d max)",
                                           ds_len, ds_avail);
          }
#line 556
          return (tmp);
        }
#line 556
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 557
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(src + idx),
             len);
#line 558
      ds_len += len;
#line 559
      dst += len;
#line 560
      idx += len;
      }
    }
#line 568
    if (idx == src_len) {
#line 569
      goto while_break___0;
    }
#line 576
    idx ++;
    {
#line 578
    if ((int const   )*(src + idx) == 37) {
#line 578
      goto case_37;
    }
#line 587
    if ((int const   )*(src + idx) == 95) {
#line 587
      goto case_95;
    }
#line 596
    if ((int const   )*(src + idx) == 45) {
#line 596
      goto case_45;
    }
#line 617
    if ((int const   )*(src + idx) == 123) {
#line 617
      goto case_123;
    }
#line 605
    goto switch_default;
    case_37: /* CIL Label */ 
#line 579
    if (spf_server___1->debug > 3) {
      {
#line 580
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 580, "Adding literal %%");
      }
    }
    {
#line 581
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 581
      if (ds_len + 1UL > ds_avail) {
        {
#line 581
        tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 581
        return (tmp___0);
      }
#line 581
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 582
    tmp___1 = dst;
#line 582
    dst ++;
#line 582
    *tmp___1 = (char )'%';
#line 583
    ds_len ++;
#line 584
    idx ++;
#line 585
    goto switch_break;
    case_95: /* CIL Label */ 
#line 588
    if (spf_server___1->debug > 3) {
      {
#line 589
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 589, "Adding literal space");
      }
    }
    {
#line 590
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 590
      if (ds_len + 1UL > ds_avail) {
        {
#line 590
        tmp___2 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 590
        return (tmp___2);
      }
#line 590
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 591
    tmp___3 = dst;
#line 591
    dst ++;
#line 591
    *tmp___3 = (char )' ';
#line 592
    ds_len ++;
#line 593
    idx ++;
#line 594
    goto switch_break;
    case_45: /* CIL Label */ 
#line 597
    if (spf_server___1->debug > 3) {
      {
#line 598
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 598, "Adding escaped space");
      }
    }
    {
#line 599
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 599
      if (ds_len + 3UL > ds_avail) {
        {
#line 599
        tmp___4 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 599
        return (tmp___4);
      }
#line 599
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 600
    tmp___5 = dst;
#line 600
    dst ++;
#line 600
    *tmp___5 = (char )'%';
#line 600
    tmp___6 = dst;
#line 600
    dst ++;
#line 600
    *tmp___6 = (char )'2';
#line 600
    tmp___7 = dst;
#line 600
    dst ++;
#line 600
    *tmp___7 = (char )'0';
#line 601
    ds_len += 3UL;
#line 602
    idx ++;
#line 603
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 606
    if (spf_server___1->debug > 3) {
      {
#line 607
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 608, "Adding illegal %%-follower \'%c\' at %d", (int const   )*(src + idx),
                 idx);
      }
    }
    {
#line 612
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 612
      if (ds_len + 1UL > ds_avail) {
        {
#line 612
        tmp___8 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                             src, "String literal fragment too long (%d chars, %d max)",
                                             ds_len, ds_avail);
        }
#line 612
        return (tmp___8);
      }
#line 612
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 613
    tmp___9 = dst;
#line 613
    dst ++;
#line 613
    *tmp___9 = (char )'%';
#line 614
    ds_len ++;
#line 615
    goto switch_break;
    case_123: /* CIL Label */ 
    {
#line 618
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 618
      if (ds_len > 0UL) {
#line 618
        if (ds_len > 255UL) {
          {
#line 618
          tmp___10 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15,
                                                (char const   *)((void *)0), src,
                                                "String literal too long (%d chars, %d max)",
                                                ds_len, 255);
          }
#line 618
          return (tmp___10);
        }
#line 618
        data->ds.len = (unsigned char )ds_len;
#line 618
        len = sizeof(*data) + ds_len;
        {
#line 618
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 618
          tmp___12 = _align_sz(len);
          }
#line 618
          if (*data_used + tmp___12 > data_avail) {
            {
#line 618
            tmp___11 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                  src, "SPF domainspec too long (%d chars, %d max)",
                                                  *data_used + len, data_avail);
            }
#line 618
            return (tmp___11);
          }
          {
#line 618
          tmp___13 = _align_sz(len);
#line 618
          *data_used += tmp___13;
          }
#line 618
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 618
        data = SPF_data_next(data);
#line 618
        ds_len = (size_t )0;
        }
      }
#line 618
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 619
    if (spf_server___1->debug > 3) {
      {
#line 620
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 620, "Adding macro, data is at %p", data);
      }
    }
    {
#line 623
    idx ++;
#line 624
    err = SPF_c_parse_var___7(spf_response, & data->dv, src + idx, is_mod);
    }
#line 625
    if ((unsigned int )err != 0U) {
#line 626
      return (err);
    }
    {
#line 627
    tmp___14 = strcspn(src + idx, "} ");
#line 627
    idx += tmp___14;
    }
#line 628
    if ((int const   )*(src + idx) == 125) {
#line 629
      idx ++;
    } else
#line 630
    if ((int const   )*(src + idx) == 32) {
      {
#line 631
      tmp___15 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )12, src,
                                            src + idx, "Unterminated variable?");
      }
#line 631
      return (tmp___15);
    }
    {
#line 637
    len = SPF_data_len(data);
    }
    {
#line 638
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 638
      tmp___17 = _align_sz(len);
      }
#line 638
      if (*data_used + tmp___17 > data_avail) {
        {
#line 638
        tmp___16 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                              src, "SPF domainspec too long (%d chars, %d max)",
                                              *data_used + len, data_avail);
        }
#line 638
        return (tmp___16);
      }
      {
#line 638
      tmp___18 = _align_sz(len);
#line 638
      *data_used += tmp___18;
      }
#line 638
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 639
    data = SPF_data_next(data);
    }
#line 640
    if (spf_server___1->debug > 3) {
      {
#line 641
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 641, "Next data is at %p", data);
      }
    }
    {
#line 643
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 643
      data->ds.parm_type = (unsigned char)12;
#line 643
      data->ds.len = (unsigned char)0;
#line 643
      data->ds.__unused0 = (unsigned char)186;
#line 643
      data->ds.__unused1 = (unsigned char)190;
#line 643
      dst = SPF_data_str(data);
#line 643
      ds_avail = data_avail - *data_used;
#line 643
      ds_len = (size_t )0;
      }
#line 643
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 649
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 649
    if (ds_len > 0UL) {
#line 649
      if (ds_len > 255UL) {
        {
#line 649
        tmp___19 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )15, (char const   *)((void *)0),
                                              src, "String literal too long (%d chars, %d max)",
                                              ds_len, 255);
        }
#line 649
        return (tmp___19);
      }
#line 649
      data->ds.len = (unsigned char )ds_len;
#line 649
      len = sizeof(*data) + ds_len;
      {
#line 649
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 649
        tmp___21 = _align_sz(len);
        }
#line 649
        if (*data_used + tmp___21 > data_avail) {
          {
#line 649
          tmp___20 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                                src, "SPF domainspec too long (%d chars, %d max)",
                                                *data_used + len, data_avail);
          }
#line 649
          return (tmp___20);
        }
        {
#line 649
        tmp___22 = _align_sz(len);
#line 649
        *data_used += tmp___22;
        }
#line 649
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 649
      data = SPF_data_next(data);
#line 649
      ds_len = (size_t )0;
      }
    }
#line 649
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 651
  return ((SPF_errcode_t )0);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_domainspec___7(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                                SPF_data_t *data , size_t *data_used ,
                                                size_t data_avail , char const   *src ,
                                                size_t src_len , SPF_errcode_t big_err ,
                                                SPF_cidr_t cidr_ok , int is_mod ) 
{ 
  SPF_errcode_t err ;
  size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  SPF_errcode_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  SPF_errcode_t tmp___5 ;
  SPF_errcode_t tmp___6 ;

  {
#line 682
  if (spf_server___1->debug) {
#line 683
    if ((unsigned int )cidr_ok == 1U) {
#line 683
      tmp___1 = "optional";
    } else {
#line 683
      if ((unsigned int )cidr_ok == 2U) {
#line 683
        tmp___0 = "only";
      } else {
#line 683
        if ((unsigned int )cidr_ok == 0U) {
#line 683
          tmp = "forbidden";
        } else {
#line 683
          tmp = "ERROR!";
        }
#line 683
        tmp___0 = tmp;
      }
#line 683
      tmp___1 = tmp___0;
    }
    {
#line 683
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               689, "Parsing domainspec starting at %s, cidr is %s", src, tmp___1);
    }
  }
#line 694
  if ((unsigned int )cidr_ok == 1U) {
#line 694
    goto _L___0;
  } else
#line 694
  if ((unsigned int )cidr_ok == 2U) {
    _L___0: /* CIL Label */ 
    {
#line 695
    err = SPF_c_parse_cidr___7(spf_response, & data->dc, src, & src_len);
    }
#line 696
    if ((unsigned int )err != 0U) {
#line 697
      return (err);
    }
#line 698
    if ((int )data->dc.ipv4 != 0) {
#line 698
      goto _L;
    } else
#line 698
    if ((int )data->dc.ipv6 != 0) {
      _L: /* CIL Label */ 
      {
#line 699
      len = SPF_data_len(data);
      }
      {
#line 700
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 700
        tmp___3 = _align_sz(len);
        }
#line 700
        if (*data_used + tmp___3 > data_avail) {
          {
#line 700
          tmp___2 = SPF_response_add_error_ptr(spf_response, big_err, (char const   *)((void *)0),
                                               src, "SPF domainspec too long (%d chars, %d max)",
                                               *data_used + len, data_avail);
          }
#line 700
          return (tmp___2);
        }
        {
#line 700
        tmp___4 = _align_sz(len);
#line 700
        *data_used += tmp___4;
        }
#line 700
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 701
      data = SPF_data_next(data);
      }
    }
#line 704
    if ((unsigned int )cidr_ok == 2U) {
#line 704
      if (src_len > 0UL) {
        {
#line 708
        tmp___5 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )8, (char const   *)((void *)0),
                                             src, "Invalid CIDR after mechanism");
        }
#line 708
        return (tmp___5);
      }
    }
  }
  {
#line 715
  tmp___6 = SPF_c_parse_macro___7(spf_server___1, spf_response, data, data_used, data_avail,
                                  src, src_len, big_err, is_mod);
  }
#line 715
  return (tmp___6);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip4___7(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  SPF_errcode_t err ;
  unsigned char mask ;
  struct in_addr *addr ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 739
  start ++;
#line 740
  len = strcspn(start, " ");
#line 741
  end = start + len;
#line 742
  p = end - 1;
#line 744
  mask = (unsigned char)0;
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 745
    tmp = __ctype_b_loc();
    }
#line 745
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 745
      goto while_break;
    }
#line 746
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 747
    if ((int const   )*p == 47) {
      {
#line 748
      err = SPF_c_parse_cidr_ip4___7(spf_response, & mask, p);
      }
#line 749
      if (err) {
#line 750
        return (err);
      }
#line 751
      end = p;
    }
  }
#line 753
  mech->mech_len = (unsigned short )mask;
#line 755
  len = (size_t )(end - start);
#line 756
  if (len > sizeof(buf) - 1UL) {
#line 757
    return ((SPF_errcode_t )19);
  }
  {
#line 759
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 760
  buf[len] = (char )'\000';
#line 761
  addr = SPF_mech_ip4_data(mech);
#line 762
  tmp___0 = inet_pton(2, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
#line 762
  err = (SPF_errcode_t )tmp___0;
  }
#line 763
  if ((unsigned int )err <= 0U) {
    {
#line 764
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )19, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 764
    return (tmp___1);
  }
#line 767
  return ((SPF_errcode_t )0);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t SPF_c_parse_ip6___7(SPF_response_t *spf_response , SPF_mech_t *mech ,
                                         char const   *start ) 
{ 
  char const   *end ;
  char const   *p ;
  char buf[46] ;
  size_t len ;
  int err ;
  unsigned char mask ;
  struct in6_addr *addr ;
  unsigned short const   **tmp ;
  SPF_errcode_t tmp___0 ;
  SPF_errcode_t tmp___1 ;

  {
  {
#line 788
  start ++;
#line 789
  len = strcspn(start, " ");
#line 790
  end = start + len;
#line 791
  p = end - 1;
#line 793
  mask = (unsigned char)0;
  }
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 794
    tmp = __ctype_b_loc();
    }
#line 794
    if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 2048)) {
#line 794
      goto while_break;
    }
#line 795
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  if ((unsigned long )p != (unsigned long )(end - 1)) {
#line 796
    if ((int const   )*p == 47) {
      {
#line 797
      tmp___0 = SPF_c_parse_cidr_ip6___7(spf_response, & mask, p);
#line 797
      err = (int )tmp___0;
      }
#line 798
      if (err) {
#line 799
        return ((SPF_errcode_t )err);
      }
#line 800
      end = p;
    }
  }
#line 802
  mech->mech_len = (unsigned short )mask;
#line 804
  len = (size_t )(end - start);
#line 805
  if (len > sizeof(buf) - 1UL) {
#line 806
    return ((SPF_errcode_t )20);
  }
  {
#line 808
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)start, len);
#line 809
  buf[len] = (char )'\000';
#line 810
  addr = SPF_mech_ip6_data(mech);
#line 811
  err = inet_pton(10, (char const   */* __restrict  */)(buf), (void */* __restrict  */)addr);
  }
#line 812
  if (err <= 0) {
    {
#line 813
    tmp___1 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )20, (char const   *)((void *)0),
                                         (char const   *)(buf), (char const   *)((void *)0));
    }
#line 813
    return (tmp___1);
  }
#line 816
  return ((SPF_errcode_t )0);
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mech_add___7)(SPF_server_t *spf_server___1 ,
                                                                                   SPF_record_t *spf_record ,
                                                                                   SPF_response_t *spf_response ,
                                                                                   SPF_mechtype_t const   *mechtype ,
                                                                                   int prefix ,
                                                                                   char const   **mech_value ) 
{ 
  union __anonunion_u_60___7 u ;
  SPF_mech_t *spf_mechanism ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  SPF_errcode_t tmp ;
  int tmp___0 ;

  {
  {
#line 834
  spf_mechanism = (SPF_mech_t *)(u.buf);
#line 842
  memset((void *)(u.buf), 'B', sizeof(u.buf));
#line 843
  memset((void *)spf_mechanism, 0, sizeof(SPF_mech_t ));
  }
#line 845
  if (spf_server___1->debug) {
    {
#line 846
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               847, "SPF_c_mech_add: type=%d, value=%s", (int const   )mechtype->mech_type,
               *mech_value);
    }
  }
#line 849
  spf_mechanism->prefix_type = (unsigned char )prefix;
#line 850
  spf_mechanism->mech_type = (unsigned char )mechtype->mech_type;
#line 851
  spf_mechanism->mech_len = (unsigned short)0;
#line 853
  len = sizeof(SPF_mech_t );
#line 855
  if (spf_record->mech_len + len > 511UL) {
#line 856
    return ((SPF_errcode_t )16);
  }
  {
#line 858
  data = SPF_mech_data(spf_mechanism);
#line 859
  data_len = (size_t )0;
#line 861
  src_len = strcspn(*mech_value, " ");
  }
  {
#line 865
  if ((int const   )mechtype->mech_type == 5) {
#line 865
    goto case_5;
  }
#line 878
  if ((int const   )mechtype->mech_type == 6) {
#line 878
    goto case_6;
  }
#line 891
  goto switch_default;
  case_5: /* CIL Label */ 
#line 866
  if ((int const   )*(*mech_value) == 58) {
    {
#line 867
    err = SPF_c_parse_ip4___7(spf_response, spf_mechanism, *mech_value);
#line 868
    data_len = sizeof(struct in_addr );
    }
  } else {
    {
#line 871
    err = (SPF_errcode_t )9;
#line 872
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 876
  goto switch_break;
  case_6: /* CIL Label */ 
#line 879
  if ((int const   )*(*mech_value) == 58) {
    {
#line 880
    err = SPF_c_parse_ip6___7(spf_response, spf_mechanism, *mech_value);
#line 881
    data_len = sizeof(struct in6_addr );
    }
  } else {
    {
#line 884
    err = (SPF_errcode_t )9;
#line 885
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Mechanism requires a value.");
    }
  }
#line 889
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 892
  if ((int const   )*(*mech_value) == 58) {
#line 892
    goto _L___0;
  } else
#line 892
  if ((int const   )*(*mech_value) == 61) {
    _L___0: /* CIL Label */ 
#line 893
    if ((unsigned int const   )mechtype->has_domainspec == 0U) {
      {
#line 894
      err = (SPF_errcode_t )7;
#line 895
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a value.");
      }
    } else {
      {
#line 900
      (*mech_value) ++;
#line 900
      src_len --;
#line 901
      err = SPF_c_parse_domainspec___7(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )mechtype->has_cidr, 0);
      }
    }
  } else
#line 909
  if ((int const   )*(*mech_value) == 47) {
#line 910
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 911
      err = (SPF_errcode_t )9;
#line 912
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else
#line 916
    if ((unsigned int const   )mechtype->has_cidr == 0U) {
      {
#line 917
      err = (SPF_errcode_t )8;
#line 918
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism does not permit a CIDR.");
      }
    } else {
      {
#line 923
      err = SPF_c_parse_domainspec___7(spf_server___1, spf_response, data, & data_len,
                                       (size_t )511, *mech_value, src_len, (SPF_errcode_t )16,
                                       (SPF_cidr_t )2, 0);
      }
    }
  } else
#line 931
  if ((int const   )*(*mech_value) == 32) {
#line 931
    goto _L;
  } else
#line 931
  if ((int const   )*(*mech_value) == 0) {
    _L: /* CIL Label */ 
#line 932
    if ((unsigned int const   )mechtype->has_domainspec == 2U) {
      {
#line 933
      err = (SPF_errcode_t )9;
#line 934
      SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                                 "Mechanism requires a value.");
      }
    } else {
#line 939
      err = (SPF_errcode_t )0;
    }
  } else {
    {
#line 943
    err = (SPF_errcode_t )3;
#line 944
    SPF_response_add_error_ptr(spf_response, err, (char const   *)((void *)0), *mech_value,
                               "Unknown character \'%c\' after mechanism.", (int const   )*(*mech_value));
    }
  }
#line 951
  spf_mechanism->mech_len = (unsigned short )data_len;
#line 952
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 955
  len += data_len;
#line 958
  if ((unsigned int )err == 0U) {
#line 959
    if (mechtype->is_dns_mech) {
#line 960
      spf_record->num_dns_mech = (unsigned char )((int )spf_record->num_dns_mech + 1);
    }
    {
#line 961
    tmp___0 = SPF_c_ensure_capacity___7((void **)(& spf_record->mech_first), & spf_record->mech_size,
                                        spf_record->mech_len + len);
    }
#line 961
    if (tmp___0 < 0) {
      {
#line 964
      tmp = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                       (char const   *)((void *)0), "Failed to allocate memory for mechanism");
      }
#line 964
      return (tmp);
    }
    {
#line 968
    memcpy((void */* __restrict  */)((char *)spf_record->mech_first + spf_record->mech_len),
           (void const   */* __restrict  */)spf_mechanism, len);
#line 971
    spf_record->mech_len += len;
#line 972
    spf_record->num_mech = (unsigned char )((int )spf_record->num_mech + 1);
    }
  }
#line 975
  *mech_value += src_len;
#line 977
  return (err);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_c_mod_add___7)(SPF_server_t *spf_server___1 ,
                                                                                  SPF_record_t *spf_record ,
                                                                                  SPF_response_t *spf_response ,
                                                                                  char const   *mod_name ,
                                                                                  size_t name_len ,
                                                                                  char const   **mod_value ) 
{ 
  union __anonunion_u_61___7 u ;
  SPF_mod_t *spf_modifier ;
  SPF_data_t *data ;
  size_t data_len ;
  size_t len ;
  size_t src_len ;
  SPF_errcode_t err ;
  char *tmp ;
  SPF_errcode_t tmp___0 ;
  int tmp___1 ;

  {
#line 992
  spf_modifier = (SPF_mod_t *)(u.buf);
#line 1000
  if (spf_server___1->debug) {
    {
#line 1001
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
               1002, "Adding modifier name=%lu@%s, value=%s", name_len, mod_name,
               *mod_value);
    }
  }
  {
#line 1004
  memset((void *)(u.buf), 'A', sizeof(u.buf));
#line 1005
  memset((void *)spf_modifier, 0, sizeof(SPF_mod_t ));
  }
#line 1007
  if (name_len > 511UL) {
#line 1008
    return ((SPF_errcode_t )17);
  }
  {
#line 1010
  spf_modifier->name_len = (unsigned short )name_len;
#line 1011
  spf_modifier->data_len = (unsigned short)0;
#line 1014
  len = _align_sz(sizeof(SPF_mod_t ) + name_len);
  }
#line 1016
  if (spf_record->mod_len + len > 511UL) {
#line 1017
    return ((SPF_errcode_t )17);
  }
  {
#line 1019
  tmp = SPF_mod_name(spf_modifier);
#line 1019
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)mod_name,
         name_len);
#line 1021
  data = SPF_mod_data(spf_modifier);
#line 1022
  data_len = (size_t )0;
#line 1024
  src_len = strcspn(*mod_value, " ");
#line 1026
  err = SPF_c_parse_macro___7(spf_server___1, spf_response, data, & data_len, (size_t )511,
                              *mod_value, src_len, (SPF_errcode_t )17, 1);
#line 1032
  spf_modifier->data_len = (unsigned short )data_len;
#line 1033
  len += data_len;
  }
#line 1036
  if ((unsigned int )err == 0U) {
    {
#line 1037
    tmp___1 = SPF_c_ensure_capacity___7((void **)(& spf_record->mod_first), & spf_record->mod_size,
                                        spf_record->mod_len + len);
    }
#line 1037
    if (tmp___1 < 0) {
      {
#line 1040
      tmp___0 = SPF_response_add_error_ptr(spf_response, (SPF_errcode_t )1, (char const   *)((void *)0),
                                           (char const   *)((void *)0), "Failed to allocate memory for modifier");
      }
#line 1040
      return (tmp___0);
    }
    {
#line 1044
    memcpy((void */* __restrict  */)((char *)spf_record->mod_first + spf_record->mod_len),
           (void const   */* __restrict  */)spf_modifier, len);
#line 1047
    spf_record->mod_len += len;
#line 1048
    spf_record->num_mod = (unsigned char )((int )spf_record->num_mod + 1);
    }
  }
#line 1051
  return (err);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c"
static void SPF_record_lint___7(SPF_server_t *spf_server___1 , SPF_response_t *spf_response ,
                                SPF_record_t *spf_record ) 
{ 
  SPF_data_t *d ;
  SPF_data_t *data_end ;
  char *s ;
  char *s_end ;
  int found_non_ip ;
  int found_valid_tld ;
  SPF_mech_t *mech ;
  SPF_data_t *data ;
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1075
  mech = spf_record->mech_first;
#line 1076
  i = 0;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (i < (int )spf_record->num_mech)) {
#line 1076
      goto while_break;
    }
#line 1081
    if ((int )mech->mech_type == 8) {
#line 1081
      goto _L;
    } else
#line 1081
    if ((int )mech->mech_type == 9) {
      _L: /* CIL Label */ 
#line 1081
      if (i != (int )spf_record->num_mech - 1) {
        {
#line 1085
        SPF_response_add_warn(spf_response, (SPF_errcode_t )29, "Mechanisms found after the \"all:\" mechanism will be ignored.");
        }
      }
    }
#line 1098
    if ((int )mech->mech_type == 5) {
#line 1100
      goto __Cont;
    } else
#line 1098
    if ((int )mech->mech_type == 6) {
#line 1100
      goto __Cont;
    }
    {
#line 1102
    data = SPF_mech_data(mech);
#line 1103
    data_end = SPF_mech_end_data(mech);
    }
#line 1104
    if ((unsigned long )data == (unsigned long )data_end) {
#line 1105
      goto __Cont;
    }
#line 1107
    if ((int )data->dc.parm_type == 11) {
      {
#line 1109
      data = SPF_data_next(data);
      }
#line 1110
      if ((unsigned long )data == (unsigned long )data_end) {
#line 1111
        goto __Cont;
      }
    }
#line 1115
    found_valid_tld = 0;
#line 1116
    found_non_ip = 0;
#line 1118
    d = data;
    {
#line 1118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1118
      if (! ((unsigned long )d < (unsigned long )data_end)) {
#line 1118
        goto while_break___0;
      }
      {
#line 1122
      if ((int )d->dv.parm_type == 11) {
#line 1122
        goto case_11;
      }
#line 1128
      if ((int )d->dv.parm_type == 0) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 5) {
#line 1128
        goto case_0;
      }
#line 1128
      if ((int )d->dv.parm_type == 4) {
#line 1128
        goto case_0;
      }
#line 1132
      if ((int )d->dv.parm_type == 12) {
#line 1132
        goto case_12;
      }
#line 1148
      goto switch_default;
      case_11: /* CIL Label */ 
      {
#line 1123
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_compile.c",
                 1123, "%s", "Multiple CIDR parameters found");
      }
#line 1124
      goto switch_break;
      case_0: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 1129
      found_valid_tld = 0;
#line 1130
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 1133
      found_valid_tld = 0;
#line 1135
      s = SPF_data_str(d);
#line 1136
      s_end = s + (int )d->ds.len;
      }
      {
#line 1137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1137
        if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 1137
          goto while_break___1;
        }
        {
#line 1138
        tmp = __ctype_b_loc();
        }
#line 1138
        if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 2048)) {
#line 1138
          if ((int )*s != 46) {
#line 1138
            if ((int )*s != 58) {
#line 1139
              found_non_ip = 1;
            }
          }
        }
#line 1141
        if ((int )*s == 46) {
#line 1142
          found_valid_tld = 1;
        } else {
          {
#line 1143
          tmp___0 = __ctype_b_loc();
          }
#line 1143
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 1024)) {
#line 1144
            found_valid_tld = 0;
          }
        }
#line 1137
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1146
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1149
      found_non_ip = 1;
#line 1150
      found_valid_tld = 1;
#line 1152
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1118
      d = SPF_data_next(d);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1156
    if (! found_valid_tld) {
#line 1156
      goto _L___0;
    } else
#line 1156
    if (! found_non_ip) {
      _L___0: /* CIL Label */ 
#line 1157
      if (! found_non_ip) {
        {
#line 1158
        SPF_response_add_warn(spf_response, (SPF_errcode_t )27, "Invalid hostname (an IP address?)");
        }
      } else
#line 1160
      if (! found_valid_tld) {
        {
#line 1161
        SPF_response_add_warn(spf_response, (SPF_errcode_t )28, "Hostname has a missing or invalid TLD");
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 1076
    i ++;
#line 1076
    mech = SPF_mech_next(mech);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1168
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
static void setsection___3(ns_msg *msg , ns_sect sect ) ;
#line 197 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libreplace/__ns_initparse.c"
static void setsection___3(ns_msg *msg , ns_sect sect ) 
{ 


  {
#line 199
  msg->_sect = sect;
#line 200
  if ((unsigned int )sect == 4U) {
#line 201
    msg->_rrnum = -1;
#line 202
    msg->_msg_ptr = (u_char const   *)((void *)0);
  } else {
#line 204
    msg->_rrnum = 0;
#line 205
    msg->_msg_ptr = msg->_sections[(int )sect];
  }
#line 207
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
static SPF_response_t *SPF_response_choose___3(SPF_response_t *yes , SPF_response_t *no ) 
{ 


  {
  {
#line 80
  SPF_response_free(no);
  }
#line 81
  return (yes);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c"
static SPF_errcode_t SPF_response_add_error_v___3(SPF_response_t *rp , SPF_errcode_t code ,
                                                  int is_error , char const   *text ,
                                                  int idx , char const   *format ,
                                                  va_list ap ) 
{ 
  SPF_error_t *tmp ;
  char buf[4096] ;
  int size ;
  void *tmp___0 ;

  {
#line 198
  if (! format) {
    {
#line 199
    format = SPF_strerror(code);
    }
  }
  {
#line 200
  size = vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
                   ap);
  }
#line 201
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
#line 202
    snprintf((char */* __restrict  */)(& buf[size]), sizeof(buf) - (unsigned long )size,
             (char const   */* __restrict  */)" near \'%.12s\'", text + idx);
    }
  }
#line 205
  buf[4095] = (char )'\000';
#line 207
  if ((int )rp->errors_length == (int )rp->errors_size) {
    {
#line 208
    size = ((int )rp->errors_size + (int )rp->errors_size / 4) + 4;
#line 209
    tmp___0 = realloc((void *)rp->errors, (unsigned long )size * sizeof(SPF_error_t ));
#line 209
    tmp = (SPF_error_t *)tmp___0;
    }
#line 210
    if (! tmp) {
      {
#line 211
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_response.c",
                 211, "%s", "Failed to allocate memory for extra response error");
      }
#line 212
      return (code);
    }
#line 214
    rp->errors = tmp;
#line 215
    rp->errors_size = (unsigned short )size;
  }
  {
#line 218
  (rp->errors + rp->errors_length)->code = code;
#line 219
  (rp->errors + rp->errors_length)->is_error = (char )is_error;
#line 221
  (rp->errors + rp->errors_length)->message = strdup((char const   *)(buf));
#line 222
  rp->errors_length = (unsigned short )((int )rp->errors_length + 1);
  }
#line 224
  return (code);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static struct res_sym  const  ns_sects___7[4]  = {      {0, (char *)"QUESTION", (char *)"Question"}, 
        {1, (char *)"ANSWER", (char *)"Answer"}, 
        {2, (char *)"AUTHORITY", (char *)"Authority"}, 
        {3, (char *)"ADDITIONAL", (char *)"Additional"}};
#line 79 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static int const   num_ns_sect___7  =    (int const   )(sizeof(ns_sects___7) / sizeof(ns_sects___7[0]));
#line 89 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_once_t res_state_control___7  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static pthread_key_t res_state_key___7  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_thread_term___7(void *arg ) 
{ 


  {
  {
#line 98
  __res_nclose((struct __res_state *)arg);
#line 100
  free(arg);
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_init_key___7(void) 
{ 


  {
  {
#line 106
  pthread_key_create(& res_state_key___7, & SPF_dns_resolv_thread_term___7);
  }
#line 107
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_debug___7(SPF_dns_server_t *spf_dns_server , ns_rr rr ,
                                     u_char const   *responsebuf , size_t responselen ,
                                     u_char const   *rdata , size_t rdlen ) 
{ 
  char ip4_buf[16] ;
  char ip6_buf[46] ;
  char name_buf[1025] ;
  int prio ;
  int err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  u_int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 123
  if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 123
    goto case_1;
  }
#line 132
  if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 132
    goto case_28;
  }
#line 141
  if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 141
    goto case_2;
  }
#line 153
  if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 153
    goto case_5;
  }
#line 165
  if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 165
    goto case_15;
  }
#line 182
  if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 182
    goto case_16;
  }
#line 193
  if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 193
    goto case_12;
  }
#line 205
  goto switch_default;
  case_1: /* CIL Label */ 
#line 124
  if (rdlen != 4UL) {
    {
#line 125
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               125, "A: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 127
    tmp = inet_ntop(2, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip4_buf),
                    (socklen_t )sizeof(ip4_buf));
#line 127
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               129, "A: %s", tmp);
    }
  }
#line 130
  goto switch_break;
  case_28: /* CIL Label */ 
#line 133
  if (rdlen != 16UL) {
    {
#line 134
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               134, "AAAA: wrong rdlen %lu", rdlen);
    }
  } else {
    {
#line 136
    tmp___0 = inet_ntop(10, (void const   */* __restrict  */)rdata, (char */* __restrict  */)(ip6_buf),
                        (socklen_t )sizeof(ip6_buf));
#line 136
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               138, "AAAA: %s", tmp___0);
    }
  }
#line 139
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 142
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 146
  if (err < 0) {
    {
#line 147
    tmp___1 = __errno_location();
#line 147
    tmp___2 = __errno_location();
#line 147
    tmp___3 = strerror(*tmp___2);
#line 147
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               148, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___3,
               *tmp___1);
    }
  } else {
    {
#line 150
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               150, "NS: %s", name_buf);
    }
  }
#line 151
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 154
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 158
  if (err < 0) {
    {
#line 159
    tmp___4 = __errno_location();
#line 159
    tmp___5 = __errno_location();
#line 159
    tmp___6 = strerror(*tmp___5);
#line 159
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               160, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___6,
               *tmp___4);
    }
  } else {
    {
#line 162
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               162, "CNAME: %s", name_buf);
    }
  }
#line 163
  goto switch_break;
  case_15: /* CIL Label */ 
#line 166
  if (rdlen < 2UL) {
    {
#line 167
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               167, "MX: rdlen too short: %lu", rdlen);
    }
#line 168
    goto switch_break;
  }
  {
#line 170
  tmp___7 = ns_get16(rdata);
#line 170
  prio = (int )tmp___7;
#line 171
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata + 2, name_buf,
                           sizeof(name_buf));
  }
#line 175
  if (err < 0) {
    {
#line 176
    tmp___8 = __errno_location();
#line 176
    tmp___9 = __errno_location();
#line 176
    tmp___10 = strerror(*tmp___9);
#line 176
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               177, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___10,
               *tmp___8);
    }
  } else {
    {
#line 179
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               179, "MX: %d %s", prio, name_buf);
    }
  }
#line 180
  goto switch_break;
  case_16: /* CIL Label */ 
#line 183
  if (rdlen < 1UL) {
    {
#line 184
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               184, "TXT: rdlen too short: %lu", rdlen);
    }
#line 185
    goto switch_break;
  }
  {
#line 189
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             190, "TXT: (%lu) \"%.*s\"", rdlen, (int )rdlen - 1, rdata + 1);
  }
#line 191
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 194
  err = ns_name_uncompress(responsebuf, responsebuf + responselen, rdata, name_buf,
                           sizeof(name_buf));
  }
#line 198
  if (err < 0) {
    {
#line 199
    tmp___11 = __errno_location();
#line 199
    tmp___12 = __errno_location();
#line 199
    tmp___13 = strerror(*tmp___12);
#line 199
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               200, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___13,
               *tmp___11);
    }
  } else {
    {
#line 202
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               202, "PTR: %s", name_buf);
    }
  }
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 206
  SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
             206, "not parsed:  type: %d", (unsigned int )((ns_type )((int )rr.type)));
  }
#line 207
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static SPF_dns_rr_t *SPF_dns_resolv_lookup___7(SPF_dns_server_t *spf_dns_server ,
                                               char const   *domain , ns_type rr_type ,
                                               int should_cache ) 
{ 
  SPF_dns_rr_t *spfrr ;
  int err ;
  int i ;
  int nrec ;
  int cnt ;
  u_char *responsebuf ;
  size_t responselen ;
  ns_msg ns_handle ;
  ns_rr rr ;
  int ns_sect___0 ;
  char name_buf[1025] ;
  size_t rdlen ;
  u_char const   *rdata ;
  void *res_spec ;
  struct __res_state *res_state___0 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int dns_len ;
  char const   *tmp___2 ;
  SPF_dns_rr_t *tmp___3 ;
  SPF_dns_rr_t *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  SPF_errcode_t tmp___20 ;
  SPF_errcode_t tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  SPF_errcode_t tmp___26 ;
  u_char *src ;
  u_char *dst ;
  size_t len ;
  SPF_errcode_t tmp___27 ;
  SPF_errcode_t tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  SPF_errcode_t tmp___33 ;

  {
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 247
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 247, "%s", "spf_dns_server is NULL");
      }
    }
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  res_spec = pthread_getspecific(res_state_key___7);
  }
#line 252
  if ((unsigned long )res_spec == (unsigned long )((void *)0)) {
    {
#line 253
    tmp = malloc(sizeof(struct __res_state ));
#line 253
    res_state___0 = (struct __res_state *)tmp;
    }
#line 257
    if (! res_state___0) {
      {
#line 258
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 259, "Failed to allocate %lu bytes for res_state", sizeof(struct __res_state ));
      }
    }
    {
#line 260
    memset((void *)res_state___0, 0, sizeof(struct __res_state ));
#line 261
    tmp___0 = __res_ninit(res_state___0);
    }
#line 261
    if (tmp___0 != 0) {
      {
#line 262
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 262, "%s", "Failed to call res_ninit()");
      }
    }
    {
#line 263
    pthread_setspecific(res_state_key___7, (void const   *)((void *)res_state___0));
    }
  } else {
#line 266
    res_state___0 = (struct __res_state *)res_spec;
  }
  {
#line 270
  responselen = (size_t )2048;
#line 271
  tmp___1 = malloc(responselen);
#line 271
  responsebuf = (u_char *)tmp___1;
  }
#line 272
  if (! responsebuf) {
#line 273
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 274
  memset((void *)responsebuf, 0, responselen);
  }
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 297
    dns_len = __res_nquery(res_state___0, domain, 1, (int )rr_type, responsebuf, (int )responselen);
    }
#line 304
    if (dns_len < 0) {
      {
#line 307
      free((void *)responsebuf);
      }
#line 308
      if (spf_dns_server->debug) {
        {
#line 309
        tmp___2 = hstrerror(res_state___0->res_h_errno);
#line 309
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   311, "query failed: err = %d  %s (%d): %s", dns_len, tmp___2, res_state___0->res_h_errno,
                   domain);
        }
      }
#line 312
      if (res_state___0->res_h_errno == 1) {
#line 312
        if ((unsigned long )spf_dns_server->layer_below != (unsigned long )((void *)0)) {
          {
#line 314
          tmp___3 = SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
          }
#line 314
          return (tmp___3);
        }
      }
      {
#line 317
      tmp___4 = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, res_state___0->res_h_errno);
      }
#line 317
      return (tmp___4);
    } else
#line 320
    if ((size_t )dns_len > responselen) {
      {
#line 323
      responselen = (size_t )(dns_len + (dns_len >> 1));
#line 332
      tmp___5 = realloc((void *)responsebuf, responselen);
      }
#line 333
      if (! tmp___5) {
        {
#line 334
        free((void *)responsebuf);
        }
#line 335
        return ((SPF_dns_rr_t *)((void *)0));
      }
#line 337
      responsebuf = (u_char *)tmp___5;
    } else {
#line 341
      responselen = (size_t )dns_len;
#line 342
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 351
  spfrr = SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, 0);
  }
#line 353
  if (! spfrr) {
    {
#line 354
    free((void *)responsebuf);
    }
#line 355
    return ((SPF_dns_rr_t *)((void *)0));
  }
  {
#line 358
  err = ns_initparse((u_char const   *)responsebuf, (int )responselen, & ns_handle);
  }
#line 360
  if (err < 0) {
#line 361
    if (spf_dns_server->debug) {
      {
#line 362
      tmp___6 = __errno_location();
#line 362
      tmp___7 = __errno_location();
#line 362
      tmp___8 = strerror(*tmp___7);
#line 362
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 363, "ns_initparse failed: err = %d  %s (%d)", err, tmp___8, *tmp___6);
      }
    }
    {
#line 364
    free((void *)responsebuf);
#line 367
    spfrr->herrno = 3;
    }
#line 368
    return (spfrr);
  }
#line 372
  if (spf_dns_server->debug > 1) {
    {
#line 373
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               373, "msg id:             %d", (int )ns_handle._id);
#line 374
    tmp___9 = ns_msg_getflag(ns_handle, 0);
#line 374
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               374, "ns_f_qr quest/resp: %d", tmp___9);
#line 375
    tmp___10 = ns_msg_getflag(ns_handle, 1);
#line 375
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               375, "ns_f_opcode:        %d", tmp___10);
#line 376
    tmp___11 = ns_msg_getflag(ns_handle, 2);
#line 376
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               376, "ns_f_aa auth ans:   %d", tmp___11);
#line 377
    tmp___12 = ns_msg_getflag(ns_handle, 3);
#line 377
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               377, "ns_f_tc truncated:  %d", tmp___12);
#line 378
    tmp___13 = ns_msg_getflag(ns_handle, 4);
#line 378
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               378, "ns_f_rd rec desire: %d", tmp___13);
#line 379
    tmp___14 = ns_msg_getflag(ns_handle, 5);
#line 379
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               379, "ns_f_ra rec avail:  %d", tmp___14);
#line 380
    tmp___15 = ns_msg_getflag(ns_handle, 9);
#line 380
    SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
               380, "ns_f_rcode:         %d", tmp___15);
    }
  }
#line 385
  ns_sect___0 = 0;
  {
#line 385
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 385
    if (! (ns_sect___0 < (int )num_ns_sect___7)) {
#line 385
      goto while_break___1;
    }
#line 391
    if (ns_sects___7[ns_sect___0].number != 1) {
#line 391
      if (spf_dns_server->debug <= 1) {
#line 392
        goto __Cont;
      }
    }
#line 394
    nrec = (int )ns_handle._counts[ns_sects___7[ns_sect___0].number];
#line 396
    if (spf_dns_server->debug > 1) {
      {
#line 397
      SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 397, "%s:  %d", ns_sects___7[ns_sect___0].name, nrec);
      }
    }
#line 399
    spfrr->num_rr = 0;
#line 400
    cnt = 0;
#line 401
    i = 0;
    {
#line 401
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 401
      if (! (i < nrec)) {
#line 401
        goto while_break___2;
      }
      {
#line 402
      err = ns_parserr(& ns_handle, (ns_sect )ns_sects___7[ns_sect___0].number, i,
                       & rr);
      }
#line 403
      if (err < 0) {
#line 404
        if (spf_dns_server->debug > 1) {
          {
#line 405
          tmp___16 = __errno_location();
#line 405
          tmp___17 = __errno_location();
#line 405
          tmp___18 = strerror(*tmp___17);
#line 405
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     406, "ns_parserr failed: err = %d  %s (%d)", err, tmp___18, *tmp___16);
          }
        }
        {
#line 407
        free((void *)responsebuf);
#line 410
        spfrr->herrno = 3;
        }
#line 411
        return (spfrr);
      }
#line 414
      rdlen = (size_t )((int )rr.rdlength);
#line 415
      if (spf_dns_server->debug > 1) {
#line 416
        if ((int )rr.name[0] != 0) {
#line 416
          tmp___19 = (char const   *)(rr.name);
        } else {
#line 416
          tmp___19 = ".";
        }
        {
#line 416
        SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                   418, "name: %s  type: %d  class: %d  ttl: %d  rdlen: %lu", tmp___19,
                   (unsigned int )((ns_type )((int )rr.type)), (unsigned int )((ns_class )((int )rr.rr_class)),
                   rr.ttl, rdlen);
        }
      }
#line 420
      if (rdlen <= 0UL) {
#line 421
        goto __Cont___0;
      }
#line 423
      rdata = rr.rdata + 0;
#line 425
      if (spf_dns_server->debug > 1) {
        {
#line 426
        SPF_dns_resolv_debug___7(spf_dns_server, rr, (u_char const   *)responsebuf,
                                 responselen, rdata, rdlen);
        }
      }
#line 430
      if (ns_sects___7[ns_sect___0].number != 1) {
#line 431
        goto __Cont___0;
      }
#line 434
      if ((unsigned int )((ns_type )((int )rr.type)) != (unsigned int )spfrr->rr_type) {
#line 434
        if ((unsigned int )((ns_type )((int )rr.type)) != 5U) {
          {
#line 435
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     436, "unexpected rr type: %d   expected: %d", (unsigned int )((ns_type )((int )rr.type)),
                     (unsigned int )rr_type);
          }
#line 437
          goto __Cont___0;
        }
      }
      {
#line 441
      if ((unsigned int )((ns_type )((int )rr.type)) == 1U) {
#line 441
        goto case_1;
      }
#line 458
      if ((unsigned int )((ns_type )((int )rr.type)) == 28U) {
#line 458
        goto case_28;
      }
#line 475
      if ((unsigned int )((ns_type )((int )rr.type)) == 2U) {
#line 475
        goto case_2;
      }
#line 478
      if ((unsigned int )((ns_type )((int )rr.type)) == 5U) {
#line 478
        goto case_5;
      }
#line 482
      if ((unsigned int )((ns_type )((int )rr.type)) == 15U) {
#line 482
        goto case_15;
      }
#line 513
      if ((unsigned int )((ns_type )((int )rr.type)) == 16U) {
#line 513
        goto case_16;
      }
#line 562
      if ((unsigned int )((ns_type )((int )rr.type)) == 12U) {
#line 562
        goto case_12;
      }
#line 588
      goto switch_default;
      case_1: /* CIL Label */ 
#line 442
      if (rdlen != 4UL) {
        {
#line 444
        free((void *)responsebuf);
        }
#line 445
        return (spfrr);
      }
      {
#line 447
      tmp___20 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->a));
      }
#line 447
      if ((unsigned int )tmp___20 != 0U) {
        {
#line 449
        free((void *)responsebuf);
        }
#line 452
        return (spfrr);
      }
      {
#line 454
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->a), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->a));
#line 455
      cnt ++;
      }
#line 456
      goto switch_break;
      case_28: /* CIL Label */ 
#line 459
      if (rdlen != 16UL) {
        {
#line 461
        free((void *)responsebuf);
        }
#line 462
        return (spfrr);
      }
      {
#line 464
      tmp___21 = SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof((*(spfrr->rr + cnt))->aaaa));
      }
#line 464
      if ((unsigned int )tmp___21 != 0U) {
        {
#line 466
        free((void *)responsebuf);
        }
#line 469
        return (spfrr);
      }
      {
#line 471
      memcpy((void */* __restrict  */)(& (*(spfrr->rr + cnt))->aaaa), (void const   */* __restrict  */)rdata,
             sizeof((*(spfrr->rr + cnt))->aaaa));
#line 472
      cnt ++;
      }
#line 473
      goto switch_break;
      case_2: /* CIL Label */ 
#line 476
      goto switch_break;
      case_5: /* CIL Label */ 
#line 480
      goto switch_break;
      case_15: /* CIL Label */ 
#line 483
      if (rdlen < 2UL) {
        {
#line 485
        free((void *)responsebuf);
        }
#line 486
        return (spfrr);
      }
      {
#line 488
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata + 2, name_buf, sizeof(name_buf));
      }
#line 492
      if (err < 0) {
#line 493
        if (spf_dns_server->debug > 1) {
          {
#line 494
          tmp___22 = __errno_location();
#line 494
          tmp___23 = __errno_location();
#line 494
          tmp___24 = strerror(*tmp___23);
#line 494
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     495, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___24,
                     *tmp___22);
          }
        }
        {
#line 496
        free((void *)responsebuf);
        }
#line 499
        return (spfrr);
      }
      {
#line 502
      tmp___25 = strlen((char const   *)(name_buf));
#line 502
      tmp___26 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___25 + 1UL);
      }
#line 502
      if ((unsigned int )tmp___26 != 0U) {
        {
#line 504
        free((void *)responsebuf);
        }
#line 507
        return (spfrr);
      }
      {
#line 509
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->mx), (char const   */* __restrict  */)(name_buf));
#line 510
      cnt ++;
      }
#line 511
      goto switch_break;
      case_16: /* CIL Label */ 
#line 514
      if (rdlen > 1UL) {
        {
#line 520
        tmp___27 = SPF_dns_rr_buf_realloc(spfrr, cnt, rdlen);
        }
#line 520
        if ((unsigned int )tmp___27 != 0U) {
          {
#line 521
          free((void *)responsebuf);
          }
#line 524
          return (spfrr);
        }
#line 527
        dst = (u_char *)((*(spfrr->rr + cnt))->txt);
#line 528
        src = (u_char *)rdata;
#line 529
        len = (size_t )0;
        {
#line 530
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 530
          if (! (rdlen > 0UL)) {
#line 530
            goto while_break___3;
          }
#line 532
          len = (size_t )*src;
#line 533
          src ++;
#line 534
          rdlen --;
#line 538
          if (len > rdlen) {
#line 539
            len = rdlen;
          }
          {
#line 540
          memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src,
                 len);
#line 543
          src += len;
#line 544
          dst += len;
#line 545
          rdlen -= len;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 547
        *dst = (u_char )'\000';
      } else {
        {
#line 550
        tmp___28 = SPF_dns_rr_buf_realloc(spfrr, cnt, (size_t )1);
        }
#line 550
        if ((unsigned int )tmp___28 != 0U) {
          {
#line 551
          free((void *)responsebuf);
          }
#line 554
          return (spfrr);
        }
#line 556
        (*(spfrr->rr + cnt))->txt[0] = (char )'\000';
      }
#line 559
      cnt ++;
#line 560
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 563
      err = ns_name_uncompress((u_char const   *)responsebuf, (u_char const   *)(responsebuf + responselen),
                               rdata, name_buf, sizeof(name_buf));
      }
#line 567
      if (err < 0) {
#line 568
        if (spf_dns_server->debug > 1) {
          {
#line 569
          tmp___29 = __errno_location();
#line 569
          tmp___30 = __errno_location();
#line 569
          tmp___31 = strerror(*tmp___30);
#line 569
          SPF_debugx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                     570, "ns_name_uncompress failed: err = %d  %s (%d)", err, tmp___31,
                     *tmp___29);
          }
        }
        {
#line 571
        free((void *)responsebuf);
        }
#line 574
        return (spfrr);
      }
      {
#line 577
      tmp___32 = strlen((char const   *)(name_buf));
#line 577
      tmp___33 = SPF_dns_rr_buf_realloc(spfrr, cnt, tmp___32 + 1UL);
      }
#line 577
      if ((unsigned int )tmp___33 != 0U) {
        {
#line 579
        free((void *)responsebuf);
        }
#line 582
        return (spfrr);
      }
      {
#line 584
      strcpy((char */* __restrict  */)((*(spfrr->rr + cnt))->ptr), (char const   */* __restrict  */)(name_buf));
#line 585
      cnt ++;
      }
#line 586
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 589
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 401
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 593
    spfrr->num_rr = cnt;
    __Cont: /* CIL Label */ 
#line 385
    ns_sect___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 596
  if (spfrr->num_rr == 0) {
#line 597
    spfrr->herrno = 4;
  }
  {
#line 599
  free((void *)responsebuf);
  }
#line 600
  return (spfrr);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c"
static void SPF_dns_resolv_free___7(SPF_dns_server_t *spf_dns_server ) 
{ 


  {
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if ((unsigned long )spf_dns_server == (unsigned long )((void *)0)) {
      {
#line 607
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_resolv.c",
                 607, "%s", "spf_dns_server is NULL");
      }
    }
#line 607
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  free((void *)spf_dns_server);
  }
#line 614
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_get_exp.c"
static SPF_errcode_t SPF_server_get_default_explanation___7(SPF_server_t *spf_server___1 ,
                                                            SPF_request_t *spf_request ,
                                                            SPF_response_t *spf_response ,
                                                            char **bufp , size_t *buflenp ) 
{ 
  SPF_errcode_t err ;
  SPF_macro_t *spf_macro ;
  SPF_data_t *tmp ;
  size_t len ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  spf_macro = spf_server___1->explanation;
#line 56
  if ((unsigned long )spf_macro != (unsigned long )((void *)0)) {
    {
#line 57
    tmp = SPF_macro_data(spf_macro);
#line 57
    err = SPF_record_expand_data(spf_server___1, spf_request, spf_response, tmp, spf_macro->macro_len,
                                 bufp, buflenp);
    }
#line 61
    return (err);
  } else {
#line 64
    len = sizeof("SPF failure: no explanation available") + 1UL;
#line 65
    if (*buflenp < len) {
      {
#line 66
      tmp___1 = realloc((void *)*bufp, len);
#line 66
      tmp___0 = (char *)tmp___1;
      }
#line 67
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 68
        return ((SPF_errcode_t )1);
      }
#line 69
      *bufp = tmp___0;
#line 70
      *buflenp = len;
    }
    {
#line 72
    strcpy((char */* __restrict  */)*bufp, (char const   */* __restrict  */)"SPF failure: no explanation available");
    }
#line 73
    return ((SPF_errcode_t )0);
  }
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
static SPF_dns_test_data_t const   SPF_dns_db___7[175]  = 
#line 59 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_dns_test.c"
  {      {"localhost", 1, 0, "127.0.0.1"}, 
        {"example.com", 1, 0, "192.0.2.3"}, 
        {"example.com", 15, 0, "mx.example.org"}, 
        {"example.com", 16, 0, "v=spf1 mx -all"}, 
        {"3.2.0.192.in-addr.arpa", 12, 0, "mx.example.org"}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}, 
        {"noexist.example.com", 1, 1, (char const   *)((void *)0)}, 
        {"mx.example.org", 1, 0, "192.0.2.3"}, 
        {"mx.example.org", 28, 0, "5f05:2000:80ad:5800::1"}, 
        {"email.example.com", 16, 0, "v=spf1 -all"}, 
        {"*.example.com", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.org", 255, 1, (char const   *)((void *)0)}, 
        {"*.example.net", 255, 1, (char const   *)((void *)0)}, 
        {"01.spf1-test.mailzone.com", 16, 0, "v=spf1                                                             "}, 
        {"02.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             -all       "}, 
        {"03.spf1-test.mailzone.com", 16, 0, "v=spf1                                             ~all"}, 
        {"05.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             default=deny   "}, 
        {"06.spf1-test.mailzone.com",
      16, 0, "v=spf1                                             ?all "}, 
        {"07.spf1-test.mailzone.com", 16, 0, "v=spf2                                             default=bogus   "}, 
        {"08.spf1-test.mailzone.com",
      16, 0, "v=spf1                       -all      ?all  "}, 
        {"09.spf1-test.mailzone.com", 16, 0, "v=spf1    scope=header-from scope=envelope         -all  "}, 
        {"10.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx                                          -all"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"10.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"11.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com                          -all"}, 
        {"12.spf1-test.mailzone.com",
      15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"12.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"13.spf1-test.mailzone.com", 16, 0, "v=spf1    mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all"}, 
        {"14.spf1-test.mailzone.com",
      15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"14.spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"20.spf1-test.mailzone.com", 1, 0, "192.0.2.120"}, 
        {"20.spf1-test.mailzone.com", 16, 0, "v=spf1 a                                           -all"}, 
        {"21.spf1-test.mailzone.com",
      16, 0, "v=spf1   a:spf1-test.mailzone.com                            -all"}, 
        {"21.spf1-test.mailzone.com",
      1, 0, "192.0.2.121"}, 
        {"22.spf1-test.mailzone.com", 16, 0, "v=spf1 a a:spf1-test.mailzone.com                            -all"}, 
        {"22.spf1-test.mailzone.com",
      1, 0, "192.0.2.122"}, 
        {"30.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr                                         -all"}, 
        {"30.spf1-test.mailzone.com",
      1, 0, "208.210.124.130"}, 
        {"31.spf1-test.mailzone.com", 16, 0, "v=spf1     ptr:spf1-test.mailzone.com                        -all"}, 
        {"31.spf1-test.mailzone.com",
      1, 0, "208.210.124.131"}, 
        {"32.spf1-test.mailzone.com", 16, 0, "v=spf1 ptr ptr:spf1-test.mailzone.com                        -all"}, 
        {"32.spf1-test.mailzone.com",
      1, 0, "208.210.124.132"}, 
        {"40.spf1-test.mailzone.com", 16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d}                    -all"}, 
        {"41.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.spf1-test.mailzone.com            -all"}, 
        {"42.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{ir}.%{v}._spf.%{d} exists:%{ir}.%{v}._spf.%{d3} -all"}, 
        {"45.spf1-test.mailzone.com",
      16, 0, "v=spf1 -a a:spf1-test.mailzone.com                           -all"}, 
        {"45.spf1-test.mailzone.com",
      1, 0, "192.0.2.147"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.145"}, 
        {"45.spf1-test.mailzone.com", 1, 0, "192.0.2.146"}, 
        {"50.spf1-test.mailzone.com", 16, 0, "v=spf1 include                                     -all"}, 
        {"51.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"52.spf1-test.mailzone.com", 16, 0, "v=spf1 include:53.spf1-test.mailzone.com                  -all"}, 
        {"53.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"54.spf1-test.mailzone.com", 16, 0, "v=spf1 include:42.spf1-test.mailzone.com                  -all"}, 
        {"55.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:56.spf1-test.mailzone.com                  -all"}, 
        {"57.spf1-test.mailzone.com", 16, 0, "v=spf1 include:spf1-test.mailzone.com         -all"}, 
        {"58.spf1-test.mailzone.com",
      16, 0, "v=spf1 include:59.spf1-test.mailzone.com                  -all"}, 
        {"59.spf1-test.mailzone.com", 16, 0, "v=spf1 include:58.spf1-test.mailzone.com                  -all"}, 
        {"70.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{lr+=}.lp._spf.spf1-test.mailzone.com -all"}, 
        {"80.spf1-test.mailzone.com", 16, 0, "v=spf1 a mx exists:%{ir}.%{v}._spf.80.spf1-test.mailzone.com ptr -all"}, 
        {"80.spf1-test.mailzone.com",
      1, 0, "208.210.124.180"}, 
        {"90.spf1-test.mailzone.com", 16, 0, "v=spf1  ip4:192.0.2.128/25 -all"}, 
        {"91.spf1-test.mailzone.com", 16, 0, "v=spf1 -ip4:192.0.2.128/25 ip4:192.0.2.0/24 -all"}, 
        {"92.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?ip4:192.0.2.192/26 ip4:192.0.2.128/25 -ip4:192.0.2.0/24 -all"}, 
        {"95.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -all"}, 
        {"96.spf1-test.mailzone.com", 16, 0, "v=spf1 -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"97.spf1-test.mailzone.com",
      16, 0, "v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -exists:%{d}.blacklist.spf1-test.mailzone.com -all"}, 
        {"98.spf1-test.mailzone.com",
      16, 0, "v=spf1 a/26 mx/26 -all"}, 
        {"98.spf1-test.mailzone.com", 15, 0, "80.spf1-test.mailzone.com"}, 
        {"98.spf1-test.mailzone.com", 1, 0, "192.0.2.98"}, 
        {"99.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp=99txt.spf1-test.mailzone.com moo"}, 
        {"99txt.spf1-test.mailzone.com",
      16, 0, "u=%{u} s=%{s} d=%{d} t=%{t} h=%{h} i=%{i} %% U=%{U} S=%{S} D=%{D} T=%{T} H=%{H} I=%{I} %% moo"}, 
        {"100.spf1-test.mailzone.com",
      16, 0, "v=spf1      redirect=98.spf1-test.mailzone.com"}, 
        {"101.spf1-test.mailzone.com", 16, 0, "v=spf1 -all redirect=98.spf1-test.mailzone.com"}, 
        {"102.spf1-test.mailzone.com",
      16, 0, "v=spf1 ?all redirect=98.spf1-test.mailzone.com"}, 
        {"103.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=98.%{d3}"}, 
        {"104.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=105.%{d3}"}, 
        {"105.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=106.%{d3}"}, 
        {"106.spf1-test.mailzone.com", 16, 0, "v=spf1      redirect=107.%{d3}"}, 
        {"107.spf1-test.mailzone.com", 16, 0, "v=spf1       include:104.%{d3}"}, 
        {"110.spf1-test.mailzone.com", 16, 0, "v=spf1 some:unrecognized=mechanism some=unrecognized:modifier -all"}, 
        {"111.spf1-test.mailzone.com",
      16, 0, "v=spf1 mx -a gpg ~all exp=111txt.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"111.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"111txt.2.0.192.in-addr._spf.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"112.spf1-test.mailzone.com",
      16, 0, "v=spf1 a mp3 ~all"}, 
        {"112.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"113.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3: ~all"}, 
        {"113.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114.spf1-test.mailzone.com", 16, 0, "v=spf1 mx -a gpg=test ~all exp=114txt.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com",
      15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"114.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"114txt.spf1-test.mailzone.com", 16, 0, "explanation text"}, 
        {"115.spf1-test.mailzone.com", 16, 0, "v=spf1 a mp3=yes -all"}, 
        {"115.spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"116.spf1-test.mailzone.com", 16, 0, "v=spf1 redirect=116rdr.spf1-test.mailzone.com a"}, 
        {"116.spf1-test.mailzone.com",
      1, 0, "192.0.2.200"}, 
        {"116rdr.spf1-test.mailzone.com", 16, 0, "v=spf1 -all"}, 
        {"117.spf1-test.mailzone.com", 16, 0, " v=spf1 +all"}, 
        {"118.spf1-test.mailzone.com", 16, 0, "v=spf1 -all exp="}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.10"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.11"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.12"}, 
        {"mx01.spf1-test.mailzone.com", 1, 0, "192.0.2.13"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.20"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.21"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.22"}, 
        {"mx02.spf1-test.mailzone.com", 1, 0, "192.0.2.23"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.30"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.31"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.32"}, 
        {"mx03.spf1-test.mailzone.com", 1, 0, "192.0.2.33"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.40"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.41"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.42"}, 
        {"mx04.spf1-test.mailzone.com", 1, 0, "192.0.2.43"}, 
        {"56.spf1-test.mailzone.com", 16, 4, (char const   *)((void *)0)}, 
        {"80.spf1-test.mailzone.com", 15, 4, (char const   *)((void *)0)}, 
        {"servfail.spf1-test.mailzone.com", 16, 2, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com", 15, 0, "mx02.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx03.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 15, 0, "mx01.spf1-test.mailzone.com"}, 
        {"spf1-test.mailzone.com", 1, 0, "208.210.124.192"}, 
        {"spf1-test.mailzone.com", 1, 0, "192.0.2.200"}, 
        {"fallback-relay.spf1-test.mailzone.com", 15, 0, "mx04.spf1-test.mailzone.com"}, 
        {"www1.cnn.com",
      1, 0, "64.236.24.4"}, 
        {"4.24.236.64.in-addr.arpa", 12, 0, "www1.cnn.com"}, 
        {"130.124.210.208.in-addr.arpa", 12, 0, "30.spf1-test.mailzone.com"}, 
        {"131.124.210.208.in-addr.arpa", 12, 0, "31.spf1-test.mailzone.com"}, 
        {"192.124.210.208.in-addr.arpa", 12, 0, "spf1-test.mailzone.com"}, 
        {"100.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"110.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"111.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"101.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"130.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"131.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"80.2.0.192.in-addr._spf.80.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"96.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"97.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com",
      1, 0, "127.0.0.2"}, 
        {"bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"postmaster.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"2.bob.lp._spf.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.joe.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"100.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"102.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"110.2.0.192.in-addr._spf.42.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"131.2.0.192.in-addr._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"4.24.236.64.in-addr._spf.80.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"droid.lp._spf.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"joe-2.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"moe-1.lp._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"unknown.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"180.124.210.208.in-addr.arpa",
      12, 0, "80.spf1-test.mailzone.com"}, 
        {"80.spf1-test.mailzone.com.whitelist.spf1-test.mailzone.com", 1, 0, "127.0.0.2"}, 
        {"1.124.210.208.in-addr.arpa",
      12, 0, "pobox-gw.icgroup.com"}, 
        {"pobox-gw.icgroup.com", 1, 0, "208.210.124.1"}, 
        {"pobox-gw.icgroup.com.whitelist.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"130.2.0.192.in-addr._spf.51.spf1-test.mailzone.com",
      1, 1, (char const   *)((void *)0)}, 
        {"200.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", 1, 1, (char const   *)((void *)0)}, 
        {"spf1-test.mailzone.com",
      16, 1, (char const   *)((void *)0)}, 
        {"spf.trusted-forwarder.org", 16, 0, "v=spf1 exists:%{ir}.wl.trusted-forwarder.org exists:%{p}.wl.trusted-forwarder.org"}, 
        {"*.spf1-text.mailzone.com",
      255, 1, (char const   *)((void *)0)}, 
        {"cat.com", 16, 4, (char const   *)((void *)0)}, 
        {"bar.com", 16, 4, (char const   *)((void *)0)}, 
        {"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa",
      12, 0, "mx.example.org"}};
#line 66 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static SPF_errcode_t ( __attribute__((__warn_unused_result__)) SPF_server_set_rec_dom_ghbn___3)(SPF_server_t *sp ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 70
  tmp = malloc((size_t )64);
#line 70
  sp->rec_dom = (char *)tmp;
  }
#line 71
  if (! sp->rec_dom) {
#line 72
    return ((SPF_errcode_t )1);
  }
  {
#line 77
  tmp___0 = gethostname(sp->rec_dom, (size_t )64);
  }
#line 77
  if (tmp___0 < 0) {
#line 79
    return ((SPF_errcode_t )10);
  }
#line 81
  return ((SPF_errcode_t )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static void SPF_server_new_common_pre___3(SPF_server_t *sp , int debug ) 
{ 
  SPF_errcode_t err ;

  {
  {
#line 89
  memset((void *)sp, 0, sizeof(SPF_server_t ));
#line 91
  sp->max_dns_mech = 10;
#line 92
  sp->max_dns_ptr = 10;
#line 93
  sp->max_dns_mx = 10;
#line 94
  sp->debug = debug;
#line 96
  err = SPF_server_set_rec_dom_ghbn___3(sp);
  }
#line 97
  if ((unsigned int )err != 0U) {
    {
#line 98
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               98, "%s", "Failed to set rec_dom using gethostname()");
    }
  }
#line 99
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c"
static void SPF_server_new_common_post___3(SPF_server_t *sp ) 
{ 
  SPF_response_t *spf_response ;
  SPF_errcode_t err ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 107
  spf_response = (SPF_response_t *)((void *)0);
#line 108
  err = SPF_server_set_explanation(sp, "Please%_see%_http://www.openspf.org/Why?id=%{S}&ip=%{C}&receiver=%{R}",
                                   & spf_response);
  }
#line 110
  if ((unsigned int )err != 0U) {
    {
#line 111
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               111, "Error code %d compiling default explanation", (unsigned int )err);
    }
  }
#line 112
  if (spf_response) {
    {
#line 114
    tmp = SPF_response_messages(spf_response);
    }
#line 114
    if (tmp > 0) {
      {
#line 115
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 115, "%s", "Response errors compiling default explanation");
      }
    }
    {
#line 116
    SPF_response_free(spf_response);
    }
  }
  {
#line 119
  spf_response = (SPF_response_t *)((void *)0);
#line 120
  err = SPF_server_set_localpolicy(sp, "", 0, & spf_response);
  }
#line 121
  if ((unsigned int )err != 0U) {
    {
#line 122
    SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
               122, "Error code %d compiling default whitelist", (unsigned int )err);
    }
  }
#line 123
  if (spf_response) {
    {
#line 125
    tmp___0 = SPF_response_messages(spf_response);
    }
#line 125
    if (tmp___0 > 0) {
      {
#line 126
      SPF_errorx("/home/june/repo/benchmarks/collector/temp/libspf2-1.2.10/src/libspf2/spf_server.c",
                 126, "%s", "Response errors compiling default whitelist");
      }
    }
    {
#line 127
    SPF_response_free(spf_response);
    }
  }
#line 129
  return;
}
}
