/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 80
extern int optopt ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 181 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
char *tokens[187]  = 
#line 37 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
  {      (char *)"copy",      (char *)"",      (char *)"return",      (char *)"", 
        (char *)"clear",      (char *)"",      (char *)"draw",      (char *)"", 
        (char *)"cls",      (char *)"",      (char *)"if",      (char *)"", 
        (char *)"randomize",      (char *)"randomise",      (char *)"save",      (char *)"", 
        (char *)"run",      (char *)"",      (char *)"plot",      (char *)"", 
        (char *)"print",      (char *)"",      (char *)"poke",      (char *)"", 
        (char *)"next",      (char *)"",      (char *)"pause",      (char *)"", 
        (char *)"let",      (char *)"",      (char *)"list",      (char *)"", 
        (char *)"load",      (char *)"",      (char *)"input",      (char *)"", 
        (char *)"go sub",      (char *)"gosub",      (char *)"go to",      (char *)"goto", 
        (char *)"for",      (char *)"",      (char *)"rem",      (char *)"", 
        (char *)"dim",      (char *)"",      (char *)"continue",      (char *)"", 
        (char *)"border",      (char *)"",      (char *)"new",      (char *)"", 
        (char *)"restore",      (char *)"",      (char *)"data",      (char *)"", 
        (char *)"read",      (char *)"",      (char *)"stop",      (char *)"", 
        (char *)"llist",      (char *)"",      (char *)"lprint",      (char *)"", 
        (char *)"out",      (char *)"",      (char *)"over",      (char *)"", 
        (char *)"inverse",      (char *)"",      (char *)"bright",      (char *)"", 
        (char *)"flash",      (char *)"",      (char *)"paper",      (char *)"", 
        (char *)"ink",      (char *)"",      (char *)"circle",      (char *)"", 
        (char *)"beep",      (char *)"",      (char *)"verify",      (char *)"", 
        (char *)"merge",      (char *)"",      (char *)"close #",      (char *)"close#", 
        (char *)"open #",      (char *)"open#",      (char *)"erase",      (char *)"", 
        (char *)"move",      (char *)"",      (char *)"format",      (char *)"", 
        (char *)"cat",      (char *)"",      (char *)"def fn",      (char *)"deffn", 
        (char *)"step",      (char *)"",      (char *)"to",      (char *)"", 
        (char *)"then",      (char *)"",      (char *)"line",      (char *)"", 
        (char *)"<>",      (char *)"",      (char *)">=",      (char *)"", 
        (char *)"<=",      (char *)"",      (char *)"and",      (char *)"", 
        (char *)"or",      (char *)"",      (char *)"bin",      (char *)"", 
        (char *)"not",      (char *)"",      (char *)"chr$",      (char *)"", 
        (char *)"str$",      (char *)"",      (char *)"usr",      (char *)"", 
        (char *)"in",      (char *)"",      (char *)"peek",      (char *)"", 
        (char *)"abs",      (char *)"",      (char *)"sgn",      (char *)"", 
        (char *)"sqr",      (char *)"",      (char *)"int",      (char *)"", 
        (char *)"exp",      (char *)"",      (char *)"ln",      (char *)"", 
        (char *)"atn",      (char *)"",      (char *)"acs",      (char *)"", 
        (char *)"asn",      (char *)"",      (char *)"tan",      (char *)"", 
        (char *)"cos",      (char *)"",      (char *)"sin",      (char *)"", 
        (char *)"len",      (char *)"",      (char *)"val",      (char *)"", 
        (char *)"code",      (char *)"",      (char *)"val$",      (char *)"", 
        (char *)"tab",      (char *)"",      (char *)"at",      (char *)"", 
        (char *)"attr",      (char *)"",      (char *)"screen$",      (char *)"", 
        (char *)"point",      (char *)"",      (char *)"fn",      (char *)"", 
        (char *)"pi",      (char *)"",      (char *)"inkey$",      (char *)"", 
        (char *)"rnd",      (char *)"",      (char *)"play",      (char *)"", 
        (char *)"spectrum",      (char *)"",      (char *)((void *)0)};
#line 147 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
unsigned char filebuf[49152]  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
char infile[1024]  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
char outfile[1024]  ;
#line 154 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
unsigned char headerbuf[17]  ;
#line 156 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
int output_tap  =    1;
#line 156 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
int use_labels  =    0;
#line 157 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
unsigned int startline  =    32768U;
#line 158 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
int autostart  =    10;
#line 158 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
int autoincr  =    2;
#line 159 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
char speccy_filename[11]  ;
#line 161 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
int labelend  =    0;
#line 162 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
unsigned char labels[2000][17]  ;
#line 163 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
int label_lines[2000]  ;
#line 165 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
unsigned char startlabel[17]  ;
#line 235 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
int dbl2spec(double num , int *pexp , unsigned long *pman ) 
{ 
  int exp___0 ;
  unsigned long man ;
  long tmp ;
  double tmp___0 ;
  int f ;

  {
#line 241
  if (num == (double )((long )num)) {
#line 241
    if (num >= - 65535.0) {
#line 241
      if (num <= 65535.0) {
        {
#line 244
        tmp___0 = fabs(num);
#line 244
        tmp = (long )tmp___0;
#line 246
        exp___0 = 0;
#line 247
        man = (unsigned long )((tmp % 256L << 16) | ((tmp >> 8) << 8));
        }
      } else {
#line 241
        goto _L___0;
      }
    } else {
#line 241
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 259
    num = fabs(num);
#line 268
    exp___0 = 0;
    }
    {
#line 269
    while (1) {
      while_continue: /* CIL Label */ ;
#line 269
      if (! (num >= 1.0)) {
#line 269
        goto while_break;
      }
#line 271
      num /= 2.0;
#line 271
      exp___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 274
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 274
      if (! (num < 0.5)) {
#line 274
        goto while_break___0;
      }
#line 276
      num *= 2.0;
#line 276
      exp___0 --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 284
    if (exp___0 < -128) {
#line 284
      return (0);
    } else
#line 284
    if (exp___0 > 127) {
#line 284
      return (0);
    }
#line 286
    exp___0 = 128 + exp___0;
#line 293
    num *= 2.0;
#line 296
    man = 0UL;
#line 297
    f = 0;
    {
#line 297
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 297
      if (! (f < 32)) {
#line 297
        goto while_break___1;
      }
#line 299
      man <<= 1;
#line 300
      man |= (unsigned long )((int )num);
#line 301
      num -= (double )((int )num);
#line 302
      num *= 2.0;
#line 297
      f ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 310
    if ((int )num) {
#line 310
      if (man != 4294967295UL) {
#line 310
        man ++;
      }
    }
#line 313
    man &= 2147483647UL;
  }
#line 317
  *pexp = exp___0;
#line 317
  *pman = man;
#line 318
  return (1);
}
}
#line 324
unsigned long grok_hex(unsigned char **ptrp , int textlinenum ) ;
#line 324 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
static char *hexits  =    (char *)"0123456789abcdefABCDEF";
#line 324 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
static char *lookup  ;
#line 322 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
unsigned long grok_hex(unsigned char **ptrp , int textlinenum ) 
{ 
  unsigned char *ptr ;
  unsigned long v ;
  unsigned long n ;
  char *tmp ;

  {
  {
#line 325
  ptr = *ptrp;
#line 326
  v = 0UL;
#line 330
  ptr += 2;
#line 331
  tmp = strchr((char const   *)hexits, (int )*ptr);
  }
#line 331
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 333
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: bad BIN 0x... number\n",
            textlinenum);
#line 334
    exit(1);
    }
  }
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (*ptr) {
      {
#line 337
      lookup = strchr((char const   *)hexits, (int )*ptr);
      }
#line 337
      if (! ((unsigned long )lookup != (unsigned long )((void *)0))) {
#line 337
        goto while_break;
      }
    } else {
#line 337
      goto while_break;
    }
#line 339
    n = (unsigned long )(lookup - hexits);
#line 340
    if (n > 15UL) {
#line 340
      n -= 6UL;
    }
#line 341
    v = v * 16UL + n;
#line 342
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  *ptrp = ptr;
#line 346
  return (v);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
unsigned long grok_binary(unsigned char **ptrp , int textlinenum ) 
{ 
  unsigned long v ;
  unsigned char *ptr ;
  unsigned short const   **tmp ;
  unsigned long tmp___0 ;

  {
#line 352
  v = 0UL;
#line 353
  ptr = *ptrp;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 355
    tmp = __ctype_b_loc();
    }
#line 355
    if (! ((int const   )*(*tmp + (int )*ptr) & 8192)) {
#line 355
      goto while_break;
    }
#line 355
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  if ((int )*ptr != 48) {
#line 357
    if ((int )*ptr != 49) {
      {
#line 359
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: bad BIN number\n",
              textlinenum);
#line 360
      exit(1);
      }
    }
  }
#line 363
  if ((int )*(ptr + 1) == 120) {
    {
#line 365
    *ptrp = ptr;
#line 366
    tmp___0 = grok_hex(ptrp, textlinenum);
    }
#line 366
    return (tmp___0);
  } else
#line 363
  if ((int )*(ptr + 1) == 88) {
    {
#line 365
    *ptrp = ptr;
#line 366
    tmp___0 = grok_hex(ptrp, textlinenum);
    }
#line 366
    return (tmp___0);
  }
  {
#line 369
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 369
    if (! ((int )*ptr == 48)) {
#line 369
      if (! ((int )*ptr == 49)) {
#line 369
        goto while_break___0;
      }
    }
#line 371
    v *= 2UL;
#line 372
    v += (unsigned long )((int )*ptr - 48);
#line 373
    ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 376
  *ptrp = ptr;
#line 377
  return (v);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
void usage_help(void) 
{ 


  {
  {
#line 383
  printf((char const   */* __restrict  */)"zmakebas - public domain by Russell Marks.\n\n");
#line 385
  printf((char const   */* __restrict  */)"usage: zmakebas [-hlr] [-a line] [-i incr] [-n speccy_filename]\n");
#line 386
  printf((char const   */* __restrict  */)"                [-o output_file] [-s line] [input_file]\n\n");
#line 388
  printf((char const   */* __restrict  */)"        -a      set auto-start line of basic file (default none).\n");
#line 389
  printf((char const   */* __restrict  */)"        -h      give this usage help.\n");
#line 390
  printf((char const   */* __restrict  */)"        -i      in labels mode, set line number incr. (default 2).\n");
#line 391
  printf((char const   */* __restrict  */)"        -l      use labels rather than line numbers.\n");
#line 392
  printf((char const   */* __restrict  */)"        -n      set Spectrum filename (to be given in tape header).");
#line 393
  printf((char const   */* __restrict  */)"\n        -o      specify output file (default `%s\').\n",
         "out.tap");
#line 395
  printf((char const   */* __restrict  */)"        -r      output raw headerless file (default is .tap file).\n");
#line 396
  printf((char const   */* __restrict  */)"        -s      in labels mode, set starting line number ");
#line 397
  printf((char const   */* __restrict  */)"(default 10).\n");
  }
#line 398
  return;
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
void parse_options(int argc , char **argv ) 
{ 
  int done ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 405
  done = 0;
#line 407
  done = 0;
#line 408
  opterr = 0;
#line 409
  startlabel[0] = (unsigned char)0;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 412
    tmp = getopt(argc, (char * const  *)argv, "a:hi:ln:o:rs:");
    }
    {
#line 414
    if (tmp == 97) {
#line 414
      goto case_97;
    }
#line 428
    if (tmp == 104) {
#line 428
      goto case_104;
    }
#line 431
    if (tmp == 105) {
#line 431
      goto case_105;
    }
#line 438
    if (tmp == 108) {
#line 438
      goto case_108;
    }
#line 441
    if (tmp == 110) {
#line 441
      goto case_110;
    }
#line 445
    if (tmp == 111) {
#line 445
      goto case_111;
    }
#line 448
    if (tmp == 114) {
#line 448
      goto case_114;
    }
#line 450
    if (tmp == 115) {
#line 450
      goto case_115;
    }
#line 456
    if (tmp == 63) {
#line 456
      goto case_63;
    }
#line 478
    if (tmp == -1) {
#line 478
      goto case_neg_1;
    }
#line 412
    goto switch_break;
    case_97: /* CIL Label */ 
#line 415
    if ((int )*optarg == 64) {
      {
#line 416
      tmp___0 = strlen((char const   *)(optarg + 1));
      }
#line 416
      if (tmp___0 > 16UL) {
        {
#line 417
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Auto-start label too long\n");
#line 417
        exit(1);
        }
      } else {
        {
#line 419
        strcpy((char */* __restrict  */)(startlabel), (char const   */* __restrict  */)(optarg + 1));
        }
      }
    } else {
      {
#line 422
      tmp___1 = atoi((char const   *)optarg);
#line 422
      startline = (unsigned int )tmp___1;
      }
#line 423
      if (startline > 9999U) {
        {
#line 424
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Auto-start line must be in the range 0 to 9999.\n");
#line 424
        exit(1);
        }
      }
    }
#line 427
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 429
    usage_help();
#line 430
    exit(1);
    }
    case_105: /* CIL Label */ 
    {
#line 432
    tmp___2 = atoi((char const   *)optarg);
#line 432
    autoincr = tmp___2;
    }
#line 434
    if (autoincr < 1) {
      {
#line 435
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Label line incr. must be in the range 1 to 1000.\n");
#line 435
      exit(1);
      }
    } else
#line 434
    if (autoincr > 1000) {
      {
#line 435
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Label line incr. must be in the range 1 to 1000.\n");
#line 435
      exit(1);
      }
    }
#line 437
    goto switch_break;
    case_108: /* CIL Label */ 
#line 439
    use_labels = 1;
#line 440
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 442
    strncpy((char */* __restrict  */)(speccy_filename), (char const   */* __restrict  */)optarg,
            (size_t )10);
#line 443
    speccy_filename[10] = (char)0;
    }
#line 444
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 446
    strcpy((char */* __restrict  */)(outfile), (char const   */* __restrict  */)optarg);
    }
#line 447
    goto switch_break;
    case_114: /* CIL Label */ 
#line 449
    output_tap = 0;
#line 449
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 451
    tmp___3 = atoi((char const   *)optarg);
#line 451
    autostart = tmp___3;
    }
#line 452
    if (autostart < 0) {
      {
#line 453
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Label start line must be in the range 0 to 9999.\n");
#line 453
      exit(1);
      }
    } else
#line 452
    if (autostart > 9999) {
      {
#line 453
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Label start line must be in the range 0 to 9999.\n");
#line 453
      exit(1);
      }
    }
#line 455
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 459
    if (optopt == 97) {
#line 459
      goto case_97___0;
    }
#line 462
    if (optopt == 105) {
#line 462
      goto case_105___0;
    }
#line 465
    if (optopt == 110) {
#line 465
      goto case_110___0;
    }
#line 468
    if (optopt == 111) {
#line 468
      goto case_111___0;
    }
#line 471
    if (optopt == 115) {
#line 471
      goto case_115___0;
    }
#line 474
    goto switch_default;
    case_97___0: /* CIL Label */ 
    {
#line 460
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The `a\' option takes a line number arg.\n");
    }
#line 461
    goto switch_break___0;
    case_105___0: /* CIL Label */ 
    {
#line 463
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The `i\' option takes a line incr. arg.\n");
    }
#line 464
    goto switch_break___0;
    case_110___0: /* CIL Label */ 
    {
#line 466
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The `n\' option takes a Spectrum filename arg.\n");
    }
#line 467
    goto switch_break___0;
    case_111___0: /* CIL Label */ 
    {
#line 469
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The `o\' option takes a filename arg.\n");
    }
#line 470
    goto switch_break___0;
    case_115___0: /* CIL Label */ 
    {
#line 472
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The `s\' option takes a line number arg.\n");
    }
#line 473
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 475
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option `%c\' not recognised.\n",
            optopt);
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 477
    exit(1);
    }
    case_neg_1: /* CIL Label */ 
#line 479
    done = 1;
    switch_break: /* CIL Label */ ;
    }
#line 411
    if (! (! done)) {
#line 411
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 483
  if (optind < argc - 1) {
    {
#line 484
    usage_help();
#line 484
    exit(1);
    }
  }
#line 486
  if (optind == argc - 1) {
    {
#line 487
    strcpy((char */* __restrict  */)(infile), (char const   */* __restrict  */)*(argv + optind));
    }
  }
#line 488
  return;
}
}
#line 493
int grok_block(unsigned char *ptr , int textlinenum ) ;
#line 493 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
static char *lookup___0[17]  = 
#line 493
  {      (char *)"  ",      (char *)" \'",      (char *)"\' ",      (char *)"\'\'", 
        (char *)" .",      (char *)" :",      (char *)"\'.",      (char *)"\':", 
        (char *)". ",      (char *)".\'",      (char *)": ",      (char *)":\'", 
        (char *)"..",      (char *)".:",      (char *)":.",      (char *)"::", 
        (char *)((void *)0)};
#line 491 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
int grok_block(unsigned char *ptr , int textlinenum ) 
{ 
  char **lptr ;
  int f ;
  int v ;
  int tmp ;

  {
#line 500
  f = 128;
#line 500
  v = -1;
#line 502
  lptr = lookup___0;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! ((unsigned long )*lptr != (unsigned long )((void *)0))) {
#line 502
      goto while_break;
    }
    {
#line 504
    tmp = strncmp((char const   *)(ptr + 1), (char const   *)*lptr, (size_t )2);
    }
#line 504
    if (tmp == 0) {
#line 506
      v = f;
#line 507
      goto while_break;
    }
#line 502
    lptr ++;
#line 502
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 511
  if (v == -1) {
    {
#line 513
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: invalid block graphics escape\n",
            textlinenum);
#line 514
    exit(1);
    }
  }
#line 517
  return (v);
}
}
#line 527 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
static unsigned char buf[2048]  ;
#line 527 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
static unsigned char lcasebuf[2048]  ;
#line 527 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
static unsigned char outbuf[4096]  ;
#line 522 "/home/june/repo/benchmarks/collector/temp/zmakebas-1.2/zmakebas.c"
int main(int argc , char **argv ) 
{ 
  int f ;
  int toknum ;
  int toklen ;
  int linenum ;
  int linelen ;
  int in_quotes ;
  int in_rem ;
  int lastline ;
  char **tarrptr ;
  unsigned char *ptr ;
  unsigned char *ptr2 ;
  unsigned char *linestart ;
  unsigned char *outptr ;
  unsigned char *remptr ;
  unsigned char *fileptr ;
  unsigned char *asciiptr ;
  double num ;
  int num_exp ;
  unsigned long num_mantissa ;
  unsigned long num_ascii ;
  int textlinenum ;
  int chk ;
  int alttok ;
  int passnum ;
  FILE *in ;
  FILE *out ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  long tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned short const   **tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  int tmp___20 ;
  unsigned char tmp___21 ;
  unsigned char tmp___22 ;
  unsigned char tmp___23 ;
  unsigned char tmp___24 ;
  unsigned char tmp___25 ;
  char *tmp___26 ;
  unsigned short const   **tmp___27 ;
  unsigned short const   **tmp___28 ;
  size_t tmp___29 ;
  unsigned char tmp___30 ;
  unsigned char tmp___31 ;
  int tmp___32 ;
  unsigned char tmp___33 ;
  unsigned char tmp___34 ;
  unsigned short const   **tmp___35 ;
  unsigned short const   **tmp___36 ;
  char *tmp___37 ;
  int len ;
  size_t tmp___38 ;
  unsigned char numbuf[20] ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;
  char *tmp___43 ;
  unsigned char *tmp___44 ;
  int tmp___45 ;
  unsigned char *tmp___46 ;
  unsigned char *tmp___47 ;
  unsigned char *tmp___48 ;
  unsigned char *tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  unsigned char *tmp___52 ;
  unsigned char *tmp___53 ;
  unsigned short const   **tmp___54 ;
  char *tmp___55 ;
  unsigned long tmp___56 ;
  unsigned char *tmp___57 ;
  int tmp___58 ;
  unsigned char *tmp___59 ;
  unsigned char *tmp___60 ;
  unsigned char *tmp___61 ;
  unsigned char *tmp___62 ;
  unsigned char *tmp___63 ;
  unsigned char *tmp___64 ;
  unsigned char *tmp___65 ;
  unsigned short const   **tmp___66 ;
  unsigned short const   **tmp___67 ;
  unsigned short const   **tmp___68 ;
  unsigned short const   **tmp___69 ;
  unsigned char *tmp___70 ;
  unsigned char *tmp___71 ;
  unsigned char *tmp___72 ;
  unsigned char *tmp___73 ;
  unsigned char *tmp___74 ;
  char *tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  unsigned int siz ;
  size_t tmp___78 ;

  {
  {
#line 536
  chk = 0;
#line 538
  passnum = 1;
#line 539
  in = stdin;
#line 539
  out = stdout;
#line 541
  strcpy((char */* __restrict  */)(speccy_filename), (char const   */* __restrict  */)"");
#line 542
  strcpy((char */* __restrict  */)(infile), (char const   */* __restrict  */)"-");
#line 543
  strcpy((char */* __restrict  */)(outfile), (char const   */* __restrict  */)"out.tap");
#line 545
  parse_options(argc, argv);
#line 547
  tmp = strcmp((char const   *)(infile), "-");
  }
#line 547
  if (tmp != 0) {
    {
#line 547
    in = fopen((char const   */* __restrict  */)(infile), (char const   */* __restrict  */)"r");
    }
#line 547
    if ((unsigned long )in == (unsigned long )((void *)0)) {
      {
#line 548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t open input file.\n");
#line 548
      exit(1);
      }
    }
  }
#line 551
  fileptr = filebuf;
#line 552
  linenum = -1;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (use_labels) {
#line 558
      linenum = autostart - autoincr;
    }
#line 559
    textlinenum = 0;
#line 560
    if (passnum > 1) {
      {
#line 560
      tmp___0 = fseek(in, 0L, 0);
      }
#line 560
      if (tmp___0 != 0) {
        {
#line 562
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Need seekable input for label support\n");
#line 563
        exit(1);
        }
      }
    }
    {
#line 566
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 566
      tmp___75 = fgets((char */* __restrict  */)(buf + 1), (int )(sizeof(buf) - 1UL),
                       (FILE */* __restrict  */)in);
      }
#line 566
      if (! ((unsigned long )tmp___75 != (unsigned long )((void *)0))) {
#line 566
        goto while_break___0;
      }
      {
#line 568
      buf[0] = (unsigned char)32;
#line 569
      textlinenum ++;
#line 570
      lastline = linenum;
#line 572
      tmp___2 = strlen((char const   *)(buf));
      }
#line 572
      if ((int )buf[tmp___2 - 1UL] == 10) {
        {
#line 572
        tmp___1 = strlen((char const   *)(buf));
#line 572
        buf[tmp___1 - 1UL] = (unsigned char)0;
        }
      }
#line 577
      if ((int )buf[1] == 0) {
#line 577
        goto while_continue___0;
      } else
#line 577
      if ((int )buf[1] == 35) {
#line 577
        goto while_continue___0;
      }
      {
#line 580
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 580
        tmp___6 = strlen((char const   *)(buf));
        }
#line 580
        if (! ((int )buf[tmp___6 - 1UL] == 92)) {
#line 580
          goto while_break___1;
        }
        {
#line 582
        tmp___3 = strlen((char const   *)(buf));
#line 582
        f = (int )(tmp___3 - 1UL);
#line 583
        fgets((char */* __restrict  */)(buf + f), (int )(sizeof(buf) - (unsigned long )f),
              (FILE */* __restrict  */)in);
#line 584
        textlinenum ++;
#line 585
        tmp___5 = strlen((char const   *)(buf));
        }
#line 585
        if ((int )buf[tmp___5 - 1UL] == 10) {
          {
#line 585
          tmp___4 = strlen((char const   *)(buf));
#line 585
          buf[tmp___4 - 1UL] = (unsigned char)0;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 588
      tmp___7 = strlen((char const   *)(buf));
      }
#line 588
      if (tmp___7 >= (sizeof(buf) - 16UL) - 1UL) {
        {
#line 593
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: line too big for input buffer\n",
                textlinenum);
#line 594
        exit(1);
        }
      }
#line 598
      if (use_labels) {
#line 600
        linestart = buf;
#line 602
        linenum += autoincr;
#line 603
        if (linenum > 9999) {
#line 604
          if (autostart > 1) {
#line 604
            tmp___8 = "try using `-s 1 -i 1\'";
          } else
#line 604
          if (autoincr > 1) {
#line 604
            tmp___8 = "try using `-s 1 -i 1\'";
          } else {
#line 604
            tmp___8 = "too many lines!";
          }
          {
#line 604
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Generated line number is >9999 - %s\n",
                  tmp___8);
#line 604
          exit(1);
          }
        }
      } else {
#line 611
        ptr = buf;
        {
#line 612
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 612
          tmp___9 = __ctype_b_loc();
          }
#line 612
          if (! ((int const   )*(*tmp___9 + (int )*ptr) & 8192)) {
#line 612
            goto while_break___2;
          }
#line 612
          ptr ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 613
        tmp___10 = __ctype_b_loc();
        }
#line 613
        if (! ((int const   )*(*tmp___10 + (int )*ptr) & 2048)) {
          {
#line 615
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: missing line number\n",
                  textlinenum);
#line 616
          exit(1);
          }
        }
        {
#line 618
        tmp___11 = strtol((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((char **)(& linestart)),
                          10);
#line 618
        linenum = (int )tmp___11;
        }
#line 620
        if (linenum <= lastline) {
          {
#line 622
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: line no. not greater than previous one\n",
                  textlinenum);
#line 624
          exit(1);
          }
        }
      }
#line 628
      if (linenum < 0) {
        {
#line 630
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: line no. out of range\n",
                textlinenum);
#line 631
        exit(1);
        }
      } else
#line 628
      if (linenum > 9999) {
        {
#line 630
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: line no. out of range\n",
                textlinenum);
#line 631
        exit(1);
        }
      }
      {
#line 635
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 635
        tmp___12 = __ctype_b_loc();
        }
#line 635
        if (! ((int const   )*(*tmp___12 + (int )*linestart) & 8192)) {
#line 635
          goto while_break___3;
        }
#line 635
        linestart ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 638
      if (use_labels) {
        {
#line 638
        tmp___13 = __ctype_b_loc();
        }
#line 638
        if ((int const   )*(*tmp___13 + (int )*linestart) & 2048) {
          {
#line 640
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: line number used in labels mode\n",
                  textlinenum);
#line 642
          exit(1);
          }
        }
      }
#line 645
      if (use_labels) {
#line 645
        if ((int )*linestart == 64) {
          {
#line 647
          tmp___14 = strchr((char const   *)linestart, ':');
#line 647
          ptr = (unsigned char *)tmp___14;
          }
#line 647
          if ((unsigned long )ptr == (unsigned long )((void *)0)) {
            {
#line 649
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: incomplete token definition\n",
                    textlinenum);
#line 650
            exit(1);
            }
          }
#line 652
          if ((ptr - linestart) - 1L > 16L) {
            {
#line 654
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: token too long\n",
                    textlinenum);
#line 655
            exit(1);
            }
          }
#line 657
          if (passnum == 1) {
            {
#line 659
            *ptr = (unsigned char)0;
#line 660
            label_lines[labelend] = linenum;
#line 661
            tmp___15 = labelend;
#line 661
            labelend ++;
#line 661
            strcpy((char */* __restrict  */)(labels[tmp___15]), (char const   */* __restrict  */)(linestart + 1));
            }
#line 662
            if (labelend >= 2000) {
              {
#line 664
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: too many labels\n",
                      textlinenum);
#line 665
              exit(1);
              }
            }
#line 667
            f = 0;
            {
#line 667
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 667
              if (! (f < labelend - 1)) {
#line 667
                goto while_break___4;
              }
              {
#line 668
              tmp___16 = strcmp((char const   *)(linestart + 1), (char const   *)(labels[f]));
              }
#line 668
              if (tmp___16 == 0) {
                {
#line 670
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iine %d: attempt to redefine label\n",
                        textlinenum);
#line 671
                exit(1);
                }
              }
#line 667
              f ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 673
            *ptr = (unsigned char )':';
          }
#line 676
          linestart = ptr + 1;
          {
#line 677
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 677
            tmp___17 = __ctype_b_loc();
            }
#line 677
            if (! ((int const   )*(*tmp___17 + (int )*linestart) & 8192)) {
#line 677
              goto while_break___5;
            }
#line 677
            linestart ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 683
          if ((int )*linestart == 0) {
#line 685
            linenum -= autoincr;
#line 686
            goto while_continue___0;
          }
        }
      }
#line 690
      if (use_labels) {
#line 690
        if (passnum == 1) {
#line 690
          goto while_continue___0;
        }
      }
#line 695
      ptr = linestart;
#line 695
      in_quotes = 0;
#line 696
      ptr2 = lcasebuf;
      {
#line 697
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 697
        if (! *ptr) {
#line 697
          goto while_break___6;
        }
#line 699
        if ((int )*ptr == 34) {
#line 699
          in_quotes = ! in_quotes;
        }
#line 700
        if (in_quotes) {
#line 700
          if ((int )*ptr != 34) {
#line 701
            tmp___18 = ptr2;
#line 701
            ptr2 ++;
#line 701
            *tmp___18 = (unsigned char)32;
          } else {
            {
#line 703
            tmp___19 = ptr2;
#line 703
            ptr2 ++;
#line 703
            tmp___20 = tolower((int )*ptr);
#line 703
            *tmp___19 = (unsigned char )tmp___20;
            }
          }
        } else {
          {
#line 703
          tmp___19 = ptr2;
#line 703
          ptr2 ++;
#line 703
          tmp___20 = tolower((int )*ptr);
#line 703
          *tmp___19 = (unsigned char )tmp___20;
          }
        }
#line 704
        ptr ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 706
      *ptr2 = (unsigned char)0;
#line 715
      remptr = (unsigned char *)((void *)0);
#line 717
      tmp___26 = strstr((char const   *)(lcasebuf), "rem");
#line 717
      ptr = (unsigned char *)tmp___26;
      }
#line 717
      if ((unsigned long )ptr != (unsigned long )((void *)0)) {
        {
#line 717
        tmp___27 = __ctype_b_loc();
        }
#line 717
        if (! ((int const   )*(*tmp___27 + (int )*(ptr + -1)) & 1024)) {
          {
#line 717
          tmp___28 = __ctype_b_loc();
          }
#line 717
          if (! ((int const   )*(*tmp___28 + (int )*(ptr + 3)) & 1024)) {
#line 720
            ptr2 = linestart + (ptr - lcasebuf);
#line 722
            remptr = ptr2;
#line 723
            tmp___21 = (unsigned char)0;
#line 723
            *ptr = tmp___21;
#line 723
            *remptr = tmp___21;
#line 725
            tmp___24 = (unsigned char)1;
#line 725
            *(ptr + 2) = tmp___24;
#line 725
            tmp___23 = tmp___24;
#line 725
            *(ptr2 + 2) = tmp___23;
#line 725
            tmp___22 = tmp___23;
#line 725
            *(ptr + 1) = tmp___22;
#line 725
            *(ptr2 + 1) = tmp___22;
#line 727
            if ((int )*(ptr + 3) == 32) {
#line 727
              tmp___25 = (unsigned char)1;
#line 727
              *(ptr + 3) = tmp___25;
#line 727
              *(ptr2 + 3) = tmp___25;
            }
          }
        }
      }
#line 730
      toknum = 256;
#line 730
      alttok = 1;
#line 731
      tarrptr = tokens;
      {
#line 731
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 731
        if (! ((unsigned long )*tarrptr != (unsigned long )((void *)0))) {
#line 731
          goto while_break___7;
        }
#line 733
        if (alttok) {
#line 733
          toknum --;
        }
#line 734
        alttok = ! alttok;
#line 735
        if ((int )*(*tarrptr) == 0) {
#line 735
          goto __Cont;
        }
        {
#line 736
        tmp___29 = strlen((char const   *)*tarrptr);
#line 736
        toklen = (int )tmp___29;
#line 737
        ptr = lcasebuf;
        }
        {
#line 738
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 738
          tmp___37 = strstr((char const   *)ptr, (char const   *)*tarrptr);
#line 738
          ptr = (unsigned char *)tmp___37;
          }
#line 738
          if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 738
            goto while_break___8;
          }
#line 743
          if ((int )*(*tarrptr + 0) == 60) {
#line 743
            goto _L;
          } else
#line 743
          if ((int )*(*tarrptr + 1) == 61) {
#line 743
            goto _L;
          } else {
            {
#line 743
            tmp___35 = __ctype_b_loc();
            }
#line 743
            if (! ((int const   )*(*tmp___35 + (int )*(ptr + -1)) & 1024)) {
              {
#line 743
              tmp___36 = __ctype_b_loc();
              }
#line 743
              if (! ((int const   )*(*tmp___36 + (int )*(ptr + toklen)) & 1024)) {
                _L: /* CIL Label */ 
#line 746
                ptr2 = linestart + (ptr - lcasebuf);
#line 750
                tmp___30 = (unsigned char )toknum;
#line 750
                *ptr = tmp___30;
#line 750
                *ptr2 = tmp___30;
#line 751
                f = 1;
                {
#line 751
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 751
                  if (! (f < toklen)) {
#line 751
                    goto while_break___9;
                  }
#line 751
                  tmp___31 = (unsigned char)1;
#line 751
                  *(ptr + f) = tmp___31;
#line 751
                  *(ptr2 + f) = tmp___31;
#line 751
                  f ++;
                }
                while_break___9: /* CIL Label */ ;
                }
                {
#line 753
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 753
                  if (! ((int )*(ptr2 + f) == 32)) {
#line 753
                    goto while_break___10;
                  }
#line 754
                  tmp___32 = f;
#line 754
                  f ++;
#line 754
                  *(ptr2 + tmp___32) = (unsigned char)1;
                }
                while_break___10: /* CIL Label */ ;
                }
#line 757
                if (toknum == 196) {
#line 759
                  tmp___33 = (unsigned char)1;
#line 759
                  *ptr = tmp___33;
#line 759
                  *ptr2 = tmp___33;
#line 760
                  tmp___34 = (unsigned char )toknum;
#line 760
                  *(ptr + (f - 1)) = tmp___34;
#line 760
                  *(ptr2 + (f - 1)) = tmp___34;
                }
              }
            }
          }
#line 764
          ptr += toklen;
        }
        while_break___8: /* CIL Label */ ;
        }
        __Cont: /* CIL Label */ 
#line 731
        tarrptr ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 768
      if (use_labels) {
#line 777
        ptr = linestart;
        {
#line 778
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 778
          tmp___43 = strchr((char const   *)ptr, '@');
#line 778
          ptr = (unsigned char *)tmp___43;
          }
#line 778
          if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 778
            goto while_break___11;
          }
#line 780
          if ((int )*(ptr + -1) == 92) {
#line 782
            ptr ++;
#line 783
            goto while_continue___11;
          }
#line 793
          ptr ++;
#line 794
          f = 0;
          {
#line 794
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 794
            if (! (f < labelend)) {
#line 794
              goto while_break___12;
            }
            {
#line 796
            tmp___38 = strlen((char const   *)(labels[f]));
#line 796
            len = (int )tmp___38;
#line 797
            tmp___42 = memcmp((void const   *)(labels[f]), (void const   *)ptr, (size_t )len);
            }
#line 797
            if (tmp___42 == 0) {
#line 797
              if ((int )*(ptr + len) < 33) {
#line 797
                goto _L___0;
              } else
#line 797
              if ((int )*(ptr + len) > 126) {
#line 797
                goto _L___0;
              } else
#line 797
              if ((int )*(ptr + len) == 58) {
                _L___0: /* CIL Label */ 
                {
#line 806
                tmp___39 = strlen((char const   *)(ptr + len));
#line 806
                memmove((void *)(ptr - 1), (void const   *)(ptr + len), tmp___39 + 1UL);
#line 808
                sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%d",
                        label_lines[f]);
#line 809
                tmp___40 = strlen((char const   *)(numbuf));
#line 809
                len = (int )tmp___40;
#line 811
                ptr --;
#line 812
                tmp___41 = strlen((char const   *)ptr);
#line 812
                memmove((void *)(ptr + len), (void const   *)ptr, tmp___41 + 1UL);
#line 813
                memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(numbuf),
                       (size_t )len);
#line 814
                ptr += len;
                }
#line 815
                goto while_break___12;
              }
            }
#line 794
            f ++;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 818
          if (f == labelend) {
            {
#line 820
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: undefined label\n",
                    textlinenum);
#line 821
            exit(1);
            }
          }
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 826
      if (remptr) {
#line 826
        *remptr = (unsigned char)234;
      }
#line 829
      ptr = linestart;
#line 830
      outptr = outbuf;
#line 831
      in_quotes = 0;
#line 831
      in_rem = in_quotes;
      {
#line 833
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 833
        if (! *ptr) {
#line 833
          goto while_break___13;
        }
#line 835
        if ((unsigned long )outptr > (unsigned long )((outbuf + sizeof(outbuf)) - 10)) {
          {
#line 837
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: line too big\n",
                  textlinenum);
#line 838
          exit(1);
          }
        }
#line 841
        if ((int )*ptr == 34) {
#line 841
          in_quotes = ! in_quotes;
        }
#line 844
        if ((int )*ptr == 1) {
#line 846
          ptr ++;
#line 847
          goto while_continue___13;
        } else
#line 844
        if ((int )*ptr == 9) {
#line 846
          ptr ++;
#line 847
          goto while_continue___13;
        } else
#line 844
        if (! in_quotes) {
#line 844
          if (! in_rem) {
#line 844
            if ((int )*ptr == 32) {
#line 846
              ptr ++;
#line 847
              goto while_continue___13;
            }
          }
        }
#line 850
        if ((int )*ptr == 234) {
#line 850
          in_rem = 1;
        }
#line 852
        if ((int )*ptr == 92) {
          {
#line 854
          tmp___54 = __ctype_b_loc();
          }
#line 854
          if ((int const   )*(*tmp___54 + (int )*(ptr + 1)) & 1024) {
            {
#line 854
            tmp___55 = strchr("VWXYZvwxyz", (int )*(ptr + 1));
            }
#line 854
            if ((unsigned long )tmp___55 == (unsigned long )((void *)0)) {
              {
#line 855
              tmp___44 = outptr;
#line 855
              outptr ++;
#line 855
              tmp___45 = tolower((int )*(ptr + 1));
#line 855
              *tmp___44 = (unsigned char )((144 + tmp___45) - 97);
              }
            } else {
#line 854
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
            {
#line 859
            if ((int )*(ptr + 1) == 92) {
#line 859
              goto case_92;
            }
#line 860
            if ((int )*(ptr + 1) == 64) {
#line 860
              goto case_64;
            }
#line 861
            if ((int )*(ptr + 1) == 42) {
#line 861
              goto case_42;
            }
#line 862
            if ((int )*(ptr + 1) == 32) {
#line 862
              goto case_32;
            }
#line 862
            if ((int )*(ptr + 1) == 58) {
#line 862
              goto case_32;
            }
#line 862
            if ((int )*(ptr + 1) == 46) {
#line 862
              goto case_32;
            }
#line 862
            if ((int )*(ptr + 1) == 39) {
#line 862
              goto case_32;
            }
#line 866
            if ((int )*(ptr + 1) == 123) {
#line 866
              goto case_123;
            }
#line 891
            goto switch_default;
            case_92: /* CIL Label */ 
#line 859
            tmp___46 = outptr;
#line 859
            outptr ++;
#line 859
            *tmp___46 = (unsigned char )'\\';
#line 859
            goto switch_break;
            case_64: /* CIL Label */ 
#line 860
            tmp___47 = outptr;
#line 860
            outptr ++;
#line 860
            *tmp___47 = (unsigned char )'@';
#line 860
            goto switch_break;
            case_42: /* CIL Label */ 
#line 861
            tmp___48 = outptr;
#line 861
            outptr ++;
#line 861
            *tmp___48 = (unsigned char)127;
#line 861
            goto switch_break;
            case_32: /* CIL Label */ 
            case_58: /* CIL Label */ 
            case_46: /* CIL Label */ 
            case_39: /* CIL Label */ 
            {
#line 863
            tmp___49 = outptr;
#line 863
            outptr ++;
#line 863
            tmp___50 = grok_block(ptr, textlinenum);
#line 863
            *tmp___49 = (unsigned char )tmp___50;
#line 864
            ptr ++;
            }
#line 865
            goto switch_break;
            case_123: /* CIL Label */ 
            {
#line 868
            tmp___51 = strchr((char const   *)(ptr + 2), '}');
#line 868
            asciiptr = (unsigned char *)tmp___51;
            }
#line 869
            if ((unsigned long )asciiptr == (unsigned long )((void *)0)) {
              {
#line 871
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: unclosed brace in eight-bit character code\n",
                      textlinenum);
#line 874
              exit(1);
              }
            }
            {
#line 877
            num_ascii = strtoul((char const   */* __restrict  */)(ptr + 2), (char **/* __restrict  */)((void *)0),
                                0);
            }
#line 878
            if (num_ascii < 0UL) {
              {
#line 880
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: eight-bit character code out of range\n",
                      textlinenum);
#line 883
              exit(1);
              }
            } else
#line 878
            if (num_ascii > 255UL) {
              {
#line 880
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: eight-bit character code out of range\n",
                      textlinenum);
#line 883
              exit(1);
              }
            }
#line 885
            tmp___52 = outptr;
#line 885
            outptr ++;
#line 885
            *tmp___52 = (unsigned char )((char )num_ascii);
#line 889
            ptr = asciiptr - 1;
#line 890
            goto switch_break;
            switch_default: /* CIL Label */ 
            {
#line 892
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: warning: unknown escape `%c\', inserting literally\n",
                    textlinenum, (int )*(ptr + 1));
#line 895
            tmp___53 = outptr;
#line 895
            outptr ++;
#line 895
            *tmp___53 = *(ptr + 1);
            }
            switch_break: /* CIL Label */ ;
            }
          }
#line 897
          ptr += 2;
#line 898
          goto while_continue___13;
        }
#line 906
        if (! in_rem) {
#line 906
          if (! in_quotes) {
            {
#line 906
            tmp___66 = __ctype_b_loc();
            }
#line 906
            if ((int const   )*(*tmp___66 + (int )*(ptr + -1)) & 1024) {
#line 945
              tmp___64 = outptr;
#line 945
              outptr ++;
#line 945
              tmp___65 = ptr;
#line 945
              ptr ++;
#line 945
              *tmp___64 = *tmp___65;
            } else {
              {
#line 906
              tmp___67 = __ctype_b_loc();
              }
#line 906
              if ((int const   )*(*tmp___67 + (int )*ptr) & 2048) {
#line 906
                goto _L___2;
              } else
#line 906
              if ((int )*ptr == 45) {
#line 906
                goto _L___5;
              } else
#line 906
              if ((int )*ptr == 43) {
#line 906
                goto _L___5;
              } else
#line 906
              if ((int )*ptr == 46) {
                _L___5: /* CIL Label */ 
                {
#line 906
                tmp___68 = __ctype_b_loc();
                }
#line 906
                if ((int const   )*(*tmp___68 + (int )*(ptr + 1)) & 2048) {
#line 906
                  goto _L___2;
                } else {
#line 906
                  goto _L___4;
                }
              } else
              _L___4: /* CIL Label */ 
#line 906
              if ((int )*ptr == 45) {
#line 906
                goto _L___3;
              } else
#line 906
              if ((int )*ptr == 43) {
                _L___3: /* CIL Label */ 
#line 906
                if ((int )*(ptr + 1) == 46) {
                  {
#line 906
                  tmp___69 = __ctype_b_loc();
                  }
#line 906
                  if ((int const   )*(*tmp___69 + (int )*(ptr + 2)) & 2048) {
                    _L___2: /* CIL Label */ 
#line 911
                    if ((int )*(ptr + -1) != 196) {
                      {
#line 913
                      num = strtod((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((char **)(& ptr2)));
                      }
                    } else {
                      {
#line 920
                      ptr2 = ptr;
#line 921
                      tmp___56 = grok_binary(& ptr2, textlinenum);
#line 921
                      num = (double )tmp___56;
                      }
                    }
                    {
#line 925
                    memcpy((void */* __restrict  */)outptr, (void const   */* __restrict  */)ptr,
                           (size_t )(ptr2 - ptr));
#line 926
                    outptr += ptr2 - ptr;
#line 928
                    tmp___57 = outptr;
#line 928
                    outptr ++;
#line 928
                    *tmp___57 = (unsigned char)14;
#line 929
                    tmp___58 = dbl2spec(num, & num_exp, & num_mantissa);
                    }
#line 929
                    if (! tmp___58) {
                      {
#line 931
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"line %d: exponent out of range (number too big)\n",
                              textlinenum);
#line 933
                      exit(1);
                      }
                    }
#line 935
                    tmp___59 = outptr;
#line 935
                    outptr ++;
#line 935
                    *tmp___59 = (unsigned char )num_exp;
#line 936
                    tmp___60 = outptr;
#line 936
                    outptr ++;
#line 936
                    *tmp___60 = (unsigned char )(num_mantissa >> 24);
#line 937
                    tmp___61 = outptr;
#line 937
                    outptr ++;
#line 937
                    *tmp___61 = (unsigned char )(num_mantissa >> 16);
#line 938
                    tmp___62 = outptr;
#line 938
                    outptr ++;
#line 938
                    *tmp___62 = (unsigned char )(num_mantissa >> 8);
#line 939
                    tmp___63 = outptr;
#line 939
                    outptr ++;
#line 939
                    *tmp___63 = (unsigned char )(num_mantissa & 255UL);
#line 940
                    ptr = ptr2;
                  } else {
#line 945
                    tmp___64 = outptr;
#line 945
                    outptr ++;
#line 945
                    tmp___65 = ptr;
#line 945
                    ptr ++;
#line 945
                    *tmp___64 = *tmp___65;
                  }
                } else {
#line 945
                  tmp___64 = outptr;
#line 945
                  outptr ++;
#line 945
                  tmp___65 = ptr;
#line 945
                  ptr ++;
#line 945
                  *tmp___64 = *tmp___65;
                }
              } else {
#line 945
                tmp___64 = outptr;
#line 945
                outptr ++;
#line 945
                tmp___65 = ptr;
#line 945
                ptr ++;
#line 945
                *tmp___64 = *tmp___65;
              }
            }
          } else {
#line 945
            tmp___64 = outptr;
#line 945
            outptr ++;
#line 945
            tmp___65 = ptr;
#line 945
            ptr ++;
#line 945
            *tmp___64 = *tmp___65;
          }
        } else {
#line 945
          tmp___64 = outptr;
#line 945
          outptr ++;
#line 945
          tmp___65 = ptr;
#line 945
          ptr ++;
#line 945
          *tmp___64 = *tmp___65;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
#line 949
      tmp___70 = outptr;
#line 949
      outptr ++;
#line 949
      *tmp___70 = (unsigned char)13;
#line 952
      linelen = (int )(outptr - outbuf);
#line 953
      if ((unsigned long )((fileptr + 4) + linelen) >= (unsigned long )(filebuf + sizeof(filebuf))) {
        {
#line 958
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"program too big!\n");
#line 959
        exit(1);
        }
      }
      {
#line 961
      tmp___71 = fileptr;
#line 961
      fileptr ++;
#line 961
      *tmp___71 = (unsigned char )(linenum >> 8);
#line 962
      tmp___72 = fileptr;
#line 962
      fileptr ++;
#line 962
      *tmp___72 = (unsigned char )(linenum & 255);
#line 963
      tmp___73 = fileptr;
#line 963
      fileptr ++;
#line 963
      *tmp___73 = (unsigned char )(linelen & 255);
#line 964
      tmp___74 = fileptr;
#line 964
      fileptr ++;
#line 964
      *tmp___74 = (unsigned char )(linelen >> 8);
#line 965
      memcpy((void */* __restrict  */)fileptr, (void const   */* __restrict  */)(outbuf),
             (size_t )linelen);
#line 966
      fileptr += linelen;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 969
    passnum ++;
#line 556
    if (use_labels) {
#line 556
      if (! (passnum <= 2)) {
#line 556
        goto while_break;
      }
    } else {
#line 556
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 973
  if ((unsigned long )in != (unsigned long )stdin) {
    {
#line 973
    fclose(in);
    }
  }
#line 979
  if (startlabel[0]) {
#line 982
    if (! use_labels) {
      {
#line 983
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Auto-start label specified, but not using labels!\n");
#line 983
      exit(1);
      }
    }
#line 985
    f = 0;
    {
#line 985
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 985
      if (! (f < labelend)) {
#line 985
        goto while_break___14;
      }
      {
#line 986
      tmp___76 = strcmp((char const   *)(startlabel), (char const   *)(labels[f]));
      }
#line 986
      if (tmp___76 == 0) {
#line 988
        startline = (unsigned int )label_lines[f];
#line 988
        goto while_break___14;
      }
#line 985
      f ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 990
    if (f == labelend) {
      {
#line 991
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Auto-start label is undefined\n");
#line 991
      exit(1);
      }
    }
  }
  {
#line 997
  tmp___77 = strcmp((char const   *)(outfile), "-");
  }
#line 997
  if (tmp___77 != 0) {
    {
#line 997
    out = fopen((char const   */* __restrict  */)(outfile), (char const   */* __restrict  */)"wb");
    }
#line 997
    if ((unsigned long )out == (unsigned long )((void *)0)) {
      {
#line 998
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t open output file.\n");
#line 998
      exit(1);
      }
    }
  }
#line 1000
  if (output_tap) {
    {
#line 1002
    siz = (unsigned int )(fileptr - filebuf);
#line 1005
    headerbuf[0] = (unsigned char)0;
#line 1006
    tmp___78 = strlen((char const   *)(speccy_filename));
#line 1006
    f = (int )tmp___78;
    }
    {
#line 1006
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1006
      if (! (f < 10)) {
#line 1006
        goto while_break___15;
      }
#line 1007
      speccy_filename[f] = (char)32;
#line 1006
      f ++;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 1008
    strncpy((char */* __restrict  */)(headerbuf + 1), (char const   */* __restrict  */)(speccy_filename),
            (size_t )10);
#line 1009
    headerbuf[11] = (unsigned char )(siz & 255U);
#line 1010
    headerbuf[12] = (unsigned char )(siz / 256U);
#line 1011
    headerbuf[13] = (unsigned char )(startline & 255U);
#line 1012
    headerbuf[14] = (unsigned char )(startline / 256U);
#line 1013
    headerbuf[15] = (unsigned char )(siz & 255U);
#line 1014
    headerbuf[16] = (unsigned char )(siz / 256U);
#line 1017
    chk = 0;
#line 1017
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c%c%c",
            19, 0, chk);
#line 1018
    f = 0;
    }
    {
#line 1018
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 1018
      if (! (f < 17)) {
#line 1018
        goto while_break___16;
      }
#line 1018
      chk ^= (int )headerbuf[f];
#line 1018
      f ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 1019
    fwrite((void const   */* __restrict  */)(headerbuf), (size_t )1, (size_t )17,
           (FILE */* __restrict  */)out);
#line 1020
    fputc(chk, out);
#line 1023
    chk = 255;
#line 1023
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c%c%c",
            (siz + 2U) & 255U, (siz + 2U) >> 8, chk);
#line 1024
    f = 0;
    }
    {
#line 1024
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1024
      if (! ((unsigned int )f < siz)) {
#line 1024
        goto while_break___17;
      }
#line 1024
      chk ^= (int )filebuf[f];
#line 1024
      f ++;
    }
    while_break___17: /* CIL Label */ ;
    }
  }
  {
#line 1027
  fwrite((void const   */* __restrict  */)(filebuf), (size_t )1, (size_t )(fileptr - filebuf),
         (FILE */* __restrict  */)out);
  }
#line 1029
  if (output_tap) {
    {
#line 1030
    fputc(chk, out);
    }
  }
#line 1032
  if ((unsigned long )out != (unsigned long )stdout) {
    {
#line 1032
    fclose(out);
    }
  }
  {
#line 1034
  exit(0);
  }
}
}
