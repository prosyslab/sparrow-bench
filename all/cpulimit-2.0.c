/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 375 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
struct process_screenshot {
   struct timespec when ;
   int jiffies ;
   int cputime ;
};
#line 382 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
struct cpu_usage {
   float pcpu ;
   float workingrate ;
};
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 76
extern int opterr ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 334 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 342
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 93 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpriority)(__priority_which_t __which ,
                                                                                  id_t __who ) ;
#line 97
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which ,
                                                                                  id_t __who ,
                                                                                  int __prio ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
pid_t pid  =    0;
#line 85 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
pid_t my_pid  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
char *program_name  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
int verbose  =    0;
#line 92 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
int lazy  =    0;
#line 94 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
int nice_lim  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
int NCPU  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
__inline long timediff(struct timespec  const  *ta , struct timespec  const  *tb ) 
{ 
  unsigned long us ;

  {
#line 106
  us = (unsigned long )((ta->tv_sec - tb->tv_sec) * 1000000L + (ta->tv_nsec / 1000L - tb->tv_nsec / 1000L));
#line 107
  return ((long )us);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
int Check_Us(pid_t target_pid ) 
{ 
  pid_t this_pid ;

  {
  {
#line 116
  this_pid = getpid();
  }
#line 117
  if (this_pid == target_pid) {
    {
#line 119
    printf((char const   */* __restrict  */)"We cannot throttle ourselves.\n");
#line 120
    exit(7);
    }
  }
#line 122
  return (1);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
int waitforpid(int pid___0 ) 
{ 
  int i ;
  DIR *dip ;
  struct dirent *dit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 135
  i = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 143
    dip = opendir("/proc");
    }
#line 143
    if ((unsigned long )dip == (unsigned long )((void *)0)) {
      {
#line 144
      perror("opendir");
      }
#line 145
      return (-1);
    }
    {
#line 149
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 149
      dit = readdir(dip);
      }
#line 149
      if (! ((unsigned long )dit != (unsigned long )((void *)0))) {
#line 149
        goto while_break___0;
      }
      {
#line 151
      tmp___2 = atoi((char const   *)(dit->d_name));
      }
#line 151
      if (pid___0 == tmp___2) {
        {
#line 153
        Check_Us(pid___0);
#line 154
        tmp___0 = kill(pid___0, 19);
        }
#line 154
        if (tmp___0 == 0) {
          {
#line 154
          tmp___1 = kill(pid___0, 18);
          }
#line 154
          if (tmp___1 == 0) {
            {
#line 156
            tmp = closedir(dip);
            }
#line 156
            if (tmp == -1) {
              {
#line 157
              perror("closedir");
              }
#line 158
              return (-1);
            }
#line 160
            goto done;
          } else {
            {
#line 163
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Process %d detected, but you don\'t have permission to control it\n",
                    pid___0);
            }
          }
        } else {
          {
#line 163
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Process %d detected, but you don\'t have permission to control it\n",
                  pid___0);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 169
    tmp___3 = closedir(dip);
    }
#line 169
    if (tmp___3 == -1) {
      {
#line 170
      perror("closedir");
      }
#line 171
      return (-1);
    }
#line 175
    tmp___4 = i;
#line 175
    i ++;
#line 175
    if (tmp___4 == 0) {
#line 176
      if (lazy) {
        {
#line 177
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No process found\n");
#line 178
        exit(2);
        }
      } else {
        {
#line 181
        printf((char const   */* __restrict  */)"Warning: no target process found. Waiting for it...\n");
        }
      }
    }
    {
#line 186
    sleep(2U);
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
#line 190
  printf((char const   */* __restrict  */)"Process %d detected\n", pid___0);
  }
#line 199
  return (0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
int getpidof(char const   *process ) 
{ 
  char exelink[20] ;
  char exepath[4097] ;
  int pid___0 ;
  int i ;
  DIR *dip ;
  struct dirent *dit ;
  int size ;
  ssize_t tmp ;
  int found ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 221
  pid___0 = 0;
#line 222
  i = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 230
    dip = opendir("/proc");
    }
#line 230
    if ((unsigned long )dip == (unsigned long )((void *)0)) {
      {
#line 231
      perror("opendir");
      }
#line 232
      return (-1);
    }
    {
#line 236
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 236
      dit = readdir(dip);
      }
#line 236
      if (! ((unsigned long )dit != (unsigned long )((void *)0))) {
#line 236
        goto while_break___0;
      }
      {
#line 238
      pid___0 = atoi((char const   *)(dit->d_name));
      }
#line 239
      if (pid___0 > 0) {
        {
#line 240
        sprintf((char */* __restrict  */)(exelink), (char const   */* __restrict  */)"/proc/%d/exe",
                pid___0);
#line 241
        tmp = readlink((char const   */* __restrict  */)(exelink), (char */* __restrict  */)(exepath),
                       sizeof(exepath));
#line 241
        size = (int )tmp;
        }
#line 242
        if (size > 0) {
#line 243
          found = 0;
#line 244
          if ((int const   )*(process + 0) == 47) {
            {
#line 244
            tmp___3 = strncmp((char const   *)(exepath), process, (size_t )size);
            }
#line 244
            if (tmp___3 == 0) {
              {
#line 244
              tmp___4 = strlen(process);
              }
#line 244
              if ((size_t )size == tmp___4) {
#line 246
                found = 1;
              } else {
#line 244
                goto _L___0;
              }
            } else {
#line 244
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 250
            tmp___0 = strlen(process);
#line 250
            tmp___1 = strlen(process);
#line 250
            tmp___2 = strncmp((char const   *)((exepath + size) - tmp___1), process,
                              tmp___0);
            }
#line 250
            if (tmp___2 == 0) {
#line 251
              found = 1;
            }
          }
#line 254
          if (found == 1) {
            {
#line 255
            Check_Us(pid___0);
#line 256
            tmp___6 = kill(pid___0, 19);
            }
#line 256
            if (tmp___6 == 0) {
              {
#line 256
              tmp___7 = kill(pid___0, 18);
              }
#line 256
              if (tmp___7 == 0) {
                {
#line 258
                tmp___5 = closedir(dip);
                }
#line 258
                if (tmp___5 == -1) {
                  {
#line 259
                  perror("closedir");
                  }
#line 260
                  return (-1);
                }
#line 262
                goto done;
              } else {
                {
#line 265
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Process %d detected, but you don\'t have permission to control it\n",
                        pid___0);
                }
              }
            } else {
              {
#line 265
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Process %d detected, but you don\'t have permission to control it\n",
                      pid___0);
              }
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 273
    tmp___8 = closedir(dip);
    }
#line 273
    if (tmp___8 == -1) {
      {
#line 274
      perror("closedir");
      }
#line 275
      return (-1);
    }
#line 279
    tmp___9 = i;
#line 279
    i ++;
#line 279
    if (tmp___9 == 0) {
#line 280
      if (lazy) {
        {
#line 281
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No process found\n");
#line 282
        exit(2);
        }
      } else {
        {
#line 285
        printf((char const   */* __restrict  */)"Warning: no target process found. Waiting for it...\n");
        }
      }
    }
    {
#line 290
    sleep(2U);
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
#line 294
  printf((char const   */* __restrict  */)"Process %d detected\n", pid___0);
  }
#line 303
  return (pid___0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
void quit(int sig ) 
{ 


  {
  {
#line 310
  kill(pid, 18);
#line 311
  printf((char const   */* __restrict  */)"Exiting...\n");
#line 312
  exit(0);
  }
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
static char stat[20]  ;
#line 347 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
static char buffer[1024]  ;
#line 345 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
int getjiffies(int pid___0 ) 
{ 
  char *p ;
  FILE *f ;
  FILE *tmp ;
  void *tmp___0 ;
  int sp ;
  void *tmp___1 ;
  int tmp___2 ;
  int utime ;
  int tmp___3 ;
  void *tmp___4 ;
  int ktime ;
  int tmp___5 ;

  {
  {
#line 349
  sprintf((char */* __restrict  */)(stat), (char const   */* __restrict  */)"/proc/%d/stat",
          pid___0);
#line 350
  tmp = fopen((char const   */* __restrict  */)(stat), (char const   */* __restrict  */)"r");
#line 350
  f = tmp;
  }
#line 351
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 351
    return (-1);
  }
  {
#line 352
  p = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)f);
#line 353
  fclose(f);
  }
#line 355
  if (p) {
    {
#line 357
    tmp___0 = memchr((void const   *)(p + 1), ')', sizeof(buffer) - (unsigned long )(p - buffer));
#line 357
    p = (char *)tmp___0;
#line 358
    sp = 12;
    }
    {
#line 359
    while (1) {
      while_continue: /* CIL Label */ ;
#line 359
      tmp___2 = sp;
#line 359
      sp --;
#line 359
      if (! tmp___2) {
#line 359
        goto while_break;
      }
      {
#line 360
      tmp___1 = memchr((void const   *)(p + 1), ' ', sizeof(buffer) - (unsigned long )(p - buffer));
#line 360
      p = (char *)tmp___1;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 362
    tmp___3 = atoi((char const   *)(p + 1));
#line 362
    utime = tmp___3;
#line 363
    tmp___4 = memchr((void const   *)(p + 1), ' ', sizeof(buffer) - (unsigned long )(p - buffer));
#line 363
    p = (char *)tmp___4;
#line 365
    tmp___5 = atoi((char const   *)(p + 1));
#line 365
    ktime = tmp___5;
    }
#line 366
    return (utime + ktime);
  }
#line 369
  return (-1);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
static struct process_screenshot ps[10]  ;
#line 397
int compute_cpu_usage(int pid___0 , int last_working_quantum , struct cpu_usage *pusage ) ;
#line 397 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
static int front  =    -1;
#line 399
int compute_cpu_usage(int pid___0 , int last_working_quantum , struct cpu_usage *pusage ) ;
#line 399 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
static int tail  =    0;
#line 392 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
int compute_cpu_usage(int pid___0 , int last_working_quantum , struct cpu_usage *pusage ) 
{ 
  int j ;
  int tmp ;
  int size ;
  long dt ;
  long tmp___0 ;
  long dtwork ;
  int i ;
  int max ;
  int used ;
  float usage ;

  {
#line 401
  if ((unsigned long )pusage == (unsigned long )((void *)0)) {
#line 403
    front = -1;
#line 404
    tail = 0;
#line 405
    return (0);
  }
  {
#line 409
  front = (front + 1) % 10;
#line 410
  tmp = getjiffies(pid___0);
#line 410
  j = tmp;
  }
#line 411
  if (j >= 0) {
#line 411
    ps[front].jiffies = j;
  } else {
#line 412
    return (-1);
  }
  {
#line 426
  clock_gettime(0, & ps[front].when);
#line 427
  ps[front].cputime = last_working_quantum;
#line 430
  size = ((front - tail) + 10) % 10 + 1;
  }
#line 432
  if (size == 1) {
#line 434
    pusage->pcpu = (float )-1;
#line 435
    pusage->workingrate = (float )1;
#line 436
    return (0);
  } else {
    {
#line 440
    tmp___0 = timediff((struct timespec  const  *)(& ps[front].when), (struct timespec  const  *)(& ps[tail].when));
#line 440
    dt = tmp___0;
#line 441
    dtwork = 0L;
#line 442
    i = (tail + 1) % 10;
#line 443
    max = (front + 1) % 10;
    }
    {
#line 444
    while (1) {
      while_continue: /* CIL Label */ ;
#line 445
      dtwork += (long )ps[i].cputime;
#line 446
      i = (i + 1) % 10;
#line 444
      if (! (i != max)) {
#line 444
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 448
    used = ps[front].jiffies - ps[tail].jiffies;
#line 449
    usage = (float )((((double )used * 1000000.0) / (double )100) / (double )dtwork);
#line 450
    pusage->workingrate = (float )((1.0 * (double )dtwork) / (double )dt);
#line 451
    pusage->pcpu = usage * pusage->workingrate;
#line 452
    if (size == 10) {
#line 453
      tail = (tail + 1) % 10;
    }
#line 454
    return (0);
  }
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
void print_caption(void) 
{ 


  {
  {
#line 460
  printf((char const   */* __restrict  */)"\n%%CPU\twork quantum\tsleep quantum\tactive rate\n");
  }
#line 461
  return;
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
void increase_priority(void) 
{ 
  int old_priority ;
  int tmp ;
  int priority ;
  int tmp___0 ;

  {
  {
#line 467
  tmp = getpriority(0, (id_t )0);
#line 467
  old_priority = tmp;
#line 468
  priority = old_priority;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 469
    tmp___0 = setpriority(0, (id_t )0, priority - 1);
    }
#line 469
    if (tmp___0 == 0) {
#line 469
      if (! (priority > -10)) {
#line 469
        goto while_break;
      }
    } else {
#line 469
      goto while_break;
    }
#line 472
    priority --;
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  if (priority != old_priority) {
#line 475
    if (verbose) {
      {
#line 475
      printf((char const   */* __restrict  */)"Priority changed to %d\n", priority);
      }
    }
  } else
#line 478
  if (verbose) {
    {
#line 478
    printf((char const   */* __restrict  */)"Warning: Cannot change priority. Run as root or renice for best results.\n");
    }
  }
#line 482
  return;
}
}
#line 486 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
void print_usage(FILE *stream , int exit_code ) 
{ 


  {
  {
#line 487
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"CPUlimit version %1.1f\n",
          2.0);
#line 488
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Usage: %s TARGET [OPTIONS...] [-- PROGRAM]\n",
          program_name);
#line 489
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"   TARGET must be exactly one of these:\n");
#line 490
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"      -p, --pid=N        pid of the process\n");
#line 491
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"      -e, --exe=FILE     name of the executable program file\n");
#line 492
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"                         The -e option only works when\n");
#line 493
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"                         cpulimit is run with admin rights.\n");
#line 494
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"      -P, --path=PATH    absolute path name of the\n");
#line 495
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"                         executable program file\n");
#line 496
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"   OPTIONS\n");
#line 497
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"      -b  --background   run in background\n");
#line 498
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"      -c  --cpu=N        override the detection of CPUs on the machine.\n");
#line 499
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"      -l, --limit=N      percentage of cpu allowed from 1 up.\n");
#line 500
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"                         Usually 1 - %d00, but can be higher\n",
          NCPU);
#line 501
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"                         on multi-core CPUs (mandatory)\n");
#line 502
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"      -k, --kill         kill processes going over their limit\n");
#line 503
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"                         instead of just throttling them.\n");
#line 504
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"      -r, --restore      Restore processes after they have\n");
#line 505
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"                         been killed. Works with the -k flag.\n");
#line 507
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"      -v, --verbose      show control statistics\n");
#line 508
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"      -z, --lazy         exit if there is no suitable target process,\n");
#line 509
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"                         or if it dies\n");
#line 510
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"          --             This is the final CPUlimit option. All following\n");
#line 511
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"                         options are for another program we will launch.\n");
#line 512
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"      -h, --help         display this help and exit\n");
#line 513
  exit(exit_code);
  }
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
int get_ncpu(void) 
{ 
  int ncpu ;
  long tmp ;

  {
  {
#line 521
  ncpu = 1;
#line 523
  tmp = sysconf(84);
#line 523
  ncpu = (int )tmp;
  }
#line 525
  return (ncpu);
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/cpulimit-2.0/cpulimit.c"
int main(int argc , char **argv ) 
{ 
  int run_in_background ;
  int next_option ;
  char const   *short_options ;
  struct option long_options[10] ;
  char const   *exe ;
  char const   *path ;
  int perclimit ;
  int pid_ok ;
  int process_ok ;
  int limit_ok ;
  int last_known_argument ;
  int kill_process ;
  int restore_process ;
  int tmp ;
  pid_t forked_pid ;
  int index___0 ;
  pid_t limit_pid ;
  float limit ;
  pid_t process_id ;
  int period ;
  struct timespec twork ;
  struct timespec tsleep ;
  int i ;
  struct timespec startwork ;
  struct timespec endwork ;
  long workingtime ;
  float pcpu_avg ;
  struct cpu_usage cu ;
  int tmp___0 ;
  float pcpu ;
  float workingrate ;
  int tmp___1 ;
  pid_t new_process ;
  int tmp___2 ;

  {
  {
#line 536
  program_name = *(argv + 0);
#line 537
  run_in_background = 0;
#line 541
  short_options = "p:e:P:l:c:bkrvzh";
#line 543
  long_options[0].name = "pid";
#line 543
  long_options[0].has_arg = 1;
#line 543
  long_options[0].flag = (int *)((void *)0);
#line 543
  long_options[0].val = 'p';
#line 543
  long_options[1].name = "exe";
#line 543
  long_options[1].has_arg = 1;
#line 543
  long_options[1].flag = (int *)((void *)0);
#line 543
  long_options[1].val = 'e';
#line 543
  long_options[2].name = "path";
#line 543
  long_options[2].has_arg = 1;
#line 543
  long_options[2].flag = (int *)((void *)0);
#line 543
  long_options[2].val = 'P';
#line 543
  long_options[3].name = "limit";
#line 543
  long_options[3].has_arg = 1;
#line 543
  long_options[3].flag = (int *)((void *)0);
#line 543
  long_options[3].val = 'l';
#line 543
  long_options[4].name = "background";
#line 543
  long_options[4].has_arg = 0;
#line 543
  long_options[4].flag = (int *)((void *)0);
#line 543
  long_options[4].val = 'b';
#line 543
  long_options[5].name = "verbose";
#line 543
  long_options[5].has_arg = 0;
#line 543
  long_options[5].flag = (int *)((void *)0);
#line 543
  long_options[5].val = 'v';
#line 543
  long_options[6].name = "lazy";
#line 543
  long_options[6].has_arg = 0;
#line 543
  long_options[6].flag = (int *)((void *)0);
#line 543
  long_options[6].val = 'z';
#line 543
  long_options[7].name = "help";
#line 543
  long_options[7].has_arg = 0;
#line 543
  long_options[7].flag = (int *)((void *)0);
#line 543
  long_options[7].val = 'h';
#line 543
  long_options[8].name = "cpu";
#line 543
  long_options[8].has_arg = 1;
#line 543
  long_options[8].flag = (int *)((void *)0);
#line 543
  long_options[8].val = 'c';
#line 543
  long_options[9].name = (char const   *)((void *)0);
#line 543
  long_options[9].has_arg = 0;
#line 543
  long_options[9].flag = (int *)((void *)0);
#line 543
  long_options[9].val = 0;
#line 556
  exe = (char const   *)((void *)0);
#line 557
  path = (char const   *)((void *)0);
#line 558
  perclimit = 0;
#line 559
  pid_ok = 0;
#line 560
  process_ok = 0;
#line 561
  limit_ok = 0;
#line 562
  last_known_argument = 0;
#line 563
  kill_process = 0;
#line 564
  restore_process = 0;
#line 567
  NCPU = get_ncpu();
#line 569
  opterr = 0;
  }
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 571
    next_option = getopt_long(argc, (char * const  *)argv, short_options, (struct option  const  *)(long_options),
                              (int *)((void *)0));
    }
    {
#line 573
    if (next_option == 98) {
#line 573
      goto case_98;
    }
#line 577
    if (next_option == 112) {
#line 577
      goto case_112;
    }
#line 586
    if (next_option == 101) {
#line 586
      goto case_101;
    }
#line 591
    if (next_option == 80) {
#line 591
      goto case_80;
    }
#line 596
    if (next_option == 108) {
#line 596
      goto case_108;
    }
#line 601
    if (next_option == 99) {
#line 601
      goto case_99;
    }
#line 605
    if (next_option == 107) {
#line 605
      goto case_107;
    }
#line 609
    if (next_option == 114) {
#line 609
      goto case_114;
    }
#line 614
    if (next_option == 118) {
#line 614
      goto case_118;
    }
#line 618
    if (next_option == 122) {
#line 618
      goto case_122;
    }
#line 622
    if (next_option == 104) {
#line 622
      goto case_104;
    }
#line 626
    if (next_option == 111) {
#line 626
      goto case_111;
    }
#line 630
    if (next_option == 63) {
#line 630
      goto case_63;
    }
#line 634
    if (next_option == -1) {
#line 634
      goto case_neg_1;
    }
#line 572
    goto switch_break;
    case_98: /* CIL Label */ 
#line 574
    run_in_background = 1;
#line 575
    last_known_argument ++;
#line 576
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 578
    pid = atoi((char const   *)optarg);
    }
#line 579
    if (pid) {
#line 581
      pid_ok = 1;
#line 582
      lazy = 1;
    }
#line 584
    last_known_argument += 2;
#line 585
    goto switch_break;
    case_101: /* CIL Label */ 
#line 587
    exe = (char const   *)optarg;
#line 588
    process_ok = 1;
#line 589
    last_known_argument += 2;
#line 590
    goto switch_break;
    case_80: /* CIL Label */ 
#line 592
    path = (char const   *)optarg;
#line 593
    process_ok = 1;
#line 594
    last_known_argument += 2;
#line 595
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 597
    perclimit = atoi((char const   *)optarg);
#line 598
    limit_ok = 1;
#line 599
    last_known_argument += 2;
    }
#line 600
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 602
    NCPU = atoi((char const   *)optarg);
#line 603
    last_known_argument += 2;
    }
#line 604
    goto switch_break;
    case_107: /* CIL Label */ 
#line 606
    kill_process = 1;
#line 607
    last_known_argument ++;
#line 608
    goto switch_break;
    case_114: /* CIL Label */ 
#line 610
    restore_process = 1;
#line 611
    last_known_argument ++;
#line 612
    goto switch_break;
    case_118: /* CIL Label */ 
#line 615
    verbose = 1;
#line 616
    last_known_argument ++;
#line 617
    goto switch_break;
    case_122: /* CIL Label */ 
#line 619
    lazy = 1;
#line 620
    last_known_argument ++;
#line 621
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 623
    print_usage(stdout, 1);
#line 624
    last_known_argument ++;
    }
#line 625
    goto switch_break;
    case_111: /* CIL Label */ 
#line 627
    last_known_argument ++;
#line 628
    next_option = -1;
#line 629
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 631
    print_usage(stderr, 1);
#line 632
    last_known_argument ++;
    }
#line 633
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 635
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 570
    if (! (next_option != -1)) {
#line 570
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  if (last_known_argument + 1 < argc) {
#line 644
    if (pid_ok == 0) {
#line 646
      last_known_argument ++;
#line 648
      if (last_known_argument + 1 < argc) {
        {
#line 648
        tmp = strcmp((char const   *)*(argv + last_known_argument), "--");
        }
#line 648
        if (! tmp) {
#line 649
          last_known_argument ++;
        }
      }
#line 652
      if (verbose) {
        {
#line 654
        index___0 = last_known_argument;
#line 655
        printf((char const   */* __restrict  */)"Launching %s", *(argv + index___0));
#line 656
        index___0 = last_known_argument + 1;
        }
        {
#line 656
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 656
          if (! (index___0 < argc)) {
#line 656
            goto while_break___0;
          }
          {
#line 657
          printf((char const   */* __restrict  */)" %s", *(argv + index___0));
#line 656
          index___0 ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 658
        printf((char const   */* __restrict  */)" with limit %d\n", perclimit);
        }
      }
      {
#line 660
      forked_pid = fork();
      }
#line 661
      if (forked_pid == -1) {
        {
#line 663
        printf((char const   */* __restrict  */)"Failed to launch specified process.\n");
#line 664
        exit(1);
        }
      } else
#line 666
      if (forked_pid == 0) {
        {
#line 668
        execvp((char const   *)*(argv + last_known_argument), (char * const  *)(argv + last_known_argument));
#line 670
        exit(2);
        }
      } else {
#line 677
        if (kill_process) {
          {
#line 678
          sleep(5U);
          }
        }
        {
#line 680
        limit_pid = fork();
        }
#line 681
        if (limit_pid == 0) {
#line 683
          pid = forked_pid;
#line 684
          lazy = 1;
#line 685
          pid_ok = 1;
#line 686
          if (verbose) {
            {
#line 687
            printf((char const   */* __restrict  */)"Throttling process %d\n", pid);
            }
          }
        } else {
          {
#line 690
          exit(0);
          }
        }
      }
    }
  }
#line 714
  if (! process_ok) {
#line 714
    if (! pid_ok) {
      {
#line 715
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: You must specify a target process\n");
#line 716
      print_usage(stderr, 1);
#line 717
      exit(1);
      }
    }
  }
#line 719
  if ((unsigned long )exe != (unsigned long )((void *)0)) {
#line 719
    if ((unsigned long )path != (unsigned long )((void *)0)) {
      {
#line 720
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: You must specify exactly one target process\n");
#line 721
      print_usage(stderr, 1);
#line 722
      exit(1);
      }
    } else {
#line 719
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 719
  if (pid_ok) {
#line 719
    if ((unsigned long )exe != (unsigned long )((void *)0)) {
      {
#line 720
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: You must specify exactly one target process\n");
#line 721
      print_usage(stderr, 1);
#line 722
      exit(1);
      }
    } else
#line 719
    if ((unsigned long )path != (unsigned long )((void *)0)) {
      {
#line 720
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: You must specify exactly one target process\n");
#line 721
      print_usage(stderr, 1);
#line 722
      exit(1);
      }
    }
  }
#line 724
  if (! limit_ok) {
    {
#line 725
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: You must specify a cpu limit\n");
#line 726
    print_usage(stderr, 1);
#line 727
    exit(1);
    }
  }
#line 729
  limit = (float )((double )perclimit / 100.0);
#line 730
  if ((double )limit <= 0.00) {
    {
#line 732
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: limit must be in the range of 1 to %d00\n",
            NCPU);
#line 733
    print_usage(stderr, 1);
#line 734
    exit(1);
    }
  } else
#line 730
  if (limit > (float )NCPU) {
    {
#line 732
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: limit must be in the range of 1 to %d00\n",
            NCPU);
#line 733
    print_usage(stderr, 1);
#line 734
    exit(1);
    }
  }
#line 738
  if (run_in_background) {
    {
#line 741
    process_id = fork();
    }
#line 742
    if (! process_id) {
      {
#line 743
      exit(0);
      }
    } else {
      {
#line 746
      setsid();
#line 747
      process_id = fork();
      }
#line 748
      if (process_id) {
        {
#line 749
        exit(0);
        }
      }
    }
  }
  {
#line 754
  signal(2, & quit);
#line 755
  signal(15, & quit);
#line 757
  my_pid = getpid();
  }
#line 758
  if (verbose) {
    {
#line 759
    printf((char const   */* __restrict  */)"%d CPUs detected.\n", NCPU);
    }
  }
  {
#line 761
  increase_priority();
#line 808
  period = 100000;
#line 810
  memset((void *)(& twork), 0, sizeof(struct timespec ));
#line 811
  memset((void *)(& tsleep), 0, sizeof(struct timespec ));
  }
  wait_for_process: 
#line 816
  if ((unsigned long )exe != (unsigned long )((void *)0)) {
    {
#line 817
    pid = getpidof(exe);
    }
  } else
#line 818
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
#line 819
    pid = getpidof(path);
    }
  } else {
    {
#line 821
    waitforpid(pid);
    }
  }
  {
#line 827
  compute_cpu_usage(0, 0, (struct cpu_usage *)((void *)0));
#line 829
  i = 0;
#line 832
  workingtime = 0L;
  }
#line 834
  if (verbose) {
    {
#line 834
    print_caption();
    }
  }
#line 836
  pcpu_avg = (float )0;
  {
#line 839
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 843
    tmp___0 = compute_cpu_usage(pid, (int )workingtime, & cu);
    }
#line 843
    if (tmp___0 == -1) {
      {
#line 844
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Process %d dead!\n",
              pid);
      }
#line 845
      if (lazy) {
        {
#line 845
        exit(2);
        }
      }
#line 847
      goto wait_for_process;
    }
#line 851
    pcpu = cu.pcpu;
#line 853
    workingrate = cu.workingrate;
#line 856
    if (pcpu > (float )0) {
#line 857
      if (((((float )period * limit) * (float )1000) / pcpu) * workingrate < (float )(period * 1000)) {
#line 857
        twork.tv_nsec = (__syscall_slong_t )(((((float )period * limit) * (float )1000) / pcpu) * workingrate);
      } else {
#line 857
        twork.tv_nsec = (__syscall_slong_t )(period * 1000);
      }
    } else
#line 859
    if (pcpu == (float )0) {
#line 860
      twork.tv_nsec = (__syscall_slong_t )(period * 1000);
    } else
#line 862
    if (pcpu == (float )-1) {
#line 864
      pcpu = limit;
#line 865
      workingrate = limit;
#line 866
      if (((float )period * limit) * (float )1000 < (float )(period * 1000)) {
#line 866
        twork.tv_nsec = (__syscall_slong_t )(((float )period * limit) * (float )1000);
      } else {
#line 866
        twork.tv_nsec = (__syscall_slong_t )(period * 1000);
      }
    }
#line 868
    tsleep.tv_nsec = (__syscall_slong_t )(period * 1000) - twork.tv_nsec;
#line 871
    pcpu_avg = (pcpu_avg * (float )i + pcpu) / (float )(i + 1);
#line 873
    if (verbose) {
#line 873
      if (i % 10 == 0) {
#line 873
        if (i > 0) {
          {
#line 874
          printf((char const   */* __restrict  */)"%0.2f%%\t%6ld us\t%6ld us\t%0.2f%%\n",
                 (double )(pcpu * (float )100), twork.tv_nsec / 1000L, tsleep.tv_nsec / 1000L,
                 (double )(workingrate * (float )100));
          }
#line 875
          if (i % 200 == 0) {
            {
#line 876
            print_caption();
            }
          }
        }
      }
    }
#line 881
    if (pcpu < limit) {
      {
#line 885
      tmp___1 = kill(pid, 18);
      }
#line 885
      if (tmp___1 != 0) {
        {
#line 886
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Process %d dead!\n",
                pid);
        }
#line 887
        if (lazy) {
          {
#line 887
          exit(2);
          }
        }
#line 889
        goto wait_for_process;
      }
    }
    {
#line 904
    clock_gettime(0, & startwork);
#line 907
    nanosleep((struct timespec  const  *)(& twork), (struct timespec *)((void *)0));
#line 919
    clock_gettime(0, & endwork);
#line 921
    workingtime = timediff((struct timespec  const  *)(& endwork), (struct timespec  const  *)(& startwork));
    }
#line 925
    if (pcpu > limit) {
#line 930
      if (kill_process) {
        {
#line 932
        kill(pid, 9);
#line 933
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Process %d killed.\n",
                pid);
        }
#line 934
        if (lazy) {
#line 934
          if (! restore_process) {
            {
#line 935
            exit(2);
            }
          }
        }
#line 937
        if (restore_process) {
          {
#line 940
          new_process = fork();
          }
#line 941
          if (new_process == -1) {
            {
#line 943
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to restore killed process.\n");
            }
          } else
#line 945
          if (new_process == 0) {
#line 948
            if (verbose) {
              {
#line 949
              printf((char const   */* __restrict  */)"Relaunching %s\n", *(argv + last_known_argument));
              }
            }
            {
#line 951
            execvp((char const   *)*(argv + last_known_argument), (char * const  *)(argv + last_known_argument));
            }
          } else {
            {
#line 957
            pid = new_process;
#line 959
            sleep(5U);
            }
          }
        }
      } else {
        {
#line 969
        tmp___2 = kill(pid, 19);
        }
#line 969
        if (tmp___2 != 0) {
          {
#line 970
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Process %d dead!\n",
                  pid);
          }
#line 971
          if (lazy) {
            {
#line 971
            exit(2);
            }
          }
#line 973
          goto wait_for_process;
        }
        {
#line 975
        nanosleep((struct timespec  const  *)(& tsleep), (struct timespec *)((void *)0));
        }
      }
    }
#line 978
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 981
  return (0);
}
}
