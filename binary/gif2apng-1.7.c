/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 368 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned char Byte;
#line 370 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned int uInt;
#line 371 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned long uLong;
#line 377 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef Byte Bytef;
#line 386 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef void *voidpf;
#line 83 "/usr/include/zlib.h"
struct internal_state;
#line 83
struct internal_state;
#line 85 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 85 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 106 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1742 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
struct __anonstruct_OP_28 {
   z_stream zstream ;
   unsigned char *zbuf ;
   int x ;
   int y ;
   int w ;
   int h ;
   int valid ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
typedef struct __anonstruct_OP_28 OP;
#line 58 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
struct __anonstruct_STATS_29 {
   unsigned char r ;
   unsigned char g ;
   unsigned char b ;
   unsigned char a ;
   unsigned int num ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
typedef struct __anonstruct_STATS_29 STATS;
#line 814 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
struct IHDR {
   unsigned int mWidth ;
   unsigned int mHeight ;
   unsigned char mDepth ;
   unsigned char mColorType ;
   unsigned char mCompression ;
   unsigned char mFilterMethod ;
   unsigned char mInterlaceMethod ;
};
#line 825 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
struct acTL {
   unsigned int mFrameCount ;
   unsigned int mLoopCount ;
};
#line 831 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
struct fcTL {
   unsigned int mSeq ;
   unsigned int mWidth ;
   unsigned int mHeight ;
   unsigned int mXOffset ;
   unsigned int mYOffset ;
   unsigned short mDelayNum ;
   unsigned short mDelayDen ;
   unsigned char mDisposeOp ;
   unsigned char mBlendOp ;
};
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static unsigned int __bswap_32(unsigned int __bsx ) 
{ 
  int tmp ;

  {
  {
#line 47
  tmp = __builtin_bswap32((int )__bsx);
  }
#line 47
  return ((unsigned int )tmp);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 246 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 353
extern int deflateEnd(z_streamp strm ) ;
#line 649
extern int deflateReset(z_streamp strm ) ;
#line 1600
extern uLong crc32(uLong crc , Bytef const   *buf , uInt len ) ;
#line 1637
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
OP op[6]  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
STATS stats[256]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
unsigned int next_seq_num  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
unsigned char png_sign[8]  = 
#line 64
  {      (unsigned char)137,      (unsigned char)80,      (unsigned char)78,      (unsigned char)71, 
        (unsigned char)13,      (unsigned char)10,      (unsigned char)26,      (unsigned char)10};
#line 65 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
unsigned char png_Software[24]  = 
#line 65
  {      (unsigned char)83,      (unsigned char)111,      (unsigned char)102,      (unsigned char)116, 
        (unsigned char)119,      (unsigned char)97,      (unsigned char)114,      (unsigned char)101, 
        (unsigned char )'\000',      (unsigned char)103,      (unsigned char)105,      (unsigned char)102, 
        (unsigned char)50,      (unsigned char)97,      (unsigned char)112,      (unsigned char)110, 
        (unsigned char)103,      (unsigned char)46,      (unsigned char)115,      (unsigned char)102, 
        (unsigned char)46,      (unsigned char)110,      (unsigned char)101,      (unsigned char)116};
#line 69 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
int cmp_stats(void const   *arg1 , void const   *arg2 ) 
{ 


  {
#line 71
  if ((int )((STATS *)arg2)->a == (int )((STATS *)arg1)->a) {
#line 72
    return ((int )(((STATS *)arg2)->num - ((STATS *)arg1)->num));
  } else {
#line 74
    return ((int )((STATS *)arg1)->a - (int )((STATS *)arg2)->a);
  }
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
void DecodeLZW(unsigned char *img , FILE *f1 ) 
{ 
  int i ;
  int bits ;
  int codesize ;
  int codemask ;
  int clearcode ;
  int nextcode ;
  int lastcode ;
  unsigned int j ;
  unsigned int size ;
  unsigned int accum ;
  unsigned short prefix[4097] ;
  unsigned char suffix[4097] ;
  unsigned char str[4097] ;
  unsigned char data[1024] ;
  unsigned char firstchar ;
  unsigned char *pstr ;
  unsigned char *pout ;
  unsigned char mincodesize ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int incode ;
  int code ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 81
  size = 0U;
#line 82
  accum = 0U;
#line 87
  firstchar = (unsigned char)0;
#line 88
  pstr = str;
#line 89
  pout = img;
#line 92
  tmp = fread((void */* __restrict  */)(& mincodesize), (size_t )1, (size_t )1, (FILE */* __restrict  */)f1);
  }
#line 92
  if (tmp != 1UL) {
#line 92
    return;
  }
#line 94
  bits = 0;
#line 95
  codesize = (int )mincodesize + 1;
#line 96
  codemask = (1 << codesize) - 1;
#line 97
  clearcode = 1 << (int )mincodesize;
#line 98
  nextcode = clearcode + 2;
#line 99
  lastcode = -1;
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < clearcode)) {
#line 101
      goto while_break;
    }
#line 102
    suffix[i] = (unsigned char )i;
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  tmp___0 = fread((void */* __restrict  */)(& size), (size_t )1, (size_t )1, (FILE */* __restrict  */)f1);
  }
#line 104
  if (tmp___0 != 1UL) {
#line 104
    return;
  }
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! (size != 0U)) {
#line 105
      goto while_break___0;
    }
    {
#line 107
    tmp___1 = fread((void */* __restrict  */)(& data[0]), (size_t )1, (size_t )size,
                    (FILE */* __restrict  */)f1);
    }
#line 107
    if (tmp___1 != (size_t )size) {
#line 107
      return;
    }
#line 109
    j = 0U;
    {
#line 109
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 109
      if (! (j < size)) {
#line 109
        goto while_break___1;
      }
#line 111
      accum += (unsigned int )((int )data[j] << bits);
#line 112
      bits += 8;
      {
#line 113
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 113
        if (! (bits >= codesize)) {
#line 113
          goto while_break___2;
        }
#line 116
        code = (int )(accum & (unsigned int )codemask);
#line 117
        accum >>= codesize;
#line 118
        bits -= codesize;
#line 120
        if (code == clearcode + 1) {
#line 121
          goto while_break___2;
        }
#line 123
        if (code == clearcode) {
#line 125
          codesize = (int )mincodesize + 1;
#line 126
          codemask = (1 << codesize) - 1;
#line 127
          nextcode = clearcode + 2;
#line 128
          lastcode = -1;
#line 129
          goto while_continue___2;
        }
#line 132
        if (lastcode == -1) {
#line 134
          tmp___2 = pout;
#line 134
          pout ++;
#line 134
          *tmp___2 = suffix[code];
#line 135
          lastcode = code;
#line 135
          firstchar = (unsigned char )lastcode;
#line 136
          goto while_continue___2;
        }
#line 139
        incode = code;
#line 140
        if (code >= nextcode) {
#line 142
          tmp___3 = pstr;
#line 142
          pstr ++;
#line 142
          *tmp___3 = firstchar;
#line 143
          code = lastcode;
        }
        {
#line 146
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 146
          if (! (code >= clearcode)) {
#line 146
            goto while_break___3;
          }
#line 148
          tmp___4 = pstr;
#line 148
          pstr ++;
#line 148
          *tmp___4 = suffix[code];
#line 149
          code = (int )prefix[code];
        }
        while_break___3: /* CIL Label */ ;
        }
#line 152
        tmp___5 = pstr;
#line 152
        pstr ++;
#line 152
        firstchar = suffix[code];
#line 152
        *tmp___5 = firstchar;
#line 154
        if (nextcode < 4096) {
#line 156
          prefix[nextcode] = (unsigned short )lastcode;
#line 157
          suffix[nextcode] = firstchar;
#line 158
          nextcode ++;
#line 159
          if ((nextcode & codemask) == 0) {
#line 159
            if (nextcode < 4096) {
#line 161
              codesize ++;
#line 162
              codemask += nextcode;
            }
          }
        }
#line 165
        lastcode = incode;
        {
#line 167
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 169
          tmp___6 = pout;
#line 169
          pout ++;
#line 169
          pstr --;
#line 169
          *tmp___6 = *pstr;
#line 167
          if (! ((unsigned long )pstr > (unsigned long )(str))) {
#line 167
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 109
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 174
    tmp___7 = fread((void */* __restrict  */)(& size), (size_t )1, (size_t )1, (FILE */* __restrict  */)f1);
    }
#line 174
    if (tmp___7 != 1UL) {
#line 174
      return;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
void write_chunk(FILE *f , char const   *name , unsigned char *data , unsigned int length ) 
{ 
  unsigned int crc ;
  uLong tmp ;
  unsigned int len ;
  unsigned int tmp___0 ;
  uLong tmp___1 ;
  unsigned int seq ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  uLong tmp___4 ;
  int tmp___5 ;
  uLong tmp___6 ;

  {
  {
#line 180
  tmp = crc32((uLong )0, (Bytef const   *)0, (uInt )0);
#line 180
  crc = (unsigned int )tmp;
#line 181
  tmp___0 = __bswap_32(length);
#line 181
  len = tmp___0;
#line 183
  fwrite((void const   */* __restrict  */)(& len), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 184
  fwrite((void const   */* __restrict  */)name, (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 185
  tmp___1 = crc32((uLong )crc, (Bytef const   *)name, (uInt )4);
#line 185
  crc = (unsigned int )tmp___1;
#line 187
  tmp___5 = memcmp((void const   *)name, (void const   *)"fdAT", (size_t )4);
  }
#line 187
  if (tmp___5 == 0) {
    {
#line 189
    tmp___2 = next_seq_num;
#line 189
    next_seq_num ++;
#line 189
    tmp___3 = __bswap_32(tmp___2);
#line 189
    seq = tmp___3;
#line 190
    fwrite((void const   */* __restrict  */)(& seq), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 191
    tmp___4 = crc32((uLong )crc, (Bytef const   *)(& seq), (uInt )4);
#line 191
    crc = (unsigned int )tmp___4;
#line 192
    length -= 4U;
    }
  }
#line 195
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 195
    if (length > 0U) {
      {
#line 197
      fwrite((void const   */* __restrict  */)data, (size_t )1, (size_t )length, (FILE */* __restrict  */)f);
#line 198
      tmp___6 = crc32((uLong )crc, (Bytef const   *)data, length);
#line 198
      crc = (unsigned int )tmp___6;
      }
    }
  }
  {
#line 201
  crc = __bswap_32(crc);
#line 202
  fwrite((void const   */* __restrict  */)(& crc), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
  }
#line 203
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
void write_IDATs(FILE *f , int frame , unsigned char *data , unsigned int length ,
                 unsigned int idat_size ) 
{ 
  unsigned int z_cmf ;
  unsigned int z_cinfo ;
  unsigned int half_z_window_size ;
  unsigned int ds ;

  {
#line 207
  z_cmf = (unsigned int )*(data + 0);
#line 208
  if ((z_cmf & 15U) == 8U) {
#line 208
    if ((z_cmf & 240U) <= 112U) {
#line 210
      if (length >= 2U) {
#line 212
        z_cinfo = z_cmf >> 4;
#line 213
        half_z_window_size = (unsigned int )(1 << (z_cinfo + 7U));
        {
#line 214
        while (1) {
          while_continue: /* CIL Label */ ;
#line 214
          if (idat_size <= half_z_window_size) {
#line 214
            if (! (half_z_window_size >= 256U)) {
#line 214
              goto while_break;
            }
          } else {
#line 214
            goto while_break;
          }
#line 216
          z_cinfo --;
#line 217
          half_z_window_size >>= 1;
        }
        while_break: /* CIL Label */ ;
        }
#line 219
        z_cmf = (z_cmf & 15U) | (z_cinfo << 4);
#line 220
        if ((int )*(data + 0) != (int )((unsigned char )z_cmf)) {
#line 222
          *(data + 0) = (unsigned char )z_cmf;
#line 223
          *(data + 1) = (unsigned char )((int )*(data + 1) & 224);
#line 224
          *(data + 1) = (unsigned char )((int )*(data + 1) + (int )((unsigned char )(31U - ((z_cmf << 8) + (unsigned int )*(data + 1)) % 31U)));
        }
      }
    }
  }
  {
#line 229
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 229
    if (! (length > 0U)) {
#line 229
      goto while_break___0;
    }
#line 231
    ds = length;
#line 232
    if (ds > 32768U) {
#line 233
      ds = 32768U;
    }
#line 235
    if (frame == 0) {
      {
#line 236
      write_chunk(f, "IDAT", data, ds);
      }
    } else {
      {
#line 238
      write_chunk(f, "fdAT", data, ds + 4U);
      }
    }
#line 240
    data += ds;
#line 241
    length -= ds;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 243
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
int get_rect(int w , int h , unsigned char *pimg1 , unsigned char *pimg2 , unsigned char *ptemp ,
             int *px , int *py , int *pw , int *ph , int bpp , int has_tcolor , int tcolor ) 
{ 
  int i ;
  int j ;
  int x_min ;
  int y_min ;
  int x_max ;
  int y_max ;
  int diffnum ;
  int over_is_possible ;
  unsigned char *pa ;
  unsigned char *pb ;
  unsigned char *pc ;
  unsigned char c ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *pa___0 ;
  unsigned char *pb___0 ;
  unsigned char *pc___0 ;
  int c1 ;
  int c2 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 248
  x_min = w - 1;
#line 249
  y_min = h - 1;
#line 250
  x_max = 0;
#line 251
  y_max = 0;
#line 252
  diffnum = 0;
#line 253
  over_is_possible = 1;
#line 255
  if (! has_tcolor) {
#line 256
    over_is_possible = 0;
  }
#line 258
  if (bpp == 1) {
#line 260
    pa = pimg1;
#line 261
    pb = pimg2;
#line 262
    pc = ptemp;
#line 264
    j = 0;
    {
#line 264
    while (1) {
      while_continue: /* CIL Label */ ;
#line 264
      if (! (j < h)) {
#line 264
        goto while_break;
      }
#line 265
      i = 0;
      {
#line 265
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 265
        if (! (i < w)) {
#line 265
          goto while_break___0;
        }
#line 267
        tmp = pb;
#line 267
        pb ++;
#line 267
        c = *tmp;
#line 268
        tmp___0 = pa;
#line 268
        pa ++;
#line 268
        if ((int )*tmp___0 != (int )c) {
#line 270
          diffnum ++;
#line 271
          if (has_tcolor) {
#line 271
            if ((int )c == tcolor) {
#line 271
              over_is_possible = 0;
            }
          }
#line 272
          if (i < x_min) {
#line 272
            x_min = i;
          }
#line 273
          if (i > x_max) {
#line 273
            x_max = i;
          }
#line 274
          if (j < y_min) {
#line 274
            y_min = j;
          }
#line 275
          if (j > y_max) {
#line 275
            y_max = j;
          }
        } else {
#line 278
          c = (unsigned char )tcolor;
        }
#line 280
        tmp___1 = pc;
#line 280
        pc ++;
#line 280
        *tmp___1 = c;
#line 265
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 264
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 284
  if (bpp == 3) {
#line 286
    pa___0 = pimg1;
#line 287
    pb___0 = pimg2;
#line 288
    pc___0 = ptemp;
#line 290
    j = 0;
    {
#line 290
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 290
      if (! (j < h)) {
#line 290
        goto while_break___1;
      }
#line 291
      i = 0;
      {
#line 291
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 291
        if (! (i < w)) {
#line 291
          goto while_break___2;
        }
#line 293
        c1 = (((int )*(pa___0 + 2) << 16) + ((int )*(pa___0 + 1) << 8)) + (int )*(pa___0 + 0);
#line 294
        c2 = (((int )*(pb___0 + 2) << 16) + ((int )*(pb___0 + 1) << 8)) + (int )*(pb___0 + 0);
#line 295
        if (c1 != c2) {
#line 297
          diffnum ++;
#line 298
          if (has_tcolor) {
#line 298
            if (c2 == tcolor) {
#line 298
              over_is_possible = 0;
            }
          }
#line 299
          if (i < x_min) {
#line 299
            x_min = i;
          }
#line 300
          if (i > x_max) {
#line 300
            x_max = i;
          }
#line 301
          if (j < y_min) {
#line 301
            y_min = j;
          }
#line 302
          if (j > y_max) {
#line 302
            y_max = j;
          }
        } else {
#line 305
          c2 = tcolor;
        }
        {
#line 307
        memcpy((void */* __restrict  */)pc___0, (void const   */* __restrict  */)(& c2),
               (size_t )3);
#line 308
        pa___0 += 3;
#line 309
        pb___0 += 3;
#line 310
        pc___0 += 3;
#line 291
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 290
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 314
  if (diffnum == 0) {
#line 316
    tmp___2 = 0;
#line 316
    *py = tmp___2;
#line 316
    *px = tmp___2;
#line 317
    tmp___3 = 1;
#line 317
    *ph = tmp___3;
#line 317
    *pw = tmp___3;
  } else {
#line 321
    *px = x_min;
#line 322
    *py = y_min;
#line 323
    *pw = (x_max - x_min) + 1;
#line 324
    *ph = (y_max - y_min) + 1;
  }
#line 327
  return (over_is_possible);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
void deflate_rect(unsigned char *p , int x , int y , int w , int h , int bpp , int stride ,
                  unsigned char *row_buf , int zbuf_size , int n ) 
{ 
  int j ;
  unsigned char *row ;

  {
#line 333
  row = (p + y * stride) + x * bpp;
#line 334
  op[n].valid = 1;
#line 335
  op[n].zstream.next_out = op[n].zbuf;
#line 336
  op[n].zstream.avail_out = (uInt )zbuf_size;
#line 338
  j = 0;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (j < h)) {
#line 338
      goto while_break;
    }
    {
#line 340
    memcpy((void */* __restrict  */)(row_buf + 1), (void const   */* __restrict  */)row,
           (size_t )(w * bpp));
#line 341
    op[n].zstream.next_in = row_buf;
#line 342
    op[n].zstream.avail_in = (uInt )(w * bpp + 1);
#line 343
    deflate(& op[n].zstream, 0);
#line 344
    row += stride;
#line 338
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 347
  deflate(& op[n].zstream, 4);
#line 349
  op[n].x = x;
#line 350
  op[n].y = y;
#line 351
  op[n].w = w;
#line 352
  op[n].h = h;
  }
#line 353
  return;
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/gif2apng-1.7/gif2apng.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int j ;
  int k ;
  int n ;
  int start ;
  int try_over ;
  int w ;
  int h ;
  int x0 ;
  int y0 ;
  int w0 ;
  int h0 ;
  int x1 ;
  int y1 ;
  int w1 ;
  int h1 ;
  int x2 ;
  int y2 ;
  int w2 ;
  int h2 ;
  int has_tcolor ;
  int tcolor ;
  int unused ;
  int tr ;
  int tg ;
  int tb ;
  int grayscale ;
  unsigned char flags ;
  unsigned char bcolor ;
  unsigned char aspect ;
  unsigned char id ;
  unsigned char val ;
  unsigned char size ;
  unsigned char end ;
  unsigned char dop ;
  unsigned char bop ;
  unsigned char dispose_op ;
  unsigned char interlaced ;
  unsigned char has_t ;
  unsigned char t ;
  unsigned int c ;
  unsigned short delay ;
  char *szIn ;
  char szOut[256] ;
  char *szOpt ;
  char *szExt ;
  FILE *f1 ;
  FILE *f2 ;
  unsigned char data[1024] ;
  unsigned char cube[4096] ;
  unsigned char gray[256] ;
  unsigned char pal_g[256][3] ;
  unsigned char pal_l[256][3] ;
  unsigned char plte[256][3] ;
  unsigned char trns[256] ;
  int frames ;
  int loops ;
  int coltype ;
  int bpp ;
  int rowbytes ;
  int imagesize ;
  int idat_size ;
  int zbuf_size ;
  int zsize ;
  unsigned int palsize_g ;
  unsigned int palsize_l ;
  int plte_size ;
  int trns_size ;
  int ssize ;
  int keep_palette ;
  unsigned char *buffer ;
  unsigned char *zbuf ;
  unsigned char *row_buf ;
  unsigned char *frame0 ;
  unsigned char *frame1 ;
  unsigned char *frame2 ;
  unsigned char *rest ;
  unsigned char *temp ;
  unsigned short *delays ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char sig[6] ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  int netscape ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  unsigned int num[256] ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  int found ;
  int tmp___29 ;
  int gray_count ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;
  void *tmp___35 ;
  unsigned char *dst ;
  unsigned char *tmp___36 ;
  unsigned char *tmp___37 ;
  unsigned char *tmp___38 ;
  struct IHDR ihdr ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  struct acTL actl ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  struct fcTL fctl ;
  void *tmp___43 ;
  void *tmp___44 ;
  void *tmp___45 ;
  size_t tmp___46 ;
  size_t tmp___47 ;
  size_t tmp___48 ;
  size_t tmp___49 ;
  size_t tmp___50 ;
  size_t tmp___51 ;
  size_t tmp___52 ;
  size_t tmp___53 ;
  size_t tmp___54 ;
  size_t tmp___55 ;
  unsigned char *src ;
  unsigned char *dst___0 ;
  unsigned int sh[256] ;
  unsigned int shuffle ;
  size_t tmp___56 ;
  size_t tmp___57 ;
  size_t tmp___58 ;
  size_t tmp___59 ;
  size_t tmp___60 ;
  size_t tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  unsigned int op_min ;
  unsigned int op_best ;
  unsigned char *tmp___66 ;
  unsigned char *tmp___67 ;
  unsigned char *tmp___68 ;
  unsigned int tmp___69 ;
  unsigned short __v ;
  unsigned short __x ;
  unsigned short __v___0 ;
  unsigned short __x___0 ;
  unsigned char *tmp___70 ;
  unsigned char *tmp___71 ;
  unsigned char *tmp___72 ;
  unsigned char *tmp___73 ;
  unsigned char *tmp___74 ;
  unsigned char *tmp___75 ;
  int tmp___76 ;
  unsigned int tmp___77 ;
  unsigned short __v___1 ;
  unsigned short __x___1 ;
  unsigned short __v___2 ;
  unsigned short __x___2 ;

  {
  {
#line 379
  zsize = 0;
#line 380
  palsize_g = 0U;
#line 381
  palsize_l = 0U;
#line 382
  plte_size = 0;
#line 383
  trns_size = 0;
#line 384
  ssize = 0;
#line 385
  keep_palette = 0;
#line 397
  printf((char const   */* __restrict  */)"\ngif2apng 1.7\n\n");
  }
#line 399
  if (argc <= 1) {
    {
#line 401
    printf((char const   */* __restrict  */)"Usage: gif2apng anim.gif [anim.png] [-kp]\n\n-kp  : keep the palette\n");
    }
#line 403
    return (1);
  }
#line 406
  szIn = *(argv + 1);
#line 407
  szOut[0] = (char)0;
#line 409
  i = 2;
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    if (! (i < argc)) {
#line 409
      goto while_break;
    }
#line 411
    szOpt = *(argv + i);
#line 413
    if ((int )*(szOpt + 0) == 47) {
#line 413
      goto _L___0;
    } else
#line 413
    if ((int )*(szOpt + 0) == 45) {
      _L___0: /* CIL Label */ 
#line 415
      if ((int )*(szOpt + 1) == 107) {
#line 415
        goto _L;
      } else
#line 415
      if ((int )*(szOpt + 1) == 75) {
        _L: /* CIL Label */ 
#line 416
        if ((int )*(szOpt + 2) == 112) {
#line 417
          keep_palette = 1;
        } else
#line 416
        if ((int )*(szOpt + 2) == 80) {
#line 417
          keep_palette = 1;
        }
      }
    } else
#line 420
    if ((int )szOut[0] == 0) {
      {
#line 421
      strcpy((char */* __restrict  */)(szOut), (char const   */* __restrict  */)szOpt);
      }
    }
#line 409
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 424
  if ((int )szOut[0] == 0) {
    {
#line 426
    strcpy((char */* __restrict  */)(szOut), (char const   */* __restrict  */)szIn);
#line 427
    szExt = strrchr((char const   *)(szOut), '.');
    }
#line 427
    if ((unsigned long )szExt != (unsigned long )((void *)0)) {
#line 427
      *szExt = (char)0;
    }
    {
#line 428
    strcat((char */* __restrict  */)(szOut), (char const   */* __restrict  */)".png");
    }
  }
  {
#line 431
  memset((void *)(& stats), 0, sizeof(stats));
#line 432
  memset((void *)(& cube), 0, sizeof(cube));
#line 433
  memset((void *)(& gray), 0, sizeof(gray));
#line 435
  i = 0;
  }
  {
#line 435
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 435
    if (! (i < 256)) {
#line 435
      goto while_break___0;
    }
#line 437
    tmp___0 = (unsigned char )i;
#line 437
    pal_g[i][2] = tmp___0;
#line 437
    tmp = tmp___0;
#line 437
    pal_g[i][1] = tmp;
#line 437
    pal_g[i][0] = tmp;
#line 438
    tmp___2 = (unsigned char )i;
#line 438
    pal_l[i][2] = tmp___2;
#line 438
    tmp___1 = tmp___2;
#line 438
    pal_l[i][1] = tmp___1;
#line 438
    pal_l[i][0] = tmp___1;
#line 439
    stats[i].a = (unsigned char)255;
#line 440
    trns[i] = (unsigned char)255;
#line 435
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 443
  f1 = fopen((char const   */* __restrict  */)szIn, (char const   */* __restrict  */)"rb");
  }
#line 443
  if ((unsigned long )f1 != (unsigned long )((FILE *)0)) {
    {
#line 446
    printf((char const   */* __restrict  */)"Reading \'%s\'...\n", szIn);
#line 448
    tmp___9 = fread((void */* __restrict  */)(sig), (size_t )1, (size_t )6, (FILE */* __restrict  */)f1);
    }
#line 448
    if (tmp___9 == 6UL) {
#line 450
      if ((int )sig[0] == 71) {
#line 450
        if ((int )sig[1] == 73) {
#line 450
          if ((int )sig[2] == 70) {
            {
#line 452
            h = 0;
#line 452
            w = h;
#line 453
            tmp___3 = fread((void */* __restrict  */)(& w), (size_t )2, (size_t )1,
                            (FILE */* __restrict  */)f1);
            }
#line 453
            if (tmp___3 != 1UL) {
#line 453
              return (1);
            }
            {
#line 454
            tmp___4 = fread((void */* __restrict  */)(& h), (size_t )2, (size_t )1,
                            (FILE */* __restrict  */)f1);
            }
#line 454
            if (tmp___4 != 1UL) {
#line 454
              return (1);
            }
            {
#line 455
            tmp___5 = fread((void */* __restrict  */)(& flags), (size_t )1, (size_t )1,
                            (FILE */* __restrict  */)f1);
            }
#line 455
            if (tmp___5 != 1UL) {
#line 455
              return (1);
            }
            {
#line 456
            tmp___6 = fread((void */* __restrict  */)(& bcolor), (size_t )1, (size_t )1,
                            (FILE */* __restrict  */)f1);
            }
#line 456
            if (tmp___6 != 1UL) {
#line 456
              return (1);
            }
            {
#line 457
            tmp___7 = fread((void */* __restrict  */)(& aspect), (size_t )1, (size_t )1,
                            (FILE */* __restrict  */)f1);
            }
#line 457
            if (tmp___7 != 1UL) {
#line 457
              return (1);
            }
#line 458
            if ((int )flags & 128) {
              {
#line 460
              palsize_g = (unsigned int )(1 << (((int )flags & 7) + 1));
#line 461
              tmp___8 = fread((void */* __restrict  */)(& pal_g), (size_t )3, (size_t )palsize_g,
                              (FILE */* __restrict  */)f1);
              }
#line 461
              if (tmp___8 != (size_t )palsize_g) {
#line 461
                return (1);
              }
            }
          } else {
            {
#line 466
            printf((char const   */* __restrict  */)"Error: wrong GIF sig\n");
            }
#line 467
            return (1);
          }
        } else {
          {
#line 466
          printf((char const   */* __restrict  */)"Error: wrong GIF sig\n");
          }
#line 467
          return (1);
        }
      } else {
        {
#line 466
        printf((char const   */* __restrict  */)"Error: wrong GIF sig\n");
        }
#line 467
        return (1);
      }
    } else {
      {
#line 472
      printf((char const   */* __restrict  */)"Error: can\'t read the sig\n");
      }
#line 473
      return (1);
    }
    {
#line 476
    tmp___10 = ftell(f1);
#line 476
    start = (int )tmp___10;
#line 478
    frames = 0;
#line 479
    loops = 1;
#line 480
    coltype = 3;
#line 481
    bpp = 1;
#line 482
    rowbytes = w;
#line 483
    imagesize = w * h;
#line 484
    grayscale = 1;
#line 486
    tmp___11 = malloc((size_t )(imagesize * 2));
#line 486
    buffer = (unsigned char *)tmp___11;
    }
#line 487
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
      {
#line 489
      printf((char const   */* __restrict  */)"Error: not enough memory\n");
      }
#line 490
      return (1);
    }
#line 493
    tb = 0;
#line 493
    tg = tb;
#line 493
    tr = tg;
#line 493
    t = (unsigned char )tr;
#line 493
    tcolor = (int )t;
#line 493
    has_t = (unsigned char )tcolor;
#line 493
    has_tcolor = (int )has_t;
    {
#line 496
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 496
      tmp___29 = feof(f1);
      }
#line 496
      if (tmp___29) {
#line 496
        goto while_break___1;
      }
      {
#line 498
      tmp___12 = fread((void */* __restrict  */)(& id), (size_t )1, (size_t )1, (FILE */* __restrict  */)f1);
      }
#line 498
      if (tmp___12 != 1UL) {
#line 498
        return (1);
      }
#line 499
      if ((int )id == 33) {
        {
#line 501
        tmp___13 = fread((void */* __restrict  */)(& val), (size_t )1, (size_t )1,
                         (FILE */* __restrict  */)f1);
        }
#line 501
        if (tmp___13 != 1UL) {
#line 501
          return (1);
        }
#line 502
        if ((int )val == 249) {
          {
#line 504
          tmp___14 = fread((void */* __restrict  */)(& size), (size_t )1, (size_t )1,
                           (FILE */* __restrict  */)f1);
          }
#line 504
          if (tmp___14 != 1UL) {
#line 504
            return (1);
          }
          {
#line 505
          tmp___15 = fread((void */* __restrict  */)(& flags), (size_t )1, (size_t )1,
                           (FILE */* __restrict  */)f1);
          }
#line 505
          if (tmp___15 != 1UL) {
#line 505
            return (1);
          }
          {
#line 506
          tmp___16 = fread((void */* __restrict  */)(& delay), (size_t )2, (size_t )1,
                           (FILE */* __restrict  */)f1);
          }
#line 506
          if (tmp___16 != 1UL) {
#line 506
            return (1);
          }
          {
#line 507
          tmp___17 = fread((void */* __restrict  */)(& t), (size_t )1, (size_t )1,
                           (FILE */* __restrict  */)f1);
          }
#line 507
          if (tmp___17 != 1UL) {
#line 507
            return (1);
          }
          {
#line 508
          tmp___18 = fread((void */* __restrict  */)(& end), (size_t )1, (size_t )1,
                           (FILE */* __restrict  */)f1);
          }
#line 508
          if (tmp___18 != 1UL) {
#line 508
            return (1);
          }
#line 509
          has_t = (unsigned char )((int )flags & 1);
        } else {
          {
#line 513
          netscape = 0;
#line 514
          tmp___19 = fread((void */* __restrict  */)(& size), (size_t )1, (size_t )1,
                           (FILE */* __restrict  */)f1);
          }
#line 514
          if (tmp___19 != 1UL) {
#line 514
            return (1);
          }
          {
#line 515
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 515
            if (! ((int )size != 0)) {
#line 515
              goto while_break___2;
            }
            {
#line 517
            tmp___20 = fread((void */* __restrict  */)(& data[0]), (size_t )1, (size_t )size,
                             (FILE */* __restrict  */)f1);
            }
#line 517
            if (tmp___20 != (size_t )size) {
#line 517
              return (1);
            }
#line 518
            if (netscape == 1) {
#line 520
              if ((int )size == 3) {
#line 520
                loops = ((int )data[2] << 8) + (int )data[1];
              }
#line 521
              netscape = 0;
            }
#line 523
            if ((int )val == 255) {
#line 523
              if ((int )size == 11) {
                {
#line 523
                tmp___21 = memcmp((void const   *)(data), (void const   *)"NETSCAPE2.0",
                                  (size_t )11);
                }
#line 523
                if (tmp___21 == 0) {
#line 524
                  netscape = 1;
                }
              }
            }
            {
#line 525
            tmp___22 = fread((void */* __restrict  */)(& size), (size_t )1, (size_t )1,
                             (FILE */* __restrict  */)f1);
            }
#line 525
            if (tmp___22 != 1UL) {
#line 525
              return (1);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      } else
#line 530
      if ((int )id == 44) {
        {
#line 533
        h0 = 0;
#line 533
        w0 = h0;
#line 533
        y0 = w0;
#line 533
        x0 = y0;
#line 534
        tmp___23 = fread((void */* __restrict  */)(& x0), (size_t )2, (size_t )1,
                         (FILE */* __restrict  */)f1);
        }
#line 534
        if (tmp___23 != 1UL) {
#line 534
          return (1);
        }
        {
#line 535
        tmp___24 = fread((void */* __restrict  */)(& y0), (size_t )2, (size_t )1,
                         (FILE */* __restrict  */)f1);
        }
#line 535
        if (tmp___24 != 1UL) {
#line 535
          return (1);
        }
        {
#line 536
        tmp___25 = fread((void */* __restrict  */)(& w0), (size_t )2, (size_t )1,
                         (FILE */* __restrict  */)f1);
        }
#line 536
        if (tmp___25 != 1UL) {
#line 536
          return (1);
        }
        {
#line 537
        tmp___26 = fread((void */* __restrict  */)(& h0), (size_t )2, (size_t )1,
                         (FILE */* __restrict  */)f1);
        }
#line 537
        if (tmp___26 != 1UL) {
#line 537
          return (1);
        }
        {
#line 538
        tmp___27 = fread((void */* __restrict  */)(& flags), (size_t )1, (size_t )1,
                         (FILE */* __restrict  */)f1);
        }
#line 538
        if (tmp___27 != 1UL) {
#line 538
          return (1);
        }
        {
#line 539
        memcpy((void */* __restrict  */)(& pal_l), (void const   */* __restrict  */)(& pal_g),
               (size_t )768);
        }
#line 540
        if ((int )flags & 128) {
          {
#line 542
          palsize_l = (unsigned int )(1 << (((int )flags & 7) + 1));
#line 543
          tmp___28 = fread((void */* __restrict  */)(& pal_l), (size_t )3, (size_t )palsize_l,
                           (FILE */* __restrict  */)f1);
          }
#line 543
          if (tmp___28 != (size_t )palsize_l) {
#line 543
            return (1);
          }
        }
        {
#line 545
        imagesize = w0 * h0;
#line 547
        DecodeLZW(buffer, f1);
#line 549
        i = 0;
        }
        {
#line 549
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 549
          if (! (i < 256)) {
#line 549
            goto while_break___3;
          }
#line 550
          num[i] = 0U;
#line 549
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 552
        i = 0;
        {
#line 552
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 552
          if (! (i < imagesize)) {
#line 552
            goto while_break___4;
          }
#line 553
          (num[*(buffer + i)]) ++;
#line 552
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 555
        if (has_t) {
#line 557
          if (frames == 0) {
#line 559
            has_tcolor = 1;
#line 560
            tcolor = (int )t;
#line 561
            tr = (int )pal_l[tcolor][0];
#line 562
            tg = (int )pal_l[tcolor][1];
#line 563
            tb = (int )pal_l[tcolor][2];
#line 564
            stats[tcolor].a = (unsigned char)0;
          }
#line 566
          num[t] = 0U;
        }
#line 569
        i = 0;
        {
#line 569
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 569
          if (! (i < 256)) {
#line 569
            goto while_break___5;
          }
#line 570
          if (num[i] != 0U) {
#line 572
            if (((((int )pal_l[i][0] | (int )pal_l[i][1]) | (int )pal_l[i][2]) & 15) == 0) {
#line 573
              cube[(((int )pal_l[i][0] << 4) + (int )pal_l[i][1]) + ((int )pal_l[i][2] >> 4)] = (unsigned char)1;
            }
#line 574
            if ((int )pal_l[i][0] == (int )pal_l[i][1]) {
#line 574
              if ((int )pal_l[i][1] == (int )pal_l[i][2]) {
#line 575
                gray[pal_l[i][0]] = (unsigned char)1;
              } else {
#line 577
                grayscale = 0;
              }
            } else {
#line 577
              grayscale = 0;
            }
          }
#line 569
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 580
        if (frames == 0) {
#line 582
          i = 0;
          {
#line 582
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 582
            if (! (i < 256)) {
#line 582
              goto while_break___6;
            }
#line 584
            stats[i].r = pal_l[i][0];
#line 585
            stats[i].g = pal_l[i][1];
#line 586
            stats[i].b = pal_l[i][2];
#line 587
            stats[i].num = num[i];
#line 582
            i ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 589
          if (palsize_g > palsize_l) {
#line 589
            ssize = (int )palsize_g;
          } else {
#line 589
            ssize = (int )palsize_l;
          }
        } else {
#line 593
          i = 0;
          {
#line 593
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 593
            if (! (i < 256)) {
#line 593
              goto while_break___7;
            }
#line 594
            if (num[i] > 0U) {
#line 596
              found = 0;
#line 597
              j = 0;
              {
#line 597
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 597
                if (! (j < ssize)) {
#line 597
                  goto while_break___8;
                }
#line 598
                if ((int )pal_l[i][0] == (int )stats[j].r) {
#line 598
                  if ((int )pal_l[i][1] == (int )stats[j].g) {
#line 598
                    if ((int )pal_l[i][2] == (int )stats[j].b) {
#line 598
                      if ((int )stats[j].a == 255) {
#line 600
                        stats[j].num += num[i];
#line 601
                        found = 1;
#line 602
                        goto while_break___8;
                      }
                    }
                  }
                }
#line 597
                j ++;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 605
              if (found == 0) {
#line 607
                if (ssize < 256) {
#line 609
                  stats[ssize].r = pal_l[i][0];
#line 610
                  stats[ssize].g = pal_l[i][1];
#line 611
                  stats[ssize].b = pal_l[i][2];
#line 612
                  stats[ssize].num = num[i];
#line 613
                  ssize ++;
                } else {
#line 617
                  keep_palette = 0;
#line 618
                  found = 0;
#line 619
                  j = 0;
                  {
#line 619
                  while (1) {
                    while_continue___9: /* CIL Label */ ;
#line 619
                    if (! (j < 256)) {
#line 619
                      goto while_break___9;
                    }
#line 621
                    if (stats[j].num == 0U) {
#line 621
                      if ((int )stats[j].a == 255) {
#line 623
                        stats[j].r = pal_l[i][0];
#line 624
                        stats[j].g = pal_l[i][1];
#line 625
                        stats[j].b = pal_l[i][2];
#line 626
                        stats[j].num = num[i];
#line 627
                        found = 1;
#line 628
                        goto while_break___9;
                      }
                    }
#line 619
                    j ++;
                  }
                  while_break___9: /* CIL Label */ ;
                  }
#line 631
                  if (found == 0) {
#line 633
                    coltype = 2;
#line 634
                    bpp = 3;
                  }
                }
              }
            }
#line 593
            i ++;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
#line 640
        frames ++;
      } else {
#line 643
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 647
    printf((char const   */* __restrict  */)"%d frames.\n", frames);
#line 649
    next_seq_num = 0U;
#line 650
    rowbytes *= bpp;
#line 651
    imagesize = rowbytes * h;
#line 654
    unused = 0;
    }
#line 655
    if (! has_tcolor) {
#line 657
      i = 0;
      {
#line 657
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 657
        if (! (i < 4096)) {
#line 657
          goto while_break___10;
        }
#line 658
        if ((int )cube[i] == 0) {
#line 660
          tr = (i >> 4) & 240;
#line 661
          tg = i & 240;
#line 662
          tb = (i << 4) & 240;
#line 663
          unused = 1;
#line 664
          goto while_break___10;
        }
#line 657
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 668
    if (coltype == 3) {
#line 670
      if (keep_palette == 1) {
#line 672
        i = 0;
        {
#line 672
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 672
          if (! (i < ssize)) {
#line 672
            goto while_break___11;
          }
#line 674
          plte[i][0] = stats[i].r;
#line 675
          plte[i][1] = stats[i].g;
#line 676
          plte[i][2] = stats[i].b;
#line 672
          i ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 678
        plte_size = ssize;
#line 679
        if (! has_tcolor) {
#line 680
          i = 0;
          {
#line 680
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 680
            if (! (i < 256)) {
#line 680
              goto while_break___12;
            }
#line 681
            if (stats[i].num == 0U) {
#line 683
              has_tcolor = 1;
#line 684
              tcolor = i;
#line 685
              goto while_break___12;
            }
#line 680
            i ++;
          }
          while_break___12: /* CIL Label */ ;
          }
        }
#line 687
        if (has_tcolor) {
#line 689
          trns[tcolor] = (unsigned char)0;
#line 690
          trns_size = tcolor + 1;
#line 691
          if (trns_size > plte_size) {
#line 692
            plte_size = trns_size;
          }
        }
      } else {
#line 697
        if (grayscale) {
#line 699
          gray_count = 0;
#line 700
          i = 0;
          {
#line 700
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 700
            if (! (i < 256)) {
#line 700
              goto while_break___13;
            }
#line 701
            gray_count += (int )gray[i];
#line 700
            i ++;
          }
          while_break___13: /* CIL Label */ ;
          }
#line 702
          if (gray_count <= 192) {
#line 703
            grayscale = 0;
          }
        }
#line 706
        if (grayscale) {
#line 708
          coltype = 0;
#line 709
          plte_size = 0;
#line 711
          if (has_tcolor) {
#line 713
            tcolor = (int )stats[tcolor].r;
#line 714
            if ((int )gray[tcolor] == 1) {
#line 715
              has_tcolor = 0;
            }
          }
#line 718
          if (! has_tcolor) {
#line 719
            i = 0;
            {
#line 719
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 719
              if (! (i < 256)) {
#line 719
                goto while_break___14;
              }
#line 720
              if ((int )gray[i] == 0) {
#line 722
                has_tcolor = 1;
#line 723
                tcolor = i;
#line 724
                goto while_break___14;
              }
#line 719
              i ++;
            }
            while_break___14: /* CIL Label */ ;
            }
          }
#line 727
          if (has_tcolor) {
#line 729
            trns[0] = (unsigned char)0;
#line 729
            trns[1] = (unsigned char )tcolor;
#line 730
            trns_size = 2;
          }
        } else {
#line 735
          if (! has_tcolor) {
#line 736
            i = 0;
            {
#line 736
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 736
              if (! (i < 256)) {
#line 736
                goto while_break___15;
              }
#line 737
              if (stats[i].num == 0U) {
#line 739
                has_tcolor = 1;
#line 740
                tcolor = i;
#line 741
                goto while_break___15;
              }
#line 736
              i ++;
            }
            while_break___15: /* CIL Label */ ;
            }
          }
#line 743
          if (has_tcolor) {
#line 744
            stats[tcolor].a = (unsigned char)0;
          }
          {
#line 746
          qsort((void *)(& stats[0]), (size_t )256, sizeof(STATS ), & cmp_stats);
#line 748
          i = 0;
          }
          {
#line 748
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 748
            if (! (i < 256)) {
#line 748
              goto while_break___16;
            }
#line 750
            plte[i][0] = stats[i].r;
#line 751
            plte[i][1] = stats[i].g;
#line 752
            plte[i][2] = stats[i].b;
#line 753
            trns[i] = stats[i].a;
#line 754
            if (stats[i].num != 0U) {
#line 755
              plte_size = i + 1;
            } else
#line 754
            if ((int )stats[i].a != 255) {
#line 755
              plte_size = i + 1;
            }
#line 756
            if ((int )trns[i] != 255) {
#line 757
              trns_size = i + 1;
            }
#line 758
            if ((int )trns[i] == 0) {
#line 759
              tcolor = i;
            }
#line 748
            i ++;
          }
          while_break___16: /* CIL Label */ ;
          }
        }
      }
    } else
#line 766
    if (has_tcolor) {
#line 766
      goto _L___1;
    } else
#line 766
    if (unused) {
      _L___1: /* CIL Label */ 
#line 768
      trns[0] = (unsigned char)0;
#line 768
      trns[1] = (unsigned char )tr;
#line 769
      trns[2] = (unsigned char)0;
#line 769
      trns[3] = (unsigned char )tg;
#line 770
      trns[4] = (unsigned char)0;
#line 770
      trns[5] = (unsigned char )tb;
#line 771
      trns_size = 6;
#line 772
      has_tcolor = 1;
#line 773
      tcolor = ((tb << 16) + (tg << 8)) + tr;
    }
    {
#line 778
    tmp___30 = malloc((size_t )(frames * 2));
#line 778
    delays = (unsigned short *)tmp___30;
    }
#line 779
    if ((unsigned long )delays == (unsigned long )((void *)0)) {
#line 780
      return (1);
    }
#line 782
    i = 0;
    {
#line 782
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 782
      if (! (i < frames)) {
#line 782
        goto while_break___17;
      }
#line 783
      *(delays + i) = (unsigned short)10;
#line 782
      i ++;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 785
    tmp___31 = malloc((size_t )imagesize);
#line 785
    frame0 = (unsigned char *)tmp___31;
#line 786
    tmp___32 = malloc((size_t )imagesize);
#line 786
    frame1 = (unsigned char *)tmp___32;
#line 787
    tmp___33 = malloc((size_t )imagesize);
#line 787
    frame2 = (unsigned char *)tmp___33;
#line 788
    tmp___34 = malloc((size_t )imagesize);
#line 788
    rest = (unsigned char *)tmp___34;
#line 789
    tmp___35 = malloc((size_t )imagesize);
#line 789
    temp = (unsigned char *)tmp___35;
    }
#line 791
    if (! frame0) {
      {
#line 793
      printf((char const   */* __restrict  */)"Error: not enough memory\n");
      }
#line 794
      return (1);
    } else
#line 791
    if (! frame1) {
      {
#line 793
      printf((char const   */* __restrict  */)"Error: not enough memory\n");
      }
#line 794
      return (1);
    } else
#line 791
    if (! frame2) {
      {
#line 793
      printf((char const   */* __restrict  */)"Error: not enough memory\n");
      }
#line 794
      return (1);
    } else
#line 791
    if (! rest) {
      {
#line 793
      printf((char const   */* __restrict  */)"Error: not enough memory\n");
      }
#line 794
      return (1);
    } else
#line 791
    if (! temp) {
      {
#line 793
      printf((char const   */* __restrict  */)"Error: not enough memory\n");
      }
#line 794
      return (1);
    }
#line 797
    if (coltype == 2) {
#line 799
      dst = frame0;
#line 800
      j = 0;
      {
#line 800
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 800
        if (! (j < h)) {
#line 800
          goto while_break___18;
        }
#line 801
        i = 0;
        {
#line 801
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 801
          if (! (i < w)) {
#line 801
            goto while_break___19;
          }
#line 803
          tmp___36 = dst;
#line 803
          dst ++;
#line 803
          *tmp___36 = (unsigned char )tr;
#line 804
          tmp___37 = dst;
#line 804
          dst ++;
#line 804
          *tmp___37 = (unsigned char )tg;
#line 805
          tmp___38 = dst;
#line 805
          dst ++;
#line 805
          *tmp___38 = (unsigned char )tb;
#line 801
          i ++;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 800
        j ++;
      }
      while_break___18: /* CIL Label */ ;
      }
    } else {
      {
#line 809
      memset((void *)frame0, tcolor, (size_t )imagesize);
      }
    }
    {
#line 812
    f2 = fopen((char const   */* __restrict  */)(szOut), (char const   */* __restrict  */)"wb");
    }
#line 812
    if ((unsigned long )f2 != (unsigned long )((FILE *)0)) {
      {
#line 814
      tmp___39 = __bswap_32((unsigned int )w);
#line 814
      tmp___40 = __bswap_32((unsigned int )h);
#line 814
      ihdr.mWidth = tmp___39;
#line 814
      ihdr.mHeight = tmp___40;
#line 814
      ihdr.mDepth = (unsigned char)8;
#line 814
      ihdr.mColorType = (unsigned char )coltype;
#line 814
      ihdr.mCompression = (unsigned char)0;
#line 814
      ihdr.mFilterMethod = (unsigned char)0;
#line 814
      ihdr.mInterlaceMethod = (unsigned char)0;
#line 825
      tmp___41 = __bswap_32((unsigned int )frames);
#line 825
      tmp___42 = __bswap_32((unsigned int )loops);
#line 825
      actl.mFrameCount = tmp___41;
#line 825
      actl.mLoopCount = tmp___42;
#line 844
      printf((char const   */* __restrict  */)"Writing \'%s\'...\n", szOut);
#line 846
      fwrite((void const   */* __restrict  */)(png_sign), (size_t )1, (size_t )8,
             (FILE */* __restrict  */)f2);
#line 848
      write_chunk(f2, "IHDR", (unsigned char *)(& ihdr), 13U);
      }
#line 850
      if (frames > 1) {
        {
#line 851
        write_chunk(f2, "acTL", (unsigned char *)(& actl), 8U);
        }
      }
#line 853
      if (plte_size > 0) {
#line 853
        if (coltype == 3) {
          {
#line 854
          write_chunk(f2, "PLTE", (unsigned char *)(& plte), (unsigned int )(plte_size * 3));
          }
        }
      }
#line 856
      if (trns_size > 0) {
        {
#line 857
        write_chunk(f2, "tRNS", trns, (unsigned int )trns_size);
        }
      }
#line 859
      idat_size = (rowbytes + 1) * h;
#line 860
      zbuf_size = ((idat_size + ((idat_size + 7) >> 3)) + ((idat_size + 63) >> 6)) + 11;
#line 862
      i = 0;
      {
#line 862
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 862
        if (! (i < 6)) {
#line 862
          goto while_break___20;
        }
        {
#line 864
        op[i].zstream.data_type = 0;
#line 865
        op[i].zstream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 866
        op[i].zstream.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 867
        op[i].zstream.opaque = (voidpf )0;
#line 869
        deflateInit2_(& op[i].zstream, 9, 8, 15, 8, 0, "1.2.8", (int )sizeof(z_stream ));
#line 871
        tmp___43 = malloc((size_t )zbuf_size);
#line 871
        op[i].zbuf = (unsigned char *)tmp___43;
        }
#line 872
        if ((unsigned long )op[i].zbuf == (unsigned long )((void *)0)) {
#line 873
          return (1);
        }
#line 862
        i ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      {
#line 876
      tmp___44 = malloc((size_t )zbuf_size);
#line 876
      zbuf = (unsigned char *)tmp___44;
      }
#line 877
      if ((unsigned long )zbuf == (unsigned long )((void *)0)) {
#line 878
        return (1);
      }
      {
#line 880
      tmp___45 = malloc((size_t )(rowbytes + 1));
#line 880
      row_buf = (unsigned char *)tmp___45;
      }
#line 881
      if ((unsigned long )row_buf == (unsigned long )((void *)0)) {
#line 882
        return (1);
      }
      {
#line 884
      *(row_buf + 0) = (unsigned char)0;
#line 886
      x1 = 0;
#line 887
      y1 = 0;
#line 888
      w1 = w;
#line 889
      h1 = h;
#line 890
      bop = (unsigned char)0;
#line 892
      fseek(f1, (long )start, 0);
#line 893
      dispose_op = (unsigned char)0;
#line 894
      has_t = (unsigned char)0;
#line 895
      n = 0;
      }
      {
#line 897
      while (1) {
        while_continue___21: /* CIL Label */ ;
        {
#line 897
        tmp___76 = feof(f1);
        }
#line 897
        if (tmp___76) {
#line 897
          goto while_break___21;
        }
        {
#line 899
        tmp___46 = fread((void */* __restrict  */)(& id), (size_t )1, (size_t )1,
                         (FILE */* __restrict  */)f1);
        }
#line 899
        if (tmp___46 != 1UL) {
#line 899
          return (1);
        }
#line 900
        if ((int )id == 33) {
          {
#line 902
          tmp___47 = fread((void */* __restrict  */)(& val), (size_t )1, (size_t )1,
                           (FILE */* __restrict  */)f1);
          }
#line 902
          if (tmp___47 != 1UL) {
#line 902
            return (1);
          }
#line 903
          if ((int )val == 249) {
            {
#line 905
            tmp___48 = fread((void */* __restrict  */)(& size), (size_t )1, (size_t )1,
                             (FILE */* __restrict  */)f1);
            }
#line 905
            if (tmp___48 != 1UL) {
#line 905
              return (1);
            }
            {
#line 906
            tmp___49 = fread((void */* __restrict  */)(& flags), (size_t )1, (size_t )1,
                             (FILE */* __restrict  */)f1);
            }
#line 906
            if (tmp___49 != 1UL) {
#line 906
              return (1);
            }
            {
#line 907
            tmp___50 = fread((void */* __restrict  */)(& delay), (size_t )2, (size_t )1,
                             (FILE */* __restrict  */)f1);
            }
#line 907
            if (tmp___50 != 1UL) {
#line 907
              return (1);
            }
            {
#line 908
            tmp___51 = fread((void */* __restrict  */)(& t), (size_t )1, (size_t )1,
                             (FILE */* __restrict  */)f1);
            }
#line 908
            if (tmp___51 != 1UL) {
#line 908
              return (1);
            }
            {
#line 909
            tmp___52 = fread((void */* __restrict  */)(& end), (size_t )1, (size_t )1,
                             (FILE */* __restrict  */)f1);
            }
#line 909
            if (tmp___52 != 1UL) {
#line 909
              return (1);
            }
#line 910
            has_t = (unsigned char )((int )flags & 1);
#line 911
            dispose_op = (unsigned char )(((int )flags >> 2) & 7);
#line 912
            if ((int )dispose_op > 3) {
#line 912
              dispose_op = (unsigned char)3;
            }
#line 913
            if ((int )dispose_op == 3) {
#line 913
              if (n == 0) {
#line 913
                dispose_op = (unsigned char)2;
              }
            }
#line 914
            if ((int )delay > 1) {
#line 914
              *(delays + n) = delay;
            }
          } else {
            {
#line 918
            tmp___53 = fread((void */* __restrict  */)(& size), (size_t )1, (size_t )1,
                             (FILE */* __restrict  */)f1);
            }
#line 918
            if (tmp___53 != 1UL) {
#line 918
              return (1);
            }
            {
#line 919
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 919
              if (! ((int )size != 0)) {
#line 919
                goto while_break___22;
              }
              {
#line 921
              tmp___54 = fread((void */* __restrict  */)(& data[0]), (size_t )1, (size_t )size,
                               (FILE */* __restrict  */)f1);
              }
#line 921
              if (tmp___54 != (size_t )size) {
#line 921
                return (1);
              }
              {
#line 922
              tmp___55 = fread((void */* __restrict  */)(& size), (size_t )1, (size_t )1,
                               (FILE */* __restrict  */)f1);
              }
#line 922
              if (tmp___55 != 1UL) {
#line 922
                return (1);
              }
            }
            while_break___22: /* CIL Label */ ;
            }
          }
        } else
#line 927
        if ((int )id == 44) {
          {
#line 933
          shuffle = 0U;
#line 935
          h0 = 0;
#line 935
          w0 = h0;
#line 935
          y0 = w0;
#line 935
          x0 = y0;
#line 936
          tmp___56 = fread((void */* __restrict  */)(& x0), (size_t )2, (size_t )1,
                           (FILE */* __restrict  */)f1);
          }
#line 936
          if (tmp___56 != 1UL) {
#line 936
            return (1);
          }
          {
#line 937
          tmp___57 = fread((void */* __restrict  */)(& y0), (size_t )2, (size_t )1,
                           (FILE */* __restrict  */)f1);
          }
#line 937
          if (tmp___57 != 1UL) {
#line 937
            return (1);
          }
          {
#line 938
          tmp___58 = fread((void */* __restrict  */)(& w0), (size_t )2, (size_t )1,
                           (FILE */* __restrict  */)f1);
          }
#line 938
          if (tmp___58 != 1UL) {
#line 938
            return (1);
          }
          {
#line 939
          tmp___59 = fread((void */* __restrict  */)(& h0), (size_t )2, (size_t )1,
                           (FILE */* __restrict  */)f1);
          }
#line 939
          if (tmp___59 != 1UL) {
#line 939
            return (1);
          }
          {
#line 940
          tmp___60 = fread((void */* __restrict  */)(& flags), (size_t )1, (size_t )1,
                           (FILE */* __restrict  */)f1);
          }
#line 940
          if (tmp___60 != 1UL) {
#line 940
            return (1);
          }
          {
#line 941
          interlaced = (unsigned char )((int )flags & 64);
#line 942
          memcpy((void */* __restrict  */)(& pal_l), (void const   */* __restrict  */)(& pal_g),
                 (size_t )768);
          }
#line 943
          if ((int )flags & 128) {
            {
#line 945
            palsize_l = (unsigned int )(1 << (((int )flags & 7) + 1));
#line 946
            tmp___61 = fread((void */* __restrict  */)(& pal_l), (size_t )3, (size_t )palsize_l,
                             (FILE */* __restrict  */)f1);
            }
#line 946
            if (tmp___61 != (size_t )palsize_l) {
#line 946
              return (1);
            }
          }
#line 949
          if (coltype == 3) {
#line 951
            c = 0U;
            {
#line 951
            while (1) {
              while_continue___23: /* CIL Label */ ;
#line 951
              if (! (c < 256U)) {
#line 951
                goto while_break___23;
              }
#line 953
              sh[c] = c;
#line 955
              if (has_t) {
#line 955
                if (c == (unsigned int )t) {
#line 956
                  sh[c] = (unsigned int )tcolor;
                } else {
#line 955
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
#line 959
                i = 0;
                {
#line 959
                while (1) {
                  while_continue___24: /* CIL Label */ ;
#line 959
                  if (! (i < plte_size)) {
#line 959
                    goto while_break___24;
                  }
#line 960
                  if ((int )pal_l[c][0] == (int )plte[i][0]) {
#line 960
                    if ((int )pal_l[c][1] == (int )plte[i][1]) {
#line 960
                      if ((int )pal_l[c][2] == (int )plte[i][2]) {
#line 960
                        if ((int )trns[i] == 255) {
#line 962
                          sh[c] = (unsigned int )i;
#line 963
                          goto while_break___24;
                        }
                      }
                    }
                  }
#line 959
                  i ++;
                }
                while_break___24: /* CIL Label */ ;
                }
              }
#line 967
              if (sh[c] != c) {
#line 968
                shuffle = 1U;
              }
#line 951
              c ++;
            }
            while_break___23: /* CIL Label */ ;
            }
          } else
#line 972
          if (coltype == 0) {
#line 974
            c = 0U;
            {
#line 974
            while (1) {
              while_continue___25: /* CIL Label */ ;
#line 974
              if (! (c < 256U)) {
#line 974
                goto while_break___25;
              }
#line 976
              if (has_t) {
#line 976
                if (c == (unsigned int )t) {
#line 977
                  sh[c] = (unsigned int )tcolor;
                } else {
#line 979
                  sh[c] = (unsigned int )pal_l[c][0];
                }
              } else {
#line 979
                sh[c] = (unsigned int )pal_l[c][0];
              }
#line 981
              if (sh[c] != c) {
#line 982
                shuffle = 1U;
              }
#line 974
              c ++;
            }
            while_break___25: /* CIL Label */ ;
            }
          }
          {
#line 986
          memcpy((void */* __restrict  */)rest, (void const   */* __restrict  */)frame0,
                 (size_t )imagesize);
#line 988
          DecodeLZW(buffer, f1);
#line 990
          h2 = (h0 - 1) / 2;
          }
#line 992
          if (coltype == 2) {
#line 994
            j = 0;
            {
#line 994
            while (1) {
              while_continue___26: /* CIL Label */ ;
#line 994
              if (! (j < h0)) {
#line 994
                goto while_break___26;
              }
#line 996
              k = j;
#line 996
              if (interlaced) {
#line 996
                if (j > h2) {
#line 996
                  k = (j - h2) * 2 - 1;
                } else {
#line 996
                  if (j > h2 / 2) {
#line 996
                    tmp___63 = (j - h2 / 2) * 4 - 2;
                  } else {
#line 996
                    if (j > h2 / 4) {
#line 996
                      tmp___62 = (j - h2 / 4) * 8 - 4;
                    } else {
#line 996
                      tmp___62 = j * 8;
                    }
#line 996
                    tmp___63 = tmp___62;
                  }
#line 996
                  k = tmp___63;
                }
              }
#line 997
              src = buffer + j * w0;
#line 998
              dst___0 = frame0 + ((k + y0) * w + x0) * 3;
#line 999
              i = 0;
              {
#line 999
              while (1) {
                while_continue___27: /* CIL Label */ ;
#line 999
                if (! (i < w0)) {
#line 999
                  goto while_break___27;
                }
#line 1000
                if (! has_t) {
                  {
#line 1001
                  memcpy((void */* __restrict  */)dst___0, (void const   */* __restrict  */)(& pal_l[*src][0]),
                         (size_t )3);
                  }
                } else
#line 1000
                if ((int )*src != (int )t) {
                  {
#line 1001
                  memcpy((void */* __restrict  */)dst___0, (void const   */* __restrict  */)(& pal_l[*src][0]),
                         (size_t )3);
                  }
                }
#line 999
                i ++;
#line 999
                src ++;
#line 999
                dst___0 += 3;
              }
              while_break___27: /* CIL Label */ ;
              }
#line 994
              j ++;
            }
            while_break___26: /* CIL Label */ ;
            }
          } else {
#line 1006
            j = 0;
            {
#line 1006
            while (1) {
              while_continue___28: /* CIL Label */ ;
#line 1006
              if (! (j < h0)) {
#line 1006
                goto while_break___28;
              }
#line 1008
              k = j;
#line 1008
              if (interlaced) {
#line 1008
                if (j > h2) {
#line 1008
                  k = (j - h2) * 2 - 1;
                } else {
#line 1008
                  if (j > h2 / 2) {
#line 1008
                    tmp___65 = (j - h2 / 2) * 4 - 2;
                  } else {
#line 1008
                    if (j > h2 / 4) {
#line 1008
                      tmp___64 = (j - h2 / 4) * 8 - 4;
                    } else {
#line 1008
                      tmp___64 = j * 8;
                    }
#line 1008
                    tmp___65 = tmp___64;
                  }
#line 1008
                  k = tmp___65;
                }
              }
#line 1009
              src = buffer + j * w0;
#line 1010
              dst___0 = (frame0 + (k + y0) * w) + x0;
#line 1011
              if (shuffle) {
#line 1013
                i = 0;
                {
#line 1013
                while (1) {
                  while_continue___29: /* CIL Label */ ;
#line 1013
                  if (! (i < w0)) {
#line 1013
                    goto while_break___29;
                  }
#line 1014
                  if (! has_t) {
#line 1015
                    *dst___0 = (unsigned char )sh[*src];
                  } else
#line 1014
                  if ((int )*src != (int )t) {
#line 1015
                    *dst___0 = (unsigned char )sh[*src];
                  }
#line 1013
                  i ++;
#line 1013
                  src ++;
#line 1013
                  dst___0 ++;
                }
                while_break___29: /* CIL Label */ ;
                }
              } else {
#line 1019
                i = 0;
                {
#line 1019
                while (1) {
                  while_continue___30: /* CIL Label */ ;
#line 1019
                  if (! (i < w0)) {
#line 1019
                    goto while_break___30;
                  }
#line 1020
                  if (! has_t) {
#line 1021
                    *dst___0 = *src;
                  } else
#line 1020
                  if ((int )*src != (int )t) {
#line 1021
                    *dst___0 = *src;
                  }
#line 1019
                  i ++;
#line 1019
                  src ++;
#line 1019
                  dst___0 ++;
                }
                while_break___30: /* CIL Label */ ;
                }
              }
#line 1006
              j ++;
            }
            while_break___28: /* CIL Label */ ;
            }
          }
#line 1028
          if (n == 0) {
            {
#line 1030
            deflate_rect(frame0, x1, y1, w1, h1, bpp, rowbytes, row_buf, zbuf_size,
                         0);
#line 1031
            zsize = (int )op[0].zstream.total_out;
#line 1032
            memcpy((void */* __restrict  */)zbuf, (void const   */* __restrict  */)op[0].zbuf,
                   (size_t )zsize);
#line 1034
            deflateReset(& op[0].zstream);
#line 1035
            op[0].zstream.data_type = 0;
            }
          } else {
#line 1042
            j = 0;
            {
#line 1042
            while (1) {
              while_continue___31: /* CIL Label */ ;
#line 1042
              if (! (j < 6)) {
#line 1042
                goto while_break___31;
              }
#line 1043
              op[j].valid = 0;
#line 1042
              j ++;
            }
            while_break___31: /* CIL Label */ ;
            }
            {
#line 1046
            try_over = get_rect(w, h, frame1, frame0, temp, & x2, & y2, & w2, & h2,
                                bpp, has_tcolor, tcolor);
#line 1047
            deflate_rect(frame0, x2, y2, w2, h2, bpp, rowbytes, row_buf, zbuf_size,
                         0);
            }
#line 1048
            if (try_over) {
              {
#line 1049
              deflate_rect(temp, x2, y2, w2, h2, bpp, rowbytes, row_buf, zbuf_size,
                           1);
              }
            }
#line 1052
            if (has_tcolor) {
              {
#line 1054
              memcpy((void */* __restrict  */)temp, (void const   */* __restrict  */)frame1,
                     (size_t )imagesize);
              }
#line 1055
              if (coltype == 2) {
#line 1057
                j = 0;
                {
#line 1057
                while (1) {
                  while_continue___32: /* CIL Label */ ;
#line 1057
                  if (! (j < h1)) {
#line 1057
                    goto while_break___32;
                  }
#line 1059
                  dst___0 = temp + ((j + y1) * w + x1) * 3;
#line 1060
                  k = 0;
                  {
#line 1060
                  while (1) {
                    while_continue___33: /* CIL Label */ ;
#line 1060
                    if (! (k < w1)) {
#line 1060
                      goto while_break___33;
                    }
#line 1062
                    tmp___66 = dst___0;
#line 1062
                    dst___0 ++;
#line 1062
                    *tmp___66 = (unsigned char )tr;
#line 1063
                    tmp___67 = dst___0;
#line 1063
                    dst___0 ++;
#line 1063
                    *tmp___67 = (unsigned char )tg;
#line 1064
                    tmp___68 = dst___0;
#line 1064
                    dst___0 ++;
#line 1064
                    *tmp___68 = (unsigned char )tb;
#line 1060
                    k ++;
                  }
                  while_break___33: /* CIL Label */ ;
                  }
#line 1057
                  j ++;
                }
                while_break___32: /* CIL Label */ ;
                }
              } else {
#line 1069
                j = 0;
                {
#line 1069
                while (1) {
                  while_continue___34: /* CIL Label */ ;
#line 1069
                  if (! (j < h1)) {
#line 1069
                    goto while_break___34;
                  }
                  {
#line 1070
                  memset((void *)((temp + (j + y1) * w) + x1), tcolor, (size_t )w1);
#line 1069
                  j ++;
                  }
                }
                while_break___34: /* CIL Label */ ;
                }
              }
              {
#line 1072
              try_over = get_rect(w, h, temp, frame0, temp, & x2, & y2, & w2, & h2,
                                  bpp, has_tcolor, tcolor);
#line 1073
              deflate_rect(frame0, x2, y2, w2, h2, bpp, rowbytes, row_buf, zbuf_size,
                           2);
              }
#line 1074
              if (try_over) {
                {
#line 1075
                deflate_rect(temp, x2, y2, w2, h2, bpp, rowbytes, row_buf, zbuf_size,
                             3);
                }
              }
            }
#line 1079
            if (n > 1) {
              {
#line 1081
              try_over = get_rect(w, h, frame2, frame0, temp, & x2, & y2, & w2, & h2,
                                  bpp, has_tcolor, tcolor);
#line 1082
              deflate_rect(frame0, x2, y2, w2, h2, bpp, rowbytes, row_buf, zbuf_size,
                           4);
              }
#line 1083
              if (try_over) {
                {
#line 1084
                deflate_rect(temp, x2, y2, w2, h2, bpp, rowbytes, row_buf, zbuf_size,
                             5);
                }
              }
            }
#line 1087
            op_min = (unsigned int )op[0].zstream.total_out;
#line 1088
            op_best = 0U;
#line 1089
            j = 1;
            {
#line 1089
            while (1) {
              while_continue___35: /* CIL Label */ ;
#line 1089
              if (! (j < 6)) {
#line 1089
                goto while_break___35;
              }
#line 1091
              if (op[j].valid) {
#line 1093
                if (op[j].zstream.total_out < (uLong )op_min) {
#line 1095
                  op_min = (unsigned int )op[j].zstream.total_out;
#line 1096
                  op_best = (unsigned int )j;
                }
              }
#line 1089
              j ++;
            }
            while_break___35: /* CIL Label */ ;
            }
            {
#line 1101
            dop = (unsigned char )(op_best >> 1);
#line 1103
            tmp___69 = next_seq_num;
#line 1103
            next_seq_num ++;
#line 1103
            fctl.mSeq = __bswap_32(tmp___69);
#line 1104
            fctl.mWidth = __bswap_32((unsigned int )w1);
#line 1105
            fctl.mHeight = __bswap_32((unsigned int )h1);
#line 1106
            fctl.mXOffset = __bswap_32((unsigned int )x1);
#line 1107
            fctl.mYOffset = __bswap_32((unsigned int )y1);
#line 1108
            __x = *(delays + (n - 1));
#line 1108
            __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1108
            fctl.mDelayNum = __v;
#line 1109
            __x___0 = (unsigned short)100;
#line 1109
            __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 1109
            fctl.mDelayDen = __v___0;
#line 1110
            fctl.mDisposeOp = dop;
#line 1111
            fctl.mBlendOp = bop;
#line 1112
            write_chunk(f2, "fcTL", (unsigned char *)(& fctl), 26U);
#line 1114
            write_IDATs(f2, n - 1, zbuf, (unsigned int )zsize, (unsigned int )idat_size);
            }
#line 1117
            if ((int )dop == 1) {
#line 1119
              if (coltype == 2) {
#line 1121
                j = 0;
                {
#line 1121
                while (1) {
                  while_continue___36: /* CIL Label */ ;
#line 1121
                  if (! (j < h1)) {
#line 1121
                    goto while_break___36;
                  }
#line 1123
                  dst___0 = frame1 + ((j + y1) * w + x1) * 3;
#line 1124
                  k = 0;
                  {
#line 1124
                  while (1) {
                    while_continue___37: /* CIL Label */ ;
#line 1124
                    if (! (k < w1)) {
#line 1124
                      goto while_break___37;
                    }
#line 1126
                    tmp___70 = dst___0;
#line 1126
                    dst___0 ++;
#line 1126
                    *tmp___70 = (unsigned char )tr;
#line 1127
                    tmp___71 = dst___0;
#line 1127
                    dst___0 ++;
#line 1127
                    *tmp___71 = (unsigned char )tg;
#line 1128
                    tmp___72 = dst___0;
#line 1128
                    dst___0 ++;
#line 1128
                    *tmp___72 = (unsigned char )tb;
#line 1124
                    k ++;
                  }
                  while_break___37: /* CIL Label */ ;
                  }
#line 1121
                  j ++;
                }
                while_break___36: /* CIL Label */ ;
                }
              } else {
#line 1133
                j = 0;
                {
#line 1133
                while (1) {
                  while_continue___38: /* CIL Label */ ;
#line 1133
                  if (! (j < h1)) {
#line 1133
                    goto while_break___38;
                  }
                  {
#line 1134
                  memset((void *)((frame1 + (j + y1) * w) + x1), tcolor, (size_t )w1);
#line 1133
                  j ++;
                  }
                }
                while_break___38: /* CIL Label */ ;
                }
              }
            } else
#line 1137
            if ((int )dop == 2) {
#line 1139
              j = 0;
              {
#line 1139
              while (1) {
                while_continue___39: /* CIL Label */ ;
#line 1139
                if (! (j < h1)) {
#line 1139
                  goto while_break___39;
                }
                {
#line 1140
                memcpy((void */* __restrict  */)(frame1 + ((j + y1) * w + x1) * bpp),
                       (void const   */* __restrict  */)(frame2 + ((j + y1) * w + x1) * bpp),
                       (size_t )(w1 * bpp));
#line 1139
                j ++;
                }
              }
              while_break___39: /* CIL Label */ ;
              }
            }
            {
#line 1144
            x1 = op[op_best].x;
#line 1145
            y1 = op[op_best].y;
#line 1146
            w1 = op[op_best].w;
#line 1147
            h1 = op[op_best].h;
#line 1148
            bop = (unsigned char )(op_best & 1U);
#line 1150
            zsize = (int )op[op_best].zstream.total_out;
#line 1151
            memcpy((void */* __restrict  */)zbuf, (void const   */* __restrict  */)op[op_best].zbuf,
                   (size_t )zsize);
#line 1153
            j = 0;
            }
            {
#line 1153
            while (1) {
              while_continue___40: /* CIL Label */ ;
#line 1153
              if (! (j < 6)) {
#line 1153
                goto while_break___40;
              }
              {
#line 1155
              deflateReset(& op[j].zstream);
#line 1156
              op[j].zstream.data_type = 0;
#line 1153
              j ++;
              }
            }
            while_break___40: /* CIL Label */ ;
            }
            {
#line 1158
            memcpy((void */* __restrict  */)frame2, (void const   */* __restrict  */)frame1,
                   (size_t )imagesize);
            }
          }
          {
#line 1160
          memcpy((void */* __restrict  */)frame1, (void const   */* __restrict  */)frame0,
                 (size_t )imagesize);
          }
#line 1164
          if (n < frames - 1) {
#line 1166
            if ((int )dispose_op == 3) {
              {
#line 1167
              memcpy((void */* __restrict  */)frame0, (void const   */* __restrict  */)rest,
                     (size_t )imagesize);
              }
            } else
#line 1169
            if ((int )dispose_op == 2) {
#line 1171
              if (coltype == 2) {
#line 1173
                j = 0;
                {
#line 1173
                while (1) {
                  while_continue___41: /* CIL Label */ ;
#line 1173
                  if (! (j < h0)) {
#line 1173
                    goto while_break___41;
                  }
#line 1175
                  dst___0 = frame0 + ((j + y0) * w + x0) * 3;
#line 1176
                  k = 0;
                  {
#line 1176
                  while (1) {
                    while_continue___42: /* CIL Label */ ;
#line 1176
                    if (! (k < w0)) {
#line 1176
                      goto while_break___42;
                    }
#line 1178
                    tmp___73 = dst___0;
#line 1178
                    dst___0 ++;
#line 1178
                    *tmp___73 = (unsigned char )tr;
#line 1179
                    tmp___74 = dst___0;
#line 1179
                    dst___0 ++;
#line 1179
                    *tmp___74 = (unsigned char )tg;
#line 1180
                    tmp___75 = dst___0;
#line 1180
                    dst___0 ++;
#line 1180
                    *tmp___75 = (unsigned char )tb;
#line 1176
                    k ++;
                  }
                  while_break___42: /* CIL Label */ ;
                  }
#line 1173
                  j ++;
                }
                while_break___41: /* CIL Label */ ;
                }
              } else {
#line 1185
                j = 0;
                {
#line 1185
                while (1) {
                  while_continue___43: /* CIL Label */ ;
#line 1185
                  if (! (j < h0)) {
#line 1185
                    goto while_break___43;
                  }
                  {
#line 1186
                  memset((void *)((frame0 + (j + y0) * w) + x0), tcolor, (size_t )w0);
#line 1185
                  j ++;
                  }
                }
                while_break___43: /* CIL Label */ ;
                }
              }
            }
          }
#line 1191
          n ++;
#line 1192
          dispose_op = (unsigned char)0;
        } else {
#line 1195
          goto while_break___21;
        }
      }
      while_break___21: /* CIL Label */ ;
      }
#line 1198
      if (frames > 1) {
        {
#line 1200
        tmp___77 = next_seq_num;
#line 1200
        next_seq_num ++;
#line 1200
        fctl.mSeq = __bswap_32(tmp___77);
#line 1201
        fctl.mWidth = __bswap_32((unsigned int )w1);
#line 1202
        fctl.mHeight = __bswap_32((unsigned int )h1);
#line 1203
        fctl.mXOffset = __bswap_32((unsigned int )x1);
#line 1204
        fctl.mYOffset = __bswap_32((unsigned int )y1);
#line 1205
        __x___1 = *(delays + (frames - 1));
#line 1205
        __asm__  ("rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 1205
        fctl.mDelayNum = __v___1;
#line 1206
        __x___2 = (unsigned short)100;
#line 1206
        __asm__  ("rorw $8, %w0": "=r" (__v___2): "0" (__x___2): "cc");
#line 1206
        fctl.mDelayDen = __v___2;
#line 1207
        fctl.mDisposeOp = (unsigned char)0;
#line 1208
        fctl.mBlendOp = bop;
#line 1209
        write_chunk(f2, "fcTL", (unsigned char *)(& fctl), 26U);
        }
      }
      {
#line 1212
      write_IDATs(f2, frames - 1, zbuf, (unsigned int )zsize, (unsigned int )idat_size);
#line 1214
      free((void *)row_buf);
#line 1215
      free((void *)zbuf);
#line 1217
      j = 0;
      }
      {
#line 1217
      while (1) {
        while_continue___44: /* CIL Label */ ;
#line 1217
        if (! (j < 6)) {
#line 1217
          goto while_break___44;
        }
        {
#line 1219
        deflateEnd(& op[j].zstream);
#line 1220
        free((void *)op[j].zbuf);
#line 1217
        j ++;
        }
      }
      while_break___44: /* CIL Label */ ;
      }
      {
#line 1223
      write_chunk(f2, "tEXt", png_Software, 24U);
#line 1224
      write_chunk(f2, "IEND", (unsigned char *)0, 0U);
#line 1225
      fclose(f2);
#line 1226
      printf((char const   */* __restrict  */)"%d frames.\n", n);
      }
    } else {
      {
#line 1229
      printf((char const   */* __restrict  */)"Error: can\'t open the file \'%s\'\n",
             szOut);
      }
    }
    {
#line 1233
    free((void *)frame0);
#line 1234
    free((void *)frame1);
#line 1235
    free((void *)frame2);
#line 1236
    free((void *)rest);
#line 1237
    free((void *)temp);
#line 1238
    free((void *)delays);
#line 1239
    free((void *)buffer);
#line 1241
    fclose(f1);
    }
  } else {
    {
#line 1245
    printf((char const   */* __restrict  */)"Error: can\'t open the file \'%s\'\n",
           szIn);
    }
#line 1246
    return (1);
  }
#line 1249
  return (0);
}
}
