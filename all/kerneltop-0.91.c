/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 112 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
struct text_symbol {
   unsigned long textadr ;
   char textname[1] ;
};
#line 118 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
struct freq_table {
   int ticks ;
   int textindex ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 538
extern int getchar(void) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 47 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vidstr(int row , int col , char *str ) 
{ 


  {
  {
#line 48
  printf((char const   */* __restrict  */)"%c[%d;%dH%s", '\033', row, col, str);
  }
#line 48
  return;
}
}
#line 50 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_putnow(void) 
{ 


  {
  {
#line 51
  fflush(stdout);
  }
#line 51
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_attr(int attr ) 
{ 


  {
  {
#line 54
  printf((char const   */* __restrict  */)"%c[%dm", '\033', attr);
  }
#line 54
  return;
}
}
#line 56 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_palette(int color , int red , int green , int blue ) 
{ 


  {
  {
#line 57
  printf((char const   */* __restrict  */)"%c]P%1.1x%2.2x%2.2x%2.2x", '\033', color,
         red, green, blue);
  }
#line 57
  return;
}
}
#line 59 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_palette_reset(void) 
{ 


  {
  {
#line 60
  printf((char const   */* __restrict  */)"%c]R", '\033');
  }
#line 60
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_clear_all(void) 
{ 


  {
  {
#line 63
  printf((char const   */* __restrict  */)"%c[2J", '\033');
  }
#line 63
  return;
}
}
#line 65 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_clear_curtoend(void) 
{ 


  {
  {
#line 66
  printf((char const   */* __restrict  */)"%c[J", '\033');
  }
#line 66
  return;
}
}
#line 68 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_clear_starttocur(void) 
{ 


  {
  {
#line 69
  printf((char const   */* __restrict  */)"%c[1J", '\033');
  }
#line 69
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_clear_line(void) 
{ 


  {
  {
#line 72
  printf((char const   */* __restrict  */)"%c[2K", '\033');
  }
#line 72
  return;
}
}
#line 74 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_clear_curtoeol(void) 
{ 


  {
  {
#line 75
  printf((char const   */* __restrict  */)"%c[K", '\033');
  }
#line 75
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_clear_soltocur(void) 
{ 


  {
  {
#line 78
  printf((char const   */* __restrict  */)"%c[1K", '\033');
  }
#line 78
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_curpos(int row , int col ) 
{ 


  {
  {
#line 81
  printf((char const   */* __restrict  */)"%c[%d;%df", '\033', row, col);
  }
#line 81
  return;
}
}
#line 83 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_insert_spaces(int count ) 
{ 


  {
  {
#line 84
  printf((char const   */* __restrict  */)"%c[%d@", '\033', count);
  }
#line 84
  return;
}
}
#line 86 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_insert_lines(int count ) 
{ 


  {
  {
#line 87
  printf((char const   */* __restrict  */)"%c[%dL", '\033', count);
  }
#line 87
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_delete_lines(int count ) 
{ 


  {
  {
#line 90
  printf((char const   */* __restrict  */)"%c[%dM", '\033', count);
  }
#line 90
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_delete_chars(int count ) 
{ 


  {
  {
#line 93
  printf((char const   */* __restrict  */)"%c[%dP", '\033', count);
  }
#line 93
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/kerneltop-0.91/vidsupport.h"
__inline void vid_erase_chars(int count ) 
{ 


  {
  {
#line 96
  printf((char const   */* __restrict  */)"%c[%dX", '\033', count);
  }
#line 96
  return;
}
}
#line 123 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static char *prgname  ;
#line 126 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static char defaultmap[17]  = 
#line 126
  {      (char )'/',      (char )'b',      (char )'o',      (char )'o', 
        (char )'t',      (char )'/',      (char )'S',      (char )'y', 
        (char )'s',      (char )'t',      (char )'e',      (char )'m', 
        (char )'.',      (char )'m',      (char )'a',      (char )'p', 
        (char )'\000'};
#line 127 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static char defaultpro[14]  = 
#line 127
  {      (char )'/',      (char )'p',      (char )'r',      (char )'o', 
        (char )'c',      (char )'/',      (char )'p',      (char )'r', 
        (char )'o',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'\000'};
#line 128 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static char optstring[14]  = 
#line 128
  {      (char )'m',      (char )':',      (char )'p',      (char )':', 
        (char )'r',      (char )'s',      (char )':',      (char )'l', 
        (char )':',      (char )'t',      (char )':',      (char )'u', 
        (char )'V',      (char )'\000'};
#line 131 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int console_lines  =    20;
#line 132 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int prof_lines  =    17;
#line 133 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int sleep_seconds  =    1;
#line 134 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int threshold  =    1;
#line 135 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int optUnsorted  =    0;
#line 137 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
char uname_all[512]  ;
#line 137 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
char uname_release[512]  ;
#line 139 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int popenMap  ;
#line 140 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
FILE *mapf  ;
#line 141 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int *freqs  ;
#line 142 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
struct freq_table freqtable[100]  ;
#line 143 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
struct text_symbol *textsymroot  ;
#line 144 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
struct text_symbol *textsym  ;
#line 145 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
struct text_symbol *textsymlast  ;
#line 146 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
unsigned long adr0  =    0UL;
#line 147 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
unsigned long adrz  =    0UL;
#line 148 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int max_fn_len  =    0;
#line 149 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int text_lines  =    0;
#line 150 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int text_entry_size  ;
#line 151 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int lookup_last  ;
#line 154 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
__inline static long round_up(long n , long size ) 
{ 


  {
#line 155
  return (((n + size) - 1L) & ~ (size - 1L));
}
}
#line 180 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static void usage(void) 
{ 


  {
  {
#line 182
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: usage: \"%s [options]\n\t -m <mapfile>  (default = \"%s\"[-`uname -r`])\n\t -p <pro-file> (default = \"%s\")\n\t -l <lines>    set number of lines to print (def. = %d; max = %d)\n\t -s <seconds>  set sleep time in seconds (def. = 1)\n\t -t <ticks>    set threshold of number of ticks to print (def. = 1)\n\t                 a function must have this many ticks to be printed\n\t -u            print unsorted (skip the sort)\n\t -V            print version and exit\n",
          prgname, prgname, defaultmap, defaultpro, 20, 100);
#line 197
  exit(1);
  }
}
}
#line 200 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static void *xmalloc(size_t size ) 
{ 
  void *t ;

  {
#line 204
  if (size == 0UL) {
#line 205
    return ((void *)0);
  }
  {
#line 207
  t = malloc(size);
  }
#line 208
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    {
#line 209
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[out of memory]");
#line 210
    exit(1);
    }
  }
#line 213
  return (t);
}
}
#line 216 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static FILE *myopen(char const   *name , char *mode , int *flag ) 
{ 
  int len ;
  size_t tmp ;
  FILE *res ;
  char *cmdline ;
  void *tmp___0 ;
  int tmp___1 ;
  FILE *tmp___2 ;

  {
  {
#line 218
  tmp = strlen(name);
#line 218
  len = (int )tmp;
#line 220
  tmp___1 = strcmp((name + len) - 3, ".gz");
  }
#line 220
  if (! tmp___1) {
    {
#line 222
    tmp___0 = xmalloc((size_t )(len + 6));
#line 222
    cmdline = (char *)tmp___0;
#line 223
    sprintf((char */* __restrict  */)cmdline, (char const   */* __restrict  */)"zcat %s",
            name);
#line 224
    res = popen((char const   *)cmdline, (char const   *)mode);
#line 225
    free((void *)cmdline);
#line 226
    *flag = 1;
    }
#line 227
    return (res);
  }
  {
#line 229
  *flag = 0;
#line 230
  tmp___2 = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)mode);
  }
#line 230
  return (tmp___2);
}
}
#line 241 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static char line[8192]  ;
#line 239 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
char *getstr(void) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 242
  i = 0;
#line 245
  fflush(stdout);
#line 246
  fflush(stdin);
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 249
    read(0, (void *)(& line[i]), (size_t )1);
#line 248
    tmp = i;
#line 248
    i ++;
    }
#line 248
    if ((int )line[tmp] != 10) {
#line 248
      if (! ((unsigned long )i < sizeof(line))) {
#line 248
        goto while_break;
      }
    } else {
#line 248
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  i --;
#line 251
  line[i] = (char)0;
#line 253
  return (line);
}
}
#line 261 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int getint(void) 
{ 
  char *line___0 ;
  int i ;
  int r ;
  unsigned short const   **tmp ;

  {
  {
#line 267
  line___0 = getstr();
#line 269
  i = 0;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! *(line___0 + i)) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp = __ctype_b_loc();
    }
#line 270
    if (! ((int const   )*(*tmp + (int )*(line___0 + i)) & 2048)) {
#line 270
      if ((int )*(line___0 + i) != 45) {
        {
#line 271
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 271
          vid_curpos(1, 1);
#line 271
          vid_clear_curtoeol();
#line 271
          printf((char const   */* __restrict  */)"That\'s not a number!");
#line 271
          vid_putnow();
#line 271
          sleep(2U);
          }
#line 271
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 272
        return (-42);
      }
    }
#line 269
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  if (! *(line___0 + 0)) {
#line 278
    return (-42);
  }
  {
#line 280
  sscanf((char const   */* __restrict  */)line___0, (char const   */* __restrict  */)"%d",
         & r);
  }
#line 281
  return (r);
}
}
#line 284 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static void get_unames(char *uname_all___0 , char *uname_release___0 ) 
{ 
  FILE *pin ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 288
  pin = popen("uname -a", "r");
  }
#line 289
  if ((unsigned long )pin == (unsigned long )((void *)0)) {
    {
#line 290
    tmp = __errno_location();
#line 290
    tmp___0 = strerror(*tmp);
#line 290
    tmp___1 = __errno_location();
#line 290
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t exec \'uname\': error (%d) = %s\n",
            *tmp___1, tmp___0);
#line 292
    exit(1);
    }
  }
  {
#line 294
  memset((void *)uname_all___0, 0, sizeof(*uname_all___0));
#line 295
  fread((void */* __restrict  */)uname_all___0, (size_t )511, (size_t )1, (FILE */* __restrict  */)pin);
#line 296
  pclose(pin);
#line 298
  pin = popen("uname -r", "r");
  }
#line 299
  if ((unsigned long )pin == (unsigned long )((void *)0)) {
    {
#line 300
    tmp___2 = __errno_location();
#line 300
    tmp___3 = strerror(*tmp___2);
#line 300
    tmp___4 = __errno_location();
#line 300
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t exec \'uname\': error (%d) = %s\n",
            *tmp___4, tmp___3);
#line 302
    exit(1);
    }
  }
  {
#line 304
  memset((void *)uname_release___0, 0, sizeof(*uname_release___0));
#line 305
  fread((void */* __restrict  */)uname_release___0, (size_t )511, (size_t )1, (FILE */* __restrict  */)pin);
#line 306
  pclose(pin);
#line 307
  tmp___6 = strlen((char const   *)uname_release___0);
  }
#line 307
  if ((int )*(uname_release___0 + (tmp___6 - 1UL)) == 10) {
    {
#line 308
    tmp___5 = strlen((char const   *)uname_release___0);
#line 308
    *(uname_release___0 + (tmp___5 - 1UL)) = (char )'\000';
    }
  }
#line 309
  return;
}
}
#line 317 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static void heading(void) 
{ 


  {
  {
#line 326
  vid_clear_all();
#line 328
  vid_curpos(1, 1);
#line 329
  printf((char const   */* __restrict  */)"%s", uname_all);
  }
#line 353
  return;
}
}
#line 361 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
void helper(void) 
{ 


  {
  {
#line 363
  vid_clear_all();
#line 365
  printf((char const   */* __restrict  */)"%s Version %s\n", prgname, "0.9");
#line 366
  printf((char const   */* __restrict  */)"h or ? : this help text\n");
#line 367
  printf((char const   */* __restrict  */)"l #    : set number of console lines to print: %d\n",
         console_lines);
#line 369
  printf((char const   */* __restrict  */)"s #    : set number of seconds between updates: %d\n",
         sleep_seconds);
#line 371
  printf((char const   */* __restrict  */)"t #    : set threshold for number of ticks required to be printed: %d\n",
         threshold);
#line 373
  printf((char const   */* __restrict  */)"q      : quit\n");
#line 374
  printf((char const   */* __restrict  */)"u      : print profile (un)sorted: %d\n",
         optUnsorted);
#line 376
  printf((char const   */* __restrict  */)"\nPress any key to continue");
#line 377
  vid_putnow();
#line 381
  getchar();
#line 382
  vid_clear_all();
#line 383
  heading();
  }
#line 384
  return;
}
}
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 407 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int keypressed(int keyboard_fd ) 
{ 
  char one_key ;
  struct termios termio_backup ;
  struct termios termio_new ;
  ssize_t actual ;
  unsigned int tmp ;

  {
  {
#line 418
  tcgetattr(keyboard_fd, & termio_backup);
#line 419
  memcpy((void */* __restrict  */)(& termio_new), (void const   */* __restrict  */)(& termio_backup),
         sizeof(struct termios ));
#line 423
  termio_new.c_lflag &= 4294967284U;
#line 424
  termio_new.c_iflag = (tcflag_t )0;
#line 427
  termio_new.c_cc[6] = (cc_t )0;
#line 428
  termio_new.c_cc[5] = (cc_t )0;
#line 429
  tcsetattr(keyboard_fd, 0, (struct termios  const  *)(& termio_new));
#line 434
  actual = read(keyboard_fd, (void *)(& one_key), (size_t )1);
#line 444
  tcsetattr(keyboard_fd, 0, (struct termios  const  *)(& termio_backup));
  }
#line 452
  if (actual) {
#line 452
    tmp = (unsigned int )one_key;
  } else {
#line 452
    tmp = 0U;
  }
#line 452
  return ((int )tmp);
}
}
#line 465 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int do_key(char c ) 
{ 
  int numinput ;

  {
#line 469
  if ((int )c == 113) {
#line 470
    return (-1);
  }
#line 471
  if ((int )c == 32) {
#line 472
    return (0);
  }
#line 473
  if ((int )c == 104) {
    {
#line 474
    helper();
    }
#line 475
    return (0);
  } else
#line 473
  if ((int )c == 63) {
    {
#line 474
    helper();
    }
#line 475
    return (0);
  }
  {
#line 489
  if ((int )c == 108) {
#line 489
    goto case_108;
  }
#line 499
  if ((int )c == 115) {
#line 499
    goto case_115;
  }
#line 507
  if ((int )c == 116) {
#line 507
    goto case_116;
  }
#line 515
  if ((int )c == 117) {
#line 515
    goto case_117;
  }
#line 488
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 490
  printf((char const   */* __restrict  */)"Number of console lines to print: ");
#line 491
  numinput = getint();
  }
#line 492
  if (numinput != -42) {
#line 493
    if (numinput > 0) {
#line 493
      if (numinput <= 100) {
#line 494
        console_lines = numinput;
#line 495
        prof_lines = console_lines - 3;
      }
    }
  }
#line 497
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 500
  printf((char const   */* __restrict  */)"Seconds between updates: ");
#line 501
  numinput = getint();
  }
#line 502
  if (numinput != -42) {
#line 503
    if (numinput > 0) {
#line 504
      sleep_seconds = numinput;
    }
  }
#line 505
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 508
  printf((char const   */* __restrict  */)"Threshold of ticks to display (0 for unlimited): ");
#line 509
  numinput = getint();
  }
#line 510
  if (numinput != -42) {
#line 511
    if (numinput > 0) {
#line 512
      threshold = numinput;
    }
  }
#line 513
  goto switch_break;
  case_117: /* CIL Label */ 
#line 516
  optUnsorted = ! optUnsorted;
#line 517
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 525
  vid_curpos(1, 0);
#line 526
  vid_clear_line();
#line 527
  printf((char const   */* __restrict  */)"%s Version %s\n", prgname, "0.9");
  }
#line 528
  return (0);
}
}
#line 536 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static unsigned long profile_read(char const   *proFile , unsigned int **buf ) 
{ 
  int proFd ;
  unsigned long len ;
  int *tmp ;
  char *tmp___0 ;
  __off_t tmp___1 ;
  __off_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  unsigned int *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  ssize_t tmp___9 ;

  {
  {
#line 544
  proFd = open(proFile, 0);
  }
#line 544
  if (proFd < 0) {
    {
#line 547
    tmp = __errno_location();
#line 547
    tmp___0 = strerror(*tmp);
#line 547
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            prgname, proFile, tmp___0);
#line 549
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enable kernel profiling [profile=N]\n");
#line 550
    exit(1);
    }
  } else {
    {
#line 544
    tmp___1 = lseek(proFd, (__off_t )0, 2);
#line 544
    len = (unsigned long )tmp___1;
    }
#line 544
    if ((int )len < 0) {
      {
#line 547
      tmp = __errno_location();
#line 547
      tmp___0 = strerror(*tmp);
#line 547
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              prgname, proFile, tmp___0);
#line 549
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enable kernel profiling [profile=N]\n");
#line 550
      exit(1);
      }
    } else {
      {
#line 544
      tmp___2 = lseek(proFd, (__off_t )0, 0);
      }
#line 544
      if (tmp___2 < 0L) {
        {
#line 547
        tmp = __errno_location();
#line 547
        tmp___0 = strerror(*tmp);
#line 547
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
                prgname, proFile, tmp___0);
#line 549
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enable kernel profiling [profile=N]\n");
#line 550
        exit(1);
        }
      }
    }
  }
  {
#line 553
  tmp___6 = malloc(len);
#line 553
  tmp___5 = (unsigned int *)tmp___6;
#line 553
  *buf = tmp___5;
  }
#line 553
  if (! tmp___5) {
    {
#line 554
    tmp___3 = __errno_location();
#line 554
    tmp___4 = strerror(*tmp___3);
#line 554
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: malloc(%ld): %s\n",
            prgname, len, tmp___4);
#line 556
    exit(1);
    }
  }
  {
#line 559
  tmp___9 = read(proFd, (void *)*buf, len);
  }
#line 559
  if ((unsigned long )tmp___9 != len) {
    {
#line 560
    tmp___7 = __errno_location();
#line 560
    tmp___8 = strerror(*tmp___7);
#line 560
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            prgname, proFile, tmp___8);
#line 562
    exit(1);
    }
  }
  {
#line 564
  close(proFd);
  }
#line 565
  return (len);
}
}
#line 575 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static void mapfile_read(char const   *mapFile , int opt_mapfile ) 
{ 
  int maplineno ;
  char mapline[1024] ;
  unsigned long seek_adr ;
  unsigned long fn_adr ;
  unsigned long prev_adr ;
  char fn_name[1024] ;
  char mode[8] ;
  int fn_len ;
  char begin_text[7] ;
  char end_text[7] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 577
  maplineno = 0;
#line 579
  seek_adr = 0UL;
#line 580
  prev_adr = 0UL;
#line 584
  begin_text[0] = (char )'_';
#line 584
  begin_text[1] = (char )'s';
#line 584
  begin_text[2] = (char )'t';
#line 584
  begin_text[3] = (char )'e';
#line 584
  begin_text[4] = (char )'x';
#line 584
  begin_text[5] = (char )'t';
#line 584
  begin_text[6] = (char )'\000';
#line 585
  end_text[0] = (char )'_';
#line 585
  end_text[1] = (char )'e';
#line 585
  end_text[2] = (char )'t';
#line 585
  end_text[3] = (char )'e';
#line 585
  end_text[4] = (char )'x';
#line 585
  end_text[5] = (char )'t';
#line 585
  end_text[6] = (char )'\000';
#line 588
  mapf = myopen(mapFile, (char *)"r", & popenMap);
  }
#line 588
  if (mapf) {
#line 589
    goto open_ok;
  }
#line 590
  if (opt_mapfile) {
#line 591
    goto open_err;
  }
  {
#line 599
  strcpy((char */* __restrict  */)(fn_name), (char const   */* __restrict  */)(defaultmap));
#line 600
  strcat((char */* __restrict  */)(fn_name), (char const   */* __restrict  */)"-");
#line 601
  strcat((char */* __restrict  */)(fn_name), (char const   */* __restrict  */)(uname_release));
#line 602
  mapf = myopen((char const   *)(fn_name), (char *)"r", & popenMap);
  }
#line 602
  if (mapf) {
#line 603
    goto open_ok;
  }
  {
#line 605
  mapf = myopen((char const   *)(defaultmap), (char *)"r", & popenMap);
  }
#line 605
  if (mapf) {
#line 606
    goto open_ok;
  }
  {
#line 608
  strcpy((char */* __restrict  */)(fn_name), (char const   */* __restrict  */)"/lib/modules/");
#line 609
  strcat((char */* __restrict  */)(fn_name), (char const   */* __restrict  */)(uname_release));
#line 610
  strcat((char */* __restrict  */)(fn_name), (char const   */* __restrict  */)"/System.map");
#line 611
  mapf = myopen((char const   *)(fn_name), (char *)"r", & popenMap);
  }
#line 611
  if (mapf) {
#line 612
    goto open_ok;
  }
  open_err: 
  {
#line 615
  tmp = __errno_location();
#line 615
  tmp___0 = strerror(*tmp);
#line 615
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
          prgname, mapFile, tmp___0);
#line 617
  exit(1);
  }
  open_ok: 
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 621
    tmp___4 = fgets((char */* __restrict  */)(mapline), 1024, (FILE */* __restrict  */)mapf);
    }
#line 621
    if (! tmp___4) {
#line 621
      goto while_break;
    }
    {
#line 622
    maplineno ++;
#line 623
    tmp___1 = sscanf((char const   */* __restrict  */)(mapline), (char const   */* __restrict  */)"%lx %s %s",
                     & fn_adr, mode, fn_name);
    }
#line 623
    if (tmp___1 != 3) {
      {
#line 624
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s(%i): wrong map line\n",
              prgname, mapFile, maplineno);
#line 626
      exit(1);
      }
    }
#line 629
    if ((int )mode[0] == 84) {
      {
#line 629
      tmp___3 = strcmp((char const   *)(fn_name), (char const   *)(begin_text));
      }
#line 629
      if (! tmp___3) {
        {
#line 631
        adr0 = fn_adr;
#line 632
        tmp___2 = ftell(mapf);
#line 632
        seek_adr = (unsigned long )tmp___2;
        }
#line 633
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  if (! adr0) {
    {
#line 638
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t find \'%s\' in %s\n",
            prgname, begin_text, mapFile);
#line 640
    exit(1);
    }
  }
  {
#line 646
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 646
    tmp___8 = fgets((char */* __restrict  */)(mapline), 1024, (FILE */* __restrict  */)mapf);
    }
#line 646
    if (! tmp___8) {
#line 646
      goto while_break___0;
    }
    {
#line 647
    maplineno ++;
#line 648
    tmp___5 = sscanf((char const   */* __restrict  */)(mapline), (char const   */* __restrict  */)"%lx %s %s",
                     & fn_adr, mode, fn_name);
    }
#line 648
    if (tmp___5 != 3) {
      {
#line 649
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s(%i): wrong map line\n",
              prgname, mapFile, maplineno);
#line 651
      exit(1);
      }
    }
#line 654
    if ((int )mode[0] == 65) {
      {
#line 654
      tmp___6 = strcmp((char const   *)(fn_name), (char const   *)(end_text));
      }
#line 654
      if (! tmp___6) {
#line 656
        adrz = fn_adr;
#line 657
        text_lines ++;
#line 658
        goto while_break___0;
      }
    }
#line 660
    if (fn_adr < prev_adr) {
      {
#line 661
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s(%i): descending address order in map line\n",
              prgname, mapFile, maplineno);
#line 663
      exit(1);
      }
    }
#line 665
    if ((int )mode[0] != 84) {
#line 665
      if ((int )mode[0] != 116) {
#line 666
        goto while_continue___0;
      }
    }
    {
#line 667
    text_lines ++;
#line 668
    tmp___7 = strlen((char const   *)(fn_name));
#line 668
    fn_len = (int )tmp___7;
    }
#line 669
    if (fn_len > max_fn_len) {
#line 670
      max_fn_len = fn_len;
    }
#line 671
    prev_adr = fn_adr;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 673
  text_lines ++;
#line 676
  tmp___9 = round_up((long )max_fn_len, 4L);
#line 676
  max_fn_len = (int )tmp___9;
#line 677
  text_entry_size = (int )(sizeof(unsigned long ) + (unsigned long )max_fn_len);
#line 679
  tmp___10 = malloc((size_t )(text_lines * text_entry_size));
#line 679
  textsymroot = (struct text_symbol *)tmp___10;
  }
#line 680
  if (! textsymroot) {
    {
#line 681
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot allocate %d bytes \n",
            prgname, text_lines * text_entry_size);
#line 683
    exit(1);
    }
  }
  {
#line 685
  textsym = textsymroot;
#line 688
  textsym->textadr = adr0;
#line 689
  strcpy((char */* __restrict  */)(textsym->textname), (char const   */* __restrict  */)(begin_text));
#line 690
  textsym = (struct text_symbol *)((char *)textsym + text_entry_size);
#line 693
  fseek(mapf, (long )seek_adr, 0);
  }
  {
#line 694
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 694
    tmp___13 = fgets((char */* __restrict  */)(mapline), 1024, (FILE */* __restrict  */)mapf);
    }
#line 694
    if (! tmp___13) {
#line 694
      goto while_break___1;
    }
    {
#line 695
    tmp___11 = sscanf((char const   */* __restrict  */)(mapline), (char const   */* __restrict  */)"%lx %s %s",
                      & fn_adr, mode, fn_name);
    }
#line 695
    if (tmp___11 != 3) {
      {
#line 696
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s(%i): wrong map line\n",
              prgname, mapFile, maplineno);
#line 698
      exit(1);
      }
    }
#line 700
    if ((int )mode[0] == 65) {
      {
#line 700
      tmp___12 = strcmp((char const   *)(fn_name), (char const   *)(end_text));
      }
#line 700
      if (! tmp___12) {
#line 702
        goto while_break___1;
      }
    }
#line 703
    if ((int )mode[0] != 84) {
#line 703
      if ((int )mode[0] != 116) {
#line 704
        goto while_continue___1;
      }
    }
    {
#line 705
    textsym->textadr = fn_adr;
#line 706
    strcpy((char */* __restrict  */)(textsym->textname), (char const   */* __restrict  */)(fn_name));
#line 707
    textsym = (struct text_symbol *)((char *)textsym + text_entry_size);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 709
  textsym->textadr = adrz;
#line 710
  strcpy((char */* __restrict  */)(textsym->textname), (char const   */* __restrict  */)(end_text));
#line 711
  textsym = (struct text_symbol *)((char *)textsym + text_entry_size);
#line 712
  textsymlast = textsym;
  }
#line 713
  return;
}
}
#line 723 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static int lookup(unsigned long adr ) 
{ 


  {
#line 725
  textsym = (struct text_symbol *)((char *)textsymroot + text_entry_size * lookup_last);
  {
#line 726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 726
    if (! (textsym->textadr < adr)) {
#line 726
      goto while_break;
    }
#line 727
    if (textsym->textadr == adrz) {
#line 727
      goto while_break;
    }
#line 728
    textsym = (struct text_symbol *)((char *)textsym + text_entry_size);
#line 729
    lookup_last ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 731
  if (textsym->textadr == adr) {
#line 732
    return (lookup_last);
  }
#line 733
  if (textsym->textadr > adr) {
#line 734
    return (lookup_last - 1);
  }
#line 735
  return (-1);
}
}
#line 741 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static int copy_freqs(int *freqs___0 , int threshold___0 , struct freq_table *sortfreqs ) 
{ 
  int ix ;
  int ticks ;
  int saved ;

  {
#line 743
  saved = 0;
#line 745
  ix = 0;
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 745
    if (! (ix < text_lines)) {
#line 745
      goto while_break;
    }
#line 746
    ticks = *(freqs___0 + ix);
#line 748
    if (ticks >= threshold___0) {
#line 749
      (sortfreqs + saved)->ticks = ticks;
#line 750
      (sortfreqs + saved)->textindex = ix;
#line 751
      saved ++;
#line 752
      if (saved >= 100) {
#line 753
        goto while_break;
      }
    }
#line 745
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 756
  return (saved);
}
}
#line 761 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static void insertionSort(struct freq_table *sortfreqs , int array_size ) 
{ 
  int i ;
  int j ;
  int xticks ;
  int xtextindex ;

  {
#line 766
  i = 1;
  {
#line 766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 766
    if (! (i < array_size)) {
#line 766
      goto while_break;
    }
#line 767
    xticks = (sortfreqs + i)->ticks;
#line 768
    xtextindex = (sortfreqs + i)->textindex;
#line 769
    j = i;
    {
#line 771
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 771
      if (j > 0) {
#line 771
        if (! ((sortfreqs + (j - 1))->ticks < xticks)) {
#line 771
          goto while_break___0;
        }
      } else {
#line 771
        goto while_break___0;
      }
#line 772
      (sortfreqs + j)->ticks = (sortfreqs + (j - 1))->ticks;
#line 773
      (sortfreqs + j)->textindex = (sortfreqs + (j - 1))->textindex;
#line 774
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 776
    (sortfreqs + j)->ticks = xticks;
#line 777
    (sortfreqs + j)->textindex = xtextindex;
#line 766
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  return;
}
}
#line 787 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
static void sort_freqs(int valid , struct freq_table *sortfreqs ) 
{ 


  {
  {
#line 789
  insertionSort(sortfreqs, valid);
  }
#line 790
  return;
}
}
#line 792 "/home/wheatley/newnew/temp/kerneltop-0.91/kerneltop.c"
int main(int argc , char **argv ) 
{ 
  char *mapFile ;
  char *proFile ;
  unsigned long len ;
  unsigned int step ;
  unsigned int *lastbuf ;
  unsigned int *buf ;
  int opt ;
  int optReverse ;
  int optProfile ;
  int optMapfile ;
  time_t timer ;
  struct tm *dttm ;
  int total_ticks ;
  int ticks ;
  int ix ;
  int mx ;
  int fnx ;
  int slpx ;
  unsigned long adr ;
  int valid ;
  char ch ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 795
  len = 0UL;
#line 797
  buf = (unsigned int *)((void *)0);
#line 799
  optReverse = 0;
#line 799
  optProfile = 0;
#line 799
  optMapfile = 0;
#line 802
  total_ticks = 0;
#line 814
  prgname = *(argv + 0);
#line 815
  proFile = defaultpro;
#line 816
  mapFile = defaultmap;
#line 817
  get_unames(uname_all, uname_release);
  }
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 819
    opt = getopt(argc, (char * const  *)argv, (char const   *)(optstring));
    }
#line 819
    if (! (opt != -1)) {
#line 819
      goto while_break;
    }
    {
#line 821
    if (opt == 109) {
#line 821
      goto case_109;
    }
#line 824
    if (opt == 112) {
#line 824
      goto case_112;
    }
#line 827
    if (opt == 108) {
#line 827
      goto case_108;
    }
#line 831
    if (opt == 115) {
#line 831
      goto case_115;
    }
#line 835
    if (opt == 114) {
#line 835
      goto case_114;
    }
#line 836
    if (opt == 116) {
#line 836
      goto case_116;
    }
#line 840
    if (opt == 117) {
#line 840
      goto case_117;
    }
#line 841
    if (opt == 86) {
#line 841
      goto case_86;
    }
#line 843
    goto switch_default;
    case_109: /* CIL Label */ 
#line 821
    mapFile = optarg;
#line 822
    optMapfile ++;
#line 823
    goto switch_break;
    case_112: /* CIL Label */ 
#line 824
    proFile = optarg;
#line 825
    optProfile ++;
#line 826
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 827
    tmp = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                 0);
#line 827
    console_lines = (int )tmp;
    }
#line 828
    if (console_lines <= 0) {
#line 829
      console_lines = 20;
    } else
#line 828
    if (console_lines > 100) {
#line 829
      console_lines = 20;
    }
#line 830
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 831
    tmp___0 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     0);
#line 831
    sleep_seconds = (int )tmp___0;
    }
#line 832
    if (sleep_seconds <= 0) {
#line 833
      sleep_seconds = 1;
    }
#line 834
    goto switch_break;
    case_114: /* CIL Label */ 
#line 835
    optReverse ++;
#line 835
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 836
    tmp___1 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     0);
#line 836
    threshold = (int )tmp___1;
    }
#line 837
    if (threshold < 1) {
#line 838
      threshold = 1;
    }
#line 839
    goto switch_break;
    case_117: /* CIL Label */ 
#line 840
    optUnsorted ++;
#line 840
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 841
    printf((char const   */* __restrict  */)"%s Version %s\n", prgname, "0.9");
#line 842
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 843
    usage();
    }
#line 843
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 859
  mapfile_read((char const   *)mapFile, optMapfile);
  }
#line 860
  if (popenMap) {
    {
#line 860
    pclose(mapf);
    }
  } else {
    {
#line 860
    fclose(mapf);
    }
  }
  {
#line 863
  tmp___2 = xmalloc(sizeof(int ) * (unsigned long )(text_lines + 1));
#line 863
  freqs = (int *)tmp___2;
#line 864
  memset((void *)freqs, 0, sizeof(int ) * (unsigned long )(text_lines + 1));
#line 866
  heading();
  }
  {
#line 868
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 869
    lastbuf = buf;
#line 870
    len = profile_read((char const   *)proFile, & buf);
#line 871
    step = *(buf + 0);
#line 872
    vid_curpos(2, 1);
#line 873
    printf((char const   */* __restrict  */)"Sampling_step: %i | Address range: 0x%lx - 0x%lx\n",
           step, adr0, adrz);
#line 876
    time(& timer);
#line 877
    dttm = localtime((time_t const   *)(& timer));
#line 878
    vid_curpos(3, 1);
#line 879
    vid_attr(7);
#line 880
    printf((char const   */* __restrict  */)"address  function ...... %d-%02d-%02d/%02d:%02d:%02d ...... ticks",
           dttm->tm_year + 1900, dttm->tm_mon + 1, dttm->tm_mday, dttm->tm_hour, dttm->tm_min,
           dttm->tm_sec);
#line 902
    mx = (int )(len / sizeof(int ) - 1UL);
#line 904
    ix = 0;
#line 904
    lookup_last = 0;
    }
    {
#line 904
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 904
      if (! (ix < mx)) {
#line 904
        goto while_break___1;
      }
#line 905
      adr = adr0 + (unsigned long )(step * (unsigned int )ix);
#line 906
      if (lastbuf) {
#line 906
        tmp___3 = *(lastbuf + (ix + 1));
      } else {
#line 906
        tmp___3 = 0U;
      }
      {
#line 906
      ticks = (int )(*(buf + (ix + 1)) - tmp___3);
#line 907
      total_ticks += ticks;
#line 908
      fnx = lookup(adr);
      }
#line 909
      if (fnx >= 0) {
#line 910
        *(freqs + fnx) += ticks;
      }
#line 904
      ix ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 913
    vid_clear_curtoeol();
#line 914
    printf((char const   */* __restrict  */)" (%6i)\n", total_ticks);
#line 915
    vid_attr(27);
#line 923
    valid = copy_freqs(freqs, threshold, freqtable);
    }
#line 924
    if (! optUnsorted) {
      {
#line 925
      sort_freqs(valid, freqtable);
      }
    }
#line 929
    ix = 0;
    {
#line 929
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 929
      if (! (ix < valid)) {
#line 929
        goto while_break___2;
      }
#line 930
      if (ix >= prof_lines) {
#line 930
        goto while_break___2;
      }
      {
#line 931
      ticks = freqtable[ix].ticks;
#line 932
      textsym = (struct text_symbol *)((char *)textsymroot + text_entry_size * freqtable[ix].textindex);
#line 933
      vid_curpos(4 + ix, 1);
#line 934
      vid_clear_curtoend();
#line 935
      printf((char const   */* __restrict  */)"%08lx %-41s %6i\n", textsym->textadr,
             textsym->textname, ticks);
#line 929
      ix ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 939
    total_ticks = 0;
#line 941
    memset((void *)freqs, 0, sizeof(int ) * (unsigned long )(text_lines + 1));
#line 942
    free((void *)lastbuf);
#line 947
    slpx = 0;
    }
    {
#line 947
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 947
      if (! (slpx < sleep_seconds)) {
#line 947
        goto while_break___3;
      }
      {
#line 948
      sleep(1U);
#line 949
      tmp___5 = keypressed(0);
#line 949
      ch = (char )tmp___5;
      }
#line 949
      if (ch) {
        {
#line 950
        tmp___4 = do_key(ch);
        }
#line 950
        if (tmp___4 < 0) {
#line 950
          goto fini;
        }
      }
#line 947
      slpx ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 955
  free((void *)buf);
  }
  fini: 
  {
#line 958
  printf((char const   */* __restrict  */)"\n");
#line 959
  free((void *)freqs);
#line 960
  free((void *)textsymroot);
#line 961
  exit(0);
  }
}
}
