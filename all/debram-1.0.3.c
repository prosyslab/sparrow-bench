/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 16 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/xref.h"
struct xref;
#line 17 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/xref.h"
struct xram {
   struct xram *next ;
   struct xram *up ;
   struct xref *sref ;
   struct xref *xref ;
   int selected ;
   char ram[5] ;
   int n_indent ;
   int ram_level ;
   char *title ;
   int n_deb ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/xref.h"
struct xref {
   struct xref *next ;
   struct xram *xram ;
   char ram[5] ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.h"
struct ram_cl {
   struct ram_cl *next ;
   char ram[5] ;
};
#line 13 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.h"
struct name_cl {
   struct name_cl *next ;
   char *name ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.h"
struct options {
   struct ram_cl *ram_cl_first ;
   struct name_cl *maint_cl_first ;
   struct name_cl *deb_cl_first ;
   int wide ;
   int no_latin1 ;
   int utf8 ;
   int latin1 ;
   int expand_xref ;
   int plan ;
   int recursive ;
   int recursive_up ;
   int no_deb ;
   int no_subram ;
   int no_title ;
   int no_xref ;
   int no_maint ;
   int no_pri ;
   int no_desc ;
   int no_count ;
   int selections ;
   int color ;
   int pri_one_color ;
   int ascii_dots ;
   char *data_file_gz ;
   char *data_file ;
};
#line 7 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.h"
enum datum_type {
    NO_DATUM = 0,
    DEB = 1,
    TITLE = 2,
    TOC = 3,
    XREF = 4
} ;
#line 8 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.h"
struct datum {
   enum datum_type type ;
   char buf0[135] ;
   char *buf ;
   char *maint ;
   char *maintX ;
   char *pri ;
   char *priX ;
   char *deb ;
   char *debX ;
   char *desc ;
   char *descX ;
   char *ram ;
   char *ramX ;
   char *title_uc ;
   char *title_ucX ;
   char *count ;
   char *countX ;
   char *indent ;
   char *indentX ;
   char *title ;
   char *titleX ;
   char *arrow ;
   char *arrowX ;
   char *xrefs ;
   char *xrefsX ;
   char *xref[14] ;
   char ram_s[5] ;
};
#line 37
enum doc_part {
    ILLEGAL = 0,
    NONE1 = 1,
    PREFACE = 2,
    TOC_SP0 = 3,
    TOC_RULE1 = 4,
    TOC_TITLE = 5,
    TOC_RULE2 = 6,
    TOC_SP3 = 7,
    TOC_TITLE_X = 8,
    TOC_O = 9,
    TOC_X = 10,
    RUBRIC_SP0 = 11,
    RUBRIC_RULE1 = 12,
    RUBRIC_SP1 = 13,
    RUBRIC_TITLE = 14,
    RUBRIC_SP2 = 15,
    TITLE_RULE1 = 16,
    TITLE_O = 17,
    TITLE_RULE2 = 18,
    DEB_O = 19,
    DEB_X = 20,
    XREF_TITLE = 21,
    XREF_TITLE_RULE2 = 22,
    XREF_TITLE_SP2 = 23,
    XREF_TITLE_X = 24,
    XREF_O = 25,
    DOC_ENDMATTER = 26,
    NONE2 = 27
} ;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 42 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/xref.c"
struct n_deb {
   struct n_deb *next ;
   char ram[5] ;
   int n ;
};
#line 62 "/usr/include/search.h"
enum __anonenum_ACTION_1 {
    FIND = 0,
    ENTER = 1
} ;
#line 62 "/usr/include/search.h"
typedef enum __anonenum_ACTION_1 ACTION;
#line 69 "/usr/include/search.h"
struct entry {
   char *key ;
   void *data ;
};
#line 69 "/usr/include/search.h"
typedef struct entry ENTRY;
#line 77
struct _ENTRY;
#line 97 "/usr/include/search.h"
struct hsearch_data {
   struct _ENTRY *table ;
   unsigned int size ;
   unsigned int filled ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 7 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.h"
enum type_name_cl {
    NAME_MAINT = 1,
    NAME_DEB = 2
} ;
#line 68 "/usr/include/errno.h"
typedef int error_t;
#line 77 "/usr/include/argp.h"
struct argp_option {
   char const   *name ;
   int key ;
   char const   *arg ;
   int flags ;
   char const   *doc ;
   int group ;
};
#line 142
struct argp;
#line 143
struct argp_state;
#line 144
struct argp_child;
#line 216 "/usr/include/argp.h"
struct argp {
   struct argp_option  const  *options ;
   error_t (*parser)(int __key , char *__arg , struct argp_state *__state ) ;
   char const   *args_doc ;
   char const   *doc ;
   struct argp_child  const  *children ;
   char *(*help_filter)(int __key , char const   *__text , void *__input ) ;
   char const   *argp_domain ;
};
#line 282 "/usr/include/argp.h"
struct argp_child {
   struct argp  const  *argp ;
   int flags ;
   char const   *header ;
   int group ;
};
#line 307 "/usr/include/argp.h"
struct argp_state {
   struct argp  const  *root_argp ;
   int argc ;
   char **argv ;
   int next ;
   unsigned int flags ;
   unsigned int arg_num ;
   int quoted ;
   void *input ;
   void **child_inputs ;
   void *hook ;
   char *name ;
   FILE *err_stream ;
   FILE *out_stream ;
   void *pstate ;
};
#line 93 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off64_t;
#line 1224 "/usr/include/zlib.h"
struct gzFile_s;
#line 1224 "/usr/include/zlib.h"
typedef struct gzFile_s *gzFile;
#line 1670 "/usr/include/zlib.h"
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off64_t pos ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/ldf.c"
enum isopen {
    GZ_FILE = 1,
    CLEAR_FILE = 2
} ;
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
#line 35 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/xref.h"
struct xram xram0000 ;
#line 37
struct xram *xref_pass(void) ;
#line 38
struct xram *first_selected(struct xram *xram ) ;
#line 39
struct xram *next_selected(struct xram *xram ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/strx.h"
char *strxcpy(char *d , char const   *s , char const   * const  x ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.h"
struct options opt ;
#line 46
char zero_ram[5] ;
#line 51 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.h"
struct datum datum ;
#line 52
enum doc_part doc_part ;
#line 56
struct datum *get_datum(struct datum *d ) ;
#line 57
void rewind_data(void) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 31 "/usr/include/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error)(int __status ,
                                                                                                                         int __errnum ,
                                                                                                                         char const   *__format 
                                                                                                                         , ...) ;
#line 34
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error_at_line)(int __status ,
                                                                                                                                 int __errnum ,
                                                                                                                                 char const   *__fname ,
                                                                                                                                 unsigned int __line ,
                                                                                                                                 char const   *__format 
                                                                                                                                 , ...) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/error.h"
extern void ( /* format attribute */  __error_alias)(int __status , int __errnum ,
                                                     char const   *__format  , ...)  __asm__("error")  ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error)(int __status ,
                                                                                                                         int __errnum ,
                                                                                                                         char const   *__format 
                                                                                                                         , ...) 
{ 


  {
  {
#line 42
  __error_alias(__status, __errnum, __format, __builtin_va_arg_pack());
  }
#line 43
  return;
}
}
#line 46
extern void ( /* format attribute */  __error_at_line_alias)(int __status , int __errnum ,
                                                             char const   *__fname ,
                                                             unsigned int __line ,
                                                             char const   *__format 
                                                             , ...)  __asm__("error_at_line")  ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error_at_line)(int __status ,
                                                                                                                                 int __errnum ,
                                                                                                                                 char const   *__fname ,
                                                                                                                                 unsigned int __line ,
                                                                                                                                 char const   *__format 
                                                                                                                                 , ...) 
{ 


  {
  {
#line 71
  __error_at_line_alias(__status, __errnum, __fname, __line, __format, __builtin_va_arg_pack());
  }
#line 73
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/alloc.h"
__inline static void *malloc2(size_t const   size ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 25
  tmp = malloc((size_t )size);
#line 25
  p = tmp;
  }
#line 26
  if (! p) {
    {
#line 26
    error(12, 0, "insufficient heap memory is available");
    }
  }
#line 27
  return (p);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/alloc.h"
__inline static void *calloc2(size_t const   nmemb , size_t const   size ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 31
  tmp = calloc((size_t )nmemb, (size_t )size);
#line 31
  p = tmp;
  }
#line 32
  if (! p) {
    {
#line 32
    error(12, 0, "insufficient heap memory is available");
    }
  }
#line 33
  return (p);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/xref.c"
struct xram xram0000  = 
#line 48 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/xref.c"
     {(struct xram *)0, (struct xram *)0, (struct xref *)0, (struct xref *)0, 0, {(char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0},
    0, 0, (char *)0, 0};
#line 50 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/xref.c"
static void select_recursively(struct xram * const  xram ) 
{ 
  struct xref *sref ;

  {
#line 52
  xram->selected = 1;
#line 53
  sref = xram->sref;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! sref) {
#line 53
      goto while_break;
    }
    {
#line 54
    select_recursively((struct xram */* const  */)sref->xram);
#line 53
    sref = sref->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/xref.c"
static void select_recursively_up(struct xram * const  xram , int step_one_down ) 
{ 
  struct xref *sref ;

  {
#line 61
  xram->selected = 1;
#line 62
  if (step_one_down) {
#line 62
    if (opt.plan) {
#line 64
      sref = xram->sref;
      {
#line 64
      while (1) {
        while_continue: /* CIL Label */ ;
#line 64
        if (! sref) {
#line 64
          goto while_break;
        }
#line 65
        (sref->xram)->selected = 1;
#line 64
        sref = sref->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 67
  if (xram->up) {
    {
#line 67
    select_recursively_up((struct xram */* const  */)xram->up, 1);
    }
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/xref.c"
struct xram *xref_pass(void) 
{ 
  struct xram *up[5] ;
  unsigned int tmp ;
  struct xref **v[5] ;
  unsigned int tmp___0 ;
  struct n_deb *n_deb_first ;
  struct xram *xram ;
  struct n_deb *n_deb_last ;
  struct n_deb *n_deb ;
  void *tmp___1 ;
  struct xram *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  struct xref *xref_last ;
  int i ;
  struct xref *xref ;
  void *tmp___5 ;
  int i___0 ;
  struct xref *sref ;
  void *tmp___6 ;
  struct xram *xram___0 ;
  struct xref *xref___0 ;
  int tmp___7 ;
  struct xram *xram___1 ;
  struct n_deb *n_deb___0 ;
  int tmp___8 ;
  int i___1 ;
  struct xram *xram___2 ;
  struct xref *sref___0 ;
  struct ram_cl *ram_cl ;
  struct xram *xram___3 ;
  int tmp___9 ;

  {
#line 73
  up[0] = & xram0000;
#line 73
  up[1] = (struct xram *)0;
#line 73
  tmp = 2U;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (tmp >= 5U) {
#line 73
      goto while_break;
    }
#line 73
    up[tmp] = (struct xram *)0;
#line 73
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  v[0] = & xram0000.sref;
#line 74
  v[1] = (struct xref **)0;
#line 74
  tmp___0 = 2U;
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 74
    if (tmp___0 >= 5U) {
#line 74
      goto while_break___0;
    }
#line 74
    v[tmp___0] = (struct xref **)0;
#line 74
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 76
  n_deb_first = (struct n_deb *)0;
#line 78
  rewind_data();
#line 81
  strncpy((char */* __restrict  */)(xram0000.ram), (char const   */* __restrict  */)(zero_ram),
          (size_t )5);
#line 82
  xram0000.n_indent = -2;
#line 83
  xram0000.title = (char *)"The Ramification\'s Principal Sections";
#line 89
  xram = & xram0000;
#line 90
  n_deb_last = (struct n_deb *)0;
  }
  {
#line 92
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 92
    if (! ((unsigned int )doc_part < 27U)) {
#line 92
      goto while_break___1;
    }
    {
#line 94
    get_datum((struct datum *)0);
    }
    {
#line 98
    if ((unsigned int )doc_part == 17U) {
#line 98
      goto case_17;
    }
#line 107
    if ((unsigned int )doc_part == 25U) {
#line 107
      goto case_25;
    }
#line 155
    goto switch_default;
    case_17: /* CIL Label */ 
    {
#line 99
    tmp___1 = calloc2((size_t const   )1, (size_t const   )sizeof(struct n_deb ));
#line 99
    n_deb = (struct n_deb *)tmp___1;
    }
#line 100
    if (n_deb_first) {
#line 100
      n_deb_last->next = n_deb;
    } else {
#line 101
      n_deb_first = n_deb;
    }
    {
#line 102
    n_deb_last = n_deb;
#line 103
    strxcpy(n_deb->ram, (char const   *)datum.ram, (char const   *)datum.ramX);
#line 104
    n_deb->n = atoi((char const   *)datum.count);
    }
#line 105
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 108
    tmp___3 = calloc2((size_t const   )1, (size_t const   )sizeof(struct xram ));
#line 108
    tmp___2 = (struct xram *)tmp___3;
#line 108
    xram->next = tmp___2;
#line 108
    xram = tmp___2;
#line 109
    xram->n_indent = (int )(datum.indentX - datum.indent);
#line 110
    tmp___4 = malloc2((size_t const   )((datum.titleX - datum.title) + 1L));
#line 110
    xram->title = (char *)tmp___4;
#line 111
    strxcpy(xram->title, (char const   *)datum.title, (char const   *)datum.titleX);
#line 112
    strxcpy(xram->ram, (char const   *)datum.ram, (char const   *)datum.ramX);
#line 113
    xram->ram_level = (xram->n_indent + 2) / 2;
    }
#line 115
    if ((xram->n_indent + 2) % 2) {
      {
#line 118
      error(5, 0, "irregular indentation at ram %s in the xref table\n", xram->ram);
      }
    } else
#line 115
    if (xram->ram_level < 0) {
      {
#line 118
      error(5, 0, "irregular indentation at ram %s in the xref table\n", xram->ram);
      }
    } else
#line 115
    if (xram->ram_level > 4) {
      {
#line 118
      error(5, 0, "irregular indentation at ram %s in the xref table\n", xram->ram);
      }
    }
#line 125
    xref_last = (struct xref *)0;
#line 127
    i = 0;
    {
#line 127
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 127
      if (i < 13) {
#line 127
        if (! datum.xref[i]) {
#line 127
          goto while_break___2;
        }
      } else {
#line 127
        goto while_break___2;
      }
      {
#line 128
      tmp___5 = calloc2((size_t const   )1, (size_t const   )sizeof(struct xref ));
#line 128
      xref = (struct xref *)tmp___5;
      }
#line 129
      if (xref_last) {
#line 129
        xref_last->next = xref;
      } else {
#line 130
        xram->xref = xref;
      }
      {
#line 131
      xref_last = xref;
#line 132
      strncpy((char */* __restrict  */)(xref->ram), (char const   */* __restrict  */)datum.xref[i],
              (size_t )4);
#line 127
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 138
    i___0 = 4;
    {
#line 138
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 138
      if (! (i___0 > xram->ram_level)) {
#line 138
        goto while_break___3;
      }
#line 139
      up[i___0] = (struct xram *)0;
#line 140
      v[i___0] = (struct xref **)0;
#line 138
      i___0 --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 142
    up[i___0] = xram;
#line 143
    v[i___0] = & xram->sref;
#line 144
    if (i___0) {
      {
#line 145
      tmp___6 = calloc2((size_t const   )1, (size_t const   )sizeof(struct xref ));
#line 145
      sref = (struct xref *)tmp___6;
#line 146
      *(v[i___0 - 1]) = sref;
#line 147
      v[i___0 - 1] = & sref->next;
#line 148
      sref->xram = xram;
#line 149
      strncpy((char */* __restrict  */)(sref->ram), (char const   */* __restrict  */)(xram->ram),
              (size_t )5);
#line 150
      xram->up = up[i___0 - 1];
      }
    }
#line 153
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 155
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 166
  xram___0 = & xram0000;
  {
#line 166
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 166
    if (! xram___0) {
#line 166
      goto while_break___4;
    }
#line 168
    xref___0 = xram___0->xref;
    {
#line 168
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 168
      if (! xref___0) {
#line 168
        goto while_break___5;
      }
#line 169
      xref___0->xram = & xram0000;
      {
#line 170
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 170
        if (xref___0->xram) {
          {
#line 170
          tmp___7 = strncmp((char const   *)((xref___0->xram)->ram), (char const   *)(xref___0->ram),
                            (size_t )4);
          }
#line 170
          if (! tmp___7) {
#line 170
            goto while_break___6;
          }
        } else {
#line 170
          goto while_break___6;
        }
#line 173
        xref___0->xram = (xref___0->xram)->next;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 174
      if (! xref___0->xram) {
        {
#line 174
        error(5, 0, "cannot find ram %s in the xref table", xref___0->ram);
        }
      }
#line 168
      xref___0 = xref___0->next;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 166
    xram___0 = xram___0->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 185
  xram___1 = & xram0000;
#line 187
  n_deb___0 = n_deb_first;
  {
#line 187
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 187
    if (! n_deb___0) {
#line 187
      goto while_break___7;
    }
    {
#line 188
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 188
      if (xram___1) {
        {
#line 188
        tmp___8 = strncmp((char const   *)(n_deb___0->ram), (char const   *)(xram___1->ram),
                          (size_t )4);
        }
#line 188
        if (! tmp___8) {
#line 188
          goto while_break___8;
        }
      } else {
#line 188
        goto while_break___8;
      }
#line 189
      xram___1 = xram___1->next;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 190
    if (! xram___1) {
      {
#line 190
      error(5, 0, "cannot find ram %s in sequence in the data file\'s main body",
            n_deb___0->ram);
      }
    }
#line 195
    xram___1->n_deb = n_deb___0->n;
#line 187
    n_deb___0 = n_deb___0->next;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 200
  i___1 = 3;
  {
#line 200
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 200
    if (! (i___1 >= 0)) {
#line 200
      goto while_break___9;
    }
#line 202
    xram___2 = & xram0000;
    {
#line 202
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 202
      if (! xram___2) {
#line 202
        goto while_break___10;
      }
#line 203
      if (xram___2->ram_level == i___1) {
#line 205
        sref___0 = xram___2->sref;
        {
#line 205
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 205
          if (! sref___0) {
#line 205
            goto while_break___11;
          }
#line 206
          xram___2->n_deb += (sref___0->xram)->n_deb;
#line 205
          sref___0 = sref___0->next;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 202
      xram___2 = xram___2->next;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 200
    i___1 --;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 215
  ram_cl = opt.ram_cl_first;
  {
#line 215
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 215
    if (! ram_cl) {
#line 215
      goto while_break___12;
    }
#line 217
    xram___3 = & xram0000;
    {
#line 217
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 217
      if (! xram___3) {
#line 217
        goto while_break___13;
      }
      {
#line 218
      tmp___9 = strncmp((char const   *)(xram___3->ram), (char const   *)(ram_cl->ram),
                        (size_t )4);
      }
#line 218
      if (! tmp___9) {
#line 218
        goto while_break___13;
      }
#line 217
      xram___3 = xram___3->next;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 219
    if (! xram___3) {
      {
#line 219
      error(22, 0, "unknown ramification %s", ram_cl->ram);
      }
    }
#line 224
    if (opt.recursive) {
      {
#line 224
      select_recursively((struct xram */* const  */)xram___3);
      }
    }
#line 225
    if (opt.recursive_up) {
      {
#line 225
      select_recursively_up((struct xram */* const  */)xram___3, 1);
      }
    } else {
#line 229
      xram___3->selected = 1;
    }
#line 215
    ram_cl = ram_cl->next;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 233
  rewind_data();
  }
#line 234
  return (& xram0000);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/xref.c"
struct xram *first_selected(struct xram *xram ) 
{ 


  {
#line 260
  if (! xram) {
#line 260
    xram = & xram0000;
  }
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (xram) {
#line 261
      if (! (! xram->selected)) {
#line 261
        goto while_break;
      }
    } else {
#line 261
      goto while_break;
    }
#line 261
    xram = xram->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (xram);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/xref.c"
struct xram *next_selected(struct xram *xram ) 
{ 


  {
#line 266
  xram = xram->next;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (xram) {
#line 267
      if (! (! xram->selected)) {
#line 267
        goto while_break;
      }
    } else {
#line 267
      goto while_break;
    }
#line 267
    xram = xram->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return (xram);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/plan.h"
void print_plan(void) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/utf8.h"
char *utf8(char *out , size_t size_out , int n  , ...) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/utf8.h"
__inline static char *utf8_sel_arg2(int const   i , char * const  s1 , char * const  s2 ) 
{ 
  char *tmp ;

  {
#line 41
  if (i == 1) {
#line 41
    tmp = s1;
  } else {
#line 41
    tmp = s2;
  }
#line 41
  return ((char *)tmp);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/plan.c"
void print_plan(void) 
{ 
  struct xram *xram ;
  char const   *tmp ;
  int i ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  struct xref  const  *xref ;
  int i___0 ;
  struct xram *xram2 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  char const   *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;

  {
#line 13
  xram = & xram0000;
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13
    if (! xram) {
#line 13
      goto while_break;
    }
#line 14
    if (xram->selected) {
#line 14
      if (xram->ram_level > 0) {
#line 15
        if (opt.color) {
#line 15
          tmp = "\033[22;37m";
        } else {
#line 15
          tmp = "";
        }
        {
#line 15
        printf((char const   */* __restrict  */)"%s%s ", tmp, xram->ram);
#line 18
        i = 0;
        }
        {
#line 18
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 18
          if (! (i < xram->n_indent)) {
#line 18
            goto while_break___0;
          }
          {
#line 18
          putchar(' ');
#line 18
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 20
        if (opt.color) {
#line 20
          tmp___0 = "\033[0m\033[m\n";
        } else {
#line 20
          tmp___0 = "\n";
        }
#line 20
        if (opt.utf8) {
#line 20
          tmp___3 = "";
        } else {
#line 20
          if (opt.color) {
#line 20
            tmp___1 = "\033[22;36m";
          } else {
#line 20
            tmp___1 = "";
          }
          {
#line 20
          tmp___2 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___1, (char */* const  */)xram->title);
#line 20
          tmp___3 = (char const   *)tmp___2;
          }
        }
#line 20
        if (opt.utf8) {
#line 20
          if (opt.color) {
#line 20
            tmp___4 = "\033[22;36m";
          } else {
#line 20
            tmp___4 = "";
          }
          {
#line 20
          tmp___5 = utf8((char *)0, (size_t )0, 2, tmp___4, xram->title);
#line 20
          tmp___8 = tmp___5;
          }
        } else {
#line 20
          if (opt.color) {
#line 20
            tmp___6 = "\033[22;36m";
          } else {
#line 20
            tmp___6 = "";
          }
          {
#line 20
          tmp___7 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___6, (char */* const  */)xram->title);
#line 20
          tmp___8 = tmp___7;
          }
        }
        {
#line 20
        printf((char const   */* __restrict  */)"%s%s%s", tmp___8, tmp___3, tmp___0);
        }
#line 21
        if (opt.expand_xref) {
#line 23
          xref = (struct xref  const  *)xram->xref;
          {
#line 23
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 23
            if (! xref) {
#line 23
              goto while_break___1;
            }
#line 26
            i___0 = 0;
            {
#line 26
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 26
              if (! (i___0 < 13)) {
#line 26
                goto while_break___2;
              }
              {
#line 27
              putchar(' ');
#line 26
              i___0 ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 30
            xram2 = (struct xram *)xref->xram;
#line 31
            if (opt.color) {
#line 31
              tmp___9 = "\033[0m\033[m\n";
            } else {
#line 31
              tmp___9 = "\n";
            }
#line 31
            if (opt.utf8) {
#line 31
              tmp___12 = "";
            } else {
#line 31
              if (opt.color) {
#line 31
                tmp___10 = "\033[02;37m";
              } else {
#line 31
                tmp___10 = "";
              }
              {
#line 31
              tmp___11 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___10,
                                       (char */* const  */)xram2->title);
#line 31
              tmp___12 = (char const   *)tmp___11;
              }
            }
#line 31
            if (opt.utf8) {
#line 31
              if (opt.color) {
#line 31
                tmp___13 = "\033[02;37m";
              } else {
#line 31
                tmp___13 = "";
              }
              {
#line 31
              tmp___14 = utf8((char *)0, (size_t )0, 2, tmp___13, xram2->title);
#line 31
              tmp___17 = tmp___14;
              }
            } else {
#line 31
              if (opt.color) {
#line 31
                tmp___15 = "\033[02;37m";
              } else {
#line 31
                tmp___15 = "";
              }
              {
#line 31
              tmp___16 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___15,
                                       (char */* const  */)xram2->title);
#line 31
              tmp___17 = tmp___16;
              }
            }
#line 31
            if (opt.color) {
#line 31
              tmp___18 = "\033[02;37m";
            } else {
#line 31
              tmp___18 = "";
            }
#line 31
            if (opt.utf8) {
#line 31
              tmp___21 = "";
            } else {
#line 31
              if (opt.color) {
#line 31
                tmp___19 = "\033[02;37m";
              } else {
#line 31
                tmp___19 = "";
              }
              {
#line 31
              tmp___20 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___19,
                                       (char */* const  */)"--->");
#line 31
              tmp___21 = (char const   *)tmp___20;
              }
            }
#line 31
            if (opt.utf8) {
#line 31
              if (opt.color) {
#line 31
                tmp___22 = "\033[02;37m";
              } else {
#line 31
                tmp___22 = "";
              }
              {
#line 31
              tmp___23 = utf8((char *)0, (size_t )0, 2, tmp___22, "--->");
#line 31
              tmp___26 = tmp___23;
              }
            } else {
#line 31
              if (opt.color) {
#line 31
                tmp___24 = "\033[02;37m";
              } else {
#line 31
                tmp___24 = "";
              }
              {
#line 31
              tmp___25 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___24,
                                       (char */* const  */)"--->");
#line 31
              tmp___26 = tmp___25;
              }
            }
            {
#line 31
            printf((char const   */* __restrict  */)"%s%s %s%s %s%s%s", tmp___26,
                   tmp___21, tmp___18, xram2->ram, tmp___17, tmp___12, tmp___9);
#line 23
            xref = (struct xref  const  *)xref->next;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
#line 13
    xram = xram->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.h"
char ram_s[5] ;
#line 55
struct datum *init_datum(struct datum *d ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/conv.h"
char *unlat(char *s ) ;
#line 16
char *undot(char *s , char const   c ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/ldf.h"
char *read_ldf(char * const  buf___0 ) ;
#line 8
void rewind_ldf(void) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
struct datum datum  = 
#line 26 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
     {(enum datum_type )0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                          (char)0, (char)0}, (char *)0, (char *)0, (char *)0, (char *)0,
    (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0,
    (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0,
    (char *)0, (char *)0, (char *)0, {(char *)0, (char *)0, (char *)0, (char *)0,
                                      (char *)0, (char *)0, (char *)0, (char *)0,
                                      (char *)0, (char *)0, (char *)0, (char *)0,
                                      (char *)0, (char *)0}, {(char)0, (char)0, (char)0,
                                                              (char)0, (char)0}};
#line 27 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
enum doc_part doc_part  =    (enum doc_part )1;
#line 28 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
char ram_s[5]  = {      (char )'\000'};
#line 31 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
static char *op  =    (char *)0;
#line 32 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
static char *pp  =    (char *)0;
#line 33 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
static char *xp  =    (char *)0;
#line 34 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
__inline static void pp_clear(void) 
{ 


  {
#line 35
  pp = (char *)0;
#line 35
  op = pp;
#line 35
  xp = op;
#line 36
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
__inline static char *pp_init(char * const  p ) 
{ 


  {
#line 38
  pp = (char *)p;
#line 38
  op = pp;
#line 38
  xp = op + 132;
#line 38
  return (xp);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
__inline static char *pp_set(char * const  p ) 
{ 
  char *tmp ;

  {
#line 41
  if ((unsigned long )xp <= (unsigned long )op) {
#line 41
    return ((char *)0);
  }
#line 42
  if ((unsigned long )p < (unsigned long )op) {
#line 42
    pp = op;
  } else {
#line 42
    if ((unsigned long )p > (unsigned long )xp) {
#line 42
      tmp = (char */* const  */)xp;
    } else {
#line 42
      tmp = p;
    }
#line 42
    pp = (char *)tmp;
  }
#line 42
  return (pp);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
__inline static char *pp_incr(void) 
{ 
  char *tmp ;

  {
  {
#line 45
  tmp = pp_set((char */* const  */)(pp + 1));
  }
#line 45
  return (tmp);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
__inline static char *pp_addn(int const   n ) 
{ 
  char *tmp ;

  {
  {
#line 51
  tmp = pp_set((char */* const  */)(pp + n));
  }
#line 51
  return (tmp);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
__inline static char *end_of_line(char *s ) 
{ 


  {
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (*s) {
#line 80
      if (! ((int )*s != 10)) {
#line 80
        goto while_break;
      }
    } else {
#line 80
      goto while_break;
    }
#line 80
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return (s);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
__inline static char *next_space(char *s ) 
{ 


  {
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (*s) {
#line 87
      if ((int )*s != 10) {
#line 87
        if (! ((int )*s != 32)) {
#line 87
          goto while_break;
        }
      } else {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 87
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (s);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
__inline static char *last_nonspace(char const   * const  s , char *x ) 
{ 
  char *p ;
  int tmp ;

  {
#line 96
  p = x;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if ((unsigned long )x > (unsigned long )s) {
#line 97
      if (! ((int )*(x + -1) == 32)) {
#line 97
        if (opt.ascii_dots) {
#line 97
          tmp = '.';
        } else {
#line 97
          tmp = '\267';
        }
#line 97
        if (! ((int )*(x + -1) == tmp)) {
#line 97
          goto while_break;
        }
      }
    } else {
#line 97
      goto while_break;
    }
#line 101
    x --;
#line 101
    if ((int )*x == 32) {
#line 101
      p = x;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return (p);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
static char *begins_with_ramno(char *s ) 
{ 
  char *x ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
#line 108
  x = s + 4;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! ((unsigned long )s < (unsigned long )x)) {
#line 109
      goto while_break;
    }
    {
#line 109
    tmp = __ctype_b_loc();
#line 109
    tmp___0 = s;
#line 109
    s ++;
    }
#line 109
    if (! ((int const   )*(*tmp + (int )*tmp___0) & 2048)) {
#line 109
      return ((char *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  if ((int )*s != 32) {
#line 110
    if ((int )*s != 10) {
#line 110
      return ((char *)0);
    }
  }
#line 111
  return (x);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
static char *begins_with_arrow(char *s ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 119
  tmp = s;
#line 119
  s ++;
#line 119
  if ((int )*tmp != 32) {
#line 119
    return ((char *)0);
  } else {
#line 119
    tmp___0 = s;
#line 119
    s ++;
#line 119
    if ((int )*tmp___0 != 45) {
#line 119
      return ((char *)0);
    }
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! ((int )*s == 45)) {
#line 120
      goto while_break;
    }
#line 120
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  tmp___1 = s;
#line 121
  s ++;
#line 121
  if ((int )*tmp___1 != 62) {
#line 121
    return ((char *)0);
  } else {
#line 121
    tmp___2 = s;
#line 121
    s ++;
#line 121
    if ((int )*tmp___2 != 32) {
#line 121
      return ((char *)0);
    }
  }
#line 122
  return (s);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
struct datum *init_datum(struct datum *d ) 
{ 


  {
#line 129
  if (! d) {
#line 129
    d = & datum;
  }
  {
#line 130
  memset((void *)d, 0, sizeof(struct datum ));
#line 137
  d->buf = d->buf0 + 1;
  }
#line 138
  return (d);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
static char rule[134]  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
static int first_call  =    1;
#line 144 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
struct datum *get_datum(struct datum *d ) 
{ 
  char *tmp ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___41 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___51 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___59 ;
  int tmp___60 ;
  char *tmp___61 ;
  int tmp___63 ;
  int tmp___65 ;
  int tmp___67 ;
  int tmp___69 ;
  int tmp___71 ;
  int tmp___74 ;
  int tmp___75 ;
  char *tmp___76 ;
  int tmp___78 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *arrowX ;
  int i ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  char *a ;
  char *b ;
  char *tmp___85 ;
  char *tmp___86 ;
  char tmp___87 ;
  char tmp___88 ;
  char tmp___89 ;
  struct datum *tmp___90 ;

  {
#line 149
  if (first_call) {
    {
#line 150
    memset((void *)(rule), '-', (size_t )132);
#line 151
    rule[132] = (char )'\n';
#line 152
    rule[133] = (char )'\000';
#line 153
    first_call = 0;
    }
  }
#line 156
  if (! d) {
#line 156
    d = & datum;
  }
  {
#line 157
  init_datum(d);
#line 158
  tmp = read_ldf(d->buf);
  }
#line 158
  if (! tmp) {
#line 159
    if ((unsigned int )doc_part >= 25U) {
#line 159
      doc_part = (enum doc_part )27;
    } else {
#line 159
      doc_part = (enum doc_part )0;
    }
  }
#line 160
  if (opt.ascii_dots) {
    {
#line 160
    undot(d->buf, (char const   )'.');
    }
  } else
#line 161
  if (opt.no_latin1) {
    {
#line 161
    undot(d->buf, (char const   )' ');
    }
  }
#line 162
  if (opt.no_latin1) {
    {
#line 162
    unlat(d->buf);
    }
  }
  {
#line 167
  if ((unsigned int )doc_part == 0U) {
#line 167
    goto case_0;
  }
#line 170
  if ((unsigned int )doc_part == 1U) {
#line 170
    goto case_1;
  }
#line 176
  if ((unsigned int )doc_part == 2U) {
#line 176
    goto case_2;
  }
#line 181
  if ((unsigned int )doc_part == 3U) {
#line 181
    goto case_3;
  }
#line 188
  if ((unsigned int )doc_part == 4U) {
#line 188
    goto case_4;
  }
#line 195
  if ((unsigned int )doc_part == 5U) {
#line 195
    goto case_5;
  }
#line 202
  if ((unsigned int )doc_part == 6U) {
#line 202
    goto case_6;
  }
#line 208
  if ((unsigned int )doc_part == 7U) {
#line 208
    goto case_7;
  }
#line 215
  if ((unsigned int )doc_part == 8U) {
#line 215
    goto case_8;
  }
#line 221
  if ((unsigned int )doc_part == 9U) {
#line 221
    goto case_9;
  }
#line 229
  if ((unsigned int )doc_part == 10U) {
#line 229
    goto case_10;
  }
#line 234
  if ((unsigned int )doc_part == 11U) {
#line 234
    goto case_11;
  }
#line 241
  if ((unsigned int )doc_part == 12U) {
#line 241
    goto case_12;
  }
#line 246
  if ((unsigned int )doc_part == 13U) {
#line 246
    goto case_13;
  }
#line 255
  if ((unsigned int )doc_part == 14U) {
#line 255
    goto case_14;
  }
#line 260
  if ((unsigned int )doc_part == 15U) {
#line 260
    goto case_15;
  }
#line 268
  if ((unsigned int )doc_part == 16U) {
#line 268
    goto case_16;
  }
#line 275
  if ((unsigned int )doc_part == 17U) {
#line 275
    goto case_17;
  }
#line 281
  if ((unsigned int )doc_part == 19U) {
#line 281
    goto case_19;
  }
#line 281
  if ((unsigned int )doc_part == 18U) {
#line 281
    goto case_19;
  }
#line 286
  if ((unsigned int )doc_part == 20U) {
#line 286
    goto case_20;
  }
#line 292
  if ((unsigned int )doc_part == 21U) {
#line 292
    goto case_21;
  }
#line 297
  if ((unsigned int )doc_part == 22U) {
#line 297
    goto case_22;
  }
#line 303
  if ((unsigned int )doc_part == 23U) {
#line 303
    goto case_23;
  }
#line 310
  if ((unsigned int )doc_part == 24U) {
#line 310
    goto case_24;
  }
#line 316
  if ((unsigned int )doc_part == 25U) {
#line 316
    goto case_25;
  }
#line 321
  if ((unsigned int )doc_part == 26U) {
#line 321
    goto case_26;
  }
#line 324
  if ((unsigned int )doc_part == 27U) {
#line 324
    goto case_27;
  }
#line 327
  goto switch_default;
  case_0: /* CIL Label */ 
#line 168
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 171
  tmp___1 = strcmp((char const   *)d->buf, "\n");
  }
#line 171
  if (tmp___1) {
#line 171
    doc_part = (enum doc_part )2;
  } else {
#line 171
    doc_part = (enum doc_part )3;
  }
#line 174
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 177
  tmp___3 = strcmp((char const   *)d->buf, "\n");
  }
#line 177
  if (tmp___3) {
#line 177
    doc_part = (enum doc_part )2;
  } else {
#line 177
    doc_part = (enum doc_part )3;
  }
#line 180
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 182
  tmp___8 = strcmp((char const   *)d->buf, (char const   *)(rule));
  }
#line 182
  if (tmp___8) {
    {
#line 182
    tmp___7 = strcmp((char const   *)d->buf, "\n");
    }
#line 182
    if (tmp___7) {
#line 182
      tmp___6 = 2;
    } else {
#line 182
      tmp___6 = 3;
    }
#line 182
    doc_part = (enum doc_part )tmp___6;
  } else {
#line 182
    doc_part = (enum doc_part )4;
  }
#line 187
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 189
  tmp___13 = strcmp((char const   *)d->buf, "RAMIFICATION MAP AND TABLE OF CONTENTS\n");
  }
#line 189
  if (tmp___13) {
    {
#line 189
    tmp___12 = strcmp((char const   *)d->buf, "\n");
    }
#line 189
    if (tmp___12) {
#line 189
      tmp___11 = 2;
    } else {
#line 189
      tmp___11 = 3;
    }
#line 189
    doc_part = (enum doc_part )tmp___11;
  } else {
#line 189
    doc_part = (enum doc_part )5;
  }
#line 194
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 196
  tmp___18 = strcmp((char const   *)d->buf, (char const   *)(rule));
  }
#line 196
  if (tmp___18) {
    {
#line 196
    tmp___17 = strcmp((char const   *)d->buf, "\n");
    }
#line 196
    if (tmp___17) {
#line 196
      tmp___16 = 2;
    } else {
#line 196
      tmp___16 = 3;
    }
#line 196
    doc_part = (enum doc_part )tmp___16;
  } else {
#line 196
    doc_part = (enum doc_part )6;
  }
#line 201
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 203
  tmp___20 = strcmp((char const   *)d->buf, "\n");
  }
#line 203
  if (tmp___20) {
#line 203
    doc_part = (enum doc_part )2;
  } else {
#line 203
    doc_part = (enum doc_part )7;
  }
#line 206
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 209
  tmp___25 = begins_with_ramno(d->buf);
  }
#line 209
  if (tmp___25) {
#line 209
    doc_part = (enum doc_part )9;
  } else {
    {
#line 209
    tmp___24 = strcmp((char const   *)d->buf, "\n");
    }
#line 209
    if (tmp___24) {
#line 209
      tmp___23 = 8;
    } else {
#line 209
      tmp___23 = 7;
    }
#line 209
    doc_part = (enum doc_part )tmp___23;
  }
#line 214
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 216
  tmp___27 = strcmp((char const   *)d->buf, "\n");
  }
#line 216
  if (tmp___27) {
#line 216
    doc_part = (enum doc_part )8;
  } else {
#line 216
    doc_part = (enum doc_part )7;
  }
#line 219
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 222
  tmp___32 = begins_with_ramno(d->buf);
  }
#line 222
  if (tmp___32) {
#line 222
    doc_part = (enum doc_part )9;
  } else {
    {
#line 222
    tmp___31 = strcmp((char const   *)d->buf, "\n");
    }
#line 222
    if (tmp___31) {
#line 222
      tmp___30 = 10;
    } else {
#line 222
      tmp___30 = 11;
    }
#line 222
    doc_part = (enum doc_part )tmp___30;
  }
#line 227
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 230
  tmp___34 = strcmp((char const   *)d->buf, "\n");
  }
#line 230
  if (tmp___34) {
#line 230
    doc_part = (enum doc_part )10;
  } else {
#line 230
    doc_part = (enum doc_part )11;
  }
#line 233
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 235
  tmp___39 = strcmp((char const   *)d->buf, (char const   *)(rule));
  }
#line 235
  if (tmp___39) {
    {
#line 235
    tmp___38 = strcmp((char const   *)d->buf, "\n");
    }
#line 235
    if (tmp___38) {
#line 235
      tmp___37 = 10;
    } else {
#line 235
      tmp___37 = 11;
    }
#line 235
    doc_part = (enum doc_part )tmp___37;
  } else {
#line 235
    doc_part = (enum doc_part )12;
  }
#line 240
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 242
  tmp___41 = strcmp((char const   *)d->buf, "\n");
  }
#line 242
  if (tmp___41) {
#line 242
    doc_part = (enum doc_part )10;
  } else {
#line 242
    doc_part = (enum doc_part )13;
  }
#line 245
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 247
  tmp___49 = strcmp((char const   *)d->buf, "THE RAMIFICATION\n");
  }
#line 247
  if (tmp___49) {
    {
#line 247
    tmp___48 = strcmp((char const   *)d->buf, (char const   *)(rule));
    }
#line 247
    if (tmp___48) {
      {
#line 247
      tmp___46 = strcmp((char const   *)d->buf, "\n");
      }
#line 247
      if (tmp___46) {
#line 247
        tmp___45 = 10;
      } else {
#line 247
        tmp___45 = 11;
      }
#line 247
      tmp___47 = tmp___45;
    } else {
#line 247
      tmp___47 = 12;
    }
#line 247
    doc_part = (enum doc_part )tmp___47;
  } else {
#line 247
    doc_part = (enum doc_part )14;
  }
#line 254
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 256
  tmp___51 = strcmp((char const   *)d->buf, "\n");
  }
#line 256
  if (tmp___51) {
#line 256
    doc_part = (enum doc_part )10;
  } else {
#line 256
    doc_part = (enum doc_part )15;
  }
#line 259
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 261
  tmp___56 = strcmp((char const   *)d->buf, (char const   *)(rule));
  }
#line 261
  if (tmp___56) {
    {
#line 261
    tmp___55 = strcmp((char const   *)d->buf, "\n");
    }
#line 261
    if (tmp___55) {
#line 261
      tmp___54 = 10;
    } else {
#line 261
      tmp___54 = 11;
    }
#line 261
    doc_part = (enum doc_part )tmp___54;
  } else {
#line 261
    doc_part = (enum doc_part )16;
  }
#line 266
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 269
  tmp___61 = begins_with_ramno(d->buf);
  }
#line 269
  if (tmp___61) {
#line 269
    doc_part = (enum doc_part )17;
  } else {
    {
#line 269
    tmp___60 = strcmp((char const   *)d->buf, "CROSS-REFERENCE (SEE ALSO)\n");
    }
#line 269
    if (tmp___60) {
#line 269
      tmp___59 = 0;
    } else {
#line 269
      tmp___59 = 21;
    }
#line 269
    doc_part = (enum doc_part )tmp___59;
  }
#line 274
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 276
  tmp___63 = strcmp((char const   *)d->buf, (char const   *)(rule));
  }
#line 276
  if (tmp___63) {
#line 276
    doc_part = (enum doc_part )0;
  } else {
#line 276
    doc_part = (enum doc_part )18;
  }
#line 279
  goto switch_break;
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  {
#line 282
  tmp___65 = strcmp((char const   *)d->buf, "\n");
  }
#line 282
  if (tmp___65) {
#line 282
    doc_part = (enum doc_part )19;
  } else {
#line 282
    doc_part = (enum doc_part )20;
  }
#line 285
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 287
  tmp___67 = strcmp((char const   *)d->buf, (char const   *)(rule));
  }
#line 287
  if (tmp___67) {
#line 287
    doc_part = (enum doc_part )0;
  } else {
#line 287
    doc_part = (enum doc_part )16;
  }
#line 290
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 293
  tmp___69 = strcmp((char const   *)d->buf, (char const   *)(rule));
  }
#line 293
  if (tmp___69) {
#line 293
    doc_part = (enum doc_part )0;
  } else {
#line 293
    doc_part = (enum doc_part )22;
  }
#line 296
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 298
  tmp___71 = strcmp((char const   *)d->buf, "\n");
  }
#line 298
  if (tmp___71) {
#line 298
    doc_part = (enum doc_part )0;
  } else {
#line 298
    doc_part = (enum doc_part )23;
  }
#line 301
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 304
  tmp___76 = begins_with_ramno(d->buf);
  }
#line 304
  if (tmp___76) {
#line 304
    doc_part = (enum doc_part )25;
  } else {
    {
#line 304
    tmp___75 = strcmp((char const   *)d->buf, "\n");
    }
#line 304
    if (tmp___75) {
#line 304
      tmp___74 = 24;
    } else {
#line 304
      tmp___74 = 23;
    }
#line 304
    doc_part = (enum doc_part )tmp___74;
  }
#line 309
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 311
  tmp___78 = strcmp((char const   *)d->buf, "\n");
  }
#line 311
  if (tmp___78) {
#line 311
    doc_part = (enum doc_part )24;
  } else {
#line 311
    doc_part = (enum doc_part )23;
  }
#line 314
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 317
  tmp___80 = begins_with_ramno(d->buf);
  }
#line 317
  if (tmp___80) {
#line 317
    doc_part = (enum doc_part )25;
  } else {
#line 317
    doc_part = (enum doc_part )26;
  }
#line 320
  goto switch_break;
  case_26: /* CIL Label */ 
#line 322
  goto switch_break;
  case_27: /* CIL Label */ 
#line 325
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 328
  error(1, 0, "impossible, datum.c get_datum()");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 347
  pp_init((char */* const  */)d->buf);
  }
  {
#line 350
  if ((unsigned int )doc_part == 0U) {
#line 350
    goto case_0___0;
  }
#line 358
  if ((unsigned int )doc_part == 25U) {
#line 358
    goto case_25___0;
  }
#line 358
  if ((unsigned int )doc_part == 9U) {
#line 358
    goto case_25___0;
  }
#line 394
  if ((unsigned int )doc_part == 17U) {
#line 394
    goto case_17___0;
  }
#line 413
  if ((unsigned int )doc_part == 19U) {
#line 413
    goto case_19___0;
  }
#line 438
  if ((unsigned int )doc_part == 20U) {
#line 438
    goto case_20___0;
  }
#line 442
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
  {
#line 351
  error(5, 0, "cannot parse the library data file (stage %d)", (unsigned int )doc_part);
  }
#line 356
  goto switch_break___0;
  case_25___0: /* CIL Label */ 
  case_9___0: /* CIL Label */ 
  {
#line 359
  d->ram = pp;
#line 360
  d->ramX = pp_addn((int const   )4);
#line 361
  d->indent = pp_incr();
  }
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! ((int )*pp == 32)) {
#line 362
      goto while_break;
    }
#line 362
    pp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  d->indentX = pp;
#line 364
  d->title = pp;
#line 365
  if ((unsigned int )doc_part == 9U) {
    {
#line 366
    d->type = (enum datum_type )3;
#line 367
    tmp___81 = end_of_line(pp);
#line 367
    d->titleX = pp_set((char */* const  */)tmp___81);
    }
  } else {
#line 370
    arrowX = (char *)0;
#line 371
    d->type = (enum datum_type )4;
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 372
      if (*pp) {
#line 372
        if ((int )*pp != 10) {
          {
#line 372
          arrowX = begins_with_arrow(pp);
          }
#line 372
          if (arrowX) {
#line 372
            goto while_break___0;
          }
        } else {
#line 372
          goto while_break___0;
        }
      } else {
#line 372
        goto while_break___0;
      }
#line 375
      pp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 376
    d->titleX = pp;
#line 377
    if (arrowX) {
      {
#line 378
      d->arrow = pp;
#line 379
      d->arrowX = pp_set((char */* const  */)arrowX);
#line 380
      d->xrefs = pp;
#line 383
      i = 0;
      }
      {
#line 383
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 383
        if (i < 13) {
          {
#line 383
          tmp___82 = begins_with_ramno(pp);
          }
#line 383
          if (! tmp___82) {
#line 383
            goto while_break___1;
          }
        } else {
#line 383
          goto while_break___1;
        }
        {
#line 387
        d->xref[i] = pp;
#line 383
        pp_addn((int const   )5);
#line 383
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 389
      d->xrefsX = pp;
    }
  }
#line 392
  goto switch_break___0;
  case_17___0: /* CIL Label */ 
  {
#line 395
  d->type = (enum datum_type )2;
#line 396
  d->ram = pp;
#line 397
  d->ramX = pp_addn((int const   )4);
#line 398
  d->title_uc = pp_incr();
#line 399
  tmp___83 = end_of_line(pp);
#line 399
  pp_set((char */* const  */)(tmp___83 - 1));
  }
  {
#line 400
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 400
    if (*pp) {
#line 400
      if (! ((int )*pp != 41)) {
#line 400
        goto while_break___2;
      }
    } else {
#line 400
      goto while_break___2;
    }
#line 401
    pp --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 402
  d->countX = pp;
  {
#line 403
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 403
    if (*pp) {
#line 403
      if (! ((int )*pp != 40)) {
#line 403
        goto while_break___3;
      }
    } else {
#line 403
      goto while_break___3;
    }
#line 404
    pp --;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 405
  d->count = pp_incr();
#line 406
  pp_addn((int const   )-2);
  }
  {
#line 407
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 407
    if (! ((int )*pp == 32)) {
#line 407
      goto while_break___4;
    }
#line 407
    pp --;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 408
  d->title_ucX = pp_incr();
#line 409
  strncpy((char */* __restrict  */)(ram_s), (char const   */* __restrict  */)d->ram,
          (size_t )4);
#line 410
  ram_s[4] = (char )'\000';
  }
#line 411
  goto switch_break___0;
  case_19___0: /* CIL Label */ 
  {
#line 414
  d->type = (enum datum_type )1;
#line 415
  d->maint = pp;
#line 416
  d->maintX = last_nonspace((char const   */* const  */)pp, pp + 15);
#line 417
  d->pri = pp_addn((int const   )18);
#line 418
  d->priX = pp_addn((int const   )3);
#line 419
  d->deb = pp_addn((int const   )3);
#line 420
  tmp___84 = next_space(pp);
#line 420
  d->debX = pp_set((char */* const  */)tmp___84);
#line 422
  a = pp + 1;
#line 423
  b = (d->deb + 28) + 1;
  }
#line 424
  if ((unsigned long )a >= (unsigned long )b) {
#line 424
    tmp___85 = a;
  } else {
#line 424
    tmp___85 = b;
  }
  {
#line 424
  d->desc = pp_set((char */* const  */)tmp___85);
#line 426
  tmp___86 = end_of_line(pp);
#line 426
  d->descX = pp_set((char */* const  */)tmp___86);
#line 433
  tmp___89 = (char )'\000';
#line 433
  *(d->pri + -1) = tmp___89;
#line 433
  tmp___88 = tmp___89;
#line 433
  *(d->deb + -1) = tmp___88;
#line 433
  tmp___87 = tmp___88;
#line 433
  *(d->desc + -1) = tmp___87;
#line 433
  *(d->descX + 0) = tmp___87;
  }
#line 434
  if (opt.no_desc) {
#line 434
    *(d->debX + 0) = (char )'\000';
  } else
#line 434
  if (! opt.wide) {
#line 434
    *(d->debX + 0) = (char )'\000';
  }
  {
#line 435
  strncpy((char */* __restrict  */)(d->ram_s), (char const   */* __restrict  */)(ram_s),
          (size_t )5);
  }
#line 436
  goto switch_break___0;
  case_20___0: /* CIL Label */ 
#line 439
  ram_s[0] = (char )'\000';
#line 440
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 442
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 445
  pp_clear();
  }
#line 447
  if (d->type) {
#line 447
    tmp___90 = d;
  } else {
#line 447
    tmp___90 = (struct datum *)0;
  }
#line 447
  return (tmp___90);
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/datum.c"
void rewind_data(void) 
{ 


  {
  {
#line 452
  rewind_ldf();
#line 453
  init_datum((struct datum *)0);
#line 454
  doc_part = (enum doc_part )1;
#line 455
  ram_s[0] = (char )'\000';
  }
#line 456
  return;
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/prdeb.h"
void print_deb(int find , struct datum  const  *d ) ;
#line 106 "/usr/include/search.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) hsearch_r)(ENTRY __item ,
                                                                                ACTION __action ,
                                                                                ENTRY **__retval ,
                                                                                struct hsearch_data *__htab ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/sel.h"
struct hsearch_data sel ;
#line 99 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/color.h"
char *color2(char *s , char const   * const  p , char const   *cs , char const   *cp ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/prdeb.c"
void print_deb(int find , struct datum  const  *d ) 
{ 
  ENTRY entry ;
  ENTRY *ep ;
  char deb[133] ;
  int tmp ;
  char *max ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  char *tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  char *tmp___36 ;
  char const   *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char const   *tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;

  {
#line 20
  if (! d) {
#line 20
    d = (struct datum  const  *)(& datum);
  }
#line 21
  if (opt.no_title) {
#line 21
    find = 0;
  }
#line 23
  if (opt.selections) {
    {
#line 26
    strxcpy(deb, (char const   *)datum.deb, (char const   *)datum.debX);
#line 27
    entry.key = deb;
#line 28
    entry.data = (void *)0;
#line 29
    tmp = hsearch_r(entry, (ACTION )0, & ep, & sel);
    }
#line 29
    if (! tmp) {
#line 29
      return;
    }
  }
#line 32
  if (opt.wide) {
#line 33
    if (find) {
#line 33
      tmp___0 = -5;
    } else {
#line 33
      tmp___0 = 0;
    }
#line 33
    max = (datum.buf + 132) + tmp___0;
#line 35
    if ((unsigned long )datum.descX > (unsigned long )max) {
#line 36
      datum.descX = max;
#line 37
      *(datum.descX) = (char )'\000';
    }
#line 39
    if ((unsigned long )datum.desc > (unsigned long )datum.descX) {
#line 39
      datum.desc = datum.descX;
    }
  }
#line 42
  if (find) {
#line 42
    if (! opt.no_title) {
#line 42
      if (opt.color) {
#line 42
        tmp___1 = "\033[22;37m";
      } else {
#line 42
        tmp___1 = "";
      }
      {
#line 42
      printf((char const   */* __restrict  */)"%s%s ", tmp___1, datum.ram_s);
      }
    }
  }
#line 46
  if (! opt.no_maint) {
#line 46
    if (opt.utf8) {
      {
#line 46
      tmp___2 = color2(datum.maint, (char const   *)datum.maintX, "\033[22;33m", "\033[02;37m");
#line 46
      tmp___3 = utf8((char *)0, (size_t )0, 1, tmp___2);
#line 46
      tmp___5 = tmp___3;
      }
    } else {
      {
#line 46
      tmp___4 = color2(datum.maint, (char const   *)datum.maintX, "\033[22;33m", "\033[02;37m");
#line 46
      tmp___5 = tmp___4;
      }
    }
    {
#line 46
    printf((char const   */* __restrict  */)"%s ", tmp___5);
    }
  }
#line 50
  if (! opt.no_pri) {
#line 50
    if (opt.utf8) {
#line 50
      if (opt.color) {
#line 50
        if (opt.pri_one_color) {
#line 50
          tmp___12 = "\033[22;36m";
        } else {
          {
#line 50
          tmp___11 = strncmp((char const   *)datum.pri, "opt", (size_t )3);
          }
#line 50
          if (tmp___11) {
            {
#line 50
            tmp___9 = strncmp((char const   *)datum.pri, "ext", (size_t )3);
            }
#line 50
            if (tmp___9) {
#line 50
              tmp___8 = "\033[01;33m";
            } else {
#line 50
              tmp___8 = "\033[02;37m";
            }
#line 50
            tmp___10 = tmp___8;
          } else {
#line 50
            tmp___10 = "\033[22;36m";
          }
#line 50
          tmp___12 = tmp___10;
        }
#line 50
        tmp___13 = tmp___12;
      } else {
#line 50
        tmp___13 = "";
      }
      {
#line 50
      tmp___14 = color2(datum.pri, (char const   *)datum.priX, tmp___13, "\033[02;37m");
#line 50
      tmp___15 = utf8((char *)0, (size_t )0, 1, tmp___14);
#line 50
      tmp___25 = tmp___15;
      }
    } else {
#line 50
      if (opt.color) {
#line 50
        if (opt.pri_one_color) {
#line 50
          tmp___22 = "\033[22;36m";
        } else {
          {
#line 50
          tmp___21 = strncmp((char const   *)datum.pri, "opt", (size_t )3);
          }
#line 50
          if (tmp___21) {
            {
#line 50
            tmp___19 = strncmp((char const   *)datum.pri, "ext", (size_t )3);
            }
#line 50
            if (tmp___19) {
#line 50
              tmp___18 = "\033[01;33m";
            } else {
#line 50
              tmp___18 = "\033[02;37m";
            }
#line 50
            tmp___20 = tmp___18;
          } else {
#line 50
            tmp___20 = "\033[22;36m";
          }
#line 50
          tmp___22 = tmp___20;
        }
#line 50
        tmp___23 = tmp___22;
      } else {
#line 50
        tmp___23 = "";
      }
      {
#line 50
      tmp___24 = color2(datum.pri, (char const   *)datum.priX, tmp___23, "\033[02;37m");
#line 50
      tmp___25 = tmp___24;
      }
    }
    {
#line 50
    printf((char const   */* __restrict  */)"%s ", tmp___25);
    }
  }
#line 60
  if (opt.utf8) {
    {
#line 60
    tmp___26 = color2(datum.deb, (char const   *)datum.debX, "\033[01;37m", "\033[02;37m");
#line 60
    tmp___27 = utf8((char *)0, (size_t )0, 1, tmp___26);
#line 60
    tmp___29 = tmp___27;
    }
  } else {
    {
#line 60
    tmp___28 = color2(datum.deb, (char const   *)datum.debX, "\033[01;37m", "\033[02;37m");
#line 60
    tmp___29 = tmp___28;
    }
  }
  {
#line 60
  printf((char const   */* __restrict  */)"%s", tmp___29);
  }
#line 64
  if (! opt.no_desc) {
#line 64
    if (opt.wide) {
#line 64
      tmp___31 = "";
    } else {
#line 64
      if (opt.color) {
#line 64
        tmp___30 = "\033[0m\033[m\n";
      } else {
#line 64
        tmp___30 = "\n";
      }
#line 64
      tmp___31 = tmp___30;
    }
#line 64
    if (opt.utf8) {
#line 64
      tmp___34 = "";
    } else {
#line 64
      if (opt.color) {
#line 64
        tmp___32 = "\033[22;37m";
      } else {
#line 64
        tmp___32 = "";
      }
      {
#line 64
      tmp___33 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___32, (char */* const  */)datum.desc);
#line 64
      tmp___34 = (char const   *)tmp___33;
      }
    }
#line 64
    if (opt.utf8) {
#line 64
      if (opt.color) {
#line 64
        tmp___35 = "\033[22;37m";
      } else {
#line 64
        tmp___35 = "";
      }
      {
#line 64
      tmp___36 = utf8((char *)0, (size_t )0, 2, tmp___35, datum.desc);
#line 64
      tmp___39 = tmp___36;
      }
    } else {
#line 64
      if (opt.color) {
#line 64
        tmp___37 = "\033[22;37m";
      } else {
#line 64
        tmp___37 = "";
      }
      {
#line 64
      tmp___38 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___37, (char */* const  */)datum.desc);
#line 64
      tmp___39 = tmp___38;
      }
    }
#line 64
    if (opt.wide) {
#line 64
      tmp___41 = " ";
    } else {
#line 64
      if (opt.color) {
#line 64
        tmp___40 = "\033[0m\033[m\n";
      } else {
#line 64
        tmp___40 = "\n";
      }
#line 64
      tmp___41 = tmp___40;
    }
    {
#line 64
    printf((char const   */* __restrict  */)"%s%s%s%s", tmp___41, tmp___39, tmp___34,
           tmp___31);
    }
  }
#line 70
  if (opt.color) {
#line 70
    tmp___42 = "\033[0m\033[m\n";
  } else {
#line 70
    tmp___42 = "\n";
  }
  {
#line 70
  printf((char const   */* __restrict  */)"%s", tmp___42);
  }
#line 72
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/find.h"
void print_find(void) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/strx.h"
int strxcmp(char const   *d , char const   *s , char const   * const  x ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/find.c"
void print_find(void) 
{ 
  int print ;
  struct name_cl **first[3] ;
  char **dname[3] ;
  char **dnameX[3] ;
  int unlink[3] ;
  int i ;
  struct name_cl *prev ;
  struct name_cl *name ;
  int tmp ;
  struct xram *xram ;
  int tmp___0 ;

  {
  {
#line 14
  rewind_data();
  }
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if ((unsigned int )doc_part <= 20U) {
#line 16
      if (! opt.maint_cl_first) {
#line 16
        if (! opt.deb_cl_first) {
#line 16
          goto while_break;
        }
      }
    } else {
#line 16
      goto while_break;
    }
#line 20
    if ((unsigned int )datum.type == 1U) {
#line 22
      print = 0;
#line 25
      first[0] = & opt.maint_cl_first;
#line 25
      first[1] = & opt.deb_cl_first;
#line 25
      first[2] = (struct name_cl **)0;
#line 27
      dname[0] = & datum.maint;
#line 27
      dname[1] = & datum.deb;
#line 27
      dname[2] = (char **)0;
#line 29
      dnameX[0] = & datum.maintX;
#line 29
      dnameX[1] = & datum.debX;
#line 29
      dnameX[2] = (char **)0;
#line 31
      unlink[0] = 0;
#line 31
      unlink[1] = 1;
#line 31
      unlink[2] = 0;
#line 34
      i = 0;
      {
#line 34
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 34
        if (! first[i]) {
#line 34
          goto while_break___0;
        }
#line 35
        name = (struct name_cl *)0;
        {
#line 36
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 37
          if (name) {
#line 37
            prev = name;
#line 37
            name = name->next;
          } else {
#line 38
            prev = (struct name_cl *)0;
#line 38
            name = *(first[i]);
          }
#line 39
          if (! name) {
#line 39
            goto while_break___1;
          }
          {
#line 40
          tmp = strxcmp((char const   *)name->name, (char const   *)*(dname[i]), (char const   *)*(dnameX[i]));
          }
#line 40
          if (! tmp) {
#line 41
            if (unlink[i]) {
#line 42
              if (prev) {
#line 42
                prev->next = name->next;
#line 42
                name = prev;
              } else {
#line 43
                *(first[i]) = name->next;
#line 43
                name = (struct name_cl *)0;
              }
            }
#line 45
            print = 1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 34
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 51
      if (print) {
#line 51
        if (opt.ram_cl_first) {
          {
#line 53
          print = 0;
#line 54
          xram = first_selected((struct xram *)0);
          }
          {
#line 54
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 54
            if (! xram) {
#line 54
              goto while_break___2;
            }
            {
#line 58
            tmp___0 = strncmp((char const   *)(datum.ram_s), (char const   *)(xram->ram),
                              (size_t )4);
            }
#line 58
            if (! tmp___0) {
#line 59
              print = 1;
#line 60
              goto while_break___2;
            }
            {
#line 54
            xram = next_selected(xram);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 64
      if (print) {
        {
#line 64
        print_deb(1, (struct datum  const  *)0);
        }
      }
    }
    {
#line 16
    get_datum((struct datum *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  return;
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/conv.h"
__inline char uc1(char const   c ) ;
#line 10
__inline char lc1(char const   c ) ;
#line 11
__inline char unlat1(char const   c ) ;
#line 12
__inline char undot1(char const   c ) ;
#line 13
char *uc(char *s ) ;
#line 14
char *lc(char *s ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/conv.c"
__inline char uc1(char const   c ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 14
  n = (int )c & 255;
#line 15
  if (n < 97) {
#line 15
    tmp___6 = n;
  } else {
#line 15
    if (n <= 122) {
#line 15
      tmp___5 = n & -33;
    } else {
#line 15
      if (n <= 222) {
#line 15
        tmp___4 = n;
      } else {
#line 15
        if (n <= 223) {
#line 15
          tmp___3 = 'S';
        } else {
#line 15
          if (n <= 246) {
#line 15
            tmp___2 = n & -33;
          } else {
#line 15
            if (n <= 247) {
#line 15
              tmp___1 = n;
            } else {
#line 15
              if (n <= 254) {
#line 15
                tmp___0 = n & -33;
              } else {
#line 15
                if (n <= 255) {
#line 15
                  tmp = 'Y';
                } else {
#line 15
                  tmp = n;
                }
#line 15
                tmp___0 = tmp;
              }
#line 15
              tmp___1 = tmp___0;
            }
#line 15
            tmp___2 = tmp___1;
          }
#line 15
          tmp___3 = tmp___2;
        }
#line 15
        tmp___4 = tmp___3;
      }
#line 15
      tmp___5 = tmp___4;
    }
#line 15
    tmp___6 = tmp___5;
  }
#line 15
  return ((char )tmp___6);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/conv.c"
__inline char lc1(char const   c ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 29
  n = (int )c & 255;
#line 30
  if (n < 65) {
#line 30
    tmp___5 = n;
  } else {
#line 30
    if (n <= 90) {
#line 30
      tmp___4 = n | 32;
    } else {
#line 30
      if (n <= 191) {
#line 30
        tmp___3 = n;
      } else {
#line 30
        if (n <= 214) {
#line 30
          tmp___2 = n | 32;
        } else {
#line 30
          if (n <= 215) {
#line 30
            tmp___1 = n;
          } else {
#line 30
            if (n <= 222) {
#line 30
              tmp___0 = n | 32;
            } else {
#line 30
              if (n <= 255) {
#line 30
                tmp = n;
              } else {
#line 30
                tmp = n;
              }
#line 30
              tmp___0 = tmp;
            }
#line 30
            tmp___1 = tmp___0;
          }
#line 30
          tmp___2 = tmp___1;
        }
#line 30
        tmp___3 = tmp___2;
      }
#line 30
      tmp___4 = tmp___3;
    }
#line 30
    tmp___5 = tmp___4;
  }
#line 30
  return ((char )tmp___5);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/conv.c"
__inline char unlat1(char const   c ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;

  {
#line 51
  n = (int )c & 255;
#line 52
  if (n < 128) {
#line 52
    tmp___54 = n;
  } else {
#line 52
    if (n <= 160) {
#line 52
      tmp___53 = ' ';
    } else {
#line 52
      if (n <= 161) {
#line 52
        tmp___52 = '!';
      } else {
#line 52
        if (n <= 162) {
#line 52
          tmp___51 = 'c';
        } else {
#line 52
          if (n <= 163) {
#line 52
            tmp___50 = '#';
          } else {
#line 52
            if (n <= 164) {
#line 52
              tmp___49 = 'E';
            } else {
#line 52
              if (n <= 165) {
#line 52
                tmp___48 = 'Y';
              } else {
#line 52
                if (n <= 166) {
#line 52
                  tmp___47 = '|';
                } else {
#line 52
                  if (n <= 167) {
#line 52
                    tmp___46 = 'S';
                  } else {
#line 52
                    if (n <= 168) {
#line 52
                      tmp___45 = '\"';
                    } else {
#line 52
                      if (n <= 169) {
#line 52
                        tmp___44 = 'c';
                      } else {
#line 52
                        if (n <= 170) {
#line 52
                          tmp___43 = 'a';
                        } else {
#line 52
                          if (n <= 171) {
#line 52
                            tmp___42 = '<';
                          } else {
#line 52
                            if (n <= 172) {
#line 52
                              tmp___41 = '!';
                            } else {
#line 52
                              if (n <= 173) {
#line 52
                                tmp___40 = '-';
                              } else {
#line 52
                                if (n <= 174) {
#line 52
                                  tmp___39 = 'R';
                                } else {
#line 52
                                  if (n <= 175) {
#line 52
                                    tmp___38 = '-';
                                  } else {
#line 52
                                    if (n <= 176) {
#line 52
                                      tmp___37 = '^';
                                    } else {
#line 52
                                      if (n <= 177) {
#line 52
                                        tmp___36 = '+';
                                      } else {
#line 52
                                        if (n <= 179) {
#line 52
                                          tmp___35 = '^';
                                        } else {
#line 52
                                          if (n <= 180) {
#line 52
                                            tmp___34 = '\'';
                                          } else {
#line 52
                                            if (n <= 181) {
#line 52
                                              tmp___33 = 'u';
                                            } else {
#line 52
                                              if (n <= 182) {
#line 52
                                                tmp___32 = 'P';
                                              } else {
#line 52
                                                if (n <= 183) {
#line 52
                                                  tmp___31 = '.';
                                                } else {
#line 52
                                                  if (n <= 184) {
#line 52
                                                    tmp___30 = ',';
                                                  } else {
#line 52
                                                    if (n <= 185) {
#line 52
                                                      tmp___29 = '^';
                                                    } else {
#line 52
                                                      if (n <= 186) {
#line 52
                                                        tmp___28 = 'o';
                                                      } else {
#line 52
                                                        if (n <= 187) {
#line 52
                                                          tmp___27 = '>';
                                                        } else {
#line 52
                                                          if (n <= 190) {
#line 52
                                                            tmp___26 = '/';
                                                          } else {
#line 52
                                                            if (n <= 191) {
#line 52
                                                              tmp___25 = '?';
                                                            } else {
#line 52
                                                              if (n <= 198) {
#line 52
                                                                tmp___24 = 'A';
                                                              } else {
#line 52
                                                                if (n <= 199) {
#line 52
                                                                  tmp___23 = 'C';
                                                                } else {
#line 52
                                                                  if (n <= 203) {
#line 52
                                                                    tmp___22 = 'E';
                                                                  } else {
#line 52
                                                                    if (n <= 207) {
#line 52
                                                                      tmp___21 = 'I';
                                                                    } else {
#line 52
                                                                      if (n <= 208) {
#line 52
                                                                        tmp___20 = 'D';
                                                                      } else {
#line 52
                                                                        if (n <= 209) {
#line 52
                                                                          tmp___19 = 'N';
                                                                        } else {
#line 52
                                                                          if (n <= 214) {
#line 52
                                                                            tmp___18 = 'O';
                                                                          } else {
#line 52
                                                                            if (n <= 215) {
#line 52
                                                                              tmp___17 = 'x';
                                                                            } else {
#line 52
                                                                              if (n <= 216) {
#line 52
                                                                                tmp___16 = 'O';
                                                                              } else {
#line 52
                                                                                if (n <= 220) {
#line 52
                                                                                  tmp___15 = 'U';
                                                                                } else {
#line 52
                                                                                  if (n <= 221) {
#line 52
                                                                                    tmp___14 = 'Y';
                                                                                  } else {
#line 52
                                                                                    if (n <= 222) {
#line 52
                                                                                      tmp___13 = 'Z';
                                                                                    } else {
#line 52
                                                                                      if (n <= 223) {
#line 52
                                                                                        tmp___12 = 's';
                                                                                      } else {
#line 52
                                                                                        if (n <= 230) {
#line 52
                                                                                          tmp___11 = 'a';
                                                                                        } else {
#line 52
                                                                                          if (n <= 231) {
#line 52
                                                                                            tmp___10 = 'c';
                                                                                          } else {
#line 52
                                                                                            if (n <= 235) {
#line 52
                                                                                              tmp___9 = 'e';
                                                                                            } else {
#line 52
                                                                                              if (n <= 239) {
#line 52
                                                                                                tmp___8 = 'i';
                                                                                              } else {
#line 52
                                                                                                if (n <= 240) {
#line 52
                                                                                                  tmp___7 = 'd';
                                                                                                } else {
#line 52
                                                                                                  if (n <= 241) {
#line 52
                                                                                                    tmp___6 = 'n';
                                                                                                  } else {
#line 52
                                                                                                    if (n <= 246) {
#line 52
                                                                                                      tmp___5 = 'o';
                                                                                                    } else {
#line 52
                                                                                                      if (n <= 247) {
#line 52
                                                                                                        tmp___4 = ':';
                                                                                                      } else {
#line 52
                                                                                                        if (n <= 248) {
#line 52
                                                                                                          tmp___3 = 'o';
                                                                                                        } else {
#line 52
                                                                                                          if (n <= 252) {
#line 52
                                                                                                            tmp___2 = 'u';
                                                                                                          } else {
#line 52
                                                                                                            if (n <= 253) {
#line 52
                                                                                                              tmp___1 = 'y';
                                                                                                            } else {
#line 52
                                                                                                              if (n <= 254) {
#line 52
                                                                                                                tmp___0 = 'z';
                                                                                                              } else {
#line 52
                                                                                                                if (n <= 255) {
#line 52
                                                                                                                  tmp = 'y';
                                                                                                                } else {
#line 52
                                                                                                                  tmp = n & 127;
                                                                                                                }
#line 52
                                                                                                                tmp___0 = tmp;
                                                                                                              }
#line 52
                                                                                                              tmp___1 = tmp___0;
                                                                                                            }
#line 52
                                                                                                            tmp___2 = tmp___1;
                                                                                                          }
#line 52
                                                                                                          tmp___3 = tmp___2;
                                                                                                        }
#line 52
                                                                                                        tmp___4 = tmp___3;
                                                                                                      }
#line 52
                                                                                                      tmp___5 = tmp___4;
                                                                                                    }
#line 52
                                                                                                    tmp___6 = tmp___5;
                                                                                                  }
#line 52
                                                                                                  tmp___7 = tmp___6;
                                                                                                }
#line 52
                                                                                                tmp___8 = tmp___7;
                                                                                              }
#line 52
                                                                                              tmp___9 = tmp___8;
                                                                                            }
#line 52
                                                                                            tmp___10 = tmp___9;
                                                                                          }
#line 52
                                                                                          tmp___11 = tmp___10;
                                                                                        }
#line 52
                                                                                        tmp___12 = tmp___11;
                                                                                      }
#line 52
                                                                                      tmp___13 = tmp___12;
                                                                                    }
#line 52
                                                                                    tmp___14 = tmp___13;
                                                                                  }
#line 52
                                                                                  tmp___15 = tmp___14;
                                                                                }
#line 52
                                                                                tmp___16 = tmp___15;
                                                                              }
#line 52
                                                                              tmp___17 = tmp___16;
                                                                            }
#line 52
                                                                            tmp___18 = tmp___17;
                                                                          }
#line 52
                                                                          tmp___19 = tmp___18;
                                                                        }
#line 52
                                                                        tmp___20 = tmp___19;
                                                                      }
#line 52
                                                                      tmp___21 = tmp___20;
                                                                    }
#line 52
                                                                    tmp___22 = tmp___21;
                                                                  }
#line 52
                                                                  tmp___23 = tmp___22;
                                                                }
#line 52
                                                                tmp___24 = tmp___23;
                                                              }
#line 52
                                                              tmp___25 = tmp___24;
                                                            }
#line 52
                                                            tmp___26 = tmp___25;
                                                          }
#line 52
                                                          tmp___27 = tmp___26;
                                                        }
#line 52
                                                        tmp___28 = tmp___27;
                                                      }
#line 52
                                                      tmp___29 = tmp___28;
                                                    }
#line 52
                                                    tmp___30 = tmp___29;
                                                  }
#line 52
                                                  tmp___31 = tmp___30;
                                                }
#line 52
                                                tmp___32 = tmp___31;
                                              }
#line 52
                                              tmp___33 = tmp___32;
                                            }
#line 52
                                            tmp___34 = tmp___33;
                                          }
#line 52
                                          tmp___35 = tmp___34;
                                        }
#line 52
                                        tmp___36 = tmp___35;
                                      }
#line 52
                                      tmp___37 = tmp___36;
                                    }
#line 52
                                    tmp___38 = tmp___37;
                                  }
#line 52
                                  tmp___39 = tmp___38;
                                }
#line 52
                                tmp___40 = tmp___39;
                              }
#line 52
                              tmp___41 = tmp___40;
                            }
#line 52
                            tmp___42 = tmp___41;
                          }
#line 52
                          tmp___43 = tmp___42;
                        }
#line 52
                        tmp___44 = tmp___43;
                      }
#line 52
                      tmp___45 = tmp___44;
                    }
#line 52
                    tmp___46 = tmp___45;
                  }
#line 52
                  tmp___47 = tmp___46;
                }
#line 52
                tmp___48 = tmp___47;
              }
#line 52
              tmp___49 = tmp___48;
            }
#line 52
            tmp___50 = tmp___49;
          }
#line 52
          tmp___51 = tmp___50;
        }
#line 52
        tmp___52 = tmp___51;
      }
#line 52
      tmp___53 = tmp___52;
    }
#line 52
    tmp___54 = tmp___53;
  }
#line 52
  return ((char )tmp___54);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/conv.c"
__inline char undot1(char const   c ) 
{ 
  int tmp ;

  {
#line 114
  if ((int const   )c == -73) {
#line 114
    tmp = ' ';
  } else {
#line 114
    tmp = (int )c;
  }
#line 114
  return ((char )tmp);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/conv.c"
char *uc(char *s ) 
{ 
  char *o ;

  {
#line 118
  o = s;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! *s) {
#line 119
      goto while_break;
    }
    {
#line 119
    *s = uc1((char const   )*s);
#line 119
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return (o);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/conv.c"
char *lc(char *s ) 
{ 
  char *o ;

  {
#line 124
  o = s;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! *s) {
#line 125
      goto while_break;
    }
    {
#line 125
    *s = lc1((char const   )*s);
#line 125
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return (o);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/conv.c"
char *unlat(char *s ) 
{ 
  char *o ;

  {
#line 130
  o = s;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! *s) {
#line 131
      goto while_break;
    }
    {
#line 131
    *s = unlat1((char const   )*s);
#line 131
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return (o);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/conv.c"
char *undot(char *s , char const   c ) 
{ 
  char *o ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 140
  o = s;
#line 141
  p = s;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (*s) {
#line 142
      if (! ((int )*s != 10)) {
#line 142
        goto while_break;
      }
    } else {
#line 142
      goto while_break;
    }
#line 143
    if (p) {
#line 144
      if ((int )*s == 32) {
        {
#line 145
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 145
          if (! ((unsigned long )p < (unsigned long )s)) {
#line 145
            goto while_break___0;
          }
#line 145
          tmp = p;
#line 145
          p ++;
#line 145
          *tmp = (char )c;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 146
        p ++;
      } else
#line 148
      if ((int )*s != -73) {
#line 148
        p = (char *)0;
      }
    } else
#line 150
    if ((int )*s == 32) {
#line 150
      p = s + 1;
    }
#line 142
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  if (p) {
    {
#line 151
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 151
      if (! ((unsigned long )p < (unsigned long )s)) {
#line 151
        goto while_break___1;
      }
#line 151
      tmp___0 = p;
#line 151
      p ++;
#line 151
      *tmp___0 = (char )c;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 152
  return (o);
}
}
#line 108 "/usr/include/search.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) hcreate_r)(size_t __nel ,
                                                                                struct hsearch_data *__htab ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/sel.h"
struct hsearch_data sel  ;
#line 20
int set_selections(void) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/sel.c"
int set_selections(void) 
{ 
  int n_sel ;
  char name[514] ;
  int tmp ;
  char *tmp___0 ;
  char *p ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int possible_dpkg_format ;
  char *p___0 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *q ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  ENTRY entry ;
  ENTRY *ep ;
  size_t tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 18
  n_sel = 0;
#line 20
  tmp = hcreate_r((size_t )32768, & sel);
  }
#line 20
  if (! tmp) {
    {
#line 20
    error(1, 0, "cannot create selection hash");
    }
  }
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 25
    tmp___14 = fgets((char */* __restrict  */)(name), 514, (FILE */* __restrict  */)stdin);
    }
#line 25
    if (! tmp___14) {
#line 25
      goto while_break;
    }
    {
#line 27
    tmp___0 = strchr((char const   *)(name), '\n');
    }
#line 27
    if (! tmp___0) {
      {
#line 28
      error(5, 0, "%s\n%s", "improper selection", name);
      }
    }
    {
#line 31
    tmp___2 = __ctype_b_loc();
    }
#line 31
    if ((int const   )*(*tmp___2 + (int )name[0]) & 8192) {
#line 32
      p = name;
      {
#line 33
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 33
        p ++;
#line 33
        if (! *p) {
#line 33
          goto while_break___0;
        }
        {
#line 33
        tmp___1 = __ctype_b_loc();
        }
#line 33
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
          {
#line 34
          error(5, 0, "%s\n%s", "improper selection", name);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 35
      goto while_continue;
    }
#line 40
    possible_dpkg_format = 0;
#line 41
    p___0 = name;
    {
#line 42
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 42
      tmp___3 = __ctype_b_loc();
      }
#line 42
      if ((int const   )*(*tmp___3 + (int )*p___0) & 8192) {
#line 42
        goto while_break___1;
      }
#line 42
      p___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 43
    if ((int )*p___0 != 10) {
#line 43
      possible_dpkg_format = 1;
    }
#line 44
    tmp___4 = p___0;
#line 44
    p___0 ++;
#line 44
    *tmp___4 = (char )'\000';
#line 45
    if (possible_dpkg_format) {
      {
#line 46
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 46
        tmp___5 = __ctype_b_loc();
        }
#line 46
        if ((int const   )*(*tmp___5 + (int )*p___0) & 8192) {
#line 46
          if (! ((int )*p___0 != 10)) {
#line 46
            goto while_break___2;
          }
        } else {
#line 46
          goto while_break___2;
        }
#line 46
        p___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 47
      if ((int )*p___0 != 10) {
#line 48
        q = p___0;
        {
#line 49
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 49
          tmp___6 = __ctype_b_loc();
          }
#line 49
          if ((int const   )*(*tmp___6 + (int )*q) & 8192) {
#line 49
            goto while_break___3;
          }
#line 49
          q ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 50
        tmp___7 = q;
#line 50
        q ++;
#line 50
        *tmp___7 = (char )'\000';
        {
#line 51
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 51
          if (! *q) {
#line 51
            goto while_break___4;
          }
          {
#line 51
          tmp___8 = __ctype_b_loc();
#line 51
          tmp___9 = q;
#line 51
          q ++;
          }
#line 51
          if (! ((int const   )*(*tmp___8 + (int )*tmp___9) & 8192)) {
            {
#line 52
            error(5, 0, "%s\n%s", "improper selection", name);
            }
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 53
        tmp___10 = strcmp("install", (char const   *)p___0);
        }
#line 53
        if (tmp___10) {
#line 56
          goto set_selections_end_input_line;
        }
      }
    }
    {
#line 65
    tmp___11 = strlen((char const   *)(name));
#line 65
    tmp___12 = malloc2((size_t const   )(tmp___11 + 1UL));
#line 65
    entry.key = (char *)tmp___12;
#line 66
    strcpy((char */* __restrict  */)entry.key, (char const   */* __restrict  */)(name));
#line 67
    entry.data = (void *)0;
#line 68
    tmp___13 = hsearch_r(entry, (ACTION )1, & ep, & sel);
    }
#line 68
    if (! tmp___13) {
      {
#line 68
      error(12, 0, "too many package names to -s");
      }
    }
#line 74
    n_sel ++;
    set_selections_end_input_line: ;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (n_sel);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/main.h"
int main(int argc , char **argv ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.h"
void parse_cl(int argc , char **argv ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/utf8.h"
void locale(void) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/prram.h"
void print_ram(void) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/main.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 16
  parse_cl(argc, argv);
#line 17
  locale();
  }
#line 18
  if (opt.selections) {
    {
#line 18
    set_selections();
    }
  }
  {
#line 19
  xref_pass();
  }
#line 21
  if (opt.plan) {
    {
#line 21
    print_plan();
    }
  } else
#line 22
  if (opt.maint_cl_first) {
    {
#line 22
    print_find();
    }
  } else
#line 22
  if (opt.deb_cl_first) {
    {
#line 22
    print_find();
    }
  } else {
    {
#line 23
    print_ram();
    }
  }
#line 25
  return (0);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/color.c"
static char buf[164]  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/color.c"
char *color2(char *s , char const   * const  p , char const   *cs , char const   *cp ) 
{ 
  char *d ;
  char *cx ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 19
  d = buf;
#line 21
  if (! opt.color) {
#line 21
    return (s);
  }
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    if (*cs) {
#line 22
      if (! ((unsigned long )d < (unsigned long )(& buf[164]))) {
#line 22
        goto while_break;
      }
    } else {
#line 22
      goto while_break;
    }
#line 22
    tmp = d;
#line 22
    d ++;
#line 22
    tmp___0 = cs;
#line 22
    cs ++;
#line 22
    *tmp = (char )*tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 23
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 23
    if (*s) {
#line 23
      if ((unsigned long )d < (unsigned long )(& buf[164])) {
#line 23
        if (! ((unsigned long )s < (unsigned long )p)) {
#line 23
          goto while_break___0;
        }
      } else {
#line 23
        goto while_break___0;
      }
    } else {
#line 23
      goto while_break___0;
    }
#line 23
    tmp___1 = d;
#line 23
    d ++;
#line 23
    tmp___2 = s;
#line 23
    s ++;
#line 23
    *tmp___1 = *tmp___2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 24
  cx = (char *)"\033[0m\033[m";
  {
#line 25
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 25
    if (*cx) {
#line 25
      if (! ((unsigned long )d < (unsigned long )(& buf[164]))) {
#line 25
        goto while_break___1;
      }
    } else {
#line 25
      goto while_break___1;
    }
#line 25
    tmp___3 = d;
#line 25
    d ++;
#line 25
    tmp___4 = cx;
#line 25
    cx ++;
#line 25
    *tmp___3 = *tmp___4;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 26
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 26
    if (*cp) {
#line 26
      if (! ((unsigned long )d < (unsigned long )(& buf[164]))) {
#line 26
        goto while_break___2;
      }
    } else {
#line 26
      goto while_break___2;
    }
#line 26
    tmp___5 = d;
#line 26
    d ++;
#line 26
    tmp___6 = cp;
#line 26
    cp ++;
#line 26
    *tmp___5 = (char )*tmp___6;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 27
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 27
    if (*s) {
#line 27
      if (! ((unsigned long )d < (unsigned long )(& buf[164]))) {
#line 27
        goto while_break___3;
      }
    } else {
#line 27
      goto while_break___3;
    }
#line 27
    tmp___7 = d;
#line 27
    d ++;
#line 27
    tmp___8 = s;
#line 27
    s ++;
#line 27
    *tmp___7 = *tmp___8;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 28
  cx = (char *)"\033[0m\033[m";
  {
#line 29
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 29
    if (*cx) {
#line 29
      if (! ((unsigned long )d < (unsigned long )(& buf[164]))) {
#line 29
        goto while_break___4;
      }
    } else {
#line 29
      goto while_break___4;
    }
#line 29
    tmp___9 = d;
#line 29
    d ++;
#line 29
    tmp___10 = cx;
#line 29
    cx ++;
#line 29
    *tmp___9 = *tmp___10;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 30
  *d = (char )'\000';
#line 31
  return (buf);
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/strx.c"
char *strxcpy(char *d , char const   *s , char const   * const  x ) 
{ 
  char *ret ;
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 10
  ret = d;
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11
    if ((unsigned long )s < (unsigned long )x) {
#line 11
      if (! *s) {
#line 11
        goto while_break;
      }
    } else {
#line 11
      goto while_break;
    }
#line 11
    tmp = d;
#line 11
    d ++;
#line 11
    tmp___0 = s;
#line 11
    s ++;
#line 11
    *tmp = (char )*tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 12
  *d = (char )'\000';
#line 13
  return (ret);
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/strx.c"
int strxcmp(char const   *d , char const   *s , char const   * const  x ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! ((unsigned long )s < (unsigned long )x)) {
#line 18
      goto while_break;
    }
#line 19
    if ((int const   )*d != (int const   )*s) {
#line 19
      if ((int const   )*d < (int const   )*s) {
#line 19
        tmp = -1;
      } else {
#line 19
        tmp = 1;
      }
#line 19
      return (tmp);
    }
#line 20
    if (! *d) {
#line 20
      if (! *s) {
#line 20
        return (0);
      }
    }
#line 18
    d ++;
#line 18
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 22
  if (*d) {
#line 22
    tmp___0 = 1;
  } else {
#line 22
    tmp___0 = 0;
  }
#line 22
  return (tmp___0);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/alloc.h"
__inline static void *strdup2(char const   *s ) 
{ 
  char *p ;
  char *tmp ;

  {
  {
#line 37
  tmp = strdup(s);
#line 37
  p = tmp;
  }
#line 38
  if (! p) {
    {
#line 38
    error(12, 0, "insufficient heap memory is available");
    }
  }
#line 39
  return ((void *)p);
}
}
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 583 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/utf8.c"
static char (*out0)[824]  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/utf8.c"
static int i_out0  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/utf8.c"
static iconv_t conv_descriptor  =    (iconv_t )-1;
#line 63 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/utf8.c"
__inline static void convert_one_character(char ** const  in , char ** const  out ,
                                           size_t * const  size_out ) 
{ 
  size_t size_in ;
  size_t tmp ;

  {
  {
#line 68
  size_in = (size_t )1;
#line 69
  tmp = iconv(conv_descriptor, (char **/* __restrict  */)in, (size_t */* __restrict  */)(& size_in),
              (char **/* __restrict  */)out, (size_t */* __restrict  */)size_out);
  }
#line 69
  if (tmp == 0xffffffffffffffffUL) {
    {
#line 72
    error(1, 0, "utf-8 conversion failed");
    }
  }
#line 76
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/utf8.c"
char *utf8(char *out , size_t size_out , int n  , ...) 
{ 
  char *out_start ;
  int isownbuf ;
  va_list argp___0 ;
  void *tmp ;
  char *in ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 90
  isownbuf = 0;
#line 94
  if (size_out < 0UL) {
    {
#line 94
    error(1, 0, "internal error: utf8() does not accept negative `size_out\' or `n\'");
    }
  } else
#line 94
  if (n < 0) {
    {
#line 94
    error(1, 0, "internal error: utf8() does not accept negative `size_out\' or `n\'");
    }
  }
#line 103
  if ((unsigned long )conv_descriptor == (unsigned long )((iconv_t )-1)) {
    {
#line 104
    conv_descriptor = iconv_open("UTF8", "LATIN1");
    }
#line 105
    if ((unsigned long )conv_descriptor == (unsigned long )((iconv_t )-1)) {
      {
#line 105
      error(1, 0, "could not initialize the utf-8 conversion");
      }
    }
    {
#line 109
    tmp = malloc2((size_t const   )2408);
#line 109
    out0 = (char (*)[824])tmp;
#line 110
    i_out0 = 0;
    }
  }
#line 114
  if (! out) {
#line 115
    isownbuf = 1;
#line 116
    out = *(out0 + i_out0);
#line 117
    if (! size_out) {
#line 118
      size_out = (size_t )824;
    } else
#line 117
    if (size_out > 824UL) {
#line 118
      size_out = (size_t )824;
    }
  } else
#line 120
  if (! size_out) {
    {
#line 120
    error(1, 0, "internal error: utf8() needs at least one byte of output buffer");
    }
  }
  {
#line 124
  out_start = out;
#line 130
  __builtin_va_start(argp___0, n);
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    tmp___1 = n;
#line 147
    n --;
#line 147
    if (! tmp___1) {
#line 147
      goto while_break;
    }
    {
#line 148
    tmp___0 = __builtin_va_arg(argp___0, char *);
#line 148
    in = tmp___0;
    }
    {
#line 149
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 149
      if (! *in) {
#line 149
        goto while_break___0;
      }
      {
#line 149
      convert_one_character((char **/* const  */)(& in), (char **/* const  */)(& out),
                            (size_t */* const  */)(& size_out));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  in = (char *)"";
#line 152
  convert_one_character((char **/* const  */)(& in), (char **/* const  */)(& out),
                        (size_t */* const  */)(& size_out));
#line 154
  __builtin_va_end(argp___0);
#line 156
  i_out0 = (i_out0 + isownbuf) % 3;
  }
#line 157
  return (out_start);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/utf8.c"
void locale(void) 
{ 
  int locale_c ;
  int code_ascii ;
  int code_latin1 ;
  int code_utf8 ;
  char *lc_ctype ;
  char *codeset ;
  char *locale_orig ;
  char *tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 188
  tmp = setlocale(6, (char const   *)((void *)0));
#line 188
  tmp___0 = strdup2((char const   *)tmp);
#line 188
  locale_orig = (char *)tmp___0;
#line 189
  lc_ctype = setlocale(0, "");
  }
#line 190
  if (lc_ctype) {
#line 190
    tmp___1 = (char const   *)lc_ctype;
  } else {
#line 190
    tmp___1 = "C";
  }
  {
#line 190
  tmp___2 = strdup2(tmp___1);
#line 190
  lc_ctype = (char *)tmp___2;
#line 192
  setlocale(0, (char const   *)lc_ctype);
#line 193
  tmp___3 = nl_langinfo(14);
#line 193
  tmp___4 = strdup2((char const   *)tmp___3);
#line 193
  codeset = (char *)tmp___4;
#line 194
  setlocale(6, (char const   *)locale_orig);
#line 195
  free((void *)locale_orig);
#line 204
  tmp___5 = strcmp((char const   *)lc_ctype, "C");
  }
#line 204
  if (tmp___5) {
    {
#line 204
    tmp___6 = strcmp((char const   *)lc_ctype, "POSIX");
    }
#line 204
    if (tmp___6) {
#line 204
      tmp___7 = 0;
    } else {
#line 204
      tmp___7 = 1;
    }
  } else {
#line 204
    tmp___7 = 1;
  }
  {
#line 204
  locale_c = tmp___7;
#line 206
  tmp___8 = strcmp((char const   *)codeset, "ANSI_X3.4-1968");
  }
#line 206
  if (tmp___8) {
#line 206
    tmp___9 = 0;
  } else {
#line 206
    tmp___9 = 1;
  }
  {
#line 206
  code_ascii = tmp___9;
#line 207
  tmp___10 = strcmp((char const   *)codeset, "ISO-8859-1");
  }
#line 207
  if (tmp___10) {
#line 207
    tmp___11 = 0;
  } else {
#line 207
    tmp___11 = 1;
  }
  {
#line 207
  code_latin1 = tmp___11;
#line 208
  tmp___12 = strcmp((char const   *)codeset, "UTF-8");
  }
#line 208
  if (tmp___12) {
#line 208
    tmp___13 = 0;
  } else {
#line 208
    tmp___13 = 1;
  }
  {
#line 208
  code_utf8 = tmp___13;
#line 209
  free((void *)lc_ctype);
#line 210
  free((void *)codeset);
  }
#line 214
  if (opt.no_latin1) {
#line 214
    return;
  } else
#line 214
  if (opt.latin1) {
#line 214
    return;
  } else
#line 214
  if (opt.utf8) {
#line 214
    return;
  }
#line 215
  if (code_utf8) {
#line 216
    opt.utf8 = 1;
  } else
#line 217
  if (code_latin1) {
#line 218
    opt.latin1 = 1;
  } else
#line 217
  if (locale_c) {
#line 217
    if (code_ascii) {
#line 218
      opt.latin1 = 1;
    } else {
#line 220
      opt.no_latin1 = 1;
#line 221
      opt.ascii_dots = 1;
    }
  } else {
#line 220
    opt.no_latin1 = 1;
#line 221
    opt.ascii_dots = 1;
  }
#line 224
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.h"
char zero_ram[5]  ;
#line 406 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                                                 size_t __maxlen )  __attribute__((__pure__)) ;
#line 404 "/usr/include/argp.h"
extern error_t argp_parse(struct argp  const  * __restrict  __argp , int __argc ,
                          char ** __restrict  __argv , unsigned int __flags , int * __restrict  __arg_index ,
                          void * __restrict  __input ) ;
#line 419
char const   *argp_program_version ;
#line 504
extern void ( /* format attribute */  argp_error)(struct argp_state  const  * __restrict  __state ,
                                                  char const   * __restrict  __fmt 
                                                  , ...) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.c"
struct options opt  = 
#line 33 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.c"
     {(struct ram_cl *)0, (struct name_cl *)0, (struct name_cl *)0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (char *)0, (char *)0};
#line 36 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.c"
char const   *argp_program_version  =    "debram 1.0.3";
#line 41 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.c"
static struct argp_option  const  option[34]  = 
#line 41
  {      {(char const   *)0, 0, (char const   *)0, 0, "Basic output formatting:", 272}, 
        {"wide",
      'w', (char const   *)0, 0, "Output in 132-column format (this is recommended\n  if your terminal is sufficiently wide)",
      273}, 
        {"color", 'c', (char const   *)0, 0, "Color-code the output (recommended)", 273}, 
        {(char const   *)0,
      0, (char const   *)0, 0, "Other general options:", 288}, 
        {"expand-xref", 'x', (char const   *)0, 0, "Print cross-references in long form",
      289}, 
        {"plan", 'p', (char const   *)0, 0, "Print the ramification plan or table of conts",
      289}, 
        {"recursive", 'r', (char const   *)0, 0, "Print the entire tree under the given ram",
      289}, 
        {"trunk", 't', (char const   *)0, 0, "Print the trunk above the given ram", 289}, 
        {"recursive-up",
      't', (char const   *)0, 4, (char const   *)0, 289}, 
        {"maint", 'm', "MAINTAINER", 0, "Print all MAINTAINER\'s .debs", 289}, 
        {"find-deb", 'd', "DEB", 0, "Find package DEB", 289}, 
        {(char const   *)0, 0, (char const   *)0, 0, "Selective output suppression:",
      304}, 
        {"no-end-level", 'A', (char const   *)0, 0, "Omit package tables", 305}, 
        {"only-end-level", 'B', (char const   *)0, 0, "Omit subramification tables",
      305}, 
        {"no-title", 'T', (char const   *)0, 0, "Omit ramification titles", 305}, 
        {"no-xref", 'X', (char const   *)0, 0, "Omit cross-references", 305}, 
        {"no-maint", 'M', (char const   *)0, 0, "Omit names of package maintainers",
      309}, 
        {"no-pri", 'P', (char const   *)0, 0, "Omit package priorities", 309}, 
        {"no-desc", 'D', (char const   *)0, 0, "Omit package descriptions", 309}, 
        {"no-count", 'N', (char const   *)0, 0, "Omit per-ramification .deb counts",
      309}, 
        {"names-only", '1', (char const   *)0, 0, "Print package names only", 317}, 
        {(char const   *)0, 0, (char const   *)0, 0, "Manual character-encoding selection:",
      320}, 
        {"ascii", 'L', (char const   *)0, 0, "Output and accept arguments in ascii",
      321}, 
        {"no-latin1", 'L', (char const   *)0, 4, (char const   *)0, 321}, 
        {"utf8", 'u', (char const   *)0, 0, "Output and accept arguments in utf-8", 321}, 
        {"latin1",
      'l', (char const   *)0, 0, "Output and accept arguments in Latin-1", 321}, 
        {(char const   *)0, 0, (char const   *)0, 0, "Other options:", 336}, 
        {"selections", 's', (char const   *)0, 0, "Print only packages named on stdin (see dpkg(8))",
      337}, 
        {"ascii-dots", '.', (char const   *)0, 0, "In the output, fill blanks with `.\'",
      337}, 
        {"pri-one-color", 'j', (char const   *)0, 2, "Do not differentiate priorities by color",
      529}, 
        {"data-file", 1, "FILE", 2, "Substitute FILE for /usr/share/debram/debram.txt",
      529}, 
        {"data-file-gz", 2, "FILE", 2, "Substitute FILE for /usr/share/debram/debram.txt.gz",
      529}, 
        {(char const   *)0, 0, (char const   *)0, 0, "Metaoptions:", 3328}, 
        {(char const   *)0, 0, (char const   *)0, 0, (char const   *)0, 0}};
#line 197 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.c"
static error_t parse_opt(int key , char *arg , struct argp_state *state ) 
{ 
  enum type_name_cl type_name_cl ;
  int gz ;
  char **data_file ;
  char **tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  struct name_cl **name_cl_first ;
  struct name_cl **tmp___2 ;
  struct name_cl **tmp___3 ;
  struct name_cl *name ;
  void *tmp___4 ;
  struct name_cl *name_last ;
  size_t tmp___5 ;
  void *tmp___6 ;
  struct ram_cl *ram ;
  void *tmp___7 ;
  struct ram_cl *ram_last ;
  int error___0 ;
  int i ;
  char const   *s ;
  char *d ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  int need_ram_cl ;
  void *tmp___13 ;

  {
#line 201
  type_name_cl = (enum type_name_cl )0;
#line 202
  gz = 0;
  {
#line 206
  if (key == 119) {
#line 206
    goto case_119;
  }
#line 207
  if (key == 76) {
#line 207
    goto case_76;
  }
#line 208
  if (key == 117) {
#line 208
    goto case_117;
  }
#line 209
  if (key == 108) {
#line 209
    goto case_108;
  }
#line 210
  if (key == 120) {
#line 210
    goto case_120;
  }
#line 211
  if (key == 112) {
#line 211
    goto case_112;
  }
#line 212
  if (key == 114) {
#line 212
    goto case_114;
  }
#line 213
  if (key == 116) {
#line 213
    goto case_116;
  }
#line 214
  if (key == 65) {
#line 214
    goto case_65;
  }
#line 215
  if (key == 66) {
#line 215
    goto case_66;
  }
#line 216
  if (key == 84) {
#line 216
    goto case_84;
  }
#line 217
  if (key == 88) {
#line 217
    goto case_88;
  }
#line 218
  if (key == 77) {
#line 218
    goto case_77;
  }
#line 219
  if (key == 80) {
#line 219
    goto case_80;
  }
#line 220
  if (key == 68) {
#line 220
    goto case_68;
  }
#line 221
  if (key == 78) {
#line 221
    goto case_78;
  }
#line 222
  if (key == 115) {
#line 222
    goto case_115;
  }
#line 223
  if (key == 99) {
#line 223
    goto case_99;
  }
#line 224
  if (key == 106) {
#line 224
    goto case_106;
  }
#line 225
  if (key == 46) {
#line 225
    goto case_46;
  }
#line 227
  if (key == 49) {
#line 227
    goto case_49;
  }
#line 239
  if (key == 2) {
#line 239
    goto case_2;
  }
#line 240
  if (key == 1) {
#line 240
    goto case_1;
  }
#line 249
  if (key == 109) {
#line 249
    goto case_109;
  }
#line 250
  if (key == 100) {
#line 250
    goto case_100;
  }
#line 267
  if (key == 0) {
#line 267
    goto case_0;
  }
#line 298
  if (key == 16777217) {
#line 298
    goto case_16777217;
  }
#line 352
  goto switch_default;
  case_119: /* CIL Label */ 
#line 206
  opt.wide = 1;
#line 206
  goto switch_break;
  case_76: /* CIL Label */ 
#line 207
  opt.no_latin1 = 1;
#line 207
  goto switch_break;
  case_117: /* CIL Label */ 
#line 208
  opt.utf8 = 1;
#line 208
  goto switch_break;
  case_108: /* CIL Label */ 
#line 209
  opt.latin1 = 1;
#line 209
  goto switch_break;
  case_120: /* CIL Label */ 
#line 210
  opt.expand_xref = 1;
#line 210
  goto switch_break;
  case_112: /* CIL Label */ 
#line 211
  opt.plan = 1;
#line 211
  goto switch_break;
  case_114: /* CIL Label */ 
#line 212
  opt.recursive = 1;
#line 212
  goto switch_break;
  case_116: /* CIL Label */ 
#line 213
  opt.recursive_up = 1;
#line 213
  goto switch_break;
  case_65: /* CIL Label */ 
#line 214
  opt.no_deb = 1;
#line 214
  goto switch_break;
  case_66: /* CIL Label */ 
#line 215
  opt.no_subram = 1;
#line 215
  goto switch_break;
  case_84: /* CIL Label */ 
#line 216
  opt.no_title = 1;
  case_88: /* CIL Label */ 
#line 217
  opt.no_xref = 1;
#line 217
  goto switch_break;
  case_77: /* CIL Label */ 
#line 218
  opt.no_maint = 1;
#line 218
  goto switch_break;
  case_80: /* CIL Label */ 
#line 219
  opt.no_pri = 1;
#line 219
  goto switch_break;
  case_68: /* CIL Label */ 
#line 220
  opt.no_desc = 1;
#line 220
  goto switch_break;
  case_78: /* CIL Label */ 
#line 221
  opt.no_count = 1;
#line 221
  goto switch_break;
  case_115: /* CIL Label */ 
#line 222
  opt.selections = 1;
#line 222
  goto switch_break;
  case_99: /* CIL Label */ 
#line 223
  opt.color = 1;
#line 223
  goto switch_break;
  case_106: /* CIL Label */ 
#line 224
  opt.pri_one_color = 1;
#line 224
  goto switch_break;
  case_46: /* CIL Label */ 
#line 225
  opt.ascii_dots = 1;
#line 225
  goto switch_break;
  case_49: /* CIL Label */ 
#line 228
  opt.no_subram = 1;
#line 229
  opt.no_title = 1;
#line 230
  opt.no_xref = 1;
#line 231
  opt.no_maint = 1;
#line 232
  opt.no_pri = 1;
#line 233
  opt.no_desc = 1;
#line 234
  opt.no_count = 1;
#line 235
  goto switch_break;
  case_2: /* CIL Label */ 
#line 239
  gz = 1;
  case_1: /* CIL Label */ 
#line 242
  if (gz) {
#line 242
    tmp = & opt.data_file_gz;
  } else {
#line 242
    tmp = & opt.data_file;
  }
#line 242
  data_file = tmp;
#line 243
  if (*data_file) {
    {
#line 243
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"ambiguous data-file designation");
    }
  }
  {
#line 246
  tmp___0 = strlen((char const   *)arg);
#line 246
  tmp___1 = malloc2((size_t const   )(tmp___0 + 1UL));
#line 246
  *data_file = strcpy((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)arg);
  }
#line 247
  goto switch_break;
  case_109: /* CIL Label */ 
#line 249
  if (! type_name_cl) {
#line 249
    type_name_cl = (enum type_name_cl )1;
  }
  case_100: /* CIL Label */ 
#line 250
  if (! type_name_cl) {
#line 250
    type_name_cl = (enum type_name_cl )2;
  }
#line 253
  if ((unsigned int )type_name_cl == 1U) {
#line 253
    tmp___3 = & opt.maint_cl_first;
  } else {
#line 253
    if ((unsigned int )type_name_cl == 2U) {
#line 253
      tmp___2 = & opt.deb_cl_first;
    } else {
#line 253
      tmp___2 = (struct name_cl **)0;
    }
#line 253
    tmp___3 = tmp___2;
  }
  {
#line 253
  name_cl_first = tmp___3;
#line 256
  tmp___4 = calloc2((size_t const   )1, (size_t const   )sizeof(struct name_cl ));
#line 256
  name = (struct name_cl *)tmp___4;
#line 258
  name_last = *name_cl_first;
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (name_last) {
#line 259
      if (! name_last->next) {
#line 259
        goto while_break;
      }
    } else {
#line 259
      goto while_break;
    }
#line 260
    name_last = name_last->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  if (name_last) {
#line 261
    name_last->next = name;
  } else {
#line 262
    *name_cl_first = name;
  }
  {
#line 264
  tmp___5 = strlen((char const   *)arg);
#line 264
  tmp___6 = malloc2((size_t const   )(tmp___5 + 1UL));
#line 264
  name->name = strcpy((char */* __restrict  */)tmp___6, (char const   */* __restrict  */)arg);
  }
#line 265
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 269
  tmp___7 = calloc2((size_t const   )1, (size_t const   )sizeof(struct ram_cl ));
#line 269
  ram = (struct ram_cl *)tmp___7;
#line 271
  ram_last = opt.ram_cl_first;
  }
  {
#line 272
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 272
    if (ram_last) {
#line 272
      if (! ram_last->next) {
#line 272
        goto while_break___0;
      }
    } else {
#line 272
      goto while_break___0;
    }
#line 273
    ram_last = ram_last->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 274
  if (ram_last) {
#line 274
    ram_last->next = ram;
  } else {
#line 275
    opt.ram_cl_first = ram;
  }
  {
#line 278
  error___0 = 0;
#line 279
  tmp___12 = strnlen((char const   *)arg, (size_t )5);
  }
#line 279
  if (tmp___12 > 4UL) {
#line 279
    error___0 = 1;
  } else {
#line 281
    i = 4;
#line 282
    s = (char const   *)arg;
#line 283
    d = ram->ram;
    {
#line 284
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 284
      if (! *s) {
#line 284
        goto while_break___1;
      }
      {
#line 285
      tmp___8 = __ctype_b_loc();
      }
#line 285
      if (! ((int const   )*(*tmp___8 + (int )*s) & 2048)) {
#line 285
        error___0 = 1;
      }
#line 286
      tmp___9 = d;
#line 286
      d ++;
#line 286
      tmp___10 = s;
#line 286
      s ++;
#line 286
      *tmp___9 = (char )*tmp___10;
#line 287
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 289
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 289
      if (! i) {
#line 289
        goto while_break___2;
      }
#line 289
      tmp___11 = d;
#line 289
      d ++;
#line 289
      *tmp___11 = (char )'0';
#line 289
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 290
    *d = (char )'\000';
  }
#line 292
  if (error___0) {
    {
#line 292
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"\"%s\" is no ram number",
               arg);
    }
  }
#line 296
  goto switch_break;
  case_16777217: /* CIL Label */ 
#line 300
  need_ram_cl = 1;
#line 303
  if (opt.plan) {
#line 303
    if (opt.deb_cl_first) {
      {
#line 317
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-p conflicts with -dmABTXDMNPs");
      }
    } else
#line 303
    if (opt.maint_cl_first) {
      {
#line 317
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-p conflicts with -dmABTXDMNPs");
      }
    } else
#line 303
    if (opt.no_deb) {
      {
#line 317
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-p conflicts with -dmABTXDMNPs");
      }
    } else
#line 303
    if (opt.no_subram) {
      {
#line 317
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-p conflicts with -dmABTXDMNPs");
      }
    } else
#line 303
    if (opt.no_title) {
      {
#line 317
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-p conflicts with -dmABTXDMNPs");
      }
    } else
#line 303
    if (opt.no_xref) {
      {
#line 317
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-p conflicts with -dmABTXDMNPs");
      }
    } else
#line 303
    if (opt.no_maint) {
      {
#line 317
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-p conflicts with -dmABTXDMNPs");
      }
    } else
#line 303
    if (opt.no_pri) {
      {
#line 317
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-p conflicts with -dmABTXDMNPs");
      }
    } else
#line 303
    if (opt.no_desc) {
      {
#line 317
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-p conflicts with -dmABTXDMNPs");
      }
    } else
#line 303
    if (opt.no_count) {
      {
#line 317
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-p conflicts with -dmABTXDMNPs");
      }
    } else
#line 303
    if (opt.selections) {
      {
#line 317
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-p conflicts with -dmABTXDMNPs");
      }
    }
  }
#line 318
  if (opt.deb_cl_first) {
#line 318
    goto _L;
  } else
#line 318
  if (opt.maint_cl_first) {
    _L: /* CIL Label */ 
#line 319
    need_ram_cl = 0;
#line 320
    if (opt.plan) {
      {
#line 321
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-dm conflict with -pA");
      }
    } else
#line 320
    if (opt.no_deb) {
      {
#line 321
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-dm conflict with -pA");
      }
    }
  }
#line 323
  if (opt.no_title) {
#line 323
    if (! opt.no_deb) {
#line 323
      if (! opt.no_subram) {
#line 323
        if (! opt.deb_cl_first) {
#line 323
          if (! opt.maint_cl_first) {
            {
#line 329
            argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-T requires at least one of -dmAB");
            }
          }
        }
      }
    }
  }
#line 331
  if (need_ram_cl) {
#line 331
    if (! opt.ram_cl_first) {
      {
#line 332
      tmp___13 = calloc2((size_t const   )1, (size_t const   )sizeof(struct ram_cl ));
#line 332
      opt.ram_cl_first = (struct ram_cl *)tmp___13;
#line 333
      strncpy((char */* __restrict  */)((opt.ram_cl_first)->ram), (char const   */* __restrict  */)(zero_ram),
              (size_t )5);
      }
    }
  }
#line 335
  if (opt.utf8) {
#line 335
    if (opt.latin1) {
      {
#line 336
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-u conflicts with -l");
      }
    }
  }
#line 338
  if (opt.no_latin1) {
#line 339
    opt.utf8 = 0;
#line 340
    opt.latin1 = 0;
  }
#line 343
  if (opt.deb_cl_first) {
#line 343
    goto _L___1;
  } else
#line 343
  if (opt.maint_cl_first) {
    _L___1: /* CIL Label */ 
#line 343
    if (opt.ram_cl_first) {
#line 348
      opt.recursive = 1;
    } else {
#line 343
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 343
  if (opt.plan) {
#line 343
    if (! opt.recursive_up) {
#line 348
      opt.recursive = 1;
    }
  }
#line 350
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 352
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 356
  return (0);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.c"
static struct argp  const  argp  =    {option, & parse_opt, "RAMIFICATION...", "debram -- look .debs up in the Debian Ramification\vEach RAMIFICATION on the command line is a four-digit number.  If none is given, 0000 is assumed and a table of the principal ramification sections is printed.\n\nIf this help list scrolls up off the screen and you cannot see it all, try \"debram --help | more\".  The list omits a few seldom-used options; enter \"man 1 debram\" for complete documentation.",
    (struct argp_child  const  *)0, (char *(*)(int __key , char const   *__text ,
                                               void *__input ))0, (char const   *)0};
#line 367 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/argp.c"
void parse_cl(int argc , char **argv ) 
{ 
  int i ;
  error_t tmp ;

  {
#line 372
  i = 0;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (i < 4)) {
#line 372
      goto while_break;
    }
#line 372
    zero_ram[i] = (char )'0';
#line 372
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 373
  zero_ram[i] = (char )'\000';
#line 376
  tmp = argp_parse((struct argp  const  */* __restrict  */)(& argp), argc, (char **/* __restrict  */)argv,
                   0U, (int */* __restrict  */)0, (void */* __restrict  */)0);
  }
#line 376
  if (tmp) {
    {
#line 376
    error(1, 0, "cannot parse the command line");
    }
  }
#line 381
  return;
}
}
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 1372 "/usr/include/zlib.h"
extern char *gzgets(gzFile file , char *buf , int len ) ;
#line 1447
extern int gzrewind(gzFile file ) ;
#line 1725
extern gzFile gzopen(char const   * , char const   * ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/ldf.c"
static enum isopen isopen  =    (enum isopen )0;
#line 39 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/ldf.c"
static gzFile *gzfile  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/ldf.c"
static FILE *file  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/ldf.c"
static int eof  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/ldf.c"
char *read_ldf(char * const  buf___0 ) 
{ 
  char *ret ;
  char *filename_gz ;
  char *filename_clear ;
  gzFile tmp ;
  size_t tmp___0 ;

  {
#line 45
  ret = (char *)0;
#line 46
  if (eof) {
#line 46
    return (ret);
  }
#line 48
  if (! isopen) {
#line 49
    filename_gz = (char *)"/usr/share/debram/debram.txt.gz";
#line 50
    filename_clear = (char *)"/usr/share/debram/debram.txt";
#line 51
    if (opt.data_file_gz) {
#line 51
      goto _L;
    } else
#line 51
    if (opt.data_file) {
      _L: /* CIL Label */ 
#line 52
      if (opt.data_file_gz) {
#line 52
        filename_gz = opt.data_file_gz;
      } else {
#line 52
        filename_gz = (char *)0;
      }
#line 53
      if (opt.data_file) {
#line 53
        filename_clear = opt.data_file;
      } else {
#line 53
        filename_clear = (char *)0;
      }
    }
    {
#line 55
    file = fopen((char const   */* __restrict  */)filename_clear, (char const   */* __restrict  */)"r");
    }
#line 55
    if (file) {
#line 56
      isopen = (enum isopen )2;
    } else {
      {
#line 57
      tmp = gzopen((char const   *)filename_gz, "r");
#line 57
      gzfile = (gzFile *)tmp;
      }
#line 57
      if (gzfile) {
#line 58
        isopen = (enum isopen )1;
      } else {
        {
#line 59
        error(13, 0, "cannot find and open the library data file");
        }
      }
    }
  }
  {
#line 66
  if ((unsigned int )isopen == 1U) {
#line 66
    goto case_1;
  }
#line 67
  if ((unsigned int )isopen == 2U) {
#line 67
    goto case_2;
  }
#line 68
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 66
  ret = gzgets((gzFile )gzfile, (char *)buf___0, 134);
  }
#line 66
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 67
  ret = fgets((char */* __restrict  */)buf___0, 134, (FILE */* __restrict  */)file);
  }
#line 67
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 68
  error(1, 0, "impossible, ldf.c read_ldf()");
  }
  switch_break: /* CIL Label */ ;
  }
#line 74
  if (ret) {
    {
#line 74
    tmp___0 = strlen((char const   *)buf___0);
    }
#line 74
    if ((int )*(buf___0 + (tmp___0 - 1UL)) != 10) {
#line 74
      ret = (char *)0;
    }
  }
#line 75
  if (! ret) {
#line 75
    eof = 1;
  }
#line 76
  return (ret);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/ldf.c"
void rewind_ldf(void) 
{ 


  {
  {
#line 82
  if ((unsigned int )isopen == 1U) {
#line 82
    goto case_1;
  }
#line 83
  if ((unsigned int )isopen == 2U) {
#line 83
    goto case_2;
  }
#line 81
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 82
  gzrewind((gzFile )gzfile);
  }
#line 82
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 83
  rewind(file);
  }
#line 83
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 85
  eof = 0;
#line 86
  return;
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/prram.h"
void rule_init(void) ;
#line 9
void print_title(struct xram * const  xram ) ;
#line 10
void print_xref(struct xram  const  * const  xram ) ;
#line 11
void print_ram_foot(struct xram  const  * const  xram ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/prram.c"
static int first_call___0  =    1;
#line 20 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/prram.c"
static char rule___0[133]  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/prram.c"
void rule_init(void) 
{ 
  int width ;
  int tmp ;

  {
#line 22
  if (first_call___0) {
#line 23
    if (opt.wide) {
#line 23
      tmp = 132;
    } else {
#line 23
      tmp = 80;
    }
    {
#line 23
    width = tmp;
#line 24
    memset((void *)(rule___0), '-', (size_t )133);
#line 25
    rule___0[width] = (char )'\000';
#line 26
    first_call___0 = 0;
    }
  }
#line 28
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/prram.c"
void print_title(struct xram * const  xram ) 
{ 
  char title_uc[133] ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char *tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  char *tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char const   *tmp___38 ;
  char const   *tmp___39 ;
  char const   *tmp___40 ;
  char *tmp___41 ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  char const   *tmp___44 ;
  char *tmp___45 ;
  char const   *tmp___46 ;
  char const   *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char const   *tmp___50 ;
  char const   *tmp___51 ;
  char const   *tmp___52 ;
  char const   *tmp___53 ;
  char const   *tmp___54 ;
  char const   *tmp___55 ;
  char const   *tmp___56 ;
  char const   *tmp___57 ;
  char const   *tmp___58 ;
  char *tmp___59 ;
  char const   *tmp___60 ;
  char const   *tmp___61 ;
  char const   *tmp___62 ;
  char *tmp___63 ;
  char const   *tmp___64 ;
  char const   *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char const   *tmp___68 ;
  char const   *tmp___69 ;
  char const   *tmp___70 ;
  char const   *tmp___71 ;
  char const   *tmp___72 ;
  char *tmp___73 ;
  char const   *tmp___74 ;
  char const   *tmp___75 ;
  char const   *tmp___76 ;
  char *tmp___77 ;
  char const   *tmp___78 ;
  char const   *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char const   *tmp___82 ;

  {
#line 31
  if (! opt.no_title) {
    {
#line 33
    title_uc[132] = (char )'\000';
#line 34
    tmp = strncpy((char */* __restrict  */)(title_uc), (char const   */* __restrict  */)xram->title,
                  (size_t )132);
#line 34
    uc(tmp);
    }
#line 35
    if (opt.no_count) {
#line 35
      if (opt.color) {
#line 35
        tmp___0 = "\033[0m\033[m\n";
      } else {
#line 35
        tmp___0 = "\n";
      }
#line 35
      if (opt.utf8) {
#line 35
        tmp___4 = "";
      } else {
#line 35
        if (opt.color) {
#line 35
          if (xram->sref) {
#line 35
            tmp___1 = "\033[02;37m";
          } else {
#line 35
            tmp___1 = "\033[02;37m";
          }
#line 35
          tmp___2 = tmp___1;
        } else {
#line 35
          tmp___2 = "";
        }
        {
#line 35
        tmp___3 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___2, (char */* const  */)(rule___0));
#line 35
        tmp___4 = (char const   *)tmp___3;
        }
      }
#line 35
      if (opt.utf8) {
#line 35
        if (opt.color) {
#line 35
          if (xram->sref) {
#line 35
            tmp___5 = "\033[02;37m";
          } else {
#line 35
            tmp___5 = "\033[02;37m";
          }
#line 35
          tmp___6 = tmp___5;
        } else {
#line 35
          tmp___6 = "";
        }
        {
#line 35
        tmp___7 = utf8((char *)0, (size_t )0, 2, tmp___6, rule___0);
#line 35
        tmp___11 = tmp___7;
        }
      } else {
#line 35
        if (opt.color) {
#line 35
          if (xram->sref) {
#line 35
            tmp___8 = "\033[02;37m";
          } else {
#line 35
            tmp___8 = "\033[02;37m";
          }
#line 35
          tmp___9 = tmp___8;
        } else {
#line 35
          tmp___9 = "";
        }
        {
#line 35
        tmp___10 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___9, (char */* const  */)(rule___0));
#line 35
        tmp___11 = tmp___10;
        }
      }
#line 35
      if (opt.color) {
#line 35
        tmp___12 = "\033[0m\033[m\n";
      } else {
#line 35
        tmp___12 = "\n";
      }
#line 35
      if (opt.utf8) {
#line 35
        tmp___16 = "";
      } else {
#line 35
        if (opt.color) {
#line 35
          if (xram->sref) {
#line 35
            tmp___13 = "\033[01;33m";
          } else {
#line 35
            tmp___13 = "\033[01;33m";
          }
#line 35
          tmp___14 = tmp___13;
        } else {
#line 35
          tmp___14 = "";
        }
        {
#line 35
        tmp___15 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___14, (char */* const  */)(title_uc));
#line 35
        tmp___16 = (char const   *)tmp___15;
        }
      }
#line 35
      if (opt.utf8) {
#line 35
        if (opt.color) {
#line 35
          if (xram->sref) {
#line 35
            tmp___17 = "\033[01;33m";
          } else {
#line 35
            tmp___17 = "\033[01;33m";
          }
#line 35
          tmp___18 = tmp___17;
        } else {
#line 35
          tmp___18 = "";
        }
        {
#line 35
        tmp___19 = utf8((char *)0, (size_t )0, 2, tmp___18, title_uc);
#line 35
        tmp___23 = tmp___19;
        }
      } else {
#line 35
        if (opt.color) {
#line 35
          if (xram->sref) {
#line 35
            tmp___20 = "\033[01;33m";
          } else {
#line 35
            tmp___20 = "\033[01;33m";
          }
#line 35
          tmp___21 = tmp___20;
        } else {
#line 35
          tmp___21 = "";
        }
        {
#line 35
        tmp___22 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___21, (char */* const  */)(title_uc));
#line 35
        tmp___23 = tmp___22;
        }
      }
#line 35
      if (opt.color) {
#line 35
        if (xram->sref) {
#line 35
          tmp___24 = "\033[22;37m";
        } else {
#line 35
          tmp___24 = "\033[22;37m";
        }
#line 35
        tmp___25 = tmp___24;
      } else {
#line 35
        tmp___25 = "";
      }
#line 35
      if (opt.color) {
#line 35
        tmp___26 = "\033[0m\033[m\n";
      } else {
#line 35
        tmp___26 = "\n";
      }
#line 35
      if (opt.utf8) {
#line 35
        tmp___30 = "";
      } else {
#line 35
        if (opt.color) {
#line 35
          if (xram->sref) {
#line 35
            tmp___27 = "\033[02;37m";
          } else {
#line 35
            tmp___27 = "\033[02;37m";
          }
#line 35
          tmp___28 = tmp___27;
        } else {
#line 35
          tmp___28 = "";
        }
        {
#line 35
        tmp___29 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___28, (char */* const  */)(rule___0));
#line 35
        tmp___30 = (char const   *)tmp___29;
        }
      }
#line 35
      if (opt.utf8) {
#line 35
        if (opt.color) {
#line 35
          if (xram->sref) {
#line 35
            tmp___31 = "\033[02;37m";
          } else {
#line 35
            tmp___31 = "\033[02;37m";
          }
#line 35
          tmp___32 = tmp___31;
        } else {
#line 35
          tmp___32 = "";
        }
        {
#line 35
        tmp___33 = utf8((char *)0, (size_t )0, 2, tmp___32, rule___0);
#line 35
        tmp___37 = tmp___33;
        }
      } else {
#line 35
        if (opt.color) {
#line 35
          if (xram->sref) {
#line 35
            tmp___34 = "\033[02;37m";
          } else {
#line 35
            tmp___34 = "\033[02;37m";
          }
#line 35
          tmp___35 = tmp___34;
        } else {
#line 35
          tmp___35 = "";
        }
        {
#line 35
        tmp___36 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___35, (char */* const  */)(rule___0));
#line 35
        tmp___37 = tmp___36;
        }
      }
      {
#line 35
      printf((char const   */* __restrict  */)"%s%s%s%s%s %s%s%s%s%s%s", tmp___37,
             tmp___30, tmp___26, tmp___25, xram->ram, tmp___23, tmp___16, tmp___12,
             tmp___11, tmp___4, tmp___0);
      }
    } else {
#line 42
      if (opt.color) {
#line 42
        tmp___38 = "\033[0m\033[m\n";
      } else {
#line 42
        tmp___38 = "\n";
      }
#line 42
      if (opt.utf8) {
#line 42
        tmp___42 = "";
      } else {
#line 42
        if (opt.color) {
#line 42
          if (xram->sref) {
#line 42
            tmp___39 = "\033[02;37m";
          } else {
#line 42
            tmp___39 = "\033[02;37m";
          }
#line 42
          tmp___40 = tmp___39;
        } else {
#line 42
          tmp___40 = "";
        }
        {
#line 42
        tmp___41 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___40, (char */* const  */)(rule___0));
#line 42
        tmp___42 = (char const   *)tmp___41;
        }
      }
#line 42
      if (opt.utf8) {
#line 42
        if (opt.color) {
#line 42
          if (xram->sref) {
#line 42
            tmp___43 = "\033[02;37m";
          } else {
#line 42
            tmp___43 = "\033[02;37m";
          }
#line 42
          tmp___44 = tmp___43;
        } else {
#line 42
          tmp___44 = "";
        }
        {
#line 42
        tmp___45 = utf8((char *)0, (size_t )0, 2, tmp___44, rule___0);
#line 42
        tmp___49 = tmp___45;
        }
      } else {
#line 42
        if (opt.color) {
#line 42
          if (xram->sref) {
#line 42
            tmp___46 = "\033[02;37m";
          } else {
#line 42
            tmp___46 = "\033[02;37m";
          }
#line 42
          tmp___47 = tmp___46;
        } else {
#line 42
          tmp___47 = "";
        }
        {
#line 42
        tmp___48 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___47, (char */* const  */)(rule___0));
#line 42
        tmp___49 = tmp___48;
        }
      }
#line 42
      if (opt.color) {
#line 42
        tmp___50 = "\033[0m\033[m\n";
      } else {
#line 42
        tmp___50 = "\n";
      }
#line 42
      if (opt.color) {
#line 42
        if (xram->sref) {
#line 42
          tmp___51 = "\033[22;37m";
        } else {
#line 42
          tmp___51 = "\033[22;37m";
        }
#line 42
        tmp___52 = tmp___51;
      } else {
#line 42
        tmp___52 = "";
      }
#line 42
      if (opt.color) {
#line 42
        if (xram->sref) {
#line 42
          tmp___53 = "\033[22;37m";
        } else {
#line 42
          tmp___53 = "\033[22;37m";
        }
#line 42
        tmp___54 = tmp___53;
      } else {
#line 42
        tmp___54 = "";
      }
#line 42
      if (opt.color) {
#line 42
        if (xram->sref) {
#line 42
          tmp___55 = "\033[22;37m";
        } else {
#line 42
          tmp___55 = "\033[22;37m";
        }
#line 42
        tmp___56 = tmp___55;
      } else {
#line 42
        tmp___56 = "";
      }
#line 42
      if (opt.utf8) {
#line 42
        tmp___60 = "";
      } else {
#line 42
        if (opt.color) {
#line 42
          if (xram->sref) {
#line 42
            tmp___57 = "\033[01;33m";
          } else {
#line 42
            tmp___57 = "\033[01;33m";
          }
#line 42
          tmp___58 = tmp___57;
        } else {
#line 42
          tmp___58 = "";
        }
        {
#line 42
        tmp___59 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___58, (char */* const  */)(title_uc));
#line 42
        tmp___60 = (char const   *)tmp___59;
        }
      }
#line 42
      if (opt.utf8) {
#line 42
        if (opt.color) {
#line 42
          if (xram->sref) {
#line 42
            tmp___61 = "\033[01;33m";
          } else {
#line 42
            tmp___61 = "\033[01;33m";
          }
#line 42
          tmp___62 = tmp___61;
        } else {
#line 42
          tmp___62 = "";
        }
        {
#line 42
        tmp___63 = utf8((char *)0, (size_t )0, 2, tmp___62, title_uc);
#line 42
        tmp___67 = tmp___63;
        }
      } else {
#line 42
        if (opt.color) {
#line 42
          if (xram->sref) {
#line 42
            tmp___64 = "\033[01;33m";
          } else {
#line 42
            tmp___64 = "\033[01;33m";
          }
#line 42
          tmp___65 = tmp___64;
        } else {
#line 42
          tmp___65 = "";
        }
        {
#line 42
        tmp___66 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___65, (char */* const  */)(title_uc));
#line 42
        tmp___67 = tmp___66;
        }
      }
#line 42
      if (opt.color) {
#line 42
        if (xram->sref) {
#line 42
          tmp___68 = "\033[22;37m";
        } else {
#line 42
          tmp___68 = "\033[22;37m";
        }
#line 42
        tmp___69 = tmp___68;
      } else {
#line 42
        tmp___69 = "";
      }
#line 42
      if (opt.color) {
#line 42
        tmp___70 = "\033[0m\033[m\n";
      } else {
#line 42
        tmp___70 = "\n";
      }
#line 42
      if (opt.utf8) {
#line 42
        tmp___74 = "";
      } else {
#line 42
        if (opt.color) {
#line 42
          if (xram->sref) {
#line 42
            tmp___71 = "\033[02;37m";
          } else {
#line 42
            tmp___71 = "\033[02;37m";
          }
#line 42
          tmp___72 = tmp___71;
        } else {
#line 42
          tmp___72 = "";
        }
        {
#line 42
        tmp___73 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___72, (char */* const  */)(rule___0));
#line 42
        tmp___74 = (char const   *)tmp___73;
        }
      }
#line 42
      if (opt.utf8) {
#line 42
        if (opt.color) {
#line 42
          if (xram->sref) {
#line 42
            tmp___75 = "\033[02;37m";
          } else {
#line 42
            tmp___75 = "\033[02;37m";
          }
#line 42
          tmp___76 = tmp___75;
        } else {
#line 42
          tmp___76 = "";
        }
        {
#line 42
        tmp___77 = utf8((char *)0, (size_t )0, 2, tmp___76, rule___0);
#line 42
        tmp___81 = tmp___77;
        }
      } else {
#line 42
        if (opt.color) {
#line 42
          if (xram->sref) {
#line 42
            tmp___78 = "\033[02;37m";
          } else {
#line 42
            tmp___78 = "\033[02;37m";
          }
#line 42
          tmp___79 = tmp___78;
        } else {
#line 42
          tmp___79 = "";
        }
        {
#line 42
        tmp___80 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___79, (char */* const  */)(rule___0));
#line 42
        tmp___81 = tmp___80;
        }
      }
      {
#line 42
      printf((char const   */* __restrict  */)"%s%s%s%s%s %s%s %s%s%s%s%d%s%s%s%s%s%s",
             tmp___81, tmp___74, tmp___70, tmp___69, xram->ram, tmp___67, tmp___60,
             tmp___56, "(", tmp___54, "", xram->n_deb, tmp___52, ")", tmp___50, tmp___49,
             tmp___42, tmp___38);
      }
    }
#line 52
    if (! xram->sref) {
#line 52
      if (! opt.wide) {
#line 52
        if (! opt.no_desc) {
#line 53
          if (opt.color) {
#line 53
            tmp___82 = "\033[0m\033[m\n";
          } else {
#line 53
            tmp___82 = "\n";
          }
          {
#line 53
          printf((char const   */* __restrict  */)"%s", tmp___82);
          }
        }
      }
    }
  }
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/prram.c"
__inline static void print_xref1(char * const  ram , char * const  title ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;

  {
#line 61
  if (opt.expand_xref) {
#line 61
    if (opt.color) {
#line 61
      tmp = "\033[0m\033[m\n";
    } else {
#line 61
      tmp = "\n";
    }
#line 61
    if (opt.utf8) {
#line 61
      tmp___2 = "";
    } else {
#line 61
      if (opt.color) {
#line 61
        tmp___0 = "\033[02;37m";
      } else {
#line 61
        tmp___0 = "";
      }
      {
#line 61
      tmp___1 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___0, title);
#line 61
      tmp___2 = (char const   *)tmp___1;
      }
    }
#line 61
    if (opt.utf8) {
#line 61
      if (opt.color) {
#line 61
        tmp___3 = "\033[02;37m";
      } else {
#line 61
        tmp___3 = "";
      }
      {
#line 61
      tmp___4 = utf8((char *)0, (size_t )0, 2, tmp___3, title);
#line 61
      tmp___7 = tmp___4;
      }
    } else {
#line 61
      if (opt.color) {
#line 61
        tmp___5 = "\033[02;37m";
      } else {
#line 61
        tmp___5 = "";
      }
      {
#line 61
      tmp___6 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___5, title);
#line 61
      tmp___7 = tmp___6;
      }
    }
#line 61
    if (opt.color) {
#line 61
      tmp___8 = "\033[02;37m";
    } else {
#line 61
      tmp___8 = "";
    }
#line 61
    if (opt.utf8) {
#line 61
      tmp___11 = "";
    } else {
#line 61
      if (opt.color) {
#line 61
        tmp___9 = "\033[02;37m";
      } else {
#line 61
        tmp___9 = "";
      }
      {
#line 61
      tmp___10 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___9, (char */* const  */)"--->");
#line 61
      tmp___11 = (char const   *)tmp___10;
      }
    }
#line 61
    if (opt.utf8) {
#line 61
      if (opt.color) {
#line 61
        tmp___12 = "\033[02;37m";
      } else {
#line 61
        tmp___12 = "";
      }
      {
#line 61
      tmp___13 = utf8((char *)0, (size_t )0, 2, tmp___12, "--->");
#line 61
      tmp___16 = tmp___13;
      }
    } else {
#line 61
      if (opt.color) {
#line 61
        tmp___14 = "\033[02;37m";
      } else {
#line 61
        tmp___14 = "";
      }
      {
#line 61
      tmp___15 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___14, (char */* const  */)"--->");
#line 61
      tmp___16 = tmp___15;
      }
    }
    {
#line 61
    printf((char const   */* __restrict  */)"%s%s %s%s %s%s%s", tmp___16, tmp___11,
           tmp___8, ram, tmp___7, tmp___2, tmp);
    }
  } else {
#line 68
    if (opt.color) {
#line 68
      tmp___17 = "\033[02;37m";
    } else {
#line 68
      tmp___17 = "";
    }
    {
#line 68
    printf((char const   */* __restrict  */)" %s%s", tmp___17, ram);
    }
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/prram.c"
void print_xref(struct xram  const  * const  xram ) 
{ 
  int none ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct xref *xref ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
#line 75
  none = 1;
#line 76
  if (opt.no_xref) {
#line 76
    return;
  }
#line 77
  if (! opt.expand_xref) {
#line 77
    if (opt.utf8) {
#line 77
      tmp___1 = "";
    } else {
#line 77
      if (opt.color) {
#line 77
        tmp = "\033[02;37m";
      } else {
#line 77
        tmp = "";
      }
      {
#line 77
      tmp___0 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp, (char */* const  */)"--->");
#line 77
      tmp___1 = (char const   *)tmp___0;
      }
    }
#line 77
    if (opt.utf8) {
#line 77
      if (opt.color) {
#line 77
        tmp___2 = "\033[02;37m";
      } else {
#line 77
        tmp___2 = "";
      }
      {
#line 77
      tmp___3 = utf8((char *)0, (size_t )0, 2, tmp___2, "--->");
#line 77
      tmp___6 = tmp___3;
      }
    } else {
#line 77
      if (opt.color) {
#line 77
        tmp___4 = "\033[02;37m";
      } else {
#line 77
        tmp___4 = "";
      }
      {
#line 77
      tmp___5 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___4, (char */* const  */)"--->");
#line 77
      tmp___6 = tmp___5;
      }
    }
    {
#line 77
    printf((char const   */* __restrict  */)"%s%s", tmp___6, tmp___1);
    }
  }
#line 81
  if (xram->up) {
#line 81
    if (xram->ram_level > 1) {
      {
#line 87
      none = 0;
#line 88
      print_xref1((char */* const  */)((xram->up)->ram), (char */* const  */)(xram->up)->title);
      }
    }
  }
#line 92
  if (xram->xref) {
#line 92
    none = 0;
  }
#line 93
  xref = (struct xref *)xram->xref;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! xref) {
#line 93
      goto while_break;
    }
    {
#line 94
    print_xref1((char */* const  */)(xref->ram), (char */* const  */)(xref->xram)->title);
#line 93
    xref = xref->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  if (! opt.expand_xref) {
#line 96
    if (opt.color) {
#line 96
      tmp___7 = "\033[0m\033[m\n";
    } else {
#line 96
      tmp___7 = "\n";
    }
#line 96
    if (opt.utf8) {
#line 96
      tmp___11 = "";
    } else {
#line 96
      if (none) {
#line 96
        tmp___8 = " (no references)";
      } else {
#line 96
        tmp___8 = "";
      }
#line 96
      if (opt.color) {
#line 96
        tmp___9 = "\033[02;37m";
      } else {
#line 96
        tmp___9 = "";
      }
      {
#line 96
      tmp___10 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___9, (char */* const  */)tmp___8);
#line 96
      tmp___11 = (char const   *)tmp___10;
      }
    }
#line 96
    if (opt.utf8) {
#line 96
      if (none) {
#line 96
        tmp___12 = " (no references)";
      } else {
#line 96
        tmp___12 = "";
      }
#line 96
      if (opt.color) {
#line 96
        tmp___13 = "\033[02;37m";
      } else {
#line 96
        tmp___13 = "";
      }
      {
#line 96
      tmp___14 = utf8((char *)0, (size_t )0, 2, tmp___13, tmp___12);
#line 96
      tmp___18 = tmp___14;
      }
    } else {
#line 96
      if (none) {
#line 96
        tmp___15 = " (no references)";
      } else {
#line 96
        tmp___15 = "";
      }
#line 96
      if (opt.color) {
#line 96
        tmp___16 = "\033[02;37m";
      } else {
#line 96
        tmp___16 = "";
      }
      {
#line 96
      tmp___17 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___16, (char */* const  */)tmp___15);
#line 96
      tmp___18 = tmp___17;
      }
    }
    {
#line 96
    printf((char const   */* __restrict  */)"%s%s%s", tmp___18, tmp___11, tmp___7);
    }
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/prram.c"
void print_ram_foot(struct xram  const  * const  xram ) 
{ 
  char const   *tmp ;

  {
#line 104
  if (! opt.no_title) {
#line 104
    if (xram->sref) {
#line 104
      goto _L;
    } else
#line 104
    if (opt.wide) {
#line 104
      goto _L;
    } else
#line 104
    if (opt.no_desc) {
#line 104
      goto _L;
    } else
#line 104
    if (! opt.no_xref) {
      _L: /* CIL Label */ 
#line 107
      if (opt.color) {
#line 107
        tmp = "\033[0m\033[m\n";
      } else {
#line 107
        tmp = "\n";
      }
      {
#line 107
      printf((char const   */* __restrict  */)"%s", tmp);
      }
    }
  }
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/debram-1.0.3/src/prram.c"
void print_ram(void) 
{ 
  struct xram *xram ;
  struct xref *sref ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 113
  rule_init();
#line 114
  rewind_data();
#line 116
  xram = first_selected((struct xram *)0);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! xram) {
#line 116
      goto while_break;
    }
#line 119
    if (xram->sref) {
#line 120
      if (! opt.no_subram) {
        {
#line 121
        print_title((struct xram */* const  */)xram);
#line 124
        sref = xram->sref;
        }
        {
#line 124
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 124
          if (! sref) {
#line 124
            goto while_break___0;
          }
#line 124
          if (opt.color) {
#line 124
            tmp = "\033[0m\033[m\n";
          } else {
#line 124
            tmp = "\n";
          }
#line 124
          if (opt.utf8) {
#line 124
            tmp___2 = "";
          } else {
#line 124
            if (opt.color) {
#line 124
              tmp___0 = "\033[22;36m";
            } else {
#line 124
              tmp___0 = "";
            }
            {
#line 124
            tmp___1 = utf8_sel_arg2((int const   )2, (char */* const  */)tmp___0,
                                    (char */* const  */)(sref->xram)->title);
#line 124
            tmp___2 = (char const   *)tmp___1;
            }
          }
#line 124
          if (opt.utf8) {
#line 124
            if (opt.color) {
#line 124
              tmp___3 = "\033[22;36m";
            } else {
#line 124
              tmp___3 = "";
            }
            {
#line 124
            tmp___4 = utf8((char *)0, (size_t )0, 2, tmp___3, (sref->xram)->title);
#line 124
            tmp___7 = tmp___4;
            }
          } else {
#line 124
            if (opt.color) {
#line 124
              tmp___5 = "\033[22;36m";
            } else {
#line 124
              tmp___5 = "";
            }
            {
#line 124
            tmp___6 = utf8_sel_arg2((int const   )1, (char */* const  */)tmp___5,
                                    (char */* const  */)(sref->xram)->title);
#line 124
            tmp___7 = tmp___6;
            }
          }
#line 124
          if (opt.color) {
#line 124
            tmp___8 = "\033[22;37m";
          } else {
#line 124
            tmp___8 = "";
          }
          {
#line 124
          printf((char const   */* __restrict  */)"%s%s %s%s%s", tmp___8, sref->ram,
                 tmp___7, tmp___2, tmp);
#line 124
          sref = sref->next;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 131
        print_xref((struct xram  const  */* const  */)xram);
#line 132
        print_ram_foot((struct xram  const  */* const  */)xram);
        }
      }
    } else {
#line 138
      datum.type = (enum datum_type )0;
      {
#line 138
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 138
        if (! ((unsigned int )datum.type != 2U)) {
          {
#line 138
          tmp___9 = strncmp((char const   *)datum.ram, (char const   *)(xram->ram),
                            (size_t )4);
          }
#line 138
          if (! tmp___9) {
#line 138
            goto while_break___1;
          }
        }
#line 143
        if ((unsigned int )doc_part > 20U) {
          {
#line 143
          error(5, 0, "cannot find ram %s in sequence in the data file\'s main body",
                xram->ram);
          }
        }
        {
#line 138
        get_datum((struct datum *)0);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 148
      if (! opt.no_deb) {
        {
#line 148
        print_title((struct xram */* const  */)xram);
        }
      }
      {
#line 149
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 149
        if (! ((unsigned int )doc_part < 20U)) {
#line 149
          goto while_break___2;
        }
#line 149
        if (! opt.no_deb) {
#line 149
          if ((unsigned int )datum.type == 1U) {
            {
#line 151
            print_deb(0, (struct datum  const  *)0);
            }
          }
        }
        {
#line 149
        get_datum((struct datum *)0);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 152
      if (! opt.no_deb) {
        {
#line 153
        print_xref((struct xram  const  */* const  */)xram);
#line 154
        print_ram_foot((struct xram  const  */* const  */)xram);
        }
      }
    }
    {
#line 116
    xram = next_selected(xram);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return;
}
}
