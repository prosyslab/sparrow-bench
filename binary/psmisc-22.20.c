/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 35 "/home/wheatley/newnew/temp/psmisc-22.20/src/signals.c"
struct __anonstruct_SIGNAME_50 {
   int number ;
   char const   *name ;
};
#line 35 "/home/wheatley/newnew/temp/psmisc-22.20/src/signals.c"
typedef struct __anonstruct_SIGNAME_50 SIGNAME;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_56 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_56 regmatch_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_59 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_59 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 3 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.h"
typedef unsigned short opt_type;
#line 15 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.h"
struct procs {
   pid_t pid ;
   uid_t uid ;
   char access ;
   char proc_type ;
   char *username ;
   char *command ;
   struct procs *next ;
};
#line 39 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.h"
struct names {
   char *filename ;
   unsigned char name_space ;
   struct stat st ;
   struct procs *matched_procs ;
   struct names *next ;
};
#line 47 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.h"
struct ip_connections {
   struct names *name ;
   unsigned long lcl_port ;
   unsigned long rmt_port ;
   struct in_addr rmt_address ;
   struct ip_connections *next ;
};
#line 55 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.h"
struct ip6_connections {
   struct names *name ;
   unsigned long lcl_port ;
   unsigned long rmt_port ;
   struct in6_addr rmt_address ;
   struct ip6_connections *next ;
};
#line 63 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.h"
struct inode_list {
   struct names *name ;
   dev_t device ;
   ino_t inode ;
   struct inode_list *next ;
};
#line 70 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.h"
struct device_list {
   struct names *name ;
   dev_t device ;
   struct device_list *next ;
};
#line 76 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.h"
struct unixsocket_list {
   char *sun_name ;
   ino_t inode ;
   ino_t net_inode ;
   dev_t dev ;
   struct unixsocket_list *next ;
};
#line 84 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.h"
struct mount_list {
   char *mountpoint ;
   struct mount_list *next ;
};
#line 28 "/usr/include/x86_64-linux-gnu/sys/ptrace.h"
enum __ptrace_request {
    PTRACE_TRACEME = 0,
    PTRACE_PEEKTEXT = 1,
    PTRACE_PEEKDATA = 2,
    PTRACE_PEEKUSER = 3,
    PTRACE_POKETEXT = 4,
    PTRACE_POKEDATA = 5,
    PTRACE_POKEUSER = 6,
    PTRACE_CONT = 7,
    PTRACE_KILL = 8,
    PTRACE_SINGLESTEP = 9,
    PTRACE_GETREGS = 12,
    PTRACE_SETREGS = 13,
    PTRACE_GETFPREGS = 14,
    PTRACE_SETFPREGS = 15,
    PTRACE_ATTACH = 16,
    PTRACE_DETACH = 17,
    PTRACE_GETFPXREGS = 18,
    PTRACE_SETFPXREGS = 19,
    PTRACE_SYSCALL = 24,
    PTRACE_SETOPTIONS = 16896,
    PTRACE_GETEVENTMSG = 16897,
    PTRACE_GETSIGINFO = 16898,
    PTRACE_SETSIGINFO = 16899,
    PTRACE_GETREGSET = 16900,
    PTRACE_SETREGSET = 16901,
    PTRACE_SEIZE = 16902,
    PTRACE_INTERRUPT = 16903,
    PTRACE_LISTEN = 16904,
    PTRACE_PEEKSIGINFO = 16905
} ;
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_47 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_48 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_47 __wait_terminated ;
   struct __anonstruct___wait_stopped_48 __wait_stopped ;
};
#line 44 "/usr/include/x86_64-linux-gnu/sys/user.h"
struct user_regs_struct {
   unsigned long long r15 ;
   unsigned long long r14 ;
   unsigned long long r13 ;
   unsigned long long r12 ;
   unsigned long long rbp ;
   unsigned long long rbx ;
   unsigned long long r11 ;
   unsigned long long r10 ;
   unsigned long long r9 ;
   unsigned long long r8 ;
   unsigned long long rax ;
   unsigned long long rcx ;
   unsigned long long rdx ;
   unsigned long long rsi ;
   unsigned long long rdi ;
   unsigned long long orig_rax ;
   unsigned long long rip ;
   unsigned long long cs ;
   unsigned long long eflags ;
   unsigned long long rsp ;
   unsigned long long ss ;
   unsigned long long fs_base ;
   unsigned long long gs_base ;
   unsigned long long ds ;
   unsigned long long es ;
   unsigned long long fs ;
   unsigned long long gs ;
};
#line 222 "/home/wheatley/newnew/temp/psmisc-22.20/src/peekfd.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 77 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
struct _child;
#line 77 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
struct _proc {
   char comm[19] ;
   char **argv ;
   int argc ;
   pid_t pid ;
   pid_t pgid ;
   uid_t uid ;
   char flags ;
   struct _child *children ;
   struct _proc *parent ;
   struct _proc *next ;
};
#line 77 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
typedef struct _proc PROC;
#line 97 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
struct _child {
   PROC *child ;
   struct _child *next ;
};
#line 97 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
typedef struct _child CHILD;
#line 102 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
struct __anonstruct_sym_ascii_32 {
   char const   *empty_2 ;
   char const   *branch_2 ;
   char const   *vert_2 ;
   char const   *last_2 ;
   char const   *single_3 ;
   char const   *first_3 ;
};
#line 2 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.h"
typedef unsigned char opt_type___0;
#line 5 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.h"
struct proc_info {
   char *comm ;
   char state ;
   int ppid ;
   int pgrp ;
   int session ;
   int tty_nr ;
   int tp_gid ;
   int exit_signal ;
   int processor ;
   unsigned int flags ;
   unsigned int rt_priority ;
   unsigned int policy ;
   unsigned long minflt ;
   unsigned long cminflt ;
   unsigned long majflt ;
   unsigned long cmajflt ;
   unsigned long utime ;
   unsigned long stime ;
   unsigned long vsize ;
   unsigned long rsslim ;
   unsigned long startcode ;
   unsigned long endcode ;
   unsigned long startstack ;
   unsigned long kstesp ;
   unsigned long ksteip ;
   unsigned long wchan ;
   unsigned long nswap ;
   unsigned long cnswap ;
   unsigned long guest_time ;
   long cutime ;
   long cstime ;
   long priority ;
   long nice ;
   long num_threads ;
   long itrealvalue ;
   long rss ;
   long cguest_time ;
   unsigned long long starttime ;
   unsigned long long blkio ;
};
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 9 "/home/wheatley/newnew/temp/psmisc-22.20/src/signals.h"
void list_signals(void) ;
#line 13
int get_signal(char *name , char const   *cmd ) ;
#line 43 "/home/wheatley/newnew/temp/psmisc-22.20/src/signals.c"
static SIGNAME signals[34]  = 
#line 43 "/home/wheatley/newnew/temp/psmisc-22.20/src/signals.c"
  {      {1, "HUP"}, 
        {2, "INT"}, 
        {3, "QUIT"}, 
        {4, "ILL"}, 
        {5, "TRAP"}, 
        {6, "ABRT"}, 
        {6, "IOT"}, 
        {7, "BUS"}, 
        {8, "FPE"}, 
        {9, "KILL"}, 
        {10, "USR1"}, 
        {11, "SEGV"}, 
        {12, "USR2"}, 
        {13, "PIPE"}, 
        {14, "ALRM"}, 
        {15, "TERM"}, 
        {16, "STKFLT"}, 
        {17, "CHLD"}, 
        {18, "CONT"}, 
        {19, "STOP"}, 
        {20, "TSTP"}, 
        {21, "TTIN"}, 
        {22, "TTOU"}, 
        {23, "URG"}, 
        {24, "XCPU"}, 
        {25, "XFSZ"}, 
        {26, "VTALRM"}, 
        {27, "PROF"}, 
        {28, "WINCH"}, 
        {29, "IO"}, 
        {30, "PWR"}, 
        {31, "SYS"}, 
        {31, "UNUSED"}, 
        {0, (char const   *)((void *)0)}};
#line 49 "/home/wheatley/newnew/temp/psmisc-22.20/src/signals.c"
void list_signals(void) 
{ 
  SIGNAME *walk ;
  int col ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 55
  col = 0;
#line 56
  walk = signals;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! walk->name) {
#line 56
      goto while_break;
    }
    {
#line 58
    tmp = strlen(walk->name);
    }
#line 58
    if (((size_t )col + tmp) + 1UL > 80UL) {
      {
#line 60
      putchar('\n');
#line 61
      col = 0;
      }
    }
#line 63
    if (col) {
#line 63
      tmp___0 = " ";
    } else {
#line 63
      tmp___0 = "";
    }
    {
#line 63
    printf((char const   */* __restrict  */)"%s%s", tmp___0, walk->name);
#line 64
    tmp___1 = strlen(walk->name);
#line 64
    col = (int )((size_t )col + (tmp___1 + 1UL));
#line 56
    walk ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  putchar('\n');
  }
#line 67
  return;
}
}
#line 70 "/home/wheatley/newnew/temp/psmisc-22.20/src/signals.c"
int get_signal(char *name , char const   *cmd ) 
{ 
  SIGNAME *walk ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 75
  tmp___0 = __ctype_b_loc();
  }
#line 75
  if ((int const   )*(*tmp___0 + (int )*name) & 2048) {
    {
#line 76
    tmp = atoi((char const   *)name);
    }
#line 76
    return (tmp);
  }
  {
#line 77
  tmp___1 = strncmp("SIG", (char const   *)name, (size_t )3);
  }
#line 77
  if (! tmp___1) {
#line 78
    name += 3;
  }
#line 79
  walk = signals;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! walk->name) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp___2 = strcmp(walk->name, (char const   *)name);
    }
#line 80
    if (! tmp___2) {
#line 81
      goto while_break;
    }
#line 79
    walk ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  if (walk->name) {
#line 83
    return (walk->number);
  }
  {
#line 84
  tmp___3 = gettext("%s: unknown signal; %s -l lists signals.\n");
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
          name, cmd);
#line 85
  exit(1);
  }
}
}
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 888
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rpmatch)(char const   *__response ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 639
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpgid)(__pid_t __pid ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 405
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 678
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 177 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long_only)(int ___argc ,
                                                                                       char * const  *___argv ,
                                                                                       char const   *__shortopts ,
                                                                                       struct option  const  *__longopts ,
                                                                                       int *__longind ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 83 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static int verbose  =    0;
#line 83 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static int exact  =    0;
#line 83 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static int interactive  =    0;
#line 83 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static int reg  =    0;
#line 83 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static int quiet  =    0;
#line 83 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static int wait_until_dead  =    0;
#line 83 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static int process_group  =    0;
#line 83 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static int ignore_case  =    0;
#line 86 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static long younger_than  =    0L;
#line 86 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static long older_than  =    0L;
#line 88 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static int ask(char *name , pid_t pid , int const   signal___0 ) 
{ 
  int res ;
  size_t len ;
  char *line ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  __ssize_t tmp___3 ;

  {
#line 95
  line = (char *)((void *)0);
#line 96
  len = (size_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (signal___0 == 15) {
#line 100
      if (process_group) {
#line 100
        tmp = "pgid ";
      } else {
#line 100
        tmp = "";
      }
      {
#line 100
      tmp___0 = gettext("Kill %s(%s%d) ? (y/N) ");
#line 100
      printf((char const   */* __restrict  */)tmp___0, name, tmp, pid);
      }
    } else {
#line 103
      if (process_group) {
#line 103
        tmp___1 = "pgid ";
      } else {
#line 103
        tmp___1 = "";
      }
      {
#line 103
      tmp___2 = gettext("Signal %s(%s%d) ? (y/N) ");
#line 103
      printf((char const   */* __restrict  */)tmp___2, name, tmp___1, pid);
      }
    }
    {
#line 106
    fflush(stdout);
#line 108
    tmp___3 = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& len),
                      (FILE */* __restrict  */)stdin);
    }
#line 108
    if (tmp___3 < 0L) {
#line 109
      return (0);
    }
#line 111
    if ((int )*(line + 0) == 10) {
      {
#line 112
      free((void *)line);
      }
#line 113
      return (0);
    }
    {
#line 115
    res = rpmatch((char const   *)line);
    }
#line 116
    if (res >= 0) {
      {
#line 117
      free((void *)line);
      }
#line 118
      return (res);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 124 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static double uptime(void) 
{ 
  char *savelocale ;
  char buf___0[2048] ;
  FILE *file ;
  int tmp ;
  double tmp___0 ;

  {
  {
#line 130
  file = fopen((char const   */* __restrict  */)"/proc/uptime", (char const   */* __restrict  */)"r");
  }
#line 130
  if (! file) {
    {
#line 131
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"killall: error opening uptime file\n");
#line 132
    exit(1);
    }
  }
  {
#line 134
  savelocale = setlocale(1, (char const   *)((void *)0));
#line 135
  setlocale(1, "C");
#line 136
  tmp = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%2047s",
               buf___0);
  }
#line 136
  if (tmp == -1) {
    {
#line 136
    perror("uptime");
    }
  }
  {
#line 137
  fclose(file);
#line 138
  setlocale(1, (char const   *)savelocale);
#line 139
  tmp___0 = atof((char const   *)(buf___0));
  }
#line 139
  return (tmp___0);
}
}
#line 143 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static double process_age(unsigned long long const   jf ) 
{ 
  double age ;
  double sc_clk_tck___0 ;
  long tmp ;
  double tmp___0 ;

  {
  {
#line 146
  tmp = sysconf(2);
#line 146
  sc_clk_tck___0 = (double )tmp;
  }
#line 147
  if (! (sc_clk_tck___0 > (double )0)) {
    {
#line 147
    __assert_fail("sc_clk_tck > 0", "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c",
                  147U, "process_age");
    }
  }
  {
#line 148
  tmp___0 = uptime();
#line 148
  age = tmp___0 - (double )jf / sc_clk_tck___0;
  }
#line 149
  if (age < (double )0L) {
#line 150
    return ((double )0L);
  }
#line 151
  return (age);
}
}
#line 157 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static long parse_time_units(char const   *age ) 
{ 
  char *unit ;
  long num ;

  {
  {
#line 163
  num = strtol((char const   */* __restrict  */)age, (char **/* __restrict  */)(& unit),
               10);
  }
#line 164
  if ((unsigned long )age == (unsigned long )unit) {
#line 165
    return (-1L);
  }
#line 166
  if ((int )*(unit + 0) == 0) {
#line 167
    return (-1L);
  }
  {
#line 170
  if ((int )*(unit + 0) == 115) {
#line 170
    goto case_115;
  }
#line 172
  if ((int )*(unit + 0) == 109) {
#line 172
    goto case_109;
  }
#line 174
  if ((int )*(unit + 0) == 104) {
#line 174
    goto case_104;
  }
#line 176
  if ((int )*(unit + 0) == 100) {
#line 176
    goto case_100;
  }
#line 178
  if ((int )*(unit + 0) == 119) {
#line 178
    goto case_119;
  }
#line 180
  if ((int )*(unit + 0) == 77) {
#line 180
    goto case_77;
  }
#line 182
  if ((int )*(unit + 0) == 121) {
#line 182
    goto case_121;
  }
#line 169
  goto switch_break;
  case_115: /* CIL Label */ 
#line 171
  return (num);
  case_109: /* CIL Label */ 
#line 173
  return (num * 60L);
  case_104: /* CIL Label */ 
#line 175
  return ((num * 60L) * 60L);
  case_100: /* CIL Label */ 
#line 177
  return (((num * 60L) * 60L) * 24L);
  case_119: /* CIL Label */ 
#line 179
  return ((((num * 60L) * 60L) * 24L) * 7L);
  case_77: /* CIL Label */ 
#line 181
  return (((((num * 60L) * 60L) * 24L) * 7L) * 4L);
  case_121: /* CIL Label */ 
#line 183
  return ((((((num * 60L) * 60L) * 24L) * 7L) * 4L) * 12L);
  switch_break: /* CIL Label */ ;
  }
#line 185
  return (-1L);
}
}
#line 188 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static int match_process_uid(pid_t pid , uid_t uid ) 
{ 
  char buf___0[128] ;
  uid_t puid ;
  FILE *f ;
  int re ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 194
  re = -1;
#line 196
  snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"/proc/%d/status",
           pid);
#line 197
  f = fopen((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)"r");
  }
#line 197
  if (! f) {
#line 198
    return (0);
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 200
    tmp___0 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)f);
    }
#line 200
    if (! tmp___0) {
#line 200
      goto while_break;
    }
    {
#line 202
    tmp = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Uid:\t%d",
                 & puid);
    }
#line 202
    if (tmp) {
#line 204
      re = uid == puid;
#line 205
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  fclose(f);
  }
#line 209
  if (re == -1) {
    {
#line 211
    tmp___1 = gettext("killall: Cannot get UID from process status\n");
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
#line 212
    exit(1);
    }
  }
#line 214
  return (re);
}
}
#line 217 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static regex_t *build_regexp_list(int names , char **namelist ) 
{ 
  int i ;
  regex_t *reglist ;
  int flag ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 222
  flag = 1 | (((1 << 1) << 1) << 1);
#line 224
  tmp = malloc(sizeof(regex_t ) * (unsigned long )names);
#line 224
  reglist = (regex_t *)tmp;
  }
#line 224
  if (! reglist) {
    {
#line 226
    perror("malloc");
#line 227
    exit(1);
    }
  }
#line 230
  if (ignore_case) {
#line 231
    flag |= 1 << 1;
  }
#line 233
  i = 0;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < names)) {
#line 233
      goto while_break;
    }
    {
#line 235
    tmp___1 = regcomp((regex_t */* __restrict  */)(reglist + i), (char const   */* __restrict  */)*(namelist + i),
                      flag);
    }
#line 235
    if (tmp___1 != 0) {
      {
#line 237
      tmp___0 = gettext("killall: Bad regular expression: %s\n");
#line 237
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              *(namelist + i));
#line 238
      exit(1);
      }
    }
#line 233
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  return (reglist);
}
}
#line 249 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static int kill_all(int signal___0 , int names , char **namelist , struct passwd *pwent ) 
{ 
  DIR *dir ;
  struct dirent *de ;
  FILE *file ;
  struct stat st ;
  struct stat sts[(int )(sizeof(unsigned long ) * 8UL)] ;
  int *name_len ;
  char *path ;
  char comm[16] ;
  char *command_buf ;
  char *command ;
  pid_t *pid_table ;
  pid_t pid ;
  pid_t self ;
  pid_t *pid_killed ;
  pid_t *pgids___0 ;
  int i ;
  int j ;
  int okay ;
  int length ;
  int got_long ;
  int error ;
  int pids___0 ;
  int max_pids ;
  int pids_killed ;
  unsigned long found ;
  regex_t *reglist ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  pid_t id ;
  int found_name ;
  double process_age_sec ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned long long proc_stt_jf ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  char *p ;
  int cmd_size ;
  void *tmp___15 ;
  int c ;
  int cur_size ;
  void *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int ok ;
  int tmp___30 ;
  size_t len ;
  size_t tmp___31 ;
  char *linkbuf ;
  void *tmp___32 ;
  ssize_t tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int j___0 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  char const   *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  int *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  int *tmp___46 ;
  pid_t tmp___47 ;
  int tmp___48 ;
  char *tmp___49 ;
  pid_t tmp___50 ;
  int tmp___51 ;
  int *tmp___52 ;

  {
#line 257
  name_len = (int *)((void *)0);
#line 266
  reglist = (regex_t *)((void *)0);
#line 271
  if (names) {
#line 271
    if (reg) {
      {
#line 272
      reglist = build_regexp_list(names, namelist);
      }
    } else {
#line 271
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 273
  if (names) {
    {
#line 275
    tmp = malloc(sizeof(int ) * (unsigned long )names);
#line 275
    name_len = (int *)tmp;
    }
#line 275
    if (! name_len) {
      {
#line 277
      perror("malloc");
#line 278
      exit(1);
      }
    }
#line 280
    i = 0;
    {
#line 280
    while (1) {
      while_continue: /* CIL Label */ ;
#line 280
      if (! (i < names)) {
#line 280
        goto while_break;
      }
      {
#line 282
      tmp___2 = strchr((char const   *)*(namelist + i), '/');
      }
#line 282
      if (tmp___2) {
        {
#line 287
        tmp___1 = stat((char const   */* __restrict  */)*(namelist + i), (struct stat */* __restrict  */)(& sts[i]));
        }
#line 287
        if (tmp___1 < 0) {
          {
#line 289
          perror((char const   *)*(namelist + i));
#line 290
          exit(1);
          }
        }
      } else {
        {
#line 284
        sts[i].st_dev = (__dev_t )0;
#line 285
        tmp___0 = strlen((char const   *)*(namelist + i));
#line 285
        *(name_len + i) = (int )tmp___0;
        }
      }
#line 280
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 294
  self = getpid();
#line 295
  found = 0UL;
#line 296
  dir = opendir("/proc");
  }
#line 296
  if (! dir) {
    {
#line 298
    perror("/proc");
#line 299
    exit(1);
    }
  }
  {
#line 301
  max_pids = 256;
#line 302
  tmp___3 = malloc((unsigned long )max_pids * sizeof(pid_t ));
#line 302
  pid_table = (pid_t *)tmp___3;
  }
#line 303
  if (! pid_table) {
    {
#line 305
    perror("malloc");
#line 306
    exit(1);
    }
  }
#line 308
  pids___0 = 0;
  {
#line 309
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 309
    de = readdir(dir);
    }
#line 309
    if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 309
      goto while_break___0;
    }
    {
#line 311
    tmp___4 = atoi((char const   *)(de->d_name));
#line 311
    pid = tmp___4;
    }
#line 311
    if (pid) {
#line 311
      if (pid == self) {
#line 312
        goto while_continue___0;
      }
    } else {
#line 312
      goto while_continue___0;
    }
#line 313
    if (pids___0 == max_pids) {
      {
#line 315
      tmp___5 = realloc((void *)pid_table, (unsigned long )(2 * pids___0) * sizeof(pid_t ));
#line 315
      pid_table = (pid_t *)tmp___5;
      }
#line 315
      if (! pid_table) {
        {
#line 317
        perror("realloc");
#line 318
        exit(1);
        }
      }
#line 320
      max_pids *= 2;
    }
#line 322
    tmp___6 = pids___0;
#line 322
    pids___0 ++;
#line 322
    *(pid_table + tmp___6) = pid;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 324
  closedir(dir);
#line 325
  pids_killed = 0;
#line 326
  tmp___7 = malloc((unsigned long )max_pids * sizeof(pid_t ));
#line 326
  pid_killed = (pid_t *)tmp___7;
  }
#line 327
  if (! pid_killed) {
    {
#line 329
    perror("malloc");
#line 330
    exit(1);
    }
  }
#line 332
  if (! process_group) {
#line 333
    pgids___0 = (pid_t *)((void *)0);
  } else {
    {
#line 336
    tmp___8 = calloc((size_t )pids___0, sizeof(pid_t ));
#line 336
    pgids___0 = (pid_t *)tmp___8;
    }
#line 337
    if (! pgids___0) {
      {
#line 339
      perror("malloc");
#line 340
      exit(1);
      }
    }
  }
#line 343
  i = 0;
  {
#line 343
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 343
    if (! (i < pids___0)) {
#line 343
      goto while_break___1;
    }
#line 346
    found_name = -1;
#line 347
    process_age_sec = (double )0;
#line 349
    if (pwent) {
      {
#line 349
      tmp___9 = match_process_uid(*(pid_table + i), pwent->pw_uid);
      }
#line 349
      if (tmp___9 == 0) {
#line 350
        goto __Cont;
      }
    }
    {
#line 365
    tmp___10 = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"/proc/%d/stat",
                        *(pid_table + i));
    }
#line 365
    if (tmp___10 < 0) {
#line 366
      goto __Cont;
    }
    {
#line 367
    file = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
    }
#line 367
    if (! file) {
      {
#line 369
      free((void *)path);
      }
#line 370
      goto __Cont;
    }
    {
#line 372
    free((void *)path);
#line 373
    tmp___11 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%*d (%15[^)]",
                      comm);
#line 373
    okay = tmp___11 == 1;
    }
#line 374
    if (! okay) {
      {
#line 375
      fclose(file);
      }
#line 376
      goto __Cont;
    }
#line 378
    if (younger_than) {
#line 378
      goto _L___0;
    } else
#line 378
    if (older_than) {
      _L___0: /* CIL Label */ 
      {
#line 379
      rewind(file);
#line 380
      proc_stt_jf = 0ULL;
#line 381
      tmp___12 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%*d %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %Lu",
                        & proc_stt_jf);
#line 381
      okay = tmp___12 == 1;
      }
#line 383
      if (! okay) {
        {
#line 384
        fclose(file);
        }
#line 385
        goto __Cont;
      }
      {
#line 387
      process_age_sec = process_age((unsigned long long const   )proc_stt_jf);
      }
    }
    {
#line 389
    fclose(file);
#line 391
    got_long = 0;
#line 392
    command = (char *)((void *)0);
#line 393
    tmp___13 = strlen((char const   *)(comm));
#line 393
    length = (int )tmp___13;
    }
#line 394
    if (length == 15) {
      {
#line 396
      tmp___14 = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"/proc/%d/cmdline",
                          *(pid_table + i));
      }
#line 396
      if (tmp___14 < 0) {
#line 397
        goto __Cont;
      }
      {
#line 398
      file = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
      }
#line 398
      if (! file) {
        {
#line 399
        free((void *)path);
        }
#line 400
        goto __Cont;
      }
      {
#line 402
      free((void *)path);
      }
      {
#line 403
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 406
        cmd_size = 128;
#line 407
        tmp___15 = malloc((size_t )cmd_size);
#line 407
        command_buf = (char *)tmp___15;
        }
#line 408
        if (! command_buf) {
          {
#line 409
          exit(1);
          }
        }
#line 412
        p = command_buf;
        {
#line 412
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 414
          if ((unsigned long )p == (unsigned long )(command_buf + cmd_size)) {
            {
#line 416
            cur_size = cmd_size;
#line 417
            cmd_size *= 2;
#line 418
            tmp___16 = realloc((void *)command_buf, (size_t )cmd_size);
#line 418
            command_buf = (char *)tmp___16;
            }
#line 419
            if (! command_buf) {
              {
#line 420
              exit(1);
              }
            }
#line 421
            p = command_buf + cur_size;
          }
          {
#line 423
          c = fgetc(file);
          }
#line 424
          if (c == -1) {
#line 425
            *p = (char )'\000';
#line 426
            goto while_break___3;
          } else
#line 424
          if (c == 0) {
#line 425
            *p = (char )'\000';
#line 426
            goto while_break___3;
          } else {
#line 428
            *p = (char )c;
          }
#line 412
          p ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 431
        tmp___17 = strlen((char const   *)command_buf);
        }
#line 431
        if (tmp___17 == 0UL) {
#line 432
          okay = 0;
#line 433
          goto while_break___2;
        }
        {
#line 435
        p = strrchr((char const   *)command_buf, '/');
        }
#line 436
        if (p) {
#line 436
          p ++;
        } else {
#line 436
          p = command_buf;
        }
        {
#line 437
        tmp___18 = strncmp((char const   *)p, (char const   *)(comm), (size_t )15);
        }
#line 437
        if (tmp___18 == 0) {
#line 438
          okay = 1;
#line 439
          command = p;
#line 440
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 443
      fclose(file);
      }
#line 444
      if (exact) {
#line 444
        if (! okay) {
#line 446
          if (verbose) {
            {
#line 447
            tmp___19 = gettext("killall: skipping partial match %s(%d)\n");
#line 447
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___19,
                    comm, *(pid_table + i));
            }
          }
#line 449
          goto __Cont;
        }
      }
#line 451
      got_long = okay;
    }
#line 454
    j = 0;
    {
#line 454
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 454
      if (! (j < names)) {
#line 454
        goto while_break___4;
      }
#line 456
      if (reg) {
#line 458
        if (got_long) {
#line 458
          tmp___20 = command;
        } else {
#line 458
          tmp___20 = comm;
        }
        {
#line 458
        tmp___21 = regexec((regex_t const   */* __restrict  */)(reglist + j), (char const   */* __restrict  */)tmp___20,
                           (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                           0);
        }
#line 458
        if (tmp___21 != 0) {
#line 459
          goto __Cont___0;
        }
      } else {
#line 463
        if (younger_than) {
#line 463
          if (process_age_sec) {
#line 463
            if (process_age_sec > (double )younger_than) {
#line 464
              goto __Cont___0;
            }
          }
        }
#line 465
        if (older_than) {
#line 465
          if (process_age_sec) {
#line 465
            if (process_age_sec < (double )older_than) {
#line 466
              goto __Cont___0;
            }
          }
        }
#line 468
        if (! sts[j].st_dev) {
#line 470
          if (length != 15) {
#line 470
            goto _L___1;
          } else
#line 470
          if (*(name_len + j) < 15) {
            _L___1: /* CIL Label */ 
#line 472
            if (ignore_case == 1) {
              {
#line 474
              tmp___22 = strcasecmp((char const   *)*(namelist + j), (char const   *)(comm));
              }
#line 474
              if (tmp___22) {
#line 475
                goto __Cont___0;
              }
            } else {
              {
#line 479
              tmp___23 = strcmp((char const   *)*(namelist + j), (char const   *)(comm));
              }
#line 479
              if (tmp___23) {
#line 480
                goto __Cont___0;
              }
            }
          } else
#line 485
          if (ignore_case == 1) {
#line 487
            if (got_long) {
              {
#line 487
              tmp___24 = strcasecmp((char const   *)*(namelist + j), (char const   *)command);
#line 487
              tmp___26 = tmp___24;
              }
            } else {
              {
#line 487
              tmp___25 = strncasecmp((char const   *)*(namelist + j), (char const   *)(comm),
                                     (size_t )15);
#line 487
              tmp___26 = tmp___25;
              }
            }
#line 487
            if (tmp___26) {
#line 489
              goto __Cont___0;
            }
          } else {
#line 493
            if (got_long) {
              {
#line 493
              tmp___27 = strcmp((char const   *)*(namelist + j), (char const   *)command);
#line 493
              tmp___29 = tmp___27;
              }
            } else {
              {
#line 493
              tmp___28 = strncmp((char const   *)*(namelist + j), (char const   *)(comm),
                                 (size_t )15);
#line 493
              tmp___29 = tmp___28;
              }
            }
#line 493
            if (tmp___29) {
#line 495
              goto __Cont___0;
            }
          }
        } else {
          {
#line 501
          ok = 1;
#line 503
          tmp___30 = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"/proc/%d/exe",
                              *(pid_table + i));
          }
#line 503
          if (tmp___30 < 0) {
#line 504
            goto __Cont___0;
          }
          {
#line 506
          tmp___35 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
          }
#line 506
          if (tmp___35 < 0) {
#line 507
            ok = 0;
          } else
#line 509
          if (sts[j].st_dev != st.st_dev) {
#line 509
            goto _L___2;
          } else
#line 509
          if (sts[j].st_ino != st.st_ino) {
            _L___2: /* CIL Label */ 
            {
#line 515
            tmp___31 = strlen((char const   *)*(namelist + j));
#line 515
            len = tmp___31;
#line 516
            tmp___32 = malloc(len + 1UL);
#line 516
            linkbuf = (char *)tmp___32;
            }
#line 518
            if (! linkbuf) {
#line 521
              ok = 0;
            } else {
              {
#line 518
              tmp___33 = readlink((char const   */* __restrict  */)path, (char */* __restrict  */)linkbuf,
                                  len + 1UL);
              }
#line 518
              if ((size_t )tmp___33 != len) {
#line 521
                ok = 0;
              } else {
                {
#line 518
                tmp___34 = memcmp((void const   *)*(namelist + j), (void const   *)linkbuf,
                                  len);
                }
#line 518
                if (tmp___34) {
#line 521
                  ok = 0;
                }
              }
            }
            {
#line 522
            free((void *)linkbuf);
            }
          }
          {
#line 525
          free((void *)path);
          }
#line 526
          if (! ok) {
#line 527
            goto __Cont___0;
          }
        }
      }
#line 530
      found_name = j;
#line 531
      goto while_break___4;
      __Cont___0: /* CIL Label */ 
#line 454
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 534
    if (names) {
#line 534
      if (found_name == -1) {
#line 535
        goto __Cont;
      }
    }
#line 538
    if (! process_group) {
#line 539
      id = *(pid_table + i);
    } else {
      {
#line 544
      id = getpgid(*(pid_table + i));
#line 545
      *(pgids___0 + i) = id;
      }
#line 546
      if (id < 0) {
        {
#line 548
        tmp___36 = __errno_location();
#line 548
        tmp___37 = strerror(*tmp___36);
#line 548
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"killall: getpgid(%d): %s\n",
                *(pid_table + i), tmp___37);
        }
      }
#line 551
      j___0 = 0;
      {
#line 551
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 551
        if (! (j___0 < i)) {
#line 551
          goto while_break___5;
        }
#line 552
        if (*(pgids___0 + j___0) == id) {
#line 553
          goto while_break___5;
        }
#line 551
        j___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 554
      if (j___0 < i) {
#line 555
        goto __Cont;
      }
    }
#line 557
    if (interactive) {
      {
#line 557
      tmp___38 = ask(comm, id, (int const   )signal___0);
      }
#line 557
      if (! tmp___38) {
#line 558
        goto __Cont;
      }
    }
#line 559
    if (process_group) {
#line 559
      tmp___47 = - id;
    } else {
#line 559
      tmp___47 = id;
    }
    {
#line 559
    tmp___48 = kill(tmp___47, signal___0);
    }
#line 559
    if (tmp___48 >= 0) {
#line 561
      if (verbose) {
#line 562
        if (process_group) {
#line 562
          tmp___39 = "pgid ";
        } else {
#line 562
          tmp___39 = "";
        }
#line 562
        if (got_long) {
#line 562
          tmp___40 = command;
        } else {
#line 562
          tmp___40 = comm;
        }
        {
#line 562
        tmp___41 = gettext("Killed %s(%s%d) with signal %d\n");
#line 562
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___41,
                tmp___40, tmp___39, id, signal___0);
        }
      }
#line 564
      if (found_name >= 0) {
#line 566
        found |= (unsigned long )(1 << found_name);
      }
#line 567
      tmp___42 = pids_killed;
#line 567
      pids_killed ++;
#line 567
      *(pid_killed + tmp___42) = id;
    } else {
      {
#line 569
      tmp___46 = __errno_location();
      }
#line 569
      if (*tmp___46 != 3) {
#line 569
        goto _L___3;
      } else
#line 569
      if (interactive) {
        _L___3: /* CIL Label */ 
        {
#line 570
        tmp___43 = __errno_location();
#line 570
        tmp___44 = strerror(*tmp___43);
        }
#line 570
        if (got_long) {
#line 570
          tmp___45 = command;
        } else {
#line 570
          tmp___45 = comm;
        }
        {
#line 570
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(%d): %s\n",
                tmp___45, id, tmp___44);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 343
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 573
  if (! quiet) {
#line 574
    i = 0;
    {
#line 574
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 574
      if (! (i < names)) {
#line 574
        goto while_break___6;
      }
#line 575
      if (! (found & (unsigned long )(1 << i))) {
        {
#line 576
        tmp___49 = gettext("%s: no process found\n");
#line 576
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___49,
                *(namelist + i));
        }
      }
#line 574
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 577
  if (names) {
#line 580
    if (found == (unsigned long )((1 << (names - 1)) | ((1 << (names - 1)) - 1))) {
#line 580
      error = 0;
    } else {
#line 580
      error = 1;
    }
  } else
#line 584
  if (pids_killed) {
#line 584
    error = 0;
  } else {
#line 584
    error = 1;
  }
  {
#line 590
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 590
    if (pids_killed) {
#line 590
      if (! wait_until_dead) {
#line 590
        goto while_break___7;
      }
    } else {
#line 590
      goto while_break___7;
    }
#line 592
    i = 0;
    {
#line 592
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 592
      if (! (i < pids_killed)) {
#line 592
        goto while_break___8;
      }
#line 594
      if (process_group) {
#line 594
        tmp___50 = - *(pid_killed + i);
      } else {
#line 594
        tmp___50 = *(pid_killed + i);
      }
      {
#line 594
      tmp___51 = kill(tmp___50, 0);
      }
#line 594
      if (tmp___51 < 0) {
        {
#line 594
        tmp___52 = __errno_location();
        }
#line 594
        if (*tmp___52 == 3) {
#line 597
          pids_killed --;
#line 597
          *(pid_killed + i) = *(pid_killed + pids_killed);
#line 598
          goto __Cont___1;
        }
      }
#line 600
      i ++;
      __Cont___1: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 602
    sleep(1U);
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 604
  return (error);
}
}
#line 608 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static void usage___0(char const   *msg ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 611
  if ((unsigned long )msg != (unsigned long )((void *)0)) {
    {
#line 612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            msg);
    }
  }
  {
#line 617
  tmp = gettext("Usage: killall [OPTION]... [--] NAME...\n");
#line 617
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 620
  tmp___0 = gettext("       killall -l, --list\n       killall -V, --version\n\n  -e,--exact          require exact match for very long names\n  -I,--ignore-case    case insensitive process name match\n  -g,--process-group  kill process group instead of process\n  -y,--younger-than   kill processes younger than TIME\n  -o,--older-than     kill processes older than TIME\n  -i,--interactive    ask for confirmation before killing\n  -l,--list           list all known signal names\n  -q,--quiet          don\'t print complaints\n  -r,--regexp         interpret NAME as an extended regular expression\n  -s,--signal SIGNAL  send this signal instead of SIGTERM\n  -u,--user USER      kill only process(es) running as USER\n  -v,--verbose        report if the signal was successfully sent\n  -V,--version        display version information\n  -w,--wait           wait for processes to die\n");
#line 620
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 642
  fputc('\n', stderr);
#line 643
  exit(1);
  }
}
}
#line 647 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
void print_version(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 649
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"killall (PSmisc) %s\n",
          "22.20");
#line 650
  tmp = gettext("Copyright (C) 1993-2012 Werner Almesberger and Craig Small\n\n");
#line 650
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 652
  tmp___0 = gettext("PSmisc comes with ABSOLUTELY NO WARRANTY.\nThis is free software, and you are welcome to redistribute it under\nthe terms of the GNU General Public License.\nFor more information about these matters, see the files named COPYING.\n");
#line 652
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
  }
#line 657
  return;
}
}
#line 659 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
static int have_proc_self_stat(void) 
{ 
  char filename[128] ;
  struct stat isproc ;
  pid_t pid ;
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 664
  tmp = getpid();
#line 664
  pid = tmp;
#line 666
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"/proc/%d/stat",
           pid);
#line 667
  tmp___0 = stat((char const   */* __restrict  */)(filename), (struct stat */* __restrict  */)(& isproc));
  }
#line 667
  return (tmp___0 == 0);
}
}
#line 670 "/home/wheatley/newnew/temp/psmisc-22.20/src/killall.c"
int main(int argc , char **argv ) 
{ 
  char *name ;
  int sig_num ;
  int optc ;
  int myoptind ;
  struct passwd *pwent ;
  char yt[16] ;
  char ot[16] ;
  struct option options[15] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 677
  pwent = (struct passwd *)((void *)0);
#line 683
  options[0].name = "exact";
#line 683
  options[0].has_arg = 0;
#line 683
  options[0].flag = (int *)((void *)0);
#line 683
  options[0].val = 'e';
#line 683
  options[1].name = "ignore-case";
#line 683
  options[1].has_arg = 0;
#line 683
  options[1].flag = (int *)((void *)0);
#line 683
  options[1].val = 'I';
#line 683
  options[2].name = "process-group";
#line 683
  options[2].has_arg = 0;
#line 683
  options[2].flag = (int *)((void *)0);
#line 683
  options[2].val = 'g';
#line 683
  options[3].name = "younger-than";
#line 683
  options[3].has_arg = 1;
#line 683
  options[3].flag = (int *)((void *)0);
#line 683
  options[3].val = 'y';
#line 683
  options[4].name = "older-than";
#line 683
  options[4].has_arg = 1;
#line 683
  options[4].flag = (int *)((void *)0);
#line 683
  options[4].val = 'o';
#line 683
  options[5].name = "interactive";
#line 683
  options[5].has_arg = 0;
#line 683
  options[5].flag = (int *)((void *)0);
#line 683
  options[5].val = 'i';
#line 683
  options[6].name = "list-signals";
#line 683
  options[6].has_arg = 0;
#line 683
  options[6].flag = (int *)((void *)0);
#line 683
  options[6].val = 'l';
#line 683
  options[7].name = "quiet";
#line 683
  options[7].has_arg = 0;
#line 683
  options[7].flag = (int *)((void *)0);
#line 683
  options[7].val = 'q';
#line 683
  options[8].name = "regexp";
#line 683
  options[8].has_arg = 0;
#line 683
  options[8].flag = (int *)((void *)0);
#line 683
  options[8].val = 'r';
#line 683
  options[9].name = "signal";
#line 683
  options[9].has_arg = 1;
#line 683
  options[9].flag = (int *)((void *)0);
#line 683
  options[9].val = 's';
#line 683
  options[10].name = "user";
#line 683
  options[10].has_arg = 1;
#line 683
  options[10].flag = (int *)((void *)0);
#line 683
  options[10].val = 'u';
#line 683
  options[11].name = "verbose";
#line 683
  options[11].has_arg = 0;
#line 683
  options[11].flag = (int *)((void *)0);
#line 683
  options[11].val = 'v';
#line 683
  options[12].name = "wait";
#line 683
  options[12].has_arg = 0;
#line 683
  options[12].flag = (int *)((void *)0);
#line 683
  options[12].val = 'w';
#line 683
  options[13].name = "version";
#line 683
  options[13].has_arg = 0;
#line 683
  options[13].flag = (int *)((void *)0);
#line 683
  options[13].val = 'V';
#line 683
  options[14].name = (char const   *)0;
#line 683
  options[14].has_arg = 0;
#line 683
  options[14].flag = (int *)0;
#line 683
  options[14].val = 0;
#line 705
  setlocale(6, "");
#line 706
  bindtextdomain("psmisc", "/usr/share/locale");
#line 707
  textdomain("psmisc");
#line 716
  name = strrchr((char const   *)*argv, '/');
  }
#line 717
  if (name) {
#line 718
    name ++;
  } else {
#line 720
    name = *argv;
  }
#line 721
  sig_num = 15;
#line 724
  opterr = 0;
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 728
    optc = getopt_long_only(argc, (char * const  *)argv, "egy:o:ilqrs:u:vwVI", (struct option  const  *)(options),
                            (int *)((void *)0));
    }
#line 728
    if (! (optc != -1)) {
#line 728
      goto while_break;
    }
    {
#line 731
    if (optc == 101) {
#line 731
      goto case_101;
    }
#line 734
    if (optc == 103) {
#line 734
      goto case_103;
    }
#line 737
    if (optc == 121) {
#line 737
      goto case_121;
    }
#line 743
    if (optc == 111) {
#line 743
      goto case_111;
    }
#line 749
    if (optc == 105) {
#line 749
      goto case_105;
    }
#line 752
    if (optc == 108) {
#line 752
      goto case_108;
    }
#line 756
    if (optc == 113) {
#line 756
      goto case_113;
    }
#line 759
    if (optc == 114) {
#line 759
      goto case_114;
    }
#line 762
    if (optc == 115) {
#line 762
      goto case_115;
    }
#line 765
    if (optc == 117) {
#line 765
      goto case_117;
    }
#line 771
    if (optc == 118) {
#line 771
      goto case_118;
    }
#line 774
    if (optc == 119) {
#line 774
      goto case_119;
    }
#line 777
    if (optc == 73) {
#line 777
      goto case_73;
    }
#line 785
    if (optc == 86) {
#line 785
      goto case_86;
    }
#line 805
    if (optc == 63) {
#line 805
      goto case_63;
    }
#line 730
    goto switch_break;
    case_101: /* CIL Label */ 
#line 732
    exact = 1;
#line 733
    goto switch_break;
    case_103: /* CIL Label */ 
#line 735
    process_group = 1;
#line 736
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 738
    strncpy((char */* __restrict  */)(yt), (char const   */* __restrict  */)optarg,
            (size_t )16);
#line 739
    yt[15] = (char )'\000';
#line 740
    younger_than = parse_time_units((char const   *)(yt));
    }
#line 740
    if (0L >= younger_than) {
      {
#line 741
      tmp = gettext("Invalid time format");
#line 741
      usage___0((char const   *)tmp);
      }
    }
#line 742
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 744
    strncpy((char */* __restrict  */)(ot), (char const   */* __restrict  */)optarg,
            (size_t )16);
#line 745
    ot[15] = (char )'\000';
#line 746
    older_than = parse_time_units((char const   *)(ot));
    }
#line 746
    if (0L >= older_than) {
      {
#line 747
      tmp___0 = gettext("Invalid time format");
#line 747
      usage___0((char const   *)tmp___0);
      }
    }
#line 748
    goto switch_break;
    case_105: /* CIL Label */ 
#line 750
    interactive = 1;
#line 751
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 753
    list_signals();
    }
#line 754
    return (0);
#line 755
    goto switch_break;
    case_113: /* CIL Label */ 
#line 757
    quiet = 1;
#line 758
    goto switch_break;
    case_114: /* CIL Label */ 
#line 760
    reg = 1;
#line 761
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 763
    sig_num = get_signal(optarg, "killall");
    }
#line 764
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 766
    pwent = getpwnam((char const   *)optarg);
    }
#line 766
    if (! pwent) {
      {
#line 767
      tmp___1 = gettext("Cannot find user %s\n");
#line 767
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              optarg);
#line 768
      exit(1);
      }
    }
#line 770
    goto switch_break;
    case_118: /* CIL Label */ 
#line 772
    verbose = 1;
#line 773
    goto switch_break;
    case_119: /* CIL Label */ 
#line 775
    wait_until_dead = 1;
#line 776
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 779
    tmp___2 = strcmp((char const   *)*(argv + (optind - 1)), "-I");
    }
#line 779
    if (tmp___2 == 0) {
#line 780
      ignore_case = 1;
    } else {
      {
#line 779
      tmp___3 = strncmp((char const   *)*(argv + (optind - 1)), "--", (size_t )2);
      }
#line 779
      if (tmp___3 == 0) {
#line 780
        ignore_case = 1;
      } else {
        {
#line 782
        sig_num = get_signal(*(argv + optind) + 1, "killall");
        }
      }
    }
#line 784
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 787
    tmp___4 = strcmp((char const   *)*(argv + (optind - 1)), "-V");
    }
#line 787
    if (tmp___4 == 0) {
      {
#line 788
      print_version();
      }
#line 789
      return (0);
    } else {
      {
#line 787
      tmp___5 = strncmp((char const   *)*(argv + (optind - 1)), "--", (size_t )2);
      }
#line 787
      if (tmp___5 == 0) {
        {
#line 788
        print_version();
        }
#line 789
        return (0);
      }
    }
    {
#line 791
    sig_num = get_signal(*(argv + optind) + 1, "killall");
    }
#line 792
    goto switch_break;
    case_63: /* CIL Label */ 
#line 808
    if ((int )*(*(argv + (optind - 1)) + 1) >= 65) {
#line 808
      if ((int )*(*(argv + (optind - 1)) + 1) <= 90) {
        {
#line 809
        sig_num = get_signal(*(argv + (optind - 1)) + 1, "killall");
        }
      } else {
#line 808
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 812
    if ((int )*(*(argv + (optind - 1)) + 1) >= 48) {
#line 812
      if ((int )*(*(argv + (optind - 1)) + 1) <= 57) {
        {
#line 813
        sig_num = atoi((char const   *)(*(argv + (optind - 1)) + 1));
        }
      } else {
        {
#line 815
        usage___0((char const   *)((void *)0));
        }
      }
    } else {
      {
#line 815
      usage___0((char const   *)((void *)0));
      }
    }
#line 818
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 821
  myoptind = optind;
#line 825
  if (argc - myoptind < 1) {
#line 825
    if ((unsigned long )pwent == (unsigned long )((void *)0)) {
      {
#line 827
      usage___0((char const   *)((void *)0));
      }
    }
  }
#line 829
  if (argc - myoptind > (int )(sizeof(unsigned long ) * 8UL)) {
    {
#line 830
    tmp___6 = gettext("killall: Maximum number of names is %d\n");
#line 830
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            (int )(sizeof(unsigned long ) * 8UL));
#line 832
    exit(1);
    }
  }
  {
#line 834
  tmp___8 = have_proc_self_stat();
  }
#line 834
  if (! tmp___8) {
    {
#line 835
    tmp___7 = gettext("killall: %s lacks process entries (not mounted ?)\n");
#line 835
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
            "/proc");
#line 837
    exit(1);
    }
  }
  {
#line 839
  argv += myoptind;
#line 845
  tmp___9 = kill_all(sig_num, argc - myoptind, argv, pwent);
  }
#line 845
  return (tmp___9);
}
}
#line 43 "/home/wheatley/newnew/temp/psmisc-22.20/src/signals.c"
static SIGNAME signals___0[34]  = 
#line 43 "/home/wheatley/newnew/temp/psmisc-22.20/src/signals.c"
  {      {1, "HUP"}, 
        {2, "INT"}, 
        {3, "QUIT"}, 
        {4, "ILL"}, 
        {5, "TRAP"}, 
        {6, "ABRT"}, 
        {6, "IOT"}, 
        {7, "BUS"}, 
        {8, "FPE"}, 
        {9, "KILL"}, 
        {10, "USR1"}, 
        {11, "SEGV"}, 
        {12, "USR2"}, 
        {13, "PIPE"}, 
        {14, "ALRM"}, 
        {15, "TERM"}, 
        {16, "STKFLT"}, 
        {17, "CHLD"}, 
        {18, "CONT"}, 
        {19, "STOP"}, 
        {20, "TSTP"}, 
        {21, "TTIN"}, 
        {22, "TTOU"}, 
        {23, "URG"}, 
        {24, "XCPU"}, 
        {25, "XFSZ"}, 
        {26, "VTALRM"}, 
        {27, "PROF"}, 
        {28, "WINCH"}, 
        {29, "IO"}, 
        {30, "PWR"}, 
        {31, "SYS"}, 
        {31, "UNUSED"}, 
        {0, (char const   *)((void *)0)}};
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 110
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) rawmemchr)(void const   *__s ,
                                                                                                  int __c )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 391
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) mempcpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 66 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void add_matched_proc(struct names *name_list , pid_t const   pid , uid_t const   uid ,
                             char const   access___0 ) ;
#line 68
static void add_special_proc(struct names *name_list , char const   ptype , uid_t const   uid ,
                             char const   *command ) ;
#line 70
static void check_dir(pid_t const   pid , char const   *dirname , struct device_list *dev_head ,
                      struct inode_list *ino_head , uid_t const   uid , char const   access___0 ,
                      struct unixsocket_list *sockets , dev_t netdev ) ;
#line 75
static void check_map(pid_t const   pid , char const   *filename , struct device_list *dev_head ,
                      struct inode_list *ino_head , uid_t const   uid , char const   access___0 ) ;
#line 79
static struct stat *get_pidstat(pid_t const   pid , char const   *filename ) ;
#line 80
static uid_t getpiduid(pid_t const   pid ) ;
#line 81
static int print_matches(struct names *names_head , opt_type const   opts , int const   sig_number ) ;
#line 83
static int kill_matched_proc(struct procs *proc_head , opt_type const   opts , int const   sig_number ) ;
#line 87
static void add_device(struct device_list **dev_list , struct names *this_name , dev_t device ) ;
#line 89
void fill_unix_cache(struct unixsocket_list **unixsocket_head ) ;
#line 90
static dev_t find_net_dev(void) ;
#line 91
static void scan_procs(struct names *names_head , struct inode_list *ino_head , struct device_list *dev_head ,
                       struct unixsocket_list *sockets , dev_t netdev ) ;
#line 94
static void scan_knfsd(struct names *names_head , struct inode_list *ino_head , struct device_list *dev_head ) ;
#line 96
static void scan_mounts(struct names *names_head , struct inode_list *ino_head , struct device_list *dev_head ) ;
#line 99
static void scan_swaps(struct names *names_head , struct inode_list *ino_head , struct device_list *dev_head ) ;
#line 112
static char *expandpath(char const   *path ) ;
#line 126 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void usage___1(char const   *errormsg ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 128
  if ((unsigned long )errormsg != (unsigned long )((void *)0)) {
    {
#line 129
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            errormsg);
    }
  }
  {
#line 131
  tmp = gettext("Usage: fuser [-fMuvw] [-a|-s] [-4|-6] [-c|-m|-n SPACE] [-k [-i] [-SIGNAL]] NAME...\n       fuser -l\n       fuser -V\nShow which processes use the named files, sockets, or filesystems.\n\n  -a,--all              display unused files too\n  -i,--interactive      ask before killing (ignored without -k)\n  -k,--kill             kill processes accessing the named file\n  -l,--list-signals     list available signal names\n  -m,--mount            show all processes using the named filesystems or block device\n  -M,--ismountpoint     fulfill request only if NAME is a mount point\n  -n,--namespace SPACE  search in this name space (file, udp, or tcp)\n  -s,--silent           silent operation\n  -SIGNAL               send this signal instead of SIGKILL\n  -u,--user             display user IDs\n  -v,--verbose          verbose output\n  -w,--writeonly        kill only processes with write access\n  -V,--version          display version information\n");
#line 131
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 150
  tmp___0 = gettext("  -4,--ipv4             search IPv4 sockets only\n  -6,--ipv6             search IPv6 sockets only\n");
#line 150
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 153
  tmp___1 = gettext("  -                     reset options\n\n  udp/tcp names: [local_port][,[rmt_host][,[rmt_port]]]\n\n");
#line 153
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
#line 155
  exit(1);
  }
}
}
#line 171 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void scan_procs(struct names *names_head , struct inode_list *ino_head , struct device_list *dev_head ,
                       struct unixsocket_list *sockets , dev_t netdev ) 
{ 
  DIR *topproc_dir ;
  struct dirent *topproc_dent ;
  struct inode_list *ino_tmp ;
  struct device_list *dev_tmp ;
  pid_t pid ;
  pid_t my_pid ;
  uid_t uid ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  dev_t cwd_dev ;
  dev_t exe_dev ;
  dev_t root_dev ;
  struct stat *cwd_stat ;
  struct stat *exe_stat ;
  struct stat *root_stat ;

  {
  {
#line 183
  topproc_dir = opendir("/proc");
  }
#line 183
  if ((unsigned long )topproc_dir == (unsigned long )((void *)0)) {
    {
#line 184
    tmp = __errno_location();
#line 184
    tmp___0 = strerror(*tmp);
#line 184
    tmp___1 = gettext("Cannot open /proc directory: %s\n");
#line 184
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            tmp___0);
#line 186
    exit(1);
    }
  }
  {
#line 188
  my_pid = getpid();
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 189
    topproc_dent = readdir(topproc_dir);
    }
#line 189
    if (! ((unsigned long )topproc_dent != (unsigned long )((void *)0))) {
#line 189
      goto while_break;
    }
#line 191
    cwd_stat = (struct stat *)((void *)0);
#line 192
    exe_stat = (struct stat *)((void *)0);
#line 193
    root_stat = (struct stat *)((void *)0);
#line 199
    if ((int )topproc_dent->d_name[0] < 48) {
#line 200
      goto while_continue;
    } else
#line 199
    if ((int )topproc_dent->d_name[0] > 57) {
#line 200
      goto while_continue;
    }
    {
#line 201
    pid = atoi((char const   *)(topproc_dent->d_name));
    }
#line 203
    if (pid == my_pid) {
#line 204
      goto while_continue;
    }
    {
#line 205
    uid = getpiduid((pid_t const   )pid);
#line 224
    cwd_stat = get_pidstat((pid_t const   )pid, "cwd");
#line 225
    exe_stat = get_pidstat((pid_t const   )pid, "exe");
#line 226
    root_stat = get_pidstat((pid_t const   )pid, "root");
    }
#line 227
    if (cwd_stat) {
#line 227
      cwd_dev = cwd_stat->st_dev;
    } else {
#line 227
      cwd_dev = (dev_t )0;
    }
#line 228
    if (exe_stat) {
#line 228
      exe_dev = exe_stat->st_dev;
    } else {
#line 228
      exe_dev = (dev_t )0;
    }
#line 229
    if (root_stat) {
#line 229
      root_dev = root_stat->st_dev;
    } else {
#line 229
      root_dev = (dev_t )0;
    }
#line 233
    dev_tmp = dev_head;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! ((unsigned long )dev_tmp != (unsigned long )((void *)0))) {
#line 233
        goto while_break___0;
      }
#line 235
      if (exe_dev == dev_tmp->device) {
        {
#line 236
        add_matched_proc(dev_tmp->name, (pid_t const   )pid, (uid_t const   )uid,
                         (char const   )2);
        }
      }
#line 238
      if (root_dev == dev_tmp->device) {
        {
#line 239
        add_matched_proc(dev_tmp->name, (pid_t const   )pid, (uid_t const   )uid,
                         (char const   )8);
        }
      }
#line 241
      if (cwd_dev == dev_tmp->device) {
        {
#line 242
        add_matched_proc(dev_tmp->name, (pid_t const   )pid, (uid_t const   )uid,
                         (char const   )1);
        }
      }
#line 233
      dev_tmp = dev_tmp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 245
    ino_tmp = ino_head;
    {
#line 245
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 245
      if (! ((unsigned long )ino_tmp != (unsigned long )((void *)0))) {
#line 245
        goto while_break___1;
      }
#line 247
      if (exe_dev == ino_tmp->device) {
#line 248
        if (! exe_stat) {
          {
#line 249
          exe_stat = get_pidstat((pid_t const   )pid, "exe");
          }
        }
#line 250
        if (exe_stat) {
#line 250
          if (exe_stat->st_dev == ino_tmp->device) {
#line 250
            if (exe_stat->st_ino == ino_tmp->inode) {
              {
#line 253
              add_matched_proc(ino_tmp->name, (pid_t const   )pid, (uid_t const   )uid,
                               (char const   )2);
              }
            }
          }
        }
      }
#line 256
      if (root_dev == ino_tmp->device) {
#line 257
        if (! root_stat) {
          {
#line 258
          root_stat = get_pidstat((pid_t const   )pid, "root");
          }
        }
#line 259
        if (root_stat) {
#line 259
          if (root_stat->st_dev == ino_tmp->device) {
#line 259
            if (root_stat->st_ino == ino_tmp->inode) {
              {
#line 262
              add_matched_proc(ino_tmp->name, (pid_t const   )pid, (uid_t const   )uid,
                               (char const   )8);
              }
            }
          }
        }
      }
#line 265
      if (cwd_dev == ino_tmp->device) {
#line 266
        if (! cwd_stat) {
          {
#line 267
          cwd_stat = get_pidstat((pid_t const   )pid, "cwd");
          }
        }
#line 268
        if (cwd_stat) {
#line 268
          if (cwd_stat->st_dev == ino_tmp->device) {
#line 268
            if (cwd_stat->st_ino == ino_tmp->inode) {
              {
#line 271
              add_matched_proc(ino_tmp->name, (pid_t const   )pid, (uid_t const   )uid,
                               (char const   )1);
              }
            }
          }
        }
      }
#line 245
      ino_tmp = ino_tmp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 275
    if (root_stat) {
      {
#line 276
      free((void *)root_stat);
      }
    }
#line 277
    if (cwd_stat) {
      {
#line 278
      free((void *)cwd_stat);
      }
    }
#line 279
    if (exe_stat) {
      {
#line 280
      free((void *)exe_stat);
      }
    }
    {
#line 287
    check_dir((pid_t const   )pid, "fd", dev_head, ino_head, (uid_t const   )uid,
              (char const   )4, sockets, netdev);
#line 289
    check_map((pid_t const   )pid, "maps", dev_head, ino_head, (uid_t const   )uid,
              (char const   )16);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 292
  closedir(topproc_dir);
  }
#line 293
  return;
}
}
#line 295 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void add_inode(struct inode_list **ino_list , struct names *this_name , dev_t device ,
                      ino_t inode ) 
{ 
  struct inode_list *ino_tmp ;
  struct inode_list *ino_head ;
  void *tmp ;

  {
  {
#line 301
  tmp = malloc(sizeof(struct inode_list ));
#line 301
  ino_tmp = (struct inode_list *)tmp;
  }
#line 301
  if ((unsigned long )ino_tmp == (unsigned long )((void *)0)) {
#line 303
    return;
  }
#line 304
  ino_head = *ino_list;
#line 305
  ino_tmp->name = this_name;
#line 306
  ino_tmp->device = device;
#line 307
  ino_tmp->inode = inode;
#line 308
  ino_tmp->next = ino_head;
#line 309
  *ino_list = ino_tmp;
#line 310
  return;
}
}
#line 312 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void add_device(struct device_list **dev_list , struct names *this_name , dev_t device ) 
{ 
  struct device_list *dev_tmp ;
  struct device_list *dev_head ;
  void *tmp ;

  {
  {
#line 321
  tmp = malloc(sizeof(struct device_list ));
#line 321
  dev_tmp = (struct device_list *)tmp;
  }
#line 321
  if ((unsigned long )dev_tmp == (unsigned long )((void *)0)) {
#line 323
    return;
  }
#line 324
  dev_head = *dev_list;
#line 325
  dev_tmp->name = this_name;
#line 326
  dev_tmp->device = device;
#line 327
  dev_tmp->next = dev_head;
#line 328
  *dev_list = dev_tmp;
#line 329
  return;
}
}
#line 331 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void add_ip_conn(struct ip_connections **ip_list , char const   *protocol ,
                        struct names *this_name , int const   lcl_port , int const   rmt_port ,
                        unsigned long rmt_address ) 
{ 
  struct ip_connections *ip_tmp ;
  struct ip_connections *ip_head ;
  void *tmp ;

  {
  {
#line 338
  tmp = malloc(sizeof(struct ip_connections ));
#line 338
  ip_tmp = (struct ip_connections *)tmp;
  }
#line 338
  if ((unsigned long )ip_tmp == (unsigned long )((void *)0)) {
#line 341
    return;
  }
#line 342
  ip_head = *ip_list;
#line 343
  ip_tmp->name = this_name;
#line 344
  ip_tmp->lcl_port = (unsigned long )lcl_port;
#line 345
  ip_tmp->rmt_port = (unsigned long )rmt_port;
#line 346
  ip_tmp->rmt_address.s_addr = (in_addr_t )rmt_address;
#line 347
  ip_tmp->next = ip_head;
#line 349
  *ip_list = ip_tmp;
#line 350
  return;
}
}
#line 353 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void add_ip6_conn(struct ip6_connections **ip_list , char const   *protocol ,
                         struct names *this_name , int const   lcl_port , int const   rmt_port ,
                         struct in6_addr rmt_address ) 
{ 
  struct ip6_connections *ip_tmp ;
  struct ip6_connections *ip_head ;
  void *tmp ;

  {
  {
#line 360
  tmp = malloc(sizeof(struct ip6_connections ));
#line 360
  ip_tmp = (struct ip6_connections *)tmp;
  }
#line 360
  if ((unsigned long )ip_tmp == (unsigned long )((void *)0)) {
#line 363
    return;
  }
  {
#line 364
  ip_head = *ip_list;
#line 365
  ip_tmp->name = this_name;
#line 366
  ip_tmp->lcl_port = (unsigned long )lcl_port;
#line 367
  ip_tmp->rmt_port = (unsigned long )rmt_port;
#line 368
  memcpy((void */* __restrict  */)(& ip_tmp->rmt_address), (void const   */* __restrict  */)(& rmt_address),
         sizeof(struct in6_addr ));
#line 369
  ip_tmp->next = ip_head;
#line 371
  *ip_list = ip_tmp;
  }
#line 372
  return;
}
}
#line 376 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void add_matched_proc(struct names *name_list , pid_t const   pid , uid_t const   uid ,
                             char const   access___0 ) 
{ 
  struct procs *pptr ;
  struct procs *last_proc ;
  char *pathname ;
  char cmdname[101] ;
  char *cptr ;
  int cmdlen ;
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 386
  last_proc = (struct procs *)((void *)0);
#line 387
  pptr = name_list->matched_procs;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! ((unsigned long )pptr != (unsigned long )((void *)0))) {
#line 387
      goto while_break;
    }
#line 388
    last_proc = pptr;
#line 389
    if (pptr->pid == (pid_t )pid) {
#line 390
      pptr->access = (char )((int )pptr->access | (int )access___0);
#line 391
      return;
    }
#line 387
    pptr = pptr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 395
  tmp___2 = malloc(sizeof(struct procs ));
#line 395
  pptr = (struct procs *)tmp___2;
  }
#line 395
  if ((unsigned long )pptr == (unsigned long )((void *)0)) {
    {
#line 396
    tmp = __errno_location();
#line 396
    tmp___0 = strerror(*tmp);
#line 396
    tmp___1 = gettext("Cannot allocate memory for matched proc: %s\n");
#line 396
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            tmp___0);
    }
#line 399
    return;
  }
  {
#line 401
  pptr->pid = (pid_t )pid;
#line 402
  pptr->uid = (uid_t )uid;
#line 403
  pptr->access = (char )access___0;
#line 404
  pptr->proc_type = (char)0;
#line 405
  pptr->next = (struct procs *)((void *)0);
#line 407
  pptr->command = (char *)((void *)0);
#line 409
  fp = (FILE *)((void *)0);
#line 410
  pathname = (char *)((void *)0);
#line 411
  tmp___8 = asprintf((char **/* __restrict  */)(& pathname), (char const   */* __restrict  */)"/proc/%d/stat",
                     pid);
  }
#line 411
  if (tmp___8 > 0) {
    {
#line 411
    fp = fopen((char const   */* __restrict  */)pathname, (char const   */* __restrict  */)"r");
    }
#line 411
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
      {
#line 411
      tmp___9 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%*d (%100[^)]",
                       cmdname);
      }
#line 411
      if (tmp___9 == 1) {
        {
#line 414
        tmp___7 = malloc((size_t )17);
#line 414
        tmp___6 = (char *)tmp___7;
#line 414
        pptr->command = tmp___6;
        }
#line 414
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 415
          cmdlen = 0;
#line 416
          cptr = cmdname;
          {
#line 416
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 416
            if (cmdlen < 16) {
#line 416
              if (! *cptr) {
#line 416
                goto while_break___0;
              }
            } else {
#line 416
              goto while_break___0;
            }
            {
#line 418
            tmp___5 = __ctype_b_loc();
            }
#line 418
            if ((int const   )*(*tmp___5 + (int )*cptr) & 16384) {
#line 419
              tmp___3 = cmdlen;
#line 419
              cmdlen ++;
#line 419
              *(pptr->command + tmp___3) = *cptr;
            } else
#line 420
            if (cmdlen < 12) {
              {
#line 421
              tmp___4 = sprintf((char */* __restrict  */)(pptr->command + cmdlen),
                                (char const   */* __restrict  */)"\\%03o", (int )*cptr);
#line 421
              cmdlen += tmp___4;
              }
            }
#line 416
            cptr ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 425
          *(pptr->command + cmdlen) = (char )'\000';
        }
      }
    }
  }
#line 427
  if ((unsigned long )last_proc == (unsigned long )((void *)0)) {
#line 428
    name_list->matched_procs = pptr;
  } else {
#line 430
    last_proc->next = pptr;
  }
#line 431
  if (pathname) {
    {
#line 432
    free((void *)pathname);
    }
  }
#line 433
  if (fp) {
    {
#line 434
    fclose(fp);
    }
  }
#line 435
  return;
}
}
#line 438 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void add_special_proc(struct names *name_list , char const   ptype , uid_t const   uid ,
                             char const   *command ) 
{ 
  struct procs *pptr ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
#line 444
  pptr = name_list->matched_procs;
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    if (! ((unsigned long )pptr != (unsigned long )((void *)0))) {
#line 444
      goto while_break;
    }
#line 445
    if ((int )pptr->proc_type == (int )ptype) {
#line 446
      return;
    }
#line 444
    pptr = pptr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 448
  tmp___2 = malloc(sizeof(struct procs ));
#line 448
  pptr = (struct procs *)tmp___2;
  }
#line 448
  if ((unsigned long )pptr == (unsigned long )((void *)0)) {
    {
#line 449
    tmp = __errno_location();
#line 449
    tmp___0 = strerror(*tmp);
#line 449
    tmp___1 = gettext("Cannot allocate memory for matched proc: %s\n");
#line 449
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            tmp___0);
    }
#line 452
    return;
  }
  {
#line 454
  pptr->pid = 0;
#line 455
  pptr->uid = (uid_t )uid;
#line 456
  pptr->access = (char)0;
#line 457
  pptr->proc_type = (char )ptype;
#line 459
  pptr->next = name_list->matched_procs;
#line 460
  name_list->matched_procs = pptr;
#line 462
  pptr->command = strdup(command);
  }
#line 463
  return;
}
}
#line 465 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
int parse_file(struct names *this_name , struct inode_list **ino_list , char const   opts ) 
{ 
  char *new ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 468
  tmp = expandpath((char const   *)this_name->filename);
#line 468
  new = tmp;
  }
#line 469
  if (new) {
#line 470
    if (this_name->filename) {
      {
#line 471
      free((void *)this_name->filename);
      }
    }
    {
#line 472
    this_name->filename = strdup((char const   *)new);
    }
  }
  {
#line 475
  tmp___5 = stat((char const   */* __restrict  */)this_name->filename, (struct stat */* __restrict  */)(& this_name->st));
  }
#line 475
  if (tmp___5 != 0) {
    {
#line 476
    tmp___4 = __errno_location();
    }
#line 476
    if (*tmp___4 == 2) {
      {
#line 477
      tmp___0 = gettext("Specified filename %s does not exist.\n");
#line 477
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              this_name->filename);
      }
    } else {
      {
#line 481
      tmp___1 = __errno_location();
#line 481
      tmp___2 = strerror(*tmp___1);
#line 481
      tmp___3 = gettext("Cannot stat %s: %s\n");
#line 481
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              this_name->filename, tmp___2);
      }
    }
#line 483
    return (-1);
  }
  {
#line 490
  add_inode(ino_list, this_name, this_name->st.st_dev, this_name->st.st_ino);
  }
#line 492
  return (0);
}
}
#line 495 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
int parse_unixsockets(struct names *this_name , struct inode_list **ino_list , struct unixsocket_list *sun_head ) 
{ 
  struct unixsocket_list *sun_tmp ;
  dev_t net_dev ;

  {
  {
#line 502
  net_dev = find_net_dev();
#line 504
  sun_tmp = sun_head;
  }
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! ((unsigned long )sun_tmp != (unsigned long )((void *)0))) {
#line 504
      goto while_break;
    }
#line 505
    if (sun_tmp->dev == this_name->st.st_dev) {
#line 505
      if (sun_tmp->inode == this_name->st.st_ino) {
        {
#line 507
        add_inode(ino_list, this_name, net_dev, sun_tmp->net_inode);
        }
#line 509
        return (0);
      }
    }
#line 504
    sun_tmp = sun_tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  return (0);
}
}
#line 515 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
int parse_mounts(struct names *this_name , struct device_list **dev_list , char const   opts ) 
{ 
  dev_t match_device ;

  {
#line 521
  if ((this_name->st.st_mode & 61440U) == 24576U) {
#line 522
    match_device = this_name->st.st_rdev;
  } else {
#line 524
    match_device = this_name->st.st_dev;
  }
  {
#line 525
  add_device(dev_list, this_name, match_device);
  }
#line 526
  return (0);
}
}
#line 530 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
int parse_inet(struct names *this_name , int const   ipv6_only , int const   ipv4_only ,
               struct ip_connections **ip_list , struct ip6_connections **ip6_list ) 
{ 
  struct addrinfo *res ;
  struct addrinfo *resptr ;
  struct addrinfo hints ;
  int errcode ;
  char *lcl_port_str ;
  char *rmt_addr_str ;
  char *rmt_port_str ;
  char *tmpstr ;
  char *tmpstr2 ;
  in_port_t lcl_port ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  char hostspec[100] ;
  char *protocol ;
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  uint16_t tmp___5 ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  uint16_t tmp___8 ;
  uint16_t tmp___9 ;
  uint16_t tmp___10 ;
  uint16_t tmp___11 ;
  uint16_t tmp___12 ;
  int tmp___13 ;

  {
  {
#line 550
  protocol = strchr((char const   *)this_name->filename, '/');
  }
#line 550
  if ((unsigned long )protocol == (unsigned long )((void *)0)) {
#line 551
    return (-1);
  }
#line 552
  protocol ++;
#line 553
  if ((int )*(protocol + 0) == 0) {
#line 554
    return (-1);
  }
#line 555
  i = 0;
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (i < 99) {
#line 555
      if ((int )*(this_name->filename + i) != 0) {
#line 555
        if (! ((int )*(this_name->filename + i) != 47)) {
#line 555
          goto while_break;
        }
      } else {
#line 555
        goto while_break;
      }
    } else {
#line 555
      goto while_break;
    }
#line 558
    hostspec[i] = *(this_name->filename + i);
#line 555
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 559
  hostspec[i] = (char )'\000';
#line 561
  rmt_port_str = (char *)((void *)0);
#line 561
  rmt_addr_str = rmt_port_str;
#line 561
  lcl_port_str = rmt_addr_str;
#line 563
  tmpstr = strchr((char const   *)(hostspec), ',');
  }
#line 563
  if ((unsigned long )tmpstr == (unsigned long )((void *)0)) {
    {
#line 565
    lcl_port_str = strdup((char const   *)(hostspec));
    }
  } else {
#line 567
    if ((unsigned long )tmpstr == (unsigned long )(hostspec)) {
#line 568
      lcl_port_str = (char *)((void *)0);
    } else {
      {
#line 570
      *tmpstr = (char )'\000';
#line 571
      lcl_port_str = strdup((char const   *)(hostspec));
      }
    }
#line 573
    tmpstr ++;
#line 574
    if ((int )*tmpstr != 0) {
      {
#line 575
      tmpstr2 = strchr((char const   *)tmpstr, ',');
      }
#line 575
      if ((unsigned long )tmpstr2 == (unsigned long )((void *)0)) {
#line 577
        rmt_addr_str = tmpstr;
      } else {
#line 579
        if ((unsigned long )tmpstr2 == (unsigned long )tmpstr) {
#line 580
          rmt_addr_str = (char *)((void *)0);
        } else {
#line 582
          rmt_addr_str = tmpstr;
#line 583
          *tmpstr2 = (char )'\000';
        }
#line 585
        tmpstr2 ++;
#line 586
        if ((int )*tmpstr2 != 0) {
#line 587
          rmt_port_str = tmpstr2;
        }
      }
    }
  }
  {
#line 596
  memset((void *)(& hints), 0, sizeof(hints));
  }
#line 598
  if (ipv6_only) {
#line 599
    hints.ai_family = 10;
  } else
#line 600
  if (ipv4_only) {
#line 601
    hints.ai_family = 2;
  } else {
#line 603
    hints.ai_family = 0;
  }
  {
#line 607
  tmp = strcmp((char const   *)protocol, "tcp");
  }
#line 607
  if (tmp == 0) {
#line 608
    hints.ai_socktype = 1;
  } else {
#line 610
    hints.ai_socktype = 2;
  }
#line 612
  if ((unsigned long )lcl_port_str == (unsigned long )((void *)0)) {
#line 613
    lcl_port = (in_port_t )0;
  } else {
    {
#line 616
    errcode = getaddrinfo((char const   */* __restrict  */)((void *)0), (char const   */* __restrict  */)lcl_port_str,
                          (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
    }
#line 616
    if (errcode != 0) {
      {
#line 618
      tmp___0 = gai_strerror(errcode);
#line 618
      tmp___1 = gettext("Cannot resolve local port %s: %s\n");
#line 618
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              lcl_port_str, tmp___0);
      }
#line 620
      return (-1);
    }
#line 622
    if ((unsigned long )res == (unsigned long )((void *)0)) {
#line 623
      return (-1);
    }
    {
#line 625
    if (res->ai_family == 2) {
#line 625
      goto case_2;
    }
#line 630
    if (res->ai_family == 10) {
#line 630
      goto case_10;
    }
#line 635
    goto switch_default;
    case_2: /* CIL Label */ 
#line 626
    lcl_port = ((struct sockaddr_in *)res->ai_addr)->sin_port;
#line 628
    goto switch_break;
    case_10: /* CIL Label */ 
#line 631
    lcl_port = ((struct sockaddr_in6 *)res->ai_addr)->sin6_port;
#line 633
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 636
    tmp___2 = gettext("Unknown local port AF %d\n");
#line 636
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            res->ai_family);
#line 638
    freeaddrinfo(res);
    }
#line 639
    return (-1);
    switch_break: /* CIL Label */ ;
    }
    {
#line 641
    freeaddrinfo(res);
    }
  }
  {
#line 643
  free((void *)lcl_port_str);
#line 644
  res = (struct addrinfo *)((void *)0);
  }
#line 645
  if ((unsigned long )rmt_addr_str == (unsigned long )((void *)0)) {
#line 645
    if ((unsigned long )rmt_port_str == (unsigned long )((void *)0)) {
      {
#line 646
      tmp___3 = ntohs(lcl_port);
#line 646
      add_ip_conn(ip_list, (char const   *)protocol, this_name, (int const   )tmp___3,
                  (int const   )0, (unsigned long )((in_addr_t )0));
#line 649
      tmp___4 = ntohs(lcl_port);
#line 649
      add_ip6_conn(ip6_list, (char const   *)protocol, this_name, (int const   )tmp___4,
                   (int const   )0, (struct in6_addr )in6addr_any);
      }
#line 652
      return (0);
    } else {
#line 645
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 655
    tmp___13 = getaddrinfo((char const   */* __restrict  */)rmt_addr_str, (char const   */* __restrict  */)rmt_port_str,
                           (struct addrinfo  const  */* __restrict  */)(& hints),
                           (struct addrinfo **/* __restrict  */)(& res));
    }
#line 655
    if (tmp___13 == 0) {
#line 656
      resptr = res;
      {
#line 656
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 656
        if (! ((unsigned long )resptr != (unsigned long )((void *)0))) {
#line 656
          goto while_break___0;
        }
        {
#line 659
        if (resptr->ai_family == 2) {
#line 659
          goto case_2___0;
        }
#line 680
        if (resptr->ai_family == 10) {
#line 680
          goto case_10___0;
        }
#line 658
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
#line 660
        sin = (struct sockaddr_in *)resptr->ai_addr;
#line 662
        if ((unsigned long )rmt_addr_str == (unsigned long )((void *)0)) {
          {
#line 663
          tmp___5 = ntohs(sin->sin_port);
#line 663
          tmp___6 = ntohs(lcl_port);
#line 663
          add_ip_conn(ip_list, (char const   *)protocol, this_name, (int const   )tmp___6,
                      (int const   )tmp___5, (unsigned long )((in_addr_t )0));
          }
        } else {
          {
#line 670
          tmp___7 = ntohs(sin->sin_port);
#line 670
          tmp___8 = ntohs(lcl_port);
#line 670
          add_ip_conn(ip_list, (char const   *)protocol, this_name, (int const   )tmp___8,
                      (int const   )tmp___7, (unsigned long )sin->sin_addr.s_addr);
          }
        }
#line 678
        goto switch_break___0;
        case_10___0: /* CIL Label */ 
#line 681
        sin6 = (struct sockaddr_in6 *)resptr->ai_addr;
#line 683
        if ((unsigned long )rmt_addr_str == (unsigned long )((void *)0)) {
          {
#line 684
          tmp___9 = ntohs(sin6->sin6_port);
#line 684
          tmp___10 = ntohs(lcl_port);
#line 684
          add_ip6_conn(ip6_list, (char const   *)protocol, this_name, (int const   )tmp___10,
                       (int const   )tmp___9, (struct in6_addr )in6addr_any);
          }
        } else {
          {
#line 691
          tmp___11 = ntohs(sin6->sin6_port);
#line 691
          tmp___12 = ntohs(lcl_port);
#line 691
          add_ip6_conn(ip6_list, (char const   *)protocol, this_name, (int const   )tmp___12,
                       (int const   )tmp___11, sin6->sin6_addr);
          }
        }
#line 698
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 656
        resptr = resptr->ai_next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 702
      return (0);
    }
  }
#line 705
  return (1);
}
}
#line 708 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
void find_net_sockets(struct inode_list **ino_list , struct ip_connections *conn_list ,
                      char const   *protocol , dev_t netdev ) 
{ 
  FILE *fp ;
  char pathname[200] ;
  char line[8192] ;
  unsigned long loc_port ;
  unsigned long rmt_port ;
  unsigned long rmt_addr ;
  unsigned long scanned_inode ;
  ino_t inode ;
  struct ip_connections *conn_tmp ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 720
  tmp = snprintf((char */* __restrict  */)(pathname), (size_t )200, (char const   */* __restrict  */)"/proc/net/%s",
                 protocol);
  }
#line 720
  if (tmp < 0) {
#line 721
    return;
  }
  {
#line 723
  fp = fopen((char const   */* __restrict  */)(pathname), (char const   */* __restrict  */)"r");
  }
#line 723
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 724
    tmp___0 = __errno_location();
#line 724
    tmp___1 = strerror(*tmp___0);
#line 724
    tmp___2 = gettext("Cannot open protocol file \"%s\": %s\n");
#line 724
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            pathname, tmp___1);
    }
#line 726
    return;
  }
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 728
    tmp___5 = fgets((char */* __restrict  */)(line), 8192, (FILE */* __restrict  */)fp);
    }
#line 728
    if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
#line 728
      goto while_break;
    }
    {
#line 729
    tmp___3 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%*u: %*x:%lx %08lx:%lx %*x %*x:%*x %*x:%*x %*x %*d %*d %lu",
                     & loc_port, & rmt_addr, & rmt_port, & scanned_inode);
    }
#line 729
    if (tmp___3 != 4) {
#line 733
      goto while_continue;
    }
#line 738
    inode = scanned_inode;
#line 739
    conn_tmp = conn_list;
    {
#line 739
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 739
      if (! ((unsigned long )conn_tmp != (unsigned long )((void *)0))) {
#line 739
        goto while_break___0;
      }
#line 747
      if (conn_tmp->lcl_port == 0UL) {
#line 747
        goto _L___0;
      } else
#line 747
      if (conn_tmp->lcl_port == loc_port) {
        _L___0: /* CIL Label */ 
#line 747
        if (conn_tmp->rmt_port == 0UL) {
#line 747
          goto _L;
        } else
#line 747
        if (conn_tmp->rmt_port == rmt_port) {
          _L: /* CIL Label */ 
#line 747
          if (conn_tmp->rmt_address.s_addr == 0U) {
            {
#line 760
            add_inode(ino_list, conn_tmp->name, netdev, inode);
            }
          } else {
            {
#line 747
            tmp___4 = memcmp((void const   *)(& conn_tmp->rmt_address), (void const   *)(& rmt_addr),
                             (size_t )4);
            }
#line 747
            if (tmp___4 == 0) {
              {
#line 760
              add_inode(ino_list, conn_tmp->name, netdev, inode);
              }
            }
          }
        }
      }
#line 739
      conn_tmp = conn_tmp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 766
  fclose(fp);
  }
#line 767
  return;
}
}
#line 770 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
void find_net6_sockets(struct inode_list **ino_list , struct ip6_connections *conn_list ,
                       char const   *protocol , dev_t const   netdev ) 
{ 
  FILE *fp ;
  char pathname[200] ;
  char line[8192] ;
  unsigned long loc_port ;
  unsigned long rmt_port ;
  struct in6_addr rmt_addr ;
  unsigned int tmp_addr[4] ;
  char rmt_addr6str[46] ;
  struct ip6_connections *conn_tmp ;
  unsigned long scanned_inode ;
  ino_t inode ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 785
  tmp = snprintf((char */* __restrict  */)(pathname), (size_t )200, (char const   */* __restrict  */)"/proc/net/%s6",
                 protocol);
  }
#line 785
  if (tmp < 0) {
#line 786
    return;
  }
  {
#line 788
  fp = fopen((char const   */* __restrict  */)(pathname), (char const   */* __restrict  */)"r");
  }
#line 788
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 793
    return;
  }
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 795
    tmp___3 = fgets((char */* __restrict  */)(line), 8192, (FILE */* __restrict  */)fp);
    }
#line 795
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 795
      goto while_break;
    }
    {
#line 796
    tmp___0 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%*u: %*x:%lx %08x%08x%08x%08x:%lx %*x %*x:%*x %*x:%*x %*x %*d %*d %lu",
                     & loc_port, & tmp_addr[0], & tmp_addr[1], & tmp_addr[2], & tmp_addr[3],
                     & rmt_port, & scanned_inode);
    }
#line 796
    if (tmp___0 != 7) {
#line 801
      goto while_continue;
    }
    {
#line 802
    inode = scanned_inode;
#line 803
    rmt_addr.__in6_u.__u6_addr32[0] = tmp_addr[0];
#line 804
    rmt_addr.__in6_u.__u6_addr32[1] = tmp_addr[1];
#line 805
    rmt_addr.__in6_u.__u6_addr32[2] = tmp_addr[2];
#line 806
    rmt_addr.__in6_u.__u6_addr32[3] = tmp_addr[3];
#line 807
    inet_ntop(10, (void const   */* __restrict  */)(& rmt_addr), (char */* __restrict  */)(rmt_addr6str),
              (socklen_t )46);
#line 812
    conn_tmp = conn_list;
    }
    {
#line 812
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 812
      if (! ((unsigned long )conn_tmp != (unsigned long )((void *)0))) {
#line 812
        goto while_break___0;
      }
      {
#line 814
      inet_ntop(10, (void const   */* __restrict  */)(& conn_tmp->rmt_address), (char */* __restrict  */)(rmt_addr6str),
                (socklen_t )46);
      }
#line 821
      if (conn_tmp->lcl_port == 0UL) {
#line 821
        goto _L___0;
      } else
#line 821
      if (conn_tmp->lcl_port == loc_port) {
        _L___0: /* CIL Label */ 
#line 821
        if (conn_tmp->rmt_port == 0UL) {
#line 821
          goto _L;
        } else
#line 821
        if (conn_tmp->rmt_port == rmt_port) {
          _L: /* CIL Label */ 
          {
#line 821
          tmp___1 = memcmp((void const   *)(& conn_tmp->rmt_address), (void const   *)(& in6addr_any),
                           (size_t )16);
          }
#line 821
          if (tmp___1 == 0) {
            {
#line 831
            add_inode(ino_list, conn_tmp->name, (dev_t )netdev, inode);
            }
          } else {
            {
#line 821
            tmp___2 = memcmp((void const   *)(& conn_tmp->rmt_address), (void const   *)(& rmt_addr),
                             (size_t )16);
            }
#line 821
            if (tmp___2 == 0) {
              {
#line 831
              add_inode(ino_list, conn_tmp->name, (dev_t )netdev, inode);
              }
            }
          }
        }
      }
#line 812
      conn_tmp = conn_tmp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 836
  fclose(fp);
  }
#line 837
  return;
}
}
#line 840 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void read_proc_mounts(struct mount_list **mnt_list ) 
{ 
  FILE *fp ;
  char line[8192] ;
  char *find_mountp ;
  char *find_space ;
  struct mount_list *mnt_tmp ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 848
  fp = fopen((char const   */* __restrict  */)"/proc/mounts", (char const   */* __restrict  */)"r");
  }
#line 848
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 849
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s\n",
            "/proc/mounts");
    }
#line 850
    return;
  }
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 852
    tmp___1 = fgets((char */* __restrict  */)(line), 8192, (FILE */* __restrict  */)fp);
    }
#line 852
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 852
      goto while_break;
    }
    {
#line 853
    find_mountp = strchr((char const   *)(line), ' ');
    }
#line 853
    if ((unsigned long )find_mountp == (unsigned long )((void *)0)) {
#line 854
      goto while_continue;
    }
    {
#line 855
    find_mountp ++;
#line 856
    find_space = strchr((char const   *)find_mountp, ' ');
    }
#line 856
    if ((unsigned long )find_space == (unsigned long )((void *)0)) {
#line 857
      goto while_continue;
    }
    {
#line 858
    *find_space = (char )'\000';
#line 859
    tmp = malloc(sizeof(struct mount_list ));
#line 859
    mnt_tmp = (struct mount_list *)tmp;
    }
#line 859
    if ((unsigned long )mnt_tmp == (unsigned long )((void *)0)) {
#line 860
      goto while_continue;
    }
    {
#line 861
    tmp___0 = strdup((char const   *)find_mountp);
#line 861
    mnt_tmp->mountpoint = tmp___0;
    }
#line 861
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 862
      goto while_continue;
    }
#line 863
    mnt_tmp->next = *mnt_list;
#line 864
    *mnt_list = mnt_tmp;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 866
  fclose(fp);
  }
#line 867
  return;
}
}
#line 869 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static int is_mountpoint(struct mount_list **mnt_list , char *arg ) 
{ 
  char *p ;
  struct mount_list *mnt_tmp ;
  int tmp ;

  {
#line 874
  if ((int )*arg == 0) {
#line 875
    return (0);
  }
#line 877
  p = arg;
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    if (! ((int )*p != 0)) {
#line 877
      goto while_break;
    }
#line 877
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 878
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 878
    p --;
#line 878
    if ((int )*p == 47) {
#line 878
      if (! ((unsigned long )p > (unsigned long )arg)) {
#line 878
        goto while_break___0;
      }
    } else {
#line 878
      goto while_break___0;
    }
#line 879
    *p = (char )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 881
  mnt_tmp = *mnt_list;
  {
#line 881
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 881
    if (! ((unsigned long )mnt_tmp != (unsigned long )((void *)0))) {
#line 881
      goto while_break___1;
    }
    {
#line 882
    tmp = strcmp((char const   *)mnt_tmp->mountpoint, (char const   *)arg);
    }
#line 882
    if (! tmp) {
#line 883
      return (1);
    }
#line 881
    mnt_tmp = mnt_tmp->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 884
  return (0);
}
}
#line 1202 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static int print_matches(struct names *names_head , opt_type const   opts , int const   sig_number ) 
{ 
  struct names *nptr ;
  struct procs *pptr ;
  char head ;
  char first ;
  int len ;
  struct passwd *pwent ;
  int have_match ;
  int have_kill ;
  int name_has_procs ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 1208
  head = (char)0;
#line 1209
  first = (char)1;
#line 1210
  len = 0;
#line 1211
  pwent = (struct passwd *)((void *)0);
#line 1212
  have_match = 0;
#line 1213
  have_kill = 0;
#line 1214
  name_has_procs = 0;
#line 1216
  nptr = names_head;
  {
#line 1216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1216
    if (! ((unsigned long )nptr != (unsigned long )((void *)0))) {
#line 1216
      goto while_break;
    }
#line 1217
    if ((int const   )opts & 32) {
#line 1218
      pptr = nptr->matched_procs;
      {
#line 1218
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1218
        if (! ((unsigned long )pptr != (unsigned long )((void *)0))) {
#line 1218
          goto while_break___0;
        }
#line 1220
        if ((int )pptr->proc_type != 0) {
#line 1221
          goto __Cont;
        }
#line 1223
        have_match = 1;
        __Cont: /* CIL Label */ 
#line 1218
        pptr = pptr->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1226
      if (((int const   )opts & 2) == 0) {
#line 1227
        name_has_procs = 0;
#line 1228
        if ((int const   )opts & 1) {
#line 1229
          if (nptr->matched_procs) {
#line 1230
            name_has_procs = 1;
          }
        } else {
#line 1232
          pptr = nptr->matched_procs;
          {
#line 1232
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1232
            if (! ((unsigned long )pptr != (unsigned long )((void *)0))) {
#line 1232
              goto while_break___1;
            }
#line 1234
            if ((int )pptr->proc_type == 0) {
#line 1236
              name_has_procs = 1;
#line 1237
              goto while_break___1;
            }
#line 1232
            pptr = pptr->next;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
#line 1242
      if (name_has_procs == 1) {
#line 1242
        goto _L;
      } else
#line 1242
      if ((int const   )opts & 2) {
        _L: /* CIL Label */ 
#line 1243
        if ((int )head == 0) {
#line 1243
          if ((int const   )opts & 1) {
            {
#line 1244
            tmp = gettext("%*s USER        PID ACCESS COMMAND\n");
#line 1244
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                    20, "");
#line 1248
            head = (char)1;
            }
          }
        }
        {
#line 1251
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:",
                nptr->filename);
#line 1252
        tmp___0 = strlen((char const   *)nptr->filename);
#line 1252
        len = (int )(tmp___0 + 1UL);
        }
      }
#line 1255
      first = (char)1;
#line 1256
      pptr = nptr->matched_procs;
      {
#line 1256
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1256
        if (! ((unsigned long )pptr != (unsigned long )((void *)0))) {
#line 1256
          goto while_break___2;
        }
#line 1259
        if (! ((int const   )opts & 1)) {
#line 1259
          if ((int )pptr->proc_type != 0) {
#line 1261
            goto __Cont___0;
          }
        }
#line 1263
        have_match = 1;
#line 1264
        if ((int const   )opts & 65) {
#line 1265
          if ((unsigned long )pwent == (unsigned long )((void *)0)) {
            {
#line 1267
            pwent = getpwuid(pptr->uid);
            }
          } else
#line 1265
          if (pwent->pw_uid != pptr->uid) {
            {
#line 1267
            pwent = getpwuid(pptr->uid);
            }
          }
        }
#line 1269
        if (len > 20) {
#line 1269
          if ((int const   )opts & 1) {
            {
#line 1270
            _IO_putc('\n', stderr);
#line 1271
            len = 0;
            }
          }
        }
#line 1273
        if ((int const   )opts & 1) {
#line 1273
          goto _L___0;
        } else
#line 1273
        if (first) {
          _L___0: /* CIL Label */ 
          {
#line 1274
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1274
            tmp___1 = len;
#line 1274
            len ++;
#line 1274
            if (! (tmp___1 < 20)) {
#line 1274
              goto while_break___3;
            }
            {
#line 1275
            _IO_putc(' ', stderr);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 1276
        if ((int const   )opts & 1) {
#line 1277
          if ((unsigned long )pwent == (unsigned long )((void *)0)) {
            {
#line 1278
            tmp___2 = gettext("(unknown)");
#line 1278
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %-8s ",
                    tmp___2);
            }
          } else {
            {
#line 1281
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %-8s ",
                    pwent->pw_name);
            }
          }
        }
#line 1284
        if ((int )pptr->proc_type == 0) {
          {
#line 1285
          printf((char const   */* __restrict  */)" %5d", pptr->pid);
          }
        } else {
          {
#line 1287
          printf((char const   */* __restrict  */)"kernel");
          }
        }
        {
#line 1288
        fflush(stdout);
        }
#line 1289
        if ((int const   )opts & 1) {
          {
#line 1291
          if ((int )pptr->proc_type == 2) {
#line 1291
            goto case_2;
          }
#line 1294
          if ((int )pptr->proc_type == 1) {
#line 1294
            goto case_1;
          }
#line 1297
          if ((int )pptr->proc_type == 3) {
#line 1297
            goto case_3;
          }
#line 1300
          goto switch_default;
          case_2: /* CIL Label */ 
          {
#line 1292
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" knfsd ");
          }
#line 1293
          goto switch_break;
          case_1: /* CIL Label */ 
          {
#line 1295
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" mount ");
          }
#line 1296
          goto switch_break;
          case_3: /* CIL Label */ 
          {
#line 1298
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" swap  ");
          }
#line 1299
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 1301
          if ((int )pptr->access & 16) {
#line 1301
            if (! ((int )pptr->access & 2)) {
#line 1301
              tmp___3 = 'm';
            } else {
#line 1301
              tmp___3 = '.';
            }
          } else {
#line 1301
            tmp___3 = '.';
          }
#line 1301
          if ((int )pptr->access & 2) {
#line 1301
            tmp___4 = 'e';
          } else {
#line 1301
            tmp___4 = '.';
          }
#line 1301
          if ((int )pptr->access & 1) {
#line 1301
            tmp___5 = 'c';
          } else {
#line 1301
            tmp___5 = '.';
          }
#line 1301
          if ((int )pptr->access & 8) {
#line 1301
            tmp___6 = 'r';
          } else {
#line 1301
            tmp___6 = '.';
          }
#line 1301
          if ((int )pptr->access & 4) {
#line 1301
            if ((int )pptr->access & 32) {
#line 1301
              tmp___7 = 'F';
            } else {
#line 1301
              tmp___7 = 'f';
            }
#line 1301
            tmp___8 = tmp___7;
          } else {
#line 1301
            tmp___8 = '.';
          }
          {
#line 1301
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %c%c%c%c%c ",
                  tmp___8, tmp___6, tmp___5, tmp___4, tmp___3);
          }
          switch_break: /* CIL Label */ ;
          }
        } else {
#line 1324
          if ((int )pptr->access & 8) {
            {
#line 1325
            _IO_putc('r', stderr);
            }
          }
#line 1326
          if ((int )pptr->access & 1) {
            {
#line 1327
            _IO_putc('c', stderr);
            }
          }
#line 1328
          if ((int )pptr->access & 2) {
            {
#line 1329
            _IO_putc('e', stderr);
            }
          } else
#line 1330
          if ((int )pptr->access & 16) {
            {
#line 1331
            _IO_putc('m', stderr);
            }
          }
        }
#line 1333
        if ((int const   )opts & 64) {
#line 1334
          if ((unsigned long )pwent == (unsigned long )((void *)0)) {
            {
#line 1335
            tmp___9 = gettext("(unknown)");
#line 1335
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %-8s ",
                    tmp___9);
            }
          } else {
            {
#line 1338
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(%s)",
                    pwent->pw_name);
            }
          }
        }
#line 1341
        if ((int const   )opts & 1) {
#line 1342
          if ((unsigned long )pptr->command == (unsigned long )((void *)0)) {
            {
#line 1343
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"???\n");
            }
          } else {
            {
#line 1345
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                    pptr->command);
            }
          }
        }
#line 1348
        len = 0;
#line 1349
        first = (char)0;
        __Cont___0: /* CIL Label */ 
#line 1256
        pptr = pptr->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1351
      if ((int const   )opts & 1) {
#line 1353
        if ((unsigned long )nptr->matched_procs == (unsigned long )((void *)0)) {
#line 1353
          if ((int const   )opts & 2) {
            {
#line 1355
            _IO_putc('\n', stderr);
            }
          }
        }
      } else
#line 1357
      if (name_has_procs) {
        {
#line 1358
        _IO_putc('\n', stderr);
        }
      } else
#line 1357
      if ((int const   )opts & 2) {
        {
#line 1358
        _IO_putc('\n', stderr);
        }
      }
    }
#line 1361
    if ((int const   )opts & 8) {
      {
#line 1362
      have_kill = kill_matched_proc(nptr->matched_procs, opts, sig_number);
      }
    }
#line 1216
    nptr = nptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1366
  if ((int const   )opts & 8) {
#line 1367
    if (have_kill == 1) {
#line 1367
      tmp___10 = 0;
    } else {
#line 1367
      tmp___10 = 1;
    }
#line 1367
    return (tmp___10);
  } else {
#line 1369
    if (have_match == 1) {
#line 1369
      tmp___11 = 0;
    } else {
#line 1369
      tmp___11 = 1;
    }
#line 1369
    return (tmp___11);
  }
}
}
#line 1373 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static struct stat *get_pidstat(pid_t const   pid , char const   *filename ) 
{ 
  char pathname[256] ;
  struct stat *st ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1378
  tmp = malloc(sizeof(struct stat ));
#line 1378
  st = (struct stat *)tmp;
  }
#line 1378
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 1379
    return ((struct stat *)((void *)0));
  }
  {
#line 1380
  snprintf((char */* __restrict  */)(pathname), (size_t )256, (char const   */* __restrict  */)"/proc/%d/%s",
           pid, filename);
#line 1381
  tmp___0 = stat((char const   */* __restrict  */)(pathname), (struct stat */* __restrict  */)st);
  }
#line 1381
  if (tmp___0 != 0) {
    {
#line 1382
    free((void *)st);
    }
#line 1383
    return ((struct stat *)((void *)0));
  }
#line 1385
  return (st);
}
}
#line 1388 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void check_dir(pid_t const   pid , char const   *dirname , struct device_list *dev_head ,
                      struct inode_list *ino_head , uid_t const   uid , char const   access___0 ,
                      struct unixsocket_list *sockets , dev_t netdev ) 
{ 
  DIR *dirp ;
  dev_t thedev ;
  struct dirent *direntry ;
  struct inode_list *ino_tmp ;
  struct device_list *dev_tmp ;
  struct unixsocket_list *sock_tmp ;
  struct stat st ;
  struct stat lst ;
  char dirpath[200] ;
  char filepath[200] ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1403
  snprintf((char */* __restrict  */)(dirpath), (size_t )200, (char const   */* __restrict  */)"/proc/%d/%s",
           pid, dirname);
#line 1404
  dirp = opendir((char const   *)(dirpath));
  }
#line 1404
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 1405
    return;
  }
  {
#line 1406
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1406
    direntry = readdir(dirp);
    }
#line 1406
    if (! ((unsigned long )direntry != (unsigned long )((void *)0))) {
#line 1406
      goto while_break;
    }
#line 1407
    if ((int )direntry->d_name[0] < 48) {
#line 1408
      goto while_continue;
    } else
#line 1407
    if ((int )direntry->d_name[0] > 57) {
#line 1408
      goto while_continue;
    }
    {
#line 1410
    snprintf((char */* __restrict  */)(filepath), (size_t )200, (char const   */* __restrict  */)"/proc/%d/%s/%s",
             pid, dirname, direntry->d_name);
#line 1413
    tmp___9 = stat((char const   */* __restrict  */)(filepath), (struct stat */* __restrict  */)(& st));
    }
#line 1413
    if (tmp___9 != 0) {
      {
#line 1414
      tmp___2 = __errno_location();
      }
#line 1414
      if (*tmp___2 != 2) {
        {
#line 1415
        tmp = __errno_location();
#line 1415
        tmp___0 = strerror(*tmp);
#line 1415
        tmp___1 = gettext("Cannot stat file %s: %s\n");
#line 1415
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                filepath, tmp___0);
        }
      }
    } else {
#line 1419
      thedev = st.st_dev;
#line 1420
      if (thedev == netdev) {
#line 1421
        sock_tmp = sockets;
        {
#line 1421
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1421
          if (! ((unsigned long )sock_tmp != (unsigned long )((void *)0))) {
#line 1421
            goto while_break___0;
          }
#line 1423
          if (sock_tmp->net_inode == st.st_ino) {
#line 1424
            st.st_ino = sock_tmp->inode;
#line 1425
            st.st_dev = sock_tmp->dev;
#line 1426
            thedev = sock_tmp->dev;
#line 1427
            goto while_break___0;
          }
#line 1421
          sock_tmp = sock_tmp->next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1431
      dev_tmp = dev_head;
      {
#line 1431
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1431
        if (! ((unsigned long )dev_tmp != (unsigned long )((void *)0))) {
#line 1431
          goto while_break___1;
        }
#line 1433
        if (thedev != dev_tmp->device) {
#line 1434
          goto __Cont;
        }
#line 1435
        if ((int const   )access___0 == 4) {
          {
#line 1435
          tmp___3 = lstat((char const   */* __restrict  */)(filepath), (struct stat */* __restrict  */)(& lst));
          }
#line 1435
          if (tmp___3 == 0) {
#line 1435
            if (lst.st_mode & 128U) {
              {
#line 1438
              add_matched_proc(dev_tmp->name, pid, uid, (char const   )(32 | (int )access___0));
              }
            } else {
              {
#line 1443
              add_matched_proc(dev_tmp->name, pid, uid, access___0);
              }
            }
          } else {
            {
#line 1443
            add_matched_proc(dev_tmp->name, pid, uid, access___0);
            }
          }
        } else {
          {
#line 1443
          add_matched_proc(dev_tmp->name, pid, uid, access___0);
          }
        }
        __Cont: /* CIL Label */ 
#line 1431
        dev_tmp = dev_tmp->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1447
      ino_tmp = ino_head;
      {
#line 1447
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1447
        if (! ((unsigned long )ino_tmp != (unsigned long )((void *)0))) {
#line 1447
          goto while_break___2;
        }
#line 1449
        if (thedev != ino_tmp->device) {
#line 1450
          goto __Cont___0;
        }
#line 1451
        if (! st.st_ino) {
          {
#line 1451
          tmp___7 = stat((char const   */* __restrict  */)(filepath), (struct stat */* __restrict  */)(& st));
          }
#line 1451
          if (tmp___7 != 0) {
            {
#line 1453
            tmp___4 = __errno_location();
#line 1453
            tmp___5 = strerror(*tmp___4);
#line 1453
            tmp___6 = gettext("Cannot stat file %s: %s\n");
#line 1453
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
                    filepath, tmp___5);
            }
#line 1456
            goto __Cont___0;
          }
        }
#line 1458
        if (st.st_ino == ino_tmp->inode) {
#line 1459
          if ((int const   )access___0 == 4) {
            {
#line 1459
            tmp___8 = lstat((char const   */* __restrict  */)(filepath), (struct stat */* __restrict  */)(& lst));
            }
#line 1459
            if (tmp___8 == 0) {
#line 1459
              if (lst.st_mode & 128U) {
                {
#line 1462
                add_matched_proc(ino_tmp->name, pid, uid, (char const   )(32 | (int )access___0));
                }
              } else {
                {
#line 1467
                add_matched_proc(ino_tmp->name, pid, uid, access___0);
                }
              }
            } else {
              {
#line 1467
              add_matched_proc(ino_tmp->name, pid, uid, access___0);
              }
            }
          } else {
            {
#line 1467
            add_matched_proc(ino_tmp->name, pid, uid, access___0);
            }
          }
        }
        __Cont___0: /* CIL Label */ 
#line 1447
        ino_tmp = ino_tmp->next;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1475
  closedir(dirp);
  }
#line 1476
  return;
}
}
#line 1478 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void check_map(pid_t const   pid , char const   *filename , struct device_list *dev_head ,
                      struct inode_list *ino_head , uid_t const   uid , char const   access___0 ) 
{ 
  char pathname[200] ;
  char line[8192] ;
  struct inode_list *ino_tmp ;
  struct device_list *dev_tmp ;
  FILE *fp ;
  unsigned long long tmp_inode ;
  unsigned int tmp_maj ;
  unsigned int tmp_min ;
  dev_t tmp_device ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1492
  snprintf((char */* __restrict  */)(pathname), (size_t )200, (char const   */* __restrict  */)"/proc/%d/%s",
           pid, filename);
#line 1493
  fp = fopen((char const   */* __restrict  */)(pathname), (char const   */* __restrict  */)"r");
  }
#line 1493
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1494
    return;
  }
  {
#line 1495
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1495
    tmp___0 = fgets((char */* __restrict  */)(line), 8192, (FILE */* __restrict  */)fp);
    }
#line 1495
    if (! tmp___0) {
#line 1495
      goto while_break;
    }
    {
#line 1496
    tmp = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%*s %*s %*s %x:%x %lld",
                 & tmp_maj, & tmp_min, & tmp_inode);
    }
#line 1496
    if (tmp == 3) {
#line 1498
      tmp_device = (dev_t )(tmp_maj * 256U + tmp_min);
#line 1499
      dev_tmp = dev_head;
      {
#line 1499
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1499
        if (! ((unsigned long )dev_tmp != (unsigned long )((void *)0))) {
#line 1499
          goto while_break___0;
        }
#line 1501
        if (dev_tmp->device == tmp_device) {
          {
#line 1502
          add_matched_proc(dev_tmp->name, pid, uid, access___0);
          }
        }
#line 1499
        dev_tmp = dev_tmp->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1504
      ino_tmp = ino_head;
      {
#line 1504
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1504
        if (! ((unsigned long )ino_tmp != (unsigned long )((void *)0))) {
#line 1504
          goto while_break___1;
        }
#line 1506
        if (ino_tmp->device == tmp_device) {
#line 1506
          if ((unsigned long long )ino_tmp->inode == tmp_inode) {
            {
#line 1508
            add_matched_proc(ino_tmp->name, pid, uid, access___0);
            }
          }
        }
#line 1504
        ino_tmp = ino_tmp->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1512
  fclose(fp);
  }
#line 1513
  return;
}
}
#line 1515 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static uid_t getpiduid(pid_t const   pid ) 
{ 
  char pathname[200] ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1520
  tmp = snprintf((char */* __restrict  */)(pathname), (size_t )200, (char const   */* __restrict  */)"/proc/%d",
                 pid);
  }
#line 1520
  if (tmp < 0) {
#line 1521
    return ((uid_t )0);
  }
  {
#line 1522
  tmp___0 = stat((char const   */* __restrict  */)(pathname), (struct stat */* __restrict  */)(& st));
  }
#line 1522
  if (tmp___0 != 0) {
#line 1523
    return ((uid_t )0);
  }
#line 1524
  return (st.st_uid);
}
}
#line 1531 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
void fill_unix_cache(struct unixsocket_list **unixsocket_head ) 
{ 
  FILE *fp ;
  char line[8192] ;
  int scanned_inode ;
  struct stat st ;
  struct unixsocket_list *newsocket ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *path ;
  char *scanned_path ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1539
  fp = fopen((char const   */* __restrict  */)"/proc/net/unix", (char const   */* __restrict  */)"r");
  }
#line 1539
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1540
    tmp = __errno_location();
#line 1540
    tmp___0 = strerror(*tmp);
#line 1540
    tmp___1 = gettext("Cannot open /proc/net/unix: %s\n");
#line 1540
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            tmp___0);
    }
#line 1542
    return;
  }
  {
#line 1544
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1544
    tmp___5 = fgets((char */* __restrict  */)(line), 8192, (FILE */* __restrict  */)fp);
    }
#line 1544
    if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
#line 1544
      goto while_break;
    }
    {
#line 1546
    scanned_path = (char *)((void *)0);
#line 1547
    tmp___2 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%*x: %*x %*x %*x %*x %*d %d %as",
                     & scanned_inode, & scanned_path);
    }
#line 1547
    if (tmp___2 != 2) {
#line 1549
      if (scanned_path) {
        {
#line 1550
        free((void *)scanned_path);
        }
      }
#line 1551
      goto while_continue;
    }
#line 1553
    if ((unsigned long )scanned_path == (unsigned long )((void *)0)) {
#line 1554
      goto while_continue;
    }
#line 1555
    path = scanned_path;
#line 1556
    if ((int )*scanned_path == 64) {
#line 1557
      scanned_path ++;
    }
    {
#line 1558
    tmp___3 = stat((char const   */* __restrict  */)scanned_path, (struct stat */* __restrict  */)(& st));
    }
#line 1558
    if (tmp___3 < 0) {
      {
#line 1559
      free((void *)path);
      }
#line 1560
      goto while_continue;
    }
    {
#line 1562
    tmp___4 = malloc(sizeof(struct unixsocket_list ));
#line 1562
    newsocket = (struct unixsocket_list *)tmp___4;
    }
#line 1562
    if ((unsigned long )newsocket == (unsigned long )((void *)0)) {
      {
#line 1564
      free((void *)path);
      }
#line 1565
      goto while_continue;
    }
    {
#line 1567
    newsocket->sun_name = strdup((char const   *)scanned_path);
#line 1568
    newsocket->inode = st.st_ino;
#line 1569
    newsocket->dev = st.st_dev;
#line 1570
    newsocket->net_inode = (ino_t )scanned_inode;
#line 1571
    newsocket->next = *unixsocket_head;
#line 1572
    *unixsocket_head = newsocket;
#line 1573
    free((void *)path);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1576
  fclose(fp);
  }
#line 1577
  return;
}
}
#line 1608 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static int ask___0(pid_t const   pid ) 
{ 
  int res ;
  size_t len ;
  char *line ;
  char *tmp ;
  __ssize_t tmp___0 ;

  {
  {
#line 1611
  len = (size_t )0;
#line 1612
  line = (char *)((void *)0);
#line 1614
  fflush(stdout);
  }
  {
#line 1615
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1616
    tmp = gettext("Kill process %d ? (y/N) ");
#line 1616
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            pid);
#line 1617
    fflush(stderr);
#line 1618
    tmp___0 = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& len),
                      (FILE */* __restrict  */)stdin);
    }
#line 1618
    if (tmp___0 < 0L) {
#line 1619
      return (0);
    }
#line 1620
    if ((int )*(line + 0) == 10) {
      {
#line 1621
      free((void *)line);
      }
#line 1622
      return (0);
    }
    {
#line 1624
    res = rpmatch((char const   *)line);
    }
#line 1625
    if (res >= 0) {
      {
#line 1626
      free((void *)line);
      }
#line 1627
      return (res);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1632 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static int kill_matched_proc(struct procs *proc_head , opt_type const   opts , int const   sig_number ) 
{ 
  struct procs *pptr ;
  pid_t mypid ;
  int ret ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1638
  ret = 0;
#line 1640
  mypid = getpid();
#line 1642
  pptr = proc_head;
  }
  {
#line 1642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1642
    if (! ((unsigned long )pptr != (unsigned long )((void *)0))) {
#line 1642
      goto while_break;
    }
#line 1643
    if (pptr->pid == mypid) {
#line 1644
      goto __Cont;
    }
#line 1645
    if ((int )pptr->proc_type != 0) {
#line 1646
      goto __Cont;
    }
#line 1647
    if ((int const   )opts & 256) {
#line 1647
      if (((int )pptr->access & 32) == 0) {
#line 1648
        goto __Cont;
      }
    }
#line 1649
    if ((int const   )opts & 16) {
      {
#line 1649
      tmp = ask___0((pid_t const   )pptr->pid);
      }
#line 1649
      if (tmp == 0) {
#line 1650
        goto __Cont;
      }
    }
    {
#line 1651
    tmp___3 = kill(pptr->pid, (int )sig_number);
    }
#line 1651
    if (tmp___3 < 0) {
      {
#line 1652
      tmp___0 = __errno_location();
#line 1652
      tmp___1 = strerror(*tmp___0);
#line 1652
      tmp___2 = gettext("Could not kill process %d: %s\n");
#line 1652
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              pptr->pid, tmp___1);
      }
#line 1654
      goto __Cont;
    }
#line 1656
    ret = 1;
    __Cont: /* CIL Label */ 
#line 1642
    pptr = pptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1658
  return (ret);
}
}
#line 1661 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static dev_t find_net_dev(void) 
{ 
  int skt ;
  struct stat st ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1666
  skt = socket(2, 2, 0);
  }
#line 1666
  if (skt < 0) {
    {
#line 1667
    tmp = gettext("Cannot open a network socket.\n");
#line 1667
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
    }
#line 1668
    return ((dev_t )-1);
  }
  {
#line 1670
  tmp___1 = fstat(skt, & st);
  }
#line 1670
  if (tmp___1 != 0) {
    {
#line 1671
    tmp___0 = gettext("Cannot find socket\'s device number.\n");
#line 1671
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 1672
    close(skt);
    }
#line 1673
    return ((dev_t )-1);
  }
  {
#line 1675
  close(skt);
  }
#line 1676
  return (st.st_dev);
}
}
#line 1679 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void scan_knfsd(struct names *names_head , struct inode_list *ino_head , struct device_list *dev_head ) 
{ 
  struct device_list *dev_tmp ;
  struct inode_list *ino_tmp ;
  FILE *fp ;
  char line[8192] ;
  char *find_space ;
  struct stat st ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1690
  fp = fopen((char const   */* __restrict  */)"/proc/fs/nfs/exports", (char const   */* __restrict  */)"r");
  }
#line 1690
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1694
    return;
  }
  {
#line 1696
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1696
    tmp___0 = fgets((char */* __restrict  */)(line), 8192, (FILE */* __restrict  */)fp);
    }
#line 1696
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 1696
      goto while_break;
    }
#line 1697
    if ((int )line[0] == 35) {
#line 1698
      goto while_continue;
    }
    {
#line 1700
    find_space = strpbrk((char const   *)(line), " \t");
    }
#line 1700
    if ((unsigned long )find_space == (unsigned long )((void *)0)) {
#line 1701
      goto while_continue;
    }
    {
#line 1702
    *find_space = (char )'\000';
#line 1703
    tmp = stat((char const   */* __restrict  */)(line), (struct stat */* __restrict  */)(& st));
    }
#line 1703
    if (tmp != 0) {
#line 1704
      goto while_continue;
    }
#line 1707
    dev_tmp = dev_head;
    {
#line 1707
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1707
      if (! ((unsigned long )dev_tmp != (unsigned long )((void *)0))) {
#line 1707
        goto while_break___0;
      }
#line 1709
      if (st.st_dev == dev_tmp->device) {
        {
#line 1710
        add_special_proc(dev_tmp->name, (char const   )2, (uid_t const   )0, (char const   *)(line));
        }
      }
#line 1707
      dev_tmp = dev_tmp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1713
    ino_tmp = ino_head;
    {
#line 1713
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1713
      if (! ((unsigned long )ino_tmp != (unsigned long )((void *)0))) {
#line 1713
        goto while_break___1;
      }
#line 1715
      if (st.st_dev == ino_tmp->device) {
#line 1715
        if (st.st_ino == ino_tmp->inode) {
          {
#line 1717
          add_special_proc(ino_tmp->name, (char const   )2, (uid_t const   )0, (char const   *)(line));
          }
        }
      }
#line 1713
      ino_tmp = ino_tmp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1721
  fclose(fp);
  }
#line 1722
  return;
}
}
#line 1724 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void scan_mounts(struct names *names_head , struct inode_list *ino_head , struct device_list *dev_head ) 
{ 
  struct device_list *dev_tmp ;
  struct inode_list *ino_tmp ;
  FILE *fp ;
  char line[8192] ;
  char *find_mountp ;
  char *find_space ;
  struct stat st ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1736
  fp = fopen((char const   */* __restrict  */)"/proc/mounts", (char const   */* __restrict  */)"r");
  }
#line 1736
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1737
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s\n",
            "/proc/mounts");
    }
#line 1738
    return;
  }
  {
#line 1740
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1740
    tmp___0 = fgets((char */* __restrict  */)(line), 8192, (FILE */* __restrict  */)fp);
    }
#line 1740
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 1740
      goto while_break;
    }
    {
#line 1741
    find_mountp = strchr((char const   *)(line), ' ');
    }
#line 1741
    if ((unsigned long )find_mountp == (unsigned long )((void *)0)) {
#line 1742
      goto while_continue;
    }
    {
#line 1743
    find_mountp ++;
#line 1744
    find_space = strchr((char const   *)find_mountp, ' ');
    }
#line 1744
    if ((unsigned long )find_space == (unsigned long )((void *)0)) {
#line 1745
      goto while_continue;
    }
    {
#line 1746
    *find_space = (char )'\000';
#line 1747
    tmp = stat((char const   */* __restrict  */)find_mountp, (struct stat */* __restrict  */)(& st));
    }
#line 1747
    if (tmp != 0) {
#line 1748
      goto while_continue;
    }
#line 1751
    dev_tmp = dev_head;
    {
#line 1751
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1751
      if (! ((unsigned long )dev_tmp != (unsigned long )((void *)0))) {
#line 1751
        goto while_break___0;
      }
#line 1753
      if (st.st_dev == dev_tmp->device) {
        {
#line 1754
        add_special_proc(dev_tmp->name, (char const   )1, (uid_t const   )0, (char const   *)find_mountp);
        }
      }
#line 1751
      dev_tmp = dev_tmp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1757
    ino_tmp = ino_head;
    {
#line 1757
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1757
      if (! ((unsigned long )ino_tmp != (unsigned long )((void *)0))) {
#line 1757
        goto while_break___1;
      }
#line 1759
      if (st.st_dev == ino_tmp->device) {
#line 1759
        if (st.st_ino == ino_tmp->inode) {
          {
#line 1761
          add_special_proc(ino_tmp->name, (char const   )1, (uid_t const   )0, (char const   *)find_mountp);
          }
        }
      }
#line 1757
      ino_tmp = ino_tmp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1765
  fclose(fp);
  }
#line 1766
  return;
}
}
#line 1768 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static void scan_swaps(struct names *names_head , struct inode_list *ino_head , struct device_list *dev_head ) 
{ 
  struct device_list *dev_tmp ;
  struct inode_list *ino_tmp ;
  FILE *fp ;
  char line[8192] ;
  char *find_space ;
  struct stat st ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1779
  fp = fopen((char const   */* __restrict  */)"/proc/swaps", (char const   */* __restrict  */)"r");
  }
#line 1779
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1781
    return;
  }
  {
#line 1784
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1784
    tmp___0 = fgets((char */* __restrict  */)(line), 8192, (FILE */* __restrict  */)fp);
    }
#line 1784
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 1784
      goto while_break;
    }
    {
#line 1785
    find_space = strchr((char const   *)(line), ' ');
    }
#line 1785
    if ((unsigned long )find_space == (unsigned long )((void *)0)) {
#line 1786
      goto while_continue;
    }
#line 1787
    *find_space = (char )'\000';
#line 1788
    find_space ++;
    {
#line 1789
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1789
      if (! ((int )*find_space == 32)) {
#line 1789
        goto while_break___0;
      }
#line 1790
      find_space ++;
#line 1791
      if ((int )*find_space == 0) {
#line 1792
        goto while_continue___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1794
    tmp = stat((char const   */* __restrict  */)(line), (struct stat */* __restrict  */)(& st));
    }
#line 1794
    if (tmp != 0) {
#line 1795
      goto while_continue;
    }
#line 1798
    dev_tmp = dev_head;
    {
#line 1798
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1798
      if (! ((unsigned long )dev_tmp != (unsigned long )((void *)0))) {
#line 1798
        goto while_break___1;
      }
#line 1800
      if (st.st_dev == dev_tmp->device) {
        {
#line 1801
        add_special_proc(dev_tmp->name, (char const   )3, (uid_t const   )0, (char const   *)(line));
        }
      }
#line 1798
      dev_tmp = dev_tmp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1804
    ino_tmp = ino_head;
    {
#line 1804
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1804
      if (! ((unsigned long )ino_tmp != (unsigned long )((void *)0))) {
#line 1804
        goto while_break___2;
      }
#line 1806
      if (st.st_dev == ino_tmp->device) {
#line 1806
        if (st.st_ino == ino_tmp->inode) {
          {
#line 1808
          add_special_proc(ino_tmp->name, (char const   )3, (uid_t const   )0, (char const   *)(line));
          }
        }
      }
#line 1804
      ino_tmp = ino_tmp->next;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1812
  fclose(fp);
  }
#line 1813
  return;
}
}
#line 2011 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static char real[4097]  ;
#line 2012 "/home/wheatley/newnew/temp/psmisc-22.20/src/fuser.c"
static char *expandpath(char const   *path ) 
{ 
  char tmpbuf[4097] ;
  char const   *start ;
  char const   *end ;
  char *curr ;
  char *dest ;
  int deep ;
  char *tmp ;
  void *tmp___0 ;
  char lnkbuf[4097] ;
  size_t len ;
  ssize_t n ;
  char *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  void *tmp___9 ;

  {
#line 2017
  deep = 20;
#line 2019
  if (! path) {
#line 2020
    return ((char *)0);
  } else
#line 2019
  if ((int const   )*path == 0) {
#line 2020
    return ((char *)0);
  }
#line 2022
  curr = & real[0];
#line 2024
  if ((int const   )*path != 47) {
    {
#line 2025
    tmp = getcwd(curr, (size_t )4096);
    }
#line 2025
    if (! tmp) {
#line 2026
      return ((char *)0);
    }
    {
#line 2028
    tmp___0 = rawmemchr((void const   *)curr, '\000');
#line 2028
    dest = (char *)tmp___0;
    }
  } else {
#line 2033
    *curr = (char )'/';
#line 2034
    dest = curr + 1;
  }
#line 2037
  end = path;
#line 2037
  start = end;
  {
#line 2037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2037
    if (! *start) {
#line 2037
      goto while_break;
    }
    {
#line 2039
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2039
      if (! ((int const   )*start == 47)) {
#line 2039
        goto while_break___0;
      }
#line 2040
      start ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2042
    end = start;
    {
#line 2042
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2042
      if (*end) {
#line 2042
        if (! ((int const   )*end != 47)) {
#line 2042
          goto while_break___1;
        }
      } else {
#line 2042
        goto while_break___1;
      }
#line 2042
      end ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2044
    if (end - start == 0L) {
#line 2045
      goto while_break;
    } else
#line 2046
    if (end - start == 1L) {
#line 2046
      if (! ((int const   )*(start + 0) == 46)) {
#line 2046
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2048
    if (end - start == 2L) {
#line 2048
      if ((int const   )*(start + 0) == 46) {
#line 2048
        if ((int const   )*(start + 1) == 46) {
#line 2050
          if ((unsigned long )dest > (unsigned long )(curr + 1)) {
            {
#line 2051
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2051
              dest --;
#line 2051
              if (! ((int )*(dest + -1) != 47)) {
#line 2051
                goto while_break___2;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        } else {
#line 2048
          goto _L___0;
        }
      } else {
#line 2048
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2057
      if ((int )*(dest + -1) != 47) {
#line 2058
        tmp___1 = dest;
#line 2058
        dest ++;
#line 2058
        *tmp___1 = (char )'/';
      }
#line 2060
      if ((unsigned long )(dest + (end - start)) > (unsigned long )(curr + 4096)) {
        {
#line 2061
        tmp___2 = __errno_location();
#line 2061
        *tmp___2 = 36;
        }
#line 2062
        return ((char *)0);
      }
      {
#line 2065
      tmp___3 = mempcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)start,
                        (size_t )(end - start));
#line 2065
      dest = (char *)tmp___3;
#line 2066
      *dest = (char )'\000';
#line 2068
      tmp___5 = deep;
#line 2068
      deep --;
      }
#line 2068
      if (tmp___5 < 0) {
        {
#line 2069
        tmp___4 = __errno_location();
#line 2069
        *tmp___4 = 40;
        }
#line 2070
        return ((char *)0);
      }
      {
#line 2073
      tmp___6 = __errno_location();
#line 2073
      *tmp___6 = 0;
#line 2074
      n = readlink((char const   */* __restrict  */)curr, (char */* __restrict  */)(lnkbuf),
                   (size_t )4096);
      }
#line 2074
      if (n < 0L) {
        {
#line 2075
        deep = 20;
#line 2076
        tmp___7 = __errno_location();
        }
#line 2076
        if (*tmp___7 == 22) {
#line 2077
          goto __Cont;
        }
#line 2078
        return ((char *)0);
      }
      {
#line 2080
      lnkbuf[n] = (char )'\000';
#line 2082
      len = strlen(end);
      }
#line 2083
      if ((size_t )n + len > 4096UL) {
        {
#line 2084
        tmp___8 = __errno_location();
#line 2084
        *tmp___8 = 36;
        }
#line 2085
        return ((char *)0);
      }
      {
#line 2088
      memmove((void *)(& tmpbuf[n]), (void const   *)end, len + 1UL);
#line 2089
      tmp___9 = memcpy((void */* __restrict  */)(tmpbuf), (void const   */* __restrict  */)(lnkbuf),
                       (size_t )n);
#line 2089
      end = (char const   *)tmp___9;
#line 2089
      path = end;
      }
#line 2091
      if ((int )lnkbuf[0] == 47) {
#line 2092
        dest = curr + 1;
      } else
#line 2093
      if ((unsigned long )dest > (unsigned long )(curr + 1)) {
        {
#line 2094
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2094
          dest --;
#line 2094
          if (! ((int )*(dest + -1) != 47)) {
#line 2094
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 2037
    start = end;
  }
  while_break: /* CIL Label */ ;
  }
#line 2099
  if ((unsigned long )dest > (unsigned long )(curr + 1)) {
#line 2099
    if ((int )*(dest + -1) == 47) {
#line 2100
      dest --;
    }
  }
#line 2101
  *dest = (char )'\000';
#line 2103
  return (curr);
}
}
#line 213 "/usr/include/x86_64-linux-gnu/sys/ptrace.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) ptrace)(enum __ptrace_request __request 
                                                                              , ...) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 82 "/home/wheatley/newnew/temp/psmisc-22.20/src/peekfd.c"
int num_attached_pids  =    0;
#line 83 "/home/wheatley/newnew/temp/psmisc-22.20/src/peekfd.c"
pid_t attached_pids[1024]  ;
#line 85 "/home/wheatley/newnew/temp/psmisc-22.20/src/peekfd.c"
void detach(void) 
{ 
  int i ;

  {
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < num_attached_pids)) {
#line 87
      goto while_break;
    }
    {
#line 88
    ptrace((enum __ptrace_request )17, attached_pids[i], 0, 0);
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 91 "/home/wheatley/newnew/temp/psmisc-22.20/src/peekfd.c"
void attach(pid_t pid ) 
{ 
  char *tmp ;
  long tmp___0 ;

  {
#line 92
  if (num_attached_pids >= 1024) {
#line 93
    return;
  }
  {
#line 94
  attached_pids[num_attached_pids] = pid;
#line 95
  tmp___0 = ptrace((enum __ptrace_request )16, pid, 0, 0);
  }
#line 95
  if (tmp___0 == -1L) {
    {
#line 96
    tmp = gettext("Error attaching to pid %i\n");
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            pid);
    }
#line 97
    return;
  }
#line 99
  num_attached_pids ++;
#line 100
  return;
}
}
#line 114 "/home/wheatley/newnew/temp/psmisc-22.20/src/peekfd.c"
void usage(void) 
{ 
  char *tmp ;

  {
  {
#line 115
  tmp = gettext("Usage: peekfd [-8] [-n] [-c] [-d] [-V] [-h] <pid> [<fd> ..]\n    -8 output 8 bit clean streams.\n    -n don\'t display read/write from fd headers.\n    -c peek at any new child processes too.\n    -d remove duplicate read/writes from the output.\n    -V prints version info.\n    -h prints this help.\n\n  Press CTRL-C to end output.\n");
#line 115
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
  }
#line 125
  return;
}
}
#line 127 "/home/wheatley/newnew/temp/psmisc-22.20/src/peekfd.c"
int bufdiff(pid_t pid , unsigned char *lastbuf , unsigned int addr , unsigned int len ) 
{ 
  int i ;
  long tmp ;

  {
#line 129
  i = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! ((unsigned int )i < len)) {
#line 129
      goto while_break;
    }
    {
#line 130
    tmp = ptrace((enum __ptrace_request )1, pid, addr + (unsigned int )i, 0);
    }
#line 130
    if ((long )*(lastbuf + i) != (tmp & 255L)) {
#line 131
      return (1);
    }
#line 129
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return (0);
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 538 "/usr/include/stdio.h"
extern int getchar(void) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 847 "/usr/include/curses.h"
extern char *tigetstr(char const   * ) ;
#line 740 "/usr/include/term.h"
extern int setupterm(char const   * , int  , int * ) ;
#line 763
extern char *tgetstr(char const   * , char ** ) ;
#line 765
extern int tgetent(char * , char const   * ) ;
#line 768
extern int tputs(char const   * , int  , int (*)(int  ) ) ;
#line 583 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 52 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
extern char const   *__progname ;
#line 102 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static struct __anonstruct_sym_ascii_32 sym_ascii  =    {"  ", "|-", "| ", "`-", "---", "-+-"};
#line 102 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static struct __anonstruct_sym_ascii_32 sym_utf  =    {"  ", "\342\224\234\342\224\200", "\342\224\202 ", "\342\224\224\342\224\200",
    "\342\224\200\342\224\200\342\224\200", "\342\224\200\342\224\254\342\224\200"};
#line 102 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static struct __anonstruct_sym_ascii_32 sym_vt100  =    {"  ", "\033(0\017tq\033(B", "\033(0\017x\033(B ", "\033(0\017mq\033(B", "\033(0\017qqq\033(B",
    "\033(0\017qwq\033(B"};
#line 102 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static struct __anonstruct_sym_ascii_32 *sym  =    & sym_ascii;
#line 125 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static PROC *list  =    (PROC *)((void *)0);
#line 128 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int capacity  =    0;
#line 129 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int *width  =    (int *)((void *)0);
#line 130 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int *more  =    (int *)((void *)0);
#line 132 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int print_args  =    0;
#line 132 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int compact  =    1;
#line 132 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int user_change  =    0;
#line 132 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int pids  =    0;
#line 132 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int pgids  =    0;
#line 132 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int show_parents  =    0;
#line 132 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int by_pid  =    0;
#line 132 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int trunc  =    1;
#line 132 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int wait_end  =    0;
#line 137 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int output_width  =    132;
#line 138 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int cur_x  =    1;
#line 139 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static char last_char  =    (char)0;
#line 140 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int dumped  =    0;
#line 141 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int charlen  =    0;
#line 143
static void fix_orphans(void) ;
#line 151 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void ensure_buffer_capacity(int index___0 ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 153
  if (index___0 >= capacity) {
#line 154
    if (capacity == 0) {
#line 155
      capacity = 100;
    } else {
#line 157
      capacity *= 2;
    }
    {
#line 158
    tmp = realloc((void *)width, (unsigned long )capacity * sizeof(int ));
#line 158
    width = (int *)tmp;
    }
#line 158
    if (! width) {
      {
#line 159
      perror("realloc");
#line 160
      exit(1);
      }
    }
    {
#line 162
    tmp___0 = realloc((void *)more, (unsigned long )capacity * sizeof(int ));
#line 162
    more = (int *)tmp___0;
    }
#line 162
    if (! more) {
      {
#line 163
      perror("realloc");
#line 164
      exit(1);
      }
    }
  }
#line 167
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void free_buffers(void) 
{ 


  {
#line 174
  if ((unsigned long )width != (unsigned long )((void *)0)) {
    {
#line 175
    free((void *)width);
#line 176
    width = (int *)((void *)0);
    }
  }
#line 178
  if ((unsigned long )more != (unsigned long )((void *)0)) {
    {
#line 179
    free((void *)more);
#line 180
    more = (int *)((void *)0);
    }
  }
#line 182
  capacity = 0;
#line 183
  return;
}
}
#line 185 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void out_char(char c ) 
{ 


  {
#line 187
  if (charlen == 0) {
#line 188
    if (((int )c & 128) == 0) {
#line 189
      charlen = 1;
    } else
#line 190
    if (((int )c & 224) == 192) {
#line 191
      charlen = 2;
    } else
#line 192
    if (((int )c & 240) == 224) {
#line 193
      charlen = 3;
    } else
#line 194
    if (((int )c & 248) == 240) {
#line 195
      charlen = 4;
    } else {
#line 197
      charlen = 1;
    }
#line 199
    cur_x ++;
  }
#line 201
  charlen --;
#line 202
  if (! trunc) {
    {
#line 203
    putchar((int )c);
    }
  } else
#line 202
  if (cur_x <= output_width) {
    {
#line 203
    putchar((int )c);
    }
  } else
#line 205
  if (trunc) {
#line 205
    if (cur_x == output_width + 1) {
      {
#line 206
      putchar('+');
      }
    }
  }
#line 208
  return;
}
}
#line 211 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void out_string(char const   *str ) 
{ 
  char const   *tmp ;

  {
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! *str) {
#line 213
      goto while_break;
    }
    {
#line 214
    tmp = str;
#line 214
    str ++;
#line 214
    out_char((char )*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 218 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int out_int(int x ) 
{ 
  int digits ;
  int div___0 ;

  {
#line 222
  digits = 0;
#line 223
  div___0 = 1;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (x / div___0)) {
#line 223
      goto while_break;
    }
#line 224
    digits ++;
#line 223
    div___0 *= 10;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  if (! digits) {
#line 226
    digits = 1;
  }
#line 227
  div___0 /= 10;
  {
#line 227
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 227
    if (! div___0) {
#line 227
      goto while_break___0;
    }
    {
#line 228
    out_char((char )(48 + (x / div___0) % 10));
#line 227
    div___0 /= 10;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 229
  return (digits);
}
}
#line 242 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void out_newline(void) 
{ 


  {
#line 244
  if (last_char) {
#line 244
    if (cur_x == output_width) {
      {
#line 245
      putchar((int )last_char);
      }
    }
  }
  {
#line 246
  last_char = (char)0;
#line 247
  putchar('\n');
#line 248
  cur_x = 1;
  }
#line 249
  return;
}
}
#line 252 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static PROC *find_proc(pid_t pid ) 
{ 
  PROC *walk ;

  {
#line 256
  walk = list;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! walk) {
#line 256
      goto while_break;
    }
#line 257
    if (walk->pid == pid) {
#line 258
      return (walk);
    }
#line 256
    walk = walk->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return ((PROC *)((void *)0));
}
}
#line 266 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static PROC *new_proc(char const   *comm , pid_t pid , uid_t uid ) 
{ 
  PROC *new ;
  void *tmp ;

  {
  {
#line 271
  tmp = malloc(sizeof(PROC ));
#line 271
  new = (PROC *)tmp;
  }
#line 271
  if (! new) {
    {
#line 272
    perror("malloc");
#line 273
    exit(1);
    }
  }
  {
#line 275
  strncpy((char */* __restrict  */)(new->comm), (char const   */* __restrict  */)comm,
          (size_t )18);
#line 276
  new->comm[17] = (char )'\000';
#line 277
  new->pid = pid;
#line 278
  new->uid = uid;
#line 279
  new->flags = (char)0;
#line 280
  new->argc = 0;
#line 281
  new->argv = (char **)((void *)0);
#line 285
  new->children = (struct _child *)((void *)0);
#line 286
  new->parent = (struct _proc *)((void *)0);
#line 287
  new->next = list;
#line 288
  list = new;
  }
#line 288
  return (list);
}
}
#line 292 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void add_child(PROC *parent , PROC *child ) 
{ 
  CHILD *new ;
  CHILD **walk ;
  int cmp ;
  void *tmp ;

  {
  {
#line 297
  tmp = malloc(sizeof(CHILD ));
#line 297
  new = (CHILD *)tmp;
  }
#line 297
  if (! new) {
    {
#line 298
    perror("malloc");
#line 299
    exit(1);
    }
  }
#line 301
  new->child = child;
#line 302
  walk = & parent->children;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! *walk) {
#line 302
      goto while_break;
    }
#line 303
    if (by_pid) {
#line 304
      if (((*walk)->child)->pid > child->pid) {
#line 305
        goto while_break;
      }
    } else {
      {
#line 306
      cmp = strcmp((char const   *)(((*walk)->child)->comm), (char const   *)(child->comm));
      }
#line 306
      if (cmp > 0) {
#line 307
        goto while_break;
      } else
#line 308
      if (! cmp) {
#line 308
        if (((*walk)->child)->uid > child->uid) {
#line 309
          goto while_break;
        }
      }
    }
#line 302
    walk = & (*walk)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  new->next = *walk;
#line 311
  *walk = new;
#line 312
  return;
}
}
#line 315 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void set_args(PROC *this , char const   *args , int size ) 
{ 
  char *start ;
  int i ;
  char **tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 320
  if (! size) {
#line 321
    this->argc = -1;
#line 322
    return;
  }
#line 324
  this->argc = 0;
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! (i < size - 1)) {
#line 325
      goto while_break;
    }
#line 326
    if (! *(args + i)) {
#line 327
      (this->argc) ++;
    }
#line 325
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  if (! this->argc) {
#line 329
    return;
  }
  {
#line 330
  tmp___0 = malloc(sizeof(char *) * (unsigned long )this->argc);
#line 330
  tmp = (char **)tmp___0;
#line 330
  this->argv = tmp;
  }
#line 330
  if (! tmp) {
    {
#line 331
    perror("malloc");
#line 332
    exit(1);
    }
  }
  {
#line 334
  tmp___1 = strchr(args, 0);
#line 334
  start = tmp___1 + 1;
#line 335
  size = (int )((long )size - (start - (char *)args));
#line 336
  tmp___3 = malloc((size_t )size);
#line 336
  tmp___2 = (char *)tmp___3;
#line 336
  *(this->argv + 0) = tmp___2;
  }
#line 336
  if (! tmp___2) {
    {
#line 337
    perror("malloc");
#line 338
    exit(1);
    }
  }
  {
#line 340
  tmp___4 = memcpy((void */* __restrict  */)*(this->argv + 0), (void const   */* __restrict  */)start,
                   (size_t )size);
#line 340
  start = (char *)tmp___4;
#line 341
  i = 1;
  }
  {
#line 341
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 341
    if (! (i < this->argc)) {
#line 341
      goto while_break___0;
    }
    {
#line 342
    tmp___5 = strchr((char const   *)start, 0);
#line 342
    start = tmp___5 + 1;
#line 342
    *(this->argv + i) = start;
#line 341
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 343
  return;
}
}
#line 345 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void rename_proc(PROC *this , char const   *comm , uid_t uid ) 
{ 
  PROC *tmp_child ;
  PROC *parent ;
  CHILD **walk ;
  int tmp ;

  {
  {
#line 351
  strncpy((char */* __restrict  */)(this->comm), (char const   */* __restrict  */)comm,
          (size_t )18);
#line 352
  this->comm[17] = (char )'\000';
#line 353
  this->uid = uid;
  }
#line 356
  if (! by_pid) {
#line 356
    if (this->parent) {
#line 357
      parent = this->parent;
#line 358
      walk = & parent->children;
      {
#line 358
      while (1) {
        while_continue: /* CIL Label */ ;
#line 358
        if (! *walk) {
#line 358
          goto while_break;
        }
#line 359
        if ((unsigned long )(*walk)->next != (unsigned long )((void *)0)) {
          {
#line 359
          tmp = strcmp((char const   *)(((*walk)->child)->comm), (char const   *)((((*walk)->next)->child)->comm));
          }
#line 359
          if (tmp > 0) {
#line 360
            tmp_child = (*walk)->child;
#line 361
            (*walk)->child = ((*walk)->next)->child;
#line 362
            ((*walk)->next)->child = tmp_child;
          }
        }
#line 358
        walk = & (*walk)->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 366
  return;
}
}
#line 372 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void add_proc(char const   *comm , pid_t pid , pid_t ppid , pid_t pgid , uid_t uid ,
                     char const   *args , int size , char isthread ) 
{ 
  PROC *this ;
  PROC *parent ;

  {
  {
#line 379
  this = find_proc(pid);
  }
#line 379
  if (this) {
    {
#line 386
    rename_proc(this, comm, uid);
    }
  } else {
    {
#line 383
    this = new_proc(comm, pid, uid);
    }
  }
#line 388
  if (args) {
    {
#line 389
    set_args(this, args, size);
    }
  }
#line 390
  if (pid == ppid) {
#line 391
    ppid = 0;
  }
#line 392
  this->pgid = pgid;
#line 393
  if (isthread) {
#line 394
    this->flags = (char )((int )this->flags | 2);
  }
  {
#line 395
  parent = find_proc(ppid);
  }
#line 395
  if (! parent) {
    {
#line 399
    parent = new_proc("?", ppid, (uid_t )0);
    }
  }
#line 402
  if (pid != 0) {
    {
#line 403
    add_child(parent, this);
#line 404
    this->parent = parent;
    }
  }
#line 406
  return;
}
}
#line 409 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int tree_equal(PROC const   *a , PROC const   *b ) 
{ 
  CHILD const   *walk_a ;
  CHILD const   *walk_b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 413
  tmp = strcmp((char const   *)(a->comm), (char const   *)(b->comm));
  }
#line 413
  if (tmp) {
#line 414
    return (0);
  }
#line 415
  if (user_change) {
#line 415
    if (a->uid != b->uid) {
#line 416
      return (0);
    }
  }
#line 417
  walk_a = (CHILD const   *)a->children;
#line 417
  walk_b = (CHILD const   *)b->children;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (walk_a) {
#line 417
      if (! walk_b) {
#line 417
        goto while_break;
      }
    } else {
#line 417
      goto while_break;
    }
    {
#line 419
    tmp___0 = tree_equal((PROC const   *)walk_a->child, (PROC const   *)walk_b->child);
    }
#line 419
    if (! tmp___0) {
#line 420
      return (0);
    }
#line 417
    walk_a = (CHILD const   *)walk_a->next;
#line 417
    walk_b = (CHILD const   *)walk_b->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 421
  if (walk_a) {
#line 421
    tmp___1 = 0;
  } else
#line 421
  if (walk_b) {
#line 421
    tmp___1 = 0;
  } else {
#line 421
    tmp___1 = 1;
  }
#line 421
  return (tmp___1);
}
}
#line 424 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static int out_args(char *mystr ) 
{ 
  char *here ;
  int strcount ;
  char tmpstr[5] ;

  {
#line 428
  strcount = 0;
#line 431
  here = mystr;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! *here) {
#line 431
      goto while_break;
    }
#line 432
    if ((int )*here == 92) {
      {
#line 433
      out_string("\\\\");
#line 434
      strcount += 2;
      }
    } else
#line 435
    if ((int )*here >= 32) {
#line 435
      if ((int )*here <= 126) {
        {
#line 436
        out_char(*here);
#line 437
        strcount ++;
        }
      } else {
        {
#line 439
        sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"\\%03o",
                (int )((unsigned char )*here));
#line 440
        out_string((char const   *)(tmpstr));
#line 441
        strcount += 4;
        }
      }
    } else {
      {
#line 439
      sprintf((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"\\%03o",
              (int )((unsigned char )*here));
#line 440
      out_string((char const   *)(tmpstr));
#line 441
      strcount += 4;
      }
    }
#line 431
    here ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  return (strcount);
}
}
#line 447 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void dump_tree(PROC *current , int level , int rep , int leaf , int last ,
                      uid_t prev_uid , int closing ) 
{ 
  CHILD *walk ;
  CHILD *next ;
  CHILD **scan ;
  struct passwd  const  *pw ;
  int lvl ;
  int i ;
  int add ;
  int offset ;
  int len ;
  int swapped ;
  int info ;
  int count ;
  int comm_len ;
  int first ;
  char const   *tmp ;
  char const   *here ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___12 ;
  int tmp___13 ;
  struct passwd *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  int tmp___24 ;

  {
#line 456
  if (! (closing >= 0)) {
    {
#line 456
    __assert_fail("closing >= 0", "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c",
                  456U, "dump_tree");
    }
  }
#line 457
  if (! current) {
#line 458
    return;
  }
#line 459
  if (! leaf) {
#line 460
    lvl = 0;
    {
#line 460
    while (1) {
      while_continue: /* CIL Label */ ;
#line 460
      if (! (lvl < level)) {
#line 460
        goto while_break;
      }
#line 461
      i = *(width + lvl) + 1;
      {
#line 461
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 461
        if (! i) {
#line 461
          goto while_break___0;
        }
        {
#line 462
        out_char((char )' ');
#line 461
        i --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 463
      if (lvl == level - 1) {
#line 463
        if (last) {
#line 463
          tmp___0 = sym->last_2;
        } else {
#line 463
          tmp___0 = sym->branch_2;
        }
#line 463
        tmp___2 = tmp___0;
      } else {
#line 463
        if (*(more + (lvl + 1))) {
#line 463
          tmp___1 = sym->vert_2;
        } else {
#line 463
          tmp___1 = sym->empty_2;
        }
#line 463
        tmp___2 = tmp___1;
      }
      {
#line 463
      out_string(tmp___2);
#line 460
      lvl ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 469
  if (rep < 2) {
#line 470
    add = 0;
  } else {
    {
#line 472
    tmp___3 = out_int(rep);
#line 472
    add = tmp___3 + 2;
#line 473
    out_string("*[");
    }
  }
#line 475
  if ((int )current->flags & 1) {
    {
#line 475
    tmp___4 = tgetstr("md", (char **)((void *)0));
#line 475
    tmp = (char const   *)tmp___4;
    }
#line 475
    if (tmp) {
      {
#line 476
      tputs(tmp, 1, & putchar);
      }
    }
  }
#line 477
  info = print_args;
#line 477
  swapped = info;
#line 478
  if (swapped) {
#line 478
    if (current->argc < 0) {
      {
#line 479
      out_char((char )'(');
      }
    }
  }
  {
#line 480
  comm_len = out_args(current->comm);
#line 481
  offset = cur_x;
  }
#line 482
  if (pids) {
#line 483
    tmp___7 = info;
#line 483
    info ++;
#line 483
    if (tmp___7) {
#line 483
      tmp___6 = ',';
    } else {
#line 483
      tmp___6 = '(';
    }
    {
#line 483
    out_char((char )tmp___6);
#line 484
    out_int(current->pid);
    }
  }
#line 486
  if (pgids) {
#line 487
    tmp___10 = info;
#line 487
    info ++;
#line 487
    if (tmp___10) {
#line 487
      tmp___9 = ',';
    } else {
#line 487
      tmp___9 = '(';
    }
    {
#line 487
    out_char((char )tmp___9);
#line 488
    out_int(current->pgid);
    }
  }
#line 490
  if (user_change) {
#line 490
    if (prev_uid != current->uid) {
#line 491
      tmp___13 = info;
#line 491
      info ++;
#line 491
      if (tmp___13) {
#line 491
        tmp___12 = ',';
      } else {
#line 491
        tmp___12 = '(';
      }
      {
#line 491
      out_char((char )tmp___12);
#line 492
      tmp___14 = getpwuid(current->uid);
#line 492
      pw = (struct passwd  const  *)tmp___14;
      }
#line 492
      if (pw) {
        {
#line 493
        out_string((char const   *)pw->pw_name);
        }
      } else {
        {
#line 495
        out_int((int )current->uid);
        }
      }
    }
  }
#line 503
  if (swapped) {
#line 503
    if (print_args) {
#line 503
      if (current->argc < 0) {
        {
#line 504
        out_char((char )')');
        }
      } else {
#line 503
        goto _L___0;
      }
    } else {
#line 503
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 503
  if (! swapped) {
#line 503
    if (info) {
      {
#line 504
      out_char((char )')');
      }
    }
  }
#line 505
  if ((int )current->flags & 1) {
    {
#line 505
    tmp___15 = tgetstr("me", (char **)((void *)0));
#line 505
    tmp = (char const   *)tmp___15;
    }
#line 505
    if (tmp) {
      {
#line 506
      tputs(tmp, 1, & putchar);
      }
    }
  }
#line 507
  if (print_args) {
#line 508
    i = 0;
    {
#line 508
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 508
      if (! (i < current->argc)) {
#line 508
        goto while_break___1;
      }
#line 509
      if (i < current->argc - 1) {
        {
#line 510
        out_char((char )' ');
        }
      }
#line 511
      len = 0;
#line 512
      here = (char const   *)*(current->argv + i);
      {
#line 512
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 512
        if (! *here) {
#line 512
          goto while_break___2;
        }
#line 513
        if ((int const   )*here >= 32) {
#line 513
          if ((int const   )*here <= 126) {
#line 513
            tmp___16 = 1;
          } else {
#line 513
            tmp___16 = 4;
          }
        } else {
#line 513
          tmp___16 = 4;
        }
#line 513
        len += tmp___16;
#line 512
        here ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 514
      if (i == current->argc - 1) {
#line 514
        tmp___17 = 0;
      } else {
#line 514
        tmp___17 = 4;
      }
#line 514
      if (cur_x + len <= output_width - tmp___17) {
        {
#line 516
        out_args(*(current->argv + i));
        }
      } else
#line 514
      if (! trunc) {
        {
#line 516
        out_args(*(current->argv + i));
        }
      } else {
        {
#line 518
        out_string("...");
        }
#line 519
        goto while_break___1;
      }
#line 508
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 526
  if (print_args) {
#line 526
    goto _L___1;
  } else
#line 526
  if (! current->children) {
    _L___1: /* CIL Label */ 
    {
#line 529
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 529
      tmp___18 = closing;
#line 529
      closing --;
#line 529
      if (! tmp___18) {
#line 529
        goto while_break___3;
      }
      {
#line 530
      out_char((char )']');
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 531
    out_newline();
    }
  }
  {
#line 533
  ensure_buffer_capacity(level);
#line 534
  *(more + level) = ! last;
  }
#line 539
  if (print_args) {
#line 542
    if (comm_len > 1) {
#line 542
      tmp___19 = 0;
    } else {
#line 542
      tmp___19 = -1;
    }
#line 542
    *(width + level) = swapped + tmp___19;
#line 543
    count = 0;
#line 544
    first = 1;
#line 545
    walk = current->children;
    {
#line 545
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 545
      if (! walk) {
#line 545
        goto while_break___4;
      }
#line 546
      next = walk->next;
#line 547
      count = 0;
#line 548
      if (compact) {
#line 548
        if ((int )(walk->child)->flags & 2) {
#line 549
          scan = & walk->next;
          {
#line 550
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 550
            if (! *scan) {
#line 550
              goto while_break___5;
            }
            {
#line 551
            tmp___20 = tree_equal((PROC const   *)walk->child, (PROC const   *)(*scan)->child);
            }
#line 551
            if (tmp___20) {
#line 554
              if ((unsigned long )next == (unsigned long )*scan) {
#line 555
                next = (*scan)->next;
              }
#line 556
              count ++;
#line 557
              *scan = (*scan)->next;
            } else {
#line 552
              scan = & (*scan)->next;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 560
          if (count) {
#line 560
            tmp___21 = 2;
          } else {
#line 560
            tmp___21 = 1;
          }
          {
#line 560
          dump_tree(walk->child, level + 1, count + 1, 0, ! next, current->uid, closing + tmp___21);
          }
        } else {
          {
#line 564
          dump_tree(walk->child, level + 1, 1, 0, ! walk->next, current->uid, 0);
          }
        }
      } else {
        {
#line 564
        dump_tree(walk->child, level + 1, 1, 0, ! walk->next, current->uid, 0);
        }
      }
#line 545
      walk = next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 568
    return;
  }
#line 570
  *(width + level) = ((comm_len + cur_x) - offset) + add;
#line 571
  if (cur_x >= output_width) {
#line 571
    if (trunc) {
      {
#line 572
      out_string(sym->first_3);
#line 573
      out_string("+");
#line 574
      out_newline();
      }
#line 575
      return;
    }
  }
#line 577
  first = 1;
#line 578
  walk = current->children;
  {
#line 578
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 578
    if (! walk) {
#line 578
      goto while_break___6;
    }
#line 579
    count = 0;
#line 580
    next = walk->next;
#line 581
    if (compact) {
#line 582
      scan = & walk->next;
      {
#line 583
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 583
        if (! *scan) {
#line 583
          goto while_break___7;
        }
        {
#line 584
        tmp___22 = tree_equal((PROC const   *)walk->child, (PROC const   *)(*scan)->child);
        }
#line 584
        if (tmp___22) {
#line 587
          if ((unsigned long )next == (unsigned long )*scan) {
#line 588
            next = (*scan)->next;
          }
#line 589
          count ++;
#line 590
          *scan = (*scan)->next;
        } else {
#line 585
          scan = & (*scan)->next;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 593
    if (first) {
#line 594
      if (next) {
#line 594
        tmp___23 = sym->first_3;
      } else {
#line 594
        tmp___23 = sym->single_3;
      }
      {
#line 594
      out_string(tmp___23);
#line 595
      first = 0;
      }
    }
#line 597
    if (count) {
#line 597
      tmp___24 = 1;
    } else {
#line 597
      tmp___24 = 0;
    }
    {
#line 597
    dump_tree(walk->child, level + 1, count + 1, (unsigned long )walk == (unsigned long )current->children,
              ! next, current->uid, closing + tmp___24);
#line 578
    walk = next;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 601
  return;
}
}
#line 604 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void dump_by_user(PROC *current , uid_t uid ) 
{ 
  CHILD const   *walk ;

  {
#line 608
  if (! current) {
#line 609
    return;
  }
#line 611
  if (current->uid == uid) {
#line 612
    if (dumped) {
      {
#line 613
      putchar('\n');
      }
    }
    {
#line 614
    dump_tree(current, 0, 1, 1, 1, uid, 0);
#line 615
    dumped = 1;
    }
#line 616
    return;
  }
#line 618
  walk = (CHILD const   *)current->children;
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    if (! walk) {
#line 618
      goto while_break;
    }
    {
#line 619
    dump_by_user((PROC *)walk->child, uid);
#line 618
    walk = (CHILD const   *)walk->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  return;
}
}
#line 622 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void trim_tree_by_parent(PROC *current ) 
{ 
  PROC *parent ;

  {
#line 624
  if (! current) {
#line 625
    return;
  }
#line 627
  parent = current->parent;
#line 629
  if (! parent) {
#line 630
    return;
  }
  {
#line 632
  parent->children = (struct _child *)((void *)0);
#line 633
  add_child(parent, current);
#line 634
  trim_tree_by_parent(parent);
  }
#line 635
  return;
}
}
#line 642 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void read_proc(void) 
{ 
  DIR *dir ;
  struct dirent *de ;
  FILE *file ;
  struct stat st ;
  char *path ;
  char *comm ;
  char *buffer ;
  size_t buffer_size ;
  char readbuf[8193] ;
  char *tmpptr ;
  char *endptr ;
  pid_t pid ;
  pid_t ppid ;
  pid_t pgid ;
  int fd ;
  int size ;
  int empty ;
  void *tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  DIR *taskdir ;
  struct dirent *dt ;
  char *taskpath ;
  char *threadname ;
  int thread ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  ssize_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;

  {
#line 661
  if (trunc) {
#line 662
    buffer_size = (size_t )(output_width + 1);
  } else {
#line 664
    buffer_size = (size_t )8193;
  }
#line 666
  if (! print_args) {
#line 667
    buffer = (char *)((void *)0);
  } else {
    {
#line 668
    tmp = malloc(buffer_size);
#line 668
    buffer = (char *)tmp;
    }
#line 668
    if (! buffer) {
      {
#line 669
      perror("malloc");
#line 670
      exit(1);
      }
    }
  }
  {
#line 672
  dir = opendir("/proc");
  }
#line 672
  if (! dir) {
    {
#line 673
    perror("/proc");
#line 674
    exit(1);
    }
  }
#line 676
  empty = 1;
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 677
    de = readdir(dir);
    }
#line 677
    if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 677
      goto while_break;
    }
    {
#line 678
    tmp___0 = strtol((char const   */* __restrict  */)(de->d_name), (char **/* __restrict  */)(& endptr),
                     10);
#line 678
    pid = (pid_t )tmp___0;
    }
#line 679
    if ((unsigned long )endptr != (unsigned long )(de->d_name)) {
#line 679
      if ((int )*(endptr + 0) == 0) {
        {
#line 680
        tmp___1 = strlen("/proc");
#line 680
        tmp___2 = strlen((char const   *)(de->d_name));
#line 680
        tmp___3 = malloc((tmp___1 + tmp___2) + 10UL);
#line 680
        path = (char *)tmp___3;
        }
#line 680
        if (! path) {
          {
#line 681
          exit(2);
          }
        }
        {
#line 682
        sprintf((char */* __restrict  */)path, (char const   */* __restrict  */)"%s/%d/stat",
                "/proc", pid);
#line 683
        file = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
        }
#line 683
        if ((unsigned long )file != (unsigned long )((void *)0)) {
          {
#line 684
          empty = 0;
#line 685
          sprintf((char */* __restrict  */)path, (char const   */* __restrict  */)"%s/%d",
                  "/proc", pid);
#line 693
          tmp___4 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
          }
#line 693
          if (tmp___4 < 0) {
            {
#line 694
            perror((char const   *)path);
#line 695
            exit(1);
            }
          }
          {
#line 697
          tmp___5 = fread((void */* __restrict  */)(readbuf), (size_t )1, (size_t )8192,
                          (FILE */* __restrict  */)file);
#line 697
          size = (int )tmp___5;
#line 698
          tmp___13 = ferror(file);
          }
#line 698
          if (tmp___13 == 0) {
            {
#line 699
            readbuf[size] = (char)0;
#line 702
            comm = strchr((char const   *)(readbuf), '(');
            }
#line 702
            if (comm) {
              {
#line 702
              tmpptr = strrchr((char const   *)comm, ')');
              }
#line 702
              if (tmpptr) {
                {
#line 704
                comm ++;
#line 705
                *tmpptr = (char)0;
#line 709
                tmp___12 = sscanf((char const   */* __restrict  */)(tmpptr + 2), (char const   */* __restrict  */)"%*c %d %d",
                                  & ppid, & pgid);
                }
#line 709
                if (tmp___12 == 2) {
                  {
#line 716
                  tmp___6 = strlen((char const   *)path);
#line 716
                  tmp___7 = malloc(tmp___6 + 10UL);
#line 716
                  taskpath = (char *)tmp___7;
                  }
#line 716
                  if (! taskpath) {
                    {
#line 717
                    exit(2);
                    }
                  }
                  {
#line 718
                  sprintf((char */* __restrict  */)taskpath, (char const   */* __restrict  */)"%s/task",
                          path);
#line 720
                  taskdir = opendir((char const   *)taskpath);
                  }
#line 720
                  if ((unsigned long )taskdir != (unsigned long )((DIR *)0)) {
                    {
#line 722
                    tmp___8 = malloc((size_t )19);
#line 722
                    threadname = (char *)tmp___8;
                    }
#line 722
                    if (! threadname) {
                      {
#line 723
                      exit(2);
                      }
                    }
                    {
#line 725
                    sprintf((char */* __restrict  */)threadname, (char const   */* __restrict  */)"{%.*s}",
                            16, comm);
                    }
                    {
#line 726
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
                      {
#line 726
                      dt = readdir(taskdir);
                      }
#line 726
                      if (! ((unsigned long )dt != (unsigned long )((void *)0))) {
#line 726
                        goto while_break___0;
                      }
                      {
#line 727
                      thread = atoi((char const   *)(dt->d_name));
                      }
#line 727
                      if (thread != 0) {
#line 728
                        if (thread != pid) {
#line 737
                          if (print_args) {
                            {
#line 738
                            tmp___9 = strlen((char const   *)threadname);
#line 738
                            add_proc((char const   *)threadname, thread, pid, pgid,
                                     st.st_uid, (char const   *)threadname, (int )(tmp___9 + 1UL),
                                     (char)1);
                            }
                          } else {
                            {
#line 741
                            add_proc((char const   *)threadname, thread, pid, pgid,
                                     st.st_uid, (char const   *)((void *)0), 0, (char)1);
                            }
                          }
                        }
                      }
                    }
                    while_break___0: /* CIL Label */ ;
                    }
                    {
#line 747
                    free((void *)threadname);
#line 748
                    closedir(taskdir);
                    }
                  }
                  {
#line 750
                  free((void *)taskpath);
                  }
#line 751
                  if (! print_args) {
                    {
#line 755
                    add_proc((char const   *)comm, pid, ppid, pgid, st.st_uid, (char const   *)((void *)0),
                             0, (char)0);
                    }
                  } else {
                    {
#line 758
                    sprintf((char */* __restrict  */)path, (char const   */* __restrict  */)"%s/%d/cmdline",
                            "/proc", pid);
#line 759
                    fd = open((char const   *)path, 0);
                    }
#line 759
                    if (fd < 0) {
                      {
#line 760
                      perror((char const   *)path);
#line 761
                      exit(1);
                      }
                    }
                    {
#line 763
                    tmp___10 = read(fd, (void *)buffer, buffer_size);
#line 763
                    size = (int )tmp___10;
                    }
#line 763
                    if (size < 0) {
                      {
#line 764
                      perror((char const   *)path);
#line 765
                      exit(1);
                      }
                    }
                    {
#line 767
                    close(fd);
                    }
#line 769
                    if ((size_t )size >= buffer_size) {
#line 770
                      size --;
                    }
#line 771
                    if (size) {
#line 772
                      tmp___11 = size;
#line 772
                      size ++;
#line 772
                      *(buffer + tmp___11) = (char)0;
                    }
                    {
#line 777
                    add_proc((char const   *)comm, pid, ppid, pgid, st.st_uid, (char const   *)buffer,
                             size, (char)0);
                    }
                  }
                }
              }
            }
          }
          {
#line 784
          fclose(file);
          }
        }
        {
#line 786
        free((void *)path);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 789
  closedir(dir);
#line 790
  fix_orphans();
  }
#line 791
  if (print_args) {
    {
#line 792
    free((void *)buffer);
    }
  }
#line 793
  if (empty) {
    {
#line 794
    tmp___14 = gettext("%s is empty (not mounted ?)\n");
#line 794
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___14,
            "/proc");
#line 795
    exit(1);
    }
  }
#line 797
  return;
}
}
#line 799 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void fix_orphans(void) 
{ 
  PROC *root ;
  PROC *walk ;

  {
  {
#line 809
  root = find_proc(1);
  }
#line 809
  if (! root) {
    {
#line 813
    root = new_proc("?", 1, (uid_t )0);
    }
  }
#line 816
  walk = list;
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 816
    if (! walk) {
#line 816
      goto while_break;
    }
#line 817
    if (walk->pid == 1) {
#line 818
      goto __Cont;
    } else
#line 817
    if (walk->pid == 0) {
#line 818
      goto __Cont;
    }
#line 819
    if ((unsigned long )walk->parent == (unsigned long )((void *)0)) {
      {
#line 820
      add_child(root, walk);
#line 821
      walk->parent = root;
      }
    }
    __Cont: /* CIL Label */ 
#line 816
    walk = walk->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 824
  return;
}
}
#line 826 "/home/wheatley/newnew/temp/psmisc-22.20/src/pstree.c"
static void usage___2(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 828
  tmp = gettext("Usage: pstree [ -a ] [ -c ] [ -h | -H PID ] [ -l ] [ -n ] [ -p ] [ -g ] [ -u ]\n              [ -A | -G | -U ] [ PID | USER ]\n       pstree -V\nDisplay a tree of processes.\n\n  -a, --arguments     show command line arguments\n  -A, --ascii         use ASCII line drawing characters\n  -c, --compact       don\'t compact identical subtrees\n  -h, --highlight-all highlight current process and its ancestors\n  -H PID,\n  --highlight-pid=PID highlight this process and its ancestors\n  -g, --show-pgids    show process group ids; implies -c\n  -G, --vt100         use VT100 line drawing characters\n  -l, --long          don\'t truncate long lines\n  -n, --numeric-sort  sort output by PID\n  -p, --show-pids     show PIDs; implies -c\n  -s, --show-parents  show parents of the selected process\n  -u, --uid-changes   show uid transitions\n  -U, --unicode       use UTF-8 (Unicode) line drawing characters\n  -V, --version       display version information\n");
#line 828
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 852
  tmp___0 = gettext("  PID    start at this PID; default is 1 (init)\n  USER   show only trees rooted at processes of this user\n\n");
#line 852
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 854
  exit(1);
  }
}
}
#line 44 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static long sc_clk_tck  ;
#line 46
static  __attribute__((__noreturn__)) void usage___3(char const   *errormsg ) ;
#line 48
static  __attribute__((__noreturn__)) void usage___3(char const   *errormsg ) ;
#line 48 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static void usage___3(char const   *errormsg ) 
{ 
  char *tmp ;

  {
#line 50
  if ((unsigned long )errormsg != (unsigned long )((void *)0)) {
    {
#line 51
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            errormsg);
    }
  }
  {
#line 52
  tmp = gettext("Usage: prtstat [options] PID ...\n       prtstat -V\nPrint information about a process\n    -r,--raw       Raw display of information\n    -V,--version   Display version information and exit\n");
#line 52
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 60
  exit(1);
  }
}
}
#line 63 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static void print_version___0(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 65
  tmp = gettext("prtstat (PSmisc) %s\n");
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, "22.20");
#line 66
  tmp___0 = gettext("Copyright (C) 2009 Craig Small\n\n");
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 67
  tmp___1 = gettext("PSmisc comes with ABSOLUTELY NO WARRANTY.\nThis is free software, and you are welcome to redistribute it under\nthe terms of the GNU General Public License.\nFor more information about these matters, see the files named COPYING.\n");
#line 67
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
  }
#line 72
  return;
}
}
#line 74 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static char *print_state(char const   state ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 77
  if ((int const   )state == 82) {
#line 77
    goto case_82;
  }
#line 79
  if ((int const   )state == 83) {
#line 79
    goto case_83;
  }
#line 81
  if ((int const   )state == 68) {
#line 81
    goto case_68;
  }
#line 83
  if ((int const   )state == 90) {
#line 83
    goto case_90;
  }
#line 85
  if ((int const   )state == 84) {
#line 85
    goto case_84;
  }
#line 87
  if ((int const   )state == 87) {
#line 87
    goto case_87;
  }
#line 76
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 78
  tmp = gettext("running");
  }
#line 78
  return (tmp);
  case_83: /* CIL Label */ 
  {
#line 80
  tmp___0 = gettext("sleeping");
  }
#line 80
  return (tmp___0);
  case_68: /* CIL Label */ 
  {
#line 82
  tmp___1 = gettext("disk sleep");
  }
#line 82
  return (tmp___1);
  case_90: /* CIL Label */ 
  {
#line 84
  tmp___2 = gettext("zombie");
  }
#line 84
  return (tmp___2);
  case_84: /* CIL Label */ 
  {
#line 86
  tmp___3 = gettext("traced");
  }
#line 86
  return (tmp___3);
  case_87: /* CIL Label */ 
  {
#line 88
  tmp___4 = gettext("paging");
  }
#line 88
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
  {
#line 90
  tmp___5 = gettext("unknown");
  }
#line 90
  return (tmp___5);
}
}
#line 96 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static double convert_time(unsigned long const   ticks ) 
{ 


  {
#line 98
  if (! (sc_clk_tck > 0L)) {
    {
#line 98
    __assert_fail("sc_clk_tck > 0", "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c",
                  98U, "convert_time");
    }
  }
#line 99
  return ((double )((float )ticks / (float )sc_clk_tck));
}
}
#line 102 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static void convert_bytes(char *buf___0 , unsigned long bytes ) 
{ 


  {
#line 104
  if (bytes > 10000000UL) {
    {
#line 105
    sprintf((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"%lu MB",
            bytes / 1000000UL);
    }
  } else
#line 106
  if (bytes > 10000UL) {
    {
#line 107
    sprintf((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"%lu kB",
            bytes / 1000UL);
    }
  } else {
    {
#line 109
    sprintf((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"%lu B",
            bytes);
    }
  }
#line 110
  return;
}
}
#line 115
static char *convert_policy(unsigned int const   policy ) ;
#line 115 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static char *policy_names[6]  = {      (char *)"normal",      (char *)"fifo",      (char *)"rr",      (char *)"batch", 
        (char *)"iso",      (char *)"idle"};
#line 113 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static char *convert_policy(unsigned int const   policy ) 
{ 


  {
#line 116
  if (policy < 6U) {
#line 117
    return (policy_names[policy]);
  }
#line 118
  return ((char *)"unknown");
}
}
#line 124 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static char buf[20]  ;
#line 122 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static char *convert_tty(int tty_nr ) 
{ 


  {
  {
#line 125
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d:%d",
          (tty_nr & 65280) >> 8, (unsigned int )(tty_nr & 255) | (((unsigned int )tty_nr & 4293918720U) >> 20));
  }
#line 126
  return (buf);
}
}
#line 130 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static void print_raw_stat(int const   pid , struct proc_info *pr ) 
{ 


  {
  {
#line 132
  printf((char const   */* __restrict  */)"%12.11s: %-15d\t%22.21s: %s\n", "pid",
         pid, "comm", pr->comm);
#line 133
  printf((char const   */* __restrict  */)"%12.11s: %-15c\t%22.21s: %d\n", "state",
         (int )pr->state, "ppid", pr->ppid);
#line 134
  printf((char const   */* __restrict  */)"%12.11s: %-15d\t%22.21s: %d\n", "pgrp",
         pr->pgrp, "session", pr->session);
#line 135
  printf((char const   */* __restrict  */)"%12.11s: %-15d\t%22.21s: %d\n", "tty_nr",
         pr->tty_nr, "tpgid", pr->tp_gid);
#line 136
  printf((char const   */* __restrict  */)"%12.11s: %-15x\t%22.21s: %lu\n", "flags",
         pr->flags, "minflt", pr->minflt);
#line 137
  printf((char const   */* __restrict  */)"%12.11s: %-15lu\t%22.21s: %lu\n", "cminflt",
         pr->cminflt, "majflt", pr->majflt);
#line 138
  printf((char const   */* __restrict  */)"%12.11s: %-15lu\t%22.21s: %lu\n", "cmajflt",
         pr->cmajflt, "utime", pr->utime);
#line 139
  printf((char const   */* __restrict  */)"%12.11s: %-15lu\t%22.21s: %ld\n", "stime",
         pr->stime, "cutime", pr->cutime);
#line 140
  printf((char const   */* __restrict  */)"%12.11s: %-15ld\t%22.21s: %ld\n", "cstime",
         pr->cstime, "priority", pr->priority);
#line 141
  printf((char const   */* __restrict  */)"%12.11s: %-15ld\t%22.21s: %ld\n", "nice",
         pr->nice, "num_threads", pr->num_threads);
#line 142
  printf((char const   */* __restrict  */)"%12.11s: %-15ld\t%22.21s: %llu\n", "itrealvalue",
         pr->itrealvalue, "starttime", pr->starttime);
#line 143
  printf((char const   */* __restrict  */)"%12.11s: %-15lu\t%22.21s: %ld\n", "vsize",
         pr->vsize, "rss", pr->rss);
#line 144
  printf((char const   */* __restrict  */)"%12.11s: %-15lu\t%22.21s: %lu\n", "rsslim",
         pr->rsslim, "startcode", pr->startcode);
#line 145
  printf((char const   */* __restrict  */)"%12.11s: %-15lu\t%22.21s: %lu\n", "endcode",
         pr->endcode, "startstack", pr->startstack);
#line 146
  printf((char const   */* __restrict  */)"%12.11s: %-15lX\t%22.21s: %lX\n", "kstkesp",
         pr->kstesp, "kstkeip", pr->ksteip);
#line 147
  printf((char const   */* __restrict  */)"%12.11s: %-15lu\t%22.21s: %lu\n", "wchan",
         pr->wchan, "nswap", pr->nswap);
#line 148
  printf((char const   */* __restrict  */)"%12.11s: %-15lu\t%22.21s: %d\n", "cnswap",
         pr->wchan, "exit_signal", pr->exit_signal);
#line 149
  printf((char const   */* __restrict  */)"%12.11s: %-15d\t%22.21s: %u\n", "processor",
         pr->processor, "rt_priority", pr->rt_priority);
#line 150
  printf((char const   */* __restrict  */)"%12.11s: %-15u\t%22.21s: %llu\n", "policy",
         pr->policy, "delayaccr_blkio_ticks", pr->blkio);
#line 151
  printf((char const   */* __restrict  */)"%12.11s: %-15lu\t%22.21s: %ld\n", "guest_time",
         pr->guest_time, "cguest_time", pr->cguest_time);
  }
#line 152
  return;
}
}
#line 153 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static void print_formated_stat(int const   pid , struct proc_info *pr ) 
{ 
  char buf_vsize[100] ;
  char buf_rss[100] ;
  char buf_rsslim[100] ;
  long page_size ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  long tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
  {
#line 160
  page_size = sysconf(30);
  }
#line 161
  if (! (page_size > 1L)) {
    {
#line 161
    __assert_fail("page_size>1", "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c",
                  161U, "print_formated_stat");
    }
  }
  {
#line 163
  tmp = convert_tty(pr->tty_nr);
#line 163
  tmp___0 = print_state((char const   )pr->state);
#line 163
  tmp___1 = gettext("Process: %-14s\t\tState: %c (%s)\n  CPU#:  %-3d\t\tTTY: %s\tThreads: %ld\n");
#line 163
  printf((char const   */* __restrict  */)tmp___1, pr->comm, (int )pr->state, tmp___0,
         pr->processor, tmp, pr->num_threads);
#line 168
  tmp___2 = gettext("Process, Group and Session IDs\n  Process ID: %d\t\t  Parent ID: %d\n    Group ID: %d\t\t Session ID: %d\n  T Group ID: %d\n\n");
#line 168
  printf((char const   */* __restrict  */)tmp___2, pid, pr->ppid, pr->pgrp, pr->session,
         pr->tp_gid);
#line 174
  tmp___3 = gettext("Page Faults\n  This Process    (minor major): %8lu  %8lu\n  Child Processes (minor major): %8lu  %8lu\n");
#line 174
  printf((char const   */* __restrict  */)tmp___3, pr->minflt, pr->majflt, pr->cminflt,
         pr->cmajflt);
#line 179
  tmp___4 = convert_time((unsigned long const   )pr->cguest_time);
#line 179
  tmp___5 = convert_time((unsigned long const   )pr->cstime);
#line 179
  tmp___6 = convert_time((unsigned long const   )pr->cutime);
#line 179
  tmp___7 = convert_time((unsigned long const   )pr->blkio);
#line 179
  tmp___8 = convert_time((unsigned long const   )pr->guest_time);
#line 179
  tmp___9 = convert_time((unsigned long const   )pr->stime);
#line 179
  tmp___10 = convert_time((unsigned long const   )pr->utime);
#line 179
  tmp___11 = gettext("CPU Times\n  This Process    (user system guest blkio): %6.2f %6.2f %6.2f %6.2f\n  Child processes (user system guest):       %6.2f %6.2f %6.2f\n");
#line 179
  printf((char const   */* __restrict  */)tmp___11, tmp___10, tmp___9, tmp___8, tmp___7,
         tmp___6, tmp___5, tmp___4);
#line 185
  convert_bytes(buf_vsize, pr->vsize);
#line 186
  convert_bytes(buf_rss, (unsigned long )(pr->rss * page_size));
#line 187
  convert_bytes(buf_rsslim, pr->rsslim);
#line 188
  tmp___12 = gettext("Memory\n  Vsize:       %-10s\n  RSS:         %-10s \t\t RSS Limit: %s\n  Code Start:  %#-10lx\t\t Code Stop:  %#-10lx\n  Stack Start: %#-10lx\n  Stack Pointer (ESP): %#10lx\t Inst Pointer (EIP): %#10lx\n");
#line 188
  printf((char const   */* __restrict  */)tmp___12, buf_vsize, buf_rss, buf_rsslim,
         pr->startcode, pr->endcode, pr->startstack, pr->kstesp, pr->ksteip);
  }
#line 198
  if (pr->priority > 0L) {
#line 198
    tmp___13 = "(non RT)";
  } else {
#line 198
    tmp___13 = "";
  }
#line 198
  if (pr->priority > 0L) {
#line 198
    tmp___14 = pr->priority - 20L;
  } else {
#line 198
    tmp___14 = 1L - pr->priority;
  }
  {
#line 198
  tmp___15 = convert_policy((unsigned int const   )pr->policy);
#line 198
  tmp___16 = gettext("Scheduling\n  Policy: %s\n  Nice:   %ld \t\t RT Priority: %ld %s\n");
#line 198
  printf((char const   */* __restrict  */)tmp___16, tmp___15, pr->nice, tmp___14,
         tmp___13);
  }
#line 209
  return;
}
}
#line 210 "/home/wheatley/newnew/temp/psmisc-22.20/src/prtstat.c"
static void print_stat(int const   pid , opt_type___0 const   options ) 
{ 
  char *pathname ;
  char buf___0[8192] ;
  char *bptr ;
  FILE *fp ;
  struct proc_info *pr ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 218
  tmp = malloc(sizeof(struct proc_info ));
#line 218
  pr = (struct proc_info *)tmp;
#line 220
  tmp___1 = asprintf((char **/* __restrict  */)(& pathname), (char const   */* __restrict  */)"/proc/%d/stat",
                     (int )pid);
  }
#line 220
  if (tmp___1 < 0) {
    {
#line 221
    tmp___0 = gettext("asprintf in print_stat failed.\n");
#line 221
    perror((char const   *)tmp___0);
#line 222
    exit(1);
    }
  }
  {
#line 224
  fp = fopen((char const   */* __restrict  */)pathname, (char const   */* __restrict  */)"r");
  }
#line 224
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 225
    tmp___6 = __errno_location();
    }
#line 225
    if (*tmp___6 == 2) {
      {
#line 226
      tmp___2 = gettext("Process with pid %d does not exist.\n");
#line 226
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              pid);
      }
    } else {
      {
#line 228
      tmp___3 = __errno_location();
#line 228
      tmp___4 = strerror(*tmp___3);
#line 228
      tmp___5 = gettext("Unable to open stat file for pid %d (%s)\n");
#line 228
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              (int )pid, tmp___4);
      }
    }
    {
#line 229
    free((void *)pathname);
    }
#line 230
    return;
  }
  {
#line 232
  free((void *)pathname);
#line 234
  tmp___7 = fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)fp);
  }
#line 234
  if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
#line 234
    return;
  }
  {
#line 235
  bptr = strchr((char const   *)(buf___0), '(');
  }
#line 236
  if ((unsigned long )bptr == (unsigned long )((void *)0)) {
#line 236
    return;
  }
  {
#line 237
  bptr ++;
#line 238
  sscanf((char const   */* __restrict  */)bptr, (char const   */* __restrict  */)"%a[^)]) %c %d %d %d %d %d %d%lu %lu %lu %lu %lu %lu %lu %lu %ld %ld %ld %ld %llu %lu %ld %lu %lu %lu %lu %lu %lu %*s %*s %*s %*s %lu %lu %lu %d %d %u%u %llu %lu %lu ",
         & pr->comm, & pr->state, & pr->ppid, & pr->pgrp, & pr->session, & pr->tty_nr,
         & pr->tp_gid, & pr->flags, & pr->minflt, & pr->cminflt, & pr->majflt, & pr->cmajflt,
         & pr->utime, & pr->stime, & pr->cutime, & pr->cstime, & pr->priority, & pr->nice,
         & pr->num_threads, & pr->itrealvalue, & pr->starttime, & pr->vsize, & pr->rss,
         & pr->rsslim, & pr->startcode, & pr->endcode, & pr->startstack, & pr->kstesp,
         & pr->ksteip, & pr->wchan, & pr->nswap, & pr->cnswap, & pr->exit_signal,
         & pr->processor, & pr->rt_priority, & pr->policy, & pr->blkio, & pr->guest_time,
         & pr->cguest_time);
  }
#line 269
  if ((int const   )options & 1) {
    {
#line 270
    print_raw_stat(pid, pr);
    }
#line 271
    return;
  }
  {
#line 273
  print_formated_stat(pid, pr);
  }
#line 276
  return;
}
}
