/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 14 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.h"
typedef int str_id;
#line 17
struct __strtab;
#line 17 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.h"
typedef struct __strtab *StrTable;
#line 15 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.h"
struct __anonstruct_pkg_id_52 {
   str_id s[3] ;
};
#line 15 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.h"
typedef struct __anonstruct_pkg_id_52 pkg_id;
#line 16 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.h"
struct __pathnode_tree;
#line 16 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.h"
typedef struct __pathnode_tree *PathNodeTree;
#line 39
struct path_node;
#line 18 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.h"
struct mempool;
#line 17 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
struct mempool {
   struct mempool *m_next ;
   int start ;
   int count ;
   size_t siz ;
   void *mem ;
};
#line 21 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
struct str_entry {
   str_id s_next ;
   char data[0] ;
};
#line 26 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
struct __strtab {
   str_id hashtab[16381] ;
   struct mempool *s_st ;
   struct str_entry *st_next ;
   int str_avail ;
   int str_alloc ;
   int num_str ;
   int num_hash ;
   int num_conflicts ;
   int num_max_depth ;
};
#line 20 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
struct path_node {
   str_id path ;
   char *pathname ;
   pkg_id package ;
   struct path_node *left ;
   struct path_node *right ;
   struct path_node *down ;
   struct path_node *dups ;
};
#line 30 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
struct __pathnode_tree {
   struct mempool *p_st ;
   struct path_node *top ;
   struct path_node *pn_next ;
   int pn_avail ;
   int pn_alloc ;
   int num_pn ;
   int num_left ;
   int num_right ;
   StrTable st ;
   pkg_id ignore_pkg_id ;
};
#line 57 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
typedef int (*funcptr)();
#line 59 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
struct realfunctab {
   char *name ;
   int (*fptr)() ;
};
#line 1221
struct stat64;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 204 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
struct pathlist {
   struct pathlist *next ;
   char *path ;
   int pathlen ;
   char *pkg ;
   struct path_node *n ;
};
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 287 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *filename ,
                                                                                      int type ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 551
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *filename ,
                                                                                        char * const  *argv ,
                                                                                        char * const  *envp ) ;
#line 563
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *filename ,
                                                                                       char * const  *argv ) ;
#line 568
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const   *path ,
                                                                                        char const   *arg 
                                                                                        , ...) ;
#line 573
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *path ,
                                                                                       char const   *arg 
                                                                                       , ...) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dlerror)(void) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 401
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int ver ,
                                                                                         char const   *filename ,
                                                                                         struct stat *buf___1 ) ;
#line 403
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int ver ,
                                                                                          char const   *filename ,
                                                                                          struct stat *buf___1 ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
int ( __attribute__((__nonnull__(1))) open)(char const   *filename , int flags  , ...) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 27 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/debug.h"
static int debug___0 ;
#line 33
static int verbose___0 ;
#line 34
static int quiet___0 ;
#line 41 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/debug.h"
__inline static int read_data(int fd , void *buf___1 , int siz ) 
{ 
  int r ;
  int n ;
  char *p ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 44
  r = 0;
#line 45
  n = siz;
#line 46
  p = (char *)buf___1;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (n > 0)) {
#line 47
      goto while_break;
    }
    {
#line 48
    tmp = read(fd, (void *)p, (size_t )n);
#line 48
    r = (int )tmp;
    }
#line 49
    if (r < 0) {
      {
#line 50
      tmp___0 = __errno_location();
      }
#line 50
      if (*tmp___0 == 4) {
#line 51
        goto while_continue;
      }
#line 52
      return (r);
    }
#line 54
    if (r == 0) {
#line 55
      return (siz - n);
    }
#line 57
    p += r;
#line 58
    n -= r;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return (siz);
}
}
#line 26 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.h"
static str_id str_intern___0(StrTable st , char *string , int add ) ;
#line 27
static char *str_symbol___0(StrTable st , str_id sid ) ;
#line 33
static StrTable strtab_restore___0(int fd , int str_margin ) ;
#line 19 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.h"
static pkg_id pkg_null___0  ;
#line 21
static void pkgtab_init___0(void) ;
#line 28
static char *pkg_symbol___0(StrTable st , pkg_id pid ) ;
#line 39 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.h"
static struct path_node *pathnode_retrieve___0(PathNodeTree pnt , struct path_node *pn ,
                                               char *path ) ;
#line 53
static struct path_node *pathnode_top___0(PathNodeTree pnt ) ;
#line 57
static char *pathnode_pathname___0(PathNodeTree pnt , struct path_node *pn ) ;
#line 61
static char *pathnode_packagename___0(PathNodeTree pnt , struct path_node *pn ) ;
#line 74
static PathNodeTree pathnode_restore___0(int fd , StrTable st , int margin ) ;
#line 30 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.h"
static PathNodeTree pkgcdb_load___0(char *dbfile , int str_margin , int pathnode_margin ) ;
#line 39
static struct path_node *pkgcdb_get___0(PathNodeTree pnt , char *file , char **matchfile ,
                                        char **ext ) ;
#line 17 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.h"
static void mempool_init___0(void) ;
#line 18
static struct mempool *mempool_alloc___0(struct mempool *mp , int count , size_t siz ) ;
#line 27
static void *mempool_mem___0(struct mempool *mp ) ;
#line 28
static void *mempool_mem_avail___0(struct mempool *mp , int avail ) ;
#line 29
static int mempool_index___0(struct mempool *mp , void *ptr ) ;
#line 30
static void *mempool_fetch___0(struct mempool *mp , int idx ) ;
#line 42
static struct mempool *mempool_restore___0(int fd , void (*unserialize)(struct mempool *mp ,
                                                                        void *ptr ,
                                                                        int count ,
                                                                        int siz ,
                                                                        void *arg ) ,
                                           void *arg , int margin ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 25 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
static void mempool_init___0(void) 
{ 


  {
#line 28
  return;
}
}
#line 31 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
static struct mempool *mempool_alloc___0(struct mempool *mp , int count , size_t siz ) 
{ 
  int start ;
  struct mempool *nmp ;
  void *tmp ;

  {
#line 37
  if (! (count != 0)) {
    {
#line 37
    __assert_fail("count != 0", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  37U, "mempool_alloc");
    }
  }
#line 38
  if (! (siz != 0UL)) {
    {
#line 38
    __assert_fail("siz != 0", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  38U, "mempool_alloc");
    }
  }
#line 39
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
#line 40
    start = 0;
  } else {
#line 42
    start = mp->start + mp->count;
#line 43
    if (! (mp->siz == siz)) {
      {
#line 43
      __assert_fail("mp->siz == siz", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                    43U, "mempool_alloc");
      }
    }
  }
  {
#line 45
  tmp = malloc(sizeof(struct mempool ));
#line 45
  nmp = (struct mempool *)tmp;
  }
#line 46
  if ((unsigned long )nmp == (unsigned long )((void *)0)) {
    {
#line 48
    abort();
    }
  }
  {
#line 50
  memset((void *)nmp, 0, sizeof(struct mempool ));
#line 51
  nmp->mem = malloc((size_t )count * siz);
  }
#line 52
  if ((unsigned long )nmp->mem == (unsigned long )((void *)0)) {
    {
#line 54
    abort();
    }
  }
  {
#line 56
  memset(nmp->mem, 0, (size_t )count * siz);
#line 57
  nmp->m_next = mp;
#line 58
  nmp->start = start;
#line 59
  nmp->count = count;
#line 60
  nmp->siz = siz;
  }
#line 61
  return (nmp);
}
}
#line 95 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
static void *mempool_mem___0(struct mempool *mp ) 
{ 


  {
#line 98
  if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
    {
#line 98
    __assert_fail("mp != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  98U, "mempool_mem");
    }
  }
#line 99
  if (! ((unsigned long )mp->mem != (unsigned long )((void *)0))) {
    {
#line 99
    __assert_fail("mp->mem != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  99U, "mempool_mem");
    }
  }
#line 100
  return (mp->mem);
}
}
#line 103 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
static void *mempool_mem_avail___0(struct mempool *mp , int avail ) 
{ 


  {
#line 106
  if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
    {
#line 106
    __assert_fail("mp != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  106U, "mempool_mem_avail");
    }
  }
#line 107
  if (! ((unsigned long )mp->mem != (unsigned long )((void *)0))) {
    {
#line 107
    __assert_fail("mp->mem != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  107U, "mempool_mem_avail");
    }
  }
#line 108
  if (! (mp->count >= avail)) {
    {
#line 108
    __assert_fail("mp->count >= avail", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  108U, "mempool_mem_avail");
    }
  }
#line 109
  if (avail == 0) {
#line 110
    return ((void *)0);
  }
#line 112
  return ((void *)((char *)mp->mem + (size_t )(mp->count - avail) * mp->siz));
}
}
#line 115 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
static int mempool_index___0(struct mempool *mp , void *ptr ) 
{ 


  {
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
#line 118
      goto while_break;
    }
#line 119
    if ((unsigned long )mp->mem <= (unsigned long )ptr) {
#line 119
      if ((unsigned long )((char *)ptr) < (unsigned long )((char *)mp->mem + (size_t )mp->count * mp->siz)) {
#line 121
        if (! ((unsigned long )((char *)ptr - (char *)mp->mem) % mp->siz == 0UL)) {
          {
#line 121
          __assert_fail("((char *)ptr - (char *)mp->mem)%mp->siz == 0", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                        121U, "mempool_index");
          }
        }
#line 122
        return ((int )((size_t )((char *)ptr - (char *)mp->mem) / mp->siz + (size_t )mp->start));
      }
    }
#line 118
    mp = mp->m_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return (-1);
}
}
#line 128 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
static void *mempool_fetch___0(struct mempool *mp , int idx ) 
{ 


  {
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
#line 131
      goto while_break;
    }
#line 132
    if (mp->start <= idx) {
#line 132
      if (idx < mp->start + mp->count) {
#line 134
        return ((void *)((char *)mp->mem + (size_t )(idx - mp->start) * mp->siz));
      }
    }
#line 131
    mp = mp->m_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return ((void *)0);
}
}
#line 215 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
static struct mempool *mempool_restore___0(int fd , void (*unserialize)(struct mempool *mp ,
                                                                        void *ptr ,
                                                                        int count ,
                                                                        int siz ,
                                                                        void *arg ) ,
                                           void *arg , int margin ) 
{ 
  struct mempool *mp ;
  int e ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 226
  if (debug___0) {
    {
#line 226
    printf((char const   */* __restrict  */)"restore ");
    }
  }
  {
#line 227
  tmp = malloc(sizeof(struct mempool ));
#line 227
  mp = (struct mempool *)tmp;
  }
#line 228
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
#line 229
    if (debug___0) {
      {
#line 229
      printf((char const   */* __restrict  */)"mempool_restore: not enough memory for mempool header\n");
      }
    }
    {
#line 230
    abort();
    }
  }
  {
#line 232
  memset((void *)mp, 0, sizeof(struct mempool ));
#line 233
  e = read_data(fd, (void *)(& mp->count), (int )sizeof(int ));
  }
#line 234
  if ((unsigned long )e != sizeof(int )) {
#line 235
    if (debug___0) {
      {
#line 235
      tmp___0 = __errno_location();
#line 235
      printf((char const   */* __restrict  */)"read count fd:%d e:%d errno:%d\n",
             fd, e, *tmp___0);
      }
    }
#line 236
    if (! quiet___0) {
      {
#line 236
      perror("read count");
      }
    }
    {
#line 237
    abort();
    }
  }
#line 239
  if (debug___0) {
    {
#line 239
    printf((char const   */* __restrict  */)"count %d + %d, ", mp->count, margin);
    }
  }
  {
#line 240
  e = read_data(fd, (void *)(& mp->siz), (int )sizeof(int ));
  }
#line 241
  if ((unsigned long )e != sizeof(int )) {
#line 242
    if (debug___0) {
      {
#line 242
      tmp___1 = __errno_location();
#line 242
      printf((char const   */* __restrict  */)"read siz fd:%d e:%d errno:%d\n", fd,
             e, *tmp___1);
      }
    }
#line 243
    if (! quiet___0) {
      {
#line 243
      perror("read siz");
      }
    }
    {
#line 244
    abort();
    }
  }
#line 246
  if (debug___0) {
    {
#line 246
    printf((char const   */* __restrict  */)"siz %d, ", mp->siz);
    }
  }
  {
#line 247
  mp->mem = malloc((size_t )(mp->count + margin) * mp->siz);
  }
#line 248
  if ((unsigned long )mp->mem == (unsigned long )((void *)0)) {
#line 249
    if (debug___0) {
      {
#line 249
      printf((char const   */* __restrict  */)"mempool_restore: not enough memory for mempool contents\n");
      }
    }
    {
#line 250
    abort();
    }
  }
  {
#line 252
  e = read_data(fd, mp->mem, (int )((size_t )mp->count * mp->siz));
  }
#line 253
  if ((size_t )e != (size_t )mp->count * mp->siz) {
#line 254
    if (debug___0) {
      {
#line 254
      tmp___2 = __errno_location();
#line 254
      printf((char const   */* __restrict  */)"read data fd:%d e:%d errno:%d\n", fd,
             e, *tmp___2);
      }
    }
#line 255
    if (! quiet___0) {
      {
#line 255
      perror("read data");
      }
    }
    {
#line 256
    abort();
    }
  }
#line 258
  if (debug___0) {
    {
#line 258
    printf((char const   */* __restrict  */)"...");
    }
  }
#line 259
  if ((unsigned long )unserialize != (unsigned long )((void *)0)) {
    {
#line 260
    (*unserialize)(mp, mp->mem, mp->count, (int )mp->siz, arg);
    }
  }
#line 262
  mp->count += margin;
#line 263
  if (debug___0) {
    {
#line 263
    printf((char const   */* __restrict  */)"done\n");
    }
  }
#line 264
  return (mp);
}
}
#line 40 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
static int str_hash(char *s ) ;
#line 41
static str_id str_add(StrTable st , char *s , str_id s_next ) ;
#line 42
static struct str_entry *str_get(StrTable st , str_id sid ) ;
#line 44 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
static int str_hash(char *s ) 
{ 
  int *p ;
  char *ss ;
  int i ;
  int n ;
  int l ;
  register int h ;
  char buf___1[sizeof(int )] ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 50
  h = 0;
#line 53
  tmp = strlen((char const   *)s);
#line 53
  l = (int )tmp;
#line 54
  tmp___0 = __builtin_alloca((unsigned long )(l + 1));
#line 54
  ss = (char *)tmp___0;
#line 55
  strcpy((char */* __restrict  */)ss, (char const   */* __restrict  */)s);
#line 56
  n = (int )((unsigned long )l / sizeof(int ));
#line 57
  p = (int *)ss;
#line 58
  i = 0;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < n)) {
#line 58
      goto while_break;
    }
#line 59
    tmp___1 = p;
#line 59
    p ++;
#line 59
    h ^= *tmp___1;
#line 58
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  n = (int )((unsigned long )l - (unsigned long )n * sizeof(int ));
#line 62
  if (n != 0) {
    {
#line 63
    memset((void *)(buf___1), 0, sizeof(buf___1));
#line 64
    strncpy((char */* __restrict  */)(buf___1 + n), (char const   */* __restrict  */)((char *)p),
            (size_t )(4 - n));
#line 65
    p = (int *)(buf___1);
#line 66
    h ^= *p;
    }
  }
#line 68
  return (h % 16381);
}
}
#line 71 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
static str_id str_add(StrTable st , char *s , str_id s_next ) 
{ 
  int len ;
  struct str_entry *se ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 76
  if (! ((unsigned long )st != (unsigned long )((void *)0))) {
    {
#line 76
    __assert_fail("st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c",
                  76U, "str_add");
    }
  }
#line 77
  if (! ((unsigned long )s != (unsigned long )((void *)0))) {
    {
#line 77
    __assert_fail("s != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c",
                  77U, "str_add");
    }
  }
  {
#line 79
  tmp = strlen((char const   *)s);
#line 79
  len = (int )((((sizeof(str_id ) + tmp) + 1UL) + 3UL) & 0xfffffffffffffffcUL);
  }
#line 80
  if ((unsigned long )st->st_next == (unsigned long )((void *)0)) {
    {
#line 81
    st->s_st = mempool_alloc___0(st->s_st, 40960, (size_t )1);
#line 82
    st->str_avail = 40960;
#line 83
    tmp___0 = mempool_mem___0(st->s_st);
#line 83
    st->st_next = (struct str_entry *)tmp___0;
#line 84
    st->str_alloc += 40960;
    }
  } else
#line 80
  if (st->str_avail <= len) {
    {
#line 81
    st->s_st = mempool_alloc___0(st->s_st, 40960, (size_t )1);
#line 82
    st->str_avail = 40960;
#line 83
    tmp___0 = mempool_mem___0(st->s_st);
#line 83
    st->st_next = (struct str_entry *)tmp___0;
#line 84
    st->str_alloc += 40960;
    }
  }
  {
#line 86
  se = st->st_next;
#line 87
  se->s_next = s_next;
#line 88
  strcpy((char */* __restrict  */)(se->data), (char const   */* __restrict  */)s);
#line 89
  st->st_next = (struct str_entry *)((char *)se + len);
#line 90
  st->str_avail -= len;
#line 91
  (st->num_str) ++;
#line 92
  tmp___1 = mempool_index___0(st->s_st, (void *)se);
  }
#line 92
  return (tmp___1);
}
}
#line 95 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
static struct str_entry *str_get(StrTable st , str_id sid ) 
{ 
  struct str_entry *se ;
  void *tmp ;

  {
#line 99
  if (! ((unsigned long )st != (unsigned long )((void *)0))) {
    {
#line 99
    __assert_fail("st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c",
                  99U, "str_get");
    }
  }
  {
#line 101
  tmp = mempool_fetch___0(st->s_st, sid);
#line 101
  se = (struct str_entry *)tmp;
  }
#line 102
  return (se);
}
}
#line 146 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
static str_id str_intern___0(StrTable st , char *string , int add ) 
{ 
  int h ;
  str_id sid ;
  struct str_entry *se ;
  int depth ;
  int tmp ;

  {
#line 152
  if (! ((unsigned long )st != (unsigned long )((void *)0))) {
    {
#line 152
    __assert_fail("st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c",
                  152U, "str_intern");
    }
  }
#line 153
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 154
    return (0);
  } else
#line 153
  if ((int )*(string + 0) == 0) {
#line 154
    return (0);
  }
  {
#line 157
  h = str_hash(string);
  }
#line 158
  if (st->hashtab[h] != 0) {
    {
#line 160
    depth = 0;
#line 161
    sid = st->hashtab[h];
#line 161
    se = str_get(st, sid);
    }
    {
#line 161
    while (1) {
      while_continue: /* CIL Label */ ;
#line 161
      if ((unsigned long )se != (unsigned long )((void *)0)) {
#line 161
        if (! (sid != 0)) {
#line 161
          goto while_break;
        }
      } else {
#line 161
        goto while_break;
      }
      {
#line 164
      depth ++;
#line 165
      tmp = strcmp((char const   *)(se->data), (char const   *)string);
      }
#line 165
      if (tmp == 0) {
#line 166
        if (st->num_max_depth < depth) {
#line 167
          st->num_max_depth = depth;
        }
#line 169
        return (sid);
      }
      {
#line 161
      sid = se->s_next;
#line 161
      se = str_get(st, sid);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 172
    if (add) {
#line 173
      (st->num_conflicts) ++;
    }
  } else
#line 175
  if (add) {
#line 176
    (st->num_hash) ++;
  }
#line 178
  if (! add) {
#line 179
    return (0);
  }
  {
#line 181
  sid = str_add(st, string, st->hashtab[h]);
#line 182
  st->hashtab[h] = sid;
  }
#line 183
  return (sid);
}
}
#line 186 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
static char *str_symbol___0(StrTable st , str_id sid ) 
{ 
  struct str_entry *se ;

  {
#line 190
  if (! ((unsigned long )st != (unsigned long )((void *)0))) {
    {
#line 190
    __assert_fail("st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c",
                  190U, "str_symbol");
    }
  }
  {
#line 192
  se = str_get(st, sid);
  }
#line 193
  if ((unsigned long )se == (unsigned long )((void *)0)) {
#line 194
    return ((char *)"");
  }
#line 196
  return (se->data);
}
}
#line 222 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
static StrTable strtab_restore___0(int fd , int str_margin ) 
{ 
  StrTable st ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 226
  if (debug___0) {
    {
#line 226
    printf((char const   */* __restrict  */)"strtab: restore ");
    }
  }
  {
#line 227
  tmp = malloc(sizeof(struct __strtab ));
#line 227
  st = (StrTable )tmp;
  }
#line 228
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 229
    if (! quiet___0) {
      {
#line 229
      printf((char const   */* __restrict  */)"not enough memory");
      }
    }
#line 230
    return ((StrTable )((void *)0));
  }
#line 232
  if (debug___0) {
    {
#line 232
    printf((char const   */* __restrict  */)"hash %d ", 16381);
    }
  }
  {
#line 233
  memset((void *)st, 0, sizeof(struct __strtab ));
#line 234
  tmp___0 = read_data(fd, (void *)(st->hashtab), (int )(16381UL * sizeof(str_id )));
  }
#line 234
  if (tmp___0 < 1) {
#line 235
    return ((StrTable )((void *)0));
  }
#line 237
  if (debug___0) {
    {
#line 237
    printf((char const   */* __restrict  */)"done\n");
    }
  }
#line 238
  if (debug___0) {
    {
#line 238
    printf((char const   */* __restrict  */)" symtab:");
    }
  }
  {
#line 239
  st->s_st = mempool_restore___0(fd, (void (*)(struct mempool *mp , void *ptr , int count ,
                                               int siz , void *arg ))((void *)0),
                                 (void *)0, str_margin);
  }
#line 240
  if ((unsigned long )st->s_st == (unsigned long )((void *)0)) {
    {
#line 241
    free((void *)st);
    }
#line 242
    return ((StrTable )((void *)0));
  }
  {
#line 244
  tmp___1 = mempool_mem_avail___0(st->s_st, str_margin);
#line 244
  st->st_next = (struct str_entry *)tmp___1;
#line 245
  st->str_avail = str_margin;
  }
#line 246
  return (st);
}
}
#line 19 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c"
static int inited  =    0;
#line 16 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c"
static void pkgtab_init___0(void) 
{ 
  int i ;

  {
#line 21
  if (inited) {
#line 22
    return;
  }
#line 23
  inited = 1;
#line 24
  i = 0;
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if (! (i < 3)) {
#line 24
      goto while_break;
    }
#line 25
    pkg_null___0.s[i] = 0;
#line 24
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  return;
}
}
#line 87 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c"
static char *buf  ;
#line 81 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c"
static char *pkg_symbol___0(StrTable st , pkg_id pid ) 
{ 
  int len ;
  int i ;
  char *p[3] ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 84
  len = 0;
#line 86
  p[0] = (char *)((void *)0);
#line 86
  p[1] = (char *)((void *)0);
#line 86
  p[2] = (char *)((void *)0);
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < 3)) {
#line 89
      goto while_break;
    }
#line 90
    if (pid.s[i] == 0) {
#line 91
      goto while_break;
    }
    {
#line 93
    p[i] = str_symbol___0(st, pid.s[i]);
#line 94
    tmp = strlen((char const   *)p[i]);
#line 94
    len = (int )((size_t )len + tmp);
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    {
#line 97
    free((void *)buf);
    }
  }
  {
#line 99
  tmp___0 = malloc((size_t )(len + 1));
#line 99
  buf = (char *)tmp___0;
  }
#line 100
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 101
    abort();
    }
  }
#line 103
  *(buf + 0) = (char )'\000';
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! (i < 3)) {
#line 104
      goto while_break___0;
    }
#line 105
    if (p[i]) {
      {
#line 106
      strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)p[i]);
      }
    } else {
#line 108
      goto while_break___0;
    }
#line 104
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 111
  return (buf);
}
}
#line 52 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
__inline static int cmp(str_id s0 , str_id s1 ) 
{ 


  {
#line 55
  return ((int )(((unsigned int )((((s0 & 255) << 24) | ((s0 & 65280) << 8)) | ((s0 & 16711680) >> 8)) | (((unsigned int )s0 & 4278190080U) >> 24)) - ((unsigned int )((((s1 & 255) << 24) | ((s1 & 65280) << 8)) | ((s1 & 16711680) >> 8)) | (((unsigned int )s1 & 4278190080U) >> 24))));
}
}
#line 241 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
static struct path_node *pathnode_retrieve___0(PathNodeTree pnt , struct path_node *pn ,
                                               char *path ) 
{ 
  int r ;
  str_id pathid ;
  str_id tmp ;
  char *tmp___0 ;

  {
  {
#line 245
  tmp = str_intern___0(pnt->st, path, 0);
#line 245
  pathid = tmp;
  }
#line 247
  if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
    {
#line 247
    __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  247U, "pathnode_retrieve");
    }
  }
#line 248
  if (debug___0) {
    {
#line 248
    tmp___0 = pathnode_pathname___0(pnt, pn);
#line 248
    printf((char const   */* __restrict  */)"retr: %p(%s) %s\n", pn, tmp___0, path);
    }
  }
#line 250
  pn = pn->down;
#line 251
  if ((unsigned long )pn == (unsigned long )((void *)0)) {
#line 252
    if (debug___0) {
      {
#line 252
      printf((char const   */* __restrict  */)"no child?\n");
      }
    }
#line 253
    return (pn);
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if ((unsigned long )pn->pathname == (unsigned long )((void *)0)) {
      {
#line 261
      pn->pathname = str_symbol___0(pnt->st, pn->path);
      }
    }
    {
#line 262
    r = cmp(pn->path, pathid);
    }
#line 263
    if (r == 0) {
#line 264
      if (debug___0) {
        {
#line 264
        printf((char const   */* __restrict  */)"found - ok %p\n", pn);
        }
      }
#line 265
      return (pn);
    }
#line 268
    if (r < 0) {
#line 273
      if ((unsigned long )pn->left == (unsigned long )((void *)0)) {
#line 274
        goto while_break;
      }
#line 275
      pn = pn->left;
    } else {
#line 281
      if ((unsigned long )pn->right == (unsigned long )((void *)0)) {
#line 282
        goto while_break;
      }
#line 283
      pn = pn->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  if (debug___0) {
    {
#line 286
    printf((char const   */* __restrict  */)"not found\n");
    }
  }
#line 287
  return ((struct path_node *)((void *)0));
}
}
#line 324 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
static struct path_node *pathnode_top___0(PathNodeTree pnt ) 
{ 


  {
#line 327
  if (! ((unsigned long )pnt != (unsigned long )((void *)0))) {
    {
#line 327
    __assert_fail("pnt != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  327U, "pathnode_top");
    }
  }
#line 328
  return (pnt->top);
}
}
#line 340 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
static char *pathnode_pathname___0(PathNodeTree pnt , struct path_node *pn ) 
{ 


  {
#line 343
  if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
    {
#line 343
    __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  343U, "pathnode_pathname");
    }
  }
#line 344
  if ((unsigned long )pn->pathname == (unsigned long )((void *)0)) {
    {
#line 344
    pn->pathname = str_symbol___0(pnt->st, pn->path);
    }
  }
#line 345
  return (pn->pathname);
}
}
#line 357 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
static char *pathnode_packagename___0(PathNodeTree pnt , struct path_node *pn ) 
{ 
  char *tmp ;

  {
#line 360
  if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
    {
#line 360
    __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  360U, "pathnode_packagename");
    }
  }
  {
#line 361
  tmp = pkg_symbol___0(pnt->st, pn->package);
  }
#line 361
  return (tmp);
}
}
#line 405 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
static void pathnode_unserialize(struct mempool *mp , void *ptr , int count , int siz ,
                                 void *arg ) 
{ 
  int i ;
  struct path_node *pn ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 411
  pn = (struct path_node *)ptr;
#line 412
  i = 0;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! (i < count)) {
#line 412
      goto while_break;
    }
#line 413
    if (pn->left) {
      {
#line 413
      tmp = mempool_fetch___0(mp, (int )pn->left);
#line 413
      pn->left = (struct path_node *)tmp;
      }
    }
#line 414
    if (pn->right) {
      {
#line 414
      tmp___0 = mempool_fetch___0(mp, (int )pn->right);
#line 414
      pn->right = (struct path_node *)tmp___0;
      }
    }
#line 415
    if (pn->down) {
      {
#line 415
      tmp___1 = mempool_fetch___0(mp, (int )pn->down);
#line 415
      pn->down = (struct path_node *)tmp___1;
      }
    }
#line 416
    if (pn->dups) {
      {
#line 416
      tmp___2 = mempool_fetch___0(mp, (int )pn->dups);
#line 416
      pn->dups = (struct path_node *)tmp___2;
      }
    }
#line 417
    pn ++;
#line 412
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return;
}
}
#line 446 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
static PathNodeTree pathnode_restore___0(int fd , StrTable st , int margin ) 
{ 
  PathNodeTree pnt ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 450
  if (debug___0) {
    {
#line 450
    printf((char const   */* __restrict  */)"pathnode: ");
    }
  }
  {
#line 451
  tmp = malloc(sizeof(struct __pathnode_tree ));
#line 451
  pnt = (PathNodeTree )tmp;
  }
#line 452
  if ((unsigned long )pnt == (unsigned long )((void *)0)) {
#line 453
    if (debug___0) {
      {
#line 453
      printf((char const   */* __restrict  */)"not enough memory\n");
      }
    }
#line 454
    return ((PathNodeTree )((void *)0));
  }
  {
#line 456
  memset((void *)pnt, 0, sizeof(struct __pathnode_tree ));
#line 457
  pnt->st = st;
#line 458
  pnt->p_st = mempool_restore___0(fd, & pathnode_unserialize, (void *)pnt, margin);
  }
#line 459
  if ((unsigned long )pnt->p_st == (unsigned long )((void *)0)) {
    {
#line 460
    free((void *)pnt);
    }
#line 461
    return ((PathNodeTree )((void *)0));
  }
  {
#line 463
  pnt->top = (struct path_node *)((void *)0);
#line 464
  tmp___0 = mempool_mem_avail___0(pnt->p_st, margin);
#line 464
  pnt->pn_next = (struct path_node *)tmp___0;
#line 465
  pnt->pn_avail = margin;
#line 466
  tmp___1 = mempool_mem___0(pnt->p_st);
#line 466
  pnt->top = (struct path_node *)tmp___1;
  }
#line 467
  return (pnt);
}
}
#line 29 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static int debug___0  =    0;
#line 31 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static int verbose___0  =    0;
#line 32 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static int quiet___0  =    0;
#line 64 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static PathNodeTree pkgcdb_load___0(char *dbfile , int str_margin , int pathnode_margin ) 
{ 
  int fd ;
  char buf___1[8] ;
  PathNodeTree pnt ;
  StrTable st ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 72
  if ((unsigned long )dbfile == (unsigned long )((void *)0)) {
#line 73
    return ((PathNodeTree )((void *)0));
  }
  {
#line 74
  fd = open((char const   *)dbfile, 0);
  }
#line 75
  if (fd < 0) {
#line 76
    return ((PathNodeTree )((void *)0));
  }
  {
#line 78
  tmp = read(fd, (void *)(buf___1), sizeof(buf___1));
  }
#line 78
  if (tmp < 0L) {
#line 79
    return ((PathNodeTree )((void *)0));
  }
  {
#line 81
  tmp___0 = strncmp((char const   *)(buf___1), "AUTO_APT", sizeof(buf___1));
  }
#line 81
  if (tmp___0 != 0) {
#line 82
    if (! quiet___0) {
      {
#line 82
      printf((char const   */* __restrict  */)"magic mismatch: %8s\n", buf___1);
      }
    }
#line 83
    return ((PathNodeTree )((void *)0));
  }
#line 85
  if (debug___0) {
    {
#line 85
    printf((char const   */* __restrict  */)"fd=%d magic: %8s\n", fd, buf___1);
    }
  }
  {
#line 86
  st = strtab_restore___0(fd, str_margin);
  }
#line 87
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 88
    if (! quiet___0) {
      {
#line 88
      printf((char const   */* __restrict  */)"strtab read error\n");
      }
    }
    {
#line 89
    close(fd);
    }
#line 90
    return ((PathNodeTree )((void *)0));
  }
  {
#line 92
  pnt = pathnode_restore___0(fd, st, pathnode_margin);
  }
#line 93
  if ((unsigned long )pnt == (unsigned long )((void *)0)) {
#line 94
    if (! quiet___0) {
      {
#line 94
      printf((char const   */* __restrict  */)"pathnode read error\n");
      }
    }
    {
#line 95
    close(fd);
    }
#line 96
    return ((PathNodeTree )((void *)0));
  }
  {
#line 98
  close(fd);
  }
#line 99
  return (pnt);
}
}
#line 138 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static char matchpath[4096]  ;
#line 133 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static struct path_node *pkgcdb_get___0(PathNodeTree pnt , char *file , char **matchfile ,
                                        char **ext ) 
{ 
  char *p ;
  char *filename ;
  char path[4096] ;
  struct path_node *pn ;
  struct path_node *match ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 143
  if (debug___0) {
    {
#line 143
    printf((char const   */* __restrict  */)"pkgcdb_get: %s\n", file);
    }
  }
#line 144
  if ((int )*(file + 0) == 47) {
#line 145
    file ++;
  }
  {
#line 147
  filename = file;
#line 148
  p = file;
#line 149
  pn = pathnode_top___0(pnt);
#line 150
  match = (struct path_node *)((void *)0);
#line 151
  matchpath[0] = (char )'\000';
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! ((int )*p != 0)) {
#line 152
      goto while_break;
    }
#line 153
    if ((int )*p != 47) {
#line 154
      p ++;
#line 155
      goto while_continue;
    } else
#line 153
    if (p - file <= 1L) {
#line 154
      p ++;
#line 155
      goto while_continue;
    }
#line 157
    p ++;
#line 159
    if (! (p - file < 4096L)) {
      {
#line 159
      __assert_fail("p - file < 4096", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                    159U, "pkgcdb_get");
      }
    }
    {
#line 160
    strncpy((char */* __restrict  */)(path), (char const   */* __restrict  */)file,
            (size_t )(p - file));
#line 161
    path[p - file] = (char )'\000';
#line 162
    pn = pathnode_retrieve___0(pnt, pn, path);
    }
#line 163
    if ((unsigned long )pn == (unsigned long )((void *)0)) {
#line 164
      if ((unsigned long )matchfile != (unsigned long )((void *)0)) {
#line 165
        if (! ((file - filename) + 2L < 4096L)) {
          {
#line 165
          __assert_fail("file - filename + 2 < 4096", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                        165U, "pkgcdb_get");
          }
        }
        {
#line 166
        *matchfile = matchpath;
#line 167
        matchpath[0] = (char )'/';
#line 168
        strncpy((char */* __restrict  */)(matchpath + 1), (char const   */* __restrict  */)filename,
                (size_t )(file - filename));
#line 169
        matchpath[(file + 1) - filename] = (char )'\000';
        }
      }
#line 171
      return (match);
    }
#line 173
    file = p;
#line 174
    match = pn;
#line 175
    if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
      {
#line 175
      __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                    175U, "pkgcdb_get");
      }
    }
#line 176
    if (! ((unsigned long )match != (unsigned long )((void *)0))) {
      {
#line 176
      __assert_fail("match != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                    176U, "pkgcdb_get");
      }
    }
#line 177
    if (debug___0) {
      {
#line 177
      tmp = pathnode_packagename___0(pnt, match);
#line 177
      tmp___0 = pathnode_pathname___0(pnt, pn);
#line 177
      printf((char const   */* __restrict  */)"match:%s[%s] rest>%s\n", tmp___0, tmp,
             file);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  if (debug___0) {
    {
#line 181
    printf((char const   */* __restrict  */)"last?%s (%d)\n", file, p - file);
    }
  }
#line 182
  if (p - file >= 1L) {
    {
#line 183
    pn = pathnode_retrieve___0(pnt, pn, file);
    }
#line 184
    if ((unsigned long )pn == (unsigned long )((void *)0)) {
#line 185
      if ((unsigned long )matchfile != (unsigned long )((void *)0)) {
#line 186
        if (! ((file - filename) + 2L < 4096L)) {
          {
#line 186
          __assert_fail("file - filename + 2 < 4096", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                        186U, "pkgcdb_get");
          }
        }
        {
#line 187
        *matchfile = matchpath;
#line 188
        matchpath[0] = (char )'/';
#line 189
        strncpy((char */* __restrict  */)(matchpath + 1), (char const   */* __restrict  */)filename,
                (size_t )(file - filename));
#line 190
        matchpath[(file + 1) - filename] = (char )'\000';
        }
      }
#line 192
      return (match);
    }
  }
#line 195
  if ((unsigned long )matchfile != (unsigned long )((void *)0)) {
    {
#line 196
    *matchfile = matchpath;
#line 197
    matchpath[0] = (char )'/';
#line 198
    strcpy((char */* __restrict  */)(matchpath + 1), (char const   */* __restrict  */)filename);
    }
  }
#line 200
  return (pn);
}
}
#line 43 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int apt_hook[4]  ;
#line 45 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static char *pkgcdb_file  =    (char *)"/var/cache/auto-apt/pkgcontents.bin";
#line 46 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static PathNodeTree pkgcdb_tree  =    (PathNodeTree )((void *)0);
#line 48 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static char *filedb_file  =    (char *)((void *)0);
#line 49 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static PathNodeTree filedb_tree  =    (PathNodeTree )((void *)0);
#line 59 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static struct realfunctab rftab[13]  = 
#line 59
  {      {(char *)"execve", (int (*)())((void *)0)}, 
        {(char *)"execv", (int (*)())((void *)0)}, 
        {(char *)"open", (int (*)())((void *)0)}, 
        {(char *)"open64", (int (*)())((void *)0)}, 
        {(char *)"__libc_open", (int (*)())((void *)0)}, 
        {(char *)"__libc_open64", (int (*)())((void *)0)}, 
        {(char *)"access", (int (*)())((void *)0)}, 
        {(char *)"euidaccess", (int (*)())((void *)0)}, 
        {(char *)"__xstat", (int (*)())((void *)0)}, 
        {(char *)"__xstat64", (int (*)())((void *)0)}, 
        {(char *)"__lxstat", (int (*)())((void *)0)}, 
        {(char *)"__lxstat64", (int (*)())((void *)0)}, 
        {(char *)((void *)0), (int (*)())((void *)0)}};
#line 83
static struct path_node *filename2package(PathNodeTree pnt , char const   *filename ,
                                          char **detected_file ) ;
#line 86
static int command_line_name(char *buf___1 , size_t siz ) ;
#line 88 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static funcptr load_library_symbol(char *name ) 
{ 
  void *handle ;
  char const   *error ;
  struct realfunctab *ft ;
  char *libcpath ;
  int tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
#line 94
  libcpath = (char *)((void *)0);
#line 96
  ft = rftab;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! ft->name) {
#line 96
      goto while_break;
    }
    {
#line 97
    tmp = strcmp((char const   *)name, (char const   *)ft->name);
    }
#line 97
    if (tmp == 0) {
#line 98
      if ((unsigned long )ft->fptr != (unsigned long )((void *)0)) {
#line 99
        return (ft->fptr);
      }
#line 101
      goto while_break;
    }
#line 96
    ft ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if ((unsigned long )ft->name == (unsigned long )((void *)0)) {
#line 105
    if (debug___0) {
      {
#line 105
      printf((char const   */* __restrict  */)"func:%s not found\n", name);
      }
    }
#line 106
    return ((funcptr )((void *)0));
  }
  {
#line 109
  libcpath = getenv("LIBC_PATH");
  }
#line 109
  if ((unsigned long )libcpath == (unsigned long )((void *)0)) {
#line 110
    libcpath = (char *)"/lib/libc.so.6";
  }
  {
#line 112
  handle = dlopen((char const   *)libcpath, 1);
  }
#line 113
  if (! handle) {
#line 114
    if (debug___0) {
      {
#line 114
      tmp___0 = dlerror();
#line 114
      printf((char const   */* __restrict  */)tmp___0);
      }
    }
#line 115
    return ((funcptr )((void *)0));
  }
  {
#line 117
  tmp___1 = dlsym((void */* __restrict  */)handle, (char const   */* __restrict  */)ft->name);
#line 117
  ft->fptr = (int (*)())tmp___1;
#line 118
  tmp___2 = dlerror();
#line 118
  error = (char const   *)tmp___2;
  }
#line 118
  if ((unsigned long )error != (unsigned long )((void *)0)) {
#line 119
    if (debug___0) {
      {
#line 119
      printf((char const   */* __restrict  */)"dysym(%s)=%s\n", ft->name, error);
      }
    }
#line 120
    ft->fptr = (int (*)())((void *)0);
  }
  {
#line 122
  dlclose(handle);
  }
#line 123
  return (ft->fptr);
}
}
#line 126 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int open_internal(char const   *filename , int flag , int mode ) 
{ 
  int (*__open)() ;
  funcptr tmp ;
  int tmp___0 ;

  {
  {
#line 129
  tmp = load_library_symbol((char *)"__libc_open64");
#line 129
  __open = tmp;
  }
#line 130
  if ((unsigned long )__open == (unsigned long )((void *)0)) {
    {
#line 130
    __open = load_library_symbol((char *)"__libc_open");
    }
  }
#line 131
  if ((unsigned long )__open == (unsigned long )((void *)0)) {
    {
#line 131
    __open = load_library_symbol((char *)"open64");
    }
  }
#line 132
  if ((unsigned long )__open == (unsigned long )((void *)0)) {
    {
#line 132
    __open = load_library_symbol((char *)"open");
    }
  }
#line 133
  if ((unsigned long )__open == (unsigned long )((void *)0)) {
#line 134
    return (-1);
  }
  {
#line 135
  tmp___0 = (*__open)(filename, flag, mode);
  }
#line 135
  return (tmp___0);
}
}
#line 139 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static char *auto_apt_conf_var(char *name , char *def ) 
{ 
  char *p ;
  char *tmp ;

  {
  {
#line 142
  tmp = getenv((char const   *)name);
#line 142
  p = tmp;
  }
#line 143
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 144
    return (def);
  }
#line 145
  if ((int )*p == 0) {
#line 146
    return (def);
  }
#line 147
  return (p);
}
}
#line 150 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int auto_apt_conf_switch(char *name ) 
{ 
  char *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 153
  tmp = auto_apt_conf_var(name, (char *)((void *)0));
#line 153
  p = tmp;
  }
#line 154
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 155
    return (0);
  }
  {
#line 156
  tmp___0 = strcasecmp((char const   *)p, "no");
  }
#line 156
  if (tmp___0 == 0) {
#line 157
    return (0);
  } else {
    {
#line 156
    tmp___1 = strcasecmp((char const   *)p, "off");
    }
#line 156
    if (tmp___1 == 0) {
#line 157
      return (0);
    }
  }
#line 158
  return (1);
}
}
#line 162 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static char *detectdb_file  =    (char *)((void *)0);
#line 163 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static char *detectdb_lockfile  =    (char *)((void *)0);
#line 166 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int detectdb_lock(void) 
{ 
  struct flock fl ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 170
  if ((unsigned long )(& detectdb_lock) != (unsigned long )((void *)0)) {
    {
#line 171
    tmp = open_internal((char const   *)detectdb_lockfile, 578, 432);
#line 171
    fd = tmp;
    }
#line 173
    if (fd == -1) {
      {
#line 174
      abort();
      }
#line 175
      return (-1);
    }
    again: 
    {
#line 178
    fl.l_type = (short)1;
#line 179
    fl.l_whence = (short)0;
#line 180
    fl.l_start = (__off_t )0;
#line 181
    fl.l_len = (__off_t )1;
#line 182
    tmp___3 = fcntl(fd, 6, & fl);
    }
#line 182
    if (tmp___3 == -1) {
      {
#line 183
      tmp___0 = __errno_location();
      }
#line 183
      if (*tmp___0 == 11) {
#line 184
        goto again;
      } else {
        {
#line 183
        tmp___1 = __errno_location();
        }
#line 183
        if (*tmp___1 == 11) {
#line 184
          goto again;
        } else {
          {
#line 183
          tmp___2 = __errno_location();
          }
#line 183
          if (*tmp___2 == 13) {
#line 184
            goto again;
          }
        }
      }
      {
#line 185
      close(fd);
#line 186
      abort();
      }
#line 187
      return (-1);
    }
#line 189
    return (fd);
  }
  {
#line 191
  abort();
  }
#line 192
  return (-1);
}
}
#line 195 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static void detectdb_unlock(int fd ) 
{ 
  struct flock fl ;
  int tmp ;

  {
#line 199
  if ((unsigned long )(& detectdb_lock) != (unsigned long )((void *)0)) {
#line 200
    if (fd >= 0) {
      {
#line 201
      fl.l_type = (short)2;
#line 202
      fl.l_whence = (short)0;
#line 203
      fl.l_start = (__off_t )0;
#line 204
      fl.l_len = (__off_t )1;
#line 205
      tmp = fcntl(fd, 6, & fl);
#line 208
      close(fd);
      }
    }
    {
#line 210
    unlink((char const   *)detectdb_lockfile);
    }
  }
#line 212
  return;
}
}
#line 214 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int detect_package(char const   *filename , char *func ) 
{ 
  int e ;
  struct path_node *pn ;
  char *file ;
  char *p ;
  char pkg[4096] ;
  int lockfd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char cmd[4096] ;
  int fd ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 217
  e = 0;
#line 219
  file = (char *)((void *)0);
#line 220
  p = (char *)((void *)0);
#line 224
  if ((unsigned long )detectdb_file == (unsigned long )((void *)0)) {
#line 225
    return (-1);
  }
#line 226
  if ((unsigned long )filedb_tree == (unsigned long )((void *)0)) {
#line 227
    return (-1);
  }
#line 228
  if (debug___0) {
    {
#line 228
    printf((char const   */* __restrict  */)"detect: %s\n", filename);
    }
  }
  {
#line 230
  tmp___2 = strcmp(filename, (char const   *)pkgcdb_file);
  }
#line 230
  if (tmp___2 == 0) {
#line 231
    return (0);
  } else {
    {
#line 232
    tmp___1 = strcmp(filename, (char const   *)detectdb_file);
    }
#line 232
    if (tmp___1 == 0) {
#line 233
      return (0);
    } else
#line 234
    if (detectdb_lockfile) {
      {
#line 234
      tmp___0 = strcmp(filename, (char const   *)detectdb_lockfile);
      }
#line 234
      if (tmp___0 == 0) {
#line 236
        return (0);
      } else {
#line 234
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 237
    if (filedb_file) {
      {
#line 237
      tmp = strcmp(filename, (char const   *)filedb_file);
      }
#line 237
      if (tmp == 0) {
#line 239
        return (0);
      }
    }
  }
#line 242
  if (debug___0) {
    {
#line 242
    printf((char const   */* __restrict  */)"check by filedb: %s\n", filename);
    }
  }
  {
#line 243
  pn = filename2package(filedb_tree, filename, & file);
  }
#line 244
  if ((unsigned long )pn == (unsigned long )((void *)0)) {
#line 245
    if (debug___0) {
      {
#line 245
      printf((char const   */* __restrict  */)"no package file, ignore\n");
      }
    }
#line 246
    return (-1);
  }
  {
#line 249
  p = pathnode_packagename___0(filedb_tree, pn);
  }
#line 250
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 250
    goto _L___0;
  } else
#line 250
  if ((int )*p == 33) {
#line 250
    goto _L___0;
  } else
#line 250
  if ((int )*p == 64) {
    _L___0: /* CIL Label */ 
#line 251
    if (debug___0) {
      {
#line 251
      printf((char const   */* __restrict  */)"dummy package, ignore\n");
      }
    }
#line 252
    return (-1);
  }
  {
#line 254
  strncpy((char */* __restrict  */)(pkg), (char const   */* __restrict  */)p, (size_t )4095);
  }
#line 255
  if (debug___0) {
    {
#line 255
    printf((char const   */* __restrict  */)"put it to detect file: %s => %s %s\n",
           filename, file, pkg);
    }
  }
#line 256
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 257
    file = (char *)filename;
  }
  {
#line 260
  lockfd = detectdb_lock();
  }
#line 261
  if (lockfd < 0) {
#line 262
    goto done;
  }
  {
#line 265
  tmp___3 = open_internal((char const   *)detectdb_file, 1089, 420);
#line 265
  fd = tmp___3;
  }
#line 267
  if (fd < 0) {
    {
#line 268
    abort();
    }
#line 269
    goto done;
  }
  {
#line 272
  tmp___4 = strlen((char const   *)file);
#line 272
  write(fd, (void const   *)file, tmp___4);
#line 273
  write(fd, (void const   *)"\t", (size_t )1);
#line 274
  tmp___5 = strlen((char const   *)(pkg));
#line 274
  write(fd, (void const   *)(pkg), tmp___5);
#line 275
  write(fd, (void const   *)"\t", (size_t )1);
#line 276
  tmp___6 = strlen((char const   *)func);
#line 276
  write(fd, (void const   *)func, tmp___6);
#line 277
  write(fd, (void const   *)"(", (size_t )1);
#line 278
  tmp___7 = strlen(filename);
#line 278
  write(fd, (void const   *)filename, tmp___7);
#line 279
  write(fd, (void const   *)")\t", (size_t )2);
#line 280
  command_line_name(cmd, (size_t )4095);
#line 281
  tmp___8 = strlen((char const   *)(cmd));
#line 281
  write(fd, (void const   *)(cmd), tmp___8);
#line 282
  write(fd, (void const   *)"\n", (size_t )1);
#line 283
  close(fd);
  }
  done: 
  {
#line 287
  detectdb_unlock(lockfd);
  }
#line 288
  return (e);
}
}
#line 298
static void auto_apt_setup(void) ;
#line 298 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int inited___0  =    0;
#line 295 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static void auto_apt_setup(void) 
{ 
  char *p ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;

  {
#line 300
  if (! inited___0) {
    {
#line 303
    inited___0 = 1;
#line 304
    mempool_init___0();
#line 305
    pkgtab_init___0();
#line 307
    i = 0;
    }
    {
#line 307
    while (1) {
      while_continue: /* CIL Label */ ;
#line 307
      if (! (i < 4)) {
#line 307
        goto while_break;
      }
#line 308
      apt_hook[i] = 0;
#line 307
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 310
    p = auto_apt_conf_var((char *)"AUTO_APT_HOOK", (char *)"none");
    }
#line 311
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 312
      tmp = strstr((char const   *)p, "exec");
#line 312
      apt_hook[0] = (unsigned long )tmp != (unsigned long )((void *)0);
#line 313
      tmp___0 = strstr((char const   *)p, "open");
#line 313
      apt_hook[1] = (unsigned long )tmp___0 != (unsigned long )((void *)0);
#line 314
      tmp___1 = strstr((char const   *)p, "access");
#line 314
      apt_hook[2] = (unsigned long )tmp___1 != (unsigned long )((void *)0);
#line 315
      tmp___2 = strstr((char const   *)p, "stat");
#line 315
      apt_hook[3] = (unsigned long )tmp___2 != (unsigned long )((void *)0);
#line 316
      tmp___3 = strcmp((char const   *)p, "all");
      }
#line 316
      if (tmp___3 == 0) {
#line 317
        i = 0;
        {
#line 317
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 317
          if (! (i < 4)) {
#line 317
            goto while_break___0;
          }
#line 318
          apt_hook[i] = 1;
#line 317
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 321
      tmp___4 = strstr((char const   *)p, "none");
      }
#line 321
      if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 322
        i = 0;
        {
#line 322
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 322
          if (! (i < 4)) {
#line 322
            goto while_break___1;
          }
#line 323
          apt_hook[i] = 0;
#line 322
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
    {
#line 327
    tmp___5 = auto_apt_conf_switch((char *)"AUTO_APT_DEBUG");
    }
#line 327
    if (tmp___5) {
#line 328
      debug___0 = 1;
    }
    {
#line 330
    tmp___6 = auto_apt_conf_switch((char *)"AUTO_APT_QUIET");
    }
#line 330
    if (tmp___6) {
#line 331
      quiet___0 = 1;
    }
    {
#line 333
    tmp___7 = auto_apt_conf_switch((char *)"AUTO_APT_VERBOSE");
    }
#line 333
    if (tmp___7) {
#line 334
      verbose___0 = 1;
    }
    {
#line 337
    p = auto_apt_conf_var((char *)"AUTO_APT_DB", (char *)"/var/cache/auto-apt/pkgcontents.bin");
    }
#line 338
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 338
      if ((int )*p == 47) {
        {
#line 339
        pkgcdb_file = strdup((char const   *)p);
#line 340
        pkgcdb_tree = pkgcdb_load___0(pkgcdb_file, 0, 0);
        }
#line 341
        if ((unsigned long )pkgcdb_tree == (unsigned long )((void *)0)) {
#line 342
          if (! quiet___0) {
#line 342
            if (verbose___0) {
              {
#line 342
              printf((char const   */* __restrict  */)"auto-apt %s load failed, auto-apt off\n",
                     pkgcdb_file);
              }
            }
          }
          {
#line 343
          unsetenv("LD_PRELOAD");
#line 344
          free((void *)pkgcdb_file);
#line 345
          pkgcdb_file = (char *)((void *)0);
          }
        }
      }
    }
    {
#line 350
    p = auto_apt_conf_var((char *)"AUTO_APT_DETECT", (char *)((void *)0));
    }
#line 351
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 352
      detectdb_file = strdup((char const   *)p);
      }
#line 353
      if (debug___0) {
        {
#line 353
        printf((char const   */* __restrict  */)"detectdb_file=%s\n", detectdb_file);
        }
      }
      {
#line 354
      tmp___8 = strlen((char const   *)detectdb_file);
#line 354
      tmp___9 = malloc(tmp___8 + 5UL);
#line 354
      detectdb_lockfile = (char *)tmp___9;
      }
#line 355
      if ((unsigned long )detectdb_lockfile != (unsigned long )((void *)0)) {
        {
#line 356
        sprintf((char */* __restrict  */)detectdb_lockfile, (char const   */* __restrict  */)"%s.lck",
                detectdb_file);
        }
#line 357
        if (debug___0) {
          {
#line 357
          printf((char const   */* __restrict  */)"lockfile=%s\n", detectdb_lockfile);
          }
        }
      }
    }
#line 360
    if ((unsigned long )detectdb_file != (unsigned long )((void *)0)) {
      {
#line 361
      p = auto_apt_conf_var((char *)"AUTO_APT_FILEDB", (char *)"/var/cache/auto-apt/pkgfiles.bin");
      }
#line 362
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 363
        filedb_file = strdup((char const   *)p);
        }
#line 364
        if (debug___0) {
          {
#line 364
          printf((char const   */* __restrict  */)"filedb: %s\n", filedb_file);
          }
        }
        {
#line 365
        filedb_tree = pkgcdb_load___0(filedb_file, 0, 0);
        }
#line 366
        if ((unsigned long )filedb_tree == (unsigned long )((void *)0)) {
#line 367
          if (! quiet___0) {
#line 367
            if (verbose___0) {
              {
#line 367
              printf((char const   */* __restrict  */)"auto-apt filedb %s not loaded, use %s\n",
                     filedb_file, pkgcdb_file);
              }
            }
          }
          {
#line 369
          free((void *)filedb_file);
#line 370
          filedb_file = (char *)((void *)0);
          }
        } else
#line 372
        if (! quiet___0) {
#line 372
          if (verbose___0) {
            {
#line 372
            printf((char const   */* __restrict  */)"auto-apt filedb: %s\n", filedb_file);
            }
          }
        }
      }
    }
  }
#line 378
  return;
}
}
#line 381 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static struct path_node *filename2package(PathNodeTree pnt , char const   *filename ,
                                          char **detected_file ) 
{ 
  int (*__stat)() ;
  char *fname ;
  char *tmp ;
  struct path_node *pn ;
  struct stat st ;
  int n ;
  char *tmp___0 ;
  char magic[4096] ;
  int len ;
  int fd ;
  int tmp___1 ;
  char *p ;
  char *q ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  char *mfile ;
  char list[4096] ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int len___0 ;
  int fd___0 ;
  int tmp___7 ;
  int tmp___8 ;
  ssize_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;

  {
  {
#line 384
  __stat = (int (*)())((void *)0);
#line 385
  tmp = strdup(filename);
#line 385
  fname = tmp;
#line 386
  pn = (struct path_node *)((void *)0);
#line 392
  n = 0;
  }
  again: 
#line 395
  n ++;
#line 395
  if (n >= 16) {
#line 396
    goto done;
  }
#line 397
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 398
    goto done;
  }
#line 399
  if (debug___0) {
    {
#line 399
    printf((char const   */* __restrict  */)"fname:%s\n", fname);
    }
  }
  {
#line 402
  tmp___0 = strstr((char const   *)fname, "/../");
  }
#line 402
  if (tmp___0) {
#line 403
    goto done;
  }
#line 405
  if ((int )*(fname + 0) != 47) {
#line 406
    goto done;
  }
#line 409
  if ((unsigned long )detected_file == (unsigned long )((void *)0)) {
#line 413
    if ((unsigned long )__stat == (unsigned long )((void *)0)) {
      {
#line 413
      __stat = load_library_symbol((char *)"__xstat");
      }
    }
#line 414
    if ((unsigned long )__stat == (unsigned long )((void *)0)) {
#line 414
      __stat = (int (*)())(& stat);
    }
#line 415
    if ((unsigned long )__stat == (unsigned long )((void *)0)) {
#line 416
      goto no_file;
    }
    {
#line 417
    tmp___3 = (*__stat)(1, fname, & st);
    }
#line 417
    if (tmp___3 == 0) {
#line 418
      if (debug___0) {
        {
#line 418
        printf((char const   */* __restrict  */)"stat(%s) ok: %0x\n", fname, st.st_mode);
        }
      }
#line 419
      if ((st.st_mode & 61440U) == 32768U) {
        {
#line 423
        tmp___1 = open_internal((char const   *)fname, 0, 0);
#line 423
        fd = tmp___1;
        }
#line 424
        if (fd < 0) {
#line 425
          if (debug___0) {
            {
#line 425
            printf((char const   */* __restrict  */)"fname:%s open fail\n", fname);
            }
          }
#line 426
          goto no_file;
        }
        {
#line 428
        tmp___2 = read(fd, (void *)(magic), sizeof(magic) - 1UL);
#line 428
        len = (int )tmp___2;
        }
#line 428
        if (len > 0) {
#line 429
          magic[len] = (char )'\000';
#line 430
          if (len > 2) {
#line 430
            if ((int )magic[0] == 35) {
#line 430
              if ((int )magic[1] == 33) {
                {
#line 433
                p = & magic[2];
#line 434
                q = strchr((char const   *)p, ' ');
                }
#line 435
                if ((unsigned long )q == (unsigned long )((void *)0)) {
                  {
#line 436
                  q = strchr((char const   *)p, '\n');
                  }
#line 437
                  if ((unsigned long )q == (unsigned long )((void *)0)) {
                    {
#line 438
                    close(fd);
                    }
#line 439
                    goto done;
                  }
                }
#line 442
                *q = (char )'\000';
#line 443
                if (debug___0) {
                  {
#line 443
                  printf((char const   */* __restrict  */)"magic#! found:%s\n", p);
                  }
                }
                {
#line 444
                free((void *)fname);
#line 445
                fname = strdup((char const   *)p);
#line 446
                close(fd);
                }
#line 447
                goto again;
              }
            }
          }
        }
#line 450
        if (debug___0) {
          {
#line 450
          printf((char const   */* __restrict  */)"magic check done\n");
          }
        }
        {
#line 451
        close(fd);
        }
      }
    }
  }
  no_file: 
  {
#line 458
  mfile = (char *)((void *)0);
#line 460
  pn = pkgcdb_get___0(pnt, fname, & mfile, (char **)((void *)0));
  }
#line 461
  if (pn) {
#line 461
    if (mfile) {
#line 462
      if (debug___0) {
        {
#line 462
        printf((char const   */* __restrict  */)"matched: file=%s\n", mfile);
        }
      }
#line 464
      if (detected_file) {
#line 465
        *detected_file = mfile;
      } else {
#line 468
        if (__stat) {
          {
#line 468
          tmp___5 = (*__stat)(1, mfile, & st);
          }
#line 468
          if (tmp___5 == 0) {
#line 470
            if (debug___0) {
              {
#line 470
              tmp___4 = pathnode_packagename___0(pnt, pn);
#line 470
              printf((char const   */* __restrict  */)"package:%s seems already installed, ignored\n",
                     tmp___4);
              }
            }
#line 472
            pn = (struct path_node *)((void *)0);
#line 473
            goto done;
          }
        }
        {
#line 480
        tmp___6 = pathnode_packagename___0(pnt, pn);
#line 480
        snprintf((char */* __restrict  */)(list), sizeof(list) - 1UL, (char const   */* __restrict  */)"/var/lib/dpkg/info/%s.list",
                 tmp___6);
        }
#line 482
        if (__stat) {
          {
#line 482
          tmp___10 = (*__stat)(1, list, & st);
          }
#line 482
          if (tmp___10 == 0) {
            {
#line 485
            tmp___7 = open_internal((char const   *)(list), 0, 0);
#line 485
            fd___0 = tmp___7;
            }
#line 486
            if (fd___0 < 0) {
#line 488
              goto done;
            }
            {
#line 490
            tmp___9 = read(fd___0, (void *)(list), sizeof(list) - 1UL);
#line 490
            len___0 = (int )tmp___9;
            }
#line 490
            if (len___0 > 0) {
              {
#line 491
              tmp___8 = strncmp((char const   *)(list), "/.\n", (size_t )3);
              }
#line 491
              if (tmp___8 == 0) {
                {
#line 493
                close(fd___0);
                }
#line 494
                return ((struct path_node *)((void *)0));
              }
            }
            {
#line 497
            close(fd___0);
            }
          }
        }
      }
    }
  }
#line 502
  if (debug___0) {
#line 502
    if (pn) {
      {
#line 502
      tmp___11 = pathnode_packagename___0(pnt, pn);
#line 502
      tmp___12 = (char const   *)tmp___11;
      }
    } else {
#line 502
      tmp___12 = "(null)";
    }
    {
#line 502
    printf((char const   */* __restrict  */)"done; package=%s\n", tmp___12);
    }
  }
  done: 
#line 505
  if (fname) {
    {
#line 506
    free((void *)fname);
    }
  }
#line 507
  return (pn);
}
}
#line 510 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int command_line_name(char *buf___1 , size_t siz ) 
{ 
  int len ;
  int pfd ;
  int i ;
  char *p ;
  ssize_t tmp ;

  {
  {
#line 515
  memset((void *)buf___1, 0, siz);
#line 516
  pfd = open_internal("/proc/self/cmdline", 0, 0);
  }
#line 517
  if (pfd < 0) {
#line 518
    return (-1);
  }
  {
#line 520
  tmp = read(pfd, (void *)buf___1, siz - 1UL);
#line 520
  len = (int )tmp;
  }
#line 520
  if (len > 0) {
#line 523
    i = 0;
    {
#line 523
    while (1) {
      while_continue: /* CIL Label */ ;
#line 523
      if (! (i < len)) {
#line 523
        goto while_break;
      }
#line 524
      if ((int )*(buf___1 + i) == 0) {
#line 524
        *(buf___1 + i) = (char )' ';
      }
#line 523
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 526
    *(buf___1 + len) = (char )'\000';
#line 528
    p = buf___1 + (len - 1);
    {
#line 528
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 528
      if (! ((unsigned long )p > (unsigned long )(buf___1 + 0))) {
#line 528
        goto while_break___0;
      }
#line 529
      if ((int )*p == 32) {
#line 530
        *p = (char )'\000';
      } else {
#line 532
        goto while_break___0;
      }
#line 528
      p --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 535
  close(pfd);
  }
#line 536
  return (0);
}
}
#line 541 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int check_dpkglock(void) 
{ 
  int fd ;
  struct flock fl ;
  __uid_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 546
  tmp = getuid();
  }
#line 546
  if (tmp) {
#line 548
    return (0);
  }
  {
#line 550
  fd = open_internal("/var/lib/dpkg/lock", 578, 432);
  }
#line 551
  if (fd == -1) {
#line 552
    return (0);
  }
  {
#line 553
  fl.l_type = (short)1;
#line 554
  fl.l_whence = (short)0;
#line 555
  fl.l_start = (__off_t )0;
#line 556
  fl.l_len = (__off_t )1;
#line 557
  tmp___3 = fcntl(fd, 6, & fl);
  }
#line 557
  if (tmp___3 == -1) {
    {
#line 558
    close(fd);
#line 559
    tmp___0 = __errno_location();
    }
#line 559
    if (*tmp___0 == 11) {
#line 560
      return (1);
    } else {
      {
#line 559
      tmp___1 = __errno_location();
      }
#line 559
      if (*tmp___1 == 11) {
#line 560
        return (1);
      } else {
        {
#line 559
        tmp___2 = __errno_location();
        }
#line 559
        if (*tmp___2 == 13) {
#line 560
          return (1);
        }
      }
    }
#line 562
    return (1);
  }
  {
#line 564
  fl.l_type = (short)2;
#line 565
  fl.l_whence = (short)0;
#line 566
  fl.l_start = (__off_t )0;
#line 567
  fl.l_len = (__off_t )1;
#line 568
  tmp___4 = fcntl(fd, 6, & fl);
#line 571
  close(fd);
  }
#line 572
  return (0);
}
}
#line 575 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int apt_get_install_for_file(char const   *filename ) 
{ 
  int status ;
  pid_t pid ;
  struct path_node *pn ;
  char *package___0 ;
  int ok ;
  char pkg[4096] ;
  char *path ;
  char *opath ;
  char *logfile ;
  char *tmp ;
  int simulate ;
  int tmp___0 ;
  int auto_apt_nobg ;
  int tmp___1 ;
  char cmdname[4096] ;
  int logfd ;
  char *accept ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *progpath ;
  char *argv[5] ;

  {
#line 582
  ok = 0;
#line 584
  if ((unsigned long )pkgcdb_tree == (unsigned long )((void *)0)) {
#line 585
    return (-1);
  }
  {
#line 586
  pn = filename2package(pkgcdb_tree, filename, (char **)((void *)0));
  }
#line 587
  if ((unsigned long )pn != (unsigned long )((void *)0)) {
    {
#line 590
    tmp = getenv("AUTO_APT_LOG");
#line 590
    logfile = tmp;
#line 591
    tmp___0 = auto_apt_conf_switch((char *)"AUTO_APT_SIMULATE");
#line 591
    simulate = tmp___0;
#line 592
    tmp___1 = auto_apt_conf_switch((char *)"AUTO_APT_NOBG");
#line 592
    auto_apt_nobg = tmp___1;
#line 594
    logfd = -1;
#line 595
    tmp___2 = getenv("AUTO_APT_ACCEPT");
#line 595
    accept = tmp___2;
    }
#line 600
    if (accept) {
      {
#line 600
      tmp___3 = strcmp((char const   *)accept, "none");
      }
#line 600
      if (tmp___3 == 0) {
#line 601
        simulate = 1;
      }
    }
#line 603
    if (logfile) {
      {
#line 604
      logfd = open_internal((char const   *)logfile, 1089, 420);
      }
    }
    {
#line 606
    opath = getenv("PATH");
#line 607
    tmp___4 = strlen("PATH=/usr/sbin:/sbin:");
#line 607
    tmp___5 = strlen((char const   *)opath);
#line 607
    tmp___6 = malloc((tmp___4 + tmp___5) + 2UL);
#line 607
    path = (char *)tmp___6;
    }
#line 608
    if (path) {
      {
#line 609
      sprintf((char */* __restrict  */)path, (char const   */* __restrict  */)"PATH=/usr/sbin:/sbin:%s",
              opath);
      }
    }
    {
#line 611
    package___0 = pathnode_packagename___0(pkgcdb_tree, pn);
#line 612
    strncpy((char */* __restrict  */)(pkg), (char const   */* __restrict  */)package___0,
            (size_t )4095);
#line 613
    command_line_name(cmdname, sizeof(cmdname));
    }
#line 615
    if (debug___0) {
      {
#line 615
      printf((char const   */* __restrict  */)"install: %s by %s\n", pkg, cmdname);
      }
    }
    {
#line 617
    if ((int )pkg[0] == 32) {
#line 617
      goto case_32;
    }
#line 617
    if ((int )pkg[0] == 42) {
#line 617
      goto case_32;
    }
#line 617
    if ((int )pkg[0] == 33) {
#line 617
      goto case_32;
    }
#line 616
    goto switch_break;
    case_32: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_33: /* CIL Label */ 
#line 619
    goto done;
    switch_break: /* CIL Label */ ;
    }
    {
#line 672
    tmp___10 = check_dpkglock();
    }
#line 672
    if (tmp___10) {
#line 673
      if (logfd >= 0) {
        {
#line 674
        write(logfd, (void const   *)"Install:", (size_t )8);
#line 675
        tmp___7 = strlen((char const   *)package___0);
#line 675
        write(logfd, (void const   *)package___0, tmp___7);
#line 676
        write(logfd, (void const   *)"\tfile:", (size_t )6);
#line 677
        tmp___8 = strlen(filename);
#line 677
        write(logfd, (void const   *)filename, tmp___8);
#line 678
        write(logfd, (void const   *)"\tby:", (size_t )4);
#line 679
        tmp___9 = strlen((char const   *)(cmdname));
#line 679
        write(logfd, (void const   *)(cmdname), tmp___9);
#line 680
        write(logfd, (void const   *)"\n", (size_t )1);
#line 681
        write(logfd, (void const   *)" - ignored, dpkg is running\n", (size_t )29);
        }
      }
#line 683
      goto done;
    }
#line 686
    if (logfd >= 0) {
      {
#line 687
      write(logfd, (void const   *)"Install:", (size_t )8);
#line 688
      tmp___11 = strlen((char const   *)package___0);
#line 688
      write(logfd, (void const   *)package___0, tmp___11);
#line 689
      write(logfd, (void const   *)"\tfile:", (size_t )6);
#line 690
      tmp___12 = strlen(filename);
#line 690
      write(logfd, (void const   *)filename, tmp___12);
#line 691
      write(logfd, (void const   *)"\tby:", (size_t )4);
#line 692
      tmp___13 = strlen((char const   *)(cmdname));
#line 692
      write(logfd, (void const   *)(cmdname), tmp___13);
#line 693
      write(logfd, (void const   *)"\n", (size_t )1);
      }
    }
#line 695
    if (logfd >= 0) {
      {
#line 696
      close(logfd);
#line 697
      logfd = -1;
      }
    }
#line 700
    if (simulate) {
#line 701
      if (! quiet___0) {
        {
#line 701
        tmp___14 = isatty(1);
        }
#line 701
        if (tmp___14) {
          {
#line 704
          printf((char const   */* __restrict  */)"Install:%s\tfile:%s\tby:%s\n",
                 package___0, filename, cmdname);
#line 706
          fflush(stdout);
          }
        }
      }
    } else {
#line 709
      if (auto_apt_nobg) {
        {
#line 709
        tmp___15 = isatty(1);
        }
#line 709
        if (! tmp___15) {
#line 710
          goto done;
        }
      }
      {
#line 712
      pid = fork();
      }
#line 713
      if (pid == 0) {
        {
#line 715
        progpath = "/usr/lib/auto-apt/auto-apt-installer";
#line 717
        argv[0] = (char *)"auto-apt-installer";
#line 718
        argv[1] = cmdname;
#line 719
        argv[2] = (char *)filename;
#line 720
        argv[3] = package___0;
#line 721
        argv[4] = (char *)((void *)0);
#line 722
        unsetenv("LD_PRELOAD");
        }
#line 723
        if (path) {
          {
#line 724
          putenv(path);
          }
        }
        {
#line 725
        execv(progpath, (char * const  *)(argv));
#line 726
        exit(-1);
        }
      }
      {
#line 785
      waitpid(pid, & status, 0);
#line 786
      ok = status == 0;
      }
    }
    done: 
#line 789
    if (logfd >= 0) {
      {
#line 790
      close(logfd);
#line 791
      logfd = -1;
      }
    }
#line 793
    if (path) {
      {
#line 794
      free((void *)path);
      }
    }
#line 795
    return (ok);
  }
#line 797
  return (0);
}
}
#line 801
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *path ,
                                                                                       char const   *arg 
                                                                                       , ...) ;
#line 801 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *path , char const   *arg 
                                                         , ...) 
{ 
  size_t argv_max ;
  char const   **argv ;
  void *tmp ;
  unsigned int i ;
  va_list args ;
  char const   **nptr ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 804
  argv_max = (size_t )1024;
#line 805
  tmp = __builtin_alloca(argv_max * sizeof(char const   *));
#line 805
  argv = (char const   **)tmp;
#line 809
  auto_apt_setup();
#line 810
  *(argv + 0) = arg;
#line 811
  __builtin_va_start(args, arg);
#line 812
  i = 0U;
  }
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    tmp___3 = i;
#line 813
    i ++;
#line 813
    if (! ((unsigned long )*(argv + tmp___3) != (unsigned long )((void *)0))) {
#line 813
      goto while_break;
    }
#line 814
    if ((size_t )i == argv_max) {
      {
#line 815
      argv_max *= 2UL;
#line 815
      tmp___0 = __builtin_alloca(argv_max * sizeof(char const   *));
#line 815
      nptr = (char const   **)tmp___0;
#line 817
      tmp___1 = memmove((void *)nptr, (void const   *)argv, (size_t )i);
#line 817
      argv = (char const   **)tmp___1;
#line 818
      argv_max += (size_t )i;
      }
    }
    {
#line 820
    tmp___2 = __builtin_va_arg(args, char const   *);
#line 820
    *(argv + i) = tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 822
  __builtin_va_end(args);
#line 823
  tmp___4 = execv(path, (char * const  *)argv);
  }
#line 823
  return (tmp___4);
}
}
#line 826
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const   *path ,
                                                                                        char const   *arg 
                                                                                        , ...) ;
#line 826 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const   *path , char const   *arg 
                                                          , ...) 
{ 
  size_t argv_max ;
  char const   **argv ;
  void *tmp ;
  char const   * const  *envp ;
  unsigned int i ;
  va_list args ;
  char const   **nptr ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  unsigned int tmp___3 ;
  char const   * const  *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 829
  argv_max = (size_t )1024;
#line 830
  tmp = __builtin_alloca(argv_max * sizeof(char const   *));
#line 830
  argv = (char const   **)tmp;
#line 834
  *(argv + 0) = arg;
#line 836
  auto_apt_setup();
#line 837
  __builtin_va_start(args, arg);
#line 838
  i = 0U;
  }
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 839
    tmp___3 = i;
#line 839
    i ++;
#line 839
    if (! ((unsigned long )*(argv + tmp___3) != (unsigned long )((void *)0))) {
#line 839
      goto while_break;
    }
#line 840
    if ((size_t )i == argv_max) {
      {
#line 841
      argv_max *= 2UL;
#line 841
      tmp___0 = __builtin_alloca(argv_max * sizeof(char const   *));
#line 841
      nptr = (char const   **)tmp___0;
#line 843
      tmp___1 = memmove((void *)nptr, (void const   *)argv, (size_t )i);
#line 843
      argv = (char const   **)tmp___1;
#line 844
      argv_max += (size_t )i;
      }
    }
    {
#line 846
    tmp___2 = __builtin_va_arg(args, char const   *);
#line 846
    *(argv + i) = tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 848
  tmp___4 = __builtin_va_arg(args, char const   * const  *);
#line 848
  envp = tmp___4;
#line 849
  __builtin_va_end(args);
#line 850
  tmp___5 = execve(path, (char * const  *)argv, (char * const  *)envp);
  }
#line 850
  return (tmp___5);
}
}
#line 853
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *filename ,
                                                                                        char * const  *argv ,
                                                                                        char * const  *envp ) ;
#line 853 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *filename ,
                                                          char * const  *argv , char * const  *envp ) 
{ 
  int e ;
  int apt ;
  int (*__execve)() ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 857
  apt = 0;
#line 860
  auto_apt_setup();
  }
  again: 
#line 862
  if (debug___0) {
    {
#line 862
    printf((char const   */* __restrict  */)"execve: filename=%s \n", filename);
    }
  }
#line 863
  if (! apt) {
#line 863
    if (detectdb_file) {
      {
#line 863
      detect_package(filename, (char *)"execve");
      }
    }
  }
  {
#line 864
  __execve = load_library_symbol((char *)"execve");
  }
#line 865
  if ((unsigned long )__execve == (unsigned long )((void *)0)) {
    {
#line 866
    tmp = __errno_location();
#line 866
    *tmp = 22;
    }
#line 867
    return (-1);
  }
#line 869
  if (debug___0) {
    {
#line 869
    printf((char const   */* __restrict  */)"execve = %p\n", __execve);
    }
  }
  {
#line 870
  e = (*__execve)(filename, argv, envp);
  }
#line 871
  if (debug___0) {
    {
#line 871
    printf((char const   */* __restrict  */)"execve: filename=%s, e=%d\n", filename,
           e);
    }
  }
#line 872
  if (apt_hook[0]) {
#line 872
    if (e < 0) {
      {
#line 873
      tmp___0 = __errno_location();
      }
      {
#line 874
      if (*tmp___0 == 2) {
#line 874
        goto case_2;
      }
#line 881
      goto switch_default;
      case_2: /* CIL Label */ 
#line 875
      if (debug___0) {
        {
#line 875
        printf((char const   */* __restrict  */)"execve: filename=%s not found\n",
               filename);
        }
      }
#line 876
      if (! apt) {
        {
#line 876
        tmp___1 = apt_get_install_for_file(filename);
        }
#line 876
        if (tmp___1) {
#line 877
          apt = 1;
#line 878
          goto again;
        }
      }
#line 880
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 882
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 885
  return (e);
}
}
#line 888
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *filename ,
                                                                                       char * const  *argv ) ;
#line 888 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *filename ,
                                                         char * const  *argv ) 
{ 
  int e ;
  int apt ;
  int (*__execv)() ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 892
  apt = 0;
#line 895
  auto_apt_setup();
  }
  again: 
#line 897
  if (debug___0) {
    {
#line 897
    printf((char const   */* __restrict  */)"execv: filename=%s \n", filename);
    }
  }
#line 898
  if (! apt) {
#line 898
    if (detectdb_file) {
      {
#line 898
      detect_package(filename, (char *)"execv");
      }
    }
  }
  {
#line 899
  __execv = load_library_symbol((char *)"execv");
  }
#line 900
  if ((unsigned long )__execv == (unsigned long )((void *)0)) {
    {
#line 901
    tmp = __errno_location();
#line 901
    *tmp = 22;
    }
#line 902
    return (-1);
  }
#line 904
  if (debug___0) {
    {
#line 904
    printf((char const   */* __restrict  */)"execv = %p :filename=%s %d,%s\n", __execv,
           filename, apt, detectdb_file);
    }
  }
  {
#line 906
  e = (*__execv)(filename, argv);
  }
#line 907
  if (debug___0) {
    {
#line 907
    printf((char const   */* __restrict  */)"execvp: filename=%s, e=%d\n", filename,
           e);
    }
  }
#line 908
  if (apt_hook[0]) {
#line 908
    if (e < 0) {
      {
#line 909
      tmp___0 = __errno_location();
      }
      {
#line 910
      if (*tmp___0 == 2) {
#line 910
        goto case_2;
      }
#line 917
      goto switch_default;
      case_2: /* CIL Label */ 
#line 911
      if (debug___0) {
        {
#line 911
        printf((char const   */* __restrict  */)"execv: filename=%s not found\n",
               filename);
        }
      }
#line 912
      if (! apt) {
        {
#line 912
        tmp___1 = apt_get_install_for_file(filename);
        }
#line 912
        if (tmp___1) {
#line 913
          apt = 1;
#line 914
          goto again;
        }
      }
#line 916
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 918
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 921
  return (e);
}
}
#line 933 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int o  =    0;
#line 925 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int ( __attribute__((__nonnull__(1))) open)(char const   *filename , int flags  , ...) 
{ 
  int apt ;
  int e ;
  int (*__open)() ;
  mode_t mode ;
  va_list ap ;
  int *tmp ;
  mode_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 928
  apt = 0;
#line 935
  auto_apt_setup();
  }
  again: 
#line 937
  if (debug___0) {
    {
#line 937
    printf((char const   */* __restrict  */)"open: filename=%s \n", filename);
    }
  }
#line 938
  if (! apt) {
#line 938
    if (detectdb_file) {
#line 938
      if (! o) {
        {
#line 939
        o = 1;
#line 939
        detect_package(filename, (char *)"open");
#line 939
        o = 0;
        }
      }
    }
  }
  {
#line 941
  __open = load_library_symbol((char *)"open");
  }
#line 942
  if ((unsigned long )__open == (unsigned long )((void *)0)) {
    {
#line 943
    tmp = __errno_location();
#line 943
    *tmp = 2;
    }
#line 944
    return (-1);
  }
#line 946
  if (debug___0) {
    {
#line 946
    printf((char const   */* __restrict  */)"open = %p\n", __open);
    }
  }
  {
#line 947
  __builtin_va_start(ap, flags);
#line 948
  tmp___0 = __builtin_va_arg(ap, mode_t );
#line 948
  mode = tmp___0;
#line 949
  __builtin_va_end(ap);
#line 950
  e = (*__open)(filename, flags, mode);
  }
#line 951
  if (debug___0) {
    {
#line 951
    printf((char const   */* __restrict  */)"open: filename=%s e=%d\n", filename,
           e);
    }
  }
#line 952
  if (apt_hook[1]) {
#line 952
    if (e < 0) {
      {
#line 953
      tmp___1 = __errno_location();
      }
      {
#line 954
      if (*tmp___1 == 2) {
#line 954
        goto case_2;
      }
#line 962
      goto switch_default;
      case_2: /* CIL Label */ 
#line 955
      if ((int const   )*filename == 47) {
#line 956
        if (! apt) {
          {
#line 956
          tmp___2 = apt_get_install_for_file(filename);
          }
#line 956
          if (tmp___2) {
#line 957
            apt = 1;
#line 958
            goto again;
          }
        }
      }
#line 961
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 963
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 966
  return (e);
}
}
#line 979
int __libc_open(char const   *filename , int flags  , ...) ;
#line 979 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int o___0  =    0;
#line 971 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int __libc_open(char const   *filename , int flags  , ...) 
{ 
  int apt ;
  int e ;
  int (*__open)() ;
  mode_t mode ;
  va_list ap ;
  int *tmp ;
  mode_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 974
  apt = 0;
#line 981
  auto_apt_setup();
  }
  again: 
#line 983
  if (debug___0) {
    {
#line 983
    printf((char const   */* __restrict  */)"__libc_open: filename=%s \n", filename);
    }
  }
#line 984
  if (! apt) {
#line 984
    if (detectdb_file) {
#line 984
      if (! o___0) {
        {
#line 985
        o___0 = 1;
#line 985
        detect_package(filename, (char *)"__libc_open");
#line 985
        o___0 = 0;
        }
      }
    }
  }
  {
#line 987
  __open = load_library_symbol((char *)"__libc_open");
  }
#line 988
  if ((unsigned long )__open == (unsigned long )((void *)0)) {
    {
#line 989
    tmp = __errno_location();
#line 989
    *tmp = 2;
    }
#line 990
    return (-1);
  }
#line 992
  if (debug___0) {
    {
#line 992
    printf((char const   */* __restrict  */)"__libc_open = %p\n", __open);
    }
  }
  {
#line 993
  __builtin_va_start(ap, flags);
#line 994
  tmp___0 = __builtin_va_arg(ap, mode_t );
#line 994
  mode = tmp___0;
#line 995
  __builtin_va_end(ap);
#line 996
  e = (*__open)(filename, flags, mode);
  }
#line 997
  if (debug___0) {
    {
#line 997
    printf((char const   */* __restrict  */)"__libc_open: filename=%s e=%d\n", filename,
           e);
    }
  }
#line 998
  if (apt_hook[1]) {
#line 998
    if (e < 0) {
      {
#line 999
      tmp___1 = __errno_location();
      }
      {
#line 1000
      if (*tmp___1 == 2) {
#line 1000
        goto case_2;
      }
#line 1008
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1001
      if ((int const   )*filename == 47) {
#line 1002
        if (! apt) {
          {
#line 1002
          tmp___2 = apt_get_install_for_file(filename);
          }
#line 1002
          if (tmp___2) {
#line 1003
            apt = 1;
#line 1004
            goto again;
          }
        }
      }
#line 1007
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1009
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1012
  return (e);
}
}
#line 1026
int open64(char const   *filename , int flags  , ...) ;
#line 1026 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int o___1  =    0;
#line 1018 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int open64(char const   *filename , int flags  , ...) 
{ 
  int apt ;
  int e ;
  int (*__open)() ;
  mode_t mode ;
  va_list ap ;
  int *tmp ;
  mode_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1021
  apt = 0;
#line 1028
  auto_apt_setup();
  }
  again: 
#line 1030
  if (debug___0) {
    {
#line 1030
    printf((char const   */* __restrict  */)"open64: filename=%s \n", filename);
    }
  }
#line 1031
  if (! apt) {
#line 1031
    if (detectdb_file) {
#line 1031
      if (! o___1) {
        {
#line 1032
        o___1 = 1;
#line 1032
        detect_package(filename, (char *)"open64");
#line 1032
        o___1 = 0;
        }
      }
    }
  }
  {
#line 1034
  __open = load_library_symbol((char *)"open64");
  }
#line 1035
  if ((unsigned long )__open == (unsigned long )((void *)0)) {
    {
#line 1036
    tmp = __errno_location();
#line 1036
    *tmp = 2;
    }
#line 1037
    return (-1);
  }
#line 1039
  if (debug___0) {
    {
#line 1039
    printf((char const   */* __restrict  */)"open64 = %p\n", __open);
    }
  }
  {
#line 1040
  __builtin_va_start(ap, flags);
#line 1041
  tmp___0 = __builtin_va_arg(ap, mode_t );
#line 1041
  mode = tmp___0;
#line 1042
  __builtin_va_end(ap);
#line 1043
  e = (*__open)(filename, flags, mode);
  }
#line 1044
  if (debug___0) {
    {
#line 1044
    printf((char const   */* __restrict  */)"open64: filename=%s e=%d\n", filename,
           e);
    }
  }
#line 1045
  if (apt_hook[1]) {
#line 1045
    if (e < 0) {
      {
#line 1046
      tmp___1 = __errno_location();
      }
      {
#line 1047
      if (*tmp___1 == 2) {
#line 1047
        goto case_2;
      }
#line 1055
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1048
      if ((int const   )*filename == 47) {
#line 1049
        if (! apt) {
          {
#line 1049
          tmp___2 = apt_get_install_for_file(filename);
          }
#line 1049
          if (tmp___2) {
#line 1050
            apt = 1;
#line 1051
            goto again;
          }
        }
      }
#line 1054
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1056
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1059
  return (e);
}
}
#line 1072
int __libc_open64(char const   *filename , int flags  , ...) ;
#line 1072 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
static int o___2  =    0;
#line 1064 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int __libc_open64(char const   *filename , int flags  , ...) 
{ 
  int apt ;
  int e ;
  int (*__open)() ;
  mode_t mode ;
  va_list ap ;
  int *tmp ;
  mode_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1067
  apt = 0;
#line 1074
  auto_apt_setup();
  }
  again: 
#line 1076
  if (debug___0) {
    {
#line 1076
    printf((char const   */* __restrict  */)"__libc_open64: filename=%s \n", filename);
    }
  }
#line 1077
  if (! apt) {
#line 1077
    if (detectdb_file) {
#line 1077
      if (! o___2) {
        {
#line 1078
        o___2 = 1;
#line 1078
        detect_package(filename, (char *)"__libc_open64");
#line 1078
        o___2 = 0;
        }
      }
    }
  }
  {
#line 1080
  __open = load_library_symbol((char *)"__libc_open64");
  }
#line 1081
  if ((unsigned long )__open == (unsigned long )((void *)0)) {
    {
#line 1082
    tmp = __errno_location();
#line 1082
    *tmp = 2;
    }
#line 1083
    return (-1);
  }
#line 1085
  if (debug___0) {
    {
#line 1085
    printf((char const   */* __restrict  */)"__libc_open64 = %p\n", __open);
    }
  }
  {
#line 1086
  __builtin_va_start(ap, flags);
#line 1087
  tmp___0 = __builtin_va_arg(ap, mode_t );
#line 1087
  mode = tmp___0;
#line 1088
  __builtin_va_end(ap);
#line 1089
  e = (*__open)(filename, flags, mode);
  }
#line 1090
  if (debug___0) {
    {
#line 1090
    printf((char const   */* __restrict  */)"__libc_open64: filename=%s e=%d\n", filename,
           e);
    }
  }
#line 1091
  if (apt_hook[1]) {
#line 1091
    if (e < 0) {
      {
#line 1092
      tmp___1 = __errno_location();
      }
      {
#line 1093
      if (*tmp___1 == 2) {
#line 1093
        goto case_2;
      }
#line 1101
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1094
      if ((int const   )*filename == 47) {
#line 1095
        if (! apt) {
          {
#line 1095
          tmp___2 = apt_get_install_for_file(filename);
          }
#line 1095
          if (tmp___2) {
#line 1096
            apt = 1;
#line 1097
            goto again;
          }
        }
      }
#line 1100
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1102
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1105
  return (e);
}
}
#line 1110
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *filename ,
                                                                                      int type ) ;
#line 1110 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *filename , int type ) 
{ 
  int apt ;
  int e ;
  int (*__access)() ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1113
  apt = 0;
#line 1117
  auto_apt_setup();
  }
  again: 
#line 1119
  if (debug___0) {
    {
#line 1119
    printf((char const   */* __restrict  */)"access: filename=%s \n", filename);
    }
  }
#line 1120
  if (! apt) {
#line 1120
    if (detectdb_file) {
      {
#line 1120
      detect_package(filename, (char *)"access");
      }
    }
  }
  {
#line 1121
  __access = load_library_symbol((char *)"access");
  }
#line 1122
  if ((unsigned long )__access == (unsigned long )((void *)0)) {
    {
#line 1123
    tmp = __errno_location();
#line 1123
    *tmp = 2;
    }
#line 1124
    return (-1);
  }
#line 1126
  if (debug___0) {
    {
#line 1126
    printf((char const   */* __restrict  */)"access = %p\n", __access);
    }
  }
  {
#line 1127
  e = (*__access)(filename, type);
  }
#line 1128
  if (debug___0) {
    {
#line 1128
    printf((char const   */* __restrict  */)"access: filename=%s e=%d\n", filename,
           e);
    }
  }
#line 1129
  if (apt_hook[2]) {
#line 1129
    if (e < 0) {
      {
#line 1130
      tmp___0 = __errno_location();
      }
      {
#line 1131
      if (*tmp___0 == 2) {
#line 1131
        goto case_2;
      }
#line 1139
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1132
      if ((int const   )*filename == 47) {
#line 1133
        if (! apt) {
          {
#line 1133
          tmp___1 = apt_get_install_for_file(filename);
          }
#line 1133
          if (tmp___1) {
#line 1134
            apt = 1;
#line 1135
            goto again;
          }
        }
      }
#line 1138
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1140
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1143
  return (e);
}
}
#line 1146 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int euidaccess(char const   *filename , int type ) 
{ 
  int apt ;
  int e ;
  int (*__euidaccess)() ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1149
  apt = 0;
#line 1153
  auto_apt_setup();
  }
  again: 
#line 1155
  if (debug___0) {
    {
#line 1155
    printf((char const   */* __restrict  */)"euidaccess: filename=%s \n", filename);
    }
  }
#line 1156
  if (! apt) {
#line 1156
    if (detectdb_file) {
      {
#line 1156
      detect_package(filename, (char *)"euidaccess");
      }
    }
  }
  {
#line 1157
  __euidaccess = load_library_symbol((char *)"euidaccess");
  }
#line 1158
  if ((unsigned long )__euidaccess == (unsigned long )((void *)0)) {
    {
#line 1159
    tmp = __errno_location();
#line 1159
    *tmp = 2;
    }
#line 1160
    return (-1);
  }
#line 1162
  if (debug___0) {
    {
#line 1162
    printf((char const   */* __restrict  */)"euidaccess = %p\n", __euidaccess);
    }
  }
  {
#line 1163
  e = (*__euidaccess)(filename, type);
  }
#line 1164
  if (debug___0) {
    {
#line 1164
    printf((char const   */* __restrict  */)"euidaccess: filename=%s e=%d\n", filename,
           e);
    }
  }
#line 1165
  if (apt_hook[2]) {
#line 1165
    if (e < 0) {
      {
#line 1166
      tmp___0 = __errno_location();
      }
      {
#line 1167
      if (*tmp___0 == 2) {
#line 1167
        goto case_2;
      }
#line 1175
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1168
      if ((int const   )*filename == 47) {
#line 1169
        if (! apt) {
          {
#line 1169
          tmp___1 = apt_get_install_for_file(filename);
          }
#line 1169
          if (tmp___1) {
#line 1170
            apt = 1;
#line 1171
            goto again;
          }
        }
      }
#line 1174
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1176
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1179
  return (e);
}
}
#line 1184
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int ver ,
                                                                                         char const   *filename ,
                                                                                         struct stat *buf___1 ) ;
#line 1184 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int ver , char const   *filename ,
                                                           struct stat *buf___1 ) 
{ 
  int apt ;
  int e ;
  int (*__stat)() ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1187
  apt = 0;
#line 1191
  auto_apt_setup();
  }
  again: 
#line 1193
  if (debug___0) {
    {
#line 1193
    printf((char const   */* __restrict  */)"stat: filename=%s \n", filename);
    }
  }
#line 1194
  if (! apt) {
#line 1194
    if (detectdb_file) {
      {
#line 1194
      detect_package(filename, (char *)"__xstat");
      }
    }
  }
  {
#line 1195
  __stat = load_library_symbol((char *)"__xstat");
  }
#line 1196
  if ((unsigned long )__stat == (unsigned long )((void *)0)) {
    {
#line 1197
    tmp = __errno_location();
#line 1197
    *tmp = 2;
    }
#line 1198
    return (-1);
  }
#line 1200
  if (debug___0) {
    {
#line 1200
    printf((char const   */* __restrict  */)"stat = %p\n", __stat);
    }
  }
  {
#line 1201
  e = (*__stat)(ver, filename, buf___1);
  }
#line 1202
  if (debug___0) {
    {
#line 1202
    printf((char const   */* __restrict  */)"stat: filename=%s e=%d\n", filename,
           e);
    }
  }
#line 1203
  if (apt_hook[3]) {
#line 1203
    if (e < 0) {
      {
#line 1204
      tmp___0 = __errno_location();
      }
      {
#line 1205
      if (*tmp___0 == 2) {
#line 1205
        goto case_2;
      }
#line 1213
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1206
      if ((int const   )*filename == 47) {
#line 1207
        if (! apt) {
          {
#line 1207
          tmp___1 = apt_get_install_for_file(filename);
          }
#line 1207
          if (tmp___1) {
#line 1208
            apt = 1;
#line 1209
            goto again;
          }
        }
      }
#line 1212
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1214
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1217
  return (e);
}
}
#line 1222 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int __xstat64(int ver , char const   *filename , struct stat64 *buf___1 ) 
{ 
  int apt ;
  int e ;
  int (*__stat)() ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1225
  apt = 0;
#line 1229
  auto_apt_setup();
  }
  again: 
#line 1231
  if (debug___0) {
    {
#line 1231
    printf((char const   */* __restrict  */)"stat64: filename=%s \n", filename);
    }
  }
#line 1232
  if (! apt) {
#line 1232
    if (detectdb_file) {
      {
#line 1232
      detect_package(filename, (char *)"__xstat64");
      }
    }
  }
  {
#line 1233
  __stat = load_library_symbol((char *)"__xstat64");
  }
#line 1234
  if ((unsigned long )__stat == (unsigned long )((void *)0)) {
    {
#line 1235
    tmp = __errno_location();
#line 1235
    *tmp = 2;
    }
#line 1236
    return (-1);
  }
#line 1238
  if (debug___0) {
    {
#line 1238
    printf((char const   */* __restrict  */)"stat64 = %p\n", __stat);
    }
  }
  {
#line 1239
  e = (*__stat)(ver, filename, buf___1);
  }
#line 1240
  if (debug___0) {
    {
#line 1240
    printf((char const   */* __restrict  */)"stat64: filename=%s e=%d\n", filename,
           e);
    }
  }
#line 1241
  if (apt_hook[3]) {
#line 1241
    if (e < 0) {
      {
#line 1242
      tmp___0 = __errno_location();
      }
      {
#line 1243
      if (*tmp___0 == 2) {
#line 1243
        goto case_2;
      }
#line 1251
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1244
      if ((int const   )*filename == 47) {
#line 1245
        if (! apt) {
          {
#line 1245
          tmp___1 = apt_get_install_for_file(filename);
          }
#line 1245
          if (tmp___1) {
#line 1246
            apt = 1;
#line 1247
            goto again;
          }
        }
      }
#line 1250
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1252
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1255
  return (e);
}
}
#line 1260
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int ver ,
                                                                                          char const   *filename ,
                                                                                          struct stat *buf___1 ) ;
#line 1260 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int ver , char const   *filename ,
                                                            struct stat *buf___1 ) 
{ 
  int apt ;
  int e ;
  int (*__stat)() ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1263
  apt = 0;
#line 1267
  auto_apt_setup();
  }
  again: 
#line 1269
  if (debug___0) {
    {
#line 1269
    printf((char const   */* __restrict  */)"lstat: filename=%s \n", filename);
    }
  }
#line 1270
  if (! apt) {
#line 1270
    if (detectdb_file) {
      {
#line 1270
      detect_package(filename, (char *)"__lxstat");
      }
    }
  }
  {
#line 1271
  __stat = load_library_symbol((char *)"__lxstat");
  }
#line 1272
  if ((unsigned long )__stat == (unsigned long )((void *)0)) {
    {
#line 1273
    tmp = __errno_location();
#line 1273
    *tmp = 2;
    }
#line 1274
    return (-1);
  }
#line 1276
  if (debug___0) {
    {
#line 1276
    printf((char const   */* __restrict  */)"lstat = %p\n", __stat);
    }
  }
  {
#line 1277
  e = (*__stat)(ver, filename, buf___1);
  }
#line 1278
  if (debug___0) {
    {
#line 1278
    printf((char const   */* __restrict  */)"lstat: filename=%s e=%d\n", filename,
           e);
    }
  }
#line 1279
  if (apt_hook[3]) {
#line 1279
    if (e < 0) {
      {
#line 1280
      tmp___0 = __errno_location();
      }
      {
#line 1281
      if (*tmp___0 == 2) {
#line 1281
        goto case_2;
      }
#line 1289
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1282
      if ((int const   )*filename == 47) {
#line 1283
        if (! apt) {
          {
#line 1283
          tmp___1 = apt_get_install_for_file(filename);
          }
#line 1283
          if (tmp___1) {
#line 1284
            apt = 1;
#line 1285
            goto again;
          }
        }
      }
#line 1288
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1290
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1293
  return (e);
}
}
#line 1297 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt.c"
int __lxstat64(int ver , char const   *filename , struct stat64 *buf___1 ) 
{ 
  int apt ;
  int e ;
  int (*__stat)() ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1300
  apt = 0;
#line 1304
  auto_apt_setup();
  }
  again: 
#line 1306
  if (debug___0) {
    {
#line 1306
    printf((char const   */* __restrict  */)"lstat64: filename=%s \n", filename);
    }
  }
#line 1307
  if (! apt) {
#line 1307
    if (detectdb_file) {
      {
#line 1307
      detect_package(filename, (char *)"__lxstat64");
      }
    }
  }
  {
#line 1308
  __stat = load_library_symbol((char *)"__lxstat64");
  }
#line 1309
  if ((unsigned long )__stat == (unsigned long )((void *)0)) {
    {
#line 1310
    tmp = __errno_location();
#line 1310
    *tmp = 2;
    }
#line 1311
    return (-1);
  }
#line 1313
  if (debug___0) {
    {
#line 1313
    printf((char const   */* __restrict  */)"lstat64 = %p\n", __stat);
    }
  }
  {
#line 1314
  e = (*__stat)(ver, filename, buf___1);
  }
#line 1315
  if (debug___0) {
    {
#line 1315
    printf((char const   */* __restrict  */)"lstat64: filename=%s e=%d\n", filename,
           e);
    }
  }
#line 1316
  if (apt_hook[3]) {
#line 1316
    if (e < 0) {
      {
#line 1317
      tmp___0 = __errno_location();
      }
      {
#line 1318
      if (*tmp___0 == 2) {
#line 1318
        goto case_2;
      }
#line 1326
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1319
      if ((int const   )*filename == 47) {
#line 1320
        if (! apt) {
          {
#line 1320
          tmp___1 = apt_get_install_for_file(filename);
          }
#line 1320
          if (tmp___1) {
#line 1321
            apt = 1;
#line 1322
            goto again;
          }
        }
      }
#line 1325
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1327
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1330
  return (e);
}
}
#line 27 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/debug.h"
int debug ;
#line 34
int quiet ;
#line 17 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.h"
void mempool_init(void) ;
#line 18
struct mempool *mempool_alloc(struct mempool *mp , int count , size_t siz ) ;
#line 21
void mempool_release(struct mempool *mp ) ;
#line 25
void mempool_shrink(struct mempool *mp , int num ) ;
#line 27
void *mempool_mem(struct mempool *mp ) ;
#line 28
void *mempool_mem_avail(struct mempool *mp , int avail ) ;
#line 29
int mempool_index(struct mempool *mp , void *ptr ) ;
#line 30
void *mempool_fetch(struct mempool *mp , int idx ) ;
#line 36
int mempool_dump(struct mempool *mp , int fd , int (*serialize)(void *buf , void *ptr ,
                                                                int count , int siz ,
                                                                void *arg ) , void *arg ) ;
#line 42
struct mempool *mempool_restore(int fd , void (*unserialize)(struct mempool *mp ,
                                                             void *ptr , int count ,
                                                             int siz , void *arg ) ,
                                void *arg , int margin ) ;
#line 25 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
void mempool_init(void) 
{ 


  {
#line 28
  return;
}
}
#line 31 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
struct mempool *mempool_alloc(struct mempool *mp , int count , size_t siz ) 
{ 
  int start ;
  struct mempool *nmp ;
  void *tmp ;

  {
#line 37
  if (! (count != 0)) {
    {
#line 37
    __assert_fail("count != 0", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  37U, "mempool_alloc");
    }
  }
#line 38
  if (! (siz != 0UL)) {
    {
#line 38
    __assert_fail("siz != 0", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  38U, "mempool_alloc");
    }
  }
#line 39
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
#line 40
    start = 0;
  } else {
#line 42
    start = mp->start + mp->count;
#line 43
    if (! (mp->siz == siz)) {
      {
#line 43
      __assert_fail("mp->siz == siz", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                    43U, "mempool_alloc");
      }
    }
  }
  {
#line 45
  tmp = malloc(sizeof(struct mempool ));
#line 45
  nmp = (struct mempool *)tmp;
  }
#line 46
  if ((unsigned long )nmp == (unsigned long )((void *)0)) {
    {
#line 48
    abort();
    }
  }
  {
#line 50
  memset((void *)nmp, 0, sizeof(struct mempool ));
#line 51
  nmp->mem = malloc((size_t )count * siz);
  }
#line 52
  if ((unsigned long )nmp->mem == (unsigned long )((void *)0)) {
    {
#line 54
    abort();
    }
  }
  {
#line 56
  memset(nmp->mem, 0, (size_t )count * siz);
#line 57
  nmp->m_next = mp;
#line 58
  nmp->start = start;
#line 59
  nmp->count = count;
#line 60
  nmp->siz = siz;
  }
#line 61
  return (nmp);
}
}
#line 65 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
void mempool_release(struct mempool *mp ) 
{ 
  struct mempool *cmp___0 ;
  struct mempool *nmp ;

  {
#line 69
  if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
    {
#line 69
    __assert_fail("mp != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  69U, "mempool_release");
    }
  }
#line 70
  cmp___0 = mp;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! ((unsigned long )cmp___0 != (unsigned long )((void *)0))) {
#line 70
      goto while_break;
    }
#line 71
    nmp = cmp___0->m_next;
#line 72
    if ((unsigned long )cmp___0->mem != (unsigned long )((void *)0)) {
      {
#line 73
      free(cmp___0->mem);
      }
    }
    {
#line 74
    cmp___0->mem = (void *)0;
#line 75
    cmp___0->start = 0;
#line 76
    cmp___0->count = 0;
#line 77
    cmp___0->siz = (size_t )0;
#line 78
    cmp___0->m_next = (struct mempool *)((void *)0);
#line 79
    free((void *)cmp___0);
#line 70
    cmp___0 = nmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 86 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
void mempool_shrink(struct mempool *mp , int num ) 
{ 


  {
#line 89
  if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
    {
#line 89
    __assert_fail("mp != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  89U, "mempool_shrink");
    }
  }
#line 90
  if (! (num < mp->count)) {
    {
#line 90
    __assert_fail("num < mp->count", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  90U, "mempool_shrink");
    }
  }
#line 91
  mp->count -= num;
#line 92
  return;
}
}
#line 95 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
void *mempool_mem(struct mempool *mp ) 
{ 


  {
#line 98
  if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
    {
#line 98
    __assert_fail("mp != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  98U, "mempool_mem");
    }
  }
#line 99
  if (! ((unsigned long )mp->mem != (unsigned long )((void *)0))) {
    {
#line 99
    __assert_fail("mp->mem != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  99U, "mempool_mem");
    }
  }
#line 100
  return (mp->mem);
}
}
#line 103 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
void *mempool_mem_avail(struct mempool *mp , int avail ) 
{ 


  {
#line 106
  if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
    {
#line 106
    __assert_fail("mp != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  106U, "mempool_mem_avail");
    }
  }
#line 107
  if (! ((unsigned long )mp->mem != (unsigned long )((void *)0))) {
    {
#line 107
    __assert_fail("mp->mem != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  107U, "mempool_mem_avail");
    }
  }
#line 108
  if (! (mp->count >= avail)) {
    {
#line 108
    __assert_fail("mp->count >= avail", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                  108U, "mempool_mem_avail");
    }
  }
#line 109
  if (avail == 0) {
#line 110
    return ((void *)0);
  }
#line 112
  return ((void *)((char *)mp->mem + (size_t )(mp->count - avail) * mp->siz));
}
}
#line 115 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
int mempool_index(struct mempool *mp , void *ptr ) 
{ 


  {
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
#line 118
      goto while_break;
    }
#line 119
    if ((unsigned long )mp->mem <= (unsigned long )ptr) {
#line 119
      if ((unsigned long )((char *)ptr) < (unsigned long )((char *)mp->mem + (size_t )mp->count * mp->siz)) {
#line 121
        if (! ((unsigned long )((char *)ptr - (char *)mp->mem) % mp->siz == 0UL)) {
          {
#line 121
          __assert_fail("((char *)ptr - (char *)mp->mem)%mp->siz == 0", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c",
                        121U, "mempool_index");
          }
        }
#line 122
        return ((int )((size_t )((char *)ptr - (char *)mp->mem) / mp->siz + (size_t )mp->start));
      }
    }
#line 118
    mp = mp->m_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return (-1);
}
}
#line 128 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
void *mempool_fetch(struct mempool *mp , int idx ) 
{ 


  {
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
#line 131
      goto while_break;
    }
#line 132
    if (mp->start <= idx) {
#line 132
      if (idx < mp->start + mp->count) {
#line 134
        return ((void *)((char *)mp->mem + (size_t )(idx - mp->start) * mp->siz));
      }
    }
#line 131
    mp = mp->m_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return ((void *)0);
}
}
#line 141 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
static int mempool_dump_rec(struct mempool *mp , int count , int siz , int fd , int (*serialize)(void *buf ,
                                                                                                 void *ptr ,
                                                                                                 int count ,
                                                                                                 int siz ,
                                                                                                 void *arg ) ,
                            void *arg ) 
{ 
  int e ;
  void *buf___1 ;
  int len ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 149
  buf___1 = (void *)0;
#line 150
  len = 0;
#line 151
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
#line 152
    if (debug) {
      {
#line 152
      printf((char const   */* __restrict  */)"-header: begin\n");
      }
    }
#line 153
    if (debug) {
      {
#line 153
      printf((char const   */* __restrict  */)"  count=%d\n", count);
      }
    }
    {
#line 154
    tmp = write(fd, (void const   *)(& count), sizeof(int ));
#line 154
    e = (int )tmp;
    }
#line 155
    if (e < 1) {
#line 156
      if (! quiet) {
        {
#line 156
        perror("write count");
        }
      }
#line 157
      return (-1);
    }
#line 159
    if (debug) {
      {
#line 159
      printf((char const   */* __restrict  */)"  siz=%d\n", siz);
      }
    }
    {
#line 160
    tmp___0 = write(fd, (void const   *)(& siz), sizeof(int ));
#line 160
    e = (int )tmp___0;
    }
#line 161
    if (e < 1) {
#line 162
      if (! quiet) {
        {
#line 162
        perror("write siz");
        }
      }
#line 163
      return (-1);
    }
#line 165
    if (debug) {
      {
#line 165
      printf((char const   */* __restrict  */)"-header: end\n");
      }
    }
#line 166
    return (0);
  }
  {
#line 168
  e = mempool_dump_rec(mp->m_next, count + mp->count, (int )mp->siz, fd, serialize,
                       arg);
  }
#line 170
  if (e < 0) {
#line 171
    if (! quiet) {
      {
#line 171
      perror("write data");
      }
    }
#line 172
    return (e);
  }
#line 174
  if (debug) {
    {
#line 174
    printf((char const   */* __restrict  */)".");
    }
  }
#line 175
  if ((unsigned long )serialize != (unsigned long )((void *)0)) {
    {
#line 176
    buf___1 = malloc((size_t )mp->count * mp->siz);
#line 177
    len = (*serialize)(buf___1, mp->mem, mp->count, (int )mp->siz, arg);
    }
#line 178
    if (len < 0) {
#line 179
      if (debug) {
        {
#line 179
        printf((char const   */* __restrict  */)"-serialize error? %d\n", len);
        }
      }
      {
#line 180
      free(buf___1);
      }
#line 181
      return (-1);
    }
  } else {
#line 184
    buf___1 = mp->mem;
#line 185
    len = (int )((size_t )mp->count * mp->siz);
  }
#line 187
  if (debug) {
    {
#line 187
    printf((char const   */* __restrict  */)"-data: %d * %d => (%d)\n", mp->count,
           mp->siz, len);
    }
  }
  {
#line 188
  tmp___1 = write(fd, (void const   *)buf___1, (size_t )len);
#line 188
  e = (int )tmp___1;
  }
#line 189
  if ((unsigned long )serialize != (unsigned long )((void *)0)) {
    {
#line 190
    free(buf___1);
    }
  }
#line 191
  if (e < 1) {
#line 192
    if (! quiet) {
      {
#line 192
      perror("write data");
      }
    }
#line 193
    return (-1);
  }
#line 195
  return (0);
}
}
#line 200 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
int mempool_dump(struct mempool *mp , int fd , int (*serialize)(void *buf , void *ptr ,
                                                                int count , int siz ,
                                                                void *arg ) , void *arg ) 
{ 
  int e ;

  {
#line 208
  if (debug) {
    {
#line 208
    printf((char const   */* __restrict  */)"\ndump: mem=%p\n", mp);
    }
  }
  {
#line 209
  e = mempool_dump_rec(mp, 0, (int )mp->siz, fd, serialize, arg);
  }
#line 210
  if (debug) {
    {
#line 210
    printf((char const   */* __restrict  */)" done\n");
    }
  }
#line 211
  return (e);
}
}
#line 215 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/mempool.c"
struct mempool *mempool_restore(int fd , void (*unserialize)(struct mempool *mp ,
                                                             void *ptr , int count ,
                                                             int siz , void *arg ) ,
                                void *arg , int margin ) 
{ 
  struct mempool *mp ;
  int e ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 226
  if (debug) {
    {
#line 226
    printf((char const   */* __restrict  */)"restore ");
    }
  }
  {
#line 227
  tmp = malloc(sizeof(struct mempool ));
#line 227
  mp = (struct mempool *)tmp;
  }
#line 228
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
#line 229
    if (debug) {
      {
#line 229
      printf((char const   */* __restrict  */)"mempool_restore: not enough memory for mempool header\n");
      }
    }
    {
#line 230
    abort();
    }
  }
  {
#line 232
  memset((void *)mp, 0, sizeof(struct mempool ));
#line 233
  e = read_data(fd, (void *)(& mp->count), (int )sizeof(int ));
  }
#line 234
  if ((unsigned long )e != sizeof(int )) {
#line 235
    if (debug) {
      {
#line 235
      tmp___0 = __errno_location();
#line 235
      printf((char const   */* __restrict  */)"read count fd:%d e:%d errno:%d\n",
             fd, e, *tmp___0);
      }
    }
#line 236
    if (! quiet) {
      {
#line 236
      perror("read count");
      }
    }
    {
#line 237
    abort();
    }
  }
#line 239
  if (debug) {
    {
#line 239
    printf((char const   */* __restrict  */)"count %d + %d, ", mp->count, margin);
    }
  }
  {
#line 240
  e = read_data(fd, (void *)(& mp->siz), (int )sizeof(int ));
  }
#line 241
  if ((unsigned long )e != sizeof(int )) {
#line 242
    if (debug) {
      {
#line 242
      tmp___1 = __errno_location();
#line 242
      printf((char const   */* __restrict  */)"read siz fd:%d e:%d errno:%d\n", fd,
             e, *tmp___1);
      }
    }
#line 243
    if (! quiet) {
      {
#line 243
      perror("read siz");
      }
    }
    {
#line 244
    abort();
    }
  }
#line 246
  if (debug) {
    {
#line 246
    printf((char const   */* __restrict  */)"siz %d, ", mp->siz);
    }
  }
  {
#line 247
  mp->mem = malloc((size_t )(mp->count + margin) * mp->siz);
  }
#line 248
  if ((unsigned long )mp->mem == (unsigned long )((void *)0)) {
#line 249
    if (debug) {
      {
#line 249
      printf((char const   */* __restrict  */)"mempool_restore: not enough memory for mempool contents\n");
      }
    }
    {
#line 250
    abort();
    }
  }
  {
#line 252
  e = read_data(fd, mp->mem, (int )((size_t )mp->count * mp->siz));
  }
#line 253
  if ((size_t )e != (size_t )mp->count * mp->siz) {
#line 254
    if (debug) {
      {
#line 254
      tmp___2 = __errno_location();
#line 254
      printf((char const   */* __restrict  */)"read data fd:%d e:%d errno:%d\n", fd,
             e, *tmp___2);
      }
    }
#line 255
    if (! quiet) {
      {
#line 255
      perror("read data");
      }
    }
    {
#line 256
    abort();
    }
  }
#line 258
  if (debug) {
    {
#line 258
    printf((char const   */* __restrict  */)"...");
    }
  }
#line 259
  if ((unsigned long )unserialize != (unsigned long )((void *)0)) {
    {
#line 260
    (*unserialize)(mp, mp->mem, mp->count, (int )mp->siz, arg);
    }
  }
#line 262
  mp->count += margin;
#line 263
  if (debug) {
    {
#line 263
    printf((char const   */* __restrict  */)"done\n");
    }
  }
#line 264
  return (mp);
}
}
#line 26 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.h"
str_id str_intern(StrTable st , char *string , int add ) ;
#line 27
char *str_symbol(StrTable st , str_id sid ) ;
#line 19 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.h"
pkg_id pkg_null ;
#line 26
pkg_id pkg_intern(StrTable st , char *pkg ) ;
#line 28
char *pkg_symbol(StrTable st , pkg_id pid ) ;
#line 30
int pkg_cmp(pkg_id *p0 , pkg_id *p1 ) ;
#line 19 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.h"
PathNodeTree pathnode_alloc(StrTable st ) ;
#line 22
void pathnode_release(PathNodeTree pnt ) ;
#line 26
void pathnode_ignore_package(PathNodeTree pnt , char *pkg ) ;
#line 30
struct path_node *pathnode_insert(PathNodeTree pnt , struct path_node *pn , char *path ,
                                  pkg_id pkgid ) ;
#line 35
struct path_node *pathnode_chain(PathNodeTree pnt , struct path_node *pn , pkg_id pkgid ) ;
#line 39
struct path_node *pathnode_retrieve(PathNodeTree pnt , struct path_node *pn , char *path ) ;
#line 42
void pathnode_traverse(PathNodeTree pnt , char *path , struct path_node *pn , void (*func)(PathNodeTree pnt ,
                                                                                           char *path ,
                                                                                           struct path_node *pn ,
                                                                                           void *arg ) ,
                       void *arg ) ;
#line 51
StrTable pathnode_strtab(PathNodeTree pnt ) ;
#line 53
struct path_node *pathnode_top(PathNodeTree pnt ) ;
#line 55
str_id pathnode_path(PathNodeTree pnt , struct path_node *pn ) ;
#line 57
char *pathnode_pathname(PathNodeTree pnt , struct path_node *pn ) ;
#line 59
pkg_id pathnode_package(PathNodeTree pnt , struct path_node *pn ) ;
#line 61
char *pathnode_packagename(PathNodeTree pnt , struct path_node *pn ) ;
#line 64
struct path_node *pathnode_next(PathNodeTree pnt , struct path_node *pn ) ;
#line 68
void pathnode_delete(PathNodeTree pnt , struct path_node *pn ) ;
#line 72
int pathnode_dump(int fd , PathNodeTree pnt , int shrink ) ;
#line 74
PathNodeTree pathnode_restore(int fd , StrTable st , int margin ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 60 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
static struct path_node *pathnode_add(PathNodeTree pnt , str_id pathid , pkg_id pkgid ) 
{ 
  struct path_node *pn ;
  void *tmp ;

  {
#line 64
  if (! ((unsigned long )pnt != (unsigned long )((void *)0))) {
    {
#line 64
    __assert_fail("pnt != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  64U, "pathnode_add");
    }
  }
#line 65
  if (! ((unsigned long )pnt->st != (unsigned long )((void *)0))) {
    {
#line 65
    __assert_fail("pnt->st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  65U, "pathnode_add");
    }
  }
#line 67
  if ((unsigned long )pnt->pn_next == (unsigned long )((void *)0)) {
    {
#line 68
    pnt->p_st = mempool_alloc(pnt->p_st, 8192, sizeof(struct path_node ));
#line 70
    tmp = mempool_mem(pnt->p_st);
#line 70
    pnt->pn_next = (struct path_node *)tmp;
#line 71
    pnt->pn_avail = 8192;
#line 72
    pnt->pn_alloc += 8192;
    }
  } else
#line 67
  if (pnt->pn_avail <= 0) {
    {
#line 68
    pnt->p_st = mempool_alloc(pnt->p_st, 8192, sizeof(struct path_node ));
#line 70
    tmp = mempool_mem(pnt->p_st);
#line 70
    pnt->pn_next = (struct path_node *)tmp;
#line 71
    pnt->pn_avail = 8192;
#line 72
    pnt->pn_alloc += 8192;
    }
  }
  {
#line 74
  pn = pnt->pn_next;
#line 75
  memset((void *)pn, 0, sizeof(struct path_node ));
#line 76
  pn->path = pathid;
#line 77
  pn->pathname = str_symbol(pnt->st, pathid);
#line 78
  pn->package = pkgid;
#line 80
  pnt->pn_next = pn + 1;
#line 81
  (pnt->pn_avail) --;
#line 82
  (pnt->num_pn) ++;
  }
#line 83
  return (pn);
}
}
#line 88 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
PathNodeTree pathnode_alloc(StrTable st ) 
{ 
  PathNodeTree pnt ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 92
  tmp = malloc(sizeof(struct __pathnode_tree ));
#line 92
  pnt = (PathNodeTree )tmp;
  }
#line 93
  if ((unsigned long )pnt == (unsigned long )((void *)0)) {
#line 94
    return ((PathNodeTree )((void *)0));
  }
  {
#line 95
  memset((void *)pnt, 0, sizeof(struct __pathnode_tree ));
#line 96
  pnt->st = st;
#line 97
  pnt->num_pn = 0;
#line 98
  pnt->p_st = mempool_alloc((struct mempool *)((void *)0), 8192, sizeof(struct path_node ));
#line 100
  tmp___0 = mempool_mem(pnt->p_st);
#line 100
  pnt->pn_next = (struct path_node *)tmp___0;
#line 101
  pnt->pn_avail = 8192;
#line 102
  pnt->pn_alloc = 8192;
#line 103
  pnt->top = pathnode_add(pnt, 0, pkg_null);
  }
#line 104
  return (pnt);
}
}
#line 109 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
void pathnode_release(PathNodeTree pnt ) 
{ 


  {
#line 112
  if (! ((unsigned long )pnt != (unsigned long )((void *)0))) {
    {
#line 112
    __assert_fail("pnt != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  112U, "pathnode_release");
    }
  }
#line 113
  if (! ((unsigned long )pnt->p_st != (unsigned long )((void *)0))) {
    {
#line 113
    __assert_fail("pnt->p_st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  113U, "pathnode_release");
    }
  }
  {
#line 115
  pnt->st = (StrTable )((void *)0);
#line 116
  mempool_release(pnt->p_st);
#line 117
  pnt->pn_next = (struct path_node *)((void *)0);
#line 118
  pnt->pn_avail = 0;
#line 119
  pnt->pn_alloc = 0;
#line 120
  free((void *)pnt);
  }
#line 121
  return;
}
}
#line 125 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
void pathnode_ignore_package(PathNodeTree pnt , char *pkg ) 
{ 


  {
#line 128
  if (! ((unsigned long )pnt != (unsigned long )((void *)0))) {
    {
#line 128
    __assert_fail("pnt != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  128U, "pathnode_ignore_package");
    }
  }
  {
#line 129
  pnt->ignore_pkg_id = pkg_intern(pnt->st, pkg);
  }
#line 130
  return;
}
}
#line 135 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
struct path_node *pathnode_insert(PathNodeTree pnt , struct path_node *pn , char *path ,
                                  pkg_id pkgid ) 
{ 
  struct path_node *npn ;
  int r ;
  str_id pathid ;
  str_id tmp ;
  struct path_node *tmp___0 ;

  {
  {
#line 141
  tmp = str_intern(pnt->st, path, 1);
#line 141
  pathid = tmp;
  }
#line 149
  if ((unsigned long )pn->down == (unsigned long )((void *)0)) {
    {
#line 150
    npn = pathnode_add(pnt, pathid, pkgid);
#line 151
    pn->down = npn;
    }
#line 157
    return (npn);
  }
#line 159
  pn = pn->down;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if ((unsigned long )pn->pathname == (unsigned long )((void *)0)) {
      {
#line 162
      pn->pathname = str_symbol(pnt->st, pn->path);
      }
    }
    {
#line 163
    r = cmp(pn->path, pathid);
    }
#line 169
    if (r == 0) {
      {
#line 171
      tmp___0 = pathnode_chain(pnt, pn, pkgid);
      }
#line 171
      return (tmp___0);
    }
#line 174
    if (r < 0) {
#line 175
      if ((unsigned long )pn->left == (unsigned long )((void *)0)) {
#line 176
        goto while_break;
      }
#line 177
      pn = pn->left;
#line 178
      (pnt->num_left) ++;
    } else {
#line 180
      if ((unsigned long )pn->right == (unsigned long )((void *)0)) {
#line 181
        goto while_break;
      }
#line 182
      pn = pn->right;
#line 183
      (pnt->num_right) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  npn = pathnode_add(pnt, pathid, pkgid);
  }
#line 189
  if (r < 0) {
#line 190
    npn->left = pn->left;
#line 191
    pn->left = npn;
  } else {
#line 198
    npn->right = pn->right;
#line 199
    pn->right = npn;
  }
#line 206
  return (npn);
}
}
#line 211 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
struct path_node *pathnode_chain(PathNodeTree pnt , struct path_node *pn , pkg_id pkgid ) 
{ 
  struct path_node *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 215
  if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
    {
#line 215
    __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  215U, "pathnode_chain");
    }
  }
  {
#line 216
  tmp = pkg_cmp(& pkgid, & pn->package);
  }
#line 216
  if (tmp == 0) {
#line 217
    return (pn);
  }
#line 219
  p = pn->dups;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 219
      goto while_break;
    }
    {
#line 220
    tmp___0 = pkg_cmp(& pkgid, & p->package);
    }
#line 220
    if (tmp___0 == 0) {
#line 221
      return (pn);
    }
    {
#line 223
    tmp___1 = pkg_cmp(& pnt->ignore_pkg_id, & p->package);
    }
#line 223
    if (tmp___1 == 0) {
#line 224
      return (pn);
    }
#line 219
    p = p->dups;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  if ((unsigned long )pn->pathname == (unsigned long )((void *)0)) {
    {
#line 227
    pn->pathname = str_symbol(pnt->st, pn->path);
    }
  }
  {
#line 229
  p = pathnode_add(pnt, pn->path, pkgid);
#line 230
  p->dups = pn->dups;
#line 231
  pn->dups = p;
  }
#line 236
  return (pn);
}
}
#line 241 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
struct path_node *pathnode_retrieve(PathNodeTree pnt , struct path_node *pn , char *path ) 
{ 
  int r ;
  str_id pathid ;
  str_id tmp ;
  char *tmp___0 ;

  {
  {
#line 245
  tmp = str_intern(pnt->st, path, 0);
#line 245
  pathid = tmp;
  }
#line 247
  if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
    {
#line 247
    __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  247U, "pathnode_retrieve");
    }
  }
#line 248
  if (debug) {
    {
#line 248
    tmp___0 = pathnode_pathname(pnt, pn);
#line 248
    printf((char const   */* __restrict  */)"retr: %p(%s) %s\n", pn, tmp___0, path);
    }
  }
#line 250
  pn = pn->down;
#line 251
  if ((unsigned long )pn == (unsigned long )((void *)0)) {
#line 252
    if (debug) {
      {
#line 252
      printf((char const   */* __restrict  */)"no child?\n");
      }
    }
#line 253
    return (pn);
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if ((unsigned long )pn->pathname == (unsigned long )((void *)0)) {
      {
#line 261
      pn->pathname = str_symbol(pnt->st, pn->path);
      }
    }
    {
#line 262
    r = cmp(pn->path, pathid);
    }
#line 263
    if (r == 0) {
#line 264
      if (debug) {
        {
#line 264
        printf((char const   */* __restrict  */)"found - ok %p\n", pn);
        }
      }
#line 265
      return (pn);
    }
#line 268
    if (r < 0) {
#line 273
      if ((unsigned long )pn->left == (unsigned long )((void *)0)) {
#line 274
        goto while_break;
      }
#line 275
      pn = pn->left;
    } else {
#line 281
      if ((unsigned long )pn->right == (unsigned long )((void *)0)) {
#line 282
        goto while_break;
      }
#line 283
      pn = pn->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  if (debug) {
    {
#line 286
    printf((char const   */* __restrict  */)"not found\n");
    }
  }
#line 287
  return ((struct path_node *)((void *)0));
}
}
#line 290 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
void pathnode_traverse(PathNodeTree pnt , char *path , struct path_node *pn , void (*func)(PathNodeTree pnt ,
                                                                                           char *path ,
                                                                                           struct path_node *pn ,
                                                                                           void *arg ) ,
                       void *arg ) 
{ 
  char *npath ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 298
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 299
    pathnode_traverse(pnt, (char *)"", pn->down, func, arg);
    }
#line 300
    return;
  }
#line 302
  if ((unsigned long )pn == (unsigned long )((void *)0)) {
#line 303
    return;
  }
#line 304
  if ((unsigned long )pn->left != (unsigned long )((void *)0)) {
    {
#line 305
    pathnode_traverse(pnt, path, pn->left, func, arg);
    }
  }
#line 306
  if ((unsigned long )pn->right != (unsigned long )((void *)0)) {
    {
#line 307
    pathnode_traverse(pnt, path, pn->right, func, arg);
    }
  }
  {
#line 308
  (*func)(pnt, path, pn, arg);
#line 309
  tmp = strlen((char const   *)path);
#line 309
  tmp___0 = pathnode_pathname(pnt, pn);
#line 309
  tmp___1 = strlen((char const   *)tmp___0);
#line 309
  tmp___2 = __builtin_alloca((tmp + tmp___1) + 1UL);
#line 309
  npath = (char *)tmp___2;
#line 310
  tmp___3 = pathnode_pathname(pnt, pn);
#line 310
  sprintf((char */* __restrict  */)npath, (char const   */* __restrict  */)"%s%s",
          path, tmp___3);
  }
#line 311
  if (pn->down) {
    {
#line 312
    pathnode_traverse(pnt, npath, pn->down, func, arg);
    }
  }
#line 313
  return;
}
}
#line 316 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
StrTable pathnode_strtab(PathNodeTree pnt ) 
{ 


  {
#line 319
  if (! ((unsigned long )pnt != (unsigned long )((void *)0))) {
    {
#line 319
    __assert_fail("pnt != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  319U, "pathnode_strtab");
    }
  }
#line 320
  return (pnt->st);
}
}
#line 324 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
struct path_node *pathnode_top(PathNodeTree pnt ) 
{ 


  {
#line 327
  if (! ((unsigned long )pnt != (unsigned long )((void *)0))) {
    {
#line 327
    __assert_fail("pnt != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  327U, "pathnode_top");
    }
  }
#line 328
  return (pnt->top);
}
}
#line 332 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
str_id pathnode_path(PathNodeTree pnt , struct path_node *pn ) 
{ 


  {
#line 335
  if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
    {
#line 335
    __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  335U, "pathnode_path");
    }
  }
#line 336
  return (pn->path);
}
}
#line 340 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
char *pathnode_pathname(PathNodeTree pnt , struct path_node *pn ) 
{ 


  {
#line 343
  if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
    {
#line 343
    __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  343U, "pathnode_pathname");
    }
  }
#line 344
  if ((unsigned long )pn->pathname == (unsigned long )((void *)0)) {
    {
#line 344
    pn->pathname = str_symbol(pnt->st, pn->path);
    }
  }
#line 345
  return (pn->pathname);
}
}
#line 349 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
pkg_id pathnode_package(PathNodeTree pnt , struct path_node *pn ) 
{ 


  {
#line 352
  if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
    {
#line 352
    __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  352U, "pathnode_package");
    }
  }
#line 353
  return (pn->package);
}
}
#line 357 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
char *pathnode_packagename(PathNodeTree pnt , struct path_node *pn ) 
{ 
  char *tmp ;

  {
#line 360
  if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
    {
#line 360
    __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  360U, "pathnode_packagename");
    }
  }
  {
#line 361
  tmp = pkg_symbol(pnt->st, pn->package);
  }
#line 361
  return (tmp);
}
}
#line 365 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
struct path_node *pathnode_next(PathNodeTree pnt , struct path_node *pn ) 
{ 


  {
#line 368
  if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
    {
#line 368
    __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  368U, "pathnode_next");
    }
  }
#line 369
  return (pn->dups);
}
}
#line 374 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
void pathnode_delete(PathNodeTree pnt , struct path_node *pn ) 
{ 


  {
#line 377
  if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
    {
#line 377
    __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c",
                  377U, "pathnode_delete");
    }
  }
#line 378
  pn->package = pkg_null;
#line 379
  return;
}
}
#line 383 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
static int pathnode_serialize(void *buf___1 , void *ptr , int count , int siz , void *arg ) 
{ 
  int i ;
  PathNodeTree pnt ;
  struct path_node *pn ;
  struct path_node *pn0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 387
  pnt = (PathNodeTree )arg;
#line 390
  memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)ptr, (size_t )(count * siz));
#line 391
  pn = (struct path_node *)buf___1;
#line 392
  pn0 = (struct path_node *)ptr;
#line 393
  i = 0;
  }
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! (i < count)) {
#line 393
      goto while_break;
    }
#line 394
    pn->pathname = (char *)((void *)0);
#line 395
    if (pn->left) {
      {
#line 395
      tmp = mempool_index(pnt->p_st, (void *)pn0->left);
#line 395
      pn->left = (struct path_node *)((void *)tmp);
      }
    }
#line 396
    if (pn->right) {
      {
#line 396
      tmp___0 = mempool_index(pnt->p_st, (void *)pn0->right);
#line 396
      pn->right = (struct path_node *)((void *)tmp___0);
      }
    }
#line 397
    if (pn->down) {
      {
#line 397
      tmp___1 = mempool_index(pnt->p_st, (void *)pn0->down);
#line 397
      pn->down = (struct path_node *)((void *)tmp___1);
      }
    }
#line 398
    if (pn->dups) {
      {
#line 398
      tmp___2 = mempool_index(pnt->p_st, (void *)pn0->dups);
#line 398
      pn->dups = (struct path_node *)((void *)tmp___2);
      }
    }
#line 399
    pn ++;
#line 399
    pn0 ++;
#line 393
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return (count * siz);
}
}
#line 405 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
static void pathnode_unserialize___0(struct mempool *mp , void *ptr , int count ,
                                     int siz , void *arg ) 
{ 
  int i ;
  struct path_node *pn ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 411
  pn = (struct path_node *)ptr;
#line 412
  i = 0;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! (i < count)) {
#line 412
      goto while_break;
    }
#line 413
    if (pn->left) {
      {
#line 413
      tmp = mempool_fetch(mp, (int )pn->left);
#line 413
      pn->left = (struct path_node *)tmp;
      }
    }
#line 414
    if (pn->right) {
      {
#line 414
      tmp___0 = mempool_fetch(mp, (int )pn->right);
#line 414
      pn->right = (struct path_node *)tmp___0;
      }
    }
#line 415
    if (pn->down) {
      {
#line 415
      tmp___1 = mempool_fetch(mp, (int )pn->down);
#line 415
      pn->down = (struct path_node *)tmp___1;
      }
    }
#line 416
    if (pn->dups) {
      {
#line 416
      tmp___2 = mempool_fetch(mp, (int )pn->dups);
#line 416
      pn->dups = (struct path_node *)tmp___2;
      }
    }
#line 417
    pn ++;
#line 412
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return;
}
}
#line 422 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
int pathnode_dump(int fd , PathNodeTree pnt , int shrink ) 
{ 
  double rl ;
  double rr ;
  int tmp ;

  {
#line 426
  if (pnt->num_left > pnt->num_right) {
#line 427
    rl = (double )pnt->num_left / (double )pnt->num_right;
#line 428
    rr = 1.0;
  } else {
#line 430
    rl = 1.0;
#line 431
    rr = (double )pnt->num_right / (double )pnt->num_left;
  }
#line 433
  if (debug) {
    {
#line 433
    printf((char const   */* __restrict  */)"pathnode: %d entries, new %d alloc, left %d entries\n   left=%d times, right=%d times  (%f:%f)\n",
           pnt->num_pn, pnt->pn_alloc, pnt->pn_avail, pnt->num_left, pnt->num_right,
           rl, rr);
    }
  }
#line 437
  if (shrink) {
    {
#line 438
    mempool_shrink(pnt->p_st, pnt->pn_avail);
#line 439
    pnt->pn_avail = 0;
    }
  }
#line 441
  if (debug) {
    {
#line 441
    printf((char const   */* __restrict  */)"pathnode: dump ");
    }
  }
  {
#line 442
  tmp = mempool_dump(pnt->p_st, fd, & pathnode_serialize, (void *)pnt);
  }
#line 442
  return (tmp);
}
}
#line 446 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pathnode.c"
PathNodeTree pathnode_restore(int fd , StrTable st , int margin ) 
{ 
  PathNodeTree pnt ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 450
  if (debug) {
    {
#line 450
    printf((char const   */* __restrict  */)"pathnode: ");
    }
  }
  {
#line 451
  tmp = malloc(sizeof(struct __pathnode_tree ));
#line 451
  pnt = (PathNodeTree )tmp;
  }
#line 452
  if ((unsigned long )pnt == (unsigned long )((void *)0)) {
#line 453
    if (debug) {
      {
#line 453
      printf((char const   */* __restrict  */)"not enough memory\n");
      }
    }
#line 454
    return ((PathNodeTree )((void *)0));
  }
  {
#line 456
  memset((void *)pnt, 0, sizeof(struct __pathnode_tree ));
#line 457
  pnt->st = st;
#line 458
  pnt->p_st = mempool_restore(fd, & pathnode_unserialize___0, (void *)pnt, margin);
  }
#line 459
  if ((unsigned long )pnt->p_st == (unsigned long )((void *)0)) {
    {
#line 460
    free((void *)pnt);
    }
#line 461
    return ((PathNodeTree )((void *)0));
  }
  {
#line 463
  pnt->top = (struct path_node *)((void *)0);
#line 464
  tmp___0 = mempool_mem_avail(pnt->p_st, margin);
#line 464
  pnt->pn_next = (struct path_node *)tmp___0;
#line 465
  pnt->pn_avail = margin;
#line 466
  tmp___1 = mempool_mem(pnt->p_st);
#line 466
  pnt->top = (struct path_node *)tmp___1;
  }
#line 467
  return (pnt);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 33 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/debug.h"
int verbose ;
#line 21 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.h"
void pkgtab_init(void) ;
#line 25 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.h"
PathNodeTree pkgcdb_alloc(void) ;
#line 30
PathNodeTree pkgcdb_load(char *dbfile , int str_margin , int pathnode_margin ) ;
#line 33
int pkgcdb_save(char *dbfile , PathNodeTree pnt , int shrink ) ;
#line 36
int pkgcdb_path_list_init(PathNodeTree pnt , char *file ) ;
#line 39
struct path_node *pkgcdb_get(PathNodeTree pnt , char *file , char **matchfile , char **ext ) ;
#line 43
struct path_node *pkgcdb_put(PathNodeTree pnt , char *file , char *pkg , int *nent ) ;
#line 48
void pkgcdb_del(PathNodeTree pnt , char *file , char *pkg , int *nent ) ;
#line 53
void pkgcdb_traverse(PathNodeTree pnt , void (*func)(PathNodeTree pnt , char *path ,
                                                     struct path_node *pn , void *arg ) ,
                     void *arg ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 23 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt-pkgcdb.c"
static int profile  =    0;
#line 25 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt-pkgcdb.c"
static char *prog  ;
#line 27 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt-pkgcdb.c"
static void delete_pathnode_entry(PathNodeTree pnt , char *path , struct path_node *pn ,
                                  void *arg ) 
{ 
  struct path_node *npn ;
  pkg_id pid ;
  pkg_id tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 32
  npn = pn;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! ((unsigned long )npn != (unsigned long )((void *)0))) {
#line 32
      goto while_break;
    }
    {
#line 33
    tmp = pathnode_package(pnt, npn);
#line 33
    pid = tmp;
#line 34
    tmp___2 = pkg_cmp(& pid, (pkg_id *)arg);
    }
#line 34
    if (tmp___2 == 0) {
#line 35
      if (! quiet) {
        {
#line 35
        tmp___0 = pathnode_packagename(pnt, npn);
#line 35
        tmp___1 = pathnode_pathname(pnt, pn);
#line 35
        printf((char const   */* __restrict  */)"%s%s\t%s\n", path, tmp___1, tmp___0);
        }
      }
      {
#line 38
      pathnode_delete(pnt, npn);
      }
    }
    {
#line 32
    npn = pathnode_next(pnt, npn);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 43 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt-pkgcdb.c"
static void print_pathnode_entry(PathNodeTree pnt , char *path , struct path_node *pn ,
                                 void *arg ) 
{ 
  struct path_node *npn ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 48
  tmp = pathnode_pathname(pnt, pn);
#line 48
  printf((char const   */* __restrict  */)"%s%s\t", path, tmp);
#line 49
  npn = pn;
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! ((unsigned long )npn != (unsigned long )((void *)0))) {
#line 49
      goto while_break;
    }
#line 50
    if ((unsigned long )npn != (unsigned long )pn) {
      {
#line 51
      printf((char const   */* __restrict  */)",");
      }
    }
    {
#line 53
    tmp___0 = pathnode_packagename(pnt, npn);
#line 53
    printf((char const   */* __restrict  */)"%s", tmp___0);
#line 49
    npn = pathnode_next(pnt, npn);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  printf((char const   */* __restrict  */)"\n");
  }
#line 56
  return;
}
}
#line 59 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt-pkgcdb.c"
static void usage(void) 
{ 


  {
  {
#line 62
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [option] [command ...]\ncommand:\n\tput\n\tget filename\n\tlist\n\tdel package\noption:\n\t-v\tverbose\n\t-q\tquiet\n\t-p\tprofile\n\t-d\tdebug\n\t-f dbfile\n\t-P paths.list\n",
          prog);
#line 76
  exit(0);
  }
}
}
#line 79 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt-pkgcdb.c"
static int timer_start(struct timeval *tvp ) 
{ 
  struct timezone tz ;
  int tmp ;

  {
  {
#line 83
  tmp = gettimeofday((struct timeval */* __restrict  */)tvp, (__timezone_ptr_t )(& tz));
  }
#line 83
  return (tmp);
}
}
#line 86 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt-pkgcdb.c"
static double timer_stop(struct timeval *tvp ) 
{ 
  struct timeval tv1 ;
  struct timezone tz ;
  double t ;

  {
  {
#line 93
  gettimeofday((struct timeval */* __restrict  */)(& tv1), (__timezone_ptr_t )(& tz));
  }
#line 94
  if (tvp->tv_usec > tv1.tv_usec) {
#line 95
    (tv1.tv_sec) --;
#line 96
    tv1.tv_usec += 1000000L;
  }
#line 98
  tv1.tv_sec -= tvp->tv_sec;
#line 99
  tv1.tv_usec -= tvp->tv_usec;
#line 100
  t = (double )tv1.tv_sec + (double )tv1.tv_usec / 1000000.0;
#line 100
  return (t);
}
}
#line 103 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt-pkgcdb.c"
static int validchartab[256]  = 
#line 103
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      1,      0,      1, 
        1,      1,      0,      0, 
        0,      0,      0,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      0, 
        0,      1,      0,      0, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      0, 
        0,      0,      1,      1, 
        0,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      0, 
        0,      0,      1,      0, 
        0};
#line 115 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt-pkgcdb.c"
static int is_validchar(int c ) 
{ 


  {
#line 118
  return (validchartab[c & 255]);
}
}
#line 121 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt-pkgcdb.c"
static unsigned char *get_line(FILE *f ) 
{ 
  unsigned char *buf___1 ;
  char *new_buf ;
  size_t buf_size ;
  size_t last ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 124
  buf___1 = (unsigned char *)((void *)0);
#line 125
  new_buf = (char *)((void *)0);
#line 126
  buf_size = (size_t )0;
#line 127
  last = (size_t )0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp___1 = feof(f);
    }
#line 129
    if (tmp___1) {
#line 129
      goto while_break;
    }
#line 130
    if (buf_size) {
#line 130
      buf_size *= 2UL;
    } else {
#line 130
      buf_size = (size_t )8192;
    }
    {
#line 131
    tmp = realloc((void *)buf___1, buf_size);
#line 131
    new_buf = (char *)tmp;
    }
#line 132
    if ((unsigned long )new_buf == (unsigned long )((void *)0)) {
      {
#line 133
      free((void *)buf___1);
      }
#line 134
      return ((unsigned char *)((void *)0));
    }
    {
#line 136
    buf___1 = (unsigned char *)new_buf;
#line 137
    tmp___0 = fgets((char */* __restrict  */)(buf___1 + last), (int )(buf_size - last),
                    (FILE */* __restrict  */)f);
    }
#line 137
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 138
      free((void *)buf___1);
      }
#line 139
      return ((unsigned char *)((void *)0));
    }
    {
#line 141
    last = strlen((char const   *)buf___1);
    }
#line 142
    if ((int )*(buf___1 + (last - 1UL)) == 10) {
#line 143
      return (buf___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return (buf___1);
}
}
#line 148 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/auto-apt-pkgcdb.c"
int main(int argc , char **argv ) 
{ 
  unsigned char *buf___1 ;
  char *cmd ;
  char *dbfile ;
  char *pathlist ;
  int ret ;
  int c ;
  char *p ;
  PathNodeTree pnt ;
  struct timeval tv ;
  int n ;
  int nent ;
  int op ;
  time_t t0 ;
  time_t t1 ;
  time_t t ;
  double tt ;
  double ta ;
  double min_t ;
  double max_t ;
  char *max_file ;
  double tmp ;
  double tmp___0 ;
  unsigned char *fname ;
  unsigned char *pkg ;
  unsigned char *p___0 ;
  int nslash ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  double tmp___11 ;
  struct path_node *match ;
  char *key ;
  char *mfile ;
  char *ext ;
  double tmp___12 ;
  double tmp___13 ;
  struct path_node *pn ;
  int found ;
  char *tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  double tmp___17 ;
  char *package___0 ;
  pkg_id delpkg ;
  StrTable tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  {
#line 151
  buf___1 = (unsigned char *)((void *)0);
#line 153
  dbfile = (char *)"/var/cache/auto-apt/pkgcontents.bin";
#line 154
  pathlist = (char *)"/etc/auto-apt/paths.list";
#line 155
  ret = 0;
#line 163
  prog = *(argv + 0);
#line 165
  p = getenv("AUTO_APT_DB");
  }
#line 166
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 166
    if ((int )*p == 47) {
      {
#line 167
      dbfile = strdup((char const   *)p);
      }
    }
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 169
    c = getopt(argc, (char * const  *)argv, "dvpqf:P:");
    }
#line 169
    if (! (c != -1)) {
#line 169
      goto while_break;
    }
    {
#line 171
    if (c == 118) {
#line 171
      goto case_118;
    }
#line 172
    if (c == 112) {
#line 172
      goto case_112;
    }
#line 173
    if (c == 113) {
#line 173
      goto case_113;
    }
#line 174
    if (c == 100) {
#line 174
      goto case_100;
    }
#line 175
    if (c == 102) {
#line 175
      goto case_102;
    }
#line 176
    if (c == 80) {
#line 176
      goto case_80;
    }
#line 177
    goto switch_default;
    case_118: /* CIL Label */ 
#line 171
    verbose ++;
#line 171
    goto switch_break;
    case_112: /* CIL Label */ 
#line 172
    profile ++;
#line 172
    goto switch_break;
    case_113: /* CIL Label */ 
#line 173
    quiet ++;
#line 173
    goto switch_break;
    case_100: /* CIL Label */ 
#line 174
    debug ++;
#line 174
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 175
    dbfile = strdup((char const   *)optarg);
    }
#line 175
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 176
    pathlist = strdup((char const   *)optarg);
    }
#line 176
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 178
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  if (argc < optind + 1) {
    {
#line 182
    usage();
    }
  }
  {
#line 184
  cmd = *(argv + optind);
#line 186
  mempool_init();
#line 187
  pkgtab_init();
#line 189
  tmp___22 = strcmp((char const   *)cmd, "put");
  }
#line 189
  if (tmp___22 == 0) {
    {
#line 190
    n = 0;
#line 190
    nent = 0;
#line 191
    op = '+';
#line 196
    t = time((time_t *)((void *)0));
#line 196
    t0 = t;
#line 196
    t1 = t0;
#line 197
    t0 --;
    }
#line 198
    if (profile) {
      {
#line 199
      timer_start(& tv);
      }
    }
    {
#line 200
    pnt = pkgcdb_load(dbfile, 0, 0);
    }
#line 201
    if ((unsigned long )pnt == (unsigned long )((void *)0)) {
      {
#line 202
      pnt = pkgcdb_alloc();
      }
#line 203
      if ((unsigned long )pnt == (unsigned long )((void *)0)) {
#line 204
        if (! quiet) {
          {
#line 204
          perror("pkgcdb_init");
          }
        }
        {
#line 205
        exit(1);
        }
      }
    }
#line 208
    if (profile) {
#line 209
      if (! quiet) {
        {
#line 209
        tmp = timer_stop(& tv);
#line 209
        printf((char const   */* __restrict  */)"db load: %f sec\n", tmp);
        }
      }
    }
#line 210
    if (profile) {
      {
#line 211
      timer_start(& tv);
      }
    }
    {
#line 212
    pkgcdb_path_list_init(pnt, pathlist);
#line 213
    pathnode_ignore_package(pnt, (char *)"*");
    }
#line 214
    if (profile) {
#line 215
      if (! quiet) {
        {
#line 215
        tmp___0 = timer_stop(& tv);
#line 215
        printf((char const   */* __restrict  */)"path init: %f sec\n", tmp___0);
        }
      }
    }
#line 217
    ta = 0.0;
#line 218
    min_t = 9999.9;
#line 218
    max_t = 0.0;
#line 219
    max_file = (char *)((void *)0);
    {
#line 220
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 220
      tmp___10 = feof(stdin);
      }
#line 220
      if (tmp___10) {
#line 220
        goto while_break___0;
      }
      {
#line 223
      nslash = 0;
#line 225
      buf___1 = get_line(stdin);
      }
#line 226
      if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 227
        goto while_break___0;
      }
#line 228
      if (profile) {
        {
#line 229
        timer_start(& tv);
        }
      }
      {
#line 230
      tmp___2 = strlen((char const   *)buf___1);
      }
#line 230
      if ((int )*(buf___1 + (tmp___2 - 1UL)) == 10) {
        {
#line 231
        tmp___1 = strlen((char const   *)buf___1);
#line 231
        *(buf___1 + (tmp___1 - 1UL)) = (unsigned char )'\000';
        }
      }
#line 233
      if (debug) {
        {
#line 233
        printf((char const   */* __restrict  */)">%s<\n", buf___1);
        }
      }
#line 234
      fname = buf___1;
      {
#line 236
      if ((int )*(fname + 0) == 32) {
#line 236
        goto case_32;
      }
#line 237
      if ((int )*(fname + 0) == 45) {
#line 237
        goto case_45;
      }
#line 238
      if ((int )*(fname + 0) == 43) {
#line 238
        goto case_43;
      }
#line 239
      goto switch_default___0;
      case_32: /* CIL Label */ 
#line 236
      goto next_line;
#line 236
      goto switch_break___0;
      case_45: /* CIL Label */ 
#line 237
      op = (int )*(fname + 0);
#line 237
      fname ++;
#line 237
      goto switch_break___0;
      case_43: /* CIL Label */ 
#line 238
      op = (int )*(fname + 0);
#line 238
      fname ++;
#line 238
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 239
      op = '+';
#line 239
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 241
      tmp___3 = strncmp((char const   *)fname, "./", (size_t )2);
      }
#line 241
      if (tmp___3 == 0) {
#line 242
        fname += 2;
      }
      {
#line 245
      tmp___4 = strlen((char const   *)fname);
#line 245
      pkg = (fname + tmp___4) - 1;
      }
      {
#line 245
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 245
        tmp___6 = __ctype_b_loc();
        }
#line 245
        if ((int const   )*(*tmp___6 + (int )*pkg) & 8192) {
#line 245
          goto while_break___1;
        } else
#line 245
        if (! ((unsigned long )pkg > (unsigned long )fname)) {
#line 245
          goto while_break___1;
        }
#line 248
        if ((int )*pkg == 47) {
#line 249
          nslash ++;
#line 250
          if (nslash >= 3) {
#line 251
            if (! quiet) {
#line 251
              if (verbose) {
                {
#line 251
                printf((char const   */* __restrict  */)"too many /: %s\n", buf___1);
                }
              }
            }
#line 252
            goto next_line;
          }
        } else
#line 254
        if ((int )*pkg == 44) {
#line 255
          nslash = 0;
        } else {
          {
#line 256
          tmp___5 = is_validchar((int )*pkg);
          }
#line 256
          if (! tmp___5) {
#line 257
            if (! quiet) {
#line 257
              if (verbose) {
                {
#line 257
                printf((char const   */* __restrict  */)"invalid line: %s\n", buf___1);
                }
              }
            }
#line 258
            goto next_line;
          }
        }
#line 245
        pkg --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 261
      tmp___7 = __ctype_b_loc();
      }
#line 261
      if ((int const   )*(*tmp___7 + (int )*pkg) & 8192) {
#line 262
        pkg ++;
      }
#line 264
      p___0 = pkg - 1;
      {
#line 264
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 264
        tmp___8 = __ctype_b_loc();
        }
#line 264
        if ((int const   )*(*tmp___8 + (int )*p___0) & 8192) {
#line 264
          if (! ((unsigned long )p___0 > (unsigned long )fname)) {
#line 264
            goto while_break___2;
          }
        } else {
#line 264
          goto while_break___2;
        }
#line 265
        *p___0 = (unsigned char )'\000';
#line 264
        p___0 --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 267
      p___0 = fname;
      {
#line 267
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 267
        if (! *p___0) {
#line 267
          goto while_break___3;
        }
        {
#line 268
        tmp___9 = is_validchar((int )*p___0);
        }
#line 268
        if (! tmp___9) {
#line 269
          if (! quiet) {
#line 269
            if (verbose) {
              {
#line 269
              printf((char const   */* __restrict  */)"invalid fname: %s\n", buf___1);
              }
            }
          }
#line 270
          goto next_line;
        }
#line 267
        p___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 274
      if (debug) {
        {
#line 274
        printf((char const   */* __restrict  */)"I: file=[%s] pkg=[%s]\n", fname,
               pkg);
        }
      }
      {
#line 275
      t1 = time((time_t *)((void *)0));
      }
      {
#line 277
      if (op == 43) {
#line 277
        goto case_43___0;
      }
#line 286
      if (op == 45) {
#line 286
        goto case_45___0;
      }
#line 276
      goto switch_break___1;
      case_43___0: /* CIL Label */ 
      {
#line 278
      pkgcdb_put(pnt, (char *)fname, (char *)pkg, & nent);
#line 279
      n ++;
      }
#line 280
      if (t1 > t0) {
#line 281
        if (! quiet) {
          {
#line 281
          printf((char const   */* __restrict  */)"put: %d files,  %d entries\r",
                 n, nent);
          }
        }
        {
#line 282
        fflush(stdout);
#line 283
        t0 = t1;
        }
      }
#line 285
      goto switch_break___1;
      case_45___0: /* CIL Label */ 
      {
#line 287
      pkgcdb_del(pnt, (char *)fname, (char *)pkg, & nent);
#line 288
      n ++;
      }
#line 289
      if (t1 > t0) {
#line 290
        if (! quiet) {
          {
#line 290
          printf((char const   */* __restrict  */)"put: %d files,  %d entries\r",
                 n, nent);
          }
        }
        {
#line 291
        fflush(stdout);
#line 292
        t0 = t1;
        }
      }
#line 294
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 296
      if (profile) {
        {
#line 297
        tt = timer_stop(& tv);
#line 298
        ta += tt;
        }
#line 299
        if (tt < min_t) {
#line 300
          min_t = tt;
        }
#line 301
        if (tt > max_t) {
#line 302
          max_t = tt;
#line 303
          if (max_file) {
            {
#line 304
            free((void *)max_file);
            }
          }
          {
#line 305
          max_file = strdup((char const   *)fname);
          }
        }
      }
      next_line: 
      {
#line 310
      free((void *)buf___1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 312
    if (profile) {
#line 313
      if (! quiet) {
        {
#line 313
        printf((char const   */* __restrict  */)"total %f sec/%d = avg %f sec\n     min = %f, max = %f<%s>\n",
               ta, n, ta / (double )n, min_t, max_t, max_file);
        }
      }
    }
#line 316
    if (profile) {
      {
#line 317
      timer_start(& tv);
      }
    }
    {
#line 318
    pkgcdb_save(dbfile, pnt, 1);
    }
#line 319
    if (profile) {
#line 320
      if (! quiet) {
        {
#line 320
        tmp___11 = timer_stop(& tv);
#line 320
        printf((char const   */* __restrict  */)"db save: %f sec\n", tmp___11);
        }
      }
    }
    {
#line 321
    t1 = time((time_t *)((void *)0));
    }
#line 322
    if (! quiet) {
      {
#line 322
      printf((char const   */* __restrict  */)"put: %d files,  %d entries done (%ld sec)\n",
             n, nent, t1 - t);
      }
    }
  } else {
    {
#line 324
    tmp___21 = strcmp((char const   *)cmd, "get");
    }
#line 324
    if (tmp___21 == 0) {
#line 326
      mfile = (char *)((void *)0);
#line 326
      ext = (char *)((void *)0);
#line 327
      if (argc < optind + 2) {
        {
#line 328
        usage();
        }
      }
#line 330
      key = *(argv + (optind + 1));
#line 331
      if (profile) {
        {
#line 332
        timer_start(& tv);
        }
      }
      {
#line 333
      pnt = pkgcdb_load(dbfile, 0, 0);
      }
#line 334
      if ((unsigned long )pnt == (unsigned long )((void *)0)) {
#line 335
        if (! quiet) {
          {
#line 335
          perror("pkgcdb_load");
          }
        }
        {
#line 336
        exit(1);
        }
      }
#line 338
      if (profile) {
#line 339
        if (! quiet) {
          {
#line 339
          tmp___12 = timer_stop(& tv);
#line 339
          printf((char const   */* __restrict  */)"db load: %f sec\n", tmp___12);
          }
        }
      }
#line 340
      if (profile) {
        {
#line 341
        timer_start(& tv);
        }
      }
      {
#line 342
      match = pkgcdb_get(pnt, key, & mfile, & ext);
      }
#line 343
      if (profile) {
#line 344
        if (! quiet) {
          {
#line 344
          tmp___13 = timer_stop(& tv);
#line 344
          printf((char const   */* __restrict  */)"db search: %f sec\n", tmp___13);
          }
        }
      }
#line 345
      if (profile) {
        {
#line 346
        timer_start(& tv);
        }
      }
#line 347
      if (match) {
#line 349
        found = 0;
#line 350
        pn = match;
        {
#line 350
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 350
          if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
#line 350
            goto while_break___4;
          }
#line 351
          if ((unsigned long )pn != (unsigned long )match) {
            {
#line 352
            printf((char const   */* __restrict  */)",");
            }
          }
          {
#line 353
          tmp___14 = pathnode_packagename(pnt, pn);
#line 353
          printf((char const   */* __restrict  */)"%s", tmp___14);
#line 354
          tmp___15 = pathnode_packagename(pnt, pn);
#line 354
          tmp___16 = strlen((char const   *)tmp___15);
          }
#line 354
          if (tmp___16 > 0UL) {
#line 355
            found = 1;
          }
          {
#line 350
          pn = pathnode_next(pnt, pn);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 358
        if (found) {
          {
#line 359
          printf((char const   */* __restrict  */)"\n");
          }
        }
#line 360
        if (mfile) {
#line 361
          if (! quiet) {
#line 361
            if (verbose) {
              {
#line 361
              printf((char const   */* __restrict  */)"%s\n", mfile);
              }
            }
          }
        }
#line 363
        if (ext) {
#line 364
          if (! quiet) {
#line 364
            if (verbose) {
              {
#line 364
              printf((char const   */* __restrict  */)"%s\n", ext);
              }
            }
          }
          {
#line 365
          free((void *)ext);
          }
        }
#line 367
        if (found == 0) {
#line 368
          ret = 1;
        }
      } else {
#line 370
        ret = 1;
      }
#line 372
      if (profile) {
#line 373
        if (! quiet) {
          {
#line 373
          tmp___17 = timer_stop(& tv);
#line 373
          printf((char const   */* __restrict  */)"output: %f sec\n", tmp___17);
          }
        }
      }
    } else {
      {
#line 374
      tmp___20 = strcmp((char const   *)cmd, "del");
      }
#line 374
      if (tmp___20 == 0) {
#line 378
        if (argc < optind + 2) {
          {
#line 379
          usage();
          }
        }
        {
#line 381
        package___0 = *(argv + (optind + 1));
#line 382
        pnt = pkgcdb_load(dbfile, 0, 0);
        }
#line 383
        if ((unsigned long )pnt == (unsigned long )((void *)0)) {
#line 384
          if (! quiet) {
            {
#line 384
            perror("pkgcdb_load");
            }
          }
          {
#line 385
          exit(1);
          }
        }
        {
#line 387
        tmp___18 = pathnode_strtab(pnt);
#line 387
        delpkg = pkg_intern(tmp___18, package___0);
#line 388
        pkgcdb_traverse(pnt, & delete_pathnode_entry, (void *)(& delpkg));
#line 389
        pkgcdb_save(dbfile, pnt, 1);
        }
      } else {
        {
#line 390
        tmp___19 = strcmp((char const   *)cmd, "list");
        }
#line 390
        if (tmp___19 == 0) {
          {
#line 391
          pnt = pkgcdb_load(dbfile, 0, 0);
          }
#line 392
          if ((unsigned long )pnt == (unsigned long )((void *)0)) {
#line 393
            if (! quiet) {
              {
#line 393
              perror("pkgcdb_load");
              }
            }
            {
#line 394
            exit(1);
            }
          }
          {
#line 396
          pkgcdb_traverse(pnt, & print_pathnode_entry, (void *)0);
          }
        } else {
          {
#line 398
          usage();
          }
        }
      }
    }
  }
  {
#line 400
  exit(ret);
  }
}
}
#line 19 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.h"
pkg_id pkg_null  ;
#line 23
void pkg_init(pkg_id *pid ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 19 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c"
static int inited___1  =    0;
#line 16 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c"
void pkgtab_init(void) 
{ 
  int i ;

  {
#line 21
  if (inited___1) {
#line 22
    return;
  }
#line 23
  inited___1 = 1;
#line 24
  i = 0;
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if (! (i < 3)) {
#line 24
      goto while_break;
    }
#line 25
    pkg_null.s[i] = 0;
#line 24
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  return;
}
}
#line 29 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c"
void pkg_init(pkg_id *pid ) 
{ 


  {
#line 32
  if (! ((unsigned long )pid != (unsigned long )((void *)0))) {
    {
#line 32
    __assert_fail("pid != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c",
                  32U, "pkg_init");
    }
  }
  {
#line 33
  memcpy((void */* __restrict  */)pid, (void const   */* __restrict  */)(& pkg_null),
         sizeof(pkg_id ));
  }
#line 34
  return;
}
}
#line 38 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c"
pkg_id pkg_intern(StrTable st , char *pkg ) 
{ 
  char *p ;
  char *buf___1 ;
  int i ;
  pkg_id pkgid ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 42
  buf___1 = (char *)((void *)0);
#line 43
  i = 0;
#line 46
  memset((void *)(& pkgid), 0, sizeof(pkgid));
#line 48
  p = pkg;
  }
#line 49
  if ((int )*p == 64) {
    {
#line 51
    tmp = strlen((char const   *)p);
#line 51
    p += tmp;
    }
#line 52
    goto done;
  }
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ((int )*p != 0)) {
#line 55
      goto while_break;
    }
#line 56
    if ((int )*p != 47) {
#line 57
      p ++;
#line 58
      goto while_continue;
    } else
#line 56
    if (p - pkg <= 1L) {
#line 57
      p ++;
#line 58
      goto while_continue;
    }
    {
#line 60
    p ++;
#line 61
    tmp___0 = (int )malloc((p - pkg) + 1L);
#line 61
    buf___1 = (char *)tmp___0;
    }
#line 62
    if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
      {
#line 63
      abort();
      }
    }
    {
#line 65
    strncpy((char */* __restrict  */)buf___1, (char const   */* __restrict  */)pkg,
            (size_t )(p - pkg));
#line 66
    *(buf___1 + (p - pkg)) = (char )'\000';
#line 67
    pkgid.s[i] = str_intern(st, buf___1, 1);
#line 68
    free(buf___1);
#line 69
    i ++;
#line 70
    pkg = p;
    }
#line 71
    if (! (i < 3)) {
      {
#line 71
      __assert_fail("i < 3", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c",
                    71U, "pkg_intern");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 74
  if (p - pkg >= 1L) {
    {
#line 75
    pkgid.s[i] = str_intern(st, pkg, 1);
    }
  }
#line 77
  return (pkgid);
}
}
#line 87 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c"
static char *buf___0  ;
#line 81 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c"
char *pkg_symbol(StrTable st , pkg_id pid ) 
{ 
  int len ;
  int i ;
  char *p[3] ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 84
  len = 0;
#line 86
  p[0] = (char *)((void *)0);
#line 86
  p[1] = (char *)((void *)0);
#line 86
  p[2] = (char *)((void *)0);
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < 3)) {
#line 89
      goto while_break;
    }
#line 90
    if (pid.s[i] == 0) {
#line 91
      goto while_break;
    }
    {
#line 93
    p[i] = str_symbol(st, pid.s[i]);
#line 94
    tmp = strlen((char const   *)p[i]);
#line 94
    len = (int )((size_t )len + tmp);
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  if ((unsigned long )buf___0 != (unsigned long )((void *)0)) {
    {
#line 97
    free(buf___0);
    }
  }
  {
#line 99
  tmp___0 = (int )malloc(len + 1);
#line 99
  buf___0 = (char *)tmp___0;
  }
#line 100
  if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
    {
#line 101
    abort();
    }
  }
#line 103
  *(buf___0 + 0) = (char )'\000';
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! (i < 3)) {
#line 104
      goto while_break___0;
    }
#line 105
    if (p[i]) {
      {
#line 106
      strcat((char */* __restrict  */)buf___0, (char const   */* __restrict  */)p[i]);
      }
    } else {
#line 108
      goto while_break___0;
    }
#line 104
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 111
  return (buf___0);
}
}
#line 115 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgtab.c"
int pkg_cmp(pkg_id *p0 , pkg_id *p1 ) 
{ 
  int tmp ;

  {
  {
#line 118
  tmp = memcmp((void const   *)p0, (void const   *)p1, sizeof(pkg_id ));
  }
#line 118
  return (tmp);
}
}
#line 20 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.h"
StrTable strtab_alloc(void) ;
#line 23
void strtab_release(StrTable st ) ;
#line 31
int strtab_dump(int fd , StrTable st , int shrink ) ;
#line 33
StrTable strtab_restore(int fd , int str_margin ) ;
#line 40 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
static int str_hash___0(char *s ) ;
#line 41
static str_id str_add___0(StrTable st , char *s , str_id s_next ) ;
#line 42
static struct str_entry *str_get___0(StrTable st , str_id sid ) ;
#line 44 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
static int str_hash___0(char *s ) 
{ 
  int *p ;
  char *ss ;
  int i ;
  int n ;
  int l ;
  register int h ;
  char buf___1[sizeof(int )] ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 50
  h = 0;
#line 53
  tmp = strlen((char const   *)s);
#line 53
  l = (int )tmp;
#line 54
  tmp___0 = __builtin_alloca((unsigned long )(l + 1));
#line 54
  ss = (char *)tmp___0;
#line 55
  strcpy((char */* __restrict  */)ss, (char const   */* __restrict  */)s);
#line 56
  n = (int )((unsigned long )l / sizeof(int ));
#line 57
  p = (int *)ss;
#line 58
  i = 0;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < n)) {
#line 58
      goto while_break;
    }
#line 59
    tmp___1 = p;
#line 59
    p ++;
#line 59
    h ^= *tmp___1;
#line 58
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  n = (int )((unsigned long )l - (unsigned long )n * sizeof(int ));
#line 62
  if (n != 0) {
    {
#line 63
    memset((void *)(buf___1), 0, sizeof(buf___1));
#line 64
    strncpy((char */* __restrict  */)(buf___1 + n), (char const   */* __restrict  */)((char *)p),
            (size_t )(4 - n));
#line 65
    p = (int *)(buf___1);
#line 66
    h ^= *p;
    }
  }
#line 68
  return (h % 16381);
}
}
#line 71 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
static str_id str_add___0(StrTable st , char *s , str_id s_next ) 
{ 
  int len ;
  struct str_entry *se ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 76
  if (! ((unsigned long )st != (unsigned long )((void *)0))) {
    {
#line 76
    __assert_fail("st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c",
                  76U, "str_add");
    }
  }
#line 77
  if (! ((unsigned long )s != (unsigned long )((void *)0))) {
    {
#line 77
    __assert_fail("s != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c",
                  77U, "str_add");
    }
  }
  {
#line 79
  tmp = strlen((char const   *)s);
#line 79
  len = (int )((((sizeof(str_id ) + tmp) + 1UL) + 3UL) & 0xfffffffffffffffcUL);
  }
#line 80
  if ((unsigned long )st->st_next == (unsigned long )((void *)0)) {
    {
#line 81
    st->s_st = mempool_alloc(st->s_st, 40960, (size_t )1);
#line 82
    st->str_avail = 40960;
#line 83
    tmp___0 = mempool_mem(st->s_st);
#line 83
    st->st_next = (struct str_entry *)tmp___0;
#line 84
    st->str_alloc += 40960;
    }
  } else
#line 80
  if (st->str_avail <= len) {
    {
#line 81
    st->s_st = mempool_alloc(st->s_st, 40960, (size_t )1);
#line 82
    st->str_avail = 40960;
#line 83
    tmp___0 = mempool_mem(st->s_st);
#line 83
    st->st_next = (struct str_entry *)tmp___0;
#line 84
    st->str_alloc += 40960;
    }
  }
  {
#line 86
  se = st->st_next;
#line 87
  se->s_next = s_next;
#line 88
  strcpy((char */* __restrict  */)(se->data), (char const   */* __restrict  */)s);
#line 89
  st->st_next = (struct str_entry *)((char *)se + len);
#line 90
  st->str_avail -= len;
#line 91
  (st->num_str) ++;
#line 92
  tmp___1 = mempool_index(st->s_st, (void *)se);
  }
#line 92
  return (tmp___1);
}
}
#line 95 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
static struct str_entry *str_get___0(StrTable st , str_id sid ) 
{ 
  struct str_entry *se ;
  void *tmp ;

  {
#line 99
  if (! ((unsigned long )st != (unsigned long )((void *)0))) {
    {
#line 99
    __assert_fail("st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c",
                  99U, "str_get");
    }
  }
  {
#line 101
  tmp = mempool_fetch(st->s_st, sid);
#line 101
  se = (struct str_entry *)tmp;
  }
#line 102
  return (se);
}
}
#line 106 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
StrTable strtab_alloc(void) 
{ 
  int i ;
  StrTable st ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 112
  tmp = malloc(sizeof(struct __strtab ));
#line 112
  st = (StrTable )tmp;
  }
#line 113
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 114
    return ((StrTable )((void *)0));
  }
  {
#line 115
  memset((void *)st, 0, sizeof(struct __strtab ));
#line 117
  st->num_str = 0;
#line 118
  i = 0;
  }
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i < 16381)) {
#line 118
      goto while_break;
    }
#line 119
    st->hashtab[i] = 0;
#line 118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  st->s_st = mempool_alloc((struct mempool *)((void *)0), 40960, (size_t )1);
#line 122
  tmp___0 = mempool_mem(st->s_st);
#line 122
  st->st_next = (struct str_entry *)tmp___0;
#line 123
  st->str_avail = 40960;
#line 124
  st->str_alloc = 40960;
#line 126
  str_add___0(st, (char *)"", 0);
  }
#line 127
  return (st);
}
}
#line 132 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
void strtab_release(StrTable st ) 
{ 


  {
#line 135
  if (! ((unsigned long )st != (unsigned long )((void *)0))) {
    {
#line 135
    __assert_fail("st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c",
                  135U, "strtab_release");
    }
  }
#line 136
  if (! ((unsigned long )st->s_st != (unsigned long )((void *)0))) {
    {
#line 136
    __assert_fail("st->s_st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c",
                  136U, "strtab_release");
    }
  }
  {
#line 137
  mempool_release(st->s_st);
#line 138
  st->s_st = (struct mempool *)((void *)0);
#line 139
  st->st_next = (struct str_entry *)((void *)0);
#line 140
  st->str_avail = 0;
#line 141
  st->str_alloc = 0;
#line 142
  free((void *)st);
  }
#line 143
  return;
}
}
#line 146 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
str_id str_intern(StrTable st , char *string , int add ) 
{ 
  int h ;
  str_id sid ;
  struct str_entry *se ;
  int depth ;
  int tmp ;

  {
#line 152
  if (! ((unsigned long )st != (unsigned long )((void *)0))) {
    {
#line 152
    __assert_fail("st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c",
                  152U, "str_intern");
    }
  }
#line 153
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 154
    return (0);
  } else
#line 153
  if ((int )*(string + 0) == 0) {
#line 154
    return (0);
  }
  {
#line 157
  h = str_hash___0(string);
  }
#line 158
  if (st->hashtab[h] != 0) {
    {
#line 160
    depth = 0;
#line 161
    sid = st->hashtab[h];
#line 161
    se = str_get___0(st, sid);
    }
    {
#line 161
    while (1) {
      while_continue: /* CIL Label */ ;
#line 161
      if ((unsigned long )se != (unsigned long )((void *)0)) {
#line 161
        if (! (sid != 0)) {
#line 161
          goto while_break;
        }
      } else {
#line 161
        goto while_break;
      }
      {
#line 164
      depth ++;
#line 165
      tmp = strcmp((char const   *)(se->data), (char const   *)string);
      }
#line 165
      if (tmp == 0) {
#line 166
        if (st->num_max_depth < depth) {
#line 167
          st->num_max_depth = depth;
        }
#line 169
        return (sid);
      }
      {
#line 161
      sid = se->s_next;
#line 161
      se = str_get___0(st, sid);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 172
    if (add) {
#line 173
      (st->num_conflicts) ++;
    }
  } else
#line 175
  if (add) {
#line 176
    (st->num_hash) ++;
  }
#line 178
  if (! add) {
#line 179
    return (0);
  }
  {
#line 181
  sid = str_add___0(st, string, st->hashtab[h]);
#line 182
  st->hashtab[h] = sid;
  }
#line 183
  return (sid);
}
}
#line 186 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
char *str_symbol(StrTable st , str_id sid ) 
{ 
  struct str_entry *se ;

  {
#line 190
  if (! ((unsigned long )st != (unsigned long )((void *)0))) {
    {
#line 190
    __assert_fail("st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c",
                  190U, "str_symbol");
    }
  }
  {
#line 192
  se = str_get___0(st, sid);
  }
#line 193
  if ((unsigned long )se == (unsigned long )((void *)0)) {
#line 194
    return ((char *)"");
  }
#line 196
  return (se->data);
}
}
#line 201 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
int strtab_dump(int fd , StrTable st , int shrink ) 
{ 
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 204
  if (debug) {
    {
#line 204
    printf((char const   */* __restrict  */)"strtab: %d strings, new %d alloc, %d bytes left\n  hash %d used (%3.1f%%), %d conflicts, %d depth\n",
           st->num_str, st->str_alloc, st->str_avail, st->num_hash, ((double )st->num_hash * 100.0) / (double )16381,
           st->num_conflicts, st->num_max_depth);
    }
  }
#line 209
  if (shrink) {
    {
#line 210
    mempool_shrink(st->s_st, st->str_avail);
#line 211
    st->str_avail = 0;
    }
  }
  {
#line 213
  tmp = write(fd, (void const   *)(st->hashtab), 16381UL * sizeof(str_id ));
  }
#line 213
  if (tmp < 1L) {
#line 214
    return (-1);
  }
#line 216
  if (debug) {
    {
#line 216
    printf((char const   */* __restrict  */)"strtab: dump ");
    }
  }
  {
#line 217
  tmp___0 = mempool_dump(st->s_st, fd, (int (*)(void *buf , void *ptr , int count ,
                                                int siz , void *arg ))((void *)0),
                         (void *)0);
  }
#line 217
  return (tmp___0);
}
}
#line 222 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/strtab.c"
StrTable strtab_restore(int fd , int str_margin ) 
{ 
  StrTable st ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 226
  if (debug) {
    {
#line 226
    printf((char const   */* __restrict  */)"strtab: restore ");
    }
  }
  {
#line 227
  tmp = malloc(sizeof(struct __strtab ));
#line 227
  st = (StrTable )tmp;
  }
#line 228
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 229
    if (! quiet) {
      {
#line 229
      printf((char const   */* __restrict  */)"not enough memory");
      }
    }
#line 230
    return ((StrTable )((void *)0));
  }
#line 232
  if (debug) {
    {
#line 232
    printf((char const   */* __restrict  */)"hash %d ", 16381);
    }
  }
  {
#line 233
  memset((void *)st, 0, sizeof(struct __strtab ));
#line 234
  tmp___0 = read_data(fd, (void *)(st->hashtab), (int )(16381UL * sizeof(str_id )));
  }
#line 234
  if (tmp___0 < 1) {
#line 235
    return ((StrTable )((void *)0));
  }
#line 237
  if (debug) {
    {
#line 237
    printf((char const   */* __restrict  */)"done\n");
    }
  }
#line 238
  if (debug) {
    {
#line 238
    printf((char const   */* __restrict  */)" symtab:");
    }
  }
  {
#line 239
  st->s_st = mempool_restore(fd, (void (*)(struct mempool *mp , void *ptr , int count ,
                                           int siz , void *arg ))((void *)0), (void *)0,
                             str_margin);
  }
#line 240
  if ((unsigned long )st->s_st == (unsigned long )((void *)0)) {
    {
#line 241
    free((void *)st);
    }
#line 242
    return ((StrTable )((void *)0));
  }
  {
#line 244
  tmp___1 = mempool_mem_avail(st->s_st, str_margin);
#line 244
  st->st_next = (struct str_entry *)tmp___1;
#line 245
  st->str_avail = str_margin;
  }
#line 246
  return (st);
}
}
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 28 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.h"
void pkgcdb_release(PathNodeTree pnt ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 29 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
int debug  =    0;
#line 31 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
int verbose  =    0;
#line 32 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
int quiet  =    0;
#line 37 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
PathNodeTree pkgcdb_alloc(void) 
{ 
  PathNodeTree pnt ;
  StrTable st ;

  {
  {
#line 42
  st = strtab_alloc();
  }
#line 43
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 44
    return ((PathNodeTree )((void *)0));
  }
  {
#line 46
  pnt = pathnode_alloc(st);
  }
#line 47
  return (pnt);
}
}
#line 52 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
void pkgcdb_release(PathNodeTree pnt ) 
{ 
  StrTable st ;

  {
#line 56
  if (! ((unsigned long )pnt != (unsigned long )((void *)0))) {
    {
#line 56
    __assert_fail("pnt != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                  56U, "pkgcdb_release");
    }
  }
  {
#line 57
  st = pathnode_strtab(pnt);
  }
#line 58
  if (! ((unsigned long )st != (unsigned long )((void *)0))) {
    {
#line 58
    __assert_fail("st != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                  58U, "pkgcdb_release");
    }
  }
  {
#line 59
  pathnode_release(pnt);
#line 60
  strtab_release(st);
  }
#line 61
  return;
}
}
#line 64 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
PathNodeTree pkgcdb_load(char *dbfile , int str_margin , int pathnode_margin ) 
{ 
  int fd ;
  char buf___1[8] ;
  PathNodeTree pnt ;
  StrTable st ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 72
  if ((unsigned long )dbfile == (unsigned long )((void *)0)) {
#line 73
    return ((PathNodeTree )((void *)0));
  }
  {
#line 74
  fd = open((char const   *)dbfile, 0);
  }
#line 75
  if (fd < 0) {
#line 76
    return ((PathNodeTree )((void *)0));
  }
  {
#line 78
  tmp = read(fd, (void *)(buf___1), sizeof(buf___1));
  }
#line 78
  if (tmp < 0L) {
#line 79
    return ((PathNodeTree )((void *)0));
  }
  {
#line 81
  tmp___0 = strncmp((char const   *)(buf___1), "AUTO_APT", sizeof(buf___1));
  }
#line 81
  if (tmp___0 != 0) {
#line 82
    if (! quiet) {
      {
#line 82
      printf((char const   */* __restrict  */)"magic mismatch: %8s\n", buf___1);
      }
    }
#line 83
    return ((PathNodeTree )((void *)0));
  }
#line 85
  if (debug) {
    {
#line 85
    printf((char const   */* __restrict  */)"fd=%d magic: %8s\n", fd, buf___1);
    }
  }
  {
#line 86
  st = strtab_restore(fd, str_margin);
  }
#line 87
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 88
    if (! quiet) {
      {
#line 88
      printf((char const   */* __restrict  */)"strtab read error\n");
      }
    }
    {
#line 89
    close(fd);
    }
#line 90
    return ((PathNodeTree )((void *)0));
  }
  {
#line 92
  pnt = pathnode_restore(fd, st, pathnode_margin);
  }
#line 93
  if ((unsigned long )pnt == (unsigned long )((void *)0)) {
#line 94
    if (! quiet) {
      {
#line 94
      printf((char const   */* __restrict  */)"pathnode read error\n");
      }
    }
    {
#line 95
    close(fd);
    }
#line 96
    return ((PathNodeTree )((void *)0));
  }
  {
#line 98
  close(fd);
  }
#line 99
  return (pnt);
}
}
#line 103 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
int pkgcdb_save(char *dbfile , PathNodeTree pnt , int shrink ) 
{ 
  int fd ;
  char buf___1[8] ;
  ssize_t tmp ;
  StrTable tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 109
  if ((unsigned long )dbfile == (unsigned long )((void *)0)) {
#line 110
    return (-1);
  }
#line 111
  if ((unsigned long )pnt == (unsigned long )((void *)0)) {
#line 112
    return (-1);
  }
  {
#line 113
  fd = open((char const   *)dbfile, 577, 420);
  }
#line 114
  if (fd < 0) {
#line 115
    return (fd);
  }
  {
#line 116
  strncpy((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"AUTO_APT",
          sizeof(buf___1));
#line 117
  tmp = write(fd, (void const   *)(buf___1), sizeof(buf___1));
  }
#line 117
  if (tmp < 0L) {
#line 118
    goto error;
  }
  {
#line 120
  tmp___0 = pathnode_strtab(pnt);
#line 120
  tmp___1 = strtab_dump(fd, tmp___0, shrink);
  }
#line 120
  if (tmp___1 < 0) {
#line 121
    goto error;
  }
  {
#line 123
  tmp___2 = pathnode_dump(fd, pnt, shrink);
  }
#line 123
  if (tmp___2 < 0) {

  }
  error: 
  {
#line 127
  close(fd);
  }
#line 128
  return (0);
}
}
#line 138 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static char matchpath___0[4096]  ;
#line 133 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
struct path_node *pkgcdb_get(PathNodeTree pnt , char *file , char **matchfile , char **ext ) 
{ 
  char *p ;
  char *filename ;
  char path[4096] ;
  struct path_node *pn ;
  struct path_node *match ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 143
  if (debug) {
    {
#line 143
    printf((char const   */* __restrict  */)"pkgcdb_get: %s\n", file);
    }
  }
#line 144
  if ((int )*(file + 0) == 47) {
#line 145
    file ++;
  }
  {
#line 147
  filename = file;
#line 148
  p = file;
#line 149
  pn = pathnode_top(pnt);
#line 150
  match = (struct path_node *)((void *)0);
#line 151
  matchpath___0[0] = (char )'\000';
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! ((int )*p != 0)) {
#line 152
      goto while_break;
    }
#line 153
    if ((int )*p != 47) {
#line 154
      p ++;
#line 155
      goto while_continue;
    } else
#line 153
    if (p - file <= 1L) {
#line 154
      p ++;
#line 155
      goto while_continue;
    }
#line 157
    p ++;
#line 159
    if (! (p - file < 4096L)) {
      {
#line 159
      __assert_fail("p - file < 4096", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                    159U, "pkgcdb_get");
      }
    }
    {
#line 160
    strncpy((char */* __restrict  */)(path), (char const   */* __restrict  */)file,
            (size_t )(p - file));
#line 161
    path[p - file] = (char )'\000';
#line 162
    pn = pathnode_retrieve(pnt, pn, path);
    }
#line 163
    if ((unsigned long )pn == (unsigned long )((void *)0)) {
#line 164
      if ((unsigned long )matchfile != (unsigned long )((void *)0)) {
#line 165
        if (! ((file - filename) + 2L < 4096L)) {
          {
#line 165
          __assert_fail("file - filename + 2 < 4096", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                        165U, "pkgcdb_get");
          }
        }
        {
#line 166
        *matchfile = matchpath___0;
#line 167
        matchpath___0[0] = (char )'/';
#line 168
        strncpy((char */* __restrict  */)(matchpath___0 + 1), (char const   */* __restrict  */)filename,
                (size_t )(file - filename));
#line 169
        matchpath___0[(file + 1) - filename] = (char )'\000';
        }
      }
#line 171
      return (match);
    }
#line 173
    file = p;
#line 174
    match = pn;
#line 175
    if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
      {
#line 175
      __assert_fail("pn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                    175U, "pkgcdb_get");
      }
    }
#line 176
    if (! ((unsigned long )match != (unsigned long )((void *)0))) {
      {
#line 176
      __assert_fail("match != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                    176U, "pkgcdb_get");
      }
    }
#line 177
    if (debug) {
      {
#line 177
      tmp = pathnode_packagename(pnt, match);
#line 177
      tmp___0 = pathnode_pathname(pnt, pn);
#line 177
      printf((char const   */* __restrict  */)"match:%s[%s] rest>%s\n", tmp___0, tmp,
             file);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  if (debug) {
    {
#line 181
    printf((char const   */* __restrict  */)"last?%s (%d)\n", file, p - file);
    }
  }
#line 182
  if (p - file >= 1L) {
    {
#line 183
    pn = pathnode_retrieve(pnt, pn, file);
    }
#line 184
    if ((unsigned long )pn == (unsigned long )((void *)0)) {
#line 185
      if ((unsigned long )matchfile != (unsigned long )((void *)0)) {
#line 186
        if (! ((file - filename) + 2L < 4096L)) {
          {
#line 186
          __assert_fail("file - filename + 2 < 4096", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                        186U, "pkgcdb_get");
          }
        }
        {
#line 187
        *matchfile = matchpath___0;
#line 188
        matchpath___0[0] = (char )'/';
#line 189
        strncpy((char */* __restrict  */)(matchpath___0 + 1), (char const   */* __restrict  */)filename,
                (size_t )(file - filename));
#line 190
        matchpath___0[(file + 1) - filename] = (char )'\000';
        }
      }
#line 192
      return (match);
    }
  }
#line 195
  if ((unsigned long )matchfile != (unsigned long )((void *)0)) {
    {
#line 196
    *matchfile = matchpath___0;
#line 197
    matchpath___0[0] = (char )'/';
#line 198
    strcpy((char */* __restrict  */)(matchpath___0 + 1), (char const   */* __restrict  */)filename);
    }
  }
#line 200
  return (pn);
}
}
#line 204 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
struct pathlist *defpathlist  =    (struct pathlist *)((void *)0);
#line 212 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
int pkgcdb_path_list_init(PathNodeTree pnt , char *file ) 
{ 
  FILE *fp ;
  char buf___1[4096] ;
  char *p ;
  char *pkg ;
  struct pathlist *pl ;
  struct pathlist *plp ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;

  {
#line 219
  n = 0;
#line 221
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 222
    return (-1);
  }
#line 223
  if (! quiet) {
#line 223
    if (verbose) {
      {
#line 223
      printf((char const   */* __restrict  */)"paths.list loading from %s...", file);
      }
    }
  }
  {
#line 224
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 225
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 226
    if (! quiet) {
      {
#line 226
      perror("fopen paths.list");
      }
    }
#line 227
    return (-1);
  }
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 229
    tmp___7 = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1), (FILE */* __restrict  */)fp);
    }
#line 229
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
#line 229
      goto while_break;
    }
#line 230
    if ((int )buf___1[0] == 35) {
#line 231
      goto while_continue;
    }
    {
#line 232
    tmp___0 = strlen((char const   *)(buf___1));
    }
#line 232
    if ((int )buf___1[tmp___0 - 1UL] == 10) {
      {
#line 233
      tmp = strlen((char const   *)(buf___1));
#line 233
      buf___1[tmp - 1UL] = (char )'\000';
      }
    }
#line 234
    p = buf___1;
    {
#line 234
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 234
      if (! ((int )*p != 0)) {
#line 234
        goto while_break___0;
      }
      {
#line 235
      tmp___2 = __ctype_b_loc();
      }
#line 235
      if ((int const   )*(*tmp___2 + (int )*p) & 8192) {
#line 236
        tmp___1 = p;
#line 236
        p ++;
#line 236
        *tmp___1 = (char )'\000';
#line 237
        goto while_break___0;
      }
#line 234
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 240
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 240
      if (! ((int )*p != 0)) {
#line 240
        goto while_break___1;
      }
      {
#line 241
      tmp___3 = __ctype_b_loc();
      }
#line 241
      if (! ((int const   )*(*tmp___3 + (int )*p) & 8192)) {
#line 242
        goto while_break___1;
      }
#line 240
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 245
    pkg = p;
#line 246
    if ((int )*p == 0) {
#line 247
      pkg = (char *)"*";
    } else {
      {
#line 249
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 249
        if (! ((int )*p != 0)) {
#line 249
          goto while_break___2;
        }
        {
#line 250
        tmp___4 = __ctype_b_loc();
        }
#line 250
        if ((int const   )*(*tmp___4 + (int )*p) & 8192) {
#line 251
          *p = (char )'\000';
#line 252
          goto while_break___2;
        }
#line 249
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 256
    tmp___5 = malloc(sizeof(struct pathlist ));
#line 256
    pl = (struct pathlist *)tmp___5;
    }
#line 257
    if ((unsigned long )pl == (unsigned long )((void *)0)) {
#line 258
      return (-1);
    }
    {
#line 259
    memset((void *)pl, 0, sizeof(struct pathlist ));
#line 260
    pl->path = strdup((char const   *)(buf___1));
#line 261
    tmp___6 = strlen((char const   *)pl->path);
#line 261
    pl->pathlen = (int )tmp___6;
#line 262
    pl->pkg = strdup((char const   *)pkg);
#line 263
    pl->n = pkgcdb_put(pnt, pl->path, pl->pkg, (int *)((void *)0));
    }
#line 265
    if ((unsigned long )defpathlist == (unsigned long )((void *)0)) {
#line 266
      pl->next = defpathlist;
#line 267
      defpathlist = pl;
    } else
#line 265
    if (pl->pathlen > defpathlist->pathlen) {
#line 266
      pl->next = defpathlist;
#line 267
      defpathlist = pl;
    } else {
#line 269
      plp = defpathlist;
      {
#line 269
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 269
        if ((unsigned long )plp != (unsigned long )((void *)0)) {
#line 269
          if (! ((unsigned long )plp->next != (unsigned long )((void *)0))) {
#line 269
            goto while_break___3;
          }
        } else {
#line 269
          goto while_break___3;
        }
#line 272
        if (pl->pathlen > (plp->next)->pathlen) {
#line 273
          pl->next = plp->next;
#line 274
          plp->next = pl;
#line 275
          goto while_break___3;
        }
#line 269
        plp = plp->next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 278
      if ((unsigned long )plp != (unsigned long )((void *)0)) {
#line 278
        if ((unsigned long )plp->next == (unsigned long )((void *)0)) {
#line 279
          plp->next = pl;
        }
      }
    }
#line 282
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  if (! quiet) {
#line 284
    if (verbose) {
      {
#line 284
      printf((char const   */* __restrict  */)"%d done\n", n);
      }
    }
  }
#line 286
  if (debug) {
#line 287
    plp = defpathlist;
    {
#line 287
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 287
      if (! ((unsigned long )plp != (unsigned long )((void *)0))) {
#line 287
        goto while_break___4;
      }
      {
#line 288
      printf((char const   */* __restrict  */)"%s %s\n", plp->path, plp->pkg);
#line 287
      plp = plp->next;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 292
  return (0);
}
}
#line 295 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static int path_list_local_init(PathNodeTree pnt ) 
{ 
  struct pathlist *pl ;
  struct pathlist *npl ;
  struct stat st ;
  char buf___1[4098] ;
  void *tmp ;
  int tmp___0 ;

  {
#line 301
  pl = defpathlist;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 301
      goto while_break;
    }
#line 302
    if ((int )*(pl->path + (pl->pathlen - 1)) == 47) {
      {
#line 303
      snprintf((char */* __restrict  */)(buf___1), (size_t )4096, (char const   */* __restrict  */)"/%s",
               pl->path);
#line 304
      tmp___0 = stat((char const   */* __restrict  */)(buf___1), (struct stat */* __restrict  */)(& st));
      }
#line 304
      if (tmp___0 == 0) {
#line 304
        if ((st.st_mode & 61440U) == 16384U) {
          {
#line 306
          tmp = malloc(sizeof(struct pathlist ));
#line 306
          npl = (struct pathlist *)tmp;
          }
#line 307
          if ((unsigned long )npl == (unsigned long )((void *)0)) {
#line 308
            goto __Cont;
          }
          {
#line 309
          memset((void *)npl, 0, sizeof(struct pathlist ));
#line 310
          npl->path = strdup((char const   *)pl->path);
#line 311
          *(npl->path + (pl->pathlen - 1)) = (char )'\000';
#line 312
          npl->pathlen = pl->pathlen - 1;
#line 313
          npl->pkg = pl->pkg;
#line 314
          npl->n = pkgcdb_put(pnt, npl->path, npl->pkg, (int *)((void *)0));
#line 315
          npl->next = pl->next;
#line 316
          pl->next = npl;
#line 317
          pl = npl;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 301
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return (0);
}
}
#line 324 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static struct pathlist *path_list_check(char *file ) 
{ 
  struct pathlist *pl ;
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 329
  if (debug) {
    {
#line 329
    printf((char const   */* __restrict  */)"path_list check? file=%s\n", file);
    }
  }
  {
#line 330
  tmp = strlen((char const   *)file);
#line 330
  len = (int )tmp;
#line 331
  pl = defpathlist;
  }
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 331
      goto while_break;
    }
#line 332
    if ((unsigned long )pl->n != (unsigned long )((void *)0)) {
#line 333
      if (len >= pl->pathlen) {
        {
#line 333
        tmp___0 = strncmp((char const   *)file, (char const   *)pl->path, (size_t )pl->pathlen);
        }
#line 333
        if (tmp___0 == 0) {
#line 335
          if (debug) {
            {
#line 335
            printf((char const   */* __restrict  */)"path list match[%s]:%s <=> %s",
                   pl->pkg, pl->path, file);
            }
          }
#line 337
          return (pl);
        }
      }
    }
#line 331
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return ((struct pathlist *)((void *)0));
}
}
#line 350 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static char package[4096]  ;
#line 346 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static char *next_package(char *p , char **np ) 
{ 
  int i ;
  int tmp ;

  {
#line 352
  *np = (char *)((void *)0);
#line 353
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 354
    return ((char *)((void *)0));
  } else
#line 353
  if ((int )*p == 0) {
#line 354
    return ((char *)((void *)0));
  }
#line 355
  i = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! ((int )*(p + i) != 0)) {
#line 355
      goto while_break;
    }
#line 356
    if ((int )*(p + i) == 44) {
#line 357
      goto while_break;
    }
    {
#line 358
    tmp = tolower((int )*(p + i));
#line 358
    package[i] = (char )tmp;
#line 355
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  if ((int )*(p + i) == 44) {
#line 361
    *np = p + (i + 1);
  }
#line 362
  package[i] = (char )'\000';
#line 363
  return (package);
}
}
#line 376 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static int inited___2  =    0;
#line 377 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static pkg_id pkg_defs  ;
#line 379 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
static int local_inited  =    0;
#line 368 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
struct path_node *pkgcdb_put(PathNodeTree pnt , char *file , char *pkg , int *nent ) 
{ 
  char *package___0 ;
  char *dups ;
  char *p ;
  char path[4096] ;
  struct path_node *pn ;
  struct path_node *npn ;
  pkg_id pkgid ;
  pkg_id npkgid ;
  struct pathlist *pl ;
  StrTable tmp ;
  StrTable tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  StrTable tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  StrTable tmp___10 ;

  {
#line 383
  if (! ((unsigned long )pnt != (unsigned long )((void *)0))) {
    {
#line 383
    __assert_fail("pnt != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                  383U, "pkgcdb_put");
    }
  }
#line 384
  if (! inited___2) {
    {
#line 385
    inited___2 = 1;
#line 386
    tmp = pathnode_strtab(pnt);
#line 386
    pkg_defs = pkg_intern(tmp, (char *)"*");
    }
  }
#line 389
  if (debug) {
    {
#line 389
    printf((char const   */* __restrict  */)"put: <%s><%s>\n", file, pkg);
    }
  }
  {
#line 390
  package___0 = next_package(pkg, & dups);
#line 391
  tmp___0 = pathnode_strtab(pnt);
#line 391
  pkgid = pkg_intern(tmp___0, package___0);
#line 392
  tmp___1 = strncmp((char const   *)file, "./", (size_t )2);
  }
#line 392
  if (tmp___1 == 0) {
#line 393
    file += 2;
  }
  {
#line 395
  pn = pathnode_top(pnt);
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if ((int )*file != 0) {
#line 396
      if (! ((int )*file == 47)) {
#line 396
        goto while_break;
      }
    } else {
#line 396
      goto while_break;
    }
#line 397
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 400
  tmp___2 = strcmp((char const   *)file, ".");
  }
#line 400
  if (tmp___2 == 0) {
#line 401
    if (! local_inited) {
#line 403
      local_inited = 1;
#line 404
      if (! quiet) {
        {
#line 404
        printf((char const   */* __restrict  */)"local file list mode\n");
        }
      }
      {
#line 405
      path_list_local_init(pnt);
      }
    }
#line 407
    return ((struct path_node *)((void *)0));
  }
  {
#line 410
  pl = path_list_check(file);
  }
#line 411
  if ((unsigned long )pl != (unsigned long )((void *)0)) {
    {
#line 412
    file += pl->pathlen;
#line 413
    pn = pl->n;
#line 414
    tmp___5 = strcmp((char const   *)pl->pkg, "*");
    }
#line 414
    if (tmp___5 == 0) {
#line 415
      if (debug) {
        {
#line 415
        tmp___3 = pathnode_pathname(pnt, pn);
#line 415
        printf((char const   */* __restrict  */)" start=<%s> %p(%s)", file, pn, tmp___3);
        }
      }
    } else {
#line 419
      if (debug) {
        {
#line 419
        tmp___4 = pathnode_pathname(pnt, pn);
#line 419
        printf((char const   */* __restrict  */)" ignore=<%s> %p(%s)", file, pn, tmp___4);
        }
      }
#line 421
      return (pn);
    }
  }
#line 426
  p = file;
#line 427
  if (debug) {
    {
#line 427
    printf((char const   */* __restrict  */)" file? %s\n", p);
    }
  }
  {
#line 428
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 428
    if (! ((int )*p != 0)) {
#line 428
      goto while_break___0;
    }
#line 429
    if ((int )*p != 47) {
#line 430
      p ++;
#line 431
      goto while_continue___0;
    } else
#line 429
    if (p - file <= 1L) {
#line 430
      p ++;
#line 431
      goto while_continue___0;
    }
#line 433
    p ++;
#line 434
    if (! (p - file < 4096L)) {
      {
#line 434
      __assert_fail("p - file < 4096", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                    434U, "pkgcdb_put");
      }
    }
    {
#line 435
    strncpy((char */* __restrict  */)(path), (char const   */* __restrict  */)file,
            (size_t )(p - file));
#line 436
    path[p - file] = (char )'\000';
    }
#line 437
    if (debug) {
      {
#line 437
      printf((char const   */* __restrict  */)"insert=<%s> %s|", path, pkg);
      }
    }
    {
#line 438
    npn = pathnode_insert(pnt, pn, path, pkgid);
    }
#line 439
    if (! ((unsigned long )npn != (unsigned long )((void *)0))) {
      {
#line 439
      __assert_fail("npn != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                    439U, "pkgcdb_put");
      }
    }
    {
#line 440
    npkgid = pathnode_package(pnt, npn);
    }
#line 441
    if ((unsigned long )nent != (unsigned long )((void *)0)) {
#line 442
      (*nent) ++;
    }
#line 443
    if (dups) {
      {
#line 444
      package___0 = next_package(dups, & dups);
      }
      {
#line 444
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 444
        if (! ((unsigned long )package___0 != (unsigned long )((void *)0))) {
#line 444
          goto while_break___1;
        }
        {
#line 447
        tmp___6 = pathnode_strtab(pnt);
#line 447
        pkgid = pkg_intern(tmp___6, package___0);
#line 448
        pathnode_chain(pnt, npn, pkgid);
#line 444
        package___0 = next_package(dups, & dups);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 451
    tmp___7 = pkg_cmp(& pkgid, & pkg_defs);
    }
#line 451
    if (tmp___7 != 0) {
      {
#line 451
      tmp___8 = pkg_cmp(& npkgid, & pkgid);
      }
#line 451
      if (tmp___8 == 0) {
#line 453
        return (npn);
      }
    }
#line 455
    file = p;
#line 456
    pn = npn;
#line 457
    if (debug) {
      {
#line 457
      tmp___9 = pathnode_pathname(pnt, pn);
#line 457
      printf((char const   */* __restrict  */)"next=<%s> %p(%s)", file, pn, tmp___9);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 459
  if (p - file >= 1L) {
#line 460
    if (debug) {
      {
#line 460
      printf((char const   */* __restrict  */)"insert=<%s> %s|", file, pkg);
      }
    }
    {
#line 461
    pn = pathnode_insert(pnt, pn, file, pkgid);
    }
#line 462
    if (dups) {
      {
#line 463
      package___0 = next_package(dups, & dups);
      }
      {
#line 463
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 463
        if (! ((unsigned long )package___0 != (unsigned long )((void *)0))) {
#line 463
          goto while_break___2;
        }
        {
#line 466
        tmp___10 = pathnode_strtab(pnt);
#line 466
        pkgid = pkg_intern(tmp___10, package___0);
#line 467
        pathnode_chain(pnt, pn, pkgid);
#line 463
        package___0 = next_package(dups, & dups);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 471
  return (pn);
}
}
#line 476 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
void pkgcdb_del(PathNodeTree pnt , char *file , char *pkg , int *nent ) 
{ 
  char *package___0 ;
  char *p ;
  int i ;
  char path[4096] ;
  struct path_node *pn ;
  struct path_node *npn ;
  pkg_id pkgid ;
  pkg_id npkgid ;
  struct pathlist *pl ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  StrTable tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
#line 487
  if (! ((unsigned long )pnt != (unsigned long )((void *)0))) {
    {
#line 487
    __assert_fail("pnt != ((void *)0)", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                  487U, "pkgcdb_del");
    }
  }
#line 488
  if (debug) {
    {
#line 488
    printf((char const   */* __restrict  */)"put: <%s><%s>\n", file, pkg);
    }
  }
  {
#line 489
  tmp = strlen((char const   *)pkg);
#line 489
  tmp___0 = malloc(tmp + 1UL);
#line 489
  package___0 = (char *)tmp___0;
#line 490
  i = 0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! ((int )*(pkg + i) != 0)) {
#line 490
      goto while_break;
    }
#line 491
    if ((int )*(pkg + i) == 44) {
#line 492
      goto while_break;
    }
    {
#line 493
    tmp___1 = tolower((int )*(pkg + i));
#line 493
    *(package___0 + i) = (char )tmp___1;
#line 490
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 495
  *(package___0 + i) = (char )'\000';
#line 496
  tmp___2 = pathnode_strtab(pnt);
#line 496
  pkgid = pkg_intern(tmp___2, package___0);
#line 497
  free((void *)package___0);
#line 498
  tmp___3 = strncmp((char const   *)file, "./", (size_t )2);
  }
#line 498
  if (tmp___3 == 0) {
#line 499
    file += 2;
  }
  {
#line 501
  pn = pathnode_top(pnt);
  }
  {
#line 502
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 502
    if ((int )*file != 0) {
#line 502
      if (! ((int )*file == 47)) {
#line 502
        goto while_break___0;
      }
    } else {
#line 502
      goto while_break___0;
    }
#line 503
    file ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 505
  pl = path_list_check(file);
  }
#line 506
  if ((unsigned long )pl != (unsigned long )((void *)0)) {
    {
#line 507
    file += pl->pathlen;
#line 508
    pn = pl->n;
#line 509
    tmp___6 = strcmp((char const   *)pl->pkg, "*");
    }
#line 509
    if (tmp___6 == 0) {
#line 510
      if (debug) {
        {
#line 510
        tmp___4 = pathnode_pathname(pnt, pn);
#line 510
        printf((char const   */* __restrict  */)" start=<%s> %p(%s)", file, pn, tmp___4);
        }
      }
    } else {
#line 514
      if (debug) {
        {
#line 514
        tmp___5 = pathnode_pathname(pnt, pn);
#line 514
        printf((char const   */* __restrict  */)" ignore=<%s> %p(%s)", file, pn, tmp___5);
        }
      }
#line 516
      return;
    }
  }
#line 520
  p = file;
  {
#line 521
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 521
    if (! ((int )*p != 0)) {
#line 521
      goto while_break___1;
    }
#line 522
    if ((int )*p != 47) {
#line 523
      p ++;
#line 524
      goto while_continue___1;
    } else
#line 522
    if (p - file <= 1L) {
#line 523
      p ++;
#line 524
      goto while_continue___1;
    }
#line 526
    p ++;
#line 527
    if (! (p - file < 4096L)) {
      {
#line 527
      __assert_fail("p - file < 4096", "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c",
                    527U, "pkgcdb_del");
      }
    }
    {
#line 528
    strncpy((char */* __restrict  */)(path), (char const   */* __restrict  */)file,
            (size_t )(p - file));
#line 529
    path[p - file] = (char )'\000';
#line 530
    npn = pathnode_retrieve(pnt, pn, path);
    }
#line 531
    if ((unsigned long )npn == (unsigned long )((void *)0)) {
#line 532
      return;
    }
#line 533
    pn = npn;
    {
#line 533
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 533
      if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
#line 533
        goto while_break___2;
      }
      {
#line 534
      npkgid = pathnode_package(pnt, pn);
#line 535
      tmp___7 = pkg_cmp(& npkgid, & pkgid);
      }
#line 535
      if (tmp___7 == 0) {
        {
#line 536
        pathnode_delete(pnt, pn);
        }
#line 537
        if (nent) {
#line 538
          (*nent) --;
        }
      }
      {
#line 533
      pn = pathnode_next(pnt, pn);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 541
    file = p;
#line 542
    pn = npn;
#line 543
    if (debug) {
      {
#line 543
      tmp___8 = pathnode_pathname(pnt, pn);
#line 543
      printf((char const   */* __restrict  */)"next=<%s> %p(%s)", file, pn, tmp___8);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 545
  if (p - file >= 1L) {
    {
#line 546
    pn = pathnode_retrieve(pnt, pn, path);
    }
#line 547
    if ((unsigned long )pn == (unsigned long )((void *)0)) {
#line 548
      return;
    }
    {
#line 549
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 549
      if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
#line 549
        goto while_break___3;
      }
      {
#line 550
      npkgid = pathnode_package(pnt, pn);
#line 551
      tmp___9 = pkg_cmp(& npkgid, & pkgid);
      }
#line 551
      if (tmp___9 == 0) {
        {
#line 552
        pathnode_delete(pnt, pn);
        }
#line 553
        if (nent) {
#line 554
          (*nent) --;
        }
      }
      {
#line 549
      pn = pathnode_next(pnt, pn);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 558
  return;
}
}
#line 564 "/home/june/collector/temp/auto-apt-0.3.23ubuntu0.14.04.1/pkgcdb/pkgcdb2.c"
void pkgcdb_traverse(PathNodeTree pnt , void (*func)(PathNodeTree pnt , char *path ,
                                                     struct path_node *pn , void *arg ) ,
                     void *arg ) 
{ 
  struct path_node *pn ;

  {
  {
#line 571
  pn = pathnode_top(pnt);
#line 572
  pathnode_traverse(pnt, (char *)((void *)0), pn, func, arg);
  }
#line 573
  return;
}
}
