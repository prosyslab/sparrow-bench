/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 45 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
struct driverlist_t;
#line 45 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
struct __anonstruct_driverlist_t_26 {
   char name[128] ;
   char *functionality ;
   struct driverlist_t *next ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
typedef struct __anonstruct_driverlist_t_26 driverlist_t;
#line 53
struct printerlist_t;
#line 53 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
struct __anonstruct_printerlist_t_27 {
   char id[128] ;
   driverlist_t *drivers ;
   struct printerlist_t *next ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
typedef struct __anonstruct_printerlist_t_27 printerlist_t;
#line 60
struct ppdlist_t;
#line 60 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
struct __anonstruct_ppdlist_t_28 {
   char driver[128] ;
   char ppd[1024] ;
   struct ppdlist_t *next ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
typedef struct __anonstruct_ppdlist_t_28 ppdlist_t;
#line 66
struct idlist_t;
#line 66 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
struct __anonstruct_idlist_t_29 {
   char *oldid ;
   char *newid ;
   struct idlist_t *next ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
typedef struct __anonstruct_idlist_t_29 idlist_t;
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
char *loadfile(char const   *filename ) 
{ 
  int blocksize ;
  FILE *inputfile ;
  char *buffer ;
  unsigned long __lengthofbuffer ;
  void *tmp ;
  char *data ;
  int size ;
  int bytesread ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 79
  blocksize = 1048576;
#line 81
  __lengthofbuffer = (unsigned long )(blocksize + 1);
#line 81
  tmp = __builtin_alloca(sizeof(*buffer) * __lengthofbuffer);
#line 81
  buffer = (char *)tmp;
#line 82
  data = (char *)((void *)0);
#line 83
  size = 1;
#line 88
  inputfile = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 89
  if ((unsigned long )inputfile == (unsigned long )((void *)0)) {
#line 90
    return ((char *)((void *)0));
  }
  {
#line 95
  tmp___0 = malloc((size_t )size);
#line 95
  data = (char *)tmp___0;
#line 96
  *(data + 0) = (char )'\000';
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    tmp___2 = fread((void */* __restrict  */)buffer, (size_t )1, (size_t )blocksize,
                    (FILE */* __restrict  */)inputfile);
#line 97
    bytesread = (int )tmp___2;
    }
#line 97
    if (! bytesread) {
#line 97
      goto while_break;
    }
    {
#line 98
    tmp___1 = realloc((void *)data, (size_t )(size + bytesread));
#line 98
    data = (char *)tmp___1;
#line 99
    *(buffer + bytesread) = (char )'\000';
#line 100
    strcat((char */* __restrict  */)data, (char const   */* __restrict  */)buffer);
#line 101
    size += bytesread;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  fclose(inputfile);
#line 105
  tmp___3 = realloc((void *)data, (size_t )(size + 4096));
#line 105
  data = (char *)tmp___3;
#line 106
  tmp___4 = strcmp((char const   *)data, "");
  }
#line 106
  if (tmp___4) {
#line 106
    return (data);
  } else {
    {
#line 106
    free((void *)data);
    }
#line 106
    return ((char *)((void *)0));
  }
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
idlist_t *loadidlist(char const   *filename ) 
{ 
  char *idlistbuffer ;
  char *scan ;
  char *oldid ;
  char *newid ;
  int inoldid ;
  int innewid ;
  idlist_t *idlist ;
  idlist_t *currentitem ;
  idlist_t *newitem ;
  void *tmp ;

  {
  {
#line 115
  idlistbuffer = (char *)((void *)0);
#line 117
  oldid = (char *)((void *)0);
#line 117
  newid = (char *)((void *)0);
#line 119
  inoldid = 0;
#line 119
  innewid = 0;
#line 121
  idlist = (idlist_t *)((void *)0);
#line 121
  currentitem = (idlist_t *)((void *)0);
#line 125
  idlistbuffer = loadfile(filename);
  }
#line 126
  if (! idlistbuffer) {
    {
#line 127
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot read file %s!\n",
            filename);
    }
#line 128
    return ((idlist_t *)((void *)0));
  }
#line 130
  scan = idlistbuffer;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! ((int )*scan != 0)) {
#line 130
      goto while_break;
    }
    {
#line 133
    if ((int )*scan == 10) {
#line 133
      goto case_10;
    }
#line 133
    if ((int )*scan == 13) {
#line 133
      goto case_10;
    }
#line 142
    if ((int )*scan == 32) {
#line 142
      goto case_32;
    }
#line 142
    if ((int )*scan == 9) {
#line 142
      goto case_32;
    }
#line 172
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 135
    if (inoldid) {
#line 137
      inoldid = 0;
#line 138
      oldid = (char *)((void *)0);
#line 139
      goto switch_break;
    }
    case_32: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 144
    if (inoldid) {
#line 146
      inoldid = 0;
#line 147
      *scan = (char )'\000';
    }
#line 149
    if (innewid) {
#line 151
      innewid = 0;
#line 152
      *scan = (char )'\000';
#line 153
      if (oldid) {
#line 153
        if (newid) {
#line 153
          if ((int )*oldid != 35) {
            {
#line 156
            tmp = malloc(sizeof(idlist_t ));
#line 156
            newitem = (idlist_t *)tmp;
#line 158
            newitem->oldid = oldid;
#line 159
            newitem->newid = newid;
#line 160
            newitem->next = (struct idlist_t *)((void *)0);
            }
#line 161
            if (currentitem) {
#line 162
              currentitem->next = (struct idlist_t *)newitem;
            } else {
#line 164
              idlist = newitem;
            }
#line 166
            currentitem = newitem;
          }
        }
      }
#line 168
      oldid = (char *)((void *)0);
#line 169
      newid = (char *)((void *)0);
    }
#line 171
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 174
    if (! inoldid) {
#line 174
      if (! innewid) {
#line 176
        if (oldid) {
#line 178
          innewid = 1;
#line 179
          newid = scan;
        } else {
#line 182
          inoldid = 1;
#line 183
          oldid = scan;
        }
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 130
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (idlist);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
char *translateid(char const   *oldid , idlist_t *idlist ) 
{ 
  idlist_t *currentitem ;
  int tmp ;

  {
#line 198
  currentitem = idlist;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! currentitem) {
#line 200
      goto while_break;
    }
    {
#line 201
    tmp = strcmp(oldid, (char const   *)currentitem->oldid);
    }
#line 201
    if (tmp == 0) {
#line 202
      return (currentitem->newid);
    }
#line 204
    currentitem = (idlist_t *)currentitem->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return ((char *)oldid);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
static char make[256]  ;
#line 346 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
static char model[256]  ;
#line 218 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
int parse(char **data , char const   *pid , char const   *driver , char const   *filename ,
          printerlist_t **printerlist , int operation , char const   **defaultsettings ,
          int num_defaultsettings , int *nopjl , idlist_t *idlist , int debug ) 
{ 
  char *trpid ;
  int datalength ;
  int linecount ;
  int nestinglevel ;
  int inxmlheader ;
  int intag ;
  int incomment ;
  int tagnamefound ;
  int intagword ;
  int inquotes ;
  int insinglequotes ;
  int indoublequotes ;
  int tagtype ;
  int inprinter ;
  int inmake ;
  int inmodel ;
  int inautodetect ;
  int indriver ;
  int indrivers ;
  int inexecution ;
  int inprototype ;
  int innopjl ;
  int inprinters ;
  int inid ;
  int inppd ;
  int inlang ;
  int inpostscript ;
  int inoption ;
  int inargshortname ;
  int inargexecution ;
  int inargpjl ;
  int inevshortname ;
  int inen ;
  int inargmax ;
  int inargmin ;
  int inenumval ;
  int inconstraints ;
  int inconstraint ;
  int inargdefault ;
  int infunctionality ;
  int inunverified ;
  int indfunctionality ;
  int incomments ;
  int printertobesaved ;
  int printerentryfound ;
  int enumvaltoberemoved ;
  int optionqualified ;
  int enumvalqualified ;
  int numenumvals ;
  int optiontype ;
  int printerscore ;
  int driverscore ;
  int printerhiscore ;
  int driverhiscore ;
  int defaultlinelength ;
  char currtagname[256] ;
  char currtagparam[256] ;
  char currtagbody[65536] ;
  int userdefault ;
  int userdefaultfound ;
  char userdefaultvalue[256] ;
  char userdefaultid[256] ;
  char currevid[256] ;
  double maxnumvalue ;
  double minnumvalue ;
  int csense ;
  char cprinter[256] ;
  char cmake[256] ;
  char cmodel[256] ;
  char cdriver[256] ;
  char cid[256] ;
  char cppd[1024] ;
  char cfunctionality[256] ;
  int cunverified ;
  char cautodetectentry[4096] ;
  char cargdefault[256] ;
  char argdefault[256] ;
  char defaultline[256] ;
  char printerentry[1048576] ;
  char dfunctionalityentry[10240] ;
  char const   *scan ;
  char const   *lasttag ;
  char const   *lasttagend ;
  char const   *tagwordstart ;
  char *lastprinters ;
  char *lastprinter ;
  char *lastenumval ;
  char *lastconstraints ;
  char *lastoption ;
  char *lastautodetect ;
  char *lastdfunctionality ;
  char *lastcomments ;
  char *lastprototype ;
  int comboconfirmed ;
  int driverhasproto ;
  int exceptionfound ;
  char *s ;
  int l ;
  int j ;
  int k ;
  printerlist_t *plistpointer ;
  driverlist_t *dlistpointer ;
  ppdlist_t *ppdlistpointer ;
  printerlist_t *plistpreventry ;
  driverlist_t *dlistpreventry ;
  driverlist_t *dlistnextentry ;
  ppdlist_t *ppdlistpreventry ;
  ppdlist_t *ppdlist ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  size_t tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  char *tmp___63 ;
  size_t tmp___64 ;
  int tmp___65 ;
  size_t tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  char *tmp___70 ;
  size_t tmp___71 ;
  size_t tmp___72 ;
  char *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  size_t tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  size_t tmp___85 ;
  size_t tmp___86 ;
  size_t tmp___87 ;
  size_t tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  char *tmp___92 ;
  size_t tmp___93 ;
  int tmp___94 ;
  double tmp___95 ;
  double tmp___96 ;
  char *tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  size_t tmp___103 ;
  char *tmp___104 ;
  int tmp___105 ;
  void *tmp___106 ;
  void *tmp___107 ;
  char *tmp___108 ;
  int tmp___109 ;
  void *tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  void *tmp___113 ;
  int tmp___114 ;
  void *tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  void *tmp___118 ;
  char *tmp___119 ;
  int tmp___120 ;
  char *tmp___121 ;
  int tmp___122 ;

  {
#line 239
  trpid = (char *)((void *)0);
#line 241
  datalength = 0;
#line 242
  linecount = 1;
#line 243
  nestinglevel = 0;
#line 245
  inxmlheader = 1;
#line 246
  intag = 0;
#line 247
  incomment = 0;
#line 248
  tagnamefound = 0;
#line 249
  intagword = 0;
#line 250
  inquotes = 0;
#line 251
  insinglequotes = 0;
#line 252
  indoublequotes = 0;
#line 255
  tagtype = 0;
#line 256
  inprinter = 0;
#line 257
  inmake = 0;
#line 258
  inmodel = 0;
#line 259
  inautodetect = 0;
#line 260
  indriver = 0;
#line 261
  indrivers = 0;
#line 262
  inexecution = 0;
#line 263
  inprototype = 0;
#line 264
  innopjl = 0;
#line 265
  inprinters = 0;
#line 266
  inid = 0;
#line 267
  inppd = 0;
#line 268
  inlang = 0;
#line 269
  inpostscript = 0;
#line 270
  inoption = 0;
#line 271
  inargshortname = 0;
#line 272
  inargexecution = 0;
#line 273
  inargpjl = 0;
#line 274
  inevshortname = 0;
#line 275
  inen = 0;
#line 276
  inargmax = 0;
#line 277
  inargmin = 0;
#line 278
  inenumval = 0;
#line 279
  inconstraints = 0;
#line 280
  inconstraint = 0;
#line 281
  inargdefault = 0;
#line 282
  infunctionality = 0;
#line 283
  inunverified = 0;
#line 284
  indfunctionality = 0;
#line 285
  incomments = 0;
#line 286
  printertobesaved = 0;
#line 287
  printerentryfound = 0;
#line 288
  enumvaltoberemoved = 0;
#line 289
  optionqualified = 0;
#line 290
  enumvalqualified = 1;
#line 291
  numenumvals = 1;
#line 301
  optiontype = 0;
#line 302
  printerscore = 0;
#line 303
  driverscore = 0;
#line 304
  printerhiscore = 0;
#line 305
  driverhiscore = 0;
#line 306
  defaultlinelength = 0;
#line 310
  userdefault = 0;
#line 311
  userdefaultfound = 0;
#line 315
  maxnumvalue = (double )0;
#line 316
  minnumvalue = (double )0;
#line 317
  csense = 0;
#line 325
  cunverified = 0;
#line 333
  lasttag = (char const   *)((void *)0);
#line 334
  lasttagend = (char const   *)((void *)0);
#line 335
  tagwordstart = (char const   *)((void *)0);
#line 336
  lastprinters = (char *)((void *)0);
#line 337
  lastprinter = (char *)((void *)0);
#line 338
  lastenumval = (char *)((void *)0);
#line 339
  lastconstraints = (char *)((void *)0);
#line 340
  lastoption = (char *)((void *)0);
#line 341
  lastautodetect = (char *)((void *)0);
#line 342
  lastdfunctionality = (char *)((void *)0);
#line 343
  lastcomments = (char *)((void *)0);
#line 344
  lastprototype = (char *)((void *)0);
#line 348
  comboconfirmed = 0;
#line 349
  driverhasproto = 0;
#line 350
  exceptionfound = 0;
#line 363
  ppdlist = (ppdlist_t *)((void *)0);
#line 366
  if (pid) {
#line 366
    if (operation < 3) {
      {
#line 366
      trpid = translateid(pid, idlist);
      }
    }
  }
  {
#line 368
  j = 0;
#line 369
  tmp = strlen((char const   *)*data);
#line 369
  datalength = (int )tmp;
  }
#line 371
  if (operation == 1) {
#line 371
    *nopjl = 0;
  }
#line 374
  scan = (char const   *)*data;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! ((int const   )*scan != 0)) {
#line 374
      goto while_break;
    }
    {
#line 376
    if ((int const   )*scan == 60) {
#line 376
      goto case_60;
    }
#line 409
    if ((int const   )*scan == 10) {
#line 409
      goto case_10;
    }
#line 415
    if ((int const   )*scan == 13) {
#line 415
      goto case_13;
    }
#line 415
    if ((int const   )*scan == 9) {
#line 415
      goto case_13;
    }
#line 415
    if ((int const   )*scan == 32) {
#line 415
      goto case_13;
    }
#line 415
    if ((int const   )*scan == 62) {
#line 415
      goto case_13;
    }
#line 415
    if ((int const   )*scan == 47) {
#line 415
      goto case_13;
    }
#line 1872
    goto switch_default;
    case_60: /* CIL Label */ 
#line 377
    if (! inquotes) {
#line 378
      if (intag) {
#line 379
        if (! incomment) {
#line 379
          if (! inxmlheader) {
            {
#line 382
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"XML error: Nested angle brackets in %s, line %d!\n",
                    filename, linecount);
#line 384
            exit(1);
            }
          }
        }
      } else {
#line 392
        intag = 1;
#line 393
        if ((unsigned long )(scan + 3) < (unsigned long )(*data + datalength)) {
#line 394
          if ((int const   )*(scan + 1) == 33) {
#line 394
            if ((int const   )*(scan + 2) == 45) {
#line 394
              if ((int const   )*(scan + 3) == 45) {
#line 396
                incomment = 1;
#line 397
                tagtype = 0;
#line 398
                if (debug) {
                  {
#line 398
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Start of a comment\n");
                  }
                }
              }
            }
          }
        }
#line 401
        if (! incomment) {
#line 402
          tagnamefound = 0;
#line 403
          tagtype = 1;
#line 404
          lasttag = scan;
        }
      }
    }
#line 408
    goto switch_break;
    case_10: /* CIL Label */ 
#line 410
    linecount ++;
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_62: /* CIL Label */ 
    case_47: /* CIL Label */ 
#line 417
    if (! inquotes) {
#line 418
      if (intag) {
#line 419
        if (! incomment) {
#line 420
          if (intagword) {
#line 421
            intagword = 0;
#line 422
            if (! tagnamefound) {
              {
#line 423
              tagnamefound = 1;
#line 424
              memmove((void *)(currtagname), (void const   *)tagwordstart, (size_t )(scan - tagwordstart));
#line 425
              currtagname[scan - tagwordstart] = (char )'\000';
              }
#line 426
              if (debug) {
                {
#line 427
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Tag Name: \'%s\'\n",
                        currtagname);
                }
              }
              {
#line 429
              if (operation == 0) {
#line 429
                goto case_0;
              }
#line 491
              if (operation == 1) {
#line 491
                goto case_1;
              }
#line 537
              if (operation == 2) {
#line 537
                goto case_2;
              }
#line 651
              if (operation == 3) {
#line 651
                goto case_3;
              }
#line 694
              if (operation == 4) {
#line 694
                goto case_4;
              }
#line 428
              goto switch_break___0;
              case_0: /* CIL Label */ 
              {
#line 431
              if ((int )currtagname[0] == 109) {
#line 431
                goto case_109;
              }
#line 436
              if ((int )currtagname[0] == 97) {
#line 436
                goto case_97;
              }
#line 439
              if ((int )currtagname[0] == 100) {
#line 439
                goto case_100;
              }
#line 452
              if ((int )currtagname[0] == 105) {
#line 452
                goto case_105;
              }
#line 455
              if ((int )currtagname[0] == 112) {
#line 455
                goto case_112;
              }
#line 487
              if ((int )currtagname[0] == 108) {
#line 487
                goto case_108;
              }
#line 430
              goto switch_break___1;
              case_109: /* CIL Label */ 
              {
#line 431
              tmp___1 = strcmp((char const   *)(currtagname), "make");
              }
#line 431
              if (tmp___1 == 0) {
#line 432
                inmake = nestinglevel + 1;
              } else {
                {
#line 433
                tmp___0 = strcmp((char const   *)(currtagname), "model");
                }
#line 433
                if (tmp___0 == 0) {
#line 434
                  inmodel = nestinglevel + 1;
                }
              }
#line 435
              goto switch_break___1;
              case_97: /* CIL Label */ 
              {
#line 436
              tmp___2 = strcmp((char const   *)(currtagname), "autodetect");
              }
#line 436
              if (tmp___2 == 0) {
#line 437
                inautodetect = nestinglevel + 1;
              }
#line 438
              goto switch_break___1;
              case_100: /* CIL Label */ 
              {
#line 439
              tmp___4 = strcmp((char const   *)(currtagname), "driver");
              }
#line 439
              if (tmp___4 == 0) {
#line 440
                indriver = nestinglevel + 1;
#line 441
                if (indrivers) {
#line 442
                  if (tagtype == 1) {
#line 443
                    if (debug) {
                      {
#line 444
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Resetting Driver.\n");
                      }
                    }
#line 446
                    cid[0] = (char )'\000';
                  }
                }
              } else {
                {
#line 449
                tmp___3 = strcmp((char const   *)(currtagname), "drivers");
                }
#line 449
                if (tmp___3 == 0) {
#line 450
                  indrivers = nestinglevel + 1;
                }
              }
#line 451
              goto switch_break___1;
              case_105: /* CIL Label */ 
              {
#line 452
              tmp___5 = strcmp((char const   *)(currtagname), "id");
              }
#line 452
              if (tmp___5 == 0) {
#line 453
                inid = nestinglevel + 1;
              }
#line 454
              goto switch_break___1;
              case_112: /* CIL Label */ 
              {
#line 455
              tmp___8 = strcmp((char const   *)(currtagname), "printer");
              }
#line 455
              if (tmp___8 == 0) {
#line 456
                inprinter = nestinglevel + 1;
#line 457
                if (tagtype == 1) {
#line 459
                  inxmlheader = 0;
#line 460
                  nestinglevel = 1;
#line 462
                  if (debug) {
                    {
#line 463
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Removing XML file header\n");
                    }
                  }
                  {
#line 465
                  memmove((void *)*data, (void const   *)lasttag, (size_t )(((*data + datalength) + 1) - (char *)lasttag));
#line 467
                  datalength = (int )((long )datalength - (lasttag - (char const   *)*data));
#line 468
                  scan -= lasttag - (char const   *)*data;
#line 469
                  tagwordstart -= lasttag - (char const   *)*data;
#line 470
                  lasttag = (char const   *)*data;
#line 471
                  lasttagend = (char const   *)((void *)0);
                  }
                }
              } else {
                {
#line 473
                tmp___7 = strcmp((char const   *)(currtagname), "postscript");
                }
#line 473
                if (tmp___7 == 0) {
#line 474
                  inpostscript = nestinglevel + 1;
#line 475
                  if (inlang) {
#line 476
                    if (tagtype == 1) {
#line 477
                      if (debug) {
                        {
#line 478
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Resetting Driver/PPD.\n");
                        }
                      }
#line 480
                      cid[0] = (char )'\000';
#line 481
                      cppd[0] = (char )'\000';
                    }
                  }
                } else {
                  {
#line 484
                  tmp___6 = strcmp((char const   *)(currtagname), "ppd");
                  }
#line 484
                  if (tmp___6 == 0) {
#line 485
                    inppd = nestinglevel + 1;
                  }
                }
              }
#line 486
              goto switch_break___1;
              case_108: /* CIL Label */ 
              {
#line 487
              tmp___9 = strcmp((char const   *)(currtagname), "lang");
              }
#line 487
              if (tmp___9 == 0) {
#line 488
                inlang = nestinglevel + 1;
              }
#line 489
              goto switch_break___1;
              switch_break___1: /* CIL Label */ ;
              }
#line 490
              goto switch_break___0;
              case_1: /* CIL Label */ 
              {
#line 492
              tmp___15 = strcmp((char const   *)(currtagname), "printer");
              }
#line 492
              if (tmp___15 == 0) {
#line 493
                inprinter = nestinglevel + 1;
#line 494
                if (tagtype == 1) {
#line 494
                  lastprinter = (char *)lasttag;
                }
              } else {
                {
#line 495
                tmp___14 = strcmp((char const   *)(currtagname), "execution");
                }
#line 495
                if (tmp___14 == 0) {
#line 496
                  inexecution = nestinglevel + 1;
                } else {
                  {
#line 497
                  tmp___13 = strcmp((char const   *)(currtagname), "nopjl");
                  }
#line 497
                  if (tmp___13 == 0) {
#line 498
                    innopjl = nestinglevel + 1;
#line 499
                    if (inexecution) {
#line 500
                      *nopjl = 1;
#line 501
                      if (debug) {
                        {
#line 502
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      <nopjl /> found, driver does not allow PJL options!\n");
                        }
                      }
                    }
                  } else {
                    {
#line 506
                    tmp___12 = strcmp((char const   *)(currtagname), "id");
                    }
#line 506
                    if (tmp___12 == 0) {
#line 507
                      inid = nestinglevel + 1;
                    } else {
                      {
#line 508
                      tmp___11 = strcmp((char const   *)(currtagname), "printers");
                      }
#line 508
                      if (tmp___11 == 0) {
#line 509
                        inprinters = nestinglevel + 1;
#line 510
                        if (tagtype == 1) {
#line 514
                          lastprinters = (char *)lasttagend + 1;
#line 515
                          printerentry[0] = (char )'\000';
                        }
                      } else {
                        {
#line 517
                        tmp___10 = strcmp((char const   *)(currtagname), "driver");
                        }
#line 517
                        if (tmp___10 == 0) {
#line 518
                          indriver = nestinglevel + 1;
#line 519
                          if (tagtype == 1) {
#line 521
                            inxmlheader = 0;
#line 522
                            nestinglevel = 1;
#line 524
                            if (debug) {
                              {
#line 525
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Removing XML file header\n");
                              }
                            }
                            {
#line 527
                            memmove((void *)*data, (void const   *)lasttag, (size_t )(((*data + datalength) + 1) - (char *)lasttag));
#line 529
                            datalength = (int )((long )datalength - (lasttag - (char const   *)*data));
#line 530
                            scan -= lasttag - (char const   *)*data;
#line 531
                            tagwordstart -= lasttag - (char const   *)*data;
#line 532
                            lasttag = (char const   *)*data;
#line 533
                            lasttagend = (char const   *)((void *)0);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
#line 536
              goto switch_break___0;
              case_2: /* CIL Label */ 
              {
#line 539
              if ((int )currtagname[0] == 109) {
#line 539
                goto case_109___0;
              }
#line 544
              if ((int )currtagname[0] == 100) {
#line 544
                goto case_100___0;
              }
#line 547
              if ((int )currtagname[0] == 112) {
#line 547
                goto case_112___0;
              }
#line 550
              if ((int )currtagname[0] == 97) {
#line 550
                goto case_97___0;
              }
#line 587
              if ((int )currtagname[0] == 101) {
#line 587
                goto case_101___0;
              }
#line 604
              if ((int )currtagname[0] == 99) {
#line 604
                goto case_99;
              }
#line 627
              if ((int )currtagname[0] == 111) {
#line 627
                goto case_111;
              }
#line 538
              goto switch_break___2;
              case_109___0: /* CIL Label */ 
              {
#line 539
              tmp___17 = strcmp((char const   *)(currtagname + 1), "make" + 1);
              }
#line 539
              if (tmp___17 == 0) {
#line 540
                inmake = nestinglevel + 1;
              } else {
                {
#line 541
                tmp___16 = strcmp((char const   *)(currtagname + 1), "model" + 1);
                }
#line 541
                if (tmp___16 == 0) {
#line 542
                  inmodel = nestinglevel + 1;
                }
              }
#line 543
              goto switch_break___2;
              case_100___0: /* CIL Label */ 
              {
#line 544
              tmp___18 = strcmp((char const   *)(currtagname + 1), "driver" + 1);
              }
#line 544
              if (tmp___18 == 0) {
#line 545
                indriver = nestinglevel + 1;
              }
#line 546
              goto switch_break___2;
              case_112___0: /* CIL Label */ 
              {
#line 547
              tmp___19 = strcmp((char const   *)(currtagname + 1), "printer" + 1);
              }
#line 547
              if (tmp___19 == 0) {
#line 548
                inprinter = nestinglevel + 1;
              }
#line 549
              goto switch_break___2;
              case_97___0: /* CIL Label */ 
              {
#line 551
              tmp___26 = strncmp((char const   *)(currtagname), "arg_", (size_t )4);
              }
#line 551
              if (! tmp___26) {
                {
#line 553
                if ((int )currtagname[4] == 100) {
#line 553
                  goto case_100___1;
                }
#line 556
                if ((int )currtagname[4] == 115) {
#line 556
                  goto case_115;
                }
#line 559
                if ((int )currtagname[4] == 101) {
#line 559
                  goto case_101;
                }
#line 562
                if ((int )currtagname[4] == 112) {
#line 562
                  goto case_112___1;
                }
#line 582
                if ((int )currtagname[4] == 109) {
#line 582
                  goto case_109___1;
                }
#line 552
                goto switch_break___3;
                case_100___1: /* CIL Label */ 
                {
#line 553
                tmp___20 = strcmp((char const   *)(currtagname + 5), "defval" + 1);
                }
#line 553
                if (tmp___20 == 0) {
#line 554
                  inargdefault = nestinglevel + 1;
                }
#line 555
                goto switch_break___3;
                case_115: /* CIL Label */ 
                {
#line 556
                tmp___21 = strcmp((char const   *)(currtagname + 5), "shortname" + 1);
                }
#line 556
                if (tmp___21 == 0) {
#line 557
                  inargshortname = nestinglevel + 1;
                }
#line 558
                goto switch_break___3;
                case_101: /* CIL Label */ 
                {
#line 559
                tmp___22 = strcmp((char const   *)(currtagname + 5), "execution" + 1);
                }
#line 559
                if (tmp___22 == 0) {
#line 560
                  inargexecution = nestinglevel + 1;
                }
#line 561
                goto switch_break___3;
                case_112___1: /* CIL Label */ 
                {
#line 563
                tmp___23 = strcmp((char const   *)(currtagname + 5), "pjl" + 1);
                }
#line 563
                if (tmp___23 == 0) {
#line 565
                  inargpjl = nestinglevel + 1;
#line 566
                  if (inargexecution) {
#line 568
                    if (*nopjl) {
                      {
#line 571
                      free((void *)*data);
#line 572
                      *data = (char *)((void *)0);
                      }
#line 573
                      if (debug) {
                        {
#line 574
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Driver does not allow PJL options and this is a PJL option -->\n    Option does not apply!\n");
                        }
                      }
#line 578
                      return (comboconfirmed);
                    }
                  }
                }
#line 581
                goto switch_break___3;
                case_109___1: /* CIL Label */ 
                {
#line 582
                tmp___25 = strcmp((char const   *)(currtagname + 5), "max" + 1);
                }
#line 582
                if (tmp___25 == 0) {
#line 583
                  inargmax = nestinglevel + 1;
                } else {
                  {
#line 584
                  tmp___24 = strcmp((char const   *)(currtagname + 5), "min" + 1);
                  }
#line 584
                  if (tmp___24 == 0) {
#line 585
                    inargmin = nestinglevel + 1;
                  }
                }
                switch_break___3: /* CIL Label */ ;
                }
              }
#line 586
              goto switch_break___2;
              case_101___0: /* CIL Label */ 
              {
#line 587
              tmp___29 = strcmp((char const   *)(currtagname + 1), "ev_shortname" + 1);
              }
#line 587
              if (tmp___29 == 0) {
#line 588
                inevshortname = nestinglevel + 1;
              } else {
                {
#line 589
                tmp___28 = strcmp((char const   *)(currtagname + 1), "en" + 1);
                }
#line 589
                if (tmp___28 == 0) {
#line 590
                  inen = nestinglevel + 1;
                } else {
                  {
#line 591
                  tmp___27 = strcmp((char const   *)(currtagname + 1), "enum_val" + 1);
                  }
#line 591
                  if (tmp___27 == 0) {
#line 592
                    inenumval = nestinglevel + 1;
#line 593
                    if (tagtype == 1) {
#line 596
                      enumvalqualified = 1;
#line 597
                      enumvaltoberemoved = 0;
#line 601
                      lastenumval = (char *)lasttagend + 1;
                    }
                  }
                }
              }
#line 603
              goto switch_break___2;
              case_99: /* CIL Label */ 
              {
#line 604
              tmp___31 = strcmp((char const   *)(currtagname + 1), "constraints" + 1);
              }
#line 604
              if (tmp___31 == 0) {
#line 605
                inconstraints = nestinglevel + 1;
#line 606
                if (tagtype == 1) {
#line 608
                  printerhiscore = 0;
#line 609
                  driverhiscore = 0;
#line 613
                  lastconstraints = (char *)lasttagend + 1;
                }
              } else {
                {
#line 615
                tmp___30 = strcmp((char const   *)(currtagname), "constraint");
                }
#line 615
                if (tmp___30 == 0) {
#line 616
                  inconstraint = nestinglevel + 1;
#line 617
                  if (tagtype == 1) {
#line 619
                    cprinter[0] = (char )'\000';
#line 620
                    cmake[0] = (char )'\000';
#line 621
                    cmodel[0] = (char )'\000';
#line 622
                    cdriver[0] = (char )'\000';
#line 623
                    cargdefault[0] = (char )'\000';
#line 624
                    csense = 0;
                  }
                }
              }
#line 626
              goto switch_break___2;
              case_111: /* CIL Label */ 
              {
#line 627
              tmp___32 = strcmp((char const   *)(currtagname + 1), "option" + 1);
              }
#line 627
              if (tmp___32 == 0) {
#line 628
                inoption = nestinglevel + 1;
#line 631
                if (tagtype == -1) {
#line 631
                  lastoption = (char *)lasttagend + 1;
                }
#line 632
                if (tagtype == 1) {
#line 634
                  inxmlheader = 0;
#line 635
                  nestinglevel = 1;
#line 636
                  argdefault[0] = (char )'\000';
#line 638
                  if (debug) {
                    {
#line 639
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Removing XML file header\n");
                    }
                  }
                  {
#line 641
                  memmove((void *)*data, (void const   *)lasttag, (size_t )(((*data + datalength) + 1) - (char *)lasttag));
#line 643
                  datalength = (int )((long )datalength - (lasttag - (char const   *)*data));
#line 644
                  scan -= lasttag - (char const   *)*data;
#line 645
                  tagwordstart -= lasttag - (char const   *)*data;
#line 646
                  lasttag = (char const   *)*data;
#line 647
                  lasttagend = (char const   *)((void *)0);
                  }
                }
              }
#line 649
              goto switch_break___2;
              switch_break___2: /* CIL Label */ ;
              }
#line 650
              goto switch_break___0;
              case_3: /* CIL Label */ 
              {
#line 652
              tmp___40 = strcmp((char const   *)(currtagname), "printer");
              }
#line 652
              if (tmp___40 == 0) {
#line 653
                inprinter = nestinglevel + 1;
#line 654
                if (tagtype == 1) {
#line 655
                  cprinter[0] = (char )'\000';
#line 656
                  dfunctionalityentry[0] = (char )'\000';
                }
              } else {
                {
#line 658
                tmp___39 = strcmp((char const   *)(currtagname), "id");
                }
#line 658
                if (tmp___39 == 0) {
#line 659
                  inid = nestinglevel + 1;
                } else {
                  {
#line 660
                  tmp___38 = strcmp((char const   *)(currtagname), "functionality");
                  }
#line 660
                  if (tmp___38 == 0) {
#line 661
                    indfunctionality = nestinglevel + 1;
#line 662
                    if (tagtype == 1) {
#line 662
                      lastdfunctionality = (char *)lasttag;
                    }
                  } else {
                    {
#line 663
                    tmp___37 = strcmp((char const   *)(currtagname), "execution");
                    }
#line 663
                    if (tmp___37 == 0) {
#line 664
                      inexecution = nestinglevel + 1;
                    } else {
                      {
#line 665
                      tmp___36 = strcmp((char const   *)(currtagname), "prototype");
                      }
#line 665
                      if (tmp___36 == 0) {
#line 666
                        inprototype = nestinglevel + 1;
#line 667
                        if (tagtype == 1) {
#line 667
                          lastprototype = (char *)lasttagend + 1;
                        }
                      } else {
                        {
#line 668
                        tmp___35 = strcmp((char const   *)(currtagname), "printers");
                        }
#line 668
                        if (tmp___35 == 0) {
#line 669
                          inprinters = nestinglevel + 1;
#line 670
                          if (tagtype == 1) {
#line 670
                            lastprinters = (char *)lasttagend + 1;
                          }
                        } else {
                          {
#line 671
                          tmp___34 = strcmp((char const   *)(currtagname), "comments");
                          }
#line 671
                          if (tmp___34 == 0) {
#line 672
                            incomments = nestinglevel + 1;
#line 673
                            if (tagtype == 1) {
#line 673
                              lastcomments = (char *)lasttagend + 1;
                            }
                          } else {
                            {
#line 674
                            tmp___33 = strcmp((char const   *)(currtagname), "driver");
                            }
#line 674
                            if (tmp___33 == 0) {
#line 675
                              indriver = nestinglevel + 1;
#line 676
                              if (tagtype == 1) {
#line 678
                                inxmlheader = 0;
#line 679
                                nestinglevel = 1;
#line 681
                                if (debug) {
                                  {
#line 682
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Removing XML file header\n");
                                  }
                                }
                                {
#line 684
                                memmove((void *)*data, (void const   *)lasttag, (size_t )(((*data + datalength) + 1) - (char *)lasttag));
#line 686
                                datalength = (int )((long )datalength - (lasttag - (char const   *)*data));
#line 687
                                scan -= lasttag - (char const   *)*data;
#line 688
                                tagwordstart -= lasttag - (char const   *)*data;
#line 689
                                lasttag = (char const   *)*data;
#line 690
                                lasttagend = (char const   *)((void *)0);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
#line 693
              goto switch_break___0;
              case_4: /* CIL Label */ 
#line 695
              if (debug) {
                {
#line 696
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     Printer XML (Overview): Tag name: %s\n",
                        currtagname);
                }
              }
              {
#line 699
              tmp___52 = strcmp((char const   *)(currtagname), "make");
              }
#line 699
              if (tmp___52 == 0) {
#line 700
                inmake = nestinglevel + 1;
              } else {
                {
#line 701
                tmp___51 = strcmp((char const   *)(currtagname), "model");
                }
#line 701
                if (tmp___51 == 0) {
#line 702
                  inmodel = nestinglevel + 1;
                } else {
                  {
#line 703
                  tmp___50 = strcmp((char const   *)(currtagname), "functionality");
                  }
#line 703
                  if (tmp___50 == 0) {
#line 704
                    infunctionality = nestinglevel + 1;
                  } else {
                    {
#line 705
                    tmp___49 = strcmp((char const   *)(currtagname), "unverified");
                    }
#line 705
                    if (tmp___49 == 0) {
#line 706
                      inunverified = nestinglevel + 1;
#line 707
                      cunverified = 1;
                    } else {
                      {
#line 708
                      tmp___48 = strcmp((char const   *)(currtagname), "driver");
                      }
#line 708
                      if (tmp___48 == 0) {
#line 709
                        indriver = nestinglevel + 1;
#line 710
                        if (indrivers) {
#line 711
                          if (tagtype == 1) {
#line 712
                            if (debug) {
                              {
#line 713
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Resetting Driver/PPD.\n");
                              }
                            }
#line 715
                            cid[0] = (char )'\000';
#line 716
                            cppd[0] = (char )'\000';
                          }
                        }
                      } else {
                        {
#line 719
                        tmp___47 = strcmp((char const   *)(currtagname), "drivers");
                        }
#line 719
                        if (tmp___47 == 0) {
#line 720
                          indrivers = nestinglevel + 1;
                        } else {
                          {
#line 721
                          tmp___46 = strcmp((char const   *)(currtagname), "id");
                          }
#line 721
                          if (tmp___46 == 0) {
#line 722
                            inid = nestinglevel + 1;
                          } else {
                            {
#line 723
                            tmp___45 = strcmp((char const   *)(currtagname), "ppd");
                            }
#line 723
                            if (tmp___45 == 0) {
#line 724
                              inppd = nestinglevel + 1;
                            } else {
                              {
#line 725
                              tmp___44 = strcmp((char const   *)(currtagname), "lang");
                              }
#line 725
                              if (tmp___44 == 0) {
#line 726
                                inlang = nestinglevel + 1;
                              } else {
                                {
#line 727
                                tmp___43 = strcmp((char const   *)(currtagname), "postscript");
                                }
#line 727
                                if (tmp___43 == 0) {
#line 728
                                  inpostscript = nestinglevel + 1;
#line 729
                                  if (inlang) {
#line 730
                                    if (tagtype == 1) {
#line 731
                                      if (debug) {
                                        {
#line 732
                                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Resetting Driver/PPD.\n");
                                        }
                                      }
#line 734
                                      cid[0] = (char )'\000';
#line 735
                                      cppd[0] = (char )'\000';
                                    }
                                  }
                                } else {
                                  {
#line 738
                                  tmp___42 = strcmp((char const   *)(currtagname),
                                                    "autodetect");
                                  }
#line 738
                                  if (tmp___42 == 0) {
#line 739
                                    inautodetect = nestinglevel + 1;
#line 740
                                    if (tagtype == 1) {
#line 740
                                      lastautodetect = (char *)lasttag;
                                    }
                                  } else {
                                    {
#line 741
                                    tmp___41 = strcmp((char const   *)(currtagname),
                                                      "printer");
                                    }
#line 741
                                    if (tmp___41 == 0) {
#line 742
                                      inprinter = nestinglevel + 1;
#line 743
                                      if (tagtype == 1) {
#line 745
                                        inxmlheader = 0;
#line 746
                                        nestinglevel = 1;
#line 748
                                        if (debug) {
                                          {
#line 749
                                          fprintf((FILE */* __restrict  */)stderr,
                                                  (char const   */* __restrict  */)"    Removing XML file header\n");
                                          }
                                        }
                                        {
#line 751
                                        memmove((void *)*data, (void const   *)lasttag,
                                                (size_t )(((*data + datalength) + 1) - (char *)lasttag));
#line 753
                                        datalength = (int )((long )datalength - (lasttag - (char const   *)*data));
#line 754
                                        scan -= lasttag - (char const   *)*data;
#line 755
                                        tagwordstart -= lasttag - (char const   *)*data;
#line 756
                                        lasttag = (char const   *)*data;
#line 757
                                        lasttagend = (char const   *)((void *)0);
                                        }
#line 758
                                        if (debug) {
                                          {
#line 758
                                          fprintf((FILE */* __restrict  */)stderr,
                                                  (char const   */* __restrict  */)"    Initializing PPD list.\n");
                                          }
                                        }
                                        {
#line 760
                                        while (1) {
                                          while_continue___0: /* CIL Label */ ;
#line 760
                                          if (! ((unsigned long )ppdlist != (unsigned long )((void *)0))) {
#line 760
                                            goto while_break___0;
                                          }
                                          {
#line 761
                                          ppdlistpointer = ppdlist;
#line 762
                                          ppdlist = (ppdlist_t *)ppdlist->next;
#line 763
                                          free((void *)ppdlistpointer);
                                          }
                                        }
                                        while_break___0: /* CIL Label */ ;
                                        }
#line 765
                                        if (debug) {
                                          {
#line 765
                                          fprintf((FILE */* __restrict  */)stderr,
                                                  (char const   */* __restrict  */)"    Initializing fields.\n");
                                          }
                                        }
#line 767
                                        cprinter[0] = (char )'\000';
#line 768
                                        cmake[0] = (char )'\000';
#line 769
                                        cmodel[0] = (char )'\000';
#line 770
                                        cfunctionality[0] = (char )'\000';
#line 771
                                        cunverified = 0;
#line 772
                                        cdriver[0] = (char )'\000';
#line 773
                                        cautodetectentry[0] = (char )'\000';
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
#line 776
              goto switch_break___0;
              switch_break___0: /* CIL Label */ ;
              }
            } else {
              {
#line 778
              memmove((void *)(currtagparam), (void const   *)tagwordstart, (size_t )(scan - tagwordstart));
#line 779
              currtagparam[scan - tagwordstart] = (char )'\000';
              }
#line 780
              if (debug) {
                {
#line 780
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Tag parameter: \'%s\'\n",
                        currtagparam);
                }
              }
#line 783
              if (operation == 2) {
                {
#line 784
                tmp___62 = strcmp((char const   *)(currtagname), "constraint");
                }
#line 784
                if (tmp___62 == 0) {
                  {
#line 786
                  s = strstr((char const   *)(currtagparam), "sense");
                  }
#line 786
                  if ((unsigned long )s != (unsigned long )((void *)0)) {
                    {
#line 787
                    tmp___54 = strstr((char const   *)(s + 5), "true");
                    }
#line 787
                    if ((unsigned long )tmp___54 != (unsigned long )((void *)0)) {
#line 788
                      csense = 1;
                    } else {
                      {
#line 789
                      tmp___53 = strstr((char const   *)(s + 5), "false");
                      }
#line 789
                      if ((unsigned long )tmp___53 != (unsigned long )((void *)0)) {
#line 790
                        csense = 0;
                      }
                    }
                  }
                } else {
                  {
#line 793
                  tmp___61 = strcmp((char const   *)(currtagname), "option");
                  }
#line 793
                  if (tmp___61 == 0) {
                    {
#line 794
                    s = strstr((char const   *)(currtagparam), "type");
                    }
#line 794
                    if ((unsigned long )s != (unsigned long )((void *)0)) {
                      {
#line 795
                      tmp___58 = strstr((char const   *)(s + 4), "enum");
                      }
#line 795
                      if ((unsigned long )tmp___58 != (unsigned long )((void *)0)) {
#line 799
                        numenumvals = 0;
#line 800
                        optiontype = 0;
                      } else {
                        {
#line 801
                        tmp___57 = strstr((char const   *)(s + 4), "bool");
                        }
#line 801
                        if ((unsigned long )tmp___57 != (unsigned long )((void *)0)) {
#line 802
                          optiontype = 1;
                        } else {
                          {
#line 803
                          tmp___56 = strstr((char const   *)(s + 4), "int");
                          }
#line 803
                          if ((unsigned long )tmp___56 != (unsigned long )((void *)0)) {
#line 804
                            optiontype = 2;
                          } else {
                            {
#line 805
                            tmp___55 = strstr((char const   *)(s + 4), "float");
                            }
#line 805
                            if ((unsigned long )tmp___55 != (unsigned long )((void *)0)) {
#line 806
                              optiontype = 3;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    {
#line 809
                    tmp___60 = strcmp((char const   *)(currtagname), "enum_val");
                    }
#line 809
                    if (tmp___60 == 0) {
                      {
#line 810
                      s = strstr((char const   *)(currtagparam), "id");
                      }
#line 810
                      if ((unsigned long )s != (unsigned long )((void *)0)) {
                        {
#line 812
                        strcpy((char */* __restrict  */)(currevid), (char const   */* __restrict  */)(s + 4));
#line 813
                        tmp___59 = strlen((char const   *)(currevid));
#line 813
                        currevid[tmp___59 - 1UL] = (char )'\000';
                        }
#line 814
                        if (debug) {
                          {
#line 815
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Enum value ID: \'%s\'\n",
                                  currevid);
                          }
                        }
                      }
                    }
                  }
                }
              } else
#line 820
              if (operation == 3) {
                {
#line 821
                tmp___65 = strcmp((char const   *)(currtagname), "driver");
                }
#line 821
                if (tmp___65 == 0) {
                  {
#line 822
                  s = strstr((char const   *)(currtagparam), "id");
                  }
#line 822
                  if ((unsigned long )s != (unsigned long )((void *)0)) {
                    {
#line 824
                    tmp___63 = strstr((char const   *)(s + 2), "driver/");
#line 824
                    s = tmp___63 + 7;
#line 826
                    tmp___64 = strlen((char const   *)s);
#line 826
                    *(s + (tmp___64 - 1UL)) = (char )'\000';
#line 827
                    strcpy((char */* __restrict  */)(cdriver), (char const   */* __restrict  */)s);
                    }
                  }
                }
              } else
#line 830
              if (operation == 4) {
#line 831
                if (debug) {
                  {
#line 832
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Printer XML file (overview): Tag name: %s, Tag param:%s\n",
                          currtagname, currtagparam);
                  }
                }
                {
#line 835
                tmp___67 = strcmp((char const   *)(currtagname), "printer");
                }
#line 835
                if (tmp___67 == 0) {
                  {
#line 836
                  s = strstr((char const   *)(currtagparam), "id");
                  }
#line 836
                  if ((unsigned long )s != (unsigned long )((void *)0)) {
                    {
#line 838
                    s = strstr((char const   *)(s + 2), "printer/");
                    }
#line 838
                    if ((unsigned long )s != (unsigned long )((void *)0)) {
                      {
#line 839
                      s += 8;
#line 841
                      tmp___66 = strlen((char const   *)s);
#line 841
                      *(s + (tmp___66 - 1UL)) = (char )'\000';
#line 842
                      strcpy((char */* __restrict  */)(cprinter), (char const   */* __restrict  */)s);
                      }
                    }
                  }
                }
              }
            }
          }
#line 849
          if ((int const   )*scan == 47) {
#line 850
            if (tagnamefound) {
#line 852
              tagtype = 0;
            } else {
#line 854
              tagtype = -1;
            }
#line 856
            if (debug) {
              {
#line 857
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    End of tag, tag type %d (0: no body, -1: with body)\n",
                      tagtype);
              }
            }
          }
        }
#line 862
        if ((int const   )*scan == 62) {
#line 863
          if (incomment) {
#line 864
            if ((int const   )*(scan - 2) == 45) {
#line 864
              if ((int const   )*(scan - 1) == 45) {
#line 865
                incomment = 0;
#line 866
                intag = 0;
#line 867
                if (debug) {
                  {
#line 867
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    End comment\n");
                  }
                }
              }
            }
          } else {
#line 870
            intag = 0;
#line 871
            if (! inxmlheader) {
#line 871
              if (tagnamefound == 0) {
                {
#line 872
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"XML error: Tag without name %s, line %d!\n",
                        filename, linecount);
#line 874
                exit(1);
                }
              }
            }
#line 876
            if ((unsigned long )lasttagend != (unsigned long )((void *)0)) {
              {
#line 877
              memmove((void *)(currtagbody), (void const   *)(lasttagend + 1), (size_t )((lasttag - lasttagend) - 1L));
#line 878
              currtagbody[(lasttag - lasttagend) - 1L] = (char )'\000';
              }
#line 879
              if (debug) {
                {
#line 880
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Contents of tag body: \'%s\'\n",
                        currtagbody);
                }
              }
            }
#line 883
            nestinglevel += tagtype;
#line 886
            if (operation == 0) {
#line 888
              if (nestinglevel < inprinter) {
#line 888
                inprinter = 0;
              }
#line 889
              if (nestinglevel < inmake) {
#line 890
                inmake = 0;
#line 892
                if (! inautodetect) {
                  {
#line 892
                  strcat((char */* __restrict  */)(make), (char const   */* __restrict  */)(currtagbody));
                  }
                }
              }
#line 894
              if (nestinglevel < inmodel) {
#line 895
                inmodel = 0;
#line 897
                if (! inautodetect) {
                  {
#line 897
                  strcat((char */* __restrict  */)(model), (char const   */* __restrict  */)(currtagbody));
                  }
                }
              }
#line 899
              if (nestinglevel < inautodetect) {
#line 899
                inautodetect = 0;
              }
#line 900
              if (nestinglevel < indrivers) {
#line 900
                indrivers = 0;
              }
#line 901
              if (nestinglevel < indriver) {
#line 902
                indriver = 0;
#line 903
                if (indrivers) {
#line 904
                  if (debug) {
                    {
#line 904
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Printer/Driver: %s %s\n",
                            pid, cid);
                    }
                  }
#line 907
                  if ((int )cid[0] != 0) {
#line 908
                    if (debug) {
                      {
#line 909
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Printer XML: Printer: %s Driver: %s\n",
                              pid, cid);
                      }
                    }
                    {
#line 912
                    tmp___68 = strcmp((char const   *)(cid), driver);
                    }
#line 912
                    if (! tmp___68) {
#line 915
                      if (debug) {
                        {
#line 916
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Printer XML: Printer/Driver combo confirmed by <drivers> section!\n");
                        }
                      }
#line 918
                      comboconfirmed = 1;
                    }
                  }
                }
              }
#line 923
              if (cppd[0]) {
                {
#line 923
                strcpy((char */* __restrict  */)(cid), (char const   */* __restrict  */)"Postscript");
                }
              }
#line 924
              if (nestinglevel < inid) {
                {
#line 925
                inid = 0;
#line 926
                strcpy((char */* __restrict  */)(cid), (char const   */* __restrict  */)(currtagbody));
                }
#line 927
                if (debug) {
                  {
#line 927
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Printer XML: Driver ID: %s\n",
                          cid);
                  }
                }
              }
#line 930
              if (nestinglevel < inlang) {
#line 930
                inlang = 0;
              }
#line 931
              if (nestinglevel < inpostscript) {
#line 932
                inpostscript = 0;
#line 933
                if (inlang) {
#line 934
                  if (debug) {
                    {
#line 934
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Printer/Driver/PPD: %s %s %s\n",
                            cprinter, cid, cppd);
                    }
                  }
                }
                {
#line 938
                tmp___69 = strcmp((char const   *)(cid), driver);
                }
#line 938
                if (! tmp___69) {
#line 941
                  if (debug) {
                    {
#line 942
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Printer XML: Printer/Driver combo confirmed by <postscript> section!\n");
                    }
                  }
#line 944
                  comboconfirmed = 1;
                }
              }
#line 947
              if (nestinglevel < inppd) {
#line 948
                inppd = 0;
#line 951
                s = currtagbody;
                {
#line 951
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 951
                  if ((int )*s != 0) {
                    {
#line 951
                    tmp___70 = strchr(" \n\r\t", (int )*s);
                    }
#line 951
                    if (! ((unsigned long )tmp___70 != (unsigned long )((void *)0))) {
#line 951
                      goto while_break___1;
                    }
                  } else {
#line 951
                    goto while_break___1;
                  }
#line 951
                  s ++;
                }
                while_break___1: /* CIL Label */ ;
                }
                {
#line 954
                strcpy((char */* __restrict  */)(cppd), (char const   */* __restrict  */)s);
                }
#line 955
                if (debug) {
                  {
#line 955
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    PPD URL: %s\n",
                          cppd);
                  }
                }
              }
            } else
#line 959
            if (operation == 1) {
#line 961
              if (nestinglevel < inexecution) {
#line 961
                inexecution = 0;
              }
#line 962
              if (nestinglevel < innopjl) {
#line 962
                innopjl = 0;
              }
#line 963
              if (nestinglevel < indriver) {
#line 963
                indriver = 0;
              }
#line 964
              if (nestinglevel < inprinters) {
#line 965
                inprinters = 0;
#line 967
                if ((unsigned long )lastprinters != (unsigned long )((void *)0)) {
#line 968
                  if (debug) {
                    {
#line 969
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Removing <printers> block\n");
                    }
                  }
                  {
#line 970
                  memmove((void *)lastprinters, (void const   *)(scan + 1), (size_t )((*data + datalength) - (char *)scan));
#line 972
                  datalength = (int )((long )datalength - ((scan + 1) - (char const   *)lastprinters));
#line 973
                  scan = (char const   *)(lastprinters - 1);
                  }
#line 974
                  if (debug) {
                    {
#line 975
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Inserting saved printer\n");
                    }
                  }
                  {
#line 976
                  tmp___71 = strlen((char const   *)(printerentry));
#line 976
                  l = (int )tmp___71;
                  }
#line 977
                  if (l != 0) {
                    {
#line 978
                    memmove((void *)(lastprinters + l), (void const   *)lastprinters,
                            (size_t )(((*data + datalength) - lastprinters) + 1L));
#line 980
                    memmove((void *)lastprinters, (void const   *)(printerentry),
                            (size_t )l);
#line 981
                    datalength += l;
#line 982
                    scan += l;
                    }
                  }
                }
              }
#line 986
              if (nestinglevel < inprinter) {
#line 987
                inprinter = 0;
#line 988
                if (printertobesaved) {
#line 991
                  printertobesaved = 0;
#line 992
                  if ((unsigned long )lastprinter != (unsigned long )((void *)0)) {
#line 993
                    if (debug) {
                      {
#line 993
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Saving printer\n");
                      }
                    }
                    {
#line 994
                    strcat((char */* __restrict  */)(printerentry), (char const   */* __restrict  */)"\n <printers>\n  ");
#line 995
                    tmp___72 = strlen((char const   *)(printerentry));
#line 995
                    l = (int )tmp___72;
#line 996
                    memmove((void *)(printerentry + l), (void const   *)lastprinter,
                            (size_t )((scan + 1) - (char const   *)lastprinter));
#line 998
                    printerentry[((scan + l) + 1) - (char const   *)lastprinter] = (char )'\000';
#line 999
                    strcat((char */* __restrict  */)(printerentry), (char const   */* __restrict  */)"\n </printers>");
                    }
#line 1000
                    if (debug) {
                      {
#line 1000
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Printer entry %s\n",
                              printerentry);
                      }
                    }
                  }
                }
              }
#line 1005
              if (nestinglevel < inid) {
                {
#line 1006
                inid = 0;
#line 1009
                tmp___73 = translateid((char const   *)(currtagbody + 8), idlist);
#line 1009
                tmp___74 = strcmp((char const   *)trpid, (char const   *)tmp___73);
                }
#line 1009
                if (tmp___74 == 0) {
#line 1012
                  printerentryfound = 1;
#line 1013
                  printertobesaved = 1;
#line 1014
                  if (debug) {
                    {
#line 1014
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Found printer\n");
                    }
                  }
                } else
#line 1016
                if (debug) {
                  {
#line 1016
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Other printer\n");
                  }
                }
              }
            } else
#line 1020
            if (operation == 2) {
#line 1022
              if (debug) {
                {
#line 1022
                tmp___75 = strcmp((char const   *)(currtagname), "constraint");
                }
#line 1022
                if (tmp___75 == 0) {
#line 1022
                  if (tagtype == -1) {
                    {
#line 1024
                    j ++;
#line 1025
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Constraint %d: %s\n",
                            j, filename);
                    }
                  }
                }
              }
#line 1027
              if (nestinglevel < inen) {
#line 1028
                inen = 0;
#line 1029
                if (inargshortname) {
#line 1032
                  if (debug) {
                    {
#line 1033
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Option short name: \'%s\'\n",
                            currtagbody);
                    }
                  }
#line 1036
                  k = 0;
                  {
#line 1036
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 1036
                    if (! (k < num_defaultsettings)) {
#line 1036
                      goto while_break___2;
                    }
                    {
#line 1038
                    tmp___92 = strstr(*(defaultsettings + k), (char const   *)(currtagbody));
                    }
#line 1038
                    if ((unsigned long )tmp___92 == (unsigned long )*(defaultsettings + k)) {
                      {
#line 1038
                      tmp___93 = strlen((char const   *)(currtagbody));
                      }
#line 1038
                      if ((int const   )*(*(defaultsettings + k) + tmp___93) == 61) {
                        {
#line 1042
                        tmp___76 = strlen((char const   *)(currtagbody));
#line 1042
                        s = (char *)((*(defaultsettings + k) + tmp___76) + 1);
#line 1044
                        userdefault = 1;
                        }
                        {
#line 1046
                        if (optiontype == 1) {
#line 1046
                          goto case_1___0;
                        }
#line 1063
                        if (optiontype == 2) {
#line 1063
                          goto case_2___0;
                        }
#line 1068
                        if (optiontype == 3) {
#line 1068
                          goto case_3___0;
                        }
#line 1045
                        goto switch_break___4;
                        case_1___0: /* CIL Label */ 
                        {
#line 1048
                        tmp___82 = strcasecmp((char const   *)s, "true");
                        }
#line 1048
                        if (tmp___82 == 0) {
#line 1052
                          s = (char *)"1";
                        } else {
                          {
#line 1048
                          tmp___83 = strcasecmp((char const   *)s, "yes");
                          }
#line 1048
                          if (tmp___83 == 0) {
#line 1052
                            s = (char *)"1";
                          } else {
                            {
#line 1048
                            tmp___84 = strcasecmp((char const   *)s, "on");
                            }
#line 1048
                            if (tmp___84 == 0) {
#line 1052
                              s = (char *)"1";
                            } else {
                              {
#line 1053
                              tmp___79 = strcasecmp((char const   *)s, "false");
                              }
#line 1053
                              if (tmp___79 == 0) {
#line 1057
                                s = (char *)"0";
                              } else {
                                {
#line 1053
                                tmp___80 = strcasecmp((char const   *)s, "no");
                                }
#line 1053
                                if (tmp___80 == 0) {
#line 1057
                                  s = (char *)"0";
                                } else {
                                  {
#line 1053
                                  tmp___81 = strcasecmp((char const   *)s, "off");
                                  }
#line 1053
                                  if (tmp___81 == 0) {
#line 1057
                                    s = (char *)"0";
                                  } else {
                                    {
#line 1058
                                    tmp___77 = strcasecmp((char const   *)s, "0");
                                    }
#line 1058
                                    if (tmp___77 != 0) {
                                      {
#line 1058
                                      tmp___78 = strcasecmp((char const   *)s, "1");
                                      }
#line 1058
                                      if (tmp___78 != 0) {
#line 1061
                                        userdefault = 0;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
#line 1062
                        goto switch_break___4;
                        case_2___0: /* CIL Label */ 
                        {
#line 1065
                        tmp___85 = strspn((char const   *)s, "+-0123456789");
#line 1065
                        tmp___86 = strlen((char const   *)s);
                        }
#line 1065
                        if (tmp___85 < tmp___86) {
#line 1066
                          userdefault = 0;
                        }
#line 1067
                        goto switch_break___4;
                        case_3___0: /* CIL Label */ 
                        {
#line 1070
                        tmp___87 = strspn((char const   *)s, "+-0123456789.eE");
#line 1070
                        tmp___88 = strlen((char const   *)s);
                        }
#line 1070
                        if (tmp___87 < tmp___88) {
#line 1071
                          userdefault = 0;
                        }
#line 1072
                        goto switch_break___4;
                        switch_break___4: /* CIL Label */ ;
                        }
                        {
#line 1073
                        strcpy((char */* __restrict  */)(userdefaultvalue), (char const   */* __restrict  */)s);
                        }
#line 1074
                        if (debug) {
#line 1074
                          if (userdefault) {
                            {
#line 1075
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      User default setting: \'%s\'\n",
                                    userdefaultvalue);
                            }
                          }
                        }
                      } else {
#line 1038
                        goto _L___0;
                      }
                    } else {
                      _L___0: /* CIL Label */ 
                      {
#line 1080
                      tmp___91 = strcmp(*(defaultsettings + k), (char const   *)(currtagbody));
                      }
#line 1080
                      if (tmp___91 == 0) {
#line 1080
                        if (optiontype == 1) {
                          {
#line 1084
                          strcpy((char */* __restrict  */)(userdefaultvalue), (char const   */* __restrict  */)"1");
#line 1085
                          userdefault = 1;
                          }
#line 1086
                          if (debug) {
                            {
#line 1087
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      User default setting: \'%s\'\n",
                                    userdefaultvalue);
                            }
                          }
                        } else {
#line 1080
                          goto _L;
                        }
                      } else {
                        _L: /* CIL Label */ 
                        {
#line 1092
                        tmp___89 = strcmp(*(defaultsettings + k) + 2, (char const   *)(currtagbody));
                        }
#line 1092
                        if (tmp___89 == 0) {
                          {
#line 1092
                          tmp___90 = strncasecmp(*(defaultsettings + k), "no", (size_t )2);
                          }
#line 1092
                          if (tmp___90 == 0) {
#line 1092
                            if (optiontype == 1) {
                              {
#line 1098
                              strcpy((char */* __restrict  */)(userdefaultvalue),
                                     (char const   */* __restrict  */)"0");
#line 1099
                              userdefault = 1;
                              }
#line 1100
                              if (debug) {
                                {
#line 1101
                                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      User default setting: \'%s\'\n",
                                        userdefaultvalue);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
#line 1036
                    k ++;
                  }
                  while_break___2: /* CIL Label */ ;
                  }
                } else
#line 1108
                if (inevshortname) {
#line 1113
                  if (debug) {
                    {
#line 1114
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Enum value short name: \'%s\'\n",
                            currtagbody);
                    }
                  }
#line 1117
                  if (userdefault) {
                    {
#line 1117
                    tmp___94 = strcmp((char const   *)(userdefaultvalue), (char const   *)(currtagbody));
                    }
#line 1117
                    if (tmp___94 == 0) {
                      {
#line 1120
                      strcpy((char */* __restrict  */)(userdefaultid), (char const   */* __restrict  */)(currevid));
#line 1121
                      userdefaultfound = 1;
                      }
#line 1122
                      if (debug) {
                        {
#line 1123
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      User default setting found!\n");
                        }
                      }
                    }
                  }
                }
              }
#line 1129
              if (nestinglevel < inargmax) {
#line 1130
                inargmax = 0;
#line 1131
                if (optiontype == 2) {
#line 1131
                  goto _L___1;
                } else
#line 1131
                if (optiontype == 3) {
                  _L___1: /* CIL Label */ 
                  {
#line 1134
                  maxnumvalue = atof((char const   *)(currtagbody));
                  }
#line 1135
                  if (userdefault) {
                    {
#line 1135
                    tmp___95 = atof((char const   *)(userdefaultvalue));
                    }
#line 1135
                    if (tmp___95 > maxnumvalue) {
#line 1139
                      userdefault = 0;
                    }
                  }
#line 1140
                  if (debug) {
                    {
#line 1141
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Maximum value: %s\n",
                            currtagbody);
                    }
                  }
                }
              }
#line 1147
              if (nestinglevel < inargmin) {
#line 1148
                inargmin = 0;
#line 1149
                if (optiontype == 2) {
#line 1149
                  goto _L___2;
                } else
#line 1149
                if (optiontype == 3) {
                  _L___2: /* CIL Label */ 
                  {
#line 1152
                  minnumvalue = atof((char const   *)(currtagbody));
                  }
#line 1153
                  if (userdefault) {
                    {
#line 1156
                    tmp___96 = atof((char const   *)(userdefaultvalue));
                    }
#line 1156
                    if (tmp___96 < minnumvalue) {
#line 1157
                      userdefault = 0;
                    }
                  }
#line 1160
                  if (debug) {
                    {
#line 1161
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Minimum value: %s\n",
                            currtagbody);
                    }
                  }
                }
              }
#line 1167
              if (nestinglevel < inargshortname) {
#line 1168
                inargshortname = 0;
              }
#line 1170
              if (nestinglevel < inargexecution) {
#line 1171
                inargexecution = 0;
              }
#line 1173
              if (nestinglevel < inargpjl) {
#line 1174
                inargpjl = 0;
              }
#line 1176
              if (nestinglevel < inevshortname) {
#line 1177
                inevshortname = 0;
              }
#line 1179
              if (nestinglevel < inprinter) {
#line 1180
                inprinter = 0;
#line 1181
                if (inconstraint) {
#line 1183
                  if ((int )currtagbody[0] == 112) {
                    {
#line 1184
                    strcat((char */* __restrict  */)(cprinter), (char const   */* __restrict  */)(currtagbody + 8));
                    }
                  } else {
                    {
#line 1186
                    strcat((char */* __restrict  */)(cprinter), (char const   */* __restrict  */)(currtagbody));
                    }
                  }
                }
              }
#line 1190
              if (nestinglevel < inmake) {
#line 1191
                inmake = 0;
#line 1192
                if (inconstraint) {
                  {
#line 1192
                  strcat((char */* __restrict  */)(cmake), (char const   */* __restrict  */)(currtagbody));
                  }
                }
              }
#line 1194
              if (nestinglevel < inmodel) {
#line 1195
                inmodel = 0;
#line 1196
                if (inconstraint) {
                  {
#line 1196
                  strcat((char */* __restrict  */)(cmodel), (char const   */* __restrict  */)(currtagbody));
                  }
                }
              }
#line 1198
              if (nestinglevel < indriver) {
#line 1199
                indriver = 0;
#line 1200
                if (inconstraint) {
                  {
#line 1200
                  strcat((char */* __restrict  */)(cdriver), (char const   */* __restrict  */)(currtagbody));
                  }
                }
              }
#line 1202
              if (nestinglevel < inargdefault) {
#line 1203
                inargdefault = 0;
#line 1204
                if (inconstraint) {
                  {
#line 1204
                  strcat((char */* __restrict  */)(cargdefault), (char const   */* __restrict  */)(currtagbody));
                  }
                }
              }
#line 1206
              if (nestinglevel < inconstraint) {
#line 1207
                inconstraint = 0;
#line 1209
                if (debug) {
                  {
#line 1210
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Evaluation of constraint\n");
#line 1211
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Values given in constraint:\n");
#line 1212
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        make: |%s|, model: |%s|, printer: |%s|\n",
                          cmake, cmodel, cprinter);
#line 1214
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        driver: |%s|, argdefault: |%s|, sense: |%d|\n",
                          cdriver, cargdefault, csense);
#line 1216
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Values of current printer/driver combo:\n");
#line 1217
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        make: |%s|, model: |%s|\n",
                          make, model);
#line 1219
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        PID: |%s|, driver: |%s|\n",
                          pid, driver);
                  }
                }
#line 1222
                if (cmake[0]) {
#line 1222
                  goto _L___8;
                } else
#line 1222
                if (cmodel[0]) {
#line 1222
                  goto _L___8;
                } else
#line 1222
                if (cprinter[0]) {
#line 1222
                  goto _L___8;
                } else
#line 1222
                if (cdriver[0]) {
                  _L___8: /* CIL Label */ 
#line 1227
                  if (cmake[0]) {
#line 1227
                    goto _L___7;
                  } else
#line 1227
                  if (cmodel[0]) {
                    _L___7: /* CIL Label */ 
#line 1227
                    if (cprinter[0]) {
                      {
#line 1229
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Both printer id and make/model in constraint in %s, line %d!\n",
                              filename, linecount);
                      }
                    } else {
#line 1227
                      goto _L___6;
                    }
                  } else {
                    _L___6: /* CIL Label */ 
#line 1232
                    if (debug) {
                      {
#line 1233
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Highest scores for printer: |%d|, driver: |%d|\n",
                              printerhiscore, driverhiscore);
                      }
                    }
#line 1240
                    printerscore = 0;
#line 1242
                    driverscore = 0;
#line 1245
                    if (cprinter[0]) {
#line 1246
                      if (debug) {
                        {
#line 1246
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        Checking PID\n");
                        }
                      }
                      {
#line 1247
                      tmp___97 = translateid((char const   *)(cprinter), idlist);
#line 1247
                      tmp___98 = strcmp((char const   *)tmp___97, (char const   *)trpid);
                      }
#line 1247
                      if (tmp___98 == 0) {
#line 1248
                        printerscore = 2;
                      } else {
#line 1250
                        printerscore = -1;
                      }
                    } else
#line 1251
                    if (cmake[0]) {
#line 1252
                      if (debug) {
                        {
#line 1252
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        Checking make\n");
                        }
                      }
                      {
#line 1255
                      tmp___100 = strcmp((char const   *)(cmake), (char const   *)(make));
                      }
#line 1255
                      if (tmp___100 == 0) {
#line 1256
                        printerscore = 1;
#line 1257
                        if (cmodel[0]) {
#line 1258
                          if (debug) {
                            {
#line 1259
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        Checking model\n");
                            }
                          }
                          {
#line 1260
                          tmp___99 = strcmp((char const   *)(cmodel), (char const   *)(model));
                          }
#line 1260
                          if (tmp___99 == 0) {
#line 1261
                            printerscore = 2;
                          } else {
#line 1263
                            printerscore = -1;
                          }
                        }
                      } else {
#line 1265
                        printerscore = -1;
                      }
                    }
#line 1269
                    if (cdriver[0]) {
#line 1270
                      if (debug) {
                        {
#line 1271
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        Checking driver\n");
                        }
                      }
                      {
#line 1272
                      tmp___101 = strcmp((char const   *)(cdriver), driver);
                      }
#line 1272
                      if (tmp___101 == 0) {
#line 1274
                        driverscore = 1;
                      } else {
                        {
#line 1272
                        tmp___102 = strcmp((char const   *)(cdriver + 7), driver);
                        }
#line 1272
                        if (tmp___102 == 0) {
#line 1274
                          driverscore = 1;
                        } else {
#line 1276
                          driverscore = -1;
                        }
                      }
                    }
#line 1278
                    if (debug) {
                      {
#line 1279
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Scores for this constraint: printer: |%d|, driver: |%d|\n",
                              printerscore, driverscore);
                      }
                    }
#line 1285
                    if (printerscore > 0) {
#line 1285
                      goto _L___5;
                    } else
#line 1285
                    if (driverscore > 0) {
                      _L___5: /* CIL Label */ 
#line 1285
                      if (printerscore > -1) {
#line 1285
                        if (driverscore > -1) {
#line 1287
                          if (debug) {
                            {
#line 1287
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Something matches\n");
                            }
                          }
#line 1290
                          if (printerscore >= printerhiscore) {
#line 1290
                            if (driverscore >= driverhiscore) {
#line 1290
                              goto _L___3;
                            } else {
#line 1290
                              goto _L___4;
                            }
                          } else
                          _L___4: /* CIL Label */ 
#line 1290
                          if (printerscore == 2) {
                            _L___3: /* CIL Label */ 
#line 1295
                            if (debug) {
                              {
#line 1296
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      This constraint wins\n");
                              }
                            }
#line 1298
                            if (printerscore > printerhiscore) {
#line 1299
                              printerhiscore = printerscore;
                            }
#line 1301
                            if (driverscore > driverhiscore) {
#line 1302
                              driverhiscore = driverscore;
                            }
#line 1305
                            if (inenumval) {
#line 1309
                              enumvalqualified = csense;
#line 1310
                              if (debug) {
                                {
#line 1311
                                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Enumeration choice qualifies? %d (0: No, 1: Yes)\n",
                                        enumvalqualified);
                                }
                              }
                            } else {
#line 1315
                              optionqualified = csense;
#line 1316
                              if (debug) {
                                {
#line 1317
                                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Option qualifies? %d (0: No, 1: Yes)\n",
                                        optionqualified);
                                }
                              }
                              {
#line 1323
                              strcpy((char */* __restrict  */)(argdefault), (char const   */* __restrict  */)(cargdefault));
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  {
#line 1224
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Illegal null constraint in %s, line %d!\n",
                          filename, linecount);
                  }
                }
              }
#line 1329
              if (nestinglevel < inconstraints) {
#line 1330
                inconstraints = 0;
#line 1333
                if (inenumval) {
#line 1334
                  if (debug) {
                    {
#line 1335
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    This enumeration value finally qualified? %d (0: No, 1: Yes)\n",
                            enumvalqualified);
                    }
                  }
#line 1338
                  if (! enumvalqualified) {
#line 1338
                    enumvaltoberemoved = 1;
                  }
                } else {
#line 1340
                  if (debug) {
                    {
#line 1341
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    This option finally qualified?  %d (0: No, 1: Yes)\n",
                            optionqualified);
                    }
                  }
#line 1344
                  if (! optionqualified) {
                    {
#line 1350
                    free((void *)*data);
#line 1351
                    *data = (char *)((void *)0);
                    }
#line 1352
                    if (debug) {
                      {
#line 1353
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Option does not apply!\n");
                      }
                    }
#line 1354
                    return (comboconfirmed);
                  }
                }
#line 1357
                if (debug) {
                  {
#line 1358
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Constr. for enum. value? %d, enum value disqualified? %d (0: No, 1: Yes)\n",
                          inenumval, enumvaltoberemoved);
                  }
                }
#line 1361
                if (! inenumval) {
#line 1361
                  goto _L___9;
                } else
#line 1361
                if (! enumvaltoberemoved) {
                  _L___9: /* CIL Label */ 
#line 1365
                  if ((unsigned long )lastconstraints != (unsigned long )((void *)0)) {
#line 1366
                    if (debug) {
                      {
#line 1367
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Removing constraints block\n");
                      }
                    }
                    {
#line 1368
                    memmove((void *)lastconstraints, (void const   *)(scan + 1), (size_t )((*data + datalength) - (char *)scan));
#line 1370
                    datalength = (int )((long )datalength - ((scan + 1) - (char const   *)lastconstraints));
#line 1371
                    scan = (char const   *)(lastconstraints - 1);
                    }
                  } else
#line 1373
                  if (debug) {
                    {
#line 1374
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    This enum value will be removed anyway, so constraints block does not  \n    need to be removed.\n");
                    }
                  }
                }
              }
#line 1378
              if (nestinglevel < inenumval) {
#line 1379
                inenumval = 0;
#line 1380
                if (debug) {
                  {
#line 1381
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    End of enumeration value block, to be removed? %d (0: No, 1: Yes)\n",
                          enumvaltoberemoved);
                  }
                }
#line 1384
                if (enumvaltoberemoved) {
#line 1387
                  if ((unsigned long )lastenumval != (unsigned long )((void *)0)) {
#line 1388
                    if (debug) {
                      {
#line 1388
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Removing enumeration value\n");
                      }
                    }
                    {
#line 1389
                    memmove((void *)lastenumval, (void const   *)(scan + 1), (size_t )((*data + datalength) - (char *)scan));
#line 1391
                    datalength = (int )((long )datalength - ((scan + 1) - (char const   *)lastenumval));
#line 1392
                    scan = (char const   *)(lastenumval - 1);
                    }
                  } else {
                    {
#line 1394
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Cannot remove this evaluation value.\n");
                    }
                  }
                } else {
#line 1398
                  numenumvals ++;
                }
              }
#line 1400
              if (nestinglevel < inoption) {
#line 1401
                inoption = 0;
#line 1402
                if (debug) {
                  {
#line 1403
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"End of option block:\n      No. of enum. values: %d, qualified by constraints? %d (0: No, 1: Yes)\n",
                          numenumvals, optionqualified);
                  }
                }
#line 1406
                if (! numenumvals) {
#line 1406
                  goto _L___10;
                } else
#line 1406
                if (! optionqualified) {
                  _L___10: /* CIL Label */ 
                  {
#line 1411
                  free((void *)*data);
#line 1412
                  *data = (char *)((void *)0);
                  }
#line 1413
                  if (debug) {
                    {
#line 1413
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    No enum. values, no constraints => Removing option!\n");
                    }
                  }
#line 1414
                  return (comboconfirmed);
                }
#line 1417
                if (argdefault[0]) {
#line 1417
                  goto _L___11;
                } else
#line 1417
                if (userdefault) {
                  _L___11: /* CIL Label */ 
#line 1418
                  if ((unsigned long )lastoption != (unsigned long )((void *)0)) {
#line 1419
                    if (debug) {
                      {
#line 1420
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Inserting default value\n");
                      }
                    }
#line 1422
                    if (userdefault) {
#line 1424
                      if (optiontype == 0) {
#line 1426
                        if (userdefaultfound) {
                          {
#line 1427
                          strcpy((char */* __restrict  */)(argdefault), (char const   */* __restrict  */)(userdefaultid));
                          }
                        }
                      } else {
#line 1431
                        if (! (optiontype == 1)) {
#line 1431
                          if (! (optiontype == 2)) {
#line 1431
                            if (! (optiontype == 3)) {
                              {
#line 1431
                              __assert_fail("+optiontype == +OPTION_TYPE_BOOL || +optiontype == +OPTION_TYPE_INT || +optiontype == +OPTION_TYPE_FLOAT",
                                            "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c",
                                            1433U, "parse");
                              }
                            }
                          }
                        }
                        {
#line 1434
                        strcpy((char */* __restrict  */)(argdefault), (char const   */* __restrict  */)(userdefaultvalue));
                        }
                      }
                    }
                    {
#line 1437
                    sprintf((char */* __restrict  */)(defaultline), (char const   */* __restrict  */)"\n  <arg_defval>%s</arg_defval>",
                            argdefault);
#line 1440
                    tmp___103 = strlen((char const   *)(defaultline));
#line 1440
                    defaultlinelength = (int )tmp___103;
#line 1441
                    memmove((void *)(lastoption + defaultlinelength), (void const   *)lastoption,
                            (size_t )(((*data + datalength) - lastoption) + 1L));
#line 1443
                    memmove((void *)lastoption, (void const   *)(defaultline), (size_t )defaultlinelength);
#line 1444
                    datalength += defaultlinelength;
#line 1445
                    scan += defaultlinelength;
                    }
#line 1446
                    if (debug) {
                      {
#line 1447
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Default value line: %s\n",
                              defaultline);
                      }
                    }
                  }
                }
              }
            } else
#line 1453
            if (operation == 3) {
#line 1455
              if (nestinglevel < indriver) {
#line 1455
                indriver = 0;
              }
#line 1456
              if (nestinglevel < inprinters) {
#line 1457
                inprinters = 0;
#line 1459
                if ((unsigned long )lastprinters != (unsigned long )((void *)0)) {
#line 1460
                  if (debug) {
                    {
#line 1461
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Removing <printers> block\n");
                    }
                  }
                  {
#line 1462
                  memmove((void *)lastprinters, (void const   *)(scan + 1), (size_t )((*data + datalength) - (char *)scan));
#line 1464
                  datalength = (int )((long )datalength - ((scan + 1) - (char const   *)lastprinters));
#line 1465
                  scan = (char const   *)(lastprinters - 1);
                  }
                }
              }
#line 1468
              if (nestinglevel < incomments) {
#line 1469
                incomments = 0;
#line 1471
                if ((unsigned long )lastcomments != (unsigned long )((void *)0)) {
#line 1471
                  if (! inprinter) {
#line 1473
                    if (debug) {
                      {
#line 1474
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Removing <comments> block\n");
                      }
                    }
                    {
#line 1475
                    memmove((void *)lastcomments, (void const   *)(scan + 1), (size_t )((*data + datalength) - (char *)scan));
#line 1477
                    datalength = (int )((long )datalength - ((scan + 1) - (char const   *)lastcomments));
#line 1478
                    scan = (char const   *)(lastcomments - 1);
                    }
                  }
                }
              }
#line 1481
              if (nestinglevel < inexecution) {
#line 1481
                inexecution = 0;
              }
#line 1482
              if (nestinglevel < inid) {
                {
#line 1483
                inid = 0;
#line 1485
                strcpy((char */* __restrict  */)(cprinter), (char const   */* __restrict  */)(currtagbody + 8));
#line 1486
                tmp___104 = translateid((char const   *)(cprinter), idlist);
#line 1486
                strcpy((char */* __restrict  */)(cprinter), (char const   */* __restrict  */)tmp___104);
                }
#line 1487
                if (debug) {
                  {
#line 1488
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Overview: Printer: %s Driver: %s\n",
                          cprinter, cdriver);
                  }
                }
              }
#line 1492
              if (nestinglevel < indfunctionality) {
#line 1494
                indfunctionality = 0;
#line 1497
                if ((unsigned long )lastdfunctionality != (unsigned long )((void *)0)) {
#line 1498
                  if (debug) {
                    {
#line 1498
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Saving <functionality> entry\n");
                    }
                  }
                  {
#line 1500
                  memmove((void *)(dfunctionalityentry), (void const   *)lastdfunctionality,
                          (size_t )((scan + 1) - (char const   *)lastdfunctionality));
#line 1502
                  dfunctionalityentry[(scan + 1) - (char const   *)lastdfunctionality] = (char )'\000';
                  }
#line 1503
                  if (debug) {
                    {
#line 1503
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    <functionality> entry: %s\n",
                            dfunctionalityentry);
                    }
                  }
                }
              }
#line 1508
              if (nestinglevel < inprinter) {
#line 1509
                inprinter = 0;
#line 1510
                if (debug) {
                  {
#line 1511
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Overview: Add driver %s to printer %s (%s)\n",
                          cdriver, cprinter, dfunctionalityentry);
                  }
                }
#line 1516
                plistpointer = *printerlist;
#line 1517
                plistpreventry = (printerlist_t *)((void *)0);
                {
#line 1519
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 1519
                  if ((unsigned long )plistpointer != (unsigned long )((void *)0)) {
                    {
#line 1519
                    tmp___105 = strcmp((char const   *)(plistpointer->id), (char const   *)(cprinter));
                    }
#line 1519
                    if (! (tmp___105 != 0)) {
#line 1519
                      goto while_break___3;
                    }
                  } else {
#line 1519
                    goto while_break___3;
                  }
#line 1522
                  plistpreventry = plistpointer;
#line 1523
                  plistpointer = (printerlist_t *)plistpointer->next;
                }
                while_break___3: /* CIL Label */ ;
                }
#line 1525
                if ((unsigned long )plistpointer == (unsigned long )((void *)0)) {
                  {
#line 1527
                  tmp___106 = malloc(sizeof(printerlist_t ));
#line 1527
                  plistpointer = (printerlist_t *)tmp___106;
#line 1529
                  strcpy((char */* __restrict  */)(plistpointer->id), (char const   */* __restrict  */)(cprinter));
#line 1530
                  plistpointer->drivers = (driverlist_t *)((void *)0);
#line 1531
                  plistpointer->next = (struct printerlist_t *)((void *)0);
                  }
#line 1532
                  if ((unsigned long )plistpreventry != (unsigned long )((void *)0)) {
#line 1533
                    plistpreventry->next = (struct printerlist_t *)plistpointer;
                  } else {
#line 1536
                    *printerlist = plistpointer;
                  }
                }
#line 1539
                dlistpointer = plistpointer->drivers;
#line 1540
                dlistpreventry = (driverlist_t *)((void *)0);
                {
#line 1541
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 1541
                  if (! ((unsigned long )dlistpointer != (unsigned long )((driverlist_t *)0))) {
#line 1541
                    goto while_break___4;
                  }
#line 1542
                  dlistpreventry = dlistpointer;
#line 1543
                  dlistpointer = (driverlist_t *)dlistpointer->next;
                }
                while_break___4: /* CIL Label */ ;
                }
                {
#line 1545
                tmp___107 = malloc(sizeof(driverlist_t ));
#line 1545
                dlistpointer = (driverlist_t *)tmp___107;
#line 1547
                strcpy((char */* __restrict  */)(dlistpointer->name), (char const   */* __restrict  */)(cdriver));
                }
#line 1548
                if ((unsigned long )(dfunctionalityentry) != (unsigned long )((void *)0)) {
#line 1548
                  if (dfunctionalityentry[0]) {
                    {
#line 1550
                    dlistpointer->functionality = strdup((char const   *)(dfunctionalityentry));
                    }
                  } else {
#line 1551
                    dlistpointer->functionality = (char *)((void *)0);
                  }
                } else {
#line 1551
                  dlistpointer->functionality = (char *)((void *)0);
                }
#line 1552
                dlistpointer->next = (struct driverlist_t *)((void *)0);
#line 1553
                if ((unsigned long )dlistpreventry != (unsigned long )((void *)0)) {
#line 1554
                  dlistpreventry->next = (struct driverlist_t *)dlistpointer;
                } else {
#line 1557
                  plistpointer->drivers = dlistpointer;
                }
              }
#line 1559
              if (nestinglevel < inprototype) {
#line 1560
                inprototype = 0;
#line 1561
                if (pid) {
#line 1569
                  s = currtagbody;
                  {
#line 1569
                  while (1) {
                    while_continue___5: /* CIL Label */ ;
#line 1569
                    if ((int )*s != 0) {
                      {
#line 1569
                      tmp___108 = strchr(" \n\r\t", (int )*s);
                      }
#line 1569
                      if (! ((unsigned long )tmp___108 != (unsigned long )((void *)0))) {
#line 1569
                        goto while_break___5;
                      }
                    } else {
#line 1569
                      goto while_break___5;
                    }
#line 1569
                    s ++;
                  }
                  while_break___5: /* CIL Label */ ;
                  }
#line 1572
                  if (debug) {
                    {
#line 1573
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Overview: Driver: %s Command line: |%s|\n",
                            cdriver, s);
                    }
                  }
#line 1576
                  if ((int )*s != 0) {
#line 1579
                    driverhasproto = 1;
#line 1582
                    plistpointer = *printerlist;
#line 1583
                    plistpreventry = (printerlist_t *)((void *)0);
#line 1584
                    dlistpointer = plistpointer->drivers;
#line 1585
                    dlistpreventry = (driverlist_t *)((void *)0);
                    {
#line 1586
                    while (1) {
                      while_continue___6: /* CIL Label */ ;
#line 1586
                      if ((unsigned long )dlistpointer != (unsigned long )((driverlist_t *)0)) {
                        {
#line 1586
                        tmp___109 = strcasecmp((char const   *)(dlistpointer->name),
                                               (char const   *)(cdriver));
                        }
#line 1586
                        if (! tmp___109) {
#line 1586
                          goto while_break___6;
                        }
                      } else {
#line 1586
                        goto while_break___6;
                      }
#line 1588
                      dlistpreventry = dlistpointer;
#line 1589
                      dlistpointer = (driverlist_t *)dlistpointer->next;
                    }
                    while_break___6: /* CIL Label */ ;
                    }
#line 1591
                    if ((unsigned long )dlistpointer == (unsigned long )((driverlist_t *)0)) {
                      {
#line 1592
                      tmp___110 = malloc(sizeof(driverlist_t ));
#line 1592
                      dlistpointer = (driverlist_t *)tmp___110;
#line 1594
                      strcpy((char */* __restrict  */)(dlistpointer->name), (char const   */* __restrict  */)(cdriver));
#line 1595
                      dlistpointer->functionality = (char *)((void *)0);
#line 1596
                      dlistpointer->next = (struct driverlist_t *)((void *)0);
                      }
#line 1597
                      if ((unsigned long )dlistpreventry != (unsigned long )((void *)0)) {
#line 1598
                        dlistpreventry->next = (struct driverlist_t *)dlistpointer;
                      } else {
#line 1601
                        plistpointer->drivers = dlistpointer;
                      }
                    }
                  } else {
                    {
#line 1607
                    free((void *)*data);
#line 1608
                    *data = (char *)((void *)0);
                    }
#line 1609
                    if (debug) {
                      {
#line 1610
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Driver entry does not produce PPDs!\n");
                      }
                    }
#line 1611
                    return (comboconfirmed);
                  }
                }
#line 1615
                if ((unsigned long )lastprototype != (unsigned long )((void *)0)) {
#line 1616
                  if (debug) {
                    {
#line 1617
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Removing <prototype> block\n");
                    }
                  }
                  {
#line 1618
                  memmove((void *)lastprototype, (void const   *)(scan + 1), (size_t )((*data + datalength) - (char *)scan));
#line 1620
                  datalength = (int )((long )datalength - ((scan + 1) - (char const   *)lastprototype));
#line 1621
                  scan = (char const   *)(lastprototype - 1);
                  }
                }
              }
            } else
#line 1624
            if (operation == 4) {
#line 1625
              if (debug) {
                {
#line 1626
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Printer (Overview), tag name: %s, tag body: %s\n",
                        currtagname, currtagbody);
                }
              }
#line 1629
              if (nestinglevel < inprinter) {
#line 1629
                inprinter = 0;
              }
#line 1630
              if (nestinglevel < inmake) {
#line 1631
                inmake = 0;
#line 1633
                if (! inautodetect) {
                  {
#line 1633
                  strcpy((char */* __restrict  */)(cmake), (char const   */* __restrict  */)(currtagbody));
                  }
                }
              }
#line 1635
              if (nestinglevel < inmodel) {
#line 1636
                inmodel = 0;
#line 1638
                if (! inautodetect) {
                  {
#line 1638
                  strcpy((char */* __restrict  */)(cmodel), (char const   */* __restrict  */)(currtagbody));
                  }
                }
              }
#line 1640
              if (nestinglevel < infunctionality) {
                {
#line 1641
                infunctionality = 0;
#line 1642
                strcpy((char */* __restrict  */)(cfunctionality), (char const   */* __restrict  */)(currtagbody));
                }
              }
#line 1644
              if (nestinglevel < inunverified) {
#line 1644
                inunverified = 0;
              }
#line 1645
              if (nestinglevel < indrivers) {
#line 1645
                indrivers = 0;
              }
#line 1646
              if (nestinglevel < inlang) {
#line 1646
                inlang = 0;
              }
#line 1647
              if (nestinglevel < indriver) {
#line 1647
                goto _L___17;
              } else
#line 1647
              if (nestinglevel < inpostscript) {
                _L___17: /* CIL Label */ 
#line 1649
                if (nestinglevel < indriver) {
#line 1649
                  indriver = 0;
                }
#line 1650
                if (nestinglevel < inpostscript) {
#line 1650
                  inpostscript = 0;
                }
#line 1651
                if (indrivers) {
#line 1651
                  goto _L___16;
                } else
#line 1651
                if (inlang) {
                  _L___16: /* CIL Label */ 
#line 1652
                  if (debug) {
                    {
#line 1652
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Printer/Driver/PPD: %s %s %s\n",
                            cprinter, cid, cppd);
                    }
                  }
#line 1655
                  driverhasproto = 0;
#line 1656
                  if ((int )cid[0] != 0) {
#line 1656
                    if (pid) {
#line 1660
                      plistpointer = *printerlist;
#line 1661
                      plistpreventry = (printerlist_t *)((void *)0);
#line 1662
                      dlistpointer = plistpointer->drivers;
#line 1663
                      dlistpreventry = (driverlist_t *)((void *)0);
                      {
#line 1664
                      while (1) {
                        while_continue___7: /* CIL Label */ ;
#line 1664
                        if ((unsigned long )dlistpointer != (unsigned long )((driverlist_t *)0)) {
                          {
#line 1664
                          tmp___111 = strcasecmp((char const   *)(dlistpointer->name),
                                                 (char const   *)(cid));
                          }
#line 1664
                          if (! tmp___111) {
#line 1664
                            goto while_break___7;
                          }
                        } else {
#line 1664
                          goto while_break___7;
                        }
#line 1666
                        dlistpreventry = dlistpointer;
#line 1667
                        dlistpointer = (driverlist_t *)dlistpointer->next;
                      }
                      while_break___7: /* CIL Label */ ;
                      }
#line 1669
                      if ((unsigned long )dlistpointer != (unsigned long )((driverlist_t *)0)) {
#line 1670
                        driverhasproto = 1;
                      }
                    }
                  }
#line 1673
                  if (debug) {
                    {
#line 1674
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Overview: Printer: %s Driver: %s Output mode: %s Driver has prototype: %d PPD: %s\n",
                            cprinter, cid, pid, driverhasproto, cppd);
                    }
                  }
#line 1677
                  if ((int )cid[0] != 0) {
#line 1678
                    if (! pid) {
#line 1678
                      goto _L___12;
                    } else
#line 1678
                    if (driverhasproto) {
#line 1678
                      if ((int )cppd[0] == 0) {
#line 1678
                        goto _L___12;
                      } else
#line 1678
                      if ((int const   )*(pid + 0) == 67) {
#line 1678
                        goto _L___12;
                      } else {
#line 1678
                        goto _L___14;
                      }
                    } else
                    _L___14: /* CIL Label */ 
#line 1678
                    if ((int )cppd[0] != 0) {
#line 1678
                      if ((int const   )*(pid + 0) == 67) {
                        _L___12: /* CIL Label */ 
#line 1695
                        if (debug) {
                          {
#line 1696
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Overview: Printer: %s Driver: %s: Adding driver to list\n",
                                  cprinter, cid);
                          }
                        }
#line 1699
                        plistpointer = *printerlist;
#line 1700
                        plistpreventry = (printerlist_t *)((void *)0);
                        {
#line 1702
                        while (1) {
                          while_continue___8: /* CIL Label */ ;
#line 1702
                          if ((unsigned long )plistpointer != (unsigned long )((void *)0)) {
                            {
#line 1702
                            tmp___112 = strcmp((char const   *)(plistpointer->id),
                                               (char const   *)(cprinter));
                            }
#line 1702
                            if (! (tmp___112 != 0)) {
#line 1702
                              goto while_break___8;
                            }
                          } else {
#line 1702
                            goto while_break___8;
                          }
#line 1704
                          plistpreventry = plistpointer;
#line 1705
                          plistpointer = (printerlist_t *)plistpointer->next;
                        }
                        while_break___8: /* CIL Label */ ;
                        }
#line 1707
                        if ((unsigned long )plistpointer == (unsigned long )((void *)0)) {
                          {
#line 1709
                          tmp___113 = malloc(sizeof(printerlist_t ));
#line 1709
                          plistpointer = (printerlist_t *)tmp___113;
#line 1711
                          strcpy((char */* __restrict  */)(plistpointer->id), (char const   */* __restrict  */)(cprinter));
#line 1712
                          plistpointer->drivers = (driverlist_t *)((void *)0);
#line 1713
                          plistpointer->next = (struct printerlist_t *)((void *)0);
                          }
#line 1714
                          if ((unsigned long )plistpreventry != (unsigned long )((void *)0)) {
#line 1715
                            plistpreventry->next = (struct printerlist_t *)plistpointer;
                          } else {
#line 1718
                            *printerlist = plistpointer;
                          }
                        }
#line 1721
                        dlistpointer = plistpointer->drivers;
#line 1722
                        dlistpreventry = (driverlist_t *)((void *)0);
                        {
#line 1723
                        while (1) {
                          while_continue___9: /* CIL Label */ ;
#line 1723
                          if ((unsigned long )dlistpointer != (unsigned long )((driverlist_t *)0)) {
                            {
#line 1723
                            tmp___114 = strcasecmp((char const   *)(dlistpointer->name),
                                                   (char const   *)(cid));
                            }
#line 1723
                            if (! tmp___114) {
#line 1723
                              goto while_break___9;
                            }
                          } else {
#line 1723
                            goto while_break___9;
                          }
#line 1725
                          dlistpreventry = dlistpointer;
#line 1726
                          dlistpointer = (driverlist_t *)dlistpointer->next;
                        }
                        while_break___9: /* CIL Label */ ;
                        }
#line 1728
                        if ((unsigned long )dlistpointer == (unsigned long )((driverlist_t *)0)) {
                          {
#line 1729
                          tmp___115 = malloc(sizeof(driverlist_t ));
#line 1729
                          dlistpointer = (driverlist_t *)tmp___115;
#line 1731
                          strcpy((char */* __restrict  */)(dlistpointer->name), (char const   */* __restrict  */)(cid));
#line 1732
                          dlistpointer->functionality = (char *)((void *)0);
#line 1733
                          dlistpointer->next = (struct driverlist_t *)((void *)0);
                          }
#line 1734
                          if ((unsigned long )dlistpreventry != (unsigned long )((void *)0)) {
#line 1735
                            dlistpreventry->next = (struct driverlist_t *)dlistpointer;
                          } else {
#line 1738
                            plistpointer->drivers = dlistpointer;
                          }
#line 1739
                          if (debug) {
                            {
#line 1740
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Overview: Driver successfully added to list.\n");
                            }
                          }
                        }
                      } else {
#line 1678
                        goto _L___13;
                      }
                    } else {
                      _L___13: /* CIL Label */ 
#line 1747
                      if (debug) {
                        {
#line 1748
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Overview: Printer: %s Driver: %s: Removing driver from list\n",
                                cprinter, cid);
                        }
                      }
#line 1751
                      plistpointer = *printerlist;
#line 1752
                      plistpreventry = (printerlist_t *)((void *)0);
                      {
#line 1754
                      while (1) {
                        while_continue___10: /* CIL Label */ ;
#line 1754
                        if ((unsigned long )plistpointer != (unsigned long )((void *)0)) {
                          {
#line 1754
                          tmp___116 = strcmp((char const   *)(plistpointer->id), (char const   *)(cprinter));
                          }
#line 1754
                          if (! (tmp___116 != 0)) {
#line 1754
                            goto while_break___10;
                          }
                        } else {
#line 1754
                          goto while_break___10;
                        }
#line 1756
                        plistpreventry = plistpointer;
#line 1757
                        plistpointer = (printerlist_t *)plistpointer->next;
                      }
                      while_break___10: /* CIL Label */ ;
                      }
#line 1761
                      if ((unsigned long )plistpointer != (unsigned long )((void *)0)) {
#line 1762
                        dlistpointer = plistpointer->drivers;
#line 1763
                        dlistpreventry = (driverlist_t *)((void *)0);
                        {
#line 1764
                        while (1) {
                          while_continue___11: /* CIL Label */ ;
#line 1764
                          if ((unsigned long )dlistpointer != (unsigned long )((void *)0)) {
                            {
#line 1764
                            tmp___117 = strcasecmp((char const   *)(dlistpointer->name),
                                                   (char const   *)(cid));
                            }
#line 1764
                            if (! tmp___117) {
#line 1764
                              goto while_break___11;
                            }
                          } else {
#line 1764
                            goto while_break___11;
                          }
#line 1766
                          dlistpreventry = dlistpointer;
#line 1767
                          dlistpointer = (driverlist_t *)dlistpointer->next;
                        }
                        while_break___11: /* CIL Label */ ;
                        }
#line 1770
                        if ((unsigned long )dlistpointer != (unsigned long )((void *)0)) {
                          {
#line 1771
                          dlistnextentry = (driverlist_t *)dlistpointer->next;
#line 1773
                          free((void *)dlistpointer);
                          }
#line 1774
                          if ((unsigned long )dlistpreventry != (unsigned long )((void *)0)) {
#line 1775
                            dlistpreventry->next = (struct driverlist_t *)dlistnextentry;
                          } else {
#line 1778
                            plistpointer->drivers = dlistnextentry;
                          }
#line 1779
                          if (debug) {
                            {
#line 1780
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Overview: Driver successfully removed from list.\n");
                            }
                          }
                        }
                      }
                    }
#line 1785
                    if ((int )cppd[0] != 0) {
#line 1786
                      if ((unsigned long )pid == (unsigned long )((void *)0)) {
#line 1786
                        goto _L___15;
                      } else
#line 1786
                      if ((int const   )*(pid + 0) == 67) {
                        _L___15: /* CIL Label */ 
#line 1789
                        if (debug) {
                          {
#line 1790
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Adding Driver/PPD to list.\n");
                          }
                        }
#line 1792
                        ppdlistpointer = ppdlist;
#line 1793
                        ppdlistpreventry = (ppdlist_t *)((void *)0);
#line 1794
                        if (debug) {
                          {
#line 1795
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Going through list: ");
                          }
                        }
                        {
#line 1797
                        while (1) {
                          while_continue___12: /* CIL Label */ ;
#line 1797
                          if (! ((unsigned long )ppdlistpointer != (unsigned long )((void *)0))) {
#line 1797
                            goto while_break___12;
                          }
#line 1798
                          ppdlistpreventry = ppdlistpointer;
#line 1799
                          ppdlistpointer = (ppdlist_t *)ppdlistpointer->next;
#line 1800
                          if (debug) {
                            {
#line 1801
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
                            }
                          }
                        }
                        while_break___12: /* CIL Label */ ;
                        }
                        {
#line 1804
                        tmp___118 = malloc(sizeof(ppdlist_t ));
#line 1804
                        ppdlistpointer = (ppdlist_t *)tmp___118;
#line 1806
                        strcpy((char */* __restrict  */)(ppdlistpointer->driver),
                               (char const   */* __restrict  */)(cid));
#line 1807
                        strcpy((char */* __restrict  */)(ppdlistpointer->ppd), (char const   */* __restrict  */)(cppd));
#line 1808
                        ppdlistpointer->next = (struct ppdlist_t *)((void *)0);
                        }
#line 1809
                        if ((unsigned long )ppdlistpreventry != (unsigned long )((void *)0)) {
#line 1810
                          ppdlistpreventry->next = (struct ppdlist_t *)ppdlistpointer;
                        } else {
#line 1813
                          ppdlist = ppdlistpointer;
                        }
#line 1814
                        if (debug) {
                          {
#line 1815
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Driver/PPD in list: %s %s\n",
                                  ppdlistpointer->driver, ppdlistpointer->ppd);
                          }
                        }
                      }
                    }
                  }
                } else {
                  {
#line 1822
                  strcpy((char */* __restrict  */)(cdriver), (char const   */* __restrict  */)(currtagbody));
                  }
                }
              }
#line 1824
              if (nestinglevel < inid) {
                {
#line 1825
                inid = 0;
#line 1826
                strcpy((char */* __restrict  */)(cid), (char const   */* __restrict  */)(currtagbody));
                }
#line 1827
                if (debug) {
                  {
#line 1827
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Driver ID for PPD: %s\n",
                          cid);
                  }
                }
              }
#line 1830
              if (nestinglevel < inppd) {
#line 1831
                inppd = 0;
#line 1834
                s = currtagbody;
                {
#line 1834
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 1834
                  if ((int )*s != 0) {
                    {
#line 1834
                    tmp___119 = strchr(" \n\r\t", (int )*s);
                    }
#line 1834
                    if (! ((unsigned long )tmp___119 != (unsigned long )((void *)0))) {
#line 1834
                      goto while_break___13;
                    }
                  } else {
#line 1834
                    goto while_break___13;
                  }
#line 1834
                  s ++;
                }
                while_break___13: /* CIL Label */ ;
                }
                {
#line 1837
                strcpy((char */* __restrict  */)(cppd), (char const   */* __restrict  */)s);
                }
#line 1838
                if (debug) {
                  {
#line 1838
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    PPD URL: %s\n",
                          cppd);
                  }
                }
              }
#line 1841
              if (nestinglevel < inautodetect) {
#line 1842
                inautodetect = 0;
#line 1845
                if ((unsigned long )lastautodetect != (unsigned long )((void *)0)) {
#line 1846
                  if (debug) {
                    {
#line 1846
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Saving <autodetect> entry\n");
                    }
                  }
                  {
#line 1848
                  memmove((void *)(cautodetectentry), (void const   *)lastautodetect,
                          (size_t )((scan + 1) - (char const   *)lastautodetect));
#line 1850
                  cautodetectentry[(scan + 1) - (char const   *)lastautodetect] = (char )'\000';
                  }
#line 1851
                  if (debug) {
                    {
#line 1851
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    <autodetect> entry: %s\n",
                            cautodetectentry);
                    }
                  }
                }
              }
            }
#line 1857
            lasttagend = scan;
#line 1858
            if (debug) {
              {
#line 1858
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    XML tag nesting level: %d\n",
                      nestinglevel);
              }
            }
          }
        }
      } else
#line 1864
      if ((int const   )*scan == 62) {

      }
    }
#line 1871
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1874
    if (intag) {
#line 1874
      if (! incomment) {
#line 1875
        if ((int const   )*scan == 39) {
#line 1875
          insinglequotes = 1 - insinglequotes;
        }
#line 1876
        if ((int const   )*scan == 34) {
#line 1876
          indoublequotes = 1 - indoublequotes;
        }
#line 1877
        if (insinglequotes) {
#line 1877
          inquotes = 1;
        } else
#line 1877
        if (indoublequotes) {
#line 1877
          inquotes = 1;
        } else {
#line 1878
          inquotes = 0;
        }
#line 1879
        if (! incomment) {
#line 1880
          if (! intagword) {
#line 1881
            intagword = 1;
#line 1882
            tagwordstart = scan;
          }
        }
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 374
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1888
  if (debug) {
    {
#line 1888
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    XML tag nesting level: %d\n",
            nestinglevel);
    }
  }
#line 1890
  if (debug) {
    {
#line 1890
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Lines of input: %d\n",
            linecount);
    }
  }
  {
#line 1893
  if (operation == 0) {
#line 1893
    goto case_0___0;
  }
#line 1902
  if (operation == 1) {
#line 1902
    goto case_1___1;
  }
#line 1914
  if (operation == 2) {
#line 1914
    goto case_2___1;
  }
#line 1917
  if (operation == 3) {
#line 1917
    goto case_3___1;
  }
#line 1962
  if (operation == 4) {
#line 1962
    goto case_4___0;
  }
#line 1891
  goto switch_break___5;
  case_0___0: /* CIL Label */ 
#line 1894
  if ((int )make[0] == 0) {
    {
#line 1896
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not determine manufacturer or model name from the printer file %s!\n",
            filename);
#line 1898
    exit(1);
    }
  } else
#line 1894
  if ((int )model[0] == 0) {
    {
#line 1896
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not determine manufacturer or model name from the printer file %s!\n",
            filename);
#line 1898
    exit(1);
    }
  }
#line 1900
  if (debug) {
    {
#line 1900
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Driver in printer\'s driver list: %d\n",
            comboconfirmed);
    }
  }
#line 1901
  goto switch_break___5;
  case_1___1: /* CIL Label */ 
#line 1903
  if (debug) {
    {
#line 1904
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    nopjl: %d (1: driver does not allow PJL options)\n",
            *nopjl);
    }
  }
#line 1907
  if (printerentryfound != 0) {
#line 1910
    comboconfirmed = 1;
  }
#line 1912
  if (debug) {
    {
#line 1912
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Printer in driver\'s printer list: %d\n",
            comboconfirmed);
    }
  }
#line 1913
  goto switch_break___5;
  case_2___1: /* CIL Label */ 
#line 1915
  if (debug) {
    {
#line 1915
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Resulting option XML:\n%s\n",
            *data);
    }
  }
#line 1916
  goto switch_break___5;
  case_3___1: /* CIL Label */ 
#line 1919
  if (pid) {
#line 1919
    if (driverhasproto == 0) {
      {
#line 1924
      free((void *)*data);
#line 1925
      *data = (char *)((void *)0);
#line 1928
      plistpointer = *printerlist;
#line 1929
      plistpreventry = (printerlist_t *)((void *)0);
      }
      {
#line 1931
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1931
        if (! ((unsigned long )plistpointer != (unsigned long )((void *)0))) {
#line 1931
          goto while_break___14;
        }
#line 1933
        dlistpointer = plistpointer->drivers;
#line 1934
        dlistpreventry = (driverlist_t *)((void *)0);
        {
#line 1935
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 1935
          if ((unsigned long )dlistpointer != (unsigned long )((void *)0)) {
            {
#line 1935
            tmp___120 = strcasecmp((char const   *)(dlistpointer->name), (char const   *)(cdriver));
            }
#line 1935
            if (! tmp___120) {
#line 1935
              goto while_break___15;
            }
          } else {
#line 1935
            goto while_break___15;
          }
#line 1938
          dlistpreventry = dlistpointer;
#line 1939
          dlistpointer = (driverlist_t *)dlistpointer->next;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 1942
        if ((unsigned long )dlistpointer != (unsigned long )((void *)0)) {
          {
#line 1944
          dlistnextentry = (driverlist_t *)dlistpointer->next;
#line 1946
          free((void *)dlistpointer);
          }
#line 1947
          if ((unsigned long )dlistpreventry != (unsigned long )((void *)0)) {
#line 1948
            dlistpreventry->next = (struct driverlist_t *)dlistnextentry;
          } else {
#line 1951
            plistpointer->drivers = dlistnextentry;
          }
        }
#line 1954
        plistpreventry = plistpointer;
#line 1955
        plistpointer = (printerlist_t *)plistpointer->next;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 1958
      if (debug) {
        {
#line 1959
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Driver entry does not produce PPDs!\n");
        }
      }
    }
  }
#line 1961
  goto switch_break___5;
  case_4___0: /* CIL Label */ 
#line 1965
  *(*data) = (char )'\000';
#line 1969
  if (debug) {
    {
#line 1969
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Data for this printer entry in the overview:\n      Printer ID: |%s|\n      Make: |%s|\n      Model: |%s|\n      Functionality: |%s|\n      Rec. driver: |%s|\n      Auto detect entry: |%s|\n",
            cprinter, cmake, cmodel, cfunctionality, cdriver, cautodetectentry);
    }
  }
#line 1971
  if (cprinter[0]) {
#line 1971
    if (cmake[0]) {
#line 1971
      if (cmodel[0]) {
#line 1971
        if (cfunctionality[0]) {
          {
#line 1973
          tmp___121 = translateid((char const   *)(cprinter), idlist);
#line 1973
          strcpy((char */* __restrict  */)(cprinter), (char const   */* __restrict  */)tmp___121);
#line 1974
          strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"  <printer>\n    <id>");
#line 1975
          strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)(cprinter));
#line 1976
          strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"</id>\n    <make>");
#line 1977
          strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)(cmake));
#line 1978
          strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"</make>\n    <model>");
#line 1979
          strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)(cmodel));
#line 1980
          strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"</model>\n    <functionality>");
#line 1981
          strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)(cfunctionality));
#line 1982
          strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"</functionality>\n");
          }
#line 1983
          if (cunverified) {
            {
#line 1984
            strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"    <unverified>");
#line 1985
            strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)(cfunctionality));
#line 1986
            strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"</unverified>\n");
            }
          }
#line 1988
          if (cdriver[0]) {
            {
#line 1989
            strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"    <driver>");
#line 1990
            strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)(cdriver));
#line 1991
            strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"</driver>\n");
            }
          }
#line 1993
          if (cautodetectentry[0]) {
            {
#line 1994
            strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"    ");
#line 1995
            strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)(cautodetectentry));
            }
          }
#line 1997
          plistpointer = *printerlist;
#line 1998
          plistpreventry = (printerlist_t *)((void *)0);
          {
#line 1999
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 1999
            if (plistpointer) {
              {
#line 1999
              tmp___122 = strcmp((char const   *)(plistpointer->id), (char const   *)(cprinter));
              }
#line 1999
              if (! (tmp___122 != 0)) {
#line 1999
                goto while_break___16;
              }
            } else {
#line 1999
              goto while_break___16;
            }
#line 2001
            plistpreventry = plistpointer;
#line 2002
            plistpointer = (printerlist_t *)plistpointer->next;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 2004
          if (plistpointer) {
            {
#line 2005
            strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"\n    <drivers>\n");
#line 2006
            dlistpointer = plistpointer->drivers;
#line 2007
            exceptionfound = 0;
            }
            {
#line 2008
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 2008
              if (! dlistpointer) {
#line 2008
                goto while_break___17;
              }
              {
#line 2009
              strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"      <driver>");
#line 2010
              strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)(dlistpointer->name));
#line 2011
              strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"</driver>\n");
              }
#line 2012
              if ((unsigned long )dlistpointer->functionality != (unsigned long )((void *)0)) {
#line 2012
                exceptionfound = 1;
              }
#line 2013
              dlistpointer = (driverlist_t *)dlistpointer->next;
            }
            while_break___17: /* CIL Label */ ;
            }
            {
#line 2015
            strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"    </drivers>\n");
            }
#line 2016
            if (exceptionfound) {
              {
#line 2017
              strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"    <driverfunctionalityexceptions>\n");
#line 2018
              dlistpointer = plistpointer->drivers;
              }
              {
#line 2019
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 2019
                if (! dlistpointer) {
#line 2019
                  goto while_break___18;
                }
#line 2020
                if ((unsigned long )(dlistpointer->name) != (unsigned long )((void *)0)) {
#line 2020
                  if ((unsigned long )dlistpointer->functionality != (unsigned long )((void *)0)) {
                    {
#line 2022
                    strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"      <driverfunctionalityexception>\n");
#line 2024
                    strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"        <driver>");
#line 2025
                    strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)(dlistpointer->name));
#line 2026
                    strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"</driver>\n");
#line 2027
                    strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)dlistpointer->functionality);
#line 2028
                    strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"\n      </driverfunctionalityexception>\n");
                    }
                  }
                }
#line 2031
                dlistpointer = (driverlist_t *)dlistpointer->next;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 2033
              strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"    </driverfunctionalityexceptions>\n");
              }
            }
#line 2040
            dlistpointer = plistpointer->drivers;
            {
#line 2041
            while (1) {
              while_continue___19: /* CIL Label */ ;
#line 2041
              if (! dlistpointer) {
#line 2041
                goto while_break___19;
              }
              {
#line 2042
              dlistpreventry = dlistpointer;
#line 2043
              dlistpointer = (driverlist_t *)dlistpointer->next;
#line 2044
              free((void *)dlistpreventry);
              }
            }
            while_break___19: /* CIL Label */ ;
            }
#line 2046
            if ((unsigned long )plistpreventry == (unsigned long )((void *)0)) {
#line 2047
              *printerlist = (printerlist_t *)plistpointer->next;
            } else {
#line 2049
              plistpreventry->next = plistpointer->next;
            }
            {
#line 2050
            free((void *)plistpointer);
            }
          }
#line 2052
          if ((unsigned long )ppdlist != (unsigned long )((void *)0)) {
            {
#line 2053
            strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"    <ppds>\n");
#line 2054
            ppdlistpointer = ppdlist;
            }
#line 2055
            if (debug) {
              {
#line 2056
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Going through list: ");
              }
            }
            {
#line 2058
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 2058
              if (! ppdlistpointer) {
#line 2058
                goto while_break___20;
              }
#line 2059
              if (debug) {
                {
#line 2060
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
                }
              }
              {
#line 2062
              strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"      <ppd>\n");
#line 2063
              strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"        <driver>");
#line 2064
              strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)(ppdlistpointer->driver));
#line 2065
              strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"</driver>\n        <ppdfile>");
#line 2066
              strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)(ppdlistpointer->ppd));
#line 2067
              strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"</ppdfile>\n");
#line 2068
              strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"      </ppd>\n");
#line 2069
              ppdlistpointer = (ppdlist_t *)ppdlistpointer->next;
              }
            }
            while_break___20: /* CIL Label */ ;
            }
            {
#line 2071
            strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"    </ppds>\n");
            }
          }
          {
#line 2073
          strcat((char */* __restrict  */)*data, (char const   */* __restrict  */)"  </printer>\n");
          }
        }
      }
    }
  }
#line 2075
  goto switch_break___5;
  switch_break___5: /* CIL Label */ ;
  }
#line 2076
  return (comboconfirmed);
}
}
#line 2083 "/home/june/repo/benchmarks/collector/temp/foomatic-db-engine-4.0.11/foomatic-combo-xml.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  char *t ;
  char const   *pid ;
  char const   *driver ;
  char const   *setting ;
  char const   *make___0 ;
  char const   *model___0 ;
  char const   *libdir ;
  char printerfilename[1024] ;
  char printerdirname[1024] ;
  char driverfilename[1024] ;
  char driverdirname[1024] ;
  char optionfilename[1024] ;
  char optiondirname[1024] ;
  char oldidfilename[1024] ;
  char *printerbuffer ;
  char *driverbuffer ;
  char **optbuffers ;
  int num_optbuffers ;
  char **defaultsettings ;
  int num_defaultsettings ;
  int overview ;
  int noreadymadeppds ;
  int nopjl ;
  int debug ;
  int debug2 ;
  int comboconfirmed ;
  int comboconfirmed2 ;
  int exceptionfound ;
  DIR *optiondir ;
  DIR *driverdir ;
  DIR *printerdir ;
  struct dirent *direntry ;
  printerlist_t *printerlist ;
  printerlist_t *plistpointer ;
  driverlist_t *dlistpointer ;
  printerlist_t *plistpreventry ;
  driverlist_t *dlistpreventry ;
  idlist_t *idlist ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
#line 2090
  pid = (char const   *)((void *)0);
#line 2090
  driver = (char const   *)((void *)0);
#line 2090
  setting = (char const   *)((void *)0);
#line 2094
  libdir = (char const   *)((void *)0);
#line 2107
  printerbuffer = (char *)((void *)0);
#line 2108
  driverbuffer = (char *)((void *)0);
#line 2109
  optbuffers = (char **)((void *)0);
#line 2110
  num_optbuffers = 0;
#line 2111
  defaultsettings = (char **)((void *)0);
#line 2112
  num_defaultsettings = 0;
#line 2113
  overview = 0;
#line 2114
  noreadymadeppds = 0;
#line 2115
  nopjl = 0;
#line 2116
  debug = 0;
#line 2117
  debug2 = 0;
#line 2118
  comboconfirmed = 0;
#line 2119
  comboconfirmed2 = 0;
#line 2120
  exceptionfound = 0;
#line 2125
  printerlist = (printerlist_t *)((void *)0);
#line 2135
  if (argc < 2) {
    {
#line 2136
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: foomatic-combo-xml [ -O ] [ -p printer -d driver ]\n                          [ -o option1=setting1 ] [ -o option2 ] [ -l dir ]\n                          [ -v | -vv ]\n");
#line 2137
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 2138
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -p printer   Foomatic ID of the printer\n");
#line 2139
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -d driver    Name of the driver to use\n");
#line 2140
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -o option1=setting1\n");
#line 2141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -o option2   Default option settings for the\n");
#line 2142
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                generated file\n");
#line 2143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -O           Generate overview XML file\n");
#line 2144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -C           Generate overview XML file only\n");
#line 2145
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                containing combos leading to a valid\n");
#line 2146
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                PPD file (for CUPS PPD list)\n");
#line 2147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -n           (used only with \"-C\") suppress the\n");
#line 2148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                printer/driver combos which point to \n");
#line 2149
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                ready-made PPD file (CUPS usually \n");
#line 2150
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                lists ready-made PPD files directly).\n");
#line 2151
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -l dir       Directory where the Foomatic database is located\n");
#line 2152
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -v           Verbose (debug) mode\n");
#line 2153
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -vv          Very Verbose (debug) mode\n");
#line 2154
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 2155
    exit(1);
    }
  }
#line 2159
  i = 1;
  {
#line 2159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2159
    if (! (i < argc)) {
#line 2159
      goto while_break;
    }
#line 2160
    if ((int )*(*(argv + i) + 0) == 45) {
      {
#line 2163
      if ((int )*(*(argv + i) + 1) == 112) {
#line 2163
        goto case_112;
      }
#line 2163
      if ((int )*(*(argv + i) + 1) == 80) {
#line 2163
        goto case_112;
      }
#line 2171
      if ((int )*(*(argv + i) + 1) == 100) {
#line 2171
        goto case_100;
      }
#line 2179
      if ((int )*(*(argv + i) + 1) == 111) {
#line 2179
        goto case_111;
      }
#line 2191
      if ((int )*(*(argv + i) + 1) == 79) {
#line 2191
        goto case_79;
      }
#line 2194
      if ((int )*(*(argv + i) + 1) == 67) {
#line 2194
        goto case_67;
      }
#line 2197
      if ((int )*(*(argv + i) + 1) == 110) {
#line 2197
        goto case_110;
      }
#line 2200
      if ((int )*(*(argv + i) + 1) == 108) {
#line 2200
        goto case_108;
      }
#line 2208
      if ((int )*(*(argv + i) + 1) == 118) {
#line 2208
        goto case_118;
      }
#line 2212
      goto switch_default;
      case_112: /* CIL Label */ 
      case_80: /* CIL Label */ 
#line 2164
      if ((int )*(*(argv + i) + 2) != 0) {
#line 2165
        pid = (char const   *)(*(argv + i) + 2);
      } else {
#line 2167
        i ++;
#line 2168
        pid = (char const   *)*(argv + i);
      }
#line 2170
      goto switch_break;
      case_100: /* CIL Label */ 
#line 2172
      if ((int )*(*(argv + i) + 2) != 0) {
#line 2173
        driver = (char const   *)(*(argv + i) + 2);
      } else {
#line 2175
        i ++;
#line 2176
        driver = (char const   *)*(argv + i);
      }
#line 2178
      goto switch_break;
      case_111: /* CIL Label */ 
#line 2180
      if ((int )*(*(argv + i) + 2) != 0) {
#line 2181
        setting = (char const   *)(*(argv + i) + 2);
      } else {
#line 2183
        i ++;
#line 2184
        setting = (char const   *)*(argv + i);
      }
      {
#line 2186
      num_defaultsettings ++;
#line 2187
      tmp = realloc((void *)defaultsettings, sizeof(char *) * (unsigned long )num_defaultsettings);
#line 2187
      defaultsettings = (char **)tmp;
#line 2189
      *(defaultsettings + (num_defaultsettings - 1)) = strdup(setting);
      }
#line 2190
      goto switch_break;
      case_79: /* CIL Label */ 
#line 2192
      overview = 1;
#line 2193
      goto switch_break;
      case_67: /* CIL Label */ 
#line 2195
      overview = 2;
#line 2196
      goto switch_break;
      case_110: /* CIL Label */ 
#line 2198
      noreadymadeppds = 1;
#line 2199
      goto switch_break;
      case_108: /* CIL Label */ 
#line 2201
      if ((int )*(*(argv + i) + 2) != 0) {
#line 2202
        libdir = (char const   *)(*(argv + i) + 2);
      } else {
#line 2204
        i ++;
#line 2205
        libdir = (char const   *)*(argv + i);
      }
#line 2207
      goto switch_break;
      case_118: /* CIL Label */ 
#line 2209
      debug ++;
#line 2210
      if ((int )*(*(argv + i) + 2) == 118) {
#line 2210
        debug ++;
      }
#line 2211
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2213
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown option \'%c\'!",
              (int )*(*(argv + i) + 1));
#line 2214
      exit(1);
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 2217
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown argument \'%s\'!",
              *(argv + i));
      }
    }
#line 2159
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2223
  if (debug > 1) {
#line 2223
    debug2 = 1;
  }
#line 2227
  if ((unsigned long )libdir == (unsigned long )((void *)0)) {
#line 2228
    libdir = "/usr/share/foomatic";
  }
  {
#line 2231
  sprintf((char */* __restrict  */)(oldidfilename), (char const   */* __restrict  */)"%s/db/oldprinterids",
          libdir);
#line 2233
  idlist = loadidlist((char const   *)(oldidfilename));
  }
#line 2234
  if (debug) {
#line 2235
    if (idlist) {
      {
#line 2236
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printer ID translation table loaded!\n");
      }
    } else {
      {
#line 2238
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printer ID translation table corrupted, missing, or not readable!\n");
      }
    }
  }
#line 2243
  if (! overview) {
#line 2251
    if ((unsigned long )pid == (unsigned long )((void *)0)) {
      {
#line 2252
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A printer ID must be supplied!\n");
#line 2253
      exit(1);
      }
    }
#line 2255
    if ((unsigned long )driver == (unsigned long )((void *)0)) {
      {
#line 2256
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A driver name must be supplied!\n");
#line 2257
      exit(1);
      }
    }
    {
#line 2262
    sprintf((char */* __restrict  */)(printerfilename), (char const   */* __restrict  */)"%s/db/source/printer/%s.xml",
            libdir, pid);
#line 2264
    sprintf((char */* __restrict  */)(driverfilename), (char const   */* __restrict  */)"%s/db/source/driver/%s.xml",
            libdir, driver);
#line 2266
    sprintf((char */* __restrict  */)(optiondirname), (char const   */* __restrict  */)"%s/db/source/opt",
            libdir);
    }
#line 2272
    if (debug) {
      {
#line 2272
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printer file: %s\n",
              printerfilename);
      }
    }
    {
#line 2273
    printerbuffer = loadfile((char const   *)(printerfilename));
    }
#line 2274
    if ((unsigned long )printerbuffer == (unsigned long )((void *)0)) {
      {
#line 2275
      tmp___0 = translateid(pid, idlist);
#line 2275
      pid = (char const   *)tmp___0;
#line 2276
      sprintf((char */* __restrict  */)(printerfilename), (char const   */* __restrict  */)"%s/db/source/printer/%s.xml",
              libdir, pid);
#line 2278
      printerbuffer = loadfile((char const   *)(printerfilename));
      }
#line 2279
      if ((unsigned long )printerbuffer == (unsigned long )((void *)0)) {
        {
#line 2280
        tmp___1 = malloc((size_t )1024);
#line 2280
        printerbuffer = (char *)tmp___1;
#line 2281
        tmp___2 = strdup(pid);
#line 2281
        make___0 = (char const   *)tmp___2;
#line 2282
        tmp___3 = strchr(make___0, '-');
#line 2282
        model___0 = (char const   *)tmp___3;
        }
#line 2283
        if (model___0) {
#line 2284
          t = (char *)model___0;
#line 2285
          *t = (char )'\000';
#line 2286
          model___0 ++;
        } else {
#line 2288
          model___0 = "Unknown model";
        }
#line 2290
        t = (char *)make___0;
        {
#line 2291
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2291
          if (! *t) {
#line 2291
            goto while_break___0;
          }
#line 2292
          if ((int )*t == 95) {
#line 2292
            *t = (char )' ';
          }
#line 2293
          t ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2295
        t = (char *)model___0;
        {
#line 2296
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2296
          if (! *t) {
#line 2296
            goto while_break___1;
          }
#line 2297
          if ((int )*t == 95) {
#line 2297
            *t = (char )' ';
          }
#line 2298
          t ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 2300
        sprintf((char */* __restrict  */)printerbuffer, (char const   */* __restrict  */)"<printer id=\"printer/%s\">\n <make>%s</make>\n <model>%s</model>\n <mechanism>\n  <color />\n </mechanism>\n <noxmlentry />\n</printer>\n",
                pid, make___0, model___0);
        }
      } else {
        {
#line 2302
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Obsolete printer ID used, using %s instead!\n",
                pid);
        }
      }
    }
#line 2307
    if (debug) {
      {
#line 2307
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Printer file loaded!\n");
      }
    }
    {
#line 2308
    comboconfirmed = parse(& printerbuffer, pid, driver, (char const   *)(printerfilename),
                           (printerlist_t **)((void *)0), 0, (char const   **)defaultsettings,
                           num_defaultsettings, & nopjl, idlist, debug2);
    }
#line 2315
    if (debug) {
      {
#line 2315
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Driver file: %s\n",
              driverfilename);
      }
    }
    {
#line 2316
    driverbuffer = loadfile((char const   *)(driverfilename));
    }
#line 2317
    if ((unsigned long )driverbuffer == (unsigned long )((void *)0)) {
#line 2318
      if (! comboconfirmed) {
        {
#line 2319
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Driver file %s corrupted, missing, or not readable!\n",
                driverfilename);
#line 2322
        exit(1);
        }
      } else {
        {
#line 2324
        tmp___4 = malloc((size_t )4096);
#line 2324
        driverbuffer = (char *)tmp___4;
#line 2325
        sprintf((char */* __restrict  */)driverbuffer, (char const   */* __restrict  */)"<driver id=\"driver/%s\">\n <name>%s</name>\n <url></url>\n <execution>\n  <filter />\n  <prototype></prototype>\n </execution>\n <printers>\n  <printer>\n   <id>printer/%s</id>\n  </printer>\n </printers>\n</driver>",
                driver, driver, pid);
        }
      }
    } else {
#line 2328
      if (debug) {
        {
#line 2328
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Driver file loaded!\n");
        }
      }
      {
#line 2329
      comboconfirmed2 = parse(& driverbuffer, pid, driver, (char const   *)(driverfilename),
                              (printerlist_t **)((void *)0), 1, (char const   **)defaultsettings,
                              num_defaultsettings, & nopjl, idlist, debug2);
      }
#line 2333
      if (! comboconfirmed) {
#line 2333
        if (! comboconfirmed2) {
          {
#line 2334
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The printer %s is not supported by the driver %s!\n",
                  pid, driver);
#line 2336
          exit(1);
          }
        }
      }
#line 2338
      if (debug) {
#line 2339
        if (nopjl) {
          {
#line 2340
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Driver forbids PJL options!\n");
          }
        } else {
          {
#line 2342
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Driver allows PJL options!\n");
          }
        }
      }
      {
#line 2350
      optiondir = opendir((char const   *)(optiondirname));
      }
#line 2351
      if ((unsigned long )optiondir == (unsigned long )((void *)0)) {
        {
#line 2352
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot read directory %s!\n",
                optiondirname);
#line 2353
        exit(1);
        }
      }
      {
#line 2356
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 2356
        direntry = readdir(optiondir);
        }
#line 2356
        if (! ((unsigned long )direntry != (unsigned long )((void *)0))) {
#line 2356
          goto while_break___2;
        }
        {
#line 2357
        sprintf((char */* __restrict  */)(optionfilename), (char const   */* __restrict  */)"%s/db/source/opt/%s",
                libdir, direntry->d_name);
        }
#line 2359
        if (debug) {
          {
#line 2359
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option file: %s\n",
                  optionfilename);
          }
        }
        {
#line 2361
        tmp___6 = strlen((char const   *)(optionfilename));
#line 2361
        tmp___7 = strcmp((char const   *)((optionfilename + tmp___6) - 4), ".xml");
        }
#line 2361
        if (tmp___7 == 0) {
          {
#line 2364
          num_optbuffers ++;
#line 2365
          tmp___5 = realloc((void *)optbuffers, sizeof(char *) * (unsigned long )num_optbuffers);
#line 2365
          optbuffers = (char **)tmp___5;
#line 2368
          *(optbuffers + (num_optbuffers - 1)) = loadfile((char const   *)(optionfilename));
          }
#line 2369
          if ((unsigned long )*(optbuffers + (num_optbuffers - 1)) == (unsigned long )((void *)0)) {
            {
#line 2370
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option file %s corrupted, missing, or not readable!\n",
                    optionfilename);
#line 2373
            exit(1);
            }
          }
#line 2375
          if (debug) {
            {
#line 2375
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Option file loaded!\n");
            }
          }
          {
#line 2377
          parse(optbuffers + (num_optbuffers - 1), pid, driver, (char const   *)(optionfilename),
                (printerlist_t **)((void *)0), 2, (char const   **)defaultsettings,
                num_defaultsettings, & nopjl, idlist, debug2);
          }
#line 2383
          if ((unsigned long )*(optbuffers + (num_optbuffers - 1)) == (unsigned long )((void *)0)) {
#line 2384
            if (debug) {
              {
#line 2384
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Option does not apply, removed!\n");
              }
            }
#line 2385
            num_optbuffers --;
          } else
#line 2387
          if (debug) {
            {
#line 2387
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Option applies!\n");
            }
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2391
      closedir(optiondir);
      }
    }
#line 2395
    if (debug) {
      {
#line 2395
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Putting out result!\n");
      }
    }
    {
#line 2396
    printf((char const   */* __restrict  */)"<foomatic>\n%s%s\n<options>\n", printerbuffer,
           driverbuffer);
#line 2397
    i = 0;
    }
    {
#line 2397
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2397
      if (! (i < num_optbuffers)) {
#line 2397
        goto while_break___3;
      }
      {
#line 2398
      printf((char const   */* __restrict  */)"%s", *(optbuffers + i));
#line 2397
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 2400
    printf((char const   */* __restrict  */)"</options>\n</foomatic>\n");
    }
  } else {
    {
#line 2410
    sprintf((char */* __restrict  */)(driverdirname), (char const   */* __restrict  */)"%s/db/source/driver",
            libdir);
#line 2412
    sprintf((char */* __restrict  */)(printerdirname), (char const   */* __restrict  */)"%s/db/source/printer",
            libdir);
    }
#line 2416
    if (overview == 2) {
#line 2417
      if (noreadymadeppds) {
#line 2418
        pid = "c";
      } else {
#line 2420
        pid = "C";
      }
    } else {
#line 2422
      pid = (char const   *)((void *)0);
    }
#line 2427
    if (pid) {
      {
#line 2428
      tmp___8 = malloc(sizeof(printerlist_t ));
#line 2428
      plistpointer = (printerlist_t *)tmp___8;
#line 2430
      strcpy((char */* __restrict  */)(plistpointer->id), (char const   */* __restrict  */)"proto");
#line 2431
      plistpointer->drivers = (driverlist_t *)((void *)0);
#line 2432
      plistpointer->next = (struct printerlist_t *)((void *)0);
#line 2433
      printerlist = plistpointer;
      }
    }
    {
#line 2436
    printf((char const   */* __restrict  */)"<overview>\n");
#line 2442
    driverdir = opendir((char const   *)(driverdirname));
    }
#line 2443
    if ((unsigned long )driverdir == (unsigned long )((void *)0)) {
      {
#line 2444
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot read directory %s!\n",
              driverdirname);
#line 2445
      exit(1);
      }
    }
    {
#line 2448
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 2448
      direntry = readdir(driverdir);
      }
#line 2448
      if (! ((unsigned long )direntry != (unsigned long )((void *)0))) {
#line 2448
        goto while_break___4;
      }
      {
#line 2449
      sprintf((char */* __restrict  */)(driverfilename), (char const   */* __restrict  */)"%s/db/source/driver/%s",
              libdir, direntry->d_name);
      }
#line 2451
      if (debug) {
        {
#line 2451
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Driver file: %s\n",
                driverfilename);
        }
      }
      {
#line 2452
      tmp___9 = strlen((char const   *)(driverfilename));
#line 2452
      tmp___10 = strcmp((char const   *)((driverfilename + tmp___9) - 4), ".xml");
      }
#line 2452
      if (tmp___10 == 0) {
        {
#line 2455
        driverbuffer = loadfile((char const   *)(driverfilename));
        }
#line 2456
        if ((unsigned long )driverbuffer == (unsigned long )((void *)0)) {
          {
#line 2457
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Driver file %s corrupted, missing, or not readable!\n",
                  driverfilename);
#line 2460
          exit(1);
          }
        }
#line 2462
        if (debug) {
          {
#line 2462
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Driver file loaded!\n");
          }
        }
        {
#line 2464
        parse(& driverbuffer, pid, (char const   *)((void *)0), (char const   *)(driverfilename),
              & printerlist, 3, (char const   **)defaultsettings, num_defaultsettings,
              & nopjl, idlist, debug2);
        }
#line 2467
        if ((unsigned long )driverbuffer != (unsigned long )((void *)0)) {
          {
#line 2469
          printf((char const   */* __restrict  */)"%s\n", driverbuffer);
#line 2471
          free((void *)driverbuffer);
#line 2472
          driverbuffer = (char *)((void *)0);
          }
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 2476
    closedir(driverdir);
    }
#line 2478
    if (debug) {
#line 2479
      plistpointer = printerlist;
      {
#line 2480
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2480
        if (! plistpointer) {
#line 2480
          goto while_break___5;
        }
        {
#line 2481
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printer: %s\n",
                plistpointer->id);
#line 2482
        dlistpointer = plistpointer->drivers;
        }
        {
#line 2483
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2483
          if (! dlistpointer) {
#line 2483
            goto while_break___6;
          }
          {
#line 2484
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   Driver: %s\n",
                  dlistpointer->name);
          }
#line 2485
          if ((unsigned long )dlistpointer->functionality != (unsigned long )((void *)0)) {
            {
#line 2486
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    %s\n",
                    dlistpointer->functionality);
            }
          }
#line 2487
          dlistpointer = (driverlist_t *)dlistpointer->next;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 2489
        plistpointer = (printerlist_t *)plistpointer->next;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 2497
    printerdir = opendir((char const   *)(printerdirname));
    }
#line 2498
    if ((unsigned long )printerdir == (unsigned long )((void *)0)) {
      {
#line 2499
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot read directory %s!\n",
              printerdirname);
#line 2500
      exit(1);
      }
    }
    {
#line 2503
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 2503
      direntry = readdir(printerdir);
      }
#line 2503
      if (! ((unsigned long )direntry != (unsigned long )((void *)0))) {
#line 2503
        goto while_break___7;
      }
      {
#line 2504
      sprintf((char */* __restrict  */)(printerfilename), (char const   */* __restrict  */)"%s/db/source/printer/%s",
              libdir, direntry->d_name);
      }
#line 2506
      if (debug) {
        {
#line 2506
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printer file: %s\n",
                printerfilename);
        }
      }
      {
#line 2507
      tmp___11 = strlen((char const   *)(printerfilename));
#line 2507
      tmp___12 = strcmp((char const   *)((printerfilename + tmp___11) - 4), ".xml");
      }
#line 2507
      if (tmp___12 == 0) {
        {
#line 2511
        printerbuffer = loadfile((char const   *)(printerfilename));
        }
#line 2512
        if ((unsigned long )printerbuffer == (unsigned long )((void *)0)) {
          {
#line 2513
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printer file %s corrupted, missing, or not readable!\n",
                  printerfilename);
#line 2516
          exit(1);
          }
        }
#line 2518
        if (debug) {
          {
#line 2518
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Printer file loaded!\n");
          }
        }
        {
#line 2520
        parse(& printerbuffer, pid, (char const   *)((void *)0), (char const   *)(printerfilename),
              & printerlist, 4, (char const   **)defaultsettings, num_defaultsettings,
              & nopjl, idlist, debug2);
#line 2524
        printf((char const   */* __restrict  */)"%s", printerbuffer);
#line 2526
        free((void *)printerbuffer);
#line 2527
        printerbuffer = (char *)((void *)0);
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 2531
    closedir(printerdir);
    }
#line 2533
    if (debug) {
#line 2534
      plistpointer = printerlist;
      {
#line 2535
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2535
        if (! plistpointer) {
#line 2535
          goto while_break___8;
        }
        {
#line 2536
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printer: %s\n",
                plistpointer->id);
#line 2537
        dlistpointer = plistpointer->drivers;
        }
        {
#line 2538
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 2538
          if (! dlistpointer) {
#line 2538
            goto while_break___9;
          }
          {
#line 2539
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   Driver: %s\n",
                  dlistpointer->name);
          }
#line 2540
          if ((unsigned long )dlistpointer->functionality != (unsigned long )((void *)0)) {
            {
#line 2541
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    %s\n",
                    dlistpointer->functionality);
            }
          }
#line 2542
          dlistpointer = (driverlist_t *)dlistpointer->next;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 2544
        plistpointer = (printerlist_t *)plistpointer->next;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
    {
#line 2551
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 2551
      if (! printerlist) {
#line 2551
        goto while_break___10;
      }
#line 2552
      if (printerlist->id) {
        {
#line 2552
        tmp___14 = strcmp((char const   *)(printerlist->id), "proto");
        }
#line 2552
        if (tmp___14) {
#line 2553
          if (debug) {
            {
#line 2553
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Printer only mentioned in driver XML files:\n      Printer ID: |%s|\n",
                    printerlist->id);
            }
          }
          {
#line 2556
          printf((char const   */* __restrict  */)"  <printer>\n    <id>");
#line 2557
          printf((char const   */* __restrict  */)"%s", printerlist->id);
#line 2558
          make___0 = (char const   *)(printerlist->id);
#line 2559
          tmp___13 = strchr(make___0, '-');
#line 2559
          model___0 = (char const   *)tmp___13;
          }
#line 2560
          if (model___0) {
#line 2561
            t = (char *)model___0;
#line 2562
            *t = (char )'\000';
#line 2563
            model___0 ++;
          } else {
#line 2565
            model___0 = "Unknown model";
          }
#line 2567
          t = (char *)make___0;
          {
#line 2568
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 2568
            if (! *t) {
#line 2568
              goto while_break___11;
            }
#line 2569
            if ((int )*t == 95) {
#line 2569
              *t = (char )' ';
            }
#line 2570
            t ++;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 2572
          t = (char *)model___0;
          {
#line 2573
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 2573
            if (! *t) {
#line 2573
              goto while_break___12;
            }
#line 2574
            if ((int )*t == 95) {
#line 2574
              *t = (char )' ';
            }
#line 2575
            t ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 2577
          printf((char const   */* __restrict  */)"</id>\n    <make>");
#line 2578
          printf((char const   */* __restrict  */)"%s", make___0);
#line 2579
          printf((char const   */* __restrict  */)"</make>\n    <model>");
#line 2580
          printf((char const   */* __restrict  */)"%s", model___0);
#line 2581
          printf((char const   */* __restrict  */)"</model>\n    <noxmlentry />\n");
#line 2582
          dlistpointer = printerlist->drivers;
#line 2583
          exceptionfound = 0;
          }
#line 2584
          if (dlistpointer) {
            {
#line 2585
            printf((char const   */* __restrict  */)"    <drivers>\n");
            }
            {
#line 2586
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 2586
              if (! dlistpointer) {
#line 2586
                goto while_break___13;
              }
#line 2587
              if (dlistpointer->name) {
                {
#line 2588
                printf((char const   */* __restrict  */)"      <driver>");
#line 2589
                printf((char const   */* __restrict  */)"%s", dlistpointer->name);
#line 2590
                printf((char const   */* __restrict  */)"</driver>\n");
                }
#line 2591
                if ((unsigned long )dlistpointer->functionality != (unsigned long )((void *)0)) {
#line 2591
                  exceptionfound = 1;
                }
              }
#line 2593
              dlistpointer = (driverlist_t *)dlistpointer->next;
            }
            while_break___13: /* CIL Label */ ;
            }
            {
#line 2595
            printf((char const   */* __restrict  */)"    </drivers>\n");
            }
          }
#line 2597
          if (exceptionfound) {
            {
#line 2598
            printf((char const   */* __restrict  */)"    <driverfunctionalityexceptions>\n");
#line 2599
            dlistpointer = printerlist->drivers;
            }
            {
#line 2600
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 2600
              if (! dlistpointer) {
#line 2600
                goto while_break___14;
              }
#line 2601
              if ((unsigned long )dlistpointer->functionality != (unsigned long )((void *)0)) {
#line 2601
                if ((unsigned long )(dlistpointer->name) != (unsigned long )((void *)0)) {
                  {
#line 2603
                  printf((char const   */* __restrict  */)"      <driverfunctionalityexception>\n");
#line 2604
                  printf((char const   */* __restrict  */)"        <driver>");
#line 2605
                  printf((char const   */* __restrict  */)"%s", dlistpointer->name);
#line 2606
                  printf((char const   */* __restrict  */)"</driver>\n");
#line 2607
                  printf((char const   */* __restrict  */)"%s", dlistpointer->functionality);
#line 2608
                  printf((char const   */* __restrict  */)"\n      </driverfunctionalityexception>\n");
                  }
                }
              }
#line 2610
              dlistpointer = (driverlist_t *)dlistpointer->next;
            }
            while_break___14: /* CIL Label */ ;
            }
            {
#line 2612
            printf((char const   */* __restrict  */)"    </driverfunctionalityexceptions>\n");
            }
          }
          {
#line 2614
          printf((char const   */* __restrict  */)"  </printer>\n");
          }
        }
      }
#line 2616
      dlistpointer = printerlist->drivers;
      {
#line 2617
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 2617
        if (! dlistpointer) {
#line 2617
          goto while_break___15;
        }
        {
#line 2618
        dlistpreventry = dlistpointer;
#line 2619
        dlistpointer = (driverlist_t *)dlistpointer->next;
#line 2620
        free((void *)dlistpreventry);
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 2622
      plistpreventry = printerlist;
#line 2623
      printerlist = (printerlist_t *)printerlist->next;
#line 2624
      free((void *)plistpreventry);
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 2627
    printf((char const   */* __restrict  */)"</overview>\n");
    }
#line 2629
    if (debug) {
#line 2630
      plistpointer = printerlist;
      {
#line 2631
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 2631
        if (! plistpointer) {
#line 2631
          goto while_break___16;
        }
        {
#line 2632
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printer: %s\n",
                plistpointer->id);
#line 2633
        dlistpointer = plistpointer->drivers;
        }
        {
#line 2634
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 2634
          if (! dlistpointer) {
#line 2634
            goto while_break___17;
          }
          {
#line 2635
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   Driver: %s\n",
                  dlistpointer->name);
          }
#line 2636
          if ((unsigned long )dlistpointer->functionality != (unsigned long )((void *)0)) {
            {
#line 2637
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    %s\n",
                    dlistpointer->functionality);
            }
          }
#line 2638
          dlistpointer = (driverlist_t *)dlistpointer->next;
        }
        while_break___17: /* CIL Label */ ;
        }
#line 2640
        plistpointer = (printerlist_t *)plistpointer->next;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
  }
  {
#line 2647
  exit(0);
  }
}
}
