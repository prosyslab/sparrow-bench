/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 6 "/usr/include/linux/errqueue.h"
struct sock_extended_err {
   __u32 ee_errno ;
   __u8 ee_origin ;
   __u8 ee_type ;
   __u8 ee_code ;
   __u8 ee_pad ;
   __u32 ee_info ;
   __u32 ee_data ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 531
struct cmsghdr;
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
struct hhistory {
   int hops ;
   struct timeval sendtime ;
};
#line 61 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
struct probehdr {
   __u32 ttl ;
   struct timeval tv ;
};
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                struct cmsghdr *__cmsg ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 92 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) herror)(char const   *__str ) ;
#line 137
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 155
extern struct hostent *gethostbyname2(char const   *__name , int __af ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
struct hhistory his[64]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
int hisptr  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
struct sockaddr_in target  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
__u16 base_port  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
int max_hops  =    30;
#line 51 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
int const   overhead  =    (int const   )28;
#line 52 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
int mtu  =    65535;
#line 53 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
void *pktbuf  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
int hops_to  =    -1;
#line 55 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
int hops_from  =    -1;
#line 56 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
int no_resolve  =    0;
#line 57 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
int show_both  =    0;
#line 67 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
void data_wait(int fd ) 
{ 
  fd_set fds ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;

  {
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.fds_bits[0]): "memory");
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  fds.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 73
  tv.tv_sec = (__time_t )1;
#line 74
  tv.tv_usec = (__suseconds_t )0;
#line 75
  select(fd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
         (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
void print_host(char const   *a , char const   *b , int both ) 
{ 
  int plen ;
  int tmp ;

  {
  {
#line 81
  plen = printf((char const   */* __restrict  */)"%s", a);
  }
#line 82
  if (both) {
    {
#line 83
    tmp = printf((char const   */* __restrict  */)" (%s)", b);
#line 83
    plen += tmp;
    }
  }
#line 84
  if (plen >= 52) {
#line 85
    plen = 51;
  }
  {
#line 86
  printf((char const   */* __restrict  */)"%*s", 52 - plen, "");
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
int recverr(int fd , int ttl ) 
{ 
  int res ;
  struct probehdr rcvbuf ;
  char cbuf[512] ;
  struct iovec iov ;
  struct msghdr msg ;
  struct cmsghdr *cmsg ;
  struct sock_extended_err *e ;
  struct sockaddr_in addr ;
  struct timeval tv ;
  struct timeval *rettv ;
  int slot ;
  int rethops ;
  int sndhops ;
  int progress ;
  int broken_router ;
  ssize_t tmp ;
  int *tmp___0 ;
  uint16_t tmp___1 ;
  char abuf[128] ;
  struct sockaddr_in *sin ;
  struct hostent *h ;
  char *idn ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int diff ;
  int *tmp___6 ;

  {
#line 104
  progress = -1;
  restart: 
  {
#line 108
  memset((void *)(& rcvbuf), -1, sizeof(rcvbuf));
#line 109
  iov.iov_base = (void *)(& rcvbuf);
#line 110
  iov.iov_len = sizeof(rcvbuf);
#line 111
  msg.msg_name = (void *)((__u8 *)(& addr));
#line 112
  msg.msg_namelen = (socklen_t )sizeof(addr);
#line 113
  msg.msg_iov = & iov;
#line 114
  msg.msg_iovlen = (size_t )1;
#line 115
  msg.msg_flags = 0;
#line 116
  msg.msg_control = (void *)(cbuf);
#line 117
  msg.msg_controllen = sizeof(cbuf);
#line 119
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 120
  tmp = recvmsg(fd, & msg, 8192);
#line 120
  res = (int )tmp;
  }
#line 121
  if (res < 0) {
    {
#line 122
    tmp___0 = __errno_location();
    }
#line 122
    if (*tmp___0 == 11) {
#line 123
      return (progress);
    }
#line 124
    goto restart;
  }
  {
#line 127
  progress = mtu;
#line 129
  rethops = -1;
#line 130
  sndhops = -1;
#line 131
  e = (struct sock_extended_err *)((void *)0);
#line 132
  rettv = (struct timeval *)((void *)0);
#line 133
  tmp___1 = ntohs(addr.sin_port);
#line 133
  slot = (int )tmp___1 - (int )base_port;
  }
#line 134
  if (slot >= 0) {
#line 134
    if (slot < 63) {
#line 134
      if (his[slot].hops) {
#line 135
        sndhops = his[slot].hops;
#line 136
        rettv = & his[slot].sendtime;
#line 137
        his[slot].hops = 0;
      }
    }
  }
#line 139
  broken_router = 0;
#line 140
  if ((unsigned long )res == sizeof(rcvbuf)) {
#line 141
    if (rcvbuf.ttl == 0U) {
#line 142
      broken_router = 1;
    } else
#line 141
    if (rcvbuf.tv.tv_sec == 0L) {
#line 142
      broken_router = 1;
    } else {
#line 144
      sndhops = (int )rcvbuf.ttl;
#line 145
      rettv = & rcvbuf.tv;
    }
  }
#line 149
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 149
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 149
    cmsg = (struct cmsghdr *)0;
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! cmsg) {
#line 149
      goto while_break;
    }
#line 150
    if (cmsg->cmsg_level == 0) {
#line 151
      if (cmsg->cmsg_type == 11) {
#line 152
        e = (struct sock_extended_err *)(cmsg->__cmsg_data);
      } else
#line 153
      if (cmsg->cmsg_type == 2) {
        {
#line 154
        memcpy((void */* __restrict  */)(& rethops), (void const   */* __restrict  */)(cmsg->__cmsg_data),
               sizeof(rethops));
        }
      } else {
        {
#line 156
        printf((char const   */* __restrict  */)"cmsg:%d\n ", cmsg->cmsg_type);
        }
      }
    }
    {
#line 149
    cmsg = __cmsg_nxthdr(& msg, cmsg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 161
    printf((char const   */* __restrict  */)"no info\n");
    }
#line 162
    return (0);
  }
#line 164
  if ((int )e->ee_origin == 1) {
    {
#line 165
    printf((char const   */* __restrict  */)"%2d?: %*s ", ttl, -51, "[LOCALHOST]");
    }
  } else
#line 166
  if ((int )e->ee_origin == 2) {
    {
#line 168
    sin = (struct sockaddr_in *)(e + 1);
#line 169
    h = (struct hostent *)((void *)0);
#line 170
    idn = (char *)((void *)0);
#line 172
    inet_ntop(2, (void const   */* __restrict  */)(& sin->sin_addr), (char */* __restrict  */)(abuf),
              (socklen_t )sizeof(abuf));
    }
#line 174
    if (sndhops > 0) {
      {
#line 175
      printf((char const   */* __restrict  */)"%2d:  ", sndhops);
      }
    } else {
      {
#line 177
      printf((char const   */* __restrict  */)"%2d?: ", ttl);
      }
    }
#line 179
    if (! no_resolve) {
      {
#line 180
      fflush(stdout);
#line 181
      h = gethostbyaddr((void const   *)((char *)(& sin->sin_addr)), (__socklen_t )sizeof(sin->sin_addr),
                        2);
      }
    } else
#line 179
    if (show_both) {
      {
#line 180
      fflush(stdout);
#line 181
      h = gethostbyaddr((void const   *)((char *)(& sin->sin_addr)), (__socklen_t )sizeof(sin->sin_addr),
                        2);
      }
    }
#line 188
    if (no_resolve) {
#line 189
      if (h) {
#line 189
        if (idn) {
#line 189
          tmp___2 = idn;
        } else {
#line 189
          tmp___2 = h->h_name;
        }
#line 189
        tmp___3 = tmp___2;
      } else {
#line 189
        tmp___3 = abuf;
      }
      {
#line 189
      print_host((char const   *)(abuf), (char const   *)tmp___3, show_both);
      }
    } else {
#line 191
      if (h) {
#line 191
        if (idn) {
#line 191
          tmp___4 = idn;
        } else {
#line 191
          tmp___4 = h->h_name;
        }
#line 191
        tmp___5 = tmp___4;
      } else {
#line 191
        tmp___5 = abuf;
      }
      {
#line 191
      print_host((char const   *)tmp___5, (char const   *)(abuf), show_both);
      }
    }
  }
#line 198
  if (rettv) {
    {
#line 199
    diff = (int )((tv.tv_sec - rettv->tv_sec) * 1000000L + (tv.tv_usec - rettv->tv_usec));
#line 200
    printf((char const   */* __restrict  */)"%3d.%03dms ", diff / 1000, diff % 1000);
    }
#line 201
    if (broken_router) {
      {
#line 202
      printf((char const   */* __restrict  */)"(This broken router returned corrupted payload) ");
      }
    }
  }
#line 205
  if (rethops <= 64) {
#line 206
    rethops = 65 - rethops;
  } else
#line 207
  if (rethops <= 128) {
#line 208
    rethops = 129 - rethops;
  } else {
#line 210
    rethops = 256 - rethops;
  }
  {
#line 213
  if (e->ee_errno == 110U) {
#line 213
    goto case_110;
  }
#line 216
  if (e->ee_errno == 90U) {
#line 216
    goto case_90;
  }
#line 221
  if (e->ee_errno == 111U) {
#line 221
    goto case_111;
  }
#line 226
  if (e->ee_errno == 71U) {
#line 226
    goto case_71;
  }
#line 229
  if (e->ee_errno == 113U) {
#line 229
    goto case_113;
  }
#line 244
  if (e->ee_errno == 101U) {
#line 244
    goto case_101;
  }
#line 247
  if (e->ee_errno == 13U) {
#line 247
    goto case_13;
  }
#line 250
  goto switch_default;
  case_110: /* CIL Label */ 
  {
#line 214
  printf((char const   */* __restrict  */)"\n");
  }
#line 215
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 217
  printf((char const   */* __restrict  */)"pmtu %d\n", e->ee_info);
#line 218
  mtu = (int )e->ee_info;
#line 219
  progress = mtu;
  }
#line 220
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 222
  printf((char const   */* __restrict  */)"reached\n");
  }
#line 223
  if (sndhops < 0) {
#line 223
    hops_to = ttl;
  } else {
#line 223
    hops_to = sndhops;
  }
#line 224
  hops_from = rethops;
#line 225
  return (0);
  case_71: /* CIL Label */ 
  {
#line 227
  printf((char const   */* __restrict  */)"!P\n");
  }
#line 228
  return (0);
  case_113: /* CIL Label */ 
#line 230
  if ((int )e->ee_origin == 2) {
#line 230
    if ((int )e->ee_type == 11) {
#line 230
      if ((int )e->ee_code == 0) {
#line 233
        if (rethops >= 0) {
#line 234
          if (sndhops >= 0) {
#line 234
            if (rethops != sndhops) {
              {
#line 235
              printf((char const   */* __restrict  */)"asymm %2d ", rethops);
              }
            } else {
#line 234
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 236
          if (sndhops < 0) {
#line 236
            if (rethops != ttl) {
              {
#line 237
              printf((char const   */* __restrict  */)"asymm %2d ", rethops);
              }
            }
          }
        }
        {
#line 239
        printf((char const   */* __restrict  */)"\n");
        }
#line 240
        goto switch_break;
      }
    }
  }
  {
#line 242
  printf((char const   */* __restrict  */)"!H\n");
  }
#line 243
  return (0);
  case_101: /* CIL Label */ 
  {
#line 245
  printf((char const   */* __restrict  */)"!N\n");
  }
#line 246
  return (0);
  case_13: /* CIL Label */ 
  {
#line 248
  printf((char const   */* __restrict  */)"!A\n");
  }
#line 249
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 251
  printf((char const   */* __restrict  */)"\n");
#line 252
  tmp___6 = __errno_location();
#line 252
  *tmp___6 = (int )e->ee_errno;
#line 253
  perror("NET ERROR");
  }
#line 254
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 256
  goto restart;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
int probe_ttl(int fd , int ttl ) 
{ 
  int i ;
  struct probehdr *hdr ;
  int res ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 262
  hdr = (struct probehdr *)pktbuf;
#line 264
  memset(pktbuf, 0, (size_t )mtu);
  }
  restart: 
#line 266
  i = 0;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! (i < 10)) {
#line 266
      goto while_break;
    }
    {
#line 269
    hdr->ttl = (__u32 )ttl;
#line 270
    target.sin_port = htons((uint16_t )((int )base_port + hisptr));
#line 271
    gettimeofday((struct timeval */* __restrict  */)(& hdr->tv), (__timezone_ptr_t )((void *)0));
#line 272
    his[hisptr].hops = ttl;
#line 273
    his[hisptr].sendtime = hdr->tv;
#line 274
    tmp = sendto(fd, (void const   *)pktbuf, (size_t )(mtu - (int )overhead), 0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& target)),
                 (socklen_t )sizeof(target));
    }
#line 274
    if (tmp > 0L) {
#line 275
      goto while_break;
    }
    {
#line 276
    res = recverr(fd, ttl);
#line 277
    his[hisptr].hops = 0;
    }
#line 278
    if (res == 0) {
#line 279
      return (0);
    }
#line 280
    if (res > 0) {
#line 281
      goto restart;
    }
#line 266
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  hisptr = (hisptr + 1) & 63;
#line 285
  if (i < 10) {
    {
#line 286
    data_wait(fd);
#line 287
    tmp___0 = recv(fd, pktbuf, (size_t )mtu, 64);
    }
#line 287
    if (tmp___0 > 0L) {
      {
#line 288
      printf((char const   */* __restrict  */)"%2d?: reply received 8)\n", ttl);
      }
#line 289
      return (0);
    }
    {
#line 291
    tmp___1 = recverr(fd, ttl);
    }
#line 291
    return (tmp___1);
  }
  {
#line 294
  printf((char const   */* __restrict  */)"%2d:  send failed\n", ttl);
  }
#line 295
  return (0);
}
}
#line 298
static  __attribute__((__noreturn__)) void usage(void) ;
#line 300
static  __attribute__((__noreturn__)) void usage(void) ;
#line 300 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
static void usage(void) 
{ 


  {
  {
#line 302
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: tracepath [-n] [-b] [-l <len>] [-p port] <destination>\n");
#line 303
  exit(-1);
  }
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/iputils-20121221/tracepath.c"
int main(int argc , char **argv ) 
{ 
  struct hostent *he ;
  int fd ;
  int on ;
  int ttl ;
  char *p ;
  int ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int res ;
  int i ;
  int tmp___5 ;
  int old_mtu ;

  {
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 320
    ch = getopt(argc, (char * const  *)argv, "nbh?l:m:p:");
    }
#line 320
    if (! (ch != -1)) {
#line 320
      goto while_break;
    }
    {
#line 322
    if (ch == 110) {
#line 322
      goto case_110;
    }
#line 325
    if (ch == 98) {
#line 325
      goto case_98;
    }
#line 328
    if (ch == 108) {
#line 328
      goto case_108;
    }
#line 335
    if (ch == 109) {
#line 335
      goto case_109;
    }
#line 343
    if (ch == 112) {
#line 343
      goto case_112;
    }
#line 346
    goto switch_default;
    case_110: /* CIL Label */ 
#line 323
    no_resolve = 1;
#line 324
    goto switch_break;
    case_98: /* CIL Label */ 
#line 326
    show_both = 1;
#line 327
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 329
    mtu = atoi((char const   *)optarg);
    }
#line 329
    if (mtu <= (int )overhead) {
      {
#line 330
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: pktlen must be > %d and <= %d.\n",
              overhead, 2147483647);
#line 332
      exit(1);
      }
    }
#line 334
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 336
    max_hops = atoi((char const   *)optarg);
    }
#line 337
    if (max_hops < 0) {
      {
#line 338
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: max hops must be 0 .. %d (inclusive).\n",
              255);
      }
    } else
#line 337
    if (max_hops > 255) {
      {
#line 338
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: max hops must be 0 .. %d (inclusive).\n",
              255);
      }
    }
#line 342
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 344
    tmp = atoi((char const   *)optarg);
#line 344
    base_port = (__u16 )tmp;
    }
#line 345
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 347
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  argc -= optind;
#line 352
  argv += optind;
#line 354
  if (argc != 1) {
    {
#line 355
    usage();
    }
  }
  {
#line 357
  fd = socket(2, 2, 0);
  }
#line 358
  if (fd < 0) {
    {
#line 359
    perror("socket");
#line 360
    exit(1);
    }
  }
#line 362
  target.sin_family = (sa_family_t )2;
#line 365
  if (! base_port) {
    {
#line 366
    p = strchr((char const   *)*(argv + 0), '/');
    }
#line 367
    if (p) {
      {
#line 368
      *p = (char)0;
#line 369
      tmp___0 = atoi((char const   *)(p + 1));
#line 369
      base_port = (__u16 )tmp___0;
      }
    } else {
#line 371
      base_port = (__u16 )44444;
    }
  }
  {
#line 374
  p = *(argv + 0);
#line 383
  he = gethostbyname2((char const   *)p, 2);
  }
#line 384
  if ((unsigned long )he == (unsigned long )((void *)0)) {
    {
#line 385
    herror("gethostbyname2");
#line 386
    exit(1);
    }
  }
  {
#line 393
  memcpy((void */* __restrict  */)(& target.sin_addr), (void const   */* __restrict  */)*(he->h_addr_list + 0),
         (size_t )4);
#line 395
  on = 3;
#line 396
  tmp___1 = setsockopt(fd, 0, 10, (void const   *)(& on), (socklen_t )sizeof(on));
  }
#line 396
  if (tmp___1) {
    {
#line 396
    on = 2;
#line 396
    tmp___2 = setsockopt(fd, 0, 10, (void const   *)(& on), (socklen_t )sizeof(on));
    }
#line 396
    if (tmp___2) {
      {
#line 399
      perror("IP_MTU_DISCOVER");
#line 400
      exit(1);
      }
    }
  }
  {
#line 402
  on = 1;
#line 403
  tmp___3 = setsockopt(fd, 0, 11, (void const   *)(& on), (socklen_t )sizeof(on));
  }
#line 403
  if (tmp___3) {
    {
#line 404
    perror("IP_RECVERR");
#line 405
    exit(1);
    }
  }
  {
#line 407
  tmp___4 = setsockopt(fd, 0, 12, (void const   *)(& on), (socklen_t )sizeof(on));
  }
#line 407
  if (tmp___4) {
    {
#line 408
    perror("IP_RECVTTL");
#line 409
    exit(1);
    }
  }
  {
#line 412
  pktbuf = malloc((size_t )mtu);
  }
#line 413
  if (! pktbuf) {
    {
#line 414
    perror("malloc");
#line 415
    exit(1);
    }
  }
#line 418
  ttl = 1;
  {
#line 418
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 418
    if (! (ttl <= max_hops)) {
#line 418
      goto while_break___0;
    }
    {
#line 422
    on = ttl;
#line 423
    tmp___5 = setsockopt(fd, 0, 2, (void const   *)(& on), (socklen_t )sizeof(on));
    }
#line 423
    if (tmp___5) {
      {
#line 424
      perror("IP_TTL");
#line 425
      exit(1);
      }
    }
    restart: 
#line 429
    i = 0;
    {
#line 429
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 429
      if (! (i < 3)) {
#line 429
        goto while_break___1;
      }
      {
#line 432
      old_mtu = mtu;
#line 433
      res = probe_ttl(fd, ttl);
      }
#line 434
      if (mtu != old_mtu) {
#line 435
        goto restart;
      }
#line 436
      if (res == 0) {
#line 437
        goto done;
      }
#line 438
      if (res > 0) {
#line 439
        goto while_break___1;
      }
#line 429
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 442
    if (res < 0) {
      {
#line 443
      printf((char const   */* __restrict  */)"%2d:  no reply\n", ttl);
      }
    }
#line 418
    ttl ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 445
  printf((char const   */* __restrict  */)"     Too many hops: pmtu %d\n", mtu);
  }
  done: 
  {
#line 447
  printf((char const   */* __restrict  */)"     Resume: pmtu %d ", mtu);
  }
#line 448
  if (hops_to >= 0) {
    {
#line 449
    printf((char const   */* __restrict  */)"hops %d ", hops_to);
    }
  }
#line 450
  if (hops_from >= 0) {
    {
#line 451
    printf((char const   */* __restrict  */)"back %d ", hops_from);
    }
  }
  {
#line 452
  printf((char const   */* __restrict  */)"\n");
#line 453
  exit(0);
  }
}
}
