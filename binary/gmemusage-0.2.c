/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_16 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_16 XGCValues;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_17 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_17 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_18 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_18 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_19 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_19 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_20 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_20 ScreenFormat;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_26 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_26 XColor;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_35 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_35 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_36 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_36 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_37 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_37 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_38 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_38 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_39 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_39 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_40 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_40 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_41 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_41 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_42 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_42 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_43 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_43 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_44 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_44 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_45 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_45 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_46 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_46 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_47 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_47 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_48 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_48 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_49 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_49 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_50 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_50 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_51 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_51 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_52 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_52 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_53 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_53 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_54 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_54 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_55 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_55 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_56 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_56 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_57 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_57 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_58 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_58 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_59 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_59 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_60 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_60 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_61 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_61 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_62 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_62 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_64 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_63 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_64 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_63 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_65 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_65 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_66 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_66 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_67 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_67 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_68 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_68 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_69 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_69 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1029 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_70 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1029 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_70 XCharStruct;
#line 1042 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_71 {
   Atom name ;
   unsigned long card32 ;
};
#line 1042 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_71 XFontProp;
#line 1047 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_72 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1047 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_72 XFontStruct;
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_95 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_94 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_95 min_aspect ;
   struct __anonstruct_min_aspect_95 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_94 XSizeHints;
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_96 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_96 XWMHints;
#line 163 "/usr/include/X11/Xutil.h"
struct __anonstruct_XTextProperty_97 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
#line 163 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XTextProperty_97 XTextProperty;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_100 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_100 XClassHint;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 12 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/common.h"
struct ProcInfo {
   char procname[14] ;
   int totMem ;
   int totRSS ;
   int nProcs ;
};
#line 404 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
struct XProcInfo {
   struct ProcInfo *pi ;
   int pixelHeight ;
   int base ;
   int midpoint ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 160 "/usr/include/X11/Xresource.h"
struct __anonstruct_XrmValue_107 {
   unsigned int size ;
   XPointer addr ;
};
#line 160 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmValue_107 XrmValue;
#line 175 "/usr/include/X11/Xresource.h"
typedef struct _XrmHashBucketRec *XrmDatabase;
#line 326
enum __anonenum_XrmOptionKind_108 {
    XrmoptionNoArg = 0,
    XrmoptionIsArg = 1,
    XrmoptionStickyArg = 2,
    XrmoptionSepArg = 3,
    XrmoptionResArg = 4,
    XrmoptionSkipArg = 5,
    XrmoptionSkipLine = 6,
    XrmoptionSkipNArgs = 7
} ;
#line 326 "/usr/include/X11/Xresource.h"
typedef enum __anonenum_XrmOptionKind_108 XrmOptionKind;
#line 338 "/usr/include/X11/Xresource.h"
struct __anonstruct_XrmOptionDescRec_109 {
   char *option ;
   char *specifier ;
   XrmOptionKind argKind ;
   XPointer value ;
};
#line 338 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmOptionDescRec_109 XrmOptionDescRec;
#line 338 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmOptionDescRec_109 *XrmOptionDescList;
#line 103 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
struct __anonstruct_argtype_121 {
   caddr_t *var ;
   char *name ;
   char *class ;
   char *def ;
   int type ;
};
#line 103 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
typedef struct __anonstruct_argtype_121 argtype;
#line 1406 "/usr/include/X11/Xlib.h"
extern XFontStruct *XLoadQueryFont(Display * , char const   * ) ;
#line 1495
extern Display *XOpenDisplay(char const   * ) ;
#line 1527
extern char *XDisplayName(char const   * ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1609
extern Pixmap XCreatePixmap(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int  ) ;
#line 1616
extern Pixmap XCreateBitmapFromData(Display * , Drawable  , char const   * , unsigned int  ,
                                    unsigned int  ) ;
#line 1633
extern Window XCreateSimpleWindow(Display * , Window  , int  , int  , unsigned int  ,
                                  unsigned int  , unsigned int  , unsigned long  ,
                                  unsigned long  ) ;
#line 1970
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2022
extern int XBell(Display * , int  ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2196
extern int XCopyArea(Display * , Drawable  , Drawable  , GC  , int  , int  , unsigned int  ,
                     unsigned int  , int  , int  ) ;
#line 2354
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 2416
extern int XDrawString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                       int  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2519
extern int XFlush(Display * ) ;
#line 2573
extern int XFreeGC(Display * , GC  ) ;
#line 2582
extern int XFreePixmap(Display * , Pixmap  ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2862
extern int XParseColor(Display * , Colormap  , char const   * , XColor * ) ;
#line 2869
extern int XParseGeometry(char const   * , int * , int * , unsigned int * , unsigned int * ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3227
extern int XSetFont(Display * , GC  , Font  ) ;
#line 3239
extern int XSetForeground(Display * , GC  , unsigned long  ) ;
#line 3270
extern int XSetLineAttributes(Display * , GC  , unsigned int  , int  , int  , int  ) ;
#line 3446
extern int XTextWidth(XFontStruct * , char const   * , int  ) ;
#line 3507
extern int XUnloadFont(Display * , Font  ) ;
#line 366 "/usr/include/X11/Xutil.h"
extern XClassHint *XAllocClassHint(void) ;
#line 374
extern XSizeHints *XAllocSizeHints(void) ;
#line 382
extern XWMHints *XAllocWMHints(void) ;
#line 534
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 665
extern void XSetWMProperties(Display * , Window  , XTextProperty * , XTextProperty * ,
                             char ** , int  , XSizeHints * , XWMHints * , XClassHint * ) ;
#line 733
extern int XStringListToTextProperty(char ** , int  , XTextProperty * ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/memusage.xbm"
static unsigned char memusage_bits[128]  = 
#line 3 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/memusage.xbm"
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)96,      (unsigned char)127, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)28,      (unsigned char)127, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)3,      (unsigned char)0, 
        (unsigned char)8,      (unsigned char)0,      (unsigned char)113,      (unsigned char)127, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)15,      (unsigned char)127, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)8,      (unsigned char)0,      (unsigned char)127,      (unsigned char)127, 
        (unsigned char)8,      (unsigned char)0,      (unsigned char)1,      (unsigned char)127, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)127,      (unsigned char)127, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)1,      (unsigned char)127, 
        (unsigned char)8,      (unsigned char)0,      (unsigned char)15,      (unsigned char)0, 
        (unsigned char)8,      (unsigned char)0,      (unsigned char)113,      (unsigned char)127, 
        (unsigned char)8,      (unsigned char)0,      (unsigned char)1,      (unsigned char)127, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)127,      (unsigned char)127, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)1,      (unsigned char)127, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)121,      (unsigned char)127, 
        (unsigned char)8,      (unsigned char)0,      (unsigned char)7,      (unsigned char)127, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)127,      (unsigned char)127, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)1,      (unsigned char)127, 
        (unsigned char)8,      (unsigned char)0,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)8,      (unsigned char)0,      (unsigned char)127,      (unsigned char)127, 
        (unsigned char)248,      (unsigned char)255,      (unsigned char)1,      (unsigned char)127, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/common.h"
struct ProcInfo *AllProcs(int *n ) ;
#line 31
void makeProcs(void) ;
#line 32
int sysmem ;
#line 40 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/common.h"
char progname[128]  ;
#line 40
char *version ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/defaults.h"
char *dGeometry ;
#line 16
char *dDisplay ;
#line 16
char *dFont ;
#line 16
char *dForeground ;
#line 16
char *dBackground ;
#line 16
char *dColor[9] ;
#line 23
int dnColors ;
#line 23
int dUpdate ;
#line 23
int dThreshhold ;
#line 27
void GetInitialResources(int *argc , char **argv ) ;
#line 27
void GetResources(Display *display___0 , int argc , char **argv ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static Display *display  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static int screen_num  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
char *version  =    (char *)"0.1";
#line 54 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static Window win  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static int window_width  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static int window_height  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static int nColors  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static int Threshhold  =    -1;
#line 67 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static XColor Foreground  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static XColor Background  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static XFontStruct *font_info  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static int Exposed  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static GC gc[9]  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static GC blackGC  ;
#line 85
void getGCs(Window win___0 , Colormap cmap ) ;
#line 92
void draw_window(void) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
void main(int argc , char **argv ) 
{ 
  int default_height ;
  int default_width ;
  int default_x ;
  int default_y ;
  int x ;
  int y ;
  int width ;
  int height ;
  unsigned int border_width ;
  unsigned int display_width ;
  unsigned int display_height ;
  char *window_name ;
  char *icon_name ;
  Pixmap icon_pixmap ;
  XSizeHints *size_hints ;
  XEvent report ;
  int screen_num___0 ;
  Screen *screen_ptr ;
  XWMHints *wm_hints ;
  XClassHint *class_hints ;
  XTextProperty windowName ;
  XTextProperty iconName ;
  Colormap cmap ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char keybuf[10] ;
  KeySym keysym ;
  int count ;
  XComposeStatus composestatus ;
  register int i ;
  register int j ;

  {
  {
#line 102
  x = 0;
#line 102
  y = 0;
#line 107
  border_width = 4U;
#line 111
  window_name = (char *)"gmemusage";
#line 111
  icon_name = (char *)"gmemusage";
#line 136
  tmp___0 = strrchr((char const   *)*(argv + 0), '/');
  }
#line 136
  if (tmp___0) {
    {
#line 138
    tmp = strrchr((char const   *)*(argv + 0), '/');
#line 138
    strcpy((char */* __restrict  */)(progname), (char const   */* __restrict  */)(tmp + 1));
    }
  } else {
    {
#line 142
    strcpy((char */* __restrict  */)(progname), (char const   */* __restrict  */)*(argv + 0));
    }
  }
  {
#line 148
  size_hints = XAllocSizeHints();
  }
#line 148
  if (! size_hints) {
    {
#line 150
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failure allocating SizeHints\n",
            progname);
#line 151
    exit(1);
    }
  }
  {
#line 153
  wm_hints = XAllocWMHints();
  }
#line 153
  if (! wm_hints) {
    {
#line 155
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failure allocating WMHints\n",
            progname);
#line 156
    exit(1);
    }
  }
  {
#line 158
  class_hints = XAllocClassHint();
  }
#line 158
  if (! class_hints) {
    {
#line 160
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failure allocating ClassHints\n",
            progname);
#line 161
    exit(1);
    }
  }
  {
#line 166
  GetInitialResources(& argc, argv);
#line 167
  display = XOpenDisplay((char const   *)dDisplay);
  }
#line 167
  if ((unsigned long )display == (unsigned long )((void *)0)) {
    {
#line 169
    tmp___1 = XDisplayName((char const   *)dDisplay);
#line 169
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot connect to X server %s\n",
            progname, tmp___1);
#line 171
    exit(1);
    }
  }
  {
#line 173
  GetResources(display, argc, argv);
#line 174
  XParseGeometry((char const   *)dGeometry, & default_x, & default_y, (unsigned int *)(& default_width),
                 (unsigned int *)(& default_height));
#line 177
  screen_num___0 = ((_XPrivDisplay )display)->default_screen;
#line 178
  screen_ptr = ((_XPrivDisplay )display)->screens + ((_XPrivDisplay )display)->default_screen;
#line 180
  display_width = (unsigned int )(((_XPrivDisplay )display)->screens + screen_num___0)->width;
#line 181
  display_height = (unsigned int )(((_XPrivDisplay )display)->screens + screen_num___0)->height;
#line 185
  cmap = (((_XPrivDisplay )display)->screens + ((_XPrivDisplay )display)->default_screen)->cmap;
#line 186
  tmp___2 = XParseColor(display, cmap, (char const   *)dForeground, & Foreground);
  }
#line 186
  if (tmp___2) {
    {
#line 194
    XAllocColor(display, cmap, & Foreground);
    }
  } else {
    {
#line 188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Cannot parse color %s\n",
            progname, dForeground);
#line 190
    Foreground.pixel = (((_XPrivDisplay )display)->screens + screen_num___0)->black_pixel;
    }
  }
  {
#line 196
  tmp___3 = XParseColor(display, cmap, (char const   *)dBackground, & Background);
  }
#line 196
  if (tmp___3) {
    {
#line 204
    XAllocColor(display, cmap, & Background);
    }
  } else {
    {
#line 198
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Cannot parse color %s\n",
            progname, dBackground);
#line 200
    Background.pixel = (((_XPrivDisplay )display)->screens + screen_num___0)->white_pixel;
    }
  }
  {
#line 206
  width = default_width;
#line 207
  height = default_height;
#line 208
  win = XCreateSimpleWindow(display, (((_XPrivDisplay )display)->screens + screen_num___0)->root,
                            x, y, (unsigned int )width, (unsigned int )height, border_width,
                            Foreground.pixel, Background.pixel);
#line 226
  icon_pixmap = XCreateBitmapFromData(display, win, (char const   *)(memusage_bits),
                                      32U, 32U);
#line 228
  size_hints->flags = ((1L << 2) | (1L << 3)) | (1L << 4);
#line 229
  size_hints->min_width = default_width;
#line 230
  size_hints->min_height = default_height;
#line 231
  tmp___4 = XStringListToTextProperty(& window_name, 1, & windowName);
  }
#line 231
  if (tmp___4 == 0) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: struct allocation for windowName failed\n",
            progname);
#line 235
    exit(1);
    }
  }
  {
#line 237
  tmp___5 = XStringListToTextProperty(& icon_name, 1, & iconName);
  }
#line 237
  if (tmp___5 == 0) {
    {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: struct allocation for iconName failed\n",
            progname);
#line 241
    exit(1);
    }
  }
  {
#line 243
  wm_hints->initial_state = 1;
#line 244
  wm_hints->input = 1;
#line 245
  wm_hints->icon_pixmap = icon_pixmap;
#line 246
  wm_hints->flags = ((1L << 1) | (1L << 2)) | 1L;
#line 247
  class_hints->res_name = progname;
#line 248
  class_hints->res_class = (char *)"BasicWin";
#line 249
  XSetWMProperties(display, win, & windowName, & iconName, argv, argc, size_hints,
                   wm_hints, class_hints);
#line 252
  XSelectInput(display, win, (((1L << 15) | 1L) | (1L << 2)) | (1L << 17));
#line 255
  getGCs(win, cmap);
#line 257
  XMapWindow(display, win);
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 261
    XNextEvent(display, & report);
    }
    {
#line 273
    if (report.type == 12) {
#line 273
      goto case_12;
    }
#line 294
    if (report.type == 22) {
#line 294
      goto case_22;
    }
#line 319
    if (report.type == 4) {
#line 319
      goto case_4;
    }
#line 323
    if (report.type == 2) {
#line 323
      goto case_2;
    }
#line 380
    goto switch_default___1;
    case_12: /* CIL Label */ 
#line 274
    if (report.xexpose.count != 0) {
#line 276
      goto switch_break;
    }
    {
#line 289
    Exposed = 1;
#line 290
    draw_window();
    }
#line 292
    goto switch_break;
    case_22: /* CIL Label */ 
#line 295
    window_width = report.xconfigure.width;
#line 296
    window_height = report.xconfigure.height;
#line 317
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 320
    XBell(display, 10);
    }
#line 321
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 324
    count = XLookupString(& report.xkey, keybuf, (int )sizeof(keybuf), & keysym, & composestatus);
    }
#line 327
    if (keysym >= 65408UL) {
#line 327
      if (keysym <= 65465UL) {
#line 327
        goto _L;
      } else {
#line 327
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 327
    if (keysym >= 32UL) {
#line 327
      if (keysym <= 126UL) {
        _L: /* CIL Label */ 
#line 332
        i = 0;
        {
#line 332
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 332
          if (! keybuf[i]) {
#line 332
            goto while_break___0;
          }
          {
#line 339
          if ((int )keybuf[i] == 81) {
#line 339
            goto case_81;
          }
#line 339
          if ((int )keybuf[i] == 113) {
#line 339
            goto case_81;
          }
#line 348
          goto switch_default;
          case_81: /* CIL Label */ 
          case_113: /* CIL Label */ 
          {
#line 340
          XUnloadFont(display, font_info->fid);
#line 341
          j = 0;
          }
          {
#line 341
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 341
            if (! (j < nColors)) {
#line 341
              goto while_break___1;
            }
            {
#line 343
            XFreeGC(display, gc[j]);
#line 341
            j ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 345
          XCloseDisplay(display);
#line 346
          exit(0);
          }
          switch_default: /* CIL Label */ 
          {
#line 349
          XBell(display, 10);
          }
#line 350
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
#line 332
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 327
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 358
      if (keysym == 65362UL) {
#line 358
        goto case_65362;
      }
#line 362
      if (keysym == 65364UL) {
#line 362
        goto case_65364;
      }
#line 371
      goto switch_default___0;
      case_65362: /* CIL Label */ 
#line 359
      Threshhold += 10;
#line 360
      goto switch_break___1;
      case_65364: /* CIL Label */ 
#line 363
      Threshhold -= 10;
#line 364
      if (Threshhold < 10) {
        {
#line 366
        XBell(display, 0);
#line 367
        Threshhold = 10;
        }
      }
#line 369
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 375
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 378
    goto switch_break;
    switch_default___1: /* CIL Label */ 
#line 385
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 388
  exit(0);
  }
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static int nprocs  ;
#line 417 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static int oldThreshhold  ;
#line 423 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static struct ProcInfo *pi  ;
#line 425 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static struct XProcInfo *xpi  ;
#line 425 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static struct XProcInfo *oldxpi  ;
#line 430 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
static int done  =    0;
#line 393 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
void draw_window(void) 
{ 
  int pcWidth ;
  int pcHeight ;
  int pixelWidth ;
  int pixelHeight ;
  Pixmap pxm ;
  register int i ;
  int oldnprocs ;
  register struct XProcInfo *this ;
  int alarmsecs ;
  int basex ;
  int basey ;
  GC *thisGC ;
  int thxpi ;
  struct ProcInfo thProc ;
  int labelNumber ;
  int nLabels ;
  int longestLabel ;
  unsigned int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int lineSpace ;
  int longestLabelWidth ;
  int textXoffset ;
  int fontHeight ;
  char buf[128] ;
  char nprocbuf[10] ;
  size_t tmp___6 ;

  {
  {
#line 441
  thxpi = -1;
#line 445
  labelNumber = 0;
#line 445
  nLabels = 0;
#line 448
  longestLabel = 0;
#line 453
  signal(14, (void (*)(int  ))1);
#line 459
  tmp = alarm((unsigned int )dUpdate);
  }
#line 459
  if (tmp) {
#line 459
    if (done) {
#line 459
      tmp___0 = 1;
    } else {
#line 459
      tmp___0 = 0;
    }
  } else {
#line 459
    tmp___0 = 0;
  }
#line 459
  alarmsecs = tmp___0;
#line 459
  if (alarmsecs) {
    {
#line 467
    alarm((unsigned int )alarmsecs);
    }
  } else {
    {
#line 477
    oldxpi = xpi;
#line 478
    oldnprocs = nprocs;
#line 479
    makeProcs();
#line 480
    pi = AllProcs(& nprocs);
#line 481
    done = 1;
    }
  }
#line 486
  pcWidth = 40;
#line 487
  pixelWidth = (int )((double )(window_width * pcWidth) / 100.0);
#line 488
  pcHeight = 90;
#line 489
  pixelHeight = (int )((double )(window_height * pcHeight) / 100.0);
#line 490
  basex = 10;
#line 491
  basey = (window_height - (window_height - pixelHeight) / 2) - 1;
#line 492
  if (Threshhold < 0) {
#line 494
    Threshhold = dThreshhold;
  }
  {
#line 503
  tmp___1 = calloc((size_t )nprocs, sizeof(struct XProcInfo ));
#line 503
  xpi = (struct XProcInfo *)tmp___1;
  }
#line 503
  if ((unsigned long )xpi == (unsigned long )((void *)0)) {
    {
#line 505
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: calloc struct XProcInfo failed",
            progname);
#line 506
    perror("");
#line 507
    exit(1);
    }
  }
#line 509
  this = xpi;
#line 513
  i = 0;
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    if (! (i < nprocs)) {
#line 513
      goto while_break;
    }
#line 515
    if ((pi + i)->totRSS < Threshhold) {
      {
#line 515
      tmp___2 = strcmp((char const   *)((pi + i)->procname), "linux");
      }
#line 515
      if (tmp___2) {
        {
#line 515
        tmp___3 = strcmp((char const   *)((pi + i)->procname), "free");
        }
#line 515
        if (tmp___3) {
#line 519
          if (thxpi < 0) {
            {
#line 521
            thxpi = i;
#line 522
            sprintf((char */* __restrict  */)(thProc.procname), (char const   */* __restrict  */)"< %d",
                    Threshhold);
#line 523
            thProc.totRSS = (pi + i)->totRSS;
#line 524
            thProc.totMem = 0;
#line 525
            thProc.nProcs = (pi + i)->nProcs;
#line 526
            (this + i)->pi = & thProc;
            }
          } else {
#line 530
            ((this + thxpi)->pi)->nProcs += (pi + i)->nProcs;
#line 531
            ((this + thxpi)->pi)->totRSS += (pi + i)->totRSS;
          }
        }
      }
    }
#line 513
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  i = 0;
  {
#line 543
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 543
    if (! (i < nprocs)) {
#line 543
      goto while_break___0;
    }
#line 545
    if (i != thxpi) {
#line 547
      if ((pi + i)->totRSS < Threshhold) {
#line 549
        (this + i)->pi = (struct ProcInfo *)((void *)0);
#line 550
        goto __Cont;
      } else {
#line 554
        (this + i)->pi = pi + i;
      }
    }
    {
#line 557
    nLabels ++;
#line 562
    (this + i)->pixelHeight = (((this + i)->pi)->totRSS * pixelHeight) / sysmem;
#line 563
    basey -= (this + i)->pixelHeight;
#line 564
    (this + i)->base = basey;
#line 565
    (this + i)->midpoint = basey + (this + i)->pixelHeight / 2;
#line 566
    tmp___5 = strlen((char const   *)(((this + i)->pi)->procname));
    }
#line 566
    if (tmp___5 > (size_t )longestLabel) {
      {
#line 568
      tmp___4 = strlen((char const   *)(((this + i)->pi)->procname));
#line 568
      longestLabel = (int )tmp___4;
      }
    }
    __Cont: /* CIL Label */ 
#line 543
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 592
  pxm = XCreatePixmap(display, win, (unsigned int )window_width, (unsigned int )window_height,
                      (unsigned int )(((_XPrivDisplay )display)->screens + screen_num)->root_depth);
#line 599
  XFillRectangle(display, pxm, blackGC, 0, 0, (unsigned int )window_width, (unsigned int )window_height);
#line 605
  labelNumber = 0;
#line 606
  i = 0;
  }
  {
#line 606
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 606
    if (! (i < nprocs)) {
#line 606
      goto while_break___1;
    }
#line 608
    if (! (this + i)->pi) {
#line 610
      goto __Cont___0;
    }
    {
#line 612
    thisGC = & gc[labelNumber % nColors];
#line 616
    XFillRectangle(display, pxm, *thisGC, basex, (this + i)->base, (unsigned int )pixelWidth,
                   (unsigned int )(this + i)->pixelHeight);
#line 618
    labelNumber ++;
    }
    __Cont___0: /* CIL Label */ 
#line 606
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 624
  lineSpace = window_height / nLabels;
#line 633
  memset((void *)(buf), 'W', (size_t )(((longestLabel + 6) + 2) + 7));
#line 634
  longestLabelWidth = XTextWidth(font_info, (char const   *)(buf), ((longestLabel + 6) + 2) + 7);
#line 636
  textXoffset = (window_width - 10) - longestLabelWidth;
#line 638
  fontHeight = font_info->ascent + font_info->descent;
#line 639
  labelNumber = 0;
#line 640
  i = 0;
  }
  {
#line 640
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 640
    if (! (i < nprocs)) {
#line 640
      goto while_break___2;
    }
#line 642
    if (! (this + i)->pi) {
#line 644
      goto __Cont___1;
    }
    {
#line 646
    thisGC = & gc[labelNumber % nColors];
#line 647
    XDrawLine(display, pxm, *thisGC, 10 + pixelWidth, (this + i)->midpoint, textXoffset - 2,
              (window_height - labelNumber * lineSpace) - lineSpace / 2);
    }
#line 653
    if (((this + i)->pi)->nProcs > 1) {
      {
#line 655
      sprintf((char */* __restrict  */)(nprocbuf), (char const   */* __restrict  */)"(%d)",
              ((this + i)->pi)->nProcs);
      }
    } else {
#line 659
      nprocbuf[0] = (char )'\000';
    }
    {
#line 661
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%-*s %6s : %5dK",
            longestLabel, ((this + i)->pi)->procname, nprocbuf, ((this + i)->pi)->totRSS);
#line 676
    tmp___6 = strlen((char const   *)(buf));
#line 676
    XDrawString(display, pxm, *thisGC, textXoffset, ((window_height - labelNumber * lineSpace) - (lineSpace - fontHeight) / 2) - 2,
                (char const   *)(buf), (int )tmp___6);
#line 681
    labelNumber ++;
    }
    __Cont___1: /* CIL Label */ 
#line 640
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 684
  XCopyArea(display, pxm, win, blackGC, 0, 0, (unsigned int )window_width, (unsigned int )window_height,
            0, 0);
#line 687
  XFreePixmap(display, pxm);
#line 689
  XFlush(display);
#line 693
  oldThreshhold = Threshhold;
#line 694
  Exposed = 0;
  }
#line 695
  if (oldxpi) {
    {
#line 697
    free((void *)oldxpi);
#line 698
    oldxpi = (struct XProcInfo *)((void *)0);
    }
  }
  {
#line 703
  signal(14, (void (*)(int  ))(& draw_window));
  }
#line 704
  return;
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/gmemusage.c"
void getGCs(Window win___0 , Colormap cmap ) 
{ 
  unsigned long valuemask ;
  XGCValues values ;
  unsigned int line_width ;
  int line_style ;
  int cap_style ;
  int join_style ;
  XColor rgb ;
  register int i ;
  int tmp ;

  {
  {
#line 710
  valuemask = 0UL;
#line 714
  line_width = 0U;
#line 716
  line_style = 0;
#line 716
  cap_style = 2;
#line 716
  join_style = 1;
#line 725
  font_info = XLoadQueryFont(display, (char const   *)dFont);
  }
#line 725
  if ((unsigned long )font_info == (unsigned long )((void *)0)) {
    {
#line 729
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot load font %s\n",
            progname, dFont);
#line 730
    exit(1);
    }
  }
#line 732
  nColors = dnColors;
#line 733
  i = 0;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (! (i < nColors)) {
#line 733
      goto while_break;
    }
#line 735
    if (*(dColor[i] + 0)) {
      {
#line 735
      tmp = XParseColor(display, cmap, (char const   *)dColor[i], & rgb);
      }
#line 735
      if (tmp) {
        {
#line 744
        XAllocColor(display, cmap, & rgb);
        }
      } else {
        {
#line 738
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Cannot parse color %s\n",
                progname, dColor[i]);
#line 740
        rgb.pixel = (((_XPrivDisplay )display)->screens + screen_num)->black_pixel;
        }
      }
    } else {
      {
#line 744
      XAllocColor(display, cmap, & rgb);
      }
    }
    {
#line 746
    gc[i] = XCreateGC(display, win___0, valuemask, & values);
#line 747
    XSetForeground(display, gc[i], rgb.pixel);
#line 748
    XSetFont(display, gc[i], font_info->fid);
#line 749
    XSetLineAttributes(display, gc[i], line_width, line_style, cap_style, join_style);
#line 733
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 752
  valuemask |= (unsigned long )(1L << 1);
#line 753
  values.plane_mask = (unsigned long )(~ 0L);
#line 754
  blackGC = XCreateGC(display, win___0, valuemask, & values);
#line 755
  XSetForeground(display, blackGC, (((_XPrivDisplay )display)->screens + screen_num)->black_pixel);
  }
#line 756
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 489
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/common.h"
void addProc(char *procname , int mem , int rss ) ;
#line 25
void ClearProcs(void) ;
#line 32
int kernelmem ;
#line 32
int freemem ;
#line 32
int buffermem ;
#line 18 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/proc.c"
int sysmem  =    0;
#line 18 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/proc.c"
int kernelmem  =    0;
#line 18 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/proc.c"
int freemem  =    0;
#line 18 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/proc.c"
int buffermem  =    0;
#line 26 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/proc.c"
static void SetMemInfo(void) 
{ 
  struct stat s ;
  char buf[128] ;
  FILE *meminfo ;
  int totalmem ;
  char const   *MemLine ;
  int MemLineLen ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 37
  MemLine = "Mem:";
#line 39
  tmp = strlen(MemLine);
#line 39
  MemLineLen = (int )tmp;
#line 45
  tmp___0 = stat((char const   */* __restrict  */)"/proc/kcore", (struct stat */* __restrict  */)(& s));
  }
#line 45
  if (tmp___0 < 0) {
    {
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot stat /proc/kcore",
            progname);
#line 48
    perror("");
#line 49
    exit(1);
    }
  }
  {
#line 51
  sysmem = (int )s.st_size;
#line 56
  meminfo = fopen((char const   */* __restrict  */)"/proc/meminfo", (char const   */* __restrict  */)"r");
  }
#line 56
  if ((unsigned long )meminfo == (unsigned long )((void *)0)) {
    {
#line 58
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot open /proc/meminfo",
            progname);
#line 59
    perror("");
#line 60
    exit(1);
    }
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 62
    tmp___2 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)meminfo);
    }
#line 62
    if (! tmp___2) {
#line 62
      goto while_break;
    }
    {
#line 64
    tmp___1 = strncmp((char const   *)(buf), MemLine, (size_t )MemLineLen);
    }
#line 64
    if (! tmp___1) {
      {
#line 67
      sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %d %*d %d %*d %d",
             & totalmem, & freemem, & buffermem);
      }
#line 69
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  sysmem /= 1024;
#line 73
  totalmem /= 1024;
#line 74
  freemem /= 1024;
#line 75
  buffermem /= 1024;
#line 76
  kernelmem = sysmem - totalmem;
#line 77
  fclose(meminfo);
  }
#line 78
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/proc.c"
void makeProcs(void) 
{ 
  DIR *proc ;
  struct dirent *procdir ;
  FILE *StatusFile ;
  char buf[128] ;
  char procName[14] ;
  int procSize ;
  int procRSS ;
  int procData ;
  int procStk ;
  int procExe ;
  char const   *NameLine ;
  char const   *VmSizeLine ;
  char const   *VmRSSLine ;
  char const   *VmDataLine ;
  char const   *VmStkLine ;
  char const   *VmExeLine ;
  int NameLineLen ;
  size_t tmp ;
  int VmSizeLineLen ;
  size_t tmp___0 ;
  int VmDataLineLen ;
  size_t tmp___1 ;
  int VmStkLineLen ;
  size_t tmp___2 ;
  int VmExeLineLen ;
  size_t tmp___3 ;
  int VmRSSLineLen ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 103
  NameLine = "Name:";
#line 103
  VmSizeLine = "VmSize:";
#line 103
  VmRSSLine = "VmRSS";
#line 103
  VmDataLine = "VmData";
#line 103
  VmStkLine = "VmStk";
#line 103
  VmExeLine = "VmExe";
#line 110
  tmp = strlen(NameLine);
#line 110
  NameLineLen = (int )tmp;
#line 110
  tmp___0 = strlen(VmSizeLine);
#line 110
  VmSizeLineLen = (int )tmp___0;
#line 110
  tmp___1 = strlen(VmDataLine);
#line 110
  VmDataLineLen = (int )tmp___1;
#line 110
  tmp___2 = strlen(VmStkLine);
#line 110
  VmStkLineLen = (int )tmp___2;
#line 110
  tmp___3 = strlen(VmExeLine);
#line 110
  VmExeLineLen = (int )tmp___3;
#line 110
  tmp___4 = strlen(VmRSSLine);
#line 110
  VmRSSLineLen = (int )tmp___4;
#line 118
  proc = opendir("/proc");
  }
#line 118
  if ((unsigned long )proc == (unsigned long )((void *)0)) {
    {
#line 120
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unable to open /proc",
            progname);
#line 121
    perror("");
#line 122
    exit(1);
    }
  }
  {
#line 124
  ClearProcs();
#line 128
  SetMemInfo();
#line 134
  addProc((char *)"linux", kernelmem + buffermem, kernelmem + buffermem);
#line 142
  sysmem = 0;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 143
    procdir = readdir(proc);
    }
#line 143
    if (! procdir) {
#line 143
      goto while_break;
    }
    {
#line 145
    tmp___5 = index("1234567890", (int )procdir->d_name[0]);
    }
#line 145
    if (! tmp___5) {
#line 147
      goto while_continue;
    }
    {
#line 149
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"/proc/%s/status",
            procdir->d_name);
#line 150
    StatusFile = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
    }
#line 150
    if ((unsigned long )StatusFile == (unsigned long )((void *)0)) {
      {
#line 152
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot open %s for reading",
              progname, buf);
#line 154
      perror("");
      }
#line 155
      goto while_continue;
    }
#line 157
    procExe = 0;
#line 157
    procStk = procExe;
#line 157
    procData = procStk;
#line 157
    procSize = procData;
#line 157
    procRSS = procSize;
    {
#line 158
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 158
      tmp___12 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)StatusFile);
      }
#line 158
      if (! tmp___12) {
#line 158
        goto while_break___0;
      }
      {
#line 164
      tmp___11 = strncmp((char const   *)(buf), NameLine, (size_t )NameLineLen);
      }
#line 164
      if (tmp___11) {
        {
#line 169
        tmp___10 = strncmp((char const   *)(buf), VmSizeLine, (size_t )VmSizeLineLen);
        }
#line 169
        if (tmp___10) {
          {
#line 174
          tmp___9 = strncmp((char const   *)(buf), VmRSSLine, (size_t )VmRSSLineLen);
          }
#line 174
          if (tmp___9) {
            {
#line 179
            tmp___8 = strncmp((char const   *)(buf), VmDataLine, (size_t )VmDataLineLen);
            }
#line 179
            if (tmp___8) {
              {
#line 184
              tmp___7 = strncmp((char const   *)(buf), VmStkLine, (size_t )VmStkLineLen);
              }
#line 184
              if (tmp___7) {
                {
#line 189
                tmp___6 = strncmp((char const   *)(buf), VmExeLine, (size_t )VmExeLineLen);
                }
#line 189
                if (! tmp___6) {
                  {
#line 192
                  sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %d",
                         & procExe);
                  }
                }
              } else {
                {
#line 187
                sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %d",
                       & procStk);
                }
              }
            } else {
              {
#line 182
              sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %d",
                     & procData);
              }
            }
          } else {
            {
#line 177
            sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %d",
                   & procRSS);
            }
          }
        } else {
          {
#line 172
          sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %d",
                 & procSize);
          }
        }
      } else {
        {
#line 167
        sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %s",
               procName);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 195
    fclose(StatusFile);
#line 196
    addProc(procName, procSize, (procData + procStk) + procExe);
#line 197
    sysmem += (procData + procStk) + procExe;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 199
  closedir(proc);
#line 200
  sysmem += (kernelmem + buffermem) + freemem;
#line 201
  addProc((char *)"free", freemem, freemem);
  }
#line 202
  return;
}
}
#line 49 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/common.h"
struct ProcInfo *NextProc(void) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/hash.c"
int const   minProcs  =    (int const   )16;
#line 18 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/hash.c"
static struct ProcInfo *procs  =    (struct ProcInfo *)((void *)0);
#line 20 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/hash.c"
static struct ProcInfo *nextproc  =    (struct ProcInfo *)((void *)0);
#line 22 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/hash.c"
static int nProcs  =    0;
#line 24 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/hash.c"
static int lastallocated  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/hash.c"
struct ProcInfo *LookupProc(char *name ) 
{ 
  register struct ProcInfo *pi___0 ;
  int tmp ;

  {
#line 40
  pi___0 = procs;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (pi___0 - procs < (long )nProcs)) {
#line 40
      goto while_break;
    }
    {
#line 42
    tmp = strcmp(pi___0->procname, name);
    }
#line 42
    if (! tmp) {
#line 44
      return (pi___0);
    }
#line 40
    pi___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return ((struct ProcInfo *)((void *)0));
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/hash.c"
void addProc(char *procname , int mem , int rss ) 
{ 
  register struct ProcInfo *thisproc ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 61
  if (! procs) {
    {
#line 63
    lastallocated = (int )minProcs;
#line 64
    tmp = calloc((size_t )minProcs, sizeof(struct ProcInfo ));
#line 64
    procs = (struct ProcInfo *)tmp;
    }
#line 64
    if ((unsigned long )procs == (unsigned long )((void *)0)) {
      {
#line 67
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot alloc %d processes",
              progname, minProcs);
#line 69
      perror("");
#line 70
      exit(1);
      }
    }
    {
#line 73
    nextproc = procs;
#line 73
    thisproc = nextproc;
#line 74
    strcpy(thisproc->procname, procname);
#line 75
    thisproc->totMem = mem;
#line 76
    thisproc->totRSS = rss;
#line 77
    thisproc->nProcs = 1;
#line 78
    nProcs = 1;
    }
  } else {
    {
#line 84
    thisproc = LookupProc(procname);
    }
#line 84
    if (thisproc) {
#line 109
      thisproc->totMem += mem;
#line 110
      thisproc->totRSS += rss;
#line 111
      (thisproc->nProcs) ++;
    } else {
#line 86
      if (nProcs == lastallocated) {
        {
#line 88
        lastallocated *= 2;
#line 89
        tmp___0 = realloc((void *)procs, (unsigned long )lastallocated * sizeof(struct ProcInfo ));
#line 89
        procs = (struct ProcInfo *)tmp___0;
        }
#line 89
        if ((unsigned long )procs == (unsigned long )((void *)0)) {
          {
#line 93
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot alloc %d processes",
                  progname, lastallocated);
#line 95
          perror("");
#line 96
          exit(1);
          }
        }
      }
      {
#line 100
      thisproc = procs + nProcs;
#line 101
      strcpy(thisproc->procname, procname);
#line 102
      thisproc->totMem = mem;
#line 103
      thisproc->totRSS = rss;
#line 104
      thisproc->nProcs = 1;
#line 105
      nProcs ++;
      }
    }
  }
#line 113
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/hash.c"
struct ProcInfo *NextProc(void) 
{ 
  struct ProcInfo *tmp ;

  {
#line 121
  if (nextproc - procs == (long )nProcs) {
#line 123
    return ((struct ProcInfo *)((void *)0));
  } else {
#line 127
    tmp = nextproc;
#line 127
    nextproc ++;
#line 127
    return (tmp);
  }
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/hash.c"
struct ProcInfo *AllProcs(int *n ) 
{ 


  {
#line 133
  *n = nProcs;
#line 134
  return (procs);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/hash.c"
void ClearProcs(void) 
{ 


  {
#line 143
  if (procs) {
    {
#line 145
    free((void *)procs);
#line 146
    procs = (struct ProcInfo *)((void *)0);
#line 147
    nProcs = 0;
#line 147
    lastallocated = nProcs;
#line 148
    nextproc = (struct ProcInfo *)((void *)0);
    }
  }
#line 150
  return;
}
}
#line 1499 "/usr/include/X11/Xlib.h"
extern void XrmInitialize(void) ;
#line 1731
extern char *XResourceManagerString(Display * ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 178 "/usr/include/X11/Xresource.h"
extern void XrmDestroyDatabase(XrmDatabase  ) ;
#line 223
extern int XrmGetResource(XrmDatabase  , char const   * , char const   * , char ** ,
                          XrmValue * ) ;
#line 276
extern XrmDatabase XrmGetStringDatabase(char const   * ) ;
#line 285
extern void XrmMergeDatabases(XrmDatabase  , XrmDatabase * ) ;
#line 346
extern void XrmParseCommand(XrmDatabase * , XrmOptionDescList  , int  , char const   * ,
                            int * , char ** ) ;
#line 38 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/defaults.h"
char *dGeometry  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/defaults.h"
char *dDisplay  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/defaults.h"
char *dFont  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/defaults.h"
char *dForeground  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/defaults.h"
char *dBackground  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/defaults.h"
char *dColor[9]  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/defaults.h"
int dnColors  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/defaults.h"
int dUpdate  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/defaults.h"
int dThreshhold  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
static XrmOptionDescRec optionTable[16]  = 
#line 48 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
  {      {(char *)"-geometry", (char *)".geometry", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-ncolors",
      (char *)".ncolors", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-color1", (char *)".color1", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-color2",
      (char *)".color2", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-color3", (char *)".color3", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-color4",
      (char *)".color4", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-color5", (char *)".color5", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-color6",
      (char *)".color6", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-color7", (char *)".color7", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-color8",
      (char *)".color8", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-color9", (char *)".color9", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-font",
      (char *)".font", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-foreground", (char *)".foreground", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-background",
      (char *)".background", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-update", (char *)".update", (XrmOptionKind )3, (caddr_t )((void *)0)}, 
        {(char *)"-threshhold",
      (char *)".threshhold", (XrmOptionKind )3, (caddr_t )((void *)0)}};
#line 67 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
int const   optionEntries  =    (int const   )(sizeof(optionTable) / sizeof(optionTable[0]));
#line 70 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
static XrmOptionDescRec displayTable[1]  = {      {(char *)"-display", (char *)".display", (XrmOptionKind )3, (caddr_t )((void *)0)}};
#line 74 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
int const   displayEntries  =    (int const   )(sizeof(displayTable) / sizeof(displayTable[0]));
#line 77 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
static XrmOptionDescRec nameTable[1]  = {      {(char *)"-name", (char *)".name", (XrmOptionKind )3, (caddr_t )((void *)0)}};
#line 81 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
int const   nameEntries  =    (int const   )(sizeof(nameTable) / sizeof(nameTable[0]));
#line 86 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
static char *dName  ;
#line 114 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
static argtype optionVars[16]  = 
#line 114
  {      {& dFont, (char *)"font", (char *)"Font", (char *)"fixed", 0}, 
        {& dGeometry, (char *)"geometry", (char *)"Geometry", (char *)"320x400", 0}, 
        {(caddr_t *)(& dnColors), (char *)"ncolors", (char *)"NColors", (char *)"3",
      1}, 
        {& dColor[0], (char *)"color1", (char *)"Color", (char *)"maroon", 0}, 
        {& dColor[1], (char *)"color2", (char *)"Color", (char *)"OliveDrab", 0}, 
        {& dColor[2], (char *)"color3", (char *)"Color", (char *)"SlateBlue", 0}, 
        {& dColor[3], (char *)"color4", (char *)"Color", (char *)"", 0}, 
        {& dColor[4], (char *)"color5", (char *)"Color", (char *)"", 0}, 
        {& dColor[5], (char *)"color6", (char *)"Color", (char *)"", 0}, 
        {& dColor[6], (char *)"color7", (char *)"Color", (char *)"", 0}, 
        {& dColor[7], (char *)"color8", (char *)"Color", (char *)"", 0}, 
        {& dColor[8], (char *)"color9", (char *)"Color", (char *)"", 0}, 
        {& dForeground, (char *)"foreground", (char *)"Foreground", (char *)"black",
      0}, 
        {& dBackground, (char *)"background", (char *)"Background", (char *)"grey4",
      0}, 
        {(caddr_t *)(& dUpdate), (char *)"update", (char *)"Interval", (char *)"5", 1}, 
        {(caddr_t *)(& dThreshhold),
      (char *)"threshhold", (char *)"Threshhold", (char *)"400", 1}};
#line 135 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
int const   nVars  =    (int const   )(sizeof(optionVars) / sizeof(optionVars[0]));
#line 141 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
static void Help(void) 
{ 


  {
  {
#line 144
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gmemusage ver %s by Raju (OldMonk) Mathur\nUsage: %s [options]\nwhere options (defaults/resources in brackets) are:\n    -name resourcename  Class name to use for resources (%s) (name)\n    -display display    X server to contact ($DISPLAY) (display)\n    -geometry geometry  Initial window geometry (%s) (geometry)\n    -font font          Text font (%s) (font)\n    -background color   Color to use for window background (%s) (background)\n    -update seconds     Update interval (%s) (update)\n    -threshhold kb      Threshhold to merge small processes (%s) (threshhold)\n    -ncolors ncolors    How many colors to use (%s) (ncolors)\n    -color1 color       color 1 (%s) (color1)\n    -color2 color       color 2 (%s) (color2)\n    -color3 color       color 3 (%s) (color3)\n    -color[4-9] color   colors 4 to 9 (undefined) (color4-color9)\n    -help               Print this message\n",
          version, progname, "Gmemusage", "320x400", "fixed", "grey4", "5", "400",
          "3", "maroon", "OliveDrab", "SlateBlue");
  }
#line 163
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
static void GetResource(XrmDatabase database , char *parentname , char *parentclass ,
                        char *name , char *class , int valueType , char *def , caddr_t *valuep ) 
{ 
  char *type ;
  XrmValue value ;
  char *string ;
  char buffer[1024] ;
  char fullname[1024] ;
  char fullclass[1024] ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  char *s ;
  void *tmp___1 ;

  {
  {
#line 182
  sprintf((char */* __restrict  */)(fullname), (char const   */* __restrict  */)"%s.%s",
          parentname, name);
#line 183
  sprintf((char */* __restrict  */)(fullclass), (char const   */* __restrict  */)"%s.%s",
          parentclass, class);
#line 184
  tmp___0 = XrmGetResource(database, (char const   *)(fullname), (char const   *)(fullclass),
                           & type, & value);
  }
#line 184
  if (tmp___0) {
#line 185
    string = value.addr;
#line 186
    len = (int )value.size;
  } else {
    {
#line 188
    string = def;
#line 189
    tmp = strlen((char const   *)string);
#line 189
    len = (int )tmp;
    }
  }
  {
#line 191
  strncpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)string,
          sizeof(buffer));
#line 192
  buffer[sizeof(buffer) - 1UL] = (char )'\000';
  }
  {
#line 195
  if (valueType == 0) {
#line 195
    goto case_0;
  }
#line 211
  if (valueType == 1) {
#line 211
    goto case_1;
  }
#line 194
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 197
  tmp___1 = malloc((size_t )(len + 1));
#line 197
  s = (char *)tmp___1;
  }
#line 198
  if ((unsigned long )s == (unsigned long )((char *)((void *)0))) {
    {
#line 200
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: GetResource - couldn\'t allocate memory",
            progname);
#line 202
    perror("");
#line 203
    exit(1);
    }
  }
  {
#line 205
  strncpy((char */* __restrict  */)s, (char const   */* __restrict  */)string, (size_t )len);
#line 206
  *(s + len) = (char )'\000';
#line 207
  *valuep = s;
  }
#line 209
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 212
  *((int *)valuep) = atoi((char const   *)(buffer));
  }
#line 213
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
static XrmDatabase optionDB  =    (XrmDatabase )((void *)0);
#line 216 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
static XrmDatabase serverDB  =    (XrmDatabase )((void *)0);
#line 216 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
static XrmDatabase mergedDB  =    (XrmDatabase )((void *)0);
#line 228 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
void GetInitialResources(int *argc , char **argv ) 
{ 
  XrmDatabase nameDB ;
  XrmDatabase displayDB ;

  {
  {
#line 231
  nameDB = (XrmDatabase )((void *)0);
#line 231
  displayDB = (XrmDatabase )((void *)0);
#line 235
  XrmInitialize();
#line 239
  XrmParseCommand(& nameDB, nameTable, (int )nameEntries, (char const   *)(progname),
                  argc, argv);
#line 241
  GetResource(nameDB, progname, (char *)"*", (char *)"name", (char *)"Name", 0, (char *)"Gmemusage",
              & dName);
#line 243
  XrmParseCommand(& displayDB, displayTable, (int )displayEntries, (char const   *)(progname),
                  argc, argv);
#line 245
  dDisplay = getenv("DISPLAY");
  }
#line 246
  if (! dDisplay) {
#line 248
    dDisplay = (char *)"";
  }
  {
#line 250
  GetResource(displayDB, progname, dName, (char *)"display", (char *)"Display", 0,
              dDisplay, & dDisplay);
#line 255
  XrmMergeDatabases(nameDB, & mergedDB);
#line 256
  XrmMergeDatabases(displayDB, & mergedDB);
  }
#line 257
  return;
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/gmemusage-0.2/resource.c"
void GetResources(Display *display___0 , int argc , char **argv ) 
{ 
  char *serverString ;
  register int i ;
  int tmp ;

  {
  {
#line 279
  serverString = XResourceManagerString(display___0);
  }
#line 280
  if (serverString) {
    {
#line 282
    serverDB = XrmGetStringDatabase((char const   *)serverString);
#line 283
    XrmMergeDatabases(serverDB, & mergedDB);
    }
  }
  {
#line 285
  XrmParseCommand(& optionDB, optionTable, (int )optionEntries, (char const   *)(progname),
                  & argc, argv);
  }
#line 291
  if (argc > 1) {
    {
#line 293
    tmp = strcmp((char const   *)*(argv + 1), "-help");
    }
#line 293
    if (tmp) {
      {
#line 295
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown option %s\n",
              progname, *(argv + 1));
      }
    }
    {
#line 297
    Help();
#line 298
    exit(1);
    }
  }
  {
#line 300
  XrmMergeDatabases(optionDB, & mergedDB);
#line 301
  i = 0;
  }
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! (i < (int )nVars)) {
#line 301
      goto while_break;
    }
    {
#line 303
    GetResource(mergedDB, progname, dName, optionVars[i].name, optionVars[i].class,
                optionVars[i].type, optionVars[i].def, optionVars[i].var);
#line 301
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  XrmDestroyDatabase(mergedDB);
  }
#line 308
  return;
}
}
