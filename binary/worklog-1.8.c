/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 358 "/usr/include/curses.h"
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 120 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 37 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
struct project_list {
   char *name ;
   int key ;
   struct project_list *next ;
   long time ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 581 "/usr/include/curses.h"
extern int beep(void) ;
#line 587
extern int cbreak(void) ;
#line 608
extern int echo(void) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 676
extern int mvscanw(int  , int  , char const   *  , ...) ;
#line 710
extern int nodelay(WINDOW * , _Bool  ) ;
#line 711
extern int noecho(void) ;
#line 774
extern int ungetch(int  ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 802
extern int wclrtobot(WINDOW * ) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 811
extern int wgetnstr(WINDOW * , char * , int  ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 1386
extern WINDOW *stdscr ;
#line 1392
extern int LINES ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 261
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) asctime)(struct tm  const  *__tp ) ;
#line 131 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 279 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) rint)(double __x ) ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
struct project_list *project_head  =    (struct project_list *)((void *)0);
#line 45 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
int num_projects  ;
#line 46 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
int x_update  ;
#line 46 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
int y_update  ;
#line 47 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
int IDLE_Y  ;
#line 48 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
struct project_list *project_update  ;
#line 48 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
struct project_list *no_category  ;
#line 48 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
struct project_list *current_project  =    (struct project_list *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
char temps[2048]  ;
#line 50 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
char temps2[2048]  ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
char starttimes[2048]  ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
char *log_filename  ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
int update_skip_refresh  ;
#line 54 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
long initial_time  ;
#line 54 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
long delta_time  ;
#line 57 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
long fetch_total_time(struct project_list *project ) 
{ 
  long result ;
  double partial ;
  char specific_timefile[2048] ;
  char line[2048] ;
  FILE *fa ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 65
  result = (long )0.0;
#line 66
  sprintf((char */* __restrict  */)(specific_timefile), (char const   */* __restrict  */)"%s.%c",
          log_filename, project->key);
#line 67
  fa = fopen((char const   */* __restrict  */)(specific_timefile), (char const   */* __restrict  */)"r");
  }
#line 68
  if ((unsigned long )fa == (unsigned long )((void *)0)) {
    {
#line 70
    fa = fopen((char const   */* __restrict  */)(specific_timefile), (char const   */* __restrict  */)"w");
    }
#line 71
    if ((unsigned long )fa == (unsigned long )((void *)0)) {
      {
#line 73
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: cannot open specific project log file : %s\n",
              specific_timefile);
#line 74
      perror("fopen");
#line 75
      exit(-1);
      }
    }
  } else {
    {
#line 80
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 80
      tmp___1 = fscanf((FILE */* __restrict  */)fa, (char const   */* __restrict  */)"%[^\n]",
                       line);
      }
#line 80
      if (! (1 == tmp___1)) {
#line 80
        goto while_break;
      }
      {
#line 81
      tmp___0 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%lf hours :",
                       & partial);
      }
#line 81
      if (1 == tmp___0) {
        {
#line 82
        tmp = rint((partial * 60.0) * 60.0);
#line 82
        result += (long )tmp;
        }
      }
      {
#line 80
      fscanf((FILE */* __restrict  */)fa, (char const   */* __restrict  */)"\n");
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 84
  fclose(fa);
  }
#line 86
  return (result);
}
}
#line 89 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
void read_config_file(char *filename ) 
{ 
  FILE *f ;
  char firstchar ;
  char colonchar ;
  struct project_list *project ;
  char names[2048] ;
  int linenum ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 98
  tmp = malloc(sizeof(struct project_list ));
#line 98
  project = (struct project_list *)tmp;
#line 99
  project->key = 10;
#line 100
  project->next = project_head;
#line 101
  project->time = 0L;
#line 102
  project->name = strdup("no category yet");
#line 103
  project_head = project;
#line 104
  no_category = project;
#line 106
  num_projects = 1;
#line 107
  linenum = 0;
#line 108
  project = project_head;
#line 109
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 110
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: cannot open project configuration file : %s\n",
            filename);
#line 113
    perror("fopen");
#line 114
    exit(-1);
    }
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    tmp___7 = feof(f);
    }
#line 116
    if (tmp___7) {
#line 116
      goto while_break;
    } else {
      {
#line 116
      tmp___8 = ferror(f);
      }
#line 116
      if (tmp___8) {
#line 116
        goto while_break;
      }
    }
#line 118
    linenum ++;
#line 119
    firstchar = (char)0;
    {
#line 119
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = feof(f);
      }
#line 119
      if (tmp___0) {
#line 119
        goto while_break___0;
      } else {
        {
#line 119
        tmp___1 = ferror(f);
        }
#line 119
        if (tmp___1) {
#line 119
          goto while_break___0;
        } else
#line 119
        if (! ((int )firstchar <= 13)) {
#line 119
          goto while_break___0;
        }
      }
      {
#line 120
      fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%c", & firstchar);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 121
    tmp___5 = feof(f);
    }
#line 121
    if (! tmp___5) {
      {
#line 121
      tmp___6 = ferror(f);
      }
#line 121
      if (! tmp___6) {
#line 123
        if ((int )firstchar == 35) {
          {
#line 125
          fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%*[^\n]");
          }
        } else {
          {
#line 130
          fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%c",
                 & colonchar);
          }
#line 131
          if ((int )colonchar != 58) {
            {
#line 133
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: second character in project line must be a colon.\n");
#line 134
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       on line %d is \'%c\'\n",
                    linenum, (int )colonchar);
#line 135
            exit(-1);
            }
          }
          {
#line 137
          tmp___2 = malloc(sizeof(struct project_list ));
#line 137
          project = (struct project_list *)tmp___2;
#line 138
          project->key = (int )firstchar;
#line 139
          project->next = project_head;
#line 140
          project->time = fetch_total_time(project);
#line 141
          project_head = project;
#line 142
          fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%[^\n]",
                 names);
#line 143
          tmp___3 = strlen((char const   *)(names));
#line 143
          tmp___4 = malloc(1UL + tmp___3);
#line 143
          project->name = (char *)tmp___4;
#line 144
          sprintf((char */* __restrict  */)project->name, (char const   */* __restrict  */)"%s",
                  names);
#line 145
          num_projects ++;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  tmp___9 = ferror(f);
  }
#line 149
  if (tmp___9) {
    {
#line 151
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: cannot read project configuration file : %s\n",
            filename);
#line 152
    perror("fscanf");
#line 153
    exit(-1);
    }
  }
  {
#line 155
  fclose(f);
  }
#line 156
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
int isdelkey(int keypress ) 
{ 
  int tmp ;

  {
#line 161
  if (keypress == 127) {
#line 161
    tmp = 1;
  } else
#line 161
  if (keypress == 8) {
#line 161
    tmp = 1;
  } else
#line 161
  if (keypress == 263) {
#line 161
    tmp = 1;
  } else
#line 161
  if (keypress == 330) {
#line 161
    tmp = 1;
  } else {
#line 161
    tmp = 0;
  }
#line 161
  return (tmp);
}
}
#line 167 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
void draw_main_screen(void) 
{ 
  struct project_list *project ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 176
  sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"Worklog version %s",
          "1.8");
#line 177
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 178
  tmp = wmove(stdscr, 0, 5);
  }
#line 178
  if (! (tmp == -1)) {
    {
#line 178
    waddnstr(stdscr, (char const   *)(temps), -1);
    }
  }
  {
#line 179
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 180
  tmp___0 = wmove(stdscr, 1, 1);
  }
#line 180
  if (! (tmp___0 == -1)) {
    {
#line 180
    waddnstr(stdscr, "---------------------------", -1);
    }
  }
#line 181
  i = 2;
#line 181
  project = project_head;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! ((unsigned long )project != (unsigned long )((void *)0))) {
#line 181
      goto while_break;
    }
    {
#line 183
    wattr_on(stdscr, 1UL << 21, (void *)0);
    }
#line 184
    if (project->key != 10) {
      {
#line 186
      wmove(stdscr, i, 1);
#line 187
      sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"    %c",
              project->key);
#line 188
      tmp___1 = wmove(stdscr, i, 1);
      }
#line 188
      if (! (tmp___1 == -1)) {
        {
#line 188
        waddnstr(stdscr, (char const   *)(temps), -1);
        }
      }
    } else {
      {
#line 191
      tmp___2 = wmove(stdscr, i, 1);
      }
#line 191
      if (! (tmp___2 == -1)) {
        {
#line 191
        waddnstr(stdscr, "   CR", -1);
        }
      }
    }
    {
#line 192
    wattr_off(stdscr, 1UL << 21, (void *)0);
#line 193
    tmp___3 = wmove(stdscr, i, 7);
    }
#line 193
    if (! (tmp___3 == -1)) {
      {
#line 193
      waddnstr(stdscr, (char const   *)project->name, -1);
      }
    }
#line 181
    project = project->next;
#line 181
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  i ++;
#line 196
  wmove(stdscr, i, 0);
#line 197
  wclrtoeol(stdscr);
#line 198
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 199
  tmp___4 = wmove(stdscr, i, 3);
  }
#line 199
  if (! (tmp___4 == -1)) {
    {
#line 199
    waddnstr(stdscr, "DEL", -1);
    }
  }
  {
#line 200
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 201
  tmp___5 = wmove(stdscr, i, 7);
  }
#line 201
  if (! (tmp___5 == -1)) {
    {
#line 201
    waddnstr(stdscr, "Quit", -1);
    }
  }
  {
#line 202
  i ++;
#line 203
  wmove(stdscr, i, 0);
#line 204
  wclrtoeol(stdscr);
#line 205
  i ++;
#line 206
  wmove(stdscr, i, 0);
#line 207
  wclrtoeol(stdscr);
#line 208
  i ++;
#line 209
  wmove(stdscr, i, 0);
#line 210
  wclrtoeol(stdscr);
#line 211
  i ++;
#line 212
  wmove(stdscr, i, 0);
#line 213
  wclrtoeol(stdscr);
  }
#line 214
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
void draw_run_options(int key ) 
{ 
  int i ;
  int j ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 221
  tmp = strlen((char const   *)current_project->name);
#line 221
  j = (int )(tmp + 10UL);
#line 222
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 223
  tmp___0 = wmove(stdscr, y_update, 1);
  }
#line 223
  if (! (tmp___0 == -1)) {
    {
#line 223
    waddnstr(stdscr, "->", -1);
    }
  }
  {
#line 224
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 226
  i = num_projects + 3;
  }
#line 228
  if (key == 10) {
    {
#line 230
    wattr_on(stdscr, 1UL << 21, (void *)0);
#line 231
    tmp___1 = wmove(stdscr, i, 1);
    }
#line 231
    if (! (tmp___1 == -1)) {
      {
#line 231
      waddnstr(stdscr, "     ", -1);
      }
    }
    {
#line 232
    tmp___2 = wmove(stdscr, i, 7);
    }
#line 232
    if (! (tmp___2 == -1)) {
      {
#line 232
      waddnstr(stdscr, "Press any of the category keys above to assign time", -1);
      }
    }
    {
#line 233
    wattr_off(stdscr, 1UL << 21, (void *)0);
#line 234
    i ++;
    }
  }
  {
#line 236
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 237
  tmp___3 = wmove(stdscr, i, 1);
  }
#line 237
  if (! (tmp___3 == -1)) {
    {
#line 237
    waddnstr(stdscr, "SPACE", -1);
    }
  }
  {
#line 238
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 239
  tmp___4 = wmove(stdscr, i, 7);
  }
#line 239
  if (! (tmp___4 == -1)) {
    {
#line 239
    waddnstr(stdscr, "Pause clock                                        ", -1);
    }
  }
#line 240
  i ++;
#line 241
  if (key != 10) {
    {
#line 243
    wattr_on(stdscr, 1UL << 21, (void *)0);
#line 244
    tmp___5 = wmove(stdscr, i, 1);
    }
#line 244
    if (! (tmp___5 == -1)) {
      {
#line 244
      waddnstr(stdscr, "   CR", -1);
      }
    }
    {
#line 245
    wattr_off(stdscr, 1UL << 21, (void *)0);
#line 246
    tmp___6 = wmove(stdscr, i, 7);
    }
#line 246
    if (! (tmp___6 == -1)) {
      {
#line 246
      waddnstr(stdscr, "Stop clock and optionally enter description", -1);
      }
    }
#line 247
    i ++;
  }
  {
#line 249
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 250
  tmp___7 = wmove(stdscr, i, 1);
  }
#line 250
  if (! (tmp___7 == -1)) {
    {
#line 250
    waddnstr(stdscr, "    +", -1);
    }
  }
  {
#line 251
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 252
  tmp___8 = wmove(stdscr, i, 7);
  }
#line 252
  if (! (tmp___8 == -1)) {
    {
#line 252
    waddnstr(stdscr, "Adjust by increasing time", -1);
    }
  }
  {
#line 253
  i ++;
#line 254
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 255
  tmp___9 = wmove(stdscr, i, 1);
  }
#line 255
  if (! (tmp___9 == -1)) {
    {
#line 255
    waddnstr(stdscr, "    -", -1);
    }
  }
  {
#line 256
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 257
  tmp___10 = wmove(stdscr, i, 7);
  }
#line 257
  if (! (tmp___10 == -1)) {
    {
#line 257
    waddnstr(stdscr, "Adjust by decreasing time", -1);
    }
  }
  {
#line 258
  i ++;
#line 259
  wattr_on(stdscr, 1UL << 21, (void *)0);
#line 260
  tmp___11 = wmove(stdscr, i, 1);
  }
#line 260
  if (! (tmp___11 == -1)) {
    {
#line 260
    waddnstr(stdscr, "  DEL", -1);
    }
  }
  {
#line 261
  wattr_off(stdscr, 1UL << 21, (void *)0);
#line 262
  tmp___12 = wmove(stdscr, i, 7);
  }
#line 262
  if (! (tmp___12 == -1)) {
    {
#line 262
    waddnstr(stdscr, "Quit", -1);
    }
  }
#line 266
  if (key == 10) {
    {
#line 268
    tmp___13 = wmove(stdscr, 1 + num_projects, 4);
    }
#line 268
    if (! (tmp___13 == -1)) {
      {
#line 268
      waddnstr(stdscr, "  ", -1);
      }
    }
  } else {
    {
#line 272
    wmove(stdscr, 1 + num_projects, 0);
#line 273
    wclrtoeol(stdscr);
    }
  }
#line 277
  return;
}
}
#line 279 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
void alarm_handler(int flag ) 
{ 
  double seconds ;
  double minutes ;
  double hours ;
  int tmp ;

  {
  {
#line 284
  signal(14, & alarm_handler);
#line 285
  (project_update->time) ++;
  }
#line 286
  if (! update_skip_refresh) {
#line 288
    delta_time = project_update->time - initial_time;
#line 289
    seconds = (double )delta_time;
#line 290
    if (seconds < 60.0) {
      {
#line 291
      sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"%0.2f seconds",
              seconds);
      }
    } else {
#line 294
      minutes = seconds / 60.0;
#line 295
      if (minutes < 60.0) {
        {
#line 296
        sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"%0.2f minutes",
                minutes);
        }
      } else {
        {
#line 299
        hours = seconds / 3600.0;
#line 300
        sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"%0.2f hours",
                hours);
        }
      }
    }
#line 304
    if ((unsigned long )project_update != (unsigned long )no_category) {
#line 306
      seconds = (double )project_update->time;
#line 307
      if (seconds < 60.0) {
        {
#line 308
        sprintf((char */* __restrict  */)(temps2), (char const   */* __restrict  */)"  (total %0.2f seconds)",
                seconds);
        }
      } else {
#line 311
        minutes = seconds / 60.0;
#line 312
        if (minutes < 60.0) {
          {
#line 313
          sprintf((char */* __restrict  */)(temps2), (char const   */* __restrict  */)"  (total %0.2f minutes)",
                  minutes);
          }
        } else {
          {
#line 316
          hours = seconds / 3600.0;
#line 317
          sprintf((char */* __restrict  */)(temps2), (char const   */* __restrict  */)"  (total %0.2f hours)",
                  hours);
          }
        }
      }
      {
#line 320
      strcat((char */* __restrict  */)(temps), (char const   */* __restrict  */)(temps2));
      }
    }
    {
#line 322
    wattr_on(stdscr, 1UL << 17, (void *)0);
#line 323
    wmove(stdscr, y_update, x_update);
#line 324
    wclrtoeol(stdscr);
#line 325
    tmp = wmove(stdscr, y_update, x_update);
    }
#line 325
    if (! (tmp == -1)) {
      {
#line 325
      waddnstr(stdscr, (char const   *)(temps), -1);
      }
    }
    {
#line 326
    wattr_off(stdscr, 1UL << 17, (void *)0);
    }
  }
#line 328
  return;
}
}
#line 330 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
void do_resize(void) 
{ 


  {
  {
#line 332
  endwin();
#line 338
  initscr();
#line 339
  cbreak();
#line 340
  noecho();
#line 341
  keypad(stdscr, (_Bool)1);
#line 343
  IDLE_Y = LINES - 1;
#line 345
  draw_main_screen();
  }
#line 346
  if ((unsigned long )current_project != (unsigned long )((void *)0)) {
    {
#line 347
    draw_run_options(current_project->key);
    }
  }
#line 348
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
void resize_handler(int flag ) 
{ 


  {
  {
#line 352
  signal(28, & resize_handler);
#line 353
  ungetch(12);
  }
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
void exit_handler(int flag ) 
{ 
  struct project_list *project ;
  FILE *f ;
  double seconds ;
  double minutes ;
  double hours ;
  time_t t ;
  struct tm *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 363
  f = fopen((char const   */* __restrict  */)log_filename, (char const   */* __restrict  */)"a");
  }
#line 364
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 366
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: cannot open project log file : %s\n",
            log_filename);
#line 367
    perror("fopen");
#line 368
    exit(-1);
    }
  }
  {
#line 371
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"-- Worklog summary begins : %s --\n",
          starttimes);
#line 372
  project = project_head;
  }
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! ((unsigned long )project != (unsigned long )((void *)0))) {
#line 372
      goto while_break;
    }
#line 373
    if (project->time > 0L) {
#line 375
      seconds = (double )project->time;
#line 376
      if (seconds < 60.0) {
        {
#line 377
        sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"%0.2f seconds",
                seconds);
        }
      } else {
#line 380
        minutes = seconds / 60.0;
#line 381
        if (minutes < 60.0) {
          {
#line 382
          sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"%0.2f minutes",
                  minutes);
          }
        } else {
          {
#line 385
          hours = seconds / 3600.0;
#line 386
          sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"%0.2f hours",
                  hours);
          }
        }
      }
      {
#line 389
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s : total %s\n",
              project->name, temps);
      }
    }
#line 372
    project = project->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 391
  time(& t);
#line 392
  tmp = localtime((time_t const   *)(& t));
#line 392
  tmp___0 = asctime((struct tm  const  *)tmp);
#line 392
  sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"%s",
          tmp___0);
#line 393
  tmp___2 = strlen((char const   *)(temps));
  }
#line 393
  if ((int )temps[tmp___2 - 1UL] < 14) {
    {
#line 394
    tmp___1 = strlen((char const   *)(temps));
#line 394
    temps[tmp___1 - 1UL] = (char)0;
    }
  }
  {
#line 395
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"-- Worklog summary ends : %s --\n\n",
          temps);
#line 396
  fclose(f);
#line 397
  endwin();
#line 398
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 399
  exit(0);
  }
}
}
#line 402 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
int clock_on(int key ) 
{ 
  struct project_list *project ;
  int i ;
  int j ;
  int found ;
  int quit ;
  int keypress ;
  struct itimerval timer_value ;
  int modification ;
  int success ;
  FILE *f ;
  FILE *fa ;
  time_t t ;
  double seconds ;
  double minutes ;
  double hours ;
  char comments[2048] ;
  char specific_timefile[2048] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  struct tm *tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 416
  comments[0] = (char)0;
#line 417
  keypress = key;
#line 418
  found = 0;
#line 418
  i = 2;
#line 418
  project = project_head;
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (! found) {
#line 418
      if (! ((unsigned long )project != (unsigned long )((void *)0))) {
#line 418
        goto while_break;
      }
    } else {
#line 418
      goto while_break;
    }
#line 419
    if (project->key == key) {
#line 421
      found = 1;
#line 422
      goto while_break;
    }
#line 418
    project = project->next;
#line 418
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  if (! found) {
#line 426
    found = 0;
#line 426
    i = 2;
#line 426
    project = project_head;
    {
#line 426
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 426
      if (! found) {
#line 426
        if (! ((unsigned long )project != (unsigned long )((void *)0))) {
#line 426
          goto while_break___0;
        }
      } else {
#line 426
        goto while_break___0;
      }
      {
#line 427
      tmp = tolower(project->key);
#line 427
      tmp___0 = tolower(key);
      }
#line 427
      if (tmp == tmp___0) {
#line 429
        found = 1;
#line 430
        key = project->key;
#line 431
        goto while_break___0;
      }
#line 426
      project = project->next;
#line 426
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 434
  if (found) {
#line 436
    current_project = project;
#line 437
    initial_time = project->time;
#line 438
    if (key != 10) {
#line 440
      project->time += no_category->time;
#line 441
      no_category->time = 0L;
    }
    {
#line 445
    project_update = project;
#line 446
    found = 1;
#line 447
    tmp___1 = strlen((char const   *)project->name);
#line 447
    j = (int )(tmp___1 + 10UL);
#line 449
    y_update = i;
#line 450
    x_update = j;
#line 451
    draw_run_options(key);
#line 453
    timer_value.it_value.tv_sec = (__time_t )1;
#line 454
    timer_value.it_value.tv_usec = (__suseconds_t )0;
#line 455
    timer_value.it_interval.tv_sec = (__time_t )1;
#line 456
    timer_value.it_interval.tv_usec = (__suseconds_t )0;
#line 457
    setitimer(0, (struct itimerval  const  */* __restrict  */)(& timer_value), (struct itimerval */* __restrict  */)0);
#line 459
    quit = 0;
    }
    {
#line 459
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 459
      if (! (! quit)) {
#line 459
        goto while_break___1;
      }
      {
#line 461
      update_skip_refresh = 0;
#line 462
      nodelay(stdscr, (_Bool)1);
#line 463
      keypress = -1;
      }
      {
#line 463
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 463
        if (! (keypress == -1)) {
#line 463
          goto while_break___2;
        }
        {
#line 464
        tmp___4 = wmove(stdscr, IDLE_Y, 5);
        }
#line 464
        if (tmp___4 == -1) {
#line 464
          keypress = -1;
        } else {
          {
#line 464
          tmp___3 = wgetch(stdscr);
#line 464
          keypress = tmp___3;
          }
        }
        {
#line 463
        usleep((__useconds_t )1000);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 465
      update_skip_refresh = 1;
#line 466
      nodelay(stdscr, (_Bool)0);
      }
      {
#line 469
      if (keypress == 32) {
#line 469
        goto case_32;
      }
#line 495
      if (keypress == 43) {
#line 495
        goto case_43;
      }
#line 526
      if (keypress == 45) {
#line 526
        goto case_45;
      }
#line 557
      if (keypress == 10) {
#line 557
        goto case_10;
      }
#line 575
      if (keypress == 410) {
#line 575
        goto case_410;
      }
#line 575
      if (keypress == 12) {
#line 575
        goto case_410;
      }
#line 579
      goto switch_default;
      case_32: /* CIL Label */ 
      {
#line 470
      timer_value.it_value.tv_sec = (__time_t )0;
#line 471
      timer_value.it_value.tv_usec = (__suseconds_t )0;
#line 472
      timer_value.it_interval.tv_sec = (__time_t )0;
#line 473
      timer_value.it_interval.tv_usec = (__suseconds_t )0;
#line 474
      setitimer(0, (struct itimerval  const  */* __restrict  */)(& timer_value), (struct itimerval */* __restrict  */)0);
#line 475
      wattr_on(stdscr, 1UL << 19, (void *)0);
#line 476
      tmp___5 = wmove(stdscr, y_update, 1);
      }
#line 476
      if (! (tmp___5 == -1)) {
        {
#line 476
        waddnstr(stdscr, "->", -1);
        }
      }
      {
#line 477
      wattr_off(stdscr, 1UL << 19, (void *)0);
#line 479
      i = num_projects + 9;
#line 480
      tmp___6 = wmove(stdscr, i, 5);
      }
#line 480
      if (! (tmp___6 == -1)) {
        {
#line 480
        waddnstr(stdscr, "-- Clock paused.  Press any key to resume --", -1);
        }
      }
      {
#line 481
      wmove(stdscr, i, 49);
#line 482
      keypress = wgetch(stdscr);
#line 483
      wmove(stdscr, i, 0);
#line 484
      wclrtoeol(stdscr);
#line 486
      wattr_on(stdscr, 1UL << 21, (void *)0);
#line 487
      tmp___7 = wmove(stdscr, y_update, 1);
      }
#line 487
      if (! (tmp___7 == -1)) {
        {
#line 487
        waddnstr(stdscr, "->", -1);
        }
      }
      {
#line 488
      wattr_off(stdscr, 1UL << 21, (void *)0);
#line 489
      timer_value.it_value.tv_sec = (__time_t )1;
#line 490
      timer_value.it_value.tv_usec = (__suseconds_t )0;
#line 491
      timer_value.it_interval.tv_sec = (__time_t )1;
#line 492
      timer_value.it_interval.tv_usec = (__suseconds_t )0;
#line 493
      setitimer(0, (struct itimerval  const  */* __restrict  */)(& timer_value), (struct itimerval */* __restrict  */)0);
      }
#line 494
      goto switch_break;
      case_43: /* CIL Label */ 
#line 496
      i = num_projects + 9;
#line 497
      if (stdscr) {
#line 497
        stdscr->_attrs = 1UL << 21;
      }
      {
#line 498
      tmp___8 = wmove(stdscr, i, 5);
      }
#line 498
      if (! (tmp___8 == -1)) {
        {
#line 498
        waddnstr(stdscr, "Enter number of minutes to add : ", -1);
        }
      }
#line 499
      if (stdscr) {
#line 499
        stdscr->_attrs = 1UL << 21;
      }
      {
#line 500
      echo();
#line 501
      tmp___9 = mvscanw(i, 38, "%d", & modification);
#line 501
      success = tmp___9 == 1;
#line 502
      noecho();
      }
#line 503
      if (success) {
#line 504
        if (modification < 0) {
#line 505
          success = 0;
        }
      }
#line 506
      if (stdscr) {
#line 506
        stdscr->_attrs = 0UL;
      }
      {
#line 507
      wmove(stdscr, i, 0);
#line 508
      wclrtoeol(stdscr);
      }
#line 509
      if (success) {
#line 511
        project->time += (long )(60 * modification);
      } else {
        {
#line 515
        beep();
#line 516
        tmp___10 = wmove(stdscr, i, 5);
        }
#line 516
        if (! (tmp___10 == -1)) {
          {
#line 516
          waddnstr(stdscr, "Error : input value must be a positive integer", -1);
          }
        }
        {
#line 517
        tmp___11 = wmove(stdscr, i + 1, 5);
        }
#line 517
        if (! (tmp___11 == -1)) {
          {
#line 517
          waddnstr(stdscr, "-- Press any key --", -1);
          }
        }
        {
#line 518
        wmove(stdscr, i + 1, 24);
#line 519
        keypress = wgetch(stdscr);
#line 520
        wmove(stdscr, i, 0);
#line 521
        wclrtoeol(stdscr);
#line 522
        wmove(stdscr, i + 1, 0);
#line 523
        wclrtoeol(stdscr);
        }
      }
#line 525
      goto switch_break;
      case_45: /* CIL Label */ 
#line 527
      i = num_projects + 9;
#line 528
      if (stdscr) {
#line 528
        stdscr->_attrs = 1UL << 21;
      }
      {
#line 529
      tmp___12 = wmove(stdscr, i, 5);
      }
#line 529
      if (! (tmp___12 == -1)) {
        {
#line 529
        waddnstr(stdscr, "Enter number of minutes to subtract : ", -1);
        }
      }
#line 530
      if (stdscr) {
#line 530
        stdscr->_attrs = 1UL << 21;
      }
      {
#line 531
      echo();
#line 532
      tmp___13 = mvscanw(i, 43, "%d", & modification);
#line 532
      success = tmp___13 == 1;
#line 533
      noecho();
      }
#line 534
      if (success) {
#line 535
        if (modification < 0) {
#line 536
          success = 0;
        }
      }
#line 537
      if (stdscr) {
#line 537
        stdscr->_attrs = 0UL;
      }
      {
#line 538
      wmove(stdscr, i, 0);
#line 539
      wclrtoeol(stdscr);
      }
#line 540
      if (success) {
#line 542
        project->time -= (long )(60 * modification);
      } else {
        {
#line 546
        beep();
#line 547
        tmp___14 = wmove(stdscr, i, 5);
        }
#line 547
        if (! (tmp___14 == -1)) {
          {
#line 547
          waddnstr(stdscr, "Error : input value must be a positive integer", -1);
          }
        }
        {
#line 548
        tmp___15 = wmove(stdscr, i + 1, 5);
        }
#line 548
        if (! (tmp___15 == -1)) {
          {
#line 548
          waddnstr(stdscr, "-- Press any key --", -1);
          }
        }
        {
#line 549
        wmove(stdscr, i + 1, 24);
#line 550
        keypress = wgetch(stdscr);
#line 551
        wmove(stdscr, i, 0);
#line 552
        wclrtoeol(stdscr);
#line 553
        wmove(stdscr, i + 1, 0);
#line 554
        wclrtoeol(stdscr);
        }
      }
#line 556
      goto switch_break;
      case_10: /* CIL Label */ 
#line 558
      if (key != 10) {
#line 560
        i = num_projects + 9;
#line 561
        if (stdscr) {
#line 561
          stdscr->_attrs = 1UL << 21;
        }
        {
#line 562
        tmp___16 = wmove(stdscr, i, 5);
        }
#line 562
        if (! (tmp___16 == -1)) {
          {
#line 562
          waddnstr(stdscr, "Enter comment : ", -1);
          }
        }
#line 563
        if (stdscr) {
#line 563
          stdscr->_attrs = 1UL << 21;
        }
        {
#line 564
        echo();
#line 565
        tmp___17 = wmove(stdscr, i, 21);
        }
#line 565
        if (! (tmp___17 == -1)) {
          {
#line 565
          wgetnstr(stdscr, comments, -1);
          }
        }
        {
#line 566
        noecho();
        }
#line 567
        if (stdscr) {
#line 567
          stdscr->_attrs = 0UL;
        }
        {
#line 568
        wmove(stdscr, i, 0);
#line 569
        wclrtobot(stdscr);
#line 570
        quit = 1;
        }
      }
#line 572
      goto switch_break;
      case_410: /* CIL Label */ 
      case_12: /* CIL Label */ 
      {
#line 577
      do_resize();
      }
#line 578
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 580
      beep();
#line 581
      quit = 1;
      }
#line 582
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 585
    if (key != 10) {
      {
#line 587
      sprintf((char */* __restrict  */)(specific_timefile), (char const   */* __restrict  */)"%s.%c",
              log_filename, key);
#line 588
      f = fopen((char const   */* __restrict  */)log_filename, (char const   */* __restrict  */)"a");
      }
#line 589
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 591
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: cannot open project log file : %s\n",
                log_filename);
#line 592
        perror("fopen");
#line 593
        exit(-1);
        }
      }
      {
#line 595
      fa = fopen((char const   */* __restrict  */)(specific_timefile), (char const   */* __restrict  */)"a");
      }
#line 596
      if ((unsigned long )fa == (unsigned long )((void *)0)) {
        {
#line 598
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: cannot open specific project log file : %s\n",
                specific_timefile);
#line 599
        perror("fopen");
#line 600
        exit(-1);
        }
      }
      {
#line 602
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s ",
              project->name);
#line 603
      delta_time = project->time - initial_time;
#line 604
      seconds = (double )delta_time;
#line 605
      hours = seconds / 3600.0;
#line 606
      sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"%8.2f hours : ",
              hours);
#line 607
      fprintf((FILE */* __restrict  */)fa, (char const   */* __restrict  */)"%s",
              temps);
#line 608
      tmp___18 = strlen((char const   *)(comments));
      }
#line 608
      if (tmp___18 > 0UL) {
        {
#line 610
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(%s) ",
                comments);
#line 611
        fprintf((FILE */* __restrict  */)fa, (char const   */* __restrict  */)"%s",
                comments);
        }
      } else {
        {
#line 614
        fprintf((FILE */* __restrict  */)fa, (char const   */* __restrict  */)"<no description>");
        }
      }
#line 615
      if (delta_time > 0L) {
#line 617
        seconds = (double )delta_time;
#line 618
        if (seconds < 60.0) {
          {
#line 619
          sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"%0.2f seconds",
                  seconds);
          }
        } else {
#line 622
          minutes = seconds / 60.0;
#line 623
          if (minutes < 60.0) {
            {
#line 624
            sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"%0.2f minutes",
                    minutes);
            }
          } else {
            {
#line 627
            hours = seconds / 3600.0;
#line 628
            sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"%0.2f hours",
                    hours);
            }
          }
        }
      }
      {
#line 632
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)": %s : finished ",
              temps);
#line 633
      fprintf((FILE */* __restrict  */)fa, (char const   */* __restrict  */)" : [%s] : finished ",
              temps);
#line 634
      time(& t);
#line 635
      tmp___19 = localtime((time_t const   *)(& t));
#line 635
      tmp___20 = asctime((struct tm  const  *)tmp___19);
#line 635
      sprintf((char */* __restrict  */)(temps), (char const   */* __restrict  */)"%s",
              tmp___20);
#line 636
      tmp___22 = strlen((char const   *)(temps));
      }
#line 636
      if ((int )temps[tmp___22 - 1UL] < 14) {
        {
#line 637
        tmp___21 = strlen((char const   *)(temps));
#line 637
        temps[tmp___21 - 1UL] = (char)0;
        }
      }
      {
#line 638
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s\n",
              temps);
#line 639
      fprintf((FILE */* __restrict  */)fa, (char const   */* __restrict  */)"%s\n",
              temps);
#line 640
      fclose(f);
#line 641
      fclose(fa);
      }
    }
    {
#line 643
    timer_value.it_value.tv_sec = (__time_t )0;
#line 644
    timer_value.it_value.tv_usec = (__suseconds_t )0;
#line 645
    timer_value.it_interval.tv_sec = (__time_t )0;
#line 646
    timer_value.it_interval.tv_usec = (__suseconds_t )0;
#line 647
    setitimer(0, (struct itimerval  const  */* __restrict  */)(& timer_value), (struct itimerval */* __restrict  */)0);
#line 648
    update_skip_refresh = 0;
#line 649
    alarm_handler(0);
#line 650
    tmp___23 = wmove(stdscr, y_update, 1);
    }
#line 650
    if (! (tmp___23 == -1)) {
      {
#line 650
      waddnstr(stdscr, "  ", -1);
      }
    }
  } else {
    {
#line 653
    tmp___24 = isdelkey(key);
    }
#line 653
    if (! tmp___24) {
#line 653
      if (key != 12) {
        {
#line 656
        beep();
#line 657
        keypress = -1;
        }
      }
    }
  }
#line 661
  current_project = (struct project_list *)((void *)0);
#line 663
  return (keypress);
}
}
#line 666 "/home/june/repo/benchmarks/collector2/temp/worklog-1.8/worklog.c"
int main(int argc , char **argv ) 
{ 
  char *config_filename ;
  int keypress ;
  int quit ;
  int i ;
  FILE *lf ;
  time_t t ;
  char *tmp ;
  char *tmp___0 ;
  char const   *default_dir ;
  int tmp___1 ;
  char *tmp___2 ;
  struct tm *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  {
#line 675
  time(& t);
  }
#line 677
  if (argc > 1) {
#line 679
    if (argc > 3) {
      {
#line 683
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"USAGE: %s [<project config file> [<log file>]]\n",
              *(argv + 0));
#line 684
      exit(0);
      }
    } else {
      {
#line 679
      tmp = strstr((char const   *)*(argv + 1), "-h");
      }
#line 679
      if ((unsigned long )tmp == (unsigned long )*(argv + 1)) {
        {
#line 683
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"USAGE: %s [<project config file> [<log file>]]\n",
                *(argv + 0));
#line 684
        exit(0);
        }
      } else {
        {
#line 679
        tmp___0 = strstr((char const   *)*(argv + 1), "-?");
        }
#line 679
        if ((unsigned long )tmp___0 == (unsigned long )*(argv + 1)) {
          {
#line 683
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"USAGE: %s [<project config file> [<log file>]]\n",
                  *(argv + 0));
#line 684
          exit(0);
          }
        }
      }
    }
  } else {
    {
#line 691
    tmp___2 = getenv("WORKLOGDIR");
#line 691
    default_dir = (char const   *)tmp___2;
    }
#line 691
    if (default_dir) {
      {
#line 692
      tmp___1 = chdir(default_dir);
      }
#line 692
      if (tmp___1) {
        {
#line 694
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Could not change to default directory ($%s = %s)\n",
                "WORKLOGDIR", default_dir);
#line 695
        perror("chdir");
        }
      } else {
        {
#line 699
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INFO: Using default directory %s (environment variable %s)\n",
                default_dir, "WORKLOGDIR");
        }
      }
    }
  }
#line 704
  if (argc > 2) {
#line 705
    log_filename = *(argv + 2);
  } else {
#line 707
    log_filename = (char *)"time.log";
  }
#line 708
  if (argc > 1) {
#line 709
    config_filename = *(argv + 1);
  } else {
#line 711
    config_filename = (char *)"projects";
  }
  {
#line 712
  read_config_file(config_filename);
#line 713
  lf = fopen((char const   */* __restrict  */)log_filename, (char const   */* __restrict  */)"a");
  }
#line 714
  if ((unsigned long )lf == (unsigned long )((void *)0)) {
    {
#line 716
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: cannot open project log file : %s\n",
            log_filename);
#line 717
    perror("fopen");
#line 718
    exit(-1);
    }
  }
  {
#line 720
  fclose(lf);
#line 722
  tmp___3 = localtime((time_t const   *)(& t));
#line 722
  tmp___4 = asctime((struct tm  const  *)tmp___3);
#line 722
  sprintf((char */* __restrict  */)(starttimes), (char const   */* __restrict  */)"%s",
          tmp___4);
#line 723
  tmp___6 = strlen((char const   *)(starttimes));
  }
#line 723
  if ((int )starttimes[tmp___6 - 1UL] < 14) {
    {
#line 724
    tmp___5 = strlen((char const   *)(starttimes));
#line 724
    starttimes[tmp___5 - 1UL] = (char)0;
    }
  }
  {
#line 726
  initscr();
#line 727
  cbreak();
#line 728
  noecho();
#line 729
  keypad(stdscr, (_Bool)1);
#line 731
  IDLE_Y = LINES - 1;
#line 733
  signal(14, & alarm_handler);
#line 735
  signal(1, & exit_handler);
#line 736
  signal(2, & exit_handler);
#line 737
  signal(3, & exit_handler);
#line 738
  signal(15, & exit_handler);
#line 739
  signal(28, & resize_handler);
#line 741
  keypress = 10;
#line 742
  draw_main_screen();
#line 743
  quit = 0;
  }
  {
#line 743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 743
    if (! (! quit)) {
#line 743
      goto while_break;
    }
#line 745
    if (keypress == 10) {
      {
#line 746
      tmp___9 = wmove(stdscr, IDLE_Y, 5);
      }
#line 746
      if (tmp___9 == -1) {
#line 746
        keypress = -1;
      } else {
        {
#line 746
        tmp___8 = wgetch(stdscr);
#line 746
        keypress = tmp___8;
        }
      }
    }
    {
#line 747
    keypress = clock_on(keypress);
#line 748
    draw_main_screen();
    }
#line 749
    if (keypress == -1) {
      {
#line 750
      tmp___12 = wmove(stdscr, IDLE_Y, 5);
      }
#line 750
      if (tmp___12 == -1) {
#line 750
        keypress = -1;
      } else {
        {
#line 750
        tmp___11 = wgetch(stdscr);
#line 750
        keypress = tmp___11;
        }
      }
    }
#line 751
    if (keypress == 12) {
      {
#line 753
      do_resize();
#line 754
      keypress = 10;
      }
    }
    {
#line 756
    tmp___19 = isdelkey(keypress);
    }
#line 756
    if (tmp___19) {
      {
#line 758
      i = num_projects + 5;
#line 759
      wattr_on(stdscr, 1UL << 19, (void *)0);
#line 760
      tmp___13 = wmove(stdscr, i, 5);
      }
#line 760
      if (! (tmp___13 == -1)) {
        {
#line 760
        waddnstr(stdscr, "Press DEL once more to quit", -1);
        }
      }
      {
#line 761
      beep();
#line 762
      wattr_off(stdscr, 1UL << 19, (void *)0);
#line 763
      tmp___16 = wmove(stdscr, IDLE_Y, 5);
      }
#line 763
      if (tmp___16 == -1) {
#line 763
        keypress = -1;
      } else {
        {
#line 763
        tmp___15 = wgetch(stdscr);
#line 763
        keypress = tmp___15;
        }
      }
      {
#line 764
      tmp___17 = wmove(stdscr, i, 5);
      }
#line 764
      if (! (tmp___17 == -1)) {
        {
#line 764
        waddnstr(stdscr, "                           ", -1);
        }
      }
      {
#line 765
      tmp___18 = isdelkey(keypress);
      }
#line 765
      if (tmp___18) {
#line 766
        quit = 1;
      }
#line 767
      keypress = 10;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 770
  exit_handler(0);
  }
#line 771
  return (0);
}
}
