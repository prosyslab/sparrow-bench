/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 45 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
typedef void (*pfp)(void);
#line 47 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
struct word_def {
   char *name ;
   struct word_def *link ;
   int class ;
   pfp func[1] ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
struct vocabulary {
   struct word_def *voc[8] ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.h"
struct _block_data {
   unsigned int block_no ;
   int dirty ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_1 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_1 __sigset_t;
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 58 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
struct voc_marker {
   struct vocabulary *list[8] ;
   int top ;
   struct vocabulary *voc ;
   struct vocabulary v_list[8] ;
   struct vocabulary v_voc ;
   char *_dp ;
   struct word_def *last ;
};
#line 74 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
struct image_header {
   char header[24] ;
   int ver_hi ;
   int ver_lo ;
   unsigned int pattern ;
   char *base ;
   int dspace_size ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/exceptio.h"
struct exception_frame {
   jmp_buf catch_buf ;
   int *sp ;
   int *rp ;
   int *bp ;
   float *fp ;
   struct exception_frame *last ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.h"
struct _block_buffer {
   char buffer[1024] ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
struct raw_voc {
   char *name ;
   void (*func)(void) ;
   int class ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 83 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
struct __anonstruct_d2_41 {
   int low ;
   int high ;
};
#line 83 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
union double_cell {
   long long d1 ;
   struct __anonstruct_d2_41 d2 ;
};
#line 714 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
struct an_error {
   char *msg ;
   char please_abort ;
   char print_word ;
};
#line 990 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
struct __anonstruct_kw_27 {
   char *name ;
   int *var ;
};
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 189 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
pfp *ip ;
#line 191
int *sp ;
#line 192
int *rp ;
#line 194
int *bp ;
#line 48 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
char *_dp ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.h"
void _paren_local_paren(void) ;
#line 44
void _paren_bp_restore_paren(void) ;
#line 45
void _paren_bp_save_paren(void) ;
#line 46
void _paren_read_local_paren(void) ;
#line 47
void _paren_write_local_paren(void) ;
#line 55
void clear_locals(void) ;
#line 56
void free_locals(void) ;
#line 57
void init_locals(void) ;
#line 58
void declare_local(char *s , unsigned int u ) ;
#line 59
struct word_def *get_first_local(void) ;
#line 60
int locals_defined(void) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
static struct word_def *first_local  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
static unsigned int local_defined  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
void _paren_local_paren(void) 
{ 
  register unsigned int u ;
  int *tmp ;
  register char *s ;
  int *tmp___0 ;

  {
  {
#line 54
  tmp = sp;
#line 54
  sp ++;
#line 54
  u = (unsigned int )*tmp;
#line 55
  tmp___0 = sp;
#line 55
  sp ++;
#line 55
  s = (char *)*tmp___0;
#line 56
  declare_local(s, u);
  }
#line 57
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
void _paren_bp_restore_paren(void) 
{ 
  pfp *tmp ;
  int *tmp___0 ;

  {
#line 61
  tmp = ip;
#line 61
  ip ++;
#line 61
  rp += (int )*tmp;
#line 62
  tmp___0 = rp;
#line 62
  rp ++;
#line 62
  bp = (int *)*tmp___0;
#line 63
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
void _paren_bp_save_paren(void) 
{ 


  {
#line 67
  rp --;
#line 67
  *rp = (int )bp;
#line 68
  bp = rp - 1;
#line 69
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
void _paren_read_local_paren(void) 
{ 
  register unsigned int offset ;
  pfp *tmp ;

  {
#line 75
  tmp = ip;
#line 75
  ip ++;
#line 75
  offset = (unsigned int )*tmp;
#line 76
  sp --;
#line 76
  *sp = *(bp - offset);
#line 77
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
void _paren_write_local_paren(void) 
{ 
  register unsigned int offset ;
  pfp *tmp ;
  int *tmp___0 ;

  {
#line 83
  tmp = ip;
#line 83
  ip ++;
#line 83
  offset = (unsigned int )*tmp;
#line 84
  tmp___0 = sp;
#line 84
  sp ++;
#line 84
  *(bp - offset) = *tmp___0;
#line 85
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
void clear_locals(void) 
{ 


  {
#line 96
  if (local_defined) {
#line 97
    *((int *)_dp) = (int )(& _paren_bp_restore_paren);
#line 97
    _dp += sizeof(int );
#line 98
    *((int *)_dp) = (int )local_defined;
#line 98
    _dp += sizeof(int );
  }
  {
#line 100
  free_locals();
#line 101
  local_defined = 0U;
  }
#line 102
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
void free_locals(void) 
{ 
  register struct word_def *p ;
  register struct word_def *p1 ;

  {
#line 106
  p = first_local;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! p) {
#line 107
      goto while_break;
    }
    {
#line 108
    free((void *)p->name);
#line 109
    p1 = p->link;
#line 110
    free((void *)p);
#line 111
    p = p1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  first_local = (struct word_def *)((void *)0);
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
void init_locals(void) 
{ 


  {
#line 117
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
void declare_local(char *s , unsigned int u ) 
{ 
  struct word_def *p ;
  void *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 124
  tmp = malloc(sizeof(struct word_def ));
#line 124
  p = (struct word_def *)tmp;
  }
#line 125
  if (p) {
    {
#line 126
    tmp___0 = malloc((size_t )(u + 1U));
#line 126
    p->name = (char *)tmp___0;
    }
#line 127
    if (p->name) {
      {
#line 128
      *(p->name + 0) = (char )u;
#line 129
      memcpy((void */* __restrict  */)(p->name + 1), (void const   */* __restrict  */)s,
             (size_t )u);
#line 130
      p->link = first_local;
#line 131
      p->class = 11;
#line 132
      tmp___1 = local_defined;
#line 132
      local_defined ++;
#line 132
      p->func[0] = (void (*)(void))tmp___1;
      }
#line 133
      if (! first_local) {
#line 133
        *((int *)_dp) = (int )(& _paren_bp_save_paren);
#line 133
        _dp += sizeof(int );
      }
#line 134
      first_local = p;
    } else {
      {
#line 135
      free((void *)p);
      }
    }
  }
#line 137
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
struct word_def *get_first_local(void) 
{ 


  {
#line 144
  return (first_local);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/locals.c"
int locals_defined(void) 
{ 


  {
#line 151
  return ((int )local_defined);
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 162 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
char *dp0 ;
#line 164
int dstack_size ;
#line 164
int rstack_size ;
#line 164
int fstack_size ;
#line 166
int pnos_size ;
#line 167
char *pnos ;
#line 168
int pad_size ;
#line 170
struct vocabulary *list[8] ;
#line 172
struct vocabulary *voc ;
#line 173
struct vocabulary *forth_wid ;
#line 177
void init_vocabulary(char **dp ) ;
#line 178
void init_stacks(int dstack_size___0 , int rstack_size___0 , int fstack_size___0 ) ;
#line 179
void init_data_space(int dspace_size___0 ) ;
#line 180
void init_tib(int size ) ;
#line 181
void init_pad(int size ) ;
#line 182
void init_pnos(void) ;
#line 183
void init_forth_environment(int reload ) ;
#line 191
int *sp_top ;
#line 191
int *sp_base ;
#line 192
int *rp_top ;
#line 192
int *rp_base ;
#line 193
float *fp ;
#line 193
float *fp_top ;
#line 193
float *fp_base ;
#line 44 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
char *_tib ;
#line 47
int _base ;
#line 50
struct word_def *_last ;
#line 52
int _env_slash_counted_string ;
#line 53
int _env_slash_hold ;
#line 54
int _env_slash_pad ;
#line 55
int _env_address_unit_bits ;
#line 56
int _env_core ;
#line 57
int _env_core_ext ;
#line 58
int _env_floored ;
#line 59
int _env_max_char ;
#line 60
int _env_max_d ;
#line 61
int _env_max_n ;
#line 62
int _env_max_u ;
#line 63
int _env_max_ud ;
#line 64
int _env_return_stack_cells ;
#line 65
int _env_stack_cells ;
#line 66
int _env_double ;
#line 67
int _env_double_ext ;
#line 68
int _env_floating ;
#line 69
int _env_floating_stack ;
#line 70
int _env_max_float ;
#line 71
int _env_floating_ext ;
#line 72
int _env_memory_alloc ;
#line 73
int _env_memory_alloc_ext ;
#line 74
int _env_search_order ;
#line 75
int _env_wordlists ;
#line 76
int _env_search_order_ext ;
#line 77
int _env_tools ;
#line 78
int _env_tools_ext ;
#line 79
int _env_number_locals ;
#line 80
int _env_locals ;
#line 81
int _env_locals_ext ;
#line 82
int _env_facility ;
#line 83
int _env_facility_ext ;
#line 84
int _env_block ;
#line 85
int _env_block_ext ;
#line 86
int _env_exception ;
#line 87
int _env_exception_ext ;
#line 88
int _env_file ;
#line 89
int _env_file_ext ;
#line 90
int _env_string ;
#line 91
int _env_string_ext ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.h"
char *_pad ;
#line 50 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.h"
void _wordlist(void) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yfinit.c"
void init_stacks(int dstack_size___0 , int rstack_size___0 , int fstack_size___0 ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 32
  tmp = malloc((unsigned long )dstack_size___0 * sizeof(int ));
#line 32
  sp_base = (int *)tmp;
#line 33
  tmp___0 = malloc((unsigned long )rstack_size___0 * sizeof(int ));
#line 33
  rp_base = (int *)tmp___0;
#line 34
  tmp___1 = malloc((unsigned long )fstack_size___0 * sizeof(float ));
#line 34
  fp_base = (float *)tmp___1;
  }
#line 35
  if (sp_base) {
#line 35
    if (rp_base) {
#line 35
      if (fp_base) {
#line 35
        goto _L;
      } else
#line 35
      if (! fstack_size___0) {
        _L: /* CIL Label */ 
#line 36
        sp_top = sp_base + dstack_size___0;
#line 36
        sp = sp_top;
#line 37
        rp_top = rp_base + rstack_size___0;
#line 37
        rp = rp_top;
#line 38
        fp_top = fp_base + fstack_size___0;
#line 38
        fp = fp_top;
      } else {
        {
#line 40
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack sizes: %d %d %d. Not enough memory.\n",
                dstack_size___0, rstack_size___0, fstack_size___0);
#line 42
        exit(-1);
        }
      }
    } else {
      {
#line 40
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack sizes: %d %d %d. Not enough memory.\n",
              dstack_size___0, rstack_size___0, fstack_size___0);
#line 42
      exit(-1);
      }
    }
  } else {
    {
#line 40
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack sizes: %d %d %d. Not enough memory.\n",
            dstack_size___0, rstack_size___0, fstack_size___0);
#line 42
    exit(-1);
    }
  }
#line 44
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yfinit.c"
void init_data_space(int dspace_size___0 ) 
{ 
  void *tmp ;

  {
  {
#line 48
  tmp = malloc((unsigned long )dspace_size___0 * sizeof(int ));
#line 48
  _dp = (char *)tmp;
#line 48
  dp0 = _dp;
  }
#line 49
  if (! _dp) {
    {
#line 50
    printf((char const   */* __restrict  */)"Data Space size: %d. Not enough memory.\n",
           dspace_size___0);
#line 51
    exit(-1);
    }
  }
#line 53
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yfinit.c"
void init_tib(int size ) 
{ 
  void *tmp ;

  {
  {
#line 57
  tmp = malloc((unsigned long )size * sizeof(char ));
#line 57
  _tib = (char *)tmp;
  }
#line 58
  if (! _tib) {
    {
#line 59
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Tib size: %d. Not enough memory.\n",
            size);
#line 60
    exit(-1);
    }
  }
#line 62
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yfinit.c"
void init_pad(int size ) 
{ 
  void *tmp ;

  {
  {
#line 66
  tmp = malloc((unsigned long )size * sizeof(char ));
#line 66
  _pad = (char *)tmp;
  }
#line 67
  if (! _pad) {
    {
#line 68
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PAD size: %d. Not enough memory.\n",
            size);
#line 69
    exit(-1);
    }
  }
#line 71
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yfinit.c"
void init_pnos(void) 
{ 
  void *tmp ;

  {
  {
#line 77
  pnos_size = (int )(sizeof(long long ) * 8UL + 2UL);
#line 78
  tmp = malloc((unsigned long )pnos_size * sizeof(char ));
#line 78
  pnos = (char *)tmp;
  }
#line 79
  if (! pnos) {
    {
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t allocate PNOS.\n");
#line 81
    exit(-1);
    }
  }
#line 83
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yfinit.c"
void init_forth_environment(int reload ) 
{ 
  int *tmp ;

  {
#line 92
  if (reload) {
    {
#line 94
    _wordlist();
#line 95
    tmp = sp;
#line 95
    sp ++;
#line 95
    voc = (struct vocabulary *)*tmp;
#line 95
    forth_wid = voc;
#line 95
    list[0] = forth_wid;
#line 96
    _last = (struct word_def *)((void *)0);
#line 97
    init_vocabulary(& _dp);
    }
  }
#line 99
  _base = 10;
#line 100
  _env_slash_counted_string = (1 << 8UL * sizeof(char )) - 1;
#line 101
  _env_slash_hold = pnos_size;
#line 102
  _env_slash_pad = pad_size;
#line 103
  _env_address_unit_bits = (int )(8UL * sizeof(char ));
#line 104
  _env_core = -1;
#line 105
  _env_core_ext = -1;
#line 106
  _env_floored = 0;
#line 107
  _env_max_char = _env_slash_counted_string;
#line 108
  _env_max_d = -1;
#line 109
  _env_max_n = 2147483647;
#line 110
  _env_max_u = -1;
#line 111
  _env_max_ud = -1;
#line 112
  _env_return_stack_cells = rstack_size;
#line 113
  _env_stack_cells = dstack_size;
#line 114
  _env_double = -1;
#line 115
  _env_double_ext = -1;
#line 116
  _env_floating = -1;
#line 117
  _env_floating_stack = fstack_size;
#line 118
  _env_max_float = (int )0.0;
#line 119
  _env_floating_ext = -1;
#line 120
  _env_memory_alloc = -1;
#line 121
  _env_memory_alloc_ext = 0;
#line 122
  _env_search_order = -1;
#line 123
  _env_search_order_ext = -1;
#line 124
  _env_wordlists = 8;
#line 125
  _env_tools = -1;
#line 126
  _env_tools_ext = -1;
#line 127
  _env_number_locals = 8;
#line 128
  _env_locals = -1;
#line 129
  _env_locals_ext = -1;
#line 130
  _env_facility = -1;
#line 131
  _env_facility_ext = 0;
#line 132
  _env_block = -1;
#line 133
  _env_block_ext = -1;
#line 134
  _env_exception = -1;
#line 135
  _env_exception_ext = 0;
#line 136
  _env_file = -1;
#line 137
  _env_file_ext = -1;
#line 138
  _env_string = -1;
#line 139
  _env_string_ext = 0;
#line 140
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
void _b_l(void) ;
#line 196
void _c_r(void) ;
#line 197
void _emit(void) ;
#line 200
void _type(void) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.h"
void _dot_r(void) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.h"
struct _block_data *block_data ;
#line 68
void _block(void) ;
#line 71
void _load(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/blocke.h"
unsigned int _s_c_r  ;
#line 48
void _empty_buffers(void) ;
#line 49
void _list(void) ;
#line 50
void _thru(void) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/blocke.c"
void _empty_buffers(void) 
{ 
  register int i ;

  {
#line 40
  i = 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < 4)) {
#line 40
      goto while_break;
    }
#line 40
    (block_data + i)->block_no = 0U;
#line 40
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/blocke.c"
void _list(void) 
{ 
  register char *buffer ;
  register int i ;
  int *tmp ;

  {
  {
#line 46
  _block();
#line 47
  tmp = sp;
#line 47
  sp ++;
#line 47
  buffer = (char *)*tmp;
#line 48
  i = 0;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < 1024)) {
#line 48
      goto while_break;
    }
    {
#line 49
    sp --;
#line 49
    *sp = i / 64;
#line 50
    sp --;
#line 50
    *sp = 2;
#line 51
    _dot_r();
#line 52
    sp --;
#line 52
    *sp = ':';
#line 53
    _emit();
#line 54
    _b_l();
#line 55
    _emit();
#line 56
    sp --;
#line 56
    *sp = (int )buffer + i;
#line 57
    sp --;
#line 57
    *sp = 64;
#line 58
    _type();
#line 59
    _c_r();
#line 48
    i += 64;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/blocke.c"
void _thru(void) 
{ 
  register unsigned int u2 ;
  int *tmp ;
  register unsigned int u1 ;
  int *tmp___0 ;

  {
#line 64
  tmp = sp;
#line 64
  sp ++;
#line 64
  u2 = (unsigned int )*tmp;
#line 65
  tmp___0 = sp;
#line 65
  sp ++;
#line 65
  u1 = (unsigned int )*tmp___0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (u1 <= u2)) {
#line 66
      goto while_break;
    }
    {
#line 67
    sp --;
#line 67
    *sp = (int )u1;
#line 68
    _load();
#line 66
    u1 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) acos)(double __x ) ;
#line 56
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) asin)(double __x ) ;
#line 58
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan)(double __x ) ;
#line 60
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan2)(double __y ,
                                                                               double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 67
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) tan)(double __x ) ;
#line 72
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cosh)(double __x ) ;
#line 74
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sinh)(double __x ) ;
#line 76
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) tanh)(double __x ) ;
#line 88
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) acosh)(double __x ) ;
#line 90
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) asinh)(double __x ) ;
#line 92
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atanh)(double __x ) ;
#line 100
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 109
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 112
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log10)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 181
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.h"
void _d_f_store(void) ;
#line 43
void _d_f_fetch(void) ;
#line 46
void _d_float_plus(void) ;
#line 47
void _d_floats(void) ;
#line 48
void _f_star_star(void) ;
#line 49
void _f_dot(void) ;
#line 50
void _f_abs(void) ;
#line 51
void _f_a_cos(void) ;
#line 52
void _f_a_cosh(void) ;
#line 53
void _f_a_log(void) ;
#line 54
void _f_a_sin(void) ;
#line 55
void _f_a_sinh(void) ;
#line 56
void _f_a_tan(void) ;
#line 57
void _f_a_tan2(void) ;
#line 58
void _f_a_tanh(void) ;
#line 59
void _f_cos(void) ;
#line 60
void _f_cosh(void) ;
#line 61
void _f_e_dot(void) ;
#line 62
void _f_exp(void) ;
#line 63
void _f_exp_m_one(void) ;
#line 64
void _f_ln(void) ;
#line 65
void _f_ln_p_one(void) ;
#line 66
void _f_log(void) ;
#line 67
void _f_s_dot(void) ;
#line 68
void _f_sin(void) ;
#line 69
void _f_sin_cos(void) ;
#line 70
void _f_sinh(void) ;
#line 71
void _f_sqrt(void) ;
#line 72
void _f_tan(void) ;
#line 73
void _f_tanh(void) ;
#line 74
void _f_proximate(void) ;
#line 75
void _precision(void) ;
#line 76
void _set_precision(void) ;
#line 77
void _s_f_store(void) ;
#line 78
void _s_f_fetch(void) ;
#line 81
void _s_float_plus(void) ;
#line 82
void _s_floats(void) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
static int precision  =    15;
#line 36 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _d_f_store(void) 
{ 
  register double *addr ;
  int *tmp ;
  float *tmp___0 ;

  {
#line 37
  tmp = sp;
#line 37
  sp ++;
#line 37
  addr = (double *)*tmp;
#line 38
  tmp___0 = fp;
#line 38
  fp ++;
#line 38
  *addr = (double )*tmp___0;
#line 39
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _d_f_fetch(void) 
{ 
  register double *addr ;
  int *tmp ;

  {
#line 42
  tmp = sp;
#line 42
  sp ++;
#line 42
  addr = (double *)*tmp;
#line 43
  fp --;
#line 43
  *fp = (float )*addr;
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _d_float_plus(void) 
{ 


  {
#line 47
  *(sp + 0) = (int )((unsigned long )*(sp + 0) + sizeof(double ));
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _d_floats(void) 
{ 


  {
#line 51
  *(sp + 0) = (int )((unsigned long )*(sp + 0) * sizeof(double ));
#line 52
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_star_star(void) 
{ 
  double tmp ;

  {
  {
#line 55
  tmp = pow((double )*(fp + 1), (double )*(fp + 0));
#line 55
  *(fp + 1) = (float )tmp;
#line 56
  fp ++;
  }
#line 57
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_dot(void) 
{ 
  float *tmp ;

  {
  {
#line 60
  tmp = fp;
#line 60
  fp ++;
#line 60
  printf((char const   */* __restrict  */)"%.*f ", precision, (double )*tmp);
  }
#line 61
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_abs(void) 
{ 
  double tmp ;

  {
  {
#line 64
  tmp = fabs((double )*fp);
#line 64
  *fp = (float )tmp;
  }
#line 65
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_a_cos(void) 
{ 
  double tmp ;

  {
  {
#line 68
  tmp = acos((double )*fp);
#line 68
  *fp = (float )tmp;
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_a_cosh(void) 
{ 
  double tmp ;

  {
  {
#line 73
  tmp = acosh((double )*fp);
#line 73
  *fp = (float )tmp;
  }
#line 77
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_a_log(void) 
{ 
  double tmp ;

  {
  {
#line 80
  tmp = pow((double )10, (double )*fp);
#line 80
  *fp = (float )tmp;
  }
#line 81
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_a_sin(void) 
{ 
  double tmp ;

  {
  {
#line 84
  tmp = asin((double )*fp);
#line 84
  *fp = (float )tmp;
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_a_sinh(void) 
{ 
  double tmp ;

  {
  {
#line 89
  tmp = asinh((double )*fp);
#line 89
  *fp = (float )tmp;
  }
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_a_tan(void) 
{ 
  double tmp ;

  {
  {
#line 96
  tmp = atan((double )*fp);
#line 96
  *fp = (float )tmp;
  }
#line 97
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_a_tan2(void) 
{ 
  double tmp ;

  {
  {
#line 100
  tmp = atan2((double )*(fp + 1), (double )*(fp + 0));
#line 100
  *(fp + 1) = (float )tmp;
#line 101
  fp ++;
  }
#line 102
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_a_tanh(void) 
{ 
  double tmp ;

  {
  {
#line 106
  tmp = atanh((double )*fp);
#line 106
  *fp = (float )tmp;
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_cos(void) 
{ 
  double tmp ;

  {
  {
#line 113
  tmp = cos((double )*fp);
#line 113
  *fp = (float )tmp;
  }
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_cosh(void) 
{ 
  double tmp ;

  {
  {
#line 117
  tmp = cosh((double )*fp);
#line 117
  *fp = (float )tmp;
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_e_dot(void) 
{ 
  register float r ;
  float *tmp ;
  register int esp ;

  {
#line 121
  tmp = fp;
#line 121
  fp ++;
#line 121
  r = *tmp;
#line 122
  esp = 0;
#line 123
  if ((double )r != 0.0) {
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! ((double )r < 1.0)) {
#line 124
        if (! ((double )r > 1000.0)) {
#line 124
          goto while_break;
        }
      }
#line 125
      if ((double )r < 1.0) {
#line 126
        r = (float )((double )r * 1000.0);
#line 127
        esp -= 3;
      } else {
#line 129
        r = (float )((double )r / 1000.0);
#line 130
        esp += 3;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 133
  printf((char const   */* __restrict  */)"%.*fE%d ", precision, (double )r, esp);
  }
#line 134
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_exp(void) 
{ 
  double tmp ;

  {
  {
#line 137
  tmp = exp((double )*fp);
#line 137
  *fp = (float )tmp;
  }
#line 138
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_exp_m_one(void) 
{ 
  double tmp ;

  {
  {
#line 141
  tmp = exp((double )*fp);
#line 141
  *fp = (float )(tmp - 1.0);
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_ln(void) 
{ 
  double tmp ;

  {
  {
#line 145
  tmp = log((double )*fp);
#line 145
  *fp = (float )tmp;
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_ln_p_one(void) 
{ 
  double tmp ;

  {
  {
#line 149
  tmp = log((double )*fp);
#line 149
  *fp = (float )(tmp + 1.0);
  }
#line 150
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_log(void) 
{ 
  double tmp ;

  {
  {
#line 153
  tmp = log10((double )*fp);
#line 153
  *fp = (float )tmp;
  }
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_s_dot(void) 
{ 
  float *tmp ;

  {
  {
#line 157
  tmp = fp;
#line 157
  fp ++;
#line 157
  printf((char const   */* __restrict  */)"%.*e ", precision, (double )*tmp);
  }
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_sin(void) 
{ 
  double tmp ;

  {
  {
#line 161
  tmp = sin((double )*fp);
#line 161
  *fp = (float )tmp;
  }
#line 162
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_sin_cos(void) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
#line 165
  fp --;
#line 166
  tmp = cos((double )*(fp + 1));
#line 166
  *(fp + 0) = (float )tmp;
#line 167
  tmp___0 = sin((double )*(fp + 1));
#line 167
  *(fp + 1) = (float )tmp___0;
  }
#line 168
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_sinh(void) 
{ 
  double tmp ;

  {
  {
#line 171
  tmp = sinh((double )*fp);
#line 171
  *fp = (float )tmp;
  }
#line 172
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_sqrt(void) 
{ 
  double tmp ;

  {
  {
#line 175
  tmp = sqrt((double )*fp);
#line 175
  *fp = (float )tmp;
  }
#line 176
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_tan(void) 
{ 
  double tmp ;

  {
  {
#line 179
  tmp = tan((double )*fp);
#line 179
  *fp = (float )tmp;
  }
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_tanh(void) 
{ 
  double tmp ;

  {
  {
#line 183
  tmp = tanh((double )*fp);
#line 183
  *fp = (float )tmp;
  }
#line 184
  return;
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _f_proximate(void) 
{ 
  register float r3 ;
  float *tmp ;
  register float r2 ;
  float *tmp___0 ;
  register float r1 ;
  float *tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
#line 187
  tmp = fp;
#line 187
  fp ++;
#line 187
  r3 = *tmp;
#line 188
  tmp___0 = fp;
#line 188
  fp ++;
#line 188
  r2 = *tmp___0;
#line 189
  tmp___1 = fp;
#line 189
  fp ++;
#line 189
  r1 = *tmp___1;
#line 190
  if ((double )r3 > 0.0) {
    {
#line 190
    sp --;
#line 190
    tmp___2 = fabs((double )(r1 - r2));
#line 190
    *sp = - (tmp___2 < (double )r3);
    }
  } else
#line 191
  if ((double )r3 < 0.0) {
    {
#line 191
    sp --;
#line 191
    tmp___3 = fabs((double )(r1 - r2));
#line 191
    tmp___4 = fabs((double )r1);
#line 191
    tmp___5 = fabs((double )r2);
#line 191
    *sp = - (tmp___3 < (double )(- r3) * (tmp___4 + tmp___5));
    }
  } else {
#line 192
    sp --;
#line 192
    *sp = - (r1 == r2);
  }
#line 193
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _precision(void) 
{ 


  {
#line 196
  sp --;
#line 196
  *sp = precision;
#line 197
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _set_precision(void) 
{ 
  int *tmp ;

  {
#line 200
  tmp = sp;
#line 200
  sp ++;
#line 200
  precision = *tmp;
#line 201
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _s_f_store(void) 
{ 
  register float *addr ;
  int *tmp ;
  float *tmp___0 ;

  {
#line 204
  tmp = sp;
#line 204
  sp ++;
#line 204
  addr = (float *)*tmp;
#line 205
  tmp___0 = fp;
#line 205
  fp ++;
#line 205
  *addr = *tmp___0;
#line 206
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _s_f_fetch(void) 
{ 
  register float *addr ;
  int *tmp ;

  {
#line 209
  tmp = sp;
#line 209
  sp ++;
#line 209
  addr = (float *)*tmp;
#line 210
  fp --;
#line 210
  *fp = *addr;
#line 211
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _s_float_plus(void) 
{ 


  {
#line 214
  *(sp + 0) = (int )((unsigned long )*(sp + 0) + sizeof(float ));
#line 215
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/floate.c"
void _s_floats(void) 
{ 


  {
#line 218
  *(sp + 0) = (int )((unsigned long )*(sp + 0) * sizeof(float ));
#line 219
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
int top ;
#line 43 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/searche.h"
void _also(void) ;
#line 44
void _forth(void) ;
#line 45
void _only(void) ;
#line 46
void _order(void) ;
#line 47
void _previous(void) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/searche.c"
void _also(void) 
{ 


  {
#line 30
  if (top < 8) {
#line 31
    top ++;
#line 32
    list[top] = list[top - 1];
  }
#line 34
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/searche.c"
void _forth(void) 
{ 


  {
#line 37
  list[top] = forth_wid;
#line 38
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/searche.c"
void _only(void) 
{ 


  {
#line 41
  top = 0;
#line 42
  list[0] = forth_wid;
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/searche.c"
void _order(void) 
{ 
  register int i ;

  {
  {
#line 47
  printf((char const   */* __restrict  */)"[%p] ", voc);
#line 48
  i = 0;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i <= top)) {
#line 48
      goto while_break;
    }
    {
#line 48
    printf((char const   */* __restrict  */)"%d: %p ", i, list[i]);
#line 48
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/searche.c"
void _previous(void) 
{ 


  {
#line 52
  if (top >= 0) {
#line 52
    top --;
  }
#line 53
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
long long get_dcell(int *ptr ) ;
#line 96
void put_dcell(int *ptr , long long d ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/doublee.h"
void _two_rote(void) ;
#line 43
void _d_u_less(void) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/doublee.c"
void _two_rote(void) 
{ 
  register long long d1 ;
  long long tmp ;
  register long long d2 ;
  long long tmp___0 ;
  register long long d3 ;
  long long tmp___1 ;

  {
  {
#line 29
  tmp = get_dcell(sp);
#line 29
  d1 = tmp;
#line 30
  tmp___0 = get_dcell(sp + 2);
#line 30
  d2 = tmp___0;
#line 31
  tmp___1 = get_dcell(sp + 4);
#line 31
  d3 = tmp___1;
#line 32
  put_dcell(sp, d3);
#line 33
  put_dcell(sp + 2, d1);
#line 34
  put_dcell(sp + 4, d2);
  }
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/doublee.c"
void _d_u_less(void) 
{ 
  register unsigned long long ud1 ;
  long long tmp ;
  register unsigned long long ud2 ;
  long long tmp___0 ;

  {
  {
#line 38
  tmp = get_dcell(sp + 2);
#line 38
  ud1 = (unsigned long long )tmp;
#line 39
  tmp___0 = get_dcell(sp);
#line 39
  ud2 = (unsigned long long )tmp___0;
#line 40
  sp += 3;
#line 41
  *(sp + 0) = - (ud1 < ud2);
  }
#line 42
  return;
}
}
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 161 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
jmp_buf warm_start_jump  ;
#line 162 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
char *dp0  ;
#line 163
int dspace_size ;
#line 165
int tib_size ;
#line 166 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
int in_pnos  ;
#line 166 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
int pnos_size  ;
#line 167 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
char *pnos  ;
#line 167 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
char *p_pnos  ;
#line 184
void init_signals(void) ;
#line 185
void print_version(void) ;
#line 167 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
void _quit(void) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.h"
int open_block_file(char *name ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.h"
void load_vocabulary(struct voc_marker *vm ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.h"
void load_file(char *name ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
jmp_buf cold_start_jump  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
int dspace_size  =    16384;
#line 36 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
int dstack_size  =    512;
#line 36 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
int rstack_size  =    64;
#line 36 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
int fstack_size  =    6;
#line 39 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
int tib_size  =    128;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
int pad_size  =    128;
#line 44 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
static char *file_name___0  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
static char *image_file  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
static int silent  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
static struct image_header hd  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
void print_version(void) 
{ 


  {
  {
#line 53
  printf((char const   */* __restrict  */)"yForth? v%d.%d%s  Copyright (C) 2012  Luca Padovani\nThis program comes with ABSOLUTELY NO WARRANTY.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions; see LICENSE for details.\n",
         0, 2, "");
  }
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
void print_help(void) 
{ 


  {
  {
#line 61
  print_version();
#line 62
  printf((char const   */* __restrict  */)"Usage: yForth [options] [file name]\n-d<n>\tData-Space size         -s<n>\tData-Stack size\n-r<n>\tReturn-Stack size       -f<n>\tFloating-Stack size\n-t<n>\tTIB size                -p<n>\tPAD size\n-h,-H\tThis help               -q   \tQuiet\n-i<file> Image file\nAll sizes are expressed in cells.\n");
  }
#line 69
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
void do_parameters(int argc , char **argv ) 
{ 
  int i ;
  int tmp ;

  {
#line 73
  i = 1;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    tmp = argc;
#line 74
    argc --;
#line 74
    if (! (tmp > 1)) {
#line 74
      goto while_break;
    }
#line 75
    if ((int )*(*(argv + i) + 0) == 45) {
      {
#line 77
      if ((int )*(*(argv + i) + 1) == 100) {
#line 77
        goto case_100;
      }
#line 78
      if ((int )*(*(argv + i) + 1) == 115) {
#line 78
        goto case_115;
      }
#line 79
      if ((int )*(*(argv + i) + 1) == 114) {
#line 79
        goto case_114;
      }
#line 80
      if ((int )*(*(argv + i) + 1) == 102) {
#line 80
        goto case_102;
      }
#line 81
      if ((int )*(*(argv + i) + 1) == 116) {
#line 81
        goto case_116;
      }
#line 82
      if ((int )*(*(argv + i) + 1) == 112) {
#line 82
        goto case_112;
      }
#line 83
      if ((int )*(*(argv + i) + 1) == 113) {
#line 83
        goto case_113;
      }
#line 84
      if ((int )*(*(argv + i) + 1) == 105) {
#line 84
        goto case_105;
      }
#line 86
      if ((int )*(*(argv + i) + 1) == 72) {
#line 86
        goto case_72;
      }
#line 86
      if ((int )*(*(argv + i) + 1) == 104) {
#line 86
        goto case_72;
      }
#line 90
      goto switch_default;
      case_100: /* CIL Label */ 
      {
#line 77
      dspace_size = atoi((char const   *)(*(argv + i) + 2));
      }
#line 77
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 78
      dstack_size = atoi((char const   *)(*(argv + i) + 2));
      }
#line 78
      goto switch_break;
      case_114: /* CIL Label */ 
      {
#line 79
      rstack_size = atoi((char const   *)(*(argv + i) + 2));
      }
#line 79
      goto switch_break;
      case_102: /* CIL Label */ 
      {
#line 80
      fstack_size = atoi((char const   *)(*(argv + i) + 2));
      }
#line 80
      goto switch_break;
      case_116: /* CIL Label */ 
      {
#line 81
      tib_size = atoi((char const   *)(*(argv + i) + 2));
      }
#line 81
      goto switch_break;
      case_112: /* CIL Label */ 
      {
#line 82
      pad_size = atoi((char const   *)(*(argv + i) + 2));
      }
#line 82
      goto switch_break;
      case_113: /* CIL Label */ 
#line 83
      silent = 1;
#line 83
      goto switch_break;
      case_105: /* CIL Label */ 
#line 84
      image_file = *(argv + i) + 2;
#line 84
      goto switch_break;
      case_72: /* CIL Label */ 
      case_104: /* CIL Label */ 
      {
#line 87
      print_help();
#line 88
      exit(0);
      }
#line 89
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 91
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c unknown option, use -h for help.\n");
#line 92
      exit(0);
      }
#line 93
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 96
      file_name___0 = *(argv + i);
#line 97
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
void default_parameters(void) 
{ 


  {
#line 106
  if (1024 > dspace_size) {
#line 106
    dspace_size = 1024;
  } else {
#line 106
    dspace_size = dspace_size;
  }
#line 107
  if (32 > dstack_size) {
#line 107
    dstack_size = 32;
  } else {
#line 107
    dstack_size = dstack_size;
  }
#line 108
  if (16 > rstack_size) {
#line 108
    rstack_size = 16;
  } else {
#line 108
    rstack_size = rstack_size;
  }
#line 109
  if (0 > fstack_size) {
#line 109
    fstack_size = 0;
  } else {
#line 109
    fstack_size = fstack_size;
  }
#line 110
  if (80 > tib_size) {
#line 110
    tib_size = 80;
  } else {
#line 110
    tib_size = tib_size;
  }
#line 111
  if (80 > pad_size) {
#line 111
    pad_size = 80;
  } else {
#line 111
    pad_size = pad_size;
  }
#line 112
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
int load_image_file(char *name , int header ) 
{ 
  FILE *f ;
  FILE *tmp ;
  int res ;
  size_t tmp___0 ;
  struct voc_marker vm ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 126
  tmp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
#line 126
  f = tmp;
#line 127
  res = 1;
  }
#line 128
  if (f) {
#line 129
    if (header) {
      {
#line 130
      tmp___0 = fread((void */* __restrict  */)(& hd), sizeof(struct image_header ),
                      (size_t )1, (FILE */* __restrict  */)f);
      }
#line 130
      if (tmp___0) {
#line 131
        if (hd.ver_hi != 0) {
#line 131
          goto _L;
        } else
#line 131
        if (hd.ver_lo != 2) {
          _L: /* CIL Label */ 
#line 132
          if (! silent) {
            {
#line 133
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: different image file version (%d.%d).\n",
                    hd.ver_hi, hd.ver_lo);
            }
          }
        }
#line 135
        if ((long )hd.pattern != ((((((((((((((((((1L | (1L << 1)) | (1L << 2)) | (1L << 3)) | (1L << 4)) | (1L << 5)) | (1L << 7)) | (1L << 8)) | (1L << 9)) | (1L << 10)) | (1L << 11)) | (1L << 12)) | (1L << 13)) | (1L << 15)) | (1L << 16)) | (1L << 17)) | (1L << 19)) | (1L << 20)) | (1L << 21))) {
#line 136
          if (! silent) {
            {
#line 137
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: different version pattern (Image: %x).\n",
                    hd.pattern);
            }
          }
        }
#line 139
        res = 0;
      } else {
        {
#line 140
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: can\'t read image file header.\n");
        }
      }
    } else {
      {
#line 142
      fseek(f, (long )sizeof(struct image_header ), 0);
      }
#line 143
      if ((unsigned long )hd.base == (unsigned long )dp0) {
        {
#line 145
        tmp___1 = fread((void */* __restrict  */)(& vm), sizeof(struct voc_marker ),
                        (size_t )1, (FILE */* __restrict  */)f);
        }
#line 145
        if (tmp___1 < 1UL) {
          {
#line 147
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: can\'t read image file.\n");
          }
        } else {
          {
#line 145
          tmp___2 = fread((void */* __restrict  */)dp0, sizeof(int ), (size_t )hd.dspace_size,
                          (FILE */* __restrict  */)f);
          }
#line 145
          if (tmp___2 != (size_t )hd.dspace_size) {
            {
#line 147
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: can\'t read image file.\n");
            }
          } else {
            {
#line 149
            load_vocabulary(& vm);
#line 150
            res = 0;
            }
          }
        }
      } else {
        {
#line 152
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: can\'t load image file with base %u at %u.\n",
                hd.base, dp0);
        }
      }
    }
    {
#line 155
    fclose(f);
    }
  } else {
    {
#line 156
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open image file (%s).\n",
            name);
    }
  }
#line 157
  return (res);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 161
  do_parameters(argc, argv);
  }
#line 162
  if (image_file) {
    {
#line 163
    tmp = load_image_file(image_file, 1);
    }
#line 163
    if (tmp) {
      {
#line 163
      exit(-1);
      }
    }
  } else {
    {
#line 164
    fopen((char const   */* __restrict  */)*(argv + 0), (char const   */* __restrict  */)"rb");
    }
  }
  {
#line 171
  default_parameters();
#line 173
  open_block_file((char *)"YFORTH.BLK");
#line 175
  init_stacks(dstack_size, rstack_size, fstack_size);
  }
#line 176
  if (image_file) {
#line 176
    if (dspace_size < hd.dspace_size) {
#line 177
      if (! silent) {
        {
#line 178
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: can\'t restrict dictionary to %u cells, now is %u cells.\n",
                dspace_size, hd.dspace_size);
        }
      }
#line 180
      if (dspace_size > hd.dspace_size) {
#line 180
        dspace_size = dspace_size;
      } else {
#line 180
        dspace_size = hd.dspace_size;
      }
    }
  }
  {
#line 182
  init_data_space(dspace_size);
#line 183
  init_tib(tib_size);
#line 184
  init_pad(pad_size);
#line 185
  init_pnos();
#line 186
  init_signals();
#line 188
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(cold_start_jump));
#line 188
  silent |= tmp___0;
  }
#line 189
  if (image_file) {
    {
#line 190
    tmp___1 = load_image_file(image_file, 0);
    }
#line 190
    if (tmp___1) {
      {
#line 190
      exit(-1);
      }
    }
  }
#line 194
  if (! silent) {
    {
#line 195
    print_version();
    }
  }
  {
#line 201
  init_forth_environment(! image_file);
#line 202
  tmp___2 = _setjmp((struct __jmp_buf_tag *)(warm_start_jump));
  }
#line 202
  if (! tmp___2) {
#line 202
    if (file_name___0) {
      {
#line 202
      load_file(file_name___0);
      }
    }
  }
  {
#line 203
  _quit();
  }
#line 204
  return (0);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/toolse.h"
void _ahead(void) ;
#line 43
void _bye(void) ;
#line 46
void _bracket_else(void) ;
#line 47
void _bracket_if(void) ;
#line 48
void _bracket_then(void) ;
#line 160 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
void _word(void) ;
#line 236
void _branch(void) ;
#line 255
int strmatch(char const   *s1 , char const   *s2 , int len1 ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.h"
void _refill(void) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.h"
void close_block_file(void) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/toolse.c"
void _bye(void) 
{ 


  {
  {
#line 35
  close_block_file();
#line 37
  exit(0);
  }
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/toolse.c"
void _ahead(void) 
{ 


  {
#line 41
  *((int *)_dp) = (int )(& _branch);
#line 41
  _dp += sizeof(int );
#line 42
  sp --;
#line 42
  *sp = (int )_dp;
#line 43
  *((int *)_dp) = 0;
#line 43
  _dp += sizeof(int );
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/toolse.c"
void _bracket_if(void) 
{ 
  register int flag ;
  int *tmp ;
  register int nest ;
  register int ok ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 47
  tmp = sp;
#line 47
  sp ++;
#line 47
  flag = *tmp;
#line 48
  nest = 1;
#line 49
  ok = -1;
#line 50
  if (! flag) {
    {
#line 51
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 52
      _b_l();
#line 53
      _word();
#line 54
      sp ++;
      }
#line 55
      if (! *_dp) {
        {
#line 56
        _refill();
#line 57
        tmp___0 = sp;
#line 57
        sp ++;
#line 57
        ok = *tmp___0;
        }
      } else {
        {
#line 59
        tmp___3 = strmatch("[IF]", (char const   *)_dp, 4);
        }
#line 59
        if (tmp___3) {
          {
#line 60
          tmp___1 = strmatch("[THEN]", (char const   *)_dp, 6);
          }
#line 60
          if (tmp___1) {
            {
#line 60
            tmp___2 = strmatch("[ELSE]", (char const   *)_dp, 6);
            }
#line 60
            if (! tmp___2) {
#line 60
              if (nest == 1) {
#line 61
                nest --;
              }
            }
          } else {
#line 61
            nest --;
          }
        } else {
#line 59
          nest ++;
        }
      }
#line 51
      if (nest) {
#line 51
        if (! ok) {
#line 51
          goto while_break;
        }
      } else {
#line 51
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 65
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/toolse.c"
void _bracket_else(void) 
{ 
  register int nest ;
  register int ok ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 68
  nest = 1;
#line 69
  ok = -1;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    _b_l();
#line 72
    _word();
#line 73
    sp ++;
    }
#line 74
    if (! *_dp) {
      {
#line 75
      _refill();
#line 76
      tmp = sp;
#line 76
      sp ++;
#line 76
      ok = *tmp;
      }
    } else {
      {
#line 78
      tmp___1 = strmatch("[IF]", (char const   *)_dp, 4);
      }
#line 78
      if (tmp___1) {
        {
#line 79
        tmp___0 = strmatch("[THEN]", (char const   *)_dp, 6);
        }
#line 79
        if (! tmp___0) {
#line 79
          nest --;
        }
      } else {
#line 78
        nest ++;
      }
    }
#line 70
    if (nest) {
#line 70
      if (! ok) {
#line 70
        goto while_break;
      }
    } else {
#line 70
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/toolse.c"
void _bracket_then(void) 
{ 


  {
#line 85
  return;
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/udio.h"
void d_open(void) ;
#line 22
void d_close(void) ;
#line 23
void d_clrscr(void) ;
#line 24
void d_clreol(void) ;
#line 26
int d_getattr(void) ;
#line 27
void d_gotoxy(int x , int y ) ;
#line 28
int d_wherex(void) ;
#line 29
int d_wherey(void) ;
#line 30
char d_getch(void) ;
#line 31
int d_kbhit(void) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/udio.c"
void d_clrscr(void) 
{ 


  {
#line 33
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/udio.c"
void d_clreol(void) 
{ 


  {
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/udio.c"
void d_setaddr(int attr ) 
{ 


  {
#line 47
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/udio.c"
int d_getattr(void) 
{ 


  {
#line 56
  return (0);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/udio.c"
void d_gotoxy(int x , int y ) 
{ 


  {
#line 63
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/udio.c"
int d_wherex(void) 
{ 


  {
#line 70
  return (0);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/udio.c"
int d_wherey(void) 
{ 


  {
#line 77
  return (0);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/udio.c"
char d_getch(void) 
{ 


  {
#line 87
  return ((char)0);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/udio.c"
int d_kbhit(void) 
{ 


  {
#line 94
  return (0);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/udio.c"
void d_open(void) 
{ 


  {
#line 98
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/udio.c"
void d_close(void) 
{ 


  {
#line 102
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
void _to_r(void) ;
#line 207
void _count(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/localse.h"
void _locals_bar(void) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/localse.c"
void _locals_bar(void) 
{ 


  {
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 32
    _b_l();
#line 33
    _word();
#line 34
    _count();
    }
#line 35
    if (*(sp + 0) != 1) {
      {
#line 36
      _paren_local_paren();
#line 37
      *((int *)_dp) = (int )(& _to_r);
#line 37
      _dp += sizeof(int );
      }
    } else
#line 35
    if ((int )*((char *)*(sp + 1)) != 124) {
      {
#line 36
      _paren_local_paren();
#line 37
      *((int *)_dp) = (int )(& _to_r);
#line 37
      _dp += sizeof(int );
      }
    } else {
#line 38
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  return;
}
}
#line 74 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 260 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
void exec_word(struct word_def *xt ) ;
#line 262
void save_input_specification(void) ;
#line 263
void restore_input_specification(void) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/exceptio.h"
void _catch(void) ;
#line 52
void _throw(void) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/exceptio.c"
struct exception_frame *top_frame  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/exceptio.c"
void _catch(void) 
{ 
  register struct exception_frame *frame ;
  void *tmp ;
  register int ret_val ;
  int *tmp___0 ;

  {
  {
#line 38
  tmp = malloc(sizeof(struct exception_frame ));
#line 38
  frame = (struct exception_frame *)tmp;
  }
#line 40
  if (frame) {
    {
#line 42
    ret_val = _setjmp((struct __jmp_buf_tag *)(frame->catch_buf));
    }
#line 42
    if (ret_val == 0) {
      {
#line 44
      save_input_specification();
#line 45
      frame->sp = sp + 1;
#line 46
      frame->rp = rp;
#line 47
      frame->bp = bp;
#line 48
      frame->fp = fp;
#line 49
      frame->last = top_frame;
#line 50
      top_frame = frame;
#line 51
      tmp___0 = sp;
#line 51
      sp ++;
#line 51
      exec_word((struct word_def *)*tmp___0);
#line 52
      sp --;
#line 52
      *sp = 0;
      }
    } else {
#line 53
      sp --;
#line 53
      *sp = ret_val;
    }
    {
#line 54
    frame = top_frame;
#line 55
    sp = frame->sp;
#line 56
    rp = frame->rp;
#line 57
    bp = frame->bp;
#line 58
    top_frame = frame->last;
#line 59
    free((void *)frame);
#line 60
    restore_input_specification();
    }
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/exceptio.c"
void _throw(void) 
{ 
  register int n ;
  int *tmp ;

  {
#line 65
  tmp = sp;
#line 65
  sp ++;
#line 65
  n = *tmp;
#line 66
  if (n) {
#line 67
    if (top_frame) {
      {
#line 67
      longjmp((struct __jmp_buf_tag *)(top_frame->catch_buf), n);
      }
    } else
#line 68
    if (! (n == -1)) {
#line 69
      if (n == -2) {
        {
#line 69
        _type();
        }
      }
    }
    {
#line 70
    sp = sp_top;
#line 71
    longjmp((struct __jmp_buf_tag *)(warm_start_jump), 1);
    }
  }
#line 73
  return;
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/tools.h"
void _dot_s(void) ;
#line 43
void _question(void) ;
#line 44
void _dump(void) ;
#line 45
void _see(void) ;
#line 46
void _words(void) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _error ;
#line 124
void _fetch(void) ;
#line 195
void _dot(void) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/tools.c"
void _dot_s(void) 
{ 
  register int *p ;

  {
#line 31
  p = sp;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! ((unsigned long )p < (unsigned long )sp_top)) {
#line 32
      goto while_break;
    }
    {
#line 33
    sp --;
#line 33
    *sp = *p;
#line 34
    _dot();
#line 35
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/tools.c"
void _question(void) 
{ 


  {
  {
#line 40
  _fetch();
#line 41
  _dot();
  }
#line 42
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/tools.c"
void _dump(void) 
{ 
  register unsigned int u ;
  int *tmp ;
  register char *addr ;
  int *tmp___0 ;
  register int i ;
  int tmp___1 ;

  {
#line 45
  tmp = sp;
#line 45
  sp ++;
#line 45
  u = (unsigned int )*tmp;
#line 46
  tmp___0 = sp;
#line 46
  sp ++;
#line 46
  addr = (char *)*tmp___0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! u) {
#line 47
      goto while_break;
    }
    {
#line 49
    printf((char const   */* __restrict  */)"%08p: ", addr);
#line 50
    i = 0;
    }
    {
#line 50
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      if (! (i < 16)) {
#line 50
        goto while_break___0;
      }
#line 51
      if ((int )(u - (unsigned int )i) > 0) {
        {
#line 51
        printf((char const   */* __restrict  */)"%02x ", (int )*(addr + i) & 255);
        }
      } else {
        {
#line 52
        printf((char const   */* __restrict  */)"   ");
        }
      }
#line 50
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 53
    i = 0;
    {
#line 53
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 53
      if (i < 16) {
#line 53
        if (! (u - (unsigned int )i > 0U)) {
#line 53
          goto while_break___1;
        }
      } else {
#line 53
        goto while_break___1;
      }
#line 54
      if ((int )*(addr + i) < 32) {
#line 54
        tmp___1 = '.';
      } else {
#line 54
        tmp___1 = (int )*(addr + i);
      }
      {
#line 54
      printf((char const   */* __restrict  */)"%c", tmp___1);
#line 53
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 55
    putchar('\n');
#line 56
    addr += i;
#line 57
    u -= (unsigned int )i;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/tools.c"
void _see(void) 
{ 


  {
#line 62
  _error = -15;
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/tools.c"
void _words(void) 
{ 
  register int i ;
  register struct word_def *p ;
  register int col ;
  int tmp ;

  {
#line 66
  i = 0;
#line 68
  col = 1;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! (i < 8)) {
#line 69
      goto while_break;
    }
#line 70
    tmp = i;
#line 70
    i ++;
#line 70
    p = voc->voc[tmp];
    {
#line 71
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 71
      if (! p) {
#line 71
        goto while_break___0;
      }
      {
#line 72
      sp --;
#line 72
      *sp = (int )p->name;
#line 73
      _count();
      }
#line 74
      if (col + *(sp + 0) > 79) {
        {
#line 75
        col = 1;
#line 76
        _c_r();
        }
      }
      {
#line 78
      col += *(sp + 0) + 1;
#line 79
      _type();
#line 80
      _b_l();
#line 81
      _emit();
#line 82
      p = p->link;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _to_in ;
#line 43
int _source_id ;
#line 45
char *_input_buffer ;
#line 46
int _in_input_buffer ;
#line 51
int _state ;
#line 126
void _align(void) ;
#line 153
void _s_to_d(void) ;
#line 163
void _accept(void) ;
#line 189
void _find(void) ;
#line 190
void _less_number_sign(void) ;
#line 193
void _number_sign_s(void) ;
#line 194
void _number_sign_greater(void) ;
#line 199
void _spaces(void) ;
#line 237
void _do_literal(void) ;
#line 251
struct word_def *search_word(char *name , int len ) ;
#line 253
void mark_word(struct word_def *p ) ;
#line 258
void create_definition(int class ) ;
#line 261
void compile_word(struct word_def *xt ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.h"
char *_pad  ;
#line 49
void _dot_paren(void) ;
#line 51
void _zero_not_equals(void) ;
#line 52
void _zero_greater(void) ;
#line 53
void _two_to_r(void) ;
#line 54
void _two_r_from(void) ;
#line 55
void _two_r_fetch(void) ;
#line 56
void _colon_no_name(void) ;
#line 57
void _not_equals(void) ;
#line 58
void _question_do(void) ;
#line 59
void _again(void) ;
#line 60
void _c_quote(void) ;
#line 61
void _compile_comma(void) ;
#line 62
void _erase(void) ;
#line 63
void _false(void) ;
#line 64
void _hex(void) ;
#line 65
void _marker(void) ;
#line 66
void _nip(void) ;
#line 67
void _parse(void) ;
#line 68
void _pick(void) ;
#line 70
void _restore_input(void) ;
#line 71
void _roll(void) ;
#line 72
void _save_input(void) ;
#line 73
void _true(void) ;
#line 74
void _tuck(void) ;
#line 75
void _u_dot_r(void) ;
#line 76
void _u_greater_than(void) ;
#line 77
void _unused(void) ;
#line 78
void _within(void) ;
#line 79
void _backslash(void) ;
#line 81
void _bracket_compile(void) ;
#line 82
void _value(void) ;
#line 83
void _to(void) ;
#line 85
void _paren_question_do_paren(void) ;
#line 86
void _paren_write_value_paren(void) ;
#line 87
void _paren_marker_paren(void) ;
#line 95
void exec_marker(struct voc_marker *vm ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.h"
void _d_dot_r(void) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.h"
unsigned int current_block ;
#line 62
unsigned int _b_l_k ;
#line 58 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.h"
void save_vocabulary(struct voc_marker *vm ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _dot_paren(void) 
{ 


  {
  {
#line 43
  sp --;
#line 43
  *sp = ')';
#line 44
  _word();
#line 45
  _count();
#line 46
  _type();
  }
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _dot_r(void) 
{ 
  register int u ;
  int *tmp ;

  {
  {
#line 50
  tmp = sp;
#line 50
  sp ++;
#line 50
  u = *tmp;
#line 51
  _s_to_d();
#line 52
  sp --;
#line 52
  *sp = u;
#line 53
  _d_dot_r();
  }
#line 54
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _zero_not_equals(void) 
{ 


  {
#line 57
  *(sp + 0) = - (*(sp + 0) != 0);
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _zero_greater(void) 
{ 


  {
#line 61
  *(sp + 0) = - (*(sp + 0) > 0);
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _two_to_r(void) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
#line 65
  rp -= 2;
#line 66
  tmp = sp;
#line 66
  sp ++;
#line 66
  *(rp + 0) = *tmp;
#line 67
  tmp___0 = sp;
#line 67
  sp ++;
#line 67
  *(rp + 1) = *tmp___0;
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _two_r_from(void) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
#line 71
  sp -= 2;
#line 72
  tmp = rp;
#line 72
  rp ++;
#line 72
  *(sp + 0) = *tmp;
#line 73
  tmp___0 = rp;
#line 73
  rp ++;
#line 73
  *(sp + 1) = *tmp___0;
#line 74
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _two_r_fetch(void) 
{ 


  {
#line 77
  sp -= 2;
#line 78
  *(sp + 0) = *(rp + 0);
#line 79
  *(sp + 1) = *(rp + 1);
#line 80
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _colon_no_name(void) 
{ 
  register struct word_def *def ;

  {
  {
#line 84
  _align();
#line 85
  def = (struct word_def *)_dp;
#line 86
  def->name = (char *)0;
#line 87
  def->link = (struct word_def *)0;
#line 88
  def->class = 3;
#line 89
  _dp += sizeof(struct word_def ) - sizeof(int );
#line 90
  _state = -1;
#line 91
  sp --;
#line 91
  *sp = (int )def;
#line 92
  init_locals();
  }
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _not_equals(void) 
{ 


  {
#line 96
  *(sp + 1) = - (*(sp + 0) != *(sp + 1));
#line 97
  sp ++;
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _question_do(void) 
{ 


  {
#line 101
  *((int *)_dp) = (int )(& _paren_question_do_paren);
#line 101
  _dp += sizeof(int );
#line 102
  sp --;
#line 102
  *sp = (int )_dp;
#line 103
  *((int *)_dp) = 0;
#line 103
  _dp += sizeof(int );
#line 104
  sp --;
#line 104
  *sp = (int )_dp;
#line 105
  sp --;
#line 105
  *sp = 1;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _paren_question_do_paren(void) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
#line 109
  if (*(sp + 0) == *(sp + 1)) {
#line 109
    ip += 1 + (int )*ip;
  } else {
#line 111
    rp --;
#line 111
    tmp = sp;
#line 111
    sp ++;
#line 111
    *rp = *tmp;
#line 112
    rp --;
#line 112
    tmp___0 = sp;
#line 112
    sp ++;
#line 112
    *rp = *tmp___0;
#line 113
    ip ++;
  }
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _again(void) 
{ 
  register int *dest ;
  int *tmp ;

  {
#line 118
  tmp = sp;
#line 118
  sp ++;
#line 118
  dest = (int *)*tmp;
#line 119
  *((int *)_dp) = (int )(& _branch);
#line 119
  _dp += sizeof(int );
#line 120
  *((int *)_dp) = (int )((dest - (int *)_dp) - 1L);
#line 120
  _dp += sizeof(int );
#line 121
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _c_quote(void) 
{ 
  register char *cur ;
  register int *patch ;

  {
  {
#line 126
  *((int *)_dp) = (int )(& _branch);
#line 126
  _dp += sizeof(int );
#line 127
  patch = (int *)_dp;
#line 128
  *((int *)_dp) = 0;
#line 128
  _dp += sizeof(int );
#line 129
  cur = _dp;
#line 130
  sp --;
#line 130
  *sp = '\"';
#line 131
  _word();
#line 132
  sp ++;
#line 133
  _dp = (char *)(((unsigned long )((int )((_dp + (int )*_dp) + sizeof(char )) - 1) | (sizeof(int ) - 1UL)) + 1UL);
#line 134
  *patch = (int )(((int *)_dp - patch) - 1L);
#line 135
  *((int *)_dp) = (int )(& _do_literal);
#line 135
  _dp += sizeof(int );
#line 136
  *((int *)_dp) = (int )cur;
#line 136
  _dp += sizeof(int );
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _compile_comma(void) 
{ 
  int *tmp ;

  {
  {
#line 140
  tmp = sp;
#line 140
  sp ++;
#line 140
  compile_word((struct word_def *)*tmp);
  }
#line 141
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _erase(void) 
{ 
  register unsigned int u ;
  int *tmp ;
  register char *addr ;
  int *tmp___0 ;

  {
#line 144
  tmp = sp;
#line 144
  sp ++;
#line 144
  u = (unsigned int )*tmp;
#line 145
  tmp___0 = sp;
#line 145
  sp ++;
#line 145
  addr = (char *)*tmp___0;
#line 146
  if (u) {
    {
#line 146
    memset((void *)addr, 0, (size_t )u);
    }
  }
#line 147
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _false(void) 
{ 


  {
#line 150
  sp --;
#line 150
  *sp = 0;
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _hex(void) 
{ 


  {
#line 154
  _base = 16;
#line 155
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _marker(void) 
{ 
  struct voc_marker vm ;

  {
  {
#line 159
  save_vocabulary(& vm);
#line 160
  create_definition(8);
#line 161
  memcpy((void */* __restrict  */)_dp, (void const   */* __restrict  */)(& vm), sizeof(struct voc_marker ));
#line 162
  _dp += ((unsigned long )((int )sizeof(struct voc_marker ) - 1) | (sizeof(int ) - 1UL)) + 1UL;
#line 163
  mark_word(_last);
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _nip(void) 
{ 


  {
#line 167
  *(sp + 1) = *(sp + 0);
#line 168
  sp ++;
#line 169
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _parse(void) 
{ 
  register char delim ;
  register char *orig ;
  register int i ;

  {
#line 172
  delim = (char )*sp;
#line 173
  orig = _input_buffer + _to_in;
#line 174
  i = 0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (_to_in < _in_input_buffer) {
#line 175
      if (! ((int )*(_input_buffer + _to_in) != (int )delim)) {
#line 175
        goto while_break;
      }
    } else {
#line 175
      goto while_break;
    }
#line 176
    _to_in ++;
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  *sp = (int )orig;
#line 180
  sp --;
#line 180
  *sp = i;
#line 182
  if (_to_in < _in_input_buffer) {
#line 182
    _to_in ++;
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _pick(void) 
{ 


  {
#line 186
  *(sp + 0) = *(sp + (*(sp + 0) + 1));
#line 187
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _refill(void) 
{ 
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 190
  if (_b_l_k != 0U) {
    {
#line 191
    tmp = _b_l_k;
#line 191
    _b_l_k ++;
#line 191
    current_block = tmp;
#line 192
    _to_in = 0;
#line 193
    sp --;
#line 193
    *sp = (int )_b_l_k;
#line 194
    _block();
#line 195
    tmp___0 = sp;
#line 195
    sp ++;
#line 195
    _input_buffer = (char *)*tmp___0;
#line 196
    _in_input_buffer = 1024;
    }
#line 197
    if (_b_l_k) {
#line 197
      if ((unsigned long )_input_buffer != (unsigned long )((void *)0)) {
#line 197
        tmp___1 = 1;
      } else {
#line 197
        tmp___1 = 0;
      }
    } else {
#line 197
      tmp___1 = 0;
    }
#line 197
    *sp = - tmp___1;
  } else
#line 198
  if (_source_id == 0) {
    {
#line 199
    sp --;
#line 199
    *sp = (int )_tib;
#line 200
    sp --;
#line 200
    *sp = tib_size;
#line 201
    _accept();
#line 202
    _input_buffer = _tib;
#line 203
    _in_input_buffer = *sp;
#line 204
    _to_in = 0;
#line 205
    *sp = -1;
    }
  } else
#line 206
  if (_source_id == -1) {
#line 207
    sp --;
#line 207
    *sp = 0;
  } else
#line 208
  if (_env_file) {
    {
#line 209
    tmp___3 = fgets((char */* __restrict  */)_input_buffer, 128, (FILE */* __restrict  */)((FILE *)_source_id));
    }
#line 209
    if (tmp___3) {
      {
#line 210
      tmp___2 = strlen((char const   *)_input_buffer);
#line 210
      _in_input_buffer = (int )tmp___2;
      }
#line 211
      if (_in_input_buffer) {
#line 211
        if ((int )*(_input_buffer + (_in_input_buffer - 1)) == 10) {
#line 212
          _in_input_buffer --;
        }
      }
#line 213
      _to_in = 0;
#line 214
      sp --;
#line 214
      *sp = -1;
    } else {
#line 215
      sp --;
#line 215
      *sp = 0;
    }
  } else {
#line 216
    sp --;
#line 216
    *sp = 0;
  }
#line 217
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _restore_input(void) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 220
  sp ++;
#line 221
  tmp = sp;
#line 221
  sp ++;
#line 221
  _b_l_k = (unsigned int )*tmp;
#line 222
  tmp___0 = sp;
#line 222
  sp ++;
#line 222
  _to_in = *tmp___0;
#line 223
  tmp___1 = sp;
#line 223
  sp ++;
#line 223
  _in_input_buffer = *tmp___1;
#line 224
  tmp___2 = sp;
#line 224
  sp ++;
#line 224
  _input_buffer = (char *)*tmp___2;
#line 225
  tmp___3 = sp;
#line 225
  sp ++;
#line 225
  _source_id = *tmp___3;
#line 230
  sp --;
#line 230
  *sp = -1;
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _roll(void) 
{ 
  register int u ;
  int *tmp ;
  register int xu ;
  register int i ;

  {
#line 234
  tmp = sp;
#line 234
  sp ++;
#line 234
  u = *tmp;
#line 235
  xu = *(sp + u);
#line 237
  i = u;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (i > 0)) {
#line 237
      goto while_break;
    }
#line 237
    *(sp + i) = *(sp + (i - 1));
#line 237
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  *(sp + 0) = xu;
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _save_input(void) 
{ 


  {
#line 246
  sp --;
#line 246
  *sp = _source_id;
#line 247
  sp --;
#line 247
  *sp = (int )_input_buffer;
#line 248
  sp --;
#line 248
  *sp = _in_input_buffer;
#line 249
  sp --;
#line 249
  *sp = _to_in;
#line 250
  sp --;
#line 250
  *sp = (int )_b_l_k;
#line 251
  sp --;
#line 251
  *sp = 5;
#line 252
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _true(void) 
{ 


  {
#line 255
  sp --;
#line 255
  *sp = -1;
#line 256
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _tuck(void) 
{ 


  {
#line 259
  sp --;
#line 260
  *(sp + 0) = *(sp + 1);
#line 261
  *(sp + 1) = *(sp + 2);
#line 262
  *(sp + 2) = *(sp + 0);
#line 263
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _u_dot_r(void) 
{ 
  register int r ;
  int *tmp ;

  {
  {
#line 266
  tmp = sp;
#line 266
  sp ++;
#line 266
  r = *tmp;
#line 267
  sp --;
#line 267
  *sp = 0;
#line 268
  _less_number_sign();
#line 269
  _number_sign_s();
#line 270
  _number_sign_greater();
  }
#line 271
  if (*(sp + 0) < r) {
    {
#line 272
    sp --;
#line 273
    *(sp + 0) = r - *(sp + 1);
#line 274
    _spaces();
    }
  }
  {
#line 276
  _type();
#line 277
  putchar(' ');
  }
#line 278
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _u_greater_than(void) 
{ 


  {
#line 281
  *(sp + 1) = - ((unsigned int )*(sp + 1) > (unsigned int )*(sp + 0));
#line 282
  sp ++;
#line 283
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _unused(void) 
{ 


  {
#line 286
  sp --;
#line 286
  *sp = (int )((unsigned long )((long )dspace_size - (_dp - dp0)) * sizeof(int ));
#line 287
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _within(void) 
{ 
  register int n3 ;
  int *tmp ;
  register int n2 ;
  int *tmp___0 ;
  register int n1 ;
  int tmp___1 ;

  {
#line 290
  tmp = sp;
#line 290
  sp ++;
#line 290
  n3 = *tmp;
#line 291
  tmp___0 = sp;
#line 291
  sp ++;
#line 291
  n2 = *tmp___0;
#line 292
  n1 = *sp;
#line 293
  if (n2 < n3) {
#line 293
    if (n2 <= n1) {
#line 293
      if (n1 < n3) {
#line 293
        tmp___1 = 1;
      } else {
#line 293
        goto _L;
      }
    } else {
#line 293
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 293
  if (n2 > n3) {
#line 293
    if (n2 <= n1) {
#line 293
      tmp___1 = 1;
    } else
#line 293
    if (n1 < n3) {
#line 293
      tmp___1 = 1;
    } else {
#line 293
      tmp___1 = 0;
    }
  } else {
#line 293
    tmp___1 = 0;
  }
#line 293
  *(sp + 0) = - tmp___1;
#line 295
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _backslash(void) 
{ 


  {
#line 298
  _to_in = _in_input_buffer;
#line 299
  return;
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _bracket_compile(void) 
{ 
  struct word_def *tmp ;

  {
  {
#line 302
  sp --;
#line 302
  *sp = ' ';
#line 303
  _word();
#line 304
  sp ++;
#line 305
  tmp = search_word(_dp + 1, (int )*_dp);
#line 305
  compile_word(tmp);
  }
#line 306
  return;
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _value(void) 
{ 


  {
  {
#line 309
  create_definition(12);
#line 310
  *((int *)_dp) = *(sp + 0);
#line 310
  _dp += sizeof(int );
#line 311
  sp ++;
#line 312
  mark_word(_last);
  }
#line 313
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _paren_write_value_paren(void) 
{ 
  register int *p ;
  pfp *tmp ;
  int *tmp___0 ;

  {
#line 316
  tmp = ip;
#line 316
  ip ++;
#line 316
  p = (int *)*tmp;
#line 317
  tmp___0 = sp;
#line 317
  sp ++;
#line 317
  *p = *tmp___0;
#line 318
  return;
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _to(void) 
{ 
  register struct word_def *xt ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 321
  _b_l();
#line 322
  _word();
#line 323
  _find();
#line 324
  tmp___1 = sp;
#line 324
  sp ++;
  }
#line 324
  if (*tmp___1) {
#line 325
    tmp = sp;
#line 325
    sp ++;
#line 325
    xt = (struct word_def *)*tmp;
#line 326
    if ((xt->class & 15) == 12) {
#line 327
      if (_state == 0) {
#line 327
        tmp___0 = sp;
#line 327
        sp ++;
#line 327
        xt->func[0] = (void (*)(void))*tmp___0;
      } else {
#line 329
        *((int *)_dp) = (int )(& _paren_write_value_paren);
#line 329
        _dp += sizeof(int );
#line 330
        *((int *)_dp) = (int )(& xt->func[0]);
#line 330
        _dp += sizeof(int );
      }
    }
  } else {
#line 338
    sp ++;
  }
#line 339
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void _paren_marker_paren(void) 
{ 
  pfp *tmp ;

  {
  {
#line 342
  tmp = ip;
#line 342
  ip ++;
#line 342
  exec_marker((struct voc_marker *)tmp);
  }
#line 343
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/coree.c"
void exec_marker(struct voc_marker *vm ) 
{ 


  {
  {
#line 350
  load_vocabulary(vm);
  }
#line 351
  return;
}
}
#line 715 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 162 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
void _interpret(void) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.h"
FILE *block_file  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.h"
struct _block_data *block_data  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.h"
struct _block_buffer *block_buffer  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.h"
unsigned int current_block  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.h"
unsigned int _b_l_k  ;
#line 69
void _buffer(void) ;
#line 70
void _flush(void) ;
#line 72
void _save_buffers(void) ;
#line 73
void _update(void) ;
#line 81
int search_block(unsigned int block_no ) ;
#line 82
int allocate_block(unsigned int block_no , int load ) ;
#line 83
void load_block(unsigned int block_no , int b ) ;
#line 84
void save_block(int b ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
static int block_clock  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
void _block(void) 
{ 
  register unsigned int u ;
  register int b ;
  int tmp ;

  {
  {
#line 49
  u = (unsigned int )*sp;
#line 50
  tmp = search_block(u);
#line 50
  b = tmp;
  }
#line 51
  if (b < 0) {
    {
#line 51
    b = allocate_block(u, 1);
    }
  }
#line 52
  current_block = (unsigned int )b;
#line 53
  *(sp + 0) = (int )(& (block_buffer + b)->buffer);
#line 54
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
void _buffer(void) 
{ 
  register unsigned int u ;
  register int b ;
  int tmp ;

  {
  {
#line 57
  u = (unsigned int )*sp;
#line 58
  tmp = search_block(u);
#line 58
  b = tmp;
  }
#line 59
  if (b < 0) {
    {
#line 59
    b = allocate_block(u, 0);
    }
  }
#line 60
  current_block = (unsigned int )b;
#line 61
  *(sp + 0) = (int )(& (block_buffer + b)->buffer);
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
void _flush(void) 
{ 
  register int i ;

  {
  {
#line 66
  _save_buffers();
#line 67
  i = 0;
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < 4)) {
#line 67
      goto while_break;
    }
#line 67
    (block_data + i)->block_no = 0U;
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
void _load(void) 
{ 
  register unsigned int block_no ;
  int *tmp ;

  {
  {
#line 71
  block_no = (unsigned int )*sp;
#line 72
  save_input_specification();
#line 73
  _block();
#line 74
  tmp = sp;
#line 74
  sp ++;
#line 74
  _input_buffer = (char *)*tmp;
#line 75
  _in_input_buffer = 1024;
#line 76
  _to_in = 0;
#line 77
  _b_l_k = block_no;
#line 78
  _interpret();
#line 79
  restore_input_specification();
  }
#line 80
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
void _save_buffers(void) 
{ 
  register int i ;

  {
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < 4)) {
#line 84
      goto while_break;
    }
#line 84
    if ((block_data + i)->dirty) {
      {
#line 84
      save_block(i);
      }
    }
#line 84
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
void _update(void) 
{ 


  {
#line 88
  (block_data + current_block)->dirty = 1;
#line 89
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
int search_block(unsigned int block_no ) 
{ 
  register int i ;
  int tmp ;

  {
#line 97
  i = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (i < 4) {
#line 97
      if (! ((block_data + i)->block_no != block_no)) {
#line 97
        goto while_break;
      }
    } else {
#line 97
      goto while_break;
    }
#line 97
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (i < 4) {
#line 98
    tmp = i;
  } else {
#line 98
    tmp = -1;
  }
#line 98
  return (tmp);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
int allocate_block(unsigned int block_no , int load ) 
{ 
  register int b ;
  int tmp ;

  {
  {
#line 103
  tmp = search_block(0U);
#line 103
  b = tmp;
  }
#line 104
  if (b < 0) {
#line 105
    if ((block_data + block_clock)->dirty) {
      {
#line 105
      save_block(block_clock);
      }
    }
#line 106
    b = block_clock;
#line 107
    block_clock = (block_clock + 1) % 4;
  }
#line 109
  if (load) {
    {
#line 109
    load_block(block_no, b);
    }
  }
#line 110
  return (b);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
void load_block(unsigned int block_no , int b ) 
{ 


  {
  {
#line 114
  (block_data + b)->block_no = block_no;
#line 115
  (block_data + b)->dirty = 0;
#line 116
  fseek(block_file, (long )(block_no - 1U) * 1024L, 0);
#line 117
  fread((void */* __restrict  */)(& (block_buffer + b)->buffer), (size_t )1024, (size_t )1,
        (FILE */* __restrict  */)block_file);
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
void save_block(int b ) 
{ 


  {
  {
#line 121
  fseek(block_file, (long )((block_data + b)->block_no - 1U) * 1024L, 0);
#line 122
  fwrite((void const   */* __restrict  */)(& (block_buffer + b)->buffer), (size_t )1024,
         (size_t )1, (FILE */* __restrict  */)block_file);
#line 123
  (block_data + b)->dirty = 0;
  }
#line 124
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
int open_block_file(char *name ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 127
  block_file = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r+b");
  }
#line 128
  if (! block_file) {
    {
#line 128
    block_file = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r+b");
    }
  }
#line 129
  if (block_file) {
    {
#line 130
    tmp = malloc(4UL * sizeof(struct _block_data ));
#line 130
    block_data = (struct _block_data *)tmp;
#line 131
    tmp___0 = malloc(4UL * sizeof(struct _block_buffer ));
#line 131
    block_buffer = (struct _block_buffer *)tmp___0;
    }
#line 132
    if (block_data) {
#line 132
      if (block_buffer) {
#line 134
        i = 0;
        {
#line 134
        while (1) {
          while_continue: /* CIL Label */ ;
#line 134
          if (! (i < 4)) {
#line 134
            goto while_break;
          }
#line 134
          (block_data + i)->block_no = 0U;
#line 134
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 135
        block_file = (FILE *)((void *)0);
      }
    } else {
#line 135
      block_file = (FILE *)((void *)0);
    }
  }
#line 137
  if (block_file) {
#line 137
    tmp___1 = 0;
  } else {
#line 137
    tmp___1 = -1;
  }
#line 137
  return (tmp___1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/block.c"
void close_block_file(void) 
{ 


  {
#line 141
  if (block_file) {
    {
#line 142
    _save_buffers();
#line 143
    fclose(block_file);
    }
  }
#line 145
  return;
}
}
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.h"
void _bin(void) ;
#line 49
void _close_file(void) ;
#line 50
void _create_file(void) ;
#line 51
void _delete_file(void) ;
#line 52
void _file_position(void) ;
#line 53
void _file_size(void) ;
#line 54
void _include_file(void) ;
#line 55
void _included(void) ;
#line 56
void _open_file(void) ;
#line 57
void _r_o(void) ;
#line 58
void _r_w(void) ;
#line 59
void _read_file(void) ;
#line 60
void _read_line(void) ;
#line 61
void _reposition_file(void) ;
#line 62
void _resize_file(void) ;
#line 63
void _w_o(void) ;
#line 64
void _write_file(void) ;
#line 65
void _write_line(void) ;
#line 73
int truncate_file(FILE *f , unsigned long long cur , unsigned long long ud ) ;
#line 74
int expand_file(FILE *f , unsigned long long cur , unsigned long long ud ) ;
#line 75
char *get_file_name(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
static char *file_mode[6]  = {      (char *)"r",      (char *)"rb",      (char *)"w",      (char *)"wb", 
        (char *)"w+",      (char *)"w+b"};
#line 43 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
char file_name[128]  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _bin(void) 
{ 


  {
#line 50
  *(sp + 0) |= 1;
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _close_file(void) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 54
  tmp___0 = fclose((FILE *)*(sp + 0));
  }
#line 54
  if (tmp___0) {
    {
#line 54
    tmp = __errno_location();
#line 54
    *(sp + 0) = *tmp;
    }
  } else {
#line 55
    *(sp + 0) = 0;
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _create_file(void) 
{ 
  register int fam ;
  int *tmp ;
  register FILE *f ;
  int *tmp___0 ;

  {
  {
#line 59
  tmp = sp;
#line 59
  sp ++;
#line 59
  fam = *tmp;
#line 61
  get_file_name();
#line 63
  f = fopen((char const   */* __restrict  */)(file_name), (char const   */* __restrict  */)file_mode[fam]);
#line 64
  sp --;
#line 64
  *sp = (int )f;
#line 65
  sp --;
  }
#line 65
  if ((int )f) {
#line 65
    *sp = 0;
  } else {
    {
#line 65
    tmp___0 = __errno_location();
#line 65
    *sp = *tmp___0;
    }
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _delete_file(void) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 69
  get_file_name();
#line 70
  tmp___0 = remove((char const   *)(file_name));
  }
#line 70
  if (tmp___0) {
    {
#line 70
    sp --;
#line 70
    tmp = __errno_location();
#line 70
    *sp = *tmp;
    }
  } else {
#line 71
    sp --;
#line 71
    *sp = 0;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _file_position(void) 
{ 
  register FILE *f ;
  register long long ud ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 75
  f = (FILE *)*(sp + 0);
#line 76
  tmp = ftell(f);
#line 76
  ud = (long long )tmp;
#line 77
  sp -= 2;
  }
#line 78
  if (ud == -1LL) {
    {
#line 78
    tmp___0 = __errno_location();
#line 78
    *(sp + 0) = *tmp___0;
    }
  } else {
    {
#line 80
    put_dcell(sp + 1, ud);
#line 81
    *(sp + 0) = 0;
    }
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _file_size(void) 
{ 
  register FILE *f ;
  register long long o_pos ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 86
  f = (FILE *)*(sp + 0);
#line 87
  tmp = ftell(f);
#line 87
  o_pos = (long long )tmp;
  }
#line 88
  if (o_pos != -1LL) {
    {
#line 89
    fseek(f, 0L, 2);
#line 90
    _file_position();
#line 91
    fseek(f, (long )o_pos, 0);
    }
  } else {
    {
#line 93
    sp -= 2;
#line 94
    tmp___0 = __errno_location();
#line 94
    *(sp + 0) = *tmp___0;
    }
  }
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _include_file(void) 
{ 
  register FILE *f ;
  int *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 99
  tmp = sp;
#line 99
  sp ++;
#line 99
  f = (FILE *)*tmp;
#line 100
  save_input_specification();
#line 101
  _source_id = (int )f;
#line 102
  tmp___0 = malloc((size_t )128);
#line 102
  _input_buffer = (char *)tmp___0;
#line 103
  _in_input_buffer = 0;
#line 104
  _b_l_k = 0U;
  }
#line 105
  if (_input_buffer) {
    {
#line 106
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 106
      tmp___3 = feof(f);
      }
#line 106
      if (tmp___3) {
#line 106
        goto while_break;
      } else {
        {
#line 106
        tmp___4 = ferror(f);
        }
#line 106
        if (tmp___4) {
#line 106
          goto while_break;
        } else
#line 106
        if (! (! _error)) {
#line 106
          goto while_break;
        }
      }
      {
#line 107
      tmp___2 = fgets((char */* __restrict  */)_input_buffer, 127, (FILE */* __restrict  */)f);
      }
#line 107
      if (tmp___2) {
        {
#line 108
        _to_in = 0;
#line 109
        tmp___1 = strlen((char const   *)_input_buffer);
#line 109
        _in_input_buffer = (int )tmp___1;
        }
#line 110
        if (_in_input_buffer) {
#line 110
          if ((int )*(_input_buffer + (_in_input_buffer - 1)) == 10) {
#line 111
            _in_input_buffer --;
          }
        }
        {
#line 112
        _interpret();
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 115
    fclose(f);
#line 116
    free((void *)_input_buffer);
    }
  }
  {
#line 118
  restore_input_specification();
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _included(void) 
{ 
  int *tmp ;

  {
  {
#line 122
  _r_o();
#line 123
  _open_file();
#line 124
  tmp = sp;
#line 124
  sp ++;
#line 124
  _error = *tmp;
  }
#line 124
  if (_error == 0) {
    {
#line 124
    _include_file();
    }
  } else {
#line 125
    sp ++;
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _open_file(void) 
{ 
  register int fam ;
  int *tmp ;
  register FILE *f ;
  int tmp___0 ;

  {
  {
#line 129
  tmp = sp;
#line 129
  sp ++;
#line 129
  fam = *tmp;
#line 131
  get_file_name();
#line 132
  f = fopen((char const   */* __restrict  */)(file_name), (char const   */* __restrict  */)file_mode[fam]);
#line 133
  sp --;
#line 133
  *sp = (int )f;
#line 134
  sp --;
  }
#line 134
  if (f) {
#line 134
    tmp___0 = 0;
  } else {
#line 134
    tmp___0 = -18;
  }
#line 134
  *sp = tmp___0;
#line 135
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _r_o(void) 
{ 


  {
#line 138
  sp --;
#line 138
  *sp = 0;
#line 139
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _r_w(void) 
{ 


  {
#line 142
  sp --;
#line 142
  *sp = 4;
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _read_file(void) 
{ 
  register FILE *f ;
  int *tmp ;
  register unsigned int u1 ;
  int *tmp___0 ;
  register char *buffer ;
  int *tmp___1 ;
  size_t rd ;
  size_t tmp___2 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 146
  tmp = sp;
#line 146
  sp ++;
#line 146
  f = (FILE *)*tmp;
#line 147
  tmp___0 = sp;
#line 147
  sp ++;
#line 147
  u1 = (unsigned int )*tmp___0;
#line 148
  tmp___1 = sp;
#line 148
  sp ++;
#line 148
  buffer = (char *)*tmp___1;
#line 149
  tmp___2 = fread((void */* __restrict  */)buffer, (size_t )1, (size_t )u1, (FILE */* __restrict  */)f);
#line 149
  rd = tmp___2;
#line 150
  sp --;
#line 150
  *sp = (int )rd;
#line 151
  sp --;
#line 151
  tmp___5 = ferror(f);
  }
#line 151
  if (tmp___5) {
    {
#line 151
    tmp___4 = __errno_location();
#line 151
    *sp = *tmp___4;
    }
  } else {
#line 151
    *sp = 0;
  }
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _read_line(void) 
{ 
  register FILE *f ;
  int *tmp ;
  register unsigned int u1 ;
  int *tmp___0 ;
  register char *buffer ;
  int *tmp___1 ;
  int len ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 155
  tmp = sp;
#line 155
  sp ++;
#line 155
  f = (FILE *)*tmp;
#line 156
  tmp___0 = sp;
#line 156
  sp ++;
#line 156
  u1 = (unsigned int )*tmp___0;
#line 157
  tmp___1 = sp;
#line 157
  sp ++;
#line 157
  buffer = (char *)*tmp___1;
#line 158
  tmp___4 = fgets((char */* __restrict  */)buffer, (int )(u1 + 1U), (FILE */* __restrict  */)f);
  }
#line 158
  if (tmp___4) {
    {
#line 159
    tmp___2 = strlen((char const   *)buffer);
#line 159
    len = (int )tmp___2;
    }
#line 160
    if (len) {
#line 160
      if ((int )*(buffer + (len - 1)) == 10) {
#line 160
        len --;
      }
    }
#line 161
    sp --;
#line 161
    *sp = 0;
#line 162
    sp --;
#line 162
    *sp = -1;
#line 163
    sp --;
#line 163
    *sp = len;
  } else {
    {
#line 165
    sp --;
#line 165
    tmp___3 = __errno_location();
#line 165
    *sp = *tmp___3;
#line 166
    sp --;
#line 166
    *sp = 0;
#line 167
    sp --;
#line 167
    *sp = 0;
    }
  }
#line 169
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _reposition_file(void) 
{ 
  register FILE *f ;
  int *tmp ;
  register unsigned long long ud ;
  long long tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 172
  tmp = sp;
#line 172
  sp ++;
#line 172
  f = (FILE *)*tmp;
#line 173
  tmp___0 = get_dcell(sp);
#line 173
  ud = (unsigned long long )tmp___0;
#line 174
  sp ++;
#line 175
  tmp___2 = fseek(f, (long )ud, 0);
  }
#line 175
  if (tmp___2) {
    {
#line 175
    tmp___1 = __errno_location();
#line 175
    *(sp + 0) = *tmp___1;
    }
  } else {
#line 176
    *(sp + 0) = 0;
  }
#line 177
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _resize_file(void) 
{ 
  register FILE *f ;
  register unsigned long long ud ;
  long long tmp ;
  register unsigned long long ud1 ;
  register int ior ;
  int *tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 180
  f = (FILE *)*(sp + 0);
#line 181
  tmp = get_dcell(sp + 1);
#line 181
  ud = (unsigned long long )tmp;
#line 183
  _file_size();
#line 184
  tmp___0 = sp;
#line 184
  sp ++;
#line 184
  ior = *tmp___0;
  }
#line 185
  if (! ior) {
    {
#line 186
    tmp___1 = get_dcell(sp);
#line 186
    ud1 = (unsigned long long )tmp___1;
    }
#line 187
    if (ud < ud1) {
      {
#line 187
      ior = truncate_file(f, ud1, ud);
      }
    } else
#line 188
    if (ud > ud1) {
      {
#line 188
      ior = expand_file(f, ud1, ud);
      }
    }
  }
#line 190
  sp += 3;
#line 191
  *(sp + 0) = ior;
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _w_o(void) 
{ 


  {
#line 195
  sp --;
#line 195
  *sp = 2;
#line 196
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _write_file(void) 
{ 
  register FILE *f ;
  int *tmp ;
  register unsigned int u ;
  int *tmp___0 ;
  register char *buffer ;
  int *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 199
  tmp = sp;
#line 199
  sp ++;
#line 199
  f = (FILE *)*tmp;
#line 200
  tmp___0 = sp;
#line 200
  sp ++;
#line 200
  u = (unsigned int )*tmp___0;
#line 201
  buffer = (char *)*sp;
#line 202
  tmp___2 = fwrite((void const   */* __restrict  */)buffer, (size_t )1, (size_t )u,
                   (FILE */* __restrict  */)f);
  }
#line 202
  if (tmp___2 < (size_t )u) {
    {
#line 202
    tmp___1 = __errno_location();
#line 202
    *(sp + 0) = *tmp___1;
    }
  } else {
#line 203
    *(sp + 0) = 0;
  }
#line 204
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void _write_line(void) 
{ 
  register FILE *f ;
  int *tmp ;
  register unsigned int u ;
  int *tmp___0 ;
  register char *buffer ;
  char *tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 207
  tmp = sp;
#line 207
  sp ++;
#line 207
  f = (FILE *)*tmp;
#line 208
  tmp___0 = sp;
#line 208
  sp ++;
#line 208
  u = (unsigned int )*tmp___0;
#line 209
  buffer = (char *)*sp;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    tmp___3 = u;
#line 210
    u --;
#line 210
    if (! tmp___3) {
#line 210
      goto while_break;
    }
    {
#line 210
    tmp___1 = buffer;
#line 210
    buffer ++;
#line 210
    tmp___2 = fputc((int )*tmp___1, f);
    }
#line 210
    if (tmp___2 == -1) {
#line 210
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  tmp___4 = ferror(f);
  }
#line 211
  if (! tmp___4) {
    {
#line 211
    fputc('\n', f);
    }
  }
  {
#line 212
  tmp___6 = ferror(f);
  }
#line 212
  if (tmp___6) {
    {
#line 212
    tmp___5 = __errno_location();
#line 212
    *(sp + 0) = *tmp___5;
    }
  } else {
#line 213
    *(sp + 0) = 0;
  }
#line 214
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
int truncate_file(FILE *f , unsigned long long cur , unsigned long long ud ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 221
  tmp___0 = fseek(f, (long )ud, 0);
  }
#line 221
  if (tmp___0) {
    {
#line 221
    tmp = __errno_location();
    }
#line 221
    return (*tmp);
  } else {
#line 222
    return (0);
  }
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
int expand_file(FILE *f , unsigned long long cur , unsigned long long ud ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 226
  fseek(f, 0L, 2);
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (cur < ud) {
      {
#line 227
      tmp = ferror(f);
      }
#line 227
      if (tmp) {
#line 227
        goto while_break;
      }
    } else {
#line 227
      goto while_break;
    }
    {
#line 228
    fputc(' ', f);
#line 229
    cur ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 231
  tmp___1 = ferror(f);
  }
#line 231
  if (tmp___1) {
    {
#line 231
    tmp___0 = __errno_location();
    }
#line 231
    return (*tmp___0);
  } else {
#line 232
    return (0);
  }
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
char *get_file_name(void) 
{ 
  register unsigned int u ;
  int *tmp ;
  register char *buffer ;
  int *tmp___0 ;

  {
  {
#line 236
  tmp = sp;
#line 236
  sp ++;
#line 236
  u = (unsigned int )*tmp;
#line 237
  tmp___0 = sp;
#line 237
  sp ++;
#line 237
  buffer = (char *)*tmp___0;
#line 238
  memcpy((void */* __restrict  */)(file_name), (void const   */* __restrict  */)buffer,
         (size_t )u);
#line 239
  file_name[u] = (char )'\000';
  }
#line 240
  return (file_name);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/file.c"
void load_file(char *name ) 
{ 
  size_t tmp ;

  {
  {
#line 244
  sp --;
#line 244
  *sp = (int )name;
#line 245
  sp --;
#line 245
  tmp = strlen((char const   *)name);
#line 245
  *sp = (int )tmp;
#line 246
  _included();
  }
#line 247
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
struct vocabulary *list[8]  ;
#line 171 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
int top  ;
#line 172 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
struct vocabulary *voc  ;
#line 173 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
struct vocabulary *forth_wid  ;
#line 250 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
struct word_def *search_wordlist(char *name , int len , struct vocabulary *wid ) ;
#line 254
void set_find_stack(char *addr , struct word_def *xt ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.h"
void _definitions(void) ;
#line 44
void _forth_wordlist(void) ;
#line 45
void _get_current(void) ;
#line 46
void _get_order(void) ;
#line 47
void _search_wordlist(void) ;
#line 48
void _set_current(void) ;
#line 49
void _set_order(void) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.c"
void _definitions(void) 
{ 


  {
#line 39
  voc = list[top];
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.c"
void _forth_wordlist(void) 
{ 


  {
#line 43
  sp --;
#line 43
  *sp = (int )forth_wid;
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.c"
void _get_current(void) 
{ 


  {
#line 47
  sp --;
#line 47
  *sp = (int )voc;
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.c"
void _get_order(void) 
{ 
  register int i ;

  {
#line 52
  i = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (i <= top)) {
#line 52
      goto while_break;
    }
#line 52
    sp --;
#line 52
    *sp = (int )list[i];
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  sp --;
#line 53
  *sp = top;
#line 54
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.c"
void _search_wordlist(void) 
{ 
  register struct vocabulary *wid ;
  int *tmp ;
  register int len ;
  int *tmp___0 ;
  register char *addr ;
  register struct word_def *xt ;
  struct word_def *tmp___1 ;

  {
  {
#line 57
  tmp = sp;
#line 57
  sp ++;
#line 57
  wid = (struct vocabulary *)*tmp;
#line 58
  tmp___0 = sp;
#line 58
  sp ++;
#line 58
  len = *tmp___0;
#line 59
  addr = (char *)*sp;
#line 60
  tmp___1 = search_wordlist(addr, len, wid);
#line 60
  xt = tmp___1;
#line 61
  set_find_stack(addr, xt);
  }
#line 62
  if (! *sp) {
#line 62
    sp ++;
#line 62
    *sp = 0;
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.c"
void _set_current(void) 
{ 
  int *tmp ;

  {
#line 66
  tmp = sp;
#line 66
  sp ++;
#line 66
  voc = (struct vocabulary *)*tmp;
#line 67
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.c"
void _set_order(void) 
{ 
  register int n ;
  int *tmp ;
  register int i ;
  int *tmp___0 ;

  {
#line 70
  tmp = sp;
#line 70
  sp ++;
#line 70
  n = *tmp;
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (i < n)) {
#line 72
      goto while_break;
    }
#line 73
    if (i < 8) {
#line 73
      tmp___0 = sp;
#line 73
      sp ++;
#line 73
      list[i] = (struct vocabulary *)*tmp___0;
    } else {
#line 74
      sp ++;
    }
#line 72
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  top = n - 1;
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.c"
void _wordlist(void) 
{ 
  register struct vocabulary *v ;
  register int i ;

  {
  {
#line 81
  _align();
#line 82
  v = (struct vocabulary *)_dp;
#line 83
  _dp += sizeof(struct vocabulary );
#line 84
  i = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < 8)) {
#line 84
      goto while_break;
    }
#line 84
    v->voc[i] = (struct word_def *)((void *)0);
#line 84
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  sp --;
#line 85
  *sp = (int )v;
#line 86
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.c"
void save_vocabulary(struct voc_marker *vm ) 
{ 
  register int i ;

  {
#line 95
  i = 0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < 8)) {
#line 95
      goto while_break;
    }
#line 96
    vm->list[i] = list[i];
#line 97
    if (list[i]) {
#line 97
      vm->v_list[i] = *(list[i]);
    }
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  vm->top = top;
#line 100
  vm->voc = voc;
#line 101
  vm->_dp = _dp;
#line 102
  vm->last = _last;
#line 103
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/search.c"
void load_vocabulary(struct voc_marker *vm ) 
{ 
  register int i ;

  {
#line 107
  i = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i < 8)) {
#line 107
      goto while_break;
    }
#line 108
    list[i] = vm->list[i];
#line 109
    if (list[i]) {
#line 109
      *(list[i]) = vm->v_list[i];
    }
#line 107
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  top = vm->top;
#line 112
  voc = vm->voc;
#line 113
  _dp = vm->_dp;
#line 114
  _last = vm->last;
#line 115
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
void _hold(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.h"
void _two_constant(void) ;
#line 43
void _two_literal(void) ;
#line 44
void _two_variable(void) ;
#line 45
void _d_plus(void) ;
#line 46
void _d_minus(void) ;
#line 47
void _d_dot(void) ;
#line 49
void _d_zero_less(void) ;
#line 50
void _d_zero_equals(void) ;
#line 51
void _d_two_star(void) ;
#line 52
void _d_two_slash(void) ;
#line 53
void _d_less_than(void) ;
#line 54
void _d_equals(void) ;
#line 56
void _dabs(void) ;
#line 57
void _dmax(void) ;
#line 58
void _dmin(void) ;
#line 59
void _dnegate(void) ;
#line 60
void _m_star_slash(void) ;
#line 61
void _m_plus(void) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _two_constant(void) 
{ 
  register long long d ;
  long long tmp ;

  {
  {
#line 31
  tmp = get_dcell(sp);
#line 31
  d = tmp;
#line 32
  sp += 2;
#line 33
  create_definition(9);
#line 34
  *((int *)_dp) = (int )d;
#line 34
  _dp += sizeof(int );
#line 35
  *((int *)_dp) = (int )(d >> sizeof(int ) * 8UL);
#line 35
  _dp += sizeof(int );
#line 36
  mark_word(_last);
  }
#line 37
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _two_literal(void) 
{ 


  {
#line 40
  *((int *)_dp) = (int )(& _do_literal);
#line 40
  _dp += sizeof(int );
#line 41
  *((int *)_dp) = *(sp + 1);
#line 41
  _dp += sizeof(int );
#line 42
  *((int *)_dp) = (int )(& _do_literal);
#line 42
  _dp += sizeof(int );
#line 43
  *((int *)_dp) = *(sp + 0);
#line 43
  _dp += sizeof(int );
#line 44
  sp += 2;
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _two_variable(void) 
{ 


  {
  {
#line 48
  create_definition(10);
#line 49
  *((int *)_dp) = 0;
#line 49
  _dp += sizeof(int );
#line 50
  *((int *)_dp) = 0;
#line 50
  _dp += sizeof(int );
#line 51
  mark_word(_last);
  }
#line 52
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _d_plus(void) 
{ 
  register long long d1 ;
  long long tmp ;
  register long long d2 ;
  long long tmp___0 ;

  {
  {
#line 55
  tmp = get_dcell(sp + 2);
#line 55
  d1 = tmp;
#line 56
  tmp___0 = get_dcell(sp);
#line 56
  d2 = tmp___0;
#line 57
  d1 += d2;
#line 58
  sp += 2;
#line 59
  put_dcell(sp, d1);
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _d_minus(void) 
{ 
  register long long d1 ;
  long long tmp ;
  register long long d2 ;
  long long tmp___0 ;

  {
  {
#line 63
  tmp = get_dcell(sp + 2);
#line 63
  d1 = tmp;
#line 64
  tmp___0 = get_dcell(sp);
#line 64
  d2 = tmp___0;
#line 65
  d1 -= d2;
#line 66
  sp += 2;
#line 67
  put_dcell(sp, d1);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _d_dot(void) 
{ 
  register long long u ;
  long long tmp ;
  register int usign ;

  {
  {
#line 71
  tmp = get_dcell(sp);
#line 71
  u = tmp;
#line 72
  usign = u < 0LL;
  }
#line 73
  if (usign) {
#line 73
    u = - u;
  }
  {
#line 74
  put_dcell(sp, u);
#line 75
  _less_number_sign();
#line 76
  _number_sign_s();
  }
#line 77
  if (usign) {
    {
#line 78
    sp --;
#line 78
    *sp = '-';
#line 79
    _hold();
    }
  }
  {
#line 81
  _number_sign_greater();
#line 82
  _type();
#line 83
  putchar(' ');
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _d_dot_r(void) 
{ 
  register int r ;
  int *tmp ;
  register long long u ;
  long long tmp___0 ;
  register int usign ;

  {
  {
#line 87
  tmp = sp;
#line 87
  sp ++;
#line 87
  r = *tmp;
#line 88
  tmp___0 = get_dcell(sp);
#line 88
  u = tmp___0;
#line 89
  usign = u < 0LL;
  }
#line 90
  if (usign) {
#line 90
    if (_base == 10) {
#line 90
      u = - u;
    }
  }
  {
#line 91
  put_dcell(sp, u);
#line 92
  _less_number_sign();
#line 93
  _number_sign_s();
  }
#line 94
  if (usign) {
    {
#line 95
    sp --;
#line 95
    *sp = '-';
#line 96
    _hold();
    }
  }
  {
#line 98
  _number_sign_greater();
  }
#line 99
  if (*(sp + 0) < r) {
    {
#line 100
    sp --;
#line 101
    *(sp + 0) = r - *(sp + 1);
#line 102
    _spaces();
    }
  }
  {
#line 104
  _type();
#line 105
  putchar(' ');
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _d_zero_less(void) 
{ 
  register long long d ;
  long long tmp ;

  {
  {
#line 109
  tmp = get_dcell(sp);
#line 109
  d = tmp;
#line 110
  sp ++;
#line 111
  *(sp + 0) = - (d < 0LL);
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _d_zero_equals(void) 
{ 
  register long long d ;
  long long tmp ;

  {
  {
#line 115
  tmp = get_dcell(sp);
#line 115
  d = tmp;
#line 116
  sp ++;
#line 117
  *(sp + 0) = - (d == 0LL);
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _d_two_star(void) 
{ 
  register long long d ;
  long long tmp ;

  {
  {
#line 121
  tmp = get_dcell(sp);
#line 121
  d = tmp;
#line 122
  d <<= 1;
#line 123
  put_dcell(sp, d);
  }
#line 124
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _d_two_slash(void) 
{ 
  register long long d ;
  long long tmp ;

  {
  {
#line 127
  tmp = get_dcell(sp);
#line 127
  d = tmp;
#line 128
  d >>= 1;
#line 129
  put_dcell(sp, d);
  }
#line 130
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _d_less_than(void) 
{ 
  register long long d1 ;
  long long tmp ;
  register long long d2 ;
  long long tmp___0 ;

  {
  {
#line 133
  tmp = get_dcell(sp + 2);
#line 133
  d1 = tmp;
#line 134
  tmp___0 = get_dcell(sp);
#line 134
  d2 = tmp___0;
#line 135
  sp += 3;
#line 136
  *(sp + 0) = - (d1 < d2);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _d_equals(void) 
{ 
  register long long d1 ;
  long long tmp ;
  register long long d2 ;
  long long tmp___0 ;

  {
  {
#line 140
  tmp = get_dcell(sp + 2);
#line 140
  d1 = tmp;
#line 141
  tmp___0 = get_dcell(sp);
#line 141
  d2 = tmp___0;
#line 142
  sp += 3;
#line 143
  *(sp + 0) = - (d1 == d2);
  }
#line 144
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _dabs(void) 
{ 
  register long long d ;
  long long tmp ;

  {
  {
#line 147
  tmp = get_dcell(sp);
#line 147
  d = tmp;
  }
#line 148
  if (d > 0LL) {
#line 148
    d = d;
  } else {
#line 148
    d = - d;
  }
  {
#line 149
  put_dcell(sp, d);
  }
#line 150
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _dmax(void) 
{ 
  register long long d1 ;
  long long tmp ;
  register long long d2 ;
  long long tmp___0 ;

  {
  {
#line 153
  tmp = get_dcell(sp + 2);
#line 153
  d1 = tmp;
#line 154
  tmp___0 = get_dcell(sp);
#line 154
  d2 = tmp___0;
#line 155
  sp += 2;
  }
#line 156
  if (d2 > d1) {
    {
#line 156
    put_dcell(sp, d2);
    }
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _dmin(void) 
{ 
  register long long d1 ;
  long long tmp ;
  register long long d2 ;
  long long tmp___0 ;

  {
  {
#line 160
  tmp = get_dcell(sp + 2);
#line 160
  d1 = tmp;
#line 161
  tmp___0 = get_dcell(sp);
#line 161
  d2 = tmp___0;
#line 162
  sp += 2;
  }
#line 163
  if (d2 < d1) {
    {
#line 163
    put_dcell(sp, d2);
    }
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _dnegate(void) 
{ 
  register long long d ;
  long long tmp ;

  {
  {
#line 167
  tmp = get_dcell(sp);
#line 167
  d = - tmp;
#line 168
  put_dcell(sp, d);
  }
#line 169
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _m_star_slash(void) 
{ 
  register int n2 ;
  int *tmp ;
  register int n1 ;
  int *tmp___0 ;
  register long long d ;
  long long tmp___1 ;

  {
  {
#line 172
  tmp = sp;
#line 172
  sp ++;
#line 172
  n2 = *tmp;
#line 173
  tmp___0 = sp;
#line 173
  sp ++;
#line 173
  n1 = *tmp___0;
#line 174
  tmp___1 = get_dcell(sp);
#line 174
  d = tmp___1;
#line 175
  d = (d * (long long )n1) / (long long )n2;
#line 176
  put_dcell(sp, d);
  }
#line 177
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/double.c"
void _m_plus(void) 
{ 


  {
  {
#line 180
  _s_to_d();
#line 181
  _d_plus();
  }
#line 182
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/facility.h"
void _at_x_y(void) ;
#line 43
void _key_question(void) ;
#line 44
void _page(void) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/facility.c"
void _at_x_y(void) 
{ 
  register int y ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 30
  tmp = sp;
#line 30
  sp ++;
#line 30
  y = *tmp;
#line 31
  tmp___0 = sp;
#line 31
  sp ++;
#line 31
  d_gotoxy(*tmp___0, y);
  }
#line 32
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/facility.c"
void _key_question(void) 
{ 
  int tmp ;

  {
  {
#line 35
  sp --;
#line 35
  tmp = d_kbhit();
#line 35
  *sp = - tmp;
  }
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/facility.c"
void _page(void) 
{ 


  {
  {
#line 39
  d_clrscr();
  }
#line 40
  return;
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/filee.h"
void _file_status(void) ;
#line 43
void _flush_file(void) ;
#line 44
void _rename_file(void) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/filee.c"
void _file_status(void) 
{ 
  register FILE *f ;
  int *tmp ;

  {
  {
#line 41
  get_file_name();
#line 42
  f = fopen((char const   */* __restrict  */)(file_name), (char const   */* __restrict  */)"rb");
#line 43
  sp --;
#line 43
  *sp = 0;
  }
#line 44
  if (f) {
    {
#line 45
    sp --;
#line 45
    *sp = 0;
#line 46
    fclose(f);
    }
  } else {
    {
#line 47
    sp --;
#line 47
    tmp = __errno_location();
#line 47
    *sp = *tmp;
    }
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/filee.c"
void _flush_file(void) 
{ 
  register FILE *f ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 51
  f = (FILE *)*sp;
#line 52
  tmp___0 = fflush(f);
  }
#line 52
  if (tmp___0) {
    {
#line 52
    tmp = __errno_location();
#line 52
    *(sp + 0) = *tmp;
    }
  } else {
#line 53
    *(sp + 0) = 0;
  }
#line 54
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/filee.c"
void _rename_file(void) 
{ 
  register char *file_name2 ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 58
  get_file_name();
#line 59
  tmp = strlen((char const   *)(file_name));
#line 59
  tmp___0 = malloc(tmp + 1UL);
#line 59
  file_name2 = (char *)tmp___0;
  }
#line 60
  if (file_name2) {
    {
#line 61
    strcpy((char */* __restrict  */)file_name2, (char const   */* __restrict  */)(file_name));
#line 62
    get_file_name();
#line 63
    tmp___2 = rename((char const   *)(file_name), (char const   *)file_name2);
    }
#line 63
    if (tmp___2) {
      {
#line 63
      sp --;
#line 63
      tmp___1 = __errno_location();
#line 63
      *sp = *tmp___1;
      }
    } else {
#line 64
      sp --;
#line 64
      *sp = 0;
    }
    {
#line 65
    free((void *)file_name2);
    }
  } else {
    {
#line 66
    sp --;
#line 66
    tmp___3 = __errno_location();
#line 66
    *sp = *tmp___3;
    }
  }
#line 67
  return;
}
}
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/ycore.c"
void _yforth_version(void) 
{ 


  {
  {
#line 38
  print_version();
  }
#line 39
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/ycore.c"
void _save_image(void) 
{ 
  FILE *f ;
  char *tmp ;
  FILE *tmp___0 ;
  struct image_header hd___0 ;
  struct voc_marker vm ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 45
  tmp = get_file_name();
#line 45
  tmp___0 = fopen((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)"wb");
#line 45
  f = tmp___0;
  }
#line 48
  if (f) {
    {
#line 49
    memset((void *)(& hd___0), 0, sizeof(struct image_header ));
#line 50
    strcpy((char */* __restrict  */)(hd___0.header), (char const   */* __restrict  */)"yForth? Image File\n");
#line 51
    hd___0.ver_hi = 0;
#line 52
    hd___0.ver_lo = 2;
#line 53
    hd___0.base = dp0;
#line 54
    hd___0.dspace_size = dspace_size;
#line 55
    hd___0.pattern = (unsigned int )((((((((((((((((((1L | (1L << 1)) | (1L << 2)) | (1L << 3)) | (1L << 4)) | (1L << 5)) | (1L << 7)) | (1L << 8)) | (1L << 9)) | (1L << 10)) | (1L << 11)) | (1L << 12)) | (1L << 13)) | (1L << 15)) | (1L << 16)) | (1L << 17)) | (1L << 19)) | (1L << 20)) | (1L << 21));
#line 56
    tmp___3 = fwrite((void const   */* __restrict  */)(& hd___0), sizeof(struct image_header ),
                     (size_t )1, (FILE */* __restrict  */)f);
    }
#line 56
    if (tmp___3 < 1UL) {
#line 56
      _error = -14;
    } else {
      {
#line 58
      save_vocabulary(& vm);
#line 59
      tmp___2 = fwrite((void const   */* __restrict  */)(& vm), sizeof(struct voc_marker ),
                       (size_t )1, (FILE */* __restrict  */)f);
      }
#line 59
      if (tmp___2 < 1UL) {
#line 59
        _error = -14;
      } else {
        {
#line 61
        tmp___1 = fwrite((void const   */* __restrict  */)dp0, sizeof(int ), (size_t )dspace_size,
                         (FILE */* __restrict  */)f);
        }
#line 61
        if (tmp___1 < (size_t )dspace_size) {
#line 62
          _error = -14;
        }
      }
    }
    {
#line 65
    fclose(f);
    }
  } else {
#line 66
    _error = -14;
  }
#line 67
  return;
}
}
#line 75
extern char s_tmp_buffer[] ;
#line 72 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/ycore.c"
void _system(void) 
{ 
  register unsigned int len ;
  int *tmp ;
  register char *name ;

  {
  {
#line 73
  tmp = sp;
#line 73
  sp ++;
#line 73
  len = (unsigned int )*tmp;
#line 74
  name = (char *)*sp;
#line 76
  memcpy((void */* __restrict  */)(s_tmp_buffer), (void const   */* __restrict  */)name,
         (size_t )len);
#line 77
  s_tmp_buffer[len] = (char )'\000';
#line 78
  *sp = system((char const   *)(s_tmp_buffer));
  }
#line 79
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _check_system ;
#line 98
void _store(void) ;
#line 99
void _star(void) ;
#line 100
void _star_slash(void) ;
#line 101
void _star_slash_mod(void) ;
#line 102
void _plus(void) ;
#line 103
void _plus_store(void) ;
#line 104
void _minus(void) ;
#line 105
void _slash(void) ;
#line 106
void _slash_mod(void) ;
#line 107
void _zero_less(void) ;
#line 108
void _zero_equals(void) ;
#line 109
void _one_plus(void) ;
#line 110
void _one_minus(void) ;
#line 111
void _two_store(void) ;
#line 112
void _two_star(void) ;
#line 113
void _two_slash(void) ;
#line 114
void _two_fetch(void) ;
#line 115
void _two_drop(void) ;
#line 116
void _two_dupe(void) ;
#line 117
void _two_over(void) ;
#line 118
void _two_swap(void) ;
#line 119
void _less_than(void) ;
#line 120
void _equals(void) ;
#line 121
void _greater_than(void) ;
#line 123
void _question_dupe(void) ;
#line 125
void _abs(void) ;
#line 127
void _aligned(void) ;
#line 128
void _and(void) ;
#line 130
void _c_store(void) ;
#line 131
void _c_fetch(void) ;
#line 132
void _cell_plus(void) ;
#line 133
void _cells(void) ;
#line 134
void _char_plus(void) ;
#line 135
void _chars(void) ;
#line 136
void _depth(void) ;
#line 137
void _drop(void) ;
#line 138
void _dupe(void) ;
#line 139
void _f_m_slash_mod(void) ;
#line 140
void _invert(void) ;
#line 141
void _l_shift(void) ;
#line 142
void _m_star(void) ;
#line 143
void _max(void) ;
#line 144
void _min(void) ;
#line 145
void _mod(void) ;
#line 146
void _negate(void) ;
#line 147
void _or(void) ;
#line 148
void _over(void) ;
#line 149
void _r_from(void) ;
#line 150
void _r_fetch(void) ;
#line 151
void _rote(void) ;
#line 152
void _r_shift(void) ;
#line 154
void _s_m_slash_rem(void) ;
#line 155
void _swap(void) ;
#line 156
void _u_less_than(void) ;
#line 157
void _u_m_star(void) ;
#line 158
void _u_m_slash_mod(void) ;
#line 159
void _xor(void) ;
#line 161
void _to_number(void) ;
#line 164
void _source(void) ;
#line 165
void _paren(void) ;
#line 166
void _evaluate(void) ;
#line 168
void _comma(void) ;
#line 169
void _allot(void) ;
#line 170
void _c_comma(void) ;
#line 171
void _here(void) ;
#line 172
void _exit_imm(void) ;
#line 173
void _colon(void) ;
#line 174
void _variable(void) ;
#line 175
void _constant(void) ;
#line 176
void _create(void) ;
#line 177
void _does(void) ;
#line 178
void _semi_colon(void) ;
#line 179
void _if(void) ;
#line 180
void _then(void) ;
#line 181
void _else(void) ;
#line 182
void _begin(void) ;
#line 183
void _do(void) ;
#line 184
void _loop(void) ;
#line 185
void _i(void) ;
#line 186
void _j(void) ;
#line 187
void _plus_loop(void) ;
#line 188
void _recurse(void) ;
#line 191
void _number_sign(void) ;
#line 198
void _space(void) ;
#line 201
void _u_dot(void) ;
#line 202
void _dot_quote(void) ;
#line 203
void _tick(void) ;
#line 204
void _to_body(void) ;
#line 205
void _abort(void) ;
#line 206
void _abort_quote(void) ;
#line 208
void _decimal(void) ;
#line 209
void _environment_query(void) ;
#line 210
void _execute(void) ;
#line 211
void _fill(void) ;
#line 212
void _immediate(void) ;
#line 213
void _key(void) ;
#line 214
void _leave(void) ;
#line 215
void _literal(void) ;
#line 216
void _move(void) ;
#line 217
void _postpone(void) ;
#line 218
void _s_quote(void) ;
#line 219
void _sign(void) ;
#line 220
void _unloop(void) ;
#line 221
void _left_bracket(void) ;
#line 222
void _bracket_tick(void) ;
#line 223
void _char(void) ;
#line 224
void _bracket_char(void) ;
#line 225
void _right_bracket(void) ;
#line 226
void _while(void) ;
#line 227
void _repeat(void) ;
#line 228
void _paren_does_paren(void) ;
#line 229
void _paren_compile_paren(void) ;
#line 230
void _paren_do_paren(void) ;
#line 231
void _paren_loop_paren(void) ;
#line 232
void _paren_plus_loop_paren(void) ;
#line 233
void _paren_dot_quote_paren(void) ;
#line 234
void _paren_do_colon_paren(void) ;
#line 235
void _zero_branch(void) ;
#line 238
void _do_fliteral(void) ;
#line 239
void _do_exit(void) ;
#line 240
void _do_value(void) ;
#line 241
void _view_error_msg(void) ;
#line 242
void _read_const(void) ;
#line 252
void ins_word(struct word_def *p ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.h"
void _to_float(void) ;
#line 43
void _d_to_f(void) ;
#line 44
void _f_store(void) ;
#line 45
void _f_star(void) ;
#line 46
void _f_plus(void) ;
#line 47
void _f_minus(void) ;
#line 48
void _f_slash(void) ;
#line 49
void _f_zero_less(void) ;
#line 50
void _f_zero_equals(void) ;
#line 51
void _f_less_than(void) ;
#line 52
void _f_to_d(void) ;
#line 53
void _f_fetch(void) ;
#line 56
void _f_constant(void) ;
#line 57
void _f_depth(void) ;
#line 58
void _f_drop(void) ;
#line 59
void _f_dupe(void) ;
#line 60
void _f_literal(void) ;
#line 61
void _float_plus(void) ;
#line 62
void _floats(void) ;
#line 63
void _floor(void) ;
#line 64
void _f_max(void) ;
#line 65
void _f_min(void) ;
#line 66
void _f_negate(void) ;
#line 67
void _f_over(void) ;
#line 68
void _f_rote(void) ;
#line 69
void _f_round(void) ;
#line 70
void _f_swap(void) ;
#line 71
void _f_variable(void) ;
#line 72
void _represent(void) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/memall.h"
void _allocate(void) ;
#line 44
void _free(void) ;
#line 45
void _resize(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/string.h"
void _dash_trailing(void) ;
#line 43
void _slash_string(void) ;
#line 44
void _blank(void) ;
#line 45
void _c_move(void) ;
#line 46
void _c_move_up(void) ;
#line 47
void _compare(void) ;
#line 48
void _search(void) ;
#line 49
void _s_literal(void) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yfvinit.c"
static struct raw_voc iv[413]  = 
#line 95 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yfvinit.c"
  {      {(char *)">in", (void (*)(void))(& _to_in), 1}, 
        {(char *)"source-id", (void (*)(void))(& _source_id), 1}, 
        {(char *)"tib", (void (*)(void))(& _tib), 1}, 
        {(char *)"input-buffer", (void (*)(void))(& _input_buffer), 1}, 
        {(char *)"in-input-buffer", (void (*)(void))(& _in_input_buffer), 1}, 
        {(char *)"base", (void (*)(void))(& _base), 1}, 
        {(char *)"dp", (void (*)(void))(& _dp), 1}, 
        {(char *)"error", (void (*)(void))(& _error), 1}, 
        {(char *)"last", (void (*)(void))(& _last), 1}, 
        {(char *)"state", (void (*)(void))(& _state), 1}, 
        {(char *)"&counted-string", (void (*)(void))(& _env_slash_counted_string), 1}, 
        {(char *)"&hold",
      (void (*)(void))(& _env_slash_hold), 1}, 
        {(char *)"&pad", (void (*)(void))(& _env_slash_pad), 1}, 
        {(char *)"&address-unit-bits", (void (*)(void))(& _env_address_unit_bits), 1}, 
        {(char *)"&core",
      (void (*)(void))(& _env_core), 1}, 
        {(char *)"&core-ext", (void (*)(void))(& _env_core_ext), 1}, 
        {(char *)"&floored", (void (*)(void))(& _env_floored), 1}, 
        {(char *)"&max-char", (void (*)(void))(& _env_max_char), 1}, 
        {(char *)"&max-d", (void (*)(void))(& _env_max_d), 1}, 
        {(char *)"&max-n", (void (*)(void))(& _env_max_n), 1}, 
        {(char *)"&max-u", (void (*)(void))(& _env_max_u), 1}, 
        {(char *)"&max-ud", (void (*)(void))(& _env_max_ud), 1}, 
        {(char *)"&return-stack-cells", (void (*)(void))(& _env_return_stack_cells),
      1}, 
        {(char *)"&stack-cells", (void (*)(void))(& _env_stack_cells), 1}, 
        {(char *)"&double", (void (*)(void))(& _env_double), 1}, 
        {(char *)"&double-ext", (void (*)(void))(& _env_double_ext), 1}, 
        {(char *)"&floating", (void (*)(void))(& _env_floating), 1}, 
        {(char *)"&floating-stack", (void (*)(void))(& _env_floating_stack), 1}, 
        {(char *)"&max-float", (void (*)(void))(& _env_max_float), 1}, 
        {(char *)"&floating-ext", (void (*)(void))(& _env_floating_ext), 1}, 
        {(char *)"&memory-alloc", (void (*)(void))(& _env_memory_alloc), 1}, 
        {(char *)"&memory-alloc-ext", (void (*)(void))(& _env_memory_alloc_ext), 1}, 
        {(char *)"&search-order", (void (*)(void))(& _env_search_order), 1}, 
        {(char *)"&wordlists", (void (*)(void))(& _env_wordlists), 1}, 
        {(char *)"&search-order-ext", (void (*)(void))(& _env_search_order_ext), 1}, 
        {(char *)"&tools", (void (*)(void))(& _env_tools), 1}, 
        {(char *)"&tools-ext", (void (*)(void))(& _env_tools_ext), 1}, 
        {(char *)"&#locals", (void (*)(void))(& _env_number_locals), 1}, 
        {(char *)"&locals", (void (*)(void))(& _env_locals), 1}, 
        {(char *)"&locals-ext", (void (*)(void))(& _env_locals_ext), 1}, 
        {(char *)"&facility", (void (*)(void))(& _env_facility), 1}, 
        {(char *)"&facility-ext", (void (*)(void))(& _env_facility_ext), 1}, 
        {(char *)"&block", (void (*)(void))(& _env_block), 1}, 
        {(char *)"&block-ext", (void (*)(void))(& _env_block_ext), 1}, 
        {(char *)"&exception", (void (*)(void))(& _env_exception), 1}, 
        {(char *)"&exception-ext", (void (*)(void))(& _env_exception_ext), 1}, 
        {(char *)"&file", (void (*)(void))(& _env_file), 1}, 
        {(char *)"&file-ext", (void (*)(void))(& _env_file_ext), 1}, 
        {(char *)"&string", (void (*)(void))(& _env_string), 1}, 
        {(char *)"&string-ext", (void (*)(void))(& _env_string_ext), 1}, 
        {(char *)"(check-system)", (void (*)(void))(& _check_system), 1}, 
        {(char *)"!", & _store, 0}, 
        {(char *)"*", & _star, 0}, 
        {(char *)"*/", & _star_slash, 0}, 
        {(char *)"*/mod", & _star_slash_mod, 0}, 
        {(char *)"+", & _plus, 0}, 
        {(char *)"+!", & _plus_store, 0}, 
        {(char *)"-", & _minus, 0}, 
        {(char *)"/", & _slash, 0}, 
        {(char *)"/mod", & _slash_mod, 0}, 
        {(char *)"0<", & _zero_less, 0}, 
        {(char *)"0=", & _zero_equals, 0}, 
        {(char *)"1+", & _one_plus, 0}, 
        {(char *)"1-", & _one_minus, 0}, 
        {(char *)"2!", & _two_store, 0}, 
        {(char *)"2*", & _two_star, 0}, 
        {(char *)"2/", & _two_slash, 0}, 
        {(char *)"2@", & _two_fetch, 0}, 
        {(char *)"2drop", & _two_drop, 0}, 
        {(char *)"2dup", & _two_dupe, 0}, 
        {(char *)"2over", & _two_over, 0}, 
        {(char *)"2swap", & _two_swap, 0}, 
        {(char *)"<", & _less_than, 0}, 
        {(char *)"=", & _equals, 0}, 
        {(char *)">", & _greater_than, 0}, 
        {(char *)">r", & _to_r, 256}, 
        {(char *)"?dup", & _question_dupe, 0}, 
        {(char *)"@", & _fetch, 0}, 
        {(char *)"abs", & _abs, 0}, 
        {(char *)"align", & _align, 0}, 
        {(char *)"aligned", & _aligned, 0}, 
        {(char *)"and", & _and, 0}, 
        {(char *)"bl", & _b_l, 0}, 
        {(char *)"c!", & _c_store, 0}, 
        {(char *)"c@", & _c_fetch, 0}, 
        {(char *)"cell+", & _cell_plus, 0}, 
        {(char *)"cells", & _cells, 0}, 
        {(char *)"char+", & _char_plus, 0}, 
        {(char *)"chars", & _chars, 0}, 
        {(char *)"depth", & _depth, 0}, 
        {(char *)"drop", & _drop, 0}, 
        {(char *)"dup", & _dupe, 0}, 
        {(char *)"fm/mod", & _f_m_slash_mod, 0}, 
        {(char *)"invert", & _invert, 0}, 
        {(char *)"lshift", & _l_shift, 0}, 
        {(char *)"m*", & _m_star, 0}, 
        {(char *)"max", & _max, 0}, 
        {(char *)"min", & _min, 0}, 
        {(char *)"mod", & _mod, 0}, 
        {(char *)"negate", & _negate, 0}, 
        {(char *)"or", & _or, 0}, 
        {(char *)"over", & _over, 0}, 
        {(char *)"r>", & _r_from, 256}, 
        {(char *)"r@", & _r_fetch, 256}, 
        {(char *)"rot", & _rote, 0}, 
        {(char *)"rshift", & _r_shift, 0}, 
        {(char *)"s>d", & _s_to_d, 0}, 
        {(char *)"sm/rem", & _s_m_slash_rem, 0}, 
        {(char *)"swap", & _swap, 0}, 
        {(char *)"u<", & _u_less_than, 0}, 
        {(char *)"um*", & _u_m_star, 0}, 
        {(char *)"um/mod", & _u_m_slash_mod, 0}, 
        {(char *)"xor", & _xor, 0}, 
        {(char *)"word", & _word, 0}, 
        {(char *)">number", & _to_number, 0}, 
        {(char *)"interpret", & _interpret, 0}, 
        {(char *)"accept", & _accept, 0}, 
        {(char *)"source", & _source, 0}, 
        {(char *)"(", & _paren, 0}, 
        {(char *)"evaluate", & _evaluate, 0}, 
        {(char *)"quit", & _quit, 0}, 
        {(char *)",", & _comma, 0}, 
        {(char *)"allot", & _allot, 0}, 
        {(char *)"c,", & _c_comma, 0}, 
        {(char *)"here", & _here, 0}, 
        {(char *)"exit", & _exit_imm, 768}, 
        {(char *)":", & _colon, 0}, 
        {(char *)"variable", & _variable, 0}, 
        {(char *)"constant", & _constant, 0}, 
        {(char *)"create", & _create, 0}, 
        {(char *)"does>", & _does, 768}, 
        {(char *)";", & _semi_colon, 768}, 
        {(char *)"if", & _if, 768}, 
        {(char *)"then", & _then, 768}, 
        {(char *)"else", & _else, 768}, 
        {(char *)"begin", & _begin, 768}, 
        {(char *)"do", & _do, 768}, 
        {(char *)"loop", & _loop, 768}, 
        {(char *)"i", & _i, 256}, 
        {(char *)"j", & _j, 256}, 
        {(char *)"+loop", & _plus_loop, 768}, 
        {(char *)"recurse", & _recurse, 768}, 
        {(char *)"find", & _find, 0}, 
        {(char *)"<#", & _less_number_sign, 0}, 
        {(char *)"#", & _number_sign, 0}, 
        {(char *)"hold", & _hold, 0}, 
        {(char *)"#s", & _number_sign_s, 0}, 
        {(char *)"#>", & _number_sign_greater, 0}, 
        {(char *)".", & _dot, 0}, 
        {(char *)"cr", & _c_r, 0}, 
        {(char *)"emit", & _emit, 0}, 
        {(char *)"space", & _space, 0}, 
        {(char *)"spaces", & _spaces, 0}, 
        {(char *)"type", & _type, 0}, 
        {(char *)"u.", & _u_dot, 0}, 
        {(char *)".\"", & _dot_quote, 768}, 
        {(char *)"\'", & _tick, 0}, 
        {(char *)">body", & _to_body, 0}, 
        {(char *)"abort", & _abort, 0}, 
        {(char *)"abort\"", & _abort_quote, 768}, 
        {(char *)"count", & _count, 0}, 
        {(char *)"decimal", & _decimal, 0}, 
        {(char *)"environment?", & _environment_query, 0}, 
        {(char *)"execute", & _execute, 0}, 
        {(char *)"fill", & _fill, 0}, 
        {(char *)"immediate", & _immediate, 0}, 
        {(char *)"key", & _key, 0}, 
        {(char *)"leave", & _leave, 256}, 
        {(char *)"literal", & _literal, 768}, 
        {(char *)"move", & _move, 0}, 
        {(char *)"postpone", & _postpone, 768}, 
        {(char *)"s\"", & _s_quote, 512}, 
        {(char *)"sign", & _sign, 0}, 
        {(char *)"unloop", & _unloop, 256}, 
        {(char *)"[", & _left_bracket, 768}, 
        {(char *)"[\']", & _bracket_tick, 768}, 
        {(char *)"char", & _char, 0}, 
        {(char *)"[char]", & _bracket_char, 768}, 
        {(char *)"]", & _right_bracket, 0}, 
        {(char *)"while", & _while, 768}, 
        {(char *)"repeat", & _repeat, 768}, 
        {(char *)"(does)", & _paren_does_paren, 0}, 
        {(char *)"(compile)", & _paren_compile_paren, 0}, 
        {(char *)"(do)", & _paren_do_paren, 0}, 
        {(char *)"(loop)", & _paren_loop_paren, 0}, 
        {(char *)"(+loop)", & _paren_plus_loop_paren, 0}, 
        {(char *)"(.\")", & _paren_dot_quote_paren, 0}, 
        {(char *)"(doCol)", & _paren_do_colon_paren, 0}, 
        {(char *)"(0branch)", & _zero_branch, 0}, 
        {(char *)"(branch)", & _branch, 0}, 
        {(char *)"(doLit)", & _do_literal, 0}, 
        {(char *)"(doFLit)", & _do_fliteral, 0}, 
        {(char *)"(doExit)", & _do_exit, 0}, 
        {(char *)"(doValue)", & _do_value, 0}, 
        {(char *)"view-error-message", & _view_error_msg, 0}, 
        {(char *)"read-const", & _read_const, 0}, 
        {(char *)"ver", & _yforth_version, 0}, 
        {(char *)"save-image", & _save_image, 0}, 
        {(char *)"system", & _system, 0}, 
        {(char *)"pad", (void (*)(void))(& _pad), 1}, 
        {(char *)"source-id", (void (*)(void))(& _source_id), 1}, 
        {(char *)".(", & _dot_paren, 512}, 
        {(char *)".r", & _dot_r, 0}, 
        {(char *)"0<>", & _zero_not_equals, 0}, 
        {(char *)"0>", & _zero_greater, 0}, 
        {(char *)"2>r", & _two_to_r, 256}, 
        {(char *)"2r>", & _two_r_from, 256}, 
        {(char *)"2r@", & _two_r_fetch, 256}, 
        {(char *)":noname", & _colon_no_name, 0}, 
        {(char *)"<>", & _not_equals, 0}, 
        {(char *)"?do", & _question_do, 768}, 
        {(char *)"again", & _again, 768}, 
        {(char *)"c\"", & _c_quote, 768}, 
        {(char *)"compile,", & _compile_comma, 256}, 
        {(char *)"erase", & _erase, 0}, 
        {(char *)"false", & _false, 0}, 
        {(char *)"hex", & _hex, 0}, 
        {(char *)"marker", & _marker, 0}, 
        {(char *)"nip", & _nip, 0}, 
        {(char *)"parse", & _parse, 0}, 
        {(char *)"pick", & _pick, 0}, 
        {(char *)"refill", & _refill, 0}, 
        {(char *)"restore-input", & _restore_input, 0}, 
        {(char *)"roll", & _roll, 0}, 
        {(char *)"save-input", & _save_input, 0}, 
        {(char *)"true", & _true, 0}, 
        {(char *)"tuck", & _tuck, 0}, 
        {(char *)"u.r", & _u_dot_r, 0}, 
        {(char *)"u>", & _u_greater_than, 0}, 
        {(char *)"unused", & _unused, 0}, 
        {(char *)"within", & _within, 0}, 
        {(char *)"\\", & _backslash, 512}, 
        {(char *)"#!", & _backslash, 512}, 
        {(char *)"[compile]", & _bracket_compile, 256}, 
        {(char *)"value", & _value, 0}, 
        {(char *)"to", & _to, 512}, 
        {(char *)"(?do)", & _paren_question_do_paren, 0}, 
        {(char *)"(wValue)", & _paren_write_value_paren, 0}, 
        {(char *)"(marker)", & _paren_marker_paren, 0}, 
        {(char *)"2constant", & _two_constant, 0}, 
        {(char *)"2literal", & _two_literal, 768}, 
        {(char *)"2variable", & _two_variable, 0}, 
        {(char *)"d+", & _d_plus, 0}, 
        {(char *)"d-", & _d_minus, 0}, 
        {(char *)"d.", & _d_dot, 0}, 
        {(char *)"d.r", & _d_dot_r, 0}, 
        {(char *)"d0<", & _d_zero_less, 0}, 
        {(char *)"d0=", & _d_zero_equals, 0}, 
        {(char *)"d2*", & _d_two_star, 0}, 
        {(char *)"d2/", & _d_two_slash, 0}, 
        {(char *)"d<", & _d_less_than, 0}, 
        {(char *)"d=", & _d_equals, 0}, 
        {(char *)"d>s", & _drop, 0}, 
        {(char *)"dabs", & _dabs, 0}, 
        {(char *)"dmax", & _dmax, 0}, 
        {(char *)"dmin", & _dmin, 0}, 
        {(char *)"dnegate", & _dnegate, 0}, 
        {(char *)"m*/", & _m_star_slash, 0}, 
        {(char *)"m+", & _m_plus, 0}, 
        {(char *)"2rot", & _two_rote, 0}, 
        {(char *)"du<", & _d_u_less, 0}, 
        {(char *)">float", & _to_float, 0}, 
        {(char *)"d>f", & _d_to_f, 0}, 
        {(char *)"f!", & _f_store, 0}, 
        {(char *)"f*", & _f_star, 0}, 
        {(char *)"f+", & _f_plus, 0}, 
        {(char *)"f-", & _f_minus, 0}, 
        {(char *)"f/", & _f_slash, 0}, 
        {(char *)"f0<", & _f_zero_less, 0}, 
        {(char *)"f0=", & _f_zero_equals, 0}, 
        {(char *)"f<", & _f_less_than, 0}, 
        {(char *)"f>d", & _f_to_d, 0}, 
        {(char *)"f@", & _f_fetch, 0}, 
        {(char *)"falign", & _align, 0}, 
        {(char *)"faligned", & _aligned, 0}, 
        {(char *)"fconstant", & _f_constant, 0}, 
        {(char *)"fdepth", & _f_depth, 0}, 
        {(char *)"fdrop", & _f_drop, 0}, 
        {(char *)"fdup", & _f_dupe, 0}, 
        {(char *)"fliteral", & _f_literal, 768}, 
        {(char *)"float+", & _float_plus, 0}, 
        {(char *)"floats", & _floats, 0}, 
        {(char *)"floor", & _floor, 0}, 
        {(char *)"fmax", & _f_max, 0}, 
        {(char *)"fmin", & _f_min, 0}, 
        {(char *)"fnegate", & _f_negate, 0}, 
        {(char *)"fover", & _f_over, 0}, 
        {(char *)"frot", & _f_rote, 0}, 
        {(char *)"fround", & _f_round, 0}, 
        {(char *)"fswap", & _f_swap, 0}, 
        {(char *)"fvariable", & _f_variable, 0}, 
        {(char *)"represent", & _represent, 0}, 
        {(char *)"df!", & _d_f_store, 0}, 
        {(char *)"df@", & _d_f_fetch, 0}, 
        {(char *)"dfalign", & _align, 0}, 
        {(char *)"dfaligned", & _aligned, 0}, 
        {(char *)"dfloat+", & _d_float_plus, 0}, 
        {(char *)"dfloats", & _d_floats, 0}, 
        {(char *)"f**", & _f_star_star, 0}, 
        {(char *)"f.", & _f_dot, 0}, 
        {(char *)"fabs", & _f_abs, 0}, 
        {(char *)"facos", & _f_a_cos, 0}, 
        {(char *)"facosh", & _f_a_cosh, 0}, 
        {(char *)"falog", & _f_a_log, 0}, 
        {(char *)"fasin", & _f_a_sin, 0}, 
        {(char *)"fasinh", & _f_a_sinh, 0}, 
        {(char *)"fatan", & _f_a_tan, 0}, 
        {(char *)"fatan2", & _f_a_tan2, 0}, 
        {(char *)"fatanh", & _f_a_tanh, 0}, 
        {(char *)"fcos", & _f_cos, 0}, 
        {(char *)"fcosh", & _f_cosh, 0}, 
        {(char *)"fe.", & _f_e_dot, 0}, 
        {(char *)"fexp", & _f_exp, 0}, 
        {(char *)"fexpm1", & _f_exp_m_one, 0}, 
        {(char *)"fln", & _f_ln, 0}, 
        {(char *)"flnp1", & _f_ln_p_one, 0}, 
        {(char *)"flog", & _f_log, 0}, 
        {(char *)"fs.", & _f_s_dot, 0}, 
        {(char *)"fsin", & _f_sin, 0}, 
        {(char *)"fsincos", & _f_sin_cos, 0}, 
        {(char *)"fsinh", & _f_sinh, 0}, 
        {(char *)"fsqrt", & _f_sqrt, 0}, 
        {(char *)"ftan", & _f_tan, 0}, 
        {(char *)"ftanh", & _f_tanh, 0}, 
        {(char *)"f~", & _f_proximate, 0}, 
        {(char *)"precision", & _precision, 0}, 
        {(char *)"set-precision", & _set_precision, 0}, 
        {(char *)"sf!", & _s_f_store, 0}, 
        {(char *)"sf@", & _s_f_fetch, 0}, 
        {(char *)"sfalign", & _align, 0}, 
        {(char *)"sfaligned", & _aligned, 0}, 
        {(char *)"sfloat+", & _s_float_plus, 0}, 
        {(char *)"sfloats", & _s_floats, 0}, 
        {(char *)"allocate", & _allocate, 0}, 
        {(char *)"free", & _free, 0}, 
        {(char *)"resize", & _resize, 0}, 
        {(char *)"definitions", & _definitions, 0}, 
        {(char *)"forth-wordlist", & _forth_wordlist, 0}, 
        {(char *)"get-current", & _get_current, 0}, 
        {(char *)"get-order", & _get_order, 0}, 
        {(char *)"search-wordlist", & _search_wordlist, 0}, 
        {(char *)"set-current", & _set_current, 0}, 
        {(char *)"set-order", & _set_order, 0}, 
        {(char *)"wordlist", & _wordlist, 0}, 
        {(char *)"also", & _also, 0}, 
        {(char *)"forth", & _forth, 0}, 
        {(char *)"only", & _only, 0}, 
        {(char *)"order", & _order, 0}, 
        {(char *)"previous", & _previous, 0}, 
        {(char *)".s", & _dot_s, 0}, 
        {(char *)"?", & _question, 0}, 
        {(char *)"dump", & _dump, 0}, 
        {(char *)"see", & _see, 0}, 
        {(char *)"words", & _words, 0}, 
        {(char *)"ahead", & _ahead, 768}, 
        {(char *)"bye", & _bye, 0}, 
        {(char *)"cs-pick", & _pick, 256}, 
        {(char *)"cs-roll", & _roll, 256}, 
        {(char *)"[else]", & _bracket_else, 512}, 
        {(char *)"[if]", & _bracket_if, 512}, 
        {(char *)"[then]", & _bracket_then, 512}, 
        {(char *)"(local)", & _paren_local_paren, 256}, 
        {(char *)"(bp!)", & _paren_bp_restore_paren, 0}, 
        {(char *)"(bp@)", & _paren_bp_save_paren, 0}, 
        {(char *)"(rLocal)", & _paren_read_local_paren, 0}, 
        {(char *)"(wLocal)", & _paren_write_local_paren, 0}, 
        {(char *)"locals|", & _locals_bar, 768}, 
        {(char *)"at-xy", & _at_x_y, 0}, 
        {(char *)"key?", & _key_question, 0}, 
        {(char *)"page", & _page, 0}, 
        {(char *)"-trailing", & _dash_trailing, 0}, 
        {(char *)"/string", & _slash_string, 0}, 
        {(char *)"blank", & _blank, 0}, 
        {(char *)"cmove", & _c_move, 0}, 
        {(char *)"cmove>", & _c_move_up, 0}, 
        {(char *)"compare", & _compare, 0}, 
        {(char *)"search", & _search, 0}, 
        {(char *)"sliteral", & _s_literal, 768}, 
        {(char *)"bin", & _bin, 0}, 
        {(char *)"close-file", & _close_file, 0}, 
        {(char *)"create-file", & _create_file, 0}, 
        {(char *)"delete-file", & _delete_file, 0}, 
        {(char *)"file-position", & _file_position, 0}, 
        {(char *)"file-size", & _file_size, 0}, 
        {(char *)"include-file", & _include_file, 0}, 
        {(char *)"included", & _included, 0}, 
        {(char *)"open-file", & _open_file, 0}, 
        {(char *)"r/o", & _r_o, 0}, 
        {(char *)"r/w", & _r_w, 0}, 
        {(char *)"read-file", & _read_file, 0}, 
        {(char *)"read-line", & _read_line, 0}, 
        {(char *)"reposition-file", & _reposition_file, 0}, 
        {(char *)"resize-file", & _resize_file, 0}, 
        {(char *)"w/o", & _w_o, 0}, 
        {(char *)"write-file", & _write_file, 0}, 
        {(char *)"write-line", & _write_line, 0}, 
        {(char *)"file-status", & _file_status, 0}, 
        {(char *)"flush-file", & _flush_file, 0}, 
        {(char *)"rename-file", & _rename_file, 0}, 
        {(char *)"blk", (void (*)(void))(& _b_l_k), 1}, 
        {(char *)"block", & _block, 0}, 
        {(char *)"buffer", & _buffer, 0}, 
        {(char *)"flush", & _flush, 0}, 
        {(char *)"load", & _load, 0}, 
        {(char *)"save-buffers", & _save_buffers, 0}, 
        {(char *)"update", & _update, 0}, 
        {(char *)"scr", (void (*)(void))(& _s_c_r), 1}, 
        {(char *)"empty-buffers", & _empty_buffers, 0}, 
        {(char *)"list", & _list, 0}, 
        {(char *)"thru", & _thru, 0}, 
        {(char *)"catch", & _catch, 0}, 
        {(char *)"throw", & _throw, 0}, 
        {(char *)0, (void (*)(void))0, 0}};
#line 175 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yfvinit.c"
void init_vocabulary(char **dp ) 
{ 
  struct word_def *w ;
  char *name ;
  int i ;
  size_t tmp ;

  {
#line 178
  i = 0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! iv[i].name) {
#line 179
      goto while_break;
    }
    {
#line 180
    name = *dp;
#line 181
    tmp = strlen((char const   *)iv[i].name);
#line 181
    *(*dp) = (char )tmp;
#line 182
    strcpy((char */* __restrict  */)(*dp + 1), (char const   */* __restrict  */)iv[i].name);
#line 183
    *dp = (char *)(((unsigned long )((int )((*dp + (int )*(*dp)) + sizeof(char )) - 1) | (sizeof(int ) - 1UL)) + 1UL);
#line 184
    w = (struct word_def *)*dp;
#line 185
    w->name = name;
#line 186
    w->class = iv[i].class;
#line 187
    ins_word(w);
#line 188
    mark_word(w);
#line 190
    *dp += sizeof(struct word_def );
    }
    {
#line 192
    if ((iv[i].class & 15) == 0) {
#line 192
      goto case_0;
    }
#line 195
    if ((iv[i].class & 15) == 1) {
#line 195
      goto case_1;
    }
#line 191
    goto switch_break;
    case_0: /* CIL Label */ 
#line 193
    w->func[0] = iv[i].func;
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 196
    w->func[0] = iv[i].func;
#line 197
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 199
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return;
}
}
#line 49 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/memall.c"
void _allocate(void) 
{ 
  register void *addr ;
  void *tmp ;

  {
  {
#line 32
  tmp = malloc((size_t )*sp);
#line 32
  addr = tmp;
  }
#line 33
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 33
    *sp = 0;
  } else {
#line 34
    *sp = (int )addr;
  }
#line 35
  sp --;
#line 35
  *sp = - ((unsigned long )addr == (unsigned long )((void *)0));
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/memall.c"
void _free(void) 
{ 


  {
  {
#line 39
  free((void *)*sp);
#line 40
  *sp = 0;
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/memall.c"
void _resize(void) 
{ 
  register void *addr ;
  void *tmp ;

  {
  {
#line 44
  tmp = realloc((void *)*(sp + 1), (size_t )*(sp + 0));
#line 44
  addr = tmp;
  }
#line 45
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 45
    *(sp + 1) = 0;
  } else {
#line 46
    *(sp + 1) = (int )addr;
  }
#line 47
  *sp = - ((unsigned long )addr == (unsigned long )((void *)0));
#line 48
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/string.c"
void _dash_trailing(void) 
{ 
  register char *s ;
  register int i ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 32
  s = (char *)*(sp + 1);
#line 33
  i = *(sp + 0);
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    tmp___0 = i;
#line 34
    i --;
#line 34
    if (! (tmp___0 > 0)) {
#line 34
      goto while_break;
    }
    {
#line 34
    tmp = __ctype_b_loc();
    }
#line 34
    if (! ((int const   )*(*tmp + (int )*(s + i)) & 8192)) {
#line 34
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  *(sp + 0) = i + 1;
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/string.c"
void _slash_string(void) 
{ 
  register int n ;
  int *tmp ;

  {
#line 39
  tmp = sp;
#line 39
  sp ++;
#line 39
  n = *tmp;
#line 40
  *(sp + 1) = (int )((char *)*(sp + 1) + n);
#line 41
  *(sp + 0) -= n;
#line 42
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/string.c"
void _blank(void) 
{ 
  register unsigned int u ;
  int *tmp ;
  register char *s ;
  int *tmp___0 ;

  {
#line 45
  tmp = sp;
#line 45
  sp ++;
#line 45
  u = (unsigned int )*tmp;
#line 46
  tmp___0 = sp;
#line 46
  sp ++;
#line 46
  s = (char *)*tmp___0;
#line 47
  if (u) {
    {
#line 47
    memset((void *)s, ' ', (size_t )u);
    }
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/string.c"
void _c_move(void) 
{ 
  register unsigned int u ;
  int *tmp ;
  register char *dest ;
  int *tmp___0 ;
  register char *source ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 51
  tmp = sp;
#line 51
  sp ++;
#line 51
  u = (unsigned int )*tmp;
#line 52
  tmp___0 = sp;
#line 52
  sp ++;
#line 52
  dest = (char *)*tmp___0;
#line 53
  tmp___1 = sp;
#line 53
  sp ++;
#line 53
  source = (char *)*tmp___1;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    tmp___4 = u;
#line 54
    u --;
#line 54
    if (! tmp___4) {
#line 54
      goto while_break;
    }
#line 54
    tmp___2 = dest;
#line 54
    dest ++;
#line 54
    tmp___3 = source;
#line 54
    source ++;
#line 54
    *tmp___2 = *tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/string.c"
void _c_move_up(void) 
{ 
  register unsigned int u ;
  int *tmp ;
  register char *dest ;
  int *tmp___0 ;
  register char *source ;
  int *tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 58
  tmp = sp;
#line 58
  sp ++;
#line 58
  u = (unsigned int )*tmp;
#line 59
  tmp___0 = sp;
#line 59
  sp ++;
#line 59
  dest = (char *)*tmp___0 + u;
#line 60
  tmp___1 = sp;
#line 60
  sp ++;
#line 60
  source = (char *)*tmp___1 + u;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    tmp___2 = u;
#line 61
    u --;
#line 61
    if (! tmp___2) {
#line 61
      goto while_break;
    }
#line 61
    dest --;
#line 61
    source --;
#line 61
    *dest = *source;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/string.c"
void _compare(void) 
{ 
  register unsigned int u2 ;
  int *tmp ;
  register char *s2 ;
  int *tmp___0 ;
  register unsigned int u1 ;
  int *tmp___1 ;
  register char *s1 ;
  register unsigned int m ;
  unsigned int tmp___2 ;

  {
#line 65
  tmp = sp;
#line 65
  sp ++;
#line 65
  u2 = (unsigned int )*tmp;
#line 66
  tmp___0 = sp;
#line 66
  sp ++;
#line 66
  s2 = (char *)*tmp___0;
#line 67
  tmp___1 = sp;
#line 67
  sp ++;
#line 67
  u1 = (unsigned int )*tmp___1;
#line 68
  s1 = (char *)*sp;
#line 69
  if (u2 <= u1) {
#line 69
    tmp___2 = u2;
  } else {
#line 69
    tmp___2 = u1;
  }
#line 69
  m = tmp___2;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! m) {
#line 70
      goto while_break;
    }
#line 71
    if ((int )*s1 != (int )*s2) {
#line 71
      goto while_break;
    }
#line 72
    s1 ++;
#line 73
    s2 ++;
#line 74
    m --;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  if (u1 == u2) {
#line 76
    if (! m) {
#line 76
      *sp = 0;
    } else {
#line 76
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 77
  if (! m) {
#line 77
    if (u1 < u2) {
#line 77
      *sp = -1;
    } else {
#line 77
      *sp = 1;
    }
  } else
#line 78
  if ((int )*s1 < (int )*s2) {
#line 78
    *sp = -1;
  } else {
#line 78
    *sp = 1;
  }
#line 79
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/string.c"
void _search(void) 
{ 
  register unsigned int u2 ;
  int *tmp ;
  register char *s2 ;
  register unsigned int u1 ;
  register char *s1 ;
  int *tmp___0 ;

  {
#line 82
  tmp = sp;
#line 82
  sp ++;
#line 82
  u2 = (unsigned int )*tmp;
#line 83
  s2 = (char *)*(sp + 0);
#line 84
  u1 = (unsigned int )*(sp + 1);
#line 85
  s1 = (char *)*(sp + 2);
#line 86
  if (u2 > u1) {
#line 86
    *sp = 0;
  } else {
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      if (! (u1 >= u2)) {
#line 88
        goto while_break;
      }
      {
#line 89
      sp --;
#line 89
      *sp = (int )s1;
#line 90
      sp --;
#line 90
      *sp = (int )u1;
#line 91
      sp --;
#line 91
      *sp = (int )s2;
#line 92
      sp --;
#line 92
      *sp = (int )u2;
#line 93
      _compare();
#line 94
      tmp___0 = sp;
#line 94
      sp ++;
      }
#line 94
      if (*tmp___0) {
#line 100
        s1 ++;
#line 101
        u1 --;
      } else {
#line 95
        *(sp + 2) = (int )s1;
#line 96
        *(sp + 1) = (int )u1;
#line 97
        *(sp + 0) = -1;
#line 98
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 105
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/string.c"
void _s_literal(void) 
{ 
  register unsigned int u ;
  int *tmp ;
  register char *s ;
  int *tmp___0 ;

  {
#line 108
  tmp = sp;
#line 108
  sp ++;
#line 108
  u = (unsigned int )*tmp;
#line 109
  tmp___0 = sp;
#line 109
  sp ++;
#line 109
  s = (char *)*tmp___0;
#line 110
  *((int *)_dp) = (int )(& _do_literal);
#line 110
  _dp += sizeof(int );
#line 111
  *((int *)_dp) = (int )s;
#line 111
  _dp += sizeof(int );
#line 112
  *((int *)_dp) = (int )(& _do_literal);
#line 112
  _dp += sizeof(int );
#line 113
  *((int *)_dp) = (int )u;
#line 113
  _dp += sizeof(int );
#line 114
  return;
}
}
#line 184 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _to_float(void) 
{ 
  register int len ;
  int *tmp ;
  register char *s ;
  char *endptr ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;

  {
  {
#line 35
  tmp = sp;
#line 35
  sp ++;
#line 35
  len = *tmp;
#line 36
  s = (char *)*sp;
#line 39
  memcpy((void */* __restrict  */)(s_tmp_buffer), (void const   */* __restrict  */)s,
         (size_t )len);
#line 40
  tmp___1 = toupper((int )*(s + (len - 1)));
  }
#line 40
  if (tmp___1 == 69) {
#line 40
    tmp___0 = len;
#line 40
    len ++;
#line 40
    *(s + tmp___0) = (char )'0';
  } else {
    {
#line 40
    tmp___2 = toupper((int )*(s + (len - 1)));
    }
#line 40
    if (tmp___2 == 68) {
#line 40
      tmp___0 = len;
#line 40
      len ++;
#line 40
      *(s + tmp___0) = (char )'0';
    }
  }
  {
#line 41
  *(s + len) = (char )'\000';
#line 42
  fp --;
#line 42
  tmp___3 = strtod((char const   */* __restrict  */)s, (char **/* __restrict  */)(& endptr));
#line 42
  *fp = (float )tmp___3;
  }
#line 43
  if (! *endptr) {
#line 43
    *sp = -1;
  } else {
#line 45
    *sp = 0;
#line 46
    fp ++;
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _d_to_f(void) 
{ 
  register long long d ;
  long long tmp ;

  {
  {
#line 51
  tmp = get_dcell(sp);
#line 51
  d = tmp;
#line 52
  fp --;
#line 52
  *fp = (float )d;
#line 53
  sp += 2;
  }
#line 54
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_store(void) 
{ 
  register float *addr ;
  int *tmp ;
  float *tmp___0 ;

  {
#line 57
  tmp = sp;
#line 57
  sp ++;
#line 57
  addr = (float *)*tmp;
#line 58
  tmp___0 = fp;
#line 58
  fp ++;
#line 58
  *addr = *tmp___0;
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_star(void) 
{ 


  {
#line 62
  *(fp + 1) *= *(fp + 0);
#line 63
  fp ++;
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_plus(void) 
{ 


  {
#line 67
  *(fp + 1) += *(fp + 0);
#line 68
  fp ++;
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_minus(void) 
{ 


  {
#line 72
  *(fp + 1) -= *(fp + 0);
#line 73
  fp ++;
#line 74
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_slash(void) 
{ 


  {
#line 77
  *(fp + 1) /= *(fp + 0);
#line 78
  fp ++;
#line 79
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_zero_less(void) 
{ 


  {
#line 82
  sp --;
#line 83
  *sp = - ((double )*fp < 0.0);
#line 84
  fp ++;
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_zero_equals(void) 
{ 


  {
#line 88
  sp --;
#line 89
  *sp = - ((double )*fp == 0.0);
#line 90
  fp ++;
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_less_than(void) 
{ 


  {
#line 94
  sp --;
#line 95
  *sp = - (*(fp + 1) < *(fp + 0));
#line 96
  fp += 2;
#line 97
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_to_d(void) 
{ 
  register long long d ;
  float *tmp ;

  {
  {
#line 100
  tmp = fp;
#line 100
  fp ++;
#line 100
  d = (long long )*tmp;
#line 101
  sp -= 2;
#line 102
  put_dcell(sp, d);
  }
#line 103
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_fetch(void) 
{ 
  int *tmp ;

  {
#line 106
  fp --;
#line 106
  tmp = sp;
#line 106
  sp ++;
#line 106
  *fp = *((float *)*tmp);
#line 107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_constant(void) 
{ 
  register float r ;
  float *tmp ;

  {
  {
#line 110
  tmp = fp;
#line 110
  fp ++;
#line 110
  r = *tmp;
#line 111
  create_definition(5);
#line 112
  *((float *)_dp) = r;
#line 112
  _dp += sizeof(float );
#line 113
  mark_word(_last);
  }
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_depth(void) 
{ 


  {
#line 117
  sp --;
#line 117
  *sp = (int )(fp_top - fp);
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_drop(void) 
{ 


  {
#line 121
  fp ++;
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_dupe(void) 
{ 


  {
#line 125
  fp --;
#line 126
  *(fp + 0) = *(fp + 1);
#line 127
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_literal(void) 
{ 


  {
#line 130
  *((int *)_dp) = (int )(& _do_fliteral);
#line 130
  _dp += sizeof(int );
#line 131
  *((float *)_dp) = *(fp + 0);
#line 131
  _dp += sizeof(float );
#line 132
  fp ++;
#line 133
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _float_plus(void) 
{ 


  {
#line 136
  *(sp + 0) = (int )((unsigned long )*(sp + 0) + sizeof(float ));
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _floats(void) 
{ 


  {
#line 140
  *(sp + 0) = (int )((unsigned long )*(sp + 0) * sizeof(float ));
#line 141
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _floor(void) 
{ 
  double tmp ;

  {
  {
#line 144
  tmp = floor((double )*(fp + 0));
#line 144
  *(fp + 0) = (float )tmp;
  }
#line 145
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_max(void) 
{ 


  {
#line 148
  if (*(fp + 0) > *(fp + 1)) {
#line 148
    *(fp + 1) = *(fp + 0);
  }
#line 149
  fp ++;
#line 150
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_min(void) 
{ 


  {
#line 153
  if (*(fp + 0) < *(fp + 1)) {
#line 153
    *(fp + 1) = *(fp + 0);
  }
#line 154
  fp ++;
#line 155
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_negate(void) 
{ 


  {
#line 158
  *(fp + 0) = - *(fp + 0);
#line 159
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_over(void) 
{ 


  {
#line 162
  fp --;
#line 163
  *(fp + 0) = *(fp + 2);
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_rote(void) 
{ 
  register float temp ;

  {
#line 167
  temp = *(fp + 0);
#line 168
  *(fp + 0) = *(fp + 2);
#line 169
  *(fp + 2) = *(fp + 1);
#line 170
  *(fp + 1) = temp;
#line 171
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_round(void) 
{ 
  double tmp ;

  {
  {
#line 174
  tmp = floor((double )*(fp + 0) + 0.5);
#line 174
  *(fp + 0) = (float )tmp;
  }
#line 175
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_swap(void) 
{ 
  register float temp ;

  {
#line 178
  temp = *(fp + 0);
#line 179
  *(fp + 0) = *(fp + 1);
#line 180
  *(fp + 1) = temp;
#line 181
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _f_variable(void) 
{ 


  {
  {
#line 184
  create_definition(6);
#line 185
  *((float *)_dp) = (float )0.0;
#line 185
  _dp += sizeof(float );
#line 186
  mark_word(_last);
  }
#line 187
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
static char buf[128]  ;
#line 189 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/float.c"
void _represent(void) 
{ 
  register float x ;
  float *tmp ;
  register int m ;
  register int sign ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 190
  tmp = fp;
#line 190
  fp ++;
#line 190
  x = *tmp;
#line 192
  sign = 0;
#line 194
  if ((double )x < 0.0) {
#line 195
    sign = 1;
#line 196
    x = - x;
  }
#line 198
  if ((double )x != 0.0) {
    {
#line 199
    tmp___0 = log10((double )x);
#line 199
    tmp___1 = floor(tmp___0);
#line 199
    m = (int )tmp___1 + 1;
#line 200
    tmp___2 = pow((double )10, (double )m);
#line 200
    x = (float )((double )x / tmp___2);
    }
#line 201
    if ((double )x >= 1.0) {
#line 202
      x /= (float )10;
#line 203
      m ++;
    }
  } else {
#line 205
    m = 0;
  }
  {
#line 206
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%0.*f",
          *(sp + 0), (double )x);
#line 207
  strncpy((char */* __restrict  */)((char *)*(sp + 1)), (char const   */* __restrict  */)(buf + 2),
          (size_t )*(sp + 0));
#line 208
  sp --;
#line 209
  *(sp + 2) = m;
#line 210
  *(sp + 1) = - sign;
#line 211
  *(sp + 0) = -1;
  }
#line 212
  return;
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 189 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
pfp *ip  ;
#line 191 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
int *sp  ;
#line 191 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
int *sp_top  ;
#line 191 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
int *sp_base  ;
#line 192 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
int *rp  ;
#line 192 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
int *rp_top  ;
#line 192 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
int *rp_base  ;
#line 193 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
float *fp  ;
#line 193 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
float *fp_top  ;
#line 193 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
float *fp_base  ;
#line 194 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/yforth.h"
int *bp  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/vm.c"
static union double_cell dcell  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/vm.c"
void stacks_recovery(void) 
{ 


  {
#line 51
  sp = sp_top;
#line 52
  rp = rp_top;
#line 53
  fp = fp_top;
#line 54
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/vm.c"
long long get_dcell(int *ptr ) 
{ 


  {
#line 63
  dcell.d2.high = *ptr;
#line 64
  dcell.d2.low = *(ptr + 1);
#line 65
  return (dcell.d1);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/vm.c"
void put_dcell(int *ptr , long long d ) 
{ 


  {
#line 71
  dcell.d1 = d;
#line 72
  *ptr = dcell.d2.high;
#line 73
  *(ptr + 1) = dcell.d2.low;
#line 74
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/vm.c"
void sig_fpe_handler(int sig ) 
{ 


  {
  {
#line 81
  signal(8, & sig_fpe_handler);
#line 82
  _error = -16;
#line 83
  _view_error_msg();
#line 84
  longjmp((struct __jmp_buf_tag *)(warm_start_jump), 1);
  }
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/vm.c"
void sig_segv_handler(int sig ) 
{ 


  {
  {
#line 91
  signal(11, & sig_segv_handler);
#line 92
  _error = -17;
#line 93
  _view_error_msg();
#line 94
  longjmp((struct __jmp_buf_tag *)(warm_start_jump), 1);
  }
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/vm.c"
void init_signals(void) 
{ 


  {
  {
#line 101
  signal(8, & sig_fpe_handler);
#line 102
  signal(11, & sig_segv_handler);
  }
#line 103
  return;
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 538 "/usr/include/stdio.h"
extern int getchar(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _to_in  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _source_id  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
char *_tib  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
char *_input_buffer  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _in_input_buffer  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _base  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
char *_dp  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _error  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
struct word_def *_last  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _state  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_slash_counted_string  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_slash_hold  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_slash_pad  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_address_unit_bits  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_core  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_core_ext  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_floored  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_max_char  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_max_d  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_max_n  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_max_u  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_max_ud  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_return_stack_cells  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_stack_cells  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_double  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_double_ext  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_floating  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_floating_stack  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_max_float  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_floating_ext  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_memory_alloc  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_memory_alloc_ext  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_search_order  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_wordlists  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_search_order_ext  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_tools  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_tools_ext  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_number_locals  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_locals  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_locals_ext  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_facility  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_facility_ext  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_block  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_block_ext  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_exception  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_exception_ext  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_file  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_file_ext  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_string  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.h"
int _env_string_ext  ;
#line 256
int is_base_digit(char ch ) ;
#line 257
int process_char(char *addr , int max_len , int cur_pos , char ch ) ;
#line 259
void exec_colon(pfp *ip0 ) ;
#line 264
void check_system(void) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
char s_tmp_buffer[80]  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
int _check_system  =    1;
#line 100 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _dot_quote(void) 
{ 


  {
  {
#line 101
  *((int *)_dp) = (int )(& _paren_dot_quote_paren);
#line 101
  _dp += sizeof(int );
#line 102
  sp --;
#line 102
  *sp = '\"';
#line 103
  _word();
#line 104
  _dp = (char *)(((unsigned long )((int )((_dp + (int )*_dp) + sizeof(char )) - 1) | (sizeof(int ) - 1UL)) + 1UL);
#line 105
  sp ++;
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _paren_dot_quote_paren(void) 
{ 
  register char *addr ;

  {
  {
#line 109
  addr = (char *)ip;
#line 110
  sp --;
#line 110
  *sp = (int )(addr + 1);
#line 111
  sp --;
#line 111
  *sp = (int )*addr;
#line 112
  _type();
#line 113
  ip = (pfp *)(((unsigned long )((int )(((char *)ip + (int )*((char *)ip)) + sizeof(char )) - 1) | (sizeof(int ) - 1UL)) + 1UL);
  }
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _type(void) 
{ 
  register int u ;
  int *tmp ;
  register char *addr ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 117
  tmp = sp;
#line 117
  sp ++;
#line 117
  u = *tmp;
#line 118
  tmp___0 = sp;
#line 118
  sp ++;
#line 118
  addr = (char *)*tmp___0;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    tmp___2 = u;
#line 119
    u --;
#line 119
    if (! tmp___2) {
#line 119
      goto while_break;
    }
    {
#line 119
    tmp___1 = addr;
#line 119
    addr ++;
#line 119
    putchar((int )*tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _u_dot(void) 
{ 


  {
  {
#line 123
  sp --;
#line 123
  *sp = 0;
#line 124
  _less_number_sign();
#line 125
  _number_sign_s();
#line 126
  _number_sign_greater();
#line 127
  _type();
#line 128
  putchar(' ');
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _c_r(void) 
{ 


  {
  {
#line 132
  putchar('\n');
  }
#line 133
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _emit(void) 
{ 
  int *tmp ;

  {
  {
#line 136
  tmp = sp;
#line 136
  sp ++;
#line 136
  putchar(*tmp);
  }
#line 137
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _dot(void) 
{ 


  {
  {
#line 141
  _s_to_d();
#line 142
  _d_dot();
  }
#line 143
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _space(void) 
{ 


  {
  {
#line 164
  putchar(' ');
  }
#line 165
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _spaces(void) 
{ 
  register unsigned int u ;
  int *tmp ;
  unsigned int tmp___0 ;

  {
#line 168
  tmp = sp;
#line 168
  sp ++;
#line 168
  u = (unsigned int )*tmp;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    tmp___0 = u;
#line 169
    u --;
#line 169
    if (! tmp___0) {
#line 169
      goto while_break;
    }
    {
#line 169
    putchar(' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _less_number_sign(void) 
{ 


  {
#line 173
  in_pnos = 0;
#line 174
  p_pnos = pnos + pnos_size;
#line 175
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _number_sign(void) 
{ 
  register unsigned long long ud1 ;
  long long tmp ;
  register int rem ;

  {
  {
#line 178
  tmp = get_dcell(sp);
#line 178
  ud1 = (unsigned long long )tmp;
#line 179
  rem = (int )(ud1 % (unsigned long long )_base);
#line 180
  ud1 /= (unsigned long long )_base;
#line 181
  put_dcell(sp, (long long )ud1);
  }
#line 182
  if (rem < 10) {
#line 182
    p_pnos --;
#line 182
    *p_pnos = (char )(rem + 48);
  } else {
#line 183
    p_pnos --;
#line 183
    *p_pnos = (char )((rem - 10) + 97);
  }
#line 184
  in_pnos ++;
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _hold(void) 
{ 
  register char ch ;
  int *tmp ;

  {
#line 188
  tmp = sp;
#line 188
  sp ++;
#line 188
  ch = (char )*tmp;
#line 189
  p_pnos --;
#line 189
  *p_pnos = ch;
#line 190
  in_pnos ++;
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _number_sign_s(void) 
{ 


  {
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 194
    _number_sign();
    }
#line 194
    if (! *(sp + 0)) {
#line 194
      if (! *(sp + 1)) {
#line 194
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _number_sign_greater(void) 
{ 


  {
#line 199
  *(sp + 1) = (int )p_pnos;
#line 200
  *(sp + 0) = in_pnos;
#line 201
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _store(void) 
{ 
  register int *addr ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 204
  tmp = sp;
#line 204
  sp ++;
#line 204
  addr = (int *)*tmp;
#line 205
  tmp___0 = sp;
#line 205
  sp ++;
#line 205
  *addr = *tmp___0;
#line 206
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _star(void) 
{ 


  {
#line 209
  *(sp + 1) *= *sp;
#line 210
  sp ++;
#line 211
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _star_slash(void) 
{ 
  register long long d ;

  {
#line 214
  d = (long long )*(sp + 1) * (long long )*(sp + 2);
#line 215
  *(sp + 2) = (int )(d / (long long )*(sp + 0));
#line 216
  sp += 2;
#line 217
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _star_slash_mod(void) 
{ 
  register long long d ;

  {
#line 220
  d = (long long )*(sp + 1) * (long long )*(sp + 2);
#line 221
  *(sp + 2) = (int )(d % (long long )*(sp + 0));
#line 222
  *(sp + 1) = (int )(d / (long long )*(sp + 0));
#line 223
  sp ++;
#line 224
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _plus(void) 
{ 


  {
#line 227
  *(sp + 1) += *(sp + 0);
#line 228
  sp ++;
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _plus_store(void) 
{ 
  register int *addr ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 232
  tmp = sp;
#line 232
  sp ++;
#line 232
  addr = (int *)*tmp;
#line 233
  tmp___0 = sp;
#line 233
  sp ++;
#line 233
  *addr += *tmp___0;
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _minus(void) 
{ 


  {
#line 237
  *(sp + 1) -= *(sp + 0);
#line 238
  sp ++;
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _slash(void) 
{ 


  {
#line 242
  *(sp + 1) /= *(sp + 0);
#line 243
  sp ++;
#line 244
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _slash_mod(void) 
{ 
  register int n1 ;
  register int n2 ;

  {
#line 247
  n1 = *(sp + 1);
#line 248
  n2 = *(sp + 0);
#line 249
  *(sp + 1) = n1 % n2;
#line 250
  *(sp + 0) = n1 / n2;
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _zero_less(void) 
{ 


  {
#line 254
  *(sp + 0) = - (*(sp + 0) < 0);
#line 255
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _zero_equals(void) 
{ 


  {
#line 258
  *(sp + 0) = - (*(sp + 0) == 0);
#line 259
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _one_plus(void) 
{ 


  {
#line 262
  (*(sp + 0)) ++;
#line 263
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _one_minus(void) 
{ 


  {
#line 266
  (*(sp + 0)) --;
#line 267
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _two_store(void) 
{ 
  register int *addr ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 270
  tmp = sp;
#line 270
  sp ++;
#line 270
  addr = (int *)*tmp;
#line 271
  tmp___0 = addr;
#line 271
  addr ++;
#line 271
  tmp___1 = sp;
#line 271
  sp ++;
#line 271
  *tmp___0 = *tmp___1;
#line 272
  tmp___2 = sp;
#line 272
  sp ++;
#line 272
  *addr = *tmp___2;
#line 273
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _two_star(void) 
{ 


  {
#line 276
  *(sp + 0) <<= 1;
#line 277
  return;
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _two_slash(void) 
{ 


  {
#line 280
  *(sp + 0) >>= 1;
#line 281
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _two_fetch(void) 
{ 
  register int *addr ;
  int *tmp ;

  {
#line 284
  addr = (int *)*sp;
#line 285
  tmp = sp;
#line 285
  sp --;
#line 285
  *tmp = *(addr + 1);
#line 286
  *sp = *addr;
#line 287
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _two_drop(void) 
{ 


  {
#line 290
  sp += 2;
#line 291
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _two_dupe(void) 
{ 


  {
#line 294
  sp -= 2;
#line 295
  *(sp + 0) = *(sp + 2);
#line 296
  *(sp + 1) = *(sp + 3);
#line 297
  return;
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _two_over(void) 
{ 


  {
#line 300
  sp -= 2;
#line 301
  *(sp + 0) = *(sp + 4);
#line 302
  *(sp + 1) = *(sp + 5);
#line 303
  return;
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _two_swap(void) 
{ 
  register int x4 ;
  register int x3 ;

  {
#line 306
  x4 = *(sp + 0);
#line 307
  x3 = *(sp + 1);
#line 308
  *(sp + 0) = *(sp + 2);
#line 309
  *(sp + 1) = *(sp + 3);
#line 310
  *(sp + 2) = x4;
#line 311
  *(sp + 3) = x3;
#line 312
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _less_than(void) 
{ 


  {
#line 315
  *(sp + 1) = - (*(sp + 1) < *(sp + 0));
#line 316
  sp ++;
#line 317
  return;
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _equals(void) 
{ 


  {
#line 320
  *(sp + 1) = - (*(sp + 1) == *(sp + 0));
#line 321
  sp ++;
#line 322
  return;
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _greater_than(void) 
{ 


  {
#line 325
  *(sp + 1) = - (*(sp + 1) > *(sp + 0));
#line 326
  sp ++;
#line 327
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _to_r(void) 
{ 
  int *tmp ;

  {
#line 330
  rp --;
#line 330
  tmp = sp;
#line 330
  sp ++;
#line 330
  *rp = *tmp;
#line 331
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _question_dupe(void) 
{ 


  {
#line 334
  if (*(sp + 0)) {
#line 334
    sp --;
#line 334
    *(sp + 0) = *(sp + 1);
  }
#line 335
  return;
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _fetch(void) 
{ 


  {
#line 338
  *(sp + 0) = *((int *)*(sp + 0));
#line 339
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _abs(void) 
{ 
  register int n ;

  {
#line 342
  n = *(sp + 0);
#line 343
  if (n >= 0) {
#line 343
    *(sp + 0) = n;
  } else {
#line 343
    *(sp + 0) = - n;
  }
#line 344
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _align(void) 
{ 


  {
#line 347
  _dp = (char *)(((unsigned long )((int )_dp - 1) | (sizeof(int ) - 1UL)) + 1UL);
#line 348
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _aligned(void) 
{ 


  {
#line 351
  *(sp + 0) = (int )(((unsigned long )((int )((int *)*(sp + 0)) - 1) | (sizeof(int ) - 1UL)) + 1UL);
#line 352
  return;
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _and(void) 
{ 


  {
#line 355
  *(sp + 1) &= *(sp + 0);
#line 356
  sp ++;
#line 357
  return;
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _b_l(void) 
{ 


  {
#line 360
  sp --;
#line 360
  *sp = ' ';
#line 361
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _c_store(void) 
{ 
  register char *addr ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 364
  tmp = sp;
#line 364
  sp ++;
#line 364
  addr = (char *)*tmp;
#line 365
  tmp___0 = sp;
#line 365
  sp ++;
#line 365
  *addr = (char )*tmp___0;
#line 366
  return;
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _c_fetch(void) 
{ 
  register char *addr ;

  {
#line 369
  addr = (char *)*sp;
#line 370
  *sp = (int )*addr;
#line 371
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _cell_plus(void) 
{ 


  {
#line 374
  *(sp + 0) = (int )((unsigned long )*(sp + 0) + sizeof(int ));
#line 375
  return;
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _cells(void) 
{ 


  {
#line 378
  *(sp + 0) = (int )((unsigned long )*(sp + 0) * sizeof(int ));
#line 379
  return;
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _char_plus(void) 
{ 


  {
#line 382
  *(sp + 0) = (int )((unsigned long )*(sp + 0) + sizeof(char ));
#line 383
  return;
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _chars(void) 
{ 


  {
#line 386
  *(sp + 0) = (int )((unsigned long )*(sp + 0) * sizeof(char ));
#line 387
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _depth(void) 
{ 
  register int dep ;

  {
#line 390
  dep = (int )(sp_top - sp);
#line 391
  sp --;
#line 391
  *sp = dep;
#line 392
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _drop(void) 
{ 


  {
#line 395
  sp ++;
#line 396
  return;
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _dupe(void) 
{ 


  {
#line 399
  sp --;
#line 400
  *(sp + 0) = *(sp + 1);
#line 401
  return;
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _f_m_slash_mod(void) 
{ 
  register int n1 ;
  int *tmp ;
  register long long d1 ;
  long long tmp___0 ;

  {
  {
#line 404
  tmp = sp;
#line 404
  sp ++;
#line 404
  n1 = *tmp;
#line 405
  tmp___0 = get_dcell(sp);
#line 405
  d1 = tmp___0;
#line 406
  *(sp + 0) = (int )(d1 / (long long )n1);
#line 407
  *(sp + 1) = (int )(d1 % (long long )n1);
  }
#line 409
  if (*sp < 0) {
#line 410
    (*(sp + 0)) --;
#line 411
    if (*(sp + 1) > 0) {
#line 411
      (*(sp + 1)) ++;
    } else {
#line 412
      (*(sp + 1)) --;
    }
#line 413
    *(sp + 1) = - *(sp + 1);
  }
#line 416
  return;
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _invert(void) 
{ 


  {
#line 419
  *(sp + 0) = ~ *(sp + 0);
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _l_shift(void) 
{ 
  register unsigned int u ;
  int *tmp ;

  {
#line 423
  tmp = sp;
#line 423
  sp ++;
#line 423
  u = (unsigned int )*tmp;
#line 424
  *(sp + 0) <<= u;
#line 425
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _m_star(void) 
{ 
  register long long d ;

  {
  {
#line 428
  d = (long long )*(sp + 1) * (long long )*(sp + 0);
#line 429
  put_dcell(sp, d);
  }
#line 430
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _max(void) 
{ 
  register int n2 ;
  int *tmp ;

  {
#line 433
  tmp = sp;
#line 433
  sp ++;
#line 433
  n2 = *tmp;
#line 434
  if (*(sp + 0) > n2) {
#line 434
    *(sp + 0) = *(sp + 0);
  } else {
#line 434
    *(sp + 0) = n2;
  }
#line 435
  return;
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _min(void) 
{ 
  register int n2 ;
  int *tmp ;

  {
#line 438
  tmp = sp;
#line 438
  sp ++;
#line 438
  n2 = *tmp;
#line 439
  if (*(sp + 0) < n2) {
#line 439
    *(sp + 0) = *(sp + 0);
  } else {
#line 439
    *(sp + 0) = n2;
  }
#line 440
  return;
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _mod(void) 
{ 


  {
#line 443
  *(sp + 1) %= *(sp + 0);
#line 444
  sp ++;
#line 445
  return;
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _negate(void) 
{ 


  {
#line 448
  *(sp + 0) = - *(sp + 0);
#line 449
  return;
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _or(void) 
{ 


  {
#line 452
  *(sp + 1) |= *(sp + 0);
#line 453
  sp ++;
#line 454
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _over(void) 
{ 


  {
#line 457
  sp --;
#line 458
  *(sp + 0) = *(sp + 2);
#line 459
  return;
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _r_from(void) 
{ 
  int *tmp ;

  {
#line 462
  sp --;
#line 462
  tmp = rp;
#line 462
  rp ++;
#line 462
  *sp = *tmp;
#line 463
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _r_fetch(void) 
{ 


  {
#line 466
  sp --;
#line 466
  *sp = *rp;
#line 467
  return;
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _rote(void) 
{ 
  register int x3 ;
  register int x2 ;
  register int x1 ;

  {
#line 470
  x3 = *(sp + 0);
#line 471
  x2 = *(sp + 1);
#line 472
  x1 = *(sp + 2);
#line 473
  *(sp + 0) = x1;
#line 474
  *(sp + 1) = x3;
#line 475
  *(sp + 2) = x2;
#line 476
  return;
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _r_shift(void) 
{ 
  register unsigned int u ;
  int *tmp ;

  {
#line 479
  tmp = sp;
#line 479
  sp ++;
#line 479
  u = (unsigned int )*tmp;
#line 480
  *((unsigned int *)sp + 0) >>= u;
#line 481
  return;
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _s_to_d(void) 
{ 
  register long long d ;
  int *tmp ;

  {
  {
#line 484
  tmp = sp;
#line 484
  sp --;
#line 484
  d = (long long )*tmp;
#line 485
  put_dcell(sp, d);
  }
#line 486
  return;
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _s_m_slash_rem(void) 
{ 
  register int n1 ;
  int *tmp ;
  register long long d1 ;
  long long tmp___0 ;

  {
  {
#line 489
  tmp = sp;
#line 489
  sp ++;
#line 489
  n1 = *tmp;
#line 490
  tmp___0 = get_dcell(sp);
#line 490
  d1 = tmp___0;
#line 491
  *(sp + 0) = (int )(d1 / (long long )n1);
#line 492
  *(sp + 1) = (int )(d1 % (long long )n1);
  }
#line 501
  return;
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _swap(void) 
{ 
  register int temp ;

  {
#line 504
  temp = *(sp + 0);
#line 505
  *(sp + 0) = *(sp + 1);
#line 506
  *(sp + 1) = temp;
#line 507
  return;
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _u_less_than(void) 
{ 


  {
#line 510
  *(sp + 1) = - ((unsigned int )*(sp + 1) < (unsigned int )*(sp + 0));
#line 511
  sp ++;
#line 512
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _u_m_star(void) 
{ 
  register unsigned long long ud ;

  {
  {
#line 515
  ud = (unsigned long long )*(sp + 1) * (unsigned long long )*(sp + 0);
#line 516
  put_dcell(sp, (long long )ud);
  }
#line 517
  return;
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _u_m_slash_mod(void) 
{ 
  register unsigned int u1 ;
  int *tmp ;
  register unsigned long long ud ;
  long long tmp___0 ;

  {
  {
#line 520
  tmp = sp;
#line 520
  sp ++;
#line 520
  u1 = (unsigned int )*tmp;
#line 521
  tmp___0 = get_dcell(sp);
#line 521
  ud = (unsigned long long )tmp___0;
#line 522
  *(sp + 1) = (int )(ud % (unsigned long long )u1);
#line 523
  *(sp + 0) = (int )(ud / (unsigned long long )u1);
  }
#line 524
  return;
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _xor(void) 
{ 


  {
#line 527
  *(sp + 1) ^= *(sp + 0);
#line 528
  sp ++;
#line 529
  return;
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _do_literal(void) 
{ 
  pfp *tmp ;

  {
#line 532
  sp --;
#line 532
  tmp = ip;
#line 532
  ip ++;
#line 532
  *sp = (int )*tmp;
#line 533
  return;
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _do_fliteral(void) 
{ 


  {
#line 536
  fp --;
#line 536
  *fp = *((float *)ip);
#line 537
  ip += sizeof(float ) / sizeof(int );
#line 538
  return;
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _word(void) 
{ 
  register char *addr ;
  register char delim ;
  register int i ;
  register int j ;
  char tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 542
  delim = (char )*sp;
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    if (_to_in < _in_input_buffer) {
#line 544
      if (! ((int )*(_input_buffer + _to_in) == (int )delim)) {
#line 544
        goto while_break;
      }
    } else {
#line 544
      goto while_break;
    }
#line 544
    _to_in ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 545
  _parse();
#line 546
  tmp___0 = sp;
#line 546
  sp ++;
#line 546
  tmp = (char )*tmp___0;
#line 546
  *_dp = tmp;
#line 546
  i = (int )tmp;
#line 547
  addr = (char *)*sp;
#line 548
  j = 0;
  }
  {
#line 548
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 548
    if (! (j < i)) {
#line 548
      goto while_break___0;
    }
#line 548
    tmp___1 = addr;
#line 548
    addr ++;
#line 548
    *((_dp + j) + 1) = *tmp___1;
#line 548
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 549
  *((_dp + i) + 1) = (char )' ';
#line 550
  *sp = (int )_dp;
#line 551
  return;
}
}
#line 553 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _to_number(void) 
{ 
  register unsigned int u1 ;
  register char *addr ;
  register unsigned long long ud1 ;
  long long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 554
  u1 = (unsigned int )*sp;
#line 555
  addr = (char *)*(sp + 1);
#line 556
  tmp = get_dcell(sp + 2);
#line 556
  ud1 = (unsigned long long )tmp;
  }
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 557
    tmp___1 = is_base_digit(*addr);
    }
#line 557
    if (tmp___1) {
#line 557
      if (! u1) {
#line 557
        goto while_break;
      }
    } else {
#line 557
      goto while_break;
    }
#line 558
    ud1 *= (unsigned long long )_base;
#line 559
    if ((int )*addr <= 57) {
#line 559
      ud1 += (unsigned long long )((int )*addr - 48);
    } else {
      {
#line 560
      tmp___0 = toupper((int )*addr);
#line 560
      ud1 += (unsigned long long )((tmp___0 - 65) + 10);
      }
    }
#line 561
    addr ++;
#line 562
    u1 --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 564
  put_dcell(sp + 2, (long long )ud1);
#line 565
  *(sp + 1) = (int )addr;
#line 566
  *sp = (int )u1;
  }
#line 567
  return;
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _read_const(void) 
{ 
  register int n ;
  register int usign ;
  register unsigned long long num ;
  register int const_type ;
  register char *orig ;
  register int orig_len ;
  int *tmp ;
  long long tmp___0 ;

  {
#line 571
  usign = 1;
#line 573
  const_type = 1;
#line 574
  orig = (char *)*(sp + 1);
#line 575
  orig_len = *(sp + 0);
#line 576
  if (*(sp + 0)) {
#line 576
    if ((int )*((char *)*(sp + 1)) == 45) {
#line 577
      usign = -1;
#line 578
      *(sp + 1) = (int )((unsigned long )*(sp + 1) + sizeof(char ));
#line 579
      (*(sp + 0)) --;
    }
  }
  {
#line 581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 581
    if (! *(sp + 0)) {
#line 581
      goto while_break;
    }
    {
#line 582
    _to_number();
    }
#line 583
    if (*(sp + 0)) {
#line 583
      if ((int )*((char *)*(sp + 1)) == 46) {
#line 584
        const_type = 2;
#line 585
        (*(sp + 0)) --;
#line 586
        *(sp + 1) = (int )((unsigned long )*(sp + 1) + sizeof(char ));
      } else {
#line 587
        goto while_break;
      }
    } else {
#line 587
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 589
  tmp = sp;
#line 589
  sp ++;
#line 589
  n = *tmp;
#line 590
  tmp___0 = get_dcell(sp + 1);
#line 590
  num = (unsigned long long )tmp___0;
  }
#line 591
  if (usign < 0) {
    {
#line 592
    num = - num;
#line 593
    put_dcell(sp + 1, (long long )num);
    }
  }
#line 595
  if (! n) {
#line 595
    *sp = const_type;
  } else
#line 598
  if (_base == 10) {
    {
#line 599
    sp ++;
#line 600
    *(sp + 1) = (int )orig;
#line 601
    *(sp + 0) = orig_len;
#line 602
    _to_float();
    }
#line 603
    if (*sp) {
#line 603
      *(sp + 0) = 3;
    }
  } else {
#line 604
    *sp = 0;
  }
#line 609
  return;
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _interpret(void) 
{ 
  register struct word_def *xt ;
  register unsigned long long num ;
  int *tmp ;
  long long tmp___0 ;
  long long tmp___1 ;

  {
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if (! _error) {
#line 613
      if (! (_to_in < _in_input_buffer)) {
#line 613
        goto while_break;
      }
    } else {
#line 613
      goto while_break;
    }
    {
#line 614
    sp --;
#line 614
    *sp = ' ';
#line 615
    _word();
#line 616
    sp ++;
    }
#line 617
    if (! *_dp) {
#line 617
      goto while_continue;
    }
    {
#line 618
    xt = search_word(_dp + 1, (int )*_dp);
    }
#line 619
    if (xt) {
#line 620
      if (_state == 0) {
#line 621
        if (xt->class & 256) {
#line 621
          _error = -3;
        } else {
          {
#line 622
          exec_word(xt);
          }
        }
      } else
#line 624
      if (xt->class & 512) {
        {
#line 624
        exec_word(xt);
        }
      } else {
        {
#line 625
        compile_word(xt);
        }
      }
    } else {
      {
#line 629
      sp --;
#line 629
      *sp = 0;
#line 630
      sp --;
#line 630
      *sp = 0;
#line 631
      sp --;
#line 631
      *sp = (int )(_dp + sizeof(char ));
#line 632
      sp --;
#line 632
      *sp = (int )*_dp;
#line 633
      _read_const();
      }
#line 634
      if (! *sp) {
#line 635
        sp ++;
#line 636
        _error = -2;
      } else {
#line 638
        tmp = sp;
#line 638
        sp ++;
        {
#line 639
        if (*tmp == 1) {
#line 639
          goto case_1;
        }
#line 648
        if (*tmp == 2) {
#line 648
          goto case_2;
        }
#line 658
        if (*tmp == 3) {
#line 658
          goto case_3;
        }
#line 638
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 640
        tmp___0 = get_dcell(sp);
#line 640
        num = (unsigned long long )tmp___0;
        }
#line 641
        if (_state == 0) {
#line 641
          sp ++;
        } else {
#line 643
          sp += 2;
#line 644
          *((int *)_dp) = (int )(& _do_literal);
#line 644
          _dp += sizeof(int );
#line 645
          *((int *)_dp) = (int )num;
#line 645
          _dp += sizeof(int );
        }
#line 647
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 649
        tmp___1 = get_dcell(sp);
#line 649
        num = (unsigned long long )tmp___1;
        }
#line 650
        if (_state == -1) {
#line 651
          sp += 2;
#line 652
          *((int *)_dp) = (int )(& _do_literal);
#line 652
          _dp += sizeof(int );
#line 653
          *((int *)_dp) = (int )num;
#line 653
          _dp += sizeof(int );
#line 654
          *((int *)_dp) = (int )(& _do_literal);
#line 654
          _dp += sizeof(int );
#line 655
          *((int *)_dp) = (int )(num >> sizeof(int ) * 8UL);
#line 655
          _dp += sizeof(int );
        }
#line 657
        goto switch_break;
        case_3: /* CIL Label */ 
#line 659
        if (_state == -1) {
#line 660
          *((int *)_dp) = (int )(& _do_fliteral);
#line 660
          _dp += sizeof(int );
#line 661
          *((float *)_dp) = *fp;
#line 661
          _dp += sizeof(float );
#line 662
          fp ++;
        }
#line 664
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 669
  return;
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _accept(void) 
{ 
  register int n1 ;
  int *tmp ;
  register char *addr ;
  register int i ;
  register char ch ;
  int tmp___0 ;

  {
#line 672
  tmp = sp;
#line 672
  sp ++;
#line 672
  n1 = *tmp;
#line 673
  addr = (char *)*sp;
#line 674
  i = 0;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 677
    tmp___0 = getchar();
#line 677
    ch = (char )tmp___0;
#line 678
    i = process_char(addr, n1, i, ch);
    }
#line 676
    if (! ((int )ch != 10)) {
#line 676
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  *sp = i;
#line 681
  return;
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _source(void) 
{ 


  {
#line 684
  sp --;
#line 684
  *sp = (int )_input_buffer;
#line 685
  sp --;
#line 685
  *sp = _in_input_buffer;
#line 686
  return;
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _paren(void) 
{ 
  register int eof ;
  int *tmp ;
  int tmp___0 ;

  {
#line 689
  eof = 1;
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 691
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 691
      if (_to_in < _in_input_buffer) {
#line 691
        if (! ((int )*(_input_buffer + _to_in) != 41)) {
#line 691
          goto while_break___0;
        }
      } else {
#line 691
        goto while_break___0;
      }
#line 691
      _to_in ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 692
    if (_source_id != 0) {
#line 692
      if (_source_id != -1) {
#line 692
        if (_to_in == _in_input_buffer) {
          {
#line 693
          _refill();
#line 694
          tmp = sp;
#line 694
          sp ++;
          }
#line 694
          if (*tmp) {
#line 694
            tmp___0 = 0;
          } else {
#line 694
            tmp___0 = 1;
          }
#line 694
          eof = tmp___0;
        }
      }
    }
#line 690
    if (_to_in == _in_input_buffer) {
#line 690
      if (! (! eof)) {
#line 690
        goto while_break;
      }
    } else {
#line 690
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  if (_to_in < _in_input_buffer) {
#line 697
    _to_in ++;
  }
#line 698
  return;
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _evaluate(void) 
{ 
  register int u ;
  int *tmp ;
  register char *addr ;
  int *tmp___0 ;

  {
  {
#line 701
  tmp = sp;
#line 701
  sp ++;
#line 701
  u = *tmp;
#line 702
  tmp___0 = sp;
#line 702
  sp ++;
#line 702
  addr = (char *)*tmp___0;
#line 703
  save_input_specification();
#line 704
  _source_id = -1;
#line 705
  _in_input_buffer = u;
#line 706
  _input_buffer = addr;
#line 707
  _to_in = 0;
#line 708
  _b_l_k = 0U;
#line 709
  _interpret();
#line 710
  restore_input_specification();
  }
#line 711
  return;
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
static struct an_error err_msg[19]  = 
#line 714
  {      {(char *)"everything allright", (char)0, (char)0}, 
        {(char *)"no input avaliable", (char)0, (char)0}, 
        {(char *)"unknown word", (char)0, (char)1}, 
        {(char *)"word must be compiled", (char)0, (char)1}, 
        {(char *)"corrupted dictionary", (char)1, (char)0}, 
        {(char *)"not enough memory", (char)0, (char)0}, 
        {(char *)"data-stack underflow", (char)1, (char)0}, 
        {(char *)"data-stack overflow", (char)1, (char)0}, 
        {(char *)"return-stack underflow", (char)1, (char)0}, 
        {(char *)"return-stack overflow", (char)1, (char)0}, 
        {(char *)"floating-stack underflow", (char)1, (char)0}, 
        {(char *)"floating-stack overflow", (char)1, (char)0}, 
        {(char *)"data-space corrupted", (char)1, (char)0}, 
        {(char *)"data-space exhausted", (char)1, (char)0}, 
        {(char *)"unable to access image file", (char)0, (char)0}, 
        {(char *)"primitive not implemented", (char)0, (char)1}, 
        {(char *)"floating-point/math exception", (char)0, (char)0}, 
        {(char *)"segmentation fault", (char)0, (char)0}, 
        {(char *)"file not found", (char)0, (char)0}};
#line 713 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _view_error_msg(void) 
{ 


  {
#line 739
  if (err_msg[- _error].print_word) {
    {
#line 740
    putchar('[');
#line 741
    sp --;
#line 741
    *sp = (int )_dp;
#line 742
    _count();
#line 743
    _type();
#line 744
    printf((char const   */* __restrict  */)"] ");
    }
  }
  {
#line 746
  printf((char const   */* __restrict  */)"error(%d): %s.\n", - _error, err_msg[- _error].msg);
  }
#line 747
  if (err_msg[- _error].please_abort) {
    {
#line 748
    printf((char const   */* __restrict  */)"Aborting...\n");
#line 749
    _abort();
    }
  }
#line 751
  return;
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _quit(void) 
{ 
  int *tmp ;

  {
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
#line 755
    rp = rp_top;
#line 756
    _source_id = 0;
#line 757
    _input_buffer = _tib;
#line 758
    _state = 0;
#line 759
    _error = 0;
    {
#line 760
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 760
      if (! (_error == 0)) {
#line 760
        goto while_break___0;
      }
      {
#line 761
      _refill();
#line 762
      tmp = sp;
#line 762
      sp ++;
      }
#line 762
      if (*tmp) {
        {
#line 763
        _to_in = 0;
#line 764
        _interpret();
        }
#line 765
        if (_state == 0) {
#line 765
          if (! _error) {
            {
#line 765
            printf((char const   */* __restrict  */)"ok\n");
            }
          } else {
#line 765
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 766
        if (_state == -1) {
          {
#line 766
          printf((char const   */* __restrict  */)"ko ");
          }
        }
      } else {
#line 767
        _error = -1;
      }
#line 768
      if (_error == 0) {
#line 768
        if (_check_system) {
          {
#line 768
          check_system();
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 770
    _view_error_msg();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 774 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _comma(void) 
{ 
  int *tmp ;

  {
#line 775
  tmp = sp;
#line 775
  sp ++;
#line 775
  *((int *)_dp) = *tmp;
#line 776
  _dp += sizeof(int );
#line 777
  return;
}
}
#line 779 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _allot(void) 
{ 
  int *tmp ;

  {
#line 780
  tmp = sp;
#line 780
  sp ++;
#line 780
  _dp += *tmp;
#line 781
  return;
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _c_comma(void) 
{ 
  char *tmp ;
  int *tmp___0 ;

  {
#line 784
  tmp = _dp;
#line 784
  _dp ++;
#line 784
  tmp___0 = sp;
#line 784
  sp ++;
#line 784
  *tmp = (char )*tmp___0;
#line 785
  return;
}
}
#line 787 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _here(void) 
{ 


  {
#line 788
  sp --;
#line 788
  *sp = (int )_dp;
#line 789
  return;
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _do_exit(void) 
{ 


  {
#line 792
  ip = (pfp *)0;
#line 793
  return;
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _exit_imm(void) 
{ 


  {
  {
#line 796
  clear_locals();
#line 797
  *((int *)_dp) = (int )(& _do_exit);
#line 797
  _dp += sizeof(int );
  }
#line 798
  return;
}
}
#line 800 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _paren_do_colon_paren(void) 
{ 
  pfp *tmp ;
  int *tmp___0 ;

  {
#line 801
  rp --;
#line 801
  *rp = (int )(ip + 1);
#line 802
  ip = (pfp *)*ip;
  {
#line 803
  while (1) {
    while_continue: /* CIL Label */ ;
#line 803
    if (! ip) {
#line 803
      goto while_break;
    }
    {
#line 803
    tmp = ip;
#line 803
    ip ++;
#line 803
    (*(*tmp))();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 804
  tmp___0 = rp;
#line 804
  rp ++;
#line 804
  ip = (pfp *)*tmp___0;
#line 805
  return;
}
}
#line 807 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _colon(void) 
{ 


  {
  {
#line 808
  create_definition(3);
#line 809
  _state = -1;
#line 810
  init_locals();
  }
#line 811
  return;
}
}
#line 813 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _variable(void) 
{ 


  {
  {
#line 814
  create_definition(2);
#line 815
  *((int *)_dp) = 0;
#line 815
  _dp += sizeof(int );
#line 816
  mark_word(_last);
  }
#line 817
  return;
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _constant(void) 
{ 
  register int x ;
  int *tmp ;

  {
  {
#line 820
  tmp = sp;
#line 820
  sp ++;
#line 820
  x = *tmp;
#line 821
  create_definition(4);
#line 822
  *((int *)_dp) = x;
#line 822
  _dp += sizeof(int );
#line 823
  mark_word(_last);
  }
#line 824
  return;
}
}
#line 826 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _create(void) 
{ 


  {
  {
#line 827
  create_definition(7);
#line 828
  *((int *)_dp) = 0;
#line 828
  _dp += sizeof(int );
#line 829
  mark_word(_last);
  }
#line 830
  return;
}
}
#line 832 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _does(void) 
{ 


  {
  {
#line 833
  *((int *)_dp) = (int )(& _paren_does_paren);
#line 833
  _dp += sizeof(int );
#line 834
  _exit_imm();
#line 835
  mark_word(_last);
#line 836
  init_locals();
  }
#line 837
  return;
}
}
#line 839 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _paren_does_paren(void) 
{ 


  {
#line 840
  _last->func[0] = (void (*)(void))(ip + 1);
#line 841
  return;
}
}
#line 843 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _semi_colon(void) 
{ 


  {
  {
#line 844
  _exit_imm();
#line 845
  _state = 0;
#line 846
  mark_word(_last);
  }
#line 847
  return;
}
}
#line 849 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _zero_branch(void) 
{ 
  int *tmp ;

  {
#line 850
  tmp = sp;
#line 850
  sp ++;
#line 850
  if (*tmp) {
#line 850
    ip ++;
  } else {
#line 851
    ip += 1 + (int )*ip;
  }
#line 852
  return;
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _branch(void) 
{ 


  {
#line 855
  ip += 1 + (int )*ip;
#line 856
  return;
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _if(void) 
{ 


  {
#line 859
  *((int *)_dp) = (int )(& _zero_branch);
#line 859
  _dp += sizeof(int );
#line 860
  sp --;
#line 860
  *sp = (int )_dp;
#line 861
  *((int *)_dp) = 0;
#line 861
  _dp += sizeof(int );
#line 862
  return;
}
}
#line 864 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _then(void) 
{ 
  register int *patch ;
  int *tmp ;

  {
#line 865
  tmp = sp;
#line 865
  sp ++;
#line 865
  patch = (int *)*tmp;
#line 866
  *patch = (int )(((int *)_dp - patch) - 1L);
#line 867
  return;
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _else(void) 
{ 


  {
  {
#line 870
  _ahead();
#line 871
  sp --;
#line 871
  *sp = 1;
#line 872
  _roll();
#line 873
  _then();
  }
#line 874
  return;
}
}
#line 876 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _begin(void) 
{ 


  {
#line 877
  sp --;
#line 877
  *sp = (int )_dp;
#line 878
  return;
}
}
#line 880 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _do(void) 
{ 


  {
#line 881
  *((int *)_dp) = (int )(& _paren_do_paren);
#line 881
  _dp += sizeof(int );
#line 882
  sp --;
#line 882
  *sp = (int )_dp;
#line 883
  sp --;
#line 883
  *sp = 0;
#line 884
  return;
}
}
#line 886 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _paren_do_paren(void) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
#line 887
  rp --;
#line 887
  tmp = sp;
#line 887
  sp ++;
#line 887
  *rp = *tmp;
#line 888
  rp --;
#line 888
  tmp___0 = sp;
#line 888
  sp ++;
#line 888
  *rp = *tmp___0;
#line 890
  return;
}
}
#line 892 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _loop(void) 
{ 
  register int q_do ;
  int *tmp ;
  register int *dest ;
  int *tmp___0 ;
  register int *patch ;
  int *tmp___1 ;

  {
#line 893
  tmp = sp;
#line 893
  sp ++;
#line 893
  q_do = *tmp;
#line 894
  tmp___0 = sp;
#line 894
  sp ++;
#line 894
  dest = (int *)*tmp___0;
#line 895
  *((int *)_dp) = (int )(& _paren_loop_paren);
#line 895
  _dp += sizeof(int );
#line 896
  *((int *)_dp) = (int )((dest - (int *)_dp) - 1L);
#line 896
  _dp += sizeof(int );
#line 897
  if (q_do) {
#line 898
    tmp___1 = sp;
#line 898
    sp ++;
#line 898
    patch = (int *)*tmp___1;
#line 899
    *patch = (int )(((int *)_dp - patch) - 1L);
  }
#line 901
  return;
}
}
#line 903 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _paren_loop_paren(void) 
{ 


  {
#line 904
  (*(rp + 1)) ++;
#line 904
  if (*(rp + 0) == *(rp + 1)) {
#line 905
    ip ++;
#line 906
    rp += 2;
  } else {
#line 907
    ip += 1 + (int )*ip;
  }
#line 908
  return;
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _i(void) 
{ 


  {
#line 911
  sp --;
#line 911
  *sp = *(rp + 1);
#line 912
  return;
}
}
#line 914 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _j(void) 
{ 


  {
#line 915
  sp --;
#line 915
  *sp = *(rp + 3);
#line 916
  return;
}
}
#line 918 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _plus_loop(void) 
{ 
  register int q_do ;
  int *tmp ;
  register int *dest ;
  int *tmp___0 ;
  register int *patch ;
  int *tmp___1 ;

  {
#line 919
  tmp = sp;
#line 919
  sp ++;
#line 919
  q_do = *tmp;
#line 920
  tmp___0 = sp;
#line 920
  sp ++;
#line 920
  dest = (int *)*tmp___0;
#line 921
  *((int *)_dp) = (int )(& _paren_plus_loop_paren);
#line 921
  _dp += sizeof(int );
#line 922
  *((int *)_dp) = (int )((dest - (int *)_dp) - 1L);
#line 922
  _dp += sizeof(int );
#line 923
  if (q_do) {
#line 924
    tmp___1 = sp;
#line 924
    sp ++;
#line 924
    patch = (int *)*tmp___1;
#line 925
    *patch = (int )(((int *)_dp - patch) - 1L);
  }
#line 927
  return;
}
}
#line 929 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _paren_plus_loop_paren(void) 
{ 
  register int old_index ;
  int *tmp ;

  {
#line 930
  old_index = *rp;
#line 931
  tmp = sp;
#line 931
  sp ++;
#line 931
  *(rp + 1) += *tmp;
#line 932
  if (old_index < *(rp + 1)) {
#line 932
    if (*(rp + 0) >= *(rp + 1)) {
#line 933
      ip ++;
#line 934
      rp += 2;
    } else {
#line 935
      ip += 1 + (int )*ip;
    }
  } else {
#line 935
    ip += 1 + (int )*ip;
  }
#line 936
  return;
}
}
#line 938 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _find(void) 
{ 
  register char *addr ;
  register int len ;
  char *tmp ;
  register struct word_def *xt ;
  struct word_def *tmp___0 ;

  {
  {
#line 939
  addr = (char *)*sp;
#line 940
  tmp = addr;
#line 940
  addr ++;
#line 940
  len = (int )*tmp;
#line 941
  tmp___0 = search_word(addr, len);
#line 941
  xt = tmp___0;
#line 942
  set_find_stack(addr, xt);
  }
#line 943
  return;
}
}
#line 945 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _recurse(void) 
{ 


  {
#line 946
  *((int *)_dp) = (int )(& _paren_do_colon_paren);
#line 946
  _dp += sizeof(int );
#line 947
  *((int *)_dp) = (int )(& _last->func[0]);
#line 947
  _dp += sizeof(int );
#line 948
  return;
}
}
#line 950 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _tick(void) 
{ 
  register char *addr ;
  int tmp ;
  struct word_def *tmp___0 ;

  {
  {
#line 952
  sp --;
#line 952
  *sp = ' ';
#line 953
  _word();
#line 954
  addr = (char *)*sp;
#line 955
  tmp___0 = search_word(addr + 1, (int )*addr);
#line 955
  tmp = (int )tmp___0;
#line 955
  *sp = tmp;
  }
#line 955
  if (! tmp) {
#line 955
    _error = -2;
  }
#line 956
  return;
}
}
#line 958 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _to_body(void) 
{ 


  {
#line 959
  *sp = (int )(& ((struct word_def *)*sp)->func[0]);
#line 960
  return;
}
}
#line 962 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _abort(void) 
{ 


  {
  {
#line 963
  sp --;
#line 963
  *sp = -1;
#line 964
  _throw();
  }
#line 965
  return;
}
}
#line 967 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _abort_quote(void) 
{ 


  {
  {
#line 968
  _if();
#line 969
  _s_quote();
#line 970
  *((int *)_dp) = (int )(& _do_literal);
#line 970
  _dp += sizeof(int );
#line 971
  *((int *)_dp) = -2;
#line 971
  _dp += sizeof(int );
#line 972
  *((int *)_dp) = (int )(& _throw);
#line 972
  _dp += sizeof(int );
#line 973
  _then();
  }
#line 974
  return;
}
}
#line 976 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _count(void) 
{ 
  register char *addr ;

  {
#line 977
  addr = (char *)*sp;
#line 978
  sp --;
#line 979
  *(sp + 0) = (int )*addr;
#line 980
  (*(sp + 1)) ++;
#line 981
  return;
}
}
#line 983 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _decimal(void) 
{ 


  {
#line 984
  _base = 10;
#line 985
  return;
}
}
#line 990 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
static struct __anonstruct_kw_27 kw[41]  = 
#line 990
  {      {(char *)"/COUNTED-STRING", & _env_slash_counted_string}, 
        {(char *)"/HOLD", & _env_slash_hold}, 
        {(char *)"/PAD", & _env_slash_pad}, 
        {(char *)"ADDRESS-UNIT-BITS", & _env_address_unit_bits}, 
        {(char *)"CORE", & _env_core}, 
        {(char *)"CORE-EXT", & _env_core_ext}, 
        {(char *)"FLOORED", & _env_floored}, 
        {(char *)"MAX-CHAR", & _env_max_char}, 
        {(char *)"MAX-D", & _env_max_d}, 
        {(char *)"MAX-N", & _env_max_n}, 
        {(char *)"MAX-U", & _env_max_u}, 
        {(char *)"MAX-UD", & _env_max_ud}, 
        {(char *)"RETURN-STACK-CELLS", & _env_return_stack_cells}, 
        {(char *)"STACK-CELLS", & _env_stack_cells}, 
        {(char *)"DOUBLE", & _env_double}, 
        {(char *)"DOUBLE-EXT", & _env_double_ext}, 
        {(char *)"FLOATING", & _env_floating}, 
        {(char *)"FLOATING-STACK", & _env_floating_stack}, 
        {(char *)"MAX-FLOAT", & _env_max_float}, 
        {(char *)"FLOATING-EXT", & _env_floating_ext}, 
        {(char *)"MEMORY-ALLOC", & _env_memory_alloc}, 
        {(char *)"MEMORY-ALLOC-EXT", & _env_memory_alloc_ext}, 
        {(char *)"SEARCH-ORDER", & _env_search_order}, 
        {(char *)"WORDLISTS", & _env_wordlists}, 
        {(char *)"SEARCH-ORDER-EXT", & _env_search_order_ext}, 
        {(char *)"TOOLS", & _env_tools}, 
        {(char *)"TOOLS-EXT", & _env_tools_ext}, 
        {(char *)"#LOCALS", & _env_number_locals}, 
        {(char *)"LOCALS", & _env_locals}, 
        {(char *)"LOCALS-EXT", & _env_locals_ext}, 
        {(char *)"FACILITY", & _env_facility}, 
        {(char *)"FACILITY-EXT", & _env_facility_ext}, 
        {(char *)"BLOCK", & _env_block}, 
        {(char *)"BLOCK-EXT", & _env_block_ext}, 
        {(char *)"EXCEPTION", & _env_exception}, 
        {(char *)"EXCEPTION-EXT", & _env_exception_ext}, 
        {(char *)"FILE", & _env_file}, 
        {(char *)"FILE-EXT", & _env_file_ext}, 
        {(char *)"STRING", & _env_string}, 
        {(char *)"STRING-EXT", & _env_string_ext}, 
        {(char *)((void *)0), (int *)((void *)0)}};
#line 987 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _environment_query(void) 
{ 
  register int len ;
  int *tmp ;
  register char *addr ;
  int *tmp___0 ;
  register int i ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 988
  tmp = sp;
#line 988
  sp ++;
#line 988
  len = *tmp;
#line 989
  tmp___0 = sp;
#line 989
  sp ++;
#line 989
  addr = (char *)*tmp___0;
#line 1036
  i = 0;
#line 1037
  i = 0;
  {
#line 1037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1037
    if (! (i < len)) {
#line 1037
      goto while_break;
    }
    {
#line 1037
    tmp___1 = toupper((int )*(addr + i));
#line 1037
    *(addr + i) = (char )tmp___1;
#line 1037
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1038
  i = 0;
  {
#line 1039
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1039
    if (kw[i].name) {
      {
#line 1039
      tmp___2 = memcmp((void const   *)addr, (void const   *)kw[i].name, (size_t )len);
      }
#line 1039
      if (! tmp___2) {
#line 1039
        goto while_break___0;
      }
    } else {
#line 1039
      goto while_break___0;
    }
#line 1039
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1040
  if (kw[i].name) {
    {
#line 1041
    tmp___4 = strcmp((char const   *)(kw[i].name + 1), "MAX-UD");
    }
#line 1041
    if (tmp___4) {
      {
#line 1044
      tmp___3 = strcmp((char const   *)(kw[i].name + 1), "MAX-FLOAT");
      }
#line 1044
      if (tmp___3) {
#line 1046
        sp --;
#line 1046
        *sp = *(kw[i].var);
      } else {
#line 1045
        fp --;
#line 1045
        *fp = (float )0.0;
      }
    } else {
      {
#line 1042
      sp -= 2;
#line 1043
      put_dcell(sp, -1LL);
      }
    }
#line 1047
    sp --;
#line 1047
    *sp = -1;
  } else {
#line 1048
    sp --;
#line 1048
    *sp = 0;
  }
#line 1049
  return;
}
}
#line 1051 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _execute(void) 
{ 
  int *tmp ;

  {
  {
#line 1052
  tmp = sp;
#line 1052
  sp ++;
#line 1052
  exec_word((struct word_def *)*tmp);
  }
#line 1053
  return;
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _fill(void) 
{ 
  register int c ;
  int *tmp ;
  register unsigned int u ;
  int *tmp___0 ;
  register char *addr ;
  int *tmp___1 ;

  {
#line 1056
  tmp = sp;
#line 1056
  sp ++;
#line 1056
  c = *tmp;
#line 1057
  tmp___0 = sp;
#line 1057
  sp ++;
#line 1057
  u = (unsigned int )*tmp___0;
#line 1058
  tmp___1 = sp;
#line 1058
  sp ++;
#line 1058
  addr = (char *)*tmp___1;
#line 1059
  if (u) {
    {
#line 1059
    memset((void *)addr, c, (size_t )u);
    }
  }
#line 1060
  return;
}
}
#line 1062 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _immediate(void) 
{ 


  {
#line 1063
  _last->class |= 512;
#line 1064
  return;
}
}
#line 1066 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _key(void) 
{ 
  char tmp ;

  {
  {
#line 1067
  sp --;
#line 1067
  tmp = d_getch();
#line 1067
  *sp = (int )tmp;
  }
#line 1068
  return;
}
}
#line 1070 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _leave(void) 
{ 


  {
#line 1071
  rp += 2;
  {
#line 1072
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1072
    if ((unsigned long )*ip != (unsigned long )(& _paren_loop_paren)) {
#line 1072
      if (! ((unsigned long )*ip != (unsigned long )(& _paren_plus_loop_paren))) {
#line 1072
        goto while_break;
      }
    } else {
#line 1072
      goto while_break;
    }
#line 1072
    ip ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1073
  ip += 2;
#line 1074
  return;
}
}
#line 1076 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _literal(void) 
{ 


  {
#line 1077
  *((int *)_dp) = (int )(& _do_literal);
#line 1077
  _dp += sizeof(int );
#line 1078
  *((int *)_dp) = *(sp + 0);
#line 1078
  _dp += sizeof(int );
#line 1079
  sp ++;
#line 1080
  return;
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _move(void) 
{ 
  register unsigned int u ;
  int *tmp ;
  register char *dest ;
  int *tmp___0 ;
  register char *source ;
  int *tmp___1 ;

  {
#line 1083
  tmp = sp;
#line 1083
  sp ++;
#line 1083
  u = (unsigned int )*tmp;
#line 1084
  tmp___0 = sp;
#line 1084
  sp ++;
#line 1084
  dest = (char *)*tmp___0;
#line 1085
  tmp___1 = sp;
#line 1085
  sp ++;
#line 1085
  source = (char *)*tmp___1;
#line 1086
  if (u) {
    {
#line 1086
    memmove((void *)dest, (void const   *)source, (size_t )u);
    }
  }
#line 1087
  return;
}
}
#line 1089 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _postpone(void) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 1090
  sp --;
#line 1090
  *sp = ' ';
#line 1091
  _word();
#line 1092
  _find();
#line 1093
  tmp___0 = sp;
#line 1093
  sp ++;
  }
#line 1093
  if (*tmp___0 > 0) {
    {
#line 1094
    tmp = sp;
#line 1094
    sp ++;
#line 1094
    compile_word((struct word_def *)*tmp);
    }
  } else {
#line 1096
    *((int *)_dp) = (int )(& _paren_compile_paren);
#line 1096
    _dp += sizeof(int );
#line 1097
    *((int *)_dp) = *(sp + 0);
#line 1097
    _dp += sizeof(int );
#line 1098
    sp ++;
  }
#line 1100
  return;
}
}
#line 1102 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _paren_compile_paren(void) 
{ 
  int *tmp ;

  {
  {
#line 1103
  tmp = sp;
#line 1103
  sp ++;
#line 1103
  compile_word((struct word_def *)*tmp);
  }
#line 1104
  return;
}
}
#line 1106 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _s_quote(void) 
{ 


  {
#line 1107
  if (_state == 0) {
    {
#line 1108
    sp --;
#line 1108
    *sp = '\"';
#line 1109
    _word();
#line 1110
    memcpy((void */* __restrict  */)(s_tmp_buffer), (void const   */* __restrict  */)_dp,
           (size_t )((int )*_dp + 1));
#line 1111
    *(sp + 0) = (int )(s_tmp_buffer);
#line 1112
    _count();
    }
  } else {
    {
#line 1114
    _c_quote();
#line 1115
    *((int *)_dp) = (int )(& _count);
#line 1115
    _dp += sizeof(int );
    }
  }
#line 1117
  return;
}
}
#line 1119 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _sign(void) 
{ 
  char *tmp ;
  int *tmp___0 ;

  {
#line 1120
  tmp___0 = sp;
#line 1120
  sp ++;
#line 1120
  if (*tmp___0 < 0) {
#line 1121
    tmp = p_pnos;
#line 1121
    p_pnos --;
#line 1121
    *tmp = (char )'-';
#line 1122
    in_pnos ++;
  }
#line 1124
  return;
}
}
#line 1126 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _unloop(void) 
{ 


  {
#line 1127
  rp += 2;
#line 1128
  return;
}
}
#line 1130 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _left_bracket(void) 
{ 


  {
#line 1131
  _state = 0;
#line 1132
  return;
}
}
#line 1134 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _bracket_tick(void) 
{ 


  {
  {
#line 1135
  _tick();
#line 1136
  _literal();
  }
#line 1137
  return;
}
}
#line 1139 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _char(void) 
{ 


  {
  {
#line 1140
  sp --;
#line 1140
  *sp = ' ';
#line 1141
  _word();
#line 1142
  *(sp + 0) = (int )*(_dp + 1);
  }
#line 1143
  return;
}
}
#line 1145 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _bracket_char(void) 
{ 


  {
  {
#line 1146
  _char();
#line 1147
  _literal();
  }
#line 1148
  return;
}
}
#line 1150 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _right_bracket(void) 
{ 


  {
#line 1151
  _state = -1;
#line 1152
  return;
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _while(void) 
{ 


  {
  {
#line 1155
  _if();
#line 1156
  sp --;
#line 1156
  *sp = 1;
#line 1157
  _roll();
  }
#line 1158
  return;
}
}
#line 1160 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _repeat(void) 
{ 


  {
  {
#line 1161
  _again();
#line 1162
  _then();
  }
#line 1163
  return;
}
}
#line 1165 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void _do_value(void) 
{ 
  pfp *tmp ;

  {
#line 1166
  sp --;
#line 1166
  tmp = ip;
#line 1166
  ip ++;
#line 1166
  *sp = *((int *)*tmp);
#line 1167
  return;
}
}
#line 1177 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
int strmatch(char const   *s1 , char const   *s2 , int len1 ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
#line 1178
  tmp___4 = s2;
#line 1178
  s2 ++;
#line 1178
  if (len1 != (int )*tmp___4) {
#line 1178
    return (1);
  } else {
    {
#line 1180
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1180
      tmp___3 = len1;
#line 1180
      len1 --;
#line 1180
      if (! tmp___3) {
#line 1180
        goto while_break;
      }
      {
#line 1180
      tmp = s1;
#line 1180
      s1 ++;
#line 1180
      tmp___0 = toupper((int )*tmp);
#line 1180
      tmp___1 = s2;
#line 1180
      s2 ++;
#line 1180
      tmp___2 = toupper((int )*tmp___1);
      }
#line 1180
      if (tmp___0 != tmp___2) {
#line 1180
        return (1);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1181
    return (0);
  }
}
}
#line 1188 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
struct word_def *search_wordlist(char *name , int len , struct vocabulary *wid ) 
{ 
  register struct word_def *p ;
  int tmp ;

  {
#line 1189
  p = wid->voc[len & 7];
  {
#line 1190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1190
    if (p) {
      {
#line 1190
      tmp = strmatch((char const   *)name, (char const   *)p->name, len);
      }
#line 1190
      if (! tmp) {
#line 1190
        goto while_break;
      }
    } else {
#line 1190
      goto while_break;
    }
#line 1190
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 1191
  return (p);
}
}
#line 1199 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
struct word_def *search_word(char *name , int len ) 
{ 
  register struct word_def *p ;
  register int ttop ;
  int tmp ;
  int tmp___0 ;
  struct vocabulary *tmp___1 ;

  {
  {
#line 1201
  ttop = top;
#line 1202
  tmp___0 = locals_defined();
  }
#line 1202
  if (tmp___0) {
    {
#line 1203
    p = get_first_local();
    }
    {
#line 1204
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1204
      if (p) {
        {
#line 1204
        tmp = strmatch((char const   *)name, (char const   *)p->name, len);
        }
#line 1204
        if (! tmp) {
#line 1204
          goto while_break;
        }
      } else {
#line 1204
        goto while_break;
      }
#line 1204
      p = p->link;
    }
    while_break: /* CIL Label */ ;
    }
#line 1205
    if (p) {
#line 1205
      return (p);
    }
  }
  {
#line 1207
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1207
    if (! (ttop >= 0)) {
#line 1207
      goto while_break___0;
    }
#line 1208
    if (ttop >= 0) {
#line 1208
      tmp___1 = list[ttop];
    } else {
#line 1208
      tmp___1 = forth_wid;
    }
    {
#line 1208
    p = search_wordlist(name, len, tmp___1);
    }
#line 1209
    if (p) {
#line 1209
      return (p);
    }
#line 1210
    ttop --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1212
  return ((struct word_def *)0);
}
}
#line 1218 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void ins_word(struct word_def *p ) 
{ 
  register int hash ;

  {
#line 1219
  hash = (int )*(p->name) & 7;
#line 1220
  p->link = voc->voc[hash];
#line 1221
  return;
}
}
#line 1226 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void mark_word(struct word_def *p ) 
{ 
  register int hash ;

  {
#line 1227
  hash = (int )*(p->name) & 7;
#line 1228
  voc->voc[hash] = p;
#line 1229
  return;
}
}
#line 1234 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void set_find_stack(char *addr , struct word_def *xt ) 
{ 


  {
#line 1235
  if (xt) {
#line 1236
    *sp = (int )xt;
#line 1237
    if (xt->class & 512) {
#line 1237
      sp --;
#line 1237
      *sp = 1;
    } else {
#line 1238
      sp --;
#line 1238
      *sp = -1;
    }
  } else {
#line 1240
    *sp = (int )addr;
#line 1241
    sp --;
#line 1241
    *sp = 0;
  }
#line 1243
  return;
}
}
#line 1248 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
int is_base_digit(char ch ) 
{ 
  int tmp ;

  {
  {
#line 1249
  tmp = toupper((int )ch);
#line 1249
  ch = (char )tmp;
  }
#line 1250
  if ((int )ch >= 48) {
#line 1250
    if ((int )ch <= 57) {
#line 1251
      if ((int )ch - 48 < _base) {
#line 1251
        return (1);
      } else {
#line 1252
        return (0);
      }
    }
  }
#line 1254
  if ((int )ch >= 65) {
#line 1254
    if ((int )ch <= 90) {
#line 1255
      if (((int )ch - 65) + 10 < _base) {
#line 1255
        return (1);
      } else {
#line 1256
        return (0);
      }
    }
  }
#line 1258
  return (0);
}
}
#line 1266 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
int process_char(char *addr , int max_len , int cur_pos , char ch ) 
{ 
  int tmp ;

  {
  {
#line 1268
  if ((int )ch == 8) {
#line 1268
    goto case_8;
  }
#line 1274
  goto switch_default;
  case_8: /* CIL Label */ 
#line 1269
  if (cur_pos) {
#line 1269
    cur_pos --;
  } else {
    {
#line 1270
    putchar('\a');
    }
  }
#line 1271
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1275
  if ((int )ch >= 32) {
#line 1276
    if (cur_pos < max_len) {
#line 1276
      tmp = cur_pos;
#line 1276
      cur_pos ++;
#line 1276
      *(addr + tmp) = ch;
    } else {
      {
#line 1277
      putchar('\a');
      }
    }
  }
#line 1279
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1281
  return (cur_pos);
}
}
#line 1289 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void create_definition(int class ) 
{ 
  register struct word_def *def ;
  register char *name ;

  {
  {
#line 1292
  sp --;
#line 1292
  *sp = ' ';
#line 1293
  name = _dp;
#line 1294
  _word();
#line 1295
  sp ++;
#line 1296
  _dp = (char *)(((unsigned long )((int )((_dp + (int )*_dp) + sizeof(char )) - 1) | (sizeof(int ) - 1UL)) + 1UL);
#line 1297
  _align();
#line 1298
  def = (struct word_def *)_dp;
#line 1299
  _last = def;
#line 1300
  def->name = name;
#line 1301
  def->class = class;
#line 1302
  ins_word(def);
#line 1303
  _dp += sizeof(struct word_def ) - sizeof(int );
  }
#line 1304
  return;
}
}
#line 1309 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void exec_colon(pfp *ip0 ) 
{ 
  register pfp *old_ip ;
  pfp *tmp ;

  {
#line 1310
  old_ip = ip;
#line 1311
  ip = ip0;
  {
#line 1312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1312
    if (! ip) {
#line 1312
      goto while_break;
    }
    {
#line 1312
    tmp = ip;
#line 1312
    ip ++;
#line 1312
    (*(*tmp))();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1313
  ip = old_ip;
#line 1314
  return;
}
}
#line 1318 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void exec_word(struct word_def *xt ) 
{ 


  {
  {
#line 1320
  if ((xt->class & 15) == 0) {
#line 1320
    goto case_0;
  }
#line 1323
  if ((xt->class & 15) == 2) {
#line 1323
    goto case_2;
  }
#line 1323
  if ((xt->class & 15) == 10) {
#line 1323
    goto case_2;
  }
#line 1323
  if ((xt->class & 15) == 6) {
#line 1323
    goto case_2;
  }
#line 1324
  if ((xt->class & 15) == 3) {
#line 1324
    goto case_3;
  }
#line 1327
  if ((xt->class & 15) == 4) {
#line 1327
    goto case_4;
  }
#line 1327
  if ((xt->class & 15) == 1) {
#line 1327
    goto case_4;
  }
#line 1327
  if ((xt->class & 15) == 12) {
#line 1327
    goto case_4;
  }
#line 1328
  if ((xt->class & 15) == 9) {
#line 1328
    goto case_9;
  }
#line 1332
  if ((xt->class & 15) == 5) {
#line 1332
    goto case_5;
  }
#line 1333
  if ((xt->class & 15) == 7) {
#line 1333
    goto case_7;
  }
#line 1337
  if ((xt->class & 15) == 8) {
#line 1337
    goto case_8;
  }
#line 1341
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1320
  (*(xt->func[0]))();
  }
#line 1320
  goto switch_break;
  case_2: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 1323
  sp --;
#line 1323
  *sp = (int )(& xt->func[0]);
#line 1323
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1324
  exec_colon(& xt->func[0]);
  }
#line 1324
  goto switch_break;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_12: /* CIL Label */ 
#line 1327
  sp --;
#line 1327
  *sp = (int )xt->func[0];
#line 1327
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1329
  sp --;
#line 1329
  *sp = (int )xt->func[0];
#line 1330
  sp --;
#line 1330
  *sp = (int )xt->func[1];
#line 1331
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1332
  fp --;
#line 1332
  *fp = *((float *)(& xt->func[0]));
#line 1332
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1334
  sp --;
#line 1334
  *sp = (int )(& xt->func[1]);
#line 1335
  if (xt->func[0]) {
    {
#line 1335
    exec_colon((pfp *)xt->func[0]);
    }
  }
#line 1336
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1338
  exec_marker((struct voc_marker *)(& xt->func[0]));
  }
#line 1339
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1341
  _error = -4;
#line 1341
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1343
  return;
}
}
#line 1347 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void compile_word(struct word_def *xt ) 
{ 


  {
  {
#line 1349
  if ((xt->class & 15) == 0) {
#line 1349
    goto case_0;
  }
#line 1354
  if ((xt->class & 15) == 6) {
#line 1354
    goto case_6;
  }
#line 1354
  if ((xt->class & 15) == 10) {
#line 1354
    goto case_6;
  }
#line 1354
  if ((xt->class & 15) == 2) {
#line 1354
    goto case_6;
  }
#line 1358
  if ((xt->class & 15) == 12) {
#line 1358
    goto case_12;
  }
#line 1363
  if ((xt->class & 15) == 4) {
#line 1363
    goto case_4;
  }
#line 1363
  if ((xt->class & 15) == 1) {
#line 1363
    goto case_4;
  }
#line 1367
  if ((xt->class & 15) == 9) {
#line 1367
    goto case_9;
  }
#line 1373
  if ((xt->class & 15) == 5) {
#line 1373
    goto case_5;
  }
#line 1377
  if ((xt->class & 15) == 3) {
#line 1377
    goto case_3;
  }
#line 1381
  if ((xt->class & 15) == 7) {
#line 1381
    goto case_7;
  }
#line 1389
  if ((xt->class & 15) == 11) {
#line 1389
    goto case_11;
  }
#line 1393
  if ((xt->class & 15) == 8) {
#line 1393
    goto case_8;
  }
#line 1397
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1350
  *((int *)_dp) = (int )xt->func[0];
#line 1350
  _dp += sizeof(int );
#line 1351
  goto switch_break;
  case_6: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1355
  *((int *)_dp) = (int )(& _do_literal);
#line 1355
  _dp += sizeof(int );
#line 1356
  *((int *)_dp) = (int )(& xt->func[0]);
#line 1356
  _dp += sizeof(int );
#line 1357
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1359
  *((int *)_dp) = (int )(& _do_value);
#line 1359
  _dp += sizeof(int );
#line 1360
  *((int *)_dp) = (int )(& xt->func[0]);
#line 1360
  _dp += sizeof(int );
#line 1361
  goto switch_break;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1364
  *((int *)_dp) = (int )(& _do_literal);
#line 1364
  _dp += sizeof(int );
#line 1365
  *((int *)_dp) = (int )xt->func[0];
#line 1365
  _dp += sizeof(int );
#line 1366
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1368
  *((int *)_dp) = (int )(& _do_literal);
#line 1368
  _dp += sizeof(int );
#line 1369
  *((int *)_dp) = (int )xt->func[0];
#line 1369
  _dp += sizeof(int );
#line 1370
  *((int *)_dp) = (int )(& _do_literal);
#line 1370
  _dp += sizeof(int );
#line 1371
  *((int *)_dp) = (int )xt->func[1];
#line 1371
  _dp += sizeof(int );
#line 1372
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1374
  *((int *)_dp) = (int )(& _do_fliteral);
#line 1374
  _dp += sizeof(int );
#line 1375
  *((float *)_dp) = *((float *)(& xt->func[0]));
#line 1375
  _dp += sizeof(float );
#line 1376
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1378
  *((int *)_dp) = (int )(& _paren_do_colon_paren);
#line 1378
  _dp += sizeof(int );
#line 1379
  *((int *)_dp) = (int )(& xt->func[0]);
#line 1379
  _dp += sizeof(int );
#line 1380
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1382
  *((int *)_dp) = (int )(& _do_literal);
#line 1382
  _dp += sizeof(int );
#line 1383
  *((int *)_dp) = (int )(& xt->func[1]);
#line 1383
  _dp += sizeof(int );
#line 1384
  if (xt->func[0]) {
#line 1385
    *((int *)_dp) = (int )(& _paren_do_colon_paren);
#line 1385
    _dp += sizeof(int );
#line 1386
    *((int *)_dp) = (int )xt->func[0];
#line 1386
    _dp += sizeof(int );
  }
#line 1388
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1390
  *((int *)_dp) = (int )(& _paren_read_local_paren);
#line 1390
  _dp += sizeof(int );
#line 1391
  *((int *)_dp) = (int )xt->func[0];
#line 1391
  _dp += sizeof(int );
#line 1392
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1394
  *((int *)_dp) = (int )(& _paren_marker_paren);
#line 1394
  _dp += sizeof(int );
#line 1395
  *((int *)_dp) = (int )(& xt->func[0]);
#line 1395
  _dp += sizeof(int );
#line 1396
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1397
  _error = -4;
#line 1397
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1399
  return;
}
}
#line 1405 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void save_input_specification(void) 
{ 
  register int dim ;
  register int dim1 ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 1407
  _save_input();
#line 1408
  tmp = sp;
#line 1408
  sp ++;
#line 1408
  dim = *tmp;
#line 1408
  dim1 = dim;
  }
  {
#line 1409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1409
    tmp___0 = dim;
#line 1409
    dim --;
#line 1409
    if (! tmp___0) {
#line 1409
      goto while_break;
    }
    {
#line 1409
    _to_r();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1410
  sp --;
#line 1410
  *sp = dim1;
#line 1411
  _to_r();
  }
#line 1412
  return;
}
}
#line 1418 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void restore_input_specification(void) 
{ 
  register int dim ;
  int *tmp ;
  register int dim1 ;
  int tmp___0 ;

  {
#line 1419
  tmp = rp;
#line 1419
  rp ++;
#line 1419
  dim = *tmp;
#line 1419
  dim1 = dim;
  {
#line 1420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1420
    tmp___0 = dim;
#line 1420
    dim --;
#line 1420
    if (! tmp___0) {
#line 1420
      goto while_break;
    }
    {
#line 1420
    _r_from();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1421
  sp --;
#line 1421
  *sp = dim1;
#line 1422
  _restore_input();
#line 1423
  sp ++;
  }
#line 1424
  return;
}
}
#line 1427 "/home/june/repo/benchmarks/collector/temp/yforth-0.2.1/core.c"
void check_system(void) 
{ 


  {
#line 1428
  if ((unsigned long )sp > (unsigned long )sp_top) {
#line 1428
    _error = -6;
  } else
#line 1429
  if ((unsigned long )sp < (unsigned long )sp_base) {
#line 1429
    _error = -7;
  } else
#line 1430
  if ((unsigned long )rp > (unsigned long )rp_top) {
#line 1430
    _error = -8;
  } else
#line 1431
  if ((unsigned long )rp < (unsigned long )rp_base) {
#line 1431
    _error = -9;
  } else
#line 1432
  if (fstack_size) {
#line 1432
    if ((unsigned long )fp > (unsigned long )fp_top) {
#line 1432
      _error = -10;
    } else {
#line 1432
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1433
  if (fstack_size) {
#line 1433
    if ((unsigned long )fp < (unsigned long )fp_base) {
#line 1433
      _error = -11;
    } else {
#line 1433
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1434
  if ((unsigned long )_dp < (unsigned long )dp0) {
#line 1434
    _error = -12;
  } else
#line 1435
  if ((unsigned long )_dp > (unsigned long )(dp0 + dspace_size)) {
#line 1435
    _error = -13;
  }
#line 1436
  return;
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
