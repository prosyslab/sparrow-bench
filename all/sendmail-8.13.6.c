/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 78 "../../include/sm/gen.h"
typedef unsigned int SM_ATOMIC_UINT_T;
#line 56 "../../include/sm/debug.h"
struct sm_debug;
#line 56 "../../include/sm/debug.h"
typedef struct sm_debug SM_DEBUG_T;
#line 57 "../../include/sm/debug.h"
struct sm_debug {
   char const   *sm_magic ;
   SM_ATOMIC_UINT_T debug_level ;
   char *debug_name ;
   char *debug_desc ;
   SM_DEBUG_T *debug_next ;
};
#line 214 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 182 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 58 "../../include/sm/gen.h"
typedef int bool;
#line 72 "../../include/sm/io.h"
struct smbuf {
   unsigned char *smb_base ;
   int smb_size ;
};
#line 103
struct sm_file;
#line 103 "../../include/sm/io.h"
typedef struct sm_file SM_FILE_T;
#line 105 "../../include/sm/io.h"
struct sm_file {
   char const   *sm_magic ;
   unsigned char *f_p ;
   int f_r ;
   int f_w ;
   long f_flags ;
   short f_file ;
   struct smbuf f_bf ;
   int f_lbfsize ;
   void *f_cookie ;
   int f_ival ;
   int (*f_close)(SM_FILE_T * ) ;
   ssize_t (*f_read)(SM_FILE_T * , char * , size_t  ) ;
   off_t (*f_seek)(SM_FILE_T * , off_t  , int  ) ;
   ssize_t (*f_write)(SM_FILE_T * , char const   * , size_t  ) ;
   int (*f_open)(SM_FILE_T * , void const   * , int  , void const   * ) ;
   int (*f_setinfo)(SM_FILE_T * , int  , void * ) ;
   int (*f_getinfo)(SM_FILE_T * , int  , void * ) ;
   int f_timeout ;
   int f_timeoutstate ;
   char *f_type ;
   struct sm_file *f_flushfp ;
   struct sm_file *f_modefp ;
   struct smbuf f_ub ;
   unsigned char *f_up ;
   int f_ur ;
   unsigned char f_ubuf[3] ;
   unsigned char f_nbuf[1] ;
   int f_blksize ;
   off_t f_lseekoff ;
   int f_dup_cnt ;
};
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 145 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 53 "../../include/sm/types.h"
typedef long long LONGLONG_T;
#line 54 "../../include/sm/types.h"
typedef unsigned long long ULONGLONG_T;
#line 38 "/usr/include/bits/setjmp.h"
typedef int __jmp_buf[6];
#line 36 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 98 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 36 "../../include/sm/clock.h"
struct sm_event {
   time_t ev_time ;
   void (*ev_func)(int  ) ;
   int ev_arg ;
   pid_t ev_pid ;
   struct sm_event *ev_link ;
};
#line 50 "../../include/sm/clock.h"
typedef struct sm_event SM_EVENT;
#line 326 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stddef.h"
typedef int wchar_t;
#line 18 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fvwrite.h"
struct sm_iov {
   void *iov_base ;
   size_t iov_len ;
};
#line 23 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fvwrite.h"
struct sm_uio {
   struct sm_iov *uio_iov ;
   int uio_iovcnt ;
   int uio_resid ;
};
#line 191 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c"
enum __anonenum_base_20 {
    OCT = 0,
    DEC = 1,
    HEX = 2
} ;
#line 585 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c"
union __anonunion_u_21 {
   void *p ;
   ULONGLONG_T ll ;
   unsigned long l ;
   unsigned int i ;
};
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 144 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 176 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 182 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 267 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 35 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
struct sm_str_obj {
   char *strio_base ;
   char *strio_end ;
   size_t strio_size ;
   size_t strio_offset ;
   int strio_flags ;
   void const   *strio_rpool ;
};
#line 45 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
typedef struct sm_str_obj SM_STR_OBJ_T;
#line 25 "../../include/sm/exc.h"
struct sm_exc;
#line 25 "../../include/sm/exc.h"
typedef struct sm_exc SM_EXC_T;
#line 26
struct sm_exc_type;
#line 26 "../../include/sm/exc.h"
typedef struct sm_exc_type SM_EXC_TYPE_T;
#line 27
union sm_val;
#line 27 "../../include/sm/exc.h"
typedef union sm_val SM_VAL_T;
#line 35 "../../include/sm/exc.h"
struct sm_exc_type {
   char const   *sm_magic ;
   char const   *etype_category ;
   char const   *etype_argformat ;
   void (*etype_print)(SM_EXC_T * , SM_FILE_T * ) ;
   char const   *etype_printcontext ;
};
#line 58 "../../include/sm/exc.h"
union sm_val {
   int v_int ;
   long v_long ;
   char *v_str ;
   SM_EXC_T *v_exc ;
};
#line 66 "../../include/sm/exc.h"
struct sm_exc {
   char const   *sm_magic ;
   size_t exc_refcount ;
   SM_EXC_TYPE_T const   *exc_type ;
   SM_VAL_T *exc_argv ;
};
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 136 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 153 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 171 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024UL / (8UL * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 147 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_14 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_15 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_16 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_17 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_18 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_19 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_13 {
   int _pad[128UL / sizeof(int ) - 3UL] ;
   struct __anonstruct__kill_14 _kill ;
   struct __anonstruct__timer_15 _timer ;
   struct __anonstruct__rt_16 _rt ;
   struct __anonstruct__sigchld_17 _sigchld ;
   struct __anonstruct__sigfault_18 _sigfault ;
   struct __anonstruct__sigpoll_19 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_13 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_31 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_31 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 2833 "../../include/sm/conf.h"
typedef void (*sigfunc_t)(int  );
#line 157 "/usr/include/bits/types.h"
typedef int __key_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 123 "/usr/include/sys/types.h"
typedef __key_t key_t;
#line 43 "/usr/include/bits/ipc.h"
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   unsigned short mode ;
   unsigned short __pad1 ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
};
#line 46 "/usr/include/bits/shm.h"
typedef unsigned long shmatt_t;
#line 49 "/usr/include/bits/shm.h"
struct shmid_ds {
   struct ipc_perm shm_perm ;
   size_t shm_segsz ;
   __time_t shm_atime ;
   unsigned long __unused1 ;
   __time_t shm_dtime ;
   unsigned long __unused2 ;
   __time_t shm_ctime ;
   unsigned long __unused3 ;
   __pid_t shm_cpid ;
   __pid_t shm_lpid ;
   shmatt_t shm_nattch ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 152 "/usr/include/sys/types.h"
typedef unsigned short ushort;
#line 39 "/usr/include/bits/sem.h"
struct semid_ds {
   struct ipc_perm sem_perm ;
   __time_t sem_otime ;
   unsigned long __unused1 ;
   __time_t sem_ctime ;
   unsigned long __unused2 ;
   unsigned long sem_nsems ;
   unsigned long __unused3 ;
   unsigned long __unused4 ;
};
#line 42 "/usr/include/sys/sem.h"
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
#line 28 "../../include/sm/sem.h"
union semun {
   int val ;
   struct semid_ds *buf ;
   ushort *array ;
};
#line 30 "../../include/sm/setjmp.h"
typedef sigjmp_buf SM_JMPBUF_T;
#line 129 "../../include/sm/exc.h"
struct sm_exc_handler;
#line 129 "../../include/sm/exc.h"
typedef struct sm_exc_handler SM_EXC_HANDLER_T;
#line 130 "../../include/sm/exc.h"
struct sm_exc_handler {
   SM_EXC_T *eh_value ;
   SM_JMPBUF_T eh_context ;
   SM_EXC_HANDLER_T *eh_parent ;
   int eh_state ;
};
#line 32 "../../include/sm/rpool.h"
struct sm_poollink;
#line 32 "../../include/sm/rpool.h"
typedef struct sm_poollink SM_POOLLINK_T;
#line 33 "../../include/sm/rpool.h"
struct sm_poollink {
   SM_POOLLINK_T *sm_pnext ;
};
#line 38 "../../include/sm/rpool.h"
typedef void (*SM_RPOOL_RFREE_T)(void *_rcontext );
#line 40 "../../include/sm/rpool.h"
typedef SM_RPOOL_RFREE_T *SM_RPOOL_ATTACH_T;
#line 42
struct sm_resource;
#line 42 "../../include/sm/rpool.h"
typedef struct sm_resource SM_RESOURCE_T;
#line 43 "../../include/sm/rpool.h"
struct sm_resource {
   void (*sm_rfree)(void *_rcontext ) ;
   void *sm_rcontext ;
};
#line 56
struct sm_rlist;
#line 56 "../../include/sm/rpool.h"
typedef struct sm_rlist SM_RLIST_T;
#line 57 "../../include/sm/rpool.h"
struct sm_rlist {
   SM_RESOURCE_T sm_rvec[511] ;
   SM_RLIST_T *sm_rnext ;
};
#line 63 "../../include/sm/rpool.h"
struct __anonstruct_SM_RPOOL_T_19 {
   char const   *sm_magic ;
   SM_RPOOL_RFREE_T *sm_parentlink ;
   size_t sm_poolsize ;
   size_t sm_bigobjectsize ;
   char *sm_poolptr ;
   size_t sm_poolavail ;
   SM_POOLLINK_T *sm_pools ;
   SM_RESOURCE_T *sm_rptr ;
   size_t sm_ravail ;
   SM_RLIST_T *sm_rlists ;
};
#line 63 "../../include/sm/rpool.h"
typedef struct __anonstruct_SM_RPOOL_T_19 SM_RPOOL_T;
#line 2964 "../../include/sm/conf.h"
union __anonunion_al_u_20 {
   long al_l ;
   void *al_p ;
   double al_d ;
   void (*al_f)(void) ;
};
#line 2964 "../../include/sm/conf.h"
struct sm_align {
   char al_c ;
   union __anonunion_al_u_20 al_u ;
};
#line 29 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
union __anonunion_SM_POOLHDR_T_21 {
   SM_POOLLINK_T link ;
   char align[(unsigned long )(& ((struct sm_align *)0)->al_u)] ;
};
#line 29 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
typedef union __anonunion_SM_POOLHDR_T_21 SM_POOLHDR_T;
#line 56 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 62 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 27 "../../include/sm/mbdb.h"
struct __anonstruct_SM_MBDB_T_24 {
   uid_t mbdb_uid ;
   gid_t mbdb_gid ;
   char mbdb_name[256] ;
   char mbdb_fullname[256] ;
   char mbdb_homedir[4096] ;
   char mbdb_shell[4096] ;
};
#line 27 "../../include/sm/mbdb.h"
typedef struct __anonstruct_SM_MBDB_T_24 SM_MBDB_T;
#line 41 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
struct __anonstruct_SM_MBDB_TYPE_T_25 {
   char *mbdb_typename ;
   int (*mbdb_initialize)(char * ) ;
   int (*mbdb_lookup)(char *name , SM_MBDB_T *user ) ;
   void (*mbdb_terminate)(void) ;
};
#line 41 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
typedef struct __anonstruct_SM_MBDB_TYPE_T_25 SM_MBDB_TYPE_T;
#line 245 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
struct sm_heap_item;
#line 245 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
typedef struct sm_heap_item SM_HEAP_ITEM_T;
#line 246 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
struct sm_heap_item {
   void *hi_ptr ;
   size_t hi_size ;
   char *hi_tag ;
   int hi_num ;
   int hi_group ;
   SM_HEAP_ITEM_T *hi_next ;
};
#line 22 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/glue.h"
struct sm_glue {
   struct sm_glue *gl_next ;
   int gl_niobs ;
   SM_FILE_T *gl_iobs ;
};
#line 160 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
struct sm_debug_setting;
#line 160 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
typedef struct sm_debug_setting SM_DEBUG_SETTING_T;
#line 161 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
struct sm_debug_setting {
   char const   *ds_pattern ;
   unsigned int ds_level ;
   SM_DEBUG_SETTING_T *ds_next ;
};
#line 17 "../../include/sm/cf.h"
struct __anonstruct_SM_CF_OPT_T_9 {
   char *opt_name ;
   char *opt_val ;
};
#line 17 "../../include/sm/cf.h"
typedef struct __anonstruct_SM_CF_OPT_T_9 SM_CF_OPT_T;
#line 37 "../../include/sm/bitops.h"
typedef unsigned int BITMAP256[32UL / sizeof(int )];
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 138 "/usr/include/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 194 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 243 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 50 "/usr/include/sys/types.h"
typedef __ino_t ino_t;
#line 62 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 22 "./timers.h"
struct _timer {
   long ti_wall_sec ;
   long ti_wall_usec ;
   long ti_cpu_sec ;
   long ti_cpu_usec ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 202 "./sendmail.h"
enum __anonenum_ARGCLASS_T_61 {
    A_HEAP = 0,
    A_TEMP = 1,
    A_PERM = 2
} ;
#line 202 "./sendmail.h"
typedef enum __anonenum_ARGCLASS_T_61 ARGCLASS_T;
#line 214
struct envelope;
#line 214 "./sendmail.h"
typedef struct envelope ENVELOPE;
#line 215
struct mailer;
#line 215 "./sendmail.h"
typedef struct mailer MAILER;
#line 223 "./sendmail.h"
struct address {
   char *q_paddr ;
   char *q_user ;
   char *q_ruser ;
   char *q_host ;
   struct mailer *q_mailer ;
   unsigned long q_flags ;
   uid_t q_uid ;
   gid_t q_gid ;
   char *q_home ;
   char *q_fullname ;
   struct address *q_next ;
   struct address *q_alias ;
   char *q_owner ;
   struct address *q_tchain ;
   struct address *q_pchain ;
   char *q_finalrcpt ;
   char *q_orcpt ;
   char *q_status ;
   char *q_rstatus ;
   time_t q_statdate ;
   char *q_statmta ;
   short q_state ;
   char *q_signature ;
   int q_qgrp ;
   int q_qdir ;
   char *q_message ;
};
#line 255 "./sendmail.h"
typedef struct address ADDRESS;
#line 370 "./sendmail.h"
struct mailer {
   char *m_name ;
   char *m_mailer ;
   char *m_mtatype ;
   char *m_addrtype ;
   char *m_diagtype ;
   BITMAP256 m_flags ;
   short m_mno ;
   short m_nice ;
   char **m_argv ;
   short m_sh_rwset ;
   short m_se_rwset ;
   short m_rh_rwset ;
   short m_re_rwset ;
   char *m_eol ;
   long m_maxsize ;
   int m_linelimit ;
   int m_maxdeliveries ;
   char *m_execdir ;
   char *m_rootdir ;
   uid_t m_uid ;
   gid_t m_gid ;
   char *m_defcharset ;
   time_t m_wait ;
   int m_maxrcpt ;
   short m_qgrp ;
};
#line 625 "./sendmail.h"
struct __anonstruct_MACROS_T_62 {
   SM_RPOOL_T *mac_rpool ;
   BITMAP256 mac_allocated ;
   char *mac_table[256] ;
};
#line 625 "./sendmail.h"
typedef struct __anonstruct_MACROS_T_62 MACROS_T;
#line 641 "./sendmail.h"
struct mailer_con_info {
   unsigned long mci_flags ;
   short mci_errno ;
   short mci_herrno ;
   short mci_exitstat ;
   short mci_state ;
   int mci_deliveries ;
   long mci_maxsize ;
   SM_FILE_T *mci_in ;
   SM_FILE_T *mci_out ;
   pid_t mci_pid ;
   char *mci_phase ;
   struct mailer *mci_mailer ;
   char *mci_host ;
   char *mci_status ;
   char *mci_rstatus ;
   time_t mci_lastuse ;
   SM_FILE_T *mci_statfile ;
   char *mci_heloname ;
   long mci_min_by ;
   bool mci_retryrcpt ;
   char *mci_tolist ;
   SM_RPOOL_T *mci_rpool ;
   int mci_okrcpts ;
   ADDRESS *mci_nextaddr ;
   MACROS_T mci_macro ;
};
#line 755 "./sendmail.h"
struct header {
   char *h_field ;
   char *h_value ;
   struct header *h_link ;
   unsigned char h_macro ;
   unsigned long h_flags ;
   BITMAP256 h_mflags ;
};
#line 765 "./sendmail.h"
typedef struct header HDR;
#line 827 "./sendmail.h"
struct sm_timers {
   struct _timer ti_overall ;
};
#line 845 "./sendmail.h"
struct envelope {
   HDR *e_header ;
   long e_msgpriority ;
   time_t e_ctime ;
   char *e_to ;
   ADDRESS e_from ;
   char *e_sender ;
   char **e_fromdomain ;
   ADDRESS *e_sendqueue ;
   ADDRESS *e_errorqueue ;
   long e_msgsize ;
   char *e_msgid ;
   unsigned long e_flags ;
   int e_nrcpts ;
   short e_class ;
   short e_hopcount ;
   short e_nsent ;
   short e_sendmode ;
   short e_errormode ;
   short e_timeoutclass ;
   bool (*e_puthdr)(struct mailer_con_info * , HDR * , ENVELOPE * , int  ) ;
   bool (*e_putbody)(struct mailer_con_info * , ENVELOPE * , char * ) ;
   ENVELOPE *e_parent ;
   ENVELOPE *e_sibling ;
   char *e_bodytype ;
   SM_FILE_T *e_dfp ;
   char *e_id ;
   int e_qgrp ;
   int e_qdir ;
   int e_dfqgrp ;
   int e_dfqdir ;
   int e_xfqgrp ;
   int e_xfqdir ;
   SM_FILE_T *e_xfp ;
   SM_FILE_T *e_lockfp ;
   char *e_message ;
   char *e_statmsg ;
   char *e_quarmsg ;
   char e_qfletter ;
   char *e_msgboundary ;
   char *e_origrcpt ;
   char *e_envid ;
   char *e_status ;
   time_t e_dtime ;
   int e_ntries ;
   dev_t e_dfdev ;
   ino_t e_dfino ;
   MACROS_T e_macro ;
   struct mailer_con_info *e_mci ;
   char *e_auth_param ;
   struct sm_timers e_timers ;
   long e_deliver_by ;
   int e_dlvr_flag ;
   SM_RPOOL_T *e_rpool ;
};
#line 1062 "./sendmail.h"
struct metamac {
   char metaname ;
   unsigned char metaval ;
};
#line 1343 "./sendmail.h"
union bigsockaddr {
   struct sockaddr sa ;
   struct sockaddr_un sunix ;
   struct sockaddr_in sin ;
};
#line 1758 "./sendmail.h"
struct termescape {
   char *te_rv_on ;
   char *te_rv_off ;
};
#line 2494 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
struct procs;
#line 2494 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
typedef struct procs PROCS_T;
#line 2496 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
struct procs {
   pid_t proc_pid ;
   char *proc_task ;
   int proc_type ;
   int proc_count ;
   int proc_other ;
   union bigsockaddr proc_hostaddr ;
};
#line 2657 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
union __anonunion___u_65 {
   int __in ;
   int __i ;
};
#line 2655 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
union __anonunion___u_66 {
   int __in ;
   int __i ;
};
#line 2660 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
union __anonunion___u_67 {
   int __in ;
   int __i ;
};
#line 2652 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
union __anonunion___u_68 {
   int __in ;
   int __i ;
};
#line 1992 "./sendmail.h"
struct __anonstruct_TimeOuts_64 {
   time_t to_initial ;
   time_t to_mail ;
   time_t to_rcpt ;
   time_t to_datainit ;
   time_t to_datablock ;
   time_t to_datafinal ;
   time_t to_nextcommand ;
   time_t to_iconnect ;
   time_t to_connect ;
   time_t to_aconnect ;
   time_t to_rset ;
   time_t to_helo ;
   time_t to_quit ;
   time_t to_miscshort ;
   time_t to_ident ;
   time_t to_fileopen ;
   time_t to_control ;
   time_t to_lhlo ;
   time_t to_q_return[8] ;
   time_t to_q_warning[8] ;
   time_t res_retrans[3] ;
   int res_retry[3] ;
};
#line 193 "/usr/include/sys/types.h"
typedef int int32_t;
#line 197 "/usr/include/sys/types.h"
typedef unsigned char u_int8_t;
#line 199 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 1164 "./sendmail.h"
struct _mapclass;
#line 1164 "./sendmail.h"
struct _map {
   struct _mapclass *map_class ;
   struct _mapclass *map_orgclass ;
   char *map_mname ;
   long map_mflags ;
   char *map_file ;
   void *map_db1 ;
   void *map_db2 ;
   char *map_keycolnm ;
   char *map_valcolnm ;
   unsigned char map_keycolno ;
   unsigned char map_valcolno ;
   char map_coldelim ;
   char map_spacesub ;
   char *map_app ;
   char *map_tapp ;
   char *map_domain ;
   char *map_rebuild ;
   time_t map_mtime ;
   time_t map_timeout ;
   int map_retry ;
   pid_t map_pid ;
   int map_lockfd ;
   short map_specificity ;
   struct _map *map_stack[12] ;
   short map_return[5] ;
};
#line 1246 "./sendmail.h"
struct _mapclass {
   char *map_cname ;
   char *map_ext ;
   short map_cflags ;
   bool (*map_parse)(struct _map * , char * ) ;
   char *(*map_lookup)(struct _map * , char * , char ** , int * ) ;
   void (*map_store)(struct _map * , char * , char * ) ;
   bool (*map_open)(struct _map * , int  ) ;
   void (*map_close)(struct _map * ) ;
};
#line 75 "/usr/include/db.h"
typedef u_int32_t db_pgno_t;
#line 79 "/usr/include/db.h"
typedef u_int32_t db_recno_t;
#line 83
struct __db;
#line 83 "/usr/include/db.h"
typedef struct __db DB;
#line 88
struct __db_dbt;
#line 88 "/usr/include/db.h"
typedef struct __db_dbt DBT;
#line 89
struct __db_env;
#line 89 "/usr/include/db.h"
typedef struct __db_env DB_ENV;
#line 91
struct __db_ilock;
#line 91 "/usr/include/db.h"
typedef struct __db_ilock DB_LOCK_ILOCK;
#line 93
struct __db_lock_u;
#line 93 "/usr/include/db.h"
typedef struct __db_lock_u DB_LOCK;
#line 96
struct __db_lsn;
#line 96 "/usr/include/db.h"
typedef struct __db_lsn DB_LSN;
#line 100
struct __db_mpoolfile;
#line 100 "/usr/include/db.h"
typedef struct __db_mpoolfile DB_MPOOLFILE;
#line 102
struct __db_txn;
#line 102 "/usr/include/db.h"
typedef struct __db_txn DB_TXN;
#line 105
struct __dbc;
#line 105 "/usr/include/db.h"
typedef struct __dbc DBC;
#line 106
struct __dbc_internal;
#line 106 "/usr/include/db.h"
typedef struct __dbc_internal DBC_INTERNAL;
#line 107
struct __fh_t;
#line 107 "/usr/include/db.h"
typedef struct __fh_t DB_FH;
#line 108
struct __key_range;
#line 108 "/usr/include/db.h"
typedef struct __key_range DB_KEY_RANGE;
#line 111 "/usr/include/db.h"
struct __db_dbt {
   void *data ;
   u_int32_t size ;
   u_int32_t ulen ;
   u_int32_t dlen ;
   u_int32_t doff ;
   u_int32_t flags ;
};
#line 251
enum __anonenum_db_recops_65 {
    DB_TXN_ABORT = 0,
    DB_TXN_BACKWARD_ROLL = 1,
    DB_TXN_FORWARD_ROLL = 2,
    DB_TXN_OPENFILES = 3
} ;
#line 251 "/usr/include/db.h"
typedef enum __anonenum_db_recops_65 db_recops;
#line 261 "/usr/include/db.h"
struct __anonstruct_dblist_66 {
   struct __db *lh_first ;
};
#line 261 "/usr/include/db.h"
struct __anonstruct_links_67 {
   struct __db_env *tqe_next ;
   struct __db_env **tqe_prev ;
};
#line 261 "/usr/include/db.h"
struct __db_env {
   FILE *db_errfile ;
   char const   *db_errpfx ;
   void (*db_errcall)(char const   * , char * ) ;
   void (*db_feedback)(DB_ENV * , int  , int  ) ;
   void (*db_paniccall)(DB_ENV * , int  ) ;
   int (*db_recovery_init)(DB_ENV * ) ;
   u_int32_t verbose ;
   void *app_private ;
   u_int8_t *lk_conflicts ;
   u_int32_t lk_modes ;
   u_int32_t lk_max ;
   u_int32_t lk_max_lockers ;
   u_int32_t lk_max_objects ;
   u_int32_t lk_detect ;
   u_int32_t lg_bsize ;
   u_int32_t lg_max ;
   u_int32_t mp_gbytes ;
   u_int32_t mp_bytes ;
   size_t mp_size ;
   int mp_ncache ;
   size_t mp_mmapsize ;
   u_int32_t tx_max ;
   time_t tx_timestamp ;
   int (*tx_recover)(DB_ENV * , DBT * , DB_LSN * , db_recops  ) ;
   int db_panic ;
   char *db_home ;
   char *db_log_dir ;
   char *db_tmp_dir ;
   char **db_data_dir ;
   int data_cnt ;
   int data_next ;
   int db_mode ;
   void *reginfo ;
   DB_FH *lockfhp ;
   long shm_key ;
   void *lg_handle ;
   void *lk_handle ;
   void *mp_handle ;
   void *tx_handle ;
   int (**dtab)(DB_ENV * , DBT * , DB_LSN * , db_recops  , void * ) ;
   size_t dtab_size ;
   void *cl_handle ;
   long cl_id ;
   int dblocal_ref ;
   u_int32_t db_mutexlocks ;
   void *dblist_mutexp ;
   struct __anonstruct_dblist_66 dblist ;
   struct __anonstruct_links_67 links ;
   int xa_rmid ;
   DB_TXN *xa_txn ;
   void *cj_internal ;
   int (*close)(DB_ENV * , u_int32_t  ) ;
   void (*err)(DB_ENV const   * , int  , char const   *  , ...) ;
   void (*errx)(DB_ENV const   * , char const   *  , ...) ;
   int (*open)(DB_ENV * , char const   * , u_int32_t  , int  ) ;
   int (*remove)(DB_ENV * , char const   * , u_int32_t  ) ;
   int (*set_data_dir)(DB_ENV * , char const   * ) ;
   void (*set_errcall)(DB_ENV * , void (*)(char const   * , char * ) ) ;
   void (*set_errfile)(DB_ENV * , FILE * ) ;
   void (*set_errpfx)(DB_ENV * , char const   * ) ;
   int (*set_feedback)(DB_ENV * , void (*)(DB_ENV * , int  , int  ) ) ;
   int (*set_flags)(DB_ENV * , u_int32_t  , int  ) ;
   int (*set_mutexlocks)(DB_ENV * , int  ) ;
   int (*set_paniccall)(DB_ENV * , void (*)(DB_ENV * , int  ) ) ;
   int (*set_recovery_init)(DB_ENV * , int (*)(DB_ENV * ) ) ;
   int (*set_server)(DB_ENV * , char * , long  , long  , u_int32_t  ) ;
   int (*set_shm_key)(DB_ENV * , long  ) ;
   int (*set_tmp_dir)(DB_ENV * , char const   * ) ;
   int (*set_verbose)(DB_ENV * , u_int32_t  , int  ) ;
   int (*set_lg_bsize)(DB_ENV * , u_int32_t  ) ;
   int (*set_lg_dir)(DB_ENV * , char const   * ) ;
   int (*set_lg_max)(DB_ENV * , u_int32_t  ) ;
   int (*set_lk_conflicts)(DB_ENV * , u_int8_t * , int  ) ;
   int (*set_lk_detect)(DB_ENV * , u_int32_t  ) ;
   int (*set_lk_max)(DB_ENV * , u_int32_t  ) ;
   int (*set_lk_max_locks)(DB_ENV * , u_int32_t  ) ;
   int (*set_lk_max_lockers)(DB_ENV * , u_int32_t  ) ;
   int (*set_lk_max_objects)(DB_ENV * , u_int32_t  ) ;
   int (*set_mp_mmapsize)(DB_ENV * , size_t  ) ;
   int (*set_cachesize)(DB_ENV * , u_int32_t  , u_int32_t  , int  ) ;
   int (*set_tx_max)(DB_ENV * , u_int32_t  ) ;
   int (*set_tx_recover)(DB_ENV * , int (*)(DB_ENV * , DBT * , DB_LSN * , db_recops  ) ) ;
   int (*set_tx_timestamp)(DB_ENV * , time_t * ) ;
   u_int32_t flags ;
};
#line 460
enum __anonenum_DBTYPE_68 {
    DB_BTREE = 1,
    DB_HASH = 2,
    DB_RECNO = 3,
    DB_QUEUE = 4,
    DB_UNKNOWN = 5
} ;
#line 460 "/usr/include/db.h"
typedef enum __anonenum_DBTYPE_68 DBTYPE;
#line 571 "/usr/include/db.h"
struct __anonstruct_links_69 {
   struct __db *tqe_next ;
   struct __db **tqe_prev ;
};
#line 571 "/usr/include/db.h"
struct __anonstruct_dblistlinks_70 {
   struct __db *le_next ;
   struct __db **le_prev ;
};
#line 571 "/usr/include/db.h"
struct __anonstruct_free_queue_71 {
   struct __dbc *tqh_first ;
   struct __dbc **tqh_last ;
};
#line 571 "/usr/include/db.h"
struct __anonstruct_active_queue_72 {
   struct __dbc *tqh_first ;
   struct __dbc **tqh_last ;
};
#line 571 "/usr/include/db.h"
struct __anonstruct_join_queue_73 {
   struct __dbc *tqh_first ;
   struct __dbc **tqh_last ;
};
#line 571 "/usr/include/db.h"
struct __db {
   u_int32_t pgsize ;
   int (*db_append_recno)(DB * , DBT * , db_recno_t  ) ;
   void (*db_feedback)(DB * , int  , int  ) ;
   void *(*db_malloc)(size_t  ) ;
   void *(*db_realloc)(void * , size_t  ) ;
   int (*dup_compare)(DB * , DBT const   * , DBT const   * ) ;
   void *app_private ;
   DB_ENV *dbenv ;
   DBTYPE type ;
   DB_MPOOLFILE *mpf ;
   void *mutexp ;
   u_int8_t fileid[20] ;
   u_int32_t adj_fileid ;
   int32_t log_fileid ;
   db_pgno_t meta_pgno ;
   DB_TXN *open_txn ;
   long cl_id ;
   DB_FH *saved_open_fhp ;
   struct __anonstruct_links_69 links ;
   struct __anonstruct_dblistlinks_70 dblistlinks ;
   struct __anonstruct_free_queue_71 free_queue ;
   struct __anonstruct_active_queue_72 active_queue ;
   struct __anonstruct_join_queue_73 join_queue ;
   void *bt_internal ;
   void *cj_internal ;
   void *h_internal ;
   void *q_internal ;
   void *xa_internal ;
   int (*close)(DB * , u_int32_t  ) ;
   int (*cursor)(DB * , DB_TXN * , DBC ** , u_int32_t  ) ;
   int (*del)(DB * , DB_TXN * , DBT * , u_int32_t  ) ;
   void (*err)(DB * , int  , char const   *  , ...) ;
   void (*errx)(DB * , char const   *  , ...) ;
   int (*fd)(DB * , int * ) ;
   int (*get)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t  ) ;
   int (*get_byteswapped)(DB * ) ;
   DBTYPE (*get_type)(DB * ) ;
   int (*join)(DB * , DBC ** , DBC ** , u_int32_t  ) ;
   int (*key_range)(DB * , DB_TXN * , DBT * , DB_KEY_RANGE * , u_int32_t  ) ;
   int (*open)(DB * , char const   * , char const   * , DBTYPE  , u_int32_t  , int  ) ;
   int (*put)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t  ) ;
   int (*remove)(DB * , char const   * , char const   * , u_int32_t  ) ;
   int (*rename)(DB * , char const   * , char const   * , char const   * , u_int32_t  ) ;
   int (*set_append_recno)(DB * , int (*)(DB * , DBT * , db_recno_t  ) ) ;
   int (*set_cachesize)(DB * , u_int32_t  , u_int32_t  , int  ) ;
   int (*set_dup_compare)(DB * , int (*)(DB * , DBT const   * , DBT const   * ) ) ;
   void (*set_errcall)(DB * , void (*)(char const   * , char * ) ) ;
   void (*set_errfile)(DB * , FILE * ) ;
   void (*set_errpfx)(DB * , char const   * ) ;
   int (*set_feedback)(DB * , void (*)(DB * , int  , int  ) ) ;
   int (*set_flags)(DB * , u_int32_t  ) ;
   int (*set_lorder)(DB * , int  ) ;
   int (*set_malloc)(DB * , void *(*)(size_t  ) ) ;
   int (*set_pagesize)(DB * , u_int32_t  ) ;
   int (*set_paniccall)(DB * , void (*)(DB_ENV * , int  ) ) ;
   int (*set_realloc)(DB * , void *(*)(void * , size_t  ) ) ;
   int (*stat)(DB * , void * , void *(*)(size_t  ) , u_int32_t  ) ;
   int (*sync)(DB * , u_int32_t  ) ;
   int (*upgrade)(DB * , char const   * , u_int32_t  ) ;
   int (*verify)(DB * , char const   * , char const   * , FILE * , u_int32_t  ) ;
   int (*set_bt_compare)(DB * , int (*)(DB * , DBT const   * , DBT const   * ) ) ;
   int (*set_bt_maxkey)(DB * , u_int32_t  ) ;
   int (*set_bt_minkey)(DB * , u_int32_t  ) ;
   int (*set_bt_prefix)(DB * , size_t (*)(DB * , DBT const   * , DBT const   * ) ) ;
   int (*set_h_ffactor)(DB * , u_int32_t  ) ;
   int (*set_h_hash)(DB * , u_int32_t (*)(DB * , void const   * , u_int32_t  ) ) ;
   int (*set_h_nelem)(DB * , u_int32_t  ) ;
   int (*set_re_delim)(DB * , int  ) ;
   int (*set_re_len)(DB * , u_int32_t  ) ;
   int (*set_re_pad)(DB * , int  ) ;
   int (*set_re_source)(DB * , char const   * ) ;
   int (*set_q_extentsize)(DB * , u_int32_t  ) ;
   int (*db_am_remove)(DB * , char const   * , char const   * , DB_LSN * , int (**)(DB * ,
                                                                                    void * ) ,
                       void ** ) ;
   int (*db_am_rename)(DB * , char const   * , char const   * , char const   * ) ;
   u_int32_t am_ok ;
   u_int32_t flags ;
};
#line 778 "/usr/include/db.h"
struct __db_ilock {
   db_pgno_t pgno ;
   u_int8_t fileid[20] ;
   u_int8_t type ;
};
#line 791 "/usr/include/db.h"
struct __db_lock_u {
   size_t off ;
   u_int32_t ndx ;
   u_int32_t gen ;
};
#line 799 "/usr/include/db.h"
struct __anonstruct_links_74 {
   DBC *tqe_next ;
   DBC **tqe_prev ;
};
#line 799 "/usr/include/db.h"
struct __dbc {
   DB *dbp ;
   DB_TXN *txn ;
   struct __anonstruct_links_74 links ;
   DBT rkey ;
   DBT rdata ;
   u_int32_t lid ;
   u_int32_t locker ;
   DBT lock_dbt ;
   DB_LOCK_ILOCK lock ;
   DB_LOCK mylock ;
   long cl_id ;
   DBTYPE dbtype ;
   DBC_INTERNAL *internal ;
   int (*c_close)(DBC * ) ;
   int (*c_count)(DBC * , db_recno_t * , u_int32_t  ) ;
   int (*c_del)(DBC * , u_int32_t  ) ;
   int (*c_dup)(DBC * , DBC ** , u_int32_t  ) ;
   int (*c_get)(DBC * , DBT * , DBT * , u_int32_t  ) ;
   int (*c_put)(DBC * , DBT * , DBT * , u_int32_t  ) ;
   int (*c_am_close)(DBC * , db_pgno_t  , int * ) ;
   int (*c_am_del)(DBC * ) ;
   int (*c_am_destroy)(DBC * ) ;
   int (*c_am_get)(DBC * , DBT * , DBT * , u_int32_t  , db_pgno_t * ) ;
   int (*c_am_put)(DBC * , DBT * , DBT * , u_int32_t  , db_pgno_t * ) ;
   int (*c_am_writelock)(DBC * ) ;
   u_int32_t flags ;
};
#line 861 "/usr/include/db.h"
struct __key_range {
   double less ;
   double equal ;
   double greater ;
};
#line 1090 "/usr/include/db.h"
struct __db_lsn {
   u_int32_t file ;
   u_int32_t offset ;
};
#line 42 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
struct __anonstruct_udb_remote_79 {
   union bigsockaddr _udb_addr ;
   int _udb_timeout ;
};
#line 42 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
struct __anonstruct_udb_forward_80 {
   char *_udb_fwdhost ;
};
#line 42 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
struct __anonstruct_udb_lookup_81 {
   char *_udb_dbname ;
   DB *_udb_dbp ;
};
#line 42 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
union __anonunion_udb_u_78 {
   struct __anonstruct_udb_remote_79 udb_remote ;
   struct __anonstruct_udb_forward_80 udb_forward ;
   struct __anonstruct_udb_lookup_81 udb_lookup ;
};
#line 42 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
struct udbent {
   char *udb_spec ;
   int udb_type ;
   pid_t udb_pid ;
   char *udb_default ;
   union __anonunion_udb_u_78 udb_u ;
};
#line 91 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
struct udb_option {
   char *udbo_name ;
   char *udbo_val ;
};
#line 23 "../../include/sendmail/mailstats.h"
struct statistics {
   int stat_magic ;
   int stat_version ;
   time_t stat_itime ;
   short stat_size ;
   long stat_cf ;
   long stat_ct ;
   long stat_cr ;
   long stat_nf[25] ;
   long stat_bf[25] ;
   long stat_nt[25] ;
   long stat_bt[25] ;
   long stat_nr[25] ;
   long stat_nd[25] ;
   long stat_nq[25] ;
};
#line 216 "./sendmail.h"
struct queuegrp;
#line 216 "./sendmail.h"
typedef struct queuegrp QUEUEGRP;
#line 484 "./sendmail.h"
struct qpaths_s {
   char *qp_name ;
   short qp_subdirs ;
   short qp_fsysidx ;
   int qp_idx ;
};
#line 494 "./sendmail.h"
typedef struct qpaths_s QPATHS;
#line 496 "./sendmail.h"
struct queuegrp {
   char *qg_name ;
   char *qg_qdir ;
   short qg_index ;
   int qg_maxqrun ;
   int qg_numqueues ;
   time_t qg_queueintvl ;
   QPATHS *qg_qpaths ;
   BITMAP256 qg_flags ;
   short qg_nice ;
   int qg_wgrp ;
   int qg_maxlist ;
   int qg_curnum ;
   int qg_maxrcpt ;
   time_t qg_nextrun ;
};
#line 773 "./sendmail.h"
struct hdrinfo {
   char *hi_field ;
   unsigned long hi_flags ;
   char *hi_ruleset ;
};
#line 1119 "./sendmail.h"
struct _namecanon {
   short nc_errno ;
   short nc_herrno ;
   short nc_stat ;
   short nc_flags ;
   char *nc_cname ;
   time_t nc_exp ;
};
#line 1134 "./sendmail.h"
struct hostsig_t {
   char *hs_sig ;
   time_t hs_exp ;
};
#line 1140 "./sendmail.h"
typedef struct hostsig_t HOSTSIG_T;
#line 1413
struct milter;
#line 1413 "./sendmail.h"
union __anonunion_s_value_63 {
   BITMAP256 sv_class ;
   ADDRESS *sv_addr ;
   MAILER *sv_mailer ;
   char *sv_alias ;
   struct _mapclass sv_mapclass ;
   struct _map sv_map ;
   HOSTSIG_T sv_hostsig ;
   struct mailer_con_info sv_mci ;
   struct _namecanon sv_namecanon ;
   int sv_macro ;
   int sv_ruleset ;
   struct hdrinfo sv_header ;
   char *sv_service[12] ;
   struct milter *sv_milter ;
   QUEUEGRP *sv_queue ;
};
#line 1413 "./sendmail.h"
struct symtab {
   char *s_name ;
   short s_symtype ;
   struct symtab *s_next ;
   union __anonunion_s_value_63 s_value ;
};
#line 1446 "./sendmail.h"
typedef struct symtab STAB;
#line 1680 "./sendmail.h"
typedef int32_t mi_int32;
#line 1690 "./sendmail.h"
struct milter {
   char *mf_name ;
   BITMAP256 mf_flags ;
   mi_int32 mf_fvers ;
   mi_int32 mf_fflags ;
   mi_int32 mf_pflags ;
   char *mf_conn ;
   int mf_sock ;
   char mf_state ;
   time_t mf_timeout[4] ;
};
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 37 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 198 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_51 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_51 in6_u ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 71 "/usr/include/resolv.h"
enum __anonenum_res_sendhookact_57 {
    res_goahead = 0,
    res_nextns = 1,
    res_modified = 2,
    res_done = 3,
    res_error = 4
} ;
#line 71 "/usr/include/resolv.h"
typedef enum __anonenum_res_sendhookact_57 res_sendhookact;
#line 104 "/usr/include/resolv.h"
struct __anonstruct_sort_list_58 {
   struct in_addr addr ;
   u_int32_t mask ;
};
#line 104 "/usr/include/resolv.h"
struct __anonstruct__ext_60 {
   u_int16_t nscount ;
   u_int16_t nsmap[3] ;
   int nssocks[3] ;
   u_int16_t nscount6 ;
   u_int16_t nsinit ;
   struct sockaddr_in6 *nsaddrs[3] ;
   unsigned int _initstamp[2] ;
};
#line 104 "/usr/include/resolv.h"
union __anonunion__u_59 {
   char pad[52] ;
   struct __anonstruct__ext_60 _ext ;
};
#line 104 "/usr/include/resolv.h"
struct __res_state {
   int retrans ;
   int retry ;
   u_long options ;
   int nscount ;
   struct sockaddr_in nsaddr_list[3] ;
   u_short id ;
   char *dnsrch[7] ;
   char defdname[256] ;
   u_long pfcode ;
   unsigned int ndots : 4 ;
   unsigned int nsort : 4 ;
   char unused[3] ;
   struct __anonstruct_sort_list_58 sort_list[10] ;
   res_sendhookact (*qhook)(struct sockaddr_in * const  *ns , u_char const   **query ,
                            int *querylen , u_char *ans , int anssiz , int *resplen ) ;
   res_sendhookact (*rhook)(struct sockaddr_in  const  *ns , u_char const   *query ,
                            int querylen , u_char *ans , int anssiz , int *resplen ) ;
   int res_h_errno ;
   int _vcsock ;
   u_int _flags ;
   union __anonunion__u_59 _u ;
};
#line 1922 "./sendmail.h"
struct queue_char {
   char *queue_match ;
   bool queue_negate ;
   struct queue_char *queue_next ;
};
#line 1937 "./sendmail.h"
typedef struct queue_char QUEUE_CHAR;
#line 149 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
struct cmd {
   char *cmd_name ;
   int cmd_code ;
};
#line 270 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
struct __anonstruct_SMTP_T_65 {
   bool sm_gotmail ;
   unsigned int sm_nrcpts ;
   bool sm_discard ;
   bool sm_milterize ;
   bool sm_milterlist ;
   char *sm_quarmsg ;
};
#line 270 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
typedef struct __anonstruct_SMTP_T_65 SMTP_T;
#line 4448 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
struct __anonstruct_srv_feat_table_66 {
   char srvf_opt ;
   unsigned int srvf_flag ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
struct __anonstruct_HEADER_56 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
typedef struct __anonstruct_HEADER_56 HEADER;
#line 65 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.h"
struct __anonstruct_DNS_QUERY_T_65 {
   char *dns_q_domain ;
   unsigned int dns_q_type ;
   unsigned int dns_q_class ;
};
#line 65 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.h"
typedef struct __anonstruct_DNS_QUERY_T_65 DNS_QUERY_T;
#line 72 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.h"
struct __anonstruct_MX_RECORD_T_66 {
   unsigned int mx_r_preference ;
   char mx_r_domain[1] ;
};
#line 72 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.h"
typedef struct __anonstruct_MX_RECORD_T_66 MX_RECORD_T;
#line 78 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.h"
struct __anonstruct_SRV_RECORDT_T_67 {
   unsigned int srv_r_priority ;
   unsigned int srv_r_weight ;
   unsigned int srv_r_port ;
   char srv_r_target[1] ;
};
#line 78 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.h"
typedef struct __anonstruct_SRV_RECORDT_T_67 SRV_RECORDT_T;
#line 87
struct resource_record;
#line 87 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.h"
typedef struct resource_record RESOURCE_RECORD_T;
#line 89 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.h"
union __anonunion_rr_u_68 {
   void *rr_data ;
   MX_RECORD_T *rr_mx ;
   MX_RECORD_T *rr_afsdb ;
   SRV_RECORDT_T *rr_srv ;
   struct in_addr *rr_a ;
   char *rr_txt ;
};
#line 89 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.h"
struct resource_record {
   char *rr_domain ;
   unsigned int rr_type ;
   unsigned int rr_class ;
   unsigned int rr_ttl ;
   unsigned int rr_size ;
   union __anonunion_rr_u_68 rr_u ;
   RESOURCE_RECORD_T *rr_next ;
};
#line 118 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.h"
struct __anonstruct_DNS_REPLY_T_69 {
   HEADER dns_r_h ;
   DNS_QUERY_T dns_r_q ;
   RESOURCE_RECORD_T *dns_r_head ;
};
#line 118 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.h"
typedef struct __anonstruct_DNS_REPLY_T_69 DNS_REPLY_T;
#line 51 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c"
struct stot {
   char const   *st_name ;
   int st_type ;
};
#line 1008 "./sendmail.h"
struct rewrite {
   char **r_lhs ;
   char **r_rhs ;
   struct rewrite *r_next ;
   int r_line ;
};
#line 24 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
typedef int sortfn_t(ADDRESS * , ADDRESS * );
#line 125 "../../include/sendmail/sendmail.h"
struct dbsval {
   char *dbs_name ;
   unsigned char dbs_flag ;
};
#line 995 "./sendmail.h"
struct priority {
   char *pri_name ;
   int pri_val ;
};
#line 1617 "./sendmail.h"
struct prival {
   char *pv_name ;
   unsigned long pv_flag ;
};
#line 1915 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
struct resolverflags {
   char *rf_name ;
   long rf_bits ;
};
#line 1943 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
struct optioninfo {
   char *o_name ;
   unsigned char o_code ;
   unsigned short o_flags ;
};
#line 4057 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
struct timeoutinfo {
   char *to_name ;
   unsigned char to_code ;
};
#line 169 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
struct CTime {
   unsigned long ct_Ticks ;
   int ct_Count ;
};
#line 169 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
typedef struct CTime CTime_T;
#line 176 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
struct CHash {
   struct in_addr ch_Addr ;
   int ch_Family ;
   time_t ch_LTime ;
   unsigned long ch_colls ;
   CTime_T ch_Times[6] ;
};
#line 176 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
typedef struct CHash CHash_T;
#line 131 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 57 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
struct work {
   char *w_name ;
   char *w_host ;
   bool w_lock ;
   bool w_tooyoung ;
   long w_pri ;
   time_t w_ctime ;
   time_t w_mtime ;
   int w_qgrp ;
   int w_qdir ;
   struct work *w_next ;
};
#line 71 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
typedef struct work WORK;
#line 107 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
struct workgrp {
   int wg_numqgrp ;
   int wg_runners ;
   int wg_curqgrp ;
   QUEUEGRP **wg_qgs ;
   int wg_maxact ;
   time_t wg_lowqintvl ;
   int wg_restart ;
   int wg_restartcnt ;
};
#line 119 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
typedef struct workgrp WORKGRP;
#line 174
struct filesys_shared;
#line 174 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
typedef struct filesys_shared FILESYS;
#line 176 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
struct filesys_shared {
   dev_t fs_dev ;
   long fs_avail ;
   long fs_blksize ;
};
#line 208
struct queue_shared;
#line 208 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
typedef struct queue_shared QUEUE_SHM_T;
#line 210 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
struct queue_shared {
   int qs_entries ;
};
#line 7489 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
struct sortqgrp {
   int sg_idx ;
   int sg_maxqrun ;
};
#line 7494 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
typedef struct sortqgrp SORTQGRP_T;
#line 954 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
struct match {
   char **match_first ;
   char **match_last ;
   char **match_pattern ;
};
#line 1871 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
struct errcodes {
   char *ec_name ;
   int ec_code ;
};
#line 2288 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
struct qflags {
   char *qf_name ;
   unsigned long qf_bit ;
};
#line 92 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
struct args {
   char *a_field ;
   char *a_value ;
};
#line 42 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 251 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 1433 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
struct milteropt {
   char *mo_name ;
   unsigned char mo_code ;
};
#line 549 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
struct mcifbits {
   int mcif_bit ;
   char *mcif_name ;
};
#line 933 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
struct dns_map {
   int dns_m_type ;
};
#line 6111 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
union __anonunion___u_83 {
   int __in ;
   int __i ;
};
#line 6109 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
union __anonunion___u_84 {
   int __in ;
   int __i ;
};
#line 1213 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c"
struct eflags {
   char *ef_name ;
   unsigned long ef_bit ;
};
#line 40 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
union __anonunion_querybuf_65 {
   HEADER qb1 ;
   unsigned char qb2[8192] ;
};
#line 40 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
typedef union __anonunion_querybuf_65 querybuf;
#line 3894 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
union __anonunion___u_65___0 {
   int __in ;
   int __i ;
};
#line 3891 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
union __anonunion___u_66___0 {
   int __in ;
   int __i ;
};
#line 3900 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
union __anonunion___u_67___0 {
   int __in ;
   int __i ;
};
#line 3901 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
union __anonunion___u_68___0 {
   int __in ;
   int __i ;
};
#line 3901 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
union __anonunion___u_69 {
   int __in ;
   int __i ;
};
#line 3900 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
union __anonunion___u_70 {
   int __in ;
   int __i ;
};
#line 3899 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
union __anonunion___u_71 {
   int __in ;
   int __i ;
};
#line 5608 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
union __anonunion___u_72 {
   int __in ;
   int __i ;
};
#line 5605 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
union __anonunion___u_73 {
   int __in ;
   int __i ;
};
#line 62 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
struct daemon {
   int d_socket ;
   union bigsockaddr d_addr ;
   unsigned short d_port ;
   int d_listenqueue ;
   int d_tcprcvbufsize ;
   int d_tcpsndbufsize ;
   time_t d_refuse_connections_until ;
   bool d_firsttime ;
   int d_socksize ;
   BITMAP256 d_flags ;
   char *d_mflags ;
   char *d_name ;
   char *d_inputfilterlist ;
   struct milter *d_inputfilters[25] ;
};
#line 88 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
typedef struct daemon DAEMON_T;
#line 1789 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
struct dflags {
   char *d_name ;
   int d_flag ;
};
#line 146 "/usr/include/bits/types.h"
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
#line 146 "/usr/include/bits/types.h"
typedef struct __anonstruct___fsid_t_1 __fsid_t;
#line 148 "/usr/include/bits/types.h"
typedef unsigned long __rlim_t;
#line 175 "/usr/include/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 179 "/usr/include/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/bits/types.h"
typedef char *__caddr_t;
#line 127 "/usr/include/bits/resource.h"
typedef __rlim_t rlim_t;
#line 135 "/usr/include/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 43 "/usr/include/sys/resource.h"
typedef int __rlimit_resource_t;
#line 62 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_43 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_44 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_43 __wait_terminated ;
   struct __anonstruct___wait_stopped_44 __wait_stopped ;
};
#line 25 "/usr/include/bits/statfs.h"
struct statfs {
   int f_type ;
   int f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   int f_namelen ;
   int f_frsize ;
   int f_spare[5] ;
};
#line 110 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 125 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_80 {
   char ifrn_name[16] ;
};
#line 125 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_81 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 125 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_80 ifr_ifrn ;
   union __anonunion_ifr_ifru_81 ifr_ifru ;
};
#line 175 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_82 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 175 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_82 ifc_ifcu ;
};
#line 53 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
struct bf {
   bool bf_committed ;
   bool bf_ondisk ;
   long bf_flags ;
   int bf_disk_fd ;
   char *bf_buf ;
   int bf_bufsize ;
   int bf_buffilled ;
   char *bf_filename ;
   mode_t bf_filemode ;
   off_t bf_offset ;
   int bf_size ;
};
#line 74 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
struct bf_info {
   char *bi_filename ;
   mode_t bi_fmode ;
   size_t bi_bsize ;
   long bi_flags ;
};
#line 49 "/usr/include/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 2247 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
union __anonunion___u_65___1 {
   int __in ;
   int __i ;
};
#line 2413 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
union __anonunion___u_66___1 {
   int __in ;
   int __i ;
};
#line 2425 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
union __anonunion___u_67___1 {
   int __in ;
   int __i ;
};
#line 2421 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
union __anonunion___u_68___1 {
   int __in ;
   int __i ;
};
#line 2435 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
union __anonunion___u_69___0 {
   int __in ;
   int __i ;
};
#line 2419 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
union __anonunion___u_70___0 {
   int __in ;
   int __i ;
};
#line 30 "/usr/include/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
#line 33
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
#line 36
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
#line 41
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
#line 41 "/usr/include/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_major(unsigned long long __dev ) 
{ 


  {
#line 44
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 47
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
#line 47 "/usr/include/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_minor(unsigned long long __dev ) 
{ 


  {
#line 50
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 53
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
#line 53 "/usr/include/sys/sysmacros.h"
__inline extern unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 


  {
#line 56
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 54 "../../include/sm/debug.h"
char const   SmDebugMagic[9] ;
#line 22 "../../include/sm/xtrap.h"
SM_ATOMIC_UINT_T SmXtrapCount  ;
#line 23
SM_DEBUG_T SmXtrapDebug ;
#line 24
SM_DEBUG_T SmXtrapReport ;
#line 17 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/xtrap.c"
SM_DEBUG_T SmXtrapDebug  =    {SmDebugMagic, (SM_ATOMIC_UINT_T )-1, (char *)"sm_xtrap", (char *)"@(#)$Debug: sm_xtrap - raise exception at N\'th xtrap point $",
    (SM_DEBUG_T *)((void *)0)};
#line 20 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/xtrap.c"
SM_DEBUG_T SmXtrapReport  =    {SmDebugMagic, (SM_ATOMIC_UINT_T )-1, (char *)"sm_xtrap_report", (char *)"@(#)$Debug: sm_xtrap_report - report xtrap count on exit $",
    (SM_DEBUG_T *)((void *)0)};
#line 38 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 37 "../../include/sm/heap.h"
void sm_free_tagged(void *ptr , char *tag , int num ) ;
#line 31 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/local.h"
void sm_init(void) ;
#line 33
void sm_makebuf(SM_FILE_T *fp ) ;
#line 36
int sm_wsetup(SM_FILE_T *fp ) ;
#line 78
bool Sm_IO_DidInit ;
#line 37 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/wsetup.c"
int sm_wsetup(SM_FILE_T *fp ) 
{ 
  int *tmp ;
  char *__cil_tmp3 ;

  {
#line 42
  if (! Sm_IO_DidInit) {
    {
#line 43
    sm_init();
    }
  }
#line 46
  if ((fp->f_flags & 32L) == 0L) {
#line 48
    if ((fp->f_flags & 64L) == 0L) {
      {
#line 50
      tmp = __errno_location();
#line 50
      *tmp = 9;
      }
#line 51
      return (-1);
    }
#line 53
    if (fp->f_flags & 16L) {
#line 56
      if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 57
        if ((unsigned long )fp->f_ub.smb_base != (unsigned long )(fp->f_ubuf)) {
          {
#line 57
          sm_free_tagged((void *)((char *)fp->f_ub.smb_base), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/wsetup.c",
                         57);
          }
        }
#line 57
        fp->f_ub.smb_base = (unsigned char *)((void *)0);
      }
#line 60
      fp->f_flags &= -145L;
#line 61
      fp->f_r = 0;
#line 62
      fp->f_p = fp->f_bf.smb_base;
    }
#line 64
    fp->f_flags |= 32L;
  }
#line 68
  if ((unsigned long )fp->f_bf.smb_base == (unsigned long )((void *)0)) {
    {
#line 69
    sm_makebuf(fp);
    }
  }
#line 70
  if (fp->f_flags & 2L) {
#line 78
    fp->f_w = 0;
#line 79
    fp->f_lbfsize = - fp->f_bf.smb_size;
  } else
#line 82
  if (fp->f_flags & 4L) {
#line 82
    fp->f_w = 0;
  } else {
#line 82
    fp->f_w = fp->f_bf.smb_size;
  }
#line 83
  return (0);
}
}
#line 273 "../../include/sm/io.h"
int sm_io_flush(SM_FILE_T *fp , int timeout ) ;
#line 346
int sm_wbuf(SM_FILE_T *fp , int timeout , int c ) ;
#line 40 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/wbuf.c"
int sm_wbuf(SM_FILE_T *fp , int timeout , int c ) 
{ 
  register int n ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;

  {
#line 56
  fp->f_w = fp->f_lbfsize;
#line 57
  if ((fp->f_flags & 32L) == 0L) {
#line 57
    goto _L;
  } else
#line 57
  if ((unsigned long )fp->f_bf.smb_base == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 57
    tmp___0 = sm_wsetup(fp);
    }
#line 57
    if (tmp___0) {
      {
#line 59
      tmp = __errno_location();
#line 59
      *tmp = 9;
      }
#line 60
      return (-1);
    }
  }
#line 62
  c = (int )((unsigned char )c);
#line 75
  n = (int )(fp->f_p - fp->f_bf.smb_base);
#line 76
  if (n >= fp->f_bf.smb_size) {
    {
#line 78
    tmp___1 = sm_io_flush(fp, timeout);
    }
#line 78
    if (tmp___1) {
#line 79
      return (-1);
    }
#line 80
    n = 0;
  }
#line 82
  (fp->f_w) --;
#line 83
  tmp___2 = fp->f_p;
#line 83
  (fp->f_p) ++;
#line 83
  *tmp___2 = (unsigned char )c;
#line 84
  n ++;
#line 84
  if (n == fp->f_bf.smb_size) {
#line 84
    goto _L___0;
  } else
#line 84
  if (fp->f_flags & 2L) {
#line 84
    if (c == 10) {
      _L___0: /* CIL Label */ 
      {
#line 85
      tmp___3 = sm_io_flush(fp, timeout);
      }
#line 85
      if (tmp___3) {
#line 86
        return (-1);
      }
    }
  }
#line 87
  return (c);
}
}
#line 152 "../../include/sm/io.h"
char const   SmFileMagic[8] ;
#line 303
int sm_io_vfprintf(SM_FILE_T *fp , int timeout , char const   *fmt0 , va_list ap ) ;
#line 325
int sm_vsnprintf(char *str , size_t n , char const   *fmt , va_list ap ) ;
#line 40 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vsnprintf.c"
int sm_vsnprintf(char *str , size_t n , char const   *fmt , va_list ap ) 
{ 
  int ret ;
  char dummy ;
  SM_FILE_T fake ;
  char *__cil_tmp8 ;

  {
#line 52
  if (n > 2147483647U) {
#line 53
    n = (size_t )2147483647;
  }
#line 56
  if (n == 0U) {
#line 58
    str = & dummy;
#line 59
    n = (size_t )1;
  }
  {
#line 61
  fake.sm_magic = SmFileMagic;
#line 62
  fake.f_timeout = -1;
#line 63
  fake.f_timeoutstate = 0;
#line 64
  fake.f_file = (short)-1;
#line 65
  fake.f_flags = 2080L;
#line 66
  fake.f_p = (unsigned char *)str;
#line 66
  fake.f_bf.smb_base = fake.f_p;
#line 67
  fake.f_w = (int )(n - 1U);
#line 67
  fake.f_bf.smb_size = fake.f_w;
#line 68
  fake.f_close = (int (*)(SM_FILE_T * ))((void *)0);
#line 69
  fake.f_open = (int (*)(SM_FILE_T * , void const   * , int  , void const   * ))((void *)0);
#line 70
  fake.f_read = (ssize_t (*)(SM_FILE_T * , char * , size_t  ))((void *)0);
#line 71
  fake.f_write = (ssize_t (*)(SM_FILE_T * , char const   * , size_t  ))((void *)0);
#line 72
  fake.f_seek = (off_t (*)(SM_FILE_T * , off_t  , int  ))((void *)0);
#line 73
  fake.f_getinfo = (int (*)(SM_FILE_T * , int  , void * ))((void *)0);
#line 73
  fake.f_setinfo = fake.f_getinfo;
#line 74
  fake.f_type = (char *)"sm_vsnprintf:fake";
#line 75
  ret = sm_io_vfprintf(& fake, -1, fmt, ap);
#line 76
  *(fake.f_p) = (unsigned char)0;
  }
#line 77
  return (ret);
}
}
#line 151 "../../include/sm/io.h"
SM_FILE_T SmIoF[6] ;
#line 39 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/local.h"
int sm_vprintf(int timeout , char const   *fmt , va_list ap ) ;
#line 32 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vprintf.c"
int sm_vprintf(int timeout , char const   *fmt , va_list ap ) 
{ 
  int tmp ;

  {
  {
#line 38
  tmp = sm_io_vfprintf(& SmIoF[4], timeout, fmt, ap);
  }
#line 38
  return (tmp);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 165 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
#line 58 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 108
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 289 "../../include/sm/io.h"
size_t sm_io_read(SM_FILE_T *fp , int timeout , void *buf___16 , size_t size ) ;
#line 302
int sm_io_ungetc(SM_FILE_T *fp , int timeout , int c ) ;
#line 344
int sm_vfscanf(SM_FILE_T *fp , int timeout , char const   *fmt0 , va_list ap ) ;
#line 53 "../../include/sm/clock.h"
void sm_clrevent(SM_EVENT *ev ) ;
#line 55
SM_EVENT *sm_seteventm(int intvl , void (*func)(int  ) , int arg ) ;
#line 104 "../../include/sm/string.h"
LONGLONG_T sm_strtoll(char const   *nptr , char **endptr , int base ) ;
#line 107
ULONGLONG_T sm_strtoull(char const   *nptr , char **endptr , int base ) ;
#line 30 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/local.h"
int sm_refill(SM_FILE_T *fp , int timeout ) ;
#line 63 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfscanf.c"
static void scanalrm(int sig ) ;
#line 64
static unsigned char *sm_sccl(char *tab , unsigned char *fmt ) ;
#line 65 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfscanf.c"
static sigjmp_buf ScanTimeOut  ;
#line 87 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfscanf.c"
static void scanalrm(int sig ) 
{ 


  {
  {
#line 91
  siglongjmp((struct __jmp_buf_tag *)(ScanTimeOut), 1);
  }
}
}
#line 131 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfscanf.c"
static short basefix[17]  = 
#line 131
  {      (short)10,      (short)1,      (short)2,      (short)3, 
        (short)4,      (short)5,      (short)6,      (short)7, 
        (short)8,      (short)9,      (short)10,      (short)11, 
        (short)12,      (short)13,      (short)14,      (short)15, 
        (short)16};
#line 108 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfscanf.c"
int sm_vfscanf(SM_FILE_T *fp , int timeout , char const   *fmt0 , va_list ap ) 
{ 
  register unsigned char *fmt ;
  register int c ;
  register size_t width ;
  register char *p ;
  register int n ;
  register int flags ;
  register char *p0 ;
  int nassigned ;
  int nread ;
  int base ;
  ULONGLONG_T (*ccfn)() ;
  char ccltab[256] ;
  char buf___16[513] ;
  SM_EVENT *evt ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  short *tmp___9 ;
  long *tmp___11 ;
  int *tmp___13 ;
  unsigned short const   **tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned short const   **tmp___17 ;
  size_t sum ;
  int tmp___18 ;
  size_t r ;
  char *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  unsigned char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  unsigned short const   **tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  unsigned char *tmp___30 ;
  int tmp___31 ;
  unsigned short const   **tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  ULONGLONG_T res ;
  void **tmp___36 ;
  LONGLONG_T *tmp___38 ;
  long *tmp___40 ;
  short *tmp___42 ;
  int *tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  double res___0 ;
  double *tmp___48 ;
  float *tmp___50 ;
  int tmp___51 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;

  {
#line 115
  fmt = (unsigned char *)fmt0;
#line 128
  evt = (SM_EVENT *)((void *)0);
#line 134
  if (timeout == -2) {
#line 135
    timeout = fp->f_timeout;
  }
#line 136
  if (timeout == 0) {
    {
#line 143
    tmp = __errno_location();
#line 143
    *tmp = 11;
    }
#line 144
    return (-1);
  }
#line 147
  if (timeout != -1) {
    {
#line 149
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(ScanTimeOut), 1);
    }
#line 149
    if (tmp___1 != 0) {
      {
#line 151
      tmp___0 = __errno_location();
#line 151
      *tmp___0 = 11;
      }
#line 152
      return (-1);
    }
    {
#line 155
    evt = sm_seteventm(timeout, & scanalrm, 0);
    }
  }
#line 158
  nassigned = 0;
#line 159
  nread = 0;
#line 160
  base = 0;
#line 161
  ccfn = (ULONGLONG_T (*)())((void *)0);
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    tmp___2 = fmt;
#line 164
    fmt ++;
#line 164
    c = (int )*tmp___2;
#line 165
    if (c == 0) {
#line 167
      if ((unsigned long )evt != (unsigned long )((void *)0)) {
        {
#line 168
        sm_clrevent(evt);
        }
      }
#line 169
      return (nassigned);
    }
    {
#line 171
    tmp___5 = __ctype_b_loc();
    }
#line 171
    if ((int const   )*(*tmp___5 + c) & 8192) {
      {
#line 173
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 173
        if (fp->f_r > 0) {
#line 173
          goto _L;
        } else {
          {
#line 173
          tmp___3 = sm_refill(fp, -1);
          }
#line 173
          if (tmp___3 == 0) {
            _L: /* CIL Label */ 
            {
#line 173
            tmp___4 = __ctype_b_loc();
            }
#line 173
            if (! ((int const   )*(*tmp___4 + (int )*(fp->f_p)) & 8192)) {
#line 173
              goto while_break___0;
            }
          } else {
#line 173
            goto while_break___0;
          }
        }
#line 176
        nread ++;
#line 176
        (fp->f_r) --;
#line 176
        (fp->f_p) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 177
      goto __Cont;
    }
#line 179
    if (c != 37) {
#line 180
      goto literal;
    }
#line 181
    width = (size_t )0;
#line 182
    flags = 0;
    again: 
#line 189
    tmp___6 = fmt;
#line 189
    fmt ++;
#line 189
    c = (int )*tmp___6;
    {
#line 192
    if (c == 37) {
#line 192
      goto literal;
    }
#line 202
    if (c == 42) {
#line 202
      goto case_42;
    }
#line 205
    if (c == 104) {
#line 205
      goto case_104;
    }
#line 208
    if (c == 108) {
#line 208
      goto case_108;
    }
#line 219
    if (c == 113) {
#line 219
      goto case_113;
    }
#line 224
    if (c == 57) {
#line 224
      goto case_57;
    }
#line 224
    if (c == 56) {
#line 224
      goto case_57;
    }
#line 224
    if (c == 55) {
#line 224
      goto case_57;
    }
#line 224
    if (c == 54) {
#line 224
      goto case_57;
    }
#line 224
    if (c == 53) {
#line 224
      goto case_57;
    }
#line 224
    if (c == 52) {
#line 224
      goto case_57;
    }
#line 224
    if (c == 51) {
#line 224
      goto case_57;
    }
#line 224
    if (c == 50) {
#line 224
      goto case_57;
    }
#line 224
    if (c == 49) {
#line 224
      goto case_57;
    }
#line 224
    if (c == 48) {
#line 224
      goto case_57;
    }
#line 236
    if (c == 68) {
#line 236
      goto case_68;
    }
#line 239
    if (c == 100) {
#line 239
      goto case_100;
    }
#line 245
    if (c == 105) {
#line 245
      goto case_105;
    }
#line 251
    if (c == 79) {
#line 251
      goto case_79;
    }
#line 254
    if (c == 111) {
#line 254
      goto case_111;
    }
#line 260
    if (c == 117) {
#line 260
      goto case_117;
    }
#line 267
    if (c == 120) {
#line 267
      goto case_120;
    }
#line 267
    if (c == 88) {
#line 267
      goto case_120;
    }
#line 278
    if (c == 103) {
#line 278
      goto case_103;
    }
#line 278
    if (c == 102) {
#line 278
      goto case_103;
    }
#line 278
    if (c == 101) {
#line 278
      goto case_103;
    }
#line 278
    if (c == 71) {
#line 278
      goto case_103;
    }
#line 278
    if (c == 69) {
#line 278
      goto case_103;
    }
#line 282
    if (c == 115) {
#line 282
      goto case_115;
    }
#line 286
    if (c == 91) {
#line 286
      goto case_91;
    }
#line 292
    if (c == 99) {
#line 292
      goto case_99;
    }
#line 297
    if (c == 112) {
#line 297
      goto case_112;
    }
#line 304
    if (c == 110) {
#line 304
      goto case_110;
    }
#line 316
    if (c == 0) {
#line 316
      goto case_0;
    }
#line 321
    goto switch_default;
    literal: 
    case_37: /* CIL Label */ 
#line 194
    if (fp->f_r <= 0) {
      {
#line 194
      tmp___7 = sm_refill(fp, -1);
      }
#line 194
      if (tmp___7) {
#line 195
        goto input_failure;
      }
    }
#line 196
    if ((int )*(fp->f_p) != c) {
#line 197
      goto match_failure;
    }
#line 198
    (fp->f_r) --;
#line 198
    (fp->f_p) ++;
#line 199
    nread ++;
#line 200
    goto __Cont;
    case_42: /* CIL Label */ 
#line 203
    flags |= 16;
#line 204
    goto again;
    case_104: /* CIL Label */ 
#line 206
    flags |= 4;
#line 207
    goto again;
    case_108: /* CIL Label */ 
#line 209
    if ((int )*fmt == 108) {
#line 211
      fmt ++;
#line 212
      flags |= 8;
    } else {
#line 216
      flags |= 1;
    }
#line 218
    goto again;
    case_113: /* CIL Label */ 
#line 220
    flags |= 8;
#line 221
    goto again;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 225
    width = (width * 10U + (size_t )c) - 48U;
#line 226
    goto again;
    case_68: /* CIL Label */ 
#line 237
    flags |= 1;
    case_100: /* CIL Label */ 
#line 240
    c = 3;
#line 241
    ccfn = (ULONGLONG_T (*)())(& sm_strtoll);
#line 242
    base = 10;
#line 243
    goto switch_break;
    case_105: /* CIL Label */ 
#line 246
    c = 3;
#line 247
    ccfn = (ULONGLONG_T (*)())(& sm_strtoll);
#line 248
    base = 0;
#line 249
    goto switch_break;
    case_79: /* CIL Label */ 
#line 252
    flags |= 1;
    case_111: /* CIL Label */ 
#line 255
    c = 3;
#line 256
    ccfn = (ULONGLONG_T (*)())(& sm_strtoull);
#line 257
    base = 8;
#line 258
    goto switch_break;
    case_117: /* CIL Label */ 
#line 261
    c = 3;
#line 262
    ccfn = (ULONGLONG_T (*)())(& sm_strtoull);
#line 263
    base = 10;
#line 264
    goto switch_break;
    case_120: /* CIL Label */ 
    case_88: /* CIL Label */ 
#line 268
    flags |= 512;
#line 269
    c = 3;
#line 270
    ccfn = (ULONGLONG_T (*)())(& sm_strtoull);
#line 271
    base = 16;
#line 272
    goto switch_break;
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 279
    c = 4;
#line 280
    goto switch_break;
    case_115: /* CIL Label */ 
#line 283
    c = 2;
#line 284
    goto switch_break;
    case_91: /* CIL Label */ 
    {
#line 287
    fmt = sm_sccl(ccltab, fmt);
#line 288
    flags |= 64;
#line 289
    c = 1;
    }
#line 290
    goto switch_break;
    case_99: /* CIL Label */ 
#line 293
    flags |= 64;
#line 294
    c = 0;
#line 295
    goto switch_break;
    case_112: /* CIL Label */ 
#line 298
    flags |= 544;
#line 299
    c = 3;
#line 300
    ccfn = (ULONGLONG_T (*)())(& sm_strtoull);
#line 301
    base = 16;
#line 302
    goto switch_break;
    case_110: /* CIL Label */ 
#line 305
    if (flags & 16) {
#line 306
      goto __Cont;
    }
#line 307
    if (flags & 4) {
      {
#line 308
      tmp___9 = __builtin_va_arg(ap, short *);
#line 308
      *tmp___9 = (short )nread;
      }
    } else
#line 309
    if (flags & 1) {
      {
#line 310
      tmp___11 = __builtin_va_arg(ap, long *);
#line 310
      *tmp___11 = (long )nread;
      }
    } else {
      {
#line 312
      tmp___13 = __builtin_va_arg(ap, int *);
#line 312
      *tmp___13 = nread;
      }
    }
#line 313
    goto __Cont;
    case_0: /* CIL Label */ 
#line 317
    if ((unsigned long )evt != (unsigned long )((void *)0)) {
      {
#line 318
      sm_clrevent(evt);
      }
    }
#line 319
    return (-1);
    switch_default: /* CIL Label */ 
    {
#line 322
    tmp___14 = __ctype_b_loc();
    }
#line 322
    if ((int const   )*(*tmp___14 + c) & 256) {
#line 323
      flags |= 1;
    }
#line 324
    c = 3;
#line 325
    ccfn = (ULONGLONG_T (*)())(& sm_strtoll);
#line 326
    base = 10;
#line 327
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 331
    if (fp->f_r <= 0) {
      {
#line 331
      tmp___15 = sm_refill(fp, -1);
      }
#line 331
      if (tmp___15) {
#line 332
        goto input_failure;
      }
    }
#line 339
    if ((flags & 64) == 0) {
      {
#line 341
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 341
        tmp___17 = __ctype_b_loc();
        }
#line 341
        if (! ((int const   )*(*tmp___17 + (int )*(fp->f_p)) & 8192)) {
#line 341
          goto while_break___1;
        }
#line 343
        nread ++;
#line 344
        (fp->f_r) --;
#line 344
        if (fp->f_r > 0) {
#line 345
          (fp->f_p) ++;
        } else {
          {
#line 346
          tmp___16 = sm_refill(fp, -1);
          }
#line 346
          if (tmp___16) {
#line 347
            goto input_failure;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 359
    if (c == 0) {
#line 359
      goto case_0___0;
    }
#line 405
    if (c == 1) {
#line 405
      goto case_1;
    }
#line 456
    if (c == 2) {
#line 456
      goto case_2;
    }
#line 493
    if (c == 3) {
#line 493
      goto case_3;
    }
#line 646
    if (c == 4) {
#line 646
      goto case_4;
    }
#line 357
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 361
    if (width == 0U) {
#line 362
      width = (size_t )1;
    }
#line 363
    if (flags & 16) {
#line 365
      sum = (size_t )0;
      {
#line 366
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 368
        n = fp->f_r;
#line 368
        if ((size_t )n < width) {
          {
#line 370
          sum += (size_t )n;
#line 371
          width -= (size_t )n;
#line 372
          fp->f_p += n;
#line 373
          tmp___18 = sm_refill(fp, -1);
          }
#line 373
          if (tmp___18) {
#line 376
            if (sum == 0U) {
#line 377
              goto input_failure;
            }
#line 378
            goto while_break___2;
          }
        } else {
#line 383
          sum += width;
#line 384
          fp->f_r = (int )((size_t )fp->f_r - width);
#line 385
          fp->f_p += width;
#line 386
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 389
      nread = (int )((size_t )nread + sum);
    } else {
      {
#line 395
      tmp___20 = __builtin_va_arg(ap, char *);
#line 395
      r = sm_io_read(fp, -1, (void *)tmp___20, width);
      }
#line 398
      if (r == 0U) {
#line 399
        goto input_failure;
      }
#line 400
      nread = (int )((size_t )nread + r);
#line 401
      nassigned ++;
    }
#line 403
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 407
    if (width == 0U) {
#line 408
      width = (size_t )(~ 0);
    }
#line 411
    if (flags & 16) {
#line 413
      n = 0;
      {
#line 414
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 414
        if (! ((int )ccltab[*(fp->f_p)] != 0)) {
#line 414
          goto while_break___3;
        }
#line 416
        n ++;
#line 416
        (fp->f_r) --;
#line 416
        (fp->f_p) ++;
#line 417
        width --;
#line 417
        if (width == 0U) {
#line 418
          goto while_break___3;
        }
#line 419
        if (fp->f_r <= 0) {
          {
#line 419
          tmp___21 = sm_refill(fp, -1);
          }
#line 419
          if (tmp___21) {
#line 422
            if (n == 0) {
#line 423
              goto input_failure;
            }
#line 424
            goto while_break___3;
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 427
      if (n == 0) {
#line 428
        goto match_failure;
      }
    } else {
      {
#line 432
      tmp___22 = __builtin_va_arg(ap, char *);
#line 432
      p = tmp___22;
#line 432
      p0 = p;
      }
      {
#line 433
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 433
        if (! ((int )ccltab[*(fp->f_p)] != 0)) {
#line 433
          goto while_break___4;
        }
#line 435
        (fp->f_r) --;
#line 436
        tmp___23 = p;
#line 436
        p ++;
#line 436
        tmp___24 = fp->f_p;
#line 436
        (fp->f_p) ++;
#line 436
        *tmp___23 = (char )*tmp___24;
#line 437
        width --;
#line 437
        if (width == 0U) {
#line 438
          goto while_break___4;
        }
#line 439
        if (fp->f_r <= 0) {
          {
#line 439
          tmp___25 = sm_refill(fp, -1);
          }
#line 439
          if (tmp___25) {
#line 442
            if ((unsigned long )p == (unsigned long )p0) {
#line 443
              goto input_failure;
            }
#line 444
            goto while_break___4;
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 447
      n = (int )(p - p0);
#line 448
      if (n == 0) {
#line 449
        goto match_failure;
      }
#line 450
      *p = (char)0;
#line 451
      nassigned ++;
    }
#line 453
    nread += n;
#line 454
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 458
    if (width == 0U) {
#line 459
      width = (size_t )(~ 0);
    }
#line 460
    if (flags & 16) {
#line 462
      n = 0;
      {
#line 463
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 463
        tmp___27 = __ctype_b_loc();
        }
#line 463
        if ((int const   )*(*tmp___27 + (int )*(fp->f_p)) & 8192) {
#line 463
          goto while_break___5;
        }
#line 465
        n ++;
#line 465
        (fp->f_r) --;
#line 465
        (fp->f_p) ++;
#line 466
        width --;
#line 466
        if (width == 0U) {
#line 467
          goto while_break___5;
        }
#line 468
        if (fp->f_r <= 0) {
          {
#line 468
          tmp___26 = sm_refill(fp, -1);
          }
#line 468
          if (tmp___26) {
#line 470
            goto while_break___5;
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 472
      nread += n;
    } else {
      {
#line 476
      tmp___28 = __builtin_va_arg(ap, char *);
#line 476
      p = tmp___28;
#line 476
      p0 = p;
      }
      {
#line 477
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 477
        tmp___32 = __ctype_b_loc();
        }
#line 477
        if ((int const   )*(*tmp___32 + (int )*(fp->f_p)) & 8192) {
#line 477
          goto while_break___6;
        }
#line 479
        (fp->f_r) --;
#line 480
        tmp___29 = p;
#line 480
        p ++;
#line 480
        tmp___30 = fp->f_p;
#line 480
        (fp->f_p) ++;
#line 480
        *tmp___29 = (char )*tmp___30;
#line 481
        width --;
#line 481
        if (width == 0U) {
#line 482
          goto while_break___6;
        }
#line 483
        if (fp->f_r <= 0) {
          {
#line 483
          tmp___31 = sm_refill(fp, -1);
          }
#line 483
          if (tmp___31) {
#line 485
            goto while_break___6;
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 487
      *p = (char)0;
#line 488
      nread = (int )((long )nread + (p - p0));
#line 489
      nassigned ++;
    }
#line 491
    goto __Cont;
    case_3: /* CIL Label */ 
#line 500
    width --;
#line 500
    if ((unsigned long )width > sizeof(buf___16) - 2UL) {
#line 501
      width = (size_t )(sizeof(buf___16) - 2UL);
    }
#line 502
    width ++;
#line 504
    flags |= 1408;
#line 505
    p = buf___16;
    {
#line 505
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 505
      if (! (width > 0U)) {
#line 505
        goto while_break___7;
      }
#line 507
      c = (int )*(fp->f_p);
      {
#line 530
      if (c == 48) {
#line 530
        goto case_48___0;
      }
#line 544
      if (c == 55) {
#line 544
        goto case_55___0;
      }
#line 544
      if (c == 54) {
#line 544
        goto case_55___0;
      }
#line 544
      if (c == 53) {
#line 544
        goto case_55___0;
      }
#line 544
      if (c == 52) {
#line 544
        goto case_55___0;
      }
#line 544
      if (c == 51) {
#line 544
        goto case_55___0;
      }
#line 544
      if (c == 50) {
#line 544
        goto case_55___0;
      }
#line 544
      if (c == 49) {
#line 544
        goto case_55___0;
      }
#line 550
      if (c == 57) {
#line 550
        goto case_57___0;
      }
#line 550
      if (c == 56) {
#line 550
        goto case_57___0;
      }
#line 561
      if (c == 102) {
#line 561
        goto case_102___0;
      }
#line 561
      if (c == 101) {
#line 561
        goto case_102___0;
      }
#line 561
      if (c == 100) {
#line 561
        goto case_102___0;
      }
#line 561
      if (c == 99) {
#line 561
        goto case_102___0;
      }
#line 561
      if (c == 98) {
#line 561
        goto case_102___0;
      }
#line 561
      if (c == 97) {
#line 561
        goto case_102___0;
      }
#line 561
      if (c == 70) {
#line 561
        goto case_102___0;
      }
#line 561
      if (c == 69) {
#line 561
        goto case_102___0;
      }
#line 561
      if (c == 68) {
#line 561
        goto case_102___0;
      }
#line 561
      if (c == 67) {
#line 561
        goto case_102___0;
      }
#line 561
      if (c == 66) {
#line 561
        goto case_102___0;
      }
#line 561
      if (c == 65) {
#line 561
        goto case_102___0;
      }
#line 570
      if (c == 45) {
#line 570
        goto case_45;
      }
#line 570
      if (c == 43) {
#line 570
        goto case_45;
      }
#line 579
      if (c == 88) {
#line 579
        goto case_88___0;
      }
#line 579
      if (c == 120) {
#line 579
        goto case_88___0;
      }
#line 514
      goto switch_break___1;
      case_48___0: /* CIL Label */ 
#line 531
      if (base == 0) {
#line 533
        base = 8;
#line 534
        flags |= 512;
      }
#line 536
      if (flags & 1024) {
#line 537
        flags &= -1409;
      } else {
#line 539
        flags &= -897;
      }
#line 540
      goto ok;
      case_55___0: /* CIL Label */ 
      case_54___0: /* CIL Label */ 
      case_53___0: /* CIL Label */ 
      case_52___0: /* CIL Label */ 
      case_51___0: /* CIL Label */ 
      case_50___0: /* CIL Label */ 
      case_49___0: /* CIL Label */ 
#line 545
      base = (int )basefix[base];
#line 546
      flags &= -897;
#line 547
      goto ok;
      case_57___0: /* CIL Label */ 
      case_56___0: /* CIL Label */ 
#line 551
      base = (int )basefix[base];
#line 552
      if (base <= 8) {
#line 553
        goto switch_break___1;
      }
#line 554
      flags &= -897;
#line 555
      goto ok;
      case_102___0: /* CIL Label */ 
      case_101___0: /* CIL Label */ 
      case_100___0: /* CIL Label */ 
      case_99___0: /* CIL Label */ 
      case_98: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_69___0: /* CIL Label */ 
      case_68___0: /* CIL Label */ 
      case_67: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_65: /* CIL Label */ 
#line 564
      if (base <= 10) {
#line 565
        goto switch_break___1;
      }
#line 566
      flags &= -897;
#line 567
      goto ok;
      case_45: /* CIL Label */ 
      case_43: /* CIL Label */ 
#line 571
      if (flags & 128) {
#line 573
        flags &= -129;
#line 574
        goto ok;
      }
#line 576
      goto switch_break___1;
      case_88___0: /* CIL Label */ 
      case_120___0: /* CIL Label */ 
#line 580
      if (flags & 512) {
#line 580
        if ((unsigned long )p == (unsigned long )(buf___16 + 1)) {
#line 582
          base = 16;
#line 583
          flags &= -513;
#line 584
          goto ok;
        }
      }
#line 586
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 594
      goto while_break___7;
      ok: 
#line 597
      tmp___33 = p;
#line 597
      p ++;
#line 597
      *tmp___33 = (char )c;
#line 598
      (fp->f_r) --;
#line 598
      if (fp->f_r > 0) {
#line 599
        (fp->f_p) ++;
      } else {
        {
#line 600
        tmp___34 = sm_refill(fp, -1);
        }
#line 600
        if (tmp___34) {
#line 601
          goto while_break___7;
        }
      }
#line 505
      width --;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 611
    if (flags & 256) {
#line 613
      if ((unsigned long )p > (unsigned long )(buf___16)) {
        {
#line 614
        p --;
#line 614
        sm_io_ungetc(fp, -2, (int )*((unsigned char *)p));
        }
      }
#line 616
      goto match_failure;
    }
#line 618
    c = (int )*((unsigned char *)p + -1);
#line 619
    if (c == 120) {
      {
#line 621
      p --;
#line 622
      sm_io_ungetc(fp, -2, c);
      }
    } else
#line 619
    if (c == 88) {
      {
#line 621
      p --;
#line 622
      sm_io_ungetc(fp, -2, c);
      }
    }
#line 624
    if ((flags & 16) == 0) {
      {
#line 628
      *p = (char)0;
#line 629
      res = (*ccfn)(buf___16, (char **)((void *)0), base);
      }
#line 630
      if (flags & 32) {
        {
#line 631
        tmp___36 = __builtin_va_arg(ap, void **);
#line 631
        *tmp___36 = (void *)((long )res);
        }
      } else
#line 633
      if (flags & 8) {
        {
#line 634
        tmp___38 = __builtin_va_arg(ap, LONGLONG_T *);
#line 634
        *tmp___38 = (LONGLONG_T )res;
        }
      } else
#line 635
      if (flags & 1) {
        {
#line 636
        tmp___40 = __builtin_va_arg(ap, long *);
#line 636
        *tmp___40 = (long )res;
        }
      } else
#line 637
      if (flags & 4) {
        {
#line 638
        tmp___42 = __builtin_va_arg(ap, short *);
#line 638
        *tmp___42 = (short )res;
        }
      } else {
        {
#line 640
        tmp___44 = __builtin_va_arg(ap, int *);
#line 640
        *tmp___44 = (int )res;
        }
      }
#line 641
      nassigned ++;
    }
#line 643
    nread = (int )((long )nread + (p - buf___16));
#line 644
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 648
    if (width == 0U) {
#line 649
      width = (size_t )(sizeof(buf___16) - 1UL);
    } else
#line 648
    if ((unsigned long )width > sizeof(buf___16) - 1UL) {
#line 649
      width = (size_t )(sizeof(buf___16) - 1UL);
    }
#line 650
    flags |= 1920;
#line 651
    p = buf___16;
    {
#line 651
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 651
      if (! width) {
#line 651
        goto while_break___8;
      }
#line 653
      c = (int )*(fp->f_p);
      {
#line 665
      if (c == 57) {
#line 665
        goto case_57___1;
      }
#line 665
      if (c == 56) {
#line 665
        goto case_57___1;
      }
#line 665
      if (c == 55) {
#line 665
        goto case_57___1;
      }
#line 665
      if (c == 54) {
#line 665
        goto case_57___1;
      }
#line 665
      if (c == 53) {
#line 665
        goto case_57___1;
      }
#line 665
      if (c == 52) {
#line 665
        goto case_57___1;
      }
#line 665
      if (c == 51) {
#line 665
        goto case_57___1;
      }
#line 665
      if (c == 50) {
#line 665
        goto case_57___1;
      }
#line 665
      if (c == 49) {
#line 665
        goto case_57___1;
      }
#line 665
      if (c == 48) {
#line 665
        goto case_57___1;
      }
#line 669
      if (c == 45) {
#line 669
        goto case_45___0;
      }
#line 669
      if (c == 43) {
#line 669
        goto case_45___0;
      }
#line 676
      if (c == 46) {
#line 676
        goto case_46;
      }
#line 683
      if (c == 69) {
#line 683
        goto case_69___1;
      }
#line 683
      if (c == 101) {
#line 683
        goto case_69___1;
      }
#line 660
      goto switch_break___2;
      case_57___1: /* CIL Label */ 
      case_56___1: /* CIL Label */ 
      case_55___1: /* CIL Label */ 
      case_54___1: /* CIL Label */ 
      case_53___1: /* CIL Label */ 
      case_52___1: /* CIL Label */ 
      case_51___1: /* CIL Label */ 
      case_50___1: /* CIL Label */ 
      case_49___1: /* CIL Label */ 
      case_48___1: /* CIL Label */ 
#line 666
      flags &= -385;
#line 667
      goto fok;
      case_45___0: /* CIL Label */ 
      case_43___0: /* CIL Label */ 
#line 670
      if (flags & 128) {
#line 672
        flags &= -129;
#line 673
        goto fok;
      }
#line 675
      goto switch_break___2;
      case_46: /* CIL Label */ 
#line 677
      if (flags & 512) {
#line 679
        flags &= -641;
#line 680
        goto fok;
      }
#line 682
      goto switch_break___2;
      case_69___1: /* CIL Label */ 
      case_101___1: /* CIL Label */ 
#line 686
      if ((flags & 1280) == 1024) {
#line 688
        flags = ((flags & -1537) | 128) | 256;
#line 691
        goto fok;
      }
#line 693
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
#line 695
      goto while_break___8;
      fok: 
#line 697
      tmp___45 = p;
#line 697
      p ++;
#line 697
      *tmp___45 = (char )c;
#line 698
      (fp->f_r) --;
#line 698
      if (fp->f_r > 0) {
#line 699
        (fp->f_p) ++;
      } else {
        {
#line 700
        tmp___46 = sm_refill(fp, -1);
        }
#line 700
        if (tmp___46) {
#line 701
          goto while_break___8;
        }
      }
#line 651
      width --;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 710
    if (flags & 256) {
#line 712
      if (flags & 1024) {
        {
#line 715
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 715
          if (! ((unsigned long )p > (unsigned long )(buf___16))) {
#line 715
            goto while_break___9;
          }
          {
#line 716
          p --;
#line 716
          sm_io_ungetc(fp, -2, (int )*((unsigned char *)p));
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 719
        goto match_failure;
      }
#line 723
      p --;
#line 723
      c = (int )*((unsigned char *)p);
#line 724
      if (c != 101) {
#line 724
        if (c != 69) {
          {
#line 726
          sm_io_ungetc(fp, -2, c);
#line 728
          p --;
#line 728
          c = (int )*((unsigned char *)p);
          }
        }
      }
      {
#line 730
      sm_io_ungetc(fp, -2, c);
      }
    }
#line 732
    if ((flags & 16) == 0) {
      {
#line 736
      *p = (char)0;
#line 737
      res___0 = strtod((char const   */* __restrict  */)(buf___16), (char **/* __restrict  */)((char **)((void *)0)));
      }
#line 738
      if (flags & 1) {
        {
#line 739
        tmp___48 = __builtin_va_arg(ap, double *);
#line 739
        *tmp___48 = res___0;
        }
      } else {
        {
#line 741
        tmp___50 = __builtin_va_arg(ap, float *);
#line 741
        *tmp___50 = (float )res___0;
        }
      }
#line 742
      nassigned ++;
    }
#line 744
    nread = (int )((long )nread + (p - buf___16));
#line 745
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  input_failure: 
#line 749
  if ((unsigned long )evt != (unsigned long )((void *)0)) {
    {
#line 750
    sm_clrevent(evt);
    }
  }
#line 751
  if (nassigned) {
#line 751
    tmp___51 = nassigned;
  } else {
#line 751
    tmp___51 = -1;
  }
#line 751
  return (tmp___51);
  match_failure: 
#line 753
  if ((unsigned long )evt != (unsigned long )((void *)0)) {
    {
#line 754
    sm_clrevent(evt);
    }
  }
#line 755
  return (nassigned);
}
}
#line 773 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfscanf.c"
static unsigned char *sm_sccl(char *tab , unsigned char *fmt ) 
{ 
  register int c ;
  register int n ;
  register int v ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 781
  tmp = fmt;
#line 781
  fmt ++;
#line 781
  c = (int )*tmp;
#line 782
  if (c == 94) {
#line 784
    v = 1;
#line 785
    tmp___0 = fmt;
#line 785
    fmt ++;
#line 785
    c = (int )*tmp___0;
  } else {
#line 788
    v = 0;
  }
#line 791
  n = 0;
  {
#line 791
  while (1) {
    while_continue: /* CIL Label */ ;
#line 791
    if (! (n < 256)) {
#line 791
      goto while_break;
    }
#line 792
    *(tab + n) = (char )v;
#line 791
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 793
  if (c == 0) {
#line 794
    return (fmt - 1);
  }
#line 804
  v = 1 - v;
  {
#line 805
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 807
    *(tab + c) = (char )v;
    doswitch: 
#line 809
    tmp___1 = fmt;
#line 809
    fmt ++;
#line 809
    n = (int )*tmp___1;
    {
#line 813
    if (n == 0) {
#line 813
      goto case_0;
    }
#line 816
    if (n == 45) {
#line 816
      goto case_45;
    }
#line 866
    if (n == 93) {
#line 866
      goto case_93;
    }
#line 869
    goto switch_default;
    case_0: /* CIL Label */ 
#line 814
    return (fmt - 1);
    case_45: /* CIL Label */ 
#line 836
    n = (int )*fmt;
#line 837
    if (n == 93) {
#line 839
      c = '-';
#line 840
      goto switch_break;
    } else
#line 837
    if (n < c) {
#line 839
      c = '-';
#line 840
      goto switch_break;
    }
#line 842
    fmt ++;
    {
#line 843
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 846
      c ++;
#line 846
      *(tab + c) = (char )v;
#line 843
      if (! (c < n)) {
#line 843
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 856
    goto doswitch;
    case_93: /* CIL Label */ 
#line 867
    return (fmt);
    switch_default: /* CIL Label */ 
#line 870
    c = n;
#line 871
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 59
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 242
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 329 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 35 "../../include/sm/heap.h"
void *sm_malloc_tagged(size_t size , char *tag , int num , int group ) ;
#line 36
void *sm_malloc_tagged_x(size_t size , char *tag , int num , int group ) ;
#line 38
void *sm_realloc_x(void *ptr , size_t size ) ;
#line 94
int SmHeapGroup ;
#line 30 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fvwrite.h"
int sm_fvwrite(SM_FILE_T *fp , int timeout , struct sm_uio *uio ) ;
#line 36 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c"
static int sm_bprintf(SM_FILE_T *fp , char const   *fmt , va_list ap ) ;
#line 37
static void sm_find_arguments(char const   *fmt0 , va_list ap , va_list **argtable ) ;
#line 38
static void sm_grow_type_table_x(unsigned char **typetable , int *tablesize ) ;
#line 39
static int sm_print(SM_FILE_T *fp , int timeout , struct sm_uio *uio ) ;
#line 57 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c"
static int sm_print(SM_FILE_T *fp , int timeout , struct sm_uio *uio ) 
{ 
  register int err ;

  {
#line 65
  if (uio->uio_resid == 0) {
#line 67
    uio->uio_iovcnt = 0;
#line 68
    return (0);
  }
  {
#line 70
  err = sm_fvwrite(fp, timeout, uio);
#line 71
  uio->uio_resid = 0;
#line 72
  uio->uio_iovcnt = 0;
  }
#line 73
  return (err);
}
}
#line 97 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c"
static int sm_bprintf(SM_FILE_T *fp , char const   *fmt , va_list ap ) 
{ 
  int ret ;
  SM_FILE_T fake ;
  unsigned char buf___16[4096] ;
  int tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 109
  fake.sm_magic = SmFileMagic;
#line 110
  fake.f_timeout = -1;
#line 111
  fake.f_timeoutstate = 0;
#line 112
  fake.f_flags = fp->f_flags & -5L;
#line 113
  fake.f_file = fp->f_file;
#line 114
  fake.f_cookie = fp->f_cookie;
#line 115
  fake.f_write = fp->f_write;
#line 116
  fake.f_close = (int (*)(SM_FILE_T * ))((void *)0);
#line 117
  fake.f_open = (int (*)(SM_FILE_T * , void const   * , int  , void const   * ))((void *)0);
#line 118
  fake.f_read = (ssize_t (*)(SM_FILE_T * , char * , size_t  ))((void *)0);
#line 119
  fake.f_seek = (off_t (*)(SM_FILE_T * , off_t  , int  ))((void *)0);
#line 120
  fake.f_getinfo = (int (*)(SM_FILE_T * , int  , void * ))((void *)0);
#line 120
  fake.f_setinfo = fake.f_getinfo;
#line 121
  fake.f_type = (char *)"sm_bprintf:fake";
#line 124
  fake.f_p = buf___16;
#line 124
  fake.f_bf.smb_base = fake.f_p;
#line 125
  fake.f_w = (int )sizeof(buf___16);
#line 125
  fake.f_bf.smb_size = fake.f_w;
#line 126
  fake.f_lbfsize = 0;
#line 129
  ret = sm_io_vfprintf(& fake, -1, fmt, ap);
  }
#line 130
  if (ret >= 0) {
    {
#line 130
    tmp = sm_io_flush(& fake, -1);
    }
#line 130
    if (tmp) {
#line 131
      ret = -1;
    }
  }
#line 132
  if (fake.f_flags & 256L) {
#line 133
    fp->f_flags |= 256L;
  }
#line 134
  return (ret);
}
}
#line 212 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c"
static char blanks[16]  = 
#line 212
  {      (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' '};
#line 214 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c"
static char zeroes[16]  = 
#line 214
  {      (char )'0',      (char )'0',      (char )'0',      (char )'0', 
        (char )'0',      (char )'0',      (char )'0',      (char )'0', 
        (char )'0',      (char )'0',      (char )'0',      (char )'0', 
        (char )'0',      (char )'0',      (char )'0',      (char )'0'};
#line 172 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c"
int sm_io_vfprintf(SM_FILE_T *fp , int timeout , char const   *fmt0 , va_list ap ) 
{ 
  register char *fmt ;
  register int ch ;
  register int n ;
  register int m ;
  register int n2 ;
  register char *cp ;
  register struct sm_iov *iovp ;
  register int flags ;
  int ret ;
  int width ;
  int prec ;
  char sign ;
  wchar_t wc ;
  ULONGLONG_T _uquad ;
  enum __anonenum_base_20 base ;
  int dprec ;
  int realsz ;
  int size ;
  char *xdigs ;
  struct sm_uio uio ;
  struct sm_iov iov[8] ;
  char buf___16[40] ;
  char ox[2] ;
  va_list *argtable ;
  va_list statargtable[8] ;
  int nextarg ;
  va_list orgap ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int hold ;
  int tmp___4 ;
  int tmp___5 ;
  int hold___0 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char tmp___11 ;
  LONGLONG_T tmp___13 ;
  long tmp___15 ;
  int tmp___17 ;
  int tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  double val ;
  char *p ;
  char fmt___0[16] ;
  char out[150] ;
  size_t len___0 ;
  double tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  LONGLONG_T *tmp___35 ;
  long *tmp___37 ;
  short *tmp___39 ;
  int *tmp___41 ;
  ULONGLONG_T tmp___43 ;
  unsigned long tmp___45 ;
  int tmp___47 ;
  unsigned int tmp___49 ;
  unsigned long tmp___50 ;
  unsigned long tmp___51 ;
  union __anonunion_u_21 u ;
  void *tmp___52 ;
  char *tmp___53 ;
  char *p___0 ;
  void *tmp___54 ;
  size_t tmp___55 ;
  ULONGLONG_T tmp___57 ;
  unsigned long tmp___59 ;
  int tmp___61 ;
  unsigned int tmp___63 ;
  unsigned long tmp___64 ;
  unsigned long tmp___65 ;
  ULONGLONG_T tmp___67 ;
  unsigned long tmp___69 ;
  int tmp___71 ;
  unsigned int tmp___73 ;
  unsigned long tmp___74 ;
  unsigned long tmp___75 ;
  size_t tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  void *__cil_tmp134 ;
  int __cil_tmp135 ;
  void *__cil_tmp136 ;
  void *__cil_tmp137 ;
  void *__cil_tmp138 ;
  void *__cil_tmp139 ;
  void *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;

  {
#line 195
  xdigs = (char *)"0123456789abcdef";
#line 313
  if ((fp->f_flags & 32L) == 0L) {
#line 313
    goto _L;
  } else
#line 313
  if ((unsigned long )fp->f_bf.smb_base == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 313
    tmp___0 = sm_wsetup(fp);
    }
#line 313
    if (tmp___0) {
      {
#line 315
      tmp = __errno_location();
#line 315
      *tmp = 9;
      }
#line 316
      return (-1);
    }
  }
#line 320
  if ((fp->f_flags & 100L) == 36L) {
#line 320
    if ((int )fp->f_file >= 0) {
      {
#line 322
      tmp___1 = sm_bprintf(fp, fmt0, ap);
      }
#line 322
      return (tmp___1);
    }
  }
  {
#line 324
  fmt = (char *)fmt0;
#line 325
  argtable = (va_list *)((void *)0);
#line 326
  nextarg = 1;
#line 327
  __builtin_va_copy(orgap, ap);
#line 328
  iovp = iov;
#line 328
  uio.uio_iov = iovp;
#line 329
  uio.uio_resid = 0;
#line 330
  uio.uio_iovcnt = 0;
#line 331
  ret = 0;
  }
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    cp = fmt;
#line 337
    n = 0;
    {
#line 338
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 338
      wc = (wchar_t )*fmt;
#line 338
      if (! (wc != 0)) {
#line 338
        goto while_break___0;
      }
#line 340
      if (wc == 37) {
#line 342
        n = 1;
#line 343
        goto while_break___0;
      }
#line 345
      fmt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 347
    m = (int )(fmt - cp);
#line 347
    if (m != 0) {
      {
#line 349
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 349
        iovp->iov_base = (void *)cp;
#line 349
        iovp->iov_len = (size_t )m;
#line 349
        uio.uio_resid += m;
#line 349
        iovp ++;
#line 349
        (uio.uio_iovcnt) ++;
#line 349
        if (uio.uio_iovcnt >= 8) {
          {
#line 349
          tmp___2 = sm_print(fp, timeout, & uio);
          }
#line 349
          if (tmp___2) {
#line 349
            goto error;
          }
#line 349
          iovp = iov;
        }
#line 349
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 350
      ret += m;
    }
#line 352
    if (n <= 0) {
#line 353
      goto done;
    }
#line 354
    fmt ++;
#line 356
    flags = 0;
#line 357
    dprec = 0;
#line 358
    width = 0;
#line 359
    prec = -1;
#line 360
    sign = (char )'\000';
    rflag: 
#line 362
    tmp___3 = fmt;
#line 362
    fmt ++;
#line 362
    ch = (int )*tmp___3;
    reswitch: 
    {
#line 365
    if (ch == 32) {
#line 365
      goto case_32;
    }
#line 376
    if (ch == 35) {
#line 376
      goto case_35;
    }
#line 379
    if (ch == 42) {
#line 379
      goto case_42;
    }
#line 393
    if (ch == 45) {
#line 393
      goto case_45;
    }
#line 396
    if (ch == 43) {
#line 396
      goto case_43;
    }
#line 399
    if (ch == 46) {
#line 399
      goto case_46;
    }
#line 425
    if (ch == 48) {
#line 425
      goto case_48;
    }
#line 436
    if (ch == 57) {
#line 436
      goto case_57;
    }
#line 436
    if (ch == 56) {
#line 436
      goto case_57;
    }
#line 436
    if (ch == 55) {
#line 436
      goto case_57;
    }
#line 436
    if (ch == 54) {
#line 436
      goto case_57;
    }
#line 436
    if (ch == 53) {
#line 436
      goto case_57;
    }
#line 436
    if (ch == 52) {
#line 436
      goto case_57;
    }
#line 436
    if (ch == 51) {
#line 436
      goto case_57;
    }
#line 436
    if (ch == 50) {
#line 436
      goto case_57;
    }
#line 436
    if (ch == 49) {
#line 436
      goto case_57;
    }
#line 456
    if (ch == 104) {
#line 456
      goto case_104;
    }
#line 459
    if (ch == 108) {
#line 459
      goto case_108;
    }
#line 470
    if (ch == 113) {
#line 470
      goto case_113;
    }
#line 473
    if (ch == 99) {
#line 473
      goto case_99;
    }
#line 478
    if (ch == 68) {
#line 478
      goto case_68;
    }
#line 482
    if (ch == 105) {
#line 482
      goto case_105;
    }
#line 482
    if (ch == 100) {
#line 482
      goto case_105;
    }
#line 495
    if (ch == 71) {
#line 495
      goto case_71;
    }
#line 495
    if (ch == 103) {
#line 495
      goto case_71;
    }
#line 495
    if (ch == 102) {
#line 495
      goto case_71;
    }
#line 495
    if (ch == 69) {
#line 495
      goto case_71;
    }
#line 495
    if (ch == 101) {
#line 495
      goto case_71;
    }
#line 556
    if (ch == 110) {
#line 556
      goto case_110;
    }
#line 566
    if (ch == 79) {
#line 566
      goto case_79;
    }
#line 569
    if (ch == 111) {
#line 569
      goto case_111;
    }
#line 573
    if (ch == 112) {
#line 573
      goto case_112;
    }
#line 605
    if (ch == 115) {
#line 605
      goto case_115;
    }
#line 631
    if (ch == 85) {
#line 631
      goto case_85;
    }
#line 634
    if (ch == 117) {
#line 634
      goto case_117;
    }
#line 638
    if (ch == 88) {
#line 638
      goto case_88;
    }
#line 641
    if (ch == 120) {
#line 641
      goto case_120;
    }
#line 716
    goto switch_default___0;
    case_32: /* CIL Label */ 
#line 373
    if (! sign) {
#line 374
      sign = (char )' ';
    }
#line 375
    goto rflag;
    case_35: /* CIL Label */ 
#line 377
    flags |= 1;
#line 378
    goto rflag;
    case_42: /* CIL Label */ 
#line 388
    n2 = 0;
#line 388
    cp = fmt;
    {
#line 388
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 388
      if (! ((unsigned int )((int )*cp - 48) <= 9U)) {
#line 388
        goto while_break___2;
      }
#line 388
      n2 = 10 * n2 + ((int )*cp - 48);
#line 388
      cp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 388
    if ((int )*cp == 36) {
#line 388
      hold = nextarg;
#line 388
      if ((unsigned long )argtable == (unsigned long )((void *)0)) {
        {
#line 388
        argtable = statargtable;
#line 388
        sm_find_arguments(fmt0, orgap, & argtable);
        }
      }
#line 388
      nextarg = n2;
#line 388
      if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 388
        ap = *(argtable + nextarg);
      }
      {
#line 388
      nextarg ++;
#line 388
      tmp___4 = __builtin_va_arg(ap, int );
#line 388
      width = tmp___4;
#line 388
      nextarg = hold;
#line 388
      cp ++;
#line 388
      fmt = cp;
      }
    } else {
#line 388
      if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 388
        ap = *(argtable + nextarg);
      }
      {
#line 388
      nextarg ++;
#line 388
      tmp___5 = __builtin_va_arg(ap, int );
#line 388
      width = tmp___5;
      }
    }
#line 389
    if (width >= 0) {
#line 390
      goto rflag;
    }
#line 391
    width = - width;
    case_45: /* CIL Label */ 
#line 394
    flags |= 4;
#line 395
    goto rflag;
    case_43: /* CIL Label */ 
#line 397
    sign = (char )'+';
#line 398
    goto rflag;
    case_46: /* CIL Label */ 
#line 400
    tmp___8 = fmt;
#line 400
    fmt ++;
#line 400
    ch = (int )*tmp___8;
#line 400
    if (ch == 42) {
#line 402
      n2 = 0;
#line 402
      cp = fmt;
      {
#line 402
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 402
        if (! ((unsigned int )((int )*cp - 48) <= 9U)) {
#line 402
          goto while_break___3;
        }
#line 402
        n2 = 10 * n2 + ((int )*cp - 48);
#line 402
        cp ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 402
      if ((int )*cp == 36) {
#line 402
        hold___0 = nextarg;
#line 402
        if ((unsigned long )argtable == (unsigned long )((void *)0)) {
          {
#line 402
          argtable = statargtable;
#line 402
          sm_find_arguments(fmt0, orgap, & argtable);
          }
        }
#line 402
        nextarg = n2;
#line 402
        if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 402
          ap = *(argtable + nextarg);
        }
        {
#line 402
        nextarg ++;
#line 402
        tmp___6 = __builtin_va_arg(ap, int );
#line 402
        n = tmp___6;
#line 402
        nextarg = hold___0;
#line 402
        cp ++;
#line 402
        fmt = cp;
        }
      } else {
#line 402
        if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 402
          ap = *(argtable + nextarg);
        }
        {
#line 402
        nextarg ++;
#line 402
        tmp___7 = __builtin_va_arg(ap, int );
#line 402
        n = tmp___7;
        }
      }
#line 403
      if (n < 0) {
#line 403
        prec = -1;
      } else {
#line 403
        prec = n;
      }
#line 404
      goto rflag;
    }
#line 406
    n = 0;
    {
#line 407
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 407
      if (! ((unsigned int )(ch - 48) <= 9U)) {
#line 407
        goto while_break___4;
      }
#line 409
      n = 10 * n + (ch - 48);
#line 410
      tmp___9 = fmt;
#line 410
      fmt ++;
#line 410
      ch = (int )*tmp___9;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 412
    if (ch == 36) {
#line 414
      nextarg = n;
#line 415
      if ((unsigned long )argtable == (unsigned long )((void *)0)) {
        {
#line 417
        argtable = statargtable;
#line 418
        sm_find_arguments(fmt0, orgap, & argtable);
        }
      }
#line 421
      goto rflag;
    }
#line 423
    if (n < 0) {
#line 423
      prec = -1;
    } else {
#line 423
      prec = n;
    }
#line 424
    goto reswitch;
    case_48: /* CIL Label */ 
#line 433
    flags |= 128;
#line 434
    goto rflag;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 437
    n = 0;
    {
#line 438
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 440
      n = 10 * n + (ch - 48);
#line 441
      tmp___10 = fmt;
#line 441
      fmt ++;
#line 441
      ch = (int )*tmp___10;
#line 438
      if (! ((unsigned int )(ch - 48) <= 9U)) {
#line 438
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 443
    if (ch == 36) {
#line 445
      nextarg = n;
#line 446
      if ((unsigned long )argtable == (unsigned long )((void *)0)) {
        {
#line 448
        argtable = statargtable;
#line 449
        sm_find_arguments(fmt0, orgap, & argtable);
        }
      }
#line 452
      goto rflag;
    }
#line 454
    width = n;
#line 455
    goto reswitch;
    case_104: /* CIL Label */ 
#line 457
    flags |= 64;
#line 458
    goto rflag;
    case_108: /* CIL Label */ 
#line 460
    if ((int )*fmt == 108) {
#line 462
      fmt ++;
#line 463
      flags |= 32;
    } else {
#line 467
      flags |= 16;
    }
#line 469
    goto rflag;
    case_113: /* CIL Label */ 
#line 471
    flags |= 32;
#line 472
    goto rflag;
    case_99: /* CIL Label */ 
#line 474
    cp = buf___16;
#line 474
    if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 474
      ap = *(argtable + nextarg);
    }
    {
#line 474
    nextarg ++;
#line 474
    tmp___11 = __builtin_va_arg(ap, int );
#line 474
    *cp = tmp___11;
#line 475
    size = 1;
#line 476
    sign = (char )'\000';
    }
#line 477
    goto switch_break;
    case_68: /* CIL Label */ 
#line 479
    flags |= 16;
    case_105: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 483
    if (flags & 32) {
      {
#line 483
      tmp___13 = __builtin_va_arg(ap, LONGLONG_T );
#line 483
      _uquad = (ULONGLONG_T )tmp___13;
      }
    } else {
#line 483
      if (flags & 16) {
#line 483
        if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 483
          ap = *(argtable + nextarg);
        }
        {
#line 483
        nextarg ++;
#line 483
        tmp___15 = __builtin_va_arg(ap, long );
#line 483
        tmp___21 = tmp___15;
        }
      } else {
#line 483
        if (flags & 64) {
#line 483
          if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 483
            ap = *(argtable + nextarg);
          }
          {
#line 483
          nextarg ++;
#line 483
          tmp___17 = __builtin_va_arg(ap, int );
#line 483
          tmp___20 = (long )((short )tmp___17);
          }
        } else {
#line 483
          if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 483
            ap = *(argtable + nextarg);
          }
          {
#line 483
          nextarg ++;
#line 483
          tmp___19 = __builtin_va_arg(ap, int );
#line 483
          tmp___20 = (long )tmp___19;
          }
        }
#line 483
        tmp___21 = tmp___20;
      }
#line 483
      _uquad = (ULONGLONG_T )tmp___21;
    }
#line 484
    if ((LONGLONG_T )_uquad < 0LL) {
#line 486
      _uquad = (ULONGLONG_T )(- ((LONGLONG_T )_uquad));
#line 487
      sign = (char )'-';
    }
#line 489
    base = (enum __anonenum_base_20 )1;
#line 490
    goto number;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
#line 512
    if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 512
      ap = *(argtable + nextarg);
    }
    {
#line 512
    nextarg ++;
#line 512
    tmp___22 = __builtin_va_arg(ap, double );
#line 512
    val = tmp___22;
#line 514
    p = fmt___0;
#line 515
    tmp___23 = p;
#line 515
    p ++;
#line 515
    *tmp___23 = (char )'%';
    }
#line 516
    if (sign) {
#line 517
      tmp___24 = p;
#line 517
      p ++;
#line 517
      *tmp___24 = sign;
    }
#line 518
    if (flags & 1) {
#line 519
      tmp___25 = p;
#line 519
      p ++;
#line 519
      *tmp___25 = (char )'#';
    }
#line 520
    if (flags & 4) {
#line 521
      tmp___26 = p;
#line 521
      p ++;
#line 521
      *tmp___26 = (char )'-';
    }
#line 522
    if (flags & 128) {
#line 523
      tmp___27 = p;
#line 523
      p ++;
#line 523
      *tmp___27 = (char )'0';
    }
#line 524
    tmp___28 = p;
#line 524
    p ++;
#line 524
    *tmp___28 = (char )'*';
#line 525
    if (prec >= 0) {
#line 527
      tmp___29 = p;
#line 527
      p ++;
#line 527
      *tmp___29 = (char )'.';
#line 528
      tmp___30 = p;
#line 528
      p ++;
#line 528
      *tmp___30 = (char )'*';
    }
#line 530
    tmp___31 = p;
#line 530
    p ++;
#line 530
    *tmp___31 = (char )ch;
#line 531
    *p = (char )'\000';
#line 533
    if (width > 120) {
#line 534
      width = 120;
    }
#line 535
    if (prec > 120) {
#line 536
      prec = 120;
    }
#line 537
    if (prec >= 0) {
      {
#line 542
      sprintf((char */* __restrict  */)(out), (char const   */* __restrict  */)(fmt___0),
              width, prec, val);
      }
    } else {
      {
#line 549
      sprintf((char */* __restrict  */)(out), (char const   */* __restrict  */)(fmt___0),
              width, val);
      }
    }
    {
#line 551
    len___0 = strlen((char const   *)(out));
    }
    {
#line 552
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 552
      iovp->iov_base = (void *)(out);
#line 552
      iovp->iov_len = len___0;
#line 552
      uio.uio_resid = (int )((size_t )uio.uio_resid + len___0);
#line 552
      iovp ++;
#line 552
      (uio.uio_iovcnt) ++;
#line 552
      if (uio.uio_iovcnt >= 8) {
        {
#line 552
        tmp___32 = sm_print(fp, timeout, & uio);
        }
#line 552
        if (tmp___32) {
#line 552
          goto error;
        }
#line 552
        iovp = iov;
      }
#line 552
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 553
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 553
      if (uio.uio_resid) {
        {
#line 553
        tmp___33 = sm_print(fp, timeout, & uio);
        }
#line 553
        if (tmp___33) {
#line 553
          goto error;
        }
      }
#line 553
      uio.uio_iovcnt = 0;
#line 553
      iovp = iov;
#line 553
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 554
    goto __Cont;
    case_110: /* CIL Label */ 
#line 557
    if (flags & 32) {
#line 558
      if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 558
        ap = *(argtable + nextarg);
      }
      {
#line 558
      nextarg ++;
#line 558
      tmp___35 = __builtin_va_arg(ap, LONGLONG_T *);
#line 558
      *tmp___35 = (LONGLONG_T )ret;
      }
    } else
#line 559
    if (flags & 16) {
#line 560
      if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 560
        ap = *(argtable + nextarg);
      }
      {
#line 560
      nextarg ++;
#line 560
      tmp___37 = __builtin_va_arg(ap, long *);
#line 560
      *tmp___37 = (long )ret;
      }
    } else
#line 561
    if (flags & 64) {
#line 562
      if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 562
        ap = *(argtable + nextarg);
      }
      {
#line 562
      nextarg ++;
#line 562
      tmp___39 = __builtin_va_arg(ap, short *);
#line 562
      *tmp___39 = (short )ret;
      }
    } else {
#line 564
      if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 564
        ap = *(argtable + nextarg);
      }
      {
#line 564
      nextarg ++;
#line 564
      tmp___41 = __builtin_va_arg(ap, int *);
#line 564
      *tmp___41 = ret;
      }
    }
#line 565
    goto __Cont;
    case_79: /* CIL Label */ 
#line 567
    flags |= 16;
    case_111: /* CIL Label */ 
#line 570
    if (flags & 32) {
      {
#line 570
      tmp___43 = __builtin_va_arg(ap, ULONGLONG_T );
#line 570
      _uquad = tmp___43;
      }
    } else {
#line 570
      if (flags & 16) {
#line 570
        if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 570
          ap = *(argtable + nextarg);
        }
        {
#line 570
        nextarg ++;
#line 570
        tmp___45 = __builtin_va_arg(ap, unsigned long );
#line 570
        tmp___51 = tmp___45;
        }
      } else {
#line 570
        if (flags & 64) {
#line 570
          if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 570
            ap = *(argtable + nextarg);
          }
          {
#line 570
          nextarg ++;
#line 570
          tmp___47 = __builtin_va_arg(ap, int );
#line 570
          tmp___50 = (unsigned long )((unsigned short )tmp___47);
          }
        } else {
#line 570
          if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 570
            ap = *(argtable + nextarg);
          }
          {
#line 570
          nextarg ++;
#line 570
          tmp___49 = __builtin_va_arg(ap, unsigned int );
#line 570
          tmp___50 = (unsigned long )tmp___49;
          }
        }
#line 570
        tmp___51 = tmp___50;
      }
#line 570
      _uquad = (ULONGLONG_T )tmp___51;
    }
#line 571
    base = (enum __anonenum_base_20 )0;
#line 572
    goto nosign;
    case_112: /* CIL Label */ 
#line 592
    if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 592
      ap = *(argtable + nextarg);
    }
    {
#line 592
    nextarg ++;
#line 592
    tmp___52 = __builtin_va_arg(ap, void *);
#line 592
    u.p = tmp___52;
    }
#line 593
    if (sizeof(void *) == sizeof(ULONGLONG_T )) {
#line 594
      _uquad = u.ll;
    } else
#line 595
    if (sizeof(void *) == sizeof(long )) {
#line 596
      _uquad = (ULONGLONG_T )u.l;
    } else {
#line 598
      _uquad = (ULONGLONG_T )u.i;
    }
#line 600
    base = (enum __anonenum_base_20 )2;
#line 601
    xdigs = (char *)"0123456789abcdef";
#line 602
    flags |= 2;
#line 603
    ch = 'x';
#line 604
    goto nosign;
    case_115: /* CIL Label */ 
#line 606
    if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 606
      ap = *(argtable + nextarg);
    }
    {
#line 606
    nextarg ++;
#line 606
    tmp___53 = __builtin_va_arg(ap, char *);
#line 606
    cp = tmp___53;
    }
#line 606
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 607
      cp = (char *)"(null)";
    }
#line 608
    if (prec >= 0) {
      {
#line 616
      tmp___54 = memchr((void const   *)cp, 0, (size_t )prec);
#line 616
      p___0 = (char *)tmp___54;
      }
#line 618
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
#line 620
        size = (int )(p___0 - cp);
#line 621
        if (size > prec) {
#line 622
          size = prec;
        }
      } else {
#line 625
        size = prec;
      }
    } else {
      {
#line 628
      tmp___55 = strlen((char const   *)cp);
#line 628
      size = (int )tmp___55;
      }
    }
#line 629
    sign = (char )'\000';
#line 630
    goto switch_break;
    case_85: /* CIL Label */ 
#line 632
    flags |= 16;
    case_117: /* CIL Label */ 
#line 635
    if (flags & 32) {
      {
#line 635
      tmp___57 = __builtin_va_arg(ap, ULONGLONG_T );
#line 635
      _uquad = tmp___57;
      }
    } else {
#line 635
      if (flags & 16) {
#line 635
        if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 635
          ap = *(argtable + nextarg);
        }
        {
#line 635
        nextarg ++;
#line 635
        tmp___59 = __builtin_va_arg(ap, unsigned long );
#line 635
        tmp___65 = tmp___59;
        }
      } else {
#line 635
        if (flags & 64) {
#line 635
          if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 635
            ap = *(argtable + nextarg);
          }
          {
#line 635
          nextarg ++;
#line 635
          tmp___61 = __builtin_va_arg(ap, int );
#line 635
          tmp___64 = (unsigned long )((unsigned short )tmp___61);
          }
        } else {
#line 635
          if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 635
            ap = *(argtable + nextarg);
          }
          {
#line 635
          nextarg ++;
#line 635
          tmp___63 = __builtin_va_arg(ap, unsigned int );
#line 635
          tmp___64 = (unsigned long )tmp___63;
          }
        }
#line 635
        tmp___65 = tmp___64;
      }
#line 635
      _uquad = (ULONGLONG_T )tmp___65;
    }
#line 636
    base = (enum __anonenum_base_20 )1;
#line 637
    goto nosign;
    case_88: /* CIL Label */ 
#line 639
    xdigs = (char *)"0123456789ABCDEF";
#line 640
    goto hex;
    case_120: /* CIL Label */ 
#line 642
    xdigs = (char *)"0123456789abcdef";
    hex: 
#line 643
    if (flags & 32) {
      {
#line 643
      tmp___67 = __builtin_va_arg(ap, ULONGLONG_T );
#line 643
      _uquad = tmp___67;
      }
    } else {
#line 643
      if (flags & 16) {
#line 643
        if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 643
          ap = *(argtable + nextarg);
        }
        {
#line 643
        nextarg ++;
#line 643
        tmp___69 = __builtin_va_arg(ap, unsigned long );
#line 643
        tmp___75 = tmp___69;
        }
      } else {
#line 643
        if (flags & 64) {
#line 643
          if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 643
            ap = *(argtable + nextarg);
          }
          {
#line 643
          nextarg ++;
#line 643
          tmp___71 = __builtin_va_arg(ap, int );
#line 643
          tmp___74 = (unsigned long )((unsigned short )tmp___71);
          }
        } else {
#line 643
          if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 643
            ap = *(argtable + nextarg);
          }
          {
#line 643
          nextarg ++;
#line 643
          tmp___73 = __builtin_va_arg(ap, unsigned int );
#line 643
          tmp___74 = (unsigned long )tmp___73;
          }
        }
#line 643
        tmp___75 = tmp___74;
      }
#line 643
      _uquad = (ULONGLONG_T )tmp___75;
    }
#line 644
    base = (enum __anonenum_base_20 )2;
#line 646
    if (flags & 1) {
#line 646
      if (_uquad != 0ULL) {
#line 647
        flags |= 2;
      }
    }
    nosign: 
#line 650
    sign = (char )'\000';
    number: 
#line 658
    dprec = prec;
#line 658
    if (dprec >= 0) {
#line 659
      flags &= -129;
    }
#line 667
    cp = buf___16 + 40;
#line 668
    if (_uquad != 0ULL) {
#line 668
      goto _L___0;
    } else
#line 668
    if (prec != 0) {
      _L___0: /* CIL Label */ 
      {
#line 678
      if ((unsigned int )base == 0U) {
#line 678
        goto case_0;
      }
#line 689
      if ((unsigned int )base == 1U) {
#line 689
        goto case_1;
      }
#line 699
      if ((unsigned int )base == 2U) {
#line 699
        goto case_2;
      }
#line 707
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 679
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 681
        cp --;
#line 681
        *cp = (char )((int )((char )(_uquad & 7ULL)) + 48);
#line 682
        _uquad >>= 3;
#line 679
        if (! _uquad) {
#line 679
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 685
      if (flags & 1) {
#line 685
        if ((int )*cp != 48) {
#line 686
          cp --;
#line 686
          *cp = (char )'0';
        }
      }
#line 687
      goto switch_break___0;
      case_1: /* CIL Label */ 
      {
#line 691
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 691
        if (! (_uquad >= 10ULL)) {
#line 691
          goto while_break___9;
        }
#line 693
        cp --;
#line 693
        *cp = (char )((int )((char )(_uquad % 10ULL)) + 48);
#line 694
        _uquad /= 10ULL;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 696
      cp --;
#line 696
      *cp = (char )((int )((char )_uquad) + 48);
#line 697
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 700
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 702
        cp --;
#line 702
        *cp = *(xdigs + (_uquad & 15ULL));
#line 703
        _uquad >>= 4;
#line 700
        if (! _uquad) {
#line 700
          goto while_break___10;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 705
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 708
      cp = (char *)"bug in sm_io_vfprintf: bad base";
#line 709
      tmp___76 = strlen((char const   *)cp);
#line 709
      size = (int )tmp___76;
      }
#line 710
      goto skipsize;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 713
    size = (int )((buf___16 + 40) - cp);
    skipsize: 
#line 715
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 717
    if (ch == 0) {
#line 718
      goto done;
    }
#line 720
    cp = buf___16;
#line 721
    *cp = (char )ch;
#line 722
    size = 1;
#line 723
    sign = (char )'\000';
#line 724
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 742
    if (dprec > size) {
#line 742
      realsz = dprec;
    } else {
#line 742
      realsz = size;
    }
#line 743
    if (sign) {
#line 744
      realsz ++;
    } else
#line 745
    if (flags & 2) {
#line 746
      realsz += 2;
    }
#line 749
    if ((flags & 132) == 0) {
      {
#line 750
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 750
        n = width - realsz;
#line 750
        if (n > 0) {
          {
#line 750
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 750
            if (! (n > 16)) {
#line 750
              goto while_break___12;
            }
            {
#line 750
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 750
              iovp->iov_base = (void *)(blanks);
#line 750
              iovp->iov_len = (size_t )16;
#line 750
              uio.uio_resid += 16;
#line 750
              iovp ++;
#line 750
              (uio.uio_iovcnt) ++;
#line 750
              if (uio.uio_iovcnt >= 8) {
                {
#line 750
                tmp___77 = sm_print(fp, timeout, & uio);
                }
#line 750
                if (tmp___77) {
#line 750
                  goto error;
                }
#line 750
                iovp = iov;
              }
#line 750
              goto while_break___13;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 750
            n -= 16;
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 750
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 750
            iovp->iov_base = (void *)(blanks);
#line 750
            iovp->iov_len = (size_t )n;
#line 750
            uio.uio_resid += n;
#line 750
            iovp ++;
#line 750
            (uio.uio_iovcnt) ++;
#line 750
            if (uio.uio_iovcnt >= 8) {
              {
#line 750
              tmp___78 = sm_print(fp, timeout, & uio);
              }
#line 750
              if (tmp___78) {
#line 750
                goto error;
              }
#line 750
              iovp = iov;
            }
#line 750
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
#line 750
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
#line 753
    if (sign) {
      {
#line 755
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 755
        iovp->iov_base = (void *)(& sign);
#line 755
        iovp->iov_len = (size_t )1;
#line 755
        (uio.uio_resid) ++;
#line 755
        iovp ++;
#line 755
        (uio.uio_iovcnt) ++;
#line 755
        if (uio.uio_iovcnt >= 8) {
          {
#line 755
          tmp___79 = sm_print(fp, timeout, & uio);
          }
#line 755
          if (tmp___79) {
#line 755
            goto error;
          }
#line 755
          iovp = iov;
        }
#line 755
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
    } else
#line 757
    if (flags & 2) {
#line 759
      ox[0] = (char )'0';
#line 760
      ox[1] = (char )ch;
      {
#line 761
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 761
        iovp->iov_base = (void *)(ox);
#line 761
        iovp->iov_len = (size_t )2;
#line 761
        uio.uio_resid += 2;
#line 761
        iovp ++;
#line 761
        (uio.uio_iovcnt) ++;
#line 761
        if (uio.uio_iovcnt >= 8) {
          {
#line 761
          tmp___80 = sm_print(fp, timeout, & uio);
          }
#line 761
          if (tmp___80) {
#line 761
            goto error;
          }
#line 761
          iovp = iov;
        }
#line 761
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
#line 765
    if ((flags & 132) == 128) {
      {
#line 766
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 766
        n = width - realsz;
#line 766
        if (n > 0) {
          {
#line 766
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 766
            if (! (n > 16)) {
#line 766
              goto while_break___18;
            }
            {
#line 766
            while (1) {
              while_continue___19: /* CIL Label */ ;
#line 766
              iovp->iov_base = (void *)(zeroes);
#line 766
              iovp->iov_len = (size_t )16;
#line 766
              uio.uio_resid += 16;
#line 766
              iovp ++;
#line 766
              (uio.uio_iovcnt) ++;
#line 766
              if (uio.uio_iovcnt >= 8) {
                {
#line 766
                tmp___81 = sm_print(fp, timeout, & uio);
                }
#line 766
                if (tmp___81) {
#line 766
                  goto error;
                }
#line 766
                iovp = iov;
              }
#line 766
              goto while_break___19;
            }
            while_break___19: /* CIL Label */ ;
            }
#line 766
            n -= 16;
          }
          while_break___18: /* CIL Label */ ;
          }
          {
#line 766
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 766
            iovp->iov_base = (void *)(zeroes);
#line 766
            iovp->iov_len = (size_t )n;
#line 766
            uio.uio_resid += n;
#line 766
            iovp ++;
#line 766
            (uio.uio_iovcnt) ++;
#line 766
            if (uio.uio_iovcnt >= 8) {
              {
#line 766
              tmp___82 = sm_print(fp, timeout, & uio);
              }
#line 766
              if (tmp___82) {
#line 766
                goto error;
              }
#line 766
              iovp = iov;
            }
#line 766
            goto while_break___20;
          }
          while_break___20: /* CIL Label */ ;
          }
        }
#line 766
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
    {
#line 769
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 769
      n = dprec - size;
#line 769
      if (n > 0) {
        {
#line 769
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 769
          if (! (n > 16)) {
#line 769
            goto while_break___22;
          }
          {
#line 769
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 769
            iovp->iov_base = (void *)(zeroes);
#line 769
            iovp->iov_len = (size_t )16;
#line 769
            uio.uio_resid += 16;
#line 769
            iovp ++;
#line 769
            (uio.uio_iovcnt) ++;
#line 769
            if (uio.uio_iovcnt >= 8) {
              {
#line 769
              tmp___83 = sm_print(fp, timeout, & uio);
              }
#line 769
              if (tmp___83) {
#line 769
                goto error;
              }
#line 769
              iovp = iov;
            }
#line 769
            goto while_break___23;
          }
          while_break___23: /* CIL Label */ ;
          }
#line 769
          n -= 16;
        }
        while_break___22: /* CIL Label */ ;
        }
        {
#line 769
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 769
          iovp->iov_base = (void *)(zeroes);
#line 769
          iovp->iov_len = (size_t )n;
#line 769
          uio.uio_resid += n;
#line 769
          iovp ++;
#line 769
          (uio.uio_iovcnt) ++;
#line 769
          if (uio.uio_iovcnt >= 8) {
            {
#line 769
            tmp___84 = sm_print(fp, timeout, & uio);
            }
#line 769
            if (tmp___84) {
#line 769
              goto error;
            }
#line 769
            iovp = iov;
          }
#line 769
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
      }
#line 769
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 772
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 772
      iovp->iov_base = (void *)cp;
#line 772
      iovp->iov_len = (size_t )size;
#line 772
      uio.uio_resid += size;
#line 772
      iovp ++;
#line 772
      (uio.uio_iovcnt) ++;
#line 772
      if (uio.uio_iovcnt >= 8) {
        {
#line 772
        tmp___85 = sm_print(fp, timeout, & uio);
        }
#line 772
        if (tmp___85) {
#line 772
          goto error;
        }
#line 772
        iovp = iov;
      }
#line 772
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
#line 774
    if (flags & 4) {
      {
#line 775
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 775
        n = width - realsz;
#line 775
        if (n > 0) {
          {
#line 775
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 775
            if (! (n > 16)) {
#line 775
              goto while_break___27;
            }
            {
#line 775
            while (1) {
              while_continue___28: /* CIL Label */ ;
#line 775
              iovp->iov_base = (void *)(blanks);
#line 775
              iovp->iov_len = (size_t )16;
#line 775
              uio.uio_resid += 16;
#line 775
              iovp ++;
#line 775
              (uio.uio_iovcnt) ++;
#line 775
              if (uio.uio_iovcnt >= 8) {
                {
#line 775
                tmp___86 = sm_print(fp, timeout, & uio);
                }
#line 775
                if (tmp___86) {
#line 775
                  goto error;
                }
#line 775
                iovp = iov;
              }
#line 775
              goto while_break___28;
            }
            while_break___28: /* CIL Label */ ;
            }
#line 775
            n -= 16;
          }
          while_break___27: /* CIL Label */ ;
          }
          {
#line 775
          while (1) {
            while_continue___29: /* CIL Label */ ;
#line 775
            iovp->iov_base = (void *)(blanks);
#line 775
            iovp->iov_len = (size_t )n;
#line 775
            uio.uio_resid += n;
#line 775
            iovp ++;
#line 775
            (uio.uio_iovcnt) ++;
#line 775
            if (uio.uio_iovcnt >= 8) {
              {
#line 775
              tmp___87 = sm_print(fp, timeout, & uio);
              }
#line 775
              if (tmp___87) {
#line 775
                goto error;
              }
#line 775
              iovp = iov;
            }
#line 775
            goto while_break___29;
          }
          while_break___29: /* CIL Label */ ;
          }
        }
#line 775
        goto while_break___26;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
#line 778
    if (width > realsz) {
#line 778
      tmp___88 = width;
    } else {
#line 778
      tmp___88 = realsz;
    }
#line 778
    ret += tmp___88;
    {
#line 780
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 780
      if (uio.uio_resid) {
        {
#line 780
        tmp___89 = sm_print(fp, timeout, & uio);
        }
#line 780
        if (tmp___89) {
#line 780
          goto error;
        }
      }
#line 780
      uio.uio_iovcnt = 0;
#line 780
      iovp = iov;
#line 780
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
#line 783
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 783
    if (uio.uio_resid) {
      {
#line 783
      tmp___90 = sm_print(fp, timeout, & uio);
      }
#line 783
      if (tmp___90) {
#line 783
        goto error;
      }
    }
#line 783
    uio.uio_iovcnt = 0;
#line 783
    iovp = iov;
#line 783
    goto while_break___31;
  }
  while_break___31: /* CIL Label */ ;
  }
  error: 
#line 785
  if ((unsigned long )argtable != (unsigned long )((void *)0)) {
#line 785
    if ((unsigned long )argtable != (unsigned long )(statargtable)) {
      {
#line 786
      sm_free_tagged((void *)argtable, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c",
                     786);
      }
    }
  }
#line 787
  if ((fp->f_flags & 256L) != 0L) {
#line 787
    tmp___91 = -1;
  } else {
#line 787
    tmp___91 = ret;
  }
#line 787
  return (tmp___91);
}
}
#line 826 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c"
static void sm_find_arguments(char const   *fmt0 , va_list ap , va_list **argtable ) 
{ 
  register char *fmt ;
  register int ch ;
  register int n ;
  register int n2 ;
  register char *cp ;
  register int flags ;
  unsigned char *typetable ;
  unsigned char stattypetable[8] ;
  int tablesize ;
  int tablemax ;
  int nextarg ;
  char *tmp ;
  int hold ;
  int tmp___0 ;
  int tmp___1 ;
  int hold___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  void *tmp___31 ;
  int tmp___33 ;
  int tmp___35 ;
  int tmp___37 ;
  short *tmp___39 ;
  int tmp___41 ;
  unsigned int tmp___43 ;
  int *tmp___45 ;
  long tmp___47 ;
  unsigned long tmp___49 ;
  long *tmp___51 ;
  LONGLONG_T tmp___53 ;
  ULONGLONG_T tmp___55 ;
  LONGLONG_T *tmp___57 ;
  double tmp___59 ;
  char *tmp___61 ;
  void *tmp___63 ;
  void *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;

  {
  {
#line 879
  fmt = (char *)fmt0;
#line 880
  typetable = stattypetable;
#line 881
  tablesize = 8;
#line 882
  tablemax = 0;
#line 883
  nextarg = 1;
#line 884
  memset((void *)typetable, 0, (size_t )8);
  }
  {
#line 887
  while (1) {
    while_continue: /* CIL Label */ ;
#line 889
    cp = fmt;
    {
#line 889
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 889
      ch = (int )*fmt;
#line 889
      if (ch != 0) {
#line 889
        if (! (ch != 37)) {
#line 889
          goto while_break___0;
        }
      } else {
#line 889
        goto while_break___0;
      }
#line 889
      fmt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 891
    if (ch == 0) {
#line 892
      goto done;
    }
#line 893
    fmt ++;
#line 895
    flags = 0;
    rflag: 
#line 897
    tmp = fmt;
#line 897
    fmt ++;
#line 897
    ch = (int )*tmp;
    reswitch: 
    {
#line 901
    if (ch == 35) {
#line 901
      goto case_35;
    }
#line 901
    if (ch == 32) {
#line 901
      goto case_35;
    }
#line 903
    if (ch == 42) {
#line 903
      goto case_42;
    }
#line 907
    if (ch == 43) {
#line 907
      goto case_43;
    }
#line 907
    if (ch == 45) {
#line 907
      goto case_43;
    }
#line 909
    if (ch == 46) {
#line 909
      goto case_46;
    }
#line 920
    if (ch == 48) {
#line 920
      goto case_48;
    }
#line 923
    if (ch == 57) {
#line 923
      goto case_57;
    }
#line 923
    if (ch == 56) {
#line 923
      goto case_57;
    }
#line 923
    if (ch == 55) {
#line 923
      goto case_57;
    }
#line 923
    if (ch == 54) {
#line 923
      goto case_57;
    }
#line 923
    if (ch == 53) {
#line 923
      goto case_57;
    }
#line 923
    if (ch == 52) {
#line 923
      goto case_57;
    }
#line 923
    if (ch == 51) {
#line 923
      goto case_57;
    }
#line 923
    if (ch == 50) {
#line 923
      goto case_57;
    }
#line 923
    if (ch == 49) {
#line 923
      goto case_57;
    }
#line 936
    if (ch == 104) {
#line 936
      goto case_104;
    }
#line 939
    if (ch == 108) {
#line 939
      goto case_108;
    }
#line 942
    if (ch == 113) {
#line 942
      goto case_113;
    }
#line 945
    if (ch == 99) {
#line 945
      goto case_99;
    }
#line 948
    if (ch == 68) {
#line 948
      goto case_68;
    }
#line 952
    if (ch == 105) {
#line 952
      goto case_105;
    }
#line 952
    if (ch == 100) {
#line 952
      goto case_105;
    }
#line 966
    if (ch == 71) {
#line 966
      goto case_71;
    }
#line 966
    if (ch == 103) {
#line 966
      goto case_71;
    }
#line 966
    if (ch == 102) {
#line 966
      goto case_71;
    }
#line 966
    if (ch == 69) {
#line 966
      goto case_71;
    }
#line 966
    if (ch == 101) {
#line 966
      goto case_71;
    }
#line 969
    if (ch == 110) {
#line 969
      goto case_110;
    }
#line 979
    if (ch == 79) {
#line 979
      goto case_79;
    }
#line 982
    if (ch == 111) {
#line 982
      goto case_111;
    }
#line 988
    if (ch == 112) {
#line 988
      goto case_112;
    }
#line 991
    if (ch == 115) {
#line 991
      goto case_115;
    }
#line 994
    if (ch == 85) {
#line 994
      goto case_85;
    }
#line 997
    if (ch == 117) {
#line 997
      goto case_117;
    }
#line 1004
    if (ch == 120) {
#line 1004
      goto case_120;
    }
#line 1004
    if (ch == 88) {
#line 1004
      goto case_120;
    }
#line 1010
    goto switch_default;
    case_35: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 902
    goto rflag;
    case_42: /* CIL Label */ 
#line 904
    n2 = 0;
#line 904
    cp = fmt;
    {
#line 904
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 904
      if (! ((unsigned int )((int )*cp - 48) <= 9U)) {
#line 904
        goto while_break___1;
      }
#line 904
      n2 = 10 * n2 + ((int )*cp - 48);
#line 904
      cp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 904
    if ((int )*cp == 36) {
#line 904
      hold = nextarg;
#line 904
      nextarg = n2;
#line 904
      if (nextarg >= tablesize) {
        {
#line 904
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 904
      tmp___0 = nextarg;
#line 904
      nextarg ++;
#line 904
      *(typetable + tmp___0) = (unsigned char)4;
#line 904
      if (nextarg > tablemax) {
#line 904
        tablemax = nextarg;
      }
#line 904
      nextarg = hold;
#line 904
      cp ++;
#line 904
      fmt = cp;
    } else {
#line 904
      if (nextarg >= tablesize) {
        {
#line 904
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 904
      tmp___1 = nextarg;
#line 904
      nextarg ++;
#line 904
      *(typetable + tmp___1) = (unsigned char)4;
#line 904
      if (nextarg > tablemax) {
#line 904
        tablemax = nextarg;
      }
    }
#line 905
    goto rflag;
    case_43: /* CIL Label */ 
    case_45: /* CIL Label */ 
#line 908
    goto rflag;
    case_46: /* CIL Label */ 
#line 910
    tmp___4 = fmt;
#line 910
    fmt ++;
#line 910
    ch = (int )*tmp___4;
#line 910
    if (ch == 42) {
#line 912
      n2 = 0;
#line 912
      cp = fmt;
      {
#line 912
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 912
        if (! ((unsigned int )((int )*cp - 48) <= 9U)) {
#line 912
          goto while_break___2;
        }
#line 912
        n2 = 10 * n2 + ((int )*cp - 48);
#line 912
        cp ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 912
      if ((int )*cp == 36) {
#line 912
        hold___0 = nextarg;
#line 912
        nextarg = n2;
#line 912
        if (nextarg >= tablesize) {
          {
#line 912
          sm_grow_type_table_x(& typetable, & tablesize);
          }
        }
#line 912
        tmp___2 = nextarg;
#line 912
        nextarg ++;
#line 912
        *(typetable + tmp___2) = (unsigned char)4;
#line 912
        if (nextarg > tablemax) {
#line 912
          tablemax = nextarg;
        }
#line 912
        nextarg = hold___0;
#line 912
        cp ++;
#line 912
        fmt = cp;
      } else {
#line 912
        if (nextarg >= tablesize) {
          {
#line 912
          sm_grow_type_table_x(& typetable, & tablesize);
          }
        }
#line 912
        tmp___3 = nextarg;
#line 912
        nextarg ++;
#line 912
        *(typetable + tmp___3) = (unsigned char)4;
#line 912
        if (nextarg > tablemax) {
#line 912
          tablemax = nextarg;
        }
      }
#line 913
      goto rflag;
    }
    {
#line 915
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 915
      if (! ((unsigned int )(ch - 48) <= 9U)) {
#line 915
        goto while_break___3;
      }
#line 917
      tmp___5 = fmt;
#line 917
      fmt ++;
#line 917
      ch = (int )*tmp___5;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 919
    goto reswitch;
    case_48: /* CIL Label */ 
#line 921
    goto rflag;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 924
    n = 0;
    {
#line 925
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 927
      n = 10 * n + (ch - 48);
#line 928
      tmp___6 = fmt;
#line 928
      fmt ++;
#line 928
      ch = (int )*tmp___6;
#line 925
      if (! ((unsigned int )(ch - 48) <= 9U)) {
#line 925
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 930
    if (ch == 36) {
#line 932
      nextarg = n;
#line 933
      goto rflag;
    }
#line 935
    goto reswitch;
    case_104: /* CIL Label */ 
#line 937
    flags |= 64;
#line 938
    goto rflag;
    case_108: /* CIL Label */ 
#line 940
    flags |= 16;
#line 941
    goto rflag;
    case_113: /* CIL Label */ 
#line 943
    flags |= 32;
#line 944
    goto rflag;
    case_99: /* CIL Label */ 
#line 946
    if (nextarg >= tablesize) {
      {
#line 946
      sm_grow_type_table_x(& typetable, & tablesize);
      }
    }
#line 946
    tmp___7 = nextarg;
#line 946
    nextarg ++;
#line 946
    *(typetable + tmp___7) = (unsigned char)4;
#line 946
    if (nextarg > tablemax) {
#line 946
      tablemax = nextarg;
    }
#line 947
    goto switch_break;
    case_68: /* CIL Label */ 
#line 949
    flags |= 16;
    case_105: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 953
    if (flags & 32) {
#line 955
      if (nextarg >= tablesize) {
        {
#line 955
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 955
      tmp___8 = nextarg;
#line 955
      nextarg ++;
#line 955
      *(typetable + tmp___8) = (unsigned char)10;
#line 955
      if (nextarg > tablemax) {
#line 955
        tablemax = nextarg;
      }
    } else
#line 959
    if (flags & 16) {
#line 959
      if (nextarg >= tablesize) {
        {
#line 959
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 959
      tmp___11 = nextarg;
#line 959
      nextarg ++;
#line 959
      *(typetable + tmp___11) = (unsigned char)7;
#line 959
      if (nextarg > tablemax) {
#line 959
        tablemax = nextarg;
      }
    } else
#line 959
    if (flags & 64) {
#line 959
      if (nextarg >= tablesize) {
        {
#line 959
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 959
      tmp___10 = nextarg;
#line 959
      nextarg ++;
#line 959
      *(typetable + tmp___10) = (unsigned char)1;
#line 959
      if (nextarg > tablemax) {
#line 959
        tablemax = nextarg;
      }
    } else {
#line 959
      if (nextarg >= tablesize) {
        {
#line 959
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 959
      tmp___9 = nextarg;
#line 959
      nextarg ++;
#line 959
      *(typetable + tmp___9) = (unsigned char)4;
#line 959
      if (nextarg > tablemax) {
#line 959
        tablemax = nextarg;
      }
    }
#line 961
    goto switch_break;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
#line 967
    if (nextarg >= tablesize) {
      {
#line 967
      sm_grow_type_table_x(& typetable, & tablesize);
      }
    }
#line 967
    tmp___12 = nextarg;
#line 967
    nextarg ++;
#line 967
    *(typetable + tmp___12) = (unsigned char)13;
#line 967
    if (nextarg > tablemax) {
#line 967
      tablemax = nextarg;
    }
#line 968
    goto switch_break;
    case_110: /* CIL Label */ 
#line 970
    if (flags & 32) {
#line 971
      if (nextarg >= tablesize) {
        {
#line 971
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 971
      tmp___13 = nextarg;
#line 971
      nextarg ++;
#line 971
      *(typetable + tmp___13) = (unsigned char)12;
#line 971
      if (nextarg > tablemax) {
#line 971
        tablemax = nextarg;
      }
    } else
#line 972
    if (flags & 16) {
#line 973
      if (nextarg >= tablesize) {
        {
#line 973
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 973
      tmp___14 = nextarg;
#line 973
      nextarg ++;
#line 973
      *(typetable + tmp___14) = (unsigned char)9;
#line 973
      if (nextarg > tablemax) {
#line 973
        tablemax = nextarg;
      }
    } else
#line 974
    if (flags & 64) {
#line 975
      if (nextarg >= tablesize) {
        {
#line 975
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 975
      tmp___15 = nextarg;
#line 975
      nextarg ++;
#line 975
      *(typetable + tmp___15) = (unsigned char)3;
#line 975
      if (nextarg > tablemax) {
#line 975
        tablemax = nextarg;
      }
    } else {
#line 977
      if (nextarg >= tablesize) {
        {
#line 977
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 977
      tmp___16 = nextarg;
#line 977
      nextarg ++;
#line 977
      *(typetable + tmp___16) = (unsigned char)6;
#line 977
      if (nextarg > tablemax) {
#line 977
        tablemax = nextarg;
      }
    }
#line 978
    goto __Cont;
    case_79: /* CIL Label */ 
#line 980
    flags |= 16;
    case_111: /* CIL Label */ 
#line 983
    if (flags & 32) {
#line 984
      if (nextarg >= tablesize) {
        {
#line 984
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 984
      tmp___17 = nextarg;
#line 984
      nextarg ++;
#line 984
      *(typetable + tmp___17) = (unsigned char)11;
#line 984
      if (nextarg > tablemax) {
#line 984
        tablemax = nextarg;
      }
    } else
#line 986
    if (flags & 16) {
#line 986
      if (nextarg >= tablesize) {
        {
#line 986
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 986
      tmp___20 = nextarg;
#line 986
      nextarg ++;
#line 986
      *(typetable + tmp___20) = (unsigned char)8;
#line 986
      if (nextarg > tablemax) {
#line 986
        tablemax = nextarg;
      }
    } else
#line 986
    if (flags & 64) {
#line 986
      if (nextarg >= tablesize) {
        {
#line 986
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 986
      tmp___19 = nextarg;
#line 986
      nextarg ++;
#line 986
      *(typetable + tmp___19) = (unsigned char)2;
#line 986
      if (nextarg > tablemax) {
#line 986
        tablemax = nextarg;
      }
    } else {
#line 986
      if (nextarg >= tablesize) {
        {
#line 986
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 986
      tmp___18 = nextarg;
#line 986
      nextarg ++;
#line 986
      *(typetable + tmp___18) = (unsigned char)5;
#line 986
      if (nextarg > tablemax) {
#line 986
        tablemax = nextarg;
      }
    }
#line 987
    goto switch_break;
    case_112: /* CIL Label */ 
#line 989
    if (nextarg >= tablesize) {
      {
#line 989
      sm_grow_type_table_x(& typetable, & tablesize);
      }
    }
#line 989
    tmp___21 = nextarg;
#line 989
    nextarg ++;
#line 989
    *(typetable + tmp___21) = (unsigned char)16;
#line 989
    if (nextarg > tablemax) {
#line 989
      tablemax = nextarg;
    }
#line 990
    goto switch_break;
    case_115: /* CIL Label */ 
#line 992
    if (nextarg >= tablesize) {
      {
#line 992
      sm_grow_type_table_x(& typetable, & tablesize);
      }
    }
#line 992
    tmp___22 = nextarg;
#line 992
    nextarg ++;
#line 992
    *(typetable + tmp___22) = (unsigned char)15;
#line 992
    if (nextarg > tablemax) {
#line 992
      tablemax = nextarg;
    }
#line 993
    goto switch_break;
    case_85: /* CIL Label */ 
#line 995
    flags |= 16;
    case_117: /* CIL Label */ 
#line 998
    if (flags & 32) {
#line 999
      if (nextarg >= tablesize) {
        {
#line 999
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 999
      tmp___23 = nextarg;
#line 999
      nextarg ++;
#line 999
      *(typetable + tmp___23) = (unsigned char)11;
#line 999
      if (nextarg > tablemax) {
#line 999
        tablemax = nextarg;
      }
    } else
#line 1001
    if (flags & 16) {
#line 1001
      if (nextarg >= tablesize) {
        {
#line 1001
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 1001
      tmp___26 = nextarg;
#line 1001
      nextarg ++;
#line 1001
      *(typetable + tmp___26) = (unsigned char)8;
#line 1001
      if (nextarg > tablemax) {
#line 1001
        tablemax = nextarg;
      }
    } else
#line 1001
    if (flags & 64) {
#line 1001
      if (nextarg >= tablesize) {
        {
#line 1001
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 1001
      tmp___25 = nextarg;
#line 1001
      nextarg ++;
#line 1001
      *(typetable + tmp___25) = (unsigned char)2;
#line 1001
      if (nextarg > tablemax) {
#line 1001
        tablemax = nextarg;
      }
    } else {
#line 1001
      if (nextarg >= tablesize) {
        {
#line 1001
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 1001
      tmp___24 = nextarg;
#line 1001
      nextarg ++;
#line 1001
      *(typetable + tmp___24) = (unsigned char)5;
#line 1001
      if (nextarg > tablemax) {
#line 1001
        tablemax = nextarg;
      }
    }
#line 1002
    goto switch_break;
    case_120: /* CIL Label */ 
    case_88: /* CIL Label */ 
#line 1005
    if (flags & 32) {
#line 1006
      if (nextarg >= tablesize) {
        {
#line 1006
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 1006
      tmp___27 = nextarg;
#line 1006
      nextarg ++;
#line 1006
      *(typetable + tmp___27) = (unsigned char)11;
#line 1006
      if (nextarg > tablemax) {
#line 1006
        tablemax = nextarg;
      }
    } else
#line 1008
    if (flags & 16) {
#line 1008
      if (nextarg >= tablesize) {
        {
#line 1008
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 1008
      tmp___30 = nextarg;
#line 1008
      nextarg ++;
#line 1008
      *(typetable + tmp___30) = (unsigned char)8;
#line 1008
      if (nextarg > tablemax) {
#line 1008
        tablemax = nextarg;
      }
    } else
#line 1008
    if (flags & 64) {
#line 1008
      if (nextarg >= tablesize) {
        {
#line 1008
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 1008
      tmp___29 = nextarg;
#line 1008
      nextarg ++;
#line 1008
      *(typetable + tmp___29) = (unsigned char)2;
#line 1008
      if (nextarg > tablemax) {
#line 1008
        tablemax = nextarg;
      }
    } else {
#line 1008
      if (nextarg >= tablesize) {
        {
#line 1008
        sm_grow_type_table_x(& typetable, & tablesize);
        }
      }
#line 1008
      tmp___28 = nextarg;
#line 1008
      nextarg ++;
#line 1008
      *(typetable + tmp___28) = (unsigned char)5;
#line 1008
      if (nextarg > tablemax) {
#line 1008
        tablemax = nextarg;
      }
    }
#line 1009
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1011
    if (ch == 0) {
#line 1012
      goto done;
    }
#line 1013
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 1018
  if (tablemax >= 8) {
    {
#line 1020
    tmp___31 = sm_malloc_tagged((size_t )(sizeof(va_list ) * (unsigned long )(tablemax + 1)),
                                (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c",
                                1021, SmHeapGroup);
#line 1020
    *argtable = (va_list *)tmp___31;
    }
  }
#line 1024
  n = 1;
  {
#line 1024
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1024
    if (! (n <= tablemax)) {
#line 1024
      goto while_break___5;
    }
    {
#line 1026
    __builtin_va_copy(*(*argtable + n), ap);
    }
    {
#line 1029
    if ((int )*(typetable + n) == 0) {
#line 1029
      goto case_0;
    }
#line 1032
    if ((int )*(typetable + n) == 1) {
#line 1032
      goto case_1;
    }
#line 1035
    if ((int )*(typetable + n) == 2) {
#line 1035
      goto case_2;
    }
#line 1038
    if ((int )*(typetable + n) == 3) {
#line 1038
      goto case_3;
    }
#line 1041
    if ((int )*(typetable + n) == 4) {
#line 1041
      goto case_4;
    }
#line 1044
    if ((int )*(typetable + n) == 5) {
#line 1044
      goto case_5;
    }
#line 1047
    if ((int )*(typetable + n) == 6) {
#line 1047
      goto case_6;
    }
#line 1050
    if ((int )*(typetable + n) == 7) {
#line 1050
      goto case_7;
    }
#line 1053
    if ((int )*(typetable + n) == 8) {
#line 1053
      goto case_8;
    }
#line 1056
    if ((int )*(typetable + n) == 9) {
#line 1056
      goto case_9;
    }
#line 1059
    if ((int )*(typetable + n) == 10) {
#line 1059
      goto case_10;
    }
#line 1062
    if ((int )*(typetable + n) == 11) {
#line 1062
      goto case_11;
    }
#line 1065
    if ((int )*(typetable + n) == 12) {
#line 1065
      goto case_12;
    }
#line 1068
    if ((int )*(typetable + n) == 13) {
#line 1068
      goto case_13;
    }
#line 1071
    if ((int )*(typetable + n) == 15) {
#line 1071
      goto case_15;
    }
#line 1074
    if ((int )*(typetable + n) == 16) {
#line 1074
      goto case_16;
    }
#line 1027
    goto switch_break___0;
    case_0: /* CIL Label */ 
    {
#line 1030
    tmp___33 = __builtin_va_arg(ap, int );
    }
#line 1031
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 1033
    tmp___35 = __builtin_va_arg(ap, int );
    }
#line 1034
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 1036
    tmp___37 = __builtin_va_arg(ap, int );
    }
#line 1037
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 1039
    tmp___39 = __builtin_va_arg(ap, short *);
    }
#line 1040
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 1042
    tmp___41 = __builtin_va_arg(ap, int );
    }
#line 1043
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 1045
    tmp___43 = __builtin_va_arg(ap, unsigned int );
    }
#line 1046
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 1048
    tmp___45 = __builtin_va_arg(ap, int *);
    }
#line 1049
    goto switch_break___0;
    case_7: /* CIL Label */ 
    {
#line 1051
    tmp___47 = __builtin_va_arg(ap, long );
    }
#line 1052
    goto switch_break___0;
    case_8: /* CIL Label */ 
    {
#line 1054
    tmp___49 = __builtin_va_arg(ap, unsigned long );
    }
#line 1055
    goto switch_break___0;
    case_9: /* CIL Label */ 
    {
#line 1057
    tmp___51 = __builtin_va_arg(ap, long *);
    }
#line 1058
    goto switch_break___0;
    case_10: /* CIL Label */ 
    {
#line 1060
    tmp___53 = __builtin_va_arg(ap, LONGLONG_T );
    }
#line 1061
    goto switch_break___0;
    case_11: /* CIL Label */ 
    {
#line 1063
    tmp___55 = __builtin_va_arg(ap, ULONGLONG_T );
    }
#line 1064
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 1066
    tmp___57 = __builtin_va_arg(ap, LONGLONG_T *);
    }
#line 1067
    goto switch_break___0;
    case_13: /* CIL Label */ 
    {
#line 1069
    tmp___59 = __builtin_va_arg(ap, double );
    }
#line 1070
    goto switch_break___0;
    case_15: /* CIL Label */ 
    {
#line 1072
    tmp___61 = __builtin_va_arg(ap, char *);
    }
#line 1073
    goto switch_break___0;
    case_16: /* CIL Label */ 
    {
#line 1075
    tmp___63 = __builtin_va_arg(ap, void *);
    }
#line 1076
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1024
    n ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1080
  if ((unsigned long )typetable != (unsigned long )((void *)0)) {
#line 1080
    if ((unsigned long )typetable != (unsigned long )(stattypetable)) {
      {
#line 1081
      sm_free_tagged((void *)typetable, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c",
                     1081);
      }
    }
  }
#line 1082
  return;
}
}
#line 1095 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c"
static void sm_grow_type_table_x(unsigned char **typetable , int *tablesize ) 
{ 
  unsigned char *oldtable ;
  int newsize ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 1100
  oldtable = *typetable;
#line 1101
  newsize = *tablesize * 2;
#line 1103
  if (*tablesize == 8) {
    {
#line 1105
    tmp = sm_malloc_tagged_x((size_t )(sizeof(unsigned char ) * (unsigned long )newsize),
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vfprintf.c",
                             1106, SmHeapGroup);
#line 1105
    *typetable = (unsigned char *)tmp;
#line 1107
    memmove((void *)*typetable, (void const   *)oldtable, (size_t )*tablesize);
    }
  } else {
    {
#line 1111
    tmp___0 = sm_realloc_x((void *)typetable, (size_t )(sizeof(unsigned char ) * (unsigned long )newsize));
#line 1111
    *typetable = (unsigned char *)tmp___0;
    }
  }
  {
#line 1114
  memset((void *)(typetable + *tablesize), 0, (size_t )(newsize - *tablesize));
#line 1117
  *tablesize = newsize;
  }
#line 1118
  return;
}
}
#line 319 "../../include/sm/io.h"
int sm_vasprintf(char **str , char const   *fmt , va_list ap ) ;
#line 57 "../../include/sm/heap.h"
void *sm_realloc(void *ptr , size_t size ) ;
#line 55 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vasprintf.c"
int sm_vasprintf(char **str , char const   *fmt , va_list ap ) 
{ 
  int ret ;
  SM_FILE_T fake ;
  unsigned char *base ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 65
  fake.sm_magic = SmFileMagic;
#line 66
  fake.f_timeout = -1;
#line 67
  fake.f_timeoutstate = 0;
#line 68
  fake.f_file = (short)-1;
#line 69
  fake.f_flags = 67616L;
#line 70
  tmp = sm_malloc_tagged((size_t )128, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vasprintf.c",
                         70, SmHeapGroup);
#line 70
  fake.f_p = (unsigned char *)tmp;
#line 70
  fake.f_bf.smb_base = fake.f_p;
  }
#line 71
  if ((unsigned long )fake.f_bf.smb_base == (unsigned long )((void *)0)) {
#line 72
    goto err2;
  }
  {
#line 73
  fake.f_close = (int (*)(SM_FILE_T * ))((void *)0);
#line 74
  fake.f_open = (int (*)(SM_FILE_T * , void const   * , int  , void const   * ))((void *)0);
#line 75
  fake.f_read = (ssize_t (*)(SM_FILE_T * , char * , size_t  ))((void *)0);
#line 76
  fake.f_write = (ssize_t (*)(SM_FILE_T * , char const   * , size_t  ))((void *)0);
#line 77
  fake.f_seek = (off_t (*)(SM_FILE_T * , off_t  , int  ))((void *)0);
#line 78
  fake.f_getinfo = (int (*)(SM_FILE_T * , int  , void * ))((void *)0);
#line 78
  fake.f_setinfo = fake.f_getinfo;
#line 79
  fake.f_type = (char *)"sm_vasprintf:fake";
#line 80
  fake.f_w = 127;
#line 80
  fake.f_bf.smb_size = fake.f_w;
#line 81
  fake.f_timeout = -1;
#line 82
  ret = sm_io_vfprintf(& fake, -1, fmt, ap);
  }
#line 83
  if (ret == -1) {
#line 84
    goto err;
  }
  {
#line 85
  *(fake.f_p) = (unsigned char )'\000';
#line 88
  tmp___0 = sm_realloc((void *)fake.f_bf.smb_base, (size_t )(ret + 1));
#line 88
  base = (unsigned char *)tmp___0;
  }
#line 89
  if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 90
    goto err;
  }
#line 91
  *str = (char *)base;
#line 92
  return (ret);
  err: 
#line 95
  if ((unsigned long )fake.f_bf.smb_base != (unsigned long )((void *)0)) {
    {
#line 97
    sm_free_tagged((void *)fake.f_bf.smb_base, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/vasprintf.c",
                   97);
#line 98
    fake.f_bf.smb_base = (unsigned char *)((void *)0);
    }
  }
  err2: 
  {
#line 101
  *str = (char *)((void *)0);
#line 102
  tmp___1 = __errno_location();
#line 102
  *tmp___1 = 12;
  }
#line 103
  return (-1);
}
}
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 29 "../../include/sm/assert.h"
 __attribute__((__noreturn__)) void sm_abort_at(char const   *filename , int lineno ,
                                                char const   *msg ) ;
#line 28 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/local.h"
int sm_flush(SM_FILE_T *fp , int *timeout ) ;
#line 29 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/ungetc.c"
static void sm_submore_x(SM_FILE_T *fp ) ;
#line 49 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/ungetc.c"
static void sm_submore_x(SM_FILE_T *fp ) 
{ 
  register int i ;
  register unsigned char *p ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 56
  if ((unsigned long )fp->f_ub.smb_base == (unsigned long )(fp->f_ubuf)) {
    {
#line 59
    tmp = sm_malloc_tagged_x((size_t )4096, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/ungetc.c",
                             59, SmHeapGroup);
#line 59
    p = (unsigned char *)tmp;
#line 60
    fp->f_ub.smb_base = p;
#line 61
    fp->f_ub.smb_size = 4096;
#line 62
    p += 4096UL - sizeof(fp->f_ubuf);
#line 63
    i = (int )sizeof(fp->f_ubuf);
    }
    {
#line 63
    while (1) {
      while_continue: /* CIL Label */ ;
#line 63
      i --;
#line 63
      if (! (i >= 0)) {
#line 63
        goto while_break;
      }
#line 64
      *(p + i) = fp->f_ubuf[i];
    }
    while_break: /* CIL Label */ ;
    }
#line 65
    fp->f_p = p;
#line 66
    return;
  }
  {
#line 68
  i = fp->f_ub.smb_size;
#line 69
  tmp___0 = sm_realloc_x((void *)fp->f_ub.smb_base, (size_t )(i << 1));
#line 69
  p = (unsigned char *)tmp___0;
#line 72
  memcpy((void */* __restrict  */)((void *)(p + i)), (void const   */* __restrict  */)((void *)p),
         (size_t )i);
#line 73
  fp->f_p = p + i;
#line 74
  fp->f_ub.smb_base = p;
#line 75
  fp->f_ub.smb_size = i << 1;
  }
#line 76
  return;
}
}
#line 95 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/ungetc.c"
int sm_io_ungetc(SM_FILE_T *fp , int timeout , int c ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 101
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 101
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 101
      tmp = 1;
    } else {
      {
#line 101
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/ungetc.c",
                  101, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 101
      tmp = 0;
      }
    }
  } else {
    {
#line 101
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/ungetc.c",
                101, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 101
    tmp = 0;
    }
  }
#line 102
  if (c == -1) {
#line 103
    return (-1);
  }
#line 104
  if (timeout == 0) {
    {
#line 111
    tmp___0 = __errno_location();
#line 111
    *tmp___0 = 11;
    }
#line 112
    return (-1);
  }
#line 115
  if (! Sm_IO_DidInit) {
    {
#line 116
    sm_init();
    }
  }
#line 117
  if ((fp->f_flags & 16L) == 0L) {
#line 124
    if ((fp->f_flags & 64L) == 0L) {
#line 125
      return (-1);
    }
#line 126
    if (fp->f_flags & 32L) {
      {
#line 128
      tmp___1 = sm_flush(fp, & timeout);
      }
#line 128
      if (tmp___1) {
#line 129
        return (-1);
      }
#line 130
      fp->f_flags &= -33L;
#line 131
      fp->f_w = 0;
#line 132
      fp->f_lbfsize = 0;
    }
#line 134
    fp->f_flags |= 16L;
  }
#line 136
  c = (int )((unsigned char )c);
#line 143
  if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 145
    if (fp->f_r >= fp->f_ub.smb_size) {
      {
#line 146
      sm_submore_x(fp);
      }
    }
#line 147
    (fp->f_p) --;
#line 147
    *(fp->f_p) = (unsigned char )c;
#line 148
    (fp->f_r) ++;
#line 149
    return (c);
  }
#line 151
  fp->f_flags &= -129L;
#line 159
  if ((unsigned long )fp->f_bf.smb_base != (unsigned long )((void *)0)) {
#line 159
    if ((unsigned long )fp->f_p > (unsigned long )fp->f_bf.smb_base) {
#line 159
      if ((int )*(fp->f_p + -1) == c) {
#line 162
        (fp->f_p) --;
#line 163
        (fp->f_r) ++;
#line 164
        return (c);
      }
    }
  }
#line 172
  fp->f_ur = fp->f_r;
#line 173
  fp->f_up = fp->f_p;
#line 174
  fp->f_ub.smb_base = fp->f_ubuf;
#line 175
  fp->f_ub.smb_size = (int )sizeof(fp->f_ubuf);
#line 176
  fp->f_ubuf[sizeof(fp->f_ubuf) - 1UL] = (unsigned char )c;
#line 177
  fp->f_p = & fp->f_ubuf[sizeof(fp->f_ubuf) - 1UL];
#line 178
  fp->f_r = 1;
#line 180
  return (c);
}
}
#line 640 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 59 "/usr/include/getopt.h"
char *optarg ;
#line 78
int opterr ;
#line 82
int optopt ;
#line 152
 __attribute__((__nothrow__)) int getopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 144
extern struct _IO_FILE *stderr ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 46 "../../include/sm/debug.h"
void sm_debug_addsettings_x(char const   *s ) ;
#line 27 "../../include/sm/test.h"
int SmTestIndex  ;
#line 28 "../../include/sm/test.h"
int SmTestNumErrors  ;
#line 30
void sm_test_begin(int argc , char **argv , char *testname ) ;
#line 36
bool sm_test(bool success , char *expr , char *filename , int lineno ) ;
#line 43
int sm_test_end(void) ;
#line 30 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/test.c"
bool SmTestVerbose  ;
#line 32 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/test.c"
static char Help[131]  = 
#line 32
  {      (char )'%',      (char )'s',      (char )' ',      (char )'[', 
        (char )'-',      (char )'h',      (char )']',      (char )' ', 
        (char )'[',      (char )'-',      (char )'d',      (char )' ', 
        (char )'d',      (char )'e',      (char )'b',      (char )'u', 
        (char )'g',      (char )'g',      (char )'i',      (char )'n', 
        (char )'g',      (char )']',      (char )' ',      (char )'[', 
        (char )'-',      (char )'v',      (char )']',      (char )'\n', 
        (char )'\n',      (char )'%',      (char )'s',      (char )'\n', 
        (char )'\n',      (char )'-',      (char )'h',      (char )'\t', 
        (char )'\t',      (char )'D',      (char )'i',      (char )'s', 
        (char )'p',      (char )'l',      (char )'a',      (char )'y', 
        (char )' ',      (char )'t',      (char )'h',      (char )'i', 
        (char )'s',      (char )' ',      (char )'h',      (char )'e', 
        (char )'l',      (char )'p',      (char )' ',      (char )'i', 
        (char )'n',      (char )'f',      (char )'o',      (char )'r', 
        (char )'m',      (char )'a',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'.',      (char )'\n', 
        (char )'-',      (char )'d',      (char )' ',      (char )'d', 
        (char )'e',      (char )'b',      (char )'u',      (char )'g', 
        (char )'g',      (char )'i',      (char )'n',      (char )'g', 
        (char )'\t',      (char )'S',      (char )'e',      (char )'t', 
        (char )' ',      (char )'d',      (char )'e',      (char )'b', 
        (char )'u',      (char )'g',      (char )' ',      (char )'a', 
        (char )'c',      (char )'t',      (char )'i',      (char )'v', 
        (char )'a',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'l',      (char )'e', 
        (char )'v',      (char )'e',      (char )'l',      (char )'s', 
        (char )'.',      (char )'\n',      (char )'-',      (char )'v', 
        (char )'\t',      (char )'\t',      (char )'V',      (char )'e', 
        (char )'r',      (char )'b',      (char )'o',      (char )'s', 
        (char )'e',      (char )' ',      (char )'o',      (char )'u', 
        (char )'t',      (char )'p',      (char )'u',      (char )'t', 
        (char )'.',      (char )'\n',      (char )'\000'};
#line 42 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/test.c"
static char Usage[41]  = 
#line 42
  {      (char )'U',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )':',      (char )' ',      (char )'%', 
        (char )'s',      (char )' ',      (char )'[',      (char )'-', 
        (char )'h',      (char )']',      (char )' ',      (char )'[', 
        (char )'-',      (char )'v',      (char )']',      (char )'\n', 
        (char )'U',      (char )'s',      (char )'e',      (char )' ', 
        (char )'%',      (char )'s',      (char )' ',      (char )'-', 
        (char )'h',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'h',      (char )'e', 
        (char )'l',      (char )'p',      (char )'.',      (char )'\n', 
        (char )'\000'};
#line 59 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/test.c"
void sm_test_begin(int argc , char **argv , char *testname ) 
{ 
  int c ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 67
  SmTestIndex = 0;
#line 68
  SmTestNumErrors = 0;
#line 69
  SmTestVerbose = 0;
#line 70
  opterr = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 72
    c = getopt(argc, (char * const  *)argv, "vhd:");
    }
#line 72
    if (! (c != -1)) {
#line 72
      goto while_break;
    }
    {
#line 76
    if (c == 118) {
#line 76
      goto case_118;
    }
#line 79
    if (c == 100) {
#line 79
      goto case_100;
    }
#line 82
    if (c == 104) {
#line 82
      goto case_104;
    }
#line 85
    goto switch_default;
    case_118: /* CIL Label */ 
#line 77
    SmTestVerbose = 1;
#line 78
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 80
    sm_debug_addsettings_x((char const   *)optarg);
    }
#line 81
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 83
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)(Help),
            *(argv + 0), testname);
#line 84
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown command line option -%c\n",
            optopt);
#line 89
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(Usage),
            *(argv + 0), *(argv + 0));
#line 90
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 108 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/test.c"
bool sm_test(bool success , char *expr , char *filename , int lineno ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 115
  SmTestIndex ++;
#line 116
  if (SmTestVerbose) {
    {
#line 117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d..",
            SmTestIndex);
    }
  }
#line 118
  if (! success) {
#line 120
    SmTestNumErrors ++;
#line 121
    if (! SmTestVerbose) {
      {
#line 122
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d..",
              SmTestIndex);
      }
    }
    {
#line 123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad! %s:%d %s\n",
            filename, lineno, expr);
    }
  } else
#line 128
  if (SmTestVerbose) {
    {
#line 129
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ok\n");
    }
  }
#line 131
  return (success);
}
}
#line 144 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/test.c"
int sm_test_end(void) 
{ 
  char const   *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 147
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d of %d tests completed successfully\n",
          SmTestIndex - SmTestNumErrors, SmTestIndex);
  }
#line 149
  if (SmTestNumErrors != 0) {
#line 150
    if (SmTestNumErrors > 1) {
#line 150
      tmp = "s";
    } else {
#line 150
      tmp = "";
    }
    {
#line 150
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** %d error%s in test! ***\n",
            SmTestNumErrors, tmp);
    }
  }
#line 154
  return (SmTestNumErrors);
}
}
#line 43 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strto.c"
LONGLONG_T sm_strtoll(char const   *nptr , char **endptr , int base ) 
{ 
  register bool neg ;
  register char const   *s ;
  register LONGLONG_T acc ;
  register LONGLONG_T cutoff ;
  register int c ;
  register int any ;
  register int cutlim ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char const   *tmp___11 ;

  {
#line 61
  s = nptr;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    tmp = s;
#line 64
    s ++;
#line 64
    c = (int )((unsigned char )*tmp);
#line 62
    if ((c & -128) == 0) {
      {
#line 62
      tmp___0 = __ctype_b_loc();
      }
#line 62
      if (! ((int const   )*(*tmp___0 + c) & 8192)) {
#line 62
        goto while_break;
      }
    } else {
#line 62
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  if (c == 45) {
#line 68
    neg = 1;
#line 69
    tmp___1 = s;
#line 69
    s ++;
#line 69
    c = (int )*tmp___1;
  } else {
#line 73
    neg = 0;
#line 74
    if (c == 43) {
#line 75
      tmp___2 = s;
#line 75
      s ++;
#line 75
      c = (int )*tmp___2;
    }
  }
#line 77
  if (base == 0) {
#line 77
    goto _L;
  } else
#line 77
  if (base == 16) {
    _L: /* CIL Label */ 
#line 77
    if (c == 48) {
#line 77
      if ((int const   )*s == 120) {
#line 80
        c = (int )*(s + 1);
#line 81
        s += 2;
#line 82
        base = 16;
      } else
#line 77
      if ((int const   )*s == 88) {
#line 80
        c = (int )*(s + 1);
#line 81
        s += 2;
#line 82
        base = 16;
      }
    }
  }
#line 84
  if (base == 0) {
#line 85
    if (c == 48) {
#line 85
      base = 8;
    } else {
#line 85
      base = 10;
    }
  }
#line 106
  if (neg) {
#line 106
    cutoff = (LONGLONG_T )(~ (0xffffffffffffffffULL >> 1));
  } else {
#line 106
    cutoff = (LONGLONG_T )(0xffffffffffffffffULL >> 1);
  }
#line 107
  cutlim = (int )(cutoff % (long long )base);
#line 108
  cutoff /= (LONGLONG_T )base;
#line 109
  if (neg) {
#line 111
    if (cutlim > 0) {
#line 113
      cutlim -= base;
#line 114
      cutoff ++;
    }
#line 116
    cutlim = - cutlim;
  }
#line 118
  acc = (LONGLONG_T )0;
#line 118
  any = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if ((c & -128) == 0) {
      {
#line 120
      tmp___8 = __ctype_b_loc();
      }
#line 120
      if ((int const   )*(*tmp___8 + c) & 2048) {
#line 121
        c -= 48;
      } else {
#line 120
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 122
    if ((c & -128) == 0) {
      {
#line 122
      tmp___7 = __ctype_b_loc();
      }
#line 122
      if ((int const   )*(*tmp___7 + c) & 1024) {
        {
#line 123
        tmp___6 = __ctype_b_loc();
        }
#line 123
        if ((int const   )*(*tmp___6 + c) & 256) {
#line 123
          tmp___5 = 55;
        } else {
#line 123
          tmp___5 = 87;
        }
#line 123
        c -= tmp___5;
      } else {
#line 125
        goto while_break___0;
      }
    } else {
#line 125
      goto while_break___0;
    }
#line 126
    if (c >= base) {
#line 127
      goto while_break___0;
    }
#line 128
    if (any < 0) {
#line 129
      goto __Cont;
    }
#line 130
    if (neg) {
#line 132
      if (acc < cutoff) {
        {
#line 134
        any = -1;
#line 135
        acc = (LONGLONG_T )(~ (0xffffffffffffffffULL >> 1));
#line 136
        tmp___9 = __errno_location();
#line 136
        *tmp___9 = 34;
        }
      } else
#line 132
      if (acc == cutoff) {
#line 132
        if (c > cutlim) {
          {
#line 134
          any = -1;
#line 135
          acc = (LONGLONG_T )(~ (0xffffffffffffffffULL >> 1));
#line 136
          tmp___9 = __errno_location();
#line 136
          *tmp___9 = 34;
          }
        } else {
#line 140
          any = 1;
#line 141
          acc *= (LONGLONG_T )base;
#line 142
          acc -= (LONGLONG_T )c;
        }
      } else {
#line 140
        any = 1;
#line 141
        acc *= (LONGLONG_T )base;
#line 142
        acc -= (LONGLONG_T )c;
      }
    } else
#line 147
    if (acc > cutoff) {
      {
#line 149
      any = -1;
#line 150
      acc = (LONGLONG_T )(0xffffffffffffffffULL >> 1);
#line 151
      tmp___10 = __errno_location();
#line 151
      *tmp___10 = 34;
      }
    } else
#line 147
    if (acc == cutoff) {
#line 147
      if (c > cutlim) {
        {
#line 149
        any = -1;
#line 150
        acc = (LONGLONG_T )(0xffffffffffffffffULL >> 1);
#line 151
        tmp___10 = __errno_location();
#line 151
        *tmp___10 = 34;
        }
      } else {
#line 155
        any = 1;
#line 156
        acc *= (LONGLONG_T )base;
#line 157
        acc += (LONGLONG_T )c;
      }
    } else {
#line 155
      any = 1;
#line 156
      acc *= (LONGLONG_T )base;
#line 157
      acc += (LONGLONG_T )c;
    }
    __Cont: /* CIL Label */ 
#line 118
    tmp___3 = s;
#line 118
    s ++;
#line 118
    c = (int )((unsigned char )*tmp___3);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 161
  if ((unsigned long )endptr != (unsigned long )((char **)0)) {
#line 162
    if (any) {
#line 162
      tmp___11 = s - 1;
    } else {
#line 162
      tmp___11 = nptr;
    }
#line 162
    *endptr = (char *)tmp___11;
  }
#line 163
  return (acc);
}
}
#line 184 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strto.c"
ULONGLONG_T sm_strtoull(char const   *nptr , char **endptr , int base ) 
{ 
  register char const   *s ;
  register ULONGLONG_T acc ;
  register ULONGLONG_T cutoff ;
  register int c ;
  register bool neg ;
  register int any ;
  register int cutlim ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  int *tmp___9 ;
  char const   *tmp___10 ;

  {
#line 197
  s = nptr;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    tmp = s;
#line 200
    s ++;
#line 200
    c = (int )((unsigned char )*tmp);
#line 198
    if ((c & -128) == 0) {
      {
#line 198
      tmp___0 = __ctype_b_loc();
      }
#line 198
      if (! ((int const   )*(*tmp___0 + c) & 8192)) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  neg = c == 45;
#line 203
  if (neg) {
#line 205
    tmp___1 = s;
#line 205
    s ++;
#line 205
    c = (int )*tmp___1;
  } else
#line 209
  if (c == 43) {
#line 210
    tmp___2 = s;
#line 210
    s ++;
#line 210
    c = (int )*tmp___2;
  }
#line 212
  if (base == 0) {
#line 212
    goto _L;
  } else
#line 212
  if (base == 16) {
    _L: /* CIL Label */ 
#line 212
    if (c == 48) {
#line 212
      if ((int const   )*s == 120) {
#line 215
        c = (int )*(s + 1);
#line 216
        s += 2;
#line 217
        base = 16;
      } else
#line 212
      if ((int const   )*s == 88) {
#line 215
        c = (int )*(s + 1);
#line 216
        s += 2;
#line 217
        base = 16;
      }
    }
  }
#line 219
  if (base == 0) {
#line 220
    if (c == 48) {
#line 220
      base = 8;
    } else {
#line 220
      base = 10;
    }
  }
#line 222
  cutoff = 0xffffffffffffffffULL / (ULONGLONG_T )base;
#line 223
  cutlim = (int )(0xffffffffffffffffULL % (ULONGLONG_T )base);
#line 224
  acc = (ULONGLONG_T )0;
#line 224
  any = 0;
  {
#line 224
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 226
    if ((c & -128) == 0) {
      {
#line 226
      tmp___8 = __ctype_b_loc();
      }
#line 226
      if ((int const   )*(*tmp___8 + c) & 2048) {
#line 227
        c -= 48;
      } else {
#line 226
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 228
    if ((c & -128) == 0) {
      {
#line 228
      tmp___7 = __ctype_b_loc();
      }
#line 228
      if ((int const   )*(*tmp___7 + c) & 1024) {
        {
#line 229
        tmp___6 = __ctype_b_loc();
        }
#line 229
        if ((int const   )*(*tmp___6 + c) & 256) {
#line 229
          tmp___5 = 55;
        } else {
#line 229
          tmp___5 = 87;
        }
#line 229
        c -= tmp___5;
      } else {
#line 231
        goto while_break___0;
      }
    } else {
#line 231
      goto while_break___0;
    }
#line 232
    if (c >= base) {
#line 233
      goto while_break___0;
    }
#line 234
    if (any < 0) {
#line 235
      goto __Cont;
    }
#line 236
    if (acc > cutoff) {
      {
#line 238
      any = -1;
#line 239
      acc = (ULONGLONG_T )-1;
#line 240
      tmp___9 = __errno_location();
#line 240
      *tmp___9 = 34;
      }
    } else
#line 236
    if (acc == cutoff) {
#line 236
      if (c > cutlim) {
        {
#line 238
        any = -1;
#line 239
        acc = (ULONGLONG_T )-1;
#line 240
        tmp___9 = __errno_location();
#line 240
        *tmp___9 = 34;
        }
      } else {
#line 244
        any = 1;
#line 245
        acc *= (ULONGLONG_T )base;
#line 246
        acc += (ULONGLONG_T )c;
      }
    } else {
#line 244
      any = 1;
#line 245
      acc *= (ULONGLONG_T )base;
#line 246
      acc += (ULONGLONG_T )c;
    }
    __Cont: /* CIL Label */ 
#line 224
    tmp___3 = s;
#line 224
    s ++;
#line 224
    c = (int )((unsigned char )*tmp___3);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 249
  if (neg) {
#line 249
    if (any > 0) {
#line 250
      acc = (ULONGLONG_T )(- ((LONGLONG_T )acc));
    }
  }
#line 251
  if ((unsigned long )endptr != (unsigned long )((char **)0)) {
#line 252
    if (any) {
#line 252
      tmp___10 = s - 1;
    } else {
#line 252
      tmp___10 = nptr;
    }
#line 252
    *endptr = (char *)tmp___10;
  }
#line 253
  return (acc);
}
}
#line 92 "../../include/sm/string.h"
int sm_strrevcmp(char const   *s1 , char const   *s2 ) ;
#line 95
int sm_strrevcasecmp(char const   *s1 , char const   *s2 ) ;
#line 19 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strrevcmp.c"
unsigned char const   charmap[256] ;
#line 32 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strrevcmp.c"
int sm_strrevcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register int i1 ;
  register int i2 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 38
  tmp = strlen(s1);
#line 38
  i1 = (int )(tmp - 1U);
#line 39
  tmp___0 = strlen(s2);
#line 39
  i2 = (int )(tmp___0 - 1U);
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (i1 >= 0) {
#line 40
      if (i2 >= 0) {
#line 40
        if (! ((int const   )charmap[(unsigned char )*(s1 + i1)] == (int const   )charmap[(unsigned char )*(s2 + i2)])) {
#line 40
          goto while_break;
        }
      } else {
#line 40
        goto while_break;
      }
    } else {
#line 40
      goto while_break;
    }
#line 44
    i1 --;
#line 45
    i2 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  if (i1 < 0) {
#line 49
    if (i2 < 0) {
#line 50
      return (0);
    } else {
#line 52
      return (-1);
    }
  } else
#line 56
  if (i2 < 0) {
#line 57
    return (1);
  } else {
#line 59
    return ((int )((int const   )charmap[(unsigned char )*(s1 + i1)] - (int const   )charmap[(unsigned char )*(s2 + i2)]));
  }
}
}
#line 74 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strrevcmp.c"
int sm_strrevcmp(char const   *s1 , char const   *s2 ) 
{ 
  register int i1 ;
  register int i2 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 80
  tmp = strlen(s1);
#line 80
  i1 = (int )(tmp - 1U);
#line 81
  tmp___0 = strlen(s2);
#line 81
  i2 = (int )(tmp___0 - 1U);
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (i1 >= 0) {
#line 82
      if (i2 >= 0) {
#line 82
        if (! ((int const   )*(s1 + i1) == (int const   )*(s2 + i2))) {
#line 82
          goto while_break;
        }
      } else {
#line 82
        goto while_break;
      }
    } else {
#line 82
      goto while_break;
    }
#line 84
    i1 --;
#line 85
    i2 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  if (i1 < 0) {
#line 89
    if (i2 < 0) {
#line 90
      return (0);
    } else {
#line 92
      return (-1);
    }
  } else
#line 96
  if (i2 < 0) {
#line 97
    return (1);
  } else {
#line 99
    return ((int )((int const   )*(s1 + i1) - (int const   )*(s2 + i2)));
  }
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 68 "../../include/sm/string.h"
size_t sm_strlcpy(char *dst , char const   *src , ssize_t size ) ;
#line 71
size_t sm_strlcat(char *dst , char const   *src , ssize_t size ) ;
#line 74
size_t sm_strlcat2(char *dst , char const   *src1 , char const   *src2 , ssize_t len___0 ) ;
#line 77
size_t sm_strlcpyn(char *dst , ssize_t len___0 , int n  , ...) ;
#line 57 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strl.c"
size_t sm_strlcpy(char *dst , char const   *src , ssize_t size ) 
{ 
  register ssize_t i ;
  size_t tmp ;
  ssize_t tmp___0 ;
  char tmp___1 ;
  size_t tmp___2 ;

  {
#line 65
  tmp___0 = size;
#line 65
  size --;
#line 65
  if (tmp___0 <= 0) {
    {
#line 66
    tmp = strlen(src);
    }
#line 66
    return (tmp);
  }
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (i < size) {
#line 67
      tmp___1 = (char )*(src + i);
#line 67
      *(dst + i) = tmp___1;
#line 67
      if (! ((int )tmp___1 != 0)) {
#line 67
        goto while_break;
      }
    } else {
#line 67
      goto while_break;
    }
#line 68
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  *(dst + i) = (char )'\000';
#line 70
  if ((int const   )*(src + i) == 0) {
#line 71
    return ((size_t )i);
  } else {
    {
#line 73
    tmp___2 = strlen(src + i);
    }
#line 73
    return ((size_t )i + tmp___2);
  }
}
}
#line 103 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strl.c"
size_t sm_strlcat(char *dst , char const   *src , ssize_t size ) 
{ 
  register ssize_t i ;
  register ssize_t j ;
  register ssize_t o ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 111
  tmp = strlen((char const   *)dst);
#line 111
  o = (ssize_t )tmp;
  }
#line 112
  if (size < o + 1) {
    {
#line 113
    tmp___0 = strlen(src);
    }
#line 113
    return ((size_t )o + tmp___0);
  }
#line 114
  size -= o + 1;
#line 115
  i = 0;
#line 115
  j = o;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (i < size) {
#line 115
      tmp___1 = (char )*(src + i);
#line 115
      *(dst + j) = tmp___1;
#line 115
      if (! ((int )tmp___1 != 0)) {
#line 115
        goto while_break;
      }
    } else {
#line 115
      goto while_break;
    }
#line 116
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 115
    i ++;
#line 115
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  *(dst + j) = (char )'\000';
#line 118
  if ((int const   )*(src + i) == 0) {
#line 119
    return ((size_t )j);
  } else {
    {
#line 121
    tmp___2 = strlen(src + i);
    }
#line 121
    return ((size_t )j + tmp___2);
  }
}
}
#line 147 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strl.c"
size_t sm_strlcat2(char *dst , char const   *src1 , char const   *src2 , ssize_t len___0 ) 
{ 
  register ssize_t i ;
  register ssize_t j ;
  register ssize_t o ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 157
  tmp = strlen((char const   *)dst);
#line 157
  o = (ssize_t )tmp;
  }
#line 160
  if (len___0 < o + 1) {
    {
#line 161
    tmp___0 = strlen(src1);
#line 161
    tmp___1 = strlen(src2);
    }
#line 161
    return (((size_t )o + tmp___0) + tmp___1);
  }
#line 163
  len___0 -= o + 1;
#line 166
  i = 0;
#line 166
  j = o;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (i < len___0) {
#line 166
      tmp___2 = (char )*(src1 + i);
#line 166
      *(dst + j) = tmp___2;
#line 166
      if (! ((int )tmp___2 != 0)) {
#line 166
        goto while_break;
      }
    } else {
#line 166
      goto while_break;
    }
#line 167
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 166
    i ++;
#line 166
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  if ((int const   )*(src1 + i) != 0) {
    {
#line 173
    *(dst + j) = (char )'\000';
#line 174
    tmp___3 = strlen(src1 + i);
#line 174
    tmp___4 = strlen(src2);
    }
#line 174
    return (((size_t )j + tmp___3) + tmp___4);
  }
#line 177
  len___0 -= i;
#line 180
  i = 0;
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (i < len___0) {
#line 180
      tmp___5 = (char )*(src2 + i);
#line 180
      *(dst + j) = tmp___5;
#line 180
      if (! ((int )tmp___5 != 0)) {
#line 180
        goto while_break___0;
      }
    } else {
#line 180
      goto while_break___0;
    }
#line 181
    goto __Cont___0;
    __Cont___0: /* CIL Label */ 
#line 180
    i ++;
#line 180
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 182
  *(dst + j) = (char )'\000';
#line 183
  if ((int const   )*(src2 + i) == 0) {
#line 184
    return ((size_t )j);
  } else {
    {
#line 186
    tmp___6 = strlen(src2 + i);
    }
#line 186
    return ((size_t )j + tmp___6);
  }
}
}
#line 210 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strl.c"
size_t sm_strlcpyn(char *dst , ssize_t len___0 , int n  , ...) 
{ 
  register ssize_t i ;
  register ssize_t j ;
  char *str ;
  va_list ap ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  char *tmp___4 ;
  char tmp___5 ;
  size_t tmp___6 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 225
  __builtin_va_start(ap, n);
#line 227
  tmp___3 = len___0;
#line 227
  len___0 --;
  }
#line 227
  if (tmp___3 <= 0) {
#line 229
    i = 0;
    {
#line 230
    while (1) {
      while_continue: /* CIL Label */ ;
#line 230
      tmp___2 = n;
#line 230
      n --;
#line 230
      if (! (tmp___2 > 0)) {
#line 230
        goto while_break;
      }
      {
#line 231
      tmp___0 = __builtin_va_arg(ap, char *);
#line 231
      tmp___1 = strlen((char const   *)tmp___0);
#line 231
      i = (ssize_t )((size_t )i + tmp___1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 232
    __builtin_va_end(ap);
    }
#line 233
    return ((size_t )i);
  }
#line 236
  j = 0;
  {
#line 239
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 239
    tmp___11 = n;
#line 239
    n --;
#line 239
    if (! (tmp___11 > 0)) {
#line 239
      goto while_break___0;
    }
    {
#line 241
    tmp___4 = __builtin_va_arg(ap, char *);
#line 241
    str = tmp___4;
#line 244
    i = 0;
    }
    {
#line 244
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 244
      if (j < len___0) {
#line 244
        tmp___5 = *(str + i);
#line 244
        *(dst + j) = tmp___5;
#line 244
        if (! ((int )tmp___5 != 0)) {
#line 244
          goto while_break___1;
        }
      } else {
#line 244
        goto while_break___1;
      }
#line 245
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 244
      i ++;
#line 244
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 248
    if ((int )*(str + i) != 0) {
      {
#line 251
      *(dst + j) = (char )'\000';
#line 252
      tmp___6 = strlen((char const   *)(str + i));
#line 252
      j = (ssize_t )((size_t )j + tmp___6);
      }
      {
#line 253
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 253
        tmp___10 = n;
#line 253
        n --;
#line 253
        if (! (tmp___10 > 0)) {
#line 253
          goto while_break___2;
        }
        {
#line 254
        tmp___8 = __builtin_va_arg(ap, char *);
#line 254
        tmp___9 = strlen((char const   *)tmp___8);
#line 254
        j = (ssize_t )((size_t )j + tmp___9);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 255
      __builtin_va_end(ap);
      }
#line 256
      return ((size_t )j);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 259
  __builtin_va_end(ap);
#line 261
  *(dst + j) = (char )'\000';
  }
#line 262
  return ((size_t )j);
}
}
#line 306 "../../include/sm/io.h"
void sm_strio_init(SM_FILE_T *fp , char *buf___16 , size_t size ) ;
#line 40 "../../include/sm/string.h"
char *sm_strdup_x(char const   *s ) ;
#line 61 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/local.h"
ssize_t sm_strread(SM_FILE_T *fp , char *buf___16 , size_t n ) ;
#line 62
ssize_t sm_strwrite(SM_FILE_T *fp , char const   *buf___16 , size_t n ) ;
#line 63
off_t sm_strseek(SM_FILE_T *fp , off_t offset , int whence ) ;
#line 64
int sm_strclose(SM_FILE_T *fp ) ;
#line 65
int sm_stropen(SM_FILE_T *fp , void const   *info , int flags , void const   *rpool ) ;
#line 66
int sm_strsetinfo(SM_FILE_T *fp , int what , void *valp ) ;
#line 67
int sm_strgetinfo(SM_FILE_T *fp , int what , void *valp ) ;
#line 28 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
static int sm_strsetmode(SM_FILE_T *fp , int const   *mode ) ;
#line 29
static int sm_strgetmode(SM_FILE_T *fp , int *mode ) ;
#line 58
static bool sm_strgrow(SM_STR_OBJ_T *s , size_t size ) ;
#line 60 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
static bool sm_strgrow(SM_STR_OBJ_T *s , size_t size ) 
{ 
  register void *p ;

  {
#line 67
  if (s->strio_size >= size) {
#line 68
    return (1);
  }
  {
#line 69
  p = sm_realloc((void *)s->strio_base, size);
  }
#line 70
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 71
    return (0);
  }
#line 72
  s->strio_base = (char *)p;
#line 73
  s->strio_end = s->strio_base + size;
#line 74
  s->strio_size = size;
#line 75
  return (1);
}
}
#line 91 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
ssize_t sm_strread(SM_FILE_T *fp , char *buf___16 , size_t n ) 
{ 
  register SM_STR_OBJ_T *s ;
  int len___0 ;
  int *tmp ;

  {
#line 97
  s = (SM_STR_OBJ_T *)fp->f_cookie;
#line 100
  if (! (s->strio_flags & 16)) {
#line 100
    if (! (s->strio_flags & 64)) {
      {
#line 102
      tmp = __errno_location();
#line 102
      *tmp = 9;
      }
#line 103
      return (-1);
    }
  }
#line 105
  if (s->strio_size - s->strio_offset < n) {
#line 105
    len___0 = (int )(s->strio_size - s->strio_offset);
  } else {
#line 105
    len___0 = (int )n;
  }
  {
#line 106
  memmove((void *)buf___16, (void const   *)(s->strio_base + s->strio_offset), (size_t )len___0);
#line 107
  s->strio_offset += (size_t )len___0;
  }
#line 108
  return (len___0);
}
}
#line 124 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
ssize_t sm_strwrite(SM_FILE_T *fp , char const   *buf___16 , size_t n ) 
{ 
  register SM_STR_OBJ_T *s ;
  int *tmp ;
  bool tmp___0 ;

  {
#line 130
  s = (SM_STR_OBJ_T *)fp->f_cookie;
#line 132
  if (! (s->strio_flags & 32)) {
#line 132
    if (! (s->strio_flags & 64)) {
      {
#line 134
      tmp = __errno_location();
#line 134
      *tmp = 9;
      }
#line 135
      return (-1);
    }
  }
#line 137
  if (n + s->strio_offset > s->strio_size) {
    {
#line 139
    tmp___0 = sm_strgrow(s, n + s->strio_offset);
    }
#line 139
    if (! tmp___0) {
#line 140
      return (0);
    }
  }
  {
#line 142
  memmove((void *)(s->strio_base + s->strio_offset), (void const   *)buf___16, n);
#line 143
  s->strio_offset += n;
  }
#line 144
  return ((ssize_t )n);
}
}
#line 163 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
off_t sm_strseek(SM_FILE_T *fp , off_t offset , int whence ) 
{ 
  register off_t ret ;
  register SM_STR_OBJ_T *s ;
  int *tmp ;
  bool tmp___0 ;

  {
#line 170
  s = (SM_STR_OBJ_T *)fp->f_cookie;
  reseek: 
  {
#line 175
  if (whence == 0) {
#line 175
    goto case_0;
  }
#line 178
  if (whence == 1) {
#line 178
    goto case_1;
  }
#line 181
  if (whence == 2) {
#line 181
    goto case_2;
  }
#line 184
  goto switch_default;
  case_0: /* CIL Label */ 
#line 176
  ret = offset;
#line 177
  goto switch_break;
  case_1: /* CIL Label */ 
#line 179
  ret = (off_t )s->strio_offset + offset;
#line 180
  goto switch_break;
  case_2: /* CIL Label */ 
#line 182
  ret = (off_t )s->strio_size;
#line 183
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 185
  tmp = __errno_location();
#line 185
  *tmp = 22;
  }
#line 186
  return ((off_t )-1);
  switch_break: /* CIL Label */ ;
  }
#line 188
  if (ret < 0L) {
#line 189
    return ((off_t )-1);
  } else
#line 188
  if (ret > 4294967295L) {
#line 189
    return ((off_t )-1);
  }
#line 190
  if ((size_t )ret > s->strio_size) {
    {
#line 192
    tmp___0 = sm_strgrow(s, (size_t )ret);
    }
#line 192
    if (tmp___0) {
#line 193
      goto reseek;
    }
#line 196
    return ((off_t )-1);
  }
#line 198
  s->strio_offset = (size_t )ret;
#line 199
  return (ret);
}
}
#line 216 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
int sm_stropen(SM_FILE_T *fp , void const   *info , int flags , void const   *rpool ) 
{ 
  register SM_STR_OBJ_T *s ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int save_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 228
  tmp = sm_malloc_tagged((size_t )sizeof(SM_STR_OBJ_T ), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c",
                         228, SmHeapGroup);
#line 228
  s = (SM_STR_OBJ_T *)tmp;
  }
#line 229
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 230
    return (-1);
  }
#line 233
  fp->f_cookie = (void *)s;
#line 234
  s->strio_rpool = rpool;
#line 235
  s->strio_offset = (size_t )0;
#line 236
  s->strio_size = (size_t )0;
#line 237
  s->strio_base = (char *)((void *)0);
#line 238
  s->strio_end = (char *)0;
  {
#line 242
  if (flags == 1) {
#line 242
    goto case_1;
  }
#line 245
  if (flags == 2) {
#line 245
    goto case_2;
  }
#line 248
  if (flags == 3) {
#line 248
    goto case_3;
  }
#line 251
  if (flags == 4) {
#line 251
    goto case_4;
  }
#line 256
  goto switch_default;
  case_1: /* CIL Label */ 
#line 243
  s->strio_flags = 64;
#line 244
  goto switch_break;
  case_2: /* CIL Label */ 
#line 246
  s->strio_flags = 16;
#line 247
  goto switch_break;
  case_3: /* CIL Label */ 
#line 249
  s->strio_flags = 32;
#line 250
  goto switch_break;
  case_4: /* CIL Label */ 
#line 252
  if ((unsigned long )s->strio_rpool == (unsigned long )((void *)0)) {
    {
#line 253
    sm_free_tagged((void *)s, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c",
                   253);
    }
  }
  {
#line 254
  tmp___0 = __errno_location();
#line 254
  *tmp___0 = 22;
  }
#line 255
  return (-1);
  switch_default: /* CIL Label */ 
#line 257
  if ((unsigned long )s->strio_rpool == (unsigned long )((void *)0)) {
    {
#line 258
    sm_free_tagged((void *)s, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c",
                   258);
    }
  }
  {
#line 259
  tmp___1 = __errno_location();
#line 259
  *tmp___1 = 22;
  }
#line 260
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 263
  if ((unsigned long )info != (unsigned long )((void *)0)) {
    {
#line 265
    s->strio_base = sm_strdup_x((char const   *)info);
    }
#line 266
    if ((unsigned long )s->strio_base == (unsigned long )((void *)0)) {
      {
#line 268
      tmp___2 = __errno_location();
#line 268
      save_errno = *tmp___2;
      }
#line 270
      if ((unsigned long )s->strio_rpool == (unsigned long )((void *)0)) {
        {
#line 271
        sm_free_tagged((void *)s, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c",
                       271);
        }
      }
      {
#line 272
      tmp___3 = __errno_location();
#line 272
      *tmp___3 = save_errno;
      }
#line 273
      return (-1);
    }
    {
#line 275
    s->strio_size = strlen((char const   *)info);
#line 276
    s->strio_end = s->strio_base + s->strio_size;
    }
  }
#line 278
  return (0);
}
}
#line 291 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
int sm_strclose(SM_FILE_T *fp ) 
{ 
  SM_STR_OBJ_T *s ;
  char *__cil_tmp3 ;

  {
  {
#line 295
  s = (SM_STR_OBJ_T *)fp->f_cookie;
#line 298
  sm_free_tagged((void *)s->strio_base, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c",
                 298);
#line 299
  s->strio_base = (char *)((void *)0);
  }
#line 301
  return (0);
}
}
#line 319 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
static int sm_strsetmode(SM_FILE_T *fp , int const   *mode ) 
{ 
  register SM_STR_OBJ_T *s ;
  int flags ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 324
  s = (SM_STR_OBJ_T *)fp->f_cookie;
  {
#line 329
  if (*mode == 1) {
#line 329
    goto case_1;
  }
#line 332
  if (*mode == 2) {
#line 332
    goto case_2;
  }
#line 335
  if (*mode == 3) {
#line 335
    goto case_3;
  }
#line 338
  if (*mode == 4) {
#line 338
    goto case_4;
  }
#line 341
  goto switch_default;
  case_1: /* CIL Label */ 
#line 330
  flags = 64;
#line 331
  goto switch_break;
  case_2: /* CIL Label */ 
#line 333
  flags = 16;
#line 334
  goto switch_break;
  case_3: /* CIL Label */ 
#line 336
  flags = 32;
#line 337
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 339
  tmp = __errno_location();
#line 339
  *tmp = 22;
  }
#line 340
  return (-1);
  switch_default: /* CIL Label */ 
  {
#line 342
  tmp___0 = __errno_location();
#line 342
  *tmp___0 = 22;
  }
#line 343
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 345
  s->strio_flags &= -113;
#line 346
  s->strio_flags |= flags;
#line 347
  return (0);
}
}
#line 362 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
static int sm_strgetmode(SM_FILE_T *fp , int *mode ) 
{ 
  register SM_STR_OBJ_T *s ;
  int *tmp ;

  {
#line 367
  s = (SM_STR_OBJ_T *)fp->f_cookie;
  {
#line 371
  if ((s->strio_flags & 112) == 64) {
#line 371
    goto case_64;
  }
#line 374
  if ((s->strio_flags & 112) == 16) {
#line 374
    goto case_16;
  }
#line 377
  if ((s->strio_flags & 112) == 32) {
#line 377
    goto case_32;
  }
#line 380
  goto switch_default;
  case_64: /* CIL Label */ 
#line 372
  *mode = 1;
#line 373
  goto switch_break;
  case_16: /* CIL Label */ 
#line 375
  *mode = 2;
#line 376
  goto switch_break;
  case_32: /* CIL Label */ 
#line 378
  *mode = 3;
#line 379
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 381
  tmp = __errno_location();
#line 381
  *tmp = 22;
  }
#line 382
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 384
  return (0);
}
}
#line 402 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
int sm_strsetinfo(SM_FILE_T *fp , int what , void *valp ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 410
  if (what == 1) {
#line 410
    goto case_1;
  }
#line 412
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 411
  tmp = sm_strsetmode(fp, (int const   *)((int *)valp));
  }
#line 411
  return (tmp);
  switch_default: /* CIL Label */ 
  {
#line 413
  tmp___0 = __errno_location();
#line 413
  *tmp___0 = 22;
  }
#line 414
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 433 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
int sm_strgetinfo(SM_FILE_T *fp , int what , void *valp ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 441
  if (what == 1) {
#line 441
    goto case_1;
  }
#line 443
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 442
  tmp = sm_strgetmode(fp, (int *)valp);
  }
#line 442
  return (tmp);
  switch_default: /* CIL Label */ 
  {
#line 444
  tmp___0 = __errno_location();
#line 444
  *tmp___0 = 22;
  }
#line 445
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 473 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strio.c"
void sm_strio_init(SM_FILE_T *fp , char *buf___16 , size_t size ) 
{ 
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 479
  fp->sm_magic = SmFileMagic;
#line 480
  fp->f_flags = 2080L;
#line 481
  fp->f_file = (short)-1;
#line 482
  tmp = (unsigned char *)buf___16;
#line 482
  fp->f_p = tmp;
#line 482
  fp->f_bf.smb_base = tmp;
#line 483
  if (size) {
#line 483
    tmp___0 = (int )(size - 1U);
  } else {
#line 483
    tmp___0 = 0;
  }
#line 483
  fp->f_w = tmp___0;
#line 483
  fp->f_bf.smb_size = tmp___0;
#line 484
  fp->f_lbfsize = 0;
#line 485
  fp->f_r = 0;
#line 486
  fp->f_read = (ssize_t (*)(SM_FILE_T * , char * , size_t  ))((void *)0);
#line 487
  fp->f_seek = (off_t (*)(SM_FILE_T * , off_t  , int  ))((void *)0);
#line 488
  fp->f_getinfo = (int (*)(SM_FILE_T * , int  , void * ))((void *)0);
#line 489
  fp->f_setinfo = (int (*)(SM_FILE_T * , int  , void * ))((void *)0);
#line 490
  return;
}
}
#line 44 "../../include/sm/exc.h"
struct sm_exc_type  const  SmEtypeOs ;
#line 110
 __attribute__((__noreturn__)) void sm_exc_raise_x(SM_EXC_T *exc ) ;
#line 114
 __attribute__((__noreturn__)) void sm_exc_raisenew_x(SM_EXC_TYPE_T const   *etype 
                                                      , ...) ;
#line 99 "../../include/sm/heap.h"
SM_EXC_T SmHeapOutOfMemory ;
#line 62 "../../include/sm/string.h"
char *sm_stringf_x(char const   *fmt  , ...) ;
#line 65
char *sm_vstringf_x(char const   *fmt , va_list ap ) ;
#line 39 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stringf.c"
char *sm_stringf_x(char const   *fmt  , ...) 
{ 
  va_list ap ;
  char *s ;

  {
  {
#line 51
  __builtin_va_start(ap, fmt);
#line 52
  s = sm_vstringf_x(fmt, ap);
#line 53
  __builtin_va_end(ap);
  }
#line 54
  return (s);
}
}
#line 71 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stringf.c"
char *sm_vstringf_x(char const   *fmt , va_list ap ) 
{ 
  char *s ;
  int *tmp ;
  int *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 78
  sm_vasprintf(& s, fmt, ap);
  }
#line 79
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 81
    tmp = __errno_location();
    }
#line 81
    if (*tmp == 12) {
      {
#line 82
      sm_exc_raise_x(& SmHeapOutOfMemory);
      }
    }
    {
#line 83
    tmp___0 = __errno_location();
#line 83
    sm_exc_raisenew_x(& SmEtypeOs, *tmp___0, "sm_vasprintf", (void *)0);
    }
  }
#line 85
  return (s);
}
}
#line 110 "../../include/sm/string.h"
void stripquotes(char *s ) ;
#line 35 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/string.c"
void stripquotes(char *s ) 
{ 
  register char *p ;
  register char *q ;
  register char c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 43
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 44
    return;
  }
#line 46
  q = s;
#line 46
  p = q;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    tmp = p;
#line 49
    p ++;
#line 49
    c = *tmp;
#line 50
    if ((int )c == 92) {
#line 51
      tmp___0 = p;
#line 51
      p ++;
#line 51
      c = *tmp___0;
    } else
#line 52
    if ((int )c == 34) {
#line 53
      goto __Cont;
    }
#line 54
    tmp___1 = q;
#line 54
    q ++;
#line 54
    *tmp___1 = c;
    __Cont: /* CIL Label */ 
#line 47
    if (! ((int )c != 0)) {
#line 47
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return;
}
}
#line 26 "../../include/sm/string.h"
int sm_snprintf(char *str , size_t n , char const   *fmt  , ...) ;
#line 105 "../../include/sm/sysexits.h"
char *sm_strexit(int ex ) ;
#line 106
char *sm_sysexitmsg(int ex ) ;
#line 107
char *sm_sysexmsg(int ex ) ;
#line 33 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strexit.c"
static char buf[64]  ;
#line 28 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strexit.c"
char *sm_strexit(int ex ) 
{ 
  char *msg ;
  char *__cil_tmp3 ;

  {
  {
#line 35
  msg = sm_sysexitmsg(ex);
  }
#line 36
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
    {
#line 38
    sm_snprintf(buf, (size_t )sizeof(buf), "Unknown exit status %d", ex);
#line 40
    msg = buf;
    }
  }
#line 42
  return (msg);
}
}
#line 56 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strexit.c"
char *sm_sysexitmsg(int ex ) 
{ 
  char *msg ;

  {
  {
#line 62
  msg = sm_sysexmsg(ex);
  }
#line 63
  if ((unsigned long )msg != (unsigned long )((void *)0)) {
#line 64
    return (msg + 11);
  } else {
#line 66
    return (msg);
  }
}
}
#line 88 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strexit.c"
char *sm_sysexmsg(int ex ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 94
  if (ex == 64) {
#line 94
    goto case_64;
  }
#line 96
  if (ex == 65) {
#line 96
    goto case_65;
  }
#line 98
  if (ex == 66) {
#line 98
    goto case_66;
  }
#line 100
  if (ex == 67) {
#line 100
    goto case_67;
  }
#line 102
  if (ex == 68) {
#line 102
    goto case_68;
  }
#line 104
  if (ex == 69) {
#line 104
    goto case_69;
  }
#line 106
  if (ex == 70) {
#line 106
    goto case_70;
  }
#line 108
  if (ex == 71) {
#line 108
    goto case_71;
  }
#line 110
  if (ex == 72) {
#line 110
    goto case_72;
  }
#line 112
  if (ex == 73) {
#line 112
    goto case_73;
  }
#line 114
  if (ex == 74) {
#line 114
    goto case_74;
  }
#line 116
  if (ex == 75) {
#line 116
    goto case_75;
  }
#line 118
  if (ex == 76) {
#line 118
    goto case_76;
  }
#line 120
  if (ex == 77) {
#line 120
    goto case_77;
  }
#line 122
  if (ex == 78) {
#line 122
    goto case_78;
  }
#line 124
  goto switch_default;
  case_64: /* CIL Label */ 
#line 95
  return ((char *)" 500 5.0.0 Command line usage error");
  case_65: /* CIL Label */ 
#line 97
  return ((char *)" 501 5.6.0 Data format error");
  case_66: /* CIL Label */ 
#line 99
  return ((char *)":550 5.3.0 Cannot open input");
  case_67: /* CIL Label */ 
#line 101
  return ((char *)" 550 5.1.1 User unknown");
  case_68: /* CIL Label */ 
#line 103
  return ((char *)" 550 5.1.2 Host unknown");
  case_69: /* CIL Label */ 
#line 105
  return ((char *)" 554 5.0.0 Service unavailable");
  case_70: /* CIL Label */ 
#line 107
  return ((char *)":554 5.3.0 Internal error");
  case_71: /* CIL Label */ 
#line 109
  return ((char *)":451 4.0.0 Operating system error");
  case_72: /* CIL Label */ 
#line 111
  return ((char *)":554 5.3.5 System file missing");
  case_73: /* CIL Label */ 
#line 113
  return ((char *)":550 5.0.0 Can\'t create output");
  case_74: /* CIL Label */ 
#line 115
  return ((char *)":451 4.0.0 I/O error");
  case_75: /* CIL Label */ 
#line 117
  return ((char *)" 450 4.0.0 Deferred");
  case_76: /* CIL Label */ 
#line 119
  return ((char *)" 554 5.5.0 Remote protocol error");
  case_77: /* CIL Label */ 
#line 121
  return ((char *)":550 5.0.0 Insufficient permission");
  case_78: /* CIL Label */ 
#line 123
  return ((char *)" 554 5.3.5 Local configuration error");
  switch_default: /* CIL Label */ 
#line 125
  return ((char *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 32 "../../include/sm/string.h"
char *sm_strdup(char *s ) ;
#line 35
char *sm_strndup_x(char const   *s , size_t n ) ;
#line 44
char *sm_pstrdup_x(char const   *s ) ;
#line 47
char *sm_strdup_tagged_x(char const   *s , char *file , int line , int group ) ;
#line 33 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strdup.c"
char *sm_strndup_x(char const   *s , size_t n ) 
{ 
  char *d ;
  void *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 38
  tmp = sm_malloc_tagged_x(n + 1U, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strdup.c",
                           38, SmHeapGroup);
#line 38
  d = (char *)tmp;
#line 40
  memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)s, n);
#line 41
  *(d + n) = (char )'\000';
  }
#line 42
  return (d);
}
}
#line 60 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strdup.c"
char *sm_strdup(char *s ) 
{ 
  size_t l ;
  char *d ;
  size_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 67
  tmp = strlen((char const   *)s);
#line 67
  l = tmp + 1U;
#line 68
  tmp___0 = sm_malloc_tagged(l, (char *)"sm_strdup", 0, SmHeapGroup);
#line 68
  d = (char *)tmp___0;
  }
#line 69
  if ((unsigned long )d != (unsigned long )((void *)0)) {
    {
#line 70
    sm_strlcpy(d, (char const   *)s, (ssize_t )l);
    }
  }
#line 71
  return (d);
}
}
#line 91 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strdup.c"
char *sm_strdup_x(char const   *s ) 
{ 
  size_t l ;
  char *d ;
  size_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 98
  tmp = strlen(s);
#line 98
  l = tmp + 1U;
#line 99
  tmp___0 = sm_malloc_tagged_x(l, (char *)"sm_strdup_x", 0, SmHeapGroup);
#line 99
  d = (char *)tmp___0;
#line 100
  sm_strlcpy(d, s, (ssize_t )l);
  }
#line 101
  return (d);
}
}
#line 119 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strdup.c"
char *sm_pstrdup_x(char const   *s ) 
{ 
  size_t l ;
  char *d ;
  size_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 126
  tmp = strlen(s);
#line 126
  l = tmp + 1U;
#line 127
  tmp___0 = sm_malloc_tagged_x(l, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strdup.c",
                               127, 0);
#line 127
  d = (char *)tmp___0;
#line 128
  sm_strlcpy(d, s, (ssize_t )l);
  }
#line 129
  return (d);
}
}
#line 150 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strdup.c"
char *sm_strdup_tagged_x(char const   *s , char *file , int line , int group ) 
{ 
  size_t l ;
  char *d ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 159
  tmp = strlen(s);
#line 159
  l = tmp + 1U;
#line 160
  tmp___0 = sm_malloc_tagged_x(l, file, line, group);
#line 160
  d = (char *)tmp___0;
#line 161
  sm_strlcpy(d, s, (ssize_t )l);
  }
#line 162
  return (d);
}
}
#line 98 "../../include/sm/string.h"
int sm_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 101
int sm_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 33 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strcasecmp.c"
unsigned char const   charmap[256]  = 
#line 33 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strcasecmp.c"
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )97,      (unsigned char const   )98,      (unsigned char const   )99, 
        (unsigned char const   )100,      (unsigned char const   )101,      (unsigned char const   )102,      (unsigned char const   )103, 
        (unsigned char const   )104,      (unsigned char const   )105,      (unsigned char const   )106,      (unsigned char const   )107, 
        (unsigned char const   )108,      (unsigned char const   )109,      (unsigned char const   )110,      (unsigned char const   )111, 
        (unsigned char const   )112,      (unsigned char const   )113,      (unsigned char const   )114,      (unsigned char const   )115, 
        (unsigned char const   )116,      (unsigned char const   )117,      (unsigned char const   )118,      (unsigned char const   )119, 
        (unsigned char const   )120,      (unsigned char const   )121,      (unsigned char const   )122,      (unsigned char const   )91, 
        (unsigned char const   )92,      (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95, 
        (unsigned char const   )96,      (unsigned char const   )97,      (unsigned char const   )98,      (unsigned char const   )99, 
        (unsigned char const   )100,      (unsigned char const   )101,      (unsigned char const   )102,      (unsigned char const   )103, 
        (unsigned char const   )104,      (unsigned char const   )105,      (unsigned char const   )106,      (unsigned char const   )107, 
        (unsigned char const   )108,      (unsigned char const   )109,      (unsigned char const   )110,      (unsigned char const   )111, 
        (unsigned char const   )112,      (unsigned char const   )113,      (unsigned char const   )114,      (unsigned char const   )115, 
        (unsigned char const   )116,      (unsigned char const   )117,      (unsigned char const   )118,      (unsigned char const   )119, 
        (unsigned char const   )120,      (unsigned char const   )121,      (unsigned char const   )122,      (unsigned char const   )123, 
        (unsigned char const   )124,      (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127, 
        (unsigned char const   )128,      (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131, 
        (unsigned char const   )132,      (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135, 
        (unsigned char const   )136,      (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139, 
        (unsigned char const   )140,      (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143, 
        (unsigned char const   )144,      (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147, 
        (unsigned char const   )148,      (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151, 
        (unsigned char const   )152,      (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163, 
        (unsigned char const   )164,      (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167, 
        (unsigned char const   )168,      (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171, 
        (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187, 
        (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195, 
        (unsigned char const   )196,      (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199, 
        (unsigned char const   )200,      (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203, 
        (unsigned char const   )204,      (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207, 
        (unsigned char const   )208,      (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211, 
        (unsigned char const   )212,      (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215, 
        (unsigned char const   )216,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
#line 69 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strcasecmp.c"
int sm_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  unsigned char const   *us1 ;
  unsigned char const   *us2 ;

  {
#line 73
  us1 = (unsigned char const   *)s1;
#line 74
  us2 = (unsigned char const   *)s2;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((int const   )charmap[*us1] == (int const   )charmap[*us2])) {
#line 76
      goto while_break;
    }
#line 78
    if ((int const   )*us1 == 0) {
#line 79
      return (0);
    }
#line 80
    us1 ++;
#line 81
    us2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return ((int )((int const   )charmap[*us1] - (int const   )charmap[*us2]));
}
}
#line 86 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/strcasecmp.c"
int sm_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *cm ;
  register unsigned char const   *us1 ;
  register unsigned char const   *us2 ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;

  {
#line 91
  if (n != 0U) {
#line 93
    cm = charmap;
#line 94
    us1 = (unsigned char const   *)s1;
#line 95
    us2 = (unsigned char const   *)s2;
    {
#line 97
    while (1) {
      while_continue: /* CIL Label */ ;
#line 99
      tmp = us2;
#line 99
      us2 ++;
#line 99
      if ((int const   )*(cm + *us1) != (int const   )*(cm + *tmp)) {
#line 100
        us2 --;
#line 100
        return ((int )((int const   )*(cm + *us1) - (int const   )*(cm + *us2)));
      }
#line 101
      tmp___0 = us1;
#line 101
      us1 ++;
#line 101
      if ((int const   )*tmp___0 == 0) {
#line 102
        goto while_break;
      }
#line 97
      n --;
#line 97
      if (! (n != 0U)) {
#line 97
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 105
  return (0);
}
}
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 305
extern int close(int __fd ) ;
#line 312
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 318
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 63 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 72
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 207 "/usr/include/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                                                            struct stat * __restrict  __statbuf ) ;
#line 212
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 235
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __path ,
                                                                                             struct stat * __restrict  __statbuf ) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 324
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
#line 326
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
#line 328
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
#line 357
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
#line 363
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                                                            struct stat * __restrict  __statbuf ) ;
#line 363 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 366
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 366
  return (tmp);
}
}
#line 370
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __path ,
                                                                                             struct stat * __restrict  __statbuf ) ;
#line 370 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __path ,
                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 373
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 373
  return (tmp);
}
}
#line 377
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 377 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 380
  tmp = __fxstat(3, __fd, __statbuf);
  }
#line 380
  return (tmp);
}
}
#line 384
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 384 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                             __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 387
  tmp = __xmknod(1, __path, __mode, & __dev);
  }
#line 387
  return (tmp);
}
}
#line 153 "../../include/sm/io.h"
SM_FILE_T SmFtStdio_def ;
#line 308
SM_FILE_T *sm_io_fopen(char *pathname , int flags  , ...) ;
#line 39 "../../include/sm/assert.h"
 __attribute__((__noreturn__)) void sm_abort(char *fmt  , ...) ;
#line 38 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/local.h"
SM_FILE_T *sm_fp(SM_FILE_T const   *t , int const   flags , SM_FILE_T *oldfp ) ;
#line 42
ssize_t sm_stdread(SM_FILE_T *fp , char *buf___16 , size_t n ) ;
#line 43
ssize_t sm_stdwrite(SM_FILE_T *fp , char const   *buf___16 , size_t n ) ;
#line 44
off_t sm_stdseek(SM_FILE_T *fp , off_t offset , int whence ) ;
#line 45
int sm_stdclose(SM_FILE_T *fp ) ;
#line 46
int sm_stdopen(SM_FILE_T *fp , void const   *info , int flags , void const   *rpool ) ;
#line 47
int sm_stdfdopen(SM_FILE_T *fp , void const   *info , int flags , void const   *rpool ) ;
#line 48
int sm_stdsetinfo(SM_FILE_T *fp , int what , void *valp ) ;
#line 49
int sm_stdgetinfo(SM_FILE_T *fp , int what , void *valp ) ;
#line 32 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stdio.c"
static int sm_stdsetmode(SM_FILE_T *fp , int const   *mode ) ;
#line 33
static int sm_stdgetmode(SM_FILE_T *fp , int *mode ) ;
#line 59 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stdio.c"
int sm_stdopen(SM_FILE_T *fp , void const   *info , int flags , void const   *rpool ) 
{ 
  char *path ;
  int oflags ;
  int *tmp ;
  int tmp___0 ;

  {
#line 66
  path = (char *)info;
  {
#line 71
  if ((flags & 15) == 1) {
#line 71
    goto case_1;
  }
#line 74
  if ((flags & 15) == 6) {
#line 74
    goto case_6;
  }
#line 77
  if ((flags & 15) == 2) {
#line 77
    goto case_2;
  }
#line 80
  if ((flags & 15) == 3) {
#line 80
    goto case_3;
  }
#line 83
  if ((flags & 15) == 4) {
#line 83
    goto case_4;
  }
#line 86
  if ((flags & 15) == 5) {
#line 86
    goto case_5;
  }
#line 89
  goto switch_default;
  case_1: /* CIL Label */ 
#line 72
  oflags = 2;
#line 73
  goto switch_break;
  case_6: /* CIL Label */ 
#line 75
  oflags = 578;
#line 76
  goto switch_break;
  case_2: /* CIL Label */ 
#line 78
  oflags = 0;
#line 79
  goto switch_break;
  case_3: /* CIL Label */ 
#line 81
  oflags = 577;
#line 82
  goto switch_break;
  case_4: /* CIL Label */ 
#line 84
  oflags = 1089;
#line 85
  goto switch_break;
  case_5: /* CIL Label */ 
#line 87
  oflags = 1090;
#line 88
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 90
  tmp = __errno_location();
#line 90
  *tmp = 22;
  }
#line 91
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 97
  tmp___0 = open((char const   *)path, oflags, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 97
  fp->f_file = (short )tmp___0;
  }
#line 99
  if ((int )fp->f_file < 0) {
#line 100
    return (-1);
  }
#line 102
  if (oflags & 1024) {
    {
#line 103
    (*(fp->f_seek))((SM_FILE_T *)((void *)fp), (off_t )0, 2);
    }
  }
#line 105
  return ((int )fp->f_file);
}
}
#line 124 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stdio.c"
ssize_t sm_stdread(SM_FILE_T *fp , char *buf___16 , size_t n ) 
{ 
  register int ret ;

  {
  {
#line 132
  ret = read((int )fp->f_file, (void *)buf___16, n);
  }
#line 135
  if (ret > 0) {
#line 136
    fp->f_lseekoff += (off_t )ret;
  }
#line 137
  return (ret);
}
}
#line 153 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stdio.c"
ssize_t sm_stdwrite(SM_FILE_T *fp , char const   *buf___16 , size_t n ) 
{ 
  ssize_t tmp ;

  {
  {
#line 159
  tmp = write((int )fp->f_file, (void const   *)buf___16, n);
  }
#line 159
  return (tmp);
}
}
#line 178 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stdio.c"
off_t sm_stdseek(SM_FILE_T *fp , off_t offset , int whence ) 
{ 
  register off_t ret ;

  {
  {
#line 186
  ret = lseek((int )fp->f_file, offset, whence);
  }
#line 187
  if (ret != -1L) {
#line 188
    fp->f_lseekoff = ret;
  }
#line 189
  return (ret);
}
}
#line 203 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stdio.c"
int sm_stdclose(SM_FILE_T *fp ) 
{ 
  int tmp ;

  {
  {
#line 207
  tmp = close((int )fp->f_file);
  }
#line 207
  return (tmp);
}
}
#line 224 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stdio.c"
static int sm_stdsetmode(SM_FILE_T *fp , int const   *mode ) 
{ 
  int flags ;
  int *tmp ;

  {
#line 229
  flags = 0;
  {
#line 233
  if ((*mode & 15) == 1) {
#line 233
    goto case_1;
  }
#line 236
  if ((*mode & 15) == 2) {
#line 236
    goto case_2;
  }
#line 239
  if ((*mode & 15) == 3) {
#line 239
    goto case_3;
  }
#line 243
  goto switch_default;
  case_1: /* CIL Label */ 
#line 234
  flags |= 64;
#line 235
  goto switch_break;
  case_2: /* CIL Label */ 
#line 237
  flags |= 16;
#line 238
  goto switch_break;
  case_3: /* CIL Label */ 
#line 240
  flags |= 32;
#line 241
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 244
  tmp = __errno_location();
#line 244
  *tmp = 22;
  }
#line 245
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 247
  fp->f_flags &= -113L;
#line 248
  fp->f_flags |= (long )flags;
#line 249
  return (0);
}
}
#line 266 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stdio.c"
static int sm_stdgetmode(SM_FILE_T *fp , int *mode ) 
{ 
  int *tmp ;

  {
  {
#line 273
  if ((fp->f_flags & 112L) == 64L) {
#line 273
    goto case_64;
  }
#line 276
  if ((fp->f_flags & 112L) == 16L) {
#line 276
    goto case_16;
  }
#line 279
  if ((fp->f_flags & 112L) == 32L) {
#line 279
    goto case_32;
  }
#line 282
  goto switch_default;
  case_64: /* CIL Label */ 
#line 274
  *mode = 1;
#line 275
  goto switch_break;
  case_16: /* CIL Label */ 
#line 277
  *mode = 2;
#line 278
  goto switch_break;
  case_32: /* CIL Label */ 
#line 280
  *mode = 3;
#line 281
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 283
  tmp = __errno_location();
#line 283
  *tmp = 22;
  }
#line 284
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 286
  return (0);
}
}
#line 302 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stdio.c"
int sm_stdsetinfo(SM_FILE_T *fp , int what , void *valp ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 310
  if (what == 1) {
#line 310
    goto case_1;
  }
#line 313
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 311
  tmp = sm_stdsetmode(fp, (int const   *)valp);
  }
#line 311
  return (tmp);
  switch_default: /* CIL Label */ 
  {
#line 314
  tmp___0 = __errno_location();
#line 314
  *tmp___0 = 22;
  }
#line 315
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 334 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stdio.c"
int sm_stdgetinfo(SM_FILE_T *fp , int what , void *valp ) 
{ 
  int tmp ;
  struct stat st ;
  int tmp___0 ;
  fd_set readfds ;
  struct timeval timeout ;
  int *tmp___1 ;
  int __d0 ;
  int __d1 ;
  int tmp___2 ;
  register char __result ;
  int *tmp___3 ;

  {
  {
#line 342
  if (what == 1) {
#line 342
    goto case_1;
  }
#line 345
  if (what == 3) {
#line 345
    goto case_3;
  }
#line 348
  if (what == 8) {
#line 348
    goto case_8;
  }
#line 358
  if (what == 6) {
#line 358
    goto case_6;
  }
#line 379
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 343
  tmp = sm_stdgetmode(fp, (int *)valp);
  }
#line 343
  return (tmp);
  case_3: /* CIL Label */ 
#line 346
  return ((int )fp->f_file);
  case_8: /* CIL Label */ 
  {
#line 352
  tmp___0 = fstat((int )fp->f_file, & st);
  }
#line 352
  if (tmp___0 == 0) {
#line 353
    return ((int )st.st_size);
  } else {
#line 355
    return (-1);
  }
  case_6: /* CIL Label */ 
#line 363
  if ((int )fp->f_file >= 1024) {
    {
#line 365
    tmp___1 = __errno_location();
#line 365
    *tmp___1 = 22;
    }
#line 366
    return (-1);
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds.__fds_bits[0]): "memory");
#line 368
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 369
  __asm__  volatile   ("btsl %1,%0": "=m" (readfds.__fds_bits[(unsigned long )fp->f_file / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )((int )fp->f_file) % (8UL * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 370
  timeout.tv_sec = (__time_t )0;
#line 371
  timeout.tv_usec = (__suseconds_t )0;
#line 372
  tmp___2 = select((int )fp->f_file + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
  }
#line 374
  if (tmp___2 > 0) {
#line 374
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned long )((int )fp->f_file) % (8UL * sizeof(__fd_mask ))),
                         "m" (readfds.__fds_bits[(unsigned long )fp->f_file / (8UL * sizeof(__fd_mask ))]): "cc");
#line 374
    if (__result) {
#line 375
      return (1);
    }
  }
#line 376
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 380
  tmp___3 = __errno_location();
#line 380
  *tmp___3 = 22;
  }
#line 381
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 403 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stdio.c"
int sm_stdfdopen(SM_FILE_T *fp , void const   *info , int flags , void const   *rpool ) 
{ 
  int oflags ;
  int tmp ;
  int fdflags ;
  int fd ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 410
  fd = *((int *)info);
  {
#line 414
  if ((flags & 15) == 1) {
#line 414
    goto case_1;
  }
#line 417
  if ((flags & 15) == 2) {
#line 417
    goto case_2;
  }
#line 420
  if ((flags & 15) == 3) {
#line 420
    goto case_3;
  }
#line 423
  if ((flags & 15) == 4) {
#line 423
    goto case_4;
  }
#line 426
  if ((flags & 15) == 5) {
#line 426
    goto case_5;
  }
#line 429
  goto switch_default;
  case_1: /* CIL Label */ 
#line 415
  oflags = 66;
#line 416
  goto switch_break;
  case_2: /* CIL Label */ 
#line 418
  oflags = 0;
#line 419
  goto switch_break;
  case_3: /* CIL Label */ 
#line 421
  oflags = 577;
#line 422
  goto switch_break;
  case_4: /* CIL Label */ 
#line 424
  oflags = 1089;
#line 425
  goto switch_break;
  case_5: /* CIL Label */ 
#line 427
  oflags = 1090;
#line 428
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 430
  tmp___0 = __errno_location();
#line 430
  *tmp___0 = 22;
  }
#line 431
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 439
  fdflags = fcntl(fd, 3, 0);
  }
#line 439
  if (fdflags < 0) {
#line 440
    return (-1);
  }
#line 441
  tmp = fdflags & 3;
#line 442
  if (tmp != 2) {
#line 442
    if (tmp != (oflags & 3)) {
      {
#line 444
      tmp___1 = __errno_location();
#line 444
      *tmp___1 = 22;
      }
#line 445
      return (-1);
    }
  }
#line 447
  fp->f_file = (short )fd;
#line 448
  if (oflags & 1024) {
    {
#line 449
    (*(fp->f_seek))(fp, (off_t )0, 2);
    }
  }
#line 450
  return ((int )fp->f_file);
}
}
#line 470 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/stdio.c"
SM_FILE_T *sm_io_fopen(char *pathname , int flags  , ...) 
{ 
  mode_t mode ;
  SM_FILE_T *fp ;
  int ioflags ;
  va_list ap ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;

  {
#line 484
  if (flags & 64) {
    {
#line 488
    __builtin_va_start(ap, flags);
#line 489
    tmp___0 = __builtin_va_arg(ap, int );
#line 489
    mode = (mode_t )tmp___0;
#line 490
    __builtin_va_end(ap);
    }
  } else {
#line 493
    mode = (mode_t )0;
  }
  {
#line 497
  if ((flags & 3) == 0) {
#line 497
    goto case_0;
  }
#line 500
  if ((flags & 3) == 1) {
#line 500
    goto case_1;
  }
#line 503
  if ((flags & 3) == 2) {
#line 503
    goto case_2;
  }
#line 506
  goto switch_default;
  case_0: /* CIL Label */ 
#line 498
  ioflags = 16;
#line 499
  goto switch_break;
  case_1: /* CIL Label */ 
#line 501
  ioflags = 32;
#line 502
  goto switch_break;
  case_2: /* CIL Label */ 
#line 504
  ioflags = 64;
#line 505
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 507
  sm_abort((char *)"sm_io_fopen: bad flags 0%o", flags);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 510
  fp = sm_fp((SM_FILE_T const   *)(& SmFtStdio_def), (int const   )ioflags, (SM_FILE_T *)((void *)0));
#line 511
  tmp___1 = open((char const   *)pathname, flags, mode);
#line 511
  fp->f_file = (short )tmp___1;
  }
#line 512
  if ((int )fp->f_file == -1) {
#line 514
    fp->f_flags = 0L;
#line 515
    fp->sm_magic = (char const   *)((void *)0);
#line 516
    return ((SM_FILE_T *)((void *)0));
  }
#line 518
  return (fp);
}
}
#line 298 "../../include/sm/io.h"
int sm_io_sscanf(char const   *str , char const   *fmt  , ...) ;
#line 34 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/sscanf.c"
static ssize_t sm_eofread(SM_FILE_T *fp , char *buf___16 , size_t len___0 ) ;
#line 41 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/sscanf.c"
static ssize_t sm_eofread(SM_FILE_T *fp , char *buf___16 , size_t len___0 ) 
{ 


  {
#line 47
  return (0);
}
}
#line 68 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/sscanf.c"
int sm_io_sscanf(char const   *str , char const   *fmt  , ...) 
{ 
  int ret ;
  SM_FILE_T fake ;
  va_list ap ;
  size_t tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 82
  fake.sm_magic = SmFileMagic;
#line 83
  fake.f_flags = 16L;
#line 84
  fake.f_p = (unsigned char *)str;
#line 84
  fake.f_bf.smb_base = fake.f_p;
#line 85
  tmp = strlen(str);
#line 85
  fake.f_r = (int )tmp;
#line 85
  fake.f_bf.smb_size = fake.f_r;
#line 86
  fake.f_file = (short)-1;
#line 87
  fake.f_read = & sm_eofread;
#line 88
  fake.f_write = (ssize_t (*)(SM_FILE_T * , char const   * , size_t  ))((void *)0);
#line 89
  fake.f_close = (int (*)(SM_FILE_T * ))((void *)0);
#line 90
  fake.f_open = (int (*)(SM_FILE_T * , void const   * , int  , void const   * ))((void *)0);
#line 91
  fake.f_seek = (off_t (*)(SM_FILE_T * , off_t  , int  ))((void *)0);
#line 92
  fake.f_getinfo = (int (*)(SM_FILE_T * , int  , void * ))((void *)0);
#line 92
  fake.f_setinfo = fake.f_getinfo;
#line 93
  fake.f_type = (char *)"sm_io_sscanf:fake";
#line 94
  fake.f_flushfp = (struct sm_file *)((void *)0);
#line 95
  fake.f_ub.smb_base = (unsigned char *)((void *)0);
#line 96
  fake.f_timeout = -1;
#line 97
  fake.f_timeoutstate = 0;
#line 98
  __builtin_va_start(ap, fmt);
#line 99
  ret = sm_vfscanf(& fake, -1, fmt, ap);
#line 100
  __builtin_va_end(ap);
  }
#line 101
  return (ret);
}
}
#line 45 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/snprintf.c"
int sm_snprintf(char *str , size_t n , char const   *fmt  , ...) 
{ 
  int ret ;
  va_list ap ;
  SM_FILE_T fake ;
  char *__cil_tmp7 ;

  {
#line 61
  if (n > 2147483647U) {
#line 62
    n = (size_t )2147483647;
  }
  {
#line 63
  __builtin_va_start(ap, fmt);
#line 66
  fake.sm_magic = SmFileMagic;
#line 67
  fake.f_file = (short)-1;
#line 68
  fake.f_flags = 2080L;
#line 69
  fake.f_cookie = (void *)(& fake);
#line 70
  fake.f_p = (unsigned char *)str;
#line 70
  fake.f_bf.smb_base = fake.f_p;
  }
#line 71
  if (n) {
#line 71
    fake.f_w = (int )(n - 1U);
  } else {
#line 71
    fake.f_w = 0;
  }
  {
#line 71
  fake.f_bf.smb_size = fake.f_w;
#line 72
  fake.f_timeout = -1;
#line 73
  fake.f_timeoutstate = 0;
#line 74
  fake.f_close = (int (*)(SM_FILE_T * ))((void *)0);
#line 75
  fake.f_open = (int (*)(SM_FILE_T * , void const   * , int  , void const   * ))((void *)0);
#line 76
  fake.f_read = (ssize_t (*)(SM_FILE_T * , char * , size_t  ))((void *)0);
#line 77
  fake.f_write = (ssize_t (*)(SM_FILE_T * , char const   * , size_t  ))((void *)0);
#line 78
  fake.f_seek = (off_t (*)(SM_FILE_T * , off_t  , int  ))((void *)0);
#line 79
  fake.f_getinfo = (int (*)(SM_FILE_T * , int  , void * ))((void *)0);
#line 79
  fake.f_setinfo = fake.f_getinfo;
#line 80
  fake.f_type = (char *)"sm_snprintf:fake";
#line 81
  ret = sm_io_vfprintf(& fake, -1, fmt, ap);
  }
#line 82
  if (n > 0U) {
#line 83
    *(fake.f_p) = (unsigned char )'\000';
  }
  {
#line 84
  __builtin_va_end(ap);
  }
#line 85
  return (ret);
}
}
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 206
extern int fclose(FILE *__stream ) ;
#line 241
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 603
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 609
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 643
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 752
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 157 "../../include/sm/io.h"
SM_FILE_T SmFtRealStdio_def ;
#line 314
SM_FILE_T *sm_io_stdioopen(FILE *stream , char *mode ) ;
#line 167 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 52 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/local.h"
ssize_t sm_stdioread(SM_FILE_T *fp , char *buf___16 , size_t n ) ;
#line 53
ssize_t sm_stdiowrite(SM_FILE_T *fp , char const   *buf___16 , size_t n ) ;
#line 54
off_t sm_stdioseek(SM_FILE_T *fp , off_t offset , int whence ) ;
#line 55
int sm_stdioclose(SM_FILE_T *fp ) ;
#line 56
int sm_stdioopen(SM_FILE_T *fp , void const   *info , int flags , void const   *rpool ) ;
#line 57
int sm_stdiosetinfo(SM_FILE_T *fp , int what , void *valp ) ;
#line 58
int sm_stdiogetinfo(SM_FILE_T *fp , int what , void *valp ) ;
#line 22 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/smstdio.c"
static void setup(SM_FILE_T *fp ) ;
#line 49 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/smstdio.c"
int sm_stdioopen(SM_FILE_T *fp , void const   *info , int flags , void const   *rpool ) 
{ 
  register FILE *s ;
  char *stdiomode ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 61
  if (flags == 2) {
#line 61
    goto case_2;
  }
#line 64
  if (flags == 3) {
#line 64
    goto case_3;
  }
#line 67
  if (flags == 4) {
#line 67
    goto case_4;
  }
#line 70
  if (flags == 5) {
#line 70
    goto case_5;
  }
#line 91
  goto switch_default;
  case_2: /* CIL Label */ 
#line 62
  stdiomode = (char *)"r";
#line 63
  goto switch_break;
  case_3: /* CIL Label */ 
#line 65
  stdiomode = (char *)"w";
#line 66
  goto switch_break;
  case_4: /* CIL Label */ 
#line 68
  stdiomode = (char *)"a";
#line 69
  goto switch_break;
  case_5: /* CIL Label */ 
#line 71
  stdiomode = (char *)"a+";
#line 72
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 92
  stdiomode = (char *)"r+";
#line 93
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 96
  s = fopen((char const   */* __restrict  */)((char *)info), (char const   */* __restrict  */)stdiomode);
  }
#line 96
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 97
    return (-1);
  }
#line 98
  fp->f_cookie = (void *)s;
#line 99
  return (0);
}
}
#line 112 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/smstdio.c"
static void setup(SM_FILE_T *fp ) 
{ 
  char *__cil_tmp2 ;

  {
#line 116
  if ((unsigned long )fp->f_cookie == (unsigned long )((void *)0)) {
    {
#line 120
    if (fp->f_ival == 0) {
#line 120
      goto case_0;
    }
#line 123
    if (fp->f_ival == 1) {
#line 123
      goto case_1;
    }
#line 126
    if (fp->f_ival == 2) {
#line 126
      goto case_2;
    }
#line 129
    goto switch_default;
    case_0: /* CIL Label */ 
#line 121
    fp->f_cookie = (void *)stdin;
#line 122
    goto switch_break;
    case_1: /* CIL Label */ 
#line 124
    fp->f_cookie = (void *)stdout;
#line 125
    goto switch_break;
    case_2: /* CIL Label */ 
#line 127
    fp->f_cookie = (void *)stderr;
#line 128
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 130
    sm_abort((char *)"fp->f_ival=%d: out of range (0...2)", fp->f_ival);
    }
#line 131
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 134
  return;
}
}
#line 148 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/smstdio.c"
ssize_t sm_stdioread(SM_FILE_T *fp , char *buf___16 , size_t n ) 
{ 
  register FILE *s ;
  size_t tmp ;

  {
#line 156
  if ((unsigned long )fp->f_cookie == (unsigned long )((void *)0)) {
    {
#line 157
    setup(fp);
    }
  }
  {
#line 158
  s = (FILE *)fp->f_cookie;
#line 159
  tmp = fread((void */* __restrict  */)buf___16, (size_t )1, n, (FILE */* __restrict  */)s);
  }
#line 159
  return ((ssize_t )tmp);
}
}
#line 174 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/smstdio.c"
ssize_t sm_stdiowrite(SM_FILE_T *fp , char const   *buf___16 , size_t n ) 
{ 
  register FILE *s ;
  size_t tmp ;

  {
#line 182
  if ((unsigned long )fp->f_cookie == (unsigned long )((void *)0)) {
    {
#line 183
    setup(fp);
    }
  }
  {
#line 184
  s = (FILE *)fp->f_cookie;
#line 185
  tmp = fwrite((void const   */* __restrict  */)buf___16, (size_t )1, n, (FILE */* __restrict  */)s);
  }
#line 185
  return ((ssize_t )tmp);
}
}
#line 200 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/smstdio.c"
off_t sm_stdioseek(SM_FILE_T *fp , off_t offset , int whence ) 
{ 
  register FILE *s ;
  int tmp ;

  {
#line 208
  if ((unsigned long )fp->f_cookie == (unsigned long )((void *)0)) {
    {
#line 209
    setup(fp);
    }
  }
  {
#line 210
  s = (FILE *)fp->f_cookie;
#line 211
  tmp = fseek(s, offset, whence);
  }
#line 211
  return ((off_t )tmp);
}
}
#line 224 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/smstdio.c"
int sm_stdioclose(SM_FILE_T *fp ) 
{ 
  register FILE *s ;
  int tmp ;

  {
#line 230
  if ((unsigned long )fp->f_cookie == (unsigned long )((void *)0)) {
    {
#line 231
    setup(fp);
    }
  }
  {
#line 232
  s = (FILE *)fp->f_cookie;
#line 233
  tmp = fclose(s);
  }
#line 233
  return (tmp);
}
}
#line 250 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/smstdio.c"
int sm_stdiosetinfo(SM_FILE_T *fp , int what , void *valp ) 
{ 
  int *tmp ;

  {
  {
#line 259
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 260
  tmp = __errno_location();
#line 260
  *tmp = 22;
  }
#line 261
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 279 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/smstdio.c"
int sm_stdiogetinfo(SM_FILE_T *fp , int what , void *valp ) 
{ 
  int fd ;
  struct stat st ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 287
  if (what == 8) {
#line 287
    goto case_8;
  }
#line 304
  goto switch_default;
  case_8: /* CIL Label */ 
#line 292
  if ((unsigned long )fp->f_cookie == (unsigned long )((void *)0)) {
    {
#line 293
    setup(fp);
    }
  }
  {
#line 294
  fd = fileno((FILE *)fp->f_cookie);
  }
#line 295
  if (fd < 0) {
#line 296
    return (-1);
  }
  {
#line 297
  tmp = fstat(fd, & st);
  }
#line 297
  if (tmp == 0) {
#line 298
    return ((int )st.st_size);
  } else {
#line 300
    return (-1);
  }
  switch_default: /* CIL Label */ 
  {
#line 305
  tmp___0 = __errno_location();
#line 305
  *tmp___0 = 22;
  }
#line 306
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 324 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/smstdio.c"
SM_FILE_T *sm_io_stdioopen(FILE *stream , char *mode ) 
{ 
  int fd ;
  bool r ;
  bool w ;
  int ioflags ;
  SM_FILE_T *fp ;
  int tmp ;
  char *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 334
  fd = fileno(stream);
  }
#line 335
  if (fd >= 0) {
#line 335
    tmp = 1;
  } else {
    {
#line 335
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/smstdio.c",
                335, "SM_REQUIRE(fd >= 0) failed");
#line 335
    tmp = 0;
    }
  }
#line 337
  w = 0;
#line 337
  r = w;
  {
#line 340
  if ((int )*(mode + 0) == 114) {
#line 340
    goto case_114;
  }
#line 344
  if ((int )*(mode + 0) == 97) {
#line 344
    goto case_97;
  }
#line 344
  if ((int )*(mode + 0) == 119) {
#line 344
    goto case_97;
  }
#line 347
  goto switch_default;
  case_114: /* CIL Label */ 
#line 341
  r = 1;
#line 342
  goto switch_break;
  case_97: /* CIL Label */ 
  case_119: /* CIL Label */ 
#line 345
  w = 1;
#line 346
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 348
  sm_abort((char *)"sm_io_stdioopen: mode \'%s\' is bad", mode);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 350
  tmp___0 = strchr((char const   *)(mode + 1), '+');
  }
#line 350
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 351
    w = 1;
#line 351
    r = w;
  }
#line 352
  if (r) {
#line 352
    if (w) {
#line 353
      ioflags = 64;
    } else {
#line 352
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 354
  if (r) {
#line 355
    ioflags = 16;
  } else {
#line 357
    ioflags = 32;
  }
  {
#line 359
  fp = sm_fp((SM_FILE_T const   *)(& SmFtRealStdio_def), (int const   )ioflags, (SM_FILE_T *)((void *)0));
#line 360
  fp->f_file = (short )fd;
#line 361
  fp->f_cookie = (void *)stream;
  }
#line 362
  return (fp);
}
}
#line 622 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 378 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 222
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 228
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigismember)(sigset_t const   *__set ,
                                                                                        int __signo ) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 59 "../../include/sm/signal.h"
unsigned int volatile   InCriticalSection  ;
#line 60 "../../include/sm/signal.h"
int volatile   PendingSignal  ;
#line 63
void pend_signal(int sig ) ;
#line 76
void sm_allsignals(bool block ) ;
#line 77
int sm_blocksignal(int sig ) ;
#line 78
int sm_releasesignal(int sig ) ;
#line 79
sigfunc_t sm_signal(int sig , void (*handler)(int  ) ) ;
#line 80
void sm_signal_noop(int sig ) ;
#line 57 "../../include/sm/clock.h"
void sm_tick(int sig ) ;
#line 38 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/signal.c"
sigfunc_t sm_signal(int sig , void (*handler)(int  ) ) 
{ 
  struct sigaction n ;
  struct sigaction o ;
  int tmp ;

  {
  {
#line 53
  memset((void *)(& n), '\000', (size_t )sizeof(n));
#line 58
  n.__sigaction_handler.sa_handler = handler;
#line 59
  n.sa_flags = 268435456;
#line 61
  tmp = sigaction(sig, (struct sigaction  const  */* __restrict  */)(& n), (struct sigaction */* __restrict  */)(& o));
  }
#line 61
  if (tmp < 0) {
#line 62
    return ((void (*)(int  ))-1);
  }
#line 63
  return (o.__sigaction_handler.sa_handler);
}
}
#line 104 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/signal.c"
int sm_blocksignal(int sig ) 
{ 
  sigset_t sset ;
  sigset_t oset ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 125
  sigemptyset(& sset);
#line 126
  sigaddset(& sset, sig);
#line 127
  tmp___0 = sigprocmask(0, (sigset_t const   */* __restrict  */)(& sset), (sigset_t */* __restrict  */)(& oset));
  }
#line 127
  if (tmp___0 < 0) {
#line 128
    return (-1);
  } else {
    {
#line 130
    tmp = sigismember((sigset_t const   *)(& oset), sig);
    }
#line 130
    return (tmp);
  }
}
}
#line 146 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/signal.c"
int sm_releasesignal(int sig ) 
{ 
  sigset_t sset ;
  sigset_t oset ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 164
  sigemptyset(& sset);
#line 165
  sigaddset(& sset, sig);
#line 166
  tmp___0 = sigprocmask(1, (sigset_t const   */* __restrict  */)(& sset), (sigset_t */* __restrict  */)(& oset));
  }
#line 166
  if (tmp___0 < 0) {
#line 167
    return (-1);
  } else {
    {
#line 169
    tmp = sigismember((sigset_t const   *)(& oset), sig);
    }
#line 169
    return (tmp);
  }
}
}
#line 187 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/signal.c"
void pend_signal(int sig ) 
{ 
  int sigbit ;
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 192
  tmp = __errno_location();
#line 192
  save_errno = *tmp;
  }
  {
#line 207
  if (sig == 1) {
#line 207
    goto case_1;
  }
#line 211
  if (sig == 2) {
#line 211
    goto case_2;
  }
#line 215
  if (sig == 15) {
#line 215
    goto case_15;
  }
#line 219
  if (sig == 10) {
#line 219
    goto case_10;
  }
#line 223
  if (sig == 14) {
#line 223
    goto case_14;
  }
#line 228
  goto switch_default;
  case_1: /* CIL Label */ 
#line 208
  sigbit = 1;
#line 209
  goto switch_break;
  case_2: /* CIL Label */ 
#line 212
  sigbit = 2;
#line 213
  goto switch_break;
  case_15: /* CIL Label */ 
#line 216
  sigbit = 4;
#line 217
  goto switch_break;
  case_10: /* CIL Label */ 
#line 220
  sigbit = 8;
#line 221
  goto switch_break;
  case_14: /* CIL Label */ 
#line 225
  sigbit = 0;
#line 226
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 230
  abort();
#line 234
  sigbit = 0;
  }
#line 235
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 238
  if (sigbit != 0) {
#line 239
    PendingSignal |= (int volatile   )sigbit;
  }
  {
#line 240
  sm_signal(14, & sm_tick);
#line 248
  alarm(1U);
#line 250
  tmp___0 = __errno_location();
#line 250
  *tmp___0 = save_errno;
  }
#line 251
  return;
}
}
#line 262 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/signal.c"
void sm_allsignals(bool block ) 
{ 
  sigset_t sset ;
  int tmp ;

  {
  {
#line 308
  sigemptyset(& sset);
#line 309
  sigaddset(& sset, 14);
#line 310
  sigaddset(& sset, 17);
#line 311
  sigaddset(& sset, 1);
#line 312
  sigaddset(& sset, 2);
#line 313
  sigaddset(& sset, 15);
#line 314
  sigaddset(& sset, 10);
  }
#line 315
  if (block) {
#line 315
    tmp = 0;
  } else {
#line 315
    tmp = 1;
  }
  {
#line 315
  sigprocmask(tmp, (sigset_t const   */* __restrict  */)(& sset), (sigset_t */* __restrict  */)((void *)0));
  }
#line 318
  return;
}
}
#line 330 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/signal.c"
void sm_signal_noop(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 334
  tmp = __errno_location();
#line 334
  save_errno = *tmp;
#line 337
  tmp___0 = __errno_location();
#line 337
  *tmp___0 = save_errno;
  }
#line 338
  return;
}
}
#line 51 "/usr/include/sys/shm.h"
extern  __attribute__((__nothrow__)) int shmctl(int __shmid , int __cmd , struct shmid_ds *__buf ) ;
#line 54
extern  __attribute__((__nothrow__)) int shmget(key_t __key , size_t __size , int __shmflg ) ;
#line 57
extern  __attribute__((__nothrow__)) void *shmat(int __shmid , void const   *__shmaddr ,
                                                 int __shmflg ) ;
#line 61
extern  __attribute__((__nothrow__)) int shmdt(void const   *__shmaddr ) ;
#line 29 "../../include/sm/shm.h"
void *sm_shmstart(key_t key , int size , int shmflg , int *shmid , bool owner ) ;
#line 30
int sm_shmstop(void *shm , int shmid , bool owner ) ;
#line 31
int sm_shmsetowner(int shmid , uid_t uid , gid_t gid , mode_t mode ) ;
#line 39 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/shm.c"
void *sm_shmstart(key_t key , int size , int shmflg , int *shmid , bool owner ) 
{ 
  int save_errno ;
  void *shm ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 48
  shm = (void *)-1;
#line 51
  if (shmflg == 0) {
#line 52
    shmflg = (384 | (256 >> 3)) | (128 >> 3);
  }
#line 53
  if (owner) {
#line 54
    shmflg |= 1536;
  }
  {
#line 55
  *shmid = shmget(key, (size_t )size, shmflg);
  }
#line 56
  if (*shmid < 0) {
#line 57
    goto error;
  }
  {
#line 59
  shm = shmat(*shmid, (void const   *)((void *)0), 0);
  }
#line 60
  if ((unsigned long )shm == (unsigned long )((void *)-1)) {
#line 61
    goto error;
  }
#line 63
  return (shm);
  error: 
  {
#line 66
  tmp = __errno_location();
#line 66
  save_errno = *tmp;
  }
#line 67
  if ((unsigned long )shm != (unsigned long )((void *)-1)) {
    {
#line 68
    sm_shmstop(shm, *shmid, owner);
    }
  } else
#line 67
  if (*shmid >= 0) {
    {
#line 68
    sm_shmstop(shm, *shmid, owner);
    }
  }
  {
#line 69
  *shmid = -2;
#line 70
  tmp___0 = __errno_location();
#line 70
  *tmp___0 = save_errno;
  }
#line 71
  return ((void *)0);
}
}
#line 92 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/shm.c"
int sm_shmstop(void *shm , int shmid , bool owner ) 
{ 
  int r ;

  {
#line 100
  if ((unsigned long )shm != (unsigned long )((void *)-1)) {
    {
#line 100
    r = shmdt((void const   *)shm);
    }
#line 100
    if (r < 0) {
#line 101
      return (r);
    }
  }
#line 102
  if (owner) {
#line 102
    if (shmid >= 0) {
      {
#line 102
      r = shmctl(shmid, 0, (struct shmid_ds *)((void *)0));
      }
#line 102
      if (r < 0) {
#line 103
        return (r);
      }
    }
  }
#line 104
  return (0);
}
}
#line 122 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/shm.c"
int sm_shmsetowner(int shmid , uid_t uid , gid_t gid , mode_t mode ) 
{ 
  int r ;
  struct shmid_ds shmid_ds ;

  {
  {
#line 132
  memset((void *)(& shmid_ds), 0, (size_t )sizeof(shmid_ds));
#line 133
  r = shmctl(shmid, 2, & shmid_ds);
  }
#line 133
  if (r < 0) {
#line 134
    return (r);
  }
  {
#line 135
  shmid_ds.shm_perm.uid = uid;
#line 136
  shmid_ds.shm_perm.gid = gid;
#line 137
  shmid_ds.shm_perm.mode = (unsigned short )mode;
#line 138
  r = shmctl(shmid, 1, & shmid_ds);
  }
#line 138
  if (r < 0) {
#line 139
    return (r);
  }
#line 140
  return (0);
}
}
#line 626 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) ;
#line 284 "../../include/sm/io.h"
int sm_io_getinfo(SM_FILE_T *fp , int what , void *valp ) ;
#line 296
int sm_io_setvbuf(SM_FILE_T *fp , int timeout , char *buf___16 , int mode , size_t size ) ;
#line 32 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/local.h"
void sm_cleanup(void) ;
#line 34
int sm_whatbuf(SM_FILE_T *fp , size_t *bufsize , int *couldbetty ) ;
#line 46 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/setvbuf.c"
int sm_io_setvbuf(SM_FILE_T *fp , int timeout , char *buf___16 , int mode , size_t size ) 
{ 
  int ret ;
  int flags ;
  size_t iosize ;
  int ttyflag ;
  int fd ;
  struct timeval to ;
  int tmp ;
  int *tmp___0 ;
  int ret___0 ;
  int tmp___1 ;
  int ret___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 60
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 60
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 60
      tmp = 1;
    } else {
      {
#line 60
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/setvbuf.c",
                  60, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 60
      tmp = 0;
      }
    }
  } else {
    {
#line 60
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/setvbuf.c",
                60, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 60
    tmp = 0;
    }
  }
#line 68
  if (mode != 2) {
#line 69
    if (mode != 0) {
#line 69
      if (mode != 1) {
#line 69
        if (mode != 3) {
#line 71
          return (-1);
        } else {
#line 69
          goto _L___0;
        }
      } else {
#line 69
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 69
    if ((int )size < 0) {
#line 71
      return (-1);
    }
  }
  {
#line 80
  ret = 0;
#line 81
  fd = sm_io_getinfo(fp, 3, (void *)0);
  }
#line 81
  if (fd == -1) {
    {
#line 81
    tmp___0 = __errno_location();
#line 81
    *tmp___0 = 0;
    }
  }
#line 81
  if (timeout == -2) {
#line 81
    timeout = fp->f_timeout;
  }
#line 81
  if (timeout == 0) {
#line 81
    to.tv_sec = (__time_t )0;
#line 81
    to.tv_usec = (__suseconds_t )0;
  } else
#line 81
  if (timeout == -1) {
#line 81
    to.tv_sec = (__time_t )0;
#line 81
    to.tv_usec = (__suseconds_t )0;
  } else {
#line 81
    to.tv_sec = (__time_t )(timeout / 1000);
#line 81
    to.tv_usec = ((__time_t )timeout - to.tv_sec * 1000L) * 1000L;
  }
#line 81
  if (timeout == -1) {
#line 81
    if (fp->f_timeoutstate == 1) {
#line 81
      if (fd != -1) {
        {
#line 81
        ret___0 = fcntl(fd, 3, 0);
        }
#line 81
        if (ret___0 == -1) {
#line 81
          return (-1);
        } else {
          {
#line 81
          tmp___1 = fcntl(fd, 4, ret___0 & -2049);
          }
#line 81
          if (tmp___1 == -1) {
#line 81
            return (-1);
          }
        }
#line 81
        fp->f_timeoutstate = 0;
#line 81
        if ((unsigned long )fp->f_modefp != (unsigned long )((void *)0)) {
#line 81
          (fp->f_modefp)->f_timeoutstate = 0;
        }
      }
    }
  } else
#line 81
  if (fp->f_timeoutstate == 0) {
#line 81
    if (fd != -1) {
      {
#line 81
      ret___1 = fcntl(fd, 3, 0);
      }
#line 81
      if (ret___1 == -1) {
#line 81
        return (-1);
      } else {
        {
#line 81
        tmp___2 = fcntl(fd, 4, ret___1 | 2048);
        }
#line 81
        if (tmp___2 == -1) {
#line 81
          return (-1);
        }
      }
#line 81
      fp->f_timeoutstate = 1;
#line 81
      if ((unsigned long )fp->f_modefp != (unsigned long )((void *)0)) {
#line 81
        (fp->f_modefp)->f_timeoutstate = 1;
      }
    }
  }
  {
#line 82
  sm_flush(fp, & timeout);
  }
#line 83
  if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 84
    if ((unsigned long )fp->f_ub.smb_base != (unsigned long )(fp->f_ubuf)) {
      {
#line 84
      sm_free_tagged((void *)((char *)fp->f_ub.smb_base), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/setvbuf.c",
                     84);
      }
    }
#line 84
    fp->f_ub.smb_base = (unsigned char *)((void *)0);
  }
#line 85
  tmp___3 = 0;
#line 85
  fp->f_lbfsize = tmp___3;
#line 85
  fp->f_r = tmp___3;
#line 86
  flags = (int )fp->f_flags;
#line 87
  if (flags & 512) {
    {
#line 89
    sm_free_tagged((void *)fp->f_bf.smb_base, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/setvbuf.c",
                   89);
#line 90
    fp->f_bf.smb_base = (unsigned char *)((void *)0);
    }
  }
#line 92
  flags &= -12944;
#line 96
  if (mode == 2) {
#line 97
    goto nbf;
  }
  {
#line 105
  tmp___4 = sm_whatbuf(fp, & iosize, & ttyflag);
#line 105
  flags |= tmp___4;
  }
#line 106
  if (size == 0U) {
#line 108
    buf___16 = (char *)((void *)0);
#line 109
    size = iosize;
  }
#line 113
  if ((unsigned long )buf___16 == (unsigned long )((void *)0)) {
    {
#line 115
    tmp___6 = sm_malloc_tagged(size, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/setvbuf.c",
                               115, SmHeapGroup);
#line 115
    buf___16 = (char *)tmp___6;
    }
#line 115
    if ((unsigned long )buf___16 == (unsigned long )((void *)0)) {
#line 122
      ret = -1;
#line 123
      if (size != iosize) {
        {
#line 125
        size = iosize;
#line 126
        tmp___5 = sm_malloc_tagged(size, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/setvbuf.c",
                                   126, SmHeapGroup);
#line 126
        buf___16 = (char *)tmp___5;
        }
      }
    }
#line 129
    if ((unsigned long )buf___16 == (unsigned long )((void *)0)) {
      nbf: 
#line 133
      fp->f_flags = (long )(flags | 4);
#line 134
      fp->f_w = 0;
#line 135
      tmp___7 = fp->f_nbuf;
#line 135
      fp->f_p = tmp___7;
#line 135
      fp->f_bf.smb_base = tmp___7;
#line 136
      fp->f_bf.smb_size = 1;
#line 137
      return (ret);
    }
#line 139
    flags |= 512;
  }
#line 149
  if (size != iosize) {
#line 150
    flags |= 8192;
  }
#line 157
  if (mode == 1) {
#line 158
    flags |= 2;
  } else
#line 159
  if (mode == 3) {
#line 160
    flags |= 8;
  } else
#line 161
  if (mode == 0) {
#line 162
    flags |= 1;
  }
#line 163
  fp->f_flags = (long )flags;
#line 164
  tmp___8 = (unsigned char *)buf___16;
#line 164
  fp->f_p = tmp___8;
#line 164
  fp->f_bf.smb_base = tmp___8;
#line 165
  fp->f_bf.smb_size = (int )size;
#line 167
  if (flags & 32) {
#line 174
    if (flags & 2) {
#line 176
      fp->f_w = 0;
#line 177
      fp->f_lbfsize = - fp->f_bf.smb_size;
    } else {
#line 180
      fp->f_w = (int )size;
    }
  } else {
#line 185
    fp->f_w = 0;
  }
  {
#line 188
  atexit(& sm_cleanup);
  }
#line 189
  return (ret);
}
}
#line 390 "/usr/include/unistd.h"
unsigned int sleep(unsigned int intvl ) ;
#line 53 "/usr/include/sys/sem.h"
extern  __attribute__((__nothrow__)) int semctl(int __semid , int __semnum , int __cmd 
                                                , ...) ;
#line 56
extern  __attribute__((__nothrow__)) int semget(key_t __key , int __nsems , int __semflg ) ;
#line 59
extern  __attribute__((__nothrow__)) int semop(int __semid , struct sembuf *__sops ,
                                               size_t __nsops ) ;
#line 45 "../../include/sm/sem.h"
int sm_sem_start(key_t key , int nsem , int semflg , bool owner ) ;
#line 46
int sm_sem_stop(int semid ) ;
#line 47
int sm_sem_acq(int semid , int semnum , int timeout ) ;
#line 48
int sm_sem_rel(int semid , int semnum , int timeout ) ;
#line 49
int sm_sem_get(int semid , int semnum ) ;
#line 34 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/sem.c"
int sm_sem_start(key_t key , int nsem , int semflg , bool owner ) 
{ 
  int semid ;
  int i ;
  int err ;
  unsigned short *semvals ;
  union semun semarg ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 44
  semvals = (unsigned short *)((void *)0);
#line 45
  if (semflg == 0) {
#line 46
    semflg = 384 | (384 >> 3);
  }
#line 47
  if (owner) {
#line 48
    semflg |= 1536;
  }
  {
#line 49
  semid = semget(key, nsem, semflg);
  }
#line 50
  if (semid < 0) {
#line 51
    goto error;
  }
#line 53
  if (owner) {
    {
#line 57
    tmp = sm_malloc_tagged((size_t )((unsigned long )nsem * sizeof(semvals)), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/sem.c",
                           57, SmHeapGroup);
#line 57
    semvals = (unsigned short *)tmp;
    }
#line 58
    if ((unsigned long )semvals == (unsigned long )((void *)0)) {
#line 59
      goto error;
    }
#line 60
    semarg.array = semvals;
#line 63
    i = 0;
    {
#line 63
    while (1) {
      while_continue: /* CIL Label */ ;
#line 63
      if (! (i < nsem)) {
#line 63
        goto while_break;
      }
#line 64
      *(semvals + i) = (unsigned short)1;
#line 63
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 65
    tmp___0 = semctl(semid, 0, 17, semarg);
    }
#line 65
    if (tmp___0 < 0) {
#line 66
      goto error;
    }
  }
#line 68
  return (semid);
  error: 
  {
#line 71
  tmp___1 = __errno_location();
#line 71
  err = *tmp___1;
  }
#line 72
  if ((unsigned long )semvals != (unsigned long )((void *)0)) {
    {
#line 73
    sm_free_tagged((void *)semvals, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/sem.c",
                   73);
    }
  }
#line 74
  if (semid >= 0) {
    {
#line 75
    sm_sem_stop(semid);
    }
  }
#line 76
  if (err > 0) {
#line 76
    tmp___2 = 0 - err;
  } else {
#line 76
    tmp___2 = -1;
  }
#line 76
  return (tmp___2);
}
}
#line 90 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/sem.c"
int sm_sem_stop(int semid ) 
{ 
  int tmp ;

  {
  {
#line 94
  tmp = semctl(semid, 0, 0, (void *)0);
  }
#line 94
  return (tmp);
}
}
#line 110 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/sem.c"
int sm_sem_acq(int semid , int semnum , int timeout ) 
{ 
  int r ;
  struct sembuf semops[1] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 119
  semops[0].sem_num = (unsigned short )semnum;
#line 120
  semops[0].sem_op = (short)-1;
#line 121
  if (timeout != -1) {
#line 121
    tmp = 0;
  } else {
#line 121
    tmp = 2048;
  }
#line 121
  semops[0].sem_flg = (short )(4096 | tmp);
#line 123
  if (timeout == 0) {
    {
#line 124
    tmp___0 = semop(semid, semops, (size_t )1);
    }
#line 124
    return (tmp___0);
  } else
#line 123
  if (timeout == -1) {
    {
#line 124
    tmp___0 = semop(semid, semops, (size_t )1);
    }
#line 124
    return (tmp___0);
  }
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 127
    r = semop(semid, semops, (size_t )1);
    }
#line 128
    if (r == 0) {
#line 129
      return (r);
    }
    {
#line 130
    sleep(1U);
#line 131
    timeout --;
    }
#line 125
    if (! (timeout > 0)) {
#line 125
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return (r);
}
}
#line 149 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/sem.c"
int sm_sem_rel(int semid , int semnum , int timeout ) 
{ 
  int r ;
  struct sembuf semops[1] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 163
  semops[0].sem_num = (unsigned short )semnum;
#line 164
  semops[0].sem_op = (short)1;
#line 165
  if (timeout != -1) {
#line 165
    tmp = 0;
  } else {
#line 165
    tmp = 2048;
  }
#line 165
  semops[0].sem_flg = (short )(4096 | tmp);
#line 167
  if (timeout == 0) {
    {
#line 168
    tmp___0 = semop(semid, semops, (size_t )1);
    }
#line 168
    return (tmp___0);
  } else
#line 167
  if (timeout == -1) {
    {
#line 168
    tmp___0 = semop(semid, semops, (size_t )1);
    }
#line 168
    return (tmp___0);
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 171
    r = semop(semid, semops, (size_t )1);
    }
#line 172
    if (r == 0) {
#line 173
      return (r);
    }
    {
#line 174
    sleep(1U);
#line 175
    timeout --;
    }
#line 169
    if (! (timeout > 0)) {
#line 169
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return (r);
}
}
#line 192 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/sem.c"
int sm_sem_get(int semid , int semnum ) 
{ 
  int semval ;

  {
  {
#line 199
  semval = semctl(semid, semnum, 12, (void *)0);
  }
#line 199
  if (semval < 0) {
#line 200
    return (-1);
  }
#line 201
  return (semval);
}
}
#line 91 "../../include/sm/exc.h"
void sm_exc_free(SM_EXC_T *exc ) ;
#line 95
bool sm_exc_match(SM_EXC_T *exc , char const   *pattern ) ;
#line 146
SM_EXC_HANDLER_T *SmExcHandler ;
#line 130 "../../include/sm/rpool.h"
SM_RPOOL_T *sm_rpool_new_x(SM_RPOOL_T *parent ) ;
#line 134
void sm_rpool_free(SM_RPOOL_T *rpool ) ;
#line 139
void *sm_rpool_malloc_tagged_x(SM_RPOOL_T *rpool , size_t size , char *file , int line ,
                               int group ) ;
#line 148
void *sm_rpool_malloc_tagged(SM_RPOOL_T *rpool , size_t size , char *file , int line ,
                             int group ) ;
#line 169
char *sm_rpool_strdup_x(SM_RPOOL_T *rpool , char const   *s ) ;
#line 175
SM_RPOOL_ATTACH_T sm_rpool_attach_x(SM_RPOOL_T *rpool , void (*rfree)(void *_rcontext ) ,
                                    void *rcontext ) ;
#line 183
void sm_rpool_setsizes(SM_RPOOL_T *rpool , size_t poolsize , size_t bigobjectsize ) ;
#line 27 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
char const   SmRpoolMagic[9]  = 
#line 27 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
  {      (char const   )'s',      (char const   )'m',      (char const   )'_',      (char const   )'r', 
        (char const   )'p',      (char const   )'o',      (char const   )'o',      (char const   )'l', 
        (char const   )'\000'};
#line 35
static char *sm_rpool_allocblock_x(SM_RPOOL_T *rpool , size_t size ) ;
#line 36
static char *sm_rpool_allocblock(SM_RPOOL_T *rpool , size_t size ) ;
#line 59 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
static char *sm_rpool_allocblock_x(SM_RPOOL_T *rpool , size_t size ) 
{ 
  SM_POOLLINK_T *p ;
  void *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 66
  tmp = sm_malloc_tagged_x((size_t )(sizeof(SM_POOLHDR_T ) + (unsigned long )size),
                           (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                           66, SmHeapGroup);
#line 66
  p = (SM_POOLLINK_T *)tmp;
#line 67
  p->sm_pnext = rpool->sm_pools;
#line 68
  rpool->sm_pools = p;
  }
#line 69
  return ((char *)p + sizeof(SM_POOLHDR_T ));
}
}
#line 83 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
static char *sm_rpool_allocblock(SM_RPOOL_T *rpool , size_t size ) 
{ 
  SM_POOLLINK_T *p ;
  void *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 90
  tmp = sm_malloc_tagged((size_t )(sizeof(SM_POOLHDR_T ) + (unsigned long )size),
                         (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                         90, SmHeapGroup);
#line 90
  p = (SM_POOLLINK_T *)tmp;
  }
#line 91
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 92
    return ((char *)((void *)0));
  }
#line 93
  p->sm_pnext = rpool->sm_pools;
#line 94
  rpool->sm_pools = p;
#line 95
  return ((char *)p + sizeof(SM_POOLHDR_T ));
}
}
#line 124 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
void *sm_rpool_malloc_tagged_x(SM_RPOOL_T *rpool , size_t size , char *file , int line ,
                               int group ) 
{ 
  char *ptr ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 140
  if ((unsigned long )rpool == (unsigned long )((void *)0)) {
    {
#line 141
    tmp = sm_malloc_tagged_x(size, file, line, group);
    }
#line 141
    return (tmp);
  }
#line 144
  if ((unsigned long )size & ((unsigned long )(& ((struct sm_align *)0)->al_u) - 1UL)) {
#line 145
    size = (size_t )(((unsigned long )size & ~ ((unsigned long )(& ((struct sm_align *)0)->al_u) - 1UL)) + (unsigned long )(& ((struct sm_align *)0)->al_u));
  }
#line 148
  if (size <= rpool->sm_poolavail) {
#line 150
    ptr = rpool->sm_poolptr;
#line 151
    rpool->sm_poolptr += size;
#line 152
    rpool->sm_poolavail -= size;
#line 153
    return ((void *)ptr);
  }
#line 163
  if ((unsigned long )rpool->sm_magic == (unsigned long )(SmRpoolMagic)) {
#line 163
    tmp___0 = 1;
  } else {
    {
#line 163
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                163, "SM_REQUIRE(rpool->sm_magic == SmRpoolMagic) failed");
#line 163
    tmp___0 = 0;
    }
  }
#line 180
  if (size > rpool->sm_bigobjectsize) {
    {
#line 185
    tmp___1 = sm_rpool_allocblock_x(rpool, size);
    }
#line 185
    return ((void *)tmp___1);
  }
#line 187
  if (rpool->sm_bigobjectsize <= rpool->sm_poolsize) {
#line 187
    tmp___2 = 1;
  } else {
    {
#line 187
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                187, "SM_ASSERT(rpool->sm_bigobjectsize <= rpool->sm_poolsize) failed");
#line 187
    tmp___2 = 0;
    }
  }
  {
#line 188
  ptr = sm_rpool_allocblock_x(rpool, rpool->sm_poolsize);
#line 189
  rpool->sm_poolptr = ptr + size;
#line 190
  rpool->sm_poolavail = rpool->sm_poolsize - size;
  }
#line 194
  return ((void *)ptr);
}
}
#line 220 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
void *sm_rpool_malloc_tagged(SM_RPOOL_T *rpool , size_t size , char *file , int line ,
                             int group ) 
{ 
  char *ptr ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 236
  if ((unsigned long )rpool == (unsigned long )((void *)0)) {
    {
#line 237
    tmp = sm_malloc_tagged(size, file, line, group);
    }
#line 237
    return (tmp);
  }
#line 240
  if ((unsigned long )size & ((unsigned long )(& ((struct sm_align *)0)->al_u) - 1UL)) {
#line 241
    size = (size_t )(((unsigned long )size & ~ ((unsigned long )(& ((struct sm_align *)0)->al_u) - 1UL)) + (unsigned long )(& ((struct sm_align *)0)->al_u));
  }
#line 244
  if (size <= rpool->sm_poolavail) {
#line 246
    ptr = rpool->sm_poolptr;
#line 247
    rpool->sm_poolptr += size;
#line 248
    rpool->sm_poolavail -= size;
#line 249
    return ((void *)ptr);
  }
#line 259
  if ((unsigned long )rpool->sm_magic == (unsigned long )(SmRpoolMagic)) {
#line 259
    tmp___0 = 1;
  } else {
    {
#line 259
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                259, "SM_REQUIRE(rpool->sm_magic == SmRpoolMagic) failed");
#line 259
    tmp___0 = 0;
    }
  }
#line 276
  if (size > rpool->sm_bigobjectsize) {
    {
#line 281
    tmp___1 = sm_rpool_allocblock(rpool, size);
    }
#line 281
    return ((void *)tmp___1);
  }
#line 283
  if (rpool->sm_bigobjectsize <= rpool->sm_poolsize) {
#line 283
    tmp___2 = 1;
  } else {
    {
#line 283
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                283, "SM_ASSERT(rpool->sm_bigobjectsize <= rpool->sm_poolsize) failed");
#line 283
    tmp___2 = 0;
    }
  }
  {
#line 284
  ptr = sm_rpool_allocblock(rpool, rpool->sm_poolsize);
  }
#line 285
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 286
    return ((void *)0);
  }
#line 287
  rpool->sm_poolptr = ptr + size;
#line 288
  rpool->sm_poolavail = rpool->sm_poolsize - size;
#line 292
  return ((void *)ptr);
}
}
#line 305 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
SM_RPOOL_T *sm_rpool_new_x(SM_RPOOL_T *parent ) 
{ 
  SM_RPOOL_T *rpool ;
  void *tmp ;
  SM_EXC_HANDLER_T _h ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___3 ;
  SM_EXC_T *exc  __attribute__((__unused__)) ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 311
  tmp = sm_malloc_tagged_x((size_t )sizeof(SM_RPOOL_T ), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                           311, SmHeapGroup);
#line 311
  rpool = (SM_RPOOL_T *)tmp;
  }
#line 312
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 313
    rpool->sm_parentlink = (SM_RPOOL_RFREE_T *)((void *)0);
  } else {
    {
#line 316
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 316
      _h.eh_value = (SM_EXC_T *)((void *)0);
#line 316
      _h.eh_parent = SmExcHandler;
#line 316
      _h.eh_state = 2;
#line 316
      SmExcHandler = & _h;
#line 316
      tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
      }
#line 316
      if (tmp___0 == 0) {
        {
#line 317
        rpool->sm_parentlink = sm_rpool_attach_x(parent, (void (*)(void *_rcontext ))(& sm_rpool_free),
                                                 (void *)rpool);
        }
      }
#line 320
      if (_h.eh_state == 1) {
#line 320
        goto while_break;
      }
#line 320
      if (_h.eh_state == 2) {
#line 320
        if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 320
          tmp___1 = 1;
        } else {
          {
#line 320
          sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                      320, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 320
          tmp___1 = 0;
          }
        }
#line 320
        SmExcHandler = _h.eh_parent;
      }
      {
#line 320
      tmp___3 = sm_exc_match(_h.eh_value, "*");
      }
#line 320
      if (tmp___3) {
#line 320
        _h.eh_state = 1;
      } else {
#line 320
        _h.eh_state = 0;
      }
#line 320
      if (_h.eh_state == 1) {
        {
#line 320
        exc = _h.eh_value;
#line 321
        sm_free_tagged((void *)rpool, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                       321);
#line 322
        sm_exc_raise_x(exc);
        }
      }
#line 316
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 323
    if (_h.eh_state == 2) {
#line 323
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 323
        tmp___4 = 1;
      } else {
        {
#line 323
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                    323, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 323
        tmp___4 = 0;
        }
      }
#line 323
      SmExcHandler = _h.eh_parent;
#line 323
      if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
        {
#line 323
        sm_exc_raise_x(_h.eh_value);
        }
      }
    } else
#line 323
    if (_h.eh_state == 0) {
#line 323
      if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
        {
#line 323
        sm_exc_raise_x(_h.eh_value);
        }
      }
    } else {
      {
#line 323
      sm_exc_free(_h.eh_value);
      }
    }
  }
#line 325
  rpool->sm_magic = SmRpoolMagic;
#line 327
  rpool->sm_poolsize = (size_t )(4096UL - sizeof(SM_POOLHDR_T ));
#line 328
  rpool->sm_bigobjectsize = rpool->sm_poolsize / 10U;
#line 329
  rpool->sm_poolptr = (char *)((void *)0);
#line 330
  rpool->sm_poolavail = (size_t )0;
#line 331
  rpool->sm_pools = (SM_POOLLINK_T *)((void *)0);
#line 333
  rpool->sm_rptr = (SM_RESOURCE_T *)((void *)0);
#line 334
  rpool->sm_ravail = (size_t )0;
#line 335
  rpool->sm_rlists = (SM_RLIST_T *)((void *)0);
#line 341
  return (rpool);
}
}
#line 356 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
void sm_rpool_setsizes(SM_RPOOL_T *rpool , size_t poolsize , size_t bigobjectsize ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 362
  if (poolsize >= bigobjectsize) {
#line 362
    tmp = 1;
  } else {
    {
#line 362
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                362, "SM_REQUIRE(poolsize >= bigobjectsize) failed");
#line 362
    tmp = 0;
    }
  }
#line 363
  if (poolsize == 0U) {
#line 364
    poolsize = (size_t )(4096UL - sizeof(SM_POOLHDR_T ));
  }
#line 365
  if (bigobjectsize == 0U) {
#line 366
    bigobjectsize = poolsize / 10U;
  }
#line 367
  rpool->sm_poolsize = poolsize;
#line 368
  rpool->sm_bigobjectsize = bigobjectsize;
#line 369
  return;
}
}
#line 381 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
void sm_rpool_free(SM_RPOOL_T *rpool ) 
{ 
  SM_RLIST_T *rl ;
  SM_RLIST_T *rnext ;
  SM_RESOURCE_T *r ;
  SM_RESOURCE_T *rmax ;
  SM_POOLLINK_T *pp ;
  SM_POOLLINK_T *pnext ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 389
  if ((unsigned long )rpool == (unsigned long )((void *)0)) {
#line 390
    return;
  }
#line 398
  rl = rpool->sm_rlists;
#line 399
  if ((unsigned long )rl != (unsigned long )((void *)0)) {
#line 401
    rmax = rpool->sm_rptr;
    {
#line 402
    while (1) {
      while_continue: /* CIL Label */ ;
#line 404
      r = rl->sm_rvec;
      {
#line 404
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 404
        if (! ((unsigned long )r < (unsigned long )rmax)) {
#line 404
          goto while_break___0;
        }
#line 406
        if ((unsigned long )r->sm_rfree != (unsigned long )((void *)0)) {
          {
#line 407
          (*(r->sm_rfree))(r->sm_rcontext);
          }
        }
#line 404
        r ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 409
      rnext = rl->sm_rnext;
#line 410
      sm_free_tagged((void *)rl, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                     410);
      }
#line 411
      if ((unsigned long )rnext == (unsigned long )((void *)0)) {
#line 412
        goto while_break;
      }
#line 413
      rl = rnext;
#line 414
      rmax = & rl->sm_rvec[511];
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 422
  pp = rpool->sm_pools;
  {
#line 422
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 422
    if (! ((unsigned long )pp != (unsigned long )((void *)0))) {
#line 422
      goto while_break___1;
    }
    {
#line 424
    pnext = pp->sm_pnext;
#line 425
    sm_free_tagged((void *)pp, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                   425);
#line 422
    pp = pnext;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 432
  if ((unsigned long )rpool->sm_parentlink != (unsigned long )((void *)0)) {
#line 433
    *(rpool->sm_parentlink) = (SM_RPOOL_RFREE_T )((void *)0);
  }
  {
#line 440
  rpool->sm_magic = (char const   *)((void *)0);
#line 441
  rpool->sm_poolavail = (size_t )0;
#line 442
  rpool->sm_ravail = (size_t )0;
#line 452
  sm_free_tagged((void *)rpool, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                 452);
  }
#line 453
  return;
}
}
#line 470 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
SM_RPOOL_ATTACH_T sm_rpool_attach_x(SM_RPOOL_T *rpool , void (*rfree)(void *_rcontext ) ,
                                    void *rcontext ) 
{ 
  SM_RLIST_T *rl ;
  SM_RPOOL_ATTACH_T a ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 479
  if ((unsigned long )rpool != (unsigned long )((void *)0)) {
#line 479
    if ((unsigned long )rpool->sm_magic == (unsigned long )(SmRpoolMagic)) {
#line 479
      tmp = 1;
    } else {
      {
#line 479
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                  479, "SM_REQUIRE((rpool) != NULL && (rpool)->sm_magic == (SmRpoolMagic)) failed");
#line 479
      tmp = 0;
      }
    }
  } else {
    {
#line 479
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                479, "SM_REQUIRE((rpool) != NULL && (rpool)->sm_magic == (SmRpoolMagic)) failed");
#line 479
    tmp = 0;
    }
  }
#line 481
  if (rpool->sm_ravail == 0U) {
    {
#line 483
    tmp___0 = sm_malloc_tagged_x((size_t )sizeof(SM_RLIST_T ), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                                 483, SmHeapGroup);
#line 483
    rl = (SM_RLIST_T *)tmp___0;
#line 484
    rl->sm_rnext = rpool->sm_rlists;
#line 485
    rpool->sm_rlists = rl;
#line 486
    rpool->sm_rptr = rl->sm_rvec;
#line 487
    rpool->sm_ravail = (size_t )511;
    }
  }
#line 490
  a = & (rpool->sm_rptr)->sm_rfree;
#line 491
  (rpool->sm_rptr)->sm_rfree = rfree;
#line 492
  (rpool->sm_rptr)->sm_rcontext = rcontext;
#line 493
  (rpool->sm_rptr) ++;
#line 494
  (rpool->sm_ravail) --;
#line 495
  return (a);
}
}
#line 510 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c"
char *sm_rpool_strdup_x(SM_RPOOL_T *rpool , char const   *s ) 
{ 
  size_t l ;
  char *n ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 518
  l = strlen(s);
  }
#line 519
  if (l + 1U > l) {
#line 519
    tmp = 1;
  } else {
    {
#line 519
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                519, "SM_ASSERT(l + 1 > l) failed");
#line 519
    tmp = 0;
    }
  }
  {
#line 520
  tmp___0 = sm_rpool_malloc_tagged_x(rpool, l + 1U, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rpool.c",
                                     520, SmHeapGroup);
#line 520
  n = (char *)tmp___0;
#line 521
  sm_strlcpy(n, s, (ssize_t )(l + 1U));
  }
#line 522
  return (n);
}
}
#line 292 "../../include/sm/io.h"
void sm_io_rewind(SM_FILE_T *fp , int timeout ) ;
#line 293
int sm_io_seek(SM_FILE_T *fp , int timeout , long offset , int whence ) ;
#line 35 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rewind.c"
void sm_io_rewind(SM_FILE_T *fp , int timeout ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 40
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 40
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 40
      tmp = 1;
    } else {
      {
#line 40
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rewind.c",
                  40, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 40
      tmp = 0;
      }
    }
  } else {
    {
#line 40
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/rewind.c",
                40, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 40
    tmp = 0;
    }
  }
  {
#line 41
  sm_io_seek(fp, timeout, 0L, 0);
#line 42
  fp->f_flags &= -385L;
#line 43
  tmp___0 = __errno_location();
#line 43
  *tmp___0 = 0;
  }
#line 44
  return;
}
}
#line 72 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz ) ;
#line 343 "../../include/sm/io.h"
int sm_rget(SM_FILE_T *fp , int timeout ) ;
#line 35 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/local.h"
int sm_fwalk(int (*function)(SM_FILE_T * , int * ) , int *timeout ) ;
#line 30 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/refill.c"
static int sm_lflush(SM_FILE_T *fp , int *timeout ) ;
#line 116 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/refill.c"
static int sm_lflush(SM_FILE_T *fp , int *timeout ) 
{ 
  int tmp ;

  {
#line 122
  if ((fp->f_flags & 34L) == 34L) {
    {
#line 123
    tmp = sm_flush(fp, timeout);
    }
#line 123
    return (tmp);
  }
#line 124
  return (0);
}
}
#line 139 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/refill.c"
int sm_refill(SM_FILE_T *fp , int timeout ) 
{ 
  int ret ;
  int r ;
  struct timeval to ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  int ret___0 ;
  int tmp___1 ;
  int ret___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  struct timeval sm_io_to_before ;
  struct timeval sm_io_to_after ;
  struct timeval sm_io_to_diff ;
  fd_set sm_io_to_mask ;
  fd_set sm_io_x_mask ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp37 ;

  {
#line 148
  if (timeout == -2) {
#line 149
    timeout = fp->f_timeout;
  }
#line 150
  if (timeout == 0) {
    {
#line 158
    tmp = __errno_location();
#line 158
    *tmp = 11;
#line 159
    fp->f_r = 0;
    }
#line 160
    return (0);
  }
#line 164
  if (! Sm_IO_DidInit) {
    {
#line 165
    sm_init();
    }
  }
#line 167
  fp->f_r = 0;
#line 169
  if (fp->f_flags & 128L) {
#line 170
    return (-1);
  }
  {
#line 172
  fd = sm_io_getinfo(fp, 3, (void *)0);
  }
#line 172
  if (fd == -1) {
    {
#line 172
    tmp___0 = __errno_location();
#line 172
    *tmp___0 = 0;
    }
  }
#line 172
  if (timeout == -2) {
#line 172
    timeout = fp->f_timeout;
  }
#line 172
  if (timeout == 0) {
#line 172
    to.tv_sec = (__time_t )0;
#line 172
    to.tv_usec = (__suseconds_t )0;
  } else
#line 172
  if (timeout == -1) {
#line 172
    to.tv_sec = (__time_t )0;
#line 172
    to.tv_usec = (__suseconds_t )0;
  } else {
#line 172
    to.tv_sec = (__time_t )(timeout / 1000);
#line 172
    to.tv_usec = ((__time_t )timeout - to.tv_sec * 1000L) * 1000L;
  }
#line 172
  if (timeout == -1) {
#line 172
    if (fp->f_timeoutstate == 1) {
#line 172
      if (fd != -1) {
        {
#line 172
        ret___0 = fcntl(fd, 3, 0);
        }
#line 172
        if (ret___0 == -1) {
#line 172
          return (-1);
        } else {
          {
#line 172
          tmp___1 = fcntl(fd, 4, ret___0 & -2049);
          }
#line 172
          if (tmp___1 == -1) {
#line 172
            return (-1);
          }
        }
#line 172
        fp->f_timeoutstate = 0;
#line 172
        if ((unsigned long )fp->f_modefp != (unsigned long )((void *)0)) {
#line 172
          (fp->f_modefp)->f_timeoutstate = 0;
        }
      }
    }
  } else
#line 172
  if (fp->f_timeoutstate == 0) {
#line 172
    if (fd != -1) {
      {
#line 172
      ret___1 = fcntl(fd, 3, 0);
      }
#line 172
      if (ret___1 == -1) {
#line 172
        return (-1);
      } else {
        {
#line 172
        tmp___2 = fcntl(fd, 4, ret___1 | 2048);
        }
#line 172
        if (tmp___2 == -1) {
#line 172
          return (-1);
        }
      }
#line 172
      fp->f_timeoutstate = 1;
#line 172
      if ((unsigned long )fp->f_modefp != (unsigned long )((void *)0)) {
#line 172
        (fp->f_modefp)->f_timeoutstate = 1;
      }
    }
  }
#line 175
  if ((fp->f_flags & 16L) == 0L) {
#line 177
    if ((fp->f_flags & 64L) == 0L) {
      {
#line 179
      tmp___3 = __errno_location();
#line 179
      *tmp___3 = 9;
#line 180
      fp->f_flags |= 256L;
      }
#line 181
      return (-1);
    }
#line 185
    if (fp->f_flags & 32L) {
      {
#line 187
      tmp___4 = sm_flush(fp, & timeout);
      }
#line 187
      if (tmp___4) {
#line 188
        return (-1);
      }
#line 189
      fp->f_flags &= -33L;
#line 190
      fp->f_w = 0;
#line 191
      fp->f_lbfsize = 0;
    }
#line 193
    fp->f_flags |= 16L;
  } else
#line 204
  if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 206
    if ((unsigned long )fp->f_ub.smb_base != (unsigned long )(fp->f_ubuf)) {
      {
#line 206
      sm_free_tagged((void *)((char *)fp->f_ub.smb_base), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/refill.c",
                     206);
      }
    }
#line 206
    fp->f_ub.smb_base = (unsigned char *)((void *)0);
#line 207
    tmp___5 = fp->f_ur;
#line 207
    fp->f_r = tmp___5;
#line 207
    if (tmp___5 != 0) {
#line 209
      fp->f_p = fp->f_up;
#line 212
      return (0);
    }
  }
#line 217
  if ((unsigned long )fp->f_bf.smb_base == (unsigned long )((void *)0)) {
    {
#line 218
    sm_makebuf(fp);
    }
  }
#line 225
  if (fp->f_flags & 6L) {
    {
#line 226
    sm_fwalk(& sm_lflush, & timeout);
    }
  }
#line 233
  if ((unsigned long )fp->f_flushfp != (unsigned long )((void *)0)) {
    {
#line 233
    tmp___6 = (*(fp->f_getinfo))(fp, 6, (void *)0);
    }
#line 233
    if (tmp___6 <= 0) {
      {
#line 235
      sm_flush(fp->f_flushfp, & timeout);
      }
    }
  }
#line 237
  fp->f_p = fp->f_bf.smb_base;
#line 245
  ret = 0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 248
    tmp___7 = __errno_location();
#line 248
    *tmp___7 = 0;
#line 249
    r = (*(fp->f_read))(fp, (char *)fp->f_p, (size_t )fp->f_bf.smb_size);
    }
#line 250
    if (r <= 0) {
#line 252
      if (r == 0) {
        {
#line 252
        tmp___8 = __errno_location();
        }
#line 252
        if (*tmp___8 == 0) {
#line 253
          goto while_break;
        }
      }
#line 254
      if (fd < 0) {
#line 255
        goto err;
      } else
#line 254
      if (r < 0) {
        {
#line 254
        tmp___9 = __errno_location();
        }
#line 254
        if (*tmp___9 != 11) {
          {
#line 254
          tmp___10 = __errno_location();
          }
#line 254
          if (*tmp___10 != 11) {
#line 255
            goto err;
          } else {
#line 254
            goto _L___0;
          }
        } else {
#line 254
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 254
      if (timeout == -1) {
#line 255
        goto err;
      }
      {
#line 258
      tmp___11 = __errno_location();
#line 258
      *tmp___11 = 0;
      }
#line 258
      if (timeout == 0) {
        {
#line 258
        tmp___12 = __errno_location();
#line 258
        *tmp___12 = 11;
        }
#line 258
        return (-1);
      }
#line 258
      if (fd >= 1024) {
        {
#line 258
        tmp___13 = __errno_location();
#line 258
        *tmp___13 = 22;
        }
#line 258
        return (-1);
      }
      {
#line 258
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 258
        __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0),
                             "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& sm_io_to_mask.__fds_bits[0]): "memory");
#line 258
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 258
      __asm__  volatile   ("btsl %1,%0": "=m" (sm_io_to_mask.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                           "memory");
      {
#line 258
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 258
        __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                             "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& sm_io_x_mask.__fds_bits[0]): "memory");
#line 258
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 258
      __asm__  volatile   ("btsl %1,%0": "=m" (sm_io_x_mask.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                           "memory");
#line 258
      tmp___14 = gettimeofday((struct timeval */* __restrict  */)(& sm_io_to_before),
                              (__timezone_ptr_t )((void *)0));
      }
#line 258
      if (tmp___14 < 0) {
#line 258
        return (-1);
      }
      {
#line 258
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 258
        ret = select(fd + 1, (fd_set */* __restrict  */)(& sm_io_to_mask), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)(& sm_io_x_mask), (struct timeval */* __restrict  */)(& to));
        }
#line 258
        if (ret < 0) {
          {
#line 258
          tmp___15 = __errno_location();
          }
#line 258
          if (! (*tmp___15 == 4)) {
#line 258
            goto while_break___2;
          }
        } else {
#line 258
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 258
      if (ret < 0) {
#line 258
        fp->f_r = 0;
#line 258
        fp->f_flags |= 256L;
#line 258
        return (-1);
      } else
#line 258
      if (ret == 0) {
        {
#line 258
        tmp___16 = __errno_location();
#line 258
        *tmp___16 = 11;
        }
#line 258
        return (-1);
      }
      {
#line 258
      tmp___17 = gettimeofday((struct timeval */* __restrict  */)(& sm_io_to_after),
                              (__timezone_ptr_t )((void *)0));
      }
#line 258
      if (tmp___17 < 0) {
#line 258
        return (-1);
      }
      {
#line 258
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 258
        sm_io_to_diff.tv_sec = sm_io_to_after.tv_sec - sm_io_to_before.tv_sec;
#line 258
        sm_io_to_diff.tv_usec = sm_io_to_after.tv_usec - sm_io_to_before.tv_usec;
#line 258
        if (sm_io_to_diff.tv_usec < 0L) {
#line 258
          (sm_io_to_diff.tv_sec) --;
#line 258
          sm_io_to_diff.tv_usec += 1000000L;
        }
#line 258
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 258
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 258
        to.tv_sec -= sm_io_to_diff.tv_sec;
#line 258
        to.tv_usec -= sm_io_to_diff.tv_usec;
#line 258
        if (to.tv_usec < 0L) {
#line 258
          (to.tv_sec) --;
#line 258
          to.tv_usec += 1000000L;
        }
#line 258
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 246
    if (r <= 0) {
#line 246
      if (! (ret > 0)) {
#line 246
        goto while_break;
      }
    } else {
#line 246
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  err: 
#line 263
  if (r <= 0) {
#line 265
    if (r == 0) {
#line 266
      fp->f_flags |= 128L;
    } else {
#line 268
      fp->f_flags |= 256L;
    }
#line 269
    fp->f_r = 0;
#line 270
    return (-1);
  }
#line 272
  fp->f_r = r;
#line 273
  return (0);
}
}
#line 291 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/refill.c"
int sm_rget(SM_FILE_T *fp , int timeout ) 
{ 
  unsigned char *tmp ;
  int tmp___0 ;

  {
  {
#line 296
  tmp___0 = sm_refill(fp, timeout);
  }
#line 296
  if (tmp___0 == 0) {
#line 298
    (fp->f_r) --;
#line 299
    tmp = fp->f_p;
#line 299
    (fp->f_p) ++;
#line 299
    return ((int )*tmp);
  }
#line 301
  return (-1);
}
}
#line 275 "../../include/sm/io.h"
int sm_io_fprintf(SM_FILE_T *fp , int timeout , char const   *fmt  , ...) ;
#line 288
int sm_io_putc(SM_FILE_T *fp , int timeout , int c ) ;
#line 332
void sm_perror(char const   *s ) ;
#line 79 "../../include/sm/errstring.h"
char const   *sm_errstring(int errnum ) ;
#line 44 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/put.c"
int sm_io_putc(SM_FILE_T *fp , int timeout , int c ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned char *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 50
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 50
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 50
      tmp = 1;
    } else {
      {
#line 50
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/put.c",
                  50, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 50
      tmp = 0;
      }
    }
  } else {
    {
#line 50
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/put.c",
                50, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 50
    tmp = 0;
    }
  }
#line 51
  if ((fp->f_flags & 32L) == 0L) {
#line 51
    goto _L;
  } else
#line 51
  if ((unsigned long )fp->f_bf.smb_base == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 51
    tmp___1 = sm_wsetup(fp);
    }
#line 51
    if (tmp___1) {
      {
#line 53
      tmp___0 = __errno_location();
#line 53
      *tmp___0 = 9;
      }
#line 54
      return (-1);
    }
  }
#line 56
  (fp->f_w) --;
#line 56
  if (fp->f_w < 0) {
#line 56
    if (fp->f_w >= fp->f_lbfsize) {
#line 56
      *(fp->f_p) = (unsigned char )c;
#line 56
      if ((int )*(fp->f_p) != 10) {
#line 56
        tmp___2 = fp->f_p;
#line 56
        (fp->f_p) ++;
#line 56
        tmp___4 = (int )*tmp___2;
      } else {
        {
#line 56
        tmp___3 = sm_wbuf(fp, timeout, '\n');
#line 56
        tmp___4 = tmp___3;
        }
      }
#line 56
      tmp___6 = tmp___4;
    } else {
      {
#line 56
      tmp___5 = sm_wbuf(fp, timeout, c);
#line 56
      tmp___6 = tmp___5;
      }
    }
#line 56
    tmp___8 = tmp___6;
  } else {
#line 56
    *(fp->f_p) = (unsigned char )c;
#line 56
    tmp___7 = fp->f_p;
#line 56
    (fp->f_p) ++;
#line 56
    tmp___8 = (int )*tmp___7;
  }
#line 56
  return (tmp___8);
}
}
#line 70 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/put.c"
void sm_perror(char const   *s ) 
{ 
  int save_errno ;
  int *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 74
  tmp = __errno_location();
#line 74
  save_errno = *tmp;
  }
#line 76
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 76
    if ((int const   )*s != 0) {
      {
#line 77
      sm_io_fprintf(& SmIoF[2], -2, "%s: ", s);
      }
    }
  }
  {
#line 78
  tmp___0 = sm_errstring(save_errno);
#line 78
  sm_io_fprintf(& SmIoF[2], -2, "%s\n", tmp___0);
  }
#line 80
  return;
}
}
#line 291 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/memstat.c"
int sm_memstat_open(void) 
{ 


  {
#line 294
  return (-1);
}
}
#line 307 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/memstat.c"
int sm_memstat_close(void) 
{ 


  {
#line 310
  return (0);
}
}
#line 325 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/memstat.c"
int sm_memstat_get(char *resource , long *pvalue ) 
{ 


  {
#line 330
  return (-1);
}
}
#line 119 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 37 "../../include/sm/mbdb.h"
int sm_mbdb_initialize(char *mbdb ) ;
#line 38
void sm_mbdb_terminate(void) ;
#line 39
int sm_mbdb_lookup(char *name , SM_MBDB_T *user ) ;
#line 40
void sm_mbdb_frompw(SM_MBDB_T *user , struct passwd *pw ) ;
#line 41
void sm_pwfullname(char *gecos , char *user , char *buf___16 , size_t buflen___1 ) ;
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 49 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
static int mbdb_pw_initialize(char *arg ) ;
#line 50
static int mbdb_pw_lookup(char *name , SM_MBDB_T *user ) ;
#line 51
static void mbdb_pw_terminate(void) ;
#line 62 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
static SM_MBDB_TYPE_T SmMbdbTypes[2]  = {      {(char *)"pw", & mbdb_pw_initialize, & mbdb_pw_lookup, & mbdb_pw_terminate}, 
        {(char *)((void *)0), (int (*)(char * ))((void *)0), (int (*)(char *name , SM_MBDB_T *user ))((void *)0),
      (void (*)(void))((void *)0)}};
#line 73 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
static SM_MBDB_TYPE_T *SmMbdbType  =    & SmMbdbTypes[0];
#line 90 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
int sm_mbdb_initialize(char *mbdb ) 
{ 
  size_t namelen ;
  int err ;
  char *name ;
  char *arg ;
  SM_MBDB_TYPE_T *t ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 100
  if ((unsigned long )mbdb != (unsigned long )((void *)0)) {
#line 100
    tmp = 1;
  } else {
    {
#line 100
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c",
                100, "SM_REQUIRE(mbdb != NULL) failed");
#line 100
    tmp = 0;
    }
  }
  {
#line 102
  name = mbdb;
#line 103
  arg = strchr((char const   *)mbdb, '.');
  }
#line 104
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 105
    namelen = strlen((char const   *)name);
    }
  } else {
#line 108
    namelen = (size_t )(arg - name);
#line 109
    arg ++;
  }
#line 112
  t = SmMbdbTypes;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )t->mbdb_typename != (unsigned long )((void *)0))) {
#line 112
      goto while_break;
    }
    {
#line 114
    tmp___0 = strlen((char const   *)t->mbdb_typename);
    }
#line 114
    if (tmp___0 == namelen) {
      {
#line 114
      tmp___1 = strncmp((char const   *)name, (char const   *)t->mbdb_typename, namelen);
      }
#line 114
      if (tmp___1 == 0) {
#line 117
        err = 0;
#line 118
        if ((unsigned long )t->mbdb_initialize != (unsigned long )((void *)0)) {
          {
#line 119
          err = (*(t->mbdb_initialize))(arg);
          }
        }
#line 120
        if (err == 0) {
#line 121
          SmMbdbType = t;
        }
#line 122
        return (err);
      }
    }
#line 112
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return (69);
}
}
#line 143 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
void sm_mbdb_terminate(void) 
{ 


  {
#line 146
  if ((unsigned long )SmMbdbType->mbdb_terminate != (unsigned long )((void *)0)) {
    {
#line 147
    (*(SmMbdbType->mbdb_terminate))();
    }
  }
#line 148
  return;
}
}
#line 164 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
int sm_mbdb_lookup(char *name , SM_MBDB_T *user ) 
{ 
  int ret ;

  {
#line 169
  ret = 67;
#line 171
  if ((unsigned long )SmMbdbType->mbdb_lookup != (unsigned long )((void *)0)) {
    {
#line 172
    ret = (*(SmMbdbType->mbdb_lookup))(name, user);
    }
  }
#line 173
  return (ret);
}
}
#line 187 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
void sm_mbdb_frompw(SM_MBDB_T *user , struct passwd *pw ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 192
  if ((unsigned long )user != (unsigned long )((void *)0)) {
#line 192
    tmp = 1;
  } else {
    {
#line 192
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c",
                192, "SM_REQUIRE(user != NULL) failed");
#line 192
    tmp = 0;
    }
  }
  {
#line 193
  sm_strlcpy(user->mbdb_name, (char const   *)pw->pw_name, (ssize_t )sizeof(user->mbdb_name));
#line 195
  user->mbdb_uid = pw->pw_uid;
#line 196
  user->mbdb_gid = pw->pw_gid;
#line 197
  sm_pwfullname(pw->pw_gecos, pw->pw_name, user->mbdb_fullname, (size_t )sizeof(user->mbdb_fullname));
#line 199
  sm_strlcpy(user->mbdb_homedir, (char const   *)pw->pw_dir, (ssize_t )sizeof(user->mbdb_homedir));
#line 201
  sm_strlcpy(user->mbdb_shell, (char const   *)pw->pw_shell, (ssize_t )sizeof(user->mbdb_shell));
  }
#line 203
  return;
}
}
#line 235 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
void sm_pwfullname(char *gecos , char *user , char *buf___16 , size_t buflen___1 ) 
{ 
  register char *p ;
  register char *bp___3 ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 243
  bp___3 = buf___16;
#line 245
  if ((int )*gecos == 42) {
#line 246
    gecos ++;
  }
#line 249
  p = gecos;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if ((int )*p != 0) {
#line 249
      if ((int )*p != 44) {
#line 249
        if ((int )*p != 59) {
#line 249
          if (! ((int )*p != 37)) {
#line 249
            goto while_break;
          }
        } else {
#line 249
          goto while_break;
        }
      } else {
#line 249
        goto while_break;
      }
    } else {
#line 249
      goto while_break;
    }
#line 251
    if ((unsigned long )bp___3 >= (unsigned long )(buf___16 + (buflen___1 - 1U))) {
      {
#line 254
      sm_strlcpy(buf___16, (char const   *)user, (ssize_t )buflen___1);
      }
#line 255
      return;
    }
#line 257
    if ((int )*p == 38) {
      {
#line 260
      sm_strlcpy(bp___3, (char const   *)user, (ssize_t )((long )buflen___1 - (bp___3 - buf___16)));
#line 261
      tmp = toupper((int )*bp___3);
#line 261
      *bp___3 = (char )tmp;
#line 262
      tmp___0 = strlen((char const   *)bp___3);
#line 262
      bp___3 += tmp___0;
      }
    } else {
#line 271
      tmp___1 = bp___3;
#line 271
      bp___3 ++;
#line 271
      *tmp___1 = *p;
    }
#line 249
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  *bp___3 = (char )'\000';
#line 275
  return;
}
}
#line 292 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
static int mbdb_pw_initialize(char *arg ) 
{ 


  {
#line 296
  return (0);
}
}
#line 311 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
static int mbdb_pw_lookup(char *name , SM_MBDB_T *user ) 
{ 
  struct passwd *pw ;
  int *tmp ;

  {
  {
#line 331
  tmp = __errno_location();
#line 331
  *tmp = 0;
#line 332
  pw = getpwnam((char const   *)name);
  }
#line 333
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
#line 352
    return (67);
  }
  {
#line 355
  sm_mbdb_frompw(user, pw);
  }
#line 356
  return (0);
}
}
#line 369 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/mbdb.c"
static void mbdb_pw_terminate(void) 
{ 


  {
  {
#line 372
  endpwent();
  }
#line 373
  return;
}
}
#line 29 "../../include/sm/string.h"
bool sm_match(char const   *str , char const   *pat ) ;
#line 44 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/match.c"
bool sm_match(char const   *str , char const   *pat ) 
{ 
  bool ccnot ;
  bool ccmatch ;
  bool ccfirst ;
  char const   *ccstart ;
  char c ;
  char c2 ;
  bool tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    if ((int const   )*pat == 0) {
#line 57
      goto case_0;
    }
#line 59
    if ((int const   )*pat == 63) {
#line 59
      goto case_63;
    }
#line 65
    if ((int const   )*pat == 42) {
#line 65
      goto case_42;
    }
#line 81
    if ((int const   )*pat == 91) {
#line 81
      goto case_91;
    }
#line 128
    goto defl;
    case_0: /* CIL Label */ 
#line 58
    return ((int const   )*str == 0);
    case_63: /* CIL Label */ 
#line 60
    if ((int const   )*str == 0) {
#line 61
      return (0);
    }
#line 62
    pat ++;
#line 63
    str ++;
#line 64
    goto __Cont;
    case_42: /* CIL Label */ 
#line 66
    pat ++;
#line 67
    if ((int const   )*pat == 0) {
#line 70
      return (1);
    }
    {
#line 72
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 74
      tmp = sm_match(pat, str);
      }
#line 74
      if (tmp) {
#line 75
        return (1);
      }
#line 76
      if ((int const   )*str == 0) {
#line 77
        return (0);
      }
#line 78
      str ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    case_91: /* CIL Label */ 
#line 82
    tmp___0 = pat;
#line 82
    pat ++;
#line 82
    ccstart = tmp___0;
#line 83
    ccnot = 0;
#line 84
    if ((int const   )*pat == 33) {
#line 86
      ccnot = 1;
#line 87
      pat ++;
    }
#line 89
    ccmatch = 0;
#line 90
    ccfirst = 1;
    {
#line 91
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 93
      if ((int const   )*pat == 0) {
#line 95
        pat = ccstart;
#line 96
        goto defl;
      }
#line 98
      if ((int const   )*pat == 93) {
#line 98
        if (! ccfirst) {
#line 99
          goto while_break___1;
        }
      }
#line 100
      tmp___1 = pat;
#line 100
      pat ++;
#line 100
      c = (char )*tmp___1;
#line 101
      ccfirst = 0;
#line 102
      if ((int const   )*pat == 45) {
#line 102
        if ((int const   )*(pat + 1) != 93) {
#line 104
          pat ++;
#line 105
          if ((int const   )*pat == 0) {
#line 107
            pat = ccstart;
#line 108
            goto defl;
          }
#line 110
          tmp___2 = pat;
#line 110
          pat ++;
#line 110
          c2 = (char )*tmp___2;
#line 111
          if ((int const   )*str >= (int const   )c) {
#line 111
            if ((int const   )*str <= (int const   )c2) {
#line 112
              ccmatch = 1;
            }
          }
        } else {
#line 102
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 116
      if ((int const   )*str == (int const   )c) {
#line 117
        ccmatch = 1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 120
    if (ccmatch ^ ccnot) {
#line 122
      pat ++;
#line 123
      str ++;
    } else {
#line 126
      return (0);
    }
#line 127
    goto __Cont;
    defl: 
    switch_default: /* CIL Label */ 
#line 130
    if ((int const   )*pat != (int const   )*str) {
#line 131
      return (0);
    }
#line 132
    pat ++;
#line 133
    str ++;
#line 134
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 717 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 39 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/makebuf.c"
void sm_makebuf(SM_FILE_T *fp ) 
{ 
  register void *p ;
  register int flags ;
  size_t size ;
  int couldbetty ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;

  {
#line 48
  if (fp->f_flags & 4L) {
#line 50
    tmp = fp->f_nbuf;
#line 50
    fp->f_p = tmp;
#line 50
    fp->f_bf.smb_base = tmp;
#line 51
    fp->f_bf.smb_size = 1;
#line 52
    return;
  }
  {
#line 54
  flags = sm_whatbuf(fp, & size, & couldbetty);
#line 55
  p = sm_malloc_tagged(size, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/makebuf.c",
                       55, SmHeapGroup);
  }
#line 55
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 57
    fp->f_flags |= 4L;
#line 58
    tmp___0 = fp->f_nbuf;
#line 58
    fp->f_p = tmp___0;
#line 58
    fp->f_bf.smb_base = tmp___0;
#line 59
    fp->f_bf.smb_size = 1;
#line 60
    return;
  }
#line 62
  if (! Sm_IO_DidInit) {
    {
#line 63
    sm_init();
    }
  }
#line 64
  flags |= 512;
#line 65
  tmp___1 = (unsigned char *)p;
#line 65
  fp->f_p = tmp___1;
#line 65
  fp->f_bf.smb_base = tmp___1;
#line 66
  fp->f_bf.smb_size = (int )size;
#line 67
  if (couldbetty) {
    {
#line 67
    tmp___2 = isatty((int )fp->f_file);
    }
#line 67
    if (tmp___2) {
#line 68
      flags |= 2;
    }
  }
#line 69
  fp->f_flags |= (long )flags;
#line 70
  return;
}
}
#line 91 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/makebuf.c"
int sm_whatbuf(SM_FILE_T *fp , size_t *bufsize , int *couldbetty ) 
{ 
  struct stat st ;
  int tmp ;

  {
#line 99
  if ((int )fp->f_file < 0) {
#line 101
    *couldbetty = 0;
#line 102
    *bufsize = (size_t )4096;
#line 103
    return (8192);
  } else {
    {
#line 99
    tmp = fstat((int )fp->f_file, & st);
    }
#line 99
    if (tmp < 0) {
#line 101
      *couldbetty = 0;
#line 102
      *bufsize = (size_t )4096;
#line 103
      return (8192);
    }
  }
#line 107
  *couldbetty = (st.st_mode & 61440U) == 8192U;
#line 108
  if (st.st_blksize == 0L) {
#line 110
    *bufsize = (size_t )4096;
#line 111
    return (8192);
  }
#line 142
  if ((fp->f_flags & 2048L) == 0L) {
#line 144
    *bufsize = (size_t )st.st_blksize;
#line 145
    fp->f_blksize = (int )st.st_blksize;
  } else {
#line 148
    *bufsize = (size_t )4096;
  }
#line 149
  if ((st.st_mode & 61440U) == 32768U) {
#line 149
    if ((unsigned long )fp->f_seek == (unsigned long )(& sm_stdseek)) {
#line 151
      return (4096);
    } else {
#line 153
      return (8192);
    }
  } else {
#line 153
    return (8192);
  }
}
}
#line 122 "../../include/sm/debug.h"
bool sm_debug_loadactive(SM_DEBUG_T *debug , int level ) ;
#line 125
int sm_debug_loadlevel(SM_DEBUG_T *debug ) ;
#line 33 "../../include/sm/exc.h"
char const   SmExcTypeMagic[12] ;
#line 47
void sm_etype_printf(SM_EXC_T *exc , SM_FILE_T *stream ) ;
#line 56
char const   SmExcMagic[7] ;
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 595
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 597
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 39 "../../include/sm/heap.h"
bool sm_heap_register(void *ptr , size_t size , char *tag , int num , int group ) ;
#line 40
void sm_heap_checkptr_tagged(void *ptr , char *tag , int num ) ;
#line 41
void sm_heap_report(SM_FILE_T *stream , int verbosity ) ;
#line 95
int SmHeapMaxGroup ;
#line 98
SM_DEBUG_T SmHeapCheck ;
#line 43 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
SM_DEBUG_T SmHeapCheck  =    {SmDebugMagic, (SM_ATOMIC_UINT_T )-1, (char *)"sm_check_heap", (char *)"@(#)$Debug: sm_check_heap - check sm_malloc, sm_realloc, sm_free calls $",
    (SM_DEBUG_T *)((void *)0)};
#line 46
static int ptrhash(void *p ) ;
#line 49 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
struct sm_exc_type  const  SmHeapOutOfMemoryType  =    {SmExcTypeMagic, "F:sm.heap", "", & sm_etype_printf, "out of memory"};
#line 58 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
SM_EXC_T SmHeapOutOfMemory  =    {SmExcMagic, (size_t )0, & SmHeapOutOfMemoryType, (SM_VAL_T *)((void *)0)};
#line 93 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
void *sm_malloc_x(size_t size ) 
{ 
  void *ptr ;
  size_t tmp ;

  {
#line 99
  InCriticalSection += (unsigned int volatile   )1;
#line 100
  if (size == 0U) {
#line 100
    tmp = (size_t )1;
  } else {
#line 100
    tmp = size;
  }
  {
#line 100
  ptr = malloc(tmp);
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 101
      InCriticalSection -= (unsigned int volatile   )1;
    }
#line 101
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 103
    sm_exc_raise_x(& SmHeapOutOfMemory);
    }
  }
#line 104
  return (ptr);
}
}
#line 215 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
int SmHeapGroup  =    1;
#line 216 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
int SmHeapMaxGroup  =    1;
#line 223 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
size_t SmHeapTotal  =    (size_t )0;
#line 229 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
size_t SmHeapMaxTotal  =    (size_t )0;
#line 237 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
SM_DEBUG_T SmHeapLimit  =    {SmDebugMagic, (SM_ATOMIC_UINT_T )-1, (char *)"sm_heap_limit", (char *)"@(#)$Debug: sm_heap_limit - max # of bytes permitted in heap $",
    (SM_DEBUG_T *)((void *)0)};
#line 257 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
static SM_HEAP_ITEM_T *SmHeapTable[256]  ;
#line 266 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
static unsigned char hashtab[256]  = 
#line 266
  {      (unsigned char)161,      (unsigned char)71,      (unsigned char)77,      (unsigned char)187, 
        (unsigned char)15,      (unsigned char)229,      (unsigned char)9,      (unsigned char)176, 
        (unsigned char)221,      (unsigned char)119,      (unsigned char)239,      (unsigned char)21, 
        (unsigned char)85,      (unsigned char)138,      (unsigned char)203,      (unsigned char)86, 
        (unsigned char)102,      (unsigned char)65,      (unsigned char)80,      (unsigned char)199, 
        (unsigned char)235,      (unsigned char)32,      (unsigned char)140,      (unsigned char)96, 
        (unsigned char)224,      (unsigned char)78,      (unsigned char)126,      (unsigned char)127, 
        (unsigned char)144,      (unsigned char)0,      (unsigned char)11,      (unsigned char)179, 
        (unsigned char)64,      (unsigned char)30,      (unsigned char)120,      (unsigned char)23, 
        (unsigned char)225,      (unsigned char)226,      (unsigned char)33,      (unsigned char)50, 
        (unsigned char)205,      (unsigned char)167,      (unsigned char)130,      (unsigned char)240, 
        (unsigned char)174,      (unsigned char)99,      (unsigned char)206,      (unsigned char)73, 
        (unsigned char)231,      (unsigned char)210,      (unsigned char)189,      (unsigned char)162, 
        (unsigned char)48,      (unsigned char)93,      (unsigned char)246,      (unsigned char)54, 
        (unsigned char)213,      (unsigned char)141,      (unsigned char)135,      (unsigned char)39, 
        (unsigned char)41,      (unsigned char)192,      (unsigned char)236,      (unsigned char)193, 
        (unsigned char)157,      (unsigned char)88,      (unsigned char)95,      (unsigned char)104, 
        (unsigned char)188,      (unsigned char)63,      (unsigned char)133,      (unsigned char)177, 
        (unsigned char)234,      (unsigned char)110,      (unsigned char)158,      (unsigned char)214, 
        (unsigned char)238,      (unsigned char)131,      (unsigned char)233,      (unsigned char)91, 
        (unsigned char)125,      (unsigned char)82,      (unsigned char)94,      (unsigned char)79, 
        (unsigned char)66,      (unsigned char)92,      (unsigned char)151,      (unsigned char)45, 
        (unsigned char)252,      (unsigned char)98,      (unsigned char)26,      (unsigned char)183, 
        (unsigned char)7,      (unsigned char)191,      (unsigned char)171,      (unsigned char)106, 
        (unsigned char)145,      (unsigned char)154,      (unsigned char)251,      (unsigned char)100, 
        (unsigned char)113,      (unsigned char)5,      (unsigned char)74,      (unsigned char)62, 
        (unsigned char)76,      (unsigned char)124,      (unsigned char)14,      (unsigned char)217, 
        (unsigned char)200,      (unsigned char)75,      (unsigned char)115,      (unsigned char)190, 
        (unsigned char)103,      (unsigned char)28,      (unsigned char)198,      (unsigned char)196, 
        (unsigned char)169,      (unsigned char)219,      (unsigned char)37,      (unsigned char)118, 
        (unsigned char)150,      (unsigned char)18,      (unsigned char)152,      (unsigned char)175, 
        (unsigned char)49,      (unsigned char)136,      (unsigned char)6,      (unsigned char)142, 
        (unsigned char)89,      (unsigned char)19,      (unsigned char)243,      (unsigned char)254, 
        (unsigned char)47,      (unsigned char)137,      (unsigned char)24,      (unsigned char)166, 
        (unsigned char)180,      (unsigned char)10,      (unsigned char)40,      (unsigned char)186, 
        (unsigned char)202,      (unsigned char)46,      (unsigned char)184,      (unsigned char)67, 
        (unsigned char)148,      (unsigned char)108,      (unsigned char)181,      (unsigned char)81, 
        (unsigned char)25,      (unsigned char)241,      (unsigned char)13,      (unsigned char)139, 
        (unsigned char)58,      (unsigned char)38,      (unsigned char)84,      (unsigned char)253, 
        (unsigned char)201,      (unsigned char)12,      (unsigned char)116,      (unsigned char)17, 
        (unsigned char)195,      (unsigned char)22,      (unsigned char)112,      (unsigned char)69, 
        (unsigned char)255,      (unsigned char)43,      (unsigned char)147,      (unsigned char)222, 
        (unsigned char)111,      (unsigned char)56,      (unsigned char)194,      (unsigned char)216, 
        (unsigned char)149,      (unsigned char)244,      (unsigned char)42,      (unsigned char)173, 
        (unsigned char)232,      (unsigned char)220,      (unsigned char)249,      (unsigned char)105, 
        (unsigned char)207,      (unsigned char)51,      (unsigned char)197,      (unsigned char)242, 
        (unsigned char)72,      (unsigned char)211,      (unsigned char)208,      (unsigned char)59, 
        (unsigned char)122,      (unsigned char)230,      (unsigned char)237,      (unsigned char)170, 
        (unsigned char)165,      (unsigned char)44,      (unsigned char)68,      (unsigned char)123, 
        (unsigned char)129,      (unsigned char)245,      (unsigned char)143,      (unsigned char)101, 
        (unsigned char)8,      (unsigned char)209,      (unsigned char)215,      (unsigned char)247, 
        (unsigned char)185,      (unsigned char)57,      (unsigned char)218,      (unsigned char)53, 
        (unsigned char)114,      (unsigned char)121,      (unsigned char)3,      (unsigned char)128, 
        (unsigned char)4,      (unsigned char)204,      (unsigned char)212,      (unsigned char)146, 
        (unsigned char)2,      (unsigned char)155,      (unsigned char)83,      (unsigned char)250, 
        (unsigned char)87,      (unsigned char)29,      (unsigned char)31,      (unsigned char)159, 
        (unsigned char)60,      (unsigned char)27,      (unsigned char)107,      (unsigned char)156, 
        (unsigned char)227,      (unsigned char)182,      (unsigned char)1,      (unsigned char)61, 
        (unsigned char)36,      (unsigned char)160,      (unsigned char)109,      (unsigned char)97, 
        (unsigned char)90,      (unsigned char)20,      (unsigned char)168,      (unsigned char)132, 
        (unsigned char)223,      (unsigned char)248,      (unsigned char)70,      (unsigned char)164, 
        (unsigned char)55,      (unsigned char)172,      (unsigned char)34,      (unsigned char)52, 
        (unsigned char)163,      (unsigned char)117,      (unsigned char)35,      (unsigned char)153, 
        (unsigned char)134,      (unsigned char)16,      (unsigned char)178,      (unsigned char)228};
#line 303 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
static int ptrhash(void *p ) 
{ 
  int h ;
  unsigned long n ;
  unsigned char *cp ;
  int i ;

  {
#line 309
  if (sizeof(void *) == 4UL) {
#line 309
    if (sizeof(unsigned long ) == 4UL) {
#line 311
      n = (unsigned long )p;
#line 313
      h = (int )hashtab[n & 255UL];
#line 314
      h = (int )hashtab[(unsigned long )h ^ ((n >> 8) & 255UL)];
#line 315
      h = (int )hashtab[(unsigned long )h ^ ((n >> 16) & 255UL)];
#line 316
      h = (int )hashtab[(unsigned long )h ^ ((n >> 24) & 255UL)];
    } else {
#line 309
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 335
    cp = (unsigned char *)(& p);
#line 338
    h = 0;
#line 339
    i = 0;
    {
#line 339
    while (1) {
      while_continue: /* CIL Label */ ;
#line 339
      if (! ((unsigned long )i < sizeof(void *))) {
#line 339
        goto while_break;
      }
#line 340
      h = (int )hashtab[h ^ (int )*(cp + i)];
#line 339
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 342
  return (h);
}
}
#line 358 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
void *sm_malloc_tagged(size_t size , char *tag , int num , int group ) 
{ 
  void *ptr ;
  size_t tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  SM_ATOMIC_UINT_T tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  SM_ATOMIC_UINT_T tmp___5 ;
  size_t tmp___6 ;
  bool tmp___7 ;

  {
#line 367
  if (SmHeapCheck.debug_level >= 1U) {
#line 367
    if (! (SmHeapCheck.debug_level != 4294967295U)) {
      {
#line 367
      tmp___0 = sm_debug_loadactive(& SmHeapCheck, 1);
      }
#line 367
      if (! tmp___0) {
#line 367
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ 
#line 369
    InCriticalSection += (unsigned int volatile   )1;
#line 370
    if (size == 0U) {
#line 370
      tmp = (size_t )1;
    } else {
#line 370
      tmp = size;
    }
    {
#line 370
    ptr = malloc(tmp);
    }
    {
#line 371
    while (1) {
      while_continue: /* CIL Label */ ;
#line 371
      if (InCriticalSection > (unsigned int volatile   )0) {
#line 371
        InCriticalSection -= (unsigned int volatile   )1;
      }
#line 371
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 372
    return (ptr);
  }
#line 375
  SmXtrapCount ++;
#line 375
  if (SmXtrapDebug.debug_level == 4294967295U) {
    {
#line 375
    tmp___1 = sm_debug_loadlevel(& SmXtrapDebug);
#line 375
    tmp___2 = (SM_ATOMIC_UINT_T )tmp___1;
    }
  } else {
#line 375
    tmp___2 = SmXtrapDebug.debug_level;
  }
#line 375
  if (SmXtrapCount == tmp___2) {
#line 376
    return ((void *)0);
  }
#line 377
  if (SmHeapLimit.debug_level >= 1U) {
#line 377
    if (SmHeapLimit.debug_level != 4294967295U) {
#line 377
      goto _L___0;
    } else {
      {
#line 377
      tmp___3 = sm_debug_loadactive(& SmHeapLimit, 1);
      }
#line 377
      if (tmp___3) {
        _L___0: /* CIL Label */ 
#line 377
        if (SmHeapLimit.debug_level == 4294967295U) {
          {
#line 377
          tmp___4 = sm_debug_loadlevel(& SmHeapLimit);
#line 377
          tmp___5 = (SM_ATOMIC_UINT_T )tmp___4;
          }
        } else {
#line 377
          tmp___5 = SmHeapLimit.debug_level;
        }
#line 377
        if (tmp___5 < SmHeapTotal + size) {
#line 379
          return ((void *)0);
        }
      }
    }
  }
#line 380
  InCriticalSection += (unsigned int volatile   )1;
#line 381
  if (size == 0U) {
#line 381
    tmp___6 = (size_t )1;
  } else {
#line 381
    tmp___6 = size;
  }
  {
#line 381
  ptr = malloc(tmp___6);
  }
  {
#line 382
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 382
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 382
      InCriticalSection -= (unsigned int volatile   )1;
    }
#line 382
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 383
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
#line 383
    tmp___7 = sm_heap_register(ptr, size, tag, num, group);
    }
#line 383
    if (! tmp___7) {
      {
#line 385
      InCriticalSection += (unsigned int volatile   )1;
#line 386
      free(ptr);
      }
      {
#line 387
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 387
        if (InCriticalSection > (unsigned int volatile   )0) {
#line 387
          InCriticalSection -= (unsigned int volatile   )1;
        }
#line 387
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 388
      ptr = (void *)0;
    }
  }
#line 390
  SmHeapTotal += size;
#line 391
  if (SmHeapTotal > SmHeapMaxTotal) {
#line 392
    SmHeapMaxTotal = SmHeapTotal;
  }
#line 393
  return (ptr);
}
}
#line 412 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
void *sm_malloc_tagged_x(size_t size , char *tag , int num , int group ) 
{ 
  void *ptr ;
  size_t tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  SM_ATOMIC_UINT_T tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  SM_ATOMIC_UINT_T tmp___5 ;
  size_t tmp___6 ;
  bool tmp___7 ;

  {
#line 421
  if (SmHeapCheck.debug_level >= 1U) {
#line 421
    if (! (SmHeapCheck.debug_level != 4294967295U)) {
      {
#line 421
      tmp___0 = sm_debug_loadactive(& SmHeapCheck, 1);
      }
#line 421
      if (! tmp___0) {
#line 421
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ 
#line 423
    InCriticalSection += (unsigned int volatile   )1;
#line 424
    if (size == 0U) {
#line 424
      tmp = (size_t )1;
    } else {
#line 424
      tmp = size;
    }
    {
#line 424
    ptr = malloc(tmp);
    }
    {
#line 425
    while (1) {
      while_continue: /* CIL Label */ ;
#line 425
      if (InCriticalSection > (unsigned int volatile   )0) {
#line 425
        InCriticalSection -= (unsigned int volatile   )1;
      }
#line 425
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 426
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 427
      sm_exc_raise_x(& SmHeapOutOfMemory);
      }
    }
#line 428
    return (ptr);
  }
#line 431
  SmXtrapCount ++;
#line 431
  if (SmXtrapDebug.debug_level == 4294967295U) {
    {
#line 431
    tmp___1 = sm_debug_loadlevel(& SmXtrapDebug);
#line 431
    tmp___2 = (SM_ATOMIC_UINT_T )tmp___1;
    }
  } else {
#line 431
    tmp___2 = SmXtrapDebug.debug_level;
  }
#line 431
  if (SmXtrapCount == tmp___2) {
    {
#line 431
    sm_exc_raise_x(& SmHeapOutOfMemory);
    }
  }
#line 432
  if (SmHeapLimit.debug_level >= 1U) {
#line 432
    if (SmHeapLimit.debug_level != 4294967295U) {
#line 432
      goto _L___0;
    } else {
      {
#line 432
      tmp___3 = sm_debug_loadactive(& SmHeapLimit, 1);
      }
#line 432
      if (tmp___3) {
        _L___0: /* CIL Label */ 
#line 432
        if (SmHeapLimit.debug_level == 4294967295U) {
          {
#line 432
          tmp___4 = sm_debug_loadlevel(& SmHeapLimit);
#line 432
          tmp___5 = (SM_ATOMIC_UINT_T )tmp___4;
          }
        } else {
#line 432
          tmp___5 = SmHeapLimit.debug_level;
        }
#line 432
        if (tmp___5 < SmHeapTotal + size) {
          {
#line 435
          sm_exc_raise_x(& SmHeapOutOfMemory);
          }
        }
      }
    }
  }
#line 437
  InCriticalSection += (unsigned int volatile   )1;
#line 438
  if (size == 0U) {
#line 438
    tmp___6 = (size_t )1;
  } else {
#line 438
    tmp___6 = size;
  }
  {
#line 438
  ptr = malloc(tmp___6);
  }
  {
#line 439
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 439
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 439
      InCriticalSection -= (unsigned int volatile   )1;
    }
#line 439
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 440
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
#line 440
    tmp___7 = sm_heap_register(ptr, size, tag, num, group);
    }
#line 440
    if (! tmp___7) {
      {
#line 442
      InCriticalSection += (unsigned int volatile   )1;
#line 443
      free(ptr);
      }
      {
#line 444
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 444
        if (InCriticalSection > (unsigned int volatile   )0) {
#line 444
          InCriticalSection -= (unsigned int volatile   )1;
        }
#line 444
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 445
      ptr = (void *)0;
    }
  }
#line 447
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 448
    sm_exc_raise_x(& SmHeapOutOfMemory);
    }
  }
#line 449
  SmHeapTotal += size;
#line 450
  if (SmHeapTotal > SmHeapMaxTotal) {
#line 451
    SmHeapMaxTotal = SmHeapTotal;
  }
#line 452
  return (ptr);
}
}
#line 469 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
bool sm_heap_register(void *ptr , size_t size , char *tag , int num , int group ) 
{ 
  int i ;
  SM_HEAP_ITEM_T *hi ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 480
  if (SmHeapCheck.debug_level >= 1U) {
#line 480
    if (! (SmHeapCheck.debug_level != 4294967295U)) {
      {
#line 480
      tmp = sm_debug_loadactive(& SmHeapCheck, 1);
      }
#line 480
      if (! tmp) {
#line 481
        return (1);
      }
    }
  } else {
#line 481
    return (1);
  }
#line 482
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 482
    tmp___0 = 1;
  } else {
    {
#line 482
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c",
                482, "SM_REQUIRE(ptr != NULL) failed");
#line 482
    tmp___0 = 0;
    }
  }
  {
#line 483
  i = ptrhash(ptr);
#line 490
  hi = SmHeapTable[i];
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! ((unsigned long )hi != (unsigned long )((void *)0))) {
#line 490
      goto while_break;
    }
#line 492
    if ((unsigned long )hi->hi_ptr == (unsigned long )ptr) {
      {
#line 493
      sm_abort((char *)"sm_heap_register: ptr %p is already registered (%s:%d)", ptr,
               hi->hi_tag, hi->hi_num);
      }
    }
#line 490
    hi = hi->hi_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 497
  InCriticalSection += (unsigned int volatile   )1;
#line 498
  tmp___1 = malloc((size_t )sizeof(SM_HEAP_ITEM_T ));
#line 498
  hi = (SM_HEAP_ITEM_T *)tmp___1;
  }
  {
#line 499
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 499
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 499
      InCriticalSection -= (unsigned int volatile   )1;
    }
#line 499
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 500
  if ((unsigned long )hi == (unsigned long )((void *)0)) {
#line 501
    return (0);
  }
#line 502
  hi->hi_ptr = ptr;
#line 503
  hi->hi_size = size;
#line 504
  hi->hi_tag = tag;
#line 505
  hi->hi_num = num;
#line 506
  hi->hi_group = group;
#line 507
  hi->hi_next = SmHeapTable[i];
#line 508
  SmHeapTable[i] = hi;
#line 509
  return (1);
}
}
#line 522 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
void *sm_realloc(void *ptr , size_t size ) 
{ 
  void *newptr ;
  SM_HEAP_ITEM_T *hi ;
  SM_HEAP_ITEM_T **hp ;
  size_t tmp ;
  bool tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  SM_ATOMIC_UINT_T tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  SM_ATOMIC_UINT_T tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 530
  if (SmHeapCheck.debug_level >= 1U) {
#line 530
    if (! (SmHeapCheck.debug_level != 4294967295U)) {
      {
#line 530
      tmp___0 = sm_debug_loadactive(& SmHeapCheck, 1);
      }
#line 530
      if (! tmp___0) {
#line 530
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ 
#line 532
    InCriticalSection += (unsigned int volatile   )1;
#line 533
    if (size == 0U) {
#line 533
      tmp = (size_t )1;
    } else {
#line 533
      tmp = size;
    }
    {
#line 533
    newptr = realloc(ptr, tmp);
    }
    {
#line 534
    while (1) {
      while_continue: /* CIL Label */ ;
#line 534
      if (InCriticalSection > (unsigned int volatile   )0) {
#line 534
        InCriticalSection -= (unsigned int volatile   )1;
      }
#line 534
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 535
    return (newptr);
  }
#line 538
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 539
    tmp___1 = sm_malloc_tagged(size, (char *)"realloc", 0, SmHeapGroup);
    }
#line 539
    return (tmp___1);
  }
  {
#line 541
  tmp___2 = ptrhash(ptr);
#line 541
  hp = & SmHeapTable[tmp___2];
  }
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 541
    if (! ((unsigned long )*hp != (unsigned long )((void *)0))) {
#line 541
      goto while_break___0;
    }
#line 543
    if ((unsigned long )(*hp)->hi_ptr == (unsigned long )ptr) {
#line 545
      SmXtrapCount ++;
#line 545
      if (SmXtrapDebug.debug_level == 4294967295U) {
        {
#line 545
        tmp___3 = sm_debug_loadlevel(& SmXtrapDebug);
#line 545
        tmp___4 = (SM_ATOMIC_UINT_T )tmp___3;
        }
      } else {
#line 545
        tmp___4 = SmXtrapDebug.debug_level;
      }
#line 545
      if (SmXtrapCount == tmp___4) {
#line 546
        return ((void *)0);
      }
#line 547
      hi = *hp;
#line 548
      if (SmHeapLimit.debug_level >= 1U) {
#line 548
        if (SmHeapLimit.debug_level != 4294967295U) {
#line 548
          goto _L___0;
        } else {
          {
#line 548
          tmp___5 = sm_debug_loadactive(& SmHeapLimit, 1);
          }
#line 548
          if (tmp___5) {
            _L___0: /* CIL Label */ 
#line 548
            if (SmHeapLimit.debug_level == 4294967295U) {
              {
#line 548
              tmp___6 = sm_debug_loadlevel(& SmHeapLimit);
#line 548
              tmp___7 = (SM_ATOMIC_UINT_T )tmp___6;
              }
            } else {
#line 548
              tmp___7 = SmHeapLimit.debug_level;
            }
#line 548
            if (tmp___7 < (SmHeapTotal - hi->hi_size) + size) {
#line 552
              return ((void *)0);
            }
          }
        }
      }
#line 554
      InCriticalSection += (unsigned int volatile   )1;
#line 555
      if (size == 0U) {
#line 555
        tmp___8 = (size_t )1;
      } else {
#line 555
        tmp___8 = size;
      }
      {
#line 555
      newptr = realloc(ptr, tmp___8);
      }
      {
#line 556
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 556
        if (InCriticalSection > (unsigned int volatile   )0) {
#line 556
          InCriticalSection -= (unsigned int volatile   )1;
        }
#line 556
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 557
      if ((unsigned long )newptr == (unsigned long )((void *)0)) {
#line 558
        return ((void *)0);
      }
#line 559
      SmHeapTotal = (SmHeapTotal - hi->hi_size) + size;
#line 560
      if (SmHeapTotal > SmHeapMaxTotal) {
#line 561
        SmHeapMaxTotal = SmHeapTotal;
      }
      {
#line 562
      *hp = hi->hi_next;
#line 563
      hi->hi_ptr = newptr;
#line 564
      hi->hi_size = size;
#line 565
      tmp___9 = ptrhash(newptr);
#line 565
      hp = & SmHeapTable[tmp___9];
#line 566
      hi->hi_next = *hp;
#line 567
      *hp = hi;
      }
#line 568
      return (newptr);
    }
#line 541
    hp = & (*hp)->hi_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 571
  sm_abort((char *)"sm_realloc: bad argument (%p)", ptr);
  }
#line 573
  return ((void *)0);
}
}
#line 590 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
void *sm_realloc_x(void *ptr , size_t size ) 
{ 
  void *newptr ;
  SM_HEAP_ITEM_T *hi ;
  SM_HEAP_ITEM_T **hp ;
  size_t tmp ;
  bool tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  SM_ATOMIC_UINT_T tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  SM_ATOMIC_UINT_T tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 598
  if (SmHeapCheck.debug_level >= 1U) {
#line 598
    if (! (SmHeapCheck.debug_level != 4294967295U)) {
      {
#line 598
      tmp___0 = sm_debug_loadactive(& SmHeapCheck, 1);
      }
#line 598
      if (! tmp___0) {
#line 598
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ 
#line 600
    InCriticalSection += (unsigned int volatile   )1;
#line 601
    if (size == 0U) {
#line 601
      tmp = (size_t )1;
    } else {
#line 601
      tmp = size;
    }
    {
#line 601
    newptr = realloc(ptr, tmp);
    }
    {
#line 602
    while (1) {
      while_continue: /* CIL Label */ ;
#line 602
      if (InCriticalSection > (unsigned int volatile   )0) {
#line 602
        InCriticalSection -= (unsigned int volatile   )1;
      }
#line 602
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 603
    if ((unsigned long )newptr == (unsigned long )((void *)0)) {
      {
#line 604
      sm_exc_raise_x(& SmHeapOutOfMemory);
      }
    }
#line 605
    return (newptr);
  }
#line 608
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 609
    tmp___1 = sm_malloc_tagged_x(size, (char *)"realloc", 0, SmHeapGroup);
    }
#line 609
    return (tmp___1);
  }
  {
#line 611
  tmp___2 = ptrhash(ptr);
#line 611
  hp = & SmHeapTable[tmp___2];
  }
  {
#line 611
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 611
    if (! ((unsigned long )*hp != (unsigned long )((void *)0))) {
#line 611
      goto while_break___0;
    }
#line 613
    if ((unsigned long )(*hp)->hi_ptr == (unsigned long )ptr) {
#line 615
      SmXtrapCount ++;
#line 615
      if (SmXtrapDebug.debug_level == 4294967295U) {
        {
#line 615
        tmp___3 = sm_debug_loadlevel(& SmXtrapDebug);
#line 615
        tmp___4 = (SM_ATOMIC_UINT_T )tmp___3;
        }
      } else {
#line 615
        tmp___4 = SmXtrapDebug.debug_level;
      }
#line 615
      if (SmXtrapCount == tmp___4) {
        {
#line 615
        sm_exc_raise_x(& SmHeapOutOfMemory);
        }
      }
#line 616
      hi = *hp;
#line 617
      if (SmHeapLimit.debug_level >= 1U) {
#line 617
        if (SmHeapLimit.debug_level != 4294967295U) {
#line 617
          goto _L___0;
        } else {
          {
#line 617
          tmp___5 = sm_debug_loadactive(& SmHeapLimit, 1);
          }
#line 617
          if (tmp___5) {
            _L___0: /* CIL Label */ 
#line 617
            if (SmHeapLimit.debug_level == 4294967295U) {
              {
#line 617
              tmp___6 = sm_debug_loadlevel(& SmHeapLimit);
#line 617
              tmp___7 = (SM_ATOMIC_UINT_T )tmp___6;
              }
            } else {
#line 617
              tmp___7 = SmHeapLimit.debug_level;
            }
#line 617
            if (tmp___7 < (SmHeapTotal - hi->hi_size) + size) {
              {
#line 621
              sm_exc_raise_x(& SmHeapOutOfMemory);
              }
            }
          }
        }
      }
#line 623
      InCriticalSection += (unsigned int volatile   )1;
#line 624
      if (size == 0U) {
#line 624
        tmp___8 = (size_t )1;
      } else {
#line 624
        tmp___8 = size;
      }
      {
#line 624
      newptr = realloc(ptr, tmp___8);
      }
      {
#line 625
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 625
        if (InCriticalSection > (unsigned int volatile   )0) {
#line 625
          InCriticalSection -= (unsigned int volatile   )1;
        }
#line 625
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 626
      if ((unsigned long )newptr == (unsigned long )((void *)0)) {
        {
#line 627
        sm_exc_raise_x(& SmHeapOutOfMemory);
        }
      }
#line 628
      SmHeapTotal = (SmHeapTotal - hi->hi_size) + size;
#line 629
      if (SmHeapTotal > SmHeapMaxTotal) {
#line 630
        SmHeapMaxTotal = SmHeapTotal;
      }
      {
#line 631
      *hp = hi->hi_next;
#line 632
      hi->hi_ptr = newptr;
#line 633
      hi->hi_size = size;
#line 634
      tmp___9 = ptrhash(newptr);
#line 634
      hp = & SmHeapTable[tmp___9];
#line 635
      hi->hi_next = *hp;
#line 636
      *hp = hi;
      }
#line 637
      return (newptr);
    }
#line 611
    hp = & (*hp)->hi_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 640
  sm_abort((char *)"sm_realloc_x: bad argument (%p)", ptr);
  }
#line 642
  return ((void *)0);
}
}
#line 657 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
void sm_free_tagged(void *ptr , char *tag , int num ) 
{ 
  SM_HEAP_ITEM_T **hp ;
  bool tmp ;
  int tmp___0 ;
  SM_HEAP_ITEM_T *hi ;
  char *__cil_tmp8 ;

  {
#line 665
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 666
    return;
  }
#line 667
  if (SmHeapCheck.debug_level >= 1U) {
#line 667
    if (! (SmHeapCheck.debug_level != 4294967295U)) {
      {
#line 667
      tmp = sm_debug_loadactive(& SmHeapCheck, 1);
      }
#line 667
      if (! tmp) {
#line 667
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 669
    InCriticalSection += (unsigned int volatile   )1;
#line 670
    free(ptr);
    }
    {
#line 671
    while (1) {
      while_continue: /* CIL Label */ ;
#line 671
      if (InCriticalSection > (unsigned int volatile   )0) {
#line 671
        InCriticalSection -= (unsigned int volatile   )1;
      }
#line 671
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 672
    return;
  }
  {
#line 674
  tmp___0 = ptrhash(ptr);
#line 674
  hp = & SmHeapTable[tmp___0];
  }
  {
#line 674
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 674
    if (! ((unsigned long )*hp != (unsigned long )((void *)0))) {
#line 674
      goto while_break___0;
    }
#line 676
    if ((unsigned long )(*hp)->hi_ptr == (unsigned long )ptr) {
      {
#line 678
      hi = *hp;
#line 680
      *hp = hi->hi_next;
#line 692
      memset(ptr, 0, hi->hi_size);
#line 693
      SmHeapTotal -= hi->hi_size;
#line 694
      InCriticalSection += (unsigned int volatile   )1;
#line 695
      free(ptr);
#line 696
      free((void *)hi);
      }
      {
#line 697
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 697
        if (InCriticalSection > (unsigned int volatile   )0) {
#line 697
          InCriticalSection -= (unsigned int volatile   )1;
        }
#line 697
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 698
      return;
    }
#line 674
    hp = & (*hp)->hi_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 701
  sm_abort((char *)"sm_free: bad argument (%p) (%s:%d)", ptr, tag, num);
  }
}
}
#line 719 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
void sm_heap_checkptr_tagged(void *ptr , char *tag , int num ) 
{ 
  SM_HEAP_ITEM_T *hp ;
  bool tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 727
  if (SmHeapCheck.debug_level >= 1U) {
#line 727
    if (! (SmHeapCheck.debug_level != 4294967295U)) {
      {
#line 727
      tmp = sm_debug_loadactive(& SmHeapCheck, 1);
      }
#line 727
      if (! tmp) {
#line 728
        return;
      }
    }
  } else {
#line 728
    return;
  }
#line 729
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 730
    return;
  }
  {
#line 731
  tmp___0 = ptrhash(ptr);
#line 731
  hp = SmHeapTable[tmp___0];
  }
  {
#line 731
  while (1) {
    while_continue: /* CIL Label */ ;
#line 731
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
#line 731
      goto while_break;
    }
#line 733
    if ((unsigned long )hp->hi_ptr == (unsigned long )ptr) {
#line 734
      return;
    }
#line 731
    hp = hp->hi_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 736
  sm_abort((char *)"sm_heap_checkptr(%p): bad ptr (%s:%d)", ptr, tag, num);
  }
}
}
#line 750 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/heap.c"
void sm_heap_report(SM_FILE_T *stream , int verbosity ) 
{ 
  int i ;
  unsigned long group0total ;
  unsigned long group1total ;
  unsigned long otherstotal ;
  unsigned long grandtotal ;
  bool tmp ;
  SM_HEAP_ITEM_T *hi ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 758
  if (SmHeapCheck.debug_level >= 1U) {
#line 758
    if (SmHeapCheck.debug_level != 4294967295U) {
#line 758
      goto _L;
    } else {
      {
#line 758
      tmp = sm_debug_loadactive(& SmHeapCheck, 1);
      }
#line 758
      if (tmp) {
        _L: /* CIL Label */ 
#line 758
        if (verbosity <= 0) {
#line 759
          return;
        }
      } else {
#line 759
        return;
      }
    }
  } else {
#line 759
    return;
  }
#line 760
  grandtotal = 0UL;
#line 760
  otherstotal = grandtotal;
#line 760
  group1total = otherstotal;
#line 760
  group0total = group1total;
#line 761
  i = 0;
  {
#line 761
  while (1) {
    while_continue: /* CIL Label */ ;
#line 761
    if (! ((unsigned long )i < sizeof(SmHeapTable) / sizeof(SmHeapTable[0]))) {
#line 761
      goto while_break;
    }
#line 763
    hi = SmHeapTable[i];
    {
#line 765
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 765
      if (! ((unsigned long )hi != (unsigned long )((void *)0))) {
#line 765
        goto while_break___0;
      }
#line 767
      if (verbosity > 2) {
#line 767
        goto _L___0;
      } else
#line 767
      if (verbosity > 1) {
#line 767
        if (hi->hi_group != 0) {
          _L___0: /* CIL Label */ 
          {
#line 770
          sm_io_fprintf(stream, -2, "%4d %*lx %7lu bytes", hi->hi_group, (int )sizeof(void *) * 2,
                        (long )hi->hi_ptr, (unsigned long )hi->hi_size);
          }
#line 776
          if ((unsigned long )hi->hi_tag != (unsigned long )((void *)0)) {
            {
#line 778
            sm_io_fprintf(stream, -2, "  %s", hi->hi_tag);
            }
#line 781
            if (hi->hi_num) {
              {
#line 783
              sm_io_fprintf(stream, -2, ":%d", hi->hi_num);
              }
            }
          }
          {
#line 789
          sm_io_fprintf(stream, -2, "\n");
          }
        }
      }
      {
#line 793
      if (hi->hi_group == 0) {
#line 793
        goto case_0;
      }
#line 796
      if (hi->hi_group == 1) {
#line 796
        goto case_1;
      }
#line 799
      goto switch_default;
      case_0: /* CIL Label */ 
#line 794
      group0total += (unsigned long )hi->hi_size;
#line 795
      goto switch_break;
      case_1: /* CIL Label */ 
#line 797
      group1total += (unsigned long )hi->hi_size;
#line 798
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 800
      otherstotal += (unsigned long )hi->hi_size;
#line 801
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 803
      grandtotal += (unsigned long )hi->hi_size;
#line 804
      hi = hi->hi_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 761
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 807
  sm_io_fprintf(stream, -2, "heap max=%lu, total=%lu, ", (unsigned long )SmHeapMaxTotal,
                grandtotal);
#line 810
  sm_io_fprintf(stream, -2, "group 0=%lu, group 1=%lu, others=%lu\n", group0total,
                group1total, otherstotal);
  }
#line 813
  if (grandtotal != (unsigned long )SmHeapTotal) {
    {
#line 815
    sm_io_fprintf(stream, -2, "BUG => SmHeapTotal: got %lu, expected %lu\n", (unsigned long )SmHeapTotal,
                  grandtotal);
    }
  }
#line 819
  return;
}
}
#line 283 "../../include/sm/io.h"
int sm_io_getc(SM_FILE_T *fp , int timeout ) ;
#line 39 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/get.c"
int sm_io_getc(SM_FILE_T *fp , int timeout ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 44
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 44
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 44
      tmp = 1;
    } else {
      {
#line 44
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/get.c",
                  44, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 44
      tmp = 0;
      }
    }
  } else {
    {
#line 44
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/get.c",
                44, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 44
    tmp = 0;
    }
  }
#line 45
  (fp->f_r) --;
#line 45
  if (fp->f_r < 0) {
    {
#line 45
    tmp___0 = sm_rget(fp, timeout);
#line 45
    tmp___2 = tmp___0;
    }
  } else {
#line 45
    tmp___1 = fp->f_p;
#line 45
    (fp->f_p) ++;
#line 45
    tmp___2 = (int )*tmp___1;
  }
#line 45
  return (tmp___2);
}
}
#line 304 "../../include/sm/io.h"
size_t sm_io_write(SM_FILE_T *fp , int timeout , void const   *buf___16 , size_t size ) ;
#line 38 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fwrite.c"
size_t sm_io_write(SM_FILE_T *fp , int timeout , void const   *buf___16 , size_t size ) 
{ 
  struct sm_uio uio ;
  struct sm_iov iov ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 48
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 48
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 48
      tmp = 1;
    } else {
      {
#line 48
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fwrite.c",
                  48, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 48
      tmp = 0;
      }
    }
  } else {
    {
#line 48
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fwrite.c",
                48, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 48
    tmp = 0;
    }
  }
#line 50
  if ((unsigned long )fp->f_write == (unsigned long )((void *)0)) {
    {
#line 52
    tmp___0 = __errno_location();
#line 52
    *tmp___0 = 19;
    }
#line 53
    return ((size_t )0);
  }
  {
#line 56
  iov.iov_base = (void *)buf___16;
#line 57
  iov.iov_len = size;
#line 57
  uio.uio_resid = (int )iov.iov_len;
#line 58
  uio.uio_iov = & iov;
#line 59
  uio.uio_iovcnt = 1;
#line 62
  tmp___1 = sm_fvwrite(fp, timeout, & uio);
  }
#line 62
  if (tmp___1 == 0) {
#line 63
    return (size);
  }
#line 66
  return (size - (size_t )uio.uio_resid);
}
}
#line 22 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/glue.h"
struct sm_glue smglue ;
#line 33 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fwalk.c"
int sm_fwalk(int (*function)(SM_FILE_T * , int * ) , int *timeout ) 
{ 
  register SM_FILE_T *fp ;
  register int n ;
  register int ret ;
  register struct sm_glue *g ;
  int fptimeout ;
  int tmp ;

  {
#line 43
  ret = 0;
#line 44
  g = & smglue;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! ((unsigned long )g != (unsigned long )((void *)0))) {
#line 44
      goto while_break;
    }
#line 46
    fp = g->gl_iobs;
#line 46
    n = g->gl_niobs;
    {
#line 46
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 46
      n --;
#line 46
      if (! (n >= 0)) {
#line 46
        goto while_break___0;
      }
#line 48
      if (fp->f_flags != 0L) {
#line 50
        if (*timeout == -2) {
#line 51
          fptimeout = fp->f_timeout;
        } else {
#line 53
          fptimeout = *timeout;
        }
#line 54
        if (fptimeout == 0) {
#line 55
          goto __Cont;
        }
        {
#line 56
        tmp = (*function)(fp, & fptimeout);
#line 56
        ret |= tmp;
        }
      }
      __Cont: /* CIL Label */ 
#line 46
      fp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 44
    g = g->gl_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return (ret);
}
}
#line 55 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fvwrite.c"
int sm_fvwrite(SM_FILE_T *fp , int timeout , struct sm_uio *uio ) 
{ 
  register size_t len___0 ;
  register char *p ;
  register struct sm_iov *iov ;
  register int w ;
  register int s ;
  char *nl ;
  int nlknown ;
  int nldist ;
  int fd ;
  struct timeval to ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int ret ;
  int tmp___2 ;
  int ret___0 ;
  int tmp___3 ;
  int *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  struct timeval sm_io_to_before ;
  struct timeval sm_io_to_after ;
  struct timeval sm_io_to_diff ;
  struct timeval sm_io_to ;
  int sm_io_to_sel ;
  fd_set sm_io_to_mask ;
  fd_set sm_io_x_mask ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t blen ;
  unsigned char *tbase ;
  int tsize ;
  void *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  int *tmp___24 ;
  struct timeval sm_io_to_before___0 ;
  struct timeval sm_io_to_after___0 ;
  struct timeval sm_io_to_diff___0 ;
  struct timeval sm_io_to___0 ;
  int sm_io_to_sel___0 ;
  fd_set sm_io_to_mask___0 ;
  fd_set sm_io_x_mask___0 ;
  int *tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;
  int __d0___1 ;
  int __d1___1 ;
  int __d0___2 ;
  int __d1___2 ;
  int tmp___29 ;
  int *tmp___30 ;
  int *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  void *tmp___35 ;
  int *tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  int *tmp___39 ;
  int *tmp___40 ;
  struct timeval sm_io_to_before___1 ;
  struct timeval sm_io_to_after___1 ;
  struct timeval sm_io_to_diff___1 ;
  struct timeval sm_io_to___1 ;
  int sm_io_to_sel___1 ;
  fd_set sm_io_to_mask___1 ;
  fd_set sm_io_x_mask___1 ;
  int *tmp___41 ;
  int *tmp___42 ;
  int *tmp___43 ;
  int *tmp___44 ;
  int __d0___3 ;
  int __d1___3 ;
  int __d0___4 ;
  int __d1___4 ;
  int tmp___45 ;
  int *tmp___46 ;
  int *tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;

  {
#line 70
  if (uio->uio_resid == 0) {
#line 71
    return (0);
  }
#line 74
  if ((fp->f_flags & 32L) == 0L) {
#line 74
    goto _L;
  } else
#line 74
  if ((unsigned long )fp->f_bf.smb_base == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 74
    tmp___0 = sm_wsetup(fp);
    }
#line 74
    if (tmp___0) {
      {
#line 76
      tmp = __errno_location();
#line 76
      *tmp = 9;
      }
#line 77
      return (-1);
    }
  }
  {
#line 80
  fd = sm_io_getinfo(fp, 3, (void *)0);
  }
#line 80
  if (fd == -1) {
    {
#line 80
    tmp___1 = __errno_location();
#line 80
    *tmp___1 = 0;
    }
  }
#line 80
  if (timeout == -2) {
#line 80
    timeout = fp->f_timeout;
  }
#line 80
  if (timeout == 0) {
#line 80
    to.tv_sec = (__time_t )0;
#line 80
    to.tv_usec = (__suseconds_t )0;
  } else
#line 80
  if (timeout == -1) {
#line 80
    to.tv_sec = (__time_t )0;
#line 80
    to.tv_usec = (__suseconds_t )0;
  } else {
#line 80
    to.tv_sec = (__time_t )(timeout / 1000);
#line 80
    to.tv_usec = ((__time_t )timeout - to.tv_sec * 1000L) * 1000L;
  }
#line 80
  if (timeout == -1) {
#line 80
    if (fp->f_timeoutstate == 1) {
#line 80
      if (fd != -1) {
        {
#line 80
        ret = fcntl(fd, 3, 0);
        }
#line 80
        if (ret == -1) {
#line 80
          return (-1);
        } else {
          {
#line 80
          tmp___2 = fcntl(fd, 4, ret & -2049);
          }
#line 80
          if (tmp___2 == -1) {
#line 80
            return (-1);
          }
        }
#line 80
        fp->f_timeoutstate = 0;
#line 80
        if ((unsigned long )fp->f_modefp != (unsigned long )((void *)0)) {
#line 80
          (fp->f_modefp)->f_timeoutstate = 0;
        }
      }
    }
  } else
#line 80
  if (fp->f_timeoutstate == 0) {
#line 80
    if (fd != -1) {
      {
#line 80
      ret___0 = fcntl(fd, 3, 0);
      }
#line 80
      if (ret___0 == -1) {
#line 80
        return (-1);
      } else {
        {
#line 80
        tmp___3 = fcntl(fd, 4, ret___0 | 2048);
        }
#line 80
        if (tmp___3 == -1) {
#line 80
          return (-1);
        }
      }
#line 80
      fp->f_timeoutstate = 1;
#line 80
      if ((unsigned long )fp->f_modefp != (unsigned long )((void *)0)) {
#line 80
        (fp->f_modefp)->f_timeoutstate = 1;
      }
    }
  }
#line 82
  iov = uio->uio_iov;
#line 83
  p = (char *)iov->iov_base;
#line 84
  len___0 = iov->iov_len;
#line 85
  iov ++;
#line 86
  if (fp->f_flags & 4L) {
    {
#line 89
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 91
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 91
        if (! (len___0 == 0U)) {
#line 91
          goto while_break___0;
        }
#line 91
        p = (char *)iov->iov_base;
#line 91
        len___0 = iov->iov_len;
#line 91
        iov ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 92
      tmp___4 = __errno_location();
#line 92
      *tmp___4 = 0;
      }
#line 93
      if (len___0 < 4096U) {
#line 93
        tmp___5 = len___0;
      } else {
#line 93
        tmp___5 = (size_t )4096;
      }
      {
#line 93
      w = (*(fp->f_write))(fp, (char const   *)p, tmp___5);
      }
#line 94
      if (w <= 0) {
#line 96
        if (w == 0) {
          {
#line 96
          tmp___6 = __errno_location();
          }
#line 96
          if (*tmp___6 == 0) {
#line 97
            goto while_break;
          }
        }
#line 98
        if (fd < 0) {
#line 99
          goto err;
        } else
#line 98
        if (w < 0) {
          {
#line 98
          tmp___7 = __errno_location();
          }
#line 98
          if (*tmp___7 != 11) {
            {
#line 98
            tmp___8 = __errno_location();
            }
#line 98
            if (*tmp___8 != 11) {
#line 99
              goto err;
            } else {
#line 98
              goto _L___1;
            }
          } else {
#line 98
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 98
        if (timeout == -1) {
#line 99
          goto err;
        }
        {
#line 102
        tmp___9 = __errno_location();
#line 102
        *tmp___9 = 0;
        }
#line 102
        if (timeout == -2) {
#line 102
          timeout = fp->f_timeout;
        }
#line 102
        if (timeout == 0) {
          {
#line 102
          tmp___10 = __errno_location();
#line 102
          *tmp___10 = 11;
          }
#line 102
          return (-1);
        } else
#line 102
        if (timeout == -1) {
          {
#line 102
          tmp___11 = __errno_location();
#line 102
          *tmp___11 = 22;
          }
#line 102
          return (-1);
        } else {
#line 102
          sm_io_to.tv_sec = (__time_t )(timeout / 1000);
#line 102
          sm_io_to.tv_usec = ((__time_t )timeout - sm_io_to.tv_sec * 1000L) * 1000L;
        }
#line 102
        if (fd >= 1024) {
          {
#line 102
          tmp___12 = __errno_location();
#line 102
          *tmp___12 = 22;
          }
#line 102
          return (-1);
        }
        {
#line 102
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 102
          __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& sm_io_to_mask.__fds_bits[0]): "memory");
#line 102
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 102
        __asm__  volatile   ("btsl %1,%0": "=m" (sm_io_to_mask.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                             "memory");
        {
#line 102
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 102
          __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& sm_io_x_mask.__fds_bits[0]): "memory");
#line 102
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 102
        __asm__  volatile   ("btsl %1,%0": "=m" (sm_io_x_mask.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 102
        tmp___13 = gettimeofday((struct timeval */* __restrict  */)(& sm_io_to_before),
                                (__timezone_ptr_t )((void *)0));
        }
#line 102
        if (tmp___13 < 0) {
#line 102
          return (-1);
        }
        {
#line 102
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 102
          sm_io_to_sel = select(fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& sm_io_to_mask),
                                (fd_set */* __restrict  */)(& sm_io_x_mask), (struct timeval */* __restrict  */)(& sm_io_to));
          }
#line 102
          if (sm_io_to_sel < 0) {
            {
#line 102
            tmp___14 = __errno_location();
            }
#line 102
            if (! (*tmp___14 == 4)) {
#line 102
              goto while_break___3;
            }
          } else {
#line 102
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 102
        if (sm_io_to_sel < 0) {
#line 102
          return (-1);
        } else
#line 102
        if (sm_io_to_sel == 0) {
          {
#line 102
          tmp___15 = __errno_location();
#line 102
          *tmp___15 = 11;
          }
#line 102
          return (-1);
        }
        {
#line 102
        tmp___16 = gettimeofday((struct timeval */* __restrict  */)(& sm_io_to_after),
                                (__timezone_ptr_t )((void *)0));
        }
#line 102
        if (tmp___16 < 0) {
#line 102
          return (-1);
        }
        {
#line 102
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 102
          sm_io_to_diff.tv_sec = sm_io_to_after.tv_sec - sm_io_to_before.tv_sec;
#line 102
          sm_io_to_diff.tv_usec = sm_io_to_after.tv_usec - sm_io_to_before.tv_usec;
#line 102
          if (sm_io_to_diff.tv_usec < 0L) {
#line 102
            (sm_io_to_diff.tv_sec) --;
#line 102
            sm_io_to_diff.tv_usec += 1000000L;
          }
#line 102
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 102
        timeout = (int )((__time_t )timeout - sm_io_to_diff.tv_sec * 1000L);
#line 102
        timeout = (int )((__suseconds_t )timeout - sm_io_to_diff.tv_usec / 1000L);
#line 102
        if (timeout < 0) {
#line 102
          timeout = 0;
        }
#line 103
        w = 0;
      } else {
#line 107
        p += w;
#line 108
        len___0 -= (size_t )w;
      }
#line 89
      tmp___17 = uio->uio_resid - w;
#line 89
      uio->uio_resid = tmp___17;
#line 89
      if (! (tmp___17 != 0)) {
#line 89
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 112
  if ((fp->f_flags & 2L) == 0L) {
    {
#line 127
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 129
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 129
        if (! (len___0 == 0U)) {
#line 129
          goto while_break___6;
        }
#line 129
        p = (char *)iov->iov_base;
#line 129
        len___0 = iov->iov_len;
#line 129
        iov ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 130
      if ((fp->f_flags & 67584L) == 67584L) {
#line 130
        goto _L___2;
      } else
#line 130
      if ((fp->f_flags & 8L) != 0L) {
        _L___2: /* CIL Label */ 
#line 130
        if ((size_t )fp->f_w < len___0) {
#line 134
          blen = (size_t )(fp->f_p - fp->f_bf.smb_base);
#line 139
          tsize = fp->f_bf.smb_size;
          {
#line 140
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 142
            tsize = (tsize << 1) + 1;
#line 140
            if (! ((size_t )tsize < blen + len___0)) {
#line 140
              goto while_break___7;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 144
          tmp___18 = sm_realloc((void *)fp->f_bf.smb_base, (size_t )(tsize + 1));
#line 144
          tbase = (unsigned char *)tmp___18;
          }
#line 146
          if ((unsigned long )tbase == (unsigned long )((void *)0)) {
            {
#line 148
            tmp___19 = __errno_location();
#line 148
            *tmp___19 = 12;
            }
#line 149
            goto err;
          }
#line 151
          fp->f_w += tsize - fp->f_bf.smb_size;
#line 152
          fp->f_bf.smb_base = tbase;
#line 153
          fp->f_bf.smb_size = tsize;
#line 154
          fp->f_p = tbase + blen;
        }
      }
      {
#line 156
      w = fp->f_w;
#line 157
      tmp___20 = __errno_location();
#line 157
      *tmp___20 = 0;
      }
#line 158
      if (fp->f_flags & 2048L) {
#line 160
        if (len___0 < (size_t )w) {
#line 161
          w = (int )len___0;
        }
        {
#line 162
        memcpy((void */* __restrict  */)((void *)fp->f_p), (void const   */* __restrict  */)((void *)p),
               (size_t )w);
#line 163
        fp->f_w -= w;
#line 164
        fp->f_p += w;
#line 165
        w = (int )len___0;
        }
      } else
#line 167
      if ((unsigned long )fp->f_p > (unsigned long )fp->f_bf.smb_base) {
#line 167
        if (len___0 > (size_t )w) {
          {
#line 171
          memcpy((void */* __restrict  */)((void *)fp->f_p), (void const   */* __restrict  */)((void *)p),
                 (size_t )w);
#line 172
          fp->f_p += w;
#line 173
          tmp___21 = sm_flush(fp, & timeout);
          }
#line 173
          if (tmp___21) {
#line 174
            goto err;
          }
        } else {
#line 167
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
#line 176
        w = fp->f_bf.smb_size;
#line 176
        if (len___0 >= (size_t )w) {
          {
#line 179
          w = (*(fp->f_write))(fp, (char const   *)p, (size_t )w);
          }
#line 180
          if (w <= 0) {
#line 182
            if (w == 0) {
              {
#line 182
              tmp___22 = __errno_location();
              }
#line 182
              if (*tmp___22 == 0) {
#line 183
                goto while_break___5;
              }
            }
#line 184
            if (fd < 0) {
#line 185
              goto err;
            } else
#line 184
            if (w < 0) {
              {
#line 184
              tmp___23 = __errno_location();
              }
#line 184
              if (*tmp___23 != 11) {
                {
#line 184
                tmp___24 = __errno_location();
                }
#line 184
                if (*tmp___24 != 11) {
#line 185
                  goto err;
                } else {
#line 184
                  goto _L___4;
                }
              } else {
#line 184
                goto _L___4;
              }
            } else
            _L___4: /* CIL Label */ 
#line 184
            if (timeout == -1) {
#line 185
              goto err;
            }
            {
#line 188
            tmp___25 = __errno_location();
#line 188
            *tmp___25 = 0;
            }
#line 188
            if (timeout == -2) {
#line 188
              timeout = fp->f_timeout;
            }
#line 188
            if (timeout == 0) {
              {
#line 188
              tmp___26 = __errno_location();
#line 188
              *tmp___26 = 11;
              }
#line 188
              return (-1);
            } else
#line 188
            if (timeout == -1) {
              {
#line 188
              tmp___27 = __errno_location();
#line 188
              *tmp___27 = 22;
              }
#line 188
              return (-1);
            } else {
#line 188
              sm_io_to___0.tv_sec = (__time_t )(timeout / 1000);
#line 188
              sm_io_to___0.tv_usec = ((__time_t )timeout - sm_io_to___0.tv_sec * 1000L) * 1000L;
            }
#line 188
            if (fd >= 1024) {
              {
#line 188
              tmp___28 = __errno_location();
#line 188
              *tmp___28 = 22;
              }
#line 188
              return (-1);
            }
            {
#line 188
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 188
              __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___1), "=D" (__d1___1): "a" (0),
                                   "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& sm_io_to_mask___0.__fds_bits[0]): "memory");
#line 188
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 188
            __asm__  volatile   ("btsl %1,%0": "=m" (sm_io_to_mask___0.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                                 "memory");
            {
#line 188
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 188
              __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___2), "=D" (__d1___2): "a" (0),
                                   "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& sm_io_x_mask___0.__fds_bits[0]): "memory");
#line 188
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
            {
#line 188
            __asm__  volatile   ("btsl %1,%0": "=m" (sm_io_x_mask___0.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                                 "memory");
#line 188
            tmp___29 = gettimeofday((struct timeval */* __restrict  */)(& sm_io_to_before___0),
                                    (__timezone_ptr_t )((void *)0));
            }
#line 188
            if (tmp___29 < 0) {
#line 188
              return (-1);
            }
            {
#line 188
            while (1) {
              while_continue___10: /* CIL Label */ ;
              {
#line 188
              sm_io_to_sel___0 = select(fd + 1, (fd_set */* __restrict  */)((void *)0),
                                        (fd_set */* __restrict  */)(& sm_io_to_mask___0),
                                        (fd_set */* __restrict  */)(& sm_io_x_mask___0),
                                        (struct timeval */* __restrict  */)(& sm_io_to___0));
              }
#line 188
              if (sm_io_to_sel___0 < 0) {
                {
#line 188
                tmp___30 = __errno_location();
                }
#line 188
                if (! (*tmp___30 == 4)) {
#line 188
                  goto while_break___10;
                }
              } else {
#line 188
                goto while_break___10;
              }
            }
            while_break___10: /* CIL Label */ ;
            }
#line 188
            if (sm_io_to_sel___0 < 0) {
#line 188
              return (-1);
            } else
#line 188
            if (sm_io_to_sel___0 == 0) {
              {
#line 188
              tmp___31 = __errno_location();
#line 188
              *tmp___31 = 11;
              }
#line 188
              return (-1);
            }
            {
#line 188
            tmp___32 = gettimeofday((struct timeval */* __restrict  */)(& sm_io_to_after___0),
                                    (__timezone_ptr_t )((void *)0));
            }
#line 188
            if (tmp___32 < 0) {
#line 188
              return (-1);
            }
            {
#line 188
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 188
              sm_io_to_diff___0.tv_sec = sm_io_to_after___0.tv_sec - sm_io_to_before___0.tv_sec;
#line 188
              sm_io_to_diff___0.tv_usec = sm_io_to_after___0.tv_usec - sm_io_to_before___0.tv_usec;
#line 188
              if (sm_io_to_diff___0.tv_usec < 0L) {
#line 188
                (sm_io_to_diff___0.tv_sec) --;
#line 188
                sm_io_to_diff___0.tv_usec += 1000000L;
              }
#line 188
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 188
            timeout = (int )((__time_t )timeout - sm_io_to_diff___0.tv_sec * 1000L);
#line 188
            timeout = (int )((__suseconds_t )timeout - sm_io_to_diff___0.tv_usec / 1000L);
#line 188
            if (timeout < 0) {
#line 188
              timeout = 0;
            }
#line 189
            w = 0;
          }
        } else {
          {
#line 195
          w = (int )len___0;
#line 196
          memcpy((void */* __restrict  */)((void *)fp->f_p), (void const   */* __restrict  */)((void *)p),
                 (size_t )w);
#line 197
          fp->f_w -= w;
#line 198
          fp->f_p += w;
          }
        }
      }
#line 200
      p += w;
#line 201
      len___0 -= (size_t )w;
#line 127
      tmp___33 = uio->uio_resid - w;
#line 127
      uio->uio_resid = tmp___33;
#line 127
      if (! (tmp___33 != 0)) {
#line 127
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 204
    if ((fp->f_flags & 8L) != 0L) {
      {
#line 204
      tmp___34 = sm_flush(fp, & timeout);
      }
#line 204
      if (tmp___34) {
#line 205
        goto err;
      }
    }
  } else {
#line 217
    nlknown = 0;
#line 218
    nldist = 0;
    {
#line 219
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 221
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 221
        if (! (len___0 == 0U)) {
#line 221
          goto while_break___13;
        }
#line 221
        nlknown = 0;
#line 221
        p = (char *)iov->iov_base;
#line 221
        len___0 = iov->iov_len;
#line 221
        iov ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 222
      if (! nlknown) {
        {
#line 224
        tmp___35 = memchr((void const   *)((void *)p), '\n', len___0);
#line 224
        nl = (char *)tmp___35;
        }
#line 225
        if ((unsigned long )nl != (unsigned long )((void *)0)) {
#line 225
          nldist = (int )((nl + 1) - p);
        } else {
#line 225
          nldist = (int )(len___0 + 1U);
        }
#line 226
        nlknown = 1;
      }
#line 228
      if (len___0 < (size_t )nldist) {
#line 228
        s = (int )len___0;
      } else {
#line 228
        s = (int )((size_t )nldist);
      }
      {
#line 229
      w = fp->f_w + fp->f_bf.smb_size;
#line 230
      tmp___36 = __errno_location();
#line 230
      *tmp___36 = 0;
      }
#line 231
      if ((unsigned long )fp->f_p > (unsigned long )fp->f_bf.smb_base) {
#line 231
        if (s > w) {
          {
#line 233
          memcpy((void */* __restrict  */)((void *)fp->f_p), (void const   */* __restrict  */)((void *)p),
                 (size_t )w);
#line 235
          fp->f_p += w;
#line 236
          tmp___37 = sm_flush(fp, & timeout);
          }
#line 236
          if (tmp___37) {
#line 237
            goto err;
          }
        } else {
#line 231
          goto _L___8;
        }
      } else {
        _L___8: /* CIL Label */ 
#line 239
        w = fp->f_bf.smb_size;
#line 239
        if (s >= w) {
          {
#line 241
          w = (*(fp->f_write))(fp, (char const   *)p, (size_t )w);
          }
#line 242
          if (w <= 0) {
#line 244
            if (w == 0) {
              {
#line 244
              tmp___38 = __errno_location();
              }
#line 244
              if (*tmp___38 == 0) {
#line 245
                goto while_break___12;
              }
            }
#line 246
            if (fd < 0) {
#line 247
              goto err;
            } else
#line 246
            if (w < 0) {
              {
#line 246
              tmp___39 = __errno_location();
              }
#line 246
              if (*tmp___39 != 11) {
                {
#line 246
                tmp___40 = __errno_location();
                }
#line 246
                if (*tmp___40 != 11) {
#line 247
                  goto err;
                } else {
#line 246
                  goto _L___7;
                }
              } else {
#line 246
                goto _L___7;
              }
            } else
            _L___7: /* CIL Label */ 
#line 246
            if (timeout == -1) {
#line 247
              goto err;
            }
            {
#line 250
            tmp___41 = __errno_location();
#line 250
            *tmp___41 = 0;
            }
#line 250
            if (timeout == -2) {
#line 250
              timeout = fp->f_timeout;
            }
#line 250
            if (timeout == 0) {
              {
#line 250
              tmp___42 = __errno_location();
#line 250
              *tmp___42 = 11;
              }
#line 250
              return (-1);
            } else
#line 250
            if (timeout == -1) {
              {
#line 250
              tmp___43 = __errno_location();
#line 250
              *tmp___43 = 22;
              }
#line 250
              return (-1);
            } else {
#line 250
              sm_io_to___1.tv_sec = (__time_t )(timeout / 1000);
#line 250
              sm_io_to___1.tv_usec = ((__time_t )timeout - sm_io_to___1.tv_sec * 1000L) * 1000L;
            }
#line 250
            if (fd >= 1024) {
              {
#line 250
              tmp___44 = __errno_location();
#line 250
              *tmp___44 = 22;
              }
#line 250
              return (-1);
            }
            {
#line 250
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 250
              __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___3), "=D" (__d1___3): "a" (0),
                                   "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& sm_io_to_mask___1.__fds_bits[0]): "memory");
#line 250
              goto while_break___14;
            }
            while_break___14: /* CIL Label */ ;
            }
#line 250
            __asm__  volatile   ("btsl %1,%0": "=m" (sm_io_to_mask___1.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                                 "memory");
            {
#line 250
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 250
              __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___4), "=D" (__d1___4): "a" (0),
                                   "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& sm_io_x_mask___1.__fds_bits[0]): "memory");
#line 250
              goto while_break___15;
            }
            while_break___15: /* CIL Label */ ;
            }
            {
#line 250
            __asm__  volatile   ("btsl %1,%0": "=m" (sm_io_x_mask___1.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                                 "memory");
#line 250
            tmp___45 = gettimeofday((struct timeval */* __restrict  */)(& sm_io_to_before___1),
                                    (__timezone_ptr_t )((void *)0));
            }
#line 250
            if (tmp___45 < 0) {
#line 250
              return (-1);
            }
            {
#line 250
            while (1) {
              while_continue___16: /* CIL Label */ ;
              {
#line 250
              sm_io_to_sel___1 = select(fd + 1, (fd_set */* __restrict  */)((void *)0),
                                        (fd_set */* __restrict  */)(& sm_io_to_mask___1),
                                        (fd_set */* __restrict  */)(& sm_io_x_mask___1),
                                        (struct timeval */* __restrict  */)(& sm_io_to___1));
              }
#line 250
              if (sm_io_to_sel___1 < 0) {
                {
#line 250
                tmp___46 = __errno_location();
                }
#line 250
                if (! (*tmp___46 == 4)) {
#line 250
                  goto while_break___16;
                }
              } else {
#line 250
                goto while_break___16;
              }
            }
            while_break___16: /* CIL Label */ ;
            }
#line 250
            if (sm_io_to_sel___1 < 0) {
#line 250
              return (-1);
            } else
#line 250
            if (sm_io_to_sel___1 == 0) {
              {
#line 250
              tmp___47 = __errno_location();
#line 250
              *tmp___47 = 11;
              }
#line 250
              return (-1);
            }
            {
#line 250
            tmp___48 = gettimeofday((struct timeval */* __restrict  */)(& sm_io_to_after___1),
                                    (__timezone_ptr_t )((void *)0));
            }
#line 250
            if (tmp___48 < 0) {
#line 250
              return (-1);
            }
            {
#line 250
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 250
              sm_io_to_diff___1.tv_sec = sm_io_to_after___1.tv_sec - sm_io_to_before___1.tv_sec;
#line 250
              sm_io_to_diff___1.tv_usec = sm_io_to_after___1.tv_usec - sm_io_to_before___1.tv_usec;
#line 250
              if (sm_io_to_diff___1.tv_usec < 0L) {
#line 250
                (sm_io_to_diff___1.tv_sec) --;
#line 250
                sm_io_to_diff___1.tv_usec += 1000000L;
              }
#line 250
              goto while_break___17;
            }
            while_break___17: /* CIL Label */ ;
            }
#line 250
            timeout = (int )((__time_t )timeout - sm_io_to_diff___1.tv_sec * 1000L);
#line 250
            timeout = (int )((__suseconds_t )timeout - sm_io_to_diff___1.tv_usec / 1000L);
#line 250
            if (timeout < 0) {
#line 250
              timeout = 0;
            }
#line 251
            w = 0;
          }
        } else {
          {
#line 256
          w = s;
#line 257
          memcpy((void */* __restrict  */)((void *)fp->f_p), (void const   */* __restrict  */)((void *)p),
                 (size_t )w);
#line 258
          fp->f_w -= w;
#line 259
          fp->f_p += w;
          }
        }
      }
#line 261
      nldist -= w;
#line 261
      if (nldist == 0) {
        {
#line 264
        tmp___49 = sm_flush(fp, & timeout);
        }
#line 264
        if (tmp___49) {
#line 265
          goto err;
        }
#line 266
        nlknown = 0;
      }
#line 268
      p += w;
#line 269
      len___0 -= (size_t )w;
#line 219
      tmp___50 = uio->uio_resid - w;
#line 219
      uio->uio_resid = tmp___50;
#line 219
      if (! (tmp___50 != 0)) {
#line 219
        goto while_break___12;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 273
  return (0);
  err: 
#line 277
  fp->f_flags |= 256L;
#line 278
  return (-1);
}
}
#line 32 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fseek.c"
static void seekalrm(int sig ) ;
#line 33 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fseek.c"
static sigjmp_buf SeekTimeOut  ;
#line 55 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fseek.c"
static void seekalrm(int sig ) 
{ 


  {
  {
#line 59
  siglongjmp((struct __jmp_buf_tag *)(SeekTimeOut), 1);
  }
}
}
#line 76 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fseek.c"
int sm_io_seek(SM_FILE_T *fp , int timeout , long offset , int whence ) 
{ 
  bool havepos ;
  off_t target ;
  off_t curoff ;
  size_t n ;
  struct stat st ;
  int ret ;
  SM_EVENT *evt ;
  register off_t (*seekfn)(SM_FILE_T * , off_t  , int  ) ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  register int o ;
  off_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  off_t tmp___12 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 88
  evt = (SM_EVENT *)((void *)0);
#line 91
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 91
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 91
      tmp = 1;
    } else {
      {
#line 91
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fseek.c",
                  91, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 91
      tmp = 0;
      }
    }
  } else {
    {
#line 91
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fseek.c",
                91, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 91
    tmp = 0;
    }
  }
#line 94
  if (! Sm_IO_DidInit) {
    {
#line 95
    sm_init();
    }
  }
#line 98
  seekfn = fp->f_seek;
#line 98
  if ((unsigned long )seekfn == (unsigned long )((void *)0)) {
    {
#line 100
    tmp___0 = __errno_location();
#line 100
    *tmp___0 = 29;
    }
#line 101
    return (-1);
  }
#line 104
  if (timeout == -2) {
#line 105
    timeout = fp->f_timeout;
  }
#line 106
  if (timeout == 0) {
    {
#line 113
    tmp___1 = __errno_location();
#line 113
    *tmp___1 = 11;
    }
#line 114
    return (-1);
  }
  {
#line 136
  if (whence == 1) {
#line 136
    goto case_1;
  }
#line 173
  if (whence == 2) {
#line 173
    goto case_2;
  }
#line 173
  if (whence == 0) {
#line 173
    goto case_2;
  }
#line 179
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 145
  sm_flush(fp, & timeout);
  }
#line 146
  if (timeout != -1) {
    {
#line 146
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(SeekTimeOut), 1);
    }
#line 146
    if (tmp___3 != 0) {
      {
#line 146
      tmp___2 = __errno_location();
#line 146
      *tmp___2 = 11;
      }
#line 146
      return (-1);
    }
    {
#line 146
    evt = sm_seteventm(timeout, & seekalrm, 0);
    }
  }
#line 147
  if (fp->f_flags & 16384L) {
#line 148
    curoff = fp->f_lseekoff;
  } else {
    {
#line 151
    curoff = (*seekfn)(fp, (off_t )0, 1);
    }
#line 152
    if (curoff == -1L) {
#line 154
      ret = -1;
#line 155
      goto clean;
    }
  }
#line 158
  if (fp->f_flags & 16L) {
#line 160
    curoff -= (off_t )fp->f_r;
#line 161
    if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 162
      curoff -= (off_t )fp->f_ur;
    }
  } else
#line 164
  if (fp->f_flags & 32L) {
#line 164
    if ((unsigned long )fp->f_p != (unsigned long )((void *)0)) {
#line 165
      curoff += fp->f_p - fp->f_bf.smb_base;
    }
  }
#line 167
  offset += curoff;
#line 168
  whence = 0;
#line 169
  havepos = 1;
#line 170
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 174
  if (timeout != -1) {
    {
#line 174
    tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)(SeekTimeOut), 1);
    }
#line 174
    if (tmp___5 != 0) {
      {
#line 174
      tmp___4 = __errno_location();
#line 174
      *tmp___4 = 11;
      }
#line 174
      return (-1);
    }
    {
#line 174
    evt = sm_seteventm(timeout, & seekalrm, 0);
    }
  }
#line 175
  curoff = (off_t )0;
#line 176
  havepos = 0;
#line 177
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 180
  tmp___6 = __errno_location();
#line 180
  *tmp___6 = 22;
  }
#line 181
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 193
  if ((unsigned long )fp->f_bf.smb_base == (unsigned long )((void *)0)) {
    {
#line 194
    sm_makebuf(fp);
    }
  }
#line 195
  if (fp->f_flags & 8292L) {
#line 196
    goto dumb;
  }
#line 197
  if ((fp->f_flags & 4096L) == 0L) {
#line 199
    if ((unsigned long )seekfn != (unsigned long )(& sm_stdseek)) {
#line 203
      fp->f_flags |= 8192L;
#line 204
      goto dumb;
    } else
#line 199
    if ((int )fp->f_file < 0) {
#line 203
      fp->f_flags |= 8192L;
#line 204
      goto dumb;
    } else {
      {
#line 199
      tmp___7 = fstat((int )fp->f_file, & st);
      }
#line 199
      if (tmp___7) {
#line 203
        fp->f_flags |= 8192L;
#line 204
        goto dumb;
      } else
#line 199
      if ((st.st_mode & 61440U) != 32768U) {
#line 203
        fp->f_flags |= 8192L;
#line 204
        goto dumb;
      }
    }
#line 206
    fp->f_blksize = (int )st.st_blksize;
#line 207
    fp->f_flags |= 4096L;
  }
#line 215
  if (whence == 0) {
#line 216
    target = offset;
  } else {
    {
#line 219
    tmp___8 = fstat((int )fp->f_file, & st);
    }
#line 219
    if (tmp___8) {
#line 220
      goto dumb;
    }
#line 221
    target = st.st_size + offset;
  }
#line 224
  if (! havepos) {
#line 226
    if (fp->f_flags & 16384L) {
#line 227
      curoff = fp->f_lseekoff;
    } else {
      {
#line 230
      curoff = (*seekfn)(fp, (off_t )0, 1);
      }
#line 231
      if (curoff == -1L) {
#line 232
        goto dumb;
      }
    }
#line 234
    curoff -= (off_t )fp->f_r;
#line 235
    if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 236
      curoff -= (off_t )fp->f_ur;
    }
  }
#line 246
  if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 248
    curoff += (off_t )fp->f_r;
#line 249
    n = (size_t )(fp->f_up - fp->f_bf.smb_base);
#line 250
    curoff -= (off_t )n;
#line 251
    n += (size_t )fp->f_ur;
  } else {
#line 255
    n = (size_t )(fp->f_p - fp->f_bf.smb_base);
#line 256
    curoff -= (off_t )n;
#line 257
    n += (size_t )fp->f_r;
  }
#line 267
  if (target >= curoff) {
#line 267
    if (target < curoff + (off_t )n) {
#line 269
      o = (int )(target - curoff);
#line 271
      fp->f_p = fp->f_bf.smb_base + o;
#line 272
      fp->f_r = (int )(n - (size_t )o);
#line 273
      if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 274
        if ((unsigned long )fp->f_ub.smb_base != (unsigned long )(fp->f_ubuf)) {
          {
#line 274
          sm_free_tagged((void *)((char *)fp->f_ub.smb_base), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fseek.c",
                         274);
          }
        }
#line 274
        fp->f_ub.smb_base = (unsigned char *)((void *)0);
      }
#line 275
      fp->f_flags &= -129L;
#line 276
      ret = 0;
#line 277
      goto clean;
    }
  }
  {
#line 289
  curoff = target & (long )(~ (fp->f_blksize - 1));
#line 290
  tmp___9 = (*seekfn)(fp, curoff, 0);
  }
#line 290
  if (tmp___9 == -1L) {
#line 291
    goto dumb;
  }
#line 292
  fp->f_r = 0;
#line 293
  fp->f_p = fp->f_bf.smb_base;
#line 294
  if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 295
    if ((unsigned long )fp->f_ub.smb_base != (unsigned long )(fp->f_ubuf)) {
      {
#line 295
      sm_free_tagged((void *)((char *)fp->f_ub.smb_base), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fseek.c",
                     295);
      }
    }
#line 295
    fp->f_ub.smb_base = (unsigned char *)((void *)0);
  }
#line 296
  fp->f_flags &= -129L;
#line 297
  n = (size_t )(target - curoff);
#line 298
  if (n) {
    {
#line 301
    tmp___10 = sm_refill(fp, -1);
    }
#line 301
    if (tmp___10) {
#line 302
      goto dumb;
    } else
#line 301
    if (fp->f_r < (int )n) {
#line 302
      goto dumb;
    }
#line 303
    fp->f_p += n;
#line 304
    fp->f_r = (int )((size_t )fp->f_r - n);
  }
#line 307
  ret = 0;
  clean: 
#line 310
  if ((unsigned long )evt != (unsigned long )((void *)0)) {
    {
#line 311
    sm_clrevent(evt);
    }
  }
#line 312
  return (ret);
  dumb: 
  {
#line 320
  ret = -1;
#line 321
  tmp___11 = sm_flush(fp, & ret);
  }
#line 321
  if (tmp___11 != 0) {
#line 324
    ret = -1;
#line 325
    goto clean;
  } else {
    {
#line 321
    tmp___12 = (*seekfn)(fp, offset, whence);
    }
#line 321
    if (tmp___12 == -1L) {
#line 324
      ret = -1;
#line 325
      goto clean;
    }
  }
#line 329
  if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 330
    if ((unsigned long )fp->f_ub.smb_base != (unsigned long )(fp->f_ubuf)) {
      {
#line 330
      sm_free_tagged((void *)((char *)fp->f_ub.smb_base), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fseek.c",
                     330);
      }
    }
#line 330
    fp->f_ub.smb_base = (unsigned char *)((void *)0);
  }
#line 331
  fp->f_p = fp->f_bf.smb_base;
#line 332
  fp->f_r = 0;
#line 333
  fp->f_flags &= -129L;
#line 334
  ret = 0;
#line 335
  goto clean;
}
}
#line 280 "../../include/sm/io.h"
int sm_io_fscanf(SM_FILE_T *fp , int timeout , char const   *fmt  , ...) ;
#line 36 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fscanf.c"
int sm_io_fscanf(SM_FILE_T *fp , int timeout , char const   *fmt  , ...) 
{ 
  int ret ;
  va_list ap ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 50
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 50
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 50
      tmp = 1;
    } else {
      {
#line 50
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fscanf.c",
                  50, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 50
      tmp = 0;
      }
    }
  } else {
    {
#line 50
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fscanf.c",
                50, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 50
    tmp = 0;
    }
  }
  {
#line 51
  __builtin_va_start(ap, fmt);
#line 52
  ret = sm_vfscanf(fp, timeout, fmt, ap);
#line 53
  __builtin_va_end(ap);
  }
#line 54
  return (ret);
}
}
#line 40 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fread.c"
size_t sm_io_read(SM_FILE_T *fp , int timeout , void *buf___16 , size_t size ) 
{ 
  register size_t resid ;
  register char *p ;
  register int r ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 47
  resid = size;
#line 51
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 51
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 51
      tmp = 1;
    } else {
      {
#line 51
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fread.c",
                  51, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 51
      tmp = 0;
      }
    }
  } else {
    {
#line 51
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fread.c",
                51, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 51
    tmp = 0;
    }
  }
#line 53
  if ((unsigned long )fp->f_read == (unsigned long )((void *)0)) {
    {
#line 55
    tmp___0 = __errno_location();
#line 55
    *tmp___0 = 19;
    }
#line 56
    return ((size_t )0);
  }
#line 65
  if (resid == 0U) {
#line 66
    return ((size_t )0);
  }
#line 67
  if (fp->f_r < 0) {
#line 68
    fp->f_r = 0;
  }
#line 69
  p = (char *)buf___16;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    r = fp->f_r;
#line 70
    if (! ((int )resid > r)) {
#line 70
      goto while_break;
    }
    {
#line 72
    memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void *)fp->f_p),
           (size_t )r);
#line 73
    fp->f_p += r;
#line 75
    p += r;
#line 76
    resid -= (size_t )r;
    }
#line 77
    if ((fp->f_flags & 8L) != 0L) {
#line 77
      if (r > 0) {
#line 87
        fp->f_r -= r;
#line 88
        return (size - resid);
      }
    }
    {
#line 90
    tmp___1 = sm_refill(fp, timeout);
    }
#line 90
    if (tmp___1 != 0) {
#line 93
      return (size - resid);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 96
  memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void *)fp->f_p),
         resid);
#line 97
  fp->f_r = (int )((size_t )fp->f_r - resid);
#line 98
  fp->f_p += resid;
  }
#line 99
  return (size);
}
}
#line 278 "../../include/sm/io.h"
int sm_io_fputs(SM_FILE_T *fp , int timeout , char const   *s ) ;
#line 37 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fput.c"
int sm_io_fputs(SM_FILE_T *fp , int timeout , char const   *s ) 
{ 
  struct sm_uio uio ;
  struct sm_iov iov ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 46
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 46
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 46
      tmp = 1;
    } else {
      {
#line 46
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fput.c",
                  46, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 46
      tmp = 0;
      }
    }
  } else {
    {
#line 46
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fput.c",
                46, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 46
    tmp = 0;
    }
  }
  {
#line 47
  iov.iov_base = (void *)s;
#line 48
  tmp___0 = strlen(s);
#line 48
  uio.uio_resid = (int )tmp___0;
#line 48
  iov.iov_len = (size_t )uio.uio_resid;
#line 49
  uio.uio_iov = & iov;
#line 50
  uio.uio_iovcnt = 1;
#line 51
  tmp___1 = sm_fvwrite(fp, timeout, & uio);
  }
#line 51
  return (tmp___1);
}
}
#line 287 "../../include/sm/io.h"
int sm_io_purge(SM_FILE_T *fp ) ;
#line 34 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fpurge.c"
int sm_io_purge(SM_FILE_T *fp ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 38
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 38
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 38
      tmp = 1;
    } else {
      {
#line 38
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fpurge.c",
                  38, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 38
      tmp = 0;
      }
    }
  } else {
    {
#line 38
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fpurge.c",
                38, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 38
    tmp = 0;
    }
  }
#line 39
  if (! fp->f_flags) {
    {
#line 41
    tmp___0 = __errno_location();
#line 41
    *tmp___0 = 9;
    }
#line 42
    return (-1);
  }
#line 45
  if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 46
    if ((unsigned long )fp->f_ub.smb_base != (unsigned long )(fp->f_ubuf)) {
      {
#line 46
      sm_free_tagged((void *)((char *)fp->f_ub.smb_base), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fpurge.c",
                     46);
      }
    }
#line 46
    fp->f_ub.smb_base = (unsigned char *)((void *)0);
  }
#line 47
  fp->f_p = fp->f_bf.smb_base;
#line 48
  fp->f_r = 0;
#line 51
  if (fp->f_flags & 6L) {
#line 51
    fp->f_w = 0;
  } else {
#line 51
    fp->f_w = fp->f_bf.smb_size;
  }
#line 52
  return (0);
}
}
#line 36 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fprintf.c"
int sm_io_fprintf(SM_FILE_T *fp , int timeout , char const   *fmt  , ...) 
{ 
  int ret ;
  va_list ap ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 50
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 50
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 50
      tmp = 1;
    } else {
      {
#line 50
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fprintf.c",
                  50, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 50
      tmp = 0;
      }
    }
  } else {
    {
#line 50
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fprintf.c",
                50, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 50
    tmp = 0;
    }
  }
  {
#line 51
  __builtin_va_start(ap, fmt);
#line 52
  ret = sm_io_vfprintf(fp, timeout, fmt, ap);
#line 53
  __builtin_va_end(ap);
  }
#line 54
  return (ret);
}
}
#line 301 "../../include/sm/io.h"
long sm_io_tell(SM_FILE_T *fp , int timeout ) ;
#line 27 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fpos.c"
static void tellalrm(int sig ) ;
#line 28 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fpos.c"
static sigjmp_buf TellTimeOut  ;
#line 50 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fpos.c"
static void tellalrm(int sig ) 
{ 


  {
  {
#line 54
  siglongjmp((struct __jmp_buf_tag *)(TellTimeOut), 1);
  }
}
}
#line 69 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fpos.c"
long sm_io_tell(SM_FILE_T *fp , int timeout ) 
{ 
  register off_t pos ;
  SM_EVENT *evt ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 75
  evt = (SM_EVENT *)((void *)0);
#line 77
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 77
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 77
      tmp = 1;
    } else {
      {
#line 77
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fpos.c",
                  77, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 77
      tmp = 0;
      }
    }
  } else {
    {
#line 77
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fpos.c",
                77, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 77
    tmp = 0;
    }
  }
#line 78
  if ((unsigned long )fp->f_seek == (unsigned long )((void *)0)) {
    {
#line 80
    tmp___0 = __errno_location();
#line 80
    *tmp___0 = 29;
    }
#line 81
    return (-1L);
  }
#line 84
  if (timeout == -2) {
#line 85
    timeout = fp->f_timeout;
  }
#line 86
  if (timeout == 0) {
    {
#line 93
    tmp___1 = __errno_location();
#line 93
    *tmp___1 = 11;
    }
#line 94
    return (-1L);
  }
  {
#line 102
  sm_flush(fp, & timeout);
  }
#line 105
  if (timeout != -1) {
    {
#line 107
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(TellTimeOut), 1);
    }
#line 107
    if (tmp___3 != 0) {
      {
#line 109
      tmp___2 = __errno_location();
#line 109
      *tmp___2 = 11;
      }
#line 110
      return (-1L);
    }
    {
#line 113
    evt = sm_seteventm(timeout, & tellalrm, 0);
    }
  }
#line 116
  if (fp->f_flags & 16384L) {
#line 117
    pos = fp->f_lseekoff;
  } else {
    {
#line 121
    pos = (*(fp->f_seek))(fp, (off_t )0, 1);
    }
#line 122
    if (pos == -1L) {
#line 123
      goto clean;
    }
  }
#line 125
  if (fp->f_flags & 16L) {
#line 133
    pos -= (off_t )fp->f_r;
#line 134
    if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 135
      pos -= (off_t )fp->f_ur;
    }
  } else
#line 137
  if (fp->f_flags & 32L) {
#line 137
    if ((unsigned long )fp->f_p != (unsigned long )((void *)0)) {
#line 145
      pos += fp->f_p - fp->f_bf.smb_base;
    }
  }
  clean: 
#line 150
  if ((unsigned long )evt != (unsigned long )((void *)0)) {
    {
#line 151
    sm_clrevent(evt);
    }
  }
#line 152
  return (pos);
}
}
#line 265 "../../include/sm/io.h"
SM_FILE_T *sm_io_autoflush(SM_FILE_T *fp , SM_FILE_T *fp2 ) ;
#line 266
void sm_io_automode(SM_FILE_T *fp1 , SM_FILE_T *fp2 ) ;
#line 268
int sm_io_close(SM_FILE_T *fp , int timeout ) ;
#line 269
SM_FILE_T *sm_io_dup(SM_FILE_T *fp ) ;
#line 285
SM_FILE_T *sm_io_open(SM_FILE_T const   *type , int timeout , void const   *info ,
                      int flags , void const   *rpool ) ;
#line 290
SM_FILE_T *sm_io_reopen(SM_FILE_T const   *type , int timeout , void const   *info ,
                        int flags , void const   *rpool , SM_FILE_T *fp ) ;
#line 37 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/local.h"
int sm_flags(int flags ) ;
#line 27 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c"
static void openalrm(int sig ) ;
#line 28
static void reopenalrm(int sig ) ;
#line 31 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c"
static sigjmp_buf OpenTimeOut  ;
#line 31 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c"
static sigjmp_buf ReopenTimeOut  ;
#line 53 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c"
static void openalrm(int sig ) 
{ 


  {
  {
#line 57
  siglongjmp((struct __jmp_buf_tag *)(OpenTimeOut), 1);
  }
}
}
#line 79 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c"
static void reopenalrm(int sig ) 
{ 


  {
  {
#line 83
  siglongjmp((struct __jmp_buf_tag *)(ReopenTimeOut), 1);
  }
}
}
#line 106 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c"
SM_FILE_T *sm_io_open(SM_FILE_T const   *type , int timeout , void const   *info ,
                      int flags , void const   *rpool ) 
{ 
  register SM_FILE_T *fp ;
  int ioflags ;
  SM_EVENT *evt ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 116
  evt = (SM_EVENT *)((void *)0);
#line 118
  ioflags = sm_flags(flags);
  }
#line 120
  if (ioflags == 0) {
    {
#line 123
    tmp = __errno_location();
#line 123
    *tmp = 22;
    }
#line 124
    return ((SM_FILE_T *)((void *)0));
  }
#line 127
  if (timeout == -2) {
#line 128
    timeout = -1;
  }
#line 129
  if (timeout == 0) {
    {
#line 131
    tmp___0 = __errno_location();
#line 131
    *tmp___0 = 11;
    }
#line 132
    return ((SM_FILE_T *)((void *)0));
  }
  {
#line 135
  fp = sm_fp(type, (int const   )ioflags, (SM_FILE_T *)((void *)0));
  }
#line 138
  if (timeout != -1) {
    {
#line 140
    tmp___2 = __sigsetjmp((struct __jmp_buf_tag *)(OpenTimeOut), 1);
    }
#line 140
    if (tmp___2 != 0) {
      {
#line 142
      tmp___1 = __errno_location();
#line 142
      *tmp___1 = 11;
      }
#line 143
      return ((SM_FILE_T *)((void *)0));
    }
    {
#line 145
    evt = sm_seteventm(timeout, & openalrm, 0);
    }
  }
  {
#line 148
  tmp___3 = (*(fp->f_open))(fp, info, flags, rpool);
  }
#line 148
  if (tmp___3 < 0) {
#line 150
    fp->f_flags = 0L;
#line 151
    fp->sm_magic = (char const   *)((void *)0);
#line 152
    return ((SM_FILE_T *)((void *)0));
  }
#line 156
  if ((unsigned long )evt != (unsigned long )((void *)0)) {
    {
#line 157
    sm_clrevent(evt);
    }
  }
#line 164
  return (fp);
}
}
#line 182 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c"
SM_FILE_T *sm_io_dup(SM_FILE_T *fp ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 187
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 187
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 187
      tmp = 1;
    } else {
      {
#line 187
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c",
                  187, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 187
      tmp = 0;
      }
    }
  } else {
    {
#line 187
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c",
                187, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 187
    tmp = 0;
    }
  }
#line 188
  if ((unsigned long )fp->sm_magic != (unsigned long )(SmFileMagic)) {
    {
#line 190
    tmp___0 = __errno_location();
#line 190
    *tmp___0 = 9;
    }
#line 191
    return ((SM_FILE_T *)((void *)0));
  }
#line 193
  if (fp->f_dup_cnt >= 2147483646) {
    {
#line 196
    tmp___1 = __errno_location();
#line 196
    *tmp___1 = 24;
    }
#line 197
    return ((SM_FILE_T *)((void *)0));
  }
#line 199
  (fp->f_dup_cnt) ++;
#line 200
  return (fp);
}
}
#line 220 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c"
SM_FILE_T *sm_io_reopen(SM_FILE_T const   *type , int timeout , void const   *info ,
                        int flags , void const   *rpool , SM_FILE_T *fp ) 
{ 
  int ioflags ;
  int ret ;
  SM_FILE_T *fp2 ;
  SM_EVENT *evt ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 231
  evt = (SM_EVENT *)((void *)0);
#line 233
  ioflags = sm_flags(flags);
  }
#line 233
  if (ioflags == 0) {
    {
#line 235
    sm_io_close(fp, timeout);
    }
#line 236
    return ((SM_FILE_T *)((void *)0));
  }
#line 239
  if (! Sm_IO_DidInit) {
    {
#line 240
    sm_init();
    }
  }
#line 242
  if (timeout == -2) {
#line 243
    timeout = -1;
  }
#line 244
  if (timeout == 0) {
    {
#line 251
    tmp = __errno_location();
#line 251
    *tmp = 11;
    }
#line 252
    return ((SM_FILE_T *)((void *)0));
  }
#line 255
  if (timeout != -1) {
    {
#line 257
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(ReopenTimeOut), 1);
    }
#line 257
    if (tmp___1 != 0) {
      {
#line 259
      tmp___0 = __errno_location();
#line 259
      *tmp___0 = 11;
      }
#line 260
      return ((SM_FILE_T *)((void *)0));
    }
    {
#line 263
    evt = sm_seteventm(timeout, & reopenalrm, 0);
    }
  }
#line 275
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 277
    if ((unsigned long )fp->sm_magic != (unsigned long )(SmFileMagic)) {
#line 278
      fp->f_flags = 128L;
    } else {
      {
#line 282
      sm_io_flush(fp, -1);
#line 283
      sm_io_close(fp, -1);
      }
    }
  }
  {
#line 287
  fp2 = sm_fp(type, (int const   )ioflags, fp);
#line 288
  ret = (*(fp2->f_open))(fp2, info, flags, rpool);
  }
#line 291
  if ((unsigned long )evt != (unsigned long )((void *)0)) {
    {
#line 292
    sm_clrevent(evt);
    }
  }
#line 294
  if (ret < 0) {
#line 296
    fp2->f_flags = 0L;
#line 297
    fp2->sm_magic = (char const   *)((void *)0);
#line 298
    return ((SM_FILE_T *)((void *)0));
  }
#line 316
  return (fp2);
}
}
#line 332 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c"
SM_FILE_T *sm_io_autoflush(SM_FILE_T *fp , SM_FILE_T *fp2 ) 
{ 
  SM_FILE_T *savefp ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 339
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 339
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 339
      tmp = 1;
    } else {
      {
#line 339
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c",
                  339, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 339
      tmp = 0;
      }
    }
  } else {
    {
#line 339
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c",
                339, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 339
    tmp = 0;
    }
  }
#line 340
  if ((unsigned long )fp2 != (unsigned long )((void *)0)) {
#line 341
    if ((unsigned long )fp2 != (unsigned long )((void *)0)) {
#line 341
      if ((unsigned long )fp2->sm_magic == (unsigned long )(SmFileMagic)) {
#line 341
        tmp___0 = 1;
      } else {
        {
#line 341
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c",
                    341, "SM_REQUIRE((fp2) != NULL && (fp2)->sm_magic == (SmFileMagic)) failed");
#line 341
        tmp___0 = 0;
        }
      }
    } else {
      {
#line 341
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c",
                  341, "SM_REQUIRE((fp2) != NULL && (fp2)->sm_magic == (SmFileMagic)) failed");
#line 341
      tmp___0 = 0;
      }
    }
  }
#line 343
  savefp = fp->f_flushfp;
#line 344
  fp->f_flushfp = fp2;
#line 345
  return (savefp);
}
}
#line 364 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c"
void sm_io_automode(SM_FILE_T *fp1 , SM_FILE_T *fp2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 369
  if ((unsigned long )fp1 != (unsigned long )((void *)0)) {
#line 369
    if ((unsigned long )fp1->sm_magic == (unsigned long )(SmFileMagic)) {
#line 369
      tmp = 1;
    } else {
      {
#line 369
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c",
                  369, "SM_REQUIRE((fp1) != NULL && (fp1)->sm_magic == (SmFileMagic)) failed");
#line 369
      tmp = 0;
      }
    }
  } else {
    {
#line 369
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c",
                369, "SM_REQUIRE((fp1) != NULL && (fp1)->sm_magic == (SmFileMagic)) failed");
#line 369
    tmp = 0;
    }
  }
#line 370
  if ((unsigned long )fp2 != (unsigned long )((void *)0)) {
#line 370
    if ((unsigned long )fp2->sm_magic == (unsigned long )(SmFileMagic)) {
#line 370
      tmp___0 = 1;
    } else {
      {
#line 370
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c",
                  370, "SM_REQUIRE((fp2) != NULL && (fp2)->sm_magic == (SmFileMagic)) failed");
#line 370
      tmp___0 = 0;
      }
    }
  } else {
    {
#line 370
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fopen.c",
                370, "SM_REQUIRE((fp2) != NULL && (fp2)->sm_magic == (SmFileMagic)) failed");
#line 370
    tmp___0 = 0;
    }
  }
#line 372
  fp1->f_modefp = fp2;
#line 373
  fp2->f_modefp = fp1;
#line 374
  return;
}
}
#line 32 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/flags.c"
int sm_flags(int flags ) 
{ 
  register int ret ;

  {
  {
#line 40
  if ((flags & 15) == 2) {
#line 40
    goto case_2;
  }
#line 44
  if ((flags & 15) == 3) {
#line 44
    goto case_3;
  }
#line 48
  if ((flags & 15) == 4) {
#line 48
    goto case_4;
  }
#line 52
  if ((flags & 15) == 1) {
#line 52
    goto case_1;
  }
#line 56
  goto switch_default;
  case_2: /* CIL Label */ 
#line 41
  ret = 16;
#line 42
  goto switch_break;
  case_3: /* CIL Label */ 
#line 45
  ret = 32;
#line 46
  goto switch_break;
  case_4: /* CIL Label */ 
#line 49
  ret = 32;
#line 50
  goto switch_break;
  case_1: /* CIL Label */ 
#line 53
  ret = 64;
#line 54
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 57
  ret = 0;
#line 58
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 62
  return (ret);
}
}
#line 99 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 154 "../../include/sm/io.h"
SM_FILE_T SmFtStdiofd_def ;
#line 155
SM_FILE_T SmFtString_def ;
#line 295
int sm_io_setinfo(SM_FILE_T *fp , int what , void *valp ) ;
#line 78 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/local.h"
bool Sm_IO_DidInit  ;
#line 33 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
char const   SmFileMagic[8]  = 
#line 33 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
  {      (char const   )'s',      (char const   )'m',      (char const   )'_',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'\000'};
#line 36 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
SM_FILE_T SmFtStdio_def  = 
#line 36
     {SmFileMagic, (unsigned char *)0, 0, 0, 65L, (short)-1, {(unsigned char *)0, 0},
    0, (void *)0, 0, & sm_stdclose, & sm_stdread, & sm_stdseek, & sm_stdwrite, & sm_stdopen,
    & sm_stdsetinfo, & sm_stdgetinfo, -1, 0, (char *)"stdio", (struct sm_file *)0,
    (struct sm_file *)0, {(unsigned char *)0, 0}, (unsigned char *)0, 0, {(unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned char)0}, 0, 0L, 0};
#line 43 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
SM_FILE_T SmFtStdiofd_def  = 
#line 43
     {SmFileMagic, (unsigned char *)0, 0, 0, 65L, (short)-1, {(unsigned char *)0, 0},
    0, (void *)0, 0, & sm_stdclose, & sm_stdread, & sm_stdseek, & sm_stdwrite, & sm_stdfdopen,
    & sm_stdsetinfo, & sm_stdgetinfo, -1, 0, (char *)"stdiofd", (struct sm_file *)0,
    (struct sm_file *)0, {(unsigned char *)0, 0}, (unsigned char *)0, 0, {(unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned char)0}, 0, 0L, 0};
#line 50 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
SM_FILE_T SmFtString_def  = 
#line 50
     {SmFileMagic, (unsigned char *)0, 0, 0, 68L, (short)-1, {(unsigned char *)0, 0},
    0, (void *)0, 0, & sm_strclose, & sm_strread, & sm_strseek, & sm_strwrite, & sm_stropen,
    & sm_strsetinfo, & sm_strgetinfo, -1, 0, (char *)"string", (struct sm_file *)0,
    (struct sm_file *)0, {(unsigned char *)0, 0}, (unsigned char *)0, 0, {(unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned char)0}, 0, 0L, 0};
#line 81 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
SM_FILE_T SmFtRealStdio_def  = 
#line 81
     {SmFileMagic, (unsigned char *)0, 0, 0, 68L, (short)-1, {(unsigned char *)0, 0},
    0, (void *)0, -1, & sm_stdioclose, & sm_stdioread, & sm_stdioseek, & sm_stdiowrite,
    & sm_stdioopen, & sm_stdiosetinfo, & sm_stdiogetinfo, -1, 0, (char *)"realstdio",
    (struct sm_file *)0, (struct sm_file *)0, {(unsigned char *)0, 0}, (unsigned char *)0,
    0, {(unsigned char)0, (unsigned char)0, (unsigned char)0}, {(unsigned char)0},
    0, 0L, 0};
#line 84 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
static SM_FILE_T usual[17]  ;
#line 85 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
static struct sm_glue smuglue  =    {(struct sm_glue *)0, 17, usual};
#line 88 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
SM_FILE_T SmIoF[6]  = {      {SmFileMagic, (unsigned char *)0, 0, 0, 18L, (short)0, {(unsigned char *)0, 0},
      0, (void *)(SmIoF + 0), 0, & sm_stdclose, & sm_stdread, & sm_stdseek, & sm_stdwrite,
      & sm_stdopen, & sm_stdsetinfo, & sm_stdgetinfo, -1, 0, (char *)"smioin", (struct sm_file *)0,
      (struct sm_file *)0, {(unsigned char *)0, 0}, (unsigned char *)0, 0, {(unsigned char)0,
                                                                            (unsigned char)0,
                                                                            (unsigned char)0},
      {(unsigned char)0}, 0, 0L, 0}, 
        {SmFileMagic, (unsigned char *)0, 0, 0, 34L, (short)1, {(unsigned char *)0, 0},
      0, (void *)(SmIoF + 1), 0, & sm_stdclose, & sm_stdread, & sm_stdseek, & sm_stdwrite,
      & sm_stdopen, & sm_stdsetinfo, & sm_stdgetinfo, -1, 0, (char *)"smioout", (struct sm_file *)0,
      (struct sm_file *)0, {(unsigned char *)0, 0}, (unsigned char *)0, 0, {(unsigned char)0,
                                                                            (unsigned char)0,
                                                                            (unsigned char)0},
      {(unsigned char)0}, 0, 0L, 0}, 
        {SmFileMagic, (unsigned char *)0, 0, 0, 36L, (short)2, {(unsigned char *)0, 0},
      0, (void *)(SmIoF + 2), 0, & sm_stdclose, & sm_stdread, & sm_stdseek, & sm_stdwrite,
      & sm_stdopen, & sm_stdsetinfo, & sm_stdgetinfo, -1, 0, (char *)"smioerr", (struct sm_file *)0,
      (struct sm_file *)0, {(unsigned char *)0, 0}, (unsigned char *)0, 0, {(unsigned char)0,
                                                                            (unsigned char)0,
                                                                            (unsigned char)0},
      {(unsigned char)0}, 0, 0L, 0}, 
        {SmFileMagic, (unsigned char *)0, 0, 0, 20L, (short)-1, {(unsigned char *)0,
                                                              0}, 0, (void *)0, 0,
      & sm_stdioclose, & sm_stdioread, & sm_stdioseek, & sm_stdiowrite, & sm_stdioopen,
      & sm_stdiosetinfo, & sm_stdiogetinfo, -1, 0, (char *)"smiostdin", (struct sm_file *)0,
      (struct sm_file *)0, {(unsigned char *)0, 0}, (unsigned char *)0, 0, {(unsigned char)0,
                                                                            (unsigned char)0,
                                                                            (unsigned char)0},
      {(unsigned char)0}, 0, 0L, 0}, 
        {SmFileMagic, (unsigned char *)0, 0, 0, 36L, (short)-1, {(unsigned char *)0,
                                                              0}, 0, (void *)0, 1,
      & sm_stdioclose, & sm_stdioread, & sm_stdioseek, & sm_stdiowrite, & sm_stdioopen,
      & sm_stdiosetinfo, & sm_stdiogetinfo, -1, 0, (char *)"smiostdout", (struct sm_file *)0,
      (struct sm_file *)0, {(unsigned char *)0, 0}, (unsigned char *)0, 0, {(unsigned char)0,
                                                                            (unsigned char)0,
                                                                            (unsigned char)0},
      {(unsigned char)0}, 0, 0L, 0}, 
        {SmFileMagic, (unsigned char *)0, 0, 0, 36L, (short)-1, {(unsigned char *)0,
                                                              0}, 0, (void *)0, 2,
      & sm_stdioclose, & sm_stdioread, & sm_stdioseek, & sm_stdiowrite, & sm_stdioopen,
      & sm_stdiosetinfo, & sm_stdiogetinfo, -1, 0, (char *)"smiostderr", (struct sm_file *)0,
      (struct sm_file *)0, {(unsigned char *)0, 0}, (unsigned char *)0, 0, {(unsigned char)0,
                                                                            (unsigned char)0,
                                                                            (unsigned char)0},
      {(unsigned char)0}, 0, 0L, 0}};
#line 99 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
struct sm_glue smglue  =    {& smuglue, 3, SmIoF};
#line 112
static struct sm_glue *sm_moreglue_x(int n ) ;
#line 113 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
static SM_FILE_T empty  ;
#line 115 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
static struct sm_glue *sm_moreglue_x(int n ) 
{ 
  register struct sm_glue *g ;
  register SM_FILE_T *p ;
  void *tmp ;
  SM_FILE_T *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 122
  tmp = sm_malloc_tagged_x((size_t )((sizeof(*g) + ((unsigned long )(& ((struct sm_align *)0)->al_u) - 1UL)) + (unsigned long )n * sizeof(SM_FILE_T )),
                           (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c",
                           123, 0);
#line 122
  g = (struct sm_glue *)tmp;
#line 124
  p = (SM_FILE_T *)(((unsigned long )(g + 1) + ((unsigned long )(& ((struct sm_align *)0)->al_u) - 1UL)) & ~ ((unsigned long )(& ((struct sm_align *)0)->al_u) - 1UL));
#line 125
  g->gl_next = (struct sm_glue *)((void *)0);
#line 126
  g->gl_niobs = n;
#line 127
  g->gl_iobs = p;
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    n --;
#line 128
    if (! (n >= 0)) {
#line 128
      goto while_break;
    }
#line 129
    tmp___0 = p;
#line 129
    p ++;
#line 129
    *tmp___0 = empty;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return (g);
}
}
#line 147 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
SM_FILE_T *sm_fp(SM_FILE_T const   *t , int const   flags , SM_FILE_T *oldfp ) 
{ 
  register SM_FILE_T *fp ;
  register int n ;
  register struct sm_glue *g ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 157
  if (t->f_open) {
#line 157
    if (t->f_close) {
#line 157
      if (t->f_read) {
#line 157
        tmp = 1;
      } else
#line 157
      if (t->f_write) {
#line 157
        tmp = 1;
      } else {
        {
#line 157
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c",
                    157, "SM_REQUIRE(t->f_open && t->f_close && (t->f_read || t->f_write)) failed");
#line 157
        tmp = 0;
        }
      }
    } else {
      {
#line 157
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c",
                  157, "SM_REQUIRE(t->f_open && t->f_close && (t->f_read || t->f_write)) failed");
#line 157
      tmp = 0;
      }
    }
  } else {
    {
#line 157
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c",
                157, "SM_REQUIRE(t->f_open && t->f_close && (t->f_read || t->f_write)) failed");
#line 157
    tmp = 0;
    }
  }
#line 159
  if (! Sm_IO_DidInit) {
    {
#line 160
    sm_init();
    }
  }
#line 162
  if ((unsigned long )oldfp != (unsigned long )((void *)0)) {
#line 164
    fp = oldfp;
#line 165
    goto found;
  }
#line 168
  g = & smglue;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    fp = g->gl_iobs;
#line 170
    n = g->gl_niobs;
    {
#line 170
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 170
      n --;
#line 170
      if (! (n >= 0)) {
#line 170
        goto while_break___0;
      }
#line 171
      if ((unsigned long )fp->sm_magic == (unsigned long )((void *)0)) {
#line 172
        goto found;
      }
#line 170
      fp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 173
    if ((unsigned long )g->gl_next == (unsigned long )((void *)0)) {
      {
#line 174
      g->gl_next = sm_moreglue_x(10);
      }
    }
#line 168
    g = g->gl_next;
  }
  while_break: /* CIL Label */ ;
  }
  found: 
#line 177
  fp->sm_magic = SmFileMagic;
#line 178
  fp->f_p = (unsigned char *)((void *)0);
#line 179
  fp->f_w = 0;
#line 180
  fp->f_r = 0;
#line 181
  fp->f_flags = (long )flags;
#line 182
  fp->f_file = (short)-1;
#line 183
  fp->f_bf.smb_base = (unsigned char *)((void *)0);
#line 184
  fp->f_bf.smb_size = 0;
#line 185
  fp->f_lbfsize = 0;
#line 186
  fp->f_flushfp = (struct sm_file *)((void *)0);
#line 188
  fp->f_cookie = (void *)fp;
#line 189
  fp->f_close = (int (*)(SM_FILE_T * ))t->f_close;
#line 190
  fp->f_read = (ssize_t (*)(SM_FILE_T * , char * , size_t  ))t->f_read;
#line 191
  fp->f_seek = (off_t (*)(SM_FILE_T * , off_t  , int  ))t->f_seek;
#line 192
  fp->f_write = (ssize_t (*)(SM_FILE_T * , char const   * , size_t  ))t->f_write;
#line 193
  fp->f_open = (int (*)(SM_FILE_T * , void const   * , int  , void const   * ))t->f_open;
#line 194
  fp->f_setinfo = (int (*)(SM_FILE_T * , int  , void * ))t->f_setinfo;
#line 195
  fp->f_getinfo = (int (*)(SM_FILE_T * , int  , void * ))t->f_getinfo;
#line 196
  fp->f_type = (char *)t->f_type;
#line 198
  fp->f_ub.smb_base = (unsigned char *)((void *)0);
#line 199
  fp->f_ub.smb_size = 0;
#line 201
  if (fp->f_timeout == -2) {
#line 202
    fp->f_timeout = -1;
  } else {
#line 204
    fp->f_timeout = (int )t->f_timeout;
  }
#line 205
  fp->f_timeoutstate = 0;
#line 207
  return (fp);
}
}
#line 225 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
void sm_cleanup(void) 
{ 
  int timeout ;

  {
  {
#line 228
  timeout = -2;
#line 230
  sm_fwalk(& sm_flush, & timeout);
  }
#line 231
  return;
}
}
#line 246 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
void sm_init(void) 
{ 


  {
#line 249
  if (Sm_IO_DidInit) {
#line 250
    return;
  }
  {
#line 253
  empty.f_type = (char *)((void *)0);
#line 254
  empty.sm_magic = (char const   *)((void *)0);
#line 257
  atexit(& sm_cleanup);
#line 258
  Sm_IO_DidInit = 1;
  }
#line 259
  return;
}
}
#line 282 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
int sm_io_setinfo(SM_FILE_T *fp , int what , void *valp ) 
{ 
  SM_FILE_T *v ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 288
  v = (SM_FILE_T *)valp;
#line 290
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 290
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 290
      tmp = 1;
    } else {
      {
#line 290
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c",
                  290, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 290
      tmp = 0;
      }
    }
  } else {
    {
#line 290
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c",
                290, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 290
    tmp = 0;
    }
  }
  {
#line 293
  if (what == 2) {
#line 293
    goto case_2;
  }
#line 311
  if (what == 7) {
#line 311
    goto case_7;
  }
#line 291
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 301
  fp->f_close = v->f_close;
#line 302
  fp->f_read = v->f_read;
#line 303
  fp->f_seek = v->f_seek;
#line 304
  fp->f_write = v->f_write;
#line 305
  fp->f_open = v->f_open;
#line 306
  fp->f_setinfo = v->f_setinfo;
#line 307
  fp->f_getinfo = v->f_getinfo;
#line 308
  sm_free_tagged((void *)fp->f_type, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c",
                 308);
#line 309
  fp->f_type = sm_strdup_x((char const   *)v->f_type);
  }
#line 310
  return (0);
  case_7: /* CIL Label */ 
#line 312
  fp->f_timeout = *((int *)valp);
#line 313
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 317
  if ((unsigned long )fp->f_setinfo == (unsigned long )((void *)0)) {
    {
#line 319
    tmp___0 = __errno_location();
#line 319
    *tmp___0 = 22;
    }
#line 320
    return (-1);
  } else {
    {
#line 323
    tmp___1 = (*(fp->f_setinfo))(fp, what, valp);
    }
#line 323
    return (tmp___1);
  }
}
}
#line 355 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c"
int sm_io_getinfo(SM_FILE_T *fp , int what , void *valp ) 
{ 
  SM_FILE_T *v ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 361
  v = (SM_FILE_T *)valp;
#line 363
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 363
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 363
      tmp = 1;
    } else {
      {
#line 363
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c",
                  363, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 363
      tmp = 0;
      }
    }
  } else {
    {
#line 363
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/findfp.c",
                363, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 363
    tmp = 0;
    }
  }
  {
#line 367
  if (what == 2) {
#line 367
    goto case_2;
  }
#line 380
  if (what == 4) {
#line 380
    goto case_4;
  }
#line 389
  if (what == 5) {
#line 389
    goto case_5;
  }
#line 397
  if (what == 6) {
#line 397
    goto case_6;
  }
#line 406
  if (what == 7) {
#line 406
    goto case_7;
  }
#line 410
  if (what == 3) {
#line 410
    goto case_3;
  }
#line 365
  goto switch_break;
  case_2: /* CIL Label */ 
#line 370
  v->f_close = fp->f_close;
#line 371
  v->f_read = fp->f_read;
#line 372
  v->f_seek = fp->f_seek;
#line 373
  v->f_write = fp->f_write;
#line 374
  v->f_open = fp->f_open;
#line 375
  v->f_setinfo = fp->f_setinfo;
#line 376
  v->f_getinfo = fp->f_getinfo;
#line 377
  v->f_type = fp->f_type;
#line 378
  return (0);
  case_4: /* CIL Label */ 
#line 381
  if ((unsigned long )valp == (unsigned long )((void *)0)) {
    {
#line 383
    tmp___0 = __errno_location();
#line 383
    *tmp___0 = 22;
    }
#line 384
    return (-1);
  }
  {
#line 386
  tmp___1 = sm_strdup_x((char const   *)fp->f_type);
#line 386
  valp = (void *)tmp___1;
  }
#line 387
  return (0);
  case_5: /* CIL Label */ 
#line 390
  if ((unsigned long )valp == (unsigned long )((void *)0)) {
    {
#line 392
    tmp___2 = __errno_location();
#line 392
    *tmp___2 = 22;
    }
#line 393
    return (-1);
  }
  {
#line 395
  tmp___3 = strcmp((char const   *)fp->f_type, (char const   *)valp);
  }
#line 395
  return (tmp___3 == 0);
  case_6: /* CIL Label */ 
#line 400
  if (fp->f_r > 0) {
#line 401
    return (1);
  }
#line 404
  goto switch_break;
  case_7: /* CIL Label */ 
#line 407
  *((int *)valp) = fp->f_timeout;
#line 408
  return (0);
  case_3: /* CIL Label */ 
#line 411
  if ((int )fp->f_file > -1) {
#line 412
    return ((int )fp->f_file);
  }
#line 415
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 419
  if ((unsigned long )fp->f_getinfo == (unsigned long )((void *)0)) {
    {
#line 421
    tmp___4 = __errno_location();
#line 421
    *tmp___4 = 22;
    }
#line 422
    return (-1);
  }
  {
#line 424
  tmp___5 = (*(fp->f_getinfo))(fp, what, valp);
  }
#line 424
  return (tmp___5);
}
}
#line 272 "../../include/sm/io.h"
char *sm_io_fgets(SM_FILE_T *fp , int timeout , char *buf___16 , int n ) ;
#line 44 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fget.c"
char *sm_io_fgets(SM_FILE_T *fp , int timeout , char *buf___16 , int n ) 
{ 
  register int len___0 ;
  register char *s ;
  register unsigned char *p ;
  register unsigned char *t ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 55
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 55
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 55
      tmp = 1;
    } else {
      {
#line 55
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fget.c",
                  55, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 55
      tmp = 0;
      }
    }
  } else {
    {
#line 55
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fget.c",
                55, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 55
    tmp = 0;
    }
  }
#line 56
  if (n <= 0) {
#line 57
    return ((char *)((void *)0));
  }
#line 59
  s = buf___16;
#line 60
  n --;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (n > 0)) {
#line 61
      goto while_break;
    }
#line 64
    len___0 = fp->f_r;
#line 64
    if (len___0 <= 0) {
      {
#line 72
      tmp___0 = sm_refill(fp, timeout);
      }
#line 72
      if (tmp___0 != 0) {
#line 75
        if ((unsigned long )s == (unsigned long )buf___16) {
#line 76
          return ((char *)((void *)0));
        }
#line 77
        goto while_break;
      }
#line 79
      len___0 = fp->f_r;
    }
#line 81
    p = fp->f_p;
#line 90
    if (len___0 > n) {
#line 91
      len___0 = n;
    }
    {
#line 92
    tmp___1 = memchr((void const   *)((void *)p), '\n', (size_t )len___0);
#line 92
    t = (unsigned char *)tmp___1;
    }
#line 93
    if ((unsigned long )t != (unsigned long )((void *)0)) {
      {
#line 95
      t ++;
#line 95
      len___0 = (int )(t - p);
#line 96
      fp->f_r -= len___0;
#line 97
      fp->f_p = t;
#line 98
      memcpy((void */* __restrict  */)((void *)s), (void const   */* __restrict  */)((void *)p),
             (size_t )len___0);
#line 99
      *(s + len___0) = (char)0;
      }
#line 100
      return (buf___16);
    }
    {
#line 102
    fp->f_r -= len___0;
#line 103
    fp->f_p += len___0;
#line 104
    memcpy((void */* __restrict  */)((void *)s), (void const   */* __restrict  */)((void *)p),
           (size_t )len___0);
#line 105
    s += len___0;
#line 106
    n -= len___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  *s = (char)0;
#line 109
  return (buf___16);
}
}
#line 44 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fflush.c"
int sm_io_flush(SM_FILE_T *fp , int timeout ) 
{ 
  int fd ;
  struct timeval to ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int ret ;
  int tmp___2 ;
  int ret___0 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 52
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 52
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 52
      tmp = 1;
    } else {
      {
#line 52
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fflush.c",
                  52, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 52
      tmp = 0;
      }
    }
  } else {
    {
#line 52
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fflush.c",
                52, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 52
    tmp = 0;
    }
  }
#line 54
  if ((fp->f_flags & 96L) == 0L) {
    {
#line 61
    tmp___0 = __errno_location();
#line 61
    *tmp___0 = 9;
    }
#line 62
    return (-1);
  }
  {
#line 65
  fd = sm_io_getinfo(fp, 3, (void *)0);
  }
#line 65
  if (fd == -1) {
    {
#line 65
    tmp___1 = __errno_location();
#line 65
    *tmp___1 = 0;
    }
  }
#line 65
  if (timeout == -2) {
#line 65
    timeout = fp->f_timeout;
  }
#line 65
  if (timeout == 0) {
#line 65
    to.tv_sec = (__time_t )0;
#line 65
    to.tv_usec = (__suseconds_t )0;
  } else
#line 65
  if (timeout == -1) {
#line 65
    to.tv_sec = (__time_t )0;
#line 65
    to.tv_usec = (__suseconds_t )0;
  } else {
#line 65
    to.tv_sec = (__time_t )(timeout / 1000);
#line 65
    to.tv_usec = ((__time_t )timeout - to.tv_sec * 1000L) * 1000L;
  }
#line 65
  if (timeout == -1) {
#line 65
    if (fp->f_timeoutstate == 1) {
#line 65
      if (fd != -1) {
        {
#line 65
        ret = fcntl(fd, 3, 0);
        }
#line 65
        if (ret == -1) {
#line 65
          return (-1);
        } else {
          {
#line 65
          tmp___2 = fcntl(fd, 4, ret & -2049);
          }
#line 65
          if (tmp___2 == -1) {
#line 65
            return (-1);
          }
        }
#line 65
        fp->f_timeoutstate = 0;
#line 65
        if ((unsigned long )fp->f_modefp != (unsigned long )((void *)0)) {
#line 65
          (fp->f_modefp)->f_timeoutstate = 0;
        }
      }
    }
  } else
#line 65
  if (fp->f_timeoutstate == 0) {
#line 65
    if (fd != -1) {
      {
#line 65
      ret___0 = fcntl(fd, 3, 0);
      }
#line 65
      if (ret___0 == -1) {
#line 65
        return (-1);
      } else {
        {
#line 65
        tmp___3 = fcntl(fd, 4, ret___0 | 2048);
        }
#line 65
        if (tmp___3 == -1) {
#line 65
          return (-1);
        }
      }
#line 65
      fp->f_timeoutstate = 1;
#line 65
      if ((unsigned long )fp->f_modefp != (unsigned long )((void *)0)) {
#line 65
        (fp->f_modefp)->f_timeoutstate = 1;
      }
    }
  }
  {
#line 68
  tmp___4 = sm_flush(fp, & timeout);
  }
#line 68
  return (tmp___4);
}
}
#line 88 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fflush.c"
int sm_flush(SM_FILE_T *fp , int *timeout ) 
{ 
  register unsigned char *p ;
  register int n ;
  register int t ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  struct timeval sm_io_to_before ;
  struct timeval sm_io_to_after ;
  struct timeval sm_io_to_diff ;
  struct timeval sm_io_to ;
  int sm_io_to_sel ;
  fd_set sm_io_to_mask ;
  fd_set sm_io_x_mask ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 97
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 97
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 97
      tmp = 1;
    } else {
      {
#line 97
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fflush.c",
                  97, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 97
      tmp = 0;
      }
    }
  } else {
    {
#line 97
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fflush.c",
                97, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 97
    tmp = 0;
    }
  }
#line 99
  t = (int )fp->f_flags;
#line 100
  if ((t & 32) == 0) {
#line 101
    return (0);
  }
#line 103
  if (t & 2048) {
#line 105
    *(fp->f_p) = (unsigned char )'\000';
#line 106
    return (0);
  }
#line 109
  p = fp->f_bf.smb_base;
#line 109
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 110
    return (0);
  }
  {
#line 112
  n = (int )(fp->f_p - p);
#line 114
  fd = sm_io_getinfo(fp, 3, (void *)0);
  }
#line 114
  if (fd == -1) {
    {
#line 117
    tmp___0 = __errno_location();
#line 117
    *tmp___0 = 0;
#line 118
    fd = -1;
    }
  }
#line 126
  fp->f_p = p;
#line 127
  if (t & 6) {
#line 127
    fp->f_w = 0;
  } else {
#line 127
    fp->f_w = fp->f_bf.smb_size;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (n > 0)) {
#line 129
      goto while_break;
    }
    {
#line 131
    tmp___1 = __errno_location();
#line 131
    *tmp___1 = 0;
#line 134
    t = (*(fp->f_write))(fp, (char const   *)((char *)p), (size_t )n);
    }
#line 135
    if (t <= 0) {
#line 137
      if (t == 0) {
        {
#line 137
        tmp___2 = __errno_location();
        }
#line 137
        if (*tmp___2 == 0) {
#line 138
          goto while_break;
        }
      }
#line 140
      if (fd < 0) {
#line 142
        fp->f_flags |= 256L;
#line 145
        return (-1);
      } else
#line 140
      if (t < 0) {
        {
#line 140
        tmp___3 = __errno_location();
        }
#line 140
        if (*tmp___3 != 11) {
          {
#line 140
          tmp___4 = __errno_location();
          }
#line 140
          if (*tmp___4 != 11) {
#line 142
            fp->f_flags |= 256L;
#line 145
            return (-1);
          } else {
#line 140
            goto _L___0;
          }
        } else {
#line 140
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 140
      if (*timeout == -1) {
#line 142
        fp->f_flags |= 256L;
#line 145
        return (-1);
      }
      {
#line 147
      tmp___5 = __errno_location();
#line 147
      *tmp___5 = 0;
      }
#line 147
      if (*timeout == -2) {
#line 147
        *timeout = fp->f_timeout;
      }
#line 147
      if (*timeout == 0) {
        {
#line 147
        tmp___6 = __errno_location();
#line 147
        *tmp___6 = 11;
        }
#line 147
        return (-1);
      } else
#line 147
      if (*timeout == -1) {
        {
#line 147
        tmp___7 = __errno_location();
#line 147
        *tmp___7 = 22;
        }
#line 147
        return (-1);
      } else {
#line 147
        sm_io_to.tv_sec = (__time_t )(*timeout / 1000);
#line 147
        sm_io_to.tv_usec = ((__time_t )*timeout - sm_io_to.tv_sec * 1000L) * 1000L;
      }
#line 147
      if (fd >= 1024) {
        {
#line 147
        tmp___8 = __errno_location();
#line 147
        *tmp___8 = 22;
        }
#line 147
        return (-1);
      }
      {
#line 147
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 147
        __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0),
                             "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& sm_io_to_mask.__fds_bits[0]): "memory");
#line 147
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 147
      __asm__  volatile   ("btsl %1,%0": "=m" (sm_io_to_mask.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                           "memory");
      {
#line 147
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 147
        __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                             "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& sm_io_x_mask.__fds_bits[0]): "memory");
#line 147
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 147
      __asm__  volatile   ("btsl %1,%0": "=m" (sm_io_x_mask.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                           "memory");
#line 147
      tmp___9 = gettimeofday((struct timeval */* __restrict  */)(& sm_io_to_before),
                             (__timezone_ptr_t )((void *)0));
      }
#line 147
      if (tmp___9 < 0) {
#line 147
        return (-1);
      }
      {
#line 147
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 147
        sm_io_to_sel = select(fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& sm_io_to_mask),
                              (fd_set */* __restrict  */)(& sm_io_x_mask), (struct timeval */* __restrict  */)(& sm_io_to));
        }
#line 147
        if (sm_io_to_sel < 0) {
          {
#line 147
          tmp___10 = __errno_location();
          }
#line 147
          if (! (*tmp___10 == 4)) {
#line 147
            goto while_break___2;
          }
        } else {
#line 147
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 147
      if (sm_io_to_sel < 0) {
#line 147
        return (-1);
      } else
#line 147
      if (sm_io_to_sel == 0) {
        {
#line 147
        tmp___11 = __errno_location();
#line 147
        *tmp___11 = 11;
        }
#line 147
        return (-1);
      }
      {
#line 147
      tmp___12 = gettimeofday((struct timeval */* __restrict  */)(& sm_io_to_after),
                              (__timezone_ptr_t )((void *)0));
      }
#line 147
      if (tmp___12 < 0) {
#line 147
        return (-1);
      }
      {
#line 147
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 147
        sm_io_to_diff.tv_sec = sm_io_to_after.tv_sec - sm_io_to_before.tv_sec;
#line 147
        sm_io_to_diff.tv_usec = sm_io_to_after.tv_usec - sm_io_to_before.tv_usec;
#line 147
        if (sm_io_to_diff.tv_usec < 0L) {
#line 147
          (sm_io_to_diff.tv_sec) --;
#line 147
          sm_io_to_diff.tv_usec += 1000000L;
        }
#line 147
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 147
      *timeout = (int )((__time_t )*timeout - sm_io_to_diff.tv_sec * 1000L);
#line 147
      *timeout = (int )((__suseconds_t )*timeout - sm_io_to_diff.tv_usec / 1000L);
#line 147
      if (*timeout < 0) {
#line 147
        *timeout = 0;
      }
#line 148
      t = 0;
    }
#line 129
    n -= t;
#line 129
    p += t;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return (0);
}
}
#line 271 "../../include/sm/io.h"
int sm_io_error(SM_FILE_T *fp ) ;
#line 34 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/ferror.c"
int sm_io_error(SM_FILE_T *fp ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 38
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 38
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 38
      tmp = 1;
    } else {
      {
#line 38
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/ferror.c",
                  38, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 38
      tmp = 0;
      }
    }
  } else {
    {
#line 38
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/ferror.c",
                38, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 38
    tmp = 0;
    }
  }
#line 40
  return ((fp->f_flags & 256L) != 0L);
}
}
#line 270 "../../include/sm/io.h"
int sm_io_eof(SM_FILE_T *fp ) ;
#line 35 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/feof.c"
int sm_io_eof(SM_FILE_T *fp ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 39
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 39
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 39
      tmp = 1;
    } else {
      {
#line 39
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/feof.c",
                  39, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 39
      tmp = 0;
      }
    }
  } else {
    {
#line 39
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/feof.c",
                39, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 39
    tmp = 0;
    }
  }
#line 41
  return ((fp->f_flags & 128L) != 0L);
}
}
#line 29 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fclose.c"
static void closealrm(int sig ) ;
#line 30 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fclose.c"
static sigjmp_buf CloseTimeOut  ;
#line 52 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fclose.c"
static void closealrm(int sig ) 
{ 


  {
  {
#line 56
  siglongjmp((struct __jmp_buf_tag *)(CloseTimeOut), 1);
  }
}
}
#line 74 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fclose.c"
int sm_io_close(SM_FILE_T *fp , int timeout ) 
{ 
  register int r ;
  SM_EVENT *evt ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 80
  evt = (SM_EVENT *)((void *)0);
#line 82
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 84
    tmp = __errno_location();
#line 84
    *tmp = 9;
    }
#line 85
    return (-1);
  }
#line 88
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 88
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 88
      tmp___0 = 1;
    } else {
      {
#line 88
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fclose.c",
                  88, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 88
      tmp___0 = 0;
      }
    }
  } else {
    {
#line 88
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fclose.c",
                88, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 88
    tmp___0 = 0;
    }
  }
#line 91
  if ((unsigned long )fp->sm_magic == (unsigned long )((void *)0)) {
    {
#line 94
    tmp___1 = __errno_location();
#line 94
    *tmp___1 = 9;
    }
#line 95
    return (-1);
  }
#line 97
  if ((unsigned long )fp->f_close == (unsigned long )((void *)0)) {
    {
#line 100
    tmp___2 = __errno_location();
#line 100
    *tmp___2 = 19;
    }
#line 101
    return (-1);
  }
#line 103
  if (fp->f_dup_cnt > 0) {
#line 106
    (fp->f_dup_cnt) --;
#line 107
    return (0);
  }
#line 111
  if (timeout == -2) {
#line 112
    timeout = fp->f_timeout;
  }
#line 113
  if (timeout == 0) {
    {
#line 115
    tmp___3 = __errno_location();
#line 115
    *tmp___3 = 11;
    }
#line 116
    return (-1);
  }
#line 120
  if (fp->f_flags & 32L) {
    {
#line 120
    tmp___4 = sm_flush(fp, & timeout);
#line 120
    r = tmp___4;
    }
  } else {
#line 120
    r = 0;
  }
#line 123
  if (timeout != -1) {
    {
#line 125
    tmp___6 = __sigsetjmp((struct __jmp_buf_tag *)(CloseTimeOut), 1);
    }
#line 125
    if (tmp___6 != 0) {
      {
#line 127
      tmp___5 = __errno_location();
#line 127
      *tmp___5 = 11;
      }
#line 128
      return (-1);
    }
    {
#line 130
    evt = sm_seteventm(timeout, & closealrm, 0);
    }
  }
  {
#line 132
  tmp___7 = (*(fp->f_close))(fp);
  }
#line 132
  if (tmp___7 < 0) {
#line 133
    r = -1;
  }
#line 136
  if ((unsigned long )evt != (unsigned long )((void *)0)) {
    {
#line 137
    sm_clrevent(evt);
    }
  }
#line 138
  if (fp->f_flags & 512L) {
    {
#line 140
    sm_free_tagged((void *)((char *)fp->f_bf.smb_base), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fclose.c",
                   140);
#line 141
    fp->f_bf.smb_base = (unsigned char *)((void *)0);
    }
  }
#line 143
  if ((unsigned long )fp->f_ub.smb_base != (unsigned long )((void *)0)) {
#line 144
    if ((unsigned long )fp->f_ub.smb_base != (unsigned long )(fp->f_ubuf)) {
      {
#line 144
      sm_free_tagged((void *)((char *)fp->f_ub.smb_base), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/fclose.c",
                     144);
      }
    }
#line 144
    fp->f_ub.smb_base = (unsigned char *)((void *)0);
  }
#line 145
  fp->f_flags = 0L;
#line 146
  fp->sm_magic = (char const   *)((void *)0);
#line 147
  tmp___8 = 0;
#line 147
  fp->f_w = tmp___8;
#line 147
  fp->f_r = tmp___8;
#line 148
  return (r);
}
}
#line 45 "../../include/sm/exc.h"
struct sm_exc_type  const  SmEtypeErr ;
#line 82
SM_EXC_T *sm_exc_new_x(SM_EXC_TYPE_T const   *etype  , ...) ;
#line 100
void sm_exc_write(SM_EXC_T *exc , SM_FILE_T *stream ) ;
#line 105
void sm_exc_print(SM_EXC_T *exc , SM_FILE_T *stream ) ;
#line 125
void sm_exc_newthread(void (*h)(SM_EXC_T * ) ) ;
#line 29 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
char const   SmExcMagic[7]  = {      (char const   )'s',      (char const   )'m',      (char const   )'_',      (char const   )'e', 
        (char const   )'x',      (char const   )'c',      (char const   )'\000'};
#line 30 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
char const   SmExcTypeMagic[12]  = 
#line 30
  {      (char const   )'s',      (char const   )'m',      (char const   )'_',      (char const   )'e', 
        (char const   )'x',      (char const   )'c',      (char const   )'_',      (char const   )'t', 
        (char const   )'y',      (char const   )'p',      (char const   )'e',      (char const   )'\000'};
#line 51 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
void sm_etype_printf(SM_EXC_T *exc , SM_FILE_T *stream ) 
{ 
  size_t n ;
  size_t tmp ;
  char const   *p ;
  char const   *s ;
  char format ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t i ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 56
  tmp = strlen((char const   *)(exc->exc_type)->etype_argformat);
#line 56
  n = tmp;
#line 60
  p = (char const   *)(exc->exc_type)->etype_printcontext;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((int const   )*p != 0)) {
#line 60
      goto while_break;
    }
#line 62
    if ((int const   )*p != 37) {
      {
#line 64
      sm_io_putc(stream, -2, (int )*p);
      }
#line 65
      goto __Cont;
    }
#line 67
    p ++;
#line 68
    if ((int const   )*p == 0) {
      {
#line 70
      sm_io_putc(stream, -2, '%');
      }
#line 71
      goto while_break;
    }
#line 73
    if ((int const   )*p == 37) {
      {
#line 75
      sm_io_putc(stream, -2, '%');
      }
#line 76
      goto __Cont;
    }
    {
#line 78
    format = (char )'\000';
#line 79
    tmp___1 = __ctype_b_loc();
    }
#line 79
    if ((int const   )*(*tmp___1 + (int )*p) & 1024) {
#line 81
      tmp___0 = p;
#line 81
      p ++;
#line 81
      format = (char )*tmp___0;
#line 82
      if ((int const   )*p == 0) {
        {
#line 84
        sm_io_putc(stream, -2, '%');
#line 85
        sm_io_putc(stream, -2, (int )format);
        }
#line 87
        goto while_break;
      }
    }
    {
#line 90
    tmp___6 = __ctype_b_loc();
    }
#line 90
    if ((int const   )*(*tmp___6 + (int )*p) & 2048) {
#line 92
      i = (size_t )((int const   )*p - 48);
#line 93
      if (i < n) {
        {
#line 98
        if ((int const   )*((exc->exc_type)->etype_argformat + i) == 114) {
#line 98
          goto case_114;
        }
#line 98
        if ((int const   )*((exc->exc_type)->etype_argformat + i) == 115) {
#line 98
          goto case_114;
        }
#line 104
        if ((int const   )*((exc->exc_type)->etype_argformat + i) == 105) {
#line 104
          goto case_105;
        }
#line 112
        if ((int const   )*((exc->exc_type)->etype_argformat + i) == 108) {
#line 112
          goto case_108;
        }
#line 120
        if ((int const   )*((exc->exc_type)->etype_argformat + i) == 101) {
#line 120
          goto case_101;
        }
#line 95
        goto switch_break;
        case_114: /* CIL Label */ 
        case_115: /* CIL Label */ 
#line 99
        s = (char const   *)(exc->exc_argv + i)->v_str;
#line 100
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 101
          s = "(null)";
        }
        {
#line 102
        sm_io_fputs(stream, -2, s);
        }
#line 103
        goto __Cont;
        case_105: /* CIL Label */ 
#line 105
        if ((int )format == 111) {
#line 105
          tmp___3 = "%o";
        } else {
#line 105
          if ((int )format == 120) {
#line 105
            tmp___2 = "%x";
          } else {
#line 105
            tmp___2 = "%d";
          }
#line 105
          tmp___3 = tmp___2;
        }
        {
#line 105
        sm_io_fprintf(stream, -2, tmp___3, (exc->exc_argv + i)->v_int);
        }
#line 111
        goto __Cont;
        case_108: /* CIL Label */ 
#line 113
        if ((int )format == 111) {
#line 113
          tmp___5 = "%lo";
        } else {
#line 113
          if ((int )format == 120) {
#line 113
            tmp___4 = "%lx";
          } else {
#line 113
            tmp___4 = "%ld";
          }
#line 113
          tmp___5 = tmp___4;
        }
        {
#line 113
        sm_io_fprintf(stream, -2, tmp___5, (exc->exc_argv + i)->v_long);
        }
#line 119
        goto __Cont;
        case_101: /* CIL Label */ 
        {
#line 121
        sm_exc_write((exc->exc_argv + i)->v_exc, stream);
        }
#line 123
        goto __Cont;
        switch_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 127
    sm_io_putc(stream, -2, '%');
    }
#line 128
    if (format) {
      {
#line 129
      sm_io_putc(stream, -2, (int )format);
      }
    }
    {
#line 130
    sm_io_putc(stream, -2, (int )*p);
    }
    __Cont: /* CIL Label */ 
#line 60
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return;
}
}
#line 149
static void sm_etype_os_print(SM_EXC_T *exc , SM_FILE_T *stream ) ;
#line 154 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
static void sm_etype_os_print(SM_EXC_T *exc , SM_FILE_T *stream ) 
{ 
  int err ;
  char *syscall ;
  char *sysargs ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 159
  err = (exc->exc_argv + 0)->v_int;
#line 160
  syscall = (exc->exc_argv + 1)->v_str;
#line 161
  sysargs = (exc->exc_argv + 2)->v_str;
#line 163
  if (sysargs) {
    {
#line 164
    tmp = sm_errstring(err);
#line 164
    sm_io_fprintf(stream, -2, "%s: %s failed: %s", sysargs, syscall, tmp);
    }
  } else {
    {
#line 167
    tmp___0 = sm_errstring(err);
#line 167
    sm_io_fprintf(stream, -2, "%s failed: %s", syscall, tmp___0);
    }
  }
#line 169
  return;
}
}
#line 179 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
struct sm_exc_type  const  SmEtypeOs  =    {SmExcTypeMagic, "E:sm.os", "isr", & sm_etype_os_print, (char const   *)((void *)0)};
#line 194 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
struct sm_exc_type  const  SmEtypeErr  =    {SmExcTypeMagic, "E:sm.err", "r", & sm_etype_printf, "%0"};
#line 232 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
SM_EXC_T *sm_exc_vnew_x(SM_EXC_TYPE_T const   *etype , va_list ap ) 
{ 
  SM_EXC_T * volatile  exc ;
  int volatile   si ;
  SM_VAL_T * volatile  argv ;
  int i ;
  int argc ;
  int tmp ;
  size_t tmp___0 ;
  SM_EXC_HANDLER_T _h ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  SM_EXC_T *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *str ;
  char *fmt ;
  int tmp___9 ;
  int tmp___10 ;
  bool tmp___12 ;
  SM_EXC_T *e  __attribute__((__unused__)) ;
  int tmp___14 ;
  long tmp___16 ;
  SM_EXC_T *tmp___18 ;
  char *tmp___20 ;
  int tmp___21 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 243
  exc = (SM_EXC_T */* volatile  */)((void *)0);
#line 244
  si = (int volatile   )0;
#line 245
  argv = (SM_VAL_T */* volatile  */)((void *)0);
#line 248
  if ((unsigned long )etype != (unsigned long )((void *)0)) {
#line 248
    if ((unsigned long )etype->sm_magic == (unsigned long )(SmExcTypeMagic)) {
#line 248
      tmp = 1;
    } else {
      {
#line 248
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                  248, "SM_REQUIRE((etype) != NULL && (etype)->sm_magic == (SmExcTypeMagic)) failed");
#line 248
      tmp = 0;
      }
    }
  } else {
    {
#line 248
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                248, "SM_REQUIRE((etype) != NULL && (etype)->sm_magic == (SmExcTypeMagic)) failed");
#line 248
    tmp = 0;
    }
  }
  {
#line 249
  tmp___0 = strlen((char const   *)etype->etype_argformat);
#line 249
  argc = (int )tmp___0;
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 250
    _h.eh_value = (SM_EXC_T *)((void *)0);
#line 250
    _h.eh_parent = SmExcHandler;
#line 250
    _h.eh_state = 2;
#line 250
    SmExcHandler = & _h;
#line 250
    tmp___9 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 250
    if (tmp___9 == 0) {
      {
#line 258
      tmp___1 = sm_malloc_tagged_x((size_t )sizeof(SM_EXC_T ), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                                   258, SmHeapGroup);
#line 258
      exc = (SM_EXC_T */* volatile  */)tmp___1;
#line 259
      exc->sm_magic = SmExcMagic;
#line 260
      exc->exc_refcount = (size_t )1;
#line 261
      exc->exc_type = etype;
#line 262
      exc->exc_argv = (SM_VAL_T *)((void *)0);
#line 271
      tmp___2 = sm_malloc_tagged_x((size_t )((unsigned long )argc * sizeof(SM_VAL_T )),
                                   (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                                   271, SmHeapGroup);
#line 271
      argv = (SM_VAL_T */* volatile  */)tmp___2;
#line 272
      exc->exc_argv = (SM_VAL_T *)argv;
#line 273
      i = 0;
      }
      {
#line 273
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 273
        if (! (i < argc)) {
#line 273
          goto while_break___0;
        }
        {
#line 277
        if ((int const   )*(etype->etype_argformat + i) == 105) {
#line 277
          goto case_105;
        }
#line 280
        if ((int const   )*(etype->etype_argformat + i) == 108) {
#line 280
          goto case_108;
        }
#line 283
        if ((int const   )*(etype->etype_argformat + i) == 101) {
#line 283
          goto case_101;
        }
#line 286
        if ((int const   )*(etype->etype_argformat + i) == 115) {
#line 286
          goto case_115;
        }
#line 289
        if ((int const   )*(etype->etype_argformat + i) == 114) {
#line 289
          goto case_114;
        }
#line 293
        goto switch_default;
        case_105: /* CIL Label */ 
        {
#line 278
        tmp___3 = __builtin_va_arg(ap, int );
#line 278
        (argv + i)->v_int = tmp___3;
        }
#line 279
        goto switch_break;
        case_108: /* CIL Label */ 
        {
#line 281
        tmp___4 = __builtin_va_arg(ap, long );
#line 281
        (argv + i)->v_long = tmp___4;
        }
#line 282
        goto switch_break;
        case_101: /* CIL Label */ 
        {
#line 284
        tmp___5 = __builtin_va_arg(ap, SM_EXC_T *);
#line 284
        (argv + i)->v_exc = tmp___5;
        }
#line 285
        goto switch_break;
        case_115: /* CIL Label */ 
        {
#line 287
        tmp___6 = __builtin_va_arg(ap, char *);
#line 287
        (argv + i)->v_str = tmp___6;
        }
#line 288
        goto switch_break;
        case_114: /* CIL Label */ 
#line 290
        if ((int const   )*(etype->etype_argformat + (i + 1)) == 0) {
#line 290
          tmp___7 = 1;
        } else {
          {
#line 290
          sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                      290, "SM_REQUIRE(etype->etype_argformat[i+1] == \'\\0\') failed");
#line 290
          tmp___7 = 0;
          }
        }
        {
#line 291
        tmp___8 = __builtin_va_arg(ap, char *);
#line 291
        (argv + i)->v_str = tmp___8;
        }
#line 292
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 294
        sm_abort((char *)"sm_exc_vnew_x: bad argformat \'%c\'", (int const   )*(etype->etype_argformat + i));
        }
        switch_break: /* CIL Label */ ;
        }
#line 273
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 307
      si = (int volatile   )0;
      {
#line 307
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 307
        if (! (si < (int volatile   )argc)) {
#line 307
          goto while_break___1;
        }
        {
#line 311
        if ((int const   )*(etype->etype_argformat + si) == 115) {
#line 311
          goto case_115___0;
        }
#line 318
        if ((int const   )*(etype->etype_argformat + si) == 114) {
#line 318
          goto case_114___0;
        }
#line 309
        goto switch_break___0;
        case_115___0: /* CIL Label */ 
#line 313
        str = (argv + si)->v_str;
#line 314
        if ((unsigned long )str != (unsigned long )((void *)0)) {
          {
#line 315
          (argv + si)->v_str = sm_strdup_x((char const   *)str);
          }
        }
#line 317
        goto switch_break___0;
        case_114___0: /* CIL Label */ 
#line 320
        fmt = (argv + si)->v_str;
#line 321
        if ((unsigned long )fmt != (unsigned long )((void *)0)) {
          {
#line 322
          (argv + si)->v_str = sm_vstringf_x((char const   *)fmt, ap);
          }
        }
#line 324
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 307
        si += (int volatile   )1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 328
    if (_h.eh_state == 1) {
#line 328
      goto while_break;
    }
#line 328
    if (_h.eh_state == 2) {
#line 328
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 328
        tmp___10 = 1;
      } else {
        {
#line 328
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                    328, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 328
        tmp___10 = 0;
        }
      }
#line 328
      SmExcHandler = _h.eh_parent;
    }
    {
#line 328
    tmp___12 = sm_exc_match(_h.eh_value, "*");
    }
#line 328
    if (tmp___12) {
#line 328
      _h.eh_state = 1;
    } else {
#line 328
      _h.eh_state = 0;
    }
#line 328
    if (_h.eh_state == 1) {
#line 328
      e = _h.eh_value;
#line 330
      if ((unsigned long )exc == (unsigned long )((void *)0)) {
#line 330
        goto _L;
      } else
#line 330
      if ((unsigned long )argv == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 337
        i = 0;
        {
#line 337
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 337
          if (! (i < argc)) {
#line 337
            goto while_break___2;
          }
          {
#line 341
          if ((int const   )*(etype->etype_argformat + i) == 105) {
#line 341
            goto case_105___0;
          }
#line 344
          if ((int const   )*(etype->etype_argformat + i) == 108) {
#line 344
            goto case_108___0;
          }
#line 347
          if ((int const   )*(etype->etype_argformat + i) == 101) {
#line 347
            goto case_101___0;
          }
#line 351
          if ((int const   )*(etype->etype_argformat + i) == 114) {
#line 351
            goto case_114___1;
          }
#line 351
          if ((int const   )*(etype->etype_argformat + i) == 115) {
#line 351
            goto case_114___1;
          }
#line 339
          goto switch_break___1;
          case_105___0: /* CIL Label */ 
          {
#line 342
          tmp___14 = __builtin_va_arg(ap, int );
          }
#line 343
          goto switch_break___1;
          case_108___0: /* CIL Label */ 
          {
#line 345
          tmp___16 = __builtin_va_arg(ap, long );
          }
#line 346
          goto switch_break___1;
          case_101___0: /* CIL Label */ 
          {
#line 348
          tmp___18 = __builtin_va_arg(ap, SM_EXC_T *);
#line 348
          sm_exc_free(tmp___18);
          }
#line 349
          goto switch_break___1;
          case_114___1: /* CIL Label */ 
          case_115___1: /* CIL Label */ 
          {
#line 352
          tmp___20 = __builtin_va_arg(ap, char *);
          }
#line 353
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
#line 337
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 366
        i = 0;
        {
#line 366
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 366
          if (! (i < argc)) {
#line 366
            goto while_break___3;
          }
          {
#line 370
          if ((int const   )*(etype->etype_argformat + i) == 101) {
#line 370
            goto case_101___1;
          }
#line 374
          if ((int const   )*(etype->etype_argformat + i) == 114) {
#line 374
            goto case_114___2;
          }
#line 374
          if ((int const   )*(etype->etype_argformat + i) == 115) {
#line 374
            goto case_114___2;
          }
#line 368
          goto switch_break___2;
          case_101___1: /* CIL Label */ 
          {
#line 371
          sm_exc_free((argv + i)->v_exc);
          }
#line 372
          goto switch_break___2;
          case_114___2: /* CIL Label */ 
          case_115___2: /* CIL Label */ 
#line 375
          if (i < (int )si) {
            {
#line 376
            sm_free_tagged((void *)(argv + i)->v_str, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                           376);
            }
          }
#line 377
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
#line 366
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 380
        sm_free_tagged((void *)argv, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                       380);
        }
      }
      {
#line 382
      sm_free_tagged((void *)exc, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                     382);
#line 383
      sm_exc_raise_x(e);
      }
    }
#line 250
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (_h.eh_state == 2) {
#line 385
    if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 385
      tmp___21 = 1;
    } else {
      {
#line 385
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                  385, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 385
      tmp___21 = 0;
      }
    }
#line 385
    SmExcHandler = _h.eh_parent;
#line 385
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 385
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else
#line 385
  if (_h.eh_state == 0) {
#line 385
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 385
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else {
    {
#line 385
    sm_exc_free(_h.eh_value);
    }
  }
#line 387
  return ((SM_EXC_T *)exc);
}
}
#line 401 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
SM_EXC_T *sm_exc_new_x(SM_EXC_TYPE_T const   *etype  , ...) 
{ 
  SM_EXC_T *exc ;
  va_list ap ;

  {
  {
#line 415
  __builtin_va_start(ap, etype);
#line 416
  exc = sm_exc_vnew_x(etype, ap);
#line 417
  __builtin_va_end(ap);
  }
#line 418
  return (exc);
}
}
#line 431 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
SM_EXC_T *sm_addref(SM_EXC_T *exc ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 435
  if ((unsigned long )exc != (unsigned long )((void *)0)) {
#line 435
    if ((unsigned long )exc->sm_magic == (unsigned long )(SmExcMagic)) {
#line 435
      tmp = 1;
    } else {
      {
#line 435
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                  435, "SM_REQUIRE((exc) != NULL && (exc)->sm_magic == (SmExcMagic)) failed");
#line 435
      tmp = 0;
      }
    }
  } else {
    {
#line 435
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                435, "SM_REQUIRE((exc) != NULL && (exc)->sm_magic == (SmExcMagic)) failed");
#line 435
    tmp = 0;
    }
  }
#line 436
  if (exc->exc_refcount != 0U) {
#line 437
    (exc->exc_refcount) ++;
  }
#line 438
  return (exc);
}
}
#line 451 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
void sm_exc_free(SM_EXC_T *exc ) 
{ 
  int tmp ;
  int i ;
  int c ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 455
  if ((unsigned long )exc == (unsigned long )((void *)0)) {
#line 456
    return;
  }
#line 457
  if ((unsigned long )exc->sm_magic == (unsigned long )(SmExcMagic)) {
#line 457
    tmp = 1;
  } else {
    {
#line 457
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                457, "SM_REQUIRE(exc->sm_magic == SmExcMagic) failed");
#line 457
    tmp = 0;
    }
  }
#line 458
  if (exc->exc_refcount == 0U) {
#line 459
    return;
  }
#line 460
  (exc->exc_refcount) --;
#line 460
  if (exc->exc_refcount == 0U) {
#line 464
    i = 0;
    {
#line 464
    while (1) {
      while_continue: /* CIL Label */ ;
#line 464
      c = (int )*((exc->exc_type)->etype_argformat + i);
#line 464
      if (! (c != 0)) {
#line 464
        goto while_break;
      }
      {
#line 470
      if (c == 114) {
#line 470
        goto case_114;
      }
#line 470
      if (c == 115) {
#line 470
        goto case_114;
      }
#line 473
      if (c == 101) {
#line 473
        goto case_101;
      }
#line 467
      goto switch_break;
      case_114: /* CIL Label */ 
      case_115: /* CIL Label */ 
      {
#line 471
      sm_free_tagged((void *)(exc->exc_argv + i)->v_str, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                     471);
      }
#line 472
      goto switch_break;
      case_101: /* CIL Label */ 
      {
#line 474
      sm_exc_free((exc->exc_argv + i)->v_exc);
      }
#line 475
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 464
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 478
    exc->sm_magic = (char const   *)((void *)0);
#line 479
    sm_free_tagged((void *)exc->exc_argv, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                   479);
#line 480
    sm_free_tagged((void *)exc, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                   480);
    }
  }
#line 482
  return;
}
}
#line 495 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
bool sm_exc_match(SM_EXC_T *exc , char const   *pattern ) 
{ 
  int tmp ;
  bool tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 500
  if ((unsigned long )exc == (unsigned long )((void *)0)) {
#line 501
    return (0);
  }
#line 502
  if ((unsigned long )exc->sm_magic == (unsigned long )(SmExcMagic)) {
#line 502
    tmp = 1;
  } else {
    {
#line 502
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                502, "SM_REQUIRE(exc->sm_magic == SmExcMagic) failed");
#line 502
    tmp = 0;
    }
  }
  {
#line 503
  tmp___0 = sm_match((char const   *)(exc->exc_type)->etype_category, pattern);
  }
#line 503
  return (tmp___0);
}
}
#line 517 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
void sm_exc_write(SM_EXC_T *exc , SM_FILE_T *stream ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 522
  if ((unsigned long )exc != (unsigned long )((void *)0)) {
#line 522
    if ((unsigned long )exc->sm_magic == (unsigned long )(SmExcMagic)) {
#line 522
      tmp = 1;
    } else {
      {
#line 522
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                  522, "SM_REQUIRE((exc) != NULL && (exc)->sm_magic == (SmExcMagic)) failed");
#line 522
      tmp = 0;
      }
    }
  } else {
    {
#line 522
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                522, "SM_REQUIRE((exc) != NULL && (exc)->sm_magic == (SmExcMagic)) failed");
#line 522
    tmp = 0;
    }
  }
  {
#line 523
  (*((exc->exc_type)->etype_print))(exc, stream);
  }
#line 524
  return;
}
}
#line 537 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
void sm_exc_print(SM_EXC_T *exc , SM_FILE_T *stream ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 542
  if ((unsigned long )exc != (unsigned long )((void *)0)) {
#line 542
    if ((unsigned long )exc->sm_magic == (unsigned long )(SmExcMagic)) {
#line 542
      tmp = 1;
    } else {
      {
#line 542
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                  542, "SM_REQUIRE((exc) != NULL && (exc)->sm_magic == (SmExcMagic)) failed");
#line 542
      tmp = 0;
      }
    }
  } else {
    {
#line 542
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                542, "SM_REQUIRE((exc) != NULL && (exc)->sm_magic == (SmExcMagic)) failed");
#line 542
    tmp = 0;
    }
  }
  {
#line 543
  (*((exc->exc_type)->etype_print))(exc, stream);
#line 544
  sm_io_putc(stream, -2, '\n');
  }
#line 545
  return;
}
}
#line 547 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
SM_EXC_HANDLER_T *SmExcHandler  =    (SM_EXC_HANDLER_T *)((void *)0);
#line 548 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
static void (*SmExcDefaultHandler)(SM_EXC_T * )  =    (void (*)(SM_EXC_T * ))((void *)0);
#line 572 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
void sm_exc_newthread(void (*h)(SM_EXC_T * ) ) 
{ 


  {
#line 576
  SmExcHandler = (SM_EXC_HANDLER_T *)((void *)0);
#line 577
  SmExcDefaultHandler = h;
#line 578
  return;
}
}
#line 590
 __attribute__((__noreturn__)) void sm_exc_raise_x(SM_EXC_T *exc ) ;
#line 590 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
void sm_exc_raise_x(SM_EXC_T *exc ) 
{ 
  int tmp ;
  void (*h)(SM_EXC_T * ) ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 594
  if ((unsigned long )exc != (unsigned long )((void *)0)) {
#line 594
    if ((unsigned long )exc->sm_magic == (unsigned long )(SmExcMagic)) {
#line 594
      tmp = 1;
    } else {
      {
#line 594
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                  594, "SM_REQUIRE((exc) != NULL && (exc)->sm_magic == (SmExcMagic)) failed");
#line 594
      tmp = 0;
      }
    }
  } else {
    {
#line 594
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c",
                594, "SM_REQUIRE((exc) != NULL && (exc)->sm_magic == (SmExcMagic)) failed");
#line 594
    tmp = 0;
    }
  }
#line 596
  if ((unsigned long )SmExcHandler == (unsigned long )((void *)0)) {
#line 598
    if ((unsigned long )SmExcDefaultHandler != (unsigned long )((void *)0)) {
      {
#line 614
      h = SmExcDefaultHandler;
#line 615
      SmExcDefaultHandler = (void (*)(SM_EXC_T * ))((void *)0);
#line 616
      (*h)(exc);
      }
    }
    {
#line 628
    sm_exc_print(exc, & SmIoF[2]);
#line 629
    exit(255);
    }
  }
#line 632
  if ((unsigned long )SmExcHandler->eh_value == (unsigned long )((void *)0)) {
#line 633
    SmExcHandler->eh_value = exc;
  } else {
    {
#line 635
    sm_exc_free(exc);
    }
  }
  {
#line 637
  siglongjmp((struct __jmp_buf_tag *)(SmExcHandler->eh_context), 1);
  }
}
}
#line 651
 __attribute__((__noreturn__)) void sm_exc_raisenew_x(SM_EXC_TYPE_T const   *etype 
                                                      , ...) ;
#line 651 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/exc.c"
void sm_exc_raisenew_x(SM_EXC_TYPE_T const   *etype  , ...) 
{ 
  SM_EXC_T *exc ;
  va_list ap ;

  {
  {
#line 665
  __builtin_va_start(ap, etype);
#line 666
  exc = sm_exc_vnew_x(etype, ap);
#line 667
  __builtin_va_end(ap);
#line 668
  sm_exc_raise_x(exc);
  }
}
}
#line 256 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int _errno ) ;
#line 277 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/errstring.c"
static char buf___0[30]  ;
#line 49 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/errstring.c"
char const   *sm_errstring(int errnum ) 
{ 
  char *ret ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 58
  if (errnum == 1) {
#line 58
    goto case_1;
  }
#line 66
  if (errnum == 256) {
#line 66
    goto case_256;
  }
#line 69
  if (errnum == 257) {
#line 69
    goto case_257;
  }
#line 72
  if (errnum == 258) {
#line 72
    goto case_258;
  }
#line 75
  if (errnum == 259) {
#line 75
    goto case_259;
  }
#line 78
  if (errnum == 260) {
#line 78
    goto case_260;
  }
#line 81
  if (errnum == 261) {
#line 81
    goto case_261;
  }
#line 84
  if (errnum == 262) {
#line 84
    goto case_262;
  }
#line 87
  if (errnum == 263) {
#line 87
    goto case_263;
  }
#line 90
  if (errnum == 264) {
#line 90
    goto case_264;
  }
#line 93
  if (errnum == 265) {
#line 93
    goto case_265;
  }
#line 96
  if (errnum == 266) {
#line 96
    goto case_266;
  }
#line 99
  if (errnum == 267) {
#line 99
    goto case_267;
  }
#line 124
  if (errnum == 297) {
#line 124
    goto case_297;
  }
#line 127
  if (errnum == 298) {
#line 127
    goto case_298;
  }
#line 130
  if (errnum == 299) {
#line 130
    goto case_299;
  }
#line 133
  if (errnum == 300) {
#line 133
    goto case_300;
  }
#line 136
  if (errnum == 301) {
#line 136
    goto case_301;
  }
#line 139
  if (errnum == 302) {
#line 139
    goto case_302;
  }
#line 142
  if (errnum == 303) {
#line 142
    goto case_303;
  }
#line 145
  if (errnum == 304) {
#line 145
    goto case_304;
  }
#line 148
  if (errnum == 305) {
#line 148
    goto case_305;
  }
#line 151
  if (errnum == 306) {
#line 151
    goto case_306;
  }
#line 154
  if (errnum == 307) {
#line 154
    goto case_307;
  }
#line 157
  if (errnum == 308) {
#line 157
    goto case_308;
  }
#line 160
  if (errnum == 309) {
#line 160
    goto case_309;
  }
#line 163
  if (errnum == 310) {
#line 163
    goto case_310;
  }
#line 166
  if (errnum == 311) {
#line 166
    goto case_311;
  }
#line 169
  if (errnum == 312) {
#line 169
    goto case_312;
  }
#line 172
  if (errnum == 313) {
#line 172
    goto case_313;
  }
#line 175
  if (errnum == 314) {
#line 175
    goto case_314;
  }
#line 178
  if (errnum == 315) {
#line 178
    goto case_315;
  }
#line 181
  if (errnum == 316) {
#line 181
    goto case_316;
  }
#line 184
  if (errnum == 317) {
#line 184
    goto case_317;
  }
#line 187
  if (errnum == 319) {
#line 187
    goto case_319;
  }
#line 190
  if (errnum == 320) {
#line 190
    goto case_320;
  }
#line 56
  goto switch_break;
  case_1: /* CIL Label */ 
#line 60
  return ("Operation not permitted");
  case_256: /* CIL Label */ 
#line 67
  return ("Timeout on file open");
  case_257: /* CIL Label */ 
#line 70
  return ("Symbolic links not allowed");
  case_258: /* CIL Label */ 
#line 73
  return ("Hard links not allowed");
  case_259: /* CIL Label */ 
#line 76
  return ("Regular files only");
  case_260: /* CIL Label */ 
#line 79
  return ("Executable files not allowed");
  case_261: /* CIL Label */ 
#line 82
  return ("World writable directory");
  case_262: /* CIL Label */ 
#line 85
  return ("Group writable directory");
  case_263: /* CIL Label */ 
#line 88
  return ("File changed after open");
  case_264: /* CIL Label */ 
#line 91
  return ("World writable file");
  case_265: /* CIL Label */ 
#line 94
  return ("Group writable file");
  case_266: /* CIL Label */ 
#line 97
  return ("Group readable file");
  case_267: /* CIL Label */ 
#line 100
  return ("World readable file");
  case_297: /* CIL Label */ 
#line 125
  return ("Memory allocation failed");
  case_298: /* CIL Label */ 
#line 128
  return ("GDBM is not supported");
  case_299: /* CIL Label */ 
#line 131
  return ("Unsupported action");
  case_300: /* CIL Label */ 
#line 134
  return ("Key already exists");
  case_301: /* CIL Label */ 
#line 137
  return ("Database open failed");
  case_302: /* CIL Label */ 
#line 140
  return ("Key not found");
  case_303: /* CIL Label */ 
#line 143
  return ("Unknown database type");
  case_304: /* CIL Label */ 
#line 146
  return ("Support for database type not compiled into this program");
  case_305: /* CIL Label */ 
#line 149
  return ("DB sync did not finish");
  case_306: /* CIL Label */ 
#line 152
  return ("Key is empty");
  case_307: /* CIL Label */ 
#line 155
  return ("Key already exists");
  case_308: /* CIL Label */ 
#line 158
  return ("Locker killed to resolve deadlock");
  case_309: /* CIL Label */ 
#line 161
  return ("Lock unavailable");
  case_310: /* CIL Label */ 
#line 164
  return ("Lock not held by locker");
  case_311: /* CIL Label */ 
#line 167
  return ("Database panic, run recovery");
  case_312: /* CIL Label */ 
#line 170
  return ("I/O error");
  case_313: /* CIL Label */ 
#line 173
  return ("Database opened read-only");
  case_314: /* CIL Label */ 
#line 176
  return ("Name too long");
  case_315: /* CIL Label */ 
#line 179
  return ("Invalid parameter");
  case_316: /* CIL Label */ 
#line 182
  return ("Only one cursor allowed");
  case_317: /* CIL Label */ 
#line 185
  return ("Invalid cursor");
  case_319: /* CIL Label */ 
#line 188
  return ("Berkeley DB file is an old version, recreate it");
  case_320: /* CIL Label */ 
#line 191
  return ("Berkeley DB version mismatch between include file and library");
  switch_break: /* CIL Label */ ;
  }
  {
#line 274
  ret = strerror(errnum);
  }
#line 275
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 279
    sm_snprintf(buf___0, (size_t )sizeof(buf___0), "Error %d", errnum);
    }
#line 280
    return ((char const   *)(buf___0));
  }
#line 282
  return ((char const   *)ret);
}
}
#line 27 "../../include/sm/debug.h"
SM_FILE_T *sm_debug_file(void) ;
#line 30
void sm_debug_setfile(SM_FILE_T *fp ) ;
#line 33
void sm_dprintf(char *fmt  , ...) ;
#line 36
void sm_dflush(void) ;
#line 39
void sm_debug_close(void) ;
#line 49
void sm_debug_addsetting_x(char const   *pattern , int level ) ;
#line 29 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
static void sm_debug_reset(void) ;
#line 30
static char const   *parse_named_setting_x(char const   *s ) ;
#line 44 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
static SM_FILE_T *SmDebugOutput  =    & SmIoF[1];
#line 56 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
SM_FILE_T *sm_debug_file(void) 
{ 


  {
#line 59
  return (SmDebugOutput);
}
}
#line 75 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
void sm_debug_setfile(SM_FILE_T *fp ) 
{ 


  {
#line 79
  SmDebugOutput = fp;
#line 80
  return;
}
}
#line 95 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
void sm_debug_close(void) 
{ 


  {
#line 98
  if ((unsigned long )SmDebugOutput != (unsigned long )((void *)0)) {
#line 98
    if ((unsigned long )SmDebugOutput != (unsigned long )(& SmIoF[1])) {
      {
#line 100
      sm_io_close(SmDebugOutput, -2);
#line 101
      SmDebugOutput = (SM_FILE_T *)((void *)0);
      }
    }
  }
#line 103
  return;
}
}
#line 115 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
void sm_dprintf(char *fmt  , ...) 
{ 
  va_list ap ;

  {
#line 126
  if ((unsigned long )SmDebugOutput == (unsigned long )((void *)0)) {
#line 127
    return;
  }
  {
#line 128
  __builtin_va_start(ap, fmt);
#line 129
  sm_io_vfprintf(SmDebugOutput, SmDebugOutput->f_timeout, (char const   *)fmt, ap);
#line 130
  __builtin_va_end(ap);
  }
#line 131
  return;
}
}
#line 143 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
void sm_dflush(void) 
{ 


  {
  {
#line 146
  sm_io_flush(SmDebugOutput, -2);
  }
#line 147
  return;
}
}
#line 167 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
SM_DEBUG_SETTING_T *SmDebugSettings  =    (SM_DEBUG_SETTING_T *)((void *)0);
#line 174 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
SM_DEBUG_T *SmDebugInitialized  =    (SM_DEBUG_T *)((void *)0);
#line 176 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
char const   SmDebugMagic[9]  = 
#line 176
  {      (char const   )'s',      (char const   )'m',      (char const   )'_',      (char const   )'d', 
        (char const   )'e',      (char const   )'b',      (char const   )'u',      (char const   )'g', 
        (char const   )'\000'};
#line 193 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
static void sm_debug_reset(void) 
{ 
  SM_DEBUG_T *debug ;

  {
#line 198
  debug = SmDebugInitialized;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )debug != (unsigned long )((void *)0))) {
#line 198
      goto while_break;
    }
#line 202
    debug->debug_level = (SM_ATOMIC_UINT_T )-1;
#line 198
    debug = debug->debug_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  SmDebugInitialized = (SM_DEBUG_T *)((void *)0);
#line 205
  return;
}
}
#line 224 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
void sm_debug_addsetting_x(char const   *pattern , int level ) 
{ 
  SM_DEBUG_SETTING_T *s ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 231
  if ((unsigned long )pattern != (unsigned long )((void *)0)) {
#line 231
    tmp = 1;
  } else {
    {
#line 231
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c",
                231, "SM_REQUIRE(pattern != NULL) failed");
#line 231
    tmp = 0;
    }
  }
#line 232
  if (level >= 0) {
#line 232
    tmp___0 = 1;
  } else {
    {
#line 232
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c",
                232, "SM_REQUIRE(level >= 0) failed");
#line 232
    tmp___0 = 0;
    }
  }
  {
#line 233
  tmp___1 = sm_malloc_tagged_x((size_t )sizeof(SM_DEBUG_SETTING_T ), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c",
                               233, SmHeapGroup);
#line 233
  s = (SM_DEBUG_SETTING_T *)tmp___1;
#line 234
  s->ds_pattern = pattern;
#line 235
  s->ds_level = (unsigned int )level;
#line 236
  s->ds_next = SmDebugSettings;
#line 237
  SmDebugSettings = s;
#line 238
  sm_debug_reset();
  }
#line 239
  return;
}
}
#line 258 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
static char const   *parse_named_setting_x(char const   *s ) 
{ 
  char const   *pat ;
  char const   *endpat ;
  int level ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
#line 265
  pat = s;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if ((int const   )*s != 0) {
#line 266
      if ((int const   )*s != 44) {
#line 266
        if (! ((int const   )*s != 46)) {
#line 266
          goto while_break;
        }
      } else {
#line 266
        goto while_break;
      }
    } else {
#line 266
      goto while_break;
    }
#line 267
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  endpat = s;
#line 269
  if ((int const   )*s == 46) {
#line 271
    s ++;
#line 272
    level = 0;
    {
#line 273
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 273
      if (((int const   )*s & -128) == 0) {
        {
#line 273
        tmp = __ctype_b_loc();
        }
#line 273
        if (! ((int const   )*(*tmp + (int )*s) & 2048)) {
#line 273
          goto while_break___0;
        }
      } else {
#line 273
        goto while_break___0;
      }
#line 275
      level = level * 10 + (int )((int const   )*s - 48);
#line 276
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 278
    if (level < 0) {
#line 279
      level = 0;
    }
  } else {
#line 282
    level = 1;
  }
  {
#line 284
  tmp___0 = sm_strndup_x(pat, (size_t )(endpat - pat));
#line 284
  sm_debug_addsetting_x((char const   *)tmp___0, level);
  }
  {
#line 287
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 287
    if ((int const   )*s != 0) {
#line 287
      if (! ((int const   )*s != 44)) {
#line 287
        goto while_break___1;
      }
    } else {
#line 287
      goto while_break___1;
    }
#line 288
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 290
  return (s);
}
}
#line 319 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
void sm_debug_addsettings_x(char const   *s ) 
{ 


  {
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if ((int const   )*s == 0) {
#line 326
      return;
    }
#line 327
    if ((int const   )*s == 44) {
#line 329
      s ++;
#line 330
      goto __Cont;
    }
    {
#line 332
    s = parse_named_setting_x(s);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 349 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
int sm_debug_loadlevel(SM_DEBUG_T *debug ) 
{ 
  SM_DEBUG_SETTING_T *s ;
  bool tmp ;

  {
#line 353
  if (debug->debug_level == 4294967295U) {
#line 357
    s = SmDebugSettings;
    {
#line 357
    while (1) {
      while_continue: /* CIL Label */ ;
#line 357
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 357
        goto while_break;
      }
      {
#line 359
      tmp = sm_match((char const   *)debug->debug_name, s->ds_pattern);
      }
#line 359
      if (tmp) {
#line 361
        debug->debug_level = s->ds_level;
#line 362
        goto initialized;
      }
#line 357
      s = s->ds_next;
    }
    while_break: /* CIL Label */ ;
    }
#line 365
    debug->debug_level = (SM_ATOMIC_UINT_T )0;
    initialized: 
#line 367
    debug->debug_next = SmDebugInitialized;
#line 368
    SmDebugInitialized = debug;
  }
#line 370
  return ((int )debug->debug_level);
}
}
#line 388 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/debug.c"
bool sm_debug_loadactive(SM_DEBUG_T *debug , int level ) 
{ 
  int tmp ;

  {
  {
#line 393
  tmp = sm_debug_loadlevel(debug);
  }
#line 393
  return (tmp >= level);
}
}
#line 171 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/config.c"
char *SmCompileOptions[15]  = 
#line 171 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/config.c"
  {      (char *)"SM_CONF_LONGLONG",      (char *)"SM_CONF_MEMCHR",      (char *)"SM_CONF_MSG",      (char *)"SM_CONF_SEM", 
        (char *)"SM_CONF_SIGSETJMP",      (char *)"SM_CONF_SHM",      (char *)"SM_CONF_SSIZE_T",      (char *)"SM_CONF_STDDEF_H", 
        (char *)"SM_CONF_SYS_CDEFS_H",      (char *)"SM_CONF_UID_GID",      (char *)"DO_NOT_USE_STRCPY",      (char *)"SM_HEAP_CHECK", 
        (char *)"SM_OS=sm_os_linux",      (char *)"SM_VA_STD",      (char *)((void *)0)};
#line 267 "../../include/sm/io.h"
void sm_io_clearerr(SM_FILE_T *fp ) ;
#line 32 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clrerr.c"
void sm_io_clearerr(SM_FILE_T *fp ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 36
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 36
    if ((unsigned long )fp->sm_magic == (unsigned long )(SmFileMagic)) {
#line 36
      tmp = 1;
    } else {
      {
#line 36
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clrerr.c",
                  36, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 36
      tmp = 0;
      }
    }
  } else {
    {
#line 36
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clrerr.c",
                36, "SM_REQUIRE((fp) != NULL && (fp)->sm_magic == (SmFileMagic)) failed");
#line 36
    tmp = 0;
    }
  }
#line 38
  fp->f_flags &= -385L;
#line 39
  return;
}
}
#line 414 "/usr/include/unistd.h"
extern int pause(void) ;
#line 549
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 184 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 54 "../../include/sm/clock.h"
void sm_clear_events(void) ;
#line 56
SM_EVENT *sm_sigsafe_seteventm(int intvl , void (*func)(int  ) , int arg ) ;
#line 60 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clock.c"
static SM_EVENT * volatile  SmEventQueue  ;
#line 61 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clock.c"
static SM_EVENT * volatile  SmFreeEventList  ;
#line 63 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clock.c"
SM_EVENT *sm_seteventm(int intvl , void (*func)(int  ) , int arg ) 
{ 
  void *tmp ;
  SM_EVENT *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 69
  InCriticalSection += (unsigned int volatile   )1;
#line 70
  if ((unsigned long )SmFreeEventList == (unsigned long )((void *)0)) {
    {
#line 72
    tmp = sm_malloc_tagged_x((size_t )sizeof(*SmFreeEventList), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clock.c",
                             72, 0);
#line 72
    SmFreeEventList = (SM_EVENT */* volatile  */)((SM_EVENT *)tmp);
#line 73
    SmFreeEventList->ev_link = (struct sm_event *)((void *)0);
    }
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 75
      InCriticalSection -= (unsigned int volatile   )1;
    }
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  tmp___0 = sm_sigsafe_seteventm(intvl, func, arg);
  }
#line 77
  return (tmp___0);
}
}
#line 86 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clock.c"
SM_EVENT *sm_sigsafe_seteventm(int intvl , void (*func)(int  ) , int arg ) 
{ 
  register SM_EVENT **evp ;
  register SM_EVENT *ev ;
  time_t now ;
  time_t nowi ;
  int wasblocked ;
  int tmp ;

  {
#line 103
  if (intvl <= 0) {
#line 104
    return ((SM_EVENT *)((void *)0));
  }
  {
#line 106
  wasblocked = sm_blocksignal(14);
#line 114
  now = time((time_t *)((void *)0));
#line 115
  nowi = now + (time_t )(intvl / 1000);
#line 119
  evp = (SM_EVENT **)(& SmEventQueue);
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    ev = *evp;
#line 119
    if (! ((unsigned long )ev != (unsigned long )((void *)0))) {
#line 119
      goto while_break;
    }
#line 126
    if (ev->ev_time >= nowi) {
#line 128
      goto while_break;
    }
#line 119
    evp = & ev->ev_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  InCriticalSection += (unsigned int volatile   )1;
#line 132
  if ((unsigned long )SmFreeEventList == (unsigned long )((void *)0)) {
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 142
      if (InCriticalSection > (unsigned int volatile   )0) {
#line 142
        InCriticalSection -= (unsigned int volatile   )1;
      }
#line 142
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 143
    if (wasblocked == 0) {
      {
#line 144
      sm_releasesignal(14);
      }
    }
#line 145
    return ((SM_EVENT *)((void *)0));
  } else {
#line 149
    ev = (SM_EVENT *)SmFreeEventList;
#line 150
    SmFreeEventList = (SM_EVENT */* volatile  */)ev->ev_link;
  }
  {
#line 152
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 152
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 152
      InCriticalSection -= (unsigned int volatile   )1;
    }
#line 152
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 155
  ev->ev_time = nowi;
#line 156
  ev->ev_func = func;
#line 157
  ev->ev_arg = arg;
#line 158
  ev->ev_pid = getpid();
#line 159
  InCriticalSection += (unsigned int volatile   )1;
#line 160
  ev->ev_link = *evp;
#line 161
  *evp = ev;
  }
  {
#line 162
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 162
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 162
      InCriticalSection -= (unsigned int volatile   )1;
    }
#line 162
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 164
  sm_signal(14, & sm_tick);
#line 175
  intvl = (int )(SmEventQueue->ev_time - now);
  }
#line 176
  if (intvl < 1) {
#line 176
    tmp = 1;
  } else {
#line 176
    tmp = intvl;
  }
  {
#line 176
  alarm((unsigned int )tmp);
  }
#line 178
  if (wasblocked == 0) {
    {
#line 179
    sm_releasesignal(14);
    }
  }
#line 180
  return (ev);
}
}
#line 195 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clock.c"
void sm_clrevent(SM_EVENT *ev ) 
{ 
  register SM_EVENT **evp ;
  int wasblocked ;
  __pid_t tmp ;

  {
#line 205
  if ((unsigned long )ev == (unsigned long )((void *)0)) {
#line 206
    return;
  }
  {
#line 209
  wasblocked = sm_blocksignal(14);
#line 210
  evp = (SM_EVENT **)(& SmEventQueue);
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! ((unsigned long )*evp != (unsigned long )((void *)0))) {
#line 210
      goto while_break;
    }
#line 214
    if ((unsigned long )*evp == (unsigned long )ev) {
#line 215
      goto while_break;
    }
#line 210
    evp = & (*evp)->ev_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  if ((unsigned long )*evp != (unsigned long )((void *)0)) {
#line 221
    InCriticalSection += (unsigned int volatile   )1;
#line 222
    *evp = ev->ev_link;
#line 223
    ev->ev_link = (struct sm_event *)SmFreeEventList;
#line 224
    SmFreeEventList = (SM_EVENT */* volatile  */)ev;
    {
#line 225
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 225
      if (InCriticalSection > (unsigned int volatile   )0) {
#line 225
        InCriticalSection -= (unsigned int volatile   )1;
      }
#line 225
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 229
  if (wasblocked == 0) {
    {
#line 230
    sm_releasesignal(14);
    }
  }
#line 231
  if ((unsigned long )SmEventQueue != (unsigned long )((void *)0)) {
    {
#line 232
    tmp = getpid();
#line 232
    kill(tmp, 14);
    }
  } else {
    {
#line 243
    alarm(0U);
    }
  }
#line 246
  return;
}
}
#line 257 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clock.c"
void sm_clear_events(void) 
{ 
  register SM_EVENT *ev ;
  int wasblocked ;

  {
  {
#line 274
  alarm(0U);
  }
#line 277
  if ((unsigned long )SmEventQueue == (unsigned long )((void *)0)) {
#line 278
    return;
  }
  {
#line 280
  wasblocked = sm_blocksignal(14);
#line 283
  ev = (SM_EVENT *)SmEventQueue;
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! ((unsigned long )ev->ev_link != (unsigned long )((void *)0))) {
#line 283
      goto while_break;
    }
#line 284
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 283
    ev = ev->ev_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  InCriticalSection += (unsigned int volatile   )1;
#line 287
  ev->ev_link = (struct sm_event *)SmFreeEventList;
#line 288
  SmFreeEventList = SmEventQueue;
#line 289
  SmEventQueue = (SM_EVENT */* volatile  */)((void *)0);
  {
#line 290
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 290
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 290
      InCriticalSection -= (unsigned int volatile   )1;
    }
#line 290
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 293
  if (wasblocked == 0) {
    {
#line 294
    sm_releasesignal(14);
    }
  }
#line 295
  return;
}
}
#line 318 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clock.c"
void sm_tick(int sig ) 
{ 
  register SM_EVENT *ev ;
  pid_t mypid ;
  int save_errno ;
  int *tmp ;
  register time_t now ;
  int *tmp___0 ;
  int sigbit ;
  int sig___0 ;
  void (*f)(int  ) ;
  int arg ;
  pid_t pid ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 324
  tmp = __errno_location();
#line 324
  save_errno = *tmp;
#line 340
  alarm(0U);
#line 341
  now = time((time_t *)((void *)0));
#line 345
  tmp___0 = __errno_location();
#line 345
  *tmp___0 = save_errno;
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 346
      if (sig != 0) {
        {
#line 346
        pend_signal(sig);
        }
#line 346
        return;
      }
    }
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  mypid = getpid();
  }
  {
#line 349
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 349
    if (! (PendingSignal != (int volatile   )0)) {
#line 349
      goto while_break___0;
    }
#line 351
    sigbit = 0;
#line 352
    sig___0 = 0;
#line 354
    if ((PendingSignal & (int volatile   )1) != (int volatile   )0) {
#line 356
      sigbit = 1;
#line 357
      sig___0 = 1;
    } else
#line 359
    if ((PendingSignal & (int volatile   )2) != (int volatile   )0) {
#line 361
      sigbit = 2;
#line 362
      sig___0 = 2;
    } else
#line 364
    if ((PendingSignal & (int volatile   )4) != (int volatile   )0) {
#line 366
      sigbit = 4;
#line 367
      sig___0 = 15;
    } else
#line 369
    if ((PendingSignal & (int volatile   )8) != (int volatile   )0) {
#line 371
      sigbit = 8;
#line 372
      sig___0 = 10;
    } else {
      {
#line 377
      abort();
      }
    }
    {
#line 379
    PendingSignal &= (int volatile   )(~ sigbit);
#line 380
    kill(mypid, sig___0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 386
  now = time((time_t *)((void *)0));
  }
  {
#line 388
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 388
    ev = (SM_EVENT *)SmEventQueue;
#line 388
    if ((unsigned long )ev != (unsigned long )((void *)0)) {
#line 388
      if (! (ev->ev_pid != mypid)) {
#line 388
        if (! (ev->ev_time <= now)) {
#line 388
          goto while_break___1;
        }
      }
    } else {
#line 388
      goto while_break___1;
    }
#line 402
    ev = (SM_EVENT *)SmEventQueue;
#line 403
    SmEventQueue = (SM_EVENT */* volatile  */)SmEventQueue->ev_link;
#line 406
    f = ev->ev_func;
#line 407
    arg = ev->ev_arg;
#line 408
    pid = ev->ev_pid;
#line 409
    InCriticalSection += (unsigned int volatile   )1;
#line 410
    ev->ev_link = (struct sm_event *)SmFreeEventList;
#line 411
    SmFreeEventList = (SM_EVENT */* volatile  */)ev;
    {
#line 412
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 412
      if (InCriticalSection > (unsigned int volatile   )0) {
#line 412
        InCriticalSection -= (unsigned int volatile   )1;
      }
#line 412
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 413
    tmp___1 = getpid();
    }
#line 413
    if (pid != tmp___1) {
#line 414
      goto while_continue___1;
    }
#line 415
    if ((unsigned long )SmEventQueue != (unsigned long )((void *)0)) {
#line 440
      if (SmEventQueue->ev_time > now) {
        {
#line 441
        alarm((unsigned int )(SmEventQueue->ev_time - now));
        }
      } else {
        {
#line 444
        alarm(3U);
        }
      }
    }
    {
#line 449
    tmp___2 = __errno_location();
#line 449
    *tmp___2 = save_errno;
#line 450
    (*f)(arg);
#line 459
    alarm(0U);
#line 460
    now = time((time_t *)((void *)0));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 463
  if ((unsigned long )SmEventQueue != (unsigned long )((void *)0)) {
    {
#line 475
    alarm((unsigned int )(SmEventQueue->ev_time - now));
    }
  }
  {
#line 478
  tmp___3 = __errno_location();
#line 478
  *tmp___3 = save_errno;
  }
#line 479
  return;
}
}
#line 500
static void sm_endsleep(int ignore ) ;
#line 501 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clock.c"
static bool volatile   SmSleepDone  ;
#line 508 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clock.c"
unsigned int sleep(unsigned int intvl ) 
{ 
  int was_held ;
  SM_EVENT *ev ;
  time_t begin ;
  time_t now ;

  {
#line 539
  if (intvl == 0U) {
#line 540
    return (0U);
  }
  {
#line 552
  SmSleepDone = (bool volatile   )0;
#line 562
  begin = time((time_t *)((void *)0));
#line 562
  now = begin;
#line 565
  ev = sm_seteventm((int )((time_t )intvl * 1000L), & sm_endsleep, 0);
  }
#line 566
  if ((unsigned long )ev == (unsigned long )((void *)0)) {
#line 572
    SmSleepDone = (bool volatile   )1;
  }
  {
#line 574
  was_held = sm_releasesignal(14);
  }
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    if (! (! SmSleepDone)) {
#line 576
      goto while_break;
    }
    {
#line 588
    now = time((time_t *)((void *)0));
    }
#line 596
    if (! ((begin + (time_t )intvl) + 1L > now)) {
#line 597
      goto while_break;
    }
    {
#line 614
    pause();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 618
  if (! SmSleepDone) {
    {
#line 619
    sm_clrevent(ev);
    }
  }
#line 620
  if (was_held > 0) {
    {
#line 621
    sm_blocksignal(14);
    }
  }
#line 622
  return (0U);
}
}
#line 627 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/clock.c"
static void sm_endsleep(int ignore ) 
{ 


  {
#line 637
  SmSleepDone = (bool volatile   )1;
#line 638
  return;
}
}
#line 23 "../../include/sm/cf.h"
int sm_cf_getopt(char *path , int optc , SM_CF_OPT_T *optv ) ;
#line 39 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/cf.c"
int sm_cf_getopt(char *path , int optc , SM_CF_OPT_T *optv ) 
{ 
  SM_FILE_T *cfp ;
  char buf___16[2048] ;
  char *p ;
  char *id ;
  char *idend ;
  char *val ;
  int i ;
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int save_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  void *__cil_tmp19 ;

  {
  {
#line 53
  cfp = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)path,
                   2, (void const   *)((void *)0));
  }
#line 54
  if ((unsigned long )cfp == (unsigned long )((void *)0)) {
    {
#line 55
    tmp = __errno_location();
    }
#line 55
    return (*tmp);
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    tmp___2 = sm_io_fgets(cfp, -2, buf___16, (int )sizeof(buf___16));
    }
#line 57
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 57
      goto while_break;
    }
    {
#line 59
    p = strchr((char const   *)(buf___16), '\n');
    }
#line 60
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 61
      *p = (char )'\000';
    }
#line 63
    if ((int )buf___16[0] != 79) {
#line 64
      goto while_continue;
    } else
#line 63
    if ((int )buf___16[1] != 32) {
#line 64
      goto while_continue;
    }
    {
#line 66
    id = & buf___16[2];
#line 67
    val = strchr((char const   *)id, '=');
    }
#line 68
    if ((unsigned long )val == (unsigned long )((void *)0)) {
      {
#line 69
      tmp___0 = strlen((char const   *)id);
#line 69
      idend = id + tmp___0;
#line 69
      val = idend;
      }
    } else {
#line 72
      idend = val;
#line 73
      val ++;
      {
#line 74
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 74
        if (! ((int )*val == 32)) {
#line 74
          goto while_break___0;
        }
#line 75
        val ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 76
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 76
        if ((unsigned long )idend > (unsigned long )id) {
#line 76
          if (! ((int )*(idend + -1) == 32)) {
#line 76
            goto while_break___1;
          }
        } else {
#line 76
          goto while_break___1;
        }
#line 77
        idend --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 78
      *idend = (char )'\000';
    }
#line 81
    i = 0;
    {
#line 81
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 81
      if (! (i < optc)) {
#line 81
        goto while_break___2;
      }
      {
#line 83
      tmp___1 = sm_strcasecmp((char const   *)(optv + i)->opt_name, (char const   *)id);
      }
#line 83
      if (tmp___1 == 0) {
        {
#line 85
        (optv + i)->opt_val = sm_strdup_x((char const   *)val);
        }
#line 86
        goto while_break___2;
      }
#line 81
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if ((cfp->f_flags & 256L) != 0L) {
    {
#line 92
    tmp___3 = __errno_location();
#line 92
    save_errno = *tmp___3;
#line 94
    sm_io_close(cfp, -2);
#line 95
    tmp___4 = __errno_location();
#line 95
    *tmp___4 = save_errno;
#line 96
    tmp___5 = __errno_location();
    }
#line 96
    return (*tmp___5);
  }
  {
#line 98
  sm_io_close(cfp, -2);
  }
#line 99
  return (0);
}
}
#line 35 "../../include/sm/assert.h"
void sm_abort_sethandler(void (*f)(char const   * , int  , char const   * ) ) ;
#line 109
SM_DEBUG_T SmExpensiveRequire ;
#line 110
SM_DEBUG_T SmExpensiveEnsure ;
#line 111
SM_DEBUG_T SmExpensiveAssert ;
#line 32 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/assert.c"
SM_DEBUG_T SmExpensiveAssert  =    {SmDebugMagic, (SM_ATOMIC_UINT_T )-1, (char *)"sm_check_assert", (char *)"@(#)$Debug: sm_check_assert - check assertions $",
    (SM_DEBUG_T *)((void *)0)};
#line 35 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/assert.c"
SM_DEBUG_T SmExpensiveRequire  =    {SmDebugMagic, (SM_ATOMIC_UINT_T )-1, (char *)"sm_check_require", (char *)"@(#)$Debug: sm_check_require - check function preconditions $",
    (SM_DEBUG_T *)((void *)0)};
#line 38 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/assert.c"
SM_DEBUG_T SmExpensiveEnsure  =    {SmDebugMagic, (SM_ATOMIC_UINT_T )-1, (char *)"sm_check_ensure", (char *)"@(#)$Debug: sm_check_ensure - check function postconditions $",
    (SM_DEBUG_T *)((void *)0)};
#line 46 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/assert.c"
SM_DEBUG_T SmAbortStop  =    {SmDebugMagic, (SM_ATOMIC_UINT_T )-1, (char *)"sm_abort_stop", (char *)"@(#)$Debug: sm_abort_stop - stop process on fatal error $",
    (SM_DEBUG_T *)((void *)0)};
#line 65
static void sm_abort_defaulthandler(char const   *filename , int lineno , char const   *msg ) ;
#line 71 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/assert.c"
static void sm_abort_defaulthandler(char const   *filename , int lineno , char const   *msg ) 
{ 
  __pid_t tmp ;
  bool tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 74
  if ((unsigned long )filename != (unsigned long )((void *)0)) {
    {
#line 75
    sm_io_fprintf(& SmIoF[2], -2, "%s:%d: %s\n", filename, lineno, msg);
    }
  } else {
    {
#line 78
    sm_io_fprintf(& SmIoF[2], -2, "%s\n", msg);
    }
  }
  {
#line 79
  sm_io_flush(& SmIoF[2], -2);
  }
#line 81
  if (SmAbortStop.debug_level >= 1U) {
#line 81
    if (SmAbortStop.debug_level != 4294967295U) {
      {
#line 82
      tmp = getpid();
#line 82
      kill(tmp, 19);
      }
    } else {
      {
#line 81
      tmp___0 = sm_debug_loadactive(& SmAbortStop, 1);
      }
#line 81
      if (tmp___0) {
        {
#line 82
        tmp = getpid();
#line 82
        kill(tmp, 19);
        }
      }
    }
  }
  {
#line 84
  abort();
  }
}
}
#line 91 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/assert.c"
static void (*SmAbortHandler)(char const   * , int  , char const   * )  =    & sm_abort_defaulthandler;
#line 109 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/assert.c"
void sm_abort_sethandler(void (*f)(char const   * , int  , char const   * ) ) 
{ 


  {
#line 113
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 114
    SmAbortHandler = & sm_abort_defaulthandler;
  } else {
#line 116
    SmAbortHandler = f;
  }
#line 117
  return;
}
}
#line 130
 __attribute__((__noreturn__)) void sm_abort(char *fmt  , ...) ;
#line 130 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/assert.c"
void sm_abort(char *fmt  , ...) 
{ 
  char msg[128] ;
  va_list ap ;
  void *__cil_tmp4 ;

  {
  {
#line 137
  __builtin_va_start(ap, fmt);
#line 138
  sm_vsnprintf(msg, (size_t )sizeof(msg), (char const   *)fmt, ap);
#line 139
  __builtin_va_end(ap);
#line 140
  sm_abort_at((char const   *)((void *)0), 0, (char const   *)(msg));
  }
}
}
#line 166
 __attribute__((__noreturn__)) void sm_abort_at(char const   *filename , int lineno ,
                                                char const   *msg ) ;
#line 166 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/assert.c"
void sm_abort_at(char const   *filename , int lineno , char const   *msg ) 
{ 
  SM_EXC_HANDLER_T _h ;
  int tmp ;
  int tmp___0 ;
  bool tmp___2 ;
  SM_EXC_T *exc  __attribute__((__unused__)) ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 172
    _h.eh_value = (SM_EXC_T *)((void *)0);
#line 173
    _h.eh_parent = SmExcHandler;
#line 174
    _h.eh_state = 2;
#line 175
    SmExcHandler = & _h;
#line 176
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 176
    if (tmp == 0) {
      {
#line 177
      (*SmAbortHandler)(filename, lineno, msg);
      }
    }
#line 179
    if (_h.eh_state == 1) {
#line 179
      goto while_break;
    }
#line 180
    if (_h.eh_state == 2) {
#line 181
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 181
        tmp___0 = 1;
      } else {
        {
#line 181
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/assert.c",
                    174, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 181
        tmp___0 = 0;
        }
      }
#line 182
      SmExcHandler = _h.eh_parent;
    }
    {
#line 184
    tmp___2 = sm_exc_match(_h.eh_value, "*");
    }
#line 184
    if (tmp___2) {
#line 184
      _h.eh_state = 1;
    } else {
#line 184
      _h.eh_state = 0;
    }
#line 185
    if (_h.eh_state == 1) {
      {
#line 186
      exc = _h.eh_value;
#line 187
      sm_io_fprintf(& SmIoF[2], -2, "exception raised by abort handler:\n");
#line 188
      sm_exc_print(exc, & SmIoF[2]);
#line 189
      sm_io_flush(& SmIoF[2], -2);
      }
    }
#line 171
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (_h.eh_state == 2) {
#line 194
    if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 194
      tmp___3 = 1;
    } else {
      {
#line 194
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsm/assert.c",
                  179, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 194
      tmp___3 = 0;
      }
    }
#line 195
    SmExcHandler = _h.eh_parent;
#line 196
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 196
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else
#line 197
  if (_h.eh_state == 0) {
#line 198
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 198
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else {
    {
#line 199
    sm_exc_free(_h.eh_value);
    }
  }
  {
#line 202
  abort();
  }
}
}
#line 2564 "../../sendmail/sendmail.h"
char *shortenstring(char const   *s , size_t m ) ;
#line 38 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/snprintf.c"
static char buf___1[204]  ;
#line 32 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/snprintf.c"
char *shortenstring(char const   *s , size_t m ) 
{ 
  size_t l ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 40
  l = strlen(s);
  }
#line 41
  if (l < m) {
#line 42
    return ((char *)s);
  }
#line 43
  if (m > 203U) {
#line 44
    m = (size_t )203;
  } else
#line 45
  if (m < 10U) {
#line 47
    if (m < 5U) {
      {
#line 49
      sm_strlcpy(buf___1, s, (ssize_t )(m + 1U));
      }
#line 50
      return (buf___1);
    }
    {
#line 52
    sm_strlcpy(buf___1, s, (ssize_t )(m - 2U));
#line 53
    sm_strlcat(buf___1, "...", (ssize_t )sizeof(buf___1));
    }
#line 54
    return (buf___1);
  }
  {
#line 56
  m = (m - 3U) / 2U;
#line 57
  sm_strlcpy(buf___1, s, (ssize_t )(m + 1U));
#line 58
  sm_strlcat2(buf___1, "...", (s + l) - m, (ssize_t )sizeof(buf___1));
  }
#line 59
  return (buf___1);
}
}
#line 621 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 739
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) readlink)(char const   * __restrict  __path ,
                                                                                       char * __restrict  __buf ,
                                                                                       size_t __len ) ;
#line 916
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 170 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 65 "../../include/sendmail/sendmail.h"
int safefile(char *fn , uid_t uid , gid_t gid , char *user , long flags , int mode ,
             struct stat *st ) ;
#line 66
int safedirpath(char *fn , uid_t uid , gid_t gid , char *user , long flags , int level ,
                int offset ) ;
#line 67
int safeopen(char *fn , int omode , int cmode , long sff ) ;
#line 68
SM_FILE_T *safefopen(char *fn , int omode , int cmode , long sff ) ;
#line 69
int dfopen(char *filename , int omode , int cmode , long sff ) ;
#line 70
bool filechanged(char *fn , int fd , struct stat *stb ) ;
#line 2058 "../../sendmail/sendmail.h"
unsigned char tTdvect[100] ;
#line 2158
bool DontInitGroups ;
#line 2251
int Verbose ;
#line 2253
gid_t RealGid ;
#line 2254
gid_t RunAsGid ;
#line 2266
uid_t RealUid ;
#line 2267
uid_t RunAsUid ;
#line 2268
uid_t TrustedUid ;
#line 2307
char *RealUserName ;
#line 2309
char *RunAsUserName ;
#line 2322
BITMAP256 DontBlameSendmail ;
#line 2352
void message(char const   *msg  , ...) ;
#line 2354
void syserr(char const   *msg  , ...) ;
#line 2514
bool lockfile(int fd , char *filename , char *ext , int type ) ;
#line 45 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/safefile.c"
int safefile(char *fn , uid_t uid , gid_t gid , char *user , long flags , int mode ,
             struct stat *st ) 
{ 
  register char *p ;
  register struct group *gr ;
  int file_errno ;
  bool checkpath ;
  struct stat stbuf ;
  struct stat fstbuf ;
  char fbuf[4096] ;
  int *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int ret ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int ret___0 ;
  int ret___1 ;
  char *dir___0 ;
  char const   *tmp___9 ;
  int *tmp___10 ;
  int md ;
  register char **gp ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  register char **gp___0 ;
  int tmp___17 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
#line 56
  gr = (struct group *)((void *)0);
#line 57
  file_errno = 0;
#line 63
  if ((int )tTdvect[44] >= 4) {
    {
#line 64
    sm_dprintf((char *)"safefile(%s, uid=%d, gid=%d, flags=%lx, mode=%o):\n", fn,
               (int )uid, (int )gid, flags, mode);
    }
  }
  {
#line 66
  tmp = __errno_location();
#line 66
  *tmp = 0;
#line 67
  tmp___0 = sm_strlcpy(fbuf, (char const   *)fn, (ssize_t )sizeof(fbuf));
  }
#line 67
  if ((unsigned long )tmp___0 >= sizeof(fbuf)) {
#line 69
    if ((int )tTdvect[44] >= 4) {
      {
#line 70
      sm_dprintf((char *)"\tpathname too long\n");
      }
    }
#line 71
    return (36);
  }
#line 73
  fn = fbuf;
#line 74
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 75
    st = & fstbuf;
  }
#line 78
  if (RealUid != 0U) {
#line 78
    if (RunAsUid == RealUid) {
#line 79
      flags &= -257L;
    }
  }
#line 83
  if ((flags & 2L) != 0L) {
    {
#line 83
    tmp___2 = lstat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)st);
#line 83
    tmp___4 = tmp___2;
    }
  } else {
    {
#line 83
    tmp___3 = stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)st);
#line 83
    tmp___4 = tmp___3;
    }
  }
#line 83
  if (tmp___4 < 0) {
    {
#line 89
    tmp___1 = __errno_location();
#line 89
    file_errno = *tmp___1;
    }
  } else
#line 91
  if ((flags & 32L) != 0L) {
#line 91
    if (! ((st->st_mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) != 0U)) {
#line 91
      if ((st->st_mode & 61440U) == 32768U) {
#line 104
        if ((st->st_mode & 2048U) != 0U) {
#line 104
          if (st->st_uid != 0U) {
#line 104
            if (st->st_uid != TrustedUid) {
#line 108
              uid = st->st_uid;
#line 109
              user = (char *)((void *)0);
            }
          }
        }
#line 114
        if ((st->st_mode & 1024U) != 0U) {
#line 114
          if (st->st_gid != 0U) {
#line 116
            gid = st->st_gid;
          }
        }
      }
    }
  }
#line 119
  if (! ((flags & 16L) != 0L)) {
#line 119
    tmp___5 = 1;
  } else
#line 119
  if (uid == 0U) {
#line 119
    if (! ((flags & 8196L) != 0L)) {
#line 119
      tmp___5 = 1;
    } else {
#line 119
      tmp___5 = 0;
    }
  } else {
#line 119
    tmp___5 = 0;
  }
#line 119
  checkpath = tmp___5;
#line 121
  if ((flags & 1024L) != 0L) {
#line 121
    if (! ((flags & 256L) != 0L)) {
      {
#line 126
      p = strrchr((char const   *)fn, '/');
      }
#line 127
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
#line 129
        ret = safedirpath((char *)".", uid, gid, user, flags | 256L, 0, 0);
        }
      } else {
        {
#line 134
        *p = (char )'\000';
#line 135
        ret = safedirpath(fn, uid, gid, user, flags | 256L, 0, 0);
#line 137
        *p = (char )'/';
        }
      }
#line 139
      if (ret == 0) {
#line 142
        checkpath = 0;
      } else {
#line 148
        if (! ((flags & 2L) != 0L)) {
          {
#line 148
          tmp___8 = lstat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)st);
          }
#line 148
          if (tmp___8 < 0) {
            {
#line 150
            tmp___6 = __errno_location();
#line 150
            ret = *tmp___6;
            }
#line 151
            if ((int )tTdvect[44] >= 4) {
              {
#line 152
              tmp___7 = sm_errstring(ret);
#line 152
              sm_dprintf((char *)"\t%s\n", tmp___7);
              }
            }
#line 153
            return (ret);
          }
        }
#line 157
        flags |= 514L;
      }
    }
  }
#line 161
  if (checkpath) {
    {
#line 165
    p = strrchr((char const   *)fn, '/');
    }
#line 166
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 168
      ret___0 = safedirpath((char *)".", uid, gid, user, flags, 0, 0);
      }
    } else {
      {
#line 172
      *p = (char )'\000';
#line 173
      ret___0 = safedirpath(fn, uid, gid, user, flags, 0, 0);
#line 174
      *p = (char )'/';
      }
    }
#line 176
    if (ret___0 != 0) {
#line 177
      return (ret___0);
    }
  }
#line 185
  if (file_errno != 0) {
#line 187
    ret___1 = file_errno;
#line 188
    dir___0 = fn;
#line 190
    if ((int )tTdvect[44] >= 4) {
      {
#line 191
      tmp___9 = sm_errstring(ret___1);
#line 191
      sm_dprintf((char *)"\t%s\n", tmp___9);
      }
    }
    {
#line 193
    tmp___10 = __errno_location();
#line 193
    *tmp___10 = 0;
    }
#line 194
    if (! ((flags & 64L) != 0L)) {
#line 195
      return (ret___1);
    } else
#line 194
    if (file_errno != 2) {
#line 195
      return (ret___1);
    }
    {
#line 198
    p = strrchr((char const   *)dir___0, '/');
    }
#line 199
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 200
      dir___0 = (char *)".";
    } else
#line 201
    if ((unsigned long )p == (unsigned long )dir___0) {
#line 202
      dir___0 = (char *)"/";
    } else {
#line 204
      *p = (char )'\000';
    }
    {
#line 205
    tmp___15 = stat((char const   */* __restrict  */)dir___0, (struct stat */* __restrict  */)(& stbuf));
    }
#line 205
    if (tmp___15 >= 0) {
#line 207
      md = 192;
#line 209
      ret___1 = 0;
#line 210
      if (! (stbuf.st_uid == uid)) {
#line 213
        if (uid == 0U) {
#line 213
          if (! (stbuf.st_uid == TrustedUid)) {
#line 213
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 218
          md >>= 3;
#line 219
          if (! (stbuf.st_gid == gid)) {
#line 223
            if ((unsigned long )user != (unsigned long )((void *)0)) {
#line 223
              if (! DontInitGroups) {
#line 223
                if ((unsigned long )gr != (unsigned long )((void *)0)) {
#line 223
                  if (gr->gr_gid == stbuf.st_gid) {
#line 223
                    goto _L;
                  } else {
#line 223
                    goto _L___0;
                  }
                } else {
                  _L___0: /* CIL Label */ 
                  {
#line 223
                  gr = getgrgid(stbuf.st_gid);
                  }
#line 223
                  if ((unsigned long )gr != (unsigned long )((void *)0)) {
                    _L: /* CIL Label */ 
#line 230
                    gp = gr->gr_mem;
                    {
#line 230
                    while (1) {
                      while_continue: /* CIL Label */ ;
#line 230
                      if (! ((unsigned long )*gp != (unsigned long )((void *)0))) {
#line 230
                        goto while_break;
                      }
                      {
#line 231
                      tmp___11 = strcmp((char const   *)*gp, (char const   *)user);
                      }
#line 231
                      if (tmp___11 == 0) {
#line 232
                        goto while_break;
                      }
#line 230
                      gp ++;
                    }
                    while_break: /* CIL Label */ ;
                    }
#line 233
                    if ((unsigned long )*gp == (unsigned long )((void *)0)) {
#line 234
                      md >>= 3;
                    }
                  } else {
#line 238
                    md >>= 3;
                  }
                }
              } else {
#line 238
                md >>= 3;
              }
            } else {
#line 238
              md >>= 3;
            }
          }
        }
      }
#line 240
      if ((stbuf.st_mode & (unsigned int )md) != (unsigned int )md) {
        {
#line 241
        tmp___12 = __errno_location();
#line 241
        tmp___13 = 13;
#line 241
        *tmp___12 = tmp___13;
#line 241
        ret___1 = tmp___13;
        }
      }
    } else {
      {
#line 244
      tmp___14 = __errno_location();
#line 244
      ret___1 = *tmp___14;
      }
    }
#line 245
    if ((int )tTdvect[44] >= 4) {
      {
#line 246
      tmp___16 = sm_errstring(ret___1);
#line 246
      sm_dprintf((char *)"\t[final dir %s uid %d mode %lo] %s\n", dir___0, (int )stbuf.st_uid,
                 (unsigned long )stbuf.st_mode, tmp___16);
      }
    }
#line 250
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 251
      *p = (char )'/';
    }
#line 252
    st->st_mode = (__mode_t )62055;
#line 253
    return (ret___1);
  }
#line 257
  if ((flags & 2L) != 0L) {
#line 257
    if ((st->st_mode & 61440U) == 40960U) {
#line 259
      if ((int )tTdvect[44] >= 4) {
        {
#line 260
        sm_dprintf((char *)"\t[slink mode %lo]\tE_SM_NOSLINK\n", (unsigned long )st->st_mode);
        }
      }
#line 262
      return (257);
    }
  }
#line 265
  if ((flags & 128L) != 0L) {
#line 265
    if (! ((st->st_mode & 61440U) == 32768U)) {
#line 267
      if ((int )tTdvect[44] >= 4) {
        {
#line 268
        sm_dprintf((char *)"\t[non-reg mode %lo]\tE_SM_REGONLY\n", (unsigned long )st->st_mode);
        }
      }
#line 270
      return (259);
    }
  }
#line 272
  if ((flags & 2048L) != 0L) {
#line 272
    if ((st->st_mode & (unsigned int )(128 >> 3)) != 0U) {
#line 275
      if ((int )tTdvect[44] >= 4) {
        {
#line 276
        sm_dprintf((char *)"\t[write bits %lo]\tE_SM_GWFILE\n", (unsigned long )st->st_mode);
        }
      }
#line 278
      return (265);
    }
  }
#line 280
  if ((flags & 4096L) != 0L) {
#line 280
    if ((st->st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
#line 283
      if ((int )tTdvect[44] >= 4) {
        {
#line 284
        sm_dprintf((char *)"\t[write bits %lo]\tE_SM_WWFILE\n", (unsigned long )st->st_mode);
        }
      }
#line 286
      return (264);
    }
  }
#line 288
  if ((flags & 32768L) != 0L) {
#line 288
    if ((st->st_mode & (unsigned int )(256 >> 3)) != 0U) {
#line 290
      if ((int )tTdvect[44] >= 4) {
        {
#line 291
        sm_dprintf((char *)"\t[read bits %lo]\tE_SM_GRFILE\n", (unsigned long )st->st_mode);
        }
      }
#line 293
      return (266);
    }
  }
#line 295
  if ((flags & 65536L) != 0L) {
#line 295
    if ((st->st_mode & (unsigned int )((256 >> 3) >> 3)) != 0U) {
#line 297
      if ((int )tTdvect[44] >= 4) {
        {
#line 298
        sm_dprintf((char *)"\t[read bits %lo]\tE_SM_WRFILE\n", (unsigned long )st->st_mode);
        }
      }
#line 300
      return (267);
    }
  }
#line 302
  if (! ((flags & 262144L) != 0L)) {
#line 302
    if ((mode & ((128 | (128 >> 3)) | ((128 >> 3) >> 3))) != 0) {
#line 302
      if ((st->st_mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) != 0U) {
#line 306
        if ((int )tTdvect[44] >= 4) {
          {
#line 307
          sm_dprintf((char *)"\t[exec bits %lo]\tE_SM_ISEXEC\n", (unsigned long )st->st_mode);
          }
        }
#line 309
        return (260);
      }
    }
  }
#line 311
  if ((flags & 512L) != 0L) {
#line 311
    if (st->st_nlink != 1U) {
#line 313
      if ((int )tTdvect[44] >= 4) {
        {
#line 314
        sm_dprintf((char *)"\t[link count %d]\tE_SM_NOHLINK\n", (int )st->st_nlink);
        }
      }
#line 316
      return (258);
    }
  }
#line 319
  if (uid == 0U) {
#line 319
    if (! ((flags & 8192L) != 0L)) {
#line 319
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 322
  if (uid == 0U) {
#line 322
    if (! ((flags & 4L) != 0L)) {
#line 323
      mode >>= 6;
    } else {
#line 322
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 324
  if (! (st->st_uid == uid)) {
#line 327
    if (uid == 0U) {
#line 327
      if (! (st->st_uid == TrustedUid)) {
#line 327
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
#line 332
      mode >>= 3;
#line 333
      if (! (st->st_gid == gid)) {
#line 337
        if ((unsigned long )user != (unsigned long )((void *)0)) {
#line 337
          if (! DontInitGroups) {
#line 337
            if ((unsigned long )gr != (unsigned long )((void *)0)) {
#line 337
              if (gr->gr_gid == st->st_gid) {
#line 337
                goto _L___2;
              } else {
#line 337
                goto _L___3;
              }
            } else {
              _L___3: /* CIL Label */ 
              {
#line 337
              gr = getgrgid(st->st_gid);
              }
#line 337
              if ((unsigned long )gr != (unsigned long )((void *)0)) {
                _L___2: /* CIL Label */ 
#line 343
                gp___0 = gr->gr_mem;
                {
#line 343
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 343
                  if (! ((unsigned long )*gp___0 != (unsigned long )((void *)0))) {
#line 343
                    goto while_break___0;
                  }
                  {
#line 344
                  tmp___17 = strcmp((char const   *)*gp___0, (char const   *)user);
                  }
#line 344
                  if (tmp___17 == 0) {
#line 345
                    goto while_break___0;
                  }
#line 343
                  gp___0 ++;
                }
                while_break___0: /* CIL Label */ ;
                }
#line 346
                if ((unsigned long )*gp___0 == (unsigned long )((void *)0)) {
#line 347
                  mode >>= 3;
                }
              } else {
#line 351
                mode >>= 3;
              }
            }
          } else {
#line 351
            mode >>= 3;
          }
        } else {
#line 351
          mode >>= 3;
        }
      }
    }
  }
#line 353
  if ((int )tTdvect[44] >= 4) {
    {
#line 354
    sm_dprintf((char *)"\t[uid %d, nlink %d, stat %lo, mode %lo] ", (int )st->st_uid,
               (int )st->st_nlink, (unsigned long )st->st_mode, (unsigned long )mode);
    }
  }
#line 357
  if (st->st_uid == uid) {
#line 357
    goto _L___7;
  } else
#line 357
  if (st->st_uid == 0U) {
#line 357
    goto _L___7;
  } else
#line 357
  if (st->st_uid == TrustedUid) {
#line 357
    goto _L___7;
  } else
#line 357
  if (! ((flags & 1L) != 0L)) {
    _L___7: /* CIL Label */ 
#line 357
    if ((st->st_mode & (unsigned int )mode) == (unsigned int )mode) {
#line 362
      if ((int )tTdvect[44] >= 4) {
        {
#line 363
        sm_dprintf((char *)"\tOK\n");
        }
      }
#line 364
      return (0);
    }
  }
#line 366
  if ((int )tTdvect[44] >= 4) {
    {
#line 367
    sm_dprintf((char *)"\tEACCES\n");
    }
  }
#line 368
  return (13);
}
}
#line 393 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/safefile.c"
int safedirpath(char *fn , uid_t uid , gid_t gid , char *user , long flags , int level ,
                int offset ) 
{ 
  int ret ;
  int mode ;
  char save ;
  char *saveptr ;
  char *p ;
  char *enddir ;
  register struct group *gr ;
  char s[81920] ;
  struct stat stbuf ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int linklen ;
  char *target ;
  char buf___16[4096] ;
  char fullbuf[81920] ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *sptr ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char const   *tmp___10 ;
  __uid_t tmp___11 ;
  register char **gp ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
#line 403
  ret = 0;
#line 404
  mode = (128 >> 3) >> 3;
#line 405
  save = (char )'\000';
#line 406
  saveptr = (char *)((void *)0);
#line 408
  gr = (struct group *)((void *)0);
#line 413
  if (level > 20) {
#line 414
    return (40);
  }
#line 416
  if (level < 0) {
#line 417
    return (22);
  } else
#line 416
  if (offset < 0) {
#line 417
    return (22);
  } else {
    {
#line 416
    tmp = strlen((char const   *)fn);
    }
#line 416
    if ((size_t )offset > tmp) {
#line 417
      return (22);
    }
  }
#line 420
  if ((int )*fn == 0) {
#line 421
    fn = (char *)"/";
  }
#line 423
  if ((int )tTdvect[44] >= 4) {
    {
#line 424
    sm_dprintf((char *)"safedirpath(%s, uid=%ld, gid=%ld, flags=%lx, level=%d, offset=%d):\n",
               fn, (long )uid, (long )gid, flags, level, offset);
    }
  }
#line 427
  if (! (DontBlameSendmail[2UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 2UL % (8UL * sizeof(int ))))) {
#line 428
    mode |= 128 >> 3;
  }
  {
#line 431
  tmp___0 = sm_strlcpy(s, (char const   *)fn, (ssize_t )sizeof(s));
  }
#line 431
  if ((unsigned long )tmp___0 >= sizeof(s)) {
#line 432
    return (22);
  }
#line 434
  p = s + offset;
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 435
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 435
      goto while_break;
    }
#line 438
    if ((unsigned long )saveptr != (unsigned long )((void *)0)) {
#line 440
      *saveptr = save;
#line 441
      saveptr = (char *)((void *)0);
#line 442
      p ++;
    }
#line 445
    if ((int )*p == 0) {
#line 446
      goto while_break;
    }
    {
#line 448
    p = strchr((char const   *)p, '/');
    }
#line 451
    if ((unsigned long )p == (unsigned long )(s)) {
#line 453
      save = *(p + 1);
#line 454
      saveptr = p + 1;
#line 455
      *(p + 1) = (char )'\000';
    } else
#line 457
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 459
      save = *p;
#line 460
      saveptr = p;
#line 461
      *p = (char )'\000';
    }
    {
#line 465
    enddir = strrchr((char const   *)(s), '/');
    }
#line 466
    if ((unsigned long )enddir != (unsigned long )((void *)0)) {
      {
#line 466
      tmp___1 = strcmp((char const   *)enddir, "/..");
      }
#line 466
      if (tmp___1 == 0) {
#line 469
        goto while_continue;
      } else {
        {
#line 466
        tmp___2 = strcmp((char const   *)enddir, "/.");
        }
#line 466
        if (tmp___2 == 0) {
#line 469
          goto while_continue;
        }
      }
    }
#line 471
    if ((int )tTdvect[44] >= 20) {
      {
#line 472
      sm_dprintf((char *)"\t[dir %s]\n", s);
      }
    }
    {
#line 475
    ret = lstat((char const   */* __restrict  */)(s), (struct stat */* __restrict  */)(& stbuf));
    }
#line 479
    if (ret < 0) {
      {
#line 481
      tmp___3 = __errno_location();
#line 481
      ret = *tmp___3;
      }
#line 482
      goto while_break;
    }
#line 487
    if ((stbuf.st_mode & 61440U) == 40960U) {
      {
#line 494
      memset((void *)(buf___16), '\000', (size_t )sizeof(buf___16));
#line 495
      linklen = readlink((char const   */* __restrict  */)(s), (char */* __restrict  */)(buf___16),
                         (size_t )sizeof(buf___16));
      }
#line 496
      if (linklen < 0) {
        {
#line 498
        tmp___4 = __errno_location();
#line 498
        ret = *tmp___4;
        }
#line 499
        goto while_break;
      }
#line 501
      if ((unsigned long )linklen >= sizeof(buf___16)) {
        {
#line 504
        tmp___5 = __errno_location();
#line 504
        tmp___6 = 22;
#line 504
        *tmp___5 = tmp___6;
#line 504
        ret = tmp___6;
        }
#line 505
        goto while_break;
      }
#line 508
      offset = 0;
#line 509
      if ((int )buf___16[0] == 47) {
#line 511
        target = buf___16;
        {
#line 514
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 514
          if ((int )s[offset] == (int )buf___16[offset]) {
#line 514
            if (! ((int )s[offset] != 0)) {
#line 514
              goto while_break___0;
            }
          } else {
#line 514
            goto while_break___0;
          }
#line 516
          offset ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 518
        if ((int )s[offset] == 0) {
#line 518
          if ((int )buf___16[offset] == 0) {
#line 521
            return (40);
          }
        }
#line 525
        if (offset > 0) {
#line 526
          offset --;
        }
#line 529
        if (offset > 0) {
#line 529
          if ((int )s[offset] != 47) {
#line 529
            if ((int )s[offset] != 0) {
              {
#line 533
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 533
                if ((int )buf___16[offset] != 47) {
#line 533
                  if (! (offset > 0)) {
#line 533
                    goto while_break___1;
                  }
                } else {
#line 533
                  goto while_break___1;
                }
#line 535
                offset --;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
          }
        }
#line 537
        if (offset > 0) {
#line 537
          if ((int )s[offset] == 47) {
#line 537
            if ((int )buf___16[offset] == 47) {
#line 542
              offset ++;
            }
          }
        }
      } else {
        {
#line 549
        sptr = strrchr((char const   *)(s), '/');
        }
#line 550
        if ((unsigned long )sptr != (unsigned long )((void *)0)) {
          {
#line 552
          *sptr = (char )'\000';
#line 553
          offset = (int )((sptr + 1) - s);
#line 554
          tmp___7 = sm_strlcpyn(fullbuf, (ssize_t )sizeof(fullbuf), 2, s, "/");
          }
#line 554
          if ((unsigned long )tmp___7 >= sizeof(fullbuf)) {
#line 562
            ret = 22;
#line 563
            goto while_break;
          } else {
            {
#line 554
            tmp___8 = sm_strlcat(fullbuf, (char const   *)(buf___16), (ssize_t )sizeof(fullbuf));
            }
#line 554
            if ((unsigned long )tmp___8 >= sizeof(fullbuf)) {
#line 562
              ret = 22;
#line 563
              goto while_break;
            }
          }
#line 565
          *sptr = (char )'/';
        } else {
          {
#line 569
          tmp___9 = sm_strlcpy(fullbuf, (char const   *)(buf___16), (ssize_t )sizeof(fullbuf));
          }
#line 569
          if ((unsigned long )tmp___9 >= sizeof(fullbuf)) {
#line 573
            ret = 22;
#line 574
            goto while_break;
          }
        }
#line 577
        target = fullbuf;
      }
      {
#line 579
      ret = safedirpath(target, uid, gid, user, flags, level + 1, offset);
      }
#line 581
      if (ret != 0) {
#line 582
        goto while_break;
      }
#line 585
      goto while_continue;
    }
#line 589
    if (uid == 0U) {
#line 589
      goto _L___0;
    } else
#line 589
    if ((flags & 256L) != 0L) {
      _L___0: /* CIL Label */ 
#line 589
      if (DontBlameSendmail[32UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 32UL % (8UL * sizeof(int )))) {
#line 589
        if (! ((stbuf.st_mode & 512U) != 0U)) {
#line 589
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 589
      if ((stbuf.st_mode & (unsigned int )mode) != 0U) {
#line 596
        if ((int )tTdvect[44] >= 4) {
          {
#line 597
          sm_dprintf((char *)"\t[dir %s] mode %lo ", s, (unsigned long )stbuf.st_mode);
          }
        }
#line 599
        if ((flags & 256L) != 0L) {
#line 601
          if ((stbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
#line 602
            ret = 261;
          } else {
#line 604
            ret = 262;
          }
#line 605
          if ((int )tTdvect[44] >= 4) {
            {
#line 606
            sm_dprintf((char *)"FATAL\n");
            }
          }
#line 607
          goto while_break;
        }
#line 609
        if ((int )tTdvect[44] >= 4) {
          {
#line 610
          sm_dprintf((char *)"WARNING\n");
          }
        }
#line 611
        if (Verbose > 1) {
#line 612
          if ((stbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
#line 612
            tmp___10 = "World";
          } else {
#line 612
            tmp___10 = "Group";
          }
          {
#line 612
          message("051 WARNING: %s writable directory %s", tmp___10, s);
          }
        }
      }
    }
#line 618
    if (uid == 0U) {
#line 618
      if (! ((flags & 8196L) != 0L)) {
#line 620
        if ((stbuf.st_mode & (unsigned int )((64 >> 3) >> 3)) != 0U) {
#line 621
          goto while_continue;
        }
#line 622
        ret = 13;
#line 623
        goto while_break;
      }
    }
    {
#line 632
    tmp___11 = geteuid();
    }
#line 632
    if (tmp___11 != 0U) {
#line 633
      goto while_continue;
    } else
#line 632
    if ((flags & 8192L) != 0L) {
#line 633
      goto while_continue;
    }
#line 635
    if (stbuf.st_uid == uid) {
#line 635
      if ((stbuf.st_mode & 64U) != 0U) {
#line 637
        goto while_continue;
      }
    }
#line 638
    if (stbuf.st_gid == gid) {
#line 638
      if ((stbuf.st_mode & (unsigned int )(64 >> 3)) != 0U) {
#line 640
        goto while_continue;
      }
    }
#line 642
    if ((unsigned long )user != (unsigned long )((void *)0)) {
#line 642
      if (! DontInitGroups) {
#line 642
        if ((unsigned long )gr != (unsigned long )((void *)0)) {
#line 642
          if (gr->gr_gid == stbuf.st_gid) {
#line 642
            goto _L___1;
          } else {
#line 642
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          {
#line 642
          gr = getgrgid(stbuf.st_gid);
          }
#line 642
          if ((unsigned long )gr != (unsigned long )((void *)0)) {
            _L___1: /* CIL Label */ 
#line 648
            gp = gr->gr_mem;
            {
#line 648
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 648
              if ((unsigned long )gp != (unsigned long )((void *)0)) {
#line 648
                if (! ((unsigned long )*gp != (unsigned long )((void *)0))) {
#line 648
                  goto while_break___2;
                }
              } else {
#line 648
                goto while_break___2;
              }
              {
#line 649
              tmp___12 = strcmp((char const   *)*gp, (char const   *)user);
              }
#line 649
              if (tmp___12 == 0) {
#line 650
                goto while_break___2;
              }
#line 648
              gp ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 651
            if ((unsigned long )gp != (unsigned long )((void *)0)) {
#line 651
              if ((unsigned long )*gp != (unsigned long )((void *)0)) {
#line 651
                if ((stbuf.st_mode & (unsigned int )(64 >> 3)) != 0U) {
#line 653
                  goto while_continue;
                }
              }
            }
          }
        }
      }
    }
#line 656
    if (! ((stbuf.st_mode & (unsigned int )((64 >> 3) >> 3)) != 0U)) {
#line 658
      ret = 13;
#line 659
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  if ((int )tTdvect[44] >= 4) {
#line 663
    if (ret == 0) {
#line 663
      tmp___14 = "OK";
    } else {
      {
#line 663
      tmp___13 = sm_errstring(ret);
#line 663
      tmp___14 = tmp___13;
      }
    }
    {
#line 663
    sm_dprintf((char *)"\t[dir %s] %s\n", fn, tmp___14);
    }
  }
#line 665
  return (ret);
}
}
#line 680 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/safefile.c"
int safeopen(char *fn , int omode , int cmode , long sff ) 
{ 
  bool truncate___0 ;
  int rval ;
  int fd ;
  int smode ;
  struct stat stb ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  bool tmp___3 ;
  int save_errno ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 695
  if ((int )tTdvect[44] >= 10) {
    {
#line 696
    sm_dprintf((char *)"safeopen: fn=%s, omode=%x, cmode=%x, sff=%lx\n", fn, omode,
               cmode, sff);
    }
  }
#line 699
  if ((omode & 64) != 0) {
#line 700
    sff |= 64L;
  }
#line 701
  omode &= -65;
#line 702
  smode = 0;
  {
#line 705
  if ((omode & 3) == 0) {
#line 705
    goto case_0;
  }
#line 709
  if ((omode & 3) == 1) {
#line 709
    goto case_1;
  }
#line 713
  if ((omode & 3) == 2) {
#line 713
    goto case_2;
  }
#line 717
  goto switch_default;
  case_0: /* CIL Label */ 
#line 706
  smode = 256;
#line 707
  goto switch_break;
  case_1: /* CIL Label */ 
#line 710
  smode = 128;
#line 711
  goto switch_break;
  case_2: /* CIL Label */ 
#line 714
  smode = 384;
#line 715
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 718
  smode = 0;
#line 719
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 721
  if ((sff & 8192L) != 0L) {
    {
#line 722
    rval = safefile(fn, RunAsUid, RunAsGid, RunAsUserName, sff, smode, & stb);
    }
  } else {
    {
#line 725
    rval = safefile(fn, RealUid, RealGid, RealUserName, sff, smode, & stb);
    }
  }
#line 727
  if (rval != 0) {
    {
#line 729
    tmp = __errno_location();
#line 729
    *tmp = rval;
    }
#line 730
    return (-1);
  }
#line 732
  if (stb.st_mode == 62055U) {
#line 732
    if ((sff & 64L) != 0L) {
#line 733
      if ((sff & 131072L) != 0L) {
#line 733
        tmp___0 = 0;
      } else {
#line 733
        tmp___0 = 128;
      }
#line 733
      omode |= 64 | tmp___0;
    } else {
#line 732
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 734
  if ((sff & 64L) != 0L) {
#line 734
    if ((omode & 128) != 0) {
      {
#line 737
      tmp___1 = __errno_location();
#line 737
      *tmp___1 = 17;
      }
#line 738
      return (-1);
    }
  }
#line 742
  truncate___0 = (omode & 512) != 0;
#line 743
  if (truncate___0) {
#line 744
    omode &= -513;
  }
  {
#line 747
  fd = dfopen(fn, omode, cmode, sff);
  }
#line 748
  if (fd < 0) {
#line 749
    return (fd);
  }
  {
#line 750
  tmp___3 = filechanged(fn, fd, & stb);
  }
#line 750
  if (tmp___3) {
    {
#line 752
    syserr("554 5.3.0 cannot open: file %s changed after open", fn);
#line 753
    close(fd);
#line 754
    tmp___2 = __errno_location();
#line 754
    *tmp___2 = 263;
    }
#line 755
    return (-1);
  }
#line 759
  if (truncate___0) {
    {
#line 759
    tmp___6 = ftruncate(fd, (off_t )0);
    }
#line 759
    if (tmp___6 < 0) {
      {
#line 764
      tmp___4 = __errno_location();
#line 764
      save_errno = *tmp___4;
#line 765
      syserr("554 5.3.0 cannot open: file %s could not be truncated", fn);
#line 767
      close(fd);
#line 768
      tmp___5 = __errno_location();
#line 768
      *tmp___5 = save_errno;
      }
#line 769
      return (-1);
    }
  }
#line 773
  return (fd);
}
}
#line 788 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/safefile.c"
SM_FILE_T *safefopen(char *fn , int omode , int cmode , long sff ) 
{ 
  int fd ;
  int save_errno ;
  SM_FILE_T *fp ;
  int fmode ;
  int *tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 802
  if ((omode & 3) == 0) {
#line 802
    goto case_0;
  }
#line 806
  if ((omode & 3) == 1) {
#line 806
    goto case_1;
  }
#line 813
  if ((omode & 3) == 2) {
#line 813
    goto case_2;
  }
#line 822
  goto switch_default;
  case_0: /* CIL Label */ 
#line 803
  fmode = 2;
#line 804
  goto switch_break;
  case_1: /* CIL Label */ 
#line 807
  if ((omode & 1024) != 0) {
#line 808
    fmode = 4;
  } else {
#line 810
    fmode = 3;
  }
#line 811
  goto switch_break;
  case_2: /* CIL Label */ 
#line 814
  if ((omode & 512) != 0) {
#line 815
    fmode = 6;
  } else
#line 816
  if ((omode & 1024) != 0) {
#line 817
    fmode = 5;
  } else {
#line 819
    fmode = 1;
  }
#line 820
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 823
  syserr("554 5.3.5 safefopen: unknown omode %o", omode);
#line 824
  fmode = 0;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 826
  fd = safeopen(fn, omode, cmode, sff);
  }
#line 827
  if (fd < 0) {
    {
#line 829
    tmp = __errno_location();
#line 829
    save_errno = *tmp;
    }
#line 830
    if ((int )tTdvect[44] >= 10) {
      {
#line 831
      tmp___0 = __errno_location();
#line 831
      tmp___1 = sm_errstring(*tmp___0);
#line 831
      sm_dprintf((char *)"safefopen: safeopen failed: %s\n", tmp___1);
      }
    }
    {
#line 833
    tmp___2 = __errno_location();
#line 833
    *tmp___2 = save_errno;
    }
#line 834
    return ((SM_FILE_T *)((void *)0));
  }
  {
#line 836
  fp = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& fd)),
                  fmode, (void const   *)((void *)0));
  }
#line 838
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 839
    return (fp);
  }
  {
#line 841
  tmp___3 = __errno_location();
#line 841
  save_errno = *tmp___3;
  }
#line 842
  if ((int )tTdvect[44] >= 10) {
    {
#line 844
    tmp___4 = __errno_location();
#line 844
    tmp___5 = sm_errstring(*tmp___4);
#line 844
    sm_dprintf((char *)"safefopen: fdopen(%s, %d) failed: omode=%x, sff=%lx, err=%s\n",
               fn, fmode, omode, sff, tmp___5);
    }
  }
  {
#line 847
  close(fd);
#line 848
  tmp___6 = __errno_location();
#line 848
  *tmp___6 = save_errno;
  }
#line 849
  return ((SM_FILE_T *)((void *)0));
}
}
#line 864 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/safefile.c"
bool filechanged(char *fn , int fd , struct stat *stb ) 
{ 
  struct stat sta ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 872
  if (stb->st_mode == 62055U) {
#line 879
    return (0);
  }
  {
#line 882
  tmp = fstat(fd, & sta);
  }
#line 882
  if (tmp < 0) {
#line 883
    return (1);
  }
#line 885
  if (sta.st_nlink != stb->st_nlink) {
#line 885
    goto _L;
  } else
#line 885
  if (sta.st_dev != stb->st_dev) {
#line 885
    goto _L;
  } else
#line 885
  if (sta.st_ino != stb->st_ino) {
#line 885
    goto _L;
  } else
#line 885
  if (sta.st_uid != stb->st_uid) {
#line 885
    goto _L;
  } else
#line 885
  if (sta.st_gid != stb->st_gid) {
    _L: /* CIL Label */ 
#line 894
    if ((int )tTdvect[44] >= 8) {
      {
#line 896
      sm_dprintf((char *)"File changed after opening:\n");
#line 897
      sm_dprintf((char *)" nlink\t= %ld/%ld\n", (long )stb->st_nlink, (long )sta.st_nlink);
#line 899
      sm_dprintf((char *)" dev\t= %ld/%ld\n", (long )stb->st_dev, (long )sta.st_dev);
#line 901
      sm_dprintf((char *)" ino\t= %llu/%llu\n", (ULONGLONG_T )stb->st_ino, (ULONGLONG_T )sta.st_ino);
#line 908
      sm_dprintf((char *)" uid\t= %ld/%ld\n", (long )stb->st_uid, (long )sta.st_uid);
#line 910
      sm_dprintf((char *)" gid\t= %ld/%ld\n", (long )stb->st_gid, (long )sta.st_gid);
      }
    }
#line 913
    return (1);
  }
#line 916
  return (0);
}
}
#line 927 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/safefile.c"
int dfopen(char *filename , int omode , int cmode , long sff ) 
{ 
  register int tries ;
  int fd ;
  struct stat st ;
  int *tmp ;
  int *tmp___0 ;
  int locktype ;
  int save_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;

  {
#line 935
  fd = -1;
#line 938
  tries = 0;
  {
#line 938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 938
    if (! (tries < 10)) {
#line 938
      goto while_break;
    }
    {
#line 940
    sleep((unsigned int )(10 * tries));
#line 941
    tmp = __errno_location();
#line 941
    *tmp = 0;
#line 942
    fd = open((char const   *)filename, omode, cmode);
    }
#line 943
    if (fd >= 0) {
#line 944
      goto while_break;
    }
    {
#line 945
    tmp___0 = __errno_location();
    }
    {
#line 950
    if (*tmp___0 == 26) {
#line 950
      goto case_26;
    }
#line 950
    if (*tmp___0 == 4) {
#line 950
      goto case_26;
    }
#line 950
    if (*tmp___0 == 23) {
#line 950
      goto case_26;
    }
#line 945
    goto switch_break;
    case_26: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_23: /* CIL Label */ 
#line 952
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
#line 954
    goto while_break;
    __Cont: /* CIL Label */ 
#line 938
    tries ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 956
  if (! ((sff & 16384L) != 0L)) {
#line 956
    if (fd >= 0) {
      {
#line 956
      tmp___5 = fstat(fd, & st);
      }
#line 956
      if (tmp___5 >= 0) {
#line 956
        if ((st.st_mode & 61440U) == 32768U) {
#line 964
          if ((omode & 3) != 0) {
#line 965
            locktype = 2;
          } else {
#line 967
            locktype = 1;
          }
#line 968
          if ((sff & 524288L) != 0L) {
#line 969
            locktype |= 4;
          }
          {
#line 971
          tmp___4 = lockfile(fd, filename, (char *)((void *)0), locktype);
          }
#line 971
          if (tmp___4) {
            {
#line 980
            tmp___3 = __errno_location();
#line 980
            *tmp___3 = 0;
            }
          } else {
            {
#line 973
            tmp___1 = __errno_location();
#line 973
            save_errno = *tmp___1;
#line 975
            close(fd);
#line 976
            fd = -1;
#line 977
            tmp___2 = __errno_location();
#line 977
            *tmp___2 = save_errno;
            }
          }
        }
      }
    }
  }
#line 982
  return (fd);
}
}
#line 36 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/lockfile.c"
bool lockfile(int fd , char *filename , char *ext , int type ) 
{ 
  int action ;
  struct flock lfd ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 47
  memset((void *)(& lfd), '\000', (size_t )sizeof(lfd));
  }
#line 48
  if ((type & 8) != 0) {
#line 49
    lfd.l_type = (short)2;
  } else
#line 50
  if ((type & 2) != 0) {
#line 51
    lfd.l_type = (short)1;
  } else {
#line 53
    lfd.l_type = (short)0;
  }
#line 54
  if ((type & 4) != 0) {
#line 55
    action = 6;
  } else {
#line 57
    action = 7;
  }
  {
#line 59
  tmp = fcntl(fd, action, & lfd);
  }
#line 59
  if (tmp >= 0) {
#line 60
    return (1);
  }
  {
#line 71
  tmp___0 = __errno_location();
  }
#line 71
  if (*tmp___0 == 22) {
#line 72
    return (1);
  }
#line 81
  return (0);
}
}
#line 336 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 18 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/err.c"
void message(char const   *msg  , ...) 
{ 
  char const   *m ;
  va_list ap ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 30
  m = msg;
#line 31
  if (((int const   )*(m + 0) & -128) == 0) {
    {
#line 31
    tmp = __ctype_b_loc();
    }
#line 31
    if ((int const   )*(*tmp + (int )*(m + 0)) & 2048) {
#line 31
      if (((int const   )*(m + 1) & -128) == 0) {
        {
#line 31
        tmp___0 = __ctype_b_loc();
        }
#line 31
        if ((int const   )*(*tmp___0 + (int )*(m + 1)) & 2048) {
#line 31
          if (((int const   )*(m + 2) & -128) == 0) {
            {
#line 31
            tmp___1 = __ctype_b_loc();
            }
#line 31
            if ((int const   )*(*tmp___1 + (int )*(m + 2)) & 2048) {
#line 31
              if ((int const   )*(m + 3) == 32) {
#line 34
                m += 4;
              }
            }
          }
        }
      }
    }
  }
  {
#line 35
  __builtin_va_start(ap, msg);
#line 36
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)m, ap);
#line 37
  __builtin_va_end(ap);
#line 38
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 39
  return;
}
}
#line 42 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/err.c"
void syserr(char const   *msg  , ...) 
{ 
  char const   *m ;
  va_list ap ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 54
  m = msg;
#line 55
  if (((int const   )*(m + 0) & -128) == 0) {
    {
#line 55
    tmp = __ctype_b_loc();
    }
#line 55
    if ((int const   )*(*tmp + (int )*(m + 0)) & 2048) {
#line 55
      if (((int const   )*(m + 1) & -128) == 0) {
        {
#line 55
        tmp___0 = __ctype_b_loc();
        }
#line 55
        if ((int const   )*(*tmp___0 + (int )*(m + 1)) & 2048) {
#line 55
          if (((int const   )*(m + 2) & -128) == 0) {
            {
#line 55
            tmp___1 = __ctype_b_loc();
            }
#line 55
            if ((int const   )*(*tmp___1 + (int )*(m + 2)) & 2048) {
#line 55
              if ((int const   )*(m + 3) == 32) {
#line 58
                m += 4;
              }
            }
          }
        }
      }
    }
  }
  {
#line 59
  __builtin_va_start(ap, msg);
#line 60
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)m, ap);
#line 61
  __builtin_va_end(ap);
#line 62
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 63
  return;
}
}
#line 2058 "../../sendmail/sendmail.h"
unsigned char tTdvect[100]  ;
#line 61 "../../include/sendmail/pathnames.h"
char *getcfname(int opmode , int submitmode , int cftype , char *conffile ) ;
#line 55 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/cf.c"
static char cf[4096]  ;
#line 33 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/libsmutil/cf.c"
char *getcfname(int opmode , int submitmode , int cftype , char *conffile ) 
{ 
  struct stat sbuf ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 44
  if ((unsigned long )conffile != (unsigned long )((void *)0)) {
#line 45
    return (conffile);
  }
#line 47
  if (cftype == 2) {
#line 47
    goto _L;
  } else
#line 47
  if (submitmode != 0) {
#line 47
    goto _L___0;
  } else
#line 47
  if (opmode == 109) {
#line 47
    goto _L___0;
  } else
#line 47
  if (opmode == 97) {
#line 47
    goto _L___0;
  } else
#line 47
  if (opmode == 115) {
    _L___0: /* CIL Label */ 
#line 47
    if (cftype != 1) {
      _L: /* CIL Label */ 
      {
#line 64
      sm_strlcpyn(cf, (ssize_t )sizeof(cf), 2, "/etc/mail/", "submit.cf");
      }
#line 66
      if (cftype == 2) {
#line 67
        return (cf);
      } else {
        {
#line 66
        tmp = stat((char const   */* __restrict  */)(cf), (struct stat */* __restrict  */)(& sbuf));
        }
#line 66
        if (tmp == 0) {
#line 67
          return (cf);
        }
      }
    }
  }
#line 75
  return ((char *)"/etc/mail/sendmail.cf");
}
}
#line 18 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/version.c"
char Version[7]  = {      (char )'8',      (char )'.',      (char )'1',      (char )'3', 
        (char )'.',      (char )'6',      (char )'\000'};
#line 369 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 434
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 469
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 480
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execve)(char const   *__path ,
                                                                                   char * const  *__argv ,
                                                                                   char * const  *__envp ) ;
#line 524
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 643
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 660
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 695
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 744
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 856
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chroot)(char const   *__path ) ;
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 191 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 284 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 114 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 128
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 355 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
#line 474 "./sendmail.h"
MAILER *ProgMailer ;
#line 960
ENVELOPE BlankEnvelope ;
#line 1073
void macdefine_tagged(MACROS_T *mac , ARGCLASS_T vclass , int id , char *value , char *file ,
                      int line , int grp ) ;
#line 1095
void expand(char *s , char *buf___16 , size_t bufsize , ENVELOPE *e ) ;
#line 1096
int macid_parse(char *p , char **ep ) ;
#line 1098
char *macname(int n ) ;
#line 1099
char *macvalue(int n , ENVELOPE *e ) ;
#line 1374
char *hostnamebyanyaddr(union bigsockaddr *sap ) ;
#line 1401
void proc_list_add(pid_t pid , char *task , int type , int count , int other , union bigsockaddr *hostaddr ) ;
#line 1402
void proc_list_clear(void) ;
#line 1403
void proc_list_display(SM_FILE_T *out , char *prefix ) ;
#line 1404
void proc_list_drop(pid_t pid , int st , int *other ) ;
#line 1405
void proc_list_probe(void) ;
#line 1406
void proc_list_set(pid_t pid , char *task ) ;
#line 1407
void proc_list_signal(int type , int signal___0 ) ;
#line 1559
void set_delivery_mode(int mode , ENVELOPE *e ) ;
#line 1939
int volatile   CurRunners ;
#line 1959
ADDRESS *copyqueue(ADDRESS *addr , SM_RPOOL_T *rpool ) ;
#line 1981
void sync_dir(char *filename , bool panic ) ;
#line 2164
bool HasEightBits ;
#line 2179
bool volatile   RestartWorkGroup ;
#line 2183
bool SevenBitInput ;
#line 2197
char OpMode ;
#line 2203
int volatile   CurChildren ;
#line 2211
int FileMode ;
#line 2212
int LineNumber ;
#line 2213
int LogLevel ;
#line 2252
gid_t DefGid ;
#line 2262
pid_t CurrentPid ;
#line 2264
pid_t PidFilePid ;
#line 2265
uid_t DefUid ;
#line 2283
char *CurHostName ;
#line 2285
char *DefUser ;
#line 2300
char *MustQuoteChars ;
#line 2303
char *PidFile ;
#line 2306
char *RealHostName ;
#line 2308
char * volatile  RestartRequest ;
#line 2312
char * volatile  ShutdownRequest ;
#line 2325
SM_FILE_T *TrafficLogFile ;
#line 2329
ENVELOPE *CurEnv ;
#line 2331
char *UserEnviron[101] ;
#line 2333
struct termescape TermEscape ;
#line 2371
void sm_syslog(int level , char const   *id , char const   *fmt  , ...) ;
#line 2439
char *addquotes(char *s , SM_RPOOL_T *rpool ) ;
#line 2441
bool atobool(char *s ) ;
#line 2442
int atooct(char *s ) ;
#line 2445
bool bitintersect(unsigned int *a , unsigned int *b___0 ) ;
#line 2446
bool bitzerop(unsigned int *map___0 ) ;
#line 2447
int check_bodytype(char *bodytype ) ;
#line 2453
void checkfd012(char *where ) ;
#line 2454
void checkfdopen(int fd , char *where ) ;
#line 2456
void checkfds(char *where ) ;
#line 2458
void cleanstrcpy(char *t , char *f , int l ) ;
#line 2462
void close_sendmail_pid(void) ;
#line 2467
char **copyplist(char **list , bool copycont , SM_RPOOL_T *rpool ) ;
#line 2469
int count_open_connections(union bigsockaddr *hostaddr ) ;
#line 2470
time_t curtime(void) ;
#line 2472
char *denlstring(char *s , bool strict , bool logattacks ) ;
#line 2482
void dumpfd(int fd , bool printclosed , bool logit ) ;
#line 2486
void fatal_error(SM_EXC_T *exc ) ;
#line 2487
char *fgetfolded(char *buf___16 , int n , SM_FILE_T *f ) ;
#line 2488
void fill_fd(int fd , char *where ) ;
#line 2489
char *find_character(char *string , int character ) ;
#line 2492
void fixcrlf(char *line , bool stripnl ) ;
#line 2497
char *get_column(char *line , int col , int delim , char *buf___16 , int buflen___1 ) ;
#line 2515
void log_sendmail_pid(ENVELOPE *e ) ;
#line 2518
void makelower(char *p ) ;
#line 2523
void mark_work_group_restart(int wgrp , int reason ) ;
#line 2526
char *newstr(char const   *s ) ;
#line 2530
bool path_is_dir(char *pathname , bool createflag ) ;
#line 2533
void printav(SM_FILE_T *fp , char **av___0 ) ;
#line 2536
void printopenfds(bool logit ) ;
#line 2539
pid_t prog_open(char **argv , int *pfd , ENVELOPE *e ) ;
#line 2540
bool putline(char *l , struct mailer_con_info *mci ) ;
#line 2541
bool putxline(char *l , size_t len___0 , struct mailer_con_info *mci , int pxflags ) ;
#line 2549
bool rfc822_string(char *s ) ;
#line 2558
void set_op_mode(int mode ) ;
#line 2563
char *sfgets(char *buf___16 , int siz , SM_FILE_T *fp , time_t timeout , char *during ) ;
#line 2565
char *shorten_hostname(char *host ) ;
#line 2566
bool shorten_rfc822_string(char *string , size_t length ) ;
#line 2569
void sm_close_on_exec(int highest , int lowest ) ;
#line 2579
char *str2prt(char *s ) ;
#line 2580
void stripbackslash(char *s ) ;
#line 2581
bool strreplnonprt(char *s , int c ) ;
#line 2582
bool strcontainedin(bool icase , char *a , char *b___0 ) ;
#line 2584
bool transienterror(int err ) ;
#line 2614
char *xalloc_tagged(int sz , char *file , int line ) ;
#line 2618
void xputs(SM_FILE_T *fp , char const   *s ) ;
#line 2621
int xunlink(char *f ) ;
#line 31 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
char *newstr(char const   *s ) 
{ 
  size_t l ;
  char *n ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 38
  l = strlen(s);
  }
#line 39
  if (l + 1U > l) {
#line 39
    tmp = 1;
  } else {
    {
#line 39
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                39, "SM_ASSERT(l + 1 > l) failed");
#line 39
    tmp = 0;
    }
  }
  {
#line 40
  n = xalloc_tagged((int )(l + 1U), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                    40);
#line 41
  sm_strlcpy(n, s, (ssize_t )(l + 1U));
  }
#line 42
  return (n);
}
}
#line 58 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
char *addquotes(char *s , SM_RPOOL_T *rpool ) 
{ 
  int len___0 ;
  char c ;
  char *p ;
  char *q ;
  char *r ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp15 ;

  {
#line 63
  len___0 = 0;
#line 65
  p = s;
#line 67
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 68
    return ((char *)((void *)0));
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    tmp = p;
#line 71
    p ++;
#line 71
    c = *tmp;
#line 71
    if (! ((int )c != 0)) {
#line 71
      goto while_break;
    }
#line 73
    len___0 ++;
#line 74
    if ((int )c == 92) {
#line 75
      len___0 ++;
    } else
#line 74
    if ((int )c == 34) {
#line 75
      len___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  tmp___0 = sm_rpool_malloc_tagged_x(rpool, (size_t )(len___0 + 3), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                                     78, SmHeapGroup);
#line 78
  r = (char *)tmp___0;
#line 78
  q = r;
#line 79
  p = s;
#line 82
  tmp___1 = q;
#line 82
  q ++;
#line 82
  *tmp___1 = (char )'\"';
  }
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 83
    tmp___4 = p;
#line 83
    p ++;
#line 83
    c = *tmp___4;
#line 83
    if (! ((int )c != 0)) {
#line 83
      goto while_break___0;
    }
#line 86
    if ((int )c == 92) {
#line 87
      tmp___2 = q;
#line 87
      q ++;
#line 87
      *tmp___2 = (char )'\\';
    } else
#line 86
    if ((int )c == 34) {
#line 87
      tmp___2 = q;
#line 87
      q ++;
#line 87
      *tmp___2 = (char )'\\';
    }
#line 88
    tmp___3 = q;
#line 88
    q ++;
#line 88
    *tmp___3 = c;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 90
  tmp___5 = q;
#line 90
  q ++;
#line 90
  *tmp___5 = (char )'\"';
#line 91
  *q = (char )'\000';
#line 92
  return (r);
}
}
#line 108 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void stripbackslash(char *s ) 
{ 
  char *p ;
  char *q ;
  char c ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char *tmp___2 ;

  {
#line 114
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 115
    return;
  } else
#line 114
  if ((int )*s == 0) {
#line 115
    return;
  }
#line 116
  q = s;
#line 116
  p = q;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if ((int )*p == 92) {
#line 117
      if (! ((int )*(p + 1) == 92)) {
#line 117
        if (((int )*(p + 1) & -128) == 0) {
          {
#line 117
          tmp = __ctype_b_loc();
          }
#line 117
          if (! ((int const   )*(*tmp + (int )*(p + 1)) & 8)) {
#line 117
            goto while_break;
          }
        } else {
#line 117
          goto while_break;
        }
      }
    } else {
#line 117
      goto while_break;
    }
#line 118
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    tmp___0 = q;
#line 121
    q ++;
#line 121
    tmp___2 = p;
#line 121
    p ++;
#line 121
    tmp___1 = *tmp___2;
#line 121
    *tmp___0 = tmp___1;
#line 121
    c = tmp___1;
#line 119
    if (! ((int )c != 0)) {
#line 119
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 139 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
bool rfc822_string(char *s ) 
{ 
  bool quoted ;
  int commentlev ;
  char *c ;
  char *tmp ;
  int tmp___0 ;

  {
#line 143
  quoted = 0;
#line 144
  commentlev = 0;
#line 145
  c = s;
#line 147
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 148
    return (0);
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((int )*c != 0)) {
#line 150
      goto while_break;
    }
#line 153
    if ((int )*c == 92) {
#line 155
      c ++;
#line 156
      if ((int )*c == 0) {
#line 157
        return (0);
      }
    } else
#line 159
    if (commentlev == 0) {
#line 159
      if ((int )*c == 34) {
#line 160
        quoted = ! quoted;
      } else {
#line 159
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 161
    if (! quoted) {
#line 163
      if ((int )*c == 41) {
#line 166
        if (commentlev == 0) {
#line 167
          return (0);
        } else {
#line 169
          commentlev --;
        }
      } else
#line 171
      if ((int )*c == 40) {
#line 172
        commentlev ++;
      } else
#line 173
      if (commentlev == 0) {
        {
#line 173
        tmp = strchr((char const   *)MustQuoteChars, (int )*c);
        }
#line 173
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 175
          return (0);
        }
      }
    }
#line 177
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  if (! quoted) {
#line 181
    if (commentlev == 0) {
#line 181
      tmp___0 = 1;
    } else {
#line 181
      tmp___0 = 0;
    }
  } else {
#line 181
    tmp___0 = 0;
  }
#line 181
  return (tmp___0);
}
}
#line 201 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
bool shorten_rfc822_string(char *string , size_t length ) 
{ 
  bool backslash ;
  bool modified ;
  bool quoted ;
  size_t slen ;
  int parencount ;
  char *ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 206
  backslash = 0;
#line 207
  modified = 0;
#line 208
  quoted = 0;
#line 210
  parencount = 0;
#line 211
  ptr = string;
#line 218
  slen = strlen((char const   *)string);
  }
#line 219
  if (length == 0U) {
#line 220
    length = slen;
  } else
#line 219
  if (slen < length) {
#line 220
    length = slen;
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! ((int )*ptr != 0)) {
#line 222
      goto while_break;
    }
#line 224
    if (backslash) {
#line 226
      backslash = 0;
#line 227
      goto increment;
    }
#line 230
    if ((int )*ptr == 92) {
#line 231
      backslash = 1;
    } else
#line 232
    if ((int )*ptr == 40) {
#line 234
      if (! quoted) {
#line 235
        parencount ++;
      }
    } else
#line 237
    if ((int )*ptr == 41) {
#line 239
      parencount --;
#line 239
      if (parencount < 0) {
#line 240
        parencount = 0;
      }
    }
#line 244
    if (parencount <= 0) {
#line 244
      if ((int )*ptr == 34) {
#line 245
        quoted = ! quoted;
      }
    }
    increment: 
#line 249
    if (backslash) {
#line 249
      tmp = 1;
    } else {
#line 249
      tmp = 0;
    }
#line 249
    if (quoted) {
#line 249
      tmp___0 = 1;
    } else {
#line 249
      tmp___0 = 0;
    }
#line 249
    if ((long )length - (ptr - string) <= (long )((size_t )((tmp + parencount) + tmp___0))) {
#line 254
      if ((int )*ptr == 92) {
#line 255
        backslash = 0;
      } else
#line 256
      if ((int )*ptr == 40) {
#line 256
        if (! quoted) {
#line 257
          parencount --;
        } else {
#line 256
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 258
      if ((int )*ptr == 34) {
#line 258
        if (parencount == 0) {
#line 259
          quoted = 0;
        }
      }
#line 260
      goto while_break;
    }
#line 262
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 266
    tmp___1 = parencount;
#line 266
    parencount --;
#line 266
    if (! (tmp___1 > 0)) {
#line 266
      goto while_break___0;
    }
#line 268
    if ((int )*ptr != 41) {
#line 270
      modified = 1;
#line 271
      *ptr = (char )')';
    }
#line 273
    ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 275
  if (quoted) {
#line 277
    if ((int )*ptr != 34) {
#line 279
      modified = 1;
#line 280
      *ptr = (char )'\"';
    }
#line 282
    ptr ++;
  }
#line 284
  if ((int )*ptr != 0) {
#line 286
    modified = 1;
#line 287
    *ptr = (char )'\000';
  }
#line 289
  return (modified);
}
}
#line 307 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
char *find_character(char *string , int character ) 
{ 
  bool backslash ;
  bool quoted ;
  int parencount ;

  {
#line 312
  backslash = 0;
#line 313
  quoted = 0;
#line 314
  parencount = 0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if ((unsigned long )string != (unsigned long )((void *)0)) {
#line 316
      if (! ((int )*string != 0)) {
#line 316
        goto while_break;
      }
    } else {
#line 316
      goto while_break;
    }
#line 318
    if (backslash) {
#line 320
      backslash = 0;
#line 321
      if (! quoted) {
#line 321
        if (character == 92) {
#line 321
          if ((int )*string == 92) {
#line 322
            goto while_break;
          }
        }
      }
#line 323
      string ++;
#line 324
      goto while_continue;
    }
    {
#line 328
    if ((int )*string == 92) {
#line 328
      goto case_92;
    }
#line 332
    if ((int )*string == 40) {
#line 332
      goto case_40;
    }
#line 337
    if ((int )*string == 41) {
#line 337
      goto case_41;
    }
#line 326
    goto switch_break;
    case_92: /* CIL Label */ 
#line 329
    backslash = 1;
#line 330
    goto switch_break;
    case_40: /* CIL Label */ 
#line 333
    if (! quoted) {
#line 334
      parencount ++;
    }
#line 335
    goto switch_break;
    case_41: /* CIL Label */ 
#line 338
    parencount --;
#line 338
    if (parencount < 0) {
#line 339
      parencount = 0;
    }
#line 340
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 344
    if (parencount > 0) {
#line 346
      string ++;
#line 347
      goto while_continue;
    }
#line 350
    if ((int )*string == 34) {
#line 351
      quoted = ! quoted;
    } else
#line 352
    if ((int )*string == character) {
#line 352
      if (! quoted) {
#line 353
        goto while_break;
      }
    }
#line 354
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  return (string);
}
}
#line 372 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
int check_bodytype(char *bodytype ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 377
  if ((unsigned long )bodytype == (unsigned long )((void *)0)) {
#line 378
    return (0);
  }
  {
#line 379
  tmp = sm_strcasecmp((char const   *)bodytype, "7BIT");
  }
#line 379
  if (tmp == 0) {
#line 380
    return (1);
  }
  {
#line 381
  tmp___0 = sm_strcasecmp((char const   *)bodytype, "8BITMIME");
  }
#line 381
  if (tmp___0 == 0) {
#line 382
    return (2);
  }
#line 383
  return (-1);
}
}
#line 446 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
char *xalloc_tagged(int sz , char *file , int line ) 
{ 
  register char *p ;
  int tmp ;
  int tmp___0 ;
  SM_ATOMIC_UINT_T tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 459
  if (sz >= 0) {
#line 459
    tmp = 1;
  } else {
    {
#line 459
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                459, "SM_REQUIRE(sz >= 0) failed");
#line 459
    tmp = 0;
    }
  }
#line 462
  if (sz <= 0) {
#line 463
    sz = 1;
  }
#line 466
  SmXtrapCount ++;
#line 466
  if (SmXtrapDebug.debug_level == 4294967295U) {
    {
#line 466
    tmp___0 = sm_debug_loadlevel(& SmXtrapDebug);
#line 466
    tmp___1 = (SM_ATOMIC_UINT_T )tmp___0;
    }
  } else {
#line 466
    tmp___1 = SmXtrapDebug.debug_level;
  }
#line 466
  if (SmXtrapCount == tmp___1) {
    {
#line 466
    sm_exc_raise_x(& SmHeapOutOfMemory);
    }
  }
  {
#line 468
  tmp___2 = sm_malloc_tagged((unsigned int )sz, file, line, SmHeapGroup);
#line 468
  p = (char *)tmp___2;
  }
#line 469
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 471
    sm_exc_raise_x(& SmHeapOutOfMemory);
    }
  }
#line 473
  return (p);
}
}
#line 493 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
char **copyplist(char **list , bool copycont , SM_RPOOL_T *rpool ) 
{ 
  register char **vp ;
  register char **newvp ;
  void *tmp ;
  char *__cil_tmp7 ;

  {
#line 502
  vp = list;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! ((unsigned long )*vp != (unsigned long )((void *)0))) {
#line 502
      goto while_break;
    }
#line 503
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 502
    vp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 505
  vp ++;
#line 507
  tmp = sm_rpool_malloc_tagged_x(rpool, (size_t )((unsigned long )(vp - list) * sizeof(*vp)),
                                 (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                                 507, SmHeapGroup);
#line 507
  newvp = (char **)tmp;
#line 508
  memmove((void *)((char *)newvp), (void const   *)((char *)list), (size_t )((unsigned long )((int )(vp - list)) * sizeof(*vp)));
  }
#line 510
  if (copycont) {
#line 512
    vp = newvp;
    {
#line 512
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 512
      if (! ((unsigned long )*vp != (unsigned long )((void *)0))) {
#line 512
        goto while_break___0;
      }
      {
#line 513
      *vp = sm_rpool_strdup_x(rpool, (char const   *)*vp);
#line 512
      vp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 516
  return (newvp);
}
}
#line 532 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
ADDRESS *copyqueue(ADDRESS *addr , SM_RPOOL_T *rpool ) 
{ 
  register ADDRESS *newaddr ;
  ADDRESS *ret ;
  register ADDRESS **tail ;
  void *tmp ;
  char *__cil_tmp7 ;

  {
#line 539
  tail = & ret;
  {
#line 541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 541
    if (! ((unsigned long )addr != (unsigned long )((void *)0))) {
#line 541
      goto while_break;
    }
#line 543
    if (! ((int )addr->q_state >= 6)) {
      {
#line 545
      tmp = sm_rpool_malloc_tagged_x(rpool, (size_t )sizeof(*newaddr), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                                     546, SmHeapGroup);
#line 545
      newaddr = (ADDRESS *)tmp;
#line 547
      *newaddr = *addr;
#line 548
      *tail = newaddr;
#line 549
      tail = & newaddr->q_next;
      }
    }
#line 551
    addr = addr->q_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 553
  *tail = (ADDRESS *)((void *)0);
#line 555
  return (ret);
}
}
#line 571 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
static SM_FILE_T *Pidf  =    (SM_FILE_T *)((void *)0);
#line 579
char *CommandLineArgs ;
#line 573 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void log_sendmail_pid(ENVELOPE *e ) 
{ 
  long sff ;
  char pidpath[4096] ;
  int *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 582
  sff = 524998L;
#line 583
  if (TrustedUid != 0U) {
#line 583
    if (RealUid == TrustedUid) {
#line 584
      sff |= 8192L;
    }
  }
  {
#line 585
  expand(PidFile, pidpath, (size_t )sizeof(pidpath), e);
#line 586
  Pidf = safefopen(pidpath, 513, FileMode, sff);
  }
#line 587
  if ((unsigned long )Pidf == (unsigned long )((void *)0)) {
    {
#line 589
    tmp___1 = __errno_location();
    }
#line 589
    if (*tmp___1 == 11) {
      {
#line 590
      sm_syslog(3, "*~*", "unable to write pid to %s: file in use by another process",
                pidpath);
      }
    } else {
      {
#line 594
      tmp = __errno_location();
#line 594
      tmp___0 = sm_errstring(*tmp);
#line 594
      sm_syslog(3, "*~*", "unable to write pid to %s: %s", pidpath, tmp___0);
      }
    }
  } else {
    {
#line 600
    PidFilePid = getpid();
#line 603
    sm_io_fprintf(Pidf, -2, "%ld\n", (long )PidFilePid);
#line 607
    sm_io_fprintf(Pidf, -2, "%s\n", CommandLineArgs);
#line 611
    sm_io_flush(Pidf, -2);
    }
  }
#line 619
  if (LogLevel > 9) {
    {
#line 620
    sm_syslog(6, "*~*", "started as: %s", CommandLineArgs);
    }
  }
#line 621
  return;
}
}
#line 633 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void close_sendmail_pid(void) 
{ 


  {
#line 636
  if ((unsigned long )Pidf == (unsigned long )((void *)0)) {
#line 637
    return;
  }
  {
#line 639
  sm_io_close(Pidf, -2);
#line 640
  Pidf = (SM_FILE_T *)((void *)0);
  }
#line 641
  return;
}
}
#line 657 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void set_delivery_mode(int mode , ENVELOPE *e ) 
{ 
  char buf___16[2] ;
  int tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 664
  e->e_sendmode = (short )((char )mode);
#line 665
  buf___16[0] = (char )mode;
#line 666
  buf___16[1] = (char )'\000';
#line 667
  tmp = macid_parse((char *)"{deliveryMode}", (char **)((void *)0));
#line 667
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp, buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                   667, SmHeapGroup);
  }
#line 668
  return;
}
}
#line 683 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void set_op_mode(int mode ) 
{ 
  char buf___16[2] ;
  void *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 690
  OpMode = (char )mode;
#line 691
  buf___16[0] = (char )mode;
#line 692
  buf___16[1] = (char )'\000';
#line 693
  macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, 130, buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                   693, SmHeapGroup);
  }
#line 694
  return;
}
}
#line 709 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void printav(SM_FILE_T *fp , char **av___0 ) 
{ 
  char **tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 714
    if (! ((unsigned long )*av___0 != (unsigned long )((void *)0))) {
#line 714
      goto while_break;
    }
#line 716
    if ((int )tTdvect[0] >= 44) {
      {
#line 717
      sm_dprintf((char *)"\n\t%08lx=", (unsigned long )*av___0);
      }
    } else {
      {
#line 719
      sm_io_putc(fp, -2, ' ');
      }
    }
    {
#line 720
    tmp = av___0;
#line 720
    av___0 ++;
#line 720
    xputs(fp, (char const   *)*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 722
  sm_io_putc(fp, -2, '\n');
  }
#line 723
  return;
}
}
#line 746
struct metamac MetaMacros[18] ;
#line 747 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
static SM_DEBUG_T DebugANSI  =    {SmDebugMagic, (SM_ATOMIC_UINT_T )-1, (char *)"ANSI", (char *)"@(#)$Debug: ANSI - enable reverse video in debug output $",
    (SM_DEBUG_T *)((void *)0)};
#line 738 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void xputs(SM_FILE_T *fp , char const   *s ) 
{ 
  register int c ;
  register struct metamac *mp ;
  bool shiftout ;
  bool tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  char const   *tmp___11 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 745
  shiftout = 0;
#line 756
  if (DebugANSI.debug_level == 4294967295U) {
#line 758
    if (DebugANSI.debug_level >= 1U) {
#line 758
      if (DebugANSI.debug_level != 4294967295U) {
#line 760
        TermEscape.te_rv_on = (char *)"\033[7m";
#line 761
        TermEscape.te_rv_off = (char *)"\033[0m";
      } else {
        {
#line 758
        tmp = sm_debug_loadactive(& DebugANSI, 1);
        }
#line 758
        if (tmp) {
#line 760
          TermEscape.te_rv_on = (char *)"\033[7m";
#line 761
          TermEscape.te_rv_off = (char *)"\033[0m";
        } else {
#line 765
          TermEscape.te_rv_on = (char *)"";
#line 766
          TermEscape.te_rv_off = (char *)"";
        }
      }
    } else {
#line 765
      TermEscape.te_rv_on = (char *)"";
#line 766
      TermEscape.te_rv_off = (char *)"";
    }
  }
#line 770
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 772
    sm_io_fprintf(fp, -2, "%s<null>%s", TermEscape.te_rv_on, TermEscape.te_rv_off);
    }
#line 774
    return;
  }
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
#line 776
    tmp___11 = s;
#line 776
    s ++;
#line 776
    c = (int )((int const   )*tmp___11 & 255);
#line 776
    if (! (c != 0)) {
#line 776
      goto while_break;
    }
#line 778
    if (shiftout) {
      {
#line 780
      sm_io_fprintf(fp, -2, "%s", TermEscape.te_rv_off);
#line 782
      shiftout = 0;
      }
    }
#line 784
    if (! ((c & -128) == 0)) {
#line 786
      if (c == 149) {
        {
#line 788
        sm_io_fprintf(fp, -2, "%s$", TermEscape.te_rv_on);
#line 791
        shiftout = 1;
        }
#line 792
        if ((int const   )*s == 0) {
#line 793
          goto while_continue;
        }
#line 794
        tmp___0 = s;
#line 794
        s ++;
#line 794
        c = (int )((int const   )*tmp___0 & 255);
#line 795
        goto printchar;
      }
#line 797
      if (c == 129) {
#line 797
        goto _L;
      } else
#line 797
      if (c == 130) {
        _L: /* CIL Label */ 
        {
#line 799
        sm_io_fprintf(fp, -2, "%s$", TermEscape.te_rv_on);
        }
#line 802
        if (c == 130) {
          {
#line 803
          sm_io_putc(fp, -2, '&');
          }
        }
#line 805
        shiftout = 1;
#line 806
        if ((int const   )*s == 0) {
#line 807
          goto while_continue;
        }
        {
#line 808
        tmp___2 = strchr("=~&?", (int )*s);
        }
#line 808
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
          {
#line 809
          tmp___1 = s;
#line 809
          s ++;
#line 809
          sm_io_putc(fp, -2, (int )*tmp___1);
          }
        }
#line 812
        if (((int const   )*s & 128) != 0) {
          {
#line 813
          tmp___3 = s;
#line 813
          s ++;
#line 813
          tmp___4 = macname((int )((unsigned int )*tmp___3 & 255U));
#line 813
          sm_io_fprintf(fp, -2, "{%s}", tmp___4);
          }
        } else {
          {
#line 818
          tmp___5 = s;
#line 818
          s ++;
#line 818
          sm_io_fprintf(fp, -2, "%c", (int const   )*tmp___5);
          }
        }
#line 822
        goto while_continue;
      }
#line 824
      mp = MetaMacros;
      {
#line 824
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 824
        if (! ((int )mp->metaname != 0)) {
#line 824
          goto while_break___0;
        }
#line 826
        if (((unsigned int )mp->metaval & 255U) == (unsigned int )c) {
          {
#line 828
          sm_io_fprintf(fp, -2, "%s$%c", TermEscape.te_rv_on, (int )mp->metaname);
#line 833
          shiftout = 1;
          }
#line 834
          goto while_break___0;
        }
#line 824
        mp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 837
      if (c == 147) {
#line 837
        goto _L___0;
      } else
#line 837
      if (c == 148) {
        _L___0: /* CIL Label */ 
#line 839
        if (((int const   )*s & 128) != 0) {
          {
#line 840
          tmp___6 = s;
#line 840
          s ++;
#line 840
          tmp___7 = macname((int )((unsigned int )*tmp___6 & 255U));
#line 840
          sm_io_fprintf(fp, -2, "{%s}", tmp___7);
          }
        } else
#line 844
        if ((int const   )*s != 0) {
          {
#line 845
          tmp___8 = s;
#line 845
          s ++;
#line 845
          sm_io_fprintf(fp, -2, "%c", (int const   )*tmp___8);
          }
        }
      }
#line 850
      if ((int )mp->metaname != 0) {
#line 851
        goto while_continue;
      }
      {
#line 854
      sm_io_fprintf(fp, -2, "%sM-", TermEscape.te_rv_on);
#line 856
      shiftout = 1;
#line 857
      c &= 127;
      }
    }
    printchar: 
    {
#line 860
    tmp___9 = __ctype_b_loc();
    }
#line 860
    if ((int const   )*(*tmp___9 + c) & 16384) {
      {
#line 862
      sm_io_putc(fp, -2, c);
      }
#line 863
      goto while_continue;
    }
    {
#line 869
    if (c == 10) {
#line 869
      goto case_10;
    }
#line 873
    if (c == 13) {
#line 873
      goto case_13;
    }
#line 877
    if (c == 9) {
#line 877
      goto case_9;
    }
#line 867
    goto switch_break;
    case_10: /* CIL Label */ 
#line 870
    c = 'n';
#line 871
    goto switch_break;
    case_13: /* CIL Label */ 
#line 874
    c = 'r';
#line 875
    goto switch_break;
    case_9: /* CIL Label */ 
#line 878
    c = 't';
#line 879
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 881
    if (! shiftout) {
      {
#line 883
      sm_io_fprintf(fp, -2, "%s", TermEscape.te_rv_on);
#line 885
      shiftout = 1;
      }
    }
    {
#line 887
    tmp___10 = __ctype_b_loc();
    }
#line 887
    if ((int const   )*(*tmp___10 + c) & 16384) {
      {
#line 889
      sm_io_putc(fp, -2, '\\');
#line 890
      sm_io_putc(fp, -2, c);
      }
    } else {
      {
#line 894
      sm_io_putc(fp, -2, '^');
#line 895
      sm_io_putc(fp, -2, c ^ 64);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  if (shiftout) {
    {
#line 899
    sm_io_fprintf(fp, -2, "%s", TermEscape.te_rv_off);
    }
  }
  {
#line 901
  sm_io_flush(fp, -2);
  }
#line 902
  return;
}
}
#line 917 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void makelower(char *p ) 
{ 
  register char c ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 923
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 924
    return;
  }
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 925
    c = *p;
#line 925
    if (! ((int )c != 0)) {
#line 925
      goto while_break;
    }
#line 926
    if (((int )c & -128) == 0) {
      {
#line 926
      tmp___0 = __ctype_b_loc();
      }
#line 926
      if ((int const   )*(*tmp___0 + (int )c) & 256) {
        {
#line 927
        tmp = tolower((int )c);
#line 927
        *p = (char )tmp;
        }
      }
    }
#line 925
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 928
  return;
}
}
#line 948 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void fixcrlf(char *line , bool stripnl ) 
{ 
  register char *p ;
  char *tmp ;

  {
  {
#line 955
  p = strchr((char const   *)line, '\n');
  }
#line 956
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 957
    return;
  }
#line 958
  if ((unsigned long )p > (unsigned long )line) {
#line 958
    if ((int )*(p + -1) == 13) {
#line 959
      p --;
    }
  }
#line 960
  if (! stripnl) {
#line 961
    tmp = p;
#line 961
    p ++;
#line 961
    *tmp = (char )'\n';
  }
#line 962
  *p = (char )'\000';
#line 963
  return;
}
}
#line 981 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
bool putline(char *l , struct mailer_con_info *mci ) 
{ 
  size_t tmp ;
  bool tmp___0 ;

  {
  {
#line 986
  tmp = strlen((char const   *)l);
#line 986
  tmp___0 = putxline(l, tmp, mci, 1);
  }
#line 986
  return (tmp___0);
}
}
#line 1011 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
bool putxline(char *l , size_t len___0 , struct mailer_con_info *mci , int pxflags ) 
{ 
  bool dead ;
  register char *p ;
  register char *end ;
  int slop ;
  register char svchar ;
  bool noeol ;
  void *tmp ;
  char *l_base ;
  register char *q ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 1018
  dead = 0;
#line 1020
  slop = 0;
#line 1023
  if ((mci->mci_flags & 128UL) != 0UL) {
#line 1023
    goto _L;
  } else
#line 1023
  if ((pxflags & 2) != 0) {
    _L: /* CIL Label */ 
#line 1028
    p = l;
    {
#line 1028
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1028
      svchar = *p;
#line 1028
      if (! ((int )svchar != 0)) {
#line 1028
        goto while_break;
      }
#line 1029
      if (((int )svchar & 128) != 0) {
#line 1030
        *p = (char )((int )svchar & -129);
      }
#line 1028
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1033
  end = l + len___0;
  {
#line 1034
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1036
    noeol = 0;
#line 1039
    tmp = memchr((void const   *)l, '\n', (size_t )(end - l));
#line 1039
    p = (char *)tmp;
    }
#line 1040
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1042
      p = end;
#line 1043
      noeol = 1;
    }
#line 1046
    if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
      {
#line 1047
      sm_io_fprintf(TrafficLogFile, -2, "%05d >>> ", CurrentPid);
      }
    }
    {
#line 1051
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1051
      if ((mci->mci_mailer)->m_linelimit > 0) {
#line 1051
        if (! ((p - l) + (long )slop > (long )(mci->mci_mailer)->m_linelimit)) {
#line 1051
          goto while_break___1;
        }
      } else {
#line 1051
        goto while_break___1;
      }
#line 1054
      l_base = l;
#line 1055
      q = l + (((mci->mci_mailer)->m_linelimit - slop) - 1);
#line 1057
      if ((int )*(l + 0) == 46) {
#line 1057
        if (slop == 0) {
#line 1057
          if ((mci->mci_mailer)->m_flags[88UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 88UL % (8UL * sizeof(int )))) {
            {
#line 1060
            tmp___0 = sm_io_putc(mci->mci_out, -2, '.');
            }
#line 1060
            if (tmp___0 == -1) {
#line 1062
              dead = 1;
            }
#line 1063
            if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
              {
#line 1064
              sm_io_putc(TrafficLogFile, -2, '.');
              }
            }
          } else {
#line 1057
            goto _L___1;
          }
        } else {
#line 1057
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1067
      if ((int )*(l + 0) == 70) {
#line 1067
        if (slop == 0) {
#line 1067
          if ((pxflags & 1) != 0) {
            {
#line 1067
            tmp___2 = strncmp((char const   *)l, "From ", (size_t )5);
            }
#line 1067
            if (tmp___2 == 0) {
#line 1067
              if ((mci->mci_mailer)->m_flags[69UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 69UL % (8UL * sizeof(int )))) {
                {
#line 1072
                tmp___1 = sm_io_putc(mci->mci_out, -2, '>');
                }
#line 1072
                if (tmp___1 == -1) {
#line 1074
                  dead = 1;
                }
#line 1075
                if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
                  {
#line 1076
                  sm_io_putc(TrafficLogFile, -2, '>');
                  }
                }
              }
            }
          }
        }
      }
#line 1080
      if (dead) {
#line 1081
        goto while_break___1;
      }
      {
#line 1083
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1083
        if (! ((unsigned long )l < (unsigned long )q)) {
#line 1083
          goto while_break___2;
        }
        {
#line 1085
        tmp___3 = l;
#line 1085
        l ++;
#line 1085
        tmp___4 = sm_io_putc(mci->mci_out, -2, (int )((unsigned char )*tmp___3));
        }
#line 1085
        if (tmp___4 == -1) {
#line 1088
          dead = 1;
#line 1089
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1092
      if (dead) {
#line 1093
        goto while_break___1;
      }
      {
#line 1095
      tmp___5 = sm_io_putc(mci->mci_out, -2, '!');
      }
#line 1095
      if (tmp___5 == -1) {
#line 1103
        dead = 1;
#line 1104
        goto while_break___1;
      } else {
        {
#line 1095
        tmp___6 = sm_io_fputs(mci->mci_out, -2, (char const   *)(mci->mci_mailer)->m_eol);
        }
#line 1095
        if (tmp___6 == -1) {
#line 1103
          dead = 1;
#line 1104
          goto while_break___1;
        } else {
          {
#line 1095
          tmp___7 = sm_io_putc(mci->mci_out, -2, ' ');
          }
#line 1095
          if (tmp___7 == -1) {
#line 1103
            dead = 1;
#line 1104
            goto while_break___1;
          }
        }
      }
#line 1106
      if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
#line 1108
        l = l_base;
        {
#line 1108
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1108
          if (! ((unsigned long )l < (unsigned long )q)) {
#line 1108
            goto while_break___3;
          }
          {
#line 1109
          sm_io_putc(TrafficLogFile, -2, (int )((unsigned char )*l));
#line 1108
          l ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1112
        sm_io_fprintf(TrafficLogFile, -2, "!\n%05d >>>  ", CurrentPid);
        }
      }
#line 1117
      slop = 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1120
    if (dead) {
#line 1121
      goto while_break___0;
    }
#line 1124
    if ((int )*(l + 0) == 46) {
#line 1124
      if (slop == 0) {
#line 1124
        if ((mci->mci_mailer)->m_flags[88UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 88UL % (8UL * sizeof(int )))) {
          {
#line 1127
          tmp___8 = sm_io_putc(mci->mci_out, -2, '.');
          }
#line 1127
          if (tmp___8 == -1) {
#line 1130
            dead = 1;
#line 1131
            goto while_break___0;
          }
#line 1133
          if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
            {
#line 1134
            sm_io_putc(TrafficLogFile, -2, '.');
            }
          }
        } else {
#line 1124
          goto _L___3;
        }
      } else {
#line 1124
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1137
    if ((int )*(l + 0) == 70) {
#line 1137
      if (slop == 0) {
#line 1137
        if ((pxflags & 1) != 0) {
          {
#line 1137
          tmp___10 = strncmp((char const   *)l, "From ", (size_t )5);
          }
#line 1137
          if (tmp___10 == 0) {
#line 1137
            if ((mci->mci_mailer)->m_flags[69UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 69UL % (8UL * sizeof(int )))) {
              {
#line 1142
              tmp___9 = sm_io_putc(mci->mci_out, -2, '>');
              }
#line 1142
              if (tmp___9 == -1) {
#line 1145
                dead = 1;
#line 1146
                goto while_break___0;
              }
#line 1148
              if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
                {
#line 1149
                sm_io_putc(TrafficLogFile, -2, '>');
                }
              }
            }
          }
        }
      }
    }
    {
#line 1152
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1152
      if (! ((unsigned long )l < (unsigned long )p)) {
#line 1152
        goto while_break___4;
      }
#line 1154
      if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
        {
#line 1155
        sm_io_putc(TrafficLogFile, -2, (int )((unsigned char )*l));
        }
      }
      {
#line 1158
      tmp___11 = sm_io_putc(mci->mci_out, -2, (int )((unsigned char )*l));
      }
#line 1158
      if (tmp___11 == -1) {
#line 1161
        dead = 1;
#line 1162
        goto while_break___4;
      }
#line 1152
      l ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1165
    if (dead) {
#line 1166
      goto while_break___0;
    }
#line 1168
    if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
      {
#line 1169
      sm_io_putc(TrafficLogFile, -2, '\n');
      }
    }
#line 1171
    if (! ((pxflags & 8) != 0)) {
#line 1171
      goto _L___4;
    } else
#line 1171
    if (! noeol) {
      _L___4: /* CIL Label */ 
      {
#line 1171
      tmp___12 = sm_io_fputs(mci->mci_out, -2, (char const   *)(mci->mci_mailer)->m_eol);
      }
#line 1171
      if (tmp___12 == -1) {
#line 1175
        dead = 1;
#line 1176
        goto while_break___0;
      }
    }
#line 1178
    if ((unsigned long )l < (unsigned long )end) {
#line 1178
      if ((int )*l == 10) {
#line 1180
        l ++;
#line 1180
        if ((int )*l != 32) {
#line 1180
          if ((int )*l != 9) {
#line 1180
            if ((int )*l != 0) {
#line 1180
              if ((pxflags & 4) != 0) {
                {
#line 1183
                tmp___13 = sm_io_putc(mci->mci_out, -2, ' ');
                }
#line 1183
                if (tmp___13 == -1) {
#line 1186
                  dead = 1;
#line 1187
                  goto while_break___0;
                }
#line 1190
                if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
                  {
#line 1191
                  sm_io_putc(TrafficLogFile, -2, ' ');
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1034
    if (! ((unsigned long )l < (unsigned long )end)) {
#line 1034
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1197
  return (! dead);
}
}
#line 1213 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
int xunlink(char *f ) 
{ 
  register int i ;
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1220
  if (LogLevel > 98) {
    {
#line 1221
    sm_syslog(7, (char const   *)CurEnv->e_id, "unlink %s", f);
    }
  }
  {
#line 1223
  i = unlink((char const   *)f);
#line 1224
  tmp = __errno_location();
#line 1224
  save_errno = *tmp;
  }
#line 1225
  if (i < 0) {
#line 1225
    if (LogLevel > 97) {
      {
#line 1226
      tmp___0 = __errno_location();
#line 1226
      sm_syslog(7, (char const   *)CurEnv->e_id, "%s: unlink-fail %d", f, *tmp___0);
      }
    }
  }
#line 1228
  if (i >= 0) {
    {
#line 1229
    sync_dir(f, 0);
    }
  }
  {
#line 1230
  tmp___1 = __errno_location();
#line 1230
  *tmp___1 = save_errno;
  }
#line 1231
  return (i);
}
}
#line 1250 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
char *sfgets(char *buf___16 , int siz , SM_FILE_T *fp , time_t timeout , char *during ) 
{ 
  register char *p ;
  int save_errno ;
  int io_timeout ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 1262
  if (siz > 0) {
#line 1262
    tmp = 1;
  } else {
    {
#line 1262
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                1262, "SM_REQUIRE(siz > 0) failed");
#line 1262
    tmp = 0;
    }
  }
#line 1263
  if ((unsigned long )buf___16 != (unsigned long )((void *)0)) {
#line 1263
    tmp___0 = 1;
  } else {
    {
#line 1263
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                1263, "SM_REQUIRE(buf != NULL) failed");
#line 1263
    tmp___0 = 0;
    }
  }
#line 1265
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1267
    *(buf___16 + 0) = (char )'\000';
#line 1268
    tmp___1 = __errno_location();
#line 1268
    *tmp___1 = 9;
    }
#line 1269
    return ((char *)((void *)0));
  }
  {
#line 1273
  p = (char *)((void *)0);
#line 1274
  tmp___2 = __errno_location();
#line 1274
  *tmp___2 = 0;
  }
#line 1277
  if (timeout <= 0L) {
#line 1277
    io_timeout = -2;
  } else {
#line 1277
    io_timeout = (int )(timeout * 1000L);
  }
  {
#line 1278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1278
    if (! ((fp->f_flags & 128L) != 0L)) {
#line 1278
      if (! (! ((fp->f_flags & 256L) != 0L))) {
#line 1278
        goto while_break;
      }
    } else {
#line 1278
      goto while_break;
    }
    {
#line 1280
    tmp___3 = __errno_location();
#line 1280
    *tmp___3 = 0;
#line 1281
    p = sm_io_fgets(fp, io_timeout, buf___16, siz);
    }
#line 1282
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 1282
      tmp___6 = __errno_location();
      }
#line 1282
      if (*tmp___6 == 11) {
#line 1285
        if (LogLevel > 1) {
#line 1286
          if ((unsigned long )CurHostName == (unsigned long )((void *)0)) {
#line 1286
            tmp___4 = "local";
          } else {
#line 1286
            tmp___4 = (char const   *)CurHostName;
          }
          {
#line 1286
          sm_syslog(5, (char const   *)CurEnv->e_id, "timeout waiting for input from %.100s during %s",
                    tmp___4, during);
          }
        }
        {
#line 1290
        *(buf___16 + 0) = (char )'\000';
#line 1292
        checkfd012(during);
        }
#line 1294
        if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
          {
#line 1295
          sm_io_fprintf(TrafficLogFile, -2, "%05d <<< [TIMEOUT]\n", CurrentPid);
          }
        }
        {
#line 1299
        tmp___5 = __errno_location();
#line 1299
        *tmp___5 = 110;
        }
#line 1300
        return ((char *)((void *)0));
      }
    }
#line 1302
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1303
      goto while_break;
    } else {
      {
#line 1302
      tmp___7 = __errno_location();
      }
#line 1302
      if (*tmp___7 != 4) {
#line 1303
        goto while_break;
      }
    }
#line 1304
    fp->f_flags &= -385L;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1306
  tmp___8 = __errno_location();
#line 1306
  save_errno = *tmp___8;
#line 1309
  LineNumber ++;
  }
#line 1310
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1312
    *(buf___16 + 0) = (char )'\000';
#line 1313
    if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
      {
#line 1314
      sm_io_fprintf(TrafficLogFile, -2, "%05d <<< [EOF]\n", CurrentPid);
      }
    }
    {
#line 1317
    tmp___9 = __errno_location();
#line 1317
    *tmp___9 = save_errno;
    }
#line 1318
    return ((char *)((void *)0));
  }
#line 1320
  if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
    {
#line 1321
    sm_io_fprintf(TrafficLogFile, -2, "%05d <<< %s", CurrentPid, buf___16);
    }
  }
#line 1323
  if (SevenBitInput) {
#line 1325
    p = buf___16;
    {
#line 1325
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1325
      if (! ((int )*p != 0)) {
#line 1325
        goto while_break___0;
      }
#line 1326
      *p = (char )((int )*p & -129);
#line 1325
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 1328
  if (! HasEightBits) {
#line 1330
    p = buf___16;
    {
#line 1330
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1330
      if (! ((int )*p != 0)) {
#line 1330
        goto while_break___1;
      }
#line 1332
      if (((int )*p & 128) != 0) {
#line 1334
        HasEightBits = 1;
#line 1335
        goto while_break___1;
      }
#line 1330
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1339
  return (buf___16);
}
}
#line 1360 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
char *fgetfolded(char *buf___16 , int n , SM_FILE_T *f ) 
{ 
  register char *p ;
  char *bp___3 ;
  register int i ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *nbp ;
  int nn ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1366
  p = buf___16;
#line 1367
  bp___3 = buf___16;
#line 1370
  if (n > 0) {
#line 1370
    tmp = 1;
  } else {
    {
#line 1370
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                1370, "SM_REQUIRE(n > 0) failed");
#line 1370
    tmp = 0;
    }
  }
#line 1371
  if ((unsigned long )buf___16 != (unsigned long )((void *)0)) {
#line 1371
    tmp___0 = 1;
  } else {
    {
#line 1371
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                1371, "SM_REQUIRE(buf != NULL) failed");
#line 1371
    tmp___0 = 0;
    }
  }
#line 1372
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 1374
    *(buf___16 + 0) = (char )'\000';
#line 1375
    tmp___1 = __errno_location();
#line 1375
    *tmp___1 = 9;
    }
#line 1376
    return ((char *)((void *)0));
  }
#line 1379
  n --;
  {
#line 1380
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1380
    i = sm_io_getc(f, -2);
    }
#line 1380
    if (! (i != -1)) {
#line 1380
      goto while_break;
    }
#line 1382
    if (i == 13) {
      {
#line 1384
      i = sm_io_getc(f, -2);
      }
#line 1385
      if (i != 10) {
#line 1387
        if (i != -1) {
          {
#line 1388
          sm_io_ungetc(f, -2, i);
          }
        }
#line 1390
        i = '\r';
      }
    }
#line 1393
    n --;
#line 1393
    if (n <= 0) {
#line 1399
      nn = (int )(p - bp___3);
#line 1400
      if (nn < 1024) {
#line 1401
        nn *= 2;
      } else {
#line 1403
        nn += 1024;
      }
      {
#line 1404
      tmp___2 = sm_malloc_tagged_x((size_t )nn, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                                   1404, SmHeapGroup);
#line 1404
      nbp = (char *)tmp___2;
#line 1405
      memmove((void *)nbp, (void const   *)bp___3, (size_t )(p - bp___3));
#line 1406
      p = nbp + (p - bp___3);
      }
#line 1407
      if ((unsigned long )bp___3 != (unsigned long )buf___16) {
        {
#line 1408
        sm_free_tagged((void *)bp___3, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                       1408);
        }
      }
#line 1409
      bp___3 = nbp;
#line 1410
      n = (int )((long )nn - (p - bp___3));
    }
#line 1412
    tmp___3 = p;
#line 1412
    p ++;
#line 1412
    *tmp___3 = (char )i;
#line 1413
    if (i == 10) {
      {
#line 1415
      LineNumber ++;
#line 1416
      i = sm_io_getc(f, -2);
      }
#line 1417
      if (i != -1) {
        {
#line 1418
        sm_io_ungetc(f, -2, i);
        }
      }
#line 1419
      if (i != 32) {
#line 1419
        if (i != 9) {
#line 1420
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1423
  if ((unsigned long )p == (unsigned long )bp___3) {
#line 1424
    return ((char *)((void *)0));
  }
#line 1425
  if ((int )*(p + -1) == 10) {
#line 1426
    p --;
  }
#line 1427
  *p = (char )'\000';
#line 1428
  return (bp___3);
}
}
#line 1440 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
time_t curtime(void) 
{ 
  time_t t ;

  {
  {
#line 1445
  time(& t);
  }
#line 1446
  return (t);
}
}
#line 1461 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
bool atobool(char *s ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
#line 1465
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1466
    return (1);
  } else
#line 1465
  if ((int )*s == 0) {
#line 1466
    return (1);
  } else {
    {
#line 1465
    tmp = strchr("tTyY", (int )*s);
    }
#line 1465
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1466
      return (1);
    }
  }
#line 1467
  return (0);
}
}
#line 1480 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
int atooct(char *s ) 
{ 
  register int i ;
  char *tmp ;

  {
#line 1484
  i = 0;
  {
#line 1486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1486
    if ((int )*s >= 48) {
#line 1486
      if (! ((int )*s <= 55)) {
#line 1486
        goto while_break;
      }
    } else {
#line 1486
      goto while_break;
    }
#line 1487
    tmp = s;
#line 1487
    s ++;
#line 1487
    i = (i << 3) | ((int )*tmp - 48);
  }
  while_break: /* CIL Label */ ;
  }
#line 1488
  return (i);
}
}
#line 1501 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
bool bitintersect(unsigned int *a , unsigned int *b___0 ) 
{ 
  int i ;

  {
#line 1508
  i = (int )(32UL / sizeof(int ));
  {
#line 1508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1508
    i --;
#line 1508
    if (! (i >= 0)) {
#line 1508
      goto while_break;
    }
#line 1510
    if ((*(a + i) & *(b___0 + i)) != 0U) {
#line 1511
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1513
  return (0);
}
}
#line 1526 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
bool bitzerop(unsigned int *map___0 ) 
{ 
  int i ;

  {
#line 1532
  i = (int )(32UL / sizeof(int ));
  {
#line 1532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1532
    i --;
#line 1532
    if (! (i >= 0)) {
#line 1532
      goto while_break;
    }
#line 1534
    if (*(map___0 + i) != 0U) {
#line 1535
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1537
  return (1);
}
}
#line 1552 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
bool strcontainedin(bool icase , char *a , char *b___0 ) 
{ 
  int la ;
  int lb ;
  int c ;
  size_t tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1562
  tmp = strlen((char const   *)a);
#line 1562
  la = (int )tmp;
#line 1563
  tmp___0 = strlen((char const   *)b___0);
#line 1563
  lb = (int )tmp___0;
#line 1564
  c = (int )*a;
  }
#line 1565
  if (icase) {
#line 1565
    if ((c & -128) == 0) {
      {
#line 1565
      tmp___1 = __ctype_b_loc();
      }
#line 1565
      if ((int const   )*(*tmp___1 + c) & 256) {
        {
#line 1566
        c = tolower(c);
        }
      }
    }
  }
  {
#line 1567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1567
    tmp___6 = lb;
#line 1567
    lb --;
#line 1567
    if (! (tmp___6 >= la)) {
#line 1567
      goto while_break;
    }
#line 1569
    if (icase) {
#line 1571
      if ((int )*b___0 != c) {
#line 1571
        if (((int )*b___0 & -128) == 0) {
          {
#line 1571
          tmp___2 = __ctype_b_loc();
          }
#line 1571
          if ((int const   )*(*tmp___2 + (int )*b___0) & 256) {
            {
#line 1571
            tmp___3 = tolower((int )*b___0);
            }
#line 1571
            if (tmp___3 != c) {
#line 1573
              goto __Cont;
            }
          }
        }
      }
      {
#line 1574
      tmp___4 = sm_strncasecmp((char const   *)a, (char const   *)b___0, (size_t )la);
      }
#line 1574
      if (tmp___4 == 0) {
#line 1575
        return (1);
      }
    } else {
#line 1579
      if ((int )*b___0 != c) {
#line 1580
        goto __Cont;
      }
      {
#line 1581
      tmp___5 = strncmp((char const   *)a, (char const   *)b___0, (size_t )la);
      }
#line 1581
      if (tmp___5 == 0) {
#line 1582
        return (1);
      }
    }
    __Cont: /* CIL Label */ 
#line 1567
    b___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1585
  return (0);
}
}
#line 1600 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void checkfd012(char *where ) 
{ 
  register int i ;

  {
#line 1607
  i = 0;
  {
#line 1607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1607
    if (! (i < 3)) {
#line 1607
      goto while_break;
    }
    {
#line 1608
    fill_fd(i, where);
#line 1607
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1610
  return;
}
}
#line 1622 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void checkfdopen(int fd , char *where ) 
{ 
  struct stat st ;
  int tmp ;
  int *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 1630
  tmp = fstat(fd, & st);
  }
#line 1630
  if (tmp < 0) {
    {
#line 1630
    tmp___0 = __errno_location();
    }
#line 1630
    if (*tmp___0 == 9) {
      {
#line 1632
      syserr("checkfdopen(%d): %s not open as expected!", fd, where);
#line 1633
      printopenfds(1);
      }
    }
  }
#line 1636
  return;
}
}
#line 1658 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
static BITMAP256 baseline  ;
#line 1659
int DtableSize ;
#line 1650 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void checkfds(char *where ) 
{ 
  int maxfd ;
  register int fd ;
  bool printhdr ;
  int save_errno ;
  int *tmp ;
  struct stat stbuf ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp11 ;

  {
  {
#line 1656
  printhdr = 1;
#line 1657
  tmp = __errno_location();
#line 1657
  save_errno = *tmp;
  }
#line 1661
  if (DtableSize > 256) {
#line 1662
    maxfd = 256;
  } else {
#line 1664
    maxfd = DtableSize;
  }
#line 1665
  if ((unsigned long )where == (unsigned long )((void *)0)) {
    {
#line 1666
    memset((void *)((char *)(baseline)), '\000', (size_t )32);
    }
  }
#line 1668
  fd = 0;
  {
#line 1668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1668
    if (! (fd < maxfd)) {
#line 1668
      goto while_break;
    }
    {
#line 1672
    tmp___0 = fstat(fd, & stbuf);
    }
#line 1672
    if (tmp___0 < 0) {
      {
#line 1672
      tmp___1 = __errno_location();
      }
#line 1672
      if (*tmp___1 != 95) {
#line 1674
        if (! (baseline[(unsigned long )((unsigned char )fd) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )fd) % (8UL * sizeof(int ))))) {
#line 1675
          goto __Cont;
        }
#line 1676
        baseline[(unsigned long )((unsigned char )fd) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] &= ~ (1U << (unsigned long )((unsigned char )fd) % (8UL * sizeof(int )));
      } else {
#line 1672
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1678
    if (! (baseline[(unsigned long )((unsigned char )fd) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )fd) % (8UL * sizeof(int ))))) {
#line 1679
      baseline[(unsigned long )((unsigned char )fd) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )fd) % (8UL * sizeof(int ));
    } else {
#line 1681
      goto __Cont;
    }
#line 1684
    if ((unsigned long )where == (unsigned long )((void *)0)) {
#line 1685
      goto __Cont;
    }
#line 1686
    if (printhdr) {
      {
#line 1688
      sm_syslog(7, (char const   *)CurEnv->e_id, "%s: changed fds:", where);
#line 1691
      printhdr = 0;
      }
    }
    {
#line 1693
    dumpfd(fd, 1, 1);
    }
    __Cont: /* CIL Label */ 
#line 1668
    fd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1695
  tmp___2 = __errno_location();
#line 1695
  *tmp___2 = save_errno;
  }
#line 1696
  return;
}
}
#line 1712 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void printopenfds(bool logit ) 
{ 
  register int fd ;

  {
#line 1719
  fd = 0;
  {
#line 1719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1719
    if (! (fd < DtableSize)) {
#line 1719
      goto while_break;
    }
    {
#line 1720
    dumpfd(fd, 0, logit);
#line 1719
    fd ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1721
  return;
}
}
#line 1735 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void dumpfd(int fd , bool printclosed , bool logit ) 
{ 
  register char *p ;
  char *hp ;
  union bigsockaddr sa ;
  int slen ;
  int i ;
  struct stat st ;
  char buf___16[200] ;
  size_t tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  uint16_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int *tmp___13 ;
  char const   *tmp___14 ;
  uint16_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  size_t tmp___24 ;
  char *tmp___25 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
  {
#line 1755
  p = buf___16;
#line 1756
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "%3d: ",
              fd);
#line 1757
  tmp = strlen((char const   *)p);
#line 1757
  p += tmp;
#line 1759
  tmp___3 = fstat(fd, & st);
  }
#line 1759
  if (tmp___3 < 0) {
    {
#line 1767
    tmp___2 = __errno_location();
    }
#line 1767
    if (*tmp___2 != 9) {
      {
#line 1769
      tmp___0 = __errno_location();
#line 1769
      tmp___1 = sm_errstring(*tmp___0);
#line 1769
      sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)),
                  "CANNOT STAT (%s)", tmp___1);
      }
#line 1772
      goto printit;
    } else
#line 1774
    if (printclosed) {
      {
#line 1776
      sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)),
                  "CLOSED");
      }
#line 1777
      goto printit;
    }
#line 1779
    return;
  }
  {
#line 1782
  i = fcntl(fd, 3, 0);
  }
#line 1783
  if (i != -1) {
    {
#line 1785
    sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "fl=0x%x, ",
                i);
#line 1786
    tmp___4 = strlen((char const   *)p);
#line 1786
    p += tmp___4;
    }
  }
  {
#line 1789
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "mode=%o: ",
              (int )st.st_mode);
#line 1791
  tmp___5 = strlen((char const   *)p);
#line 1791
  p += tmp___5;
  }
  {
#line 1795
  if ((st.st_mode & 61440U) == 49152U) {
#line 1795
    goto case_49152;
  }
#line 1857
  if ((st.st_mode & 61440U) == 8192U) {
#line 1857
    goto case_8192;
  }
#line 1863
  if ((st.st_mode & 61440U) == 24576U) {
#line 1863
    goto case_24576;
  }
#line 1870
  if ((st.st_mode & 61440U) == 4096U) {
#line 1870
    goto case_4096;
  }
#line 1877
  if ((st.st_mode & 61440U) == 16384U) {
#line 1877
    goto case_16384;
  }
#line 1884
  if ((st.st_mode & 61440U) == 40960U) {
#line 1884
    goto case_40960;
  }
#line 1890
  goto defprint;
  case_49152: /* CIL Label */ 
  {
#line 1796
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "SOCK ");
#line 1797
  tmp___6 = strlen((char const   *)p);
#line 1797
  p += tmp___6;
#line 1798
  memset((void *)(& sa), '\000', (size_t )sizeof(sa));
#line 1799
  slen = (int )sizeof(sa);
#line 1800
  tmp___10 = getsockname(fd, (struct sockaddr */* __restrict  */)(& sa.sa), (socklen_t */* __restrict  */)(& slen));
  }
#line 1800
  if (tmp___10 < 0) {
    {
#line 1801
    tmp___7 = __errno_location();
#line 1801
    tmp___8 = sm_errstring(*tmp___7);
#line 1801
    sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "(%s)",
                tmp___8);
    }
  } else {
    {
#line 1805
    hp = hostnamebyanyaddr(& sa);
    }
#line 1806
    if (! ((unsigned long )hp == (unsigned long )((void *)0))) {
#line 1812
      if ((int )sa.sa.sa_family == 2) {
        {
#line 1813
        tmp___9 = ntohs(sa.sin.sin_port);
#line 1813
        sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)),
                    "%s/%d", hp, (int )tmp___9);
        }
      } else {
        {
#line 1822
        sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)),
                    "%s", hp);
        }
      }
    }
  }
  {
#line 1825
  tmp___11 = strlen((char const   *)p);
#line 1825
  p += tmp___11;
#line 1826
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "->");
#line 1827
  tmp___12 = strlen((char const   *)p);
#line 1827
  p += tmp___12;
#line 1828
  slen = (int )sizeof(sa);
#line 1829
  tmp___16 = getpeername(fd, (struct sockaddr */* __restrict  */)(& sa.sa), (socklen_t */* __restrict  */)(& slen));
  }
#line 1829
  if (tmp___16 < 0) {
    {
#line 1830
    tmp___13 = __errno_location();
#line 1830
    tmp___14 = sm_errstring(*tmp___13);
#line 1830
    sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "(%s)",
                tmp___14);
    }
  } else {
    {
#line 1834
    hp = hostnamebyanyaddr(& sa);
    }
#line 1835
    if (! ((unsigned long )hp == (unsigned long )((void *)0))) {
#line 1841
      if ((int )sa.sa.sa_family == 2) {
        {
#line 1842
        tmp___15 = ntohs(sa.sin.sin_port);
#line 1842
        sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)),
                    "%s/%d", hp, (int )tmp___15);
        }
      } else {
        {
#line 1851
        sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)),
                    "%s", hp);
        }
      }
    }
  }
#line 1854
  goto switch_break;
  case_8192: /* CIL Label */ 
  {
#line 1858
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "CHR: ");
#line 1859
  tmp___17 = strlen((char const   *)p);
#line 1859
  p += tmp___17;
  }
#line 1860
  goto defprint;
  case_24576: /* CIL Label */ 
  {
#line 1864
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "BLK: ");
#line 1865
  tmp___18 = strlen((char const   *)p);
#line 1865
  p += tmp___18;
  }
#line 1866
  goto defprint;
  case_4096: /* CIL Label */ 
  {
#line 1871
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "FIFO: ");
#line 1872
  tmp___19 = strlen((char const   *)p);
#line 1872
  p += tmp___19;
  }
#line 1873
  goto defprint;
  case_16384: /* CIL Label */ 
  {
#line 1878
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "DIR: ");
#line 1879
  tmp___20 = strlen((char const   *)p);
#line 1879
  p += tmp___20;
  }
#line 1880
  goto defprint;
  case_40960: /* CIL Label */ 
  {
#line 1885
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "LNK: ");
#line 1886
  tmp___21 = strlen((char const   *)p);
#line 1886
  p += tmp___21;
  }
#line 1887
  goto defprint;
  defprint: 
  switch_default: /* CIL Label */ 
  {
#line 1892
  tmp___22 = gnu_dev_minor(st.st_dev);
#line 1892
  tmp___23 = gnu_dev_major(st.st_dev);
#line 1892
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "dev=%d/%d, ino=%llu, nlink=%d, u/gid=%d/%d, ",
              tmp___23, tmp___22, (ULONGLONG_T )st.st_ino, (int )st.st_nlink, (int )st.st_uid,
              (int )st.st_gid);
#line 1898
  tmp___24 = strlen((char const   *)p);
#line 1898
  p += tmp___24;
#line 1899
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "size=%llu",
              (ULONGLONG_T )st.st_size);
  }
#line 1901
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  printit: 
#line 1905
  if (logit) {
#line 1906
    if (CurEnv) {
#line 1906
      tmp___25 = CurEnv->e_id;
    } else {
#line 1906
      tmp___25 = (char *)((void *)0);
    }
    {
#line 1906
    sm_syslog(7, (char const   *)tmp___25, "%.800s", buf___16);
    }
  } else {
    {
#line 1909
    sm_dprintf((char *)"%s\n", buf___16);
    }
  }
#line 1910
  return;
}
}
#line 1921 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
char *shorten_hostname(char *host ) 
{ 
  register char *p ;
  char *mydom ;
  int i ;
  bool canon ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp12 ;

  {
  {
#line 1928
  canon = 0;
#line 1931
  tmp = strlen((char const   *)host);
#line 1931
  i = (int )tmp;
  }
#line 1932
  if (i == 0) {
#line 1932
    tmp___0 = 0;
  } else {
#line 1932
    tmp___0 = i - 1;
  }
#line 1932
  p = host + tmp___0;
#line 1933
  if ((int )*p == 46) {
#line 1935
    *p = (char )'\000';
#line 1936
    canon = 1;
  }
  {
#line 1940
  p = strchr((char const   *)host, '.');
  }
#line 1941
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1942
    return ((char *)((void *)0));
  }
  {
#line 1945
  mydom = macvalue('m', CurEnv);
  }
#line 1946
  if ((unsigned long )mydom == (unsigned long )((void *)0)) {
#line 1947
    mydom = (char *)"";
  }
  {
#line 1948
  p ++;
#line 1948
  tmp___1 = strlen((char const   *)p);
#line 1948
  i = (int )tmp___1;
  }
#line 1949
  if (canon) {
    {
#line 1949
    tmp___2 = sm_strcasecmp((char const   *)p, (char const   *)mydom);
#line 1949
    tmp___4 = tmp___2;
    }
  } else {
    {
#line 1949
    tmp___3 = sm_strncasecmp((char const   *)p, (char const   *)mydom, (size_t )i);
#line 1949
    tmp___4 = tmp___3;
    }
  }
#line 1949
  if (tmp___4 == 0) {
#line 1949
    if ((int )*(mydom + i) == 46) {
#line 1953
      p --;
#line 1953
      *p = (char )'\000';
#line 1954
      return (p);
    } else
#line 1949
    if ((int )*(mydom + i) == 0) {
#line 1953
      p --;
#line 1953
      *p = (char )'\000';
#line 1954
      return (p);
    }
  }
#line 1956
  return ((char *)((void *)0));
}
}
#line 1970 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
pid_t prog_open(char **argv , int *pfd , ENVELOPE *e ) 
{ 
  pid_t pid ;
  int save_errno ;
  int sff ;
  int ret ;
  int fdv[2] ;
  char *p ;
  char *q ;
  char buf___16[4096] ;
  int tmp ;
  int tmp___0 ;
  int xfd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __uid_t tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  int *tmp___13 ;
  bool tmp___14 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 1985
  tmp = pipe((int *)(fdv));
  }
#line 1985
  if (tmp < 0) {
    {
#line 1987
    syserr("%s: cannot create pipe for stdout", *(argv + 0));
    }
#line 1988
    return (-1);
  }
  {
#line 1990
  pid = fork();
  }
#line 1991
  if (pid < 0) {
    {
#line 1993
    syserr("%s: cannot fork", *(argv + 0));
#line 1994
    close(fdv[0]);
#line 1995
    close(fdv[1]);
    }
#line 1996
    return (-1);
  }
#line 1998
  if (pid > 0) {
    {
#line 2001
    close(fdv[1]);
#line 2002
    *pfd = fdv[0];
    }
#line 2003
    return (pid);
  }
  {
#line 2007
  RestartRequest = (char */* volatile  */)((void *)0);
#line 2008
  RestartWorkGroup = (bool volatile   )0;
#line 2009
  ShutdownRequest = (char */* volatile  */)((void *)0);
#line 2010
  PendingSignal = (int volatile   )0;
#line 2011
  CurrentPid = getpid();
#line 2018
  sm_exc_newthread(& fatal_error);
#line 2021
  close(0);
#line 2024
  close(fdv[0]);
#line 2025
  tmp___0 = dup2(fdv[1], 1);
  }
#line 2025
  if (tmp___0 < 0) {
    {
#line 2027
    syserr("%s: cannot dup2 for stdout", *(argv + 0));
#line 2028
    _exit(71);
    }
  }
  {
#line 2030
  close(fdv[1]);
  }
#line 2033
  if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
    {
#line 2037
    xfd = sm_io_getinfo(e->e_xfp, 3, (void *)0);
    }
#line 2038
    if (xfd >= 0) {
      {
#line 2038
      tmp___1 = dup2(xfd, 2);
      }
#line 2038
      if (tmp___1 < 0) {
        {
#line 2040
        syserr("%s: cannot dup2 for stderr", *(argv + 0));
#line 2041
        _exit(71);
        }
      }
    }
  }
#line 2046
  if ((unsigned long )e->e_lockfp != (unsigned long )((void *)0)) {
    {
#line 2047
    tmp___2 = sm_io_getinfo(e->e_lockfp, 3, (void *)0);
#line 2047
    close(tmp___2);
    }
  }
#line 2050
  if ((unsigned long )ProgMailer != (unsigned long )((void *)0)) {
#line 2050
    if ((unsigned long )ProgMailer->m_rootdir != (unsigned long )((void *)0)) {
      {
#line 2052
      expand(ProgMailer->m_rootdir, buf___16, (size_t )sizeof(buf___16), e);
#line 2053
      tmp___3 = chroot((char const   *)(buf___16));
      }
#line 2053
      if (tmp___3 < 0) {
        {
#line 2055
        syserr("prog_open: cannot chroot(%s)", buf___16);
#line 2056
        exit(75);
        }
      }
      {
#line 2058
      tmp___4 = chdir("/");
      }
#line 2058
      if (tmp___4 < 0) {
        {
#line 2060
        syserr("prog_open: cannot chdir(/)");
#line 2061
        exit(75);
        }
      }
    }
  }
  {
#line 2066
  endpwent();
#line 2067
  sm_mbdb_terminate();
#line 2071
  tmp___5 = setgid(DefGid);
  }
#line 2071
  if (tmp___5 < 0) {
    {
#line 2071
    tmp___6 = geteuid();
    }
#line 2071
    if (tmp___6 == 0U) {
      {
#line 2073
      syserr("prog_open: setgid(%ld) failed", (long )DefGid);
#line 2074
      exit(75);
      }
    }
  }
  {
#line 2076
  tmp___7 = setuid(DefUid);
  }
#line 2076
  if (tmp___7 < 0) {
    {
#line 2076
    tmp___8 = geteuid();
    }
#line 2076
    if (tmp___8 == 0U) {
      {
#line 2078
      syserr("prog_open: setuid(%ld) failed", (long )DefUid);
#line 2079
      exit(75);
      }
    }
  }
#line 2083
  if ((unsigned long )ProgMailer != (unsigned long )((void *)0)) {
#line 2084
    p = ProgMailer->m_execdir;
  } else {
#line 2086
    p = (char *)((void *)0);
  }
  {
#line 2087
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2087
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 2087
      goto while_break;
    }
    {
#line 2089
    q = strchr((char const   *)p, ':');
    }
#line 2090
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 2091
      *q = (char )'\000';
    }
    {
#line 2092
    expand(p, buf___16, (size_t )sizeof(buf___16), e);
    }
#line 2093
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 2094
      tmp___9 = q;
#line 2094
      q ++;
#line 2094
      *tmp___9 = (char )':';
    }
#line 2095
    if ((int )buf___16[0] != 0) {
      {
#line 2095
      tmp___10 = chdir((char const   *)(buf___16));
      }
#line 2095
      if (tmp___10 >= 0) {
#line 2096
        goto while_break;
      }
    }
#line 2087
    p = q;
  }
  while_break: /* CIL Label */ ;
  }
#line 2098
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 2101
    tmp___11 = chdir("/tmp");
    }
#line 2101
    if (tmp___11 < 0) {
      {
#line 2102
      chdir("/");
      }
    }
  }
#line 2106
  sff = 262148;
#line 2107
  if (! (DontBlameSendmail[29UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 29UL % (8UL * sizeof(int ))))) {
#line 2108
    sff = (int )((long )sff | 6144L);
  }
#line 2109
  if (DontBlameSendmail[28UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 28UL % (8UL * sizeof(int )))) {
#line 2110
    sff = (int )((long )sff | 16L);
  } else {
#line 2112
    sff = (int )((long )sff | 256L);
  }
  {
#line 2113
  ret = safefile(*(argv + 0), DefUid, DefGid, DefUser, (long )sff, 0, (struct stat *)((void *)0));
  }
#line 2114
  if (ret != 0) {
    {
#line 2115
    tmp___12 = sm_errstring(ret);
#line 2115
    sm_syslog(6, (char const   *)e->e_id, "Warning: prog_open: program %s unsafe: %s",
              *(argv + 0), tmp___12);
    }
  }
  {
#line 2120
  sm_close_on_exec(3, DtableSize);
#line 2123
  execve((char const   *)*(argv + 0), (char * const  *)argv, (char * const  *)(UserEnviron));
#line 2126
  tmp___13 = __errno_location();
#line 2126
  save_errno = *tmp___13;
#line 2127
  syserr("%s: cannot exec", *(argv + 0));
#line 2128
  tmp___14 = transienterror(save_errno);
  }
#line 2128
  if (tmp___14) {
    {
#line 2129
    _exit(71);
    }
  }
  {
#line 2130
  _exit(78);
  }
#line 2131
  return (-1);
}
}
#line 2149 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
char *get_column(char *line , int col , int delim , char *buf___16 , int buflen___1 ) 
{ 
  char *p ;
  char *begin ;
  char *end ;
  int i ;
  char delimbuf[4] ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2162
  if ((int )((char )delim) == 0) {
    {
#line 2163
    sm_strlcpy(delimbuf, "\n\t ", (ssize_t )sizeof(delimbuf));
    }
  } else {
#line 2166
    delimbuf[0] = (char )delim;
#line 2167
    delimbuf[1] = (char )'\000';
  }
#line 2170
  p = line;
#line 2171
  if ((int )*p == 0) {
#line 2172
    return ((char *)((void *)0));
  }
#line 2173
  if ((int )*p == (int )((char )delim)) {
#line 2173
    if (col == 0) {
#line 2174
      return ((char *)((void *)0));
    }
  }
#line 2176
  begin = line;
#line 2178
  if (col == 0) {
#line 2178
    if ((int )((char )delim) == 0) {
      {
#line 2180
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2180
        if ((int )*begin != 0) {
#line 2180
          if (((int )*begin & -128) == 0) {
            {
#line 2180
            tmp = __ctype_b_loc();
            }
#line 2180
            if (! ((int const   )*(*tmp + (int )*begin) & 8192)) {
#line 2180
              goto while_break;
            }
          } else {
#line 2180
            goto while_break;
          }
        } else {
#line 2180
          goto while_break;
        }
#line 2181
        begin ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2184
  i = 0;
  {
#line 2184
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2184
    if (! (i < col)) {
#line 2184
      goto while_break___0;
    }
    {
#line 2186
    begin = strpbrk((char const   *)begin, (char const   *)(delimbuf));
    }
#line 2186
    if ((unsigned long )begin == (unsigned long )((void *)0)) {
#line 2187
      return ((char *)((void *)0));
    }
#line 2188
    begin ++;
#line 2189
    if ((int )((char )delim) == 0) {
      {
#line 2191
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2191
        if ((int )*begin != 0) {
#line 2191
          if (((int )*begin & -128) == 0) {
            {
#line 2191
            tmp___0 = __ctype_b_loc();
            }
#line 2191
            if (! ((int const   )*(*tmp___0 + (int )*begin) & 8192)) {
#line 2191
              goto while_break___1;
            }
          } else {
#line 2191
            goto while_break___1;
          }
        } else {
#line 2191
          goto while_break___1;
        }
#line 2192
        begin ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2184
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2196
  end = strpbrk((char const   *)begin, (char const   *)(delimbuf));
  }
#line 2197
  if ((unsigned long )end == (unsigned long )((void *)0)) {
    {
#line 2198
    tmp___1 = strlen((char const   *)begin);
#line 2198
    i = (int )tmp___1;
    }
  } else {
#line 2200
    i = (int )(end - begin);
  }
#line 2201
  if (i >= buflen___1) {
#line 2202
    i = buflen___1 - 1;
  }
  {
#line 2203
  sm_strlcpy(buf___16, (char const   *)begin, i + 1);
  }
#line 2204
  return (buf___16);
}
}
#line 2218 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void cleanstrcpy(char *t , char *f , int l ) 
{ 
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2225
  denlstring(f, 1, 1);
  }
#line 2227
  if (l <= 0) {
    {
#line 2228
    syserr("!cleanstrcpy: length == 0");
    }
  }
#line 2230
  l --;
  {
#line 2231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2231
    if (l > 0) {
#line 2231
      if (! ((int )*f != 0)) {
#line 2231
        goto while_break;
      }
    } else {
#line 2231
      goto while_break;
    }
#line 2233
    if (((int )*f & -128) == 0) {
      {
#line 2233
      tmp___0 = __ctype_b_loc();
      }
#line 2233
      if ((int const   )*(*tmp___0 + (int )*f) & 8) {
#line 2236
        l --;
#line 2237
        tmp = t;
#line 2237
        t ++;
#line 2237
        *tmp = *f;
      } else {
        {
#line 2233
        tmp___1 = strchr("!#$%&\'*+-./^_`{|}~", (int )*f);
        }
#line 2233
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 2236
          l --;
#line 2237
          tmp = t;
#line 2237
          t ++;
#line 2237
          *tmp = *f;
        }
      }
    }
#line 2239
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2241
  *t = (char )'\000';
#line 2242
  return;
}
}
#line 2264 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
static char *bp  =    (char *)((void *)0);
#line 2265 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
static int bl  =    0;
#line 2256 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
char *denlstring(char *s , bool strict , bool logattacks ) 
{ 
  register char *p ;
  int l ;
  size_t tmp ;
  char *nbp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2267
  p = s;
  {
#line 2268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2268
    p = strchr((char const   *)p, '\n');
    }
#line 2268
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 2268
      goto while_break;
    }
#line 2269
    if (strict) {
#line 2270
      goto while_break;
    } else {
#line 2269
      p ++;
#line 2269
      if ((int )*p != 32) {
#line 2269
        if ((int )*p != 9) {
#line 2270
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2271
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2272
    return (s);
  }
  {
#line 2274
  tmp = strlen((char const   *)s);
#line 2274
  l = (int )(tmp + 1U);
  }
#line 2275
  if (bl < l) {
    {
#line 2278
    tmp___0 = sm_malloc_tagged_x((size_t )l, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                                 2278, 0);
#line 2278
    nbp = (char *)tmp___0;
    }
#line 2280
    if ((unsigned long )bp != (unsigned long )((void *)0)) {
      {
#line 2281
      sm_free_tagged((void *)bp, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                     2281);
      }
    }
#line 2282
    bp = nbp;
#line 2283
    bl = l;
  }
  {
#line 2285
  sm_strlcpy(bp, (char const   *)s, l);
#line 2286
  p = bp;
  }
  {
#line 2286
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2286
    p = strchr((char const   *)p, '\n');
    }
#line 2286
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 2286
      goto while_break___0;
    }
#line 2287
    tmp___1 = p;
#line 2287
    p ++;
#line 2287
    *tmp___1 = (char )' ';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2289
  if (logattacks) {
    {
#line 2291
    tmp___2 = shortenstring((char const   *)bp, (size_t )203);
    }
#line 2291
    if ((unsigned long )RealHostName == (unsigned long )((void *)0)) {
#line 2291
      tmp___3 = "[UNKNOWN]";
    } else {
#line 2291
      tmp___3 = (char const   *)RealHostName;
    }
    {
#line 2291
    sm_syslog(5, (char const   *)CurEnv->e_id, "POSSIBLE ATTACK from %.100s: newline in string \"%s\"",
              tmp___3, tmp___2);
    }
  }
#line 2297
  return (bp);
}
}
#line 2311 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
bool strreplnonprt(char *s , int c ) 
{ 
  bool ok ;
  unsigned short const   **tmp ;

  {
#line 2318
  ok = 1;
#line 2319
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 2320
    return (ok);
  }
  {
#line 2321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2321
    if (! ((int )*s != 0)) {
#line 2321
      goto while_break;
    }
#line 2323
    if (((int )*s & -128) == 0) {
      {
#line 2323
      tmp = __ctype_b_loc();
      }
#line 2323
      if (! ((int const   )*(*tmp + (int )*s) & 16384)) {
#line 2325
        *s = (char )c;
#line 2326
        ok = 0;
      }
    } else {
#line 2325
      *s = (char )c;
#line 2326
      ok = 0;
    }
#line 2328
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2330
  return (ok);
}
}
#line 2352 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
static int len  =    0;
#line 2353 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
static char *buf___2  =    (char *)((void *)0);
#line 2345 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
char *str2prt(char *s ) 
{ 
  int l ;
  char c ;
  char *h ;
  bool ok ;
  unsigned short const   **tmp ;
  char *nbuf ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 2355
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 2356
    return ((char *)((void *)0));
  }
#line 2357
  ok = 1;
#line 2358
  h = s;
#line 2358
  l = 1;
  {
#line 2358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2358
    if (! ((int )*h != 0)) {
#line 2358
      goto while_break;
    }
#line 2360
    if ((int )*h == 92) {
#line 2362
      l ++;
#line 2363
      ok = 0;
    } else
#line 2365
    if (((int )*h & -128) == 0) {
      {
#line 2365
      tmp = __ctype_b_loc();
      }
#line 2365
      if (! ((int const   )*(*tmp + (int )*h) & 16384)) {
#line 2367
        l += 3;
#line 2368
        ok = 0;
      }
    } else {
#line 2367
      l += 3;
#line 2368
      ok = 0;
    }
#line 2358
    h ++;
#line 2358
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2371
  if (ok) {
#line 2372
    return (s);
  }
#line 2373
  if (l > len) {
    {
#line 2375
    tmp___0 = sm_malloc_tagged_x((size_t )l, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                                 2375, 0);
#line 2375
    nbuf = (char *)tmp___0;
    }
#line 2377
    if ((unsigned long )buf___2 != (unsigned long )((void *)0)) {
      {
#line 2378
      sm_free_tagged((void *)buf___2, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                     2378);
      }
    }
#line 2379
    len = l;
#line 2380
    buf___2 = nbuf;
  }
#line 2382
  h = buf___2;
  {
#line 2382
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2382
    if ((int )*s != 0) {
#line 2382
      if (! (l > 0)) {
#line 2382
        goto while_break___0;
      }
    } else {
#line 2382
      goto while_break___0;
    }
#line 2384
    c = *s;
#line 2385
    if (((int )c & -128) == 0) {
      {
#line 2385
      tmp___8 = __ctype_b_loc();
      }
#line 2385
      if ((int const   )*(*tmp___8 + (int )c) & 16384) {
#line 2385
        if ((int )c != 92) {
#line 2387
          tmp___1 = h;
#line 2387
          h ++;
#line 2387
          *tmp___1 = c;
        } else {
#line 2385
          goto _L___0;
        }
      } else {
#line 2385
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2391
      tmp___2 = h;
#line 2391
      h ++;
#line 2391
      *tmp___2 = (char )'\\';
#line 2392
      l --;
      {
#line 2395
      if ((int )c == 92) {
#line 2395
        goto case_92;
      }
#line 2398
      if ((int )c == 9) {
#line 2398
        goto case_9;
      }
#line 2401
      if ((int )c == 10) {
#line 2401
        goto case_10;
      }
#line 2404
      if ((int )c == 13) {
#line 2404
        goto case_13;
      }
#line 2407
      goto switch_default;
      case_92: /* CIL Label */ 
#line 2396
      tmp___3 = h;
#line 2396
      h ++;
#line 2396
      *tmp___3 = (char )'\\';
#line 2397
      goto switch_break;
      case_9: /* CIL Label */ 
#line 2399
      tmp___4 = h;
#line 2399
      h ++;
#line 2399
      *tmp___4 = (char )'t';
#line 2400
      goto switch_break;
      case_10: /* CIL Label */ 
#line 2402
      tmp___5 = h;
#line 2402
      h ++;
#line 2402
      *tmp___5 = (char )'n';
#line 2403
      goto switch_break;
      case_13: /* CIL Label */ 
#line 2405
      tmp___6 = h;
#line 2405
      h ++;
#line 2405
      *tmp___6 = (char )'r';
#line 2406
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2408
      if (l >= 2) {
#line 2408
        tmp___7 = 1;
      } else {
        {
#line 2408
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                    2408, "SM_ASSERT(l >= 2) failed");
#line 2408
        tmp___7 = 0;
        }
      }
      {
#line 2409
      sm_snprintf(h, (size_t )l, "%03o", (unsigned int )((unsigned char )c));
#line 2418
      l -= 2;
#line 2419
      h += 3;
      }
#line 2420
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 2382
    s ++;
#line 2382
    l --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2424
  *h = (char )'\000';
#line 2425
  *(buf___2 + (len - 1)) = (char )'\000';
#line 2426
  return (buf___2);
}
}
#line 2444 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
bool path_is_dir(char *pathname , bool createflag ) 
{ 
  struct stat statbuf ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 2452
  tmp___1 = lstat((char const   */* __restrict  */)pathname, (struct stat */* __restrict  */)(& statbuf));
  }
#line 2452
  if (tmp___1 < 0) {
    {
#line 2457
    tmp = __errno_location();
    }
#line 2457
    if (*tmp != 2) {
#line 2458
      return (0);
    } else
#line 2457
    if (! createflag) {
#line 2458
      return (0);
    }
    {
#line 2459
    tmp___0 = mkdir((char const   *)pathname, (__mode_t )493);
    }
#line 2459
    if (tmp___0 < 0) {
#line 2460
      return (0);
    }
#line 2461
    return (1);
  }
#line 2463
  if (! ((statbuf.st_mode & 61440U) == 16384U)) {
    {
#line 2465
    tmp___2 = __errno_location();
#line 2465
    *tmp___2 = 20;
    }
#line 2466
    return (0);
  }
#line 2470
  if ((statbuf.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) != 0U) {
    {
#line 2472
    tmp___3 = __errno_location();
#line 2472
    *tmp___3 = 13;
    }
#line 2473
    return (0);
  }
#line 2475
  return (1);
}
}
#line 2506 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
static PROCS_T * volatile  ProcListVec  =    (PROCS_T */* volatile  */)((void *)0);
#line 2507 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
static int ProcListSize  =    0;
#line 2509 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void proc_list_add(pid_t pid , char *task , int type , int count , int other , union bigsockaddr *hostaddr ) 
{ 
  int i ;
  PROCS_T *npv ;
  int tmp ;
  void *tmp___0 ;
  char *_newval ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2520
  i = 0;
  {
#line 2520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2520
    if (! (i < ProcListSize)) {
#line 2520
      goto while_break;
    }
#line 2522
    if ((ProcListVec + i)->proc_pid == 0) {
#line 2523
      goto while_break;
    }
#line 2520
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2525
  if (i >= ProcListSize) {
    {
#line 2528
    proc_list_probe();
#line 2531
    i = 0;
    }
    {
#line 2531
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2531
      if (! (i < ProcListSize)) {
#line 2531
        goto while_break___0;
      }
#line 2533
      if ((ProcListVec + i)->proc_pid == 0) {
#line 2534
        goto while_break___0;
      }
#line 2531
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2537
  if (i >= ProcListSize) {
#line 2542
    if (ProcListSize < 2147483615) {
#line 2542
      tmp = 1;
    } else {
      {
#line 2542
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                  2542, "SM_ASSERT(ProcListSize < INT_MAX - PROC_LIST_SEG) failed");
#line 2542
      tmp = 0;
      }
    }
    {
#line 2543
    tmp___0 = sm_malloc_tagged_x((size_t )(sizeof(*npv) * (unsigned long )(ProcListSize + 32)),
                                 (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                                 2544, 0);
#line 2543
    npv = (PROCS_T *)tmp___0;
    }
#line 2545
    if (ProcListSize > 0) {
      {
#line 2547
      memmove((void *)npv, (void const   *)ProcListVec, (size_t )((unsigned long )ProcListSize * sizeof(PROCS_T )));
#line 2549
      sm_free_tagged((void *)ProcListVec, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                     2549);
      }
    }
#line 2553
    i = ProcListSize;
    {
#line 2553
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2553
      if (! (i < ProcListSize + 32)) {
#line 2553
        goto while_break___1;
      }
#line 2555
      (npv + i)->proc_pid = 0;
#line 2556
      (npv + i)->proc_task = (char *)((void *)0);
#line 2557
      (npv + i)->proc_type = 0;
#line 2553
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2559
    i = ProcListSize;
#line 2560
    ProcListSize += 32;
#line 2561
    ProcListVec = (PROCS_T */* volatile  */)npv;
  }
#line 2563
  (ProcListVec + i)->proc_pid = pid;
  {
#line 2564
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 2564
    tmp___1 = sm_pstrdup_x((char const   *)task);
#line 2564
    _newval = tmp___1;
    }
#line 2564
    if ((unsigned long )(ProcListVec + i)->proc_task != (unsigned long )((void *)0)) {
      {
#line 2564
      sm_free_tagged((void *)(ProcListVec + i)->proc_task, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                     2564);
      }
    }
#line 2564
    (ProcListVec + i)->proc_task = _newval;
#line 2564
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2565
  (ProcListVec + i)->proc_type = type;
#line 2566
  (ProcListVec + i)->proc_count = count;
#line 2567
  (ProcListVec + i)->proc_other = other;
#line 2568
  if ((unsigned long )hostaddr != (unsigned long )((void *)0)) {
#line 2569
    (ProcListVec + i)->proc_hostaddr = *hostaddr;
  } else {
    {
#line 2571
    memset((void *)(& (ProcListVec + i)->proc_hostaddr), 0, (size_t )sizeof((ProcListVec + i)->proc_hostaddr));
    }
  }
#line 2575
  if (pid != CurrentPid) {
#line 2577
    if (CurChildren < (int volatile   )2147483647) {
#line 2577
      tmp___2 = 1;
    } else {
      {
#line 2577
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                  2577, "SM_ASSERT(CurChildren < INT_MAX) failed");
#line 2577
      tmp___2 = 0;
      }
    }
#line 2578
    CurChildren += (int volatile   )1;
  }
#line 2580
  return;
}
}
#line 2592 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void proc_list_set(pid_t pid , char *task ) 
{ 
  int i ;
  char *_newval ;
  char *tmp ;
  char *__cil_tmp6 ;

  {
#line 2599
  i = 0;
  {
#line 2599
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2599
    if (! (i < ProcListSize)) {
#line 2599
      goto while_break;
    }
#line 2601
    if ((ProcListVec + i)->proc_pid == pid) {
      {
#line 2603
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2603
        tmp = sm_pstrdup_x((char const   *)task);
#line 2603
        _newval = tmp;
        }
#line 2603
        if ((unsigned long )(ProcListVec + i)->proc_task != (unsigned long )((void *)0)) {
          {
#line 2603
          sm_free_tagged((void *)(ProcListVec + i)->proc_task, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                         2603);
          }
        }
#line 2603
        (ProcListVec + i)->proc_task = _newval;
#line 2603
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2604
      goto while_break;
    }
#line 2599
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2607
  return;
}
}
#line 2628 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void proc_list_drop(pid_t pid , int st , int *other ) 
{ 
  int i ;
  int type ;
  union __anonunion___u_65 __u ;
  union __anonunion___u_66 __u___0 ;
  union __anonunion___u_67 __u___1 ;
  union __anonunion___u_68 __u___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 2635
  type = 0;
#line 2637
  i = 0;
  {
#line 2637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2637
    if (! (i < ProcListSize)) {
#line 2637
      goto while_break;
    }
#line 2639
    if ((ProcListVec + i)->proc_pid == pid) {
#line 2641
      (ProcListVec + i)->proc_pid = 0;
#line 2642
      type = (ProcListVec + i)->proc_type;
#line 2643
      if ((unsigned long )other != (unsigned long )((void *)0)) {
#line 2644
        *other = (ProcListVec + i)->proc_other;
      }
#line 2645
      if (CurChildren > (int volatile   )0) {
#line 2646
        CurChildren -= (int volatile   )1;
      }
#line 2647
      goto while_break;
    }
#line 2637
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2652
  if (type == 4) {
#line 2652
    __u___2.__in = st;
#line 2652
    if ((__u___2.__i & 127) == 0) {
#line 2655
      __u___0.__in = st;
#line 2655
      if ((__u___0.__i & 65280) >> 8 == 23) {
#line 2656
        RestartRequest = (char */* volatile  */)"control socket";
      } else {
#line 2657
        __u.__in = st;
#line 2657
        if ((__u.__i & 65280) >> 8 == 24) {
#line 2658
          ShutdownRequest = (char */* volatile  */)"control socket";
        }
      }
    } else {
#line 2652
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2660
  if (type == 3) {
#line 2660
    __u___1.__in = st;
#line 2660
    if ((__u___1.__i & 255) == 127) {
#line 2660
      goto _L___0;
    } else
#line 2660
    if ((ProcListVec + i)->proc_other > -1) {
      {
#line 2664
      mark_work_group_restart((ProcListVec + i)->proc_other, st);
      }
    } else {
#line 2660
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2666
  if (type == 3) {
#line 2667
    CurRunners -= (int volatile   )(ProcListVec + i)->proc_count;
  }
#line 2668
  return;
}
}
#line 2682 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void proc_list_clear(void) 
{ 
  int i ;

  {
#line 2688
  i = 1;
  {
#line 2688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2688
    if (! (i < ProcListSize)) {
#line 2688
      goto while_break;
    }
#line 2689
    (ProcListVec + i)->proc_pid = 0;
#line 2688
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2690
  CurChildren = (int volatile   )0;
#line 2691
  return;
}
}
#line 2705 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void proc_list_probe(void) 
{ 
  int i ;
  int children ;
  int chldwasblocked ;
  pid_t pid ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2712
  children = 0;
#line 2713
  chldwasblocked = sm_blocksignal(17);
#line 2716
  i = 1;
  }
  {
#line 2716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2716
    if (! (i < ProcListSize)) {
#line 2716
      goto while_break;
    }
#line 2718
    pid = (ProcListVec + i)->proc_pid;
#line 2719
    if (pid == 0) {
#line 2720
      goto __Cont;
    } else
#line 2719
    if (pid == CurrentPid) {
#line 2720
      goto __Cont;
    }
    {
#line 2721
    tmp = kill(pid, 0);
    }
#line 2721
    if (tmp < 0) {
#line 2723
      if (LogLevel > 3) {
        {
#line 2724
        sm_syslog(7, (char const   *)CurEnv->e_id, "proc_list_probe: lost pid %d",
                  (ProcListVec + i)->proc_pid);
        }
      }
#line 2727
      (ProcListVec + i)->proc_pid = 0;
#line 2728
      if ((unsigned long )(ProcListVec + i)->proc_task != (unsigned long )((void *)0)) {
        {
#line 2728
        sm_free_tagged((void *)(ProcListVec + i)->proc_task, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c",
                       2728);
#line 2728
        (ProcListVec + i)->proc_task = (char *)((void *)0);
        }
      }
#line 2729
      CurChildren -= (int volatile   )1;
    } else {
#line 2733
      children ++;
    }
    __Cont: /* CIL Label */ 
#line 2716
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2736
  if (CurChildren < (int volatile   )0) {
#line 2737
    CurChildren = (int volatile   )0;
  }
#line 2738
  if (chldwasblocked == 0) {
    {
#line 2739
    sm_releasesignal(17);
    }
  }
#line 2740
  if (LogLevel > 10) {
#line 2740
    if (children != (int )CurChildren) {
      {
#line 2742
      sm_syslog(3, "*~*", "proc_list_probe: found %d children, expected %d", children,
                CurChildren);
      }
    }
  }
#line 2746
  return;
}
}
#line 2759 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void proc_list_display(SM_FILE_T *out , char *prefix ) 
{ 
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 2766
  i = 0;
  {
#line 2766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2766
    if (! (i < ProcListSize)) {
#line 2766
      goto while_break;
    }
#line 2768
    if ((ProcListVec + i)->proc_pid == 0) {
#line 2769
      goto __Cont;
    }
#line 2771
    if ((int )OpMode == 115) {
#line 2771
      tmp = "\r";
    } else
#line 2771
    if ((int )OpMode == 100) {
#line 2771
      tmp = "\r";
    } else
#line 2771
    if ((int )OpMode == 97) {
#line 2771
      tmp = "\r";
    } else {
#line 2771
      tmp = "";
    }
#line 2771
    if ((unsigned long )(ProcListVec + i)->proc_task != (unsigned long )((void *)0)) {
#line 2771
      tmp___0 = (char const   *)(ProcListVec + i)->proc_task;
    } else {
#line 2771
      tmp___0 = "(unknown)";
    }
    {
#line 2771
    sm_io_fprintf(out, -2, "%s%d %s%s\n", prefix, (ProcListVec + i)->proc_pid, tmp___0,
                  tmp);
    }
    __Cont: /* CIL Label */ 
#line 2766
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2780
  return;
}
}
#line 2797 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
void proc_list_signal(int type , int signal___0 ) 
{ 
  int chldwasblocked ;
  int alrmwasblocked ;
  int i ;
  pid_t mypid ;
  __pid_t tmp ;

  {
  {
#line 2805
  tmp = getpid();
#line 2805
  mypid = tmp;
#line 2808
  chldwasblocked = sm_blocksignal(17);
#line 2809
  alrmwasblocked = sm_blocksignal(14);
#line 2812
  i = 0;
  }
  {
#line 2812
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2812
    if (! (i < ProcListSize)) {
#line 2812
      goto while_break;
    }
#line 2814
    if ((ProcListVec + i)->proc_pid == 0) {
#line 2816
      goto __Cont;
    } else
#line 2814
    if ((ProcListVec + i)->proc_pid == mypid) {
#line 2816
      goto __Cont;
    }
#line 2817
    if ((ProcListVec + i)->proc_type != type) {
#line 2818
      goto __Cont;
    }
    {
#line 2819
    kill((ProcListVec + i)->proc_pid, signal___0);
    }
    __Cont: /* CIL Label */ 
#line 2812
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2823
  if (alrmwasblocked == 0) {
    {
#line 2824
    sm_releasesignal(14);
    }
  }
#line 2825
  if (chldwasblocked == 0) {
    {
#line 2826
    sm_releasesignal(17);
    }
  }
#line 2827
  return;
}
}
#line 2840 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/util.c"
int count_open_connections(union bigsockaddr *hostaddr ) 
{ 
  int i ;
  int n ;

  {
#line 2846
  if ((unsigned long )hostaddr == (unsigned long )((void *)0)) {
#line 2847
    return (0);
  }
#line 2848
  n = 0;
#line 2849
  i = 0;
  {
#line 2849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2849
    if (! (i < ProcListSize)) {
#line 2849
      goto while_break;
    }
#line 2851
    if ((ProcListVec + i)->proc_pid == 0) {
#line 2852
      goto __Cont;
    }
#line 2853
    if ((int )hostaddr->sa.sa_family != (int )(ProcListVec + i)->proc_hostaddr.sa.sa_family) {
#line 2855
      goto __Cont;
    }
#line 2857
    if ((int )hostaddr->sa.sa_family == 2) {
#line 2857
      if (hostaddr->sin.sin_addr.s_addr == (ProcListVec + i)->proc_hostaddr.sin.sin_addr.s_addr) {
#line 2860
        n ++;
      }
    }
    __Cont: /* CIL Label */ 
#line 2849
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2869
  return (n);
}
}
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 151
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 194 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 20 "./bf.h"
int bfrewind(SM_FILE_T *fp ) ;
#line 731 "./sendmail.h"
void mci_close(struct mailer_con_info *mci , char *where ) ;
#line 732
void mci_dump(SM_FILE_T *fp , struct mailer_con_info *mci , bool logit ) ;
#line 741
void mci_setstat(struct mailer_con_info *mci , int xstat , char *dstat , char *rstat ) ;
#line 966
void clrsessenvelope(ENVELOPE *e ) ;
#line 1965
char *qid_printname(ENVELOPE *e ) ;
#line 1992
struct __anonstruct_TimeOuts_64 TimeOuts ;
#line 2166
bool HoldErrs ;
#line 2190
bool SuprErrs ;
#line 2192
bool UseMSP ;
#line 2230
int MimeMode ;
#line 2301
char *MyHostName ;
#line 2314
char *SmtpPhase ;
#line 2315
char SmtpError[2048] ;
#line 2353
void nmessage(char const   *msg  , ...) ;
#line 2355
void usrerrenh(char *enhsc , char const   *fmt  , ...) ;
#line 2356
void usrerr(char const   *fmt  , ...) ;
#line 2357
int isenhsc(char const   *s , int delim ) ;
#line 2358
int extenhsc(char const   *s , int delim , char *e ) ;
#line 2374
void giveresponse(int status , char *dsn , MAILER *m , struct mailer_con_info *mci ,
                  ADDRESS *ctladdr , time_t xstart , ENVELOPE *e , ADDRESS *to ) ;
#line 2375
int reply(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e , time_t timeout ,
          void (*pfunc)(char * , bool  , MAILER * , struct mailer_con_info * , ENVELOPE * ) ,
          char **enhstat , int rtype ) ;
#line 2380
int smtpdata(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e , ADDRESS *ctladdr ,
             time_t xstart ) ;
#line 2381
int smtpgetstat(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e ) ;
#line 2382
int smtpmailfrom(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e ) ;
#line 2383
void smtpmessage(char *f , MAILER *m , struct mailer_con_info *mci  , ...) ;
#line 2384
void smtpinit(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e , bool onlyhelo ) ;
#line 2385
char *smtptodsn(int smtpstat ) ;
#line 2386
int smtpprobe(struct mailer_con_info *mci ) ;
#line 2387
void smtpquit(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e ) ;
#line 2388
int smtprcpt(ADDRESS *to , MAILER *m , struct mailer_con_info *mci , ENVELOPE *e ,
             ADDRESS *ctladdr , time_t xstart ) ;
#line 2389
void smtprset(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e ) ;
#line 2401
int endmailer(struct mailer_con_info *mci , ENVELOPE *e , char **pv ) ;
#line 2522
void markfailure(ENVELOPE *e , ADDRESS *q , struct mailer_con_info *mci , int rcode ,
                 bool ovr ) ;
#line 2575
void sm_setproctitle(bool status , ENVELOPE *e , char const   *fmt  , ...) ;
#line 21 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
static void esmtp_check(char *line , bool firstline , MAILER *m , struct mailer_con_info *mci ,
                        ENVELOPE *e ) ;
#line 22
static void helo_options(char *line , bool firstline , MAILER *m , struct mailer_con_info *mci ,
                         ENVELOPE *e ) ;
#line 23
static int smtprcptstat(ADDRESS *to , MAILER *m , struct mailer_con_info *mci , ENVELOPE *e ) ;
#line 44 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
static char SmtpMsgBuffer[2048]  ;
#line 45 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
static char SmtpReplyBuffer[2048]  ;
#line 46 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
static bool SmtpNeedIntro  ;
#line 65 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
void smtpinit(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e , bool onlyhelo ) 
{ 
  register int r ;
  int state ;
  register char *p ;
  register char *hn ;
  char *enhsc ;
  SM_FILE_T *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  time_t tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 78
  enhsc = (char *)((void *)0);
#line 79
  if ((int )tTdvect[18] >= 1) {
    {
#line 81
    sm_dprintf((char *)"smtpinit ");
#line 82
    tmp = sm_debug_file();
#line 82
    mci_dump(tmp, mci, 0);
    }
  }
#line 89
  SmtpError[0] = (char )'\000';
#line 90
  SmtpMsgBuffer[0] = (char )'\000';
#line 91
  CurHostName = mci->mci_host;
#line 92
  if ((unsigned long )CurHostName == (unsigned long )((void *)0)) {
#line 93
    CurHostName = MyHostName;
  }
#line 94
  SmtpNeedIntro = 1;
#line 95
  state = (int )mci->mci_state;
  {
#line 100
  if (state == 5) {
#line 100
    goto case_5;
  }
#line 100
  if (state == 4) {
#line 100
    goto case_5;
  }
#line 100
  if (state == 3) {
#line 100
    goto case_5;
  }
#line 105
  if (state == 2) {
#line 105
    goto case_2;
  }
#line 112
  if (state == 7) {
#line 112
    goto case_7;
  }
#line 112
  if (state == 6) {
#line 112
    goto case_7;
  }
#line 112
  if (state == 8) {
#line 112
    goto case_7;
  }
#line 117
  if (state == 0) {
#line 117
    goto case_0;
  }
#line 121
  if (state == 1) {
#line 121
    goto case_1;
  }
#line 96
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 102
  smtprset(m, mci, e);
  }
  case_2: /* CIL Label */ 
#line 106
  if (! onlyhelo) {
#line 107
    return;
  }
#line 108
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
#line 114
  smtpquit(m, mci, e);
  }
  case_0: /* CIL Label */ 
  {
#line 118
  syserr("451 4.4.0 smtpinit: state CLOSED (was %d)", state);
  }
#line 119
  return;
  case_1: /* CIL Label */ 
#line 122
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 124
  if (onlyhelo) {
#line 125
    goto helo;
  }
  {
#line 127
  mci->mci_state = (short)1;
#line 128
  clrsessenvelope(e);
#line 136
  tmp___0 = (char *)"client greeting";
#line 136
  mci->mci_phase = tmp___0;
#line 136
  SmtpPhase = tmp___0;
#line 137
  tmp___1 = qid_printname(e);
#line 137
  sm_setproctitle(1, e, "%s %s: %s", tmp___1, CurHostName, mci->mci_phase);
#line 139
  r = reply(m, mci, e, TimeOuts.to_initial, & esmtp_check, (char **)((void *)0), 0);
  }
#line 141
  if (r < 0) {
#line 142
    goto tempfail1;
  }
#line 143
  if (r / 100 == 4) {
#line 144
    goto tempfail2;
  }
#line 145
  if (r / 100 != 2) {
#line 146
    goto unavailable;
  }
  helo: 
#line 154
  if (m->m_flags[97UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 97UL % (8UL * sizeof(int )))) {
#line 155
    mci->mci_flags |= 8UL;
  } else
#line 154
  if (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int )))) {
#line 155
    mci->mci_flags |= 8UL;
  }
#line 156
  if (mci->mci_heloname) {
#line 156
    hn = mci->mci_heloname;
  } else {
#line 156
    hn = MyHostName;
  }
  tryhelo: 
#line 162
  if (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int )))) {
    {
#line 164
    smtpmessage((char *)"LHLO %s", m, mci, hn);
#line 165
    tmp___2 = (char *)"client LHLO";
#line 165
    mci->mci_phase = tmp___2;
#line 165
    SmtpPhase = tmp___2;
    }
  } else
#line 167
  if ((mci->mci_flags & 8UL) != 0UL) {
#line 167
    if (! (m->m_flags[50UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 50UL % (8UL * sizeof(int ))))) {
      {
#line 170
      smtpmessage((char *)"EHLO %s", m, mci, hn);
#line 171
      tmp___3 = (char *)"client EHLO";
#line 171
      mci->mci_phase = tmp___3;
#line 171
      SmtpPhase = tmp___3;
      }
    } else {
      {
#line 175
      smtpmessage((char *)"HELO %s", m, mci, hn);
#line 176
      tmp___4 = (char *)"client HELO";
#line 176
      mci->mci_phase = tmp___4;
#line 176
      SmtpPhase = tmp___4;
      }
    }
  } else {
    {
#line 175
    smtpmessage((char *)"HELO %s", m, mci, hn);
#line 176
    tmp___4 = (char *)"client HELO";
#line 176
    mci->mci_phase = tmp___4;
#line 176
    SmtpPhase = tmp___4;
    }
  }
  {
#line 181
  tmp___5 = qid_printname(e);
#line 181
  sm_setproctitle(1, e, "%s %s: %s", tmp___5, CurHostName, mci->mci_phase);
  }
#line 183
  if (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int )))) {
#line 183
    tmp___6 = TimeOuts.to_lhlo;
  } else {
#line 183
    tmp___6 = TimeOuts.to_helo;
  }
  {
#line 183
  r = reply(m, mci, e, tmp___6, & helo_options, (char **)((void *)0), 0);
  }
#line 187
  if (r < 0) {
#line 188
    goto tempfail1;
  } else
#line 189
  if (r / 100 == 5) {
#line 191
    if ((mci->mci_flags & 8UL) != 0UL) {
#line 191
      if (! (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int ))))) {
#line 195
        mci->mci_flags &= 0xfffffffffffffff7UL;
#line 196
        goto tryhelo;
      }
    }
#line 198
    goto unavailable;
  } else
#line 200
  if (r / 100 != 2) {
#line 201
    goto tempfail2;
  }
  {
#line 209
  p = strchr((char const   *)(& SmtpReplyBuffer[4]), ' ');
  }
#line 210
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 211
    *p = (char )'\000';
  }
#line 212
  if (! (m->m_flags[107UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 107UL % (8UL * sizeof(int ))))) {
#line 212
    if (! (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int ))))) {
      {
#line 212
      tmp___7 = sm_strcasecmp((char const   *)(& SmtpReplyBuffer[4]), (char const   *)MyHostName);
      }
#line 212
      if (tmp___7 == 0) {
        {
#line 216
        syserr("553 5.3.5 %s config error: mail loops back to me (MX problem?)", CurHostName);
#line 218
        mci_setstat(mci, 78, (char *)"5.3.5", (char *)"553 5.3.5 system config error");
#line 220
        mci->mci_errno = (short)0;
#line 221
        smtpquit(m, mci, e);
        }
#line 222
        return;
      }
    }
  }
#line 231
  if (UseMSP) {
#line 231
    if (Verbose) {
#line 231
      if ((mci->mci_flags & 524288UL) != 0UL) {
#line 231
        goto _L;
      } else {
#line 231
        goto _L___1;
      }
    } else {
#line 231
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 231
  if (m->m_flags[73UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 73UL % (8UL * sizeof(int )))) {
    _L: /* CIL Label */ 
    {
#line 238
    smtpmessage((char *)"VERB", m, mci);
#line 239
    r = reply(m, mci, e, TimeOuts.to_miscshort, (void (*)(char * , bool  , MAILER * ,
                                                          struct mailer_con_info * ,
                                                          ENVELOPE * ))((void *)0),
              & enhsc, 0);
    }
#line 241
    if (r < 0) {
#line 242
      goto tempfail1;
    }
  }
#line 245
  if ((int )mci->mci_state != 0) {
#line 247
    mci->mci_state = (short)2;
#line 248
    return;
  }
  tempfail1: 
#line 254
  if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 254
    tmp___8 = "4.4.2";
  } else {
#line 254
    tmp___8 = (char const   *)enhsc;
  }
  {
#line 254
  mci_setstat(mci, 75, (char *)tmp___8, (char *)((void *)0));
  }
#line 255
  if ((int )mci->mci_state != 0) {
    {
#line 256
    smtpquit(m, mci, e);
    }
  }
#line 257
  return;
  tempfail2: 
#line 261
  if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 261
    tmp___9 = "4.5.0";
  } else {
#line 261
    tmp___9 = (char const   *)enhsc;
  }
  {
#line 261
  mci_setstat(mci, 75, (char *)tmp___9, SmtpReplyBuffer);
  }
#line 263
  if ((int )mci->mci_state != 0) {
    {
#line 264
    smtpquit(m, mci, e);
    }
  }
#line 265
  return;
  unavailable: 
  {
#line 268
  mci_setstat(mci, 69, (char *)"5.5.0", SmtpReplyBuffer);
#line 269
  smtpquit(m, mci, e);
  }
#line 270
  return;
}
}
#line 286 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
static void esmtp_check(char *line , bool firstline , MAILER *m , struct mailer_con_info *mci ,
                        ENVELOPE *e ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 294
  tmp = strstr((char const   *)line, "ESMTP");
  }
#line 294
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 295
    mci->mci_flags |= 8UL;
  }
  {
#line 305
  tmp___0 = strstr((char const   *)line, "8BIT-OK");
  }
#line 305
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 306
    mci->mci_flags |= 4096UL;
  }
#line 307
  return;
}
}
#line 397 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
static void helo_options(char *line , bool firstline , MAILER *m , struct mailer_con_info *mci ,
                         ENVELOPE *e ) 
{ 
  register char *p ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 410
  if (firstline) {
#line 418
    return;
  }
  {
#line 435
  tmp = strlen((char const   *)line);
  }
#line 435
  if (tmp < 5U) {
#line 436
    return;
  }
  {
#line 437
  line += 4;
#line 438
  p = strpbrk((char const   *)line, " =");
  }
#line 439
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 440
    tmp___0 = p;
#line 440
    p ++;
#line 440
    *tmp___0 = (char )'\000';
  }
  {
#line 441
  tmp___8 = sm_strcasecmp((char const   *)line, "size");
  }
#line 441
  if (tmp___8 == 0) {
#line 443
    mci->mci_flags |= 32UL;
#line 444
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 445
      mci->mci_maxsize = atol((char const   *)p);
      }
    }
  } else {
    {
#line 447
    tmp___7 = sm_strcasecmp((char const   *)line, "8bitmime");
    }
#line 447
    if (tmp___7 == 0) {
#line 449
      mci->mci_flags |= 64UL;
#line 450
      mci->mci_flags &= 0xffffffffffffff7fUL;
    } else {
      {
#line 452
      tmp___6 = sm_strcasecmp((char const   *)line, "expn");
      }
#line 452
      if (tmp___6 == 0) {
#line 453
        mci->mci_flags |= 16UL;
      } else {
        {
#line 454
        tmp___5 = sm_strcasecmp((char const   *)line, "dsn");
        }
#line 454
        if (tmp___5 == 0) {
#line 455
          mci->mci_flags |= 2048UL;
        } else {
          {
#line 456
          tmp___4 = sm_strcasecmp((char const   *)line, "enhancedstatuscodes");
          }
#line 456
          if (tmp___4 == 0) {
#line 457
            mci->mci_flags |= 131072UL;
          } else {
            {
#line 458
            tmp___3 = sm_strcasecmp((char const   *)line, "pipelining");
            }
#line 458
            if (tmp___3 == 0) {
#line 459
              mci->mci_flags |= 262144UL;
            } else {
              {
#line 460
              tmp___2 = sm_strcasecmp((char const   *)line, "verb");
              }
#line 460
              if (tmp___2 == 0) {
#line 461
                mci->mci_flags |= 524288UL;
              } else {
                {
#line 466
                tmp___1 = sm_strcasecmp((char const   *)line, "deliverby");
                }
#line 466
                if (tmp___1 == 0) {
#line 468
                  mci->mci_flags |= 4194304UL;
#line 469
                  if ((unsigned long )p != (unsigned long )((void *)0)) {
                    {
#line 470
                    mci->mci_min_by = atol((char const   *)p);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 506
  return;
}
}
#line 2061
char MsgBuf[16384] ;
#line 1982 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
int smtpmailfrom(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e ) 
{ 
  int r ;
  char *bufp ;
  char *bodytype ;
  char *enhsc ;
  char buf___16[257] ;
  char optbuf[2048] ;
  int *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  long dby ;
  time_t tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  char const   *tmp___24 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;

  {
#line 1995
  if ((int )tTdvect[18] >= 2) {
    {
#line 1996
    sm_dprintf((char *)"smtpmailfrom: CurHost=%s\n", CurHostName);
    }
  }
#line 1997
  enhsc = (char *)((void *)0);
#line 2005
  if ((int )mci->mci_state == 0) {
    {
#line 2007
    tmp = __errno_location();
#line 2007
    *tmp = (int )mci->mci_errno;
    }
#line 2008
    return (75);
  }
#line 2012
  if ((mci->mci_flags & 32UL) != 0UL) {
#line 2012
    if (e->e_msgsize > 0L) {
      {
#line 2014
      sm_snprintf(optbuf, (size_t )sizeof(optbuf), " SIZE=%ld", e->e_msgsize);
#line 2016
      tmp___0 = strlen((char const   *)(optbuf));
#line 2016
      bufp = & optbuf[tmp___0];
      }
    } else {
#line 2020
      optbuf[0] = (char )'\000';
#line 2021
      bufp = optbuf;
    }
  } else {
#line 2020
    optbuf[0] = (char )'\000';
#line 2021
    bufp = optbuf;
  }
#line 2024
  bodytype = e->e_bodytype;
#line 2025
  if ((mci->mci_flags & 64UL) != 0UL) {
#line 2027
    if ((unsigned long )bodytype == (unsigned long )((void *)0)) {
#line 2027
      if ((MimeMode & 4) != 0) {
#line 2027
        if ((e->e_flags & 131072UL) != 0UL) {
#line 2027
          if (! ((e->e_flags & 8388608UL) != 0UL)) {
#line 2027
            if (! (m->m_flags[56UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 56UL % (8UL * sizeof(int ))))) {
#line 2032
              bodytype = (char *)"8BITMIME";
            }
          }
        }
      }
    }
#line 2033
    if ((unsigned long )bodytype != (unsigned long )((void *)0)) {
      {
#line 2033
      tmp___2 = strlen((char const   *)bodytype);
      }
#line 2033
      if (sizeof(optbuf) - (unsigned long )(bufp - optbuf) > (unsigned long )(tmp___2 + 7U)) {
        {
#line 2036
        sm_snprintf(bufp, (size_t )(sizeof(optbuf) - (unsigned long )(bufp - optbuf)),
                    " BODY=%s", bodytype);
#line 2038
        tmp___1 = strlen((char const   *)bufp);
#line 2038
        bufp += tmp___1;
        }
      }
    }
  } else
#line 2041
  if (! (m->m_flags[56UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 56UL % (8UL * sizeof(int ))))) {
#line 2041
    if (! (! ((e->e_flags & 131072UL) != 0UL))) {
#line 2041
      if (! ((mci->mci_flags & 4096UL) != 0UL)) {
#line 2049
        if ((MimeMode & 1) != 0) {
#line 2049
          if (! ((e->e_flags & 8388608UL) != 0UL)) {
#line 2049
            if (! ((MimeMode & 2) != 0)) {
#line 2055
              mci->mci_flags |= 1024UL;
            } else
#line 2049
            if ((e->e_flags & 4194304UL) != 0UL) {
#line 2055
              mci->mci_flags |= 1024UL;
            } else {
#line 2049
              goto _L___0;
            }
          } else {
#line 2049
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 2058
        if (! ((MimeMode & 2) != 0)) {
          {
#line 2063
          usrerrenh((char *)"5.6.3", "%s does not support 8BITMIME", CurHostName);
#line 2064
          mci_setstat(mci, -5, (char *)"5.6.3", MsgBuf);
          }
#line 2065
          return (65);
        }
      }
    }
  }
#line 2068
  if ((mci->mci_flags & 2048UL) != 0UL) {
#line 2070
    if ((unsigned long )e->e_envid != (unsigned long )((void *)0)) {
      {
#line 2070
      tmp___4 = strlen((char const   *)e->e_envid);
      }
#line 2070
      if (sizeof(optbuf) - (unsigned long )(bufp - optbuf) > (unsigned long )(tmp___4 + 7U)) {
        {
#line 2073
        sm_snprintf(bufp, (size_t )(sizeof(optbuf) - (unsigned long )(bufp - optbuf)),
                    " ENVID=%s", e->e_envid);
#line 2075
        tmp___3 = strlen((char const   *)bufp);
#line 2075
        bufp += tmp___3;
        }
      }
    }
#line 2079
    if ((e->e_flags & 1048576UL) != 0UL) {
#line 2079
      if (sizeof(optbuf) - (unsigned long )(bufp - optbuf) > 9UL) {
#line 2082
        if ((e->e_flags & 4UL) != 0UL) {
#line 2082
          tmp___5 = "HDRS";
        } else {
#line 2082
          tmp___5 = "FULL";
        }
        {
#line 2082
        sm_snprintf(bufp, (size_t )(sizeof(optbuf) - (unsigned long )(bufp - optbuf)),
                    " RET=%s", tmp___5);
#line 2086
        tmp___6 = strlen((char const   *)bufp);
#line 2086
        bufp += tmp___6;
        }
      }
    }
  }
#line 2090
  if ((mci->mci_flags & 32768UL) != 0UL) {
#line 2090
    if ((unsigned long )e->e_auth_param != (unsigned long )((void *)0)) {
      {
#line 2090
      tmp___8 = strlen((char const   *)e->e_auth_param);
      }
#line 2090
      if (sizeof(optbuf) - (unsigned long )(bufp - optbuf) > (unsigned long )(tmp___8 + 7U)) {
        {
#line 2097
        sm_snprintf(bufp, (size_t )(sizeof(optbuf) - (unsigned long )(bufp - optbuf)),
                    " AUTH=%s", e->e_auth_param);
#line 2099
        tmp___7 = strlen((char const   *)bufp);
#line 2099
        bufp += tmp___7;
        }
      }
    }
  }
#line 2107
  if ((mci->mci_flags & 4194304UL) != 0UL) {
#line 2107
    if (e->e_dlvr_flag != 0) {
#line 2107
      if (sizeof(optbuf) - (unsigned long )(bufp - optbuf) > 17UL) {
        {
#line 2119
        tmp___9 = curtime();
#line 2119
        dby = e->e_deliver_by - (tmp___9 - e->e_ctime);
        }
#line 2120
        if (dby <= 0L) {
#line 2120
          if ((e->e_dlvr_flag & 2) != 0) {
#line 2121
            if (mci->mci_min_by <= 0L) {
#line 2121
              dby = 1L;
            } else {
#line 2121
              dby = mci->mci_min_by;
            }
          }
        }
#line 2122
        if ((e->e_dlvr_flag & 16) != 0) {
#line 2122
          tmp___10 = "T";
        } else {
#line 2122
          tmp___10 = "";
        }
#line 2122
        if ((e->e_dlvr_flag & 2) != 0) {
#line 2122
          tmp___11 = 'R';
        } else {
#line 2122
          tmp___11 = 'N';
        }
        {
#line 2122
        sm_snprintf(bufp, (size_t )(sizeof(optbuf) - (unsigned long )(bufp - optbuf)),
                    " BY=%ld;%c%s", dby, tmp___11, tmp___10);
#line 2127
        tmp___12 = strlen((char const   *)bufp);
#line 2127
        bufp += tmp___12;
        }
      }
    }
  }
#line 2135
  mci->mci_state = (short)3;
#line 2137
  if ((e->e_flags & 128UL) != 0UL) {
#line 2137
    if (! (m->m_flags[103UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 103UL % (8UL * sizeof(int ))))) {
#line 2139
      buf___16[0] = (char )'\000';
    } else {
      {
#line 2141
      expand((char *)"\201g", buf___16, (size_t )sizeof(buf___16), e);
      }
    }
  } else {
    {
#line 2141
    expand((char *)"\201g", buf___16, (size_t )sizeof(buf___16), e);
    }
  }
#line 2142
  if ((int )buf___16[0] == 60) {
    {
#line 2145
    tmp___13 = strlen((char const   *)(buf___16));
#line 2145
    bufp = & buf___16[tmp___13 - 1U];
    }
#line 2146
    if ((int )*bufp == 62) {
#line 2147
      *bufp = (char )'\000';
    }
#line 2148
    bufp = & buf___16[1];
  } else {
#line 2151
    bufp = buf___16;
  }
#line 2152
  if ((e->e_from.q_mailer)->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int )))) {
    {
#line 2155
    smtpmessage((char *)"MAIL From:<%s>%s", m, mci, bufp, optbuf);
    }
  } else
#line 2152
  if (! (m->m_flags[112UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 112UL % (8UL * sizeof(int ))))) {
    {
#line 2155
    smtpmessage((char *)"MAIL From:<%s>%s", m, mci, bufp, optbuf);
    }
  } else {
#line 2159
    if ((int )*bufp == 64) {
#line 2159
      tmp___14 = ',';
    } else {
#line 2159
      tmp___14 = ':';
    }
    {
#line 2159
    smtpmessage((char *)"MAIL From:<@%s%c%s>%s", m, mci, MyHostName, tmp___14, bufp,
                optbuf);
    }
  }
  {
#line 2162
  tmp___15 = (char *)"client MAIL";
#line 2162
  mci->mci_phase = tmp___15;
#line 2162
  SmtpPhase = tmp___15;
#line 2163
  tmp___16 = qid_printname(e);
#line 2163
  sm_setproctitle(1, e, "%s %s: %s", tmp___16, CurHostName, mci->mci_phase);
#line 2165
  r = reply(m, mci, e, TimeOuts.to_mail, (void (*)(char * , bool  , MAILER * , struct mailer_con_info * ,
                                                   ENVELOPE * ))((void *)0), & enhsc,
            0);
  }
#line 2166
  if (r < 0) {
    {
#line 2169
    mci_setstat(mci, 75, (char *)"4.4.2", (char *)((void *)0));
    }
#line 2170
    return (75);
  } else
#line 2172
  if (r == 421) {
#line 2175
    return (75);
  } else
#line 2177
  if (r / 100 == 4) {
#line 2179
    if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
      {
#line 2179
      tmp___17 = smtptodsn(r);
#line 2179
      tmp___18 = tmp___17;
      }
    } else {
#line 2179
      tmp___18 = enhsc;
    }
    {
#line 2179
    mci_setstat(mci, -5, tmp___18, SmtpReplyBuffer);
    }
#line 2181
    return (75);
  } else
#line 2183
  if (r / 100 == 2) {
#line 2185
    return (0);
  } else
#line 2187
  if (r == 501) {
#line 2190
    if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 2190
      tmp___19 = "5.5.2";
    } else {
#line 2190
      tmp___19 = (char const   *)enhsc;
    }
    {
#line 2190
    mci_setstat(mci, -5, (char *)tmp___19, SmtpReplyBuffer);
    }
#line 2192
    return (65);
  } else
#line 2194
  if (r == 553) {
#line 2197
    if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 2197
      tmp___20 = "5.1.3";
    } else {
#line 2197
      tmp___20 = (char const   *)enhsc;
    }
    {
#line 2197
    mci_setstat(mci, -5, (char *)tmp___20, SmtpReplyBuffer);
    }
#line 2199
    return (65);
  } else
#line 2201
  if (r == 552) {
#line 2204
    if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 2204
      tmp___21 = "5.3.4";
    } else {
#line 2204
      tmp___21 = (char const   *)enhsc;
    }
    {
#line 2204
    mci_setstat(mci, -5, (char *)tmp___21, SmtpReplyBuffer);
    }
#line 2206
    if ((mci->mci_flags & 32UL) != 0UL) {
#line 2207
      e->e_flags |= 4UL;
    }
#line 2208
    return (69);
  } else
#line 2210
  if (r / 100 == 5) {
#line 2213
    if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 2213
      tmp___22 = "5.0.0";
    } else {
#line 2213
      tmp___22 = (char const   *)enhsc;
    }
    {
#line 2213
    mci_setstat(mci, -5, (char *)tmp___22, SmtpReplyBuffer);
    }
#line 2215
    return (69);
  }
#line 2218
  if (LogLevel > 1) {
    {
#line 2220
    tmp___23 = shortenstring((char const   *)(SmtpReplyBuffer), (size_t )403);
#line 2220
    sm_syslog(2, (char const   *)e->e_id, "%.100s: SMTP MAIL protocol error: %s",
              CurHostName, tmp___23);
    }
  }
#line 2227
  if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 2227
    tmp___24 = "5.5.1";
  } else {
#line 2227
    tmp___24 = (char const   *)enhsc;
  }
  {
#line 2227
  mci_setstat(mci, 76, (char *)tmp___24, SmtpReplyBuffer);
#line 2229
  smtpquit(m, mci, e);
  }
#line 2230
  return (76);
}
}
#line 2248 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
int smtprcpt(ADDRESS *to , MAILER *m , struct mailer_con_info *mci , ENVELOPE *e ,
             ADDRESS *ctladdr , time_t xstart ) 
{ 
  char *bufp ;
  char optbuf[2048] ;
  int r ;
  int tmp ;
  int *tmp___0 ;
  bool firstone ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 2266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2266
    if ((unsigned long )mci->mci_nextaddr != (unsigned long )((void *)0)) {
      {
#line 2266
      tmp = sm_io_getinfo(mci->mci_in, 6, (void *)0);
      }
#line 2266
      if (! (tmp > 0)) {
#line 2266
        goto while_break;
      }
    } else {
#line 2266
      goto while_break;
    }
    {
#line 2271
    r = smtprcptstat(mci->mci_nextaddr, m, mci, e);
    }
#line 2272
    if (r != 0) {
      {
#line 2274
      markfailure(e, mci->mci_nextaddr, mci, r, 0);
#line 2275
      giveresponse(r, (mci->mci_nextaddr)->q_status, m, mci, ctladdr, xstart, e, to);
      }
    }
#line 2278
    mci->mci_nextaddr = (mci->mci_nextaddr)->q_pchain;
  }
  while_break: /* CIL Label */ ;
  }
#line 2288
  if ((int )mci->mci_state == 0) {
    {
#line 2290
    tmp___0 = __errno_location();
#line 2290
    *tmp___0 = (int )mci->mci_errno;
    }
#line 2291
    return (75);
  }
#line 2294
  optbuf[0] = (char )'\000';
#line 2295
  bufp = optbuf;
#line 2302
  if ((mci->mci_flags & 2048UL) != 0UL) {
#line 2304
    if ((e->e_dlvr_flag & 1) != 0) {
#line 2304
      if (! ((mci->mci_flags & 4194304UL) != 0UL)) {
#line 2308
        if (! ((to->q_flags & 512UL) != 0UL)) {
#line 2309
          to->q_flags |= 896UL;
        } else
#line 2310
        if ((to->q_flags & 64UL) != 0UL) {
#line 2313
          to->q_flags |= 256UL;
        } else
#line 2310
        if ((to->q_flags & 128UL) != 0UL) {
#line 2313
          to->q_flags |= 256UL;
        } else
#line 2310
        if ((to->q_flags & 256UL) != 0UL) {
#line 2313
          to->q_flags |= 256UL;
        }
      }
    }
#line 2317
    if ((to->q_flags & 512UL) != 0UL) {
#line 2317
      if ((to->q_flags & 2UL) != 0UL) {
#line 2317
        if (! (m->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int ))))) {
          {
#line 2321
          firstone = 1;
#line 2323
          sm_strlcat(bufp, " NOTIFY=", (ssize_t )sizeof(optbuf));
          }
#line 2324
          if ((to->q_flags & 64UL) != 0UL) {
            {
#line 2326
            sm_strlcat(bufp, "SUCCESS", (ssize_t )sizeof(optbuf));
#line 2327
            firstone = 0;
            }
          }
#line 2329
          if ((to->q_flags & 128UL) != 0UL) {
#line 2331
            if (! firstone) {
              {
#line 2332
              sm_strlcat(bufp, ",", (ssize_t )sizeof(optbuf));
              }
            }
            {
#line 2334
            sm_strlcat(bufp, "FAILURE", (ssize_t )sizeof(optbuf));
#line 2335
            firstone = 0;
            }
          }
#line 2337
          if ((to->q_flags & 256UL) != 0UL) {
#line 2339
            if (! firstone) {
              {
#line 2340
              sm_strlcat(bufp, ",", (ssize_t )sizeof(optbuf));
              }
            }
            {
#line 2342
            sm_strlcat(bufp, "DELAY", (ssize_t )sizeof(optbuf));
#line 2343
            firstone = 0;
            }
          }
#line 2345
          if (firstone) {
            {
#line 2346
            sm_strlcat(bufp, "NEVER", (ssize_t )sizeof(optbuf));
            }
          }
          {
#line 2347
          tmp___1 = strlen((char const   *)bufp);
#line 2347
          bufp += tmp___1;
          }
        }
      }
    }
#line 2351
    if ((unsigned long )to->q_orcpt != (unsigned long )((void *)0)) {
      {
#line 2351
      tmp___3 = strlen((char const   *)to->q_orcpt);
      }
#line 2351
      if (sizeof(optbuf) - (unsigned long )(bufp - optbuf) > (unsigned long )(tmp___3 + 7U)) {
        {
#line 2354
        sm_snprintf(bufp, (size_t )(sizeof(optbuf) - (unsigned long )(bufp - optbuf)),
                    " ORCPT=%s", to->q_orcpt);
#line 2356
        tmp___2 = strlen((char const   *)bufp);
#line 2356
        bufp += tmp___2;
        }
      }
    }
  }
  {
#line 2360
  smtpmessage((char *)"RCPT To:<%s>%s", m, mci, to->q_user, optbuf);
#line 2361
  mci->mci_state = (short)4;
#line 2363
  tmp___4 = (char *)"client RCPT";
#line 2363
  mci->mci_phase = tmp___4;
#line 2363
  SmtpPhase = tmp___4;
#line 2364
  tmp___5 = qid_printname(e);
#line 2364
  sm_setproctitle(1, e, "%s %s: %s", tmp___5, CurHostName, mci->mci_phase);
  }
#line 2372
  if ((mci->mci_flags & 262144UL) != 0UL) {
#line 2373
    return (0);
  }
  {
#line 2376
  tmp___6 = smtprcptstat(to, m, mci, e);
  }
#line 2376
  return (tmp___6);
}
}
#line 2393 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
static int smtprcptstat(ADDRESS *to , MAILER *m , struct mailer_con_info *mci , ENVELOPE *e ) 
{ 
  int r ;
  int save_errno ;
  char *enhsc ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *t ;
  char *p ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 2410
  if ((int )mci->mci_state == 0) {
    {
#line 2412
    tmp = __errno_location();
#line 2412
    *tmp = (int )mci->mci_errno;
    }
#line 2413
    return (75);
  }
  {
#line 2416
  enhsc = (char *)((void *)0);
#line 2417
  r = reply(m, mci, e, TimeOuts.to_rcpt, (void (*)(char * , bool  , MAILER * , struct mailer_con_info * ,
                                                   ENVELOPE * ))((void *)0), & enhsc,
            0);
#line 2418
  tmp___0 = __errno_location();
#line 2418
  save_errno = *tmp___0;
#line 2419
  to->q_rstatus = sm_rpool_strdup_x(e->e_rpool, (char const   *)(SmtpReplyBuffer));
  }
#line 2420
  if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
    {
#line 2420
    tmp___1 = smtptodsn(r);
#line 2420
    to->q_status = tmp___1;
    }
  } else {
    {
#line 2420
    tmp___2 = sm_rpool_strdup_x(e->e_rpool, (char const   *)enhsc);
#line 2420
    to->q_status = tmp___2;
    }
  }
#line 2421
  if (! (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int ))))) {
#line 2422
    to->q_statmta = mci->mci_host;
  }
#line 2423
  if (r < 0) {
    {
#line 2425
    mci->mci_retryrcpt = 1;
#line 2426
    tmp___3 = __errno_location();
#line 2426
    *tmp___3 = save_errno;
    }
#line 2427
    return (75);
  } else
#line 2423
  if (r / 100 == 4) {
    {
#line 2425
    mci->mci_retryrcpt = 1;
#line 2426
    tmp___3 = __errno_location();
#line 2426
    *tmp___3 = save_errno;
    }
#line 2427
    return (75);
  } else
#line 2429
  if (r / 100 == 2) {
#line 2433
    t = mci->mci_tolist;
#line 2433
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 2437
      tmp___4 = t;
#line 2437
      t ++;
#line 2437
      *tmp___4 = (char )',';
#line 2438
      p = to->q_paddr;
      {
#line 2438
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2438
        if (! ((int )*p != 0)) {
#line 2438
          goto while_break;
        }
#line 2439
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 2438
        tmp___5 = t;
#line 2438
        t ++;
#line 2438
        tmp___6 = p;
#line 2438
        p ++;
#line 2438
        *tmp___5 = *tmp___6;
      }
      while_break: /* CIL Label */ ;
      }
#line 2440
      *t = (char )'\000';
#line 2441
      mci->mci_tolist = t;
    }
#line 2444
    (mci->mci_okrcpts) ++;
#line 2446
    return (0);
  } else
#line 2448
  if (r == 550) {
#line 2450
    if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 2450
      to->q_status = (char *)"5.1.1";
    } else {
      {
#line 2450
      tmp___7 = sm_rpool_strdup_x(e->e_rpool, (char const   *)enhsc);
#line 2450
      to->q_status = tmp___7;
      }
    }
#line 2451
    return (67);
  } else
#line 2453
  if (r == 551) {
#line 2455
    if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 2455
      to->q_status = (char *)"5.1.6";
    } else {
      {
#line 2455
      tmp___8 = sm_rpool_strdup_x(e->e_rpool, (char const   *)enhsc);
#line 2455
      to->q_status = tmp___8;
      }
    }
#line 2456
    return (67);
  } else
#line 2458
  if (r == 553) {
#line 2460
    if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 2460
      to->q_status = (char *)"5.1.3";
    } else {
      {
#line 2460
      tmp___9 = sm_rpool_strdup_x(e->e_rpool, (char const   *)enhsc);
#line 2460
      to->q_status = tmp___9;
      }
    }
#line 2461
    return (67);
  } else
#line 2463
  if (r / 100 == 5) {
#line 2465
    return (69);
  }
#line 2468
  if (LogLevel > 1) {
    {
#line 2470
    tmp___10 = shortenstring((char const   *)(SmtpReplyBuffer), (size_t )403);
#line 2470
    sm_syslog(2, (char const   *)e->e_id, "%.100s: SMTP RCPT protocol error: %s",
              CurHostName, tmp___10);
    }
  }
#line 2476
  if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 2476
    tmp___11 = "5.5.1";
  } else {
#line 2476
    tmp___11 = (char const   *)enhsc;
  }
  {
#line 2476
  mci_setstat(mci, 76, (char *)tmp___11, SmtpReplyBuffer);
  }
#line 2478
  return (76);
}
}
#line 2492 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
int smtpdata(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e , ADDRESS *ctladdr ,
             time_t xstart ) 
{ 
  register int r ;
  int rstat ;
  int xstat ;
  int timeout ;
  char *enhsc ;
  int *tmp ;
  char *oldto ;
  int r___0 ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
#line 2512
  if ((int )mci->mci_state == 0) {
    {
#line 2514
    tmp = __errno_location();
#line 2514
    *tmp = (int )mci->mci_errno;
    }
#line 2515
    return (75);
  }
  {
#line 2518
  enhsc = (char *)((void *)0);
#line 2529
  smtpmessage((char *)"DATA", m, mci);
  }
#line 2532
  if ((unsigned long )mci->mci_nextaddr != (unsigned long )((void *)0)) {
#line 2534
    oldto = e->e_to;
    {
#line 2537
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2537
      if (! ((unsigned long )mci->mci_nextaddr != (unsigned long )((void *)0))) {
#line 2537
        goto while_break;
      }
      {
#line 2541
      e->e_to = (mci->mci_nextaddr)->q_paddr;
#line 2542
      r___0 = smtprcptstat(mci->mci_nextaddr, m, mci, e);
      }
#line 2543
      if (r___0 != 0) {
        {
#line 2545
        markfailure(e, mci->mci_nextaddr, mci, r___0, 0);
#line 2547
        giveresponse(r___0, (mci->mci_nextaddr)->q_status, m, mci, ctladdr, xstart,
                     e, mci->mci_nextaddr);
        }
#line 2550
        if (r___0 == 75) {
#line 2551
          (mci->mci_nextaddr)->q_state = (short)4;
        }
      }
#line 2553
      mci->mci_nextaddr = (mci->mci_nextaddr)->q_pchain;
    }
    while_break: /* CIL Label */ ;
    }
#line 2555
    e->e_to = oldto;
#line 2565
    if ((int )mci->mci_state == 0) {
      {
#line 2567
      tmp___0 = __errno_location();
#line 2567
      *tmp___0 = (int )mci->mci_errno;
      }
#line 2568
      return (75);
    }
  }
  {
#line 2574
  tmp___1 = (char *)"client DATA 354";
#line 2574
  mci->mci_phase = tmp___1;
#line 2574
  SmtpPhase = tmp___1;
#line 2575
  mci->mci_state = (short)5;
#line 2576
  tmp___2 = qid_printname(e);
#line 2576
  sm_setproctitle(1, e, "%s %s: %s", tmp___2, CurHostName, mci->mci_phase);
#line 2578
  r = reply(m, mci, e, TimeOuts.to_datainit, (void (*)(char * , bool  , MAILER * ,
                                                       struct mailer_con_info * ,
                                                       ENVELOPE * ))((void *)0), & enhsc,
            0);
  }
#line 2579
  if (r < 0) {
#line 2579
    goto _L;
  } else
#line 2579
  if (r / 100 == 4) {
    _L: /* CIL Label */ 
#line 2581
    if (r >= 0) {
      {
#line 2582
      smtpquit(m, mci, e);
      }
    }
    {
#line 2583
    tmp___3 = __errno_location();
#line 2583
    *tmp___3 = (int )mci->mci_errno;
    }
#line 2584
    return (75);
  } else
#line 2586
  if (r / 100 == 5) {
    {
#line 2588
    smtprset(m, mci, e);
    }
#line 2590
    if (mci->mci_okrcpts <= 0) {
#line 2591
      if (mci->mci_retryrcpt) {
#line 2591
        tmp___4 = 75;
      } else {
#line 2591
        tmp___4 = 69;
      }
#line 2591
      return (tmp___4);
    }
#line 2594
    return (69);
  } else
#line 2596
  if (r / 100 != 3) {
#line 2598
    if (LogLevel > 1) {
      {
#line 2600
      tmp___5 = shortenstring((char const   *)(SmtpReplyBuffer), (size_t )403);
#line 2600
      sm_syslog(2, (char const   *)e->e_id, "%.100s: SMTP DATA-1 protocol error: %s",
                CurHostName, tmp___5);
      }
    }
    {
#line 2605
    smtprset(m, mci, e);
    }
#line 2606
    if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 2606
      tmp___6 = "5.5.1";
    } else {
#line 2606
      tmp___6 = (char const   *)enhsc;
    }
    {
#line 2606
    mci_setstat(mci, 76, (char *)tmp___6, SmtpReplyBuffer);
    }
#line 2609
    if (mci->mci_okrcpts <= 0) {
#line 2610
      if (mci->mci_retryrcpt) {
#line 2610
        tmp___7 = 75;
      } else {
#line 2610
        tmp___7 = 76;
      }
#line 2610
      return (tmp___7);
    }
#line 2613
    return (76);
  }
#line 2617
  if (mci->mci_okrcpts > 0) {
#line 2627
    if ((int )tTdvect[18] >= 101) {
#line 2630
      timeout = 10;
    } else {
#line 2633
      timeout = 300000;
    }
    {
#line 2634
    sm_io_setinfo(mci->mci_out, 7, (void *)(& timeout));
#line 2641
    tmp___8 = (*(e->e_puthdr))(mci, e->e_header, e, 0);
    }
#line 2641
    if (! tmp___8) {
#line 2642
      goto writeerr;
    }
#line 2644
    if ((int )tTdvect[18] >= 101) {
      {
#line 2647
      sleep(2U);
      }
    }
    {
#line 2650
    tmp___9 = (*(e->e_putbody))(mci, e, (char *)((void *)0));
    }
#line 2650
    if (! tmp___9) {
#line 2651
      goto writeerr;
    }
  }
#line 2685
  if (((mci->mci_out)->f_flags & 256L) != 0L) {
    {
#line 2688
    mci->mci_errno = (short)5;
#line 2689
    mci->mci_state = (short)8;
#line 2690
    mci_setstat(mci, 74, (char *)"4.4.2", (char *)((void *)0));
#line 2691
    smtpquit(m, mci, e);
    }
#line 2692
    return (74);
  }
  {
#line 2696
  tmp___10 = sm_io_fprintf(mci->mci_out, -2, ".%s", m->m_eol);
  }
#line 2696
  if (tmp___10 == -1) {
#line 2698
    goto writeerr;
  }
#line 2699
  if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
    {
#line 2700
    sm_io_fprintf(TrafficLogFile, -2, "%05d >>> .\n", CurrentPid);
    }
  }
#line 2702
  if (Verbose) {
    {
#line 2703
    nmessage(">>> .");
    }
  }
  {
#line 2706
  tmp___11 = (char *)"client DATA status";
#line 2706
  mci->mci_phase = tmp___11;
#line 2706
  SmtpPhase = tmp___11;
#line 2707
  tmp___12 = qid_printname(e);
#line 2707
  sm_setproctitle(1, e, "%s %s: %s", tmp___12, CurHostName, mci->mci_phase);
  }
#line 2709
  if (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int )))) {
#line 2710
    return (0);
  }
  {
#line 2711
  r = reply(m, mci, e, TimeOuts.to_datafinal, (void (*)(char * , bool  , MAILER * ,
                                                        struct mailer_con_info * ,
                                                        ENVELOPE * ))((void *)0),
            & enhsc, 0);
  }
#line 2712
  if (r < 0) {
#line 2713
    return (75);
  }
#line 2714
  if ((int )mci->mci_state == 5) {
#line 2715
    mci->mci_state = (short)2;
  }
#line 2716
  xstat = -5;
#line 2717
  if (r == 452) {
#line 2718
    rstat = 75;
  } else
#line 2719
  if (r / 100 == 4) {
#line 2720
    xstat = 75;
#line 2720
    rstat = xstat;
  } else
#line 2721
  if (r / 100 == 2) {
#line 2722
    xstat = 0;
#line 2722
    rstat = xstat;
  } else
#line 2723
  if ((r / 10) % 10 != 5) {
#line 2724
    xstat = 76;
#line 2724
    rstat = xstat;
  } else
#line 2725
  if (r / 100 == 5) {
#line 2726
    rstat = 69;
  } else {
#line 2728
    rstat = 76;
  }
#line 2729
  if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
    {
#line 2729
    tmp___13 = smtptodsn(r);
#line 2729
    tmp___14 = tmp___13;
    }
  } else {
#line 2729
    tmp___14 = enhsc;
  }
  {
#line 2729
  mci_setstat(mci, xstat, tmp___14, SmtpReplyBuffer);
  }
#line 2731
  if ((mci->mci_flags & 131072UL) != 0UL) {
    {
#line 2731
    r = isenhsc((char const   *)(SmtpReplyBuffer + 4), ' ');
    }
#line 2731
    if (r > 0) {
#line 2733
      r += 5;
    } else {
#line 2735
      r = 4;
    }
  } else {
#line 2735
    r = 4;
  }
  {
#line 2736
  e->e_statmsg = sm_rpool_strdup_x(e->e_rpool, (char const   *)(& SmtpReplyBuffer[r]));
#line 2737
  tmp___15 = (char *)"idle";
#line 2737
  mci->mci_phase = tmp___15;
#line 2737
  SmtpPhase = tmp___15;
#line 2738
  sm_setproctitle(1, e, "%s: %s", CurHostName, mci->mci_phase);
  }
#line 2739
  if (rstat != 76) {
#line 2740
    return (rstat);
  }
#line 2741
  if (LogLevel > 1) {
    {
#line 2743
    tmp___16 = shortenstring((char const   *)(SmtpReplyBuffer), (size_t )403);
#line 2743
    sm_syslog(2, (char const   *)e->e_id, "%.100s: SMTP DATA-2 protocol error: %s",
              CurHostName, tmp___16);
    }
  }
#line 2748
  return (rstat);
  writeerr: 
  {
#line 2751
  tmp___17 = __errno_location();
#line 2751
  mci->mci_errno = (short )*tmp___17;
#line 2752
  mci->mci_state = (short)8;
#line 2753
  mci_setstat(mci, 75, (char *)"4.4.2", (char *)((void *)0));
  }
#line 2761
  if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
    {
#line 2762
    bfrewind(e->e_dfp);
    }
  }
  {
#line 2764
  tmp___18 = __errno_location();
#line 2764
  *tmp___18 = (int )mci->mci_errno;
#line 2765
  syserr("451 4.4.1 timeout writing message to %s", CurHostName);
#line 2766
  smtpquit(m, mci, e);
  }
#line 2767
  return (75);
}
}
#line 2782 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
int smtpgetstat(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e ) 
{ 
  int r ;
  int off ;
  int status ;
  int xstat ;
  char *enhsc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp12 ;

  {
  {
#line 2793
  enhsc = (char *)((void *)0);
#line 2796
  r = reply(m, mci, e, TimeOuts.to_datafinal, (void (*)(char * , bool  , MAILER * ,
                                                        struct mailer_con_info * ,
                                                        ENVELOPE * ))((void *)0),
            & enhsc, 0);
  }
#line 2797
  if (r < 0) {
#line 2798
    return (75);
  }
#line 2799
  xstat = -5;
#line 2800
  if (r / 100 == 4) {
#line 2801
    status = 75;
  } else
#line 2802
  if (r / 100 == 2) {
#line 2803
    xstat = 0;
#line 2803
    status = xstat;
  } else
#line 2804
  if ((r / 10) % 10 != 5) {
#line 2805
    xstat = 76;
#line 2805
    status = xstat;
  } else
#line 2806
  if (r / 100 == 5) {
#line 2807
    status = 69;
  } else {
#line 2809
    status = 76;
  }
#line 2810
  if ((mci->mci_flags & 131072UL) != 0UL) {
    {
#line 2810
    off = isenhsc((char const   *)(SmtpReplyBuffer + 4), ' ');
    }
#line 2810
    if (off > 0) {
#line 2812
      off += 5;
    } else {
#line 2814
      off = 4;
    }
  } else {
#line 2814
    off = 4;
  }
  {
#line 2815
  e->e_statmsg = sm_rpool_strdup_x(e->e_rpool, (char const   *)(& SmtpReplyBuffer[off]));
  }
#line 2816
  if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
    {
#line 2816
    tmp = smtptodsn(r);
#line 2816
    tmp___0 = tmp;
    }
  } else {
#line 2816
    tmp___0 = enhsc;
  }
  {
#line 2816
  mci_setstat(mci, xstat, tmp___0, SmtpReplyBuffer);
  }
#line 2817
  if (LogLevel > 1) {
#line 2817
    if (status == 76) {
      {
#line 2819
      tmp___1 = shortenstring((char const   *)(SmtpReplyBuffer), (size_t )403);
#line 2819
      sm_syslog(2, (char const   *)e->e_id, "%.100s: SMTP DATA-3 protocol error: %s",
                CurHostName, tmp___1);
      }
    }
  }
#line 2824
  return (status);
}
}
#line 2841 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
void smtpquit(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e ) 
{ 
  bool oldSuprErrs ;
  int rcode ;
  char *oldcurhost ;
  char *mailer ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 2847
  oldSuprErrs = SuprErrs;
#line 2851
  if ((int )mci->mci_state == 0) {
    {
#line 2853
    mci_close(mci, (char *)"smtpquit:1");
    }
#line 2854
    return;
  }
#line 2857
  oldcurhost = CurHostName;
#line 2858
  CurHostName = mci->mci_host;
#line 2859
  if ((unsigned long )CurHostName == (unsigned long )((void *)0)) {
#line 2860
    CurHostName = MyHostName;
  }
#line 2863
  mci->mci_okrcpts = 0;
#line 2873
  SuprErrs = 1;
#line 2876
  if ((int )mci->mci_state != 8) {
#line 2876
    if ((int )mci->mci_state != 6) {
      {
#line 2879
      SmtpPhase = (char *)"client QUIT";
#line 2880
      mci->mci_state = (short)6;
#line 2881
      smtpmessage((char *)"QUIT", m, mci);
#line 2882
      reply(m, mci, e, TimeOuts.to_quit, (void (*)(char * , bool  , MAILER * , struct mailer_con_info * ,
                                                   ENVELOPE * ))((void *)0), (char **)((void *)0),
            0);
#line 2884
      SuprErrs = oldSuprErrs;
      }
#line 2885
      if ((int )mci->mci_state == 0) {
#line 2886
        goto end;
      }
    }
  }
  {
#line 2890
  rcode = endmailer(mci, e, (char **)((void *)0));
  }
#line 2891
  if (rcode != 0) {
#line 2893
    mailer = (char *)((void *)0);
#line 2895
    if ((unsigned long )mci->mci_mailer != (unsigned long )((void *)0)) {
#line 2895
      if ((unsigned long )(mci->mci_mailer)->m_name != (unsigned long )((void *)0)) {
#line 2897
        mailer = (mci->mci_mailer)->m_name;
      }
    }
#line 2900
    if ((unsigned long )mailer == (unsigned long )((void *)0)) {
#line 2900
      tmp = "";
    } else {
#line 2900
      tmp = (char const   *)mailer;
    }
#line 2900
    if ((unsigned long )mailer == (unsigned long )((void *)0)) {
#line 2900
      tmp___0 = "";
    } else {
#line 2900
      tmp___0 = " ";
    }
    {
#line 2900
    sm_syslog(3, (char const   *)e->e_id, "smtpquit: mailer%s%s exited with exit value %d",
              tmp___0, tmp, rcode);
    }
  }
#line 2907
  SuprErrs = oldSuprErrs;
  end: 
#line 2910
  CurHostName = oldcurhost;
#line 2911
  return;
}
}
#line 2928 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
void smtprset(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e ) 
{ 
  int r ;
  int *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2936
  CurHostName = mci->mci_host;
#line 2937
  if ((unsigned long )CurHostName == (unsigned long )((void *)0)) {
#line 2938
    CurHostName = MyHostName;
  }
#line 2941
  mci->mci_okrcpts = 0;
#line 2950
  if ((int )mci->mci_state == 0) {
    {
#line 2952
    tmp = __errno_location();
#line 2952
    *tmp = (int )mci->mci_errno;
    }
#line 2953
    return;
  }
  {
#line 2956
  SmtpPhase = (char *)"client RSET";
#line 2957
  smtpmessage((char *)"RSET", m, mci);
#line 2958
  r = reply(m, mci, e, TimeOuts.to_rset, (void (*)(char * , bool  , MAILER * , struct mailer_con_info * ,
                                                   ENVELOPE * ))((void *)0), (char **)((void *)0),
            0);
  }
#line 2959
  if (r < 0) {
#line 2960
    return;
  }
#line 2973
  if ((int )mci->mci_state != 7) {
#line 2973
    if ((int )mci->mci_state != 0) {
#line 2974
      mci->mci_state = (short)2;
    } else {
#line 2973
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2975
  if ((int )mci->mci_exitstat == 0) {
    {
#line 2976
    mci_setstat(mci, 75, (char *)"4.5.0", (char *)((void *)0));
    }
  }
#line 2977
  return;
}
}
#line 2991 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
int smtpprobe(struct mailer_con_info *mci ) 
{ 
  int r ;
  MAILER *m ;
  ENVELOPE *e ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 2996
  m = mci->mci_mailer;
#line 3000
  CurHostName = mci->mci_host;
#line 3001
  if ((unsigned long )CurHostName == (unsigned long )((void *)0)) {
#line 3002
    CurHostName = MyHostName;
  }
  {
#line 3004
  e = & BlankEnvelope;
#line 3005
  SmtpPhase = (char *)"client probe";
#line 3006
  smtpmessage((char *)"RSET", m, mci);
#line 3007
  r = reply(m, mci, e, TimeOuts.to_miscshort, (void (*)(char * , bool  , MAILER * ,
                                                        struct mailer_con_info * ,
                                                        ENVELOPE * ))((void *)0),
            (char **)((void *)0), 0);
  }
#line 3008
  if (r / 100 != 2) {
    {
#line 3009
    smtpquit(m, mci, e);
    }
  }
#line 3010
  return (r);
}
}
#line 3046 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
static char enhstatcode[10]  ;
#line 3032 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
int reply(MAILER *m , struct mailer_con_info *mci , ENVELOPE *e , time_t timeout ,
          void (*pfunc)(char * , bool  , MAILER * , struct mailer_con_info * , ENVELOPE * ) ,
          char **enhstat , int rtype ) 
{ 
  register char *bufp ;
  register int r ;
  bool firstline ;
  char junkbuf[2048] ;
  int save_errno ;
  register char *p ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  bool oldholderrs ;
  int tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char const   *tmp___9 ;
  char wbuf[2048] ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char const   *tmp___12 ;
  int *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  unsigned short const   **tmp___18 ;
  unsigned short const   **tmp___19 ;
  unsigned short const   **tmp___20 ;
  int tmp___21 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
#line 3044
  firstline = 1;
#line 3058
  if ((unsigned long )mci->mci_out != (unsigned long )((void *)0)) {
    {
#line 3059
    sm_io_flush(mci->mci_out, -2);
    }
  }
#line 3061
  if ((int )tTdvect[18] >= 1) {
    {
#line 3062
    sm_dprintf((char *)"reply\n");
    }
  }
#line 3068
  bufp = SmtpReplyBuffer;
  {
#line 3069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3074
    if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
      {
#line 3075
      sm_io_flush(e->e_xfp, -2);
      }
    }
#line 3078
    if ((int )mci->mci_state == 0) {
#line 3079
      return (421);
    }
#line 3082
    if ((unsigned long )mci->mci_in == (unsigned long )((void *)0)) {
#line 3084
      if ((int )mci->mci_errno == 0) {
#line 3085
        mci->mci_errno = (short)9;
      }
      {
#line 3088
      tmp___0 = strncmp((char const   *)(SmtpMsgBuffer), "QUIT", (size_t )4);
      }
#line 3088
      if (tmp___0 == 0) {
        {
#line 3090
        tmp = __errno_location();
#line 3090
        *tmp = (int )mci->mci_errno;
#line 3091
        mci_close(mci, (char *)"reply:1");
        }
#line 3092
        return (-1);
      }
      {
#line 3094
      mci->mci_state = (short)8;
#line 3095
      smtpquit(m, mci, e);
#line 3096
      tmp___1 = __errno_location();
#line 3096
      *tmp___1 = (int )mci->mci_errno;
      }
#line 3097
      return (-1);
    }
#line 3100
    if ((unsigned long )mci->mci_out != (unsigned long )((void *)0)) {
      {
#line 3101
      sm_io_flush(mci->mci_out, -2);
      }
    }
    {
#line 3104
    p = sfgets(bufp, 2048, mci->mci_in, timeout, SmtpPhase);
#line 3105
    tmp___2 = __errno_location();
#line 3105
    save_errno = *tmp___2;
#line 3106
    mci->mci_lastuse = curtime();
    }
#line 3108
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 3114
      tmp___3 = strncmp((char const   *)(SmtpMsgBuffer), "QUIT", (size_t )4);
      }
#line 3114
      if (tmp___3 == 0) {
        {
#line 3116
        mci_close(mci, (char *)"reply:2");
        }
#line 3117
        return (-1);
      }
      {
#line 3121
      tmp___4 = __errno_location();
#line 3121
      *tmp___4 = save_errno;
#line 3122
      tmp___7 = __errno_location();
      }
#line 3122
      if (*tmp___7 == 0) {
#line 3124
        if ((unsigned long )CurHostName == (unsigned long )((void *)0)) {
#line 3124
          tmp___5 = "local";
        } else {
#line 3124
          tmp___5 = (char const   *)CurHostName;
        }
        {
#line 3124
        sm_snprintf(SmtpReplyBuffer, (size_t )sizeof(SmtpReplyBuffer), "421 4.4.1 Connection reset by %s",
                    tmp___5);
#line 3129
        tmp___6 = __errno_location();
#line 3129
        *tmp___6 = 104;
        }
      }
      {
#line 3135
      tmp___8 = __errno_location();
#line 3135
      mci->mci_errno = (short )*tmp___8;
#line 3136
      oldholderrs = HoldErrs;
#line 3137
      HoldErrs = 1;
      }
#line 3138
      if ((unsigned long )CurHostName == (unsigned long )((void *)0)) {
#line 3138
        tmp___9 = "local";
      } else {
#line 3138
        tmp___9 = (char const   *)CurHostName;
      }
      {
#line 3138
      usrerr("451 4.4.1 reply: read error from %s", tmp___9);
#line 3140
      mci_setstat(mci, 75, (char *)"4.4.2", MsgBuf);
      }
#line 3143
      if ((int )tTdvect[18] >= 100) {
        {
#line 3144
        pause();
        }
      }
      {
#line 3145
      mci->mci_state = (short)8;
#line 3146
      smtpquit(m, mci, e);
#line 3151
      p = wbuf;
      }
#line 3152
      if ((unsigned long )e->e_to != (unsigned long )((void *)0)) {
        {
#line 3154
        tmp___10 = shortenstring((char const   *)e->e_to, (size_t )203);
#line 3154
        sm_snprintf(p, (size_t )(sizeof(wbuf) - (unsigned long )(p - wbuf)), "%s... ",
                    tmp___10);
#line 3158
        tmp___11 = strlen((char const   *)p);
#line 3158
        p += tmp___11;
        }
      }
#line 3160
      if ((unsigned long )CurHostName == (unsigned long )((void *)0)) {
#line 3160
        tmp___12 = "local";
      } else {
#line 3160
        tmp___12 = (char const   *)CurHostName;
      }
      {
#line 3160
      sm_snprintf(p, (size_t )(sizeof(wbuf) - (unsigned long )(p - wbuf)), "reply(%.100s) during %s",
                  tmp___12, SmtpPhase);
#line 3163
      checkfd012(wbuf);
#line 3166
      HoldErrs = oldholderrs;
#line 3167
      tmp___13 = __errno_location();
#line 3167
      *tmp___13 = save_errno;
      }
#line 3168
      return (-1);
    }
    {
#line 3170
    fixcrlf(bufp, 1);
    }
#line 3173
    if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
#line 3173
      if ((int )*(bufp + 0) == 52) {
#line 3173
        goto _L;
      } else
#line 3173
      if ((int )*(bufp + 0) == 53) {
        {
#line 3173
        tmp___17 = strncmp((char const   *)(SmtpMsgBuffer), "EHLO", (size_t )4);
        }
#line 3173
        if (tmp___17 != 0) {
          _L: /* CIL Label */ 
#line 3177
          if (SmtpNeedIntro) {
#line 3180
            if ((unsigned long )CurHostName == (unsigned long )((void *)0)) {
#line 3180
              tmp___14 = "local";
            } else {
#line 3180
              tmp___14 = (char const   *)CurHostName;
            }
            {
#line 3180
            sm_io_fprintf(CurEnv->e_xfp, -2, "... while talking to %s:\n", tmp___14);
#line 3184
            SmtpNeedIntro = 0;
            }
          }
#line 3186
          if ((int )SmtpMsgBuffer[0] != 0) {
#line 3188
            if (rtype == 1) {
#line 3188
              tmp___16 = "STARTTLS dialogue";
            } else {
#line 3188
              if (rtype == 2) {
#line 3188
                tmp___15 = "AUTH dialogue";
              } else {
#line 3188
                tmp___15 = (char const   *)(SmtpMsgBuffer);
              }
#line 3188
              tmp___16 = tmp___15;
            }
            {
#line 3188
            sm_io_fprintf(e->e_xfp, -2, ">>> %s\n", tmp___16);
#line 3196
            SmtpMsgBuffer[0] = (char )'\000';
            }
          }
          {
#line 3200
          sm_io_fprintf(e->e_xfp, -2, "<<< %s\n", bufp);
          }
        }
      }
    }
#line 3205
    if (Verbose) {
      {
#line 3206
      nmessage("050 %s", bufp);
      }
    }
#line 3209
    if (((int )*(bufp + 0) & -128) == 0) {
      {
#line 3209
      tmp___18 = __ctype_b_loc();
      }
#line 3209
      if ((int const   )*(*tmp___18 + (int )*(bufp + 0)) & 2048) {
#line 3209
        if (((int )*(bufp + 1) & -128) == 0) {
          {
#line 3209
          tmp___19 = __ctype_b_loc();
          }
#line 3209
          if ((int const   )*(*tmp___19 + (int )*(bufp + 1)) & 2048) {
#line 3209
            if (((int )*(bufp + 2) & -128) == 0) {
              {
#line 3209
              tmp___20 = __ctype_b_loc();
              }
#line 3209
              if ((int const   )*(*tmp___20 + (int )*(bufp + 2)) & 2048) {
#line 3209
                if (! ((int )*(bufp + 3) == 32)) {
#line 3209
                  if (! ((int )*(bufp + 3) == 45)) {
#line 3209
                    if (! ((int )*(bufp + 3) == 0)) {
#line 3210
                      goto __Cont;
                    }
                  }
                }
              } else {
#line 3210
                goto __Cont;
              }
            } else {
#line 3210
              goto __Cont;
            }
          } else {
#line 3210
            goto __Cont;
          }
        } else {
#line 3210
          goto __Cont;
        }
      } else {
#line 3210
        goto __Cont;
      }
    } else {
#line 3210
      goto __Cont;
    }
#line 3212
    if ((mci->mci_flags & 131072UL) != 0UL) {
#line 3212
      if ((unsigned long )enhstat != (unsigned long )((void *)0)) {
        {
#line 3212
        tmp___21 = extenhsc((char const   *)(bufp + 4), ' ', enhstatcode);
        }
#line 3212
        if (tmp___21 > 0) {
#line 3215
          *enhstat = enhstatcode;
        }
      }
    }
#line 3218
    if ((unsigned long )pfunc != (unsigned long )((void *)0)) {
      {
#line 3219
      (*pfunc)(bufp, firstline, m, mci, e);
      }
    }
    {
#line 3221
    firstline = 0;
#line 3224
    r = atoi((char const   *)bufp);
    }
#line 3227
    if (r < 100) {
#line 3228
      goto __Cont;
    }
#line 3231
    if ((int )*(bufp + 3) != 45) {
#line 3232
      goto while_break;
    }
#line 3235
    bufp = junkbuf;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3244
  if ((int )SmtpReplyBuffer[0] == 52) {
    {
#line 3245
    sm_strlcpy(SmtpError, (char const   *)(SmtpReplyBuffer), (ssize_t )sizeof(SmtpError));
    }
  }
#line 3248
  if (r == 421) {
#line 3248
    if ((int )mci->mci_state != 7) {
#line 3248
      if ((int )mci->mci_state != 6) {
        {
#line 3252
        mci->mci_state = (short)7;
#line 3253
        smtpquit(m, mci, e);
        }
      }
    }
  }
#line 3256
  return (r);
}
}
#line 3274 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/usersmtp.c"
void smtpmessage(char *f , MAILER *m , struct mailer_con_info *mci  , ...) 
{ 
  va_list ap ;
  char const   *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 3287
  __builtin_va_start(ap, mci);
#line 3288
  sm_vsnprintf(SmtpMsgBuffer, (size_t )sizeof(SmtpMsgBuffer), (char const   *)f, ap);
#line 3289
  __builtin_va_end(ap);
  }
#line 3291
  if ((int )tTdvect[18] >= 1) {
    {
#line 3292
    nmessage(">>> %s", SmtpMsgBuffer);
    }
  } else
#line 3291
  if (Verbose) {
    {
#line 3292
    nmessage(">>> %s", SmtpMsgBuffer);
    }
  }
#line 3293
  if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
    {
#line 3294
    sm_io_fprintf(TrafficLogFile, -2, "%05d >>> %s\n", CurrentPid, SmtpMsgBuffer);
    }
  }
#line 3297
  if ((unsigned long )mci->mci_out != (unsigned long )((void *)0)) {
#line 3299
    if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 3299
      tmp = "\r\n";
    } else {
#line 3299
      tmp = (char const   *)m->m_eol;
    }
    {
#line 3299
    sm_io_fprintf(mci->mci_out, -2, "%s%s", SmtpMsgBuffer, tmp);
    }
  } else
#line 3303
  if ((int )tTdvect[18] >= 1) {
    {
#line 3305
    sm_dprintf((char *)"smtpmessage: NULL mci_out\n");
    }
  }
#line 3307
  return;
}
}
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 344 "./sendmail.h"
void printaddr(SM_FILE_T *fp , ADDRESS *a , bool follow ) ;
#line 349
int sendtolist(char *list , ADDRESS *ctladdr , ADDRESS **sendq , int aliaslevel ,
               ENVELOPE *e ) ;
#line 1276
char *map_rewrite(struct _map *map___0 , char const   *s , size_t slen , char **av___0 ) ;
#line 1282
void _udbx_close(void) ;
#line 1283
int udbexpand(ADDRESS *a , ADDRESS **sendq , int aliaslevel , ENVELOPE *e ) ;
#line 1284
char *udbsender(char *sender , SM_RPOOL_T *rpool ) ;
#line 1369
char *anynet_ntoa(union bigsockaddr *sap ) ;
#line 2318
char *UdbSpec ;
#line 928 "/usr/include/db.h"
extern int db_create(DB ** , DB_ENV * , u_int32_t  ) ;
#line 100 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
static char *udbmatch(char *user , char *field , SM_RPOOL_T *rpool ) ;
#line 101
static int _udbx_init(ENVELOPE *e ) ;
#line 102
static int _udb_parsespec(char *udbspec , struct udb_option *opt , int maxopts ) ;
#line 122 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
static struct udbent UdbEnts[11]  ;
#line 123 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
static bool UdbInitialized  =    0;
#line 125 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
int udbexpand(ADDRESS *a , ADDRESS **sendq , int aliaslevel , ENVELOPE *e ) 
{ 
  int i ;
  DBT key ;
  DBT info ;
  bool breakout ;
  register struct udbent *up ;
  int keylen ;
  int naddrs ;
  char *user ;
  char keybuf[128] ;
  int tmp ;
  size_t tmp___0 ;
  int usersize ;
  int userleft ;
  char userbuf[1024] ;
  DBC *dbc ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char *p ;
  char *nuser ;
  int size ;
  void *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  SM_FILE_T *tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  SM_FILE_T *tmp___20 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
  {
#line 142
  memset((void *)(& key), '\000', (size_t )sizeof(key));
#line 143
  memset((void *)(& info), '\000', (size_t )sizeof(info));
  }
#line 145
  if ((int )tTdvect[28] >= 1) {
    {
#line 146
    sm_dprintf((char *)"udbexpand(%s)\n", a->q_paddr);
    }
  }
#line 149
  if (! ((int )a->q_state == 0)) {
#line 149
    if (! ((int )a->q_state == 3)) {
#line 149
      if (! ((int )a->q_state == 4)) {
#line 150
        return (0);
      }
    }
  }
#line 151
  e->e_to = a->q_paddr;
#line 154
  if (! UdbInitialized) {
    {
#line 156
    tmp = _udbx_init(e);
    }
#line 156
    if (tmp == 75) {
#line 157
      return (75);
    }
  }
#line 161
  if ((unsigned long )UdbSpec == (unsigned long )((void *)0)) {
#line 162
    return (0);
  } else
#line 161
  if ((int )*(UdbSpec + 0) == 0) {
#line 162
    return (0);
  }
#line 165
  user = a->q_user;
#line 169
  if ((int )*(user + 0) == 92) {
#line 170
    return (0);
  }
#line 173
  if ((int )*(user + 0) == 58) {
#line 174
    return (0);
  }
  {
#line 176
  tmp___0 = sm_strlcpyn(keybuf, (ssize_t )sizeof(keybuf), 2, user, ":maildrop");
#line 176
  keylen = (int )tmp___0;
  }
#line 179
  if ((unsigned long )keylen >= sizeof(keybuf)) {
#line 180
    return (0);
  }
#line 184
  breakout = 0;
#line 185
  up = UdbEnts;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (! breakout)) {
#line 185
      goto while_break;
    }
#line 194
    dbc = (DBC *)((void *)0);
#line 197
    user = userbuf;
#line 198
    userbuf[0] = (char )'\000';
#line 199
    usersize = (int )sizeof(userbuf);
#line 200
    userleft = (int )(sizeof(userbuf) - 1UL);
    {
#line 213
    if (up->udb_type == 3) {
#line 213
      goto case_3;
    }
#line 502
    if (up->udb_type == 2) {
#line 502
      goto case_2;
    }
#line 506
    if (up->udb_type == 4) {
#line 506
      goto case_4;
    }
#line 535
    if (up->udb_type == 0) {
#line 535
      goto case_0;
    }
#line 539
    goto switch_default;
    case_3: /* CIL Label */ 
#line 214
    key.data = (void *)(keybuf);
#line 215
    key.size = (u_int32_t )keylen;
#line 216
    if ((int )tTdvect[28] >= 80) {
      {
#line 217
      sm_dprintf((char *)"udbexpand: trying %s (%d) via db\n", keybuf, keylen);
      }
    }
#line 222
    i = 0;
#line 223
    if ((unsigned long )dbc == (unsigned long )((void *)0)) {
      {
#line 223
      tmp___1 = __errno_location();
#line 223
      tmp___2 = (*((up->udb_u.udb_lookup._udb_dbp)->cursor))(up->udb_u.udb_lookup._udb_dbp,
                                                             (DB_TXN *)((void *)0),
                                                             & dbc, (u_int32_t )0);
#line 223
      *tmp___1 = tmp___2;
      }
#line 223
      if (tmp___2 != 0) {
#line 231
        i = -1;
      }
    }
#line 232
    if (i != 0) {
#line 235
      i = 1;
    } else
#line 232
    if ((unsigned long )dbc == (unsigned long )((void *)0)) {
#line 235
      i = 1;
    } else {
      {
#line 232
      tmp___3 = __errno_location();
#line 232
      tmp___4 = (*(dbc->c_get))(dbc, & key, & info, (u_int32_t )30);
#line 232
      *tmp___3 = tmp___4;
      }
#line 232
      if (tmp___4 != 0) {
#line 235
        i = 1;
      }
    }
#line 237
    if (i > 0) {
#line 237
      goto _L;
    } else
#line 237
    if (info.size <= 0U) {
      _L: /* CIL Label */ 
#line 239
      if ((int )tTdvect[28] >= 2) {
        {
#line 240
        sm_dprintf((char *)"udbexpand: no match on %s (%d)\n", keybuf, keylen);
        }
      }
#line 243
      if ((unsigned long )dbc != (unsigned long )((void *)0)) {
        {
#line 245
        (*(dbc->c_close))(dbc);
#line 246
        dbc = (DBC *)((void *)0);
        }
      }
#line 249
      goto switch_break;
    }
#line 251
    if ((int )tTdvect[28] >= 80) {
      {
#line 252
      sm_dprintf((char *)"udbexpand: match %.*s: %.*s\n", (int )key.size, (char *)key.data,
                 (int )info.size, (char *)info.data);
      }
    }
#line 256
    a->q_flags &= 0xfffffffffffffff7UL;
    {
#line 257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 257
      if (i == 0) {
#line 257
        if (key.size == (u_int32_t )keylen) {
          {
#line 257
          tmp___10 = memcmp((void const   *)key.data, (void const   *)(keybuf), (size_t )keylen);
          }
#line 257
          if (! (tmp___10 == 0)) {
#line 257
            goto while_break___0;
          }
        } else {
#line 257
          goto while_break___0;
        }
      } else {
#line 257
        goto while_break___0;
      }
#line 262
      if ((e->e_flags & 512UL) != 0UL) {
#line 264
        a->q_state = (short)5;
#line 266
        if ((unsigned long )dbc != (unsigned long )((void *)0)) {
          {
#line 268
          (*(dbc->c_close))(dbc);
#line 269
          dbc = (DBC *)((void *)0);
          }
        }
#line 272
        return (0);
      }
#line 275
      breakout = 1;
#line 276
      if (info.size >= (u_int32_t )(userleft - 1)) {
#line 279
        size = 1024;
#line 281
        if (info.size > 1024U) {
#line 282
          size = (int )info.size;
        }
        {
#line 283
        tmp___5 = sm_malloc_tagged_x((size_t )(usersize + size), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                                     283, SmHeapGroup);
#line 283
        nuser = (char *)tmp___5;
#line 285
        memmove((void *)nuser, (void const   *)user, (size_t )usersize);
        }
#line 286
        if ((unsigned long )user != (unsigned long )(userbuf)) {
          {
#line 287
          sm_free_tagged((void *)user, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                         287);
          }
        }
#line 288
        user = nuser;
#line 289
        usersize += size;
#line 290
        userleft += size;
      }
      {
#line 292
      tmp___6 = strlen((char const   *)user);
#line 292
      p = user + tmp___6;
      }
#line 293
      if ((unsigned long )p != (unsigned long )user) {
#line 295
        tmp___7 = p;
#line 295
        p ++;
#line 295
        *tmp___7 = (char )',';
#line 296
        userleft --;
      }
      {
#line 298
      memmove((void *)p, (void const   *)info.data, info.size);
#line 299
      *(p + info.size) = (char )'\000';
#line 300
      userleft = (int )((u_int32_t )userleft - info.size);
#line 306
      i = 0;
#line 307
      tmp___8 = __errno_location();
#line 307
      tmp___9 = (*(dbc->c_get))(dbc, & key, & info, (u_int32_t )19);
#line 307
      *tmp___8 = tmp___9;
      }
#line 307
      if (tmp___9 != 0) {
#line 309
        i = 1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 314
    if ((unsigned long )dbc != (unsigned long )((void *)0)) {
      {
#line 316
      (*(dbc->c_close))(dbc);
#line 317
      dbc = (DBC *)((void *)0);
      }
    }
#line 322
    if (! breakout) {
#line 323
      goto switch_break;
    }
    {
#line 325
    message("expanded to %s", user);
    }
#line 326
    if (LogLevel > 10) {
      {
#line 327
      tmp___11 = shortenstring((char const   *)user, (size_t )203);
#line 327
      sm_syslog(6, (char const   *)e->e_id, "expand %.100s => %s", e->e_to, tmp___11);
      }
    }
    {
#line 331
    naddrs = sendtolist(user, a, sendq, aliaslevel + 1, e);
    }
#line 332
    if (naddrs > 0) {
#line 332
      if (! ((a->q_flags & 8UL) != 0UL)) {
#line 334
        if ((int )tTdvect[28] >= 5) {
          {
#line 336
          sm_dprintf((char *)"udbexpand: QS_EXPANDED ");
#line 337
          tmp___12 = sm_debug_file();
#line 337
          printaddr(tmp___12, a, 0);
          }
        }
#line 339
        a->q_state = (short)7;
      }
    }
#line 341
    if (i < 0) {
      {
#line 343
      syserr("udbexpand: db-get %.*s stat %d", (int )key.size, (char *)key.data, i);
      }
#line 345
      return (75);
    }
    {
#line 353
    memset((void *)(& key), '\000', (size_t )sizeof(key));
#line 354
    memset((void *)(& info), '\000', (size_t )sizeof(info));
#line 355
    sm_strlcpyn(keybuf, (ssize_t )sizeof(keybuf), 2, a->q_user, ":mailsender");
#line 357
    tmp___13 = strlen((char const   *)(keybuf));
#line 357
    keylen = (int )tmp___13;
#line 358
    key.data = (void *)(keybuf);
#line 359
    key.size = (u_int32_t )keylen;
#line 364
    tmp___14 = __errno_location();
#line 364
    tmp___15 = (*((up->udb_u.udb_lookup._udb_dbp)->get))(up->udb_u.udb_lookup._udb_dbp,
                                                         (DB_TXN *)((void *)0), & key,
                                                         & info, (u_int32_t )0);
#line 364
    *tmp___14 = tmp___15;
#line 364
    i = tmp___15;
    }
#line 367
    if (i != 0) {
#line 368
      goto switch_break;
    } else
#line 367
    if (info.size <= 0U) {
#line 368
      goto switch_break;
    }
    {
#line 369
    tmp___16 = sm_rpool_malloc_tagged_x(e->e_rpool, info.size + 1U, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                                        370, SmHeapGroup);
#line 369
    a->q_owner = (char *)tmp___16;
#line 371
    memmove((void *)a->q_owner, (void const   *)info.data, info.size);
#line 372
    *(a->q_owner + info.size) = (char )'\000';
    }
#line 375
    if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
      {
#line 377
      sm_io_fprintf(e->e_xfp, -2, "Message delivered to mailing list %s\n", a->q_paddr);
      }
    }
#line 381
    e->e_flags |= 16UL;
#line 382
    a->q_flags |= 6144UL;
#line 383
    goto switch_break;
    case_2: /* CIL Label */ 
#line 504
    goto switch_break;
    case_4: /* CIL Label */ 
#line 507
    if ((e->e_flags & 512UL) != 0UL) {
#line 509
      a->q_state = (short)5;
#line 510
      return (0);
    }
    {
#line 512
    tmp___17 = strlen((char const   *)up->udb_u.udb_forward._udb_fwdhost);
#line 512
    tmp___18 = strlen((char const   *)a->q_user);
#line 512
    i = (int )((tmp___17 + tmp___18) + 1U);
    }
#line 513
    if (i >= usersize) {
      {
#line 515
      usersize = i + 1;
#line 516
      tmp___19 = sm_malloc_tagged_x((size_t )usersize, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                                    516, SmHeapGroup);
#line 516
      user = (char *)tmp___19;
      }
    }
    {
#line 518
    sm_strlcpyn(user, usersize, 3, a->q_user, "@", up->udb_u.udb_forward._udb_fwdhost);
#line 520
    message("expanded to %s", user);
#line 521
    a->q_flags &= 0xfffffffffffffff7UL;
#line 522
    naddrs = sendtolist(user, a, sendq, aliaslevel + 1, e);
    }
#line 523
    if (naddrs > 0) {
#line 523
      if (! ((a->q_flags & 8UL) != 0UL)) {
#line 525
        if ((int )tTdvect[28] >= 5) {
          {
#line 527
          sm_dprintf((char *)"udbexpand: QS_EXPANDED ");
#line 528
          tmp___20 = sm_debug_file();
#line 528
          printaddr(tmp___20, a, 0);
          }
        }
#line 530
        a->q_state = (short)7;
      }
    }
#line 532
    breakout = 1;
#line 533
    goto switch_break;
    case_0: /* CIL Label */ 
#line 536
    breakout = 1;
#line 537
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 541
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 544
    if ((unsigned long )user != (unsigned long )(userbuf)) {
      {
#line 545
      sm_free_tagged((void *)user, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                     545);
      }
    }
#line 185
    up ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  return (0);
}
}
#line 565 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
char *udbsender(char *sender , SM_RPOOL_T *rpool ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 570
  tmp = udbmatch(sender, (char *)"mailname", rpool);
  }
#line 570
  return (tmp);
}
}
#line 589 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
static char *udbmatch(char *user , char *field , SM_RPOOL_T *rpool ) 
{ 
  register char *p ;
  register struct udbent *up ;
  int i ;
  int keylen ;
  DBT key ;
  DBT info ;
  char keybuf[128] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
#line 602
  if ((int )tTdvect[28] >= 1) {
    {
#line 603
    sm_dprintf((char *)"udbmatch(%s, %s)\n", user, field);
    }
  }
#line 605
  if (! UdbInitialized) {
    {
#line 607
    tmp = _udbx_init(CurEnv);
    }
#line 607
    if (tmp == 75) {
#line 608
      return ((char *)((void *)0));
    }
  }
#line 612
  if ((unsigned long )UdbSpec == (unsigned long )((void *)0)) {
#line 613
    return ((char *)((void *)0));
  } else
#line 612
  if ((int )*(UdbSpec + 0) == 0) {
#line 613
    return ((char *)((void *)0));
  }
#line 616
  if ((int )*(user + 0) == 92) {
#line 617
    return ((char *)((void *)0));
  }
  {
#line 620
  tmp___0 = strlen((char const   *)field);
#line 620
  i = (int )tmp___0;
  }
#line 621
  if ((unsigned long )i < sizeof("maildrop")) {
#line 622
    i = (int )sizeof("maildrop");
  }
  {
#line 623
  tmp___1 = strlen((char const   *)user);
  }
#line 623
  if ((unsigned long )(tmp___1 + (size_t )i) > sizeof(keybuf) - 4UL) {
#line 624
    return ((char *)((void *)0));
  }
#line 627
  if ((int )*(user + 0) == 58) {
#line 628
    return ((char *)((void *)0));
  }
  {
#line 631
  sm_strlcpyn(keybuf, (ssize_t )sizeof(keybuf), 3, user, ":", field);
#line 632
  tmp___2 = strlen((char const   *)(keybuf));
#line 632
  keylen = (int )tmp___2;
#line 634
  up = UdbEnts;
  }
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 634
    if (! (up->udb_type != 0)) {
#line 634
      goto while_break;
    }
    {
#line 643
    if (up->udb_type == 3) {
#line 643
      goto case_3;
    }
#line 640
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 644
    memset((void *)(& key), '\000', (size_t )sizeof(key));
#line 645
    memset((void *)(& info), '\000', (size_t )sizeof(info));
#line 646
    key.data = (void *)(keybuf);
#line 647
    key.size = (u_int32_t )keylen;
#line 651
    tmp___3 = __errno_location();
#line 651
    tmp___4 = (*((up->udb_u.udb_lookup._udb_dbp)->get))(up->udb_u.udb_lookup._udb_dbp,
                                                        (DB_TXN *)((void *)0), & key,
                                                        & info, (u_int32_t )0);
#line 651
    *tmp___3 = tmp___4;
#line 651
    i = tmp___4;
    }
#line 654
    if (i != 0) {
#line 654
      goto _L;
    } else
#line 654
    if (info.size <= 0U) {
      _L: /* CIL Label */ 
#line 656
      if ((int )tTdvect[28] >= 2) {
        {
#line 657
        sm_dprintf((char *)"udbmatch: no match on %s (%d) via db\n", keybuf, keylen);
        }
      }
#line 659
      goto __Cont;
    }
    {
#line 662
    tmp___5 = sm_rpool_malloc_tagged_x(rpool, info.size + 1U, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                                       662, SmHeapGroup);
#line 662
    p = (char *)tmp___5;
#line 663
    memmove((void *)p, (void const   *)info.data, info.size);
#line 664
    *(p + info.size) = (char )'\000';
    }
#line 665
    if ((int )tTdvect[28] >= 1) {
      {
#line 666
      sm_dprintf((char *)"udbmatch ==> %s\n", p);
      }
    }
#line 667
    return (p);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 634
    up ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 693
  tmp___6 = strcmp((char const   *)field, "mailname");
  }
#line 693
  if (tmp___6 != 0) {
#line 694
    return ((char *)((void *)0));
  }
  {
#line 703
  sm_strlcpyn(keybuf, (ssize_t )sizeof(keybuf), 2, user, ":maildrop");
#line 704
  tmp___7 = strlen((char const   *)(keybuf));
#line 704
  keylen = (int )tmp___7;
#line 706
  up = UdbEnts;
  }
  {
#line 706
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 706
    if (! (up->udb_type != 0)) {
#line 706
      goto while_break___0;
    }
    {
#line 711
    if (up->udb_type == 3) {
#line 711
      goto case_3___0;
    }
#line 708
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
#line 713
    if ((unsigned long )up->udb_default == (unsigned long )((void *)0)) {
      {
#line 715
      memset((void *)(& key), '\000', (size_t )sizeof(key));
#line 716
      memset((void *)(& info), '\000', (size_t )sizeof(info));
#line 717
      key.data = (void *)":default:mailname";
#line 718
      key.size = strlen((char const   *)key.data);
#line 723
      tmp___8 = __errno_location();
#line 723
      tmp___9 = (*((up->udb_u.udb_lookup._udb_dbp)->get))(up->udb_u.udb_lookup._udb_dbp,
                                                          (DB_TXN *)((void *)0), & key,
                                                          & info, (u_int32_t )0);
#line 723
      *tmp___8 = tmp___9;
#line 723
      i = tmp___9;
      }
#line 727
      if (i != 0) {
#line 730
        up->udb_default = (char *)"";
#line 731
        goto __Cont___0;
      } else
#line 727
      if (info.size <= 0U) {
#line 730
        up->udb_default = (char *)"";
#line 731
        goto __Cont___0;
      }
      {
#line 735
      tmp___10 = sm_malloc_tagged_x(info.size + 1U, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                                    735, 0);
#line 735
      up->udb_default = (char *)tmp___10;
#line 736
      memmove((void *)up->udb_default, (void const   *)info.data, info.size);
#line 737
      *(up->udb_default + info.size) = (char )'\000';
      }
    } else
#line 739
    if ((int )*(up->udb_default + 0) == 0) {
#line 740
      goto __Cont___0;
    }
    {
#line 743
    memset((void *)(& key), '\000', (size_t )sizeof(key));
#line 744
    memset((void *)(& info), '\000', (size_t )sizeof(info));
#line 745
    key.data = (void *)(keybuf);
#line 746
    key.size = (u_int32_t )keylen;
#line 750
    tmp___11 = __errno_location();
#line 750
    tmp___12 = (*((up->udb_u.udb_lookup._udb_dbp)->get))(up->udb_u.udb_lookup._udb_dbp,
                                                         (DB_TXN *)((void *)0), & key,
                                                         & info, (u_int32_t )0);
#line 750
    *tmp___11 = tmp___12;
#line 750
    i = tmp___12;
    }
#line 753
    if (i != 0) {
#line 756
      goto __Cont___0;
    } else
#line 753
    if (info.size <= 0U) {
#line 756
      goto __Cont___0;
    }
    {
#line 760
    tmp___13 = strlen((char const   *)user);
#line 760
    tmp___14 = strlen((char const   *)up->udb_default);
#line 760
    i = (int )((tmp___13 + tmp___14) + 2U);
#line 761
    tmp___15 = sm_rpool_malloc_tagged_x(rpool, (size_t )i, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                                        761, SmHeapGroup);
#line 761
    p = (char *)tmp___15;
#line 762
    sm_strlcpyn(p, i, 3, user, "@", up->udb_default);
    }
#line 763
    if ((int )tTdvect[28] >= 1) {
      {
#line 764
      sm_dprintf((char *)"udbmatch ==> %s\n", p);
      }
    }
#line 765
    return (p);
    switch_break___0: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 706
    up ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 815
  return ((char *)((void *)0));
}
}
#line 832 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
char *udb_map_lookup(struct _map *map___0 , char *name , char **av___0 , int *statp ) 
{ 
  char *val ;
  char *key ;
  char *result___0 ;
  char keybuf[257] ;
  int keysize ;
  size_t tmp ;
  SM_EXC_HANDLER_T _h ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 841
  result___0 = (char *)((void *)0);
#line 844
  if ((int )tTdvect[28] >= 20) {
    {
#line 845
    sm_dprintf((char *)"udb_map_lookup(%s, %s)\n", map___0->map_mname, name);
    }
  } else
#line 844
  if ((int )tTdvect[38] >= 20) {
    {
#line 845
    sm_dprintf((char *)"udb_map_lookup(%s, %s)\n", map___0->map_mname, name);
    }
  }
#line 847
  if ((map___0->map_mflags & 8L) != 0L) {
#line 849
    key = name;
  } else {
    {
#line 853
    tmp = strlen((char const   *)name);
#line 853
    keysize = (int )tmp;
    }
#line 855
    if ((unsigned long )keysize > sizeof(keybuf) - 1UL) {
#line 856
      keysize = (int )(sizeof(keybuf) - 1UL);
    }
    {
#line 857
    memmove((void *)(keybuf), (void const   *)name, (size_t )keysize);
#line 858
    keybuf[keysize] = (char )'\000';
#line 859
    makelower(keybuf);
#line 860
    key = keybuf;
    }
  }
  {
#line 862
  val = udbmatch(key, map___0->map_file, (SM_RPOOL_T *)((void *)0));
  }
#line 863
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 864
    return ((char *)((void *)0));
  }
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 865
    _h.eh_value = (SM_EXC_T *)((void *)0);
#line 865
    _h.eh_parent = SmExcHandler;
#line 865
    _h.eh_state = 2;
#line 865
    SmExcHandler = & _h;
#line 865
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 865
    if (tmp___3 == 0) {
#line 866
      if ((map___0->map_mflags & 16L) != 0L) {
        {
#line 867
        tmp___0 = strlen((char const   *)name);
#line 867
        result___0 = map_rewrite(map___0, (char const   *)name, tmp___0, (char **)((void *)0));
        }
      } else {
        {
#line 869
        tmp___1 = strlen((char const   *)val);
#line 869
        result___0 = map_rewrite(map___0, (char const   *)val, tmp___1, av___0);
        }
      }
#line 870
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 870
        tmp___2 = 1;
      } else {
        {
#line 870
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                    870, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 870
        tmp___2 = 0;
        }
      }
    }
    {
#line 870
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 870
    if (tmp___4 == 0) {
      {
#line 871
      sm_free_tagged((void *)val, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                     871);
      }
    }
#line 865
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 872
  if (_h.eh_state == 2) {
#line 872
    if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 872
      tmp___5 = 1;
    } else {
      {
#line 872
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                  872, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 872
      tmp___5 = 0;
      }
    }
#line 872
    SmExcHandler = _h.eh_parent;
#line 872
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 872
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else
#line 872
  if (_h.eh_state == 0) {
#line 872
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 872
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else {
    {
#line 872
    sm_exc_free(_h.eh_value);
    }
  }
#line 873
  return (result___0);
}
}
#line 893 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
static int _udbx_init(ENVELOPE *e ) 
{ 
  int ents ;
  register char *p ;
  register struct udbent *up ;
  char *spec ;
  int l ;
  struct udb_option opts[28] ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int flags ;
  int ret ;
  int *tmp___4 ;
  int save_errno ;
  int *tmp___5 ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char const   *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 897
  ents = 0;
#line 901
  if (UdbInitialized) {
#line 902
    return (0);
  }
#line 909
  p = UdbSpec;
#line 910
  up = UdbEnts;
  {
#line 911
  while (1) {
    while_continue: /* CIL Label */ ;
#line 911
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 911
      goto while_break;
    }
    {
#line 917
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 917
      if (! ((int )*p == 32)) {
#line 917
        if (! ((int )*p == 9)) {
#line 917
          if (! ((int )*p == 44)) {
#line 917
            goto while_break___0;
          }
        }
      }
#line 918
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 919
    if ((int )*p == 0) {
#line 920
      goto while_break;
    }
    {
#line 921
    spec = p;
#line 922
    p = strchr((char const   *)p, ',');
    }
#line 923
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 924
      tmp = p;
#line 924
      p ++;
#line 924
      *tmp = (char )'\000';
    }
#line 926
    if (ents >= 10) {
      {
#line 928
      syserr("Maximum number of UDB entries exceeded");
      }
#line 929
      goto while_break;
    }
    {
#line 933
    _udb_parsespec(spec, opts, 27);
    }
    {
#line 952
    if ((int )*spec == 64) {
#line 952
      goto case_64;
    }
#line 973
    if ((int )*spec == 47) {
#line 973
      goto case_47;
    }
#line 1084
    goto switch_default;
    case_64: /* CIL Label */ 
#line 953
    up->udb_type = 4;
#line 954
    up->udb_pid = CurrentPid;
#line 955
    up->udb_u.udb_forward._udb_fwdhost = spec + 1;
#line 956
    ents ++;
#line 957
    up ++;
#line 958
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 974
    tmp___0 = strlen((char const   *)spec);
#line 974
    l = (int )tmp___0;
    }
#line 975
    if (l > 3) {
      {
#line 975
      tmp___2 = strcmp((char const   *)(spec + (l - 3)), ".db");
      }
#line 975
      if (tmp___2 == 0) {
#line 977
        up->udb_u.udb_lookup._udb_dbname = spec;
      } else {
        {
#line 981
        tmp___1 = sm_malloc_tagged_x((size_t )(l + 4), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                                     981, 0);
#line 981
        up->udb_u.udb_lookup._udb_dbname = (char *)tmp___1;
#line 982
        sm_strlcpyn(up->udb_u.udb_lookup._udb_dbname, l + 4, 2, spec, ".db");
        }
      }
    } else {
      {
#line 981
      tmp___1 = sm_malloc_tagged_x((size_t )(l + 4), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                                   981, 0);
#line 981
      up->udb_u.udb_lookup._udb_dbname = (char *)tmp___1;
#line 982
      sm_strlcpyn(up->udb_u.udb_lookup._udb_dbname, l + 4, 2, spec, ".db");
      }
    }
    {
#line 985
    tmp___3 = __errno_location();
#line 985
    *tmp___3 = 0;
#line 991
    flags = 16;
#line 996
    flags |= 2048;
#line 997
    up->udb_u.udb_lookup._udb_dbp = (DB *)((void *)0);
#line 999
    ret = db_create(& up->udb_u.udb_lookup._udb_dbp, (DB_ENV *)((void *)0), (u_int32_t )0);
    }
#line 1000
    if (ret != 0) {
      {
#line 1002
      (*((up->udb_u.udb_lookup._udb_dbp)->close))(up->udb_u.udb_lookup._udb_dbp, (u_int32_t )0);
#line 1004
      up->udb_u.udb_lookup._udb_dbp = (DB *)((void *)0);
      }
    } else {
      {
#line 1008
      ret = (*((up->udb_u.udb_lookup._udb_dbp)->open))(up->udb_u.udb_lookup._udb_dbp,
                                                       (char const   *)up->udb_u.udb_lookup._udb_dbname,
                                                       (char const   *)((void *)0),
                                                       (DBTYPE )1, (u_int32_t )flags,
                                                       420);
      }
#line 1015
      if (ret != 0) {
#line 1018
        if (ret == -30990) {
#line 1019
          ret = 22;
        }
        {
#line 1021
        (*((up->udb_u.udb_lookup._udb_dbp)->close))(up->udb_u.udb_lookup._udb_dbp,
                                                    (u_int32_t )0);
#line 1022
        up->udb_u.udb_lookup._udb_dbp = (DB *)((void *)0);
        }
      }
    }
    {
#line 1025
    tmp___4 = __errno_location();
#line 1025
    *tmp___4 = ret;
    }
#line 1033
    if ((unsigned long )up->udb_u.udb_lookup._udb_dbp == (unsigned long )((void *)0)) {
#line 1035
      if ((int )tTdvect[28] >= 1) {
        {
#line 1037
        tmp___5 = __errno_location();
#line 1037
        save_errno = *tmp___5;
#line 1042
        tmp___6 = __errno_location();
#line 1042
        tmp___7 = sm_errstring(*tmp___6);
#line 1042
        sm_dprintf((char *)"db_open(%s): %s\n", up->udb_u.udb_lookup._udb_dbname,
                   tmp___7);
#line 1046
        tmp___8 = __errno_location();
#line 1046
        *tmp___8 = save_errno;
        }
      }
      {
#line 1048
      tmp___11 = __errno_location();
      }
#line 1048
      if (*tmp___11 != 2) {
        {
#line 1048
        tmp___12 = __errno_location();
        }
#line 1048
        if (*tmp___12 != 13) {
#line 1050
          if (LogLevel > 2) {
            {
#line 1051
            tmp___9 = __errno_location();
#line 1051
            tmp___10 = sm_errstring(*tmp___9);
#line 1051
            sm_syslog(3, (char const   *)e->e_id, "db_open(%s): %s", up->udb_u.udb_lookup._udb_dbname,
                      tmp___10);
            }
          }
#line 1059
          up->udb_type = 0;
#line 1060
          if ((unsigned long )up->udb_u.udb_lookup._udb_dbname != (unsigned long )spec) {
            {
#line 1061
            sm_free_tagged((void *)up->udb_u.udb_lookup._udb_dbname, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                           1061);
            }
          }
#line 1062
          goto tempfail;
        }
      }
#line 1064
      if ((unsigned long )up->udb_u.udb_lookup._udb_dbname != (unsigned long )spec) {
        {
#line 1065
        sm_free_tagged((void *)up->udb_u.udb_lookup._udb_dbname, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c",
                       1065);
        }
      }
#line 1066
      goto switch_break;
    }
#line 1068
    if ((int )tTdvect[28] >= 1) {
      {
#line 1073
      sm_dprintf((char *)"_udbx_init: db_open(%s)\n", up->udb_u.udb_lookup._udb_dbname);
      }
    }
#line 1077
    up->udb_type = 3;
#line 1078
    up->udb_pid = CurrentPid;
#line 1079
    ents ++;
#line 1080
    up ++;
#line 1081
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1088
    syserr("Unknown UDB spec %s", spec);
    }
#line 1089
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1092
  up->udb_type = 0;
#line 1094
  if ((int )tTdvect[28] >= 4) {
#line 1096
    up = UdbEnts;
    {
#line 1096
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1096
      if (! (up->udb_type != 0)) {
#line 1096
        goto while_break___1;
      }
      {
#line 1100
      if (up->udb_type == 2) {
#line 1100
        goto case_2;
      }
#line 1106
      if (up->udb_type == 3) {
#line 1106
        goto case_3;
      }
#line 1115
      if (up->udb_type == 4) {
#line 1115
        goto case_4;
      }
#line 1120
      if (up->udb_type == 5) {
#line 1120
        goto case_5;
      }
#line 1124
      goto switch_default___0;
      case_2: /* CIL Label */ 
      {
#line 1101
      tmp___13 = anynet_ntoa(& up->udb_u.udb_remote._udb_addr);
#line 1101
      sm_dprintf((char *)"REMOTE: addr %s, timeo %d\n", tmp___13, up->udb_u.udb_remote._udb_timeout);
      }
#line 1104
      goto switch_break___0;
      case_3: /* CIL Label */ 
      {
#line 1108
      sm_dprintf((char *)"FETCH: file %s\n", up->udb_u.udb_lookup._udb_dbname);
      }
#line 1113
      goto switch_break___0;
      case_4: /* CIL Label */ 
      {
#line 1116
      sm_dprintf((char *)"FORWARD: host %s\n", up->udb_u.udb_forward._udb_fwdhost);
      }
#line 1118
      goto switch_break___0;
      case_5: /* CIL Label */ 
      {
#line 1121
      sm_dprintf((char *)"HESIOD\n");
      }
#line 1122
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 1125
      sm_dprintf((char *)"UNKNOWN\n");
      }
#line 1126
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 1096
      up ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1131
  UdbInitialized = 1;
#line 1132
  tmp___14 = __errno_location();
#line 1132
  *tmp___14 = 0;
  }
#line 1133
  return (0);
  tempfail: 
#line 1141
  up = UdbEnts;
  {
#line 1141
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1141
    if (! (up->udb_type != 0)) {
#line 1141
      goto while_break___2;
    }
#line 1143
    if (up->udb_type == 3) {
      {
#line 1148
      tmp___15 = __errno_location();
#line 1148
      *tmp___15 = (*((up->udb_u.udb_lookup._udb_dbp)->close))(up->udb_u.udb_lookup._udb_dbp,
                                                              (u_int32_t )0);
      }
#line 1150
      if ((int )tTdvect[28] >= 1) {
        {
#line 1151
        sm_dprintf((char *)"_udbx_init: db->close(%s)\n", up->udb_u.udb_lookup._udb_dbname);
        }
      }
    }
#line 1141
    up ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1156
  return (75);
}
}
#line 1159 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
static int _udb_parsespec(char *udbspec , struct udb_option *opt , int maxopts ) 
{ 
  register char *spec ;
  register char *spec_end ;
  register int optnum ;
  register char *p ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
  {
#line 1169
  spec_end = strchr((char const   *)udbspec, ':');
#line 1170
  optnum = 0;
  }
  {
#line 1170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1170
    if (optnum < maxopts) {
#line 1170
      spec = spec_end;
#line 1170
      if (! ((unsigned long )spec != (unsigned long )((void *)0))) {
#line 1170
        goto while_break;
      }
    } else {
#line 1170
      goto while_break;
    }
    {
#line 1174
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1174
      if (((int )*spec & -128) == 0) {
        {
#line 1174
        tmp = __ctype_b_loc();
        }
#line 1174
        if (! ((int const   )*(*tmp + (int )*spec) & 8192)) {
#line 1174
          goto while_break___0;
        }
      } else {
#line 1174
        goto while_break___0;
      }
#line 1175
      spec ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1176
    spec_end = strchr((char const   *)spec, ':');
    }
#line 1177
    if ((unsigned long )spec_end != (unsigned long )((void *)0)) {
#line 1178
      tmp___0 = spec_end;
#line 1178
      spec_end ++;
#line 1178
      *tmp___0 = (char )'\000';
    }
    {
#line 1180
    (opt + optnum)->udbo_name = spec;
#line 1181
    (opt + optnum)->udbo_val = (char *)((void *)0);
#line 1182
    p = strchr((char const   *)spec, '=');
    }
#line 1183
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1184
      p ++;
#line 1184
      (opt + optnum)->udbo_val = p;
    }
#line 1170
    optnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1186
  return (optnum);
}
}
#line 1197 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/udb.c"
void _udbx_close(void) 
{ 
  struct udbent *up ;
  int *tmp ;
  char *__cil_tmp3 ;

  {
#line 1202
  if (! UdbInitialized) {
#line 1203
    return;
  }
#line 1205
  up = UdbEnts;
  {
#line 1205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1205
    if (! (up->udb_type != 0)) {
#line 1205
      goto while_break;
    }
#line 1207
    if (up->udb_pid != CurrentPid) {
#line 1208
      goto __Cont;
    }
#line 1211
    if (up->udb_type == 3) {
      {
#line 1216
      tmp = __errno_location();
#line 1216
      *tmp = (*((up->udb_u.udb_lookup._udb_dbp)->close))(up->udb_u.udb_lookup._udb_dbp,
                                                         (u_int32_t )0);
      }
    }
#line 1219
    if ((int )tTdvect[28] >= 1) {
      {
#line 1220
      sm_dprintf((char *)"_udbx_init: db->close(%s)\n", up->udb_u.udb_lookup._udb_dbname);
      }
    }
    __Cont: /* CIL Label */ 
#line 1205
    up ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1224
  return;
}
}
#line 2588 "./sendmail.h"
void tTflag(char *s ) ;
#line 2589
void tTsetup(unsigned char *vect , unsigned int size , char *defflags ) ;
#line 20 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/trace.c"
static char *tTnewflag(char *s ) ;
#line 21
static char *tToldflag(char *s ) ;
#line 38 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/trace.c"
static unsigned char *tTvect  ;
#line 39 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/trace.c"
static unsigned int tTsize  ;
#line 40 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/trace.c"
static char *DefFlags  ;
#line 42 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/trace.c"
void tTsetup(unsigned char *vect , unsigned int size , char *defflags ) 
{ 


  {
#line 48
  tTvect = vect;
#line 49
  tTsize = size;
#line 50
  DefFlags = defflags;
#line 51
  return;
}
}
#line 67 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/trace.c"
static char *tToldflag(char *s ) 
{ 
  unsigned int first ;
  unsigned int last ;
  register unsigned int i ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 75
  i = 0U;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (((int )*s & -128) == 0) {
      {
#line 76
      tmp___0 = __ctype_b_loc();
      }
#line 76
      if ((int const   )*(*tmp___0 + (int )*s) & 2048) {
#line 76
        if (! (i < tTsize)) {
#line 76
          goto while_break;
        }
      } else {
#line 76
        goto while_break;
      }
    } else {
#line 76
      goto while_break;
    }
#line 77
    tmp = s;
#line 77
    s ++;
#line 77
    i = i * 10U + (unsigned int )((int )*tmp - 48);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (((int )*s & -128) == 0) {
      {
#line 84
      tmp___1 = __ctype_b_loc();
      }
#line 84
      if ((int const   )*(*tmp___1 + (int )*s) & 2048) {
#line 84
        if (! (i >= tTsize)) {
#line 84
          goto while_break___0;
        }
      } else {
#line 84
        goto while_break___0;
      }
    } else {
#line 84
      goto while_break___0;
    }
#line 85
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 86
  first = i;
#line 89
  if ((int )*s == 45) {
#line 91
    i = 0U;
    {
#line 92
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 92
      s ++;
#line 92
      if (((int )*s & -128) == 0) {
        {
#line 92
        tmp___2 = __ctype_b_loc();
        }
#line 92
        if ((int const   )*(*tmp___2 + (int )*s) & 2048) {
#line 92
          if (! (i < tTsize)) {
#line 92
            goto while_break___1;
          }
        } else {
#line 92
          goto while_break___1;
        }
      } else {
#line 92
        goto while_break___1;
      }
#line 93
      i = i * 10U + (unsigned int )((int )*s - 48);
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 96
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 96
      if (((int )*s & -128) == 0) {
        {
#line 96
        tmp___3 = __ctype_b_loc();
        }
#line 96
        if ((int const   )*(*tmp___3 + (int )*s) & 2048) {
#line 96
          if (! (i >= tTsize)) {
#line 96
            goto while_break___2;
          }
        } else {
#line 96
          goto while_break___2;
        }
      } else {
#line 96
        goto while_break___2;
      }
#line 97
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 99
  last = i;
#line 102
  i = 1U;
#line 103
  if ((int )*s == 46) {
#line 105
    i = 0U;
    {
#line 106
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 106
      s ++;
#line 106
      if (((int )*s & -128) == 0) {
        {
#line 106
        tmp___4 = __ctype_b_loc();
        }
#line 106
        if (! ((int const   )*(*tmp___4 + (int )*s) & 2048)) {
#line 106
          goto while_break___3;
        }
      } else {
#line 106
        goto while_break___3;
      }
#line 107
      i = i * 10U + (unsigned int )((int )*s - 48);
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 111
  if (first >= tTsize) {
#line 112
    first = tTsize - 1U;
  }
#line 113
  if (last >= tTsize) {
#line 114
    last = tTsize - 1U;
  }
  {
#line 117
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 117
    if (! (first <= last)) {
#line 117
      goto while_break___4;
    }
#line 118
    tmp___5 = first;
#line 118
    first ++;
#line 118
    *(tTvect + tmp___5) = (unsigned char )i;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 121
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 121
    if ((int )*s != 0) {
#line 121
      if ((int )*s != 44) {
#line 121
        if ((int )*s != 32) {
#line 121
          if (! ((int )*s != 9)) {
#line 121
            goto while_break___5;
          }
        } else {
#line 121
          goto while_break___5;
        }
      } else {
#line 121
        goto while_break___5;
      }
    } else {
#line 121
      goto while_break___5;
    }
#line 122
    s ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 124
  return (s);
}
}
#line 141 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/trace.c"
static char *tTnewflag(char *s ) 
{ 
  char *pat ;
  char *endpat ;
  int level ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
#line 148
  pat = s;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if ((int )*s != 0) {
#line 149
      if ((int )*s != 44) {
#line 149
        if ((int )*s != 32) {
#line 149
          if ((int )*s != 9) {
#line 149
            if (! ((int )*s != 46)) {
#line 149
              goto while_break;
            }
          } else {
#line 149
            goto while_break;
          }
        } else {
#line 149
          goto while_break;
        }
      } else {
#line 149
        goto while_break;
      }
    } else {
#line 149
      goto while_break;
    }
#line 150
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  endpat = s;
#line 152
  if ((int )*s == 46) {
#line 154
    s ++;
#line 155
    level = 0;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      if (((int )*s & -128) == 0) {
        {
#line 156
        tmp = __ctype_b_loc();
        }
#line 156
        if (! ((int const   )*(*tmp + (int )*s) & 2048)) {
#line 156
          goto while_break___0;
        }
      } else {
#line 156
        goto while_break___0;
      }
#line 158
      level = level * 10 + ((int )*s - 48);
#line 159
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 161
    if (level < 0) {
#line 162
      level = 0;
    }
  } else {
#line 166
    level = 1;
  }
  {
#line 169
  tmp___0 = sm_strndup_x((char const   *)pat, (size_t )(endpat - pat));
#line 169
  sm_debug_addsetting_x((char const   *)tmp___0, level);
  }
  {
#line 172
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 172
    if ((int )*s != 0) {
#line 172
      if ((int )*s != 44) {
#line 172
        if ((int )*s != 32) {
#line 172
          if (! ((int )*s != 9)) {
#line 172
            goto while_break___1;
          }
        } else {
#line 172
          goto while_break___1;
        }
      } else {
#line 172
        goto while_break___1;
      }
    } else {
#line 172
      goto while_break___1;
    }
#line 173
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 175
  return (s);
}
}
#line 203 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/trace.c"
void tTflag(char *s ) 
{ 
  unsigned short const   **tmp ;

  {
#line 207
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 208
    s = DefFlags;
  } else
#line 207
  if ((int )*s == 0) {
#line 208
    s = DefFlags;
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if ((int )*s == 0) {
#line 213
      return;
    }
#line 214
    if ((int )*s == 44) {
#line 216
      s ++;
#line 217
      goto __Cont;
    } else
#line 214
    if ((int )*s == 32) {
#line 216
      s ++;
#line 217
      goto __Cont;
    } else
#line 214
    if ((int )*s == 9) {
#line 216
      s ++;
#line 217
      goto __Cont;
    }
#line 219
    if (((int )*s & -128) == 0) {
      {
#line 219
      tmp = __ctype_b_loc();
      }
#line 219
      if ((int const   )*(*tmp + (int )*s) & 2048) {
        {
#line 220
        s = tToldflag(s);
        }
      } else {
        {
#line 222
        s = tTnewflag(s);
        }
      }
    } else {
      {
#line 222
      s = tTnewflag(s);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 2481 "./sendmail.h"
int dsntoexitstat(char *dsncode ) ;
#line 2485
char *exitstat(char *excode ) ;
#line 28 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sysexits.c"
int dsntoexitstat(char *dsncode ) 
{ 
  int code2 ;
  int code3 ;

  {
#line 35
  if ((int )*dsncode == 50) {
#line 36
    return (0);
  }
#line 37
  if ((int )*dsncode == 52) {
#line 38
    return (75);
  }
#line 41
  if ((int )*dsncode != 53) {
#line 42
    return (78);
  }
#line 45
  dsncode ++;
#line 45
  if ((int )*dsncode == 46) {
#line 46
    dsncode ++;
  }
  {
#line 47
  code2 = atoi((char const   *)dsncode);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if ((int )*dsncode != 0) {
#line 48
      if (! ((int )*dsncode != 46)) {
#line 48
        goto while_break;
      }
    } else {
#line 48
      goto while_break;
    }
#line 49
    dsncode ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  if ((int )*dsncode != 0) {
#line 51
    dsncode ++;
  }
  {
#line 52
  code3 = atoi((char const   *)dsncode);
  }
  {
#line 57
  if (code2 == 0) {
#line 57
    goto case_0;
  }
#line 60
  if (code2 == 1) {
#line 60
    goto case_1;
  }
#line 87
  if (code2 == 2) {
#line 87
    goto case_2___0;
  }
#line 101
  if (code2 == 3) {
#line 101
    goto case_3___1;
  }
#line 104
  if (code2 == 4) {
#line 104
    goto case_4___1;
  }
#line 129
  if (code2 == 5) {
#line 129
    goto case_5___1;
  }
#line 132
  if (code2 == 6) {
#line 132
    goto case_6___1;
  }
#line 135
  if (code2 == 7) {
#line 135
    goto case_7___1;
  }
#line 55
  goto switch_break;
  case_0: /* CIL Label */ 
#line 58
  return (69);
  case_1: /* CIL Label */ 
  {
#line 63
  if (code3 == 0) {
#line 63
    goto case_0___0;
  }
#line 67
  if (code3 == 6) {
#line 67
    goto case_6;
  }
#line 67
  if (code3 == 1) {
#line 67
    goto case_6;
  }
#line 71
  if (code3 == 8) {
#line 71
    goto case_8;
  }
#line 71
  if (code3 == 2) {
#line 71
    goto case_8;
  }
#line 75
  if (code3 == 7) {
#line 75
    goto case_7;
  }
#line 75
  if (code3 == 3) {
#line 75
    goto case_7;
  }
#line 78
  if (code3 == 4) {
#line 78
    goto case_4;
  }
#line 81
  if (code3 == 5) {
#line 81
    goto case_5;
  }
#line 61
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 64
  return (65);
  case_6: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 68
  return (67);
  case_8: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 72
  return (68);
  case_7: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 76
  return (64);
  case_4: /* CIL Label */ 
#line 79
  return (69);
  case_5: /* CIL Label */ 
#line 83
  return (78);
  switch_break___0: /* CIL Label */ ;
  }
#line 85
  goto switch_break;
  case_2___0: /* CIL Label */ 
  {
#line 93
  if (code3 == 4) {
#line 93
    goto case_4___0;
  }
#line 93
  if (code3 == 2) {
#line 93
    goto case_4___0;
  }
#line 93
  if (code3 == 1) {
#line 93
    goto case_4___0;
  }
#line 93
  if (code3 == 0) {
#line 93
    goto case_4___0;
  }
#line 96
  if (code3 == 3) {
#line 96
    goto case_3___0;
  }
#line 88
  goto switch_break___1;
  case_4___0: /* CIL Label */ 
  case_2___1: /* CIL Label */ 
  case_1___1: /* CIL Label */ 
  case_0___1: /* CIL Label */ 
#line 94
  return (69);
  case_3___0: /* CIL Label */ 
#line 97
  return (65);
  switch_break___1: /* CIL Label */ ;
  }
#line 99
  goto switch_break;
  case_3___1: /* CIL Label */ 
#line 102
  return (71);
  case_4___1: /* CIL Label */ 
  {
#line 107
  if (code3 == 0) {
#line 107
    goto case_0___2;
  }
#line 112
  if (code3 == 5) {
#line 112
    goto case_5___0;
  }
#line 112
  if (code3 == 3) {
#line 112
    goto case_5___0;
  }
#line 112
  if (code3 == 1) {
#line 112
    goto case_5___0;
  }
#line 115
  if (code3 == 2) {
#line 115
    goto case_2___2;
  }
#line 118
  if (code3 == 4) {
#line 118
    goto case_4___2;
  }
#line 121
  if (code3 == 6) {
#line 121
    goto case_6___0;
  }
#line 124
  if (code3 == 7) {
#line 124
    goto case_7___0;
  }
#line 105
  goto switch_break___2;
  case_0___2: /* CIL Label */ 
#line 108
  return (74);
  case_5___0: /* CIL Label */ 
  case_3___2: /* CIL Label */ 
  case_1___2: /* CIL Label */ 
#line 113
  return (75);
  case_2___2: /* CIL Label */ 
#line 116
  return (74);
  case_4___2: /* CIL Label */ 
#line 119
  return (76);
  case_6___0: /* CIL Label */ 
#line 122
  return (78);
  case_7___0: /* CIL Label */ 
#line 125
  return (69);
  switch_break___2: /* CIL Label */ ;
  }
#line 127
  goto switch_break;
  case_5___1: /* CIL Label */ 
#line 130
  return (76);
  case_6___1: /* CIL Label */ 
#line 133
  return (69);
  case_7___1: /* CIL Label */ 
#line 136
  return (65);
  switch_break: /* CIL Label */ ;
  }
#line 138
  return (69);
}
}
#line 150 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sysexits.c"
char *exitstat(char *excode ) 
{ 
  char *c ;
  int i ;
  char *exitmsg ;
  long tmp ;

  {
#line 158
  if ((unsigned long )excode == (unsigned long )((void *)0)) {
#line 159
    return (excode);
  } else
#line 158
  if ((int )*excode == 0) {
#line 159
    return (excode);
  }
  {
#line 160
  tmp = strtol((char const   */* __restrict  */)excode, (char **/* __restrict  */)(& c),
               10);
#line 160
  i = (int )tmp;
  }
#line 161
  if ((int )*c != 0) {
#line 162
    return (excode);
  }
  {
#line 163
  exitmsg = sm_sysexitmsg(i);
  }
#line 164
  if ((unsigned long )exitmsg != (unsigned long )((void *)0)) {
#line 165
    return (exitmsg);
  }
#line 166
  return (excode);
}
}
#line 2411 "./sendmail.h"
void markstats(ENVELOPE *e , ADDRESS *to , int type ) ;
#line 2412
void clearstats(void) ;
#line 2413
void poststats(char *sfile ) ;
#line 20 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stats.c"
static struct statistics Stat  ;
#line 22 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stats.c"
static bool GotStats  =    0;
#line 42 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stats.c"
void markstats(ENVELOPE *e , ADDRESS *to , int type ) 
{ 


  {
  {
#line 50
  if (type == 113) {
#line 50
    goto case_113;
  }
#line 55
  if (type == 114) {
#line 55
    goto case_114;
  }
#line 66
  if (type == 99) {
#line 66
    goto case_99;
  }
#line 73
  if (type == 110) {
#line 73
    goto case_110;
  }
#line 90
  goto switch_default;
  case_113: /* CIL Label */ 
#line 51
  if ((unsigned long )e->e_from.q_mailer != (unsigned long )((void *)0)) {
#line 52
    (Stat.stat_nq[(e->e_from.q_mailer)->m_mno]) ++;
  }
#line 53
  goto switch_break;
  case_114: /* CIL Label */ 
#line 56
  if ((unsigned long )e->e_from.q_mailer != (unsigned long )((void *)0)) {
#line 58
    if ((e->e_flags & 16777216UL) != 0UL) {
#line 59
      (Stat.stat_nd[(e->e_from.q_mailer)->m_mno]) ++;
    } else {
#line 61
      (Stat.stat_nr[(e->e_from.q_mailer)->m_mno]) ++;
    }
  }
#line 63
  (Stat.stat_cr) ++;
#line 64
  goto switch_break;
  case_99: /* CIL Label */ 
#line 67
  if ((unsigned long )to == (unsigned long )((void *)0)) {
#line 68
    (Stat.stat_cf) ++;
  } else {
#line 70
    (Stat.stat_ct) ++;
  }
#line 71
  goto switch_break;
  case_110: /* CIL Label */ 
#line 74
  if ((unsigned long )to == (unsigned long )((void *)0)) {
#line 76
    if ((unsigned long )e->e_from.q_mailer != (unsigned long )((void *)0)) {
#line 78
      (Stat.stat_nf[(e->e_from.q_mailer)->m_mno]) ++;
#line 79
      Stat.stat_bf[(e->e_from.q_mailer)->m_mno] += (e->e_msgsize + 999L) / 1000L;
    }
  } else {
#line 85
    (Stat.stat_nt[(to->q_mailer)->m_mno]) ++;
#line 86
    Stat.stat_bt[(to->q_mailer)->m_mno] += (e->e_msgsize + 999L) / 1000L;
  }
#line 88
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 92
  return;
  switch_break: /* CIL Label */ ;
  }
#line 96
  GotStats = 1;
#line 97
  return;
}
}
#line 111 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stats.c"
void clearstats(void) 
{ 


  {
  {
#line 115
  memset((void *)(& Stat), '\000', (size_t )sizeof(Stat));
#line 116
  GotStats = 0;
  }
#line 117
  return;
}
}
#line 136 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stats.c"
static bool entered  =    0;
#line 131 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stats.c"
void poststats(char *sfile ) 
{ 
  int fd ;
  long sff ;
  struct statistics stats ;
  int *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  register int i ;
  ssize_t tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 137
  sff = 8320L;
#line 141
  if ((unsigned long )sfile == (unsigned long )((void *)0)) {
#line 142
    return;
  } else
#line 141
  if ((int )*sfile == 0) {
#line 142
    return;
  } else
#line 141
  if (! GotStats) {
#line 142
    return;
  } else
#line 141
  if (entered) {
#line 142
    return;
  }
  {
#line 143
  entered = 1;
#line 145
  time(& Stat.stat_itime);
#line 146
  Stat.stat_size = (short )sizeof(Stat);
#line 147
  Stat.stat_magic = 111070;
#line 148
  Stat.stat_version = 4;
  }
#line 150
  if (! (DontBlameSendmail[20UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 20UL % (8UL * sizeof(int ))))) {
#line 151
    sff |= 2L;
  }
#line 152
  if (! (DontBlameSendmail[19UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 19UL % (8UL * sizeof(int ))))) {
#line 153
    sff |= 512L;
  }
  {
#line 155
  fd = safeopen(sfile, 2, 384, sff);
  }
#line 156
  if (fd < 0) {
#line 158
    if (LogLevel > 12) {
      {
#line 159
      tmp = __errno_location();
#line 159
      tmp___0 = sm_errstring(*tmp);
#line 159
      sm_syslog(6, "*~*", "poststats: %s: %s", sfile, tmp___0);
      }
    }
    {
#line 161
    tmp___1 = __errno_location();
#line 161
    *tmp___1 = 0;
#line 162
    entered = 0;
    }
#line 163
    return;
  }
  {
#line 165
  tmp___2 = read(fd, (void *)((char *)(& stats)), (size_t )sizeof(stats));
  }
#line 165
  if ((unsigned long )tmp___2 == sizeof(stats)) {
#line 165
    if ((unsigned long )stats.stat_size == sizeof(stats)) {
#line 165
      if (stats.stat_magic == Stat.stat_magic) {
#line 165
        if (stats.stat_version == Stat.stat_version) {
#line 173
          i = 0;
          {
#line 173
          while (1) {
            while_continue: /* CIL Label */ ;
#line 173
            if (! (i < 25)) {
#line 173
              goto while_break;
            }
#line 175
            stats.stat_nf[i] += Stat.stat_nf[i];
#line 176
            stats.stat_bf[i] += Stat.stat_bf[i];
#line 177
            stats.stat_nt[i] += Stat.stat_nt[i];
#line 178
            stats.stat_bt[i] += Stat.stat_bt[i];
#line 179
            stats.stat_nr[i] += Stat.stat_nr[i];
#line 180
            stats.stat_nd[i] += Stat.stat_nd[i];
#line 181
            stats.stat_nq[i] += Stat.stat_nq[i];
#line 173
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 183
          stats.stat_cr += Stat.stat_cr;
#line 184
          stats.stat_ct += Stat.stat_ct;
#line 185
          stats.stat_cf += Stat.stat_cf;
        } else {
          {
#line 188
          memmove((void *)((char *)(& stats)), (void const   *)((char *)(& Stat)),
                  (size_t )sizeof(stats));
          }
        }
      } else {
        {
#line 188
        memmove((void *)((char *)(& stats)), (void const   *)((char *)(& Stat)), (size_t )sizeof(stats));
        }
      }
    } else {
      {
#line 188
      memmove((void *)((char *)(& stats)), (void const   *)((char *)(& Stat)), (size_t )sizeof(stats));
      }
    }
  } else {
    {
#line 188
    memmove((void *)((char *)(& stats)), (void const   *)((char *)(& Stat)), (size_t )sizeof(stats));
    }
  }
  {
#line 191
  lseek(fd, (off_t )0, 0);
#line 192
  write(fd, (void const   *)((char *)(& stats)), (size_t )sizeof(stats));
#line 193
  close(fd);
#line 196
  clearstats();
#line 197
  entered = 0;
  }
#line 198
  return;
}
}
#line 1506 "./sendmail.h"
STAB *stab(char *name , int type , int op ) ;
#line 1507
void stabapply(void (*func)(STAB * , int  ) , int arg ) ;
#line 2468
void copy_class(int src , int dst ) ;
#line 2542
void queueup_macros(int class , SM_FILE_T *qfp , ENVELOPE *e ) ;
#line 39 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c"
static STAB *SymTab[2003]  ;
#line 41 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c"
STAB *stab(char *name , int type , int op ) 
{ 
  register STAB *s ;
  register STAB **ps ;
  register int hfunc ;
  register char *p ;
  int len___0 ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long *lp ;
  void *tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 53
  if ((int )tTdvect[36] >= 5) {
    {
#line 54
    sm_dprintf((char *)"STAB: %s %d ", name, type);
    }
  }
#line 60
  hfunc = type;
#line 61
  p = name;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! ((int )*p != 0)) {
#line 61
      goto while_break;
    }
#line 62
    if (((int )*p & -128) == 0) {
      {
#line 62
      tmp___2 = __ctype_b_loc();
      }
#line 62
      if ((int const   )*(*tmp___2 + (int )*p) & 256) {
        {
#line 62
        tmp___0 = tolower((int )*p);
#line 62
        tmp___1 = tmp___0;
        }
      } else {
#line 62
        tmp___1 = (int )*p;
      }
    } else {
#line 62
      tmp___1 = (int )*p;
    }
#line 62
    hfunc = ((hfunc << 1) ^ (tmp___1 & 255)) % 2003;
#line 61
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  if ((int )tTdvect[36] >= 9) {
    {
#line 65
    sm_dprintf((char *)"(hfunc=%d) ", hfunc);
    }
  }
#line 67
  ps = & SymTab[hfunc];
#line 68
  if (type == 9) {
#line 68
    goto _L;
  } else
#line 68
  if (type == 10) {
    _L: /* CIL Label */ 
    {
#line 70
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 70
      s = *ps;
#line 70
      if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 70
        if (! ((int )s->s_symtype != type)) {
          {
#line 70
          tmp___3 = strcmp((char const   *)name, (char const   *)s->s_name);
          }
#line 70
          if (! tmp___3) {
#line 70
            goto while_break___0;
          }
        }
      } else {
#line 70
        goto while_break___0;
      }
#line 72
      ps = & s->s_next;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 76
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 76
      s = *ps;
#line 76
      if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 76
        if (! ((int )s->s_symtype != type)) {
          {
#line 76
          tmp___4 = sm_strcasecmp((char const   *)name, (char const   *)s->s_name);
          }
#line 76
          if (! tmp___4) {
#line 76
            goto while_break___1;
          }
        }
      } else {
#line 76
        goto while_break___1;
      }
#line 78
      ps = & s->s_next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 85
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 85
    goto _L___0;
  } else
#line 85
  if (op == 0) {
    _L___0: /* CIL Label */ 
#line 87
    if ((int )tTdvect[36] >= 5) {
#line 89
      if ((unsigned long )s == (unsigned long )((void *)0)) {
        {
#line 90
        sm_dprintf((char *)"not found\n");
        }
      } else {
        {
#line 93
        lp = (long *)(s->s_value.sv_class);
#line 95
        sm_dprintf((char *)"type %d val %lx %lx %lx %lx\n", (int )s->s_symtype, *(lp + 0),
                   *(lp + 1), *(lp + 2), *(lp + 3));
        }
      }
    }
#line 99
    return (s);
  }
#line 106
  if ((int )tTdvect[36] >= 5) {
    {
#line 107
    sm_dprintf((char *)"entered\n");
    }
  }
  {
#line 112
  if (type == 1) {
#line 112
    goto case_1;
  }
#line 116
  if (type == 2) {
#line 116
    goto case_2;
  }
#line 120
  if (type == 3) {
#line 120
    goto case_3;
  }
#line 124
  if (type == 4) {
#line 124
    goto case_4;
  }
#line 128
  if (type == 5) {
#line 128
    goto case_5;
  }
#line 132
  if (type == 6) {
#line 132
    goto case_6;
  }
#line 136
  if (type == 7) {
#line 136
    goto case_7;
  }
#line 140
  if (type == 8) {
#line 140
    goto case_8;
  }
#line 144
  if (type == 9) {
#line 144
    goto case_9;
  }
#line 148
  if (type == 10) {
#line 148
    goto case_10;
  }
#line 152
  if (type == 12) {
#line 152
    goto case_12;
  }
#line 156
  if (type == 11) {
#line 156
    goto case_11;
  }
#line 167
  if (type == 14) {
#line 167
    goto case_14;
  }
#line 172
  if (type == 15) {
#line 172
    goto case_15;
  }
#line 182
  goto switch_default;
  case_1: /* CIL Label */ 
#line 113
  len___0 = (int )sizeof(s->s_value.sv_class);
#line 114
  goto switch_break;
  case_2: /* CIL Label */ 
#line 117
  len___0 = (int )sizeof(s->s_value.sv_addr);
#line 118
  goto switch_break;
  case_3: /* CIL Label */ 
#line 121
  len___0 = (int )sizeof(s->s_value.sv_mailer);
#line 122
  goto switch_break;
  case_4: /* CIL Label */ 
#line 125
  len___0 = (int )sizeof(s->s_value.sv_alias);
#line 126
  goto switch_break;
  case_5: /* CIL Label */ 
#line 129
  len___0 = (int )sizeof(s->s_value.sv_mapclass);
#line 130
  goto switch_break;
  case_6: /* CIL Label */ 
#line 133
  len___0 = (int )sizeof(s->s_value.sv_map);
#line 134
  goto switch_break;
  case_7: /* CIL Label */ 
#line 137
  len___0 = (int )sizeof(s->s_value.sv_hostsig);
#line 138
  goto switch_break;
  case_8: /* CIL Label */ 
#line 141
  len___0 = (int )sizeof(s->s_value.sv_namecanon);
#line 142
  goto switch_break;
  case_9: /* CIL Label */ 
#line 145
  len___0 = (int )sizeof(s->s_value.sv_macro);
#line 146
  goto switch_break;
  case_10: /* CIL Label */ 
#line 149
  len___0 = (int )sizeof(s->s_value.sv_ruleset);
#line 150
  goto switch_break;
  case_12: /* CIL Label */ 
#line 153
  len___0 = (int )sizeof(s->s_value.sv_header);
#line 154
  goto switch_break;
  case_11: /* CIL Label */ 
#line 157
  len___0 = (int )sizeof(s->s_value.sv_service);
#line 158
  goto switch_break;
  case_14: /* CIL Label */ 
#line 168
  len___0 = (int )sizeof(s->s_value.sv_milter);
#line 169
  goto switch_break;
  case_15: /* CIL Label */ 
#line 173
  len___0 = (int )sizeof(s->s_value.sv_queue);
#line 174
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 191
  if (type >= 17) {
#line 192
    len___0 = (int )sizeof(s->s_value.sv_mci);
  } else {
    {
#line 195
    syserr("stab: unknown symbol type %d", type);
#line 196
    len___0 = (int )sizeof(s->s_value);
    }
  }
#line 198
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 200
  len___0 = (int )((unsigned long )len___0 + (sizeof(*s) - sizeof(s->s_value)));
#line 202
  if ((int )tTdvect[36] >= 15) {
    {
#line 203
    sm_dprintf((char *)"size of stab entry: %d\n", len___0);
    }
  }
  {
#line 206
  tmp___5 = sm_malloc_tagged_x((size_t )len___0, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c",
                               206, 0);
#line 206
  s = (STAB *)tmp___5;
#line 207
  memset((void *)((char *)s), '\000', (size_t )len___0);
#line 208
  s->s_name = sm_pstrdup_x((char const   *)name);
#line 209
  s->s_symtype = (short )type;
#line 212
  *ps = s;
  }
#line 215
  if (type == 10) {
#line 216
    s->s_value.sv_ruleset = -1;
  }
#line 218
  return (s);
}
}
#line 232 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c"
void stabapply(void (*func)(STAB * , int  ) , int arg ) 
{ 
  register STAB **shead ;
  register STAB *s ;
  char *__cil_tmp5 ;

  {
#line 240
  shead = SymTab;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! ((unsigned long )shead < (unsigned long )(& SymTab[2003]))) {
#line 240
      goto while_break;
    }
#line 242
    s = *shead;
    {
#line 242
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 242
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 242
        goto while_break___0;
      }
#line 244
      if ((int )tTdvect[36] >= 90) {
        {
#line 245
        sm_dprintf((char *)"stabapply: trying %d/%s\n", (int )s->s_symtype, s->s_name);
        }
      }
      {
#line 247
      (*func)(s, arg);
#line 242
      s = s->s_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 240
    shead ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  return;
}
}
#line 266 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c"
void queueup_macros(int class , SM_FILE_T *qfp , ENVELOPE *e ) 
{ 
  register STAB **shead ;
  register STAB *s ;
  int m ;
  char *p ;
  char *tmp ;
  char *__cil_tmp9 ;

  {
#line 275
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 276
    return;
  }
#line 278
  class = (int )((unsigned int )class & 255U);
#line 279
  shead = SymTab;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! ((unsigned long )shead < (unsigned long )(& SymTab[2003]))) {
#line 279
      goto while_break;
    }
#line 281
    s = *shead;
    {
#line 281
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 281
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 281
        goto while_break___0;
      }
#line 286
      if ((int )s->s_symtype == 1) {
#line 286
        if (s->s_value.sv_class[(unsigned long )((unsigned char )((unsigned int )class & 255U)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )((unsigned int )class & 255U)) % (8UL * sizeof(int )))) {
          {
#line 286
          m = macid_parse(s->s_name, (char **)((void *)0));
          }
#line 286
          if (m != 0) {
            {
#line 286
            p = macvalue(m, e);
            }
#line 286
            if ((unsigned long )p != (unsigned long )((void *)0)) {
              {
#line 291
              tmp = denlstring(p, 1, 0);
#line 291
              sm_io_fprintf(qfp, -2, "$%s%s\n", s->s_name, tmp);
              }
            }
          }
        }
      }
#line 281
      s = s->s_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 279
    shead ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  return;
}
}
#line 311 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c"
void copy_class(int src , int dst ) 
{ 
  register STAB **shead ;
  register STAB *s ;

  {
#line 319
  src = (int )((unsigned int )src & 255U);
#line 320
  dst = (int )((unsigned int )dst & 255U);
#line 321
  shead = SymTab;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! ((unsigned long )shead < (unsigned long )(& SymTab[2003]))) {
#line 321
      goto while_break;
    }
#line 323
    s = *shead;
    {
#line 323
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 323
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 323
        goto while_break___0;
      }
#line 325
      if ((int )s->s_symtype == 1) {
#line 325
        if (s->s_value.sv_class[(unsigned long )((unsigned char )src) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )src) % (8UL * sizeof(int )))) {
#line 327
          s->s_value.sv_class[(unsigned long )((unsigned char )dst) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )dst) % (8UL * sizeof(int ));
        }
      }
#line 323
      s = s->s_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 321
    shead ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  return;
}
}
#line 360 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c"
void rmexpstab(void) 
{ 
  int i ;
  STAB *s ;
  STAB *p ;
  STAB *f ;
  time_t now ;
  char *o ;
  char *o___0 ;
  char *o___1 ;
  char *o___2 ;
  char *o___3 ;
  char *o___4 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 367
  now = curtime();
#line 368
  i = 0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (i < 2003)) {
#line 368
      goto while_break;
    }
#line 370
    p = (STAB *)((void *)0);
#line 371
    s = SymTab[i];
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 372
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 372
        goto while_break___0;
      }
      {
#line 376
      if ((int )s->s_symtype == 7) {
#line 376
        goto case_7;
      }
#line 382
      if ((int )s->s_symtype == 8) {
#line 382
        goto case_8;
      }
#line 388
      goto switch_default;
      case_7: /* CIL Label */ 
#line 377
      if (s->s_value.sv_hostsig.hs_exp >= now) {
#line 378
        goto next;
      }
      {
#line 379
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 379
        o = s->s_value.sv_hostsig.hs_sig;
#line 379
        s->s_value.sv_hostsig.hs_sig = (char *)((void *)0);
#line 379
        if ((unsigned long )o != (unsigned long )((void *)0)) {
          {
#line 379
          sm_free_tagged((void *)o, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c",
                         379);
          }
        }
#line 379
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 380
      goto switch_break;
      case_8: /* CIL Label */ 
#line 383
      if (s->s_value.sv_namecanon.nc_exp >= now) {
#line 384
        goto next;
      }
      {
#line 385
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 385
        o___0 = s->s_value.sv_namecanon.nc_cname;
#line 385
        s->s_value.sv_namecanon.nc_cname = (char *)((void *)0);
#line 385
        if ((unsigned long )o___0 != (unsigned long )((void *)0)) {
          {
#line 385
          sm_free_tagged((void *)o___0, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c",
                         385);
          }
        }
#line 385
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 386
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 389
      if ((int )s->s_symtype >= 17) {
        {
#line 392
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 392
          o___1 = s->s_value.sv_mci.mci_status;
#line 392
          s->s_value.sv_mci.mci_status = (char *)((void *)0);
#line 392
          if ((unsigned long )o___1 != (unsigned long )((void *)0)) {
            {
#line 392
            sm_free_tagged((void *)o___1, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c",
                           392);
            }
          }
#line 392
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 393
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 393
          o___2 = s->s_value.sv_mci.mci_rstatus;
#line 393
          s->s_value.sv_mci.mci_rstatus = (char *)((void *)0);
#line 393
          if ((unsigned long )o___2 != (unsigned long )((void *)0)) {
            {
#line 393
            sm_free_tagged((void *)o___2, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c",
                           393);
            }
          }
#line 393
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 394
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 394
          o___3 = s->s_value.sv_mci.mci_heloname;
#line 394
          s->s_value.sv_mci.mci_heloname = (char *)((void *)0);
#line 394
          if ((unsigned long )o___3 != (unsigned long )((void *)0)) {
            {
#line 394
            sm_free_tagged((void *)o___3, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c",
                           394);
            }
          }
#line 394
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 404
        if ((unsigned long )s->s_value.sv_mci.mci_rpool != (unsigned long )((void *)0)) {
          {
#line 406
          sm_rpool_free(s->s_value.sv_mci.mci_rpool);
#line 407
          s->s_value.sv_mci.mci_macro.mac_rpool = (SM_RPOOL_T *)((void *)0);
#line 408
          s->s_value.sv_mci.mci_rpool = (SM_RPOOL_T *)((void *)0);
          }
        }
#line 410
        goto switch_break;
      }
      next: 
#line 413
      p = s;
#line 414
      s = s->s_next;
#line 415
      goto while_continue___0;
      switch_break: /* CIL Label */ ;
      }
      {
#line 419
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 419
        o___4 = s->s_name;
#line 419
        s->s_name = (char *)((void *)0);
#line 419
        if ((unsigned long )o___4 != (unsigned long )((void *)0)) {
          {
#line 419
          sm_free_tagged((void *)o___4, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c",
                         419);
          }
        }
#line 419
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 420
      f = s;
#line 421
      s = s->s_next;
#line 422
      sm_free_tagged((void *)f, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c",
                     422);
      }
#line 423
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 424
        SymTab[i] = s;
      } else {
#line 426
        p->s_next = s;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 368
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  return;
}
}
#line 445 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c"
static int prevt[18]  ;
#line 445
void dumpstab(void) ;
#line 445 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c"
static int prev  =    0;
#line 440 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/stab.c"
void dumpstab(void) 
{ 
  int i ;
  int t ;
  int total ;
  int types[18] ;
  STAB *s ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 447
  total = 0;
#line 448
  i = 0;
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    if (! (i < 18)) {
#line 448
      goto while_break;
    }
#line 449
    types[i] = 0;
#line 448
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  i = 0;
  {
#line 450
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 450
    if (! (i < 2003)) {
#line 450
      goto while_break___0;
    }
#line 452
    s = SymTab[i];
    {
#line 453
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 453
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 453
        goto while_break___1;
      }
#line 455
      total ++;
#line 456
      t = (int )s->s_symtype;
#line 457
      if (t > 17) {
#line 458
        t = 17;
      }
#line 459
      (types[t]) ++;
#line 460
      s = s->s_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 450
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 463
  sm_syslog(6, "*~*", "stab: total=%d (%d)", total, total - prev);
#line 464
  prev = total;
#line 465
  i = 0;
  }
  {
#line 465
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 465
    if (! (i < 18)) {
#line 465
      goto while_break___2;
    }
#line 467
    if (types[i] != 0) {
      {
#line 469
      sm_syslog(6, "*~*", "stab: type[%2d]=%2d (%d)", i, types[i], types[i] - prevt[i]);
      }
    }
#line 472
    prevt[i] = types[i];
#line 465
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 474
  return;
}
}
#line 869 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 237 "/usr/include/resolv.h"
extern struct __res_state *__res_state(void)  __attribute__((__const__)) ;
#line 341 "./sendmail.h"
ADDRESS *parseaddr(char *addr , ADDRESS *a , int flags , int delim , char **delimptr ,
                   ENVELOPE *e , bool isrcpt ) ;
#line 345
ADDRESS *recipient(ADDRESS *new , ADDRESS **sendq , int aliaslevel , ENVELOPE *e ) ;
#line 353
void setsender(char *from , ENVELOPE *e , char **delimptr , int delimchar , bool internal ) ;
#line 964
void dropenvelope(ENVELOPE *e , bool fulldrop , bool split ) ;
#line 965
ENVELOPE *newenvelope(ENVELOPE *e , ENVELOPE *parent , SM_RPOOL_T *rpool ) ;
#line 1100
int rscheck(char *rwset , char *p1 , char *p2 , ENVELOPE *e , int flags , int logl ,
            char *host , char *logid ) ;
#line 1101
int rscap(char *rwset , char *p1 , char *p2 , ENVELOPE *e , char ***pvp , char *pvpbuf ,
          int size ) ;
#line 1104
void translate_dollars(char *bp___3 ) ;
#line 1105
bool wordinclass(char *str , int cl ) ;
#line 1623
unsigned long PrivacyFlags ;
#line 1719
int MilterLogLevel ;
#line 1944
int NumQueue ;
#line 1946
int QueueMode ;
#line 1953
QUEUE_CHAR *QueueLimitRecipient ;
#line 1955
QUEUEGRP *Queue[51] ;
#line 1962
void initsys(ENVELOPE *e ) ;
#line 1964
int name2qid(char *queuename___0 ) ;
#line 1968
char *queuename(ENVELOPE *e , int type ) ;
#line 1969
void queueup(ENVELOPE *e , bool announce , bool msync ) ;
#line 1970
bool runqueue(bool forkflag , bool verbose , bool persistent , bool runall ) ;
#line 1971
bool run_work_group(int wgrp , int flags ) ;
#line 1975
bool shouldqueue(long pri , time_t ct ) ;
#line 2147
bool AllowBogusHELO ;
#line 2159
bool DontLockReadFiles ;
#line 2169
bool LogUsrErrs ;
#line 2174
bool OnlyOneError ;
#line 2175
bool QuickAbort ;
#line 2182
bool SendMIMEErrors ;
#line 2199
int BadRcptThrottle ;
#line 2204
int CurrentLA ;
#line 2206
int DelayLA ;
#line 2208
int Errors ;
#line 2209
int ExitStat ;
#line 2215
int MaxChildren ;
#line 2222
int MaxNOOPCommands ;
#line 2224
int MaxRcptPerMsg ;
#line 2235
int *PNumFileSys ;
#line 2249
int SuperSafe ;
#line 2270
time_t DeliverByMin ;
#line 2276
long MaxMessageSize ;
#line 2291
char *FileName ;
#line 2296
char *HelpFile ;
#line 2313
char *SmtpGreeting ;
#line 2323
SM_FILE_T *InChannel ;
#line 2324
SM_FILE_T *OutChannel ;
#line 2335
union bigsockaddr RealHostAddr ;
#line 2336
struct sm_exc_type  const  EtypeQuickAbort ;
#line 2346
void closexscript(ENVELOPE *e ) ;
#line 2350
void buffer_errors(void) ;
#line 2351
void flush_errors(bool print ) ;
#line 2369
void logdelivery(MAILER *m , struct mailer_con_info *mci , char *dsn , char const   *status ,
                 ADDRESS *ctladdr , time_t xstart , ENVELOPE *e ) ;
#line 2370
void logsender(ENVELOPE *e , char *msgid ) ;
#line 2376
void smtp(char * volatile  nullserver , unsigned int *d_flags , ENVELOPE * volatile  e ) ;
#line 2400
pid_t doworklist(ENVELOPE *el , bool forkflag , bool requeueflag ) ;
#line 2403
void sendall(ENVELOPE *e , int mode ) ;
#line 2426
bool milter_can_delrcpts(void) ;
#line 2427
bool milter_init(ENVELOPE *e , char *state ) ;
#line 2428
void milter_quit(ENVELOPE *e ) ;
#line 2429
void milter_abort(ENVELOPE *e ) ;
#line 2430
char *milter_connect(char *hostname , union bigsockaddr addr , ENVELOPE *e , char *state ) ;
#line 2431
char *milter_helo(char *helo , ENVELOPE *e , char *state ) ;
#line 2432
char *milter_envfrom(char **args , ENVELOPE *e , char *state ) ;
#line 2434
char *milter_envrcpt(char **args , ENVELOPE *e , char *state ) ;
#line 2435
char *milter_data(ENVELOPE *e , char *state ) ;
#line 2443
void auth_warning(ENVELOPE *e , char const   *msg  , ...) ;
#line 2464
void collect(SM_FILE_T *fp , bool smtpmode , HDR **hdrp , ENVELOPE *e , bool rsetsize ) ;
#line 2473
void dferror(SM_FILE_T * volatile  df , char *msg , ENVELOPE *e ) ;
#line 2474
void disconnect(int droplev , ENVELOPE *e ) ;
#line 2484
bool enoughdiskspace(long msize , ENVELOPE *e ) ;
#line 2491
void finis(bool drop , bool cleanup , int volatile   exitstat___0 ) ;
#line 2500
int getla(void) ;
#line 2504
void help(char *topic , ENVELOPE *e ) ;
#line 2516
void logundelrcpts(ENVELOPE *e , char *msg , int level , bool all ) ;
#line 2562
void settime(ENVELOPE *e ) ;
#line 2572
void sm_getla(void) ;
#line 2577
bool split_by_recipient(ENVELOPE *e ) ;
#line 2592
void unlockqueue(ENVELOPE *e ) ;
#line 2620
bool xtextok(char *s ) ;
#line 68 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static unsigned int srvfeatures(ENVELOPE *e , char *clientname , unsigned int features ) ;
#line 71
static time_t checksmtpattack(unsigned int volatile   *pcounter , unsigned int maxcount ,
                              bool waitnow , char *cname , ENVELOPE *e ) ;
#line 73
static void mail_esmtp_args(char *kp , char *vp , ENVELOPE *e ) ;
#line 74
static void printvrfyaddr(ADDRESS *a , bool last , bool vrfy ) ;
#line 75
static void rcpt_esmtp_args(ADDRESS *a , char *kp , char *vp , ENVELOPE *e ) ;
#line 76
static char *skipword(char * volatile  p , char *w ) ;
#line 77
static void setup_smtpd_io(void) ;
#line 189 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static struct cmd CmdTab[21]  = 
#line 189
  {      {(char *)"mail", 1}, 
        {(char *)"rcpt", 2}, 
        {(char *)"data", 3}, 
        {(char *)"rset", 4}, 
        {(char *)"vrfy", 5}, 
        {(char *)"expn", 6}, 
        {(char *)"help", 10}, 
        {(char *)"noop", 7}, 
        {(char *)"quit", 8}, 
        {(char *)"helo", 9}, 
        {(char *)"ehlo", 11}, 
        {(char *)"etrn", 12}, 
        {(char *)"verb", 17}, 
        {(char *)"send", 19}, 
        {(char *)"saml", 19}, 
        {(char *)"soml", 19}, 
        {(char *)"turn", 19}, 
        {(char *)"showq", 24}, 
        {(char *)"debug", 25}, 
        {(char *)"wiz", 23}, 
        {(char *)((void *)0), 0}};
#line 222 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static char *CurSmtpClient  ;
#line 266 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static SM_DEBUG_T DebugLeakSmtp  =    {SmDebugMagic, (SM_ATOMIC_UINT_T )-1, (char *)"leak_smtp", (char *)"@(#)$Debug: leak_smtp - trace memory leaks during SMTP processing $",
    (SM_DEBUG_T *)((void *)0)};
#line 282
static bool smtp_data(SMTP_T *smtp___0 , ENVELOPE *e ) ;
#line 2203
char *FullName ;
#line 451 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
void smtp(char * volatile  nullserver , unsigned int *d_flags , ENVELOPE * volatile  e ) 
{ 
  register char * volatile  p ;
  register struct cmd * volatile  c ;
  char *cmd ;
  ADDRESS *vrfyqueue ;
  ADDRESS *a ;
  bool volatile   gothello ;
  bool vrfy ;
  char * volatile  protocol ;
  char * volatile  sendinghost ;
  char * volatile  peerhostname ;
  char *delimptr ;
  char *id ;
  unsigned int volatile   n_badcmds ;
  unsigned int volatile   n_badrcpts ;
  unsigned int volatile   n_verifies ;
  unsigned int volatile   n_etrn ;
  unsigned int volatile   n_noop ;
  unsigned int volatile   n_helo ;
  int volatile   save_sevenbitinput ;
  bool ok ;
  bool volatile   tempfail ;
  time_t volatile   wt ;
  time_t volatile   previous ;
  bool volatile   lognullconnection ;
  register char *q ;
  SMTP_T smtp___0 ;
  char *addr ;
  char *greetcode ;
  char *hostname ;
  QUEUE_CHAR *new ;
  int argno ;
  char *args[20] ;
  char inp[2048] ;
  char cmdbuf[2048] ;
  int r ;
  unsigned int volatile   features ;
  time_t volatile   log_delay___0 ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  char state ;
  char state___0 ;
  char *response ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  time_t msecs ;
  char **pvp ;
  char pvpbuf[1256] ;
  char *tmp___10 ;
  int fd ;
  fd_set readfds ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  char *tmp___11 ;
  int tmp___12 ;
  register char __result ;
  char *tmp___13 ;
  char * volatile  tmp___14 ;
  size_t tmp___15 ;
  char * volatile  tmp___16 ;
  unsigned short const   **tmp___17 ;
  char *tmp___18 ;
  unsigned short const   **tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  SM_EXC_HANDLER_T _h ;
  char *d ;
  int tmp___22 ;
  char const   *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  unsigned short const   **tmp___26 ;
  char *tmp___27 ;
  char * volatile  tmp___28 ;
  unsigned short const   **tmp___29 ;
  unsigned short const   **tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  time_t dnow ;
  char *tmp___34 ;
  char *tmp___35 ;
  unsigned short const   **tmp___36 ;
  unsigned short const   **tmp___37 ;
  unsigned short const   **tmp___38 ;
  time_t dnow___0 ;
  char *tmp___39 ;
  char *tmp___40 ;
  time_t tmp___41 ;
  size_t tmp___42 ;
  unsigned short const   **tmp___43 ;
  unsigned short const   **tmp___44 ;
  unsigned short const   **tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  int tmp___48 ;
  SM_RPOOL_T *tmp___49 ;
  ENVELOPE *tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  char state___1 ;
  char *response___0 ;
  char *tmp___53 ;
  time_t dnow___1 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  bool tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  char *tmp___61 ;
  SM_EXC_HANDLER_T _h___0 ;
  char *tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  bool tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  char *kp ;
  char *vp ;
  char *equal ;
  unsigned short const   **tmp___72 ;
  unsigned short const   **tmp___73 ;
  char * volatile  tmp___74 ;
  unsigned short const   **tmp___75 ;
  char * volatile  tmp___76 ;
  char const   *tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  bool tmp___82 ;
  char state___2 ;
  char *response___1 ;
  int savelogusrerrs ;
  bool tsave ;
  bool tsave___0 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  bool tmp___88 ;
  SM_EXC_T *exc  __attribute__((__unused__)) ;
  int tmp___89 ;
  time_t dnow___2 ;
  char *tmp___90 ;
  char *tmp___91 ;
  char buf___16[16] ;
  unsigned int volatile   tmp___92 ;
  int tmp___93 ;
  SM_EXC_HANDLER_T _h___1 ;
  bool tmp___94 ;
  char *tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  char *tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  char *kp___0 ;
  char *vp___0 ;
  char *equal___0 ;
  unsigned short const   **tmp___106 ;
  unsigned short const   **tmp___107 ;
  char * volatile  tmp___108 ;
  unsigned short const   **tmp___109 ;
  char * volatile  tmp___110 ;
  char const   *tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  char state___3 ;
  char *response___2 ;
  int savelogusrerrs___0 ;
  bool tsave___1 ;
  bool tsave___2 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  char const   *tmp___122 ;
  char buf___17[16] ;
  unsigned int volatile   tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  bool tmp___128 ;
  SM_EXC_T *exc___0  __attribute__((__unused__)) ;
  char buf___18[16] ;
  unsigned int volatile   tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  time_t dnow___3 ;
  char *tmp___132 ;
  char *tmp___133 ;
  bool tmp___134 ;
  int tmp___135 ;
  SM_RPOOL_T *tmp___136 ;
  ENVELOPE *tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  time_t dnow___4 ;
  char const   *tmp___140 ;
  char *tmp___141 ;
  char const   *tmp___142 ;
  char *tmp___143 ;
  char const   *tmp___144 ;
  char const   *tmp___145 ;
  time_t tmp___146 ;
  time_t tmp___147 ;
  char *tmp___148 ;
  int tmp___149 ;
  char *tmp___150 ;
  SM_EXC_HANDLER_T _h___2 ;
  unsigned short const   **tmp___151 ;
  char const   *tmp___152 ;
  int tmp___153 ;
  time_t t ;
  time_t tmp___154 ;
  char const   *tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  bool tmp___159 ;
  SM_EXC_T *exc___1  __attribute__((__unused__)) ;
  int tmp___160 ;
  time_t dnow___5 ;
  char *tmp___161 ;
  char *tmp___162 ;
  char *tmp___163 ;
  size_t tmp___164 ;
  time_t tmp___165 ;
  int tmp___166 ;
  char *tmp___167 ;
  int i ;
  int qgrp ;
  void *tmp___168 ;
  time_t dnow___6 ;
  char *tmp___169 ;
  char *tmp___170 ;
  time_t dnow___7 ;
  char *tmp___171 ;
  char *tmp___172 ;
  time_t tmp___173 ;
  char *d___0 ;
  int tmp___174 ;
  time_t dnow___8 ;
  char *tmp___175 ;
  char *tmp___176 ;
  time_t tmp___177 ;
  time_t dnow___9 ;
  char *tmp___178 ;
  char *tmp___179 ;
  char *tmp___180 ;
  char *tmp___181 ;
  time_t dnow___10 ;
  char *tmp___182 ;
  char *tmp___183 ;
  char *tmp___184 ;
  time_t dnow___11 ;
  char *tmp___185 ;
  char *tmp___186 ;
  int *tmp___187 ;
  int tmp___188 ;
  int tmp___189 ;
  bool tmp___191 ;
  SM_EXC_T *exc___2  __attribute__((__unused__)) ;
  int tmp___192 ;
  void *__cil_tmp294 ;
  void *__cil_tmp295 ;
  void *__cil_tmp296 ;
  void *__cil_tmp297 ;
  void *__cil_tmp298 ;
  void *__cil_tmp299 ;
  void *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;
  char *__cil_tmp345 ;
  char *__cil_tmp346 ;
  char *__cil_tmp347 ;
  char *__cil_tmp348 ;
  char *__cil_tmp349 ;
  char *__cil_tmp350 ;
  char *__cil_tmp351 ;
  char *__cil_tmp352 ;
  char *__cil_tmp353 ;
  char *__cil_tmp354 ;
  char *__cil_tmp355 ;
  char *__cil_tmp356 ;
  char *__cil_tmp357 ;
  char *__cil_tmp358 ;
  char *__cil_tmp359 ;
  char *__cil_tmp360 ;
  char *__cil_tmp361 ;
  char *__cil_tmp362 ;
  char *__cil_tmp363 ;
  char *__cil_tmp364 ;
  char *__cil_tmp365 ;
  char *__cil_tmp366 ;
  char *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;
  char *__cil_tmp370 ;
  char *__cil_tmp371 ;
  char *__cil_tmp372 ;
  char *__cil_tmp373 ;
  char *__cil_tmp374 ;
  char *__cil_tmp375 ;
  char *__cil_tmp376 ;
  char *__cil_tmp377 ;
  char *__cil_tmp378 ;
  char *__cil_tmp379 ;
  char *__cil_tmp380 ;
  char *__cil_tmp381 ;
  char *__cil_tmp382 ;
  char *__cil_tmp383 ;
  char *__cil_tmp384 ;
  char *__cil_tmp385 ;
  char *__cil_tmp386 ;
  char *__cil_tmp387 ;
  char *__cil_tmp388 ;
  char *__cil_tmp389 ;
  char *__cil_tmp390 ;
  char *__cil_tmp391 ;
  char *__cil_tmp392 ;
  char *__cil_tmp393 ;
  char *__cil_tmp394 ;
  char *__cil_tmp395 ;
  char *__cil_tmp396 ;
  char *__cil_tmp397 ;
  char *__cil_tmp398 ;
  char *__cil_tmp399 ;
  char *__cil_tmp400 ;
  char *__cil_tmp401 ;
  char *__cil_tmp402 ;
  char *__cil_tmp403 ;
  char *__cil_tmp404 ;
  char *__cil_tmp405 ;
  char *__cil_tmp406 ;
  char *__cil_tmp407 ;
  char *__cil_tmp408 ;
  char *__cil_tmp409 ;
  char *__cil_tmp410 ;
  char *__cil_tmp411 ;
  char *__cil_tmp412 ;
  char *__cil_tmp413 ;
  char *__cil_tmp414 ;
  char *__cil_tmp415 ;
  char *__cil_tmp416 ;
  char *__cil_tmp417 ;
  char *__cil_tmp418 ;
  char *__cil_tmp419 ;
  char *__cil_tmp420 ;
  char *__cil_tmp421 ;
  char *__cil_tmp422 ;
  char *__cil_tmp423 ;
  char *__cil_tmp424 ;
  char *__cil_tmp425 ;
  char *__cil_tmp426 ;
  char *__cil_tmp427 ;
  char *__cil_tmp428 ;
  char *__cil_tmp429 ;
  char *__cil_tmp430 ;
  char *__cil_tmp431 ;
  char *__cil_tmp432 ;
  char *__cil_tmp433 ;
  char *__cil_tmp434 ;
  char *__cil_tmp435 ;
  char *__cil_tmp436 ;
  char *__cil_tmp437 ;
  char *__cil_tmp438 ;
  char *__cil_tmp439 ;
  char *__cil_tmp440 ;
  char *__cil_tmp441 ;
  char *__cil_tmp442 ;
  char *__cil_tmp443 ;
  char *__cil_tmp444 ;
  char *__cil_tmp445 ;
  char *__cil_tmp446 ;
  char *__cil_tmp447 ;
  char *__cil_tmp448 ;
  char *__cil_tmp449 ;
  char *__cil_tmp450 ;
  char *__cil_tmp451 ;
  char *__cil_tmp452 ;
  char *__cil_tmp453 ;
  char *__cil_tmp454 ;
  char *__cil_tmp455 ;
  char *__cil_tmp456 ;
  char *__cil_tmp457 ;
  char *__cil_tmp458 ;
  char *__cil_tmp459 ;
  char *__cil_tmp460 ;
  char *__cil_tmp461 ;
  char *__cil_tmp462 ;
  char *__cil_tmp463 ;
  char *__cil_tmp464 ;
  char *__cil_tmp465 ;
  char *__cil_tmp466 ;
  char *__cil_tmp467 ;
  char *__cil_tmp468 ;
  char *__cil_tmp469 ;
  char *__cil_tmp470 ;
  char *__cil_tmp471 ;
  char *__cil_tmp472 ;
  char *__cil_tmp473 ;
  char *__cil_tmp474 ;
  char *__cil_tmp475 ;
  char *__cil_tmp476 ;
  char *__cil_tmp477 ;
  char *__cil_tmp478 ;
  char *__cil_tmp479 ;
  char *__cil_tmp480 ;
  char *__cil_tmp481 ;
  char *__cil_tmp482 ;
  char *__cil_tmp483 ;
  char *__cil_tmp484 ;
  char *__cil_tmp485 ;
  char *__cil_tmp486 ;
  char *__cil_tmp487 ;
  char *__cil_tmp488 ;
  char *__cil_tmp489 ;
  char *__cil_tmp490 ;
  char *__cil_tmp491 ;
  char *__cil_tmp492 ;
  char *__cil_tmp493 ;
  char *__cil_tmp494 ;
  char *__cil_tmp495 ;
  char *__cil_tmp496 ;
  char *__cil_tmp497 ;
  char *__cil_tmp498 ;
  char *__cil_tmp499 ;
  char *__cil_tmp500 ;
  char *__cil_tmp501 ;
  char *__cil_tmp502 ;
  char *__cil_tmp503 ;
  char *__cil_tmp504 ;
  char *__cil_tmp505 ;
  char *__cil_tmp506 ;
  char *__cil_tmp507 ;
  char *__cil_tmp508 ;
  char *__cil_tmp509 ;
  char *__cil_tmp510 ;
  char *__cil_tmp511 ;
  char *__cil_tmp512 ;
  char *__cil_tmp513 ;
  char *__cil_tmp514 ;
  char *__cil_tmp515 ;
  char *__cil_tmp516 ;
  char *__cil_tmp517 ;
  char *__cil_tmp518 ;
  char *__cil_tmp519 ;
  char *__cil_tmp520 ;
  char *__cil_tmp521 ;
  char *__cil_tmp522 ;
  char *__cil_tmp523 ;
  char *__cil_tmp524 ;
  char *__cil_tmp525 ;
  char *__cil_tmp526 ;
  char *__cil_tmp527 ;
  char *__cil_tmp528 ;
  char *__cil_tmp529 ;
  char *__cil_tmp530 ;
  char *__cil_tmp531 ;
  char *__cil_tmp532 ;
  char *__cil_tmp533 ;
  char *__cil_tmp534 ;
  char *__cil_tmp535 ;
  char *__cil_tmp536 ;
  char *__cil_tmp537 ;
  char *__cil_tmp538 ;
  char *__cil_tmp539 ;
  char *__cil_tmp540 ;
  char *__cil_tmp541 ;
  char *__cil_tmp542 ;
  char *__cil_tmp543 ;
  char *__cil_tmp544 ;
  char *__cil_tmp545 ;
  char *__cil_tmp546 ;
  char *__cil_tmp547 ;
  char *__cil_tmp548 ;
  char *__cil_tmp549 ;
  char *__cil_tmp550 ;
  char *__cil_tmp551 ;
  char *__cil_tmp552 ;
  char *__cil_tmp553 ;
  char *__cil_tmp554 ;
  char *__cil_tmp555 ;
  char *__cil_tmp556 ;
  char *__cil_tmp557 ;
  char *__cil_tmp558 ;
  char *__cil_tmp559 ;
  char *__cil_tmp560 ;
  char *__cil_tmp561 ;
  char *__cil_tmp562 ;
  char *__cil_tmp563 ;
  char *__cil_tmp564 ;
  char *__cil_tmp565 ;
  char *__cil_tmp566 ;
  char *__cil_tmp567 ;
  char *__cil_tmp568 ;
  char *__cil_tmp569 ;
  char *__cil_tmp570 ;
  char *__cil_tmp571 ;
  char *__cil_tmp572 ;
  char *__cil_tmp573 ;
  char *__cil_tmp574 ;
  char *__cil_tmp575 ;
  char *__cil_tmp576 ;
  char *__cil_tmp577 ;
  char *__cil_tmp578 ;
  char *__cil_tmp579 ;
  char *__cil_tmp580 ;
  char *__cil_tmp581 ;
  char *__cil_tmp582 ;
  char *__cil_tmp583 ;
  char *__cil_tmp584 ;
  char *__cil_tmp585 ;
  char *__cil_tmp586 ;
  char *__cil_tmp587 ;
  char *__cil_tmp588 ;
  char *__cil_tmp589 ;
  char *__cil_tmp590 ;
  char *__cil_tmp591 ;
  char *__cil_tmp592 ;
  char *__cil_tmp593 ;
  char *__cil_tmp594 ;
  char *__cil_tmp595 ;
  char *__cil_tmp596 ;
  char *__cil_tmp597 ;
  char *__cil_tmp598 ;
  char *__cil_tmp599 ;
  char *__cil_tmp600 ;
  char *__cil_tmp601 ;
  char *__cil_tmp602 ;
  char *__cil_tmp603 ;
  char *__cil_tmp604 ;
  char *__cil_tmp605 ;
  char *__cil_tmp606 ;
  char *__cil_tmp607 ;
  char *__cil_tmp608 ;
  char *__cil_tmp609 ;
  char *__cil_tmp610 ;
  char *__cil_tmp611 ;
  char *__cil_tmp612 ;
  char *__cil_tmp613 ;
  char *__cil_tmp614 ;
  char *__cil_tmp615 ;
  char *__cil_tmp616 ;
  char *__cil_tmp617 ;
  char *__cil_tmp618 ;
  char *__cil_tmp619 ;
  char *__cil_tmp620 ;
  char *__cil_tmp621 ;
  char *__cil_tmp622 ;
  char *__cil_tmp623 ;
  char *__cil_tmp624 ;
  char *__cil_tmp625 ;
  char *__cil_tmp626 ;
  char *__cil_tmp627 ;
  char *__cil_tmp628 ;
  char *__cil_tmp629 ;
  char *__cil_tmp630 ;
  char *__cil_tmp631 ;
  char *__cil_tmp632 ;
  char *__cil_tmp633 ;
  char *__cil_tmp634 ;
  char *__cil_tmp635 ;
  char *__cil_tmp636 ;
  char *__cil_tmp637 ;
  char *__cil_tmp638 ;
  char *__cil_tmp639 ;
  char *__cil_tmp640 ;
  char *__cil_tmp641 ;
  char *__cil_tmp642 ;
  char *__cil_tmp643 ;
  char *__cil_tmp644 ;
  char *__cil_tmp645 ;
  char *__cil_tmp646 ;
  char *__cil_tmp647 ;
  char *__cil_tmp648 ;
  char *__cil_tmp649 ;
  char *__cil_tmp650 ;
  char *__cil_tmp651 ;
  char *__cil_tmp652 ;
  char *__cil_tmp653 ;
  char *__cil_tmp654 ;
  char *__cil_tmp655 ;
  char *__cil_tmp656 ;
  char *__cil_tmp657 ;
  char *__cil_tmp658 ;
  char *__cil_tmp659 ;
  char *__cil_tmp660 ;
  char *__cil_tmp661 ;
  char *__cil_tmp662 ;
  char *__cil_tmp663 ;
  char *__cil_tmp664 ;
  char *__cil_tmp665 ;
  char *__cil_tmp666 ;
  char *__cil_tmp667 ;
  char *__cil_tmp668 ;
  char *__cil_tmp669 ;
  char *__cil_tmp670 ;
  char *__cil_tmp671 ;
  char *__cil_tmp672 ;
  char *__cil_tmp673 ;
  char *__cil_tmp674 ;
  char *__cil_tmp675 ;
  char *__cil_tmp676 ;
  char *__cil_tmp677 ;
  char *__cil_tmp678 ;
  char *__cil_tmp679 ;
  char *__cil_tmp680 ;
  char *__cil_tmp681 ;

  {
  {
#line 458
  c = (struct cmd */* volatile  */)((void *)0);
#line 469
  n_badcmds = (unsigned int volatile   )0;
#line 470
  n_badrcpts = (unsigned int volatile   )0;
#line 471
  n_verifies = (unsigned int volatile   )0;
#line 472
  n_etrn = (unsigned int volatile   )0;
#line 473
  n_noop = (unsigned int volatile   )0;
#line 474
  n_helo = (unsigned int volatile   )0;
#line 480
  tempfail = (bool volatile   )0;
#line 483
  lognullconnection = (bool volatile   )1;
#line 487
  greetcode = (char *)"220";
#line 539
  log_delay___0 = (time_t volatile   )((time_t )0);
#line 541
  save_sevenbitinput = (int volatile   )SevenBitInput;
#line 542
  smtp___0.sm_nrcpts = 0U;
#line 544
  smtp___0.sm_milterize = (unsigned long )nullserver == (unsigned long )((void *)0);
#line 545
  smtp___0.sm_milterlist = 0;
#line 549
  setup_smtpd_io();
  }
#line 552
  if (DebugLeakSmtp.debug_level >= 1U) {
#line 552
    if (DebugLeakSmtp.debug_level != 4294967295U) {
      {
#line 554
      SmHeapMaxGroup ++;
#line 554
      SmHeapGroup = SmHeapMaxGroup;
#line 555
      sm_dprintf((char *)"smtp() heap group #%d\n", SmHeapGroup);
      }
    } else {
      {
#line 552
      tmp = sm_debug_loadactive(& DebugLeakSmtp, 1);
      }
#line 552
      if (tmp) {
        {
#line 554
        SmHeapMaxGroup ++;
#line 554
        SmHeapGroup = SmHeapMaxGroup;
#line 555
        sm_dprintf((char *)"smtp() heap group #%d\n", SmHeapGroup);
        }
      }
    }
  }
  {
#line 560
  e->e_rpool = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 561
  e->e_macro.mac_rpool = e->e_rpool;
#line 563
  settime((ENVELOPE *)e);
#line 564
  sm_getla();
#line 565
  peerhostname = (char */* volatile  */)RealHostName;
  }
#line 566
  if ((unsigned long )peerhostname == (unsigned long )((void *)0)) {
#line 567
    peerhostname = (char */* volatile  */)"localhost";
  }
  {
#line 568
  CurHostName = (char *)peerhostname;
#line 569
  CurSmtpClient = macvalue('_', (ENVELOPE *)e);
  }
#line 570
  if ((unsigned long )CurSmtpClient == (unsigned long )((void *)0)) {
#line 571
    CurSmtpClient = CurHostName;
  }
  {
#line 574
  smtp___0.sm_discard = (e->e_flags & 16777216UL) != 0UL;
#line 578
  sm_io_autoflush(InChannel, OutChannel);
#line 581
  sm_setproctitle(1, (ENVELOPE *)e, "server %s startup", CurSmtpClient);
  }
#line 584
  if ((PrivacyFlags & 524288UL) != 0UL) {
#line 584
    tmp___0 = 0;
  } else
#line 584
  if (*(d_flags + (69UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL))) & (1U << 69UL % (8UL * sizeof(int )))) {
#line 584
    tmp___0 = 0;
  } else {
#line 584
    tmp___0 = 8;
  }
#line 584
  if (*(d_flags + (97UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL))) & (1U << 97UL % (8UL * sizeof(int )))) {
#line 584
    tmp___1 = 1024;
  } else {
#line 584
    tmp___1 = 0;
  }
#line 584
  if ((PrivacyFlags & 8UL) != 0UL) {
#line 584
    tmp___3 = 0;
  } else {
#line 584
    if ((PrivacyFlags & 64UL) != 0UL) {
#line 584
      tmp___2 = 0;
    } else {
#line 584
      tmp___2 = 64;
    }
#line 584
    tmp___3 = 32 | tmp___2;
  }
#line 584
  if ((PrivacyFlags & 2097152UL) != 0UL) {
#line 584
    tmp___4 = 0;
  } else {
#line 584
    tmp___4 = 128;
  }
#line 584
  features = (unsigned int volatile   )((((tmp___0 | tmp___1) | tmp___3) | tmp___4) | 256);
#line 607
  if ((unsigned long )nullserver == (unsigned long )((void *)0)) {
    {
#line 609
    tmp___5 = srvfeatures((ENVELOPE *)e, CurSmtpClient, (unsigned int )features);
#line 609
    features = (unsigned int volatile   )tmp___5;
    }
#line 610
    if ((features & (unsigned int volatile   )4096) != (unsigned int volatile   )0) {
#line 612
      if (LogLevel > 4) {
        {
#line 613
        sm_syslog(3, "*~*", "ERROR: srv_features=tempfail, relay=%.100s, access temporarily disabled",
                  CurSmtpClient);
        }
      }
#line 616
      nullserver = (char */* volatile  */)"450 4.3.0 Please try again later.";
    }
  } else {
    {
#line 637
    tmp___6 = strncmp((char const   *)nullserver, "421 ", (size_t )4);
    }
#line 637
    if (tmp___6 == 0) {
      {
#line 639
      message((char const   *)nullserver);
      }
#line 640
      goto doquit;
    }
  }
  {
#line 643
  hostname = macvalue('j', (ENVELOPE *)e);
  }
#line 807
  if (smtp___0.sm_milterize) {
    {
#line 812
    smtp___0.sm_milterlist = milter_init((ENVELOPE *)e, & state);
    }
    {
#line 815
    if ((int )state == 114) {
#line 815
      goto case_114;
    }
#line 824
    if ((int )state == 116) {
#line 824
      goto case_116;
    }
#line 832
    if ((int )state == 52) {
#line 832
      goto case_52;
    }
#line 813
    goto switch_break;
    case_114: /* CIL Label */ 
#line 816
    if (MilterLogLevel > 3) {
      {
#line 817
      sm_syslog(6, (char const   *)e->e_id, "Milter: initialization failed, rejecting commands");
      }
    }
#line 819
    greetcode = (char *)"554";
#line 820
    nullserver = (char */* volatile  */)"Command rejected";
#line 821
    smtp___0.sm_milterize = 0;
#line 822
    goto switch_break;
    case_116: /* CIL Label */ 
#line 825
    if (MilterLogLevel > 3) {
      {
#line 826
      sm_syslog(6, (char const   *)e->e_id, "Milter: initialization failed, temp failing commands");
      }
    }
#line 828
    tempfail = (bool volatile   )1;
#line 829
    smtp___0.sm_milterize = 0;
#line 830
    goto switch_break;
    case_52: /* CIL Label */ 
#line 833
    if (MilterLogLevel > 3) {
      {
#line 834
      sm_syslog(6, (char const   *)e->e_id, "Milter: initialization failed, closing connection");
      }
    }
    {
#line 836
    tempfail = (bool volatile   )1;
#line 837
    smtp___0.sm_milterize = 0;
#line 838
    message("421 4.7.0 %s closing connection", MyHostName);
#line 842
    e->e_sendqueue = (ADDRESS *)((void *)0);
    }
#line 843
    goto doquit;
    switch_break: /* CIL Label */ ;
    }
  }
#line 847
  if (smtp___0.sm_milterlist) {
#line 847
    if (smtp___0.sm_milterize) {
#line 847
      if (! ((e->e_flags & 16777216UL) != 0UL)) {
        {
#line 853
        response = milter_connect((char *)peerhostname, RealHostAddr, (ENVELOPE *)e,
                                  & state___0);
        }
        {
#line 858
        if ((int )state___0 == 114) {
#line 858
          goto case_114___0;
        }
#line 858
        if ((int )state___0 == 121) {
#line 858
          goto case_114___0;
        }
#line 869
        if ((int )state___0 == 116) {
#line 869
          goto case_116___0;
        }
#line 879
        if ((int )state___0 == 52) {
#line 879
          goto case_52___0;
        }
#line 855
        goto switch_break___0;
        case_114___0: /* CIL Label */ 
        case_121: /* CIL Label */ 
#line 859
        if (MilterLogLevel > 3) {
          {
#line 860
          tmp___7 = anynet_ntoa(& RealHostAddr);
#line 860
          sm_syslog(6, (char const   *)e->e_id, "Milter: connect: host=%s, addr=%s, rejecting commands",
                    peerhostname, tmp___7);
          }
        }
#line 864
        greetcode = (char *)"554";
#line 865
        nullserver = (char */* volatile  */)"Command rejected";
#line 866
        smtp___0.sm_milterize = 0;
#line 867
        goto switch_break___0;
        case_116___0: /* CIL Label */ 
#line 870
        if (MilterLogLevel > 3) {
          {
#line 871
          tmp___8 = anynet_ntoa(& RealHostAddr);
#line 871
          sm_syslog(6, (char const   *)e->e_id, "Milter: connect: host=%s, addr=%s, temp failing commands",
                    peerhostname, tmp___8);
          }
        }
#line 875
        tempfail = (bool volatile   )1;
#line 876
        smtp___0.sm_milterize = 0;
#line 877
        goto switch_break___0;
        case_52___0: /* CIL Label */ 
#line 880
        if (MilterLogLevel > 3) {
          {
#line 881
          tmp___9 = anynet_ntoa(& RealHostAddr);
#line 881
          sm_syslog(6, (char const   *)e->e_id, "Milter: connect: host=%s, addr=%s, shutdown",
                    peerhostname, tmp___9);
          }
        }
        {
#line 885
        tempfail = (bool volatile   )1;
#line 886
        smtp___0.sm_milterize = 0;
#line 887
        message("421 4.7.0 %s closing connection", MyHostName);
#line 891
        e->e_sendqueue = (ADDRESS *)((void *)0);
        }
#line 892
        goto doquit;
        switch_break___0: /* CIL Label */ ;
        }
#line 894
        if ((unsigned long )response != (unsigned long )((void *)0)) {
          {
#line 895
          sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                         895);
          }
        }
      }
    }
  }
#line 904
  if ((int )*greetcode == 50) {
    {
#line 910
    msecs = (time_t )0;
#line 915
    pvp = (char **)((void *)0);
#line 916
    tmp___10 = anynet_ntoa(& RealHostAddr);
#line 916
    r = rscap((char *)"greet_pause", (char *)peerhostname, tmp___10, (ENVELOPE *)e,
              & pvp, pvpbuf, (int )sizeof(pvpbuf));
    }
#line 919
    if (r == 0) {
#line 919
      if ((unsigned long )pvp != (unsigned long )((void *)0)) {
#line 919
        if ((unsigned long )*(pvp + 0) != (unsigned long )((void *)0)) {
#line 919
          if (((int )*(*(pvp + 0) + 0) & 255) == 150) {
#line 919
            if ((unsigned long )*(pvp + 1) != (unsigned long )((void *)0)) {
              {
#line 922
              msecs = strtol((char const   */* __restrict  */)*(pvp + 1), (char **/* __restrict  */)((void *)0),
                             10);
              }
            }
          }
        }
      }
    }
#line 925
    if (msecs > 0L) {
#line 935
      timeout.tv_sec = msecs / 1000L;
#line 936
      timeout.tv_usec = (msecs % 1000L) * 1000L;
#line 939
      if (timeout.tv_sec >= 300L) {
#line 941
        timeout.tv_sec = (__time_t )300;
#line 942
        timeout.tv_usec = (__suseconds_t )0;
      }
      {
#line 946
      fd = sm_io_getinfo(InChannel, 3, (void *)0);
      }
      {
#line 947
      while (1) {
        while_continue: /* CIL Label */ ;
#line 947
        __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0),
                             "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& readfds.__fds_bits[0]): "memory");
#line 947
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 948
      __asm__  volatile   ("btsl %1,%0": "=m" (readfds.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                           "memory");
#line 952
      tmp___12 = select(fd + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                        (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
      }
#line 954
      if (tmp___12 > 0) {
#line 954
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))),
                             "m" (readfds.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "cc");
#line 954
        if (__result) {
          {
#line 960
          greetcode = (char *)"554";
#line 961
          nullserver = (char */* volatile  */)"Command rejected";
#line 962
          tmp___11 = anynet_ntoa(& RealHostAddr);
#line 962
          sm_syslog(6, (char const   *)e->e_id, "rejecting commands from %s [%s] due to pre-greeting traffic",
                    peerhostname, tmp___11);
          }
        }
      }
    }
  }
#line 992
  if ((int )*greetcode == 53) {
    {
#line 993
    sm_snprintf(inp, (size_t )sizeof(inp), "%s not accepting messages", hostname);
    }
  } else {
    {
#line 996
    expand(SmtpGreeting, inp, (size_t )sizeof(inp), (ENVELOPE *)e);
    }
  }
  {
#line 998
  tmp___13 = strchr((char const   *)(inp), '\n');
#line 998
  p = (char */* volatile  */)tmp___13;
  }
#line 999
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1000
    tmp___14 = p;
#line 1000
    p ++;
#line 1000
    *tmp___14 = (char )'\000';
  }
  {
#line 1001
  id = strchr((char const   *)(inp), ' ');
  }
#line 1002
  if ((unsigned long )id == (unsigned long )((void *)0)) {
    {
#line 1003
    tmp___15 = strlen((char const   *)(inp));
#line 1003
    id = & inp[tmp___15];
    }
  }
#line 1004
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1005
    sm_snprintf(cmdbuf, (size_t )sizeof(cmdbuf), "%s %%.*s ESMTP%%s", greetcode);
    }
  } else {
    {
#line 1008
    sm_snprintf(cmdbuf, (size_t )sizeof(cmdbuf), "%s-%%.*s ESMTP%%s", greetcode);
    }
  }
  {
#line 1010
  message((char const   *)(cmdbuf), (int )(id - inp), inp, id);
  }
  {
#line 1013
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1013
    id = (char *)p;
#line 1013
    if ((unsigned long )id != (unsigned long )((void *)0)) {
      {
#line 1013
      tmp___18 = strchr((char const   *)id, '\n');
#line 1013
      p = (char */* volatile  */)tmp___18;
      }
#line 1013
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1013
        goto while_break___0;
      }
    } else {
#line 1013
      goto while_break___0;
    }
#line 1015
    tmp___16 = p;
#line 1015
    p ++;
#line 1015
    *tmp___16 = (char )'\000';
#line 1016
    if (((int )*id & -128) == 0) {
      {
#line 1016
      tmp___17 = __ctype_b_loc();
      }
#line 1016
      if ((int const   )*(*tmp___17 + (int )*id) & 8192) {
#line 1017
        id ++;
      }
    }
    {
#line 1018
    sm_strlcpyn(cmdbuf, (ssize_t )sizeof(cmdbuf), 2, greetcode, "-%s");
#line 1019
    message((char const   *)(cmdbuf), id);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1021
  if ((unsigned long )id != (unsigned long )((void *)0)) {
#line 1023
    if (((int )*id & -128) == 0) {
      {
#line 1023
      tmp___19 = __ctype_b_loc();
      }
#line 1023
      if ((int const   )*(*tmp___19 + (int )*id) & 8192) {
#line 1024
        id ++;
      }
    }
    {
#line 1025
    sm_strlcpyn(cmdbuf, (ssize_t )sizeof(cmdbuf), 2, greetcode, " %s");
#line 1026
    message((char const   *)(cmdbuf), id);
    }
  }
  {
#line 1029
  protocol = (char */* volatile  */)((void *)0);
#line 1030
  tmp___20 = macvalue('s', (ENVELOPE *)e);
#line 1030
  sendinghost = (char */* volatile  */)tmp___20;
  }
#line 1033
  if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
#line 1034
    smtp___0.sm_quarmsg = (char *)((void *)0);
  } else {
    {
#line 1036
    smtp___0.sm_quarmsg = newstr((char const   *)e->e_quarmsg);
    }
  }
#line 1039
  if ((unsigned long )sendinghost != (unsigned long )((void *)0)) {
    {
#line 1040
    tmp___21 = sm_strdup_x((char const   *)sendinghost);
#line 1040
    sendinghost = (char */* volatile  */)tmp___21;
    }
  }
#line 1044
  gothello = (bool volatile   )0;
#line 1045
  smtp___0.sm_gotmail = 0;
  {
#line 1046
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1048
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1048
      _h.eh_value = (SM_EXC_T *)((void *)0);
#line 1048
      _h.eh_parent = SmExcHandler;
#line 1048
      _h.eh_state = 2;
#line 1048
      SmExcHandler = & _h;
#line 1048
      tmp___188 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
      }
#line 1048
      if (tmp___188 == 0) {
        {
#line 1050
        QuickAbort = 0;
#line 1051
        HoldErrs = 0;
#line 1052
        SuprErrs = 0;
#line 1053
        LogUsrErrs = 0;
#line 1054
        OnlyOneError = 1;
#line 1055
        e->e_flags &= 0xffffffffffffedffUL;
#line 1058
        e->e_to = (char *)((void *)0);
#line 1059
        Errors = 0;
#line 1060
        FileName = (char *)((void *)0);
#line 1061
        sm_io_flush(& SmIoF[1], -2);
#line 1064
        SmtpPhase = (char *)"server cmd read";
#line 1065
        sm_setproctitle(1, (ENVELOPE *)e, "server %s cmd read", CurSmtpClient);
        }
#line 1074
        if ((OutChannel->f_flags & 256L) != 0L) {
#line 1074
          goto _L;
        } else {
          {
#line 1074
          tmp___25 = sfgets(inp, (int )sizeof(inp), InChannel, TimeOuts.to_nextcommand,
                            SmtpPhase);
#line 1074
          p = (char */* volatile  */)tmp___25;
          }
#line 1074
          if ((unsigned long )p == (unsigned long )((void *)0)) {
            _L: /* CIL Label */ 
            {
#line 1080
            tmp___22 = macid_parse((char *)"{daemon_name}", (char **)((void *)0));
#line 1080
            d = macvalue(tmp___22, (ENVELOPE *)e);
            }
#line 1081
            if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 1082
              d = (char *)"stdin";
            }
            {
#line 1084
            disconnect(1, (ENVELOPE *)e);
#line 1088
            milter_quit((ENVELOPE *)e);
#line 1091
            message("421 4.4.1 %s Lost input channel from %s", MyHostName, CurSmtpClient);
            }
#line 1093
            if (smtp___0.sm_gotmail) {
#line 1093
              tmp___24 = 1;
            } else {
#line 1093
              tmp___24 = 19;
            }
#line 1093
            if (LogLevel > tmp___24) {
#line 1094
              if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1094
                tmp___23 = "startup";
              } else
#line 1094
              if ((unsigned long )c->cmd_name == (unsigned long )((void *)0)) {
#line 1094
                tmp___23 = "startup";
              } else {
#line 1094
                tmp___23 = (char const   *)c->cmd_name;
              }
              {
#line 1094
              sm_syslog(5, (char const   *)e->e_id, "lost input channel from %s to %s after %s",
                        CurSmtpClient, d, tmp___23);
              }
            }
#line 1103
            if ((e->e_flags & 8UL) != 0UL) {
#line 1104
              e->e_sendqueue = (ADDRESS *)((void *)0);
            }
#line 1105
            goto doquit;
          }
        }
        {
#line 1140
        fixcrlf(inp, 1);
        }
#line 1371
        if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
          {
#line 1372
          sm_io_fprintf(e->e_xfp, -2, "<<< %s\n", inp);
          }
        }
#line 1375
        if (LogLevel > 14) {
          {
#line 1376
          sm_syslog(6, (char const   *)e->e_id, "<-- %s", inp);
          }
        }
#line 1379
        p = (char */* volatile  */)(inp);
        {
#line 1379
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1379
          if (((int )*p & -128) == 0) {
            {
#line 1379
            tmp___26 = __ctype_b_loc();
            }
#line 1379
            if (! ((int const   )*(*tmp___26 + (int )*p) & 8192)) {
#line 1379
              goto while_break___3;
            }
          } else {
#line 1379
            goto while_break___3;
          }
#line 1380
          goto __Cont;
          __Cont: /* CIL Label */ 
#line 1379
          p ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1381
        cmd = cmdbuf;
        {
#line 1382
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1382
          if ((int )*p != 0) {
#line 1382
            if (((int )*p & -128) == 0) {
              {
#line 1382
              tmp___29 = __ctype_b_loc();
              }
#line 1382
              if ((int const   )*(*tmp___29 + (int )*p) & 8192) {
#line 1382
                goto while_break___4;
              } else {
#line 1382
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 1382
            if (! ((unsigned long )cmd < (unsigned long )(& cmdbuf[sizeof(cmdbuf) - 2UL]))) {
#line 1382
              goto while_break___4;
            }
          } else {
#line 1382
            goto while_break___4;
          }
#line 1385
          tmp___27 = cmd;
#line 1385
          cmd ++;
#line 1385
          tmp___28 = p;
#line 1385
          p ++;
#line 1385
          *tmp___27 = *tmp___28;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1386
        *cmd = (char )'\000';
        {
#line 1389
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1389
          if (((int )*p & -128) == 0) {
            {
#line 1389
            tmp___30 = __ctype_b_loc();
            }
#line 1389
            if (! ((int const   )*(*tmp___30 + (int )*p) & 8192)) {
#line 1389
              goto while_break___5;
            }
          } else {
#line 1389
            goto while_break___5;
          }
#line 1389
          p ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1392
        c = (struct cmd */* volatile  */)(CmdTab);
        {
#line 1392
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1392
          if (! ((unsigned long )c->cmd_name != (unsigned long )((void *)0))) {
#line 1392
            goto while_break___6;
          }
          {
#line 1394
          tmp___31 = sm_strcasecmp((char const   *)c->cmd_name, (char const   *)(cmdbuf));
          }
#line 1394
          if (tmp___31 == 0) {
#line 1395
            goto while_break___6;
          }
#line 1392
          c ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 1399
        tmp___32 = __errno_location();
#line 1399
        *tmp___32 = 0;
        }
        {
#line 1414
        if (c->cmd_code == 12) {
#line 1414
          goto case_12;
        }
#line 1414
        if (c->cmd_code == 5) {
#line 1414
          goto case_12;
        }
#line 1414
        if (c->cmd_code == 6) {
#line 1414
          goto case_12;
        }
#line 1414
        if (c->cmd_code == 1) {
#line 1414
          goto case_12;
        }
#line 1417
        goto switch_default;
        case_12: /* CIL Label */ 
        case_5: /* CIL Label */ 
        case_6: /* CIL Label */ 
        case_1: /* CIL Label */ 
#line 1415
        lognullconnection = (bool volatile   )0;
        switch_default: /* CIL Label */ 
#line 1418
        q = inp;
#line 1419
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 1422
        if ((unsigned long )e->e_id == (unsigned long )((void *)0)) {
          {
#line 1423
          sm_setproctitle(1, (ENVELOPE *)e, "%s: %.80s", CurSmtpClient, q);
          }
        } else {
          {
#line 1426
          tmp___33 = qid_printname((ENVELOPE *)e);
#line 1426
          sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___33, CurSmtpClient,
                          q);
          }
        }
#line 1437
        if ((unsigned long )nullserver != (unsigned long )((void *)0)) {
#line 1437
          goto _L___1;
        } else
#line 1437
        if (*(d_flags + (1UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL))) & (1U << 1UL % (8UL * sizeof(int )))) {
          _L___1: /* CIL Label */ 
          {
#line 1446
          if (c->cmd_code == 0) {
#line 1446
            goto case_0;
          }
#line 1446
          if (c->cmd_code == 4) {
#line 1446
            goto case_0;
          }
#line 1446
          if (c->cmd_code == 7) {
#line 1446
            goto case_0;
          }
#line 1446
          if (c->cmd_code == 11) {
#line 1446
            goto case_0;
          }
#line 1446
          if (c->cmd_code == 9) {
#line 1446
            goto case_0;
          }
#line 1446
          if (c->cmd_code == 8) {
#line 1446
            goto case_0;
          }
#line 1450
          if (c->cmd_code == 12) {
#line 1450
            goto case_12___0;
          }
#line 1457
          goto switch_default___0;
          case_0: /* CIL Label */ 
          case_4: /* CIL Label */ 
          case_7: /* CIL Label */ 
          case_11: /* CIL Label */ 
          case_9: /* CIL Label */ 
          case_8: /* CIL Label */ 
#line 1448
          goto switch_break___2;
          case_12___0: /* CIL Label */ 
#line 1451
          if (*(d_flags + (1UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL))) & (1U << 1UL % (8UL * sizeof(int )))) {
#line 1451
            if ((unsigned long )nullserver == (unsigned long )((void *)0)) {
#line 1453
              goto switch_break___2;
            }
          }
#line 1454
          if (DelayLA > 0) {
            {
#line 1454
            CurrentLA = getla();
            }
#line 1454
            if (CurrentLA >= DelayLA) {
              {
#line 1454
              tmp___34 = qid_printname((ENVELOPE *)e);
#line 1454
              sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                              tmp___34, CurSmtpClient, "ETRN", DelayLA);
              }
#line 1454
              if (LogLevel > 8) {
                {
#line 1454
                dnow = curtime();
                }
#line 1454
                if (dnow > (time_t )log_delay___0) {
                  {
#line 1454
                  sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                            "ETRN", CurrentLA, DelayLA);
#line 1454
                  log_delay___0 = (time_t volatile   )(dnow + 15L);
                  }
                }
              }
              {
#line 1454
              sleep(1U);
#line 1454
              tmp___35 = qid_printname((ENVELOPE *)e);
#line 1454
              sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___35, CurSmtpClient,
                              inp);
              }
            }
          }
          switch_default___0: /* CIL Label */ 
#line 1460
          if ((unsigned long )nullserver != (unsigned long )((void *)0)) {
#line 1460
            n_badcmds += (unsigned int volatile   )1;
#line 1460
            if (n_badcmds > (unsigned int volatile   )25) {
              {
#line 1463
              message("421 4.7.0 %s Too many bad commands; closing connection", MyHostName);
#line 1467
              e->e_sendqueue = (ADDRESS *)((void *)0);
              }
#line 1468
              goto doquit;
            }
          }
#line 1471
          if ((unsigned long )nullserver != (unsigned long )((void *)0)) {
#line 1473
            if (((int )*(nullserver + 0) & -128) == 0) {
              {
#line 1473
              tmp___36 = __ctype_b_loc();
              }
#line 1473
              if ((int const   )*(*tmp___36 + (int )*(nullserver + 0)) & 2048) {
#line 1473
                if (((int )*(nullserver + 1) & -128) == 0) {
                  {
#line 1473
                  tmp___37 = __ctype_b_loc();
                  }
#line 1473
                  if ((int const   )*(*tmp___37 + (int )*(nullserver + 1)) & 2048) {
#line 1473
                    if (((int )*(nullserver + 2) & -128) == 0) {
                      {
#line 1473
                      tmp___38 = __ctype_b_loc();
                      }
#line 1473
                      if ((int const   )*(*tmp___38 + (int )*(nullserver + 2)) & 2048) {
#line 1473
                        if ((int )*(nullserver + 3) == 32) {
                          {
#line 1474
                          usrerr((char const   *)nullserver);
                          }
                        } else
#line 1473
                        if ((int )*(nullserver + 3) == 45) {
                          {
#line 1474
                          usrerr((char const   *)nullserver);
                          }
                        } else
#line 1473
                        if ((int )*(nullserver + 3) == 0) {
                          {
#line 1474
                          usrerr((char const   *)nullserver);
                          }
                        } else {
                          {
#line 1476
                          usrerr("550 5.0.0 %s", nullserver);
                          }
                        }
                      } else {
                        {
#line 1476
                        usrerr("550 5.0.0 %s", nullserver);
                        }
                      }
                    } else {
                      {
#line 1476
                      usrerr("550 5.0.0 %s", nullserver);
                      }
                    }
                  } else {
                    {
#line 1476
                    usrerr("550 5.0.0 %s", nullserver);
                    }
                  }
                } else {
                  {
#line 1476
                  usrerr("550 5.0.0 %s", nullserver);
                  }
                }
              } else {
                {
#line 1476
                usrerr("550 5.0.0 %s", nullserver);
                }
              }
            } else {
              {
#line 1476
              usrerr("550 5.0.0 %s", nullserver);
              }
            }
          } else {
            {
#line 1480
            usrerr("452 4.4.5 Insufficient disk space; try again later");
            }
          }
#line 1481
          goto __Cont___0;
          switch_break___2: /* CIL Label */ ;
          }
        }
        {
#line 1885
        if (c->cmd_code == 11) {
#line 1885
          goto case_11___0;
        }
#line 1885
        if (c->cmd_code == 9) {
#line 1885
          goto case_11___0;
        }
#line 2114
        if (c->cmd_code == 1) {
#line 2114
          goto case_1___0;
        }
#line 2419
        if (c->cmd_code == 2) {
#line 2419
          goto case_2;
        }
#line 2658
        if (c->cmd_code == 3) {
#line 2658
          goto case_3;
        }
#line 2664
        if (c->cmd_code == 4) {
#line 2664
          goto case_4___0;
        }
#line 2673
        if (c->cmd_code == 6) {
#line 2673
          goto case_6___0;
        }
#line 2673
        if (c->cmd_code == 5) {
#line 2673
          goto case_6___0;
        }
#line 2784
        if (c->cmd_code == 12) {
#line 2784
          goto case_12___1;
        }
#line 2887
        if (c->cmd_code == 10) {
#line 2887
          goto case_10;
        }
#line 2892
        if (c->cmd_code == 7) {
#line 2892
          goto case_7___0;
        }
#line 2899
        if (c->cmd_code == 8) {
#line 2899
          goto case_8___0;
        }
#line 2971
        if (c->cmd_code == 17) {
#line 2971
          goto case_17;
        }
#line 3004
        if (c->cmd_code == 23) {
#line 3004
          goto case_23;
        }
#line 3004
        if (c->cmd_code == 25) {
#line 3004
          goto case_23;
        }
#line 3004
        if (c->cmd_code == 24) {
#line 3004
          goto case_23;
        }
#line 3013
        if (c->cmd_code == 0) {
#line 3013
          goto case_0___0;
        }
#line 3054
        if (c->cmd_code == 19) {
#line 3054
          goto case_19;
        }
#line 3060
        goto switch_default___1;
        case_11___0: /* CIL Label */ 
        case_9___0: /* CIL Label */ 
#line 1886
        if (DelayLA > 0) {
          {
#line 1886
          CurrentLA = getla();
          }
#line 1886
          if (CurrentLA >= DelayLA) {
            {
#line 1886
            tmp___39 = qid_printname((ENVELOPE *)e);
#line 1886
            sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                            tmp___39, CurSmtpClient, "EHLO", DelayLA);
            }
#line 1886
            if (LogLevel > 8) {
              {
#line 1886
              dnow___0 = curtime();
              }
#line 1886
              if (dnow___0 > (time_t )log_delay___0) {
                {
#line 1886
                sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                          "EHLO", CurrentLA, DelayLA);
#line 1886
                log_delay___0 = (time_t volatile   )(dnow___0 + 15L);
                }
              }
            }
            {
#line 1886
            sleep(1U);
#line 1886
            tmp___40 = qid_printname((ENVELOPE *)e);
#line 1886
            sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___40, CurSmtpClient,
                            inp);
            }
          }
        }
#line 1887
        if (c->cmd_code == 11) {
#line 1889
          protocol = (char */* volatile  */)"ESMTP";
#line 1890
          SmtpPhase = (char *)"server EHLO";
        } else {
#line 1894
          protocol = (char */* volatile  */)"SMTP";
#line 1895
          SmtpPhase = (char *)"server HELO";
        }
        {
#line 1899
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 1899
          tmp___41 = checksmtpattack(& n_helo, 3U, 1, (char *)"HELO/EHLO", (ENVELOPE *)e);
          }
#line 1899
          if (tmp___41 == -1L) {
#line 1899
            goto stopattack;
          }
#line 1899
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1914
        if ((int )*p == 0) {
#line 1914
          if (! AllowBogusHELO) {
            {
#line 1916
            usrerr("501 %s requires domain address", cmdbuf);
            }
#line 1918
            goto switch_break___3;
          }
        }
        {
#line 1922
        tmp___42 = strlen((char const   *)p);
        }
#line 1922
        if (tmp___42 > 256U) {
          {
#line 1924
          usrerr("501 Invalid domain name");
          }
#line 1925
          if (LogLevel > 9) {
            {
#line 1926
            sm_syslog(6, (char const   *)CurEnv->e_id, "invalid domain name (too long) from %s",
                      CurSmtpClient);
            }
          }
#line 1929
          goto switch_break___3;
        }
#line 1932
        ok = 1;
#line 1933
        q = (char *)p;
        {
#line 1933
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1933
          if (! ((int )*q != 0)) {
#line 1933
            goto while_break___8;
          }
#line 1935
          if (! (((int )*q & -128) == 0)) {
#line 1936
            goto while_break___8;
          }
          {
#line 1937
          tmp___43 = __ctype_b_loc();
          }
#line 1937
          if ((int const   )*(*tmp___43 + (int )*q) & 8) {
#line 1938
            goto __Cont___1;
          }
          {
#line 1939
          tmp___45 = __ctype_b_loc();
          }
#line 1939
          if ((int const   )*(*tmp___45 + (int )*q) & 8192) {
#line 1941
            *q = (char )'\000';
#line 1944
            ok = AllowBogusHELO;
            {
#line 1947
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 1947
              if (! ok) {
#line 1947
                q ++;
#line 1947
                if ((int )*q != 0) {
                  {
#line 1947
                  tmp___44 = __ctype_b_loc();
                  }
#line 1947
                  if (! ((int const   )*(*tmp___44 + (int )*q) & 8192)) {
#line 1947
                    goto while_break___9;
                  }
                } else {
#line 1947
                  goto while_break___9;
                }
              } else {
#line 1947
                goto while_break___9;
              }
            }
            while_break___9: /* CIL Label */ ;
            }
#line 1950
            if ((int )*q == 0) {
#line 1951
              ok = 1;
            }
#line 1952
            goto while_break___8;
          }
          {
#line 1954
          tmp___46 = strchr("[].-_#:", (int )*q);
          }
#line 1954
          if ((unsigned long )tmp___46 == (unsigned long )((void *)0)) {
#line 1955
            goto while_break___8;
          }
          __Cont___1: /* CIL Label */ 
#line 1933
          q ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 1958
        if ((int )*q == 0) {
#line 1958
          if (ok) {
            {
#line 1960
            q = (char *)"pleased to meet you";
#line 1961
            tmp___47 = sm_strdup_x((char const   *)p);
#line 1961
            sendinghost = (char */* volatile  */)tmp___47;
            }
          } else {
#line 1958
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 1963
        if (! AllowBogusHELO) {
          {
#line 1965
          usrerr("501 Invalid domain name");
          }
#line 1966
          if (LogLevel > 9) {
            {
#line 1967
            sm_syslog(6, (char const   *)CurEnv->e_id, "invalid domain name (%s) from %.100s",
                      p, CurSmtpClient);
            }
          }
#line 1970
          goto switch_break___3;
        } else {
#line 1974
          q = (char *)"accepting invalid domain name";
        }
#line 1977
        if (gothello) {
#line 1977
          goto _L___3;
        } else
#line 1977
        if (smtp___0.sm_gotmail) {
          _L___3: /* CIL Label */ 
          {
#line 1978
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 1978
            milter_abort((ENVELOPE *)e);
            }
#line 1978
            if (smtp___0.sm_nrcpts > 0U) {
              {
#line 1978
              logundelrcpts((ENVELOPE *)e, cmdbuf, 10, 0);
#line 1978
              smtp___0.sm_nrcpts = 0U;
#line 1978
              tmp___48 = macid_parse((char *)"{nrcpts}", (char **)((void *)0));
#line 1978
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___48, (char *)"0",
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               1978, SmHeapGroup);
              }
            }
#line 1978
            e->e_sendqueue = (ADDRESS *)((void *)0);
#line 1978
            e->e_flags |= 8UL;
#line 1978
            if (LogLevel > 4) {
#line 1978
              if ((e->e_flags & 32768UL) != 0UL) {
                {
#line 1978
                logsender((ENVELOPE *)e, (char *)((void *)0));
                }
              }
            }
            {
#line 1978
            e->e_flags &= 0xffffffffffff7fffUL;
#line 1978
            smtp___0.sm_gotmail = 0;
#line 1978
            SuprErrs = 1;
#line 1978
            dropenvelope((ENVELOPE *)e, 1, 0);
#line 1978
            sm_rpool_free(e->e_rpool);
#line 1978
            tmp___49 = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 1978
            tmp___50 = newenvelope((ENVELOPE *)e, CurEnv, tmp___49);
#line 1978
            e = (ENVELOPE */* volatile  */)tmp___50;
#line 1978
            CurEnv = (ENVELOPE *)e;
            }
#line 1978
            if (smtp___0.sm_discard) {
#line 1978
              e->e_flags |= 16777216UL;
            }
#line 1978
            if ((unsigned long )smtp___0.sm_quarmsg == (unsigned long )((void *)0)) {
              {
#line 1978
              e->e_quarmsg = (char *)((void *)0);
#line 1978
              tmp___51 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 1978
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___51, (char *)"",
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               1978, SmHeapGroup);
              }
            } else {
              {
#line 1978
              e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, (char const   *)smtp___0.sm_quarmsg);
#line 1978
              tmp___52 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 1978
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___52, e->e_quarmsg,
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               1978, SmHeapGroup);
              }
            }
#line 1978
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
        }
#line 1981
        if (smtp___0.sm_milterlist) {
#line 1981
          if (smtp___0.sm_milterize) {
#line 1981
            if (! ((e->e_flags & 16777216UL) != 0UL)) {
              {
#line 1987
              response___0 = milter_helo((char *)p, (ENVELOPE *)e, & state___1);
              }
              {
#line 1990
              if ((int )state___1 == 121) {
#line 1990
                goto case_121___0;
              }
#line 1999
              if ((int )state___1 == 114) {
#line 1999
                goto case_114___1;
              }
#line 2008
              if ((int )state___1 == 116) {
#line 2008
                goto case_116___1;
              }
#line 2017
              if ((int )state___1 == 52) {
#line 2017
                goto case_52___1;
              }
#line 1988
              goto switch_break___4;
              case_121___0: /* CIL Label */ 
#line 1991
              if (MilterLogLevel > 3) {
                {
#line 1992
                sm_syslog(6, (char const   *)e->e_id, "Milter: helo=%s, reject=%s",
                          p, response___0);
                }
              }
              {
#line 1995
              tmp___53 = newstr((char const   *)response___0);
#line 1995
              nullserver = (char */* volatile  */)tmp___53;
#line 1996
              smtp___0.sm_milterize = 0;
              }
#line 1997
              goto switch_break___4;
              case_114___1: /* CIL Label */ 
#line 2000
              if (MilterLogLevel > 3) {
                {
#line 2001
                sm_syslog(6, (char const   *)e->e_id, "Milter: helo=%s, reject=Command rejected",
                          p);
                }
              }
#line 2004
              nullserver = (char */* volatile  */)"Command rejected";
#line 2005
              smtp___0.sm_milterize = 0;
#line 2006
              goto switch_break___4;
              case_116___1: /* CIL Label */ 
#line 2009
              if (MilterLogLevel > 3) {
                {
#line 2010
                sm_syslog(6, (char const   *)e->e_id, "Milter: helo=%s, reject=%s",
                          p, "451 4.3.2 Please try again later");
                }
              }
#line 2013
              tempfail = (bool volatile   )1;
#line 2014
              smtp___0.sm_milterize = 0;
#line 2015
              goto switch_break___4;
              case_52___1: /* CIL Label */ 
#line 2018
              if (MilterLogLevel > 3) {
                {
#line 2019
                sm_syslog(6, (char const   *)e->e_id, "Milter: Milter: helo=%s, reject=421 4.7.0 %s closing connection",
                          p, MyHostName);
                }
              }
              {
#line 2022
              tempfail = (bool volatile   )1;
#line 2023
              smtp___0.sm_milterize = 0;
#line 2024
              message("421 4.7.0 %s closing connection", MyHostName);
#line 2027
              e->e_sendqueue = (ADDRESS *)((void *)0);
              }
#line 2028
              goto doquit;
              switch_break___4: /* CIL Label */ ;
              }
#line 2030
              if ((unsigned long )response___0 != (unsigned long )((void *)0)) {
                {
#line 2031
                sm_free_tagged((void *)response___0, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2031);
                }
              }
#line 2038
              if ((unsigned long )smtp___0.sm_quarmsg == (unsigned long )((void *)0)) {
#line 2038
                if ((unsigned long )e->e_quarmsg != (unsigned long )((void *)0)) {
                  {
#line 2040
                  smtp___0.sm_quarmsg = newstr((char const   *)e->e_quarmsg);
                  }
                }
              }
            }
          }
        }
#line 2043
        gothello = (bool volatile   )1;
#line 2046
        if (c->cmd_code != 11) {
          {
#line 2048
          message("250 %s Hello %s, %s", MyHostName, CurSmtpClient, q);
          }
#line 2050
          goto switch_break___3;
        }
        {
#line 2053
        message("250-%s Hello %s, %s", MyHostName, CurSmtpClient, q);
        }
#line 2057
        if ((unsigned long )nullserver != (unsigned long )((void *)0)) {
          {
#line 2059
          message("250 ENHANCEDSTATUSCODES");
          }
#line 2060
          goto switch_break___3;
        }
        {
#line 2070
        message("250-ENHANCEDSTATUSCODES");
        }
#line 2072
        if ((features & (unsigned int volatile   )256) != (unsigned int volatile   )0) {
          {
#line 2073
          message("250-PIPELINING");
          }
        }
#line 2075
        if ((features & (unsigned int volatile   )32) != (unsigned int volatile   )0) {
          {
#line 2077
          message("250-EXPN");
          }
#line 2078
          if ((features & (unsigned int volatile   )64) != (unsigned int volatile   )0) {
            {
#line 2079
            message("250-VERB");
            }
          }
        }
        {
#line 2082
        message("250-8BITMIME");
        }
#line 2084
        if (MaxMessageSize > 0L) {
          {
#line 2085
          message("250-SIZE %ld", MaxMessageSize);
          }
        } else {
          {
#line 2087
          message("250-SIZE");
          }
        }
#line 2089
        if (SendMIMEErrors) {
#line 2089
          if ((features & (unsigned int volatile   )128) != (unsigned int volatile   )0) {
            {
#line 2090
            message("250-DSN");
            }
          }
        }
#line 2092
        if ((features & (unsigned int volatile   )8) != (unsigned int volatile   )0) {
          {
#line 2093
          message("250-ETRN");
          }
        }
#line 2103
        if (DeliverByMin > 0L) {
          {
#line 2104
          message("250-DELIVERBY %ld", DeliverByMin);
          }
        } else
#line 2106
        if (DeliverByMin == 0L) {
          {
#line 2107
          message("250-DELIVERBY");
          }
        }
        {
#line 2111
        message("250 HELP");
        }
#line 2112
        goto switch_break___3;
        case_1___0: /* CIL Label */ 
#line 2115
        SmtpPhase = (char *)"server MAIL";
#line 2116
        if (DelayLA > 0) {
          {
#line 2116
          CurrentLA = getla();
          }
#line 2116
          if (CurrentLA >= DelayLA) {
            {
#line 2116
            tmp___54 = qid_printname((ENVELOPE *)e);
#line 2116
            sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                            tmp___54, CurSmtpClient, "MAIL", DelayLA);
            }
#line 2116
            if (LogLevel > 8) {
              {
#line 2116
              dnow___1 = curtime();
              }
#line 2116
              if (dnow___1 > (time_t )log_delay___0) {
                {
#line 2116
                sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                          "MAIL", CurrentLA, DelayLA);
#line 2116
                log_delay___0 = (time_t volatile   )(dnow___1 + 15L);
                }
              }
            }
            {
#line 2116
            sleep(1U);
#line 2116
            tmp___55 = qid_printname((ENVELOPE *)e);
#line 2116
            sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___55, CurSmtpClient,
                            inp);
            }
          }
        }
#line 2119
        if (! gothello) {
#line 2119
          if ((PrivacyFlags & 1UL) != 0UL) {
            {
#line 2121
            usrerr("503 5.0.0 Polite people say HELO first");
            }
#line 2122
            goto switch_break___3;
          }
        }
#line 2124
        if (smtp___0.sm_gotmail) {
          {
#line 2126
          usrerr("503 5.5.0 Sender already specified");
          }
#line 2127
          goto switch_break___3;
        }
        {
#line 2138
        tmp___56 = skipword(p, (char *)"from");
#line 2138
        p = (char */* volatile  */)tmp___56;
        }
#line 2139
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2140
          goto switch_break___3;
        }
#line 2141
        if (tempfail) {
#line 2143
          if (LogLevel > 9) {
            {
#line 2144
            sm_syslog(6, (char const   *)e->e_id, "SMTP MAIL command (%.100s) from %s tempfailed (due to previous checks)",
                      p, CurSmtpClient);
            }
          }
          {
#line 2147
          usrerr("451 4.3.2 Please try again later");
          }
#line 2148
          goto switch_break___3;
        }
#line 2152
        if ((unsigned long )sendinghost == (unsigned long )((void *)0)) {
#line 2153
          sendinghost = peerhostname;
        }
#line 2157
        if (DebugLeakSmtp.debug_level >= 1U) {
#line 2157
          if (DebugLeakSmtp.debug_level != 4294967295U) {
            {
#line 2159
            SmHeapMaxGroup ++;
#line 2159
            SmHeapGroup = SmHeapMaxGroup;
#line 2160
            sm_dprintf((char *)"smtp() heap group #%d\n", SmHeapGroup);
            }
          } else {
            {
#line 2157
            tmp___57 = sm_debug_loadactive(& DebugLeakSmtp, 1);
            }
#line 2157
            if (tmp___57) {
              {
#line 2159
              SmHeapMaxGroup ++;
#line 2159
              SmHeapGroup = SmHeapMaxGroup;
#line 2160
              sm_dprintf((char *)"smtp() heap group #%d\n", SmHeapGroup);
              }
            }
          }
        }
#line 2165
        if (Errors > 0) {
#line 2166
          goto undo_no_pm;
        }
#line 2167
        if (! gothello) {
          {
#line 2169
          auth_warning((ENVELOPE *)e, "%s didn\'t use HELO protocol", CurSmtpClient);
          }
        }
#line 2182
        if ((unsigned long )protocol == (unsigned long )((void *)0)) {
#line 2183
          protocol = (char */* volatile  */)"SMTP";
        }
        {
#line 2184
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'r', (char *)protocol, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                         2184, SmHeapGroup);
#line 2185
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 's', (char *)sendinghost, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                         2185, SmHeapGroup);
        }
#line 2187
        if (Errors > 0) {
#line 2188
          goto undo_no_pm;
        }
        {
#line 2189
        smtp___0.sm_nrcpts = 0U;
#line 2190
        n_badrcpts = (unsigned int volatile   )0;
#line 2191
        tmp___58 = macid_parse((char *)"{ntries}", (char **)((void *)0));
#line 2191
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___58, (char *)"0", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                         2191, SmHeapGroup);
#line 2192
        tmp___59 = macid_parse((char *)"{nrcpts}", (char **)((void *)0));
#line 2192
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___59, (char *)"0", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                         2192, SmHeapGroup);
#line 2193
        tmp___60 = macid_parse((char *)"{nbadrcpts}", (char **)((void *)0));
#line 2193
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___60, (char *)"0", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                         2194, SmHeapGroup);
#line 2195
        e->e_flags |= 8UL;
#line 2196
        tmp___61 = qid_printname((ENVELOPE *)e);
#line 2196
        sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___61, CurSmtpClient,
                        inp);
        }
        {
#line 2201
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 2201
          _h___0.eh_value = (SM_EXC_T *)((void *)0);
#line 2201
          _h___0.eh_parent = SmExcHandler;
#line 2201
          _h___0.eh_state = 2;
#line 2201
          SmExcHandler = & _h___0;
#line 2201
          tmp___85 = __sigsetjmp((struct __jmp_buf_tag *)(_h___0.eh_context), 0);
          }
#line 2201
          if (tmp___85 == 0) {
#line 2205
            QuickAbort = 1;
#line 2206
            if ((unsigned long )FullName != (unsigned long )((void *)0)) {
              {
#line 2206
              sm_free_tagged((void *)FullName, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2206);
#line 2206
              FullName = (char *)((void *)0);
              }
            }
            {
#line 2209
            delimptr = (char *)((void *)0);
#line 2210
            setsender((char *)p, (ENVELOPE *)e, & delimptr, ' ', 0);
            }
#line 2211
            if ((unsigned long )delimptr != (unsigned long )((void *)0)) {
#line 2211
              if ((int )*delimptr != 0) {
#line 2212
                tmp___62 = delimptr;
#line 2212
                delimptr ++;
#line 2212
                *tmp___62 = (char )'\000';
              }
            }
#line 2213
            if (Errors > 0) {
              {
#line 2214
              sm_exc_raisenew_x(& EtypeQuickAbort, 1);
              }
            }
#line 2217
            e->e_flags |= 32768UL;
#line 2220
            if ((unsigned long )e->e_from.q_mailer != (unsigned long )((void *)0)) {
              {
#line 2221
              tmp___63 = macid_parse((char *)"{mail_mailer}", (char **)((void *)0));
#line 2221
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___63, (e->e_from.q_mailer)->m_name,
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2223, SmHeapGroup);
              }
            } else {
              {
#line 2225
              tmp___64 = macid_parse((char *)"{mail_mailer}", (char **)((void *)0));
#line 2225
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___64, (char *)((void *)0),
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2226, SmHeapGroup);
              }
            }
#line 2227
            if ((unsigned long )e->e_from.q_host != (unsigned long )((void *)0)) {
              {
#line 2228
              tmp___65 = macid_parse((char *)"{mail_host}", (char **)((void *)0));
#line 2228
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___65, e->e_from.q_host,
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2230, SmHeapGroup);
              }
            } else {
              {
#line 2232
              tmp___66 = macid_parse((char *)"{mail_host}", (char **)((void *)0));
#line 2232
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___66, (char *)"localhost",
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2233, SmHeapGroup);
              }
            }
#line 2234
            if ((unsigned long )e->e_from.q_user != (unsigned long )((void *)0)) {
              {
#line 2235
              tmp___67 = macid_parse((char *)"{mail_addr}", (char **)((void *)0));
#line 2235
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___67, e->e_from.q_user,
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2237, SmHeapGroup);
              }
            } else {
              {
#line 2239
              tmp___68 = macid_parse((char *)"{mail_addr}", (char **)((void *)0));
#line 2239
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___68, (char *)((void *)0),
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2240, SmHeapGroup);
              }
            }
#line 2241
            if (Errors > 0) {
              {
#line 2242
              sm_exc_raisenew_x(& EtypeQuickAbort, 1);
              }
            }
#line 2245
            if (RealUid != 0U) {
#line 2245
              if ((int )OpMode == 115) {
                {
#line 2245
                tmp___69 = wordinclass(RealUserName, 't');
                }
#line 2245
                if (! tmp___69) {
#line 2245
                  if (! ((e->e_from.q_mailer)->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int ))))) {
                    {
#line 2251
                    auth_warning((ENVELOPE *)e, "%s owned process doing -bs", RealUserName);
                    }
                  } else {
                    {
#line 2245
                    tmp___70 = strcmp((char const   *)e->e_from.q_user, (char const   *)RealUserName);
                    }
#line 2245
                    if (tmp___70 != 0) {
                      {
#line 2251
                      auth_warning((ENVELOPE *)e, "%s owned process doing -bs", RealUserName);
                      }
                    }
                  }
                }
              }
            }
#line 2256
            SevenBitInput = (bool )save_sevenbitinput;
#line 2259
            e->e_msgsize = 0L;
#line 2260
            addr = (char *)p;
#line 2261
            argno = 0;
#line 2262
            tmp___71 = argno;
#line 2262
            argno ++;
#line 2262
            args[tmp___71] = (char *)p;
#line 2263
            p = (char */* volatile  */)delimptr;
            {
#line 2264
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 2264
              if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2264
                if (! ((int )*p != 0)) {
#line 2264
                  goto while_break___12;
                }
              } else {
#line 2264
                goto while_break___12;
              }
#line 2267
              vp = (char *)((void *)0);
#line 2268
              equal = (char *)((void *)0);
              {
#line 2271
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 2271
                if (((int )*p & -128) == 0) {
                  {
#line 2271
                  tmp___72 = __ctype_b_loc();
                  }
#line 2271
                  if (! ((int const   )*(*tmp___72 + (int )*p) & 8192)) {
#line 2271
                    goto while_break___13;
                  }
                } else {
#line 2271
                  goto while_break___13;
                }
#line 2271
                p ++;
              }
              while_break___13: /* CIL Label */ ;
              }
#line 2272
              if ((int )*p == 0) {
#line 2273
                goto while_break___12;
              }
#line 2274
              kp = (char *)p;
              {
#line 2277
              while (1) {
                while_continue___14: /* CIL Label */ ;
#line 2277
                if (((int )*p & -128) == 0) {
                  {
#line 2277
                  tmp___73 = __ctype_b_loc();
                  }
#line 2277
                  if (! ((int const   )*(*tmp___73 + (int )*p) & 8)) {
#line 2277
                    goto _L___4;
                  }
                } else
                _L___4: /* CIL Label */ 
#line 2277
                if (! ((int )*p == 45)) {
#line 2277
                  goto while_break___14;
                }
#line 2278
                p ++;
              }
              while_break___14: /* CIL Label */ ;
              }
#line 2279
              if ((int )*p == 61) {
#line 2281
                equal = (char *)p;
#line 2282
                tmp___74 = p;
#line 2282
                p ++;
#line 2282
                *tmp___74 = (char )'\000';
#line 2283
                vp = (char *)p;
                {
#line 2286
                while (1) {
                  while_continue___15: /* CIL Label */ ;
#line 2286
                  if ((int )*p != 0) {
#line 2286
                    if ((int )*p != 32) {
#line 2286
                      if (((int )*p & -128) == 0) {
                        {
#line 2286
                        tmp___75 = __ctype_b_loc();
                        }
#line 2286
                        if ((int const   )*(*tmp___75 + (int )*p) & 2) {
#line 2286
                          goto while_break___15;
                        } else {
#line 2286
                          goto _L___5;
                        }
                      } else
                      _L___5: /* CIL Label */ 
#line 2286
                      if (! ((int )*p != 61)) {
#line 2286
                        goto while_break___15;
                      }
                    } else {
#line 2286
                      goto while_break___15;
                    }
                  } else {
#line 2286
                    goto while_break___15;
                  }
#line 2289
                  p ++;
                }
                while_break___15: /* CIL Label */ ;
                }
              }
#line 2292
              if ((int )*p != 0) {
#line 2293
                tmp___76 = p;
#line 2293
                p ++;
#line 2293
                *tmp___76 = (char )'\000';
              }
#line 2295
              if ((int )tTdvect[19] >= 1) {
#line 2296
                if ((unsigned long )vp == (unsigned long )((void *)0)) {
#line 2296
                  tmp___77 = "<null>";
                } else {
#line 2296
                  tmp___77 = (char const   *)vp;
                }
                {
#line 2296
                sm_dprintf((char *)"MAIL: got arg %s=\"%s\"\n", kp, tmp___77);
                }
              }
              {
#line 2299
              mail_esmtp_args(kp, vp, (ENVELOPE *)e);
              }
#line 2300
              if ((unsigned long )equal != (unsigned long )((void *)0)) {
#line 2301
                *equal = (char )'=';
              }
#line 2302
              tmp___78 = argno;
#line 2302
              argno ++;
#line 2302
              args[tmp___78] = kp;
#line 2303
              if (argno >= 19) {
                {
#line 2304
                usrerr("501 5.5.4 Too many parameters");
                }
              }
#line 2305
              if (Errors > 0) {
                {
#line 2306
                sm_exc_raisenew_x(& EtypeQuickAbort, 1);
                }
              }
            }
            while_break___12: /* CIL Label */ ;
            }
#line 2308
            args[argno] = (char *)((void *)0);
#line 2309
            if (Errors > 0) {
              {
#line 2310
              sm_exc_raisenew_x(& EtypeQuickAbort, 1);
              }
            }
            {
#line 2333
            tmp___79 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 2333
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___79, (char *)"e s",
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2334, SmHeapGroup);
#line 2340
            tmp___80 = rscheck((char *)"check_mail", addr, (char *)((void *)0), (ENVELOPE *)e,
                               5, 3, (char *)((void *)0), e->e_id);
            }
#line 2340
            if (tmp___80 != 0) {
              {
#line 2344
              sm_exc_raisenew_x(& EtypeQuickAbort, 1);
              }
            } else
#line 2340
            if (Errors > 0) {
              {
#line 2344
              sm_exc_raisenew_x(& EtypeQuickAbort, 1);
              }
            }
            {
#line 2345
            tmp___81 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 2345
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___81, (char *)((void *)0),
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2346, SmHeapGroup);
            }
#line 2348
            if (MaxMessageSize > 0L) {
#line 2348
              if (e->e_msgsize > MaxMessageSize) {
                {
#line 2352
                usrerr("552 5.2.3 Message size exceeds fixed maximum message size (%ld)",
                       MaxMessageSize);
#line 2354
                sm_exc_raisenew_x(& EtypeQuickAbort, 1);
                }
              } else
#line 2348
              if (e->e_msgsize < 0L) {
                {
#line 2352
                usrerr("552 5.2.3 Message size exceeds fixed maximum message size (%ld)",
                       MaxMessageSize);
#line 2354
                sm_exc_raisenew_x(& EtypeQuickAbort, 1);
                }
              }
            }
#line 2365
            if (*PNumFileSys == 1) {
#line 2365
              goto _L___6;
            } else
#line 2365
            if (NumQueue == 1) {
              _L___6: /* CIL Label */ 
              {
#line 2365
              tmp___82 = enoughdiskspace(e->e_msgsize, (ENVELOPE *)e);
              }
#line 2365
              if (! tmp___82) {
                {
#line 2377
                usrerr("452 4.4.5 Insufficient disk space; try again later");
#line 2378
                sm_exc_raisenew_x(& EtypeQuickAbort, 1);
                }
              }
            }
#line 2380
            if (Errors > 0) {
              {
#line 2381
              sm_exc_raisenew_x(& EtypeQuickAbort, 1);
              }
            }
#line 2383
            LogUsrErrs = 1;
#line 2385
            if (smtp___0.sm_milterlist) {
#line 2385
              if (smtp___0.sm_milterize) {
#line 2385
                if (! ((e->e_flags & 16777216UL) != 0UL)) {
                  {
#line 2391
                  response___1 = milter_envfrom(args, (ENVELOPE *)e, & state___2);
#line 2392
                  savelogusrerrs = LogUsrErrs;
                  }
                  {
#line 2392
                  if ((int )state___2 == 52) {
#line 2392
                    goto case_52___2;
                  }
#line 2392
                  if ((int )state___2 == 121) {
#line 2392
                    goto case_121___1;
                  }
#line 2392
                  if ((int )state___2 == 114) {
#line 2392
                    goto case_114___2;
                  }
#line 2392
                  if ((int )state___2 == 100) {
#line 2392
                    goto case_100;
                  }
#line 2392
                  if ((int )state___2 == 116) {
#line 2392
                    goto case_116___2;
                  }
#line 2392
                  goto switch_break___5;
                  case_52___2: /* CIL Label */ 
#line 2392
                  if (MilterLogLevel > 3) {
                    {
#line 2392
                    sm_syslog(6, (char const   *)e->e_id, "Milter: %s=%s, reject=421, errormode=4",
                              "from", addr);
#line 2392
                    LogUsrErrs = 0;
                    }
                  }
                  {
#line 2392
                  tsave = QuickAbort;
#line 2392
                  QuickAbort = 0;
#line 2392
                  usrerr("421 4.3.0 closing connection");
#line 2392
                  QuickAbort = tsave;
#line 2392
                  e->e_sendqueue = (ADDRESS *)((void *)0);
                  }
#line 2392
                  goto doquit;
#line 2392
                  goto switch_break___5;
                  case_121___1: /* CIL Label */ 
#line 2392
                  if (MilterLogLevel > 3) {
                    {
#line 2392
                    sm_syslog(6, (char const   *)e->e_id, "Milter: %s=%s, reject=%s",
                              "from", addr, response___1);
#line 2392
                    LogUsrErrs = 0;
                    }
                  }
                  {
#line 2392
                  tmp___83 = strncmp((char const   *)response___1, "421 ", (size_t )4);
                  }
#line 2392
                  if (tmp___83 == 0) {
#line 2392
                    goto _L___7;
                  } else {
                    {
#line 2392
                    tmp___84 = strncmp((char const   *)response___1, "421-", (size_t )4);
                    }
#line 2392
                    if (tmp___84 == 0) {
                      _L___7: /* CIL Label */ 
                      {
#line 2392
                      tsave___0 = QuickAbort;
#line 2392
                      QuickAbort = 0;
#line 2392
                      usrerr((char const   *)response___1);
#line 2392
                      QuickAbort = tsave___0;
#line 2392
                      e->e_sendqueue = (ADDRESS *)((void *)0);
                      }
#line 2392
                      goto doquit;
                    } else {
                      {
#line 2392
                      usrerr((char const   *)response___1);
                      }
                    }
                  }
#line 2392
                  goto switch_break___5;
                  case_114___2: /* CIL Label */ 
#line 2392
                  if (MilterLogLevel > 3) {
                    {
#line 2392
                    sm_syslog(6, (char const   *)e->e_id, "Milter: %s=%s, reject=550 5.7.1 Command rejected",
                              "from", addr);
#line 2392
                    LogUsrErrs = 0;
                    }
                  }
                  {
#line 2392
                  usrerr("550 5.7.1 Command rejected");
                  }
#line 2392
                  goto switch_break___5;
                  case_100: /* CIL Label */ 
#line 2392
                  if (MilterLogLevel > 3) {
                    {
#line 2392
                    sm_syslog(6, (char const   *)e->e_id, "Milter: %s=%s, discard",
                              "from", addr);
                    }
                  }
#line 2392
                  e->e_flags |= 16777216UL;
#line 2392
                  goto switch_break___5;
                  case_116___2: /* CIL Label */ 
#line 2392
                  if (MilterLogLevel > 3) {
                    {
#line 2392
                    sm_syslog(6, (char const   *)e->e_id, "Milter: %s=%s, reject=%s",
                              "from", addr, "451 4.3.2 Please try again later");
#line 2392
                    LogUsrErrs = 0;
                    }
                  }
                  {
#line 2392
                  usrerr("451 4.3.2 Please try again later");
                  }
#line 2392
                  goto switch_break___5;
                  switch_break___5: /* CIL Label */ ;
                  }
#line 2392
                  LogUsrErrs = savelogusrerrs;
#line 2392
                  if ((unsigned long )response___1 != (unsigned long )((void *)0)) {
                    {
#line 2392
                    sm_free_tagged((void *)response___1, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                                   2392);
                    }
                  }
                }
              }
            }
#line 2395
            if (Errors > 0) {
              {
#line 2396
              sm_exc_raisenew_x(& EtypeQuickAbort, 1);
              }
            }
            {
#line 2398
            message("250 2.1.0 Sender ok");
#line 2399
            smtp___0.sm_gotmail = 1;
            }
          }
#line 2401
          if (_h___0.eh_state == 1) {
#line 2401
            goto while_break___11;
          }
#line 2401
          if (_h___0.eh_state == 2) {
#line 2401
            if ((unsigned long )SmExcHandler == (unsigned long )(& _h___0)) {
#line 2401
              tmp___86 = 1;
            } else {
              {
#line 2401
              sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                          2401, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2401
              tmp___86 = 0;
              }
            }
#line 2401
            SmExcHandler = _h___0.eh_parent;
          }
          {
#line 2401
          tmp___88 = sm_exc_match(_h___0.eh_value, "[!F]*");
          }
#line 2401
          if (tmp___88) {
#line 2401
            _h___0.eh_state = 1;
          } else {
#line 2401
            _h___0.eh_state = 0;
          }
#line 2401
          if (_h___0.eh_state == 1) {
            {
#line 2401
            exc = _h___0.eh_value;
#line 2408
            sm_exc_free(exc);
            }
#line 2409
            goto undo_no_pm;
          }
#line 2201
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 2411
        if (_h___0.eh_state == 2) {
#line 2411
          if ((unsigned long )SmExcHandler == (unsigned long )(& _h___0)) {
#line 2411
            tmp___89 = 1;
          } else {
            {
#line 2411
            sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                        2411, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2411
            tmp___89 = 0;
            }
          }
#line 2411
          SmExcHandler = _h___0.eh_parent;
#line 2411
          if ((unsigned long )_h___0.eh_value != (unsigned long )((void *)0)) {
            {
#line 2411
            sm_exc_raise_x(_h___0.eh_value);
            }
          }
        } else
#line 2411
        if (_h___0.eh_state == 0) {
#line 2411
          if ((unsigned long )_h___0.eh_value != (unsigned long )((void *)0)) {
            {
#line 2411
            sm_exc_raise_x(_h___0.eh_value);
            }
          }
        } else {
          {
#line 2411
          sm_exc_free(_h___0.eh_value);
          }
        }
#line 2412
        goto switch_break___3;
        undo_no_pm: 
#line 2415
        e->e_flags &= 0xffffffffffffdfffUL;
        undo: 
#line 2417
        goto switch_break___3;
        case_2: /* CIL Label */ 
#line 2420
        if (DelayLA > 0) {
          {
#line 2420
          CurrentLA = getla();
          }
#line 2420
          if (CurrentLA >= DelayLA) {
            {
#line 2420
            tmp___90 = qid_printname((ENVELOPE *)e);
#line 2420
            sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                            tmp___90, CurSmtpClient, "RCPT", DelayLA);
            }
#line 2420
            if (LogLevel > 8) {
              {
#line 2420
              dnow___2 = curtime();
              }
#line 2420
              if (dnow___2 > (time_t )log_delay___0) {
                {
#line 2420
                sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                          "RCPT", CurrentLA, DelayLA);
#line 2420
                log_delay___0 = (time_t volatile   )(dnow___2 + 15L);
                }
              }
            }
            {
#line 2420
            sleep(1U);
#line 2420
            tmp___91 = qid_printname((ENVELOPE *)e);
#line 2420
            sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___91, CurSmtpClient,
                            inp);
            }
          }
        }
#line 2421
        if (BadRcptThrottle > 0) {
#line 2421
          if (n_badrcpts >= (unsigned int volatile   )BadRcptThrottle) {
#line 2424
            if (LogLevel > 5) {
#line 2424
              if (n_badrcpts == (unsigned int volatile   )BadRcptThrottle) {
                {
#line 2427
                sm_syslog(6, (char const   *)e->e_id, "%s: Possible SMTP RCPT flood, throttling.",
                          CurSmtpClient);
#line 2432
                n_badrcpts += (unsigned int volatile   )1;
                }
              }
            }
            {
#line 2434
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 2434
              if (BadRcptThrottle > 0) {
#line 2434
                if (n_badrcpts > (unsigned int volatile   )BadRcptThrottle) {
#line 2434
                  tmp___92 = n_badrcpts - (unsigned int volatile   )1;
                } else {
#line 2434
                  tmp___92 = n_badrcpts;
                }
              } else {
#line 2434
                tmp___92 = n_badrcpts;
              }
              {
#line 2434
              sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%d", tmp___92);
#line 2434
              tmp___93 = macid_parse((char *)"{nbadrcpts}", (char **)((void *)0));
#line 2434
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___93, buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2434, SmHeapGroup);
              }
#line 2434
              goto while_break___16;
            }
            while_break___16: /* CIL Label */ ;
            }
            {
#line 2443
            sleep(1U);
            }
          }
        }
#line 2445
        if (! smtp___0.sm_gotmail) {
          {
#line 2447
          usrerr("503 5.0.0 Need MAIL before RCPT");
          }
#line 2448
          goto switch_break___3;
        }
#line 2450
        SmtpPhase = (char *)"server RCPT";
        {
#line 2451
        while (1) {
          while_continue___17: /* CIL Label */ ;
          {
#line 2451
          _h___1.eh_value = (SM_EXC_T *)((void *)0);
#line 2451
          _h___1.eh_parent = SmExcHandler;
#line 2451
          _h___1.eh_state = 2;
#line 2451
          SmExcHandler = & _h___1;
#line 2451
          tmp___125 = __sigsetjmp((struct __jmp_buf_tag *)(_h___1.eh_context), 0);
          }
#line 2451
          if (tmp___125 == 0) {
#line 2453
            QuickAbort = 1;
#line 2454
            LogUsrErrs = 1;
#line 2457
            if (MaxRcptPerMsg > 0) {
#line 2457
              if (smtp___0.sm_nrcpts >= (unsigned int )MaxRcptPerMsg) {
                {
#line 2461
                usrerr("452 4.5.3 Too many recipients");
                }
#line 2462
                goto rcpt_done;
              }
            }
#line 2465
            if ((int )e->e_sendmode != 105) {
#line 2470
              e->e_flags |= 512UL;
            }
            {
#line 2482
            tmp___94 = milter_can_delrcpts();
            }
#line 2482
            if (tmp___94) {
#line 2483
              e->e_flags |= 512UL;
            }
            {
#line 2486
            tmp___95 = skipword(p, (char *)"to");
#line 2486
            p = (char */* volatile  */)tmp___95;
            }
#line 2487
            if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2488
              goto rcpt_done;
            }
            {
#line 2489
            tmp___96 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 2489
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___96, (char *)"e r",
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2490, SmHeapGroup);
#line 2491
            a = parseaddr((char *)p, (ADDRESS *)((void *)0), 48, ' ', & delimptr,
                          (ENVELOPE *)e, 1);
#line 2493
            tmp___97 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 2493
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___97, (char *)((void *)0),
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2494, SmHeapGroup);
            }
#line 2495
            if (Errors > 0) {
#line 2496
              goto rcpt_done;
            }
#line 2497
            if ((unsigned long )a == (unsigned long )((void *)0)) {
              {
#line 2499
              usrerr("501 5.0.0 Missing recipient");
              }
#line 2500
              goto rcpt_done;
            }
#line 2503
            if ((unsigned long )delimptr != (unsigned long )((void *)0)) {
#line 2503
              if ((int )*delimptr != 0) {
#line 2504
                tmp___98 = delimptr;
#line 2504
                delimptr ++;
#line 2504
                *tmp___98 = (char )'\000';
              }
            }
#line 2507
            if ((unsigned long )a->q_mailer != (unsigned long )((void *)0)) {
              {
#line 2508
              tmp___99 = macid_parse((char *)"{rcpt_mailer}", (char **)((void *)0));
#line 2508
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___99, (a->q_mailer)->m_name,
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2510, SmHeapGroup);
              }
            } else {
              {
#line 2512
              tmp___100 = macid_parse((char *)"{rcpt_mailer}", (char **)((void *)0));
#line 2512
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___100, (char *)((void *)0),
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2513, SmHeapGroup);
              }
            }
#line 2514
            if ((unsigned long )a->q_host != (unsigned long )((void *)0)) {
              {
#line 2515
              tmp___101 = macid_parse((char *)"{rcpt_host}", (char **)((void *)0));
#line 2515
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___101, a->q_host,
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2516, SmHeapGroup);
              }
            } else {
              {
#line 2518
              tmp___102 = macid_parse((char *)"{rcpt_host}", (char **)((void *)0));
#line 2518
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___102, (char *)"localhost",
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2519, SmHeapGroup);
              }
            }
#line 2520
            if ((unsigned long )a->q_user != (unsigned long )((void *)0)) {
              {
#line 2521
              tmp___103 = macid_parse((char *)"{rcpt_addr}", (char **)((void *)0));
#line 2521
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___103, a->q_user,
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2522, SmHeapGroup);
              }
            } else {
              {
#line 2524
              tmp___104 = macid_parse((char *)"{rcpt_addr}", (char **)((void *)0));
#line 2524
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___104, (char *)((void *)0),
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2525, SmHeapGroup);
              }
            }
#line 2526
            if (Errors > 0) {
#line 2527
              goto rcpt_done;
            }
#line 2530
            addr = (char *)p;
#line 2531
            argno = 0;
#line 2532
            tmp___105 = argno;
#line 2532
            argno ++;
#line 2532
            args[tmp___105] = (char *)p;
#line 2533
            p = (char */* volatile  */)delimptr;
            {
#line 2534
            while (1) {
              while_continue___18: /* CIL Label */ ;
#line 2534
              if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2534
                if (! ((int )*p != 0)) {
#line 2534
                  goto while_break___18;
                }
              } else {
#line 2534
                goto while_break___18;
              }
#line 2537
              vp___0 = (char *)((void *)0);
#line 2538
              equal___0 = (char *)((void *)0);
              {
#line 2541
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 2541
                if (((int )*p & -128) == 0) {
                  {
#line 2541
                  tmp___106 = __ctype_b_loc();
                  }
#line 2541
                  if (! ((int const   )*(*tmp___106 + (int )*p) & 8192)) {
#line 2541
                    goto while_break___19;
                  }
                } else {
#line 2541
                  goto while_break___19;
                }
#line 2541
                p ++;
              }
              while_break___19: /* CIL Label */ ;
              }
#line 2542
              if ((int )*p == 0) {
#line 2543
                goto while_break___18;
              }
#line 2544
              kp___0 = (char *)p;
              {
#line 2547
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 2547
                if (((int )*p & -128) == 0) {
                  {
#line 2547
                  tmp___107 = __ctype_b_loc();
                  }
#line 2547
                  if (! ((int const   )*(*tmp___107 + (int )*p) & 8)) {
#line 2547
                    goto _L___8;
                  }
                } else
                _L___8: /* CIL Label */ 
#line 2547
                if (! ((int )*p == 45)) {
#line 2547
                  goto while_break___20;
                }
#line 2548
                p ++;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 2549
              if ((int )*p == 61) {
#line 2551
                equal___0 = (char *)p;
#line 2552
                tmp___108 = p;
#line 2552
                p ++;
#line 2552
                *tmp___108 = (char )'\000';
#line 2553
                vp___0 = (char *)p;
                {
#line 2556
                while (1) {
                  while_continue___21: /* CIL Label */ ;
#line 2556
                  if ((int )*p != 0) {
#line 2556
                    if ((int )*p != 32) {
#line 2556
                      if (((int )*p & -128) == 0) {
                        {
#line 2556
                        tmp___109 = __ctype_b_loc();
                        }
#line 2556
                        if ((int const   )*(*tmp___109 + (int )*p) & 2) {
#line 2556
                          goto while_break___21;
                        } else {
#line 2556
                          goto _L___9;
                        }
                      } else
                      _L___9: /* CIL Label */ 
#line 2556
                      if (! ((int )*p != 61)) {
#line 2556
                        goto while_break___21;
                      }
                    } else {
#line 2556
                      goto while_break___21;
                    }
                  } else {
#line 2556
                    goto while_break___21;
                  }
#line 2559
                  p ++;
                }
                while_break___21: /* CIL Label */ ;
                }
              }
#line 2562
              if ((int )*p != 0) {
#line 2563
                tmp___110 = p;
#line 2563
                p ++;
#line 2563
                *tmp___110 = (char )'\000';
              }
#line 2565
              if ((int )tTdvect[19] >= 1) {
#line 2566
                if ((unsigned long )vp___0 == (unsigned long )((void *)0)) {
#line 2566
                  tmp___111 = "<null>";
                } else {
#line 2566
                  tmp___111 = (char const   *)vp___0;
                }
                {
#line 2566
                sm_dprintf((char *)"RCPT: got arg %s=\"%s\"\n", kp___0, tmp___111);
                }
              }
              {
#line 2569
              rcpt_esmtp_args(a, kp___0, vp___0, (ENVELOPE *)e);
              }
#line 2570
              if ((unsigned long )equal___0 != (unsigned long )((void *)0)) {
#line 2571
                *equal___0 = (char )'=';
              }
#line 2572
              tmp___112 = argno;
#line 2572
              argno ++;
#line 2572
              args[tmp___112] = kp___0;
#line 2573
              if (argno >= 19) {
                {
#line 2574
                usrerr("501 5.5.4 Too many parameters");
                }
              }
#line 2575
              if (Errors > 0) {
#line 2576
                goto while_break___18;
              }
            }
            while_break___18: /* CIL Label */ ;
            }
#line 2578
            args[argno] = (char *)((void *)0);
#line 2579
            if (Errors > 0) {
#line 2580
              goto rcpt_done;
            }
            {
#line 2583
            tmp___113 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 2583
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___113, (char *)"e r",
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2584, SmHeapGroup);
#line 2585
            tmp___114 = rscheck((char *)"check_rcpt", addr, (char *)((void *)0), (ENVELOPE *)e,
                                5, 3, (char *)((void *)0), e->e_id);
            }
#line 2585
            if (tmp___114 != 0) {
#line 2589
              goto rcpt_done;
            } else
#line 2585
            if (Errors > 0) {
#line 2589
              goto rcpt_done;
            }
            {
#line 2590
            tmp___115 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 2590
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___115, (char *)((void *)0),
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2591, SmHeapGroup);
            }
#line 2594
            if ((e->e_flags & 16777216UL) != 0UL) {
#line 2595
              a->q_state = (short)5;
            }
#line 2598
            if (smtp___0.sm_milterlist) {
#line 2598
              if (smtp___0.sm_milterize) {
#line 2598
                if (! ((e->e_flags & 16777216UL) != 0UL)) {
                  {
#line 2604
                  response___2 = milter_envrcpt(args, (ENVELOPE *)e, & state___3);
#line 2605
                  savelogusrerrs___0 = LogUsrErrs;
                  }
                  {
#line 2605
                  if ((int )state___3 == 52) {
#line 2605
                    goto case_52___3;
                  }
#line 2605
                  if ((int )state___3 == 121) {
#line 2605
                    goto case_121___2;
                  }
#line 2605
                  if ((int )state___3 == 114) {
#line 2605
                    goto case_114___3;
                  }
#line 2605
                  if ((int )state___3 == 100) {
#line 2605
                    goto case_100___0;
                  }
#line 2605
                  if ((int )state___3 == 116) {
#line 2605
                    goto case_116___3;
                  }
#line 2605
                  goto switch_break___6;
                  case_52___3: /* CIL Label */ 
#line 2605
                  if (MilterLogLevel > 3) {
                    {
#line 2605
                    sm_syslog(6, (char const   *)e->e_id, "Milter: %s=%s, reject=421, errormode=4",
                              "to", addr);
#line 2605
                    LogUsrErrs = 0;
                    }
                  }
                  {
#line 2605
                  tsave___1 = QuickAbort;
#line 2605
                  QuickAbort = 0;
#line 2605
                  usrerr("421 4.3.0 closing connection");
#line 2605
                  QuickAbort = tsave___1;
#line 2605
                  e->e_sendqueue = (ADDRESS *)((void *)0);
                  }
#line 2605
                  goto doquit;
#line 2605
                  goto switch_break___6;
                  case_121___2: /* CIL Label */ 
#line 2605
                  if (MilterLogLevel > 3) {
                    {
#line 2605
                    sm_syslog(6, (char const   *)e->e_id, "Milter: %s=%s, reject=%s",
                              "to", addr, response___2);
#line 2605
                    LogUsrErrs = 0;
                    }
                  }
                  {
#line 2605
                  tmp___116 = strncmp((char const   *)response___2, "421 ", (size_t )4);
                  }
#line 2605
                  if (tmp___116 == 0) {
#line 2605
                    goto _L___10;
                  } else {
                    {
#line 2605
                    tmp___117 = strncmp((char const   *)response___2, "421-", (size_t )4);
                    }
#line 2605
                    if (tmp___117 == 0) {
                      _L___10: /* CIL Label */ 
                      {
#line 2605
                      tsave___2 = QuickAbort;
#line 2605
                      QuickAbort = 0;
#line 2605
                      usrerr((char const   *)response___2);
#line 2605
                      QuickAbort = tsave___2;
#line 2605
                      e->e_sendqueue = (ADDRESS *)((void *)0);
                      }
#line 2605
                      goto doquit;
                    } else {
                      {
#line 2605
                      usrerr((char const   *)response___2);
                      }
                    }
                  }
#line 2605
                  goto switch_break___6;
                  case_114___3: /* CIL Label */ 
#line 2605
                  if (MilterLogLevel > 3) {
                    {
#line 2605
                    sm_syslog(6, (char const   *)e->e_id, "Milter: %s=%s, reject=550 5.7.1 Command rejected",
                              "to", addr);
#line 2605
                    LogUsrErrs = 0;
                    }
                  }
                  {
#line 2605
                  usrerr("550 5.7.1 Command rejected");
                  }
#line 2605
                  goto switch_break___6;
                  case_100___0: /* CIL Label */ 
#line 2605
                  if (MilterLogLevel > 3) {
                    {
#line 2605
                    sm_syslog(6, (char const   *)e->e_id, "Milter: %s=%s, discard",
                              "to", addr);
                    }
                  }
#line 2605
                  e->e_flags |= 16777216UL;
#line 2605
                  goto switch_break___6;
                  case_116___3: /* CIL Label */ 
#line 2605
                  if (MilterLogLevel > 3) {
                    {
#line 2605
                    sm_syslog(6, (char const   *)e->e_id, "Milter: %s=%s, reject=%s",
                              "to", addr, "451 4.3.2 Please try again later");
#line 2605
                    LogUsrErrs = 0;
                    }
                  }
                  {
#line 2605
                  usrerr("451 4.3.2 Please try again later");
                  }
#line 2605
                  goto switch_break___6;
                  switch_break___6: /* CIL Label */ ;
                  }
#line 2605
                  LogUsrErrs = savelogusrerrs___0;
#line 2605
                  if ((unsigned long )response___2 != (unsigned long )((void *)0)) {
                    {
#line 2605
                    sm_free_tagged((void *)response___2, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                                   2605);
                    }
                  }
                }
              }
            }
            {
#line 2609
            tmp___118 = macid_parse((char *)"{rcpt_mailer}", (char **)((void *)0));
#line 2609
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___118, (char *)((void *)0),
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2610, SmHeapGroup);
#line 2611
            tmp___119 = macid_parse((char *)"{rcpt_host}", (char **)((void *)0));
#line 2611
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___119, (char *)((void *)0),
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2612, SmHeapGroup);
#line 2613
            tmp___120 = macid_parse((char *)"{rcpt_addr}", (char **)((void *)0));
#line 2613
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___120, (char *)((void *)0),
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2614, SmHeapGroup);
#line 2615
            tmp___121 = macid_parse((char *)"{dsn_notify}", (char **)((void *)0));
#line 2615
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___121, (char *)((void *)0),
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2616, SmHeapGroup);
            }
#line 2617
            if (Errors > 0) {
#line 2618
              goto rcpt_done;
            }
            {
#line 2621
            a = recipient(a, & e->e_sendqueue, 0, (ENVELOPE *)e);
            }
#line 2622
            if (Errors > 0) {
#line 2623
              goto rcpt_done;
            }
#line 2626
            e->e_to = a->q_paddr;
#line 2627
            if (! ((int )a->q_state == 2)) {
#line 2629
              if (smtp___0.sm_nrcpts == 0U) {
                {
#line 2630
                initsys((ENVELOPE *)e);
                }
              }
#line 2631
              if ((int )a->q_state == 3) {
#line 2631
                tmp___122 = " (will queue)";
              } else {
#line 2631
                tmp___122 = "";
              }
              {
#line 2631
              message("250 2.1.5 Recipient ok%s", tmp___122);
#line 2634
              (smtp___0.sm_nrcpts) ++;
              }
            } else {
              {
#line 2639
              usrerr("550 5.1.1 Addressee unknown");
              }
            }
            rcpt_done: 
#line 2642
            if (Errors > 0) {
#line 2644
              n_badrcpts += (unsigned int volatile   )1;
              {
#line 2645
              while (1) {
                while_continue___22: /* CIL Label */ ;
#line 2645
                if (BadRcptThrottle > 0) {
#line 2645
                  if (n_badrcpts > (unsigned int volatile   )BadRcptThrottle) {
#line 2645
                    tmp___123 = n_badrcpts - (unsigned int volatile   )1;
                  } else {
#line 2645
                    tmp___123 = n_badrcpts;
                  }
                } else {
#line 2645
                  tmp___123 = n_badrcpts;
                }
                {
#line 2645
                sm_snprintf(buf___17, (size_t )sizeof(buf___17), "%d", tmp___123);
#line 2645
                tmp___124 = macid_parse((char *)"{nbadrcpts}", (char **)((void *)0));
#line 2645
                macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___124, buf___17,
                                 (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                                 2645, SmHeapGroup);
                }
#line 2645
                goto while_break___22;
              }
              while_break___22: /* CIL Label */ ;
              }
            }
          }
#line 2648
          if (_h___1.eh_state == 1) {
#line 2648
            goto while_break___17;
          }
#line 2648
          if (_h___1.eh_state == 2) {
#line 2648
            if ((unsigned long )SmExcHandler == (unsigned long )(& _h___1)) {
#line 2648
              tmp___126 = 1;
            } else {
              {
#line 2648
              sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                          2648, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2648
              tmp___126 = 0;
              }
            }
#line 2648
            SmExcHandler = _h___1.eh_parent;
          }
          {
#line 2648
          tmp___128 = sm_exc_match(_h___1.eh_value, "[!F]*");
          }
#line 2648
          if (tmp___128) {
#line 2648
            _h___1.eh_state = 1;
          } else {
#line 2648
            _h___1.eh_state = 0;
          }
#line 2648
          if (_h___1.eh_state == 1) {
#line 2648
            exc___0 = _h___1.eh_value;
#line 2651
            e->e_flags &= 0xffffffffffffdfdfUL;
#line 2652
            n_badrcpts += (unsigned int volatile   )1;
            {
#line 2653
            while (1) {
              while_continue___23: /* CIL Label */ ;
#line 2653
              if (BadRcptThrottle > 0) {
#line 2653
                if (n_badrcpts > (unsigned int volatile   )BadRcptThrottle) {
#line 2653
                  tmp___129 = n_badrcpts - (unsigned int volatile   )1;
                } else {
#line 2653
                  tmp___129 = n_badrcpts;
                }
              } else {
#line 2653
                tmp___129 = n_badrcpts;
              }
              {
#line 2653
              sm_snprintf(buf___18, (size_t )sizeof(buf___18), "%d", tmp___129);
#line 2653
              tmp___130 = macid_parse((char *)"{nbadrcpts}", (char **)((void *)0));
#line 2653
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___130, buf___18,
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                               2653, SmHeapGroup);
              }
#line 2653
              goto while_break___23;
            }
            while_break___23: /* CIL Label */ ;
            }
          }
#line 2451
          goto while_break___17;
        }
        while_break___17: /* CIL Label */ ;
        }
#line 2655
        if (_h___1.eh_state == 2) {
#line 2655
          if ((unsigned long )SmExcHandler == (unsigned long )(& _h___1)) {
#line 2655
            tmp___131 = 1;
          } else {
            {
#line 2655
            sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                        2655, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2655
            tmp___131 = 0;
            }
          }
#line 2655
          SmExcHandler = _h___1.eh_parent;
#line 2655
          if ((unsigned long )_h___1.eh_value != (unsigned long )((void *)0)) {
            {
#line 2655
            sm_exc_raise_x(_h___1.eh_value);
            }
          }
        } else
#line 2655
        if (_h___1.eh_state == 0) {
#line 2655
          if ((unsigned long )_h___1.eh_value != (unsigned long )((void *)0)) {
            {
#line 2655
            sm_exc_raise_x(_h___1.eh_value);
            }
          }
        } else {
          {
#line 2655
          sm_exc_free(_h___1.eh_value);
          }
        }
#line 2656
        goto switch_break___3;
        case_3: /* CIL Label */ 
#line 2659
        if (DelayLA > 0) {
          {
#line 2659
          CurrentLA = getla();
          }
#line 2659
          if (CurrentLA >= DelayLA) {
            {
#line 2659
            tmp___132 = qid_printname((ENVELOPE *)e);
#line 2659
            sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                            tmp___132, CurSmtpClient, "DATA", DelayLA);
            }
#line 2659
            if (LogLevel > 8) {
              {
#line 2659
              dnow___3 = curtime();
              }
#line 2659
              if (dnow___3 > (time_t )log_delay___0) {
                {
#line 2659
                sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                          "DATA", CurrentLA, DelayLA);
#line 2659
                log_delay___0 = (time_t volatile   )(dnow___3 + 15L);
                }
              }
            }
            {
#line 2659
            sleep(1U);
#line 2659
            tmp___133 = qid_printname((ENVELOPE *)e);
#line 2659
            sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___133, CurSmtpClient,
                            inp);
            }
          }
        }
        {
#line 2660
        tmp___134 = smtp_data(& smtp___0, (ENVELOPE *)e);
        }
#line 2660
        if (! tmp___134) {
#line 2661
          goto doquit;
        }
#line 2662
        goto switch_break___3;
        case_4___0: /* CIL Label */ 
#line 2665
        if ((int )tTdvect[94] >= 100) {
          {
#line 2666
          message("451 4.0.0 Test failure");
          }
        } else {
          {
#line 2668
          message("250 2.0.0 Reset state");
          }
        }
        {
#line 2669
        while (1) {
          while_continue___24: /* CIL Label */ ;
          {
#line 2669
          milter_abort((ENVELOPE *)e);
          }
#line 2669
          if (smtp___0.sm_nrcpts > 0U) {
            {
#line 2669
            logundelrcpts((ENVELOPE *)e, cmdbuf, 10, 0);
#line 2669
            smtp___0.sm_nrcpts = 0U;
#line 2669
            tmp___135 = macid_parse((char *)"{nrcpts}", (char **)((void *)0));
#line 2669
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___135, (char *)"0",
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2669, SmHeapGroup);
            }
          }
#line 2669
          e->e_sendqueue = (ADDRESS *)((void *)0);
#line 2669
          e->e_flags |= 8UL;
#line 2669
          if (LogLevel > 4) {
#line 2669
            if ((e->e_flags & 32768UL) != 0UL) {
              {
#line 2669
              logsender((ENVELOPE *)e, (char *)((void *)0));
              }
            }
          }
          {
#line 2669
          e->e_flags &= 0xffffffffffff7fffUL;
#line 2669
          smtp___0.sm_gotmail = 0;
#line 2669
          SuprErrs = 1;
#line 2669
          dropenvelope((ENVELOPE *)e, 1, 0);
#line 2669
          sm_rpool_free(e->e_rpool);
#line 2669
          tmp___136 = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 2669
          tmp___137 = newenvelope((ENVELOPE *)e, CurEnv, tmp___136);
#line 2669
          e = (ENVELOPE */* volatile  */)tmp___137;
#line 2669
          CurEnv = (ENVELOPE *)e;
          }
#line 2669
          if (smtp___0.sm_discard) {
#line 2669
            e->e_flags |= 16777216UL;
          }
#line 2669
          if ((unsigned long )smtp___0.sm_quarmsg == (unsigned long )((void *)0)) {
            {
#line 2669
            e->e_quarmsg = (char *)((void *)0);
#line 2669
            tmp___138 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 2669
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___138, (char *)"",
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2669, SmHeapGroup);
            }
          } else {
            {
#line 2669
            e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, (char const   *)smtp___0.sm_quarmsg);
#line 2669
            tmp___139 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 2669
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___139, e->e_quarmsg,
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                             2669, SmHeapGroup);
            }
          }
#line 2669
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
#line 2670
        goto switch_break___3;
        case_6___0: /* CIL Label */ 
        case_5___0: /* CIL Label */ 
#line 2674
        vrfy = c->cmd_code == 5;
#line 2675
        if (DelayLA > 0) {
          {
#line 2675
          CurrentLA = getla();
          }
#line 2675
          if (CurrentLA >= DelayLA) {
#line 2675
            if (vrfy) {
#line 2675
              tmp___140 = "VRFY";
            } else {
#line 2675
              tmp___140 = "EXPN";
            }
            {
#line 2675
            tmp___141 = qid_printname((ENVELOPE *)e);
#line 2675
            sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                            tmp___141, CurSmtpClient, tmp___140, DelayLA);
            }
#line 2675
            if (LogLevel > 8) {
              {
#line 2675
              dnow___4 = curtime();
              }
#line 2675
              if (dnow___4 > (time_t )log_delay___0) {
#line 2675
                if (vrfy) {
#line 2675
                  tmp___142 = "VRFY";
                } else {
#line 2675
                  tmp___142 = "EXPN";
                }
                {
#line 2675
                sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                          tmp___142, CurrentLA, DelayLA);
#line 2675
                log_delay___0 = (time_t volatile   )(dnow___4 + 15L);
                }
              }
            }
            {
#line 2675
            sleep(1U);
#line 2675
            tmp___143 = qid_printname((ENVELOPE *)e);
#line 2675
            sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___143, CurSmtpClient,
                            inp);
            }
          }
        }
#line 2676
        if (tempfail) {
#line 2678
          if (LogLevel > 9) {
#line 2679
            if (vrfy) {
#line 2679
              tmp___144 = "VRFY";
            } else {
#line 2679
              tmp___144 = "EXPN";
            }
            {
#line 2679
            sm_syslog(6, (char const   *)e->e_id, "SMTP %s command (%.100s) from %s tempfailed (due to previous checks)",
                      tmp___144, p, CurSmtpClient);
            }
          }
          {
#line 2685
          usrerr("550 5.7.1 Please try again later");
          }
#line 2686
          goto switch_break___3;
        }
#line 2688
        if (vrfy) {
#line 2688
          tmp___145 = "VRFY";
        } else {
#line 2688
          tmp___145 = "EXPN";
        }
        {
#line 2688
        tmp___146 = checksmtpattack(& n_verifies, 6U, 0, (char *)tmp___145, (ENVELOPE *)e);
#line 2688
        wt = (time_t volatile   )tmp___146;
        }
        {
#line 2690
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 2690
          if (wt == (time_t volatile   )-1L) {
#line 2690
            goto stopattack;
          }
#line 2690
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
        {
#line 2691
        tmp___147 = curtime();
#line 2691
        previous = (time_t volatile   )tmp___147;
        }
#line 2692
        if (vrfy) {
#line 2692
          if ((PrivacyFlags & 16UL) != 0UL) {
#line 2692
            goto _L___11;
          } else {
#line 2692
            goto _L___13;
          }
        } else
        _L___13: /* CIL Label */ 
#line 2692
        if (! vrfy) {
#line 2692
          if (! ((features & (unsigned int volatile   )32) != (unsigned int volatile   )0)) {
            _L___11: /* CIL Label */ 
#line 2695
            if (vrfy) {
              {
#line 2696
              message("252 2.5.2 Cannot VRFY user; try RCPT to attempt delivery (or try finger)");
              }
            } else {
              {
#line 2698
              message("502 5.7.0 Sorry, we do not allow this operation");
              }
            }
#line 2699
            if (LogLevel > 5) {
              {
#line 2700
              tmp___148 = shortenstring((char const   *)(inp), (size_t )203);
#line 2700
              sm_syslog(6, (char const   *)e->e_id, "%s: %s [rejected]", CurSmtpClient,
                        tmp___148);
              }
            }
#line 2704
            goto switch_break___3;
          } else {
#line 2692
            goto _L___12;
          }
        } else
        _L___12: /* CIL Label */ 
#line 2706
        if (! gothello) {
#line 2706
          if (vrfy) {
#line 2706
            tmp___149 = 4;
          } else {
#line 2706
            tmp___149 = 2;
          }
#line 2706
          if ((PrivacyFlags & (unsigned long )tmp___149) != 0UL) {
            {
#line 2710
            usrerr("503 5.0.0 I demand that you introduce yourself first");
            }
#line 2711
            goto switch_break___3;
          }
        }
#line 2713
        if (Errors > 0) {
#line 2714
          goto switch_break___3;
        }
#line 2715
        if (LogLevel > 5) {
          {
#line 2716
          tmp___150 = shortenstring((char const   *)(inp), (size_t )203);
#line 2716
          sm_syslog(6, (char const   *)e->e_id, "%s: %s", CurSmtpClient, tmp___150);
          }
        }
        {
#line 2719
        while (1) {
          while_continue___26: /* CIL Label */ ;
          {
#line 2719
          _h___2.eh_value = (SM_EXC_T *)((void *)0);
#line 2719
          _h___2.eh_parent = SmExcHandler;
#line 2719
          _h___2.eh_state = 2;
#line 2719
          SmExcHandler = & _h___2;
#line 2719
          tmp___156 = __sigsetjmp((struct __jmp_buf_tag *)(_h___2.eh_context), 0);
          }
#line 2719
          if (tmp___156 == 0) {
#line 2721
            QuickAbort = 1;
#line 2722
            vrfyqueue = (ADDRESS *)((void *)0);
#line 2723
            if (vrfy) {
#line 2724
              e->e_flags |= 512UL;
            }
            {
#line 2725
            while (1) {
              while_continue___27: /* CIL Label */ ;
#line 2725
              if ((int )*p != 0) {
#line 2725
                if (((int )*p & -128) == 0) {
                  {
#line 2725
                  tmp___151 = __ctype_b_loc();
                  }
#line 2725
                  if (! ((int const   )*(*tmp___151 + (int )*p) & 8192)) {
#line 2725
                    goto while_break___27;
                  }
                } else {
#line 2725
                  goto while_break___27;
                }
              } else {
#line 2725
                goto while_break___27;
              }
#line 2726
              p ++;
            }
            while_break___27: /* CIL Label */ ;
            }
#line 2727
            if ((int )*p == 0) {
              {
#line 2729
              usrerr("501 5.5.2 Argument required");
              }
            } else {
#line 2734
              if (vrfy) {
#line 2734
                tmp___152 = "check_vrfy";
              } else {
#line 2734
                tmp___152 = "check_expn";
              }
              {
#line 2734
              tmp___153 = rscheck((char *)tmp___152, (char *)p, (char *)((void *)0),
                                  (ENVELOPE *)e, 1, 3, (char *)((void *)0), (char *)"*~*");
              }
#line 2734
              if (tmp___153 != 0) {
                {
#line 2738
                sm_exc_raisenew_x(& EtypeQuickAbort, 1);
                }
              } else
#line 2734
              if (Errors > 0) {
                {
#line 2738
                sm_exc_raisenew_x(& EtypeQuickAbort, 1);
                }
              }
              {
#line 2739
              sendtolist((char *)p, (ADDRESS *)((void *)0), & vrfyqueue, 0, (ENVELOPE *)e);
              }
            }
#line 2741
            if (wt > (time_t volatile   )0) {
              {
#line 2745
              tmp___154 = curtime();
#line 2745
              t = (time_t )(wt - (time_t volatile   )(tmp___154 - (time_t )previous));
              }
#line 2746
              if (t > 0L) {
                {
#line 2747
                sleep((unsigned int )t);
                }
              }
            }
#line 2749
            if (Errors > 0) {
              {
#line 2750
              sm_exc_raisenew_x(& EtypeQuickAbort, 1);
              }
            }
#line 2751
            if ((unsigned long )vrfyqueue == (unsigned long )((void *)0)) {
#line 2753
              if (vrfy) {
#line 2753
                tmp___155 = "VRFY";
              } else {
#line 2753
                tmp___155 = "EXPN";
              }
              {
#line 2753
              usrerr("554 5.5.2 Nothing to %s", tmp___155);
              }
            }
            {
#line 2755
            while (1) {
              while_continue___28: /* CIL Label */ ;
#line 2755
              if (! ((unsigned long )vrfyqueue != (unsigned long )((void *)0))) {
#line 2755
                goto while_break___28;
              }
#line 2757
              if (! ((int )vrfyqueue->q_state == 0)) {
#line 2757
                if (! ((int )vrfyqueue->q_state == 3)) {
#line 2757
                  if (! ((int )vrfyqueue->q_state == 4)) {
#line 2757
                    if (! ((int )vrfyqueue->q_state == 5)) {
#line 2759
                      vrfyqueue = vrfyqueue->q_next;
#line 2760
                      goto while_continue___28;
                    }
                  }
                }
              }
#line 2764
              a = vrfyqueue;
              {
#line 2765
              while (1) {
                while_continue___29: /* CIL Label */ ;
#line 2765
                a = a->q_next;
#line 2765
                if ((unsigned long )a != (unsigned long )((void *)0)) {
#line 2765
                  if ((int )a->q_state == 0) {
#line 2765
                    goto while_break___29;
                  } else
#line 2765
                  if ((int )a->q_state == 3) {
#line 2765
                    goto while_break___29;
                  } else
#line 2765
                  if ((int )a->q_state == 4) {
#line 2765
                    goto while_break___29;
                  } else
#line 2765
                  if ((int )a->q_state == 5) {
#line 2765
                    goto while_break___29;
                  }
                } else {
#line 2765
                  goto while_break___29;
                }
#line 2767
                goto while_continue___29;
              }
              while_break___29: /* CIL Label */ ;
              }
              {
#line 2768
              printvrfyaddr(vrfyqueue, (unsigned long )a == (unsigned long )((void *)0),
                            vrfy);
#line 2769
              vrfyqueue = a;
              }
            }
            while_break___28: /* CIL Label */ ;
            }
          }
#line 2772
          if (_h___2.eh_state == 1) {
#line 2772
            goto while_break___26;
          }
#line 2772
          if (_h___2.eh_state == 2) {
#line 2772
            if ((unsigned long )SmExcHandler == (unsigned long )(& _h___2)) {
#line 2772
              tmp___157 = 1;
            } else {
              {
#line 2772
              sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                          2772, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2772
              tmp___157 = 0;
              }
            }
#line 2772
            SmExcHandler = _h___2.eh_parent;
          }
          {
#line 2772
          tmp___159 = sm_exc_match(_h___2.eh_value, "[!F]*");
          }
#line 2772
          if (tmp___159) {
#line 2772
            _h___2.eh_state = 1;
          } else {
#line 2772
            _h___2.eh_state = 0;
          }
#line 2772
          if (_h___2.eh_state == 1) {
            {
#line 2772
            exc___1 = _h___2.eh_value;
#line 2778
            sm_exc_free(exc___1);
            }
#line 2779
            goto undo;
          }
#line 2719
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 2781
        if (_h___2.eh_state == 2) {
#line 2781
          if ((unsigned long )SmExcHandler == (unsigned long )(& _h___2)) {
#line 2781
            tmp___160 = 1;
          } else {
            {
#line 2781
            sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                        2781, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2781
            tmp___160 = 0;
            }
          }
#line 2781
          SmExcHandler = _h___2.eh_parent;
#line 2781
          if ((unsigned long )_h___2.eh_value != (unsigned long )((void *)0)) {
            {
#line 2781
            sm_exc_raise_x(_h___2.eh_value);
            }
          }
        } else
#line 2781
        if (_h___2.eh_state == 0) {
#line 2781
          if ((unsigned long )_h___2.eh_value != (unsigned long )((void *)0)) {
            {
#line 2781
            sm_exc_raise_x(_h___2.eh_value);
            }
          }
        } else {
          {
#line 2781
          sm_exc_free(_h___2.eh_value);
          }
        }
#line 2782
        goto switch_break___3;
        case_12___1: /* CIL Label */ 
#line 2785
        if (DelayLA > 0) {
          {
#line 2785
          CurrentLA = getla();
          }
#line 2785
          if (CurrentLA >= DelayLA) {
            {
#line 2785
            tmp___161 = qid_printname((ENVELOPE *)e);
#line 2785
            sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                            tmp___161, CurSmtpClient, "ETRN", DelayLA);
            }
#line 2785
            if (LogLevel > 8) {
              {
#line 2785
              dnow___5 = curtime();
              }
#line 2785
              if (dnow___5 > (time_t )log_delay___0) {
                {
#line 2785
                sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                          "ETRN", CurrentLA, DelayLA);
#line 2785
                log_delay___0 = (time_t volatile   )(dnow___5 + 15L);
                }
              }
            }
            {
#line 2785
            sleep(1U);
#line 2785
            tmp___162 = qid_printname((ENVELOPE *)e);
#line 2785
            sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___162, CurSmtpClient,
                            inp);
            }
          }
        }
#line 2788
        if (! ((features & (unsigned int volatile   )8) != (unsigned int volatile   )0)) {
#line 2788
          goto _L___14;
        } else
#line 2788
        if (UseMSP) {
#line 2788
          goto _L___14;
        } else
#line 2788
        if (RealUid != 0U) {
#line 2788
          if (RealUid != TrustedUid) {
#line 2788
            if ((int )OpMode == 115) {
              _L___14: /* CIL Label */ 
              {
#line 2793
              message("502 5.7.0 Sorry, we do not allow this operation");
              }
#line 2794
              if (LogLevel > 5) {
                {
#line 2795
                tmp___163 = shortenstring((char const   *)(inp), (size_t )203);
#line 2795
                sm_syslog(6, (char const   *)e->e_id, "%s: %s [rejected]", CurSmtpClient,
                          tmp___163);
                }
              }
#line 2799
              goto switch_break___3;
            }
          }
        }
#line 2801
        if (tempfail) {
#line 2803
          if (LogLevel > 9) {
            {
#line 2804
            sm_syslog(6, (char const   *)e->e_id, "SMTP ETRN command (%.100s) from %s tempfailed (due to previous checks)",
                      p, CurSmtpClient);
            }
          }
          {
#line 2807
          usrerr("451 4.3.2 Please try again later");
          }
#line 2808
          goto switch_break___3;
        }
        {
#line 2811
        tmp___164 = strlen((char const   *)p);
        }
#line 2811
        if (tmp___164 <= 0U) {
          {
#line 2813
          usrerr("500 5.5.2 Parameter required");
          }
#line 2814
          goto switch_break___3;
        }
        {
#line 2818
        while (1) {
          while_continue___30: /* CIL Label */ ;
          {
#line 2818
          tmp___165 = checksmtpattack(& n_etrn, 8U, 1, (char *)"ETRN", (ENVELOPE *)e);
          }
#line 2818
          if (tmp___165 == -1L) {
#line 2818
            goto stopattack;
          }
#line 2818
          goto while_break___30;
        }
        while_break___30: /* CIL Label */ ;
        }
        {
#line 2831
        tmp___166 = rscheck((char *)"check_etrn", (char *)p, (char *)((void *)0),
                            (ENVELOPE *)e, 1, 3, (char *)((void *)0), (char *)"*~*");
        }
#line 2831
        if (tmp___166 != 0) {
#line 2834
          goto switch_break___3;
        } else
#line 2831
        if (Errors > 0) {
#line 2834
          goto switch_break___3;
        }
#line 2836
        if (LogLevel > 5) {
          {
#line 2837
          tmp___167 = shortenstring((char const   *)p, (size_t )203);
#line 2837
          sm_syslog(6, (char const   *)e->e_id, "%s: ETRN %s", CurSmtpClient, tmp___167);
          }
        }
#line 2841
        id = (char *)p;
#line 2842
        if ((int )*id == 35) {
          {
#line 2846
          id ++;
#line 2847
          qgrp = name2qid(id);
          }
#line 2848
          if (! (qgrp >= 0)) {
            {
#line 2850
            usrerr("459 4.5.4 Queue %s unknown", id);
            }
#line 2852
            goto switch_break___3;
          }
#line 2854
          i = 0;
          {
#line 2854
          while (1) {
            while_continue___31: /* CIL Label */ ;
#line 2854
            if (i < NumQueue) {
#line 2854
              if (! ((unsigned long )Queue[i] != (unsigned long )((void *)0))) {
#line 2854
                goto while_break___31;
              }
            } else {
#line 2854
              goto while_break___31;
            }
#line 2856
            (Queue[i])->qg_nextrun = (time_t )-1;
#line 2854
            i ++;
          }
          while_break___31: /* CIL Label */ ;
          }
          {
#line 2857
          (Queue[qgrp])->qg_nextrun = (time_t )0;
#line 2858
          ok = run_work_group((Queue[qgrp])->qg_wgrp, 9);
          }
#line 2860
          if (ok) {
#line 2860
            if (Errors == 0) {
              {
#line 2861
              message("250 2.0.0 Queuing for queue group %s started", id);
              }
            }
          }
#line 2862
          goto switch_break___3;
        }
#line 2865
        if ((int )*id == 64) {
#line 2866
          id ++;
        } else {
#line 2868
          id --;
#line 2868
          *id = (char )'@';
        }
        {
#line 2870
        tmp___168 = sm_malloc_tagged((size_t )sizeof(QUEUE_CHAR ), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                                     2870, SmHeapGroup);
#line 2870
        new = (QUEUE_CHAR *)tmp___168;
        }
#line 2871
        if ((unsigned long )new == (unsigned long )((void *)0)) {
          {
#line 2873
          syserr("500 5.5.0 ETRN out of memory");
          }
#line 2874
          goto switch_break___3;
        }
        {
#line 2876
        new->queue_match = id;
#line 2877
        new->queue_negate = 0;
#line 2878
        new->queue_next = (struct queue_char *)((void *)0);
#line 2879
        QueueLimitRecipient = new;
#line 2880
        ok = runqueue(1, 0, 0, 1);
#line 2881
        sm_free_tagged((void *)QueueLimitRecipient, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                       2881);
#line 2882
        QueueLimitRecipient = (QUEUE_CHAR *)((void *)0);
        }
#line 2883
        if (ok) {
#line 2883
          if (Errors == 0) {
            {
#line 2884
            message("250 2.0.0 Queuing for node %s started", p);
            }
          }
        }
#line 2885
        goto switch_break___3;
        case_10: /* CIL Label */ 
#line 2888
        if (DelayLA > 0) {
          {
#line 2888
          CurrentLA = getla();
          }
#line 2888
          if (CurrentLA >= DelayLA) {
            {
#line 2888
            tmp___169 = qid_printname((ENVELOPE *)e);
#line 2888
            sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                            tmp___169, CurSmtpClient, "HELP", DelayLA);
            }
#line 2888
            if (LogLevel > 8) {
              {
#line 2888
              dnow___6 = curtime();
              }
#line 2888
              if (dnow___6 > (time_t )log_delay___0) {
                {
#line 2888
                sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                          "HELP", CurrentLA, DelayLA);
#line 2888
                log_delay___0 = (time_t volatile   )(dnow___6 + 15L);
                }
              }
            }
            {
#line 2888
            sleep(1U);
#line 2888
            tmp___170 = qid_printname((ENVELOPE *)e);
#line 2888
            sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___170, CurSmtpClient,
                            inp);
            }
          }
        }
        {
#line 2889
        help((char *)p, (ENVELOPE *)e);
        }
#line 2890
        goto switch_break___3;
        case_7___0: /* CIL Label */ 
#line 2893
        if (DelayLA > 0) {
          {
#line 2893
          CurrentLA = getla();
          }
#line 2893
          if (CurrentLA >= DelayLA) {
            {
#line 2893
            tmp___171 = qid_printname((ENVELOPE *)e);
#line 2893
            sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                            tmp___171, CurSmtpClient, "NOOP", DelayLA);
            }
#line 2893
            if (LogLevel > 8) {
              {
#line 2893
              dnow___7 = curtime();
              }
#line 2893
              if (dnow___7 > (time_t )log_delay___0) {
                {
#line 2893
                sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                          "NOOP", CurrentLA, DelayLA);
#line 2893
                log_delay___0 = (time_t volatile   )(dnow___7 + 15L);
                }
              }
            }
            {
#line 2893
            sleep(1U);
#line 2893
            tmp___172 = qid_printname((ENVELOPE *)e);
#line 2893
            sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___172, CurSmtpClient,
                            inp);
            }
          }
        }
        {
#line 2894
        while (1) {
          while_continue___32: /* CIL Label */ ;
          {
#line 2894
          tmp___173 = checksmtpattack(& n_noop, (unsigned int )MaxNOOPCommands, 1,
                                      (char *)"NOOP", (ENVELOPE *)e);
          }
#line 2894
          if (tmp___173 == -1L) {
#line 2894
            goto stopattack;
          }
#line 2894
          goto while_break___32;
        }
        while_break___32: /* CIL Label */ ;
        }
        {
#line 2896
        message("250 2.0.0 OK");
        }
#line 2897
        goto switch_break___3;
        case_8___0: /* CIL Label */ 
        {
#line 2900
        message("221 2.0.0 %s closing connection", MyHostName);
#line 2902
        sm_io_flush(OutChannel, -2);
        }
#line 2905
        if (smtp___0.sm_nrcpts > 0U) {
          {
#line 2906
          logundelrcpts((ENVELOPE *)e, (char *)"aborted by sender", 9, 0);
          }
        }
#line 2909
        e->e_sendqueue = (ADDRESS *)((void *)0);
        doquit: 
        {
#line 2930
        disconnect(1, (ENVELOPE *)e);
#line 2934
        milter_quit((ENVELOPE *)e);
        }
#line 2937
        if (LogLevel > 4) {
#line 2937
          if ((e->e_flags & 32768UL) != 0UL) {
            {
#line 2938
            logsender((ENVELOPE *)e, (char *)((void *)0));
            }
          }
        }
#line 2939
        e->e_flags &= 0xffffffffffff7fffUL;
#line 2941
        if (lognullconnection) {
#line 2941
          if (LogLevel > 5) {
#line 2941
            if ((unsigned long )nullserver == (unsigned long )((void *)0)) {
              {
#line 2946
              tmp___174 = macid_parse((char *)"{daemon_name}", (char **)((void *)0));
#line 2946
              d___0 = macvalue(tmp___174, (ENVELOPE *)e);
              }
#line 2947
              if ((unsigned long )d___0 == (unsigned long )((void *)0)) {
#line 2948
                d___0 = (char *)"stdin";
              }
              {
#line 2956
              sm_syslog(6, (char const   *)e->e_id, "%s did not issue MAIL/EXPN/VRFY/ETRN during connection to %s",
                        CurSmtpClient, d___0);
              }
            }
          }
        }
#line 2960
        if ((int )tTdvect[93] >= 100) {
#line 2963
          return;
        }
        {
#line 2965
        finis(1, 1, (int volatile   )ExitStat);
#line 2969
        exit(71);
        }
        case_17: /* CIL Label */ 
#line 2972
        if (DelayLA > 0) {
          {
#line 2972
          CurrentLA = getla();
          }
#line 2972
          if (CurrentLA >= DelayLA) {
            {
#line 2972
            tmp___175 = qid_printname((ENVELOPE *)e);
#line 2972
            sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                            tmp___175, CurSmtpClient, "VERB", DelayLA);
            }
#line 2972
            if (LogLevel > 8) {
              {
#line 2972
              dnow___8 = curtime();
              }
#line 2972
              if (dnow___8 > (time_t )log_delay___0) {
                {
#line 2972
                sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                          "VERB", CurrentLA, DelayLA);
#line 2972
                log_delay___0 = (time_t volatile   )(dnow___8 + 15L);
                }
              }
            }
            {
#line 2972
            sleep(1U);
#line 2972
            tmp___176 = qid_printname((ENVELOPE *)e);
#line 2972
            sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___176, CurSmtpClient,
                            inp);
            }
          }
        }
#line 2973
        if (! ((features & (unsigned int volatile   )32) != (unsigned int volatile   )0)) {
          {
#line 2977
          message("502 5.7.0 Verbose unavailable");
          }
#line 2978
          goto switch_break___3;
        } else
#line 2973
        if (! ((features & (unsigned int volatile   )64) != (unsigned int volatile   )0)) {
          {
#line 2977
          message("502 5.7.0 Verbose unavailable");
          }
#line 2978
          goto switch_break___3;
        }
        {
#line 2980
        while (1) {
          while_continue___33: /* CIL Label */ ;
          {
#line 2980
          tmp___177 = checksmtpattack(& n_noop, (unsigned int )MaxNOOPCommands, 1,
                                      (char *)"VERB", (ENVELOPE *)e);
          }
#line 2980
          if (tmp___177 == -1L) {
#line 2980
            goto stopattack;
          }
#line 2980
          goto while_break___33;
        }
        while_break___33: /* CIL Label */ ;
        }
        {
#line 2982
        Verbose = 1;
#line 2983
        set_delivery_mode('i', (ENVELOPE *)e);
#line 2984
        message("250 2.0.0 Verbose mode");
        }
#line 2985
        goto switch_break___3;
        case_23: /* CIL Label */ 
        case_25: /* CIL Label */ 
        case_24: /* CIL Label */ 
#line 3005
        if (DelayLA > 0) {
          {
#line 3005
          CurrentLA = getla();
          }
#line 3005
          if (CurrentLA >= DelayLA) {
            {
#line 3005
            tmp___178 = qid_printname((ENVELOPE *)e);
#line 3005
            sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                            tmp___178, CurSmtpClient, "Bogus", DelayLA);
            }
#line 3005
            if (LogLevel > 8) {
              {
#line 3005
              dnow___9 = curtime();
              }
#line 3005
              if (dnow___9 > (time_t )log_delay___0) {
                {
#line 3005
                sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                          "Bogus", CurrentLA, DelayLA);
#line 3005
                log_delay___0 = (time_t volatile   )(dnow___9 + 15L);
                }
              }
            }
            {
#line 3005
            sleep(1U);
#line 3005
            tmp___179 = qid_printname((ENVELOPE *)e);
#line 3005
            sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___179, CurSmtpClient,
                            inp);
            }
          }
        }
#line 3006
        if (LogLevel > 0) {
          {
#line 3007
          tmp___180 = anynet_ntoa(& RealHostAddr);
#line 3007
          sm_syslog(2, (char const   *)e->e_id, "\"%s\" command from %s (%.100s)",
                    c->cmd_name, CurSmtpClient, tmp___180);
          }
        }
        case_0___0: /* CIL Label */ 
#line 3015
        n_badcmds += (unsigned int volatile   )1;
#line 3015
        if (n_badcmds > (unsigned int volatile   )25) {
          stopattack: 
          {
#line 3018
          message("421 4.7.0 %s Too many bad commands; closing connection", MyHostName);
#line 3022
          e->e_sendqueue = (ADDRESS *)((void *)0);
          }
#line 3023
          goto doquit;
        }
        {
#line 3050
        tmp___181 = shortenstring((char const   *)(inp), (size_t )203);
#line 3050
        usrerr("500 5.5.1 Command unrecognized: \"%s\"", tmp___181);
        }
#line 3052
        goto switch_break___3;
        case_19: /* CIL Label */ 
#line 3055
        if (DelayLA > 0) {
          {
#line 3055
          CurrentLA = getla();
          }
#line 3055
          if (CurrentLA >= DelayLA) {
            {
#line 3055
            tmp___182 = qid_printname((ENVELOPE *)e);
#line 3055
            sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                            tmp___182, CurSmtpClient, "Unimpl", DelayLA);
            }
#line 3055
            if (LogLevel > 8) {
              {
#line 3055
              dnow___10 = curtime();
              }
#line 3055
              if (dnow___10 > (time_t )log_delay___0) {
                {
#line 3055
                sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                          "Unimpl", CurrentLA, DelayLA);
#line 3055
                log_delay___0 = (time_t volatile   )(dnow___10 + 15L);
                }
              }
            }
            {
#line 3055
            sleep(1U);
#line 3055
            tmp___183 = qid_printname((ENVELOPE *)e);
#line 3055
            sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___183, CurSmtpClient,
                            inp);
            }
          }
        }
        {
#line 3056
        tmp___184 = shortenstring((char const   *)(inp), (size_t )203);
#line 3056
        usrerr("502 5.5.1 Command not implemented: \"%s\"", tmp___184);
        }
#line 3058
        goto switch_break___3;
        switch_default___1: /* CIL Label */ 
#line 3061
        if (DelayLA > 0) {
          {
#line 3061
          CurrentLA = getla();
          }
#line 3061
          if (CurrentLA >= DelayLA) {
            {
#line 3061
            tmp___185 = qid_printname((ENVELOPE *)e);
#line 3061
            sm_setproctitle(1, (ENVELOPE *)e, "%s: %s: delaying %s: load average: %d",
                            tmp___185, CurSmtpClient, "default", DelayLA);
            }
#line 3061
            if (LogLevel > 8) {
              {
#line 3061
              dnow___11 = curtime();
              }
#line 3061
              if (dnow___11 > (time_t )log_delay___0) {
                {
#line 3061
                sm_syslog(6, (char const   *)e->e_id, "delaying=%s, load average=%d >= %d",
                          "default", CurrentLA, DelayLA);
#line 3061
                log_delay___0 = (time_t volatile   )(dnow___11 + 15L);
                }
              }
            }
            {
#line 3061
            sleep(1U);
#line 3061
            tmp___186 = qid_printname((ENVELOPE *)e);
#line 3061
            sm_setproctitle(1, (ENVELOPE *)e, "%s %s: %.80s", tmp___186, CurSmtpClient,
                            inp);
            }
          }
        }
        {
#line 3062
        tmp___187 = __errno_location();
#line 3062
        *tmp___187 = 0;
#line 3063
        syserr("500 5.5.0 smtp: unknown code %d", c->cmd_code);
        }
#line 3064
        goto switch_break___3;
        switch_break___3: /* CIL Label */ ;
        }
      }
#line 3070
      if (_h.eh_state == 1) {
#line 3070
        goto while_break___2;
      }
#line 3070
      if (_h.eh_state == 2) {
#line 3070
        if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 3070
          tmp___189 = 1;
        } else {
          {
#line 3070
          sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                      3070, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 3070
          tmp___189 = 0;
          }
        }
#line 3070
        SmExcHandler = _h.eh_parent;
      }
      {
#line 3070
      tmp___191 = sm_exc_match(_h.eh_value, "[!F]*");
      }
#line 3070
      if (tmp___191) {
#line 3070
        _h.eh_state = 1;
      } else {
#line 3070
        _h.eh_state = 0;
      }
#line 3070
      if (_h.eh_state == 1) {
#line 3070
        exc___2 = _h.eh_value;
      }
      __Cont___0: /* CIL Label */ 
#line 1048
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3077
    if (_h.eh_state == 2) {
#line 3077
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 3077
        tmp___192 = 1;
      } else {
        {
#line 3077
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                    3077, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 3077
        tmp___192 = 0;
        }
      }
#line 3077
      SmExcHandler = _h.eh_parent;
#line 3077
      if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
        {
#line 3077
        sm_exc_raise_x(_h.eh_value);
        }
      }
    } else
#line 3077
    if (_h.eh_state == 0) {
#line 3077
      if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
        {
#line 3077
        sm_exc_raise_x(_h.eh_value);
        }
      }
    } else {
      {
#line 3077
      sm_exc_free(_h.eh_value);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 3094 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static bool smtp_data(SMTP_T *smtp___0 , ENVELOPE *e ) 
{ 
  bool milteraccept ;
  bool aborting ;
  bool doublequeue ;
  ADDRESS *a ;
  ENVELOPE *ee ;
  char *id ;
  char *oldid ;
  char buf___16[32] ;
  bool rv ;
  int tmp ;
  int tmp___0 ;
  char state ;
  char *response ;
  int tmp___1 ;
  int afd ;
  SM_FILE_T * volatile  df ;
  char *dfname ;
  int save_errno ;
  int *tmp___2 ;
  struct stat st ;
  int dfd ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  bool tmp___10 ;
  struct __res_state *tmp___11 ;
  struct __res_state *tmp___12 ;
  int mode ;
  bool anything_to_send ;
  bool tmp___13 ;
  SM_RPOOL_T *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;

  {
#line 3109
  rv = 1;
#line 3111
  SmtpPhase = (char *)"server DATA";
#line 3112
  if (! smtp___0->sm_gotmail) {
    {
#line 3114
    usrerr("503 5.0.0 Need MAIL command");
    }
#line 3115
    return (1);
  } else
#line 3117
  if (smtp___0->sm_nrcpts <= 0U) {
    {
#line 3119
    usrerr("503 5.0.0 Need RCPT (recipient)");
    }
#line 3120
    return (1);
  }
  {
#line 3122
  sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%u", smtp___0->sm_nrcpts);
#line 3123
  tmp = rscheck((char *)"check_data", buf___16, (char *)((void *)0), e, 7, 3, (char *)((void *)0),
                e->e_id);
  }
#line 3123
  if (tmp != 0) {
#line 3126
    return (1);
  }
#line 3203
  if (smtp___0->sm_discard) {
#line 3204
    e->e_flags |= 16777216UL;
  }
#line 3208
  doublequeue = 0;
#line 3209
  a = e->e_sendqueue;
  {
#line 3209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3209
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 3209
      goto while_break;
    }
#line 3211
    if ((int )a->q_state == 5) {
#line 3211
      if (! ((e->e_flags & 16777216UL) != 0UL)) {
#line 3215
        doublequeue = 1;
      }
    }
#line 3217
    if ((int )a->q_state == 2) {
#line 3220
      a->q_state = (short)6;
    }
#line 3209
    a = a->q_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3225
  SmtpPhase = (char *)"collect";
#line 3226
  buffer_errors();
#line 3228
  collect(InChannel, 1, (HDR **)((void *)0), e, 1);
#line 3231
  sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%ld", e->e_msgsize);
#line 3232
  tmp___0 = macid_parse((char *)"{msg_size}", (char **)((void *)0));
#line 3232
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___0, buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                   3232, SmHeapGroup);
#line 3241
  milteraccept = 1;
  }
#line 3242
  if (smtp___0->sm_milterlist) {
#line 3242
    if (smtp___0->sm_milterize) {
#line 3242
      if (Errors <= 0) {
#line 3242
        if (! ((e->e_flags & 16777216UL) != 0UL)) {
          {
#line 3249
          response = milter_data(e, & state);
          }
          {
#line 3252
          if ((int )state == 121) {
#line 3252
            goto case_121;
          }
#line 3261
          if ((int )state == 114) {
#line 3261
            goto case_114;
          }
#line 3269
          if ((int )state == 100) {
#line 3269
            goto case_100;
          }
#line 3277
          if ((int )state == 116) {
#line 3277
            goto case_116;
          }
#line 3286
          if ((int )state == 52) {
#line 3286
            goto case_52;
          }
#line 3250
          goto switch_break;
          case_121: /* CIL Label */ 
#line 3253
          if (MilterLogLevel > 3) {
            {
#line 3254
            sm_syslog(6, (char const   *)e->e_id, "Milter: data, reject=%s", response);
            }
          }
          {
#line 3257
          milteraccept = 0;
#line 3258
          usrerr((char const   *)response);
          }
#line 3259
          goto switch_break;
          case_114: /* CIL Label */ 
#line 3262
          milteraccept = 0;
#line 3263
          if (MilterLogLevel > 3) {
            {
#line 3264
            sm_syslog(6, (char const   *)e->e_id, "Milter: data, reject=554 5.7.1 Command rejected");
            }
          }
          {
#line 3266
          usrerr("554 5.7.1 Command rejected");
          }
#line 3267
          goto switch_break;
          case_100: /* CIL Label */ 
#line 3270
          if (MilterLogLevel > 3) {
            {
#line 3271
            sm_syslog(6, (char const   *)e->e_id, "Milter: data, discard");
            }
          }
#line 3273
          milteraccept = 0;
#line 3274
          e->e_flags |= 16777216UL;
#line 3275
          goto switch_break;
          case_116: /* CIL Label */ 
#line 3278
          if (MilterLogLevel > 3) {
            {
#line 3279
            sm_syslog(6, (char const   *)e->e_id, "Milter: data, reject=%s", "451 4.3.2 Please try again later");
            }
          }
          {
#line 3282
          milteraccept = 0;
#line 3283
          usrerr("451 4.3.2 Please try again later");
          }
#line 3284
          goto switch_break;
          case_52: /* CIL Label */ 
#line 3287
          if (MilterLogLevel > 3) {
            {
#line 3288
            sm_syslog(6, (char const   *)e->e_id, "Milter: data, reject=421 4.7.0 %s closing connection",
                      MyHostName);
            }
          }
          {
#line 3291
          milteraccept = 0;
#line 3292
          usrerr("421 4.7.0 %s closing connection", MyHostName);
#line 3293
          rv = 0;
          }
#line 3294
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 3296
          if ((unsigned long )response != (unsigned long )((void *)0)) {
            {
#line 3297
            sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                           3297);
            }
          }
        }
      }
    }
  }
  {
#line 3301
  sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%ld", e->e_msgsize);
#line 3302
  tmp___1 = macid_parse((char *)"{msg_size}", (char **)((void *)0));
#line 3302
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___1, buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                   3302, SmHeapGroup);
  }
#line 3305
  if (smtp___0->sm_milterlist) {
#line 3305
    if (smtp___0->sm_milterize) {
      {
#line 3307
      milter_abort(e);
      }
#line 3308
      if (milteraccept) {
#line 3308
        if (MilterLogLevel > 9) {
          {
#line 3309
          sm_syslog(6, (char const   *)e->e_id, "Milter accept: message");
          }
        }
      }
    }
  }
#line 3320
  if (milteraccept) {
#line 3320
    if (SuperSafe == 3) {
      {
#line 3326
      df = (SM_FILE_T */* volatile  */)e->e_dfp;
#line 3327
      dfname = queuename(e, 'd');
#line 3328
      tmp___8 = sm_io_setinfo((SM_FILE_T *)df, 1001, (void *)0);
      }
#line 3328
      if (tmp___8 < 0) {
        {
#line 3328
        tmp___9 = __errno_location();
        }
#line 3328
        if (*tmp___9 != 22) {
          {
#line 3333
          tmp___2 = __errno_location();
#line 3333
          save_errno = *tmp___2;
          }
#line 3334
          if (save_errno == 17) {
            {
#line 3339
            tmp___3 = stat((char const   */* __restrict  */)dfname, (struct stat */* __restrict  */)(& st));
            }
#line 3339
            if (tmp___3 < 0) {
#line 3340
              st.st_size = (__off_t )-1;
            }
            {
#line 3341
            tmp___4 = __errno_location();
#line 3341
            *tmp___4 = 17;
#line 3342
            syserr("@collect: bfcommit(%s): already on disk, size=%ld", dfname, st.st_size);
#line 3344
            dfd = sm_io_getinfo((SM_FILE_T *)df, 3, (void *)0);
            }
#line 3345
            if (dfd >= 0) {
              {
#line 3346
              dumpfd(dfd, 1, 1);
              }
            }
          }
          {
#line 3348
          tmp___5 = __errno_location();
#line 3348
          *tmp___5 = save_errno;
#line 3349
          dferror(df, (char *)"bfcommit", e);
#line 3350
          flush_errors(1);
#line 3351
          finis(save_errno != 17, 1, (int volatile   )ExitStat);
          }
        } else {
#line 3328
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 3353
        afd = sm_io_getinfo((SM_FILE_T *)df, 3, (void *)0);
        }
#line 3353
        if (afd < 0) {
          {
#line 3355
          dferror(df, (char *)"sm_io_getinfo", e);
#line 3356
          flush_errors(1);
#line 3357
          finis(1, 1, (int volatile   )ExitStat);
          }
        } else {
          {
#line 3360
          tmp___7 = fsync(afd);
          }
#line 3360
          if (tmp___7 < 0) {
            {
#line 3362
            dferror(df, (char *)"fsync", e);
#line 3363
            flush_errors(1);
#line 3364
            finis(1, 1, (int volatile   )ExitStat);
            }
          } else {
            {
#line 3367
            tmp___6 = sm_io_close((SM_FILE_T *)df, -2);
            }
#line 3367
            if (tmp___6 < 0) {
              {
#line 3369
              dferror(df, (char *)"sm_io_close", e);
#line 3370
              flush_errors(1);
#line 3371
              finis(1, 1, (int volatile   )ExitStat);
              }
            }
          }
        }
      }
      {
#line 3376
      e->e_dfp = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)dfname,
                            2, (void const   *)((void *)0));
      }
#line 3378
      if ((unsigned long )e->e_dfp == (unsigned long )((void *)0)) {
        {
#line 3381
        syserr("@Cannot reopen %s", dfname);
#line 3382
        finis(1, 1, (int volatile   )ExitStat);
        }
      }
    }
  }
#line 3389
  if ((unsigned long )e->e_quarmsg != (unsigned long )((void *)0)) {
    {
#line 3390
    markstats(e, (ADDRESS *)((void *)0), 'q');
    }
  }
#line 3399
  if ((e->e_flags & 16777216UL) != 0UL) {
#line 3400
    doublequeue = 0;
  }
#line 3402
  aborting = Errors > 0;
#line 3403
  if (! aborting) {
#line 3403
    if (! ((e->e_flags & 16777216UL) != 0UL)) {
#line 3403
      if (QueueMode == 81) {
#line 3403
        goto _L___0;
      } else
#line 3403
      if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
        {
#line 3403
        tmp___10 = split_by_recipient(e);
        }
#line 3403
        if (! tmp___10) {
#line 3406
          aborting = (e->e_flags & 32UL) != 0UL;
        }
      }
    }
  }
#line 3408
  if (aborting) {
    {
#line 3411
    logundelrcpts(e, e->e_message, 8, 0);
#line 3412
    flush_errors(1);
#line 3413
    buffer_errors();
    }
#line 3414
    goto abortmessage;
  }
  {
#line 3418
  buffer_errors();
#line 3449
  SmtpPhase = (char *)"delivery";
#line 3450
  sm_io_setinfo(e->e_xfp, 1002, (void *)0);
#line 3451
  id = e->e_id;
#line 3454
  tmp___11 = __res_state();
#line 3454
  tmp___11->retry = TimeOuts.res_retry[0];
#line 3455
  tmp___12 = __res_state();
#line 3455
  tmp___12->retrans = (int )TimeOuts.res_retrans[0];
#line 3458
  ee = e;
  }
  {
#line 3458
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3458
    if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 3458
      goto while_break___0;
    }
#line 3461
    ee->e_flags &= 0xfffffffffffffff7UL;
#line 3464
    ee->e_errormode = (short )'m';
#line 3466
    if (doublequeue) {
      {
#line 3469
      queueup(ee, 0, 1);
      }
    } else {
      {
#line 3476
      mode = '\000';
#line 3492
      sendall(ee, mode);
      }
    }
#line 3494
    ee->e_to = (char *)((void *)0);
#line 3458
    ee = ee->e_sibling;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3498
  oldid = CurEnv->e_id;
#line 3499
  CurEnv->e_id = id;
#line 3512
  message("250 2.0.0 %s Message accepted for delivery", id);
#line 3513
  CurEnv->e_id = oldid;
  }
#line 3516
  if (doublequeue) {
    {
#line 3518
    anything_to_send = 0;
#line 3520
    sm_getla();
#line 3521
    ee = e;
    }
    {
#line 3521
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3521
      if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 3521
        goto while_break___1;
      }
#line 3523
      if ((int )ee->e_sendmode == 113) {
#line 3524
        goto __Cont;
      } else
#line 3523
      if ((int )ee->e_sendmode == 100) {
#line 3524
        goto __Cont;
      }
      {
#line 3525
      tmp___13 = shouldqueue(ee->e_msgpriority, ee->e_ctime);
      }
#line 3525
      if (tmp___13) {
#line 3527
        ee->e_sendmode = (short )'q';
#line 3528
        goto __Cont;
      } else
#line 3530
      if (QueueMode != 81) {
#line 3530
        if ((unsigned long )ee->e_quarmsg != (unsigned long )((void *)0)) {
#line 3533
          ee->e_sendmode = (short )'q';
#line 3534
          goto __Cont;
        }
      }
      {
#line 3536
      anything_to_send = 1;
#line 3539
      closexscript(ee);
      }
#line 3540
      if ((unsigned long )ee->e_dfp != (unsigned long )((void *)0)) {
        {
#line 3542
        sm_io_close(ee->e_dfp, -2);
#line 3543
        ee->e_dfp = (SM_FILE_T *)((void *)0);
        }
      }
      {
#line 3545
      unlockqueue(ee);
      }
      __Cont: /* CIL Label */ 
#line 3521
      ee = ee->e_sibling;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3547
    if (anything_to_send) {
      {
#line 3555
      sm_io_flush(OutChannel, -2);
#line 3557
      doworklist(e, 1, 1);
      }
    }
  }
  abortmessage: 
#line 3562
  if (LogLevel > 4) {
#line 3562
    if ((e->e_flags & 32768UL) != 0UL) {
      {
#line 3563
      logsender(e, (char *)((void *)0));
      }
    }
  }
#line 3564
  e->e_flags &= 0xffffffffffff7fffUL;
#line 3567
  smtp___0->sm_gotmail = 0;
#line 3574
  if (aborting) {
    {
#line 3575
    dropenvelope(e, 1, 0);
    }
  } else
#line 3574
  if ((e->e_flags & 16777216UL) != 0UL) {
    {
#line 3575
    dropenvelope(e, 1, 0);
    }
  } else {
#line 3578
    ee = e;
    {
#line 3578
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3578
      if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 3578
        goto while_break___2;
      }
#line 3580
      if (! doublequeue) {
#line 3580
        if (QueueMode != 81) {
#line 3580
          if ((unsigned long )ee->e_quarmsg != (unsigned long )((void *)0)) {
            {
#line 3584
            dropenvelope(ee, 1, 0);
            }
#line 3585
            goto __Cont___0;
          }
        }
      }
#line 3587
      if ((int )ee->e_sendmode == 113) {
        {
#line 3588
        dropenvelope(ee, 1, 0);
        }
      } else
#line 3587
      if ((int )ee->e_sendmode == 100) {
        {
#line 3588
        dropenvelope(ee, 1, 0);
        }
      }
      __Cont___0: /* CIL Label */ 
#line 3578
      ee = ee->e_sibling;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 3591
  sm_rpool_free(e->e_rpool);
#line 3600
  CurEnv = e;
#line 3601
  tmp___14 = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 3601
  newenvelope(e, e, tmp___14);
#line 3602
  e->e_flags = BlankEnvelope.e_flags;
  }
#line 3605
  if ((unsigned long )smtp___0->sm_quarmsg == (unsigned long )((void *)0)) {
    {
#line 3607
    e->e_quarmsg = (char *)((void *)0);
#line 3608
    tmp___15 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 3608
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___15, (char *)"", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                     3608, SmHeapGroup);
    }
  } else {
    {
#line 3612
    e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, (char const   *)smtp___0->sm_quarmsg);
#line 3613
    tmp___16 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 3613
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___16, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                     3614, SmHeapGroup);
    }
  }
#line 3616
  return (rv);
}
}
#line 3634 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
void logundelrcpts(ENVELOPE *e , char *msg , int level , bool all ) 
{ 
  ADDRESS *a ;
  char *__cil_tmp6 ;

  {
#line 3643
  if (LogLevel <= level) {
#line 3644
    return;
  } else
#line 3643
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 3644
    return;
  } else
#line 3643
  if ((int )*msg == 0) {
#line 3644
    return;
  }
  {
#line 3647
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'h', (char *)((void *)0), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                   3647, SmHeapGroup);
#line 3650
  a = e->e_sendqueue;
  }
  {
#line 3650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3650
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 3650
      goto while_break;
    }
#line 3652
    if (! ((int )a->q_state == 0)) {
#line 3652
      if (! ((int )a->q_state == 3)) {
#line 3652
        if (! ((int )a->q_state == 4)) {
#line 3652
          if (! ((int )a->q_state == 5)) {
#line 3652
            if (! all) {
#line 3653
              goto __Cont;
            }
          }
        }
      }
    }
    {
#line 3654
    e->e_to = a->q_paddr;
#line 3655
    logdelivery((MAILER *)((void *)0), (struct mailer_con_info *)((void *)0), a->q_status,
                (char const   *)msg, (ADDRESS *)((void *)0), (time_t )0, e);
    }
    __Cont: /* CIL Label */ 
#line 3650
    a = a->q_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 3658
  e->e_to = (char *)((void *)0);
#line 3659
  return;
}
}
#line 3680 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static time_t checksmtpattack(unsigned int volatile   *pcounter , unsigned int maxcount ,
                              bool waitnow , char *cname , ENVELOPE *e ) 
{ 
  unsigned int shift ;
  time_t s ;
  time_t tmp ;
  time_t tmp___0 ;
  char *__cil_tmp10 ;

  {
#line 3688
  if (maxcount <= 0U) {
#line 3689
    return ((time_t )0);
  }
#line 3691
  *pcounter += (unsigned int volatile   )1;
#line 3691
  if (*pcounter >= (unsigned int volatile   )maxcount) {
#line 3696
    if (*pcounter == (unsigned int volatile   )maxcount) {
#line 3696
      if (LogLevel > 5) {
        {
#line 3698
        sm_syslog(6, (char const   *)e->e_id, "%s: possible SMTP attack: command=%.40s, count=%u",
                  CurSmtpClient, cname, *pcounter);
        }
      }
    }
#line 3702
    shift = (unsigned int )(*pcounter - (unsigned int volatile   )maxcount);
#line 3703
    s = (time_t )(1 << shift);
#line 3704
    if (shift > 8U) {
#line 3705
      s = (time_t )240;
    } else
#line 3704
    if (s >= 240L) {
#line 3705
      s = (time_t )240;
    } else
#line 3704
    if (s <= 0L) {
#line 3705
      s = (time_t )240;
    }
    {
#line 3711
    sleep((unsigned int )(*pcounter / (unsigned int volatile   )maxcount));
#line 3712
    s -= (time_t )(*pcounter / (unsigned int volatile   )maxcount);
    }
#line 3713
    if (s >= 240L) {
#line 3714
      s = (time_t )240;
    } else
#line 3713
    if (s < 0L) {
#line 3714
      s = (time_t )240;
    }
#line 3715
    if (waitnow) {
#line 3715
      if (s > 0L) {
        {
#line 3717
        sleep((unsigned int )s);
        }
#line 3718
        if (MaxChildren > 0) {
#line 3718
          if (*pcounter >= (unsigned int volatile   )(maxcount * 2U)) {
#line 3718
            tmp = (time_t )-1;
          } else {
#line 3718
            tmp = (time_t )0;
          }
        } else {
#line 3718
          tmp = (time_t )0;
        }
#line 3718
        return (tmp);
      }
    }
#line 3720
    if (MaxChildren > 0) {
#line 3720
      if (*pcounter >= (unsigned int volatile   )(maxcount * 2U)) {
#line 3720
        tmp___0 = (time_t )-1;
      } else {
#line 3720
        tmp___0 = s;
      }
    } else {
#line 3720
      tmp___0 = s;
    }
#line 3720
    return (tmp___0);
  }
#line 3722
  return ((time_t )0);
}
}
#line 3737 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static void setup_smtpd_io(void) 
{ 
  int inchfd ;
  int outchfd ;
  int outfd ;
  int inmode ;
  int outmode ;
  int *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 3742
  inchfd = sm_io_getinfo(InChannel, 3, (void *)0);
#line 3743
  outchfd = sm_io_getinfo(OutChannel, 3, (void *)0);
#line 3744
  outfd = sm_io_getinfo(& SmIoF[1], 3, (void *)0);
  }
#line 3745
  if (outchfd != outfd) {
    {
#line 3748
    dup2(outchfd, outfd);
    }
  }
#line 3758
  if (inchfd == 0) {
#line 3758
    if (outchfd == 1) {
      {
#line 3758
      tmp___4 = isatty(inchfd);
      }
#line 3758
      if (tmp___4) {
        {
#line 3758
        tmp___5 = isatty(outchfd);
        }
#line 3758
        if (tmp___5) {
          {
#line 3763
          inmode = fcntl(inchfd, 3, 0);
          }
#line 3764
          if (inmode == -1) {
#line 3766
            if (LogLevel > 11) {
              {
#line 3767
              tmp = __errno_location();
#line 3767
              tmp___0 = sm_errstring(*tmp);
#line 3767
              sm_syslog(6, "*~*", "fcntl(inchfd, F_GETFL) failed: %s", tmp___0);
              }
            }
#line 3770
            return;
          }
          {
#line 3772
          outmode = fcntl(outchfd, 3, 0);
          }
#line 3773
          if (outmode == -1) {
#line 3775
            if (LogLevel > 11) {
              {
#line 3776
              tmp___1 = __errno_location();
#line 3776
              tmp___2 = sm_errstring(*tmp___1);
#line 3776
              sm_syslog(6, "*~*", "fcntl(outchfd, F_GETFL) failed: %s", tmp___2);
              }
            }
#line 3779
            return;
          }
#line 3781
          if ((inmode & 2048) != 0) {
#line 3784
            return;
          } else
#line 3781
          if ((outmode & 2048) != 0) {
#line 3784
            return;
          } else {
            {
#line 3781
            tmp___3 = fcntl(inchfd, 4, inmode | 2048);
            }
#line 3781
            if (tmp___3 == -1) {
#line 3784
              return;
            }
          }
          {
#line 3785
          outmode = fcntl(outchfd, 3, 0);
          }
#line 3786
          if (outmode != -1) {
#line 3786
            if ((outmode & 2048) != 0) {
              {
#line 3789
              sm_io_automode(OutChannel, InChannel);
              }
#line 3790
              if ((int )tTdvect[97] >= 4) {
#line 3790
                if (LogLevel > 9) {
                  {
#line 3791
                  sm_syslog(6, "*~*", "set automode for I (%d)/O (%d) in SMTP server",
                            inchfd, outchfd);
                  }
                }
              }
            }
          }
          {
#line 3797
          fcntl(inchfd, 4, inmode);
          }
        }
      }
    }
  }
#line 3799
  return;
}
}
#line 3815 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static char *skipword(char * volatile  p , char *w ) 
{ 
  register char *q ;
  char *firstp ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char * volatile  tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char * volatile  tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp13 ;

  {
#line 3821
  firstp = (char *)p;
  {
#line 3824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3824
    if (((int )*p & -128) == 0) {
      {
#line 3824
      tmp = __ctype_b_loc();
      }
#line 3824
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 3824
        goto while_break;
      }
    } else {
#line 3824
      goto while_break;
    }
#line 3824
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3825
  q = (char *)p;
  {
#line 3828
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3828
    if ((int )*p != 0) {
#line 3828
      if ((int )*p != 58) {
#line 3828
        if (((int )*p & -128) == 0) {
          {
#line 3828
          tmp___0 = __ctype_b_loc();
          }
#line 3828
          if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
#line 3828
            goto while_break___0;
          }
        }
      } else {
#line 3828
        goto while_break___0;
      }
    } else {
#line 3828
      goto while_break___0;
    }
#line 3829
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3830
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3830
    if (((int )*p & -128) == 0) {
      {
#line 3830
      tmp___2 = __ctype_b_loc();
      }
#line 3830
      if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 3830
        goto while_break___1;
      }
    } else {
#line 3830
      goto while_break___1;
    }
#line 3831
    tmp___1 = p;
#line 3831
    p ++;
#line 3831
    *tmp___1 = (char )'\000';
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3832
  if ((int )*p != 58) {
    syntax: 
    {
#line 3835
    tmp___3 = shortenstring((char const   *)firstp, (size_t )203);
#line 3835
    usrerr("501 5.5.2 Syntax error in parameters scanning \"%s\"", tmp___3);
    }
#line 3837
    return ((char *)((void *)0));
  }
#line 3839
  tmp___4 = p;
#line 3839
  p ++;
#line 3839
  *tmp___4 = (char )'\000';
  {
#line 3840
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3840
    if (((int )*p & -128) == 0) {
      {
#line 3840
      tmp___5 = __ctype_b_loc();
      }
#line 3840
      if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 3840
        goto while_break___2;
      }
    } else {
#line 3840
      goto while_break___2;
    }
#line 3840
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3842
  if ((int )*p == 0) {
#line 3843
    goto syntax;
  }
  {
#line 3846
  tmp___6 = sm_strcasecmp((char const   *)q, (char const   *)w);
  }
#line 3846
  if (tmp___6) {
#line 3847
    goto syntax;
  }
#line 3849
  return ((char *)p);
}
}
#line 3863 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static void mail_esmtp_args(char *kp , char *vp , ENVELOPE *e ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *s ;
  int *tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
  {
#line 3869
  tmp___24 = sm_strcasecmp((char const   *)kp, "size");
  }
#line 3869
  if (tmp___24 == 0) {
#line 3871
    if ((unsigned long )vp == (unsigned long )((void *)0)) {
      {
#line 3873
      usrerr("501 5.5.2 SIZE requires a value");
      }
    }
    {
#line 3876
    tmp = macid_parse((char *)"{msg_size}", (char **)((void *)0));
#line 3876
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp, vp, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                     3876, SmHeapGroup);
#line 3877
    tmp___0 = __errno_location();
#line 3877
    *tmp___0 = 0;
#line 3878
    e->e_msgsize = strtol((char const   */* __restrict  */)vp, (char **/* __restrict  */)((char **)((void *)0)),
                          10);
    }
#line 3879
    if (e->e_msgsize == 2147483647L) {
      {
#line 3879
      tmp___1 = __errno_location();
      }
#line 3879
      if (*tmp___1 == 34) {
        {
#line 3881
        usrerr("552 5.2.3 Message size exceeds maximum value");
        }
      }
    }
#line 3884
    if (e->e_msgsize < 0L) {
      {
#line 3886
      usrerr("552 5.2.3 Message size invalid");
      }
    }
  } else {
    {
#line 3890
    tmp___23 = sm_strcasecmp((char const   *)kp, "body");
    }
#line 3890
    if (tmp___23 == 0) {
#line 3892
      if ((unsigned long )vp == (unsigned long )((void *)0)) {
        {
#line 3894
        usrerr("501 5.5.2 BODY requires a value");
        }
      } else {
        {
#line 3897
        tmp___3 = sm_strcasecmp((char const   *)vp, "8bitmime");
        }
#line 3897
        if (tmp___3 == 0) {
#line 3899
          SevenBitInput = 0;
        } else {
          {
#line 3901
          tmp___2 = sm_strcasecmp((char const   *)vp, "7bit");
          }
#line 3901
          if (tmp___2 == 0) {
#line 3903
            SevenBitInput = 1;
          } else {
            {
#line 3907
            usrerr("501 5.5.4 Unknown BODY type %s", vp);
            }
          }
        }
      }
      {
#line 3910
      e->e_bodytype = sm_rpool_strdup_x(e->e_rpool, (char const   *)vp);
      }
    } else {
      {
#line 3912
      tmp___22 = sm_strcasecmp((char const   *)kp, "envid");
      }
#line 3912
      if (tmp___22 == 0) {
#line 3914
        if ((PrivacyFlags & 2097152UL) != 0UL) {
          {
#line 3916
          usrerr("504 5.7.0 Sorry, ENVID not supported, we do not allow DSN");
          }
        }
#line 3919
        if ((unsigned long )vp == (unsigned long )((void *)0)) {
          {
#line 3921
          usrerr("501 5.5.2 ENVID requires a value");
          }
        }
        {
#line 3924
        tmp___4 = xtextok(vp);
        }
#line 3924
        if (! tmp___4) {
          {
#line 3926
          usrerr("501 5.5.4 Syntax error in ENVID parameter value");
          }
        }
#line 3929
        if ((unsigned long )e->e_envid != (unsigned long )((void *)0)) {
          {
#line 3931
          usrerr("501 5.5.0 Duplicate ENVID parameter");
          }
        }
        {
#line 3934
        e->e_envid = sm_rpool_strdup_x(e->e_rpool, (char const   *)vp);
#line 3935
        tmp___5 = macid_parse((char *)"{dsn_envid}", (char **)((void *)0));
#line 3935
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___5, e->e_envid, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                         3936, SmHeapGroup);
        }
      } else {
        {
#line 3938
        tmp___21 = sm_strcasecmp((char const   *)kp, "ret");
        }
#line 3938
        if (tmp___21 == 0) {
#line 3940
          if ((PrivacyFlags & 2097152UL) != 0UL) {
            {
#line 3942
            usrerr("504 5.7.0 Sorry, RET not supported, we do not allow DSN");
            }
          }
#line 3945
          if ((unsigned long )vp == (unsigned long )((void *)0)) {
            {
#line 3947
            usrerr("501 5.5.2 RET requires a value");
            }
          }
#line 3950
          if ((e->e_flags & 1048576UL) != 0UL) {
            {
#line 3952
            usrerr("501 5.5.0 Duplicate RET parameter");
            }
          }
          {
#line 3955
          e->e_flags |= 1048576UL;
#line 3956
          tmp___7 = sm_strcasecmp((char const   *)vp, "hdrs");
          }
#line 3956
          if (tmp___7 == 0) {
#line 3957
            e->e_flags |= 4UL;
          } else {
            {
#line 3958
            tmp___6 = sm_strcasecmp((char const   *)vp, "full");
            }
#line 3958
            if (tmp___6 != 0) {
              {
#line 3960
              usrerr("501 5.5.2 Bad argument \"%s\" to RET", vp);
              }
            }
          }
          {
#line 3963
          tmp___8 = macid_parse((char *)"{dsn_ret}", (char **)((void *)0));
#line 3963
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___8, vp, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                           3963, SmHeapGroup);
          }
        } else {
          {
#line 4052
          tmp___20 = sm_strcasecmp((char const   *)kp, "by");
          }
#line 4052
          if (tmp___20 == 0) {
#line 4052
            if (DeliverByMin >= 0L) {
#line 4056
              if ((unsigned long )vp == (unsigned long )((void *)0)) {
                {
#line 4058
                usrerr("501 5.5.2 BY= requires a value");
                }
              }
              {
#line 4061
              tmp___9 = __errno_location();
#line 4061
              *tmp___9 = 0;
#line 4062
              e->e_deliver_by = strtol((char const   */* __restrict  */)vp, (char **/* __restrict  */)(& s),
                                       10);
              }
#line 4063
              if (e->e_deliver_by == (-0x7FFFFFFF-1)) {
                {
#line 4068
                usrerr("501 5.5.2 BY=%s out of range", vp);
                }
              } else
#line 4063
              if (e->e_deliver_by == 2147483647L) {
                {
#line 4068
                usrerr("501 5.5.2 BY=%s out of range", vp);
                }
              } else
#line 4063
              if (e->e_deliver_by > 999999999L) {
                {
#line 4068
                usrerr("501 5.5.2 BY=%s out of range", vp);
                }
              } else
#line 4063
              if (e->e_deliver_by < -999999999L) {
                {
#line 4068
                usrerr("501 5.5.2 BY=%s out of range", vp);
                }
              }
#line 4071
              if ((unsigned long )s == (unsigned long )((void *)0)) {
                {
#line 4073
                usrerr("501 5.5.2 BY= missing \';\'");
                }
              } else
#line 4071
              if ((int )*s != 59) {
                {
#line 4073
                usrerr("501 5.5.2 BY= missing \';\'");
                }
              }
#line 4076
              e->e_dlvr_flag = 0;
#line 4077
              s ++;
              {
#line 4078
              while (1) {
                while_continue: /* CIL Label */ ;
#line 4078
                if (((int )*s & -128) == 0) {
                  {
#line 4078
                  tmp___10 = __ctype_b_loc();
                  }
#line 4078
                  if (! ((int const   )*(*tmp___10 + (int )*s) & 8192)) {
#line 4078
                    goto while_break;
                  }
                } else {
#line 4078
                  goto while_break;
                }
#line 4078
                s ++;
              }
              while_break: /* CIL Label */ ;
              }
              {
#line 4079
              tmp___11 = tolower((int )*s);
              }
              {
#line 4081
              if (tmp___11 == 110) {
#line 4081
                goto case_110;
              }
#line 4084
              if (tmp___11 == 114) {
#line 4084
                goto case_114;
              }
#line 4099
              goto switch_default;
              case_110: /* CIL Label */ 
#line 4082
              e->e_dlvr_flag = 1;
#line 4083
              goto switch_break;
              case_114: /* CIL Label */ 
#line 4085
              e->e_dlvr_flag = 2;
#line 4086
              if (e->e_deliver_by <= 0L) {
                {
#line 4088
                usrerr("501 5.5.4 mode R requires BY time > 0");
                }
              }
#line 4091
              if (DeliverByMin > 0L) {
#line 4091
                if (e->e_deliver_by > 0L) {
#line 4091
                  if (e->e_deliver_by < DeliverByMin) {
                    {
#line 4094
                    usrerr("555 5.5.2 time %ld less than %ld", e->e_deliver_by, DeliverByMin);
                    }
                  }
                }
              }
#line 4098
              goto switch_break;
              switch_default: /* CIL Label */ 
#line 4100
              if (((int )*s & -128) == 0) {
                {
#line 4100
                tmp___14 = __ctype_b_loc();
                }
#line 4100
                if ((int const   )*(*tmp___14 + (int )*s) & 16384) {
#line 4100
                  tmp___13 = (int )*s;
                } else {
#line 4100
                  tmp___13 = '?';
                }
              } else {
#line 4100
                tmp___13 = '?';
              }
              {
#line 4100
              usrerr("501 5.5.2 illegal by-mode \'%c\'", tmp___13);
              }
              switch_break: /* CIL Label */ ;
              }
#line 4103
              s ++;
              {
#line 4104
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 4104
                if (((int )*s & -128) == 0) {
                  {
#line 4104
                  tmp___15 = __ctype_b_loc();
                  }
#line 4104
                  if (! ((int const   )*(*tmp___15 + (int )*s) & 8192)) {
#line 4104
                    goto while_break___0;
                  }
                } else {
#line 4104
                  goto while_break___0;
                }
#line 4104
                s ++;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 4105
              tmp___16 = tolower((int )*s);
              }
              {
#line 4107
              if (tmp___16 == 116) {
#line 4107
                goto case_116;
              }
#line 4110
              if (tmp___16 == 0) {
#line 4110
                goto case_0;
              }
#line 4112
              goto switch_default___0;
              case_116: /* CIL Label */ 
#line 4108
              e->e_dlvr_flag |= 16;
#line 4109
              goto switch_break___0;
              case_0: /* CIL Label */ 
#line 4111
              goto switch_break___0;
              switch_default___0: /* CIL Label */ 
#line 4113
              if (((int )*s & -128) == 0) {
                {
#line 4113
                tmp___19 = __ctype_b_loc();
                }
#line 4113
                if ((int const   )*(*tmp___19 + (int )*s) & 16384) {
#line 4113
                  tmp___18 = (int )*s;
                } else {
#line 4113
                  tmp___18 = '?';
                }
              } else {
#line 4113
                tmp___18 = '?';
              }
              {
#line 4113
              usrerr("501 5.5.2 illegal by-trace \'%c\'", tmp___18);
              }
              switch_break___0: /* CIL Label */ ;
              }
            } else {
              {
#line 4121
              usrerr("555 5.5.4 %s parameter unrecognized", kp);
              }
            }
          } else {
            {
#line 4121
            usrerr("555 5.5.4 %s parameter unrecognized", kp);
            }
          }
        }
      }
    }
  }
#line 4124
  return;
}
}
#line 4138 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static void rcpt_esmtp_args(ADDRESS *a , char *kp , char *vp , ENVELOPE *e ) 
{ 
  char *p ;
  int tmp ;
  int tmp___0 ;
  char *s ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 4145
  tmp___8 = sm_strcasecmp((char const   *)kp, "notify");
  }
#line 4145
  if (tmp___8 == 0) {
#line 4149
    if ((PrivacyFlags & 2097152UL) != 0UL) {
      {
#line 4151
      usrerr("504 5.7.0 Sorry, NOTIFY not supported, we do not allow DSN");
      }
    }
#line 4154
    if ((unsigned long )vp == (unsigned long )((void *)0)) {
      {
#line 4156
      usrerr("501 5.5.2 NOTIFY requires a value");
      }
    }
    {
#line 4159
    a->q_flags &= 0xfffffffffffffe3fUL;
#line 4160
    a->q_flags |= 512UL;
#line 4161
    tmp = macid_parse((char *)"{dsn_notify}", (char **)((void *)0));
#line 4161
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp, vp, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c",
                     4161, SmHeapGroup);
#line 4163
    tmp___0 = sm_strcasecmp((char const   *)vp, "never");
    }
#line 4163
    if (tmp___0 == 0) {
#line 4164
      return;
    }
#line 4165
    p = vp;
    {
#line 4165
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4165
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 4165
        goto while_break;
      }
      {
#line 4169
      p = strchr((char const   *)p, ',');
#line 4169
      s = p;
      }
#line 4170
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 4171
        tmp___1 = p;
#line 4171
        p ++;
#line 4171
        *tmp___1 = (char )'\000';
      }
      {
#line 4172
      tmp___4 = sm_strcasecmp((char const   *)vp, "success");
      }
#line 4172
      if (tmp___4 == 0) {
#line 4173
        a->q_flags |= 64UL;
      } else {
        {
#line 4174
        tmp___3 = sm_strcasecmp((char const   *)vp, "failure");
        }
#line 4174
        if (tmp___3 == 0) {
#line 4175
          a->q_flags |= 128UL;
        } else {
          {
#line 4176
          tmp___2 = sm_strcasecmp((char const   *)vp, "delay");
          }
#line 4176
          if (tmp___2 == 0) {
#line 4177
            a->q_flags |= 256UL;
          } else {
            {
#line 4180
            usrerr("501 5.5.4 Bad argument \"%s\"  to NOTIFY", vp);
            }
          }
        }
      }
#line 4184
      if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 4185
        *s = (char )',';
      }
#line 4165
      vp = p;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 4188
    tmp___7 = sm_strcasecmp((char const   *)kp, "orcpt");
    }
#line 4188
    if (tmp___7 == 0) {
#line 4190
      if ((PrivacyFlags & 2097152UL) != 0UL) {
        {
#line 4192
        usrerr("504 5.7.0 Sorry, ORCPT not supported, we do not allow DSN");
        }
      }
#line 4195
      if ((unsigned long )vp == (unsigned long )((void *)0)) {
        {
#line 4197
        usrerr("501 5.5.2 ORCPT requires a value");
        }
      }
      {
#line 4200
      tmp___5 = strchr((char const   *)vp, ';');
      }
#line 4200
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
        {
#line 4202
        usrerr("501 5.5.4 Syntax error in ORCPT parameter value");
        }
      } else {
        {
#line 4200
        tmp___6 = xtextok(vp);
        }
#line 4200
        if (! tmp___6) {
          {
#line 4202
          usrerr("501 5.5.4 Syntax error in ORCPT parameter value");
          }
        }
      }
#line 4205
      if ((unsigned long )a->q_orcpt != (unsigned long )((void *)0)) {
        {
#line 4207
        usrerr("501 5.5.0 Duplicate ORCPT parameter");
        }
      }
      {
#line 4210
      a->q_orcpt = sm_rpool_strdup_x(e->e_rpool, (char const   *)vp);
      }
    } else {
      {
#line 4214
      usrerr("555 5.5.4 %s parameter unrecognized", kp);
      }
    }
  }
#line 4217
  return;
}
}
#line 4234 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static void printvrfyaddr(ADDRESS *a , bool last , bool vrfy ) 
{ 
  char fmtbuf[30] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 4242
  if (vrfy) {
#line 4242
    if ((unsigned long )a->q_mailer != (unsigned long )((void *)0)) {
#line 4242
      if (! ((a->q_mailer)->m_flags[113UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 113UL % (8UL * sizeof(int ))))) {
        {
#line 4244
        sm_strlcpy(fmtbuf, "252", (ssize_t )sizeof(fmtbuf));
        }
      } else {
        {
#line 4246
        sm_strlcpy(fmtbuf, "250", (ssize_t )sizeof(fmtbuf));
        }
      }
    } else {
      {
#line 4246
      sm_strlcpy(fmtbuf, "250", (ssize_t )sizeof(fmtbuf));
      }
    }
  } else {
    {
#line 4246
    sm_strlcpy(fmtbuf, "250", (ssize_t )sizeof(fmtbuf));
    }
  }
#line 4247
  if (last) {
#line 4247
    fmtbuf[3] = (char )' ';
  } else {
#line 4247
    fmtbuf[3] = (char )'-';
  }
  {
#line 4248
  sm_strlcpy(& fmtbuf[4], "2.1.5 ", (ssize_t )(sizeof(fmtbuf) - 4UL));
  }
#line 4249
  if ((unsigned long )a->q_fullname == (unsigned long )((void *)0)) {
#line 4251
    if ((unsigned long )a->q_mailer == (unsigned long )((void *)0)) {
#line 4251
      goto _L;
    } else
#line 4251
    if ((unsigned long )(a->q_mailer)->m_addrtype == (unsigned long )((void *)0)) {
#line 4251
      goto _L;
    } else {
      {
#line 4251
      tmp = sm_strcasecmp((char const   *)(a->q_mailer)->m_addrtype, "rfc822");
      }
#line 4251
      if (tmp == 0) {
        _L: /* CIL Label */ 
        {
#line 4251
        tmp___0 = strchr((char const   *)a->q_user, '@');
        }
#line 4251
        if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
          {
#line 4255
          sm_strlcpy(& fmtbuf[10], "<%s@%s>", (ssize_t )(sizeof(fmtbuf) - 10UL));
          }
        } else {
          {
#line 4258
          sm_strlcpy(& fmtbuf[10], "<%s>", (ssize_t )(sizeof(fmtbuf) - 10UL));
          }
        }
      } else {
        {
#line 4258
        sm_strlcpy(& fmtbuf[10], "<%s>", (ssize_t )(sizeof(fmtbuf) - 10UL));
        }
      }
    }
    {
#line 4260
    message((char const   *)(fmtbuf), a->q_user, MyHostName);
    }
  } else {
#line 4264
    if ((unsigned long )a->q_mailer == (unsigned long )((void *)0)) {
#line 4264
      goto _L___0;
    } else
#line 4264
    if ((unsigned long )(a->q_mailer)->m_addrtype == (unsigned long )((void *)0)) {
#line 4264
      goto _L___0;
    } else {
      {
#line 4264
      tmp___1 = sm_strcasecmp((char const   *)(a->q_mailer)->m_addrtype, "rfc822");
      }
#line 4264
      if (tmp___1 == 0) {
        _L___0: /* CIL Label */ 
        {
#line 4264
        tmp___2 = strchr((char const   *)a->q_user, '@');
        }
#line 4264
        if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
          {
#line 4268
          sm_strlcpy(& fmtbuf[10], "%s <%s@%s>", (ssize_t )(sizeof(fmtbuf) - 10UL));
          }
        } else {
          {
#line 4271
          sm_strlcpy(& fmtbuf[10], "%s <%s>", (ssize_t )(sizeof(fmtbuf) - 10UL));
          }
        }
      } else {
        {
#line 4271
        sm_strlcpy(& fmtbuf[10], "%s <%s>", (ssize_t )(sizeof(fmtbuf) - 10UL));
        }
      }
    }
    {
#line 4273
    message((char const   *)(fmtbuf), a->q_fullname, a->q_user, MyHostName);
    }
  }
#line 4275
  return;
}
}
#line 4448 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static struct __anonstruct_srv_feat_table_66 srv_feat_table[12]  = 
#line 4448
  {      {(char )'A', 4U}, 
        {(char )'B', 64U}, 
        {(char )'C', 2048U}, 
        {(char )'D', 128U}, 
        {(char )'E', 8U}, 
        {(char )'L', 1024U}, 
        {(char )'P', 256U}, 
        {(char )'R', 2U}, 
        {(char )'S', 1U}, 
        {(char )'V', 2U}, 
        {(char )'X', 32U}, 
        {(char )'\000', 0U}};
#line 4475 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static unsigned int srvfeatures(ENVELOPE *e , char *clientname , unsigned int features ) 
{ 
  int r ;
  int i ;
  int j ;
  char **pvp ;
  char c ;
  char opt ;
  char pvpbuf[1256] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 4485
  pvp = (char **)((void *)0);
#line 4486
  r = rscap((char *)"srv_features", clientname, (char *)"", e, & pvp, pvpbuf, (int )sizeof(pvpbuf));
  }
#line 4488
  if (r != 0) {
#line 4489
    return (features);
  }
#line 4490
  if ((unsigned long )pvp == (unsigned long )((void *)0)) {
#line 4491
    return (features);
  } else
#line 4490
  if ((unsigned long )*(pvp + 0) == (unsigned long )((void *)0)) {
#line 4491
    return (features);
  } else
#line 4490
  if (((int )*(*(pvp + 0) + 0) & 255) != 150) {
#line 4491
    return (features);
  }
#line 4492
  if ((unsigned long )*(pvp + 1) != (unsigned long )((void *)0)) {
    {
#line 4492
    tmp = sm_strncasecmp((char const   *)*(pvp + 1), "temp", (size_t )4);
    }
#line 4492
    if (tmp == 0) {
#line 4493
      return (4096U);
    }
  }
#line 4503
  i = 1;
  {
#line 4503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4503
    if (! ((unsigned long )*(pvp + i) != (unsigned long )((void *)0))) {
#line 4503
      goto while_break;
    }
#line 4505
    c = *(*(pvp + i) + 0);
#line 4506
    j = 0;
    {
#line 4507
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4509
      opt = srv_feat_table[j].srvf_opt;
#line 4509
      if ((int )opt == 0) {
#line 4511
        if (LogLevel > 9) {
          {
#line 4512
          sm_syslog(4, (char const   *)e->e_id, "srvfeatures: unknown feature %s",
                    *(pvp + i));
          }
        }
#line 4515
        goto while_break___0;
      }
#line 4517
      if ((int )c == (int )opt) {
#line 4519
        features &= ~ srv_feat_table[j].srvf_flag;
#line 4520
        goto while_break___0;
      }
      {
#line 4522
      tmp___0 = tolower((int )opt);
      }
#line 4522
      if ((int )c == tmp___0) {
#line 4524
        features |= srv_feat_table[j].srvf_flag;
#line 4525
        goto while_break___0;
      }
#line 4527
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4530
  return (features);
}
}
#line 4562 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
static int foundvers  =    -1;
#line 4549 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/srvrsmtp.c"
void help(char *topic , ENVELOPE *e ) 
{ 
  register SM_FILE_T *hf ;
  register char *p ;
  int len___0 ;
  bool noinfo ;
  bool first ;
  long sff ;
  char buf___16[2048] ;
  char inp[2048] ;
  int *tmp ;
  size_t tmp___0 ;
  int h ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 4558
  first = 1;
#line 4559
  sff = 8320L;
#line 4565
  if (DontLockReadFiles) {
#line 4566
    sff |= 16384L;
  }
#line 4567
  if (! (DontBlameSendmail[25UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 25UL % (8UL * sizeof(int ))))) {
#line 4568
    sff |= 256L;
  }
#line 4570
  if ((unsigned long )HelpFile == (unsigned long )((void *)0)) {
    {
#line 4574
    tmp = __errno_location();
#line 4574
    *tmp = 0;
#line 4575
    message("502 5.3.0 Sendmail %s -- HELP not implemented", Version);
    }
#line 4577
    return;
  } else {
    {
#line 4570
    hf = safefopen(HelpFile, 0, 292, sff);
    }
#line 4570
    if ((unsigned long )hf == (unsigned long )((void *)0)) {
      {
#line 4574
      tmp = __errno_location();
#line 4574
      *tmp = 0;
#line 4575
      message("502 5.3.0 Sendmail %s -- HELP not implemented", Version);
      }
#line 4577
      return;
    }
  }
#line 4580
  if ((unsigned long )topic == (unsigned long )((void *)0)) {
#line 4582
    topic = (char *)"smtp";
#line 4583
    noinfo = 0;
  } else
#line 4580
  if ((int )*topic == 0) {
#line 4582
    topic = (char *)"smtp";
#line 4583
    noinfo = 0;
  } else {
    {
#line 4587
    makelower(topic);
#line 4588
    noinfo = 1;
    }
  }
  {
#line 4591
  tmp___0 = strlen((char const   *)topic);
#line 4591
  len___0 = (int )tmp___0;
  }
  {
#line 4593
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4593
    tmp___7 = sm_io_fgets(hf, -2, buf___16, (int )sizeof(buf___16));
    }
#line 4593
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
#line 4593
      goto while_break;
    }
#line 4595
    if ((int )buf___16[0] == 35) {
#line 4597
      if (foundvers < 0) {
        {
#line 4597
        tmp___3 = strlen("#vers\t");
#line 4597
        tmp___4 = strncmp((char const   *)(buf___16), "#vers\t", tmp___3);
        }
#line 4597
        if (tmp___4 == 0) {
          {
#line 4602
          tmp___1 = strlen("#vers\t");
#line 4602
          tmp___2 = sm_io_sscanf((char const   *)(buf___16 + tmp___1), "%d", & h);
          }
#line 4602
          if (tmp___2 == 1) {
#line 4604
            foundvers = h;
          }
        }
      }
#line 4606
      goto while_continue;
    }
    {
#line 4608
    tmp___6 = strncmp((char const   *)(buf___16), (char const   *)topic, (size_t )len___0);
    }
#line 4608
    if (tmp___6 == 0) {
#line 4610
      if (first) {
#line 4612
        first = 0;
#line 4615
        if (foundvers < 2) {
#line 4615
          if (! noinfo) {
            {
#line 4616
            message("214-2.0.0 This is Sendmail version %s", Version);
            }
          }
        }
      }
      {
#line 4618
      p = strpbrk((char const   *)(buf___16), " \t");
      }
#line 4619
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
#line 4620
        tmp___5 = strlen((char const   *)(buf___16));
#line 4620
        p = (buf___16 + tmp___5) - 1;
        }
      } else {
#line 4622
        p ++;
      }
      {
#line 4623
      fixcrlf(p, 1);
      }
#line 4624
      if (foundvers >= 2) {
        {
#line 4626
        translate_dollars(p);
#line 4627
        expand(p, inp, (size_t )sizeof(inp), e);
#line 4628
        p = inp;
        }
      }
      {
#line 4630
      message("214-2.0.0 %s", p);
#line 4631
      noinfo = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4635
  if (noinfo) {
    {
#line 4636
    message("504 5.3.0 HELP topic \"%.10s\" unknown", topic);
    }
  } else {
    {
#line 4638
    message("214 2.0.0 End of HELP info");
    }
  }
#line 4640
  if (foundvers != 0) {
#line 4640
    if (foundvers < 2) {
#line 4642
      if (LogLevel > 1) {
        {
#line 4643
        sm_syslog(4, (char const   *)e->e_id, "%s too old (require version %d)", HelpFile,
                  2);
        }
      }
#line 4648
      foundvers = 0;
    }
  }
  {
#line 4651
  sm_io_close(hf, -2);
  }
#line 4652
  return;
}
}
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *__h_errno_location(void)  __attribute__((__const__)) ;
#line 268 "/usr/include/resolv.h"
extern  __attribute__((__nothrow__)) int __res_search(char const   * , int  , int  ,
                                                      u_char * , int  ) ;
#line 345
extern  __attribute__((__nothrow__)) int __dn_expand(u_char const   * , u_char const   * ,
                                                     u_char const   * , char * , int  ) ;
#line 126 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.h"
void dns_free_data(DNS_REPLY_T *r ) ;
#line 127
int dns_string_to_type(char const   *name ) ;
#line 128
char const   *dns_type_to_string(int type ) ;
#line 129
DNS_REPLY_T *dns_lookup_int(char const   *domain , int rr_class , int rr_type , time_t retrans ,
                            int retry ) ;
#line 51 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c"
static struct stot stot[9]  = 
#line 51 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c"
  {      {"A", 1}, 
        {"NS", 2}, 
        {"CNAME", 5}, 
        {"PTR", 12}, 
        {"MX", 15}, 
        {"TXT", 16}, 
        {"AFSDB", 18}, 
        {"SRV", 33}, 
        {(char const   *)((void *)0), 0}};
#line 73
static DNS_REPLY_T *parse_dns_reply(unsigned char *data , int len___0 ) ;
#line 86 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c"
int dns_string_to_type(char const   *name ) 
{ 
  struct stot *p ;
  int tmp ;

  {
#line 90
  p = stot;
#line 92
  p = stot;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )p->st_name != (unsigned long )((void *)0))) {
#line 92
      goto while_break;
    }
    {
#line 93
    tmp = sm_strcasecmp(name, p->st_name);
    }
#line 93
    if (tmp == 0) {
#line 94
      return (p->st_type);
    }
#line 92
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return (-1);
}
}
#line 109 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c"
char const   *dns_type_to_string(int type ) 
{ 
  struct stot *p ;

  {
#line 113
  p = stot;
#line 115
  p = stot;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! ((unsigned long )p->st_name != (unsigned long )((void *)0))) {
#line 115
      goto while_break;
    }
#line 116
    if (type == p->st_type) {
#line 117
      return (p->st_name);
    }
#line 115
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return ((char const   *)((void *)0));
}
}
#line 131 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c"
void dns_free_data(DNS_REPLY_T *r ) 
{ 
  RESOURCE_RECORD_T *rr ;
  RESOURCE_RECORD_T *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 137
  if ((unsigned long )r->dns_r_q.dns_q_domain != (unsigned long )((void *)0)) {
    {
#line 138
    sm_free_tagged((void *)r->dns_r_q.dns_q_domain, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c",
                   138);
    }
  }
#line 139
  rr = r->dns_r_head;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! ((unsigned long )rr != (unsigned long )((void *)0))) {
#line 139
      goto while_break;
    }
#line 141
    tmp = rr;
#line 143
    if ((unsigned long )rr->rr_domain != (unsigned long )((void *)0)) {
      {
#line 144
      sm_free_tagged((void *)rr->rr_domain, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c",
                     144);
      }
    }
#line 145
    if ((unsigned long )rr->rr_u.rr_data != (unsigned long )((void *)0)) {
      {
#line 146
      sm_free_tagged(rr->rr_u.rr_data, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c",
                     146);
      }
    }
    {
#line 147
    rr = rr->rr_next;
#line 148
    sm_free_tagged((void *)tmp, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c",
                   148);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  sm_free_tagged((void *)r, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c",
                 150);
  }
#line 151
  return;
}
}
#line 165 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c"
static DNS_REPLY_T *parse_dns_reply(unsigned char *data , int len___0 ) 
{ 
  unsigned char *p ;
  int status ;
  size_t l ;
  char host[64] ;
  DNS_REPLY_T *r ;
  RESOURCE_RECORD_T **rr ;
  void *tmp ;
  register u_char *t_cp ;
  register u_char *t_cp___0 ;
  int type ;
  int class ;
  int ttl ;
  int size ;
  int txtlen ;
  register u_char *t_cp___1 ;
  register u_char *t_cp___2 ;
  register u_char *t_cp___3 ;
  register u_char *t_cp___4 ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 177
  tmp = sm_malloc_tagged((size_t )sizeof(*r), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c",
                         177, SmHeapGroup);
#line 177
  r = (DNS_REPLY_T *)tmp;
  }
#line 178
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 179
    return ((DNS_REPLY_T *)((void *)0));
  }
  {
#line 180
  memset((void *)r, 0, (size_t )sizeof(*r));
#line 182
  p = data;
#line 185
  memcpy((void */* __restrict  */)(& r->dns_r_h), (void const   */* __restrict  */)p,
         (size_t )sizeof(r->dns_r_h));
#line 186
  p += sizeof(r->dns_r_h);
#line 187
  status = __dn_expand((u_char const   *)data, (u_char const   *)(data + len___0),
                       (u_char const   *)p, host, (int )sizeof(host));
  }
#line 188
  if (status < 0) {
    {
#line 190
    dns_free_data(r);
    }
#line 191
    return ((DNS_REPLY_T *)((void *)0));
  }
  {
#line 193
  r->dns_r_q.dns_q_domain = sm_strdup(host);
  }
#line 194
  if ((unsigned long )r->dns_r_q.dns_q_domain == (unsigned long )((void *)0)) {
    {
#line 196
    dns_free_data(r);
    }
#line 197
    return ((DNS_REPLY_T *)((void *)0));
  }
#line 199
  p += status;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    t_cp = p;
#line 200
    r->dns_r_q.dns_q_type = (unsigned int )(((int )((u_int16_t )*(t_cp + 0)) << 8) | (int )((u_int16_t )*(t_cp + 1)));
#line 200
    p += 2;
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    t_cp___0 = p;
#line 201
    r->dns_r_q.dns_q_class = (unsigned int )(((int )((u_int16_t )*(t_cp___0 + 0)) << 8) | (int )((u_int16_t )*(t_cp___0 + 1)));
#line 201
    p += 2;
#line 201
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 202
  rr = & r->dns_r_head;
  {
#line 203
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 203
    if (! ((unsigned long )p < (unsigned long )(data + len___0))) {
#line 203
      goto while_break___1;
    }
    {
#line 207
    status = __dn_expand((u_char const   *)data, (u_char const   *)(data + len___0),
                         (u_char const   *)p, host, (int )sizeof(host));
    }
#line 208
    if (status < 0) {
      {
#line 210
      dns_free_data(r);
      }
#line 211
      return ((DNS_REPLY_T *)((void *)0));
    }
#line 213
    p += status;
    {
#line 214
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 214
      t_cp___1 = p;
#line 214
      type = ((int )((u_int16_t )*(t_cp___1 + 0)) << 8) | (int )((u_int16_t )*(t_cp___1 + 1));
#line 214
      p += 2;
#line 214
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 215
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 215
      t_cp___2 = p;
#line 215
      class = ((int )((u_int16_t )*(t_cp___2 + 0)) << 8) | (int )((u_int16_t )*(t_cp___2 + 1));
#line 215
      p += 2;
#line 215
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 216
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 216
      t_cp___3 = p;
#line 216
      ttl = (int )(((((u_int32_t )*(t_cp___3 + 0) << 24) | ((u_int32_t )*(t_cp___3 + 1) << 16)) | ((u_int32_t )*(t_cp___3 + 2) << 8)) | (u_int32_t )*(t_cp___3 + 3));
#line 216
      p += 4;
#line 216
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 217
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 217
      t_cp___4 = p;
#line 217
      size = ((int )((u_int16_t )*(t_cp___4 + 0)) << 8) | (int )((u_int16_t )*(t_cp___4 + 1));
#line 217
      p += 2;
#line 217
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 218
    if ((unsigned long )(p + size) > (unsigned long )(data + len___0)) {
#line 225
      if (LogLevel > 5) {
        {
#line 226
        sm_syslog(4, "*~*", "ERROR: DNS RDLENGTH=%d > data len=%d", size, (long )len___0 - (p - data));
        }
      }
      {
#line 229
      dns_free_data(r);
      }
#line 230
      return ((DNS_REPLY_T *)((void *)0));
    }
    {
#line 232
    tmp___0 = sm_malloc_tagged((size_t )sizeof(*(*rr)), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c",
                               232, SmHeapGroup);
#line 232
    *rr = (RESOURCE_RECORD_T *)tmp___0;
    }
#line 233
    if ((unsigned long )*rr == (unsigned long )((void *)0)) {
      {
#line 235
      dns_free_data(r);
      }
#line 236
      return ((DNS_REPLY_T *)((void *)0));
    }
    {
#line 238
    memset((void *)*rr, 0, (size_t )sizeof(*(*rr)));
#line 239
    (*rr)->rr_domain = sm_strdup(host);
    }
#line 240
    if ((unsigned long )(*rr)->rr_domain == (unsigned long )((void *)0)) {
      {
#line 242
      dns_free_data(r);
      }
#line 243
      return ((DNS_REPLY_T *)((void *)0));
    }
#line 245
    (*rr)->rr_type = (unsigned int )type;
#line 246
    (*rr)->rr_class = (unsigned int )class;
#line 247
    (*rr)->rr_ttl = (unsigned int )ttl;
#line 248
    (*rr)->rr_size = (unsigned int )size;
    {
#line 253
    if (type == 12) {
#line 253
      goto case_12;
    }
#line 253
    if (type == 5) {
#line 253
      goto case_12;
    }
#line 253
    if (type == 2) {
#line 253
      goto case_12;
    }
#line 270
    if (type == 18) {
#line 270
      goto case_18;
    }
#line 270
    if (type == 15) {
#line 270
      goto case_18;
    }
#line 291
    if (type == 33) {
#line 291
      goto case_33;
    }
#line 314
    if (type == 16) {
#line 314
      goto case_16;
    }
#line 346
    goto switch_default;
    case_12: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 254
    status = __dn_expand((u_char const   *)data, (u_char const   *)(data + len___0),
                         (u_char const   *)p, host, (int )sizeof(host));
    }
#line 256
    if (status < 0) {
      {
#line 258
      dns_free_data(r);
      }
#line 259
      return ((DNS_REPLY_T *)((void *)0));
    }
    {
#line 261
    (*rr)->rr_u.rr_txt = sm_strdup(host);
    }
#line 262
    if ((unsigned long )(*rr)->rr_u.rr_txt == (unsigned long )((void *)0)) {
      {
#line 264
      dns_free_data(r);
      }
#line 265
      return ((DNS_REPLY_T *)((void *)0));
    }
#line 267
    goto switch_break;
    case_18: /* CIL Label */ 
    case_15: /* CIL Label */ 
    {
#line 271
    status = __dn_expand((u_char const   *)data, (u_char const   *)(data + len___0),
                         (u_char const   *)(p + 2), host, (int )sizeof(host));
    }
#line 273
    if (status < 0) {
      {
#line 275
      dns_free_data(r);
      }
#line 276
      return ((DNS_REPLY_T *)((void *)0));
    }
    {
#line 278
    tmp___1 = strlen((char const   *)(host));
#line 278
    l = tmp___1 + 1U;
#line 279
    tmp___2 = sm_malloc_tagged((size_t )(sizeof(*((*rr)->rr_u.rr_mx)) + (unsigned long )l),
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c",
                               280, SmHeapGroup);
#line 279
    (*rr)->rr_u.rr_mx = (MX_RECORD_T *)tmp___2;
    }
#line 281
    if ((unsigned long )(*rr)->rr_u.rr_mx == (unsigned long )((void *)0)) {
      {
#line 283
      dns_free_data(r);
      }
#line 284
      return ((DNS_REPLY_T *)((void *)0));
    }
    {
#line 286
    ((*rr)->rr_u.rr_mx)->mx_r_preference = (unsigned int )(((int )*(p + 0) << 8) | (int )*(p + 1));
#line 287
    sm_strlcpy(((*rr)->rr_u.rr_mx)->mx_r_domain, (char const   *)(host), (ssize_t )l);
    }
#line 289
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 292
    status = __dn_expand((u_char const   *)data, (u_char const   *)(data + len___0),
                         (u_char const   *)(p + 6), host, (int )sizeof(host));
    }
#line 294
    if (status < 0) {
      {
#line 296
      dns_free_data(r);
      }
#line 297
      return ((DNS_REPLY_T *)((void *)0));
    }
    {
#line 299
    tmp___3 = strlen((char const   *)(host));
#line 299
    l = tmp___3 + 1U;
#line 300
    tmp___4 = sm_malloc_tagged((size_t )(sizeof(*((*rr)->rr_u.rr_srv)) + (unsigned long )l),
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c",
                               301, SmHeapGroup);
#line 300
    (*rr)->rr_u.rr_srv = (SRV_RECORDT_T *)tmp___4;
    }
#line 302
    if ((unsigned long )(*rr)->rr_u.rr_srv == (unsigned long )((void *)0)) {
      {
#line 304
      dns_free_data(r);
      }
#line 305
      return ((DNS_REPLY_T *)((void *)0));
    }
    {
#line 307
    ((*rr)->rr_u.rr_srv)->srv_r_priority = (unsigned int )(((int )*(p + 0) << 8) | (int )*(p + 1));
#line 308
    ((*rr)->rr_u.rr_srv)->srv_r_weight = (unsigned int )(((int )*(p + 2) << 8) | (int )*(p + 3));
#line 309
    ((*rr)->rr_u.rr_srv)->srv_r_port = (unsigned int )(((int )*(p + 4) << 8) | (int )*(p + 5));
#line 310
    sm_strlcpy(((*rr)->rr_u.rr_srv)->srv_r_target, (char const   *)(host), (ssize_t )l);
    }
#line 312
    goto switch_break;
    case_16: /* CIL Label */ 
#line 326
    txtlen = (int )*p;
#line 327
    if (txtlen >= size) {
#line 329
      if (LogLevel > 5) {
        {
#line 330
        sm_syslog(4, "*~*", "ERROR: DNS TXT record size=%d <= text len=%d", size,
                  txtlen);
        }
      }
      {
#line 333
      dns_free_data(r);
      }
#line 334
      return ((DNS_REPLY_T *)((void *)0));
    }
    {
#line 336
    tmp___5 = sm_malloc_tagged((size_t )(txtlen + 1), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c",
                               336, SmHeapGroup);
#line 336
    (*rr)->rr_u.rr_txt = (char *)tmp___5;
    }
#line 337
    if ((unsigned long )(*rr)->rr_u.rr_txt == (unsigned long )((void *)0)) {
      {
#line 339
      dns_free_data(r);
      }
#line 340
      return ((DNS_REPLY_T *)((void *)0));
    }
    {
#line 342
    sm_strlcpy((*rr)->rr_u.rr_txt, (char const   *)((char *)p + 1), txtlen + 1);
    }
#line 344
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 347
    tmp___6 = sm_malloc_tagged((size_t )size, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c",
                               347, SmHeapGroup);
#line 347
    (*rr)->rr_u.rr_data = (void *)((unsigned char *)tmp___6);
    }
#line 348
    if ((unsigned long )(*rr)->rr_u.rr_data == (unsigned long )((void *)0)) {
      {
#line 350
      dns_free_data(r);
      }
#line 351
      return ((DNS_REPLY_T *)((void *)0));
    }
    {
#line 353
    memcpy((void */* __restrict  */)(*rr)->rr_u.rr_data, (void const   */* __restrict  */)p,
           (size_t )size);
    }
#line 354
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 356
    p += size;
#line 357
    rr = & (*rr)->rr_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 359
  *rr = (RESOURCE_RECORD_T *)((void *)0);
#line 360
  return (r);
}
}
#line 378 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/sm_resolve.c"
DNS_REPLY_T *dns_lookup_int(char const   *domain , int rr_class , int rr_type , time_t retrans ,
                            int retry ) 
{ 
  int len___0 ;
  unsigned long old_options ;
  time_t save_retrans ;
  int save_retry ;
  DNS_REPLY_T *r ;
  unsigned char reply___0[1024] ;
  struct __res_state *tmp ;
  struct __res_state *tmp___0 ;
  char const   *tmp___1 ;
  struct __res_state *tmp___2 ;
  struct __res_state *tmp___3 ;
  struct __res_state *tmp___4 ;
  struct __res_state *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  struct __res_state *tmp___8 ;
  char const   *tmp___9 ;
  struct __res_state *tmp___10 ;
  struct __res_state *tmp___11 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 387
  old_options = 0UL;
#line 388
  save_retrans = (time_t )0;
#line 389
  save_retry = 0;
#line 390
  r = (DNS_REPLY_T *)((void *)0);
#line 393
  if ((int )tTdvect[8] >= 16) {
    {
#line 395
    tmp = __res_state();
#line 395
    old_options = tmp->options;
#line 396
    tmp___0 = __res_state();
#line 396
    tmp___0->options |= 2UL;
#line 397
    tmp___1 = dns_type_to_string(rr_type);
#line 397
    sm_dprintf((char *)"dns_lookup(%s, %d, %s)\n", domain, rr_class, tmp___1);
    }
  }
#line 400
  if (retrans > 0L) {
    {
#line 402
    tmp___2 = __res_state();
#line 402
    save_retrans = (time_t )tmp___2->retrans;
#line 403
    tmp___3 = __res_state();
#line 403
    tmp___3->retrans = (int )retrans;
    }
  }
#line 405
  if (retry > 0) {
    {
#line 407
    tmp___4 = __res_state();
#line 407
    save_retry = tmp___4->retry;
#line 408
    tmp___5 = __res_state();
#line 408
    tmp___5->retry = retry;
    }
  }
  {
#line 410
  tmp___6 = __errno_location();
#line 410
  *tmp___6 = 0;
#line 411
  tmp___7 = __h_errno_location();
#line 411
  *tmp___7 = 0;
#line 412
  len___0 = __res_search(domain, rr_class, rr_type, reply___0, (int )sizeof(reply___0));
  }
#line 413
  if ((int )tTdvect[8] >= 16) {
    {
#line 415
    tmp___8 = __res_state();
#line 415
    tmp___8->options = old_options;
#line 416
    tmp___9 = dns_type_to_string(rr_type);
#line 416
    sm_dprintf((char *)"dns_lookup(%s, %d, %s) --> %d\n", domain, rr_class, tmp___9,
               len___0);
    }
  }
#line 419
  if (len___0 >= 0) {
    {
#line 420
    r = parse_dns_reply(reply___0, len___0);
    }
  }
#line 421
  if (retrans > 0L) {
    {
#line 422
    tmp___10 = __res_state();
#line 422
    tmp___10->retrans = (int )save_retrans;
    }
  }
#line 423
  if (retry > 0) {
    {
#line 424
    tmp___11 = __res_state();
#line 424
    tmp___11->retry = save_retry;
    }
  }
#line 425
  return (r);
}
}
#line 254 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 337 "./sendmail.h"
bool emptyaddr(ADDRESS *a ) ;
#line 471
MAILER *FileMailer ;
#line 810
void addheader(char *field , char *value , int flags , ENVELOPE *e ) ;
#line 814
void eatheader(ENVELOPE *e , bool full , bool log ) ;
#line 815
char *hvalue(char *field , HDR *header ) ;
#line 818
bool putfromline(struct mailer_con_info *mci , ENVELOPE *e ) ;
#line 968
bool putbody(struct mailer_con_info *mci , ENVELOPE *e , char *separator ) ;
#line 969
bool putheader(struct mailer_con_info *mci , HDR *hdr , ENVELOPE *e , int flags ) ;
#line 1144
int getmxrr(char *host , char **mxhosts , unsigned short *mxprefs , bool droplocalhost ,
            int *rcode , bool tryfallback , int *pttl ) ;
#line 1669
int returntosender(char *msg , ADDRESS *returnq , int flags , ENVELOPE *e ) ;
#line 1963
void loseqfile(ENVELOPE *e , char *why ) ;
#line 1974
bool setnewqueue(ENVELOPE *e ) ;
#line 2160
bool DontPruneRoutes ;
#line 2284
char *DeadLetterDrop ;
#line 2287
char *DoubleBounceAddr ;
#line 2288
char *ErrMsgFile ;
#line 2310
char *SafeFileEnv ;
#line 2402
int mailfile(char * volatile  filename , MAILER * volatile  mailer , ADDRESS *ctladdr ,
             long volatile   sfflags , ENVELOPE *e ) ;
#line 2440
char *arpadate(char *ud ) ;
#line 2550
bool savemail(ENVELOPE *e , bool sendbody ) ;
#line 2611
bool writable(char *filename , ADDRESS *ctladdr , long flags ) ;
#line 2619
char *xtextify(char *t , char *taboo ) ;
#line 2622
char *xuntextify(char *t ) ;
#line 18 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
static bool errbody(struct mailer_con_info *mci , ENVELOPE *e , char *separator ) ;
#line 19
static bool pruneroute(char *addr ) ;
#line 54 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
bool savemail(ENVELOPE *e , bool sendbody ) 
{ 
  register SM_FILE_T *fp ;
  bool panic ;
  int state ;
  ADDRESS *q ;
  register char *p ;
  struct mailer_con_info mcibuf ;
  int flags ;
  long sff ;
  char buf___16[2049] ;
  char dlbuf[4096] ;
  SM_MBDB_T user ;
  char const   *tmp ;
  SM_FILE_T *tmp___0 ;
  ADDRESS *tmp___1 ;
  SM_FILE_T *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char from[4096] ;
  size_t tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int oldverb ;
  bool tmp___12 ;
  int tmp___13 ;
  bool tmp___14 ;
  int oldverb___0 ;
  bool tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  bool tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;

  {
#line 60
  panic = 0;
#line 62
  q = (ADDRESS *)((void *)0);
#line 72
  if ((int )tTdvect[6] >= 1) {
#line 74
    if ((unsigned long )e->e_id == (unsigned long )((void *)0)) {
#line 74
      tmp = "NONE";
    } else {
#line 74
      tmp = (char const   *)e->e_id;
    }
    {
#line 74
    sm_dprintf((char *)"\nsavemail, errormode = %c, id = %s, ExitStat = %d\n  e_from=",
               (int )e->e_errormode, tmp, ExitStat);
#line 77
    tmp___0 = sm_debug_file();
#line 77
    printaddr(tmp___0, & e->e_from, 0);
    }
  }
#line 80
  if ((unsigned long )e->e_id == (unsigned long )((void *)0)) {
#line 83
    return (panic);
  }
#line 91
  if ((unsigned long )e->e_from.q_paddr == (unsigned long )((void *)0)) {
    {
#line 93
    e->e_sender = (char *)"Postmaster";
#line 94
    tmp___1 = parseaddr(e->e_sender, & e->e_from, 17, '\000', (char **)((void *)0),
                        e, 0);
    }
#line 94
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 98
      syserr("553 5.3.5 Cannot parse Postmaster!");
#line 99
      finis(1, 1, (int volatile   )70);
      }
    }
  }
#line 102
  e->e_to = (char *)((void *)0);
  {
#line 123
  if ((int )e->e_errormode == 119) {
#line 123
    goto case_119;
  }
#line 128
  if ((int )e->e_errormode == 109) {
#line 128
    goto case_109;
  }
#line 128
  if ((int )e->e_errormode == 101) {
#line 128
    goto case_109;
  }
#line 133
  if ((int )e->e_errormode == 0) {
#line 133
    goto case_0;
  }
#line 133
  if ((int )e->e_errormode == 112) {
#line 133
    goto case_0;
  }
#line 137
  if ((int )e->e_errormode == 113) {
#line 137
    goto case_113;
  }
#line 141
  goto switch_default;
  case_119: /* CIL Label */ 
#line 124
  state = 0;
#line 125
  goto switch_break;
  case_109: /* CIL Label */ 
  case_101: /* CIL Label */ 
#line 129
  state = 1;
#line 130
  goto switch_break;
  case_0: /* CIL Label */ 
  case_112: /* CIL Label */ 
#line 134
  state = 2;
#line 135
  goto switch_break;
  case_113: /* CIL Label */ 
#line 139
  return (panic);
  switch_default: /* CIL Label */ 
  {
#line 142
  syserr("554 5.3.0 savemail: bogus errormode x%x", (int )e->e_errormode);
#line 144
  state = 1;
  }
#line 145
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 149
  if ((e->e_flags & 128UL) != 0UL) {
#line 151
    if ((unsigned long )e->e_parent != (unsigned long )((void *)0)) {
#line 151
      if (((e->e_parent)->e_flags & 128UL) != 0UL) {
#line 155
        return (panic);
      }
    }
#line 157
    state = 4;
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (state != 7)) {
#line 160
      goto while_break;
    }
#line 162
    if ((int )tTdvect[6] >= 5) {
      {
#line 163
      sm_dprintf((char *)"  state %d\n", state);
      }
    }
    {
#line 167
    if (state == 2) {
#line 167
      goto case_2;
    }
#line 174
    if (state == 0) {
#line 174
      goto case_0___0;
    }
#line 225
    if (state == 1) {
#line 225
      goto case_1;
    }
#line 302
    if (state == 4) {
#line 302
      goto case_4;
    }
#line 340
    if (state == 3) {
#line 340
      goto case_3;
    }
#line 397
    if (state == 5) {
#line 397
      goto case_5;
    }
#line 467
    if (state == 6) {
#line 467
      goto case_6;
    }
#line 463
    goto switch_default___0;
    case_2: /* CIL Label */ 
#line 168
    if ((e->e_from.q_mailer)->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int )))) {
#line 169
      state = 3;
    } else {
#line 171
      state = 1;
    }
#line 172
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 184
    p = (char *)((void *)0);
#line 187
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 192
      state = 1;
#line 193
      goto switch_break___0;
    } else {
      {
#line 187
      tmp___2 = sm_io_reopen((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)p,
                             3, (void const   *)((void *)0), & SmIoF[1]);
      }
#line 187
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 192
        state = 1;
#line 193
        goto switch_break___0;
      }
    }
    {
#line 196
    expand((char *)"\201n", buf___16, (size_t )sizeof(buf___16), e);
#line 197
    sm_io_fprintf(& SmIoF[1], -2, "\r\nMessage from %s...\r\n", buf___16);
#line 199
    sm_io_fprintf(& SmIoF[1], -2, "Errors occurred while sending mail.\r\n");
    }
#line 201
    if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
      {
#line 203
      bfrewind(e->e_xfp);
#line 204
      sm_io_fprintf(& SmIoF[1], -2, "Transcript follows:\r\n");
      }
      {
#line 206
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 206
        tmp___3 = sm_io_fgets(e->e_xfp, -2, buf___16, (int )sizeof(buf___16));
        }
#line 206
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 206
          if (! (! ((SmIoF[1].f_flags & 256L) != 0L))) {
#line 206
            goto while_break___0;
          }
        } else {
#line 206
          goto while_break___0;
        }
        {
#line 209
        sm_io_fputs(& SmIoF[1], -2, (char const   *)(buf___16));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 215
      tmp___4 = queuename(e, 'x');
#line 215
      syserr("Cannot open %s", tmp___4);
#line 217
      sm_io_fprintf(& SmIoF[1], -2, "Transcript of session is unavailable.\r\n");
      }
    }
    {
#line 220
    sm_io_fprintf(& SmIoF[1], -2, "Original message will be saved in dead.letter.\r\n");
#line 222
    state = 3;
    }
#line 223
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 244
    if (ExitStat == 78) {
      {
#line 246
      sendtolist((char *)"postmaster", (ADDRESS *)((void *)0), & e->e_errorqueue,
                 0, e);
      }
    } else
#line 244
    if (ExitStat == 70) {
      {
#line 246
      sendtolist((char *)"postmaster", (ADDRESS *)((void *)0), & e->e_errorqueue,
                 0, e);
      }
    }
    {
#line 249
    tmp___6 = emptyaddr(& e->e_from);
    }
#line 249
    if (! tmp___6) {
      {
#line 253
      tmp___5 = sm_strlcpy(from, (char const   *)e->e_from.q_paddr, (ssize_t )sizeof(from));
      }
#line 253
      if ((unsigned long )tmp___5 >= sizeof(from)) {
#line 256
        state = 4;
#line 257
        goto switch_break___0;
      }
#line 260
      if (! DontPruneRoutes) {
        {
#line 261
        pruneroute(from);
        }
      }
      {
#line 263
      sendtolist(from, (ADDRESS *)((void *)0), & e->e_errorqueue, 0, e);
      }
    }
#line 275
    e->e_flags |= 8192UL;
#line 278
    q = e->e_errorqueue;
    {
#line 278
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 278
      if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 278
        goto while_break___1;
      }
#line 280
      if ((int )q->q_state == 0) {
#line 281
        goto while_break___1;
      } else
#line 280
      if ((int )q->q_state == 3) {
#line 281
        goto while_break___1;
      } else
#line 280
      if ((int )q->q_state == 4) {
#line 281
        goto while_break___1;
      }
#line 278
      q = q->q_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 283
    if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 286
      state = 4;
#line 287
      goto switch_break___0;
    }
#line 289
    if (sendbody) {
#line 289
      tmp___7 = 1;
    } else {
#line 289
      tmp___7 = 0;
    }
    {
#line 289
    tmp___8 = returntosender(e->e_message, e->e_errorqueue, tmp___7, e);
    }
#line 289
    if (tmp___8 == 0) {
#line 294
      state = 7;
#line 295
      goto switch_break___0;
    }
#line 299
    state = 4;
#line 300
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 307
    q = (ADDRESS *)((void *)0);
#line 308
    expand(DoubleBounceAddr, buf___16, (size_t )sizeof(buf___16), e);
    }
#line 315
    if ((int )buf___16[0] == 0) {
#line 317
      state = 7;
#line 318
      goto switch_break___0;
    }
    {
#line 320
    tmp___9 = sendtolist(buf___16, (ADDRESS *)((void *)0), & q, 0, e);
    }
#line 320
    if (tmp___9 <= 0) {
      {
#line 322
      syserr("553 5.3.0 cannot parse %s!", buf___16);
#line 323
      ExitStat = 70;
#line 324
      state = 5;
      }
#line 325
      goto switch_break___0;
    }
#line 327
    flags = 2;
#line 328
    if (sendbody) {
#line 329
      flags |= 1;
    }
    {
#line 330
    tmp___10 = returntosender(e->e_message, q, flags, e);
    }
#line 330
    if (tmp___10 == 0) {
#line 332
      state = 7;
#line 333
      goto switch_break___0;
    }
#line 337
    state = 5;
#line 338
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 350
    p = (char *)((void *)0);
#line 351
    if ((e->e_from.q_mailer)->m_flags[119UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 119UL % (8UL * sizeof(int )))) {
#line 353
      if ((unsigned long )e->e_from.q_home != (unsigned long )((void *)0)) {
#line 354
        p = e->e_from.q_home;
      } else {
        {
#line 355
        tmp___11 = sm_mbdb_lookup(e->e_from.q_user, & user);
        }
#line 355
        if (tmp___11 == 0) {
#line 355
          if ((int )user.mbdb_homedir[0] != 0) {
#line 358
            p = user.mbdb_homedir;
          }
        }
      }
    }
#line 360
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 363
      state = 1;
#line 364
      goto switch_break___0;
    } else
#line 360
    if ((unsigned long )e->e_dfp == (unsigned long )((void *)0)) {
#line 363
      state = 1;
#line 364
      goto switch_break___0;
    }
    {
#line 368
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, 'z', p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                     368, SmHeapGroup);
#line 371
    p = macvalue('g', e);
#line 372
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'g', e->e_sender, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                     372, SmHeapGroup);
#line 374
    expand((char *)"\201z/dead.letter", dlbuf, (size_t )sizeof(dlbuf), e);
#line 375
    sff = 200L;
    }
#line 376
    if (RealUid == 0U) {
#line 377
      sff |= 4L;
    }
    {
#line 378
    e->e_to = dlbuf;
#line 379
    tmp___12 = writable(dlbuf, (ADDRESS *)((void *)0), sff);
    }
#line 379
    if (tmp___12) {
      {
#line 379
      tmp___13 = mailfile((char */* volatile  */)(dlbuf), (MAILER */* volatile  */)FileMailer,
                          (ADDRESS *)((void *)0), (long volatile   )sff, e);
      }
#line 379
      if (tmp___13 == 0) {
#line 382
        oldverb = Verbose;
#line 384
        if ((int )OpMode != 100) {
#line 384
          if ((int )OpMode != 115) {
#line 385
            Verbose = 1;
          }
        }
#line 386
        if (Verbose > 0) {
          {
#line 387
          message("Saved message in %s", dlbuf);
          }
        }
        {
#line 388
        Verbose = oldverb;
#line 389
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'g', p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                         389, SmHeapGroup);
#line 390
        state = 7;
        }
#line 391
        goto switch_break___0;
      }
    }
    {
#line 393
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'g', p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                     393, SmHeapGroup);
#line 394
    state = 1;
    }
#line 395
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 402
    if ((int )e->e_class < 0) {
#line 404
      state = 7;
#line 405
      goto switch_break___0;
    }
#line 408
    if ((unsigned long )SafeFileEnv != (unsigned long )((void *)0)) {
#line 408
      if ((int )*(SafeFileEnv + 0) != 0) {
#line 412
        state = 6;
#line 413
        goto switch_break___0;
      } else {
#line 408
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 408
    if ((unsigned long )DeadLetterDrop == (unsigned long )((void *)0)) {
#line 412
      state = 6;
#line 413
      goto switch_break___0;
    } else
#line 408
    if ((int )*(DeadLetterDrop + 0) == 0) {
#line 412
      state = 6;
#line 413
      goto switch_break___0;
    }
    {
#line 416
    sff = 8389L;
#line 417
    tmp___14 = writable(DeadLetterDrop, (ADDRESS *)((void *)0), sff);
    }
#line 417
    if (tmp___14) {
      {
#line 417
      fp = safefopen(DeadLetterDrop, 1025, FileMode, sff);
      }
#line 417
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 421
        state = 6;
#line 422
        goto switch_break___0;
      }
    } else {
#line 421
      state = 6;
#line 422
      goto switch_break___0;
    }
    {
#line 425
    memset((void *)(& mcibuf), '\000', (size_t )sizeof(mcibuf));
#line 426
    mcibuf.mci_out = fp;
#line 427
    mcibuf.mci_mailer = FileMailer;
    }
#line 428
    if (FileMailer->m_flags[55UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 55UL % (8UL * sizeof(int )))) {
#line 429
      mcibuf.mci_flags |= 128UL;
    }
    {
#line 432
    p = macvalue('g', e);
#line 433
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'g', e->e_sender, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                     433, SmHeapGroup);
#line 435
    tmp___15 = putfromline(& mcibuf, e);
    }
#line 435
    if (tmp___15) {
      {
#line 435
      tmp___16 = (*(e->e_puthdr))(& mcibuf, e->e_header, e, 0);
      }
#line 435
      if (tmp___16) {
        {
#line 435
        tmp___17 = (*(e->e_putbody))(& mcibuf, e, (char *)((void *)0));
        }
#line 435
        if (tmp___17) {
          {
#line 435
          tmp___18 = putline((char *)"\n", & mcibuf);
          }
#line 435
          if (tmp___18) {
            {
#line 435
            tmp___19 = sm_io_flush(fp, -2);
            }
#line 435
            if (tmp___19 == -1) {
#line 443
              state = 6;
            } else
#line 435
            if ((fp->f_flags & 256L) != 0L) {
#line 443
              state = 6;
            } else {
              {
#line 435
              tmp___20 = sm_io_close(fp, -2);
              }
#line 435
              if (tmp___20 < 0) {
#line 443
                state = 6;
              } else {
#line 446
                oldverb___0 = Verbose;
#line 448
                if ((int )OpMode != 100) {
#line 448
                  if ((int )OpMode != 115) {
#line 449
                    Verbose = 1;
                  }
                }
#line 450
                if (Verbose > 0) {
                  {
#line 451
                  message("Saved message in %s", DeadLetterDrop);
                  }
                }
#line 453
                Verbose = oldverb___0;
#line 454
                if (LogLevel > 3) {
                  {
#line 455
                  sm_syslog(5, (char const   *)e->e_id, "Saved message in %s", DeadLetterDrop);
                  }
                }
#line 458
                state = 7;
              }
            }
          } else {
#line 443
            state = 6;
          }
        } else {
#line 443
          state = 6;
        }
      } else {
#line 443
        state = 6;
      }
    } else {
#line 443
      state = 6;
    }
    {
#line 460
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'g', p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                     460, SmHeapGroup);
    }
#line 461
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 464
    syserr("554 5.3.5 savemail: unknown state %d", state);
    }
    case_6: /* CIL Label */ 
    {
#line 469
    loseqfile(e, (char *)"savemail panic");
#line 470
    panic = 1;
#line 471
    tmp___21 = __errno_location();
#line 471
    *tmp___21 = 0;
#line 472
    syserr("554 savemail: cannot save rejected email anywhere");
#line 473
    state = 7;
    }
#line 474
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  return (panic);
}
}
#line 512 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
static int returndepth  =    0;
#line 502 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
int returntosender(char *msg , ADDRESS *returnq , int flags , ENVELOPE *e ) 
{ 
  register ENVELOPE *ee ;
  ENVELOPE *oldcur ;
  ENVELOPE errenvelope ;
  register ADDRESS *q ;
  char *p ;
  char buf___16[257] ;
  SM_FILE_T *tmp ;
  SM_FILE_T *tmp___0 ;
  SM_RPOOL_T *tmp___1 ;
  bool tmp___2 ;
  struct __res_state *tmp___3 ;
  struct __res_state *tmp___4 ;
  char *tmp___5 ;
  time_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  ADDRESS *tmp___11 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;

  {
#line 510
  oldcur = CurEnv;
#line 517
  if ((unsigned long )returnq == (unsigned long )((void *)0)) {
#line 518
    return (-1);
  }
#line 520
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 521
    msg = (char *)"Unable to deliver mail";
  }
#line 523
  if ((int )tTdvect[6] >= 1) {
    {
#line 525
    sm_dprintf((char *)"\n*** Return To Sender: msg=\"%s\", depth=%d, e=%p, returnq=",
               msg, returndepth, e);
#line 527
    tmp = sm_debug_file();
#line 527
    printaddr(tmp, returnq, 1);
    }
#line 528
    if ((int )tTdvect[6] >= 20) {
      {
#line 530
      sm_dprintf((char *)"Sendq=");
#line 531
      tmp___0 = sm_debug_file();
#line 531
      printaddr(tmp___0, e->e_sendqueue, 1);
      }
    }
  }
#line 535
  returndepth ++;
#line 535
  if (returndepth >= 6) {
#line 537
    if (returndepth != 6) {
      {
#line 538
      syserr("554 5.3.0 returntosender: infinite recursion on %s", returnq->q_paddr);
      }
    }
#line 542
    return (0);
  }
  {
#line 545
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'g', e->e_sender, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                   545, SmHeapGroup);
#line 546
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'u', (char *)((void *)0), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                   546, SmHeapGroup);
#line 549
  tmp___1 = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 549
  ee = newenvelope(& errenvelope, e, tmp___1);
#line 550
  macdefine_tagged(& ee->e_macro, (ARGCLASS_T )2, 'a', (char *)"\201b", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                   550, SmHeapGroup);
#line 551
  macdefine_tagged(& ee->e_macro, (ARGCLASS_T )2, 'r', (char *)"", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                   551, SmHeapGroup);
#line 552
  macdefine_tagged(& ee->e_macro, (ARGCLASS_T )2, 's', (char *)"localhost", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                   552, SmHeapGroup);
#line 553
  macdefine_tagged(& ee->e_macro, (ARGCLASS_T )2, '_', (char *)"localhost", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                   553, SmHeapGroup);
#line 554
  clrsessenvelope(ee);
#line 556
  ee->e_puthdr = & putheader;
#line 557
  ee->e_putbody = & errbody;
#line 558
  ee->e_flags |= 16512UL;
  }
#line 559
  if (! ((e->e_flags & 1UL) != 0UL)) {
#line 560
    ee->e_flags &= 0xfffffffffffffffeUL;
  }
#line 561
  if ((e->e_flags & 8388608UL) != 0UL) {
#line 563
    ee->e_flags |= 8388608UL;
#line 570
    if ((e->e_flags & 131072UL) != 0UL) {
#line 570
      if (! ((MimeMode & 2) != 0)) {
#line 572
        flags &= -2;
      }
    }
  }
#line 575
  ee->e_sendqueue = returnq;
#line 576
  ee->e_msgsize = 0L;
#line 577
  if ((flags & 1) != 0) {
#line 577
    if (! ((PrivacyFlags & 1048576UL) != 0UL)) {
#line 579
      ee->e_msgsize = 1024L + e->e_msgsize;
    } else {
#line 581
      ee->e_flags |= 4UL;
    }
  } else {
#line 581
    ee->e_flags |= 4UL;
  }
  {
#line 583
  tmp___2 = setnewqueue(ee);
  }
#line 583
  if (! tmp___2) {
    {
#line 585
    syserr("554 5.3.0 returntosender: cannot select queue for %s", returnq->q_paddr);
#line 587
    ExitStat = 69;
#line 588
    returndepth --;
    }
#line 589
    return (-1);
  }
  {
#line 591
  initsys(ee);
#line 594
  tmp___3 = __res_state();
#line 594
  tmp___3->retry = TimeOuts.res_retry[0];
#line 595
  tmp___4 = __res_state();
#line 595
  tmp___4->retrans = (int )TimeOuts.res_retrans[0];
#line 597
  q = returnq;
  }
  {
#line 597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 597
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 597
      goto while_break;
    }
#line 599
    if ((int )q->q_state == 2) {
#line 600
      goto __Cont;
    }
#line 602
    q->q_flags &= 0xfffffffffffffc3fUL;
#line 603
    q->q_flags |= 128UL;
#line 605
    if (! ((int )q->q_state >= 6)) {
#line 606
      (ee->e_nrcpts) ++;
    }
#line 608
    if ((unsigned long )q->q_alias == (unsigned long )((void *)0)) {
      {
#line 609
      addheader((char *)"To", q->q_paddr, 0, ee);
      }
    }
    __Cont: /* CIL Label */ 
#line 597
    q = q->q_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 612
  if (LogLevel > 5) {
#line 614
    if ((e->e_flags & 128UL) != 0UL) {
#line 615
      p = (char *)"return to sender";
    } else
#line 616
    if ((e->e_flags & 1024UL) != 0UL) {
#line 617
      p = (char *)"sender notify";
    } else
#line 618
    if ((flags & 2) != 0) {
#line 619
      p = (char *)"postmaster notify";
    } else {
#line 621
      p = (char *)"DSN";
    }
    {
#line 622
    tmp___5 = shortenstring((char const   *)msg, (size_t )203);
#line 622
    sm_syslog(6, (char const   *)e->e_id, "%s: %s: %s", ee->e_id, p, tmp___5);
    }
  }
#line 626
  if (SendMIMEErrors) {
    {
#line 628
    addheader((char *)"MIME-Version", (char *)"1.0", 0, ee);
#line 629
    tmp___6 = curtime();
#line 629
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%s.%ld/%.100s", ee->e_id, tmp___6,
                MyHostName);
#line 631
    ee->e_msgboundary = sm_rpool_strdup_x(ee->e_rpool, (char const   *)(buf___16));
#line 632
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "multipart/report; report-type=delivery-status;\n\tboundary=\"%s\"",
                ee->e_msgboundary);
#line 639
    addheader((char *)"Content-Type", buf___16, 0, ee);
#line 641
    p = hvalue((char *)"Content-Transfer-Encoding", e->e_header);
    }
#line 642
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 642
      tmp___7 = sm_strcasecmp((char const   *)p, "binary");
      }
#line 642
      if (tmp___7 != 0) {
#line 643
        p = (char *)((void *)0);
      }
    }
#line 644
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 644
      if ((e->e_flags & 131072UL) != 0UL) {
#line 645
        p = (char *)"8bit";
      }
    }
#line 646
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 647
      addheader((char *)"Content-Transfer-Encoding", p, 0, ee);
      }
    }
  }
  {
#line 649
  tmp___10 = strncmp((char const   *)msg, "Warning:", (size_t )8);
  }
#line 649
  if (tmp___10 == 0) {
    {
#line 651
    addheader((char *)"Subject", msg, 0, ee);
#line 652
    p = (char *)"warning-timeout";
    }
  } else {
    {
#line 654
    tmp___9 = strncmp((char const   *)msg, "Postmaster warning:", (size_t )19);
    }
#line 654
    if (tmp___9 == 0) {
      {
#line 656
      addheader((char *)"Subject", msg, 0, ee);
#line 657
      p = (char *)"postmaster-warning";
      }
    } else {
      {
#line 659
      tmp___8 = strcmp((char const   *)msg, "Return receipt");
      }
#line 659
      if (tmp___8 == 0) {
        {
#line 661
        addheader((char *)"Subject", msg, 0, ee);
#line 662
        p = (char *)"return-receipt";
        }
      } else
#line 664
      if ((flags & 2) != 0) {
        {
#line 666
        sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Postmaster notify: see transcript for details");
#line 668
        addheader((char *)"Subject", buf___16, 0, ee);
#line 669
        p = (char *)"postmaster-notification";
        }
      } else {
        {
#line 673
        sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Returned mail: see transcript for details");
#line 675
        addheader((char *)"Subject", buf___16, 0, ee);
#line 676
        p = (char *)"failure";
        }
      }
    }
  }
  {
#line 678
  sm_snprintf(buf___16, (size_t )sizeof(buf___16), "auto-generated (%s)", p);
#line 679
  addheader((char *)"Auto-Submitted", buf___16, 0, ee);
#line 682
  expand((char *)"\201n", buf___16, (size_t )sizeof(buf___16), e);
#line 683
  tmp___11 = parseaddr(buf___16, & ee->e_from, 49, '\000', (char **)((void *)0), e,
                       0);
  }
#line 683
  if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
    {
#line 686
    syserr("553 5.3.5 Can\'t parse myself!");
#line 687
    ExitStat = 70;
#line 688
    returndepth --;
    }
#line 689
    return (-1);
  }
  {
#line 691
  ee->e_from.q_flags &= 0xfffffffffffffc3fUL;
#line 692
  ee->e_from.q_flags |= 128UL;
#line 693
  ee->e_sender = ee->e_from.q_paddr;
#line 696
  CurEnv = ee;
#line 697
  macdefine_tagged(& ee->e_macro, (ARGCLASS_T )2, 'f', (char *)"\201n", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                   697, SmHeapGroup);
#line 698
  macdefine_tagged(& ee->e_macro, (ARGCLASS_T )2, 'x', (char *)"Mail Delivery Subsystem",
                   (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                   698, SmHeapGroup);
#line 699
  eatheader(ee, 1, 1);
#line 702
  markstats(ee, (ADDRESS *)((void *)0), 'n');
#line 705
  sendall(ee, 'i');
#line 708
  dropenvelope(ee, 1, 0);
#line 709
  sm_rpool_free(ee->e_rpool);
#line 710
  CurEnv = oldcur;
#line 711
  returndepth --;
  }
#line 714
  if ((unsigned long )ee->e_parent == (unsigned long )((void *)0)) {
#line 716
    return (0);
  } else
#line 714
  if (! (((ee->e_parent)->e_flags & 128UL) != 0UL)) {
#line 716
    return (0);
  }
#line 717
  q = ee->e_sendqueue;
  {
#line 717
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 717
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 717
      goto while_break___0;
    }
#line 719
    if ((int )q->q_state == 3) {
#line 720
      return (0);
    } else
#line 719
    if ((int )q->q_state == 4) {
#line 720
      return (0);
    } else
#line 719
    if ((int )q->q_state == 1) {
#line 720
      return (0);
    }
#line 717
    q = q->q_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 722
  return (-1);
}
}
#line 743 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
static bool errbody(struct mailer_con_info *mci , ENVELOPE *e , char *separator ) 
{ 
  bool printheader ;
  bool sendbody ;
  bool pm_notify ;
  int save_errno ;
  register SM_FILE_T *xfile ;
  char *p ;
  register ADDRESS *q ;
  char actual[2048] ;
  char buf___16[2048] ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  bool tmp___13 ;
  bool tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;
  long sff ;
  bool tmp___17 ;
  char *tmp___18 ;
  bool tmp___19 ;
  bool tmp___20 ;
  bool tmp___21 ;
  bool tmp___22 ;
  char *tmp___23 ;
  bool tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  bool tmp___27 ;
  char *tmp___28 ;
  bool tmp___29 ;
  bool tmp___30 ;
  bool tmp___31 ;
  char *tmp___32 ;
  bool tmp___33 ;
  char *tmp___34 ;
  bool tmp___35 ;
  bool tmp___36 ;
  bool tmp___37 ;
  char *tmp___38 ;
  bool tmp___39 ;
  char *tmp___40 ;
  bool tmp___41 ;
  bool tmp___42 ;
  bool tmp___43 ;
  bool tmp___44 ;
  bool tmp___45 ;
  char *tmp___46 ;
  int *tmp___47 ;
  bool tmp___48 ;
  bool tmp___49 ;
  bool tmp___50 ;
  bool tmp___51 ;
  char *tmp___52 ;
  bool tmp___53 ;
  bool tmp___54 ;
  bool tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  bool tmp___58 ;
  time_t dbyd ;
  char *tmp___59 ;
  char *tmp___60 ;
  bool tmp___61 ;
  char *action ;
  bool tmp___62 ;
  bool tmp___63 ;
  int tmp___64 ;
  char *tmp___65 ;
  bool tmp___66 ;
  bool tmp___67 ;
  int tmp___68 ;
  bool tmp___69 ;
  bool tmp___70 ;
  size_t tmp___71 ;
  bool tmp___72 ;
  bool tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  bool tmp___76 ;
  time_t xdate ;
  char *tmp___77 ;
  char *tmp___78 ;
  bool tmp___79 ;
  bool tmp___80 ;
  int tmp___81 ;
  char const   *tmp___82 ;
  bool tmp___83 ;
  bool tmp___84 ;
  char const   *tmp___85 ;
  bool tmp___86 ;
  int tmp___87 ;
  bool tmp___88 ;
  bool tmp___89 ;
  int *tmp___90 ;
  bool tmp___91 ;
  int *tmp___92 ;
  bool tmp___93 ;
  bool tmp___94 ;
  bool tmp___95 ;
  bool tmp___96 ;
  bool tmp___97 ;
  bool tmp___98 ;
  bool tmp___99 ;
  int tmp___100 ;
  int *tmp___101 ;
  void *__cil_tmp120 ;
  void *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;

  {
#line 755
  q = (ADDRESS *)((void *)0);
#line 759
  if ((mci->mci_flags & 512UL) != 0UL) {
    {
#line 761
    tmp = putline((char *)"", mci);
    }
#line 761
    if (! tmp) {
#line 762
      goto writeerr;
    }
#line 763
    mci->mci_flags &= 0xfffffffffffffdffUL;
  }
#line 765
  if ((unsigned long )e->e_parent == (unsigned long )((void *)0)) {
    {
#line 767
    syserr("errbody: null parent");
#line 768
    tmp___0 = putline((char *)"   ----- Original message lost -----\n", mci);
    }
#line 768
    if (! tmp___0) {
#line 769
      goto writeerr;
    }
#line 770
    return (1);
  }
#line 777
  if ((unsigned long )e->e_msgboundary != (unsigned long )((void *)0)) {
    {
#line 779
    sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, "--", e->e_msgboundary);
#line 780
    tmp___1 = putline((char *)"This is a MIME-encapsulated message", mci);
    }
#line 780
    if (tmp___1) {
      {
#line 780
      tmp___2 = putline((char *)"", mci);
      }
#line 780
      if (tmp___2) {
        {
#line 780
        tmp___3 = putline(buf___16, mci);
        }
#line 780
        if (tmp___3) {
          {
#line 780
          tmp___4 = putline((char *)"", mci);
          }
#line 780
          if (! tmp___4) {
#line 784
            goto writeerr;
          }
        } else {
#line 784
          goto writeerr;
        }
      } else {
#line 784
        goto writeerr;
      }
    } else {
#line 784
      goto writeerr;
    }
  }
  {
#line 791
  pm_notify = 0;
#line 792
  p = hvalue((char *)"subject", e->e_header);
  }
#line 793
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 793
    tmp___5 = strncmp((char const   *)p, "Postmaster ", (size_t )11);
    }
#line 793
    if (tmp___5 == 0) {
#line 794
      pm_notify = 1;
    } else {
#line 793
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 797
    q = (e->e_parent)->e_sendqueue;
    {
#line 797
    while (1) {
      while_continue: /* CIL Label */ ;
#line 797
      if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 797
        goto while_break;
      }
#line 799
      if ((int )q->q_state == 2) {
#line 800
        goto while_break;
      }
#line 797
      q = q->q_next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 803
  if (! pm_notify) {
#line 803
    if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 803
      if (! (((e->e_parent)->e_flags & 48UL) != 0UL)) {
        {
#line 806
        tmp___6 = putline((char *)"    **********************************************",
                          mci);
        }
#line 806
        if (tmp___6) {
          {
#line 806
          tmp___7 = putline((char *)"    **      THIS IS A WARNING MESSAGE ONLY      **",
                            mci);
          }
#line 806
          if (tmp___7) {
            {
#line 806
            tmp___8 = putline((char *)"    **  YOU DO NOT NEED TO RESEND YOUR MESSAGE  **",
                              mci);
            }
#line 806
            if (tmp___8) {
              {
#line 806
              tmp___9 = putline((char *)"    **********************************************",
                                mci);
              }
#line 806
              if (tmp___9) {
                {
#line 806
                tmp___10 = putline((char *)"", mci);
                }
#line 806
                if (! tmp___10) {
#line 815
                  goto writeerr;
                }
              } else {
#line 815
                goto writeerr;
              }
            } else {
#line 815
              goto writeerr;
            }
          } else {
#line 815
            goto writeerr;
          }
        } else {
#line 815
          goto writeerr;
        }
      }
    }
  }
  {
#line 817
  tmp___11 = ctime((time_t const   *)(& (e->e_parent)->e_ctime));
#line 817
  tmp___12 = arpadate(tmp___11);
#line 817
  sm_snprintf(buf___16, (size_t )sizeof(buf___16), "The original message was received at %s",
              tmp___12);
#line 820
  tmp___13 = putline(buf___16, mci);
  }
#line 820
  if (! tmp___13) {
#line 821
    goto writeerr;
  }
  {
#line 822
  expand((char *)"from \201_", buf___16, (size_t )sizeof(buf___16), e->e_parent);
#line 823
  tmp___14 = putline(buf___16, mci);
  }
#line 823
  if (! tmp___14) {
#line 824
    goto writeerr;
  }
#line 827
  if (pm_notify) {
#line 827
    if ((unsigned long )(e->e_parent)->e_id != (unsigned long )((void *)0)) {
      {
#line 829
      sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, "with id ", (e->e_parent)->e_id);
#line 831
      tmp___15 = putline(buf___16, mci);
      }
#line 831
      if (! tmp___15) {
#line 832
        goto writeerr;
      }
    }
  }
  {
#line 834
  tmp___16 = putline((char *)"", mci);
  }
#line 834
  if (! tmp___16) {
#line 835
    goto writeerr;
  }
#line 841
  if ((unsigned long )ErrMsgFile != (unsigned long )((void *)0)) {
#line 841
    if (! (((e->e_parent)->e_flags & 16UL) != 0UL)) {
#line 844
      if ((int )*ErrMsgFile == 47) {
#line 846
        sff = 132L;
#line 848
        if (DontLockReadFiles) {
#line 849
          sff |= 16384L;
        }
#line 850
        if (! (DontBlameSendmail[24UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 24UL % (8UL * sizeof(int ))))) {
#line 852
          sff |= 256L;
        }
        {
#line 853
        xfile = safefopen(ErrMsgFile, 0, 292, sff);
        }
#line 854
        if ((unsigned long )xfile != (unsigned long )((void *)0)) {
          {
#line 856
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 856
            tmp___18 = sm_io_fgets(xfile, -2, buf___16, (int )sizeof(buf___16));
            }
#line 856
            if (! ((unsigned long )tmp___18 != (unsigned long )((void *)0))) {
#line 856
              goto while_break___0;
            }
            {
#line 859
            translate_dollars(buf___16);
#line 860
            expand(buf___16, buf___16, (size_t )sizeof(buf___16), e);
#line 861
            tmp___17 = putline(buf___16, mci);
            }
#line 861
            if (! tmp___17) {
#line 862
              goto writeerr;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 864
          sm_io_close(xfile, -2);
#line 865
          tmp___19 = putline((char *)"\n", mci);
          }
#line 865
          if (! tmp___19) {
#line 866
            goto writeerr;
          }
        }
      } else {
        {
#line 871
        expand(ErrMsgFile, buf___16, (size_t )sizeof(buf___16), e);
#line 872
        tmp___20 = putline(buf___16, mci);
        }
#line 872
        if (tmp___20) {
          {
#line 872
          tmp___21 = putline((char *)"", mci);
          }
#line 872
          if (! tmp___21) {
#line 873
            goto writeerr;
          }
        } else {
#line 873
          goto writeerr;
        }
      }
    }
  }
#line 882
  printheader = 1;
#line 883
  q = (e->e_parent)->e_sendqueue;
  {
#line 883
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 883
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 883
      goto while_break___1;
    }
#line 885
    if (! ((int )q->q_state == 2)) {
#line 887
      goto __Cont;
    } else
#line 885
    if (! ((q->q_flags & 128UL) != 0UL)) {
#line 887
      goto __Cont;
    }
#line 889
    if (printheader) {
      {
#line 891
      tmp___22 = putline((char *)"   ----- The following addresses had permanent fatal errors -----",
                         mci);
      }
#line 891
      if (! tmp___22) {
#line 893
        goto writeerr;
      }
#line 894
      printheader = 0;
    }
    {
#line 897
    tmp___23 = shortenstring((char const   *)q->q_paddr, (size_t )203);
#line 897
    sm_strlcpy(buf___16, (char const   *)tmp___23, (ssize_t )sizeof(buf___16));
#line 899
    tmp___24 = putline(buf___16, mci);
    }
#line 899
    if (! tmp___24) {
#line 900
      goto writeerr;
    }
#line 901
    if ((unsigned long )q->q_rstatus != (unsigned long )((void *)0)) {
      {
#line 903
      tmp___25 = exitstat(q->q_rstatus);
#line 903
      tmp___26 = shortenstring((char const   *)tmp___25, (size_t )203);
#line 903
      sm_snprintf(buf___16, (size_t )sizeof(buf___16), "    (reason: %s)", tmp___26);
#line 907
      tmp___27 = putline(buf___16, mci);
      }
#line 907
      if (! tmp___27) {
#line 908
        goto writeerr;
      }
    }
#line 910
    if ((unsigned long )q->q_alias != (unsigned long )((void *)0)) {
      {
#line 912
      tmp___28 = shortenstring((char const   *)(q->q_alias)->q_paddr, (size_t )203);
#line 912
      sm_snprintf(buf___16, (size_t )sizeof(buf___16), "    (expanded from: %s)",
                  tmp___28);
#line 916
      tmp___29 = putline(buf___16, mci);
      }
#line 916
      if (! tmp___29) {
#line 917
        goto writeerr;
      }
    }
    __Cont: /* CIL Label */ 
#line 883
    q = q->q_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 920
  if (! printheader) {
    {
#line 920
    tmp___30 = putline((char *)"", mci);
    }
#line 920
    if (! tmp___30) {
#line 921
      goto writeerr;
    }
  }
#line 924
  printheader = 1;
#line 925
  q = (e->e_parent)->e_sendqueue;
  {
#line 925
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 925
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 925
      goto while_break___2;
    }
#line 927
    if ((int )q->q_state == 2) {
#line 931
      goto __Cont___0;
    } else
#line 927
    if (! ((q->q_flags & 2UL) != 0UL)) {
#line 931
      goto __Cont___0;
    } else
#line 927
    if (! ((q->q_flags & 65536UL) != 0UL)) {
#line 931
      goto __Cont___0;
    } else
#line 927
    if (! ((q->q_flags & 8192UL) != 0UL)) {
#line 931
      goto __Cont___0;
    }
#line 933
    if (printheader) {
      {
#line 935
      tmp___31 = putline((char *)"   ----- The following addresses had transient non-fatal errors -----",
                         mci);
      }
#line 935
      if (! tmp___31) {
#line 937
        goto writeerr;
      }
#line 938
      printheader = 0;
    }
    {
#line 941
    tmp___32 = shortenstring((char const   *)q->q_paddr, (size_t )203);
#line 941
    sm_strlcpy(buf___16, (char const   *)tmp___32, (ssize_t )sizeof(buf___16));
#line 943
    tmp___33 = putline(buf___16, mci);
    }
#line 943
    if (! tmp___33) {
#line 944
      goto writeerr;
    }
#line 945
    if ((unsigned long )q->q_alias != (unsigned long )((void *)0)) {
      {
#line 947
      tmp___34 = shortenstring((char const   *)(q->q_alias)->q_paddr, (size_t )203);
#line 947
      sm_snprintf(buf___16, (size_t )sizeof(buf___16), "    (expanded from: %s)",
                  tmp___34);
#line 951
      tmp___35 = putline(buf___16, mci);
      }
#line 951
      if (! tmp___35) {
#line 952
        goto writeerr;
      }
    }
    __Cont___0: /* CIL Label */ 
#line 925
    q = q->q_next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 955
  if (! printheader) {
    {
#line 955
    tmp___36 = putline((char *)"", mci);
    }
#line 955
    if (! tmp___36) {
#line 956
      goto writeerr;
    }
  }
#line 959
  printheader = 1;
#line 960
  q = (e->e_parent)->e_sendqueue;
  {
#line 960
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 960
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 960
      goto while_break___3;
    }
#line 962
    if ((int )q->q_state == 2) {
#line 966
      goto __Cont___1;
    } else
#line 962
    if (! ((q->q_flags & 2UL) != 0UL)) {
#line 966
      goto __Cont___1;
    } else
#line 962
    if ((q->q_flags & 65536UL) != 0UL) {
#line 966
      goto __Cont___1;
    } else
#line 962
    if ((q->q_flags & 8192UL) != 0UL) {
#line 966
      goto __Cont___1;
    } else
#line 967
    if ((q->q_flags & 131072UL) != 0UL) {
#line 968
      p = (char *)"Deliver-By notify: relayed";
    } else
#line 969
    if ((q->q_flags & 32768UL) != 0UL) {
#line 970
      p = (char *)"Deliver-By trace: relayed";
    } else
#line 971
    if (! ((q->q_flags & 64UL) != 0UL)) {
#line 972
      goto __Cont___1;
    } else
#line 973
    if ((q->q_flags & 1024UL) != 0UL) {
#line 974
      p = (char *)"relayed to non-DSN-aware mailer";
    } else
#line 975
    if ((q->q_flags & 4096UL) != 0UL) {
#line 977
      if ((q->q_flags & 2048UL) != 0UL) {
#line 978
        p = (char *)"successfully delivered to mailing list";
      } else {
#line 980
        p = (char *)"successfully delivered to mailbox";
      }
    } else
#line 982
    if ((q->q_flags & 2048UL) != 0UL) {
#line 983
      p = (char *)"expanded by alias";
    } else {
#line 985
      goto __Cont___1;
    }
#line 987
    if (printheader) {
      {
#line 989
      tmp___37 = putline((char *)"   ----- The following addresses had successful delivery notifications -----",
                         mci);
      }
#line 989
      if (! tmp___37) {
#line 991
        goto writeerr;
      }
#line 992
      printheader = 0;
    }
    {
#line 995
    tmp___38 = shortenstring((char const   *)q->q_paddr, (size_t )203);
#line 995
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%s  (%s)", tmp___38, p);
#line 997
    tmp___39 = putline(buf___16, mci);
    }
#line 997
    if (! tmp___39) {
#line 998
      goto writeerr;
    }
#line 999
    if ((unsigned long )q->q_alias != (unsigned long )((void *)0)) {
      {
#line 1001
      tmp___40 = shortenstring((char const   *)(q->q_alias)->q_paddr, (size_t )203);
#line 1001
      sm_snprintf(buf___16, (size_t )sizeof(buf___16), "    (expanded from: %s)",
                  tmp___40);
#line 1005
      tmp___41 = putline(buf___16, mci);
      }
#line 1005
      if (! tmp___41) {
#line 1006
        goto writeerr;
      }
    }
    __Cont___1: /* CIL Label */ 
#line 960
    q = q->q_next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1009
  if (! printheader) {
    {
#line 1009
    tmp___42 = putline((char *)"", mci);
    }
#line 1009
    if (! tmp___42) {
#line 1010
      goto writeerr;
    }
  }
  {
#line 1016
  sm_io_flush(& SmIoF[1], -2);
  }
#line 1017
  if ((unsigned long )(e->e_parent)->e_xfp == (unsigned long )((void *)0)) {
    {
#line 1019
    tmp___43 = putline((char *)"   ----- Transcript of session is unavailable -----\n",
                       mci);
    }
#line 1019
    if (! tmp___43) {
#line 1021
      goto writeerr;
    }
  } else {
    {
#line 1025
    printheader = 1;
#line 1026
    bfrewind((e->e_parent)->e_xfp);
    }
#line 1027
    if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
      {
#line 1028
      sm_io_flush(e->e_xfp, -2);
      }
    }
    {
#line 1029
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1029
      tmp___46 = sm_io_fgets((e->e_parent)->e_xfp, -2, buf___16, (int )sizeof(buf___16));
      }
#line 1029
      if (! ((unsigned long )tmp___46 != (unsigned long )((void *)0))) {
#line 1029
        goto while_break___4;
      }
#line 1032
      if (printheader) {
        {
#line 1032
        tmp___44 = putline((char *)"   ----- Transcript of session follows -----\n",
                           mci);
        }
#line 1032
        if (! tmp___44) {
#line 1034
          goto writeerr;
        }
      }
      {
#line 1035
      printheader = 0;
#line 1036
      tmp___45 = putline(buf___16, mci);
      }
#line 1036
      if (! tmp___45) {
#line 1037
        goto writeerr;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 1040
  tmp___47 = __errno_location();
#line 1040
  *tmp___47 = 0;
  }
#line 1047
  if ((unsigned long )e->e_msgboundary != (unsigned long )((void *)0)) {
    {
#line 1049
    sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, "--", e->e_msgboundary);
#line 1050
    tmp___48 = putline((char *)"", mci);
    }
#line 1050
    if (tmp___48) {
      {
#line 1050
      tmp___49 = putline(buf___16, mci);
      }
#line 1050
      if (tmp___49) {
        {
#line 1050
        tmp___50 = putline((char *)"Content-Type: message/delivery-status", mci);
        }
#line 1050
        if (tmp___50) {
          {
#line 1050
          tmp___51 = putline((char *)"", mci);
          }
#line 1050
          if (! tmp___51) {
#line 1054
            goto writeerr;
          }
        } else {
#line 1054
          goto writeerr;
        }
      } else {
#line 1054
        goto writeerr;
      }
    } else {
#line 1054
      goto writeerr;
    }
#line 1061
    if ((unsigned long )(e->e_parent)->e_envid != (unsigned long )((void *)0)) {
      {
#line 1063
      tmp___52 = xuntextify((e->e_parent)->e_envid);
#line 1063
      sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Original-Envelope-Id: %.800s",
                  tmp___52);
#line 1066
      tmp___53 = putline(buf___16, mci);
      }
#line 1066
      if (! tmp___53) {
#line 1067
        goto writeerr;
      }
    }
    {
#line 1071
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Reporting-MTA: dns; %.800s",
                MyHostName);
#line 1073
    tmp___54 = putline(buf___16, mci);
    }
#line 1073
    if (! tmp___54) {
#line 1074
      goto writeerr;
    }
#line 1079
    if ((unsigned long )RealHostName != (unsigned long )((void *)0)) {
#line 1082
      if ((unsigned long )(e->e_parent)->e_from.q_mailer == (unsigned long )((void *)0)) {
#line 1084
        p = (char *)"dns";
      } else {
#line 1082
        p = ((e->e_parent)->e_from.q_mailer)->m_mtatype;
#line 1082
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1084
          p = (char *)"dns";
        }
      }
      {
#line 1085
      sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Received-From-MTA: %s; %.800s",
                  p, RealHostName);
#line 1088
      tmp___55 = putline(buf___16, mci);
      }
#line 1088
      if (! tmp___55) {
#line 1089
        goto writeerr;
      }
    }
    {
#line 1093
    tmp___56 = ctime((time_t const   *)(& (e->e_parent)->e_ctime));
#line 1093
    tmp___57 = arpadate(tmp___56);
#line 1093
    sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, "Arrival-Date: ", tmp___57);
#line 1095
    tmp___58 = putline(buf___16, mci);
    }
#line 1095
    if (! tmp___58) {
#line 1096
      goto writeerr;
    }
#line 1099
    if ((e->e_parent)->e_dlvr_flag != 0) {
      {
#line 1103
      dbyd = (e->e_parent)->e_ctime + (e->e_parent)->e_deliver_by;
#line 1104
      tmp___59 = ctime((time_t const   *)(& dbyd));
#line 1104
      tmp___60 = arpadate(tmp___59);
#line 1104
      sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, "Deliver-By-Date: ", tmp___60);
#line 1107
      tmp___61 = putline(buf___16, mci);
      }
#line 1107
      if (! tmp___61) {
#line 1108
        goto writeerr;
      }
    }
#line 1115
    q = (e->e_parent)->e_sendqueue;
    {
#line 1115
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1115
      if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 1115
        goto while_break___5;
      }
#line 1119
      if ((int )q->q_state == 2) {
#line 1122
        if ((q->q_flags & 512UL) != 0UL) {
#line 1122
          if (! ((q->q_flags & 128UL) != 0UL)) {
#line 1124
            goto __Cont___2;
          }
        }
#line 1125
        action = (char *)"failed";
      } else
#line 1127
      if (! ((q->q_flags & 2UL) != 0UL)) {
#line 1128
        goto __Cont___2;
      } else
#line 1129
      if ((q->q_flags & 4096UL) != 0UL) {
#line 1131
        if ((q->q_flags & 2048UL) != 0UL) {
#line 1132
          action = (char *)"delivered (to mailing list)";
        } else {
#line 1134
          action = (char *)"delivered (to mailbox)";
        }
      } else
#line 1136
      if ((q->q_flags & 1024UL) != 0UL) {
#line 1137
        action = (char *)"relayed (to non-DSN-aware mailer)";
      } else
#line 1138
      if ((q->q_flags & 2048UL) != 0UL) {
#line 1139
        action = (char *)"expanded (to multi-recipient alias)";
      } else
#line 1140
      if ((q->q_flags & 8192UL) != 0UL) {
#line 1141
        action = (char *)"delayed";
      } else
#line 1142
      if ((q->q_flags & 32768UL) != 0UL) {
#line 1143
        action = (char *)"relayed (Deliver-By trace mode)";
      } else
#line 1144
      if ((q->q_flags & 65536UL) != 0UL) {
#line 1145
        action = (char *)"delayed (Deliver-By notify mode)";
      } else
#line 1146
      if ((q->q_flags & 131072UL) != 0UL) {
#line 1147
        action = (char *)"relayed (Deliver-By notify mode)";
      } else {
#line 1149
        goto __Cont___2;
      }
      {
#line 1151
      tmp___62 = putline((char *)"", mci);
      }
#line 1151
      if (! tmp___62) {
#line 1152
        goto writeerr;
      }
#line 1155
      if ((unsigned long )q->q_orcpt != (unsigned long )((void *)0)) {
        {
#line 1157
        sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Original-Recipient: %.800s",
                    q->q_orcpt);
#line 1160
        tmp___63 = putline(buf___16, mci);
        }
#line 1160
        if (! tmp___63) {
#line 1161
          goto writeerr;
        }
      }
#line 1165
      actual[0] = (char )'\000';
#line 1166
      if ((int )*(q->q_user + 0) != 0) {
#line 1168
        if ((unsigned long )q->q_mailer != (unsigned long )((void *)0)) {
#line 1168
          if ((unsigned long )(q->q_mailer)->m_addrtype != (unsigned long )((void *)0)) {
#line 1170
            p = (q->q_mailer)->m_addrtype;
          } else {
#line 1172
            p = (char *)"rfc822";
          }
        } else {
#line 1172
          p = (char *)"rfc822";
        }
        {
#line 1174
        tmp___64 = sm_strcasecmp((char const   *)p, "rfc822");
        }
#line 1174
        if (tmp___64 == 0) {
          {
#line 1174
          tmp___65 = strchr((char const   *)q->q_user, '@');
          }
#line 1174
          if ((unsigned long )tmp___65 == (unsigned long )((void *)0)) {
            {
#line 1177
            sm_snprintf(actual, (size_t )sizeof(actual), "%s; %.700s@%.100s", p, q->q_user,
                        MyHostName);
            }
          } else {
            {
#line 1185
            sm_snprintf(actual, (size_t )sizeof(actual), "%s; %.800s", p, q->q_user);
            }
          }
        } else {
          {
#line 1185
          sm_snprintf(actual, (size_t )sizeof(actual), "%s; %.800s", p, q->q_user);
          }
        }
      }
#line 1193
      if ((unsigned long )q->q_finalrcpt == (unsigned long )((void *)0)) {
        {
#line 1196
        sm_syslog(3, (char const   *)e->e_id, "returntosender: q_finalrcpt is NULL");
        }
#line 1200
        if ((int )actual[0] != 0) {
          {
#line 1201
          q->q_finalrcpt = sm_rpool_strdup_x(e->e_rpool, (char const   *)(actual));
          }
        }
      }
#line 1205
      if ((unsigned long )q->q_finalrcpt != (unsigned long )((void *)0)) {
        {
#line 1207
        sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Final-Recipient: %s", q->q_finalrcpt);
#line 1210
        tmp___66 = putline(buf___16, mci);
        }
#line 1210
        if (! tmp___66) {
#line 1211
          goto writeerr;
        }
      }
#line 1215
      if ((int )actual[0] != 0) {
#line 1215
        if ((unsigned long )q->q_finalrcpt != (unsigned long )((void *)0)) {
          {
#line 1215
          tmp___68 = strcmp((char const   *)(actual), (char const   *)q->q_finalrcpt);
          }
#line 1215
          if (tmp___68 != 0) {
            {
#line 1222
            sm_snprintf(buf___16, (size_t )sizeof(buf___16), "X-Actual-Recipient: %s",
                        actual);
#line 1225
            tmp___67 = putline(buf___16, mci);
            }
#line 1225
            if (! tmp___67) {
#line 1226
              goto writeerr;
            }
          }
        }
      }
      {
#line 1230
      sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, "Action: ", action);
#line 1232
      tmp___69 = putline(buf___16, mci);
      }
#line 1232
      if (! tmp___69) {
#line 1233
        goto writeerr;
      }
#line 1236
      if ((unsigned long )q->q_status != (unsigned long )((void *)0)) {
#line 1237
        p = q->q_status;
      } else
#line 1238
      if ((int )q->q_state == 2) {
#line 1239
        p = (char *)"5.0.0";
      } else
#line 1240
      if ((int )q->q_state == 3) {
#line 1241
        p = (char *)"4.0.0";
      } else {
#line 1243
        p = (char *)"2.0.0";
      }
      {
#line 1244
      sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, "Status: ", p);
#line 1245
      tmp___70 = putline(buf___16, mci);
      }
#line 1245
      if (! tmp___70) {
#line 1246
        goto writeerr;
      }
#line 1249
      if ((unsigned long )q->q_statmta != (unsigned long )((void *)0)) {
#line 1251
        if ((unsigned long )q->q_mailer == (unsigned long )((void *)0)) {
#line 1253
          p = (char *)"dns";
        } else {
#line 1251
          p = (q->q_mailer)->m_mtatype;
#line 1251
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1253
            p = (char *)"dns";
          }
        }
        {
#line 1254
        sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Remote-MTA: %s; %.800s",
                    p, q->q_statmta);
#line 1257
        tmp___71 = strlen((char const   *)(buf___16));
#line 1257
        p = & buf___16[tmp___71 - 1U];
        }
#line 1258
        if ((int )*p == 46) {
#line 1259
          *p = (char )'\000';
        }
        {
#line 1260
        tmp___72 = putline(buf___16, mci);
        }
#line 1260
        if (! tmp___72) {
#line 1261
          goto writeerr;
        }
      }
#line 1265
      if ((unsigned long )q->q_rstatus != (unsigned long )((void *)0)) {
#line 1267
        p = (q->q_mailer)->m_diagtype;
#line 1268
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1269
          p = (char *)"smtp";
        }
        {
#line 1270
        sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Diagnostic-Code: %s; %.800s",
                    p, q->q_rstatus);
#line 1273
        tmp___73 = putline(buf___16, mci);
        }
#line 1273
        if (! tmp___73) {
#line 1274
          goto writeerr;
        }
      }
#line 1278
      if (q->q_statdate == 0L) {
        {
#line 1279
        q->q_statdate = curtime();
        }
      }
      {
#line 1280
      tmp___74 = ctime((time_t const   *)(& q->q_statdate));
#line 1280
      tmp___75 = arpadate(tmp___74);
#line 1280
      sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, "Last-Attempt-Date: ",
                  tmp___75);
#line 1283
      tmp___76 = putline(buf___16, mci);
      }
#line 1283
      if (! tmp___76) {
#line 1284
        goto writeerr;
      }
#line 1287
      if ((int )q->q_state == 3) {
        {
#line 1291
        xdate = (e->e_parent)->e_ctime + TimeOuts.to_q_return[(e->e_parent)->e_timeoutclass];
#line 1293
        tmp___77 = ctime((time_t const   *)(& xdate));
#line 1293
        tmp___78 = arpadate(tmp___77);
#line 1293
        sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, "Will-Retry-Until: ",
                    tmp___78);
#line 1296
        tmp___79 = putline(buf___16, mci);
        }
#line 1296
        if (! tmp___79) {
#line 1297
          goto writeerr;
        }
      }
      __Cont___2: /* CIL Label */ 
#line 1115
      q = q->q_next;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 1307
  tmp___80 = putline((char *)"", mci);
  }
#line 1307
  if (! tmp___80) {
#line 1308
    goto writeerr;
  }
#line 1309
  if (((e->e_parent)->e_flags & 2097152UL) != 0UL) {
#line 1311
    if (! (((e->e_parent)->e_flags & 4UL) != 0UL)) {
#line 1311
      if (! ((e->e_flags & 4UL) != 0UL)) {
#line 1311
        tmp___81 = 1;
      } else {
#line 1311
        tmp___81 = 0;
      }
    } else {
#line 1311
      tmp___81 = 0;
    }
#line 1311
    sendbody = tmp___81;
#line 1314
    if ((unsigned long )e->e_msgboundary == (unsigned long )((void *)0)) {
#line 1316
      if (sendbody) {
#line 1316
        tmp___82 = "   ----- Original message follows -----\n";
      } else {
#line 1316
        tmp___82 = "   ----- Message header follows -----\n";
      }
      {
#line 1316
      tmp___83 = putline((char *)tmp___82, mci);
      }
#line 1316
      if (! tmp___83) {
#line 1322
        goto writeerr;
      }
    } else {
      {
#line 1327
      sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, "--", e->e_msgboundary);
#line 1330
      tmp___84 = putline(buf___16, mci);
      }
#line 1330
      if (! tmp___84) {
#line 1331
        goto writeerr;
      }
#line 1332
      if (sendbody) {
#line 1332
        tmp___85 = "message/rfc822";
      } else {
#line 1332
        tmp___85 = "text/rfc822-headers";
      }
      {
#line 1332
      sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, "Content-Type: ", tmp___85);
#line 1335
      tmp___86 = putline(buf___16, mci);
      }
#line 1335
      if (! tmp___86) {
#line 1336
        goto writeerr;
      }
      {
#line 1338
      p = hvalue((char *)"Content-Transfer-Encoding", (e->e_parent)->e_header);
      }
#line 1340
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 1340
        tmp___87 = sm_strcasecmp((char const   *)p, "binary");
        }
#line 1340
        if (tmp___87 != 0) {
#line 1341
          p = (char *)((void *)0);
        }
      }
#line 1342
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1342
        if (((e->e_parent)->e_flags & 131072UL) != 0UL) {
#line 1344
          p = (char *)"8bit";
        }
      }
#line 1345
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 1347
        sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Content-Transfer-Encoding: %s",
                    p);
#line 1350
        tmp___88 = putline(buf___16, mci);
        }
#line 1350
        if (! tmp___88) {
#line 1351
          goto writeerr;
        }
      }
    }
    {
#line 1354
    tmp___89 = putline((char *)"", mci);
    }
#line 1354
    if (! tmp___89) {
#line 1355
      goto writeerr;
    }
    {
#line 1356
    tmp___90 = __errno_location();
#line 1356
    save_errno = *tmp___90;
#line 1357
    tmp___91 = putheader(mci, (e->e_parent)->e_header, e->e_parent, 0);
    }
#line 1357
    if (! tmp___91) {
#line 1359
      goto writeerr;
    }
    {
#line 1360
    tmp___92 = __errno_location();
#line 1360
    *tmp___92 = save_errno;
    }
#line 1361
    if (sendbody) {
      {
#line 1363
      tmp___93 = putbody(mci, e->e_parent, e->e_msgboundary);
      }
#line 1363
      if (! tmp___93) {
#line 1364
        goto writeerr;
      }
    } else
#line 1366
    if ((unsigned long )e->e_msgboundary == (unsigned long )((void *)0)) {
      {
#line 1368
      tmp___94 = putline((char *)"", mci);
      }
#line 1368
      if (tmp___94) {
        {
#line 1368
        tmp___95 = putline((char *)"   ----- Message body suppressed -----", mci);
        }
#line 1368
        if (! tmp___95) {
#line 1372
          goto writeerr;
        }
      } else {
#line 1372
        goto writeerr;
      }
    }
  } else
#line 1376
  if ((unsigned long )e->e_msgboundary == (unsigned long )((void *)0)) {
    {
#line 1378
    tmp___96 = putline((char *)"  ----- No message was collected -----\n", mci);
    }
#line 1378
    if (! tmp___96) {
#line 1379
      goto writeerr;
    }
  }
#line 1382
  if ((unsigned long )e->e_msgboundary != (unsigned long )((void *)0)) {
    {
#line 1384
    sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 3, "--", e->e_msgboundary, "--");
#line 1386
    tmp___97 = putline((char *)"", mci);
    }
#line 1386
    if (tmp___97) {
      {
#line 1386
      tmp___98 = putline(buf___16, mci);
      }
#line 1386
      if (! tmp___98) {
#line 1387
        goto writeerr;
      }
    } else {
#line 1387
      goto writeerr;
    }
  }
  {
#line 1389
  tmp___99 = putline((char *)"", mci);
  }
#line 1389
  if (tmp___99) {
    {
#line 1389
    tmp___100 = sm_io_flush(mci->mci_out, -2);
    }
#line 1389
    if (tmp___100 == -1) {
#line 1391
      goto writeerr;
    }
  } else {
#line 1391
    goto writeerr;
  }
  {
#line 1397
  tmp___101 = __errno_location();
  }
#line 1397
  if (*tmp___101 != 0) {
    writeerr: 
    {
#line 1400
    syserr("errbody: I/O error");
    }
#line 1401
    return (0);
  }
#line 1403
  return (1);
}
}
#line 1421 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
char *smtptodsn(int smtpstat ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1425
  if (smtpstat < 0) {
#line 1426
    return ((char *)"4.4.2");
  }
  {
#line 1430
  if (smtpstat == 450) {
#line 1430
    goto case_450;
  }
#line 1433
  if (smtpstat == 451) {
#line 1433
    goto case_451;
  }
#line 1436
  if (smtpstat == 452) {
#line 1436
    goto case_452;
  }
#line 1439
  if (smtpstat == 500) {
#line 1439
    goto case_500;
  }
#line 1442
  if (smtpstat == 501) {
#line 1442
    goto case_501;
  }
#line 1445
  if (smtpstat == 502) {
#line 1445
    goto case_502;
  }
#line 1448
  if (smtpstat == 503) {
#line 1448
    goto case_503;
  }
#line 1451
  if (smtpstat == 504) {
#line 1451
    goto case_504;
  }
#line 1454
  if (smtpstat == 550) {
#line 1454
    goto case_550;
  }
#line 1457
  if (smtpstat == 551) {
#line 1457
    goto case_551;
  }
#line 1460
  if (smtpstat == 552) {
#line 1460
    goto case_552;
  }
#line 1463
  if (smtpstat == 553) {
#line 1463
    goto case_553;
  }
#line 1466
  if (smtpstat == 554) {
#line 1466
    goto case_554;
  }
#line 1428
  goto switch_break;
  case_450: /* CIL Label */ 
#line 1431
  return ((char *)"4.2.0");
  case_451: /* CIL Label */ 
#line 1434
  return ((char *)"4.3.0");
  case_452: /* CIL Label */ 
#line 1437
  return ((char *)"4.3.1");
  case_500: /* CIL Label */ 
#line 1440
  return ((char *)"5.5.2");
  case_501: /* CIL Label */ 
#line 1443
  return ((char *)"5.5.4");
  case_502: /* CIL Label */ 
#line 1446
  return ((char *)"5.5.1");
  case_503: /* CIL Label */ 
#line 1449
  return ((char *)"5.5.1");
  case_504: /* CIL Label */ 
#line 1452
  return ((char *)"5.5.4");
  case_550: /* CIL Label */ 
#line 1455
  return ((char *)"5.2.0");
  case_551: /* CIL Label */ 
#line 1458
  return ((char *)"5.1.6");
  case_552: /* CIL Label */ 
#line 1461
  return ((char *)"5.2.2");
  case_553: /* CIL Label */ 
#line 1464
  return ((char *)"5.1.0");
  case_554: /* CIL Label */ 
#line 1467
  return ((char *)"5.0.0");
  switch_break: /* CIL Label */ ;
  }
#line 1470
  if (smtpstat / 100 == 2) {
#line 1471
    return ((char *)"2.0.0");
  }
#line 1472
  if (smtpstat / 100 == 4) {
#line 1473
    return ((char *)"4.0.0");
  }
#line 1474
  return ((char *)"5.0.0");
}
}
#line 1495 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
static char *bp___0  =    (char *)((void *)0);
#line 1496 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
static int bplen  =    0;
#line 1487 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
char *xtextify(char *t , char *taboo ) 
{ 
  register char *p ;
  int l ;
  int nbogus ;
  register int c ;
  char *tmp ;
  void *tmp___0 ;
  register int c___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 1498
  if ((unsigned long )taboo == (unsigned long )((void *)0)) {
#line 1499
    taboo = (char *)"";
  }
#line 1502
  l = 0;
#line 1502
  nbogus = l;
#line 1503
  p = t;
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1503
    if (! ((int )*p != 0)) {
#line 1503
      goto while_break;
    }
#line 1505
    c = (int )*p & 255;
#line 1508
    if (c < 33) {
#line 1510
      nbogus ++;
    } else
#line 1508
    if (c > 126) {
#line 1510
      nbogus ++;
    } else
#line 1508
    if (c == 43) {
#line 1510
      nbogus ++;
    } else
#line 1508
    if (c == 92) {
#line 1510
      nbogus ++;
    } else
#line 1508
    if (c == 40) {
#line 1510
      nbogus ++;
    } else {
      {
#line 1508
      tmp = strchr((char const   *)taboo, c);
      }
#line 1508
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1510
        nbogus ++;
      }
    }
#line 1511
    l ++;
#line 1503
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1513
  if (nbogus < 0) {
    {
#line 1516
    syserr("!xtextify string too long");
    }
  }
#line 1518
  if (nbogus == 0) {
#line 1519
    return (t);
  }
#line 1520
  l += nbogus * 2 + 1;
#line 1523
  if (l > bplen) {
#line 1525
    if ((unsigned long )bp___0 != (unsigned long )((void *)0)) {
      {
#line 1526
      sm_free_tagged((void *)bp___0, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                     1526);
      }
    }
    {
#line 1527
    tmp___0 = sm_malloc_tagged_x((size_t )l, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                                 1527, 0);
#line 1527
    bp___0 = (char *)tmp___0;
#line 1528
    bplen = l;
    }
  }
#line 1532
  p = bp___0;
  {
#line 1532
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1532
    if (! ((int )*t != 0)) {
#line 1532
      goto while_break___0;
    }
#line 1534
    tmp___1 = t;
#line 1534
    t ++;
#line 1534
    c___0 = (int )*tmp___1 & 255;
#line 1537
    if (c___0 < 33) {
#line 1537
      goto _L;
    } else
#line 1537
    if (c___0 > 126) {
#line 1537
      goto _L;
    } else
#line 1537
    if (c___0 == 43) {
#line 1537
      goto _L;
    } else
#line 1537
    if (c___0 == 92) {
#line 1537
      goto _L;
    } else
#line 1537
    if (c___0 == 40) {
#line 1537
      goto _L;
    } else {
      {
#line 1537
      tmp___6 = strchr((char const   *)taboo, c___0);
      }
#line 1537
      if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1540
        tmp___2 = p;
#line 1540
        p ++;
#line 1540
        *tmp___2 = (char )'+';
#line 1541
        tmp___3 = p;
#line 1541
        p ++;
#line 1541
        *tmp___3 = (char )*("0123456789ABCDEF" + (c___0 >> 4));
#line 1542
        tmp___4 = p;
#line 1542
        p ++;
#line 1542
        *tmp___4 = (char )*("0123456789ABCDEF" + (c___0 & 15));
      } else {
#line 1545
        tmp___5 = p;
#line 1545
        p ++;
#line 1545
        *tmp___5 = (char )c___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1547
  *p = (char )'\000';
#line 1548
  return (bp___0);
}
}
#line 1567 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
static char *bp___1  =    (char *)((void *)0);
#line 1568 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
static int bplen___0  =    0;
#line 1561 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
char *xuntextify(char *t ) 
{ 
  register char *p ;
  int l ;
  char *tmp ;
  size_t tmp___0 ;
  register int c ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 1571
  tmp = strchr((char const   *)t, '+');
  }
#line 1571
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1572
    return (t);
  }
  {
#line 1575
  tmp___0 = strlen((char const   *)t);
#line 1575
  l = (int )tmp___0;
  }
#line 1576
  if (l > bplen___0) {
#line 1578
    if ((unsigned long )bp___1 != (unsigned long )((void *)0)) {
      {
#line 1579
      sm_free_tagged((void *)bp___1, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                     1579);
      }
    }
    {
#line 1580
    bp___1 = xalloc_tagged(l, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c",
                           1580);
#line 1581
    bplen___0 = l;
    }
  }
#line 1585
  p = bp___1;
  {
#line 1585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1585
    if (! ((int )*t != 0)) {
#line 1585
      goto while_break;
    }
#line 1587
    c = (int )*t & 255;
#line 1589
    if (c != 43) {
#line 1591
      tmp___1 = p;
#line 1591
      p ++;
#line 1591
      *tmp___1 = (char )c;
#line 1592
      goto __Cont;
    }
#line 1595
    t ++;
#line 1595
    c = (int )*t & 255;
#line 1596
    if (! ((c & -128) == 0)) {
      {
#line 1599
      usrerr("bogus xtext: +%c", c);
#line 1600
      t --;
      }
#line 1601
      goto __Cont;
    } else {
      {
#line 1596
      tmp___2 = __ctype_b_loc();
      }
#line 1596
      if (! ((int const   )*(*tmp___2 + c) & 4096)) {
        {
#line 1599
        usrerr("bogus xtext: +%c", c);
#line 1600
        t --;
        }
#line 1601
        goto __Cont;
      }
    }
    {
#line 1603
    tmp___4 = __ctype_b_loc();
    }
#line 1603
    if ((int const   )*(*tmp___4 + c) & 2048) {
#line 1604
      c -= 48;
    } else {
      {
#line 1605
      tmp___3 = __ctype_b_loc();
      }
#line 1605
      if ((int const   )*(*tmp___3 + c) & 256) {
#line 1606
        c -= 55;
      } else {
#line 1608
        c -= 87;
      }
    }
#line 1609
    *p = (char )(c << 4);
#line 1611
    t ++;
#line 1611
    c = (int )*t & 255;
#line 1612
    if (! ((c & -128) == 0)) {
      {
#line 1615
      usrerr("bogus xtext: +%x%c", (int )*p >> 4, c);
#line 1616
      t --;
      }
#line 1617
      goto __Cont;
    } else {
      {
#line 1612
      tmp___5 = __ctype_b_loc();
      }
#line 1612
      if (! ((int const   )*(*tmp___5 + c) & 4096)) {
        {
#line 1615
        usrerr("bogus xtext: +%x%c", (int )*p >> 4, c);
#line 1616
        t --;
        }
#line 1617
        goto __Cont;
      }
    }
    {
#line 1619
    tmp___7 = __ctype_b_loc();
    }
#line 1619
    if ((int const   )*(*tmp___7 + c) & 2048) {
#line 1620
      c -= 48;
    } else {
      {
#line 1621
      tmp___6 = __ctype_b_loc();
      }
#line 1621
      if ((int const   )*(*tmp___6 + c) & 256) {
#line 1622
        c -= 55;
      } else {
#line 1624
        c -= 87;
      }
    }
#line 1625
    tmp___8 = p;
#line 1625
    p ++;
#line 1625
    *tmp___8 = (char )((int )*tmp___8 | c);
    __Cont: /* CIL Label */ 
#line 1585
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1627
  *p = (char )'\000';
#line 1628
  return (bp___1);
}
}
#line 1645 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
bool xtextok(char *s ) 
{ 
  int c ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1651
    tmp___3 = s;
#line 1651
    s ++;
#line 1651
    c = (int )*tmp___3;
#line 1651
    if (! (c != 0)) {
#line 1651
      goto while_break;
    }
#line 1653
    if (c == 43) {
#line 1655
      tmp = s;
#line 1655
      s ++;
#line 1655
      c = (int )*tmp;
#line 1656
      if (! ((c & -128) == 0)) {
#line 1657
        return (0);
      } else {
        {
#line 1656
        tmp___0 = __ctype_b_loc();
        }
#line 1656
        if (! ((int const   )*(*tmp___0 + c) & 4096)) {
#line 1657
          return (0);
        }
      }
#line 1658
      tmp___1 = s;
#line 1658
      s ++;
#line 1658
      c = (int )*tmp___1;
#line 1659
      if (! ((c & -128) == 0)) {
#line 1660
        return (0);
      } else {
        {
#line 1659
        tmp___2 = __ctype_b_loc();
        }
#line 1659
        if (! ((int const   )*(*tmp___2 + c) & 4096)) {
#line 1660
          return (0);
        }
      }
    } else
#line 1662
    if (c < 33) {
#line 1663
      return (0);
    } else
#line 1662
    if (c > 126) {
#line 1663
      return (0);
    } else
#line 1662
    if (c == 61) {
#line 1663
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1665
  return (1);
}
}
#line 1684 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/savemail.c"
static bool pruneroute(char *addr ) 
{ 
  char *start ;
  char *at ;
  char *comma ;
  char c ;
  int braclev ;
  int rcode ;
  int i ;
  char hostbuf___1[8192] ;
  char *mxhosts[101] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 1698
  if ((int )*addr != 60) {
#line 1699
    return (0);
  } else
#line 1698
  if ((int )*(addr + 1) != 64) {
#line 1699
    return (0);
  } else {
    {
#line 1698
    tmp = strlen((char const   *)addr);
    }
#line 1698
    if ((int )*(addr + (tmp - 1U)) != 62) {
#line 1699
      return (0);
    }
  }
#line 1707
  start = addr;
#line 1708
  braclev = 0;
  {
#line 1709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1709
    if (! ((int )*start != 0)) {
#line 1709
      goto while_break;
    }
#line 1711
    if ((int )*start == 58) {
#line 1711
      if (braclev <= 0) {
#line 1712
        goto while_break;
      } else {
#line 1711
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1713
    if ((int )*start == 91) {
#line 1714
      braclev ++;
    } else
#line 1715
    if ((int )*start == 93) {
#line 1715
      if (braclev > 0) {
#line 1716
        braclev --;
      }
    }
#line 1717
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1719
  if (braclev > 0) {
#line 1720
    return (0);
  } else
#line 1719
  if ((int )*start != 58) {
#line 1720
    return (0);
  }
  {
#line 1722
  at = strrchr((char const   *)addr, '@');
  }
#line 1723
  if ((unsigned long )at == (unsigned long )((void *)0)) {
#line 1724
    return (0);
  } else
#line 1723
  if ((unsigned long )at < (unsigned long )start) {
#line 1724
    return (0);
  }
  {
#line 1727
  tmp___0 = strlen((char const   *)(at + 1));
#line 1727
  i = (int )tmp___0;
  }
#line 1728
  if ((unsigned long )i >= sizeof(hostbuf___1)) {
#line 1729
    return (0);
  }
  {
#line 1730
  sm_strlcpy(hostbuf___1, (char const   *)(at + 1), (ssize_t )sizeof(hostbuf___1));
#line 1731
  hostbuf___1[i - 1] = (char )'\000';
  }
  {
#line 1733
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1733
    if (! ((unsigned long )start != (unsigned long )((void *)0))) {
#line 1733
      goto while_break___0;
    }
    {
#line 1735
    tmp___2 = getmxrr(hostbuf___1, mxhosts, (unsigned short *)((void *)0), 0, & rcode,
                      1, (int *)((void *)0));
    }
#line 1735
    if (tmp___2 > 0) {
      {
#line 1738
      tmp___1 = strlen((char const   *)addr);
#line 1738
      sm_strlcpy(addr + 1, (char const   *)(start + 1), (ssize_t )(tmp___1 - 1U));
      }
#line 1740
      return (1);
    }
    {
#line 1742
    c = *start;
#line 1743
    *start = (char )'\000';
#line 1744
    comma = strrchr((char const   *)addr, ',');
    }
#line 1745
    if ((unsigned long )comma != (unsigned long )((void *)0)) {
#line 1745
      if ((int )*(comma + 1) == 64) {
        {
#line 1745
        tmp___3 = strlen((char const   *)(comma + 2));
        }
#line 1745
        if ((unsigned long )tmp___3 < sizeof(hostbuf___1)) {
          {
#line 1747
          sm_strlcpy(hostbuf___1, (char const   *)(comma + 2), (ssize_t )sizeof(hostbuf___1));
          }
        } else {
#line 1749
          comma = (char *)((void *)0);
        }
      } else {
#line 1749
        comma = (char *)((void *)0);
      }
    } else {
#line 1749
      comma = (char *)((void *)0);
    }
#line 1750
    *start = c;
#line 1751
    start = comma;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1754
  return (0);
}
}
#line 618 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 624
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 627
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 648
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 73 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 85
extern struct passwd *getpwent(void) ;
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 199
extern int initgroups(char const   * , __gid_t __group ) ;
#line 338 "./sendmail.h"
ADDRESS *getctladdr(ADDRESS *a ) ;
#line 339
int include(char *fname , bool forwarding , ADDRESS *ctladdr , ADDRESS **sendq , int aliaslevel ,
            ENVELOPE *e ) ;
#line 348
bool sameaddr(ADDRESS *a , ADDRESS *b___0 ) ;
#line 351
int removefromlist(char *list , ADDRESS **sendq , ENVELOPE *e ) ;
#line 472
MAILER *InclMailer ;
#line 1145
char *hostsignature(MAILER *m , char *host ) ;
#line 1275
void maplocaluser(ADDRESS *a , ADDRESS **sendq , int aliaslevel , ENVELOPE *e ) ;
#line 2170
bool MatchGecos ;
#line 2173
bool NoConnect ;
#line 2198
char SpaceSub ;
#line 2201
int ConfigLevel ;
#line 2210
int FastSplit ;
#line 2214
int MaxAliasRecursion ;
#line 2216
int MaxForwardEntries ;
#line 2332
struct rewrite *RewriteRules[200] ;
#line 2361
void alias(ADDRESS *a , ADDRESS **sendq , int aliaslevel , ENVELOPE *e ) ;
#line 2363
void forward(ADDRESS *user , ADDRESS **sendq , int aliaslevel , ENVELOPE *e ) ;
#line 2457
bool chownsafe(int fd , bool safedir ) ;
#line 2490
int finduser(char *name , bool *fuzzyp , SM_MBDB_T *user ) ;
#line 2552
void sendtoargv(char **argv , ENVELOPE *e ) ;
#line 2574
struct passwd *sm_getpwuid(uid_t uid ) ;
#line 2607
bool usershellok(char *user , char *shell ) ;
#line 18 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
static void includetimeout(int ignore ) ;
#line 19
static ADDRESS *self_reference(ADDRESS *a ) ;
#line 20
static int sortexpensive(ADDRESS *xx , ADDRESS *yy ) ;
#line 21
static int sortbysignature(ADDRESS *xx , ADDRESS *yy ) ;
#line 22
static int sorthost(ADDRESS *xx , ADDRESS *yy ) ;
#line 39 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
static int sorthost(ADDRESS *xx , ADDRESS *yy ) 
{ 
  int tmp ;

  {
  {
#line 48
  tmp = sm_strcasecmp((char const   *)xx->q_host, (char const   *)yy->q_host);
  }
#line 48
  return (tmp);
}
}
#line 75 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
static int sortexpensive(ADDRESS *xx , ADDRESS *yy ) 
{ 
  int tmp ;

  {
#line 80
  if (! ((yy->q_mailer)->m_flags[101UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 101UL % (8UL * sizeof(int ))))) {
#line 81
    return (1);
  }
  {
#line 86
  tmp = sm_strcasecmp((char const   *)xx->q_host, (char const   *)yy->q_host);
  }
#line 86
  return (tmp);
}
}
#line 106 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
static int sortbysignature(ADDRESS *xx , ADDRESS *yy ) 
{ 
  register int ret ;
  int tmp ;

  {
#line 114
  if ((unsigned long )xx->q_signature == (unsigned long )((void *)0)) {
    {
#line 115
    xx->q_signature = hostsignature(xx->q_mailer, xx->q_host);
    }
  }
#line 116
  if ((unsigned long )yy->q_signature == (unsigned long )((void *)0)) {
    {
#line 117
    yy->q_signature = hostsignature(yy->q_mailer, yy->q_host);
    }
  }
  {
#line 118
  ret = strcmp((char const   *)xx->q_signature, (char const   *)yy->q_signature);
  }
#line 128
  if (ret == 0) {
    {
#line 129
    tmp = strcmp((char const   *)yy->q_user, (char const   *)xx->q_user);
    }
#line 129
    return (tmp);
  } else {
#line 131
    return (ret);
  }
}
}
#line 159 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
int sendtolist(char *list , ADDRESS *ctladdr , ADDRESS **sendq , int aliaslevel ,
               ENVELOPE *e ) 
{ 
  register char *p ;
  register ADDRESS *al ;
  char delimiter ;
  int naddrs ;
  int i ;
  char *endp ;
  char *oldto ;
  char *bufp ;
  char buf___16[257] ;
  SM_FILE_T *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  SM_EXC_HANDLER_T _h ;
  char *tmp___6 ;
  int tmp___7 ;
  char *delimptr ;
  register ADDRESS *a ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  ADDRESS *b___0 ;
  SM_FILE_T *tmp___12 ;
  bool tmp___13 ;
  SM_FILE_T *tmp___14 ;
  SM_FILE_T *tmp___15 ;
  register ADDRESS *a___0 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
#line 173
  oldto = e->e_to;
#line 177
  if ((unsigned long )list == (unsigned long )((void *)0)) {
    {
#line 179
    syserr("sendtolist: null list");
    }
#line 180
    return (0);
  }
#line 183
  if ((int )tTdvect[25] >= 1) {
    {
#line 185
    sm_dprintf((char *)"sendto: %s\n   ctladdr=", list);
#line 186
    tmp = sm_debug_file();
#line 186
    printaddr(tmp, ctladdr, 0);
    }
  }
#line 190
  if ((unsigned long )ctladdr == (unsigned long )((void *)0)) {
    {
#line 190
    tmp___0 = strchr((char const   *)list, ',');
    }
#line 190
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 193
      e->e_flags &= 0xfffffffffffffffeUL;
    } else {
      {
#line 190
      tmp___1 = strchr((char const   *)list, ';');
      }
#line 190
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 193
        e->e_flags &= 0xfffffffffffffffeUL;
      } else {
        {
#line 190
        tmp___2 = strchr((char const   *)list, '<');
        }
#line 190
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 193
          e->e_flags &= 0xfffffffffffffffeUL;
        } else {
          {
#line 190
          tmp___3 = strchr((char const   *)list, '(');
          }
#line 190
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 193
            e->e_flags &= 0xfffffffffffffffeUL;
          }
        }
      }
    }
  }
#line 194
  delimiter = (char )' ';
#line 195
  if (! ((e->e_flags & 1UL) != 0UL)) {
#line 196
    delimiter = (char )',';
  } else
#line 195
  if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
#line 196
    delimiter = (char )',';
  }
  {
#line 198
  al = (ADDRESS *)((void *)0);
#line 199
  naddrs = 0;
#line 202
  tmp___4 = strlen((char const   *)list);
#line 202
  i = (int )(tmp___4 + 1U);
  }
#line 203
  if ((unsigned long )i <= sizeof(buf___16)) {
#line 205
    bufp = buf___16;
#line 206
    i = (int )sizeof(buf___16);
  } else {
    {
#line 209
    tmp___5 = sm_malloc_tagged_x((size_t )i, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                                 209, SmHeapGroup);
#line 209
    bufp = (char *)tmp___5;
    }
  }
#line 210
  endp = bufp + i;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    _h.eh_value = (SM_EXC_T *)((void *)0);
#line 212
    _h.eh_parent = SmExcHandler;
#line 212
    _h.eh_state = 2;
#line 212
    SmExcHandler = & _h;
#line 212
    tmp___17 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 212
    if (tmp___17 == 0) {
      {
#line 214
      tmp___6 = denlstring(list, 0, 1);
#line 214
      sm_strlcpy(bufp, (char const   *)tmp___6, i);
#line 216
      tmp___7 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 216
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___7, (char *)"e r", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                       216, SmHeapGroup);
#line 217
      p = bufp;
      }
      {
#line 217
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 217
        if (! ((int )*p != 0)) {
#line 217
          goto while_break___0;
        }
#line 222
        if ((unsigned long )p < (unsigned long )endp) {
#line 222
          tmp___8 = 1;
        } else {
          {
#line 222
          sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                      222, "SM_ASSERT(p < endp) failed");
#line 222
          tmp___8 = 0;
          }
        }
        {
#line 225
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 225
          if (((int )*p & -128) == 0) {
            {
#line 225
            tmp___9 = __ctype_b_loc();
            }
#line 225
            if (! ((int const   )*(*tmp___9 + (int )*p) & 8192)) {
#line 225
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 225
          if (! ((int )*p == 44)) {
#line 225
            goto while_break___1;
          }
#line 226
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 227
        if ((unsigned long )p < (unsigned long )endp) {
#line 227
          tmp___10 = 1;
        } else {
          {
#line 227
          sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                      227, "SM_ASSERT(p < endp) failed");
#line 227
          tmp___10 = 0;
          }
        }
        {
#line 228
        a = parseaddr(p, (ADDRESS *)((void *)0), 48, (int )delimiter, & delimptr,
                      e, 1);
#line 230
        p = delimptr;
        }
#line 231
        if ((unsigned long )p < (unsigned long )endp) {
#line 231
          tmp___11 = 1;
        } else {
          {
#line 231
          sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                      231, "SM_ASSERT(p < endp) failed");
#line 231
          tmp___11 = 0;
          }
        }
#line 232
        if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 233
          goto __Cont;
        }
#line 234
        a->q_next = al;
#line 235
        a->q_alias = ctladdr;
#line 238
        if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
          {
#line 243
          tmp___13 = sameaddr(ctladdr, a);
          }
#line 243
          if (tmp___13) {
#line 245
            if ((int )tTdvect[27] >= 5) {
              {
#line 247
              sm_dprintf((char *)"sendtolist: QSELFREF ");
#line 248
              tmp___12 = sm_debug_file();
#line 248
              printaddr(tmp___12, ctladdr, 0);
              }
            }
#line 250
            ctladdr->q_flags |= 8UL;
          }
          {
#line 254
          b___0 = self_reference(a);
          }
#line 255
          if ((unsigned long )b___0 != (unsigned long )((void *)0)) {
#line 257
            b___0->q_flags |= 8UL;
#line 258
            if ((int )tTdvect[27] >= 5) {
              {
#line 260
              sm_dprintf((char *)"sendtolist: QSELFREF ");
#line 261
              tmp___14 = sm_debug_file();
#line 261
              printaddr(tmp___14, b___0, 0);
              }
            }
#line 263
            if ((unsigned long )a != (unsigned long )b___0) {
#line 265
              if ((int )tTdvect[27] >= 5) {
                {
#line 267
                sm_dprintf((char *)"sendtolist: QS_DONTSEND ");
#line 268
                tmp___15 = sm_debug_file();
#line 268
                printaddr(tmp___15, a, 0);
                }
              }
#line 270
              a->q_state = (short)6;
#line 271
              b___0->q_flags |= a->q_flags & 4UL;
#line 272
              goto __Cont;
            }
          }
#line 277
          if ((unsigned long )a->q_fullname == (unsigned long )((void *)0)) {
#line 278
            a->q_fullname = ctladdr->q_fullname;
          }
#line 281
          a->q_flags &= 0xfffffffffffffc3fUL;
#line 282
          a->q_flags |= ctladdr->q_flags & 960UL;
#line 285
          a->q_finalrcpt = ctladdr->q_finalrcpt;
#line 286
          a->q_orcpt = ctladdr->q_orcpt;
        }
#line 289
        al = a;
        __Cont: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 293
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 293
        if (! ((unsigned long )al != (unsigned long )((void *)0))) {
#line 293
          goto while_break___2;
        }
        {
#line 295
        a___0 = al;
#line 297
        al = a___0->q_next;
#line 298
        a___0 = recipient(a___0, sendq, aliaslevel, e);
#line 299
        naddrs ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 302
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 302
        tmp___16 = 1;
      } else {
        {
#line 302
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                    302, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 302
        tmp___16 = 0;
        }
      }
    }
    {
#line 302
    tmp___19 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 302
    if (tmp___19 == 0) {
#line 304
      e->e_to = oldto;
#line 305
      if ((unsigned long )bufp != (unsigned long )(buf___16)) {
        {
#line 306
        sm_free_tagged((void *)bufp, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                       306);
        }
      }
      {
#line 307
      tmp___18 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 307
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___18, (char *)((void *)0),
                       (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                       307, SmHeapGroup);
      }
    }
#line 212
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  if (_h.eh_state == 2) {
#line 309
    if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 309
      tmp___20 = 1;
    } else {
      {
#line 309
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                  309, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 309
      tmp___20 = 0;
      }
    }
#line 309
    SmExcHandler = _h.eh_parent;
#line 309
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 309
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else
#line 309
  if (_h.eh_state == 0) {
#line 309
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 309
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else {
    {
#line 309
    sm_exc_free(_h.eh_value);
    }
  }
#line 310
  return (naddrs);
}
}
#line 332 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
int removefromlist(char *list , ADDRESS **sendq , ENVELOPE *e ) 
{ 
  char delimiter ;
  int naddrs ;
  int i ;
  char *p ;
  char *oldto ;
  char *bufp ;
  char buf___16[257] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  SM_EXC_HANDLER_T _h ;
  char *tmp___5 ;
  int tmp___6 ;
  ADDRESS a ;
  ADDRESS *q ;
  ADDRESS **pq ;
  char *delimptr ;
  unsigned short const   **tmp___7 ;
  ADDRESS *tmp___8 ;
  SM_FILE_T *tmp___9 ;
  bool tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
#line 342
  oldto = e->e_to;
#line 346
  if ((unsigned long )list == (unsigned long )((void *)0)) {
    {
#line 348
    syserr("removefromlist: null list");
    }
#line 349
    return (0);
  }
#line 352
  if ((int )tTdvect[25] >= 1) {
    {
#line 353
    sm_dprintf((char *)"removefromlist: %s\n", list);
    }
  }
  {
#line 356
  tmp = strchr((char const   *)list, ',');
  }
#line 356
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 358
    e->e_flags &= 0xfffffffffffffffeUL;
  } else {
    {
#line 356
    tmp___0 = strchr((char const   *)list, ';');
    }
#line 356
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 358
      e->e_flags &= 0xfffffffffffffffeUL;
    } else {
      {
#line 356
      tmp___1 = strchr((char const   *)list, '<');
      }
#line 356
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 358
        e->e_flags &= 0xfffffffffffffffeUL;
      } else {
        {
#line 356
        tmp___2 = strchr((char const   *)list, '(');
        }
#line 356
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 358
          e->e_flags &= 0xfffffffffffffffeUL;
        }
      }
    }
  }
#line 359
  delimiter = (char )' ';
#line 360
  if (! ((e->e_flags & 1UL) != 0UL)) {
#line 361
    delimiter = (char )',';
  }
  {
#line 363
  naddrs = 0;
#line 366
  tmp___3 = strlen((char const   *)list);
#line 366
  i = (int )(tmp___3 + 1U);
  }
#line 367
  if ((unsigned long )i <= sizeof(buf___16)) {
#line 369
    bufp = buf___16;
#line 370
    i = (int )sizeof(buf___16);
  } else {
    {
#line 373
    tmp___4 = sm_malloc_tagged_x((size_t )i, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                                 373, SmHeapGroup);
#line 373
    bufp = (char *)tmp___4;
    }
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 375
    _h.eh_value = (SM_EXC_T *)((void *)0);
#line 375
    _h.eh_parent = SmExcHandler;
#line 375
    _h.eh_state = 2;
#line 375
    SmExcHandler = & _h;
#line 375
    tmp___13 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 375
    if (tmp___13 == 0) {
      {
#line 377
      tmp___5 = denlstring(list, 0, 1);
#line 377
      sm_strlcpy(bufp, (char const   *)tmp___5, i);
#line 379
      tmp___6 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 379
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___6, (char *)"e r", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                       379, SmHeapGroup);
#line 380
      p = bufp;
      }
      {
#line 380
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 380
        if (! ((int )*p != 0)) {
#line 380
          goto while_break___0;
        }
        {
#line 388
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 388
          if (((int )*p & -128) == 0) {
            {
#line 388
            tmp___7 = __ctype_b_loc();
            }
#line 388
            if (! ((int const   )*(*tmp___7 + (int )*p) & 8192)) {
#line 388
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 388
          if (! ((int )*p == 44)) {
#line 388
            goto while_break___1;
          }
#line 389
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 390
        tmp___8 = parseaddr(p, & a, 48, (int )delimiter, & delimptr, e, 1);
        }
#line 390
        if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 393
          p = delimptr;
#line 394
          goto __Cont;
        }
#line 396
        p = delimptr;
#line 397
        pq = sendq;
        {
#line 397
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 397
          q = *pq;
#line 397
          if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 397
            goto while_break___2;
          }
#line 399
          if (! ((int )q->q_state >= 6)) {
            {
#line 399
            tmp___10 = sameaddr(q, & a);
            }
#line 399
            if (tmp___10) {
#line 399
              goto _L___0;
            } else {
              {
#line 399
              tmp___11 = strcmp((char const   *)q->q_paddr, (char const   *)a.q_paddr);
              }
#line 399
              if (tmp___11 == 0) {
                _L___0: /* CIL Label */ 
#line 403
                if ((int )tTdvect[25] >= 5) {
                  {
#line 405
                  sm_dprintf((char *)"removefromlist: QS_REMOVED ");
#line 406
                  tmp___9 = sm_debug_file();
#line 406
                  printaddr(tmp___9, & a, 0);
                  }
                }
#line 408
                q->q_state = (short)12;
#line 409
                naddrs ++;
#line 410
                goto while_break___2;
              }
            }
          }
#line 397
          pq = & q->q_next;
        }
        while_break___2: /* CIL Label */ ;
        }
        __Cont: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 415
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 415
        tmp___12 = 1;
      } else {
        {
#line 415
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                    415, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 415
        tmp___12 = 0;
        }
      }
    }
    {
#line 415
    tmp___15 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 415
    if (tmp___15 == 0) {
#line 417
      e->e_to = oldto;
#line 418
      if ((unsigned long )bufp != (unsigned long )(buf___16)) {
        {
#line 419
        sm_free_tagged((void *)bufp, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                       419);
        }
      }
      {
#line 420
      tmp___14 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 420
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___14, (char *)((void *)0),
                       (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                       420, SmHeapGroup);
      }
    }
#line 375
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  if (_h.eh_state == 2) {
#line 422
    if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 422
      tmp___16 = 1;
    } else {
      {
#line 422
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                  422, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 422
      tmp___16 = 0;
      }
    }
#line 422
    SmExcHandler = _h.eh_parent;
#line 422
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 422
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else
#line 422
  if (_h.eh_state == 0) {
#line 422
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 422
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else {
    {
#line 422
    sm_exc_free(_h.eh_value);
    }
  }
#line 423
  return (naddrs);
}
}
#line 445 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
ADDRESS *recipient(ADDRESS *new , ADDRESS **sendq , int aliaslevel , ENVELOPE *e ) 
{ 
  register ADDRESS *q ;
  ADDRESS **pq ;
  ADDRESS **prev___0 ;
  register struct mailer *m ;
  register char *p ;
  int i ;
  int buflen___1 ;
  bool quoted ;
  bool insert ;
  int findusercount ;
  bool initialdontsend ;
  char *buf___16 ;
  char buf0[257] ;
  sortfn_t *sortfn ;
  int *tmp ;
  SM_FILE_T *tmp___0 ;
  char frbuf[2048] ;
  char *qp ;
  bool b___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  SM_FILE_T *tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  SM_FILE_T *tmp___11 ;
  int ret ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  bool tmp___18 ;
  int *tmp___19 ;
  char const   *tmp___20 ;
  int *tmp___21 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  SM_FILE_T *tmp___24 ;
  bool fuzzy ;
  SM_MBDB_T user ;
  int status ;
  int tmp___25 ;
  int tmp___26 ;
  bool tmp___27 ;
  SM_FILE_T *tmp___28 ;
  SM_FILE_T *tmp___29 ;
  int nrcpts ;
  ADDRESS *only ;
  int tmp___30 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;

  {
  {
#line 466
  p = (char *)((void *)0);
#line 467
  quoted = 0;
#line 468
  insert = 0;
#line 469
  findusercount = 0;
#line 470
  initialdontsend = (int )new->q_state >= 6;
#line 471
  e->e_to = new->q_paddr;
#line 472
  m = new->q_mailer;
#line 473
  tmp = __errno_location();
#line 473
  *tmp = 0;
  }
#line 474
  if (aliaslevel == 0) {
#line 475
    new->q_flags |= 2UL;
  }
#line 476
  if ((int )tTdvect[26] >= 1) {
    {
#line 478
    sm_dprintf((char *)"\nrecipient (%d): ", aliaslevel);
#line 479
    tmp___0 = sm_debug_file();
#line 479
    printaddr(tmp___0, new, 0);
    }
  }
#line 483
  if ((unsigned long )new->q_alias == (unsigned long )((void *)0)) {
#line 485
    if ((unsigned long )e->e_origrcpt == (unsigned long )((void *)0)) {
#line 486
      e->e_origrcpt = new->q_paddr;
    } else
#line 487
    if ((unsigned long )e->e_origrcpt != (unsigned long )new->q_paddr) {
#line 488
      e->e_origrcpt = (char *)"";
    }
  }
#line 492
  q = new;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! ((unsigned long )q->q_alias != (unsigned long )((void *)0))) {
#line 492
      goto while_break;
    }
#line 493
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 492
    q = q->q_alias;
  }
  while_break: /* CIL Label */ ;
  }
#line 496
  if ((unsigned long )new->q_finalrcpt == (unsigned long )((void *)0)) {
#line 496
    if ((unsigned long )e->e_from.q_mailer != (unsigned long )((void *)0)) {
#line 501
      p = (e->e_from.q_mailer)->m_addrtype;
#line 502
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 503
        p = (char *)"rfc822";
      }
      {
#line 504
      tmp___6 = sm_strcasecmp((char const   *)p, "rfc822");
      }
#line 504
      if (tmp___6 != 0) {
        {
#line 506
        sm_snprintf(frbuf, (size_t )sizeof(frbuf), "%s; %.800s", (q->q_mailer)->m_addrtype,
                    q->q_user);
        }
      } else {
        {
#line 510
        tmp___5 = strchr((char const   *)q->q_user, '@');
        }
#line 510
        if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
          {
#line 512
          sm_snprintf(frbuf, (size_t )sizeof(frbuf), "%s; %.800s", p, q->q_user);
          }
        } else {
          {
#line 515
          tmp___4 = strchr((char const   *)q->q_paddr, '@');
          }
#line 515
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 520
            qp = q->q_paddr;
#line 523
            b___0 = 0;
#line 524
            if ((int )*qp == 60) {
              {
#line 526
              tmp___1 = strlen((char const   *)qp);
#line 526
              b___0 = (int )*(qp + (tmp___1 - 1U)) == 62;
              }
#line 527
              if (b___0) {
                {
#line 528
                tmp___2 = strlen((char const   *)qp);
#line 528
                *(qp + (tmp___2 - 1U)) = (char )'\000';
                }
              }
#line 529
              qp ++;
            }
            {
#line 531
            sm_snprintf(frbuf, (size_t )sizeof(frbuf), "%s; %.800s", p, qp);
            }
#line 535
            if (b___0) {
              {
#line 536
              tmp___3 = strlen((char const   *)qp);
#line 536
              *(qp + tmp___3) = (char )'>';
              }
            }
          } else {
            {
#line 540
            sm_snprintf(frbuf, (size_t )sizeof(frbuf), "%s; %.700s@%.100s", p, q->q_user,
                        MyHostName);
            }
          }
        }
      }
      {
#line 544
      new->q_finalrcpt = sm_rpool_strdup_x(e->e_rpool, (char const   *)(frbuf));
      }
    }
  }
#line 600
  if (aliaslevel > MaxAliasRecursion) {
    {
#line 602
    new->q_state = (short)2;
#line 603
    new->q_status = (char *)"5.4.6";
#line 604
    usrerrenh(new->q_status, "554 aliasing/forwarding loop broken (%d aliases deep; %d max)",
              aliaslevel, MaxAliasRecursion);
    }
#line 607
    return (new);
  }
  {
#line 615
  tmp___7 = strlen((char const   *)new->q_user);
#line 615
  i = (int )tmp___7;
  }
#line 616
  if ((unsigned long )i >= sizeof(buf0)) {
    {
#line 618
    buflen___1 = i + 1;
#line 619
    buf___16 = xalloc_tagged(buflen___1, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                             619);
    }
  } else {
#line 623
    buf___16 = buf0;
#line 624
    buflen___1 = (int )sizeof(buf0);
  }
  {
#line 626
  sm_strlcpy(buf___16, (char const   *)new->q_user, buflen___1);
#line 627
  p = buf___16;
  }
  {
#line 627
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 627
    if ((int )*p != 0) {
#line 627
      if (! (! quoted)) {
#line 627
        goto while_break___0;
      }
    } else {
#line 627
      goto while_break___0;
    }
#line 629
    if ((int )*p == 92) {
#line 630
      quoted = 1;
    }
#line 627
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 632
  stripquotes(buf___16);
  }
#line 635
  if ((unsigned long )m == (unsigned long )ProgMailer) {
#line 637
    if ((unsigned long )new->q_alias == (unsigned long )((void *)0)) {
      {
#line 640
      new->q_state = (short)2;
#line 641
      new->q_status = (char *)"5.7.1";
#line 642
      usrerrenh(new->q_status, "550 Cannot mail directly to programs");
      }
    } else
#line 637
    if (UseMSP) {
      {
#line 640
      new->q_state = (short)2;
#line 641
      new->q_status = (char *)"5.7.1";
#line 642
      usrerrenh(new->q_status, "550 Cannot mail directly to programs");
      }
    } else
#line 637
    if ((e->e_flags & 134217728UL) != 0UL) {
      {
#line 640
      new->q_state = (short)2;
#line 641
      new->q_status = (char *)"5.7.1";
#line 642
      usrerrenh(new->q_status, "550 Cannot mail directly to programs");
      }
    } else
#line 645
    if (((new->q_alias)->q_flags & 16UL) != 0UL) {
#line 647
      new->q_state = (short)2;
#line 648
      new->q_status = (char *)"5.7.1";
#line 649
      if ((unsigned long )(new->q_alias)->q_ruser == (unsigned long )((void *)0)) {
        {
#line 650
        usrerrenh(new->q_status, "550 UID %d is an unknown user: cannot mail to programs",
                  (new->q_alias)->q_uid);
        }
      } else {
        {
#line 654
        usrerrenh(new->q_status, "550 User %s@%s doesn\'t have a valid shell for mailing to programs",
                  (new->q_alias)->q_ruser, MyHostName);
        }
      }
    } else
#line 658
    if (((new->q_alias)->q_flags & 32UL) != 0UL) {
      {
#line 660
      new->q_state = (short)2;
#line 661
      new->q_status = (char *)"5.7.1";
#line 662
      new->q_rstatus = (char *)"550 Unsafe for mailing to programs";
#line 663
      usrerrenh(new->q_status, "550 Address %s is unsafe for mailing to programs",
                (new->q_alias)->q_paddr);
      }
    }
  }
#line 678
  prev___0 = (ADDRESS **)((void *)0);
#line 689
  if (UseMSP) {
#line 692
    sortfn = & sorthost;
  } else
#line 689
  if ((int )e->e_sendmode == 113) {
#line 692
    sortfn = & sorthost;
  } else
#line 689
  if ((int )e->e_sendmode == 100) {
#line 692
    sortfn = & sorthost;
  } else
#line 689
  if (! ((e->e_flags & 67108864UL) != 0UL)) {
#line 689
    if (e->e_ntries == 0) {
#line 689
      if (FastSplit > 0) {
#line 692
        sortfn = & sorthost;
      } else {
#line 689
        goto _L___0;
      }
    } else {
#line 689
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 693
  if (NoConnect) {
#line 693
    if ((new->q_mailer)->m_flags[101UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 101UL % (8UL * sizeof(int )))) {
#line 694
      sortfn = & sortexpensive;
    } else {
#line 696
      sortfn = & sortbysignature;
    }
  } else {
#line 696
    sortfn = & sortbysignature;
  }
#line 698
  pq = sendq;
  {
#line 698
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 698
    q = *pq;
#line 698
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 698
      goto while_break___1;
    }
    {
#line 711
    i = (*sortfn)(new, q);
    }
#line 712
    if (i == 0) {
      {
#line 722
      tmp___9 = sameaddr(q, new);
      }
#line 722
      if (tmp___9) {
#line 722
        if ((q->q_flags & 2147483648UL) != 0UL) {
#line 722
          goto _L___1;
        } else
#line 722
        if (! ((q->q_flags & 2UL) != 0UL)) {
          _L___1: /* CIL Label */ 
#line 726
          if ((int )tTdvect[26] >= 1) {
            {
#line 728
            sm_dprintf((char *)"%s in sendq: ", new->q_paddr);
#line 730
            tmp___8 = sm_debug_file();
#line 730
            printaddr(tmp___8, q, 0);
            }
          }
#line 732
          if (! ((q->q_flags & 2UL) != 0UL)) {
#line 734
            if (! ((int )new->q_state >= 6)) {
              {
#line 735
              message("duplicate suppressed");
              }
            } else {
#line 737
              q->q_state = (short)13;
            }
#line 738
            q->q_flags |= new->q_flags;
          } else
#line 740
          if ((q->q_flags & 8UL) != 0UL) {
#line 749
            q->q_state = new->q_state;
#line 750
            q->q_flags |= new->q_flags;
          } else
#line 740
          if ((int )q->q_state == 12) {
#line 749
            q->q_state = new->q_state;
#line 750
            q->q_flags |= new->q_flags;
          }
#line 752
          new = q;
#line 753
          goto done;
        }
      }
    } else
#line 756
    if (i < 0) {
#line 758
      insert = 1;
#line 759
      goto while_break___1;
    }
#line 761
    prev___0 = pq;
#line 698
    pq = & q->q_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 765
  if ((unsigned long )pq != (unsigned long )((void *)0)) {
#line 765
    tmp___10 = 1;
  } else {
    {
#line 765
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                765, "SM_ASSERT(pq != NULL) failed");
#line 765
    tmp___10 = 0;
    }
  }
#line 768
  if (insert) {
#line 775
    new->q_next = *pq;
#line 776
    if ((unsigned long )prev___0 == (unsigned long )((void *)0)) {
#line 777
      *sendq = new;
    } else {
#line 779
      (*prev___0)->q_next = new;
    }
  } else {
#line 788
    new->q_next = (struct address *)((void *)0);
#line 789
    *pq = new;
  }
#line 793
  e->e_flags &= 0xfffffffffbffffffUL;
  trylocaluser: 
#line 800
  if ((int )tTdvect[29] >= 7) {
    {
#line 802
    sm_dprintf((char *)"at trylocaluser: ");
#line 803
    tmp___11 = sm_debug_file();
#line 803
    printaddr(tmp___11, new, 0);
    }
  }
#line 806
  if (! ((int )new->q_state == 0)) {
#line 808
    if ((int )new->q_state == 0) {
#line 809
      (e->e_nrcpts) ++;
    } else
#line 808
    if ((int )new->q_state == 3) {
#line 809
      (e->e_nrcpts) ++;
    } else
#line 808
    if ((int )new->q_state == 4) {
#line 809
      (e->e_nrcpts) ++;
    } else
#line 808
    if ((int )new->q_state == 5) {
#line 809
      (e->e_nrcpts) ++;
    }
#line 810
    goto testselfdestruct;
  }
#line 813
  if ((unsigned long )m == (unsigned long )InclMailer) {
#line 815
    new->q_state = (short)14;
#line 816
    if ((unsigned long )new->q_alias == (unsigned long )((void *)0)) {
      {
#line 819
      new->q_state = (short)2;
#line 820
      new->q_status = (char *)"5.7.1";
#line 821
      usrerrenh(new->q_status, "550 Cannot mail directly to :include:s");
      }
    } else
#line 816
    if (UseMSP) {
      {
#line 819
      new->q_state = (short)2;
#line 820
      new->q_status = (char *)"5.7.1";
#line 821
      usrerrenh(new->q_status, "550 Cannot mail directly to :include:s");
      }
    } else
#line 816
    if ((e->e_flags & 134217728UL) != 0UL) {
      {
#line 819
      new->q_state = (short)2;
#line 820
      new->q_status = (char *)"5.7.1";
#line 821
      usrerrenh(new->q_status, "550 Cannot mail directly to :include:s");
      }
    } else {
      {
#line 828
      message("including file %s", new->q_user);
#line 829
      ret = include(new->q_user, 0, new, sendq, aliaslevel, e);
#line 831
      tmp___18 = transienterror(ret);
      }
#line 831
      if (tmp___18) {
#line 833
        if (LogLevel > 2) {
          {
#line 834
          tmp___12 = sm_errstring(ret);
#line 834
          tmp___13 = shortenstring((char const   *)new->q_user, (size_t )203);
#line 834
          sm_syslog(3, (char const   *)e->e_id, "include %s: transient error: %s",
                    tmp___13, tmp___12);
          }
        }
        {
#line 839
        new->q_state = (short)3;
#line 840
        tmp___14 = sm_errstring(ret);
#line 840
        tmp___15 = shortenstring((char const   *)new->q_user, (size_t )203);
#line 840
        usrerr("451 4.2.4 Cannot open %s: %s", tmp___15, tmp___14);
        }
      } else
#line 845
      if (ret != 0) {
        {
#line 847
        new->q_state = (short)2;
#line 848
        new->q_status = (char *)"5.2.4";
#line 849
        tmp___16 = sm_errstring(ret);
#line 849
        tmp___17 = shortenstring((char const   *)new->q_user, (size_t )203);
#line 849
        usrerrenh(new->q_status, "550 Cannot open %s: %s", tmp___17, tmp___16);
        }
      }
    }
  } else
#line 857
  if ((unsigned long )m == (unsigned long )FileMailer) {
#line 860
    if ((unsigned long )new->q_alias == (unsigned long )((void *)0)) {
      {
#line 863
      new->q_state = (short)2;
#line 864
      new->q_status = (char *)"5.7.1";
#line 865
      usrerrenh(new->q_status, "550 Cannot mail directly to files");
      }
    } else
#line 860
    if (UseMSP) {
      {
#line 863
      new->q_state = (short)2;
#line 864
      new->q_status = (char *)"5.7.1";
#line 865
      usrerrenh(new->q_status, "550 Cannot mail directly to files");
      }
    } else
#line 860
    if ((e->e_flags & 134217728UL) != 0UL) {
      {
#line 863
      new->q_state = (short)2;
#line 864
      new->q_status = (char *)"5.7.1";
#line 865
      usrerrenh(new->q_status, "550 Cannot mail directly to files");
      }
    } else
#line 868
    if (((new->q_alias)->q_flags & 16UL) != 0UL) {
#line 870
      new->q_state = (short)2;
#line 871
      new->q_status = (char *)"5.7.1";
#line 872
      if ((unsigned long )(new->q_alias)->q_ruser == (unsigned long )((void *)0)) {
        {
#line 873
        usrerrenh(new->q_status, "550 UID %d is an unknown user: cannot mail to files",
                  (new->q_alias)->q_uid);
        }
      } else {
        {
#line 877
        usrerrenh(new->q_status, "550 User %s@%s doesn\'t have a valid shell for mailing to files",
                  (new->q_alias)->q_ruser, MyHostName);
        }
      }
    } else
#line 881
    if (((new->q_alias)->q_flags & 32UL) != 0UL) {
      {
#line 883
      new->q_state = (short)2;
#line 884
      new->q_status = (char *)"5.7.1";
#line 885
      new->q_rstatus = (char *)"550 Unsafe for mailing to files";
#line 886
      usrerrenh(new->q_status, "550 Address %s is unsafe for mailing to files", (new->q_alias)->q_paddr);
      }
    }
  }
#line 893
  if (! quoted) {
#line 893
    if ((int )new->q_state == 0) {
#line 893
      if (m->m_flags[65UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 65UL % (8UL * sizeof(int )))) {
        {
#line 895
        alias(new, sendq, aliaslevel, e);
        }
      }
    }
  }
#line 899
  if (! ((new->q_flags & 4UL) != 0UL)) {
#line 899
    if ((int )new->q_state == 0) {
#line 899
      goto _L___2;
    } else
#line 899
    if ((int )new->q_state == 3) {
#line 899
      goto _L___2;
    } else
#line 899
    if ((int )new->q_state == 4) {
      _L___2: /* CIL Label */ 
#line 899
      if (m->m_flags[64UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 64UL % (8UL * sizeof(int )))) {
        {
#line 903
        tmp___23 = udbexpand(new, sendq, aliaslevel, e);
        }
#line 903
        if (tmp___23 == 75) {
#line 905
          new->q_state = (short)3;
#line 906
          if ((unsigned long )e->e_message == (unsigned long )((void *)0)) {
#line 907
            e->e_message = (char *)"Deferred: user database error";
          }
#line 908
          if ((unsigned long )new->q_message == (unsigned long )((void *)0)) {
#line 909
            new->q_message = (char *)"Deferred: user database error";
          }
#line 910
          if (LogLevel > 8) {
            {
#line 911
            tmp___19 = __errno_location();
#line 911
            tmp___20 = sm_errstring(*tmp___19);
#line 911
            sm_syslog(6, (char const   *)e->e_id, "deferred: udbexpand: %s", tmp___20);
            }
          }
          {
#line 914
          tmp___21 = __errno_location();
#line 914
          tmp___22 = sm_errstring(*tmp___21);
#line 914
          message("queued (user database error): %s", tmp___22);
#line 916
          (e->e_nrcpts) ++;
          }
#line 917
          goto testselfdestruct;
        }
      }
    }
  }
#line 929
  if ((int )tTdvect[29] >= 5) {
    {
#line 931
    sm_dprintf((char *)"recipient: testing local?  cl=%d, rr5=%p\n\t", ConfigLevel,
               RewriteRules[5]);
#line 933
    tmp___24 = sm_debug_file();
#line 933
    printaddr(tmp___24, new, 0);
    }
  }
#line 935
  if (ConfigLevel >= 2) {
#line 935
    if ((unsigned long )RewriteRules[5] != (unsigned long )((void *)0)) {
#line 935
      if (m->m_flags[53UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 53UL % (8UL * sizeof(int )))) {
#line 935
        if (! ((new->q_flags & 4UL) != 0UL)) {
#line 935
          if ((int )new->q_state == 0) {
            {
#line 940
            maplocaluser(new, sendq, aliaslevel + 1, e);
            }
          }
        }
      }
    }
  }
#line 948
  if ((int )new->q_state == 0) {
#line 948
    if (m->m_flags[119UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 119UL % (8UL * sizeof(int )))) {
      {
#line 956
      status = finduser(buf___16, & fuzzy, & user);
      }
      {
#line 959
      if (status == 75) {
#line 959
        goto case_75;
      }
#line 972
      if (status == 0) {
#line 972
        goto case_0;
      }
#line 965
      goto switch_default;
      case_75: /* CIL Label */ 
      {
#line 960
      new->q_state = (short)3;
#line 961
      new->q_status = (char *)"4.5.2";
#line 962
      giveresponse(75, new->q_status, m, (struct mailer_con_info *)((void *)0), new->q_alias,
                   (time_t )0, e, new);
      }
#line 964
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 966
      new->q_state = (short)2;
#line 967
      new->q_status = (char *)"5.1.1";
#line 968
      new->q_rstatus = (char *)"550 5.1.1 User unknown";
#line 969
      giveresponse(67, new->q_status, m, (struct mailer_con_info *)((void *)0), new->q_alias,
                   (time_t )0, e, new);
      }
#line 971
      goto switch_break;
      case_0: /* CIL Label */ 
#line 973
      if (fuzzy) {
        {
#line 976
        new->q_user = sm_rpool_strdup_x(e->e_rpool, (char const   *)(user.mbdb_name));
#line 978
        tmp___25 = findusercount;
#line 978
        findusercount ++;
        }
#line 978
        if (tmp___25 > 3) {
          {
#line 980
          new->q_state = (short)2;
#line 981
          new->q_status = (char *)"5.4.6";
#line 982
          usrerrenh(new->q_status, "554 aliasing/forwarding loop for %s broken", user.mbdb_name);
          }
#line 985
          goto done;
        }
        {
#line 989
        sm_strlcpy(buf___16, (char const   *)(user.mbdb_name), buflen___1);
        }
#line 990
        goto trylocaluser;
      }
#line 992
      if ((int )user.mbdb_homedir[0] == 0) {
#line 993
        new->q_home = (char *)((void *)0);
      } else {
        {
#line 994
        tmp___26 = strcmp((char const   *)(user.mbdb_homedir), "/");
        }
#line 994
        if (tmp___26 == 0) {
#line 995
          new->q_home = (char *)"";
        } else {
          {
#line 997
          new->q_home = sm_rpool_strdup_x(e->e_rpool, (char const   *)(user.mbdb_homedir));
          }
        }
      }
#line 999
      if (user.mbdb_uid != 4294967295U) {
#line 1001
        new->q_uid = user.mbdb_uid;
#line 1002
        new->q_gid = user.mbdb_gid;
#line 1003
        new->q_flags |= 1UL;
      }
      {
#line 1005
      new->q_ruser = sm_rpool_strdup_x(e->e_rpool, (char const   *)(user.mbdb_name));
      }
#line 1007
      if ((int )user.mbdb_fullname[0] != 0) {
        {
#line 1008
        new->q_fullname = sm_rpool_strdup_x(e->e_rpool, (char const   *)(user.mbdb_fullname));
        }
      }
      {
#line 1010
      tmp___27 = usershellok(user.mbdb_name, user.mbdb_shell);
      }
#line 1010
      if (! tmp___27) {
#line 1012
        new->q_flags |= 16UL;
      }
#line 1014
      if ((e->e_flags & 512UL) != 0UL) {
#line 1017
        new->q_state = (short)5;
      } else
#line 1019
      if (! quoted) {
        {
#line 1020
        forward(new, sendq, aliaslevel, e);
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1023
  if (! ((int )new->q_state >= 6)) {
#line 1024
    (e->e_nrcpts) ++;
  }
  testselfdestruct: 
#line 1027
  new->q_flags |= 1073741824UL;
#line 1028
  if ((int )tTdvect[26] >= 8) {
    {
#line 1030
    sm_dprintf((char *)"testselfdestruct: ");
#line 1031
    tmp___28 = sm_debug_file();
#line 1031
    printaddr(tmp___28, new, 0);
    }
#line 1032
    if ((int )tTdvect[26] >= 10) {
      {
#line 1034
      sm_dprintf((char *)"SENDQ:\n");
#line 1035
      tmp___29 = sm_debug_file();
#line 1035
      printaddr(tmp___29, *sendq, 1);
#line 1036
      sm_dprintf((char *)"----\n");
      }
    }
  }
#line 1039
  if ((unsigned long )new->q_alias == (unsigned long )((void *)0)) {
#line 1039
    if ((unsigned long )new != (unsigned long )(& e->e_from)) {
#line 1039
      if ((int )new->q_state >= 6) {
#line 1042
        q = *sendq;
        {
#line 1042
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1042
          if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 1042
            goto while_break___2;
          }
#line 1044
          if (! ((int )q->q_state >= 6)) {
#line 1045
            goto while_break___2;
          }
#line 1042
          q = q->q_next;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1047
        if ((unsigned long )q == (unsigned long )((void *)0)) {
          {
#line 1049
          new->q_state = (short)2;
#line 1050
          new->q_status = (char *)"5.4.6";
#line 1051
          usrerrenh(new->q_status, "554 aliasing/forwarding loop broken");
          }
        }
      }
    }
  }
  done: 
#line 1057
  new->q_flags |= 1073741824UL;
#line 1058
  if ((unsigned long )buf___16 != (unsigned long )(buf0)) {
    {
#line 1059
    sm_free_tagged((void *)buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                   1059);
    }
  }
#line 1069
  if (aliaslevel == 0) {
#line 1071
    nrcpts = 0;
#line 1072
    only = (ADDRESS *)((void *)0);
#line 1074
    q = *sendq;
    {
#line 1074
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1074
      if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 1074
        goto while_break___3;
      }
#line 1076
      if ((q->q_flags & 1073741824UL) != 0UL) {
#line 1076
        if ((int )q->q_state == 0) {
#line 1079
          nrcpts ++;
#line 1080
          only = q;
        } else
#line 1076
        if ((int )q->q_state == 3) {
#line 1079
          nrcpts ++;
#line 1080
          only = q;
        } else
#line 1076
        if ((int )q->q_state == 4) {
#line 1079
          nrcpts ++;
#line 1080
          only = q;
        }
      }
#line 1082
      q->q_flags &= 0xffffffffbfffffffUL;
#line 1074
      q = q->q_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1084
    if (nrcpts == 1) {
#line 1087
      q = only;
      {
#line 1088
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1088
        q = q->q_alias;
#line 1088
        if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 1088
          goto while_break___4;
        }
#line 1090
        if ((unsigned long )q->q_owner != (unsigned long )((void *)0)) {
#line 1091
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1093
      if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 1094
        only->q_flags |= 2UL;
      }
    } else
#line 1096
    if (! initialdontsend) {
#line 1096
      if (nrcpts > 0) {
#line 1099
        e->e_flags |= 16UL;
#line 1100
        new->q_flags |= 2048UL;
#line 1101
        if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
#line 1101
          if ((new->q_flags & 64UL) != 0UL) {
            {
#line 1103
            sm_io_fprintf(e->e_xfp, -2, "%s... expanded to multiple addresses\n",
                          new->q_paddr);
            }
          }
        }
      }
    }
  }
  {
#line 1108
  new->q_flags |= 2147483648UL;
#line 1109
  sm_snprintf(buf0, (size_t )sizeof(buf0), "%d", e->e_nrcpts);
#line 1110
  tmp___30 = macid_parse((char *)"{nrcpts}", (char **)((void *)0));
#line 1110
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___30, buf0, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c",
                   1110, SmHeapGroup);
  }
#line 1111
  return (new);
}
}
#line 1138 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
int finduser(char *name , bool *fuzzyp , SM_MBDB_T *user ) 
{ 
  register struct passwd *pw ;
  register char *p ;
  bool tryagain ;
  int status ;
  char *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char buf___16[257] ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 1151
  if ((int )tTdvect[29] >= 4) {
    {
#line 1152
    sm_dprintf((char *)"finduser(%s): ", name);
    }
  }
  {
#line 1154
  *fuzzyp = 0;
#line 1170
  status = sm_mbdb_lookup(name, user);
  }
#line 1171
  if (status != 67) {
#line 1173
    if ((int )tTdvect[29] >= 4) {
      {
#line 1174
      tmp = sm_strexit(status);
#line 1174
      sm_dprintf((char *)"%s (non-fuzzy)\n", tmp);
      }
    }
#line 1175
    return (status);
  }
#line 1179
  tryagain = 0;
#line 1180
  p = name;
  {
#line 1180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1180
    if (! ((int )*p != 0)) {
#line 1180
      goto while_break;
    }
#line 1182
    if (((int )*p & -128) == 0) {
      {
#line 1182
      tmp___1 = __ctype_b_loc();
      }
#line 1182
      if ((int const   )*(*tmp___1 + (int )*p) & 256) {
        {
#line 1184
        tmp___0 = tolower((int )*p);
#line 1184
        *p = (char )tmp___0;
#line 1185
        tryagain = 1;
        }
      }
    }
#line 1180
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1188
  if (tryagain) {
    {
#line 1188
    status = sm_mbdb_lookup(name, user);
    }
#line 1188
    if (status != 67) {
#line 1190
      if ((int )tTdvect[29] >= 4) {
        {
#line 1191
        tmp___2 = sm_strexit(status);
#line 1191
        sm_dprintf((char *)"%s (lower case)\n", tmp___2);
        }
      }
#line 1192
      *fuzzyp = 1;
#line 1193
      return (status);
    }
  }
#line 1198
  if (! MatchGecos) {
#line 1200
    if ((int )tTdvect[29] >= 4) {
      {
#line 1201
      sm_dprintf((char *)"not found (fuzzy disabled)\n");
      }
    }
#line 1202
    return (67);
  }
#line 1206
  p = name;
  {
#line 1206
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1206
    if (! ((int )*p != 0)) {
#line 1206
      goto while_break___0;
    }
#line 1208
    if ((int )*p == ((int )SpaceSub & 127)) {
#line 1209
      *p = (char )' ';
    } else
#line 1208
    if ((int )*p == 95) {
#line 1209
      *p = (char )' ';
    }
#line 1206
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1211
  setpwent();
  }
  {
#line 1212
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1212
    pw = getpwent();
    }
#line 1212
    if (! ((unsigned long )pw != (unsigned long )((void *)0))) {
#line 1212
      goto while_break___1;
    }
    {
#line 1225
    sm_pwfullname(pw->pw_gecos, pw->pw_name, buf___16, (size_t )sizeof(buf___16));
#line 1226
    tmp___3 = strchr((char const   *)(buf___16), ' ');
    }
#line 1226
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
      {
#line 1226
      tmp___4 = sm_strcasecmp((char const   *)(buf___16), (char const   *)name);
      }
#line 1226
      if (tmp___4 == 0) {
#line 1228
        if ((int )tTdvect[29] >= 4) {
          {
#line 1229
          sm_dprintf((char *)"fuzzy matches %s\n", pw->pw_name);
          }
        }
        {
#line 1230
        message("sending to login name %s", pw->pw_name);
        }
#line 1231
        goto while_break___1;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1234
  if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 1235
    *fuzzyp = 1;
  } else
#line 1236
  if ((int )tTdvect[29] >= 4) {
    {
#line 1237
    sm_dprintf((char *)"no fuzzy match found\n");
    }
  }
#line 1241
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
#line 1242
    return (67);
  }
  {
#line 1243
  sm_mbdb_frompw(user, pw);
  }
#line 1244
  return (0);
}
}
#line 1275 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
bool writable(char *filename , ADDRESS *ctladdr , long flags ) 
{ 
  uid_t euid ;
  gid_t egid ;
  char *user ;
  __uid_t tmp ;
  __uid_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 1281
  euid = (uid_t )0;
#line 1282
  egid = (gid_t )0;
#line 1283
  user = (char *)((void *)0);
#line 1285
  if ((int )tTdvect[44] >= 5) {
    {
#line 1286
    sm_dprintf((char *)"writable(%s, 0x%lx)\n", filename, flags);
    }
  }
  {
#line 1292
  tmp = geteuid();
  }
#line 1292
  if (tmp != 0U) {
    {
#line 1294
    euid = geteuid();
#line 1295
    egid = getegid();
#line 1296
    user = (char *)((void *)0);
    }
  } else
#line 1298
  if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
#line 1300
    euid = ctladdr->q_uid;
#line 1301
    egid = ctladdr->q_gid;
#line 1302
    user = ctladdr->q_user;
  } else
#line 1304
  if ((flags & 8L) != 0L) {
#line 1306
    euid = RealUid;
#line 1307
    egid = RealGid;
#line 1308
    user = RealUserName;
  } else
#line 1310
  if ((unsigned long )FileMailer != (unsigned long )((void *)0)) {
#line 1310
    if (! ((flags & 4L) != 0L)) {
#line 1312
      if (FileMailer->m_uid == 4294967295U) {
#line 1314
        euid = DefUid;
#line 1315
        user = DefUser;
      } else {
#line 1319
        euid = FileMailer->m_uid;
#line 1320
        user = (char *)((void *)0);
      }
#line 1322
      if (FileMailer->m_gid == 4294967295U) {
#line 1323
        egid = DefGid;
      } else {
#line 1325
        egid = FileMailer->m_gid;
      }
    } else {
#line 1329
      egid = (gid_t )0;
#line 1329
      euid = egid;
#line 1330
      user = (char *)((void *)0);
    }
  } else {
#line 1329
    egid = (gid_t )0;
#line 1329
    euid = egid;
#line 1330
    user = (char *)((void *)0);
  }
#line 1332
  if (! ((flags & 4L) != 0L)) {
#line 1334
    if (euid == 0U) {
#line 1336
      euid = DefUid;
#line 1337
      user = DefUser;
    }
#line 1339
    if (egid == 0U) {
#line 1340
      egid = DefGid;
    }
  }
  {
#line 1342
  tmp___0 = geteuid();
  }
#line 1342
  if (tmp___0 == 0U) {
#line 1342
    if ((unsigned long )ctladdr == (unsigned long )((void *)0)) {
#line 1344
      flags |= 32L;
    } else
#line 1342
    if (! ((ctladdr->q_flags & 1UL) != 0UL)) {
#line 1344
      flags |= 32L;
    }
  }
#line 1346
  if (! (DontBlameSendmail[16UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 16UL % (8UL * sizeof(int ))))) {
#line 1347
    flags |= 2L;
  }
#line 1348
  if (! (DontBlameSendmail[15UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 15UL % (8UL * sizeof(int ))))) {
#line 1349
    flags |= 512L;
  }
  {
#line 1351
  tmp___1 = __errno_location();
#line 1351
  *tmp___1 = safefile(filename, euid, egid, user, flags, 128, (struct stat *)((void *)0));
#line 1352
  tmp___2 = __errno_location();
  }
#line 1352
  return (*tmp___2 == 0);
}
}
#line 1390 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
static sigjmp_buf CtxIncludeTimeout  ;
#line 1392 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
int include(char *fname , bool forwarding , ADDRESS *ctladdr , ADDRESS **sendq , int aliaslevel ,
            ENVELOPE *e ) 
{ 
  SM_FILE_T * volatile  fp ;
  char *oldto ;
  char *oldfilename ;
  int oldlinenumber ;
  register SM_EVENT *ev ;
  int nincludes ;
  int mode ;
  bool volatile   maxreached ;
  register ADDRESS *ca ;
  uid_t volatile   saveduid ;
  gid_t volatile   savedgid ;
  uid_t volatile   uid ;
  gid_t volatile   gid ;
  char * volatile  user ;
  int rval ;
  long volatile   sfflags ;
  register char *p ;
  bool safechown ;
  bool volatile   safedir ;
  struct stat st ;
  char buf___16[2048] ;
  __uid_t tmp ;
  __uid_t tmp___0 ;
  SM_FILE_T *tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __gid_t tmp___7 ;
  int tmp___8 ;
  gid_t gidset[1] ;
  int tmp___9 ;
  int tmp___10 ;
  __uid_t tmp___11 ;
  __uid_t tmp___12 ;
  int tmp___13 ;
  __uid_t tmp___14 ;
  __uid_t tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int ret ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char const   *tmp___27 ;
  int *tmp___28 ;
  char const   *tmp___29 ;
  int tmp___30 ;
  bool tmp___31 ;
  SM_FILE_T *tmp___32 ;
  __uid_t tmp___33 ;
  __uid_t tmp___34 ;
  int tmp___35 ;
  __uid_t tmp___36 ;
  __uid_t tmp___37 ;
  int tmp___38 ;
  __gid_t tmp___39 ;
  __gid_t tmp___40 ;
  int tmp___41 ;
  __uid_t tmp___42 ;
  __uid_t tmp___43 ;
  int *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  char const   *tmp___48 ;
  char const   *tmp___49 ;
  register struct passwd *pw ;
  char *sh ;
  char const   *tmp___50 ;
  char *tmp___51 ;
  bool tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  char const   *tmp___55 ;
  char *tmp___56 ;
  char const   *tmp___57 ;
  char const   *tmp___58 ;
  char *tmp___59 ;
  unsigned short const   **tmp___60 ;
  unsigned short const   **tmp___61 ;
  unsigned short const   **tmp___62 ;
  char const   *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  char *tmp___66 ;
  int *tmp___67 ;
  char const   *tmp___68 ;
  SM_FILE_T *tmp___69 ;
  void *__cil_tmp103 ;
  void *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;

  {
#line 1401
  fp = (SM_FILE_T */* volatile  */)((void *)0);
#line 1402
  oldto = e->e_to;
#line 1403
  oldfilename = FileName;
#line 1404
  oldlinenumber = LineNumber;
#line 1405
  ev = (SM_EVENT *)((void *)0);
#line 1408
  maxreached = (bool volatile   )0;
#line 1415
  rval = 0;
#line 1416
  sfflags = (long volatile   )128L;
#line 1418
  safechown = 0;
#line 1419
  safedir = (bool volatile   )0;
#line 1423
  if ((int )tTdvect[27] >= 2) {
    {
#line 1424
    sm_dprintf((char *)"include(%s)\n", fname);
    }
  }
#line 1425
  if ((int )tTdvect[27] >= 4) {
    {
#line 1426
    tmp = geteuid();
#line 1426
    tmp___0 = getuid();
#line 1426
    sm_dprintf((char *)"   ruid=%d euid=%d\n", (int )tmp___0, (int )tmp);
    }
  }
#line 1428
  if ((int )tTdvect[27] >= 14) {
    {
#line 1430
    sm_dprintf((char *)"ctladdr ");
#line 1431
    tmp___1 = sm_debug_file();
#line 1431
    printaddr(tmp___1, ctladdr, 0);
    }
  }
#line 1434
  if ((int )tTdvect[27] >= 9) {
    {
#line 1435
    tmp___2 = geteuid();
#line 1435
    tmp___3 = getuid();
#line 1435
    sm_dprintf((char *)"include: old uid = %d/%d\n", (int )tmp___3, (int )tmp___2);
    }
  }
#line 1438
  if (forwarding) {
#line 1440
    sfflags |= (long volatile   )5L;
#line 1441
    if (! (DontBlameSendmail[37UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 37UL % (8UL * sizeof(int ))))) {
#line 1442
      sfflags |= (long volatile   )2048L;
    }
#line 1443
    if (! (DontBlameSendmail[39UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 39UL % (8UL * sizeof(int ))))) {
#line 1444
      sfflags |= (long volatile   )4096L;
    }
  } else {
#line 1448
    if (! (DontBlameSendmail[38UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 38UL % (8UL * sizeof(int ))))) {
#line 1449
      sfflags |= (long volatile   )2048L;
    }
#line 1450
    if (! (DontBlameSendmail[40UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 40UL % (8UL * sizeof(int ))))) {
#line 1451
      sfflags |= (long volatile   )4096L;
    }
  }
  {
#line 1459
  tmp___5 = geteuid();
  }
#line 1459
  if (tmp___5 != 0U) {
#line 1459
    goto _L;
  } else
#line 1459
  if (RunAsUid != 0U) {
    _L: /* CIL Label */ 
#line 1459
    if (! (DontBlameSendmail[31UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 31UL % (8UL * sizeof(int ))))) {
#line 1462
      if ((int )tTdvect[27] >= 4) {
        {
#line 1463
        tmp___4 = geteuid();
#line 1463
        sm_dprintf((char *)"include: not safe (euid=%d, RunAsUid=%d)\n", (int )tmp___4,
                   (int )RunAsUid);
        }
      }
#line 1465
      ctladdr->q_flags |= 32UL;
    }
  }
  {
#line 1468
  ca = getctladdr(ctladdr);
  }
#line 1469
  if ((unsigned long )ca == (unsigned long )((void *)0)) {
#line 1472
    uid = (uid_t volatile   )DefUid;
#line 1473
    gid = (gid_t volatile   )DefGid;
#line 1474
    user = (char */* volatile  */)DefUser;
  } else
#line 1469
  if (ca->q_uid == DefUid) {
#line 1469
    if (ca->q_gid == 0U) {
#line 1472
      uid = (uid_t volatile   )DefUid;
#line 1473
      gid = (gid_t volatile   )DefGid;
#line 1474
      user = (char */* volatile  */)DefUser;
    } else {
#line 1478
      uid = (uid_t volatile   )ca->q_uid;
#line 1479
      gid = (gid_t volatile   )ca->q_gid;
#line 1480
      user = (char */* volatile  */)ca->q_user;
    }
  } else {
#line 1478
    uid = (uid_t volatile   )ca->q_uid;
#line 1479
    gid = (gid_t volatile   )ca->q_gid;
#line 1480
    user = (char */* volatile  */)ca->q_user;
  }
  {
#line 1483
  tmp___6 = geteuid();
#line 1483
  saveduid = (uid_t volatile   )tmp___6;
#line 1484
  tmp___7 = getegid();
#line 1484
  savedgid = (gid_t volatile   )tmp___7;
  }
#line 1485
  if (saveduid == (uid_t volatile   )0) {
#line 1487
    if (! DontInitGroups) {
      {
#line 1489
      tmp___8 = initgroups((char const   *)user, (__gid_t )gid);
      }
#line 1489
      if (tmp___8 == -1) {
        {
#line 1491
        rval = 11;
#line 1492
        syserr("include: initgroups(%s, %d) failed", user, gid);
        }
#line 1494
        goto resetuid;
      }
    } else {
      {
#line 1501
      gidset[0] = (gid_t )gid;
#line 1502
      tmp___9 = setgroups((size_t )1, (__gid_t const   *)(gidset));
      }
#line 1502
      if (tmp___9 == -1) {
        {
#line 1504
        rval = 11;
#line 1505
        syserr("include: setgroups() failed");
        }
#line 1506
        goto resetuid;
      }
    }
#line 1510
    if (gid != (gid_t volatile   )0) {
      {
#line 1510
      tmp___10 = setgid((__gid_t )gid);
      }
#line 1510
      if (tmp___10 < -1) {
        {
#line 1512
        rval = 11;
#line 1513
        syserr("setgid(%d) failure", gid);
        }
#line 1514
        goto resetuid;
      }
    }
#line 1516
    if (uid != (uid_t volatile   )0) {
      {
#line 1528
      tmp___13 = setreuid((__uid_t )0, (__uid_t )uid);
      }
#line 1528
      if (tmp___13 < 0) {
        {
#line 1530
        rval = 11;
#line 1531
        tmp___11 = geteuid();
#line 1531
        tmp___12 = getuid();
#line 1531
        syserr("setreuid(0, %d) failure (real=%d, eff=%d)", uid, (int )tmp___12, (int )tmp___11);
        }
#line 1533
        goto resetuid;
      }
    }
  }
#line 1540
  if ((int )tTdvect[27] >= 9) {
    {
#line 1541
    tmp___14 = geteuid();
#line 1541
    tmp___15 = getuid();
#line 1541
    sm_dprintf((char *)"include: new uid = %d/%d\n", (int )tmp___15, (int )tmp___14);
    }
  }
  {
#line 1549
  tmp___17 = __sigsetjmp((struct __jmp_buf_tag *)(CtxIncludeTimeout), 1);
  }
#line 1549
  if (tmp___17 != 0) {
    {
#line 1551
    ctladdr->q_state = (short)3;
#line 1552
    tmp___16 = __errno_location();
#line 1552
    *tmp___16 = 0;
#line 1555
    rval = 256;
    }
#line 1556
    goto resetuid;
  }
#line 1558
  if (TimeOuts.to_fileopen > 0L) {
    {
#line 1559
    ev = sm_seteventm((int )(TimeOuts.to_fileopen * 1000L), & includetimeout, 0);
    }
  } else {
#line 1561
    ev = (SM_EVENT *)((void *)0);
  }
  {
#line 1565
  p = strrchr((char const   *)fname, '/');
  }
#line 1566
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1570
    *p = (char )'\000';
#line 1571
    ret = safedirpath(fname, (uid_t )uid, (gid_t )gid, (char *)user, (long )(sfflags | (long volatile   )256L),
                      0, 0);
    }
#line 1573
    if (ret == 0) {
#line 1576
      safedir = (bool volatile   )1;
#line 1577
      sfflags |= (long volatile   )16L;
    } else {
#line 1581
      if (forwarding) {
#line 1581
        tmp___20 = 7;
      } else {
#line 1581
        tmp___20 = 30;
      }
#line 1581
      if (forwarding) {
#line 1581
        tmp___21 = 7;
      } else {
#line 1581
        tmp___21 = 30;
      }
#line 1581
      if (DontBlameSendmail[(unsigned long )((unsigned char )tmp___20) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )tmp___21) % (8UL * sizeof(int )))) {
#line 1585
        sfflags |= (long volatile   )16L;
      } else {
#line 1586
        if (forwarding) {
#line 1586
          tmp___18 = 21;
        } else {
#line 1586
          tmp___18 = 22;
        }
#line 1586
        if (forwarding) {
#line 1586
          tmp___19 = 21;
        } else {
#line 1586
          tmp___19 = 22;
        }
#line 1586
        if (DontBlameSendmail[(unsigned long )((unsigned char )tmp___18) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )tmp___19) % (8UL * sizeof(int )))) {
#line 1586
          if (ret == 262) {
            {
#line 1592
            DontBlameSendmail[2UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 2UL % (8UL * sizeof(int ));
#line 1594
            ret = safedirpath(fname, (uid_t )uid, (gid_t )gid, (char *)user, (long )(sfflags | (long volatile   )256L),
                              0, 0);
#line 1597
            DontBlameSendmail[2UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] &= ~ (1U << 2UL % (8UL * sizeof(int )));
            }
#line 1599
            if (ret == 0) {
#line 1600
              sfflags |= (long volatile   )16L;
            } else {
#line 1602
              sfflags |= (long volatile   )256L;
            }
          } else {
#line 1605
            sfflags |= (long volatile   )256L;
          }
        } else {
#line 1605
          sfflags |= (long volatile   )256L;
        }
      }
#line 1606
      if (ret > 256) {
#line 1606
        if (forwarding) {
#line 1606
          tmp___23 = 26;
        } else {
#line 1606
          tmp___23 = 27;
        }
#line 1606
        if (forwarding) {
#line 1606
          tmp___24 = 26;
        } else {
#line 1606
          tmp___24 = 27;
        }
#line 1606
        if (! (DontBlameSendmail[(unsigned long )((unsigned char )tmp___23) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )tmp___24) % (8UL * sizeof(int ))))) {
#line 1612
          if (LogLevel > 11) {
            {
#line 1613
            tmp___22 = shortenstring((char const   *)fname, (size_t )203);
#line 1613
            sm_syslog(6, (char const   *)e->e_id, "%s: unsafe directory path, marked unsafe",
                      tmp___22);
            }
          }
#line 1616
          ctladdr->q_flags |= 32UL;
        }
      }
    }
#line 1619
    *p = (char )'/';
  }
#line 1623
  if (! safedir) {
#line 1623
    if (forwarding) {
#line 1623
      tmp___25 = 11;
    } else {
#line 1623
      tmp___25 = 12;
    }
#line 1623
    if (forwarding) {
#line 1623
      tmp___26 = 11;
    } else {
#line 1623
      tmp___26 = 12;
    }
#line 1623
    if (! (DontBlameSendmail[(unsigned long )((unsigned char )tmp___25) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )tmp___26) % (8UL * sizeof(int ))))) {
#line 1628
      sfflags |= (long volatile   )514L;
    }
  }
  {
#line 1630
  rval = safefile(fname, (uid_t )uid, (gid_t )gid, (char *)user, (long )sfflags, 256,
                  & st);
  }
#line 1631
  if (rval != 0) {
#line 1634
    if ((int )tTdvect[27] >= 4) {
      {
#line 1635
      tmp___27 = sm_errstring(rval);
#line 1635
      sm_dprintf((char *)"include: not safe (uid=%d): %s\n", (int )uid, tmp___27);
      }
    }
  } else {
    {
#line 1638
    tmp___32 = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)fname,
                          2, (void const   *)((void *)0));
#line 1638
    fp = (SM_FILE_T */* volatile  */)tmp___32;
    }
#line 1638
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 1641
      tmp___28 = __errno_location();
#line 1641
      rval = *tmp___28;
      }
#line 1642
      if ((int )tTdvect[27] >= 4) {
        {
#line 1643
        tmp___29 = sm_errstring(rval);
#line 1643
        sm_dprintf((char *)"include: open: %s\n", tmp___29);
        }
      }
    } else {
      {
#line 1645
      tmp___30 = sm_io_getinfo((SM_FILE_T *)fp, 3, (void *)0);
#line 1645
      tmp___31 = filechanged(fname, tmp___30, & st);
      }
#line 1645
      if (tmp___31) {
#line 1647
        rval = 263;
#line 1648
        if ((int )tTdvect[27] >= 4) {
          {
#line 1649
          sm_dprintf((char *)"include: file changed after open\n");
          }
        }
      }
    }
  }
#line 1651
  if ((unsigned long )ev != (unsigned long )((void *)0)) {
    {
#line 1652
    sm_clrevent(ev);
    }
  }
  resetuid: 
#line 1657
  if (saveduid == (uid_t volatile   )0) {
#line 1659
    if (uid != (uid_t volatile   )0) {
      {
#line 1666
      tmp___35 = setreuid((__uid_t )-1, (__uid_t )0);
      }
#line 1666
      if (tmp___35 < 0) {
        {
#line 1667
        tmp___33 = geteuid();
#line 1667
        tmp___34 = getuid();
#line 1667
        syserr("!setreuid(-1, 0) failure (real=%d, eff=%d)", (int )tmp___34, (int )tmp___33);
        }
      }
      {
#line 1669
      tmp___38 = setreuid(RealUid, (__uid_t )0);
      }
#line 1669
      if (tmp___38 < 0) {
        {
#line 1670
        tmp___36 = geteuid();
#line 1670
        tmp___37 = getuid();
#line 1670
        syserr("!setreuid(%d, 0) failure (real=%d, eff=%d)", (int )RealUid, (int )tmp___37,
               (int )tmp___36);
        }
      }
    }
    {
#line 1675
    tmp___41 = setgid((__gid_t )savedgid);
    }
#line 1675
    if (tmp___41 < 0) {
      {
#line 1676
      tmp___39 = getegid();
#line 1676
      tmp___40 = getgid();
#line 1676
      syserr("!setgid(%d) failure (real=%d eff=%d)", (int )savedgid, (int )tmp___40,
             (int )tmp___39);
      }
    }
  }
#line 1682
  if ((int )tTdvect[27] >= 9) {
    {
#line 1683
    tmp___42 = geteuid();
#line 1683
    tmp___43 = getuid();
#line 1683
    sm_dprintf((char *)"include: reset uid = %d/%d\n", (int )tmp___43, (int )tmp___42);
    }
  }
#line 1686
  if (rval == 256) {
    {
#line 1687
    usrerr("451 4.4.1 open timeout on %s", fname);
    }
  }
#line 1689
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1690
    return (rval);
  }
  {
#line 1692
  tmp___45 = sm_io_getinfo((SM_FILE_T *)fp, 3, (void *)0);
#line 1692
  tmp___46 = fstat(tmp___45, & st);
  }
#line 1692
  if (tmp___46 < 0) {
    {
#line 1694
    tmp___44 = __errno_location();
#line 1694
    rval = *tmp___44;
#line 1695
    syserr("Cannot fstat %s!", fname);
#line 1696
    sm_io_close((SM_FILE_T *)fp, -2);
    }
#line 1697
    return (rval);
  }
  {
#line 1701
  tmp___47 = sm_io_getinfo((SM_FILE_T *)fp, 3, (void *)0);
#line 1701
  safechown = chownsafe(tmp___47, (bool )safedir);
  }
#line 1702
  if ((int )tTdvect[27] >= 6) {
#line 1703
    if (safechown) {
#line 1703
      tmp___48 = "";
    } else {
#line 1703
      tmp___48 = "un";
    }
#line 1703
    if (safedir) {
#line 1703
      tmp___49 = "safe";
    } else {
#line 1703
      tmp___49 = "dangerous";
    }
    {
#line 1703
    sm_dprintf((char *)"include: parent of %s is %s, chown is %ssafe\n", fname, tmp___49,
               tmp___48);
    }
  }
#line 1708
  if (safechown) {
#line 1708
    if ((unsigned long )ca == (unsigned long )((void *)0)) {
#line 1712
      ctladdr->q_uid = st.st_uid;
#line 1713
      ctladdr->q_gid = st.st_gid;
#line 1714
      ctladdr->q_flags |= 1UL;
    } else
#line 1708
    if (ca->q_uid == DefUid) {
#line 1708
      if (ca->q_gid == 0U) {
#line 1712
        ctladdr->q_uid = st.st_uid;
#line 1713
        ctladdr->q_gid = st.st_gid;
#line 1714
        ctladdr->q_flags |= 1UL;
      }
    }
  }
#line 1716
  if ((unsigned long )ca != (unsigned long )((void *)0)) {
#line 1716
    if (ca->q_uid == st.st_uid) {
#line 1719
      ctladdr->q_flags |= ca->q_flags & 16UL;
#line 1720
      ctladdr->q_ruser = ca->q_ruser;
    } else {
#line 1716
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1722
  if (! forwarding) {
    {
#line 1726
    pw = sm_getpwuid(st.st_uid);
    }
#line 1727
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
#line 1729
      ctladdr->q_uid = st.st_uid;
#line 1730
      ctladdr->q_flags |= 16UL;
    } else {
      {
#line 1736
      ctladdr->q_ruser = sm_rpool_strdup_x(e->e_rpool, (char const   *)pw->pw_name);
      }
#line 1738
      if (safechown) {
#line 1739
        sh = pw->pw_shell;
      } else {
#line 1741
        sh = (char *)"/SENDMAIL/ANY/SHELL/";
      }
      {
#line 1742
      tmp___52 = usershellok(pw->pw_name, sh);
      }
#line 1742
      if (! tmp___52) {
#line 1744
        if (LogLevel > 11) {
#line 1745
          if (safechown) {
#line 1745
            tmp___50 = "bogus";
          } else {
#line 1745
            tmp___50 = "unsafe";
          }
          {
#line 1745
          tmp___51 = shortenstring((char const   *)fname, (size_t )203);
#line 1745
          sm_syslog(6, (char const   *)e->e_id, "%s: user %s has bad shell %s, marked %s",
                    tmp___51, pw->pw_name, sh, tmp___50);
          }
        }
#line 1751
        if (safechown) {
#line 1752
          ctladdr->q_flags |= 16UL;
        } else {
#line 1754
          ctladdr->q_flags |= 32UL;
        }
      }
    }
  }
#line 1759
  if ((e->e_flags & 512UL) != 0UL) {
    {
#line 1762
    ctladdr->q_state = (short)5;
#line 1763
    (e->e_nrcpts) ++;
#line 1764
    sm_io_close((SM_FILE_T *)fp, -2);
    }
#line 1765
    return (rval);
  }
#line 1776
  mode = (128 >> 3) >> 3;
#line 1777
  if (forwarding) {
#line 1777
    tmp___53 = 3;
  } else {
#line 1777
    tmp___53 = 4;
  }
#line 1777
  if (forwarding) {
#line 1777
    tmp___54 = 3;
  } else {
#line 1777
    tmp___54 = 4;
  }
#line 1777
  if (! (DontBlameSendmail[(unsigned long )((unsigned char )tmp___53) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )tmp___54) % (8UL * sizeof(int ))))) {
#line 1781
    mode |= 128 >> 3;
  }
#line 1783
  if ((st.st_mode & (unsigned int )mode) != 0U) {
#line 1785
    if ((int )tTdvect[27] >= 6) {
#line 1786
      if ((st.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
#line 1786
        tmp___55 = "world";
      } else {
#line 1786
        tmp___55 = "group";
      }
      {
#line 1786
      tmp___56 = shortenstring((char const   *)fname, (size_t )203);
#line 1786
      sm_dprintf((char *)"include: %s is %s writable, marked unsafe\n", tmp___56,
                 tmp___55);
      }
    }
#line 1790
    if (LogLevel > 11) {
#line 1791
      if (forwarding) {
#line 1791
        tmp___57 = "forward";
      } else {
#line 1791
        tmp___57 = ":include:";
      }
#line 1791
      if ((st.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U) {
#line 1791
        tmp___58 = "world";
      } else {
#line 1791
        tmp___58 = "group";
      }
      {
#line 1791
      tmp___59 = shortenstring((char const   *)fname, (size_t )203);
#line 1791
      sm_syslog(6, (char const   *)e->e_id, "%s: %s writable %s file, marked unsafe",
                tmp___59, tmp___58, tmp___57);
      }
    }
#line 1796
    ctladdr->q_flags |= 32UL;
  }
#line 1800
  FileName = fname;
#line 1801
  LineNumber = 0;
#line 1802
  ctladdr->q_flags &= 0xfffffffffffffff7UL;
#line 1803
  nincludes = 0;
  {
#line 1804
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1804
    tmp___66 = sm_io_fgets((SM_FILE_T *)fp, -2, buf___16, (int )sizeof(buf___16));
    }
#line 1804
    if ((unsigned long )tmp___66 != (unsigned long )((void *)0)) {
#line 1804
      if (! (! maxreached)) {
#line 1804
        goto while_break;
      }
    } else {
#line 1804
      goto while_break;
    }
    {
#line 1807
    fixcrlf(buf___16, 1);
#line 1808
    LineNumber ++;
    }
#line 1809
    if ((int )buf___16[0] == 35) {
#line 1810
      goto while_continue;
    } else
#line 1809
    if ((int )buf___16[0] == 0) {
#line 1810
      goto while_continue;
    }
#line 1814
    p = buf___16;
    {
#line 1814
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1814
      p ++;
#line 1814
      p = strchr((char const   *)p, '#');
      }
#line 1814
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1814
        goto while_break___0;
      }
#line 1816
      if ((int )*(p + 1) == 64) {
#line 1816
        if ((int )*(p + 2) == 35) {
#line 1816
          if (((int )*(p + -1) & -128) == 0) {
            {
#line 1816
            tmp___61 = __ctype_b_loc();
            }
#line 1816
            if ((int const   )*(*tmp___61 + (int )*(p + -1)) & 8192) {
#line 1816
              if ((int )*(p + 3) == 0) {
#line 1816
                goto _L___1;
              } else
#line 1816
              if (((int )*(p + 3) & -128) == 0) {
                {
#line 1816
                tmp___62 = __ctype_b_loc();
                }
#line 1816
                if ((int const   )*(*tmp___62 + (int )*(p + 3)) & 8192) {
                  _L___1: /* CIL Label */ 
#line 1820
                  p --;
                  {
#line 1821
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
#line 1821
                    if ((unsigned long )p > (unsigned long )(buf___16)) {
#line 1821
                      if (((int )*(p + -1) & -128) == 0) {
                        {
#line 1821
                        tmp___60 = __ctype_b_loc();
                        }
#line 1821
                        if (! ((int const   )*(*tmp___60 + (int )*(p + -1)) & 8192)) {
#line 1821
                          goto while_break___1;
                        }
                      } else {
#line 1821
                        goto while_break___1;
                      }
                    } else {
#line 1821
                      goto while_break___1;
                    }
#line 1823
                    p --;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
#line 1824
                  *(p + 0) = (char )'\000';
#line 1825
                  goto while_break___0;
                }
              }
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1828
    if ((int )buf___16[0] == 0) {
#line 1829
      goto while_continue;
    }
#line 1831
    e->e_to = (char *)((void *)0);
#line 1832
    if (forwarding) {
#line 1832
      tmp___63 = "forwarding";
    } else {
#line 1832
      tmp___63 = "sending";
    }
    {
#line 1832
    message("%s to %s", tmp___63, buf___16);
    }
#line 1834
    if (forwarding) {
#line 1834
      if (LogLevel > 10) {
        {
#line 1835
        tmp___64 = shortenstring((char const   *)(buf___16), (size_t )203);
#line 1835
        sm_syslog(6, (char const   *)e->e_id, "forward %.200s => %s", oldto, tmp___64);
        }
      }
    }
    {
#line 1839
    tmp___65 = sendtolist(buf___16, ctladdr, sendq, aliaslevel + 1, e);
#line 1839
    nincludes += tmp___65;
    }
#line 1841
    if (forwarding) {
#line 1841
      if (MaxForwardEntries > 0) {
#line 1841
        if (nincludes >= MaxForwardEntries) {
          {
#line 1851
          syserr("Attempt to forward to more than %d addresses (in %s)!", MaxForwardEntries,
                 fname);
#line 1853
          maxreached = (bool volatile   )1;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1857
  if ((fp->f_flags & 256L) != 0L) {
#line 1857
    if ((int )tTdvect[27] >= 3) {
      {
#line 1858
      tmp___67 = __errno_location();
#line 1858
      tmp___68 = sm_errstring(*tmp___67);
#line 1858
      sm_dprintf((char *)"include: read error: %s\n", tmp___68);
      }
    }
  }
#line 1859
  if (nincludes > 0) {
#line 1859
    if (! ((ctladdr->q_flags & 8UL) != 0UL)) {
#line 1861
      if ((int )tTdvect[27] >= 5) {
        {
#line 1863
        sm_dprintf((char *)"include: QS_DONTSEND ");
#line 1864
        tmp___69 = sm_debug_file();
#line 1864
        printaddr(tmp___69, ctladdr, 0);
        }
      }
#line 1866
      ctladdr->q_state = (short)6;
    }
  }
  {
#line 1869
  sm_io_close((SM_FILE_T *)fp, -2);
#line 1870
  FileName = oldfilename;
#line 1871
  LineNumber = oldlinenumber;
#line 1872
  e->e_to = oldto;
  }
#line 1873
  return (rval);
}
}
#line 1876 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
static void includetimeout(int ignore ) 
{ 
  int *tmp ;

  {
  {
#line 1886
  tmp = __errno_location();
#line 1886
  *tmp = 110;
#line 1887
  siglongjmp((struct __jmp_buf_tag *)(CtxIncludeTimeout), 1);
  }
}
}
#line 1904 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
void sendtoargv(char **argv , ENVELOPE *e ) 
{ 
  register char *p ;
  char **tmp ;

  {
  {
#line 1911
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1911
    tmp = argv;
#line 1911
    argv ++;
#line 1911
    p = *tmp;
#line 1911
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1911
      goto while_break;
    }
    {
#line 1912
    sendtolist(p, (ADDRESS *)((void *)0), & e->e_sendqueue, 0, e);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1913
  return;
}
}
#line 1926 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
ADDRESS *getctladdr(ADDRESS *a ) 
{ 


  {
  {
#line 1930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1930
    if ((unsigned long )a != (unsigned long )((void *)0)) {
#line 1930
      if (! (! ((a->q_flags & 1UL) != 0UL))) {
#line 1930
        goto while_break;
      }
    } else {
#line 1930
      goto while_break;
    }
#line 1931
    a = a->q_alias;
  }
  while_break: /* CIL Label */ ;
  }
#line 1932
  return (a);
}
}
#line 1953 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/recipient.c"
static ADDRESS *self_reference(ADDRESS *a ) 
{ 
  ADDRESS *b___0 ;
  ADDRESS *c ;
  bool tmp ;
  SM_MBDB_T user ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1960
  if ((int )tTdvect[27] >= 1) {
    {
#line 1961
    sm_dprintf((char *)"self_reference(%s)\n", a->q_paddr);
    }
  }
#line 1963
  b___0 = a->q_alias;
  {
#line 1963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1963
    if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 1963
      goto while_break;
    }
    {
#line 1965
    tmp = sameaddr(a, b___0);
    }
#line 1965
    if (tmp) {
#line 1966
      goto while_break;
    }
#line 1963
    b___0 = b___0->q_alias;
  }
  while_break: /* CIL Label */ ;
  }
#line 1969
  if ((unsigned long )b___0 == (unsigned long )((void *)0)) {
#line 1971
    if ((int )tTdvect[27] >= 1) {
      {
#line 1972
      sm_dprintf((char *)"\t... no self ref\n");
      }
    }
#line 1973
    return ((ADDRESS *)((void *)0));
  }
#line 1993
  c = a;
  {
#line 1994
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1994
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 1994
      goto while_break___0;
    }
#line 1996
    if ((int )tTdvect[27] >= 10) {
      {
#line 1997
      sm_dprintf((char *)"  %s", c->q_user);
      }
    }
#line 1998
    if ((c->q_mailer)->m_flags[119UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 119UL % (8UL * sizeof(int )))) {
#line 2002
      if ((int )tTdvect[27] >= 2) {
        {
#line 2003
        sm_dprintf((char *)"\t... getpwnam(%s)... ", c->q_user);
        }
      }
      {
#line 2004
      tmp___1 = sm_mbdb_lookup(c->q_user, & user);
      }
#line 2004
      if (tmp___1 == 0) {
#line 2006
        if ((int )tTdvect[27] >= 2) {
          {
#line 2007
          sm_dprintf((char *)"found\n");
          }
        }
        {
#line 2010
        tmp___0 = sameaddr(b___0, c);
        }
#line 2010
        if (tmp___0) {
#line 2011
          return (b___0);
        } else {
#line 2013
          return (c);
        }
      }
#line 2015
      if ((int )tTdvect[27] >= 2) {
        {
#line 2016
        sm_dprintf((char *)"failed\n");
        }
      }
    } else
#line 2021
    if ((c->q_mailer)->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int )))) {
#line 2021
      if ((unsigned long )b___0->q_mailer == (unsigned long )c->q_mailer) {
#line 2024
        if ((int )tTdvect[27] >= 2) {
          {
#line 2025
          sm_dprintf((char *)"\t... local match (%s)\n", c->q_user);
          }
        }
        {
#line 2027
        tmp___2 = sameaddr(b___0, c);
        }
#line 2027
        if (tmp___2) {
#line 2028
          return (b___0);
        } else {
#line 2030
          return (c);
        }
      }
    }
#line 2033
    if ((int )tTdvect[27] >= 10) {
      {
#line 2034
      sm_dprintf((char *)"\n");
      }
    }
#line 2035
    c = c->q_alias;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2038
  if ((int )tTdvect[27] >= 1) {
    {
#line 2039
    sm_dprintf((char *)"\t... cannot break loop for \"%s\"\n", a->q_paddr);
    }
  }
#line 2041
  return ((ADDRESS *)((void *)0));
}
}
#line 199 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 343 "./sendmail.h"
char **prescan(char *addr , int delim , char *pvpbuf , int pvpbsize , char **delimptr ,
               unsigned char *toktab , bool ignore ) ;
#line 464
void makemailer(char *line ) ;
#line 465
void makequeue(char *line , bool qdef ) ;
#line 475
MAILER *Mailer[26] ;
#line 746
int MaxMciCache ;
#line 747
time_t MciCacheTimeout ;
#line 748
time_t MciInfoTimeout ;
#line 811
unsigned long chompheader(char *line , int pflag , HDR **hdrp , ENVELOPE *e ) ;
#line 1001
int NumPriorities ;
#line 1002
struct priority Priorities[25] ;
#line 1102
void setclass(int class , char *str ) ;
#line 1103
int strtorwset(char *p , char **endp , int stabmode ) ;
#line 1274
struct _map *makemapentry(char *line ) ;
#line 1718
char *InputFilterList ;
#line 1940
int MaxQueueRun ;
#line 1941
int MaxQueueChildren ;
#line 1942
int MaxRunnersPerQueue ;
#line 1943
int NiceQueueRun ;
#line 1945
int QueueFileMode ;
#line 1947
int QueueSortOrder ;
#line 1948
time_t MinQueueAge ;
#line 1950
char *QueueDir ;
#line 2039
void inittimeouts(char *val , bool sticky ) ;
#line 2148
bool CheckAliases ;
#line 2152
bool ColonOkInAddr ;
#line 2157
bool DontExpandCnames ;
#line 2161
bool ForkQueueRuns ;
#line 2165
bool HasWildcardMX ;
#line 2168
bool IgnrDot ;
#line 2171
bool MeToo ;
#line 2177
bool RequiresDirfsync ;
#line 2180
bool RrtImpliesDsn ;
#line 2181
bool SaveFrom ;
#line 2184
bool SingleLineFromHeader ;
#line 2185
bool SingleThreadDelivery ;
#line 2191
bool TryNullMXList ;
#line 2193
bool WorkAroundBrokenAAAA ;
#line 2194
bool UseErrorsTo ;
#line 2195
bool UseNameServer ;
#line 2200
int CheckpointInterval ;
#line 2202
int ConnRateThrottle ;
#line 2207
int DontProbeInterfaces ;
#line 2217
int MaxHeadersLength ;
#line 2218
int MaxHopCount ;
#line 2220
int MaxMimeFieldLength ;
#line 2221
int MaxMimeHeaderLength ;
#line 2231
int NoRecipientAction ;
#line 2241
int QueueLA ;
#line 2242
int RefuseLA ;
#line 2243
time_t RejectLogInterval ;
#line 2255
gid_t EffGid ;
#line 2257
key_t ShmKey ;
#line 2269
size_t DataFileBufferSize ;
#line 2271
time_t DialDelay ;
#line 2272
time_t SafeAlias ;
#line 2274
size_t XscriptFileBufferSize ;
#line 2277
long MinBlocksFree ;
#line 2278
long QueueFactor ;
#line 2279
long WkClassFact ;
#line 2280
long WkRecipFact ;
#line 2281
long WkTimeFact ;
#line 2282
char *ControlSocketName ;
#line 2286
char *DefaultCharSet ;
#line 2289
char *FallbackMX ;
#line 2290
char *FallbackSmartHost ;
#line 2292
char *ForwardPath ;
#line 2297
char *HostStatDir ;
#line 2298
char *HostsFile ;
#line 2299
char *Mbdb ;
#line 2302
char *OperatorChars ;
#line 2304
char *PostMasterCopy ;
#line 2305
char *ProcTitlePrefix ;
#line 2311
char *ServiceSwitchFile ;
#line 2316
char *StatFile ;
#line 2317
char *TimeZoneSpec ;
#line 2319
char *UnixFromLine ;
#line 2330
char *RuleSetNames[200] ;
#line 2334
union bigsockaddr ConnectOnlyTo ;
#line 2339
int ConnectionRateWindowSize ;
#line 2366
void setalias(char *spec ) ;
#line 2424
void milter_setup(char *line ) ;
#line 2425
void milter_set_option(char *name , char *val , bool sticky ) ;
#line 2466
time_t convtime(char *p , int units ) ;
#line 2480
int drop_privileges(bool to_real_uid ) ;
#line 2501
char *getmodifiers(char *v , unsigned int *modifiers ) ;
#line 2506
void initdaemon(void) ;
#line 2507
void inithostmaps(void) ;
#line 2524
char *munchstring(char *p , char **delimptr , int delim ) ;
#line 2534
void printmailer(SM_FILE_T *fp , MAILER *m ) ;
#line 2538
void printrules(void) ;
#line 2543
void readcf(char *cfname , bool safe , ENVELOPE *e ) ;
#line 2553
void setclientoptions(char *p ) ;
#line 2554
bool setdaemonoptions(char *p ) ;
#line 2556
void setdefuser(void) ;
#line 2557
bool setvendor(char *vendor ) ;
#line 2559
void setoption(int opt , char *val , bool safe , bool sticky , ENVELOPE *e ) ;
#line 2561
void sm_setuserenv(char const   *envar , char const   *value ) ;
#line 2573
struct passwd *sm_getpwnam(char *user ) ;
#line 2583
int switch_map_find(char *service , char **maptype , short *mapreturn ) ;
#line 2610
int waitfor(pid_t pid ) ;
#line 35 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
#line 27 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static void fileclass(int class , char *filename , char *fmt , bool ismap , bool safe ,
                      bool optional ) ;
#line 28
static char **makeargv(char *p ) ;
#line 29
static void settimeout(char *name , char *val , bool sticky ) ;
#line 30
static void toomany(int id , int maxcnt ) ;
#line 31
static char *extrquotstr(char *p , char **delimptr , char *delimbuf , bool *st ) ;
#line 32
static void parse_class_words(int class , char *line ) ;
#line 108 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static char *null_list[1]  = {      (char *)((void *)0)};
#line 109
unsigned char TokTypeNoC[256] ;
#line 84 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
void readcf(char *cfname , bool safe , ENVELOPE *e ) 
{ 
  SM_FILE_T *cf___0 ;
  int ruleset ;
  char *q ;
  struct rewrite *rwp ;
  char *bp___3 ;
  char *ep ;
  int nfuzzy ;
  char *file ;
  bool optional ;
  bool ok ;
  bool ismap ;
  int mid ;
  register char *p ;
  long sff ;
  struct stat statb ;
  char buf___16[2048] ;
  char exbuf[2048] ;
  char pvpbuf[3048] ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned char *tmp___4 ;
  register char **ap ;
  char *botch ;
  unsigned char *tmp___5 ;
  register char **ap___0 ;
  int args ;
  int endtoken ;
  bool inmap ;
  char *botch___0 ;
  register char *wd ;
  char delim ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  long tmp___16 ;
  char *tmp___17 ;
  unsigned short const   **tmp___18 ;
  bool tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int nmaps ;
  char *maptype[12] ;
  short mapreturn[5] ;
  register int mapno ;
  int tmp___22 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;

  {
#line 91
  ruleset = -1;
#line 93
  rwp = (struct rewrite *)((void *)0);
#line 103
  sff = 8192L;
#line 111
  FileName = cfname;
#line 112
  LineNumber = 0;
#line 114
  if (DontLockReadFiles) {
#line 115
    sff |= 16384L;
  }
  {
#line 116
  cf___0 = safefopen(cfname, 0, 292, sff);
  }
#line 117
  if ((unsigned long )cf___0 == (unsigned long )((void *)0)) {
    {
#line 119
    syserr("cannot open");
#line 120
    finis(0, 1, (int volatile   )72);
    }
  }
  {
#line 123
  tmp = sm_io_getinfo(cf___0, 3, (void *)0);
#line 123
  tmp___0 = fstat(tmp, & statb);
  }
#line 123
  if (tmp___0 < 0) {
    {
#line 125
    syserr("cannot fstat");
#line 126
    finis(0, 1, (int volatile   )72);
    }
  }
#line 129
  if (! ((statb.st_mode & 61440U) == 32768U)) {
    {
#line 131
    syserr("not a plain file");
#line 132
    finis(0, 1, (int volatile   )72);
    }
  }
#line 135
  if ((int )OpMode != 116) {
#line 135
    if ((statb.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) != 0U) {
#line 137
      if ((int )OpMode == 100) {
        {
#line 138
        sm_io_fprintf(& SmIoF[2], -2, "%s: WARNING: dangerous write permissions\n",
                      FileName);
        }
      } else
#line 137
      if ((int )OpMode == 105) {
        {
#line 138
        sm_io_fprintf(& SmIoF[2], -2, "%s: WARNING: dangerous write permissions\n",
                      FileName);
        }
      }
#line 141
      if (LogLevel > 0) {
        {
#line 142
        sm_syslog(2, "*~*", "%s: WARNING: dangerous write permissions", FileName);
        }
      }
    }
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 151
    bp___3 = fgetfolded(buf___16, (int )sizeof(buf___16), cf___0);
    }
#line 151
    if (! ((unsigned long )bp___3 != (unsigned long )((void *)0))) {
#line 151
      goto while_break;
    }
#line 153
    if ((int )*(bp___3 + 0) == 35) {
#line 155
      if ((unsigned long )bp___3 != (unsigned long )(buf___16)) {
        {
#line 156
        sm_free_tagged((void *)bp___3, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                       156);
        }
      }
#line 157
      goto while_continue;
    }
    {
#line 161
    translate_dollars(bp___3);
#line 164
    tmp___1 = __errno_location();
#line 164
    *tmp___1 = 0;
    }
    {
#line 168
    if ((int )*(bp___3 + 0) == 35) {
#line 168
      goto case_35;
    }
#line 168
    if ((int )*(bp___3 + 0) == 0) {
#line 168
      goto case_35;
    }
#line 171
    if ((int )*(bp___3 + 0) == 82) {
#line 171
      goto case_82;
    }
#line 448
    if ((int )*(bp___3 + 0) == 83) {
#line 448
      goto case_83;
    }
#line 470
    if ((int )*(bp___3 + 0) == 68) {
#line 470
      goto case_68;
    }
#line 478
    if ((int )*(bp___3 + 0) == 72) {
#line 478
      goto case_72;
    }
#line 483
    if ((int )*(bp___3 + 0) == 84) {
#line 483
      goto case_84;
    }
#line 483
    if ((int )*(bp___3 + 0) == 67) {
#line 483
      goto case_84;
    }
#line 515
    if ((int )*(bp___3 + 0) == 70) {
#line 515
      goto case_70;
    }
#line 597
    if ((int )*(bp___3 + 0) == 77) {
#line 597
      goto case_77;
    }
#line 601
    if ((int )*(bp___3 + 0) == 79) {
#line 601
      goto case_79;
    }
#line 605
    if ((int )*(bp___3 + 0) == 80) {
#line 605
      goto case_80;
    }
#line 621
    if ((int )*(bp___3 + 0) == 81) {
#line 621
      goto case_81;
    }
#line 625
    if ((int )*(bp___3 + 0) == 86) {
#line 625
      goto case_86;
    }
#line 673
    if ((int )*(bp___3 + 0) == 75) {
#line 673
      goto case_75;
    }
#line 678
    if ((int )*(bp___3 + 0) == 69) {
#line 678
      goto case_69;
    }
#line 685
    if ((int )*(bp___3 + 0) == 88) {
#line 685
      goto case_88;
    }
#line 694
    goto badline;
    case_35: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 169
    goto switch_break;
    case_82: /* CIL Label */ 
#line 172
    if (ruleset < 0) {
      {
#line 174
      syserr("missing valid ruleset for \"%s\"", bp___3);
      }
#line 175
      goto switch_break;
    }
#line 177
    p = bp___3 + 1;
    {
#line 177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 177
      if ((int )*p != 0) {
#line 177
        if (! ((int )*p != 9)) {
#line 177
          goto while_break___0;
        }
      } else {
#line 177
        goto while_break___0;
      }
#line 178
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 177
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 180
    if ((int )*p == 0) {
      {
#line 182
      syserr("invalid rewrite line \"%s\" (tab expected)", bp___3);
      }
#line 183
      goto switch_break;
    }
#line 187
    if ((unsigned long )rwp == (unsigned long )((void *)0)) {
      {
#line 189
      tmp___2 = xalloc_tagged((int )sizeof(*rwp), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                              190);
#line 189
      rwp = (struct rewrite *)tmp___2;
#line 189
      RewriteRules[ruleset] = rwp;
      }
    } else {
      {
#line 194
      tmp___3 = xalloc_tagged((int )sizeof(*rwp), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                              194);
#line 194
      rwp->r_next = (struct rewrite *)tmp___3;
#line 195
      rwp = rwp->r_next;
      }
    }
    {
#line 197
    rwp->r_next = (struct rewrite *)((void *)0);
#line 200
    *p = (char )'\000';
#line 201
    expand(bp___3 + 1, exbuf, (size_t )sizeof(exbuf), e);
    }
#line 202
    if (ConfigLevel >= 9) {
#line 202
      tmp___4 = TokTypeNoC;
    } else {
#line 202
      tmp___4 = (unsigned char *)((void *)0);
    }
    {
#line 202
    rwp->r_lhs = prescan(exbuf, '\t', pvpbuf, (int )sizeof(pvpbuf), (char **)((void *)0),
                         tmp___4, 1);
#line 206
    nfuzzy = 0;
    }
#line 207
    if ((unsigned long )rwp->r_lhs != (unsigned long )((void *)0)) {
      {
#line 211
      rwp->r_lhs = copyplist(rwp->r_lhs, 1, (SM_RPOOL_T *)((void *)0));
#line 214
      ap = rwp->r_lhs;
      }
      {
#line 214
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 214
        if (! ((unsigned long )*ap != (unsigned long )((void *)0))) {
#line 214
          goto while_break___1;
        }
#line 218
        botch = (char *)((void *)0);
        {
#line 225
        if (((int )*(*ap) & 255) == 148) {
#line 225
          goto case_148;
        }
#line 225
        if (((int )*(*ap) & 255) == 147) {
#line 225
          goto case_148;
        }
#line 225
        if (((int )*(*ap) & 255) == 146) {
#line 225
          goto case_148;
        }
#line 225
        if (((int )*(*ap) & 255) == 145) {
#line 225
          goto case_148;
        }
#line 225
        if (((int )*(*ap) & 255) == 144) {
#line 225
          goto case_148;
        }
#line 229
        if (((int )*(*ap) & 255) == 149) {
#line 229
          goto case_149;
        }
#line 233
        if (((int )*(*ap) & 255) == 152) {
#line 233
          goto case_152;
        }
#line 237
        if (((int )*(*ap) & 255) == 153) {
#line 237
          goto case_153;
        }
#line 241
        if (((int )*(*ap) & 255) == 154) {
#line 241
          goto case_154;
        }
#line 245
        if (((int )*(*ap) & 255) == 156) {
#line 245
          goto case_156;
        }
#line 249
        if (((int )*(*ap) & 255) == 157) {
#line 249
          goto case_157;
        }
#line 253
        if (((int )*(*ap) & 255) == 158) {
#line 253
          goto case_158;
        }
#line 257
        if (((int )*(*ap) & 255) == 133) {
#line 257
          goto case_133;
        }
#line 261
        if (((int )*(*ap) & 255) == 134) {
#line 261
          goto case_134;
        }
#line 219
        goto switch_break___0;
        case_148: /* CIL Label */ 
        case_147: /* CIL Label */ 
        case_146: /* CIL Label */ 
        case_145: /* CIL Label */ 
        case_144: /* CIL Label */ 
#line 226
        nfuzzy ++;
#line 227
        goto switch_break___0;
        case_149: /* CIL Label */ 
#line 230
        botch = (char *)"$0-$9";
#line 231
        goto switch_break___0;
        case_152: /* CIL Label */ 
#line 234
        botch = (char *)"$:";
#line 235
        goto switch_break___0;
        case_153: /* CIL Label */ 
#line 238
        botch = (char *)"$>";
#line 239
        goto switch_break___0;
        case_154: /* CIL Label */ 
#line 242
        botch = (char *)"$?";
#line 243
        goto switch_break___0;
        case_156: /* CIL Label */ 
#line 246
        botch = (char *)"$.";
#line 247
        goto switch_break___0;
        case_157: /* CIL Label */ 
#line 250
        botch = (char *)"$[";
#line 251
        goto switch_break___0;
        case_158: /* CIL Label */ 
#line 254
        botch = (char *)"$]";
#line 255
        goto switch_break___0;
        case_133: /* CIL Label */ 
#line 258
        botch = (char *)"$(";
#line 259
        goto switch_break___0;
        case_134: /* CIL Label */ 
#line 262
        botch = (char *)"$)";
#line 263
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 265
        if ((unsigned long )botch != (unsigned long )((void *)0)) {
          {
#line 266
          syserr("Inappropriate use of %s on LHS", botch);
          }
        }
#line 214
        ap ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 269
      rwp->r_line = LineNumber;
    } else {
      {
#line 273
      syserr("R line: null LHS");
#line 274
      rwp->r_lhs = null_list;
      }
    }
#line 276
    if (nfuzzy > 9) {
      {
#line 278
      syserr("R line: too many wildcards");
#line 279
      rwp->r_lhs = null_list;
      }
    }
    {
#line 283
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 283
      p ++;
#line 283
      if (! ((int )*p == 9)) {
#line 283
        goto while_break___2;
      }
#line 284
      goto while_continue___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 285
    q = p;
    {
#line 286
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 286
      if ((int )*p != 0) {
#line 286
        if (! ((int )*p != 9)) {
#line 286
          goto while_break___3;
        }
      } else {
#line 286
        goto while_break___3;
      }
#line 287
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 288
    *p = (char )'\000';
#line 289
    expand(q, exbuf, (size_t )sizeof(exbuf), e);
    }
#line 290
    if (ConfigLevel >= 9) {
#line 290
      tmp___5 = TokTypeNoC;
    } else {
#line 290
      tmp___5 = (unsigned char *)((void *)0);
    }
    {
#line 290
    rwp->r_rhs = prescan(exbuf, '\t', pvpbuf, (int )sizeof(pvpbuf), (char **)((void *)0),
                         tmp___5, 1);
    }
#line 294
    if ((unsigned long )rwp->r_rhs != (unsigned long )((void *)0)) {
      {
#line 303
      rwp->r_rhs = copyplist(rwp->r_rhs, 1, (SM_RPOOL_T *)((void *)0));
#line 306
      nfuzzy += 48;
#line 307
      inmap = 0;
#line 308
      args = 0;
#line 309
      endtoken = 0;
#line 310
      ap___0 = rwp->r_rhs;
      }
      {
#line 310
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 310
        if (! ((unsigned long )*ap___0 != (unsigned long )((void *)0))) {
#line 310
          goto while_break___4;
        }
#line 314
        botch___0 = (char *)((void *)0);
        {
#line 317
        if (((int )*(*ap___0) & 255) == 149) {
#line 317
          goto case_149___0;
        }
#line 325
        if (((int )*(*ap___0) & 255) == 144) {
#line 325
          goto case_144___0;
        }
#line 329
        if (((int )*(*ap___0) & 255) == 145) {
#line 329
          goto case_145___0;
        }
#line 333
        if (((int )*(*ap___0) & 255) == 146) {
#line 333
          goto case_146___0;
        }
#line 337
        if (((int )*(*ap___0) & 255) == 147) {
#line 337
          goto case_147___0;
        }
#line 341
        if (((int )*(*ap___0) & 255) == 148) {
#line 341
          goto case_148___0;
        }
#line 345
        if (((int )*(*ap___0) & 255) == 151) {
#line 345
          goto case_151;
        }
#line 352
        if (((int )*(*ap___0) & 255) == 157) {
#line 352
          goto case_157___0;
        }
#line 355
        if (((int )*(*ap___0) & 255) == 133) {
#line 355
          goto case_133___0;
        }
#line 396
        if (((int )*(*ap___0) & 255) == 134) {
#line 396
          goto case_134___0;
        }
#line 396
        if (((int )*(*ap___0) & 255) == 158) {
#line 396
          goto case_134___0;
        }
#line 315
        goto switch_break___1;
        case_149___0: /* CIL Label */ 
#line 318
        if ((int )*(*ap___0 + 1) <= 48) {
          {
#line 320
          syserr("replacement $%c out of bounds", (int )*(*ap___0 + 1));
          }
        } else
#line 318
        if ((int )*(*ap___0 + 1) > nfuzzy) {
          {
#line 320
          syserr("replacement $%c out of bounds", (int )*(*ap___0 + 1));
          }
        }
#line 323
        goto switch_break___1;
        case_144___0: /* CIL Label */ 
#line 326
        botch___0 = (char *)"$*";
#line 327
        goto switch_break___1;
        case_145___0: /* CIL Label */ 
#line 330
        botch___0 = (char *)"$+";
#line 331
        goto switch_break___1;
        case_146___0: /* CIL Label */ 
#line 334
        botch___0 = (char *)"$-";
#line 335
        goto switch_break___1;
        case_147___0: /* CIL Label */ 
#line 338
        botch___0 = (char *)"$=";
#line 339
        goto switch_break___1;
        case_148___0: /* CIL Label */ 
#line 342
        botch___0 = (char *)"$~";
#line 343
        goto switch_break___1;
        case_151: /* CIL Label */ 
#line 346
        if (! inmap) {
#line 347
          goto switch_break___1;
        }
#line 348
        args ++;
#line 348
        if (args >= 10) {
          {
#line 349
          syserr("too many arguments for map lookup");
          }
        }
#line 350
        goto switch_break___1;
        case_157___0: /* CIL Label */ 
#line 353
        endtoken = 158;
        case_133___0: /* CIL Label */ 
#line 357
        if (((int )*(*ap___0) & 255) == 133) {
#line 358
          endtoken = 134;
        }
#line 359
        if (inmap) {
          {
#line 360
          syserr("cannot nest map lookups");
          }
        }
#line 361
        inmap = 1;
#line 362
        args = 0;
#line 393
        goto switch_break___1;
        case_134___0: /* CIL Label */ 
        case_158___0: /* CIL Label */ 
#line 397
        if (((int )*(*ap___0) & 255) != endtoken) {
#line 398
          goto switch_break___1;
        }
#line 399
        inmap = 0;
#line 400
        endtoken = 0;
#line 401
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 434
        if ((unsigned long )botch___0 != (unsigned long )((void *)0)) {
          {
#line 435
          syserr("Inappropriate use of %s on RHS", botch___0);
          }
        }
#line 310
        ap___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 438
      if (inmap) {
        {
#line 439
        syserr("missing map closing token");
        }
      }
    } else {
      {
#line 443
      syserr("R line: null RHS");
#line 444
      rwp->r_rhs = null_list;
      }
    }
#line 446
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 449
    expand(bp___3 + 1, exbuf, (size_t )sizeof(exbuf), e);
#line 450
    ruleset = strtorwset(exbuf, (char **)((void *)0), 1);
    }
#line 451
    if (ruleset < 0) {
#line 452
      goto switch_break;
    }
#line 454
    rwp = RewriteRules[ruleset];
#line 455
    if ((unsigned long )rwp != (unsigned long )((void *)0)) {
#line 457
      if ((int )OpMode == 116) {
        {
#line 458
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ruleset %s has multiple definitions\n",
                      bp___3 + 1);
        }
      }
#line 462
      if ((int )tTdvect[37] >= 1) {
        {
#line 463
        sm_dprintf((char *)"WARNING: Ruleset %s has multiple definitions\n", bp___3 + 1);
        }
      }
      {
#line 465
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 465
        if (! ((unsigned long )rwp->r_next != (unsigned long )((void *)0))) {
#line 465
          goto while_break___5;
        }
#line 466
        rwp = rwp->r_next;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 468
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 471
    mid = macid_parse(bp___3 + 1, & ep);
    }
#line 472
    if (mid == 0) {
#line 473
      goto switch_break;
    }
    {
#line 474
    p = munchstring(ep, (char **)((void *)0), '\000');
#line 475
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, mid, p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                     475, SmHeapGroup);
    }
#line 476
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 479
    chompheader(bp___3 + 1, 1, (HDR **)((void *)0), e);
    }
#line 480
    goto switch_break;
    case_84: /* CIL Label */ 
    case_67: /* CIL Label */ 
#line 484
    if ((int )*(bp___3 + 0) == 67) {
      {
#line 486
      mid = macid_parse(bp___3 + 1, & ep);
      }
#line 487
      if (mid == 0) {
#line 488
        goto switch_break;
      }
      {
#line 489
      expand(ep, exbuf, (size_t )sizeof(exbuf), e);
#line 490
      p = exbuf;
      }
    } else {
#line 494
      mid = 't';
#line 495
      p = bp___3 + 1;
    }
    {
#line 497
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 497
      if (! ((int )*p != 0)) {
#line 497
        goto while_break___6;
      }
      {
#line 502
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 502
        if ((int )*p != 0) {
#line 502
          if (((int )*p & -128) == 0) {
            {
#line 502
            tmp___6 = __ctype_b_loc();
            }
#line 502
            if (! ((int const   )*(*tmp___6 + (int )*p) & 8192)) {
#line 502
              goto while_break___7;
            }
          } else {
#line 502
            goto while_break___7;
          }
        } else {
#line 502
          goto while_break___7;
        }
#line 503
        p ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 504
      wd = p;
      {
#line 505
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 505
        if ((int )*p != 0) {
#line 505
          if (((int )*p & -128) == 0) {
            {
#line 505
            tmp___7 = __ctype_b_loc();
            }
#line 505
            if ((int const   )*(*tmp___7 + (int )*p) & 8192) {
#line 505
              goto while_break___8;
            }
          }
        } else {
#line 505
          goto while_break___8;
        }
#line 506
        p ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 507
      delim = *p;
#line 508
      *p = (char )'\000';
#line 509
      if ((int )*(wd + 0) != 0) {
        {
#line 510
        setclass(mid, wd);
        }
      }
#line 511
      *p = delim;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 513
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 516
    mid = macid_parse(bp___3 + 1, & ep);
    }
#line 517
    if (mid == 0) {
#line 518
      goto switch_break;
    }
#line 519
    p = ep;
    {
#line 519
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 519
      if (((int )*p & -128) == 0) {
        {
#line 519
        tmp___8 = __ctype_b_loc();
        }
#line 519
        if (! ((int const   )*(*tmp___8 + (int )*p) & 8192)) {
#line 519
          goto while_break___9;
        }
      } else {
#line 519
        goto while_break___9;
      }
#line 520
      p ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 521
    if ((int )*(p + 0) == 45) {
#line 521
      if ((int )*(p + 1) == 111) {
#line 523
        optional = 1;
        {
#line 524
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 524
          if ((int )*p != 0) {
#line 524
            if (((int )*p & -128) == 0) {
              {
#line 524
              tmp___9 = __ctype_b_loc();
              }
#line 524
              if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 524
                goto while_break___10;
              }
            }
          } else {
#line 524
            goto while_break___10;
          }
#line 526
          p ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 527
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 527
          if (((int )*p & -128) == 0) {
            {
#line 527
            tmp___10 = __ctype_b_loc();
            }
#line 527
            if (! ((int const   )*(*tmp___10 + (int )*p) & 8192)) {
#line 527
              goto while_break___11;
            }
          } else {
#line 527
            goto while_break___11;
          }
#line 528
          p ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 529
        file = p;
      } else {
#line 532
        optional = 0;
      }
    } else {
#line 532
      optional = 0;
    }
#line 535
    ismap = 0;
#line 536
    if (! ((int )*p == 47)) {
#line 536
      if ((int )*p != 124) {
        {
#line 536
        q = strchr((char const   *)p, '@');
        }
#line 536
        if ((unsigned long )q != (unsigned long )((void *)0)) {
          {
#line 540
          q ++;
#line 543
          tmp___11 = strcmp((char const   *)q, "LDAP");
          }
#line 543
          if (tmp___11 == 0) {
#line 546
            ismap = 1;
          } else
#line 543
          if ((int )*q != 58) {
            {
#line 543
            tmp___12 = strchr((char const   *)q, ':');
            }
#line 543
            if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
#line 546
              ismap = 1;
            }
          }
        }
      }
    }
#line 549
    if (ismap) {
#line 552
      file = p;
    } else {
      {
#line 556
      file = extrquotstr(p, & q, (char *)" ", & ok);
      }
#line 557
      if (! ok) {
        {
#line 559
        syserr("illegal filename \'%s\'", p);
        }
#line 560
        goto switch_break;
      }
    }
#line 564
    if ((int )*file == 124) {
#line 565
      p = (char *)"%s";
    } else
#line 564
    if (ismap) {
#line 565
      p = (char *)"%s";
    } else {
#line 568
      p = q;
#line 569
      if ((int )*p == 0) {
#line 570
        p = (char *)"%s";
      } else {
#line 573
        *p = (char )'\000';
        {
#line 574
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 574
          p ++;
#line 574
          if (((int )*p & -128) == 0) {
            {
#line 574
            tmp___13 = __ctype_b_loc();
            }
#line 574
            if (! ((int const   )*(*tmp___13 + (int )*p) & 8192)) {
#line 574
              goto while_break___12;
            }
          } else {
#line 574
            goto while_break___12;
          }
#line 575
          goto while_continue___12;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
    }
    {
#line 578
    fileclass(mid, file, p, ismap, safe, optional);
    }
#line 579
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 598
    makemailer(bp___3 + 1);
    }
#line 599
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 602
    setoption((int )*(bp___3 + 1), bp___3 + 2, safe, 0, e);
    }
#line 603
    goto switch_break;
    case_80: /* CIL Label */ 
#line 606
    if (NumPriorities >= 25) {
      {
#line 608
      toomany('P', 25);
      }
#line 609
      goto switch_break;
    }
#line 611
    p = bp___3 + 1;
    {
#line 611
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 611
      if ((int )*p != 0) {
#line 611
        if (! ((int )*p != 61)) {
#line 611
          goto while_break___13;
        }
      } else {
#line 611
        goto while_break___13;
      }
#line 612
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 611
      p ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 613
    if ((int )*p == 0) {
#line 614
      goto badline;
    }
    {
#line 615
    *p = (char )'\000';
#line 616
    Priorities[NumPriorities].pri_name = newstr((char const   *)(bp___3 + 1));
#line 617
    p ++;
#line 617
    Priorities[NumPriorities].pri_val = atoi((char const   *)p);
#line 618
    NumPriorities ++;
    }
#line 619
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 622
    makequeue(bp___3 + 1, 1);
    }
#line 623
    goto switch_break;
    case_86: /* CIL Label */ 
#line 626
    p = bp___3 + 1;
    {
#line 626
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 626
      if (((int )*p & -128) == 0) {
        {
#line 626
        tmp___14 = __ctype_b_loc();
        }
#line 626
        if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 626
          goto while_break___14;
        }
      } else {
#line 626
        goto while_break___14;
      }
#line 627
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 626
      p ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 628
    if (! (((int )*p & -128) == 0)) {
      {
#line 630
      syserr("invalid argument to V line: \"%.20s\"", bp___3 + 1);
      }
#line 632
      goto switch_break;
    } else {
      {
#line 628
      tmp___15 = __ctype_b_loc();
      }
#line 628
      if (! ((int const   )*(*tmp___15 + (int )*p) & 2048)) {
        {
#line 630
        syserr("invalid argument to V line: \"%.20s\"", bp___3 + 1);
        }
#line 632
        goto switch_break;
      }
    }
    {
#line 634
    tmp___16 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& ep),
                      10);
#line 634
    ConfigLevel = (int )tmp___16;
    }
#line 640
    if (ConfigLevel >= 5) {
      {
#line 643
      p = macvalue('w', e);
      }
#line 644
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 644
        p = strchr((char const   *)p, '.');
        }
#line 644
        if ((unsigned long )p != (unsigned long )((void *)0)) {
          {
#line 646
          *p = (char )'\000';
#line 647
          tmp___17 = macvalue('w', e);
#line 647
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, 'w', tmp___17, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                           648, SmHeapGroup);
          }
        }
      }
    }
#line 651
    if (ConfigLevel >= 6) {
#line 653
      ColonOkInAddr = 0;
    }
#line 660
    tmp___20 = ep;
#line 660
    ep ++;
#line 660
    if ((int )*tmp___20 == 47) {
#line 663
      p = ep;
      {
#line 663
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 663
        if (((int )*p & -128) == 0) {
          {
#line 663
          tmp___18 = __ctype_b_loc();
          }
#line 663
          if (! ((int const   )*(*tmp___18 + (int )*p) & 1024)) {
#line 663
            goto while_break___15;
          }
        } else {
#line 663
          goto while_break___15;
        }
#line 664
        p ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 665
      *p = (char )'\000';
#line 667
      tmp___19 = setvendor(ep);
      }
#line 667
      if (! tmp___19) {
        {
#line 668
        syserr("invalid V line vendor code: \"%s\"", ep);
        }
      }
    }
#line 671
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 674
    expand(bp___3 + 1, exbuf, (size_t )sizeof(exbuf), e);
#line 675
    makemapentry(exbuf);
    }
#line 676
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 679
    p = strchr((char const   *)bp___3, '=');
    }
#line 680
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 681
      tmp___21 = p;
#line 681
      p ++;
#line 681
      *tmp___21 = (char )'\000';
    }
    {
#line 682
    sm_setuserenv((char const   *)(bp___3 + 1), (char const   *)p);
    }
#line 683
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 687
    milter_setup(bp___3 + 1);
    }
#line 692
    goto switch_break;
    badline: 
    switch_default: /* CIL Label */ 
    {
#line 696
    syserr("unknown configuration line \"%s\"", bp___3);
    }
    switch_break: /* CIL Label */ ;
    }
#line 698
    if ((unsigned long )bp___3 != (unsigned long )(buf___16)) {
      {
#line 699
      sm_free_tagged((void *)bp___3, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                     699);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 701
  if ((cf___0->f_flags & 256L) != 0L) {
    {
#line 703
    syserr("I/O read error");
#line 704
    finis(0, 1, (int volatile   )72);
    }
  }
  {
#line 706
  sm_io_close(cf___0, -2);
#line 707
  FileName = (char *)((void *)0);
#line 710
  inithostmaps();
#line 713
  initdaemon();
#line 721
  nmaps = switch_map_find((char *)"hosts", maptype, mapreturn);
#line 722
  UseNameServer = 0;
  }
#line 723
  if (nmaps > 0) {
#line 723
    if (nmaps <= 12) {
#line 727
      mapno = 0;
      {
#line 727
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 727
        if (mapno < nmaps) {
#line 727
          if (! (! UseNameServer)) {
#line 727
            goto while_break___16;
          }
        } else {
#line 727
          goto while_break___16;
        }
        {
#line 730
        tmp___22 = strcmp((char const   *)maptype[mapno], "dns");
        }
#line 730
        if (tmp___22 == 0) {
#line 731
          UseNameServer = 1;
        }
#line 727
        mapno ++;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
  }
#line 735
  return;
}
}
#line 751 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
void translate_dollars(char *bp___3 ) 
{ 
  register char *p ;
  char *ep ;
  register char *e ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  unsigned short const   **tmp___7 ;

  {
#line 758
  p = bp___3;
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 758
    if (! ((int )*p != 0)) {
#line 758
      goto while_break;
    }
#line 760
    if ((int )*p == 35) {
#line 760
      if ((unsigned long )p > (unsigned long )bp___3) {
#line 760
        if (ConfigLevel >= 3) {
#line 764
          p --;
          {
#line 766
          if (((int )*p & 255) == 129) {
#line 766
            goto case_129;
          }
#line 771
          if (((int )*p & 255) == 92) {
#line 771
            goto case_92;
          }
#line 776
          goto switch_default;
          case_129: /* CIL Label */ 
#line 768
          p ++;
#line 769
          goto switch_break;
          case_92: /* CIL Label */ 
          {
#line 773
          tmp = strlen((char const   *)p);
#line 773
          sm_strlcpy(p, (char const   *)(p + 1), (ssize_t )tmp);
          }
#line 774
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 778
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 778
            if (((int )*p & -128) == 0) {
              {
#line 778
              tmp___0 = __ctype_b_loc();
              }
#line 778
              if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
#line 778
                if ((int )*p != 10) {
#line 778
                  if (! ((unsigned long )p > (unsigned long )bp___3)) {
#line 778
                    goto while_break___0;
                  }
                } else {
#line 778
                  goto while_break___0;
                }
              } else {
#line 778
                goto while_break___0;
              }
            } else {
#line 778
              goto while_break___0;
            }
#line 780
            p --;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 781
          p ++;
#line 781
          e = strchr((char const   *)p, '\n');
          }
#line 781
          if ((unsigned long )e != (unsigned long )((void *)0)) {
            {
#line 782
            tmp___1 = strlen((char const   *)p);
#line 782
            sm_strlcpy(p, (char const   *)e, (ssize_t )tmp___1);
            }
          } else {
#line 784
            tmp___2 = p;
#line 784
            p --;
#line 784
            *tmp___2 = (char )'\000';
          }
#line 785
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 787
          goto __Cont;
        }
      }
    }
#line 790
    if ((int )*p != 36) {
#line 791
      goto __Cont;
    } else
#line 790
    if ((int )*(p + 1) == 0) {
#line 791
      goto __Cont;
    }
#line 793
    if ((int )*(p + 1) == 36) {
      {
#line 796
      tmp___3 = strlen((char const   *)p);
#line 796
      sm_strlcpy(p, (char const   *)(p + 1), (ssize_t )tmp___3);
      }
#line 797
      goto __Cont;
    }
#line 801
    tmp___4 = p;
#line 801
    p ++;
#line 801
    *tmp___4 = (char)-127;
#line 804
    if ((int )*p == 61) {
#line 805
      p ++;
    } else
#line 804
    if ((int )*p == 126) {
#line 805
      p ++;
    } else
#line 804
    if ((int )*p == 38) {
#line 805
      p ++;
    } else
#line 804
    if ((int )*p == 63) {
#line 805
      p ++;
    }
    {
#line 808
    tmp___5 = macid_parse(p, & ep);
#line 808
    *p = (char )tmp___5;
    }
#line 809
    if ((unsigned long )ep != (unsigned long )(p + 1)) {
      {
#line 810
      tmp___6 = strlen((char const   *)(p + 1));
#line 810
      sm_strlcpy(p + 1, (char const   *)ep, (ssize_t )tmp___6);
      }
    }
    __Cont: /* CIL Label */ 
#line 758
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 814
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 814
    p --;
#line 814
    if ((unsigned long )p > (unsigned long )bp___3) {
#line 814
      if (((int )*p & -128) == 0) {
        {
#line 814
        tmp___7 = __ctype_b_loc();
        }
#line 814
        if (! ((int const   )*(*tmp___7 + (int )*p) & 8192)) {
#line 814
          goto while_break___1;
        }
      } else {
#line 814
        goto while_break___1;
      }
    } else {
#line 814
      goto while_break___1;
    }
#line 815
    *p = (char )'\000';
  }
  while_break___1: /* CIL Label */ ;
  }
#line 816
  return;
}
}
#line 831 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static void toomany(int id , int maxcnt ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 836
  syserr("too many %c lines, %d max", id, maxcnt);
  }
#line 837
  return;
}
}
#line 862 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static void parse_class_words(int class , char *line ) 
{ 
  register char *q ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 867
    if ((unsigned long )line != (unsigned long )((void *)0)) {
#line 867
      if (! ((int )*line != 0)) {
#line 867
        goto while_break;
      }
    } else {
#line 867
      goto while_break;
    }
    {
#line 872
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 872
      if (((int )*line & -128) == 0) {
        {
#line 872
        tmp = __ctype_b_loc();
        }
#line 872
        if (! ((int const   )*(*tmp + (int )*line) & 8192)) {
#line 872
          goto while_break___0;
        }
      } else {
#line 872
        goto while_break___0;
      }
#line 873
      line ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 874
    if ((int )*line == 0) {
#line 875
      goto while_break;
    }
#line 878
    q = line;
    {
#line 879
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 879
      if ((int )*line != 0) {
#line 879
        if (((int )*line & -128) == 0) {
          {
#line 879
          tmp___0 = __ctype_b_loc();
          }
#line 879
          if ((int const   )*(*tmp___0 + (int )*line) & 8192) {
#line 879
            goto while_break___1;
          }
        }
      } else {
#line 879
        goto while_break___1;
      }
#line 880
      line ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 881
    if ((int )*line != 0) {
#line 882
      tmp___1 = line;
#line 882
      line ++;
#line 882
      *tmp___1 = (char )'\000';
    }
    {
#line 885
    setclass(class, q);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 887
  return;
}
}
#line 889 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static void fileclass(int class , char *filename , char *fmt , bool ismap , bool safe ,
                      bool optional ) 
{ 
  SM_FILE_T *f ;
  long sff ;
  pid_t pid ;
  register char *p ;
  char buf___16[2048] ;
  int status ;
  char *key ;
  char *mn ;
  char *cl ;
  char *spec ;
  STAB *mapclass ;
  struct _map map___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int fd ;
  int i ;
  char *argv[257] ;
  int tmp___4 ;
  char wordbuf[2049] ;
  int tmp___5 ;
  char *tmp___6 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
#line 904
  if ((int )tTdvect[37] >= 2) {
    {
#line 905
    sm_dprintf((char *)"fileclass(%s, fmt=%s)\n", filename, fmt);
    }
  }
#line 907
  if ((int )*filename == 0) {
    {
#line 909
    syserr("fileclass: missing file name");
    }
#line 910
    return;
  } else
#line 912
  if (ismap) {
    {
#line 914
    status = 0;
#line 921
    tmp = macname(class);
#line 921
    mn = newstr((char const   *)tmp);
#line 923
    key = filename;
#line 926
    p = strchr((char const   *)filename, '@');
    }
#line 926
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 929
      syserr("fileclass: bogus map specification");
#line 930
      sm_free_tagged((void *)mn, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                     930);
      }
#line 931
      return;
    }
    {
#line 935
    tmp___0 = p;
#line 935
    p ++;
#line 935
    *tmp___0 = (char )'\000';
#line 936
    cl = p;
#line 980
    spec = strchr((char const   *)cl, ':');
    }
#line 980
    if ((unsigned long )spec == (unsigned long )((void *)0)) {
      {
#line 982
      syserr("fileclass: F{%s}: missing map class", mn);
#line 984
      sm_free_tagged((void *)mn, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                     984);
      }
#line 985
      return;
    }
    {
#line 987
    tmp___1 = spec;
#line 987
    spec ++;
#line 987
    *tmp___1 = (char )'\000';
#line 991
    mapclass = stab(cl, 5, 0);
    }
#line 992
    if ((unsigned long )mapclass == (unsigned long )((void *)0)) {
      {
#line 994
      syserr("fileclass: F{%s}: class %s not available", mn, cl);
#line 996
      sm_free_tagged((void *)mn, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                     996);
      }
#line 997
      return;
    }
    {
#line 999
    memset((void *)(& map___0), '\000', (size_t )sizeof(map___0));
#line 1000
    map___0.map_class = & mapclass->s_value.sv_mapclass;
#line 1001
    map___0.map_mname = mn;
#line 1002
    map___0.map_mflags |= 4194304L;
    }
#line 1004
    if ((int )tTdvect[37] >= 5) {
      {
#line 1005
      sm_dprintf((char *)"fileclass: F{%s}: map class %s, key %s, spec %s\n", mn,
                 cl, key, spec);
      }
    }
    {
#line 1010
    tmp___2 = (*((map___0.map_class)->map_parse))(& map___0, spec);
    }
#line 1010
    if (! tmp___2) {
      {
#line 1013
      sm_free_tagged((void *)mn, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                     1013);
      }
#line 1014
      return;
    }
    {
#line 1016
    map___0.map_mflags |= 1L;
#line 1019
    tmp___3 = (*((map___0.map_class)->map_open))(& map___0, 0);
    }
#line 1019
    if (tmp___3) {
      {
#line 1021
      map___0.map_mflags |= 32L;
#line 1022
      map___0.map_pid = getpid();
      }
    } else {
#line 1026
      if (! optional) {
#line 1026
        if (! ((map___0.map_mflags & 4L) != 0L)) {
          {
#line 1028
          syserr("fileclass: F{%s}: map open failed", mn);
          }
        }
      }
      {
#line 1030
      sm_free_tagged((void *)mn, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                     1030);
      }
#line 1031
      return;
    }
    {
#line 1035
    p = (*((map___0.map_class)->map_lookup))(& map___0, key, (char **)((void *)0),
                                             & status);
    }
#line 1036
    if (status != 0) {
#line 1036
      if (status != 68) {
#line 1038
        if (! optional) {
          {
#line 1039
          syserr("fileclass: F{%s}: map lookup failed", mn);
          }
        }
#line 1041
        p = (char *)((void *)0);
      }
    }
#line 1045
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 1046
      parse_class_words(class, p);
      }
    }
    {
#line 1049
    map___0.map_mflags |= 16777216L;
#line 1050
    (*((map___0.map_class)->map_close))(& map___0);
#line 1051
    map___0.map_mflags &= -16777313L;
#line 1052
    sm_free_tagged((void *)mn, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                   1052);
    }
#line 1053
    return;
  } else
#line 1055
  if ((int )*(filename + 0) == 124) {
    {
#line 1061
    i = 0;
#line 1062
    p = strtok((char */* __restrict  */)(filename + 1), (char const   */* __restrict  */)" \t");
    }
    {
#line 1062
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1062
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1062
        if (! (i < 256)) {
#line 1062
          goto while_break;
        }
      } else {
#line 1062
        goto while_break;
      }
      {
#line 1065
      tmp___4 = i;
#line 1065
      i ++;
#line 1065
      argv[tmp___4] = p;
#line 1062
      p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t");
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1066
    argv[i] = (char *)((void *)0);
#line 1067
    pid = prog_open(argv, & fd, CurEnv);
    }
#line 1068
    if (pid < 0) {
#line 1069
      f = (SM_FILE_T *)((void *)0);
    } else {
      {
#line 1071
      f = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& fd)),
                     2, (void const   *)((void *)0));
      }
    }
  } else {
#line 1076
    pid = -1;
#line 1077
    sff = 128L;
#line 1078
    if (! (DontBlameSendmail[23UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 23UL % (8UL * sizeof(int ))))) {
#line 1079
      sff |= 256L;
    }
#line 1080
    if (! (DontBlameSendmail[10UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 10UL % (8UL * sizeof(int ))))) {
#line 1082
      sff |= 1024L;
    }
#line 1083
    if (safe) {
#line 1084
      sff |= 8192L;
    } else
#line 1085
    if (RealUid == 0U) {
#line 1086
      sff |= 4L;
    }
#line 1087
    if (DontLockReadFiles) {
#line 1088
      sff |= 16384L;
    }
    {
#line 1089
    f = safefopen(filename, 0, 0, sff);
    }
  }
#line 1091
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1093
    if (! optional) {
      {
#line 1094
      syserr("fileclass: cannot open \'%s\'", filename);
      }
    }
#line 1095
    return;
  }
  {
#line 1098
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1098
    tmp___6 = sm_io_fgets(f, -2, buf___16, (int )sizeof(buf___16));
    }
#line 1098
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 1098
      goto while_break___0;
    }
#line 1104
    if ((int )buf___16[0] == 35) {
#line 1105
      goto while_continue___0;
    }
    {
#line 1107
    tmp___5 = sm_io_sscanf((char const   *)(buf___16), (char const   *)fmt, wordbuf);
    }
#line 1107
    if (tmp___5 != 1) {
#line 1108
      goto while_continue___0;
    }
    {
#line 1109
    p = wordbuf;
#line 1114
    parse_class_words(class, p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1123
  sm_io_close(f, -2);
  }
#line 1124
  if (pid > 0) {
    {
#line 1125
    waitfor(pid);
    }
  }
#line 1126
  return;
}
}
#line 1170 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static int nextmailer  =    0;
#line 1160 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
void makemailer(char *line ) 
{ 
  register char *p ;
  register struct mailer *m ;
  register STAB *s ;
  int i ;
  char fcode ;
  char *endp ;
  char *tmp ;
  int *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *delimptr ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  short tmp___7 ;
  short tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *q ;
  struct passwd *pw ;
  unsigned short const   **tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  unsigned short const   **tmp___16 ;
  char *tmp___17 ;
  char *q___0 ;
  long tmp___18 ;
  unsigned short const   **tmp___19 ;
  unsigned short const   **tmp___20 ;
  unsigned short const   **tmp___21 ;
  char *q___1 ;
  struct group *gr ;
  unsigned short const   **tmp___22 ;
  char *tmp___23 ;
  long tmp___24 ;
  unsigned short const   **tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char const   *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char **pp ;
  char *tmp___34 ;
  int tmp___35 ;
  MAILER *tmp___36 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;

  {
  {
#line 1173
  tmp = xalloc_tagged((int )sizeof(*m), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                      1173);
#line 1173
  m = (struct mailer *)tmp;
#line 1174
  memset((void *)((char *)m), '\000', (size_t )sizeof(*m));
#line 1175
  tmp___0 = __errno_location();
#line 1175
  *tmp___0 = 0;
#line 1178
  p = line;
  }
  {
#line 1178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1178
    if ((int )*p != 0) {
#line 1178
      if ((int )*p != 44) {
#line 1178
        if (((int )*p & -128) == 0) {
          {
#line 1178
          tmp___1 = __ctype_b_loc();
          }
#line 1178
          if ((int const   )*(*tmp___1 + (int )*p) & 8192) {
#line 1178
            goto while_break;
          }
        }
      } else {
#line 1178
        goto while_break;
      }
    } else {
#line 1178
      goto while_break;
    }
#line 1181
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1178
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1182
  if ((int )*p != 0) {
#line 1183
    tmp___2 = p;
#line 1183
    p ++;
#line 1183
    *tmp___2 = (char )'\000';
  }
#line 1184
  if ((int )*(line + 0) == 0) {
    {
#line 1186
    syserr("name required for mailer");
    }
#line 1187
    return;
  }
  {
#line 1189
  m->m_name = newstr((char const   *)line);
#line 1190
  m->m_qgrp = (short)-1;
#line 1191
  m->m_uid = (uid_t )-1;
#line 1192
  m->m_gid = (gid_t )-1;
  }
  {
#line 1195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1195
    if (! ((int )*p != 0)) {
#line 1195
      goto while_break___0;
    }
    {
#line 1199
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1199
      if ((int )*p != 0) {
#line 1199
        if (! ((int )*p == 44)) {
#line 1199
          if (((int )*p & -128) == 0) {
            {
#line 1199
            tmp___3 = __ctype_b_loc();
            }
#line 1199
            if (! ((int const   )*(*tmp___3 + (int )*p) & 8192)) {
#line 1199
              goto while_break___1;
            }
          } else {
#line 1199
            goto while_break___1;
          }
        }
      } else {
#line 1199
        goto while_break___1;
      }
#line 1201
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1204
    fcode = *p;
    {
#line 1205
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1205
      if ((int )*p != 0) {
#line 1205
        if ((int )*p != 61) {
#line 1205
          if (! ((int )*p != 44)) {
#line 1205
            goto while_break___2;
          }
        } else {
#line 1205
          goto while_break___2;
        }
      } else {
#line 1205
        goto while_break___2;
      }
#line 1206
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1207
    tmp___4 = p;
#line 1207
    p ++;
#line 1207
    if ((int )*tmp___4 != 61) {
      {
#line 1209
      syserr("mailer %s: `=\' expected", m->m_name);
      }
#line 1210
      return;
    }
    {
#line 1212
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1212
      if (((int )*p & -128) == 0) {
        {
#line 1212
        tmp___5 = __ctype_b_loc();
        }
#line 1212
        if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 1212
          goto while_break___3;
        }
      } else {
#line 1212
        goto while_break___3;
      }
#line 1213
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1216
    p = munchstring(p, & delimptr, ',');
    }
    {
#line 1221
    if ((int )fcode == 80) {
#line 1221
      goto case_80;
    }
#line 1226
    if ((int )fcode == 70) {
#line 1226
      goto case_70;
    }
#line 1243
    if ((int )fcode == 82) {
#line 1243
      goto case_82;
    }
#line 1243
    if ((int )fcode == 83) {
#line 1243
      goto case_82;
    }
#line 1265
    if ((int )fcode == 69) {
#line 1265
      goto case_69;
    }
#line 1273
    if ((int )fcode == 65) {
#line 1273
      goto case_65;
    }
#line 1278
    if ((int )fcode == 77) {
#line 1278
      goto case_77;
    }
#line 1282
    if ((int )fcode == 109) {
#line 1282
      goto case_109;
    }
#line 1286
    if ((int )fcode == 114) {
#line 1286
      goto case_114;
    }
#line 1290
    if ((int )fcode == 76) {
#line 1290
      goto case_76;
    }
#line 1296
    if ((int )fcode == 78) {
#line 1296
      goto case_78;
    }
#line 1300
    if ((int )fcode == 68) {
#line 1300
      goto case_68;
    }
#line 1308
    if ((int )fcode == 67) {
#line 1308
      goto case_67;
    }
#line 1315
    if ((int )fcode == 81) {
#line 1315
      goto case_81;
    }
#line 1329
    if ((int )fcode == 84) {
#line 1329
      goto case_84;
    }
#line 1361
    if ((int )fcode == 85) {
#line 1361
      goto case_85;
    }
#line 1436
    if ((int )fcode == 87) {
#line 1436
      goto case_87;
    }
#line 1440
    if ((int )fcode == 47) {
#line 1440
      goto case_47;
    }
#line 1448
    goto switch_default;
    case_80: /* CIL Label */ 
#line 1222
    if ((int )*p != 0) {
      {
#line 1223
      m->m_mailer = newstr((char const   *)p);
      }
    }
#line 1224
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 1227
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1227
      if (! ((int )*p != 0)) {
#line 1227
        goto while_break___4;
      }
#line 1229
      if (((int )*p & -128) == 0) {
        {
#line 1229
        tmp___6 = __ctype_b_loc();
        }
#line 1229
        if (! ((int const   )*(*tmp___6 + (int )*p) & 8192)) {
#line 1237
          m->m_flags[(unsigned long )((unsigned char )((unsigned int )*p & 255U)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )((unsigned int )*p & 255U)) % (8UL * sizeof(int ));
        }
      } else {
#line 1237
        m->m_flags[(unsigned long )((unsigned char )((unsigned int )*p & 255U)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )((unsigned int )*p & 255U)) % (8UL * sizeof(int ));
      }
#line 1227
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1240
    goto switch_break;
    case_82: /* CIL Label */ 
    case_83: /* CIL Label */ 
    {
#line 1244
    i = strtorwset(p, & endp, 1);
    }
#line 1245
    if (i < 0) {
#line 1246
      return;
    }
#line 1247
    if ((int )fcode == 83) {
#line 1248
      tmp___7 = (short )i;
#line 1248
      m->m_se_rwset = tmp___7;
#line 1248
      m->m_sh_rwset = tmp___7;
    } else {
#line 1250
      tmp___8 = (short )i;
#line 1250
      m->m_re_rwset = tmp___8;
#line 1250
      m->m_rh_rwset = tmp___8;
    }
#line 1252
    p = endp;
#line 1253
    tmp___9 = p;
#line 1253
    p ++;
#line 1253
    if ((int )*tmp___9 == 47) {
      {
#line 1255
      i = strtorwset(p, (char **)((void *)0), 1);
      }
#line 1256
      if (i < 0) {
#line 1257
        return;
      }
#line 1258
      if ((int )fcode == 83) {
#line 1259
        m->m_sh_rwset = (short )i;
      } else {
#line 1261
        m->m_rh_rwset = (short )i;
      }
    }
#line 1263
    goto switch_break;
    case_69: /* CIL Label */ 
#line 1266
    if ((int )*p == 0) {
      {
#line 1267
      syserr("mailer %s: null end-of-line string", m->m_name);
      }
    } else {
      {
#line 1270
      m->m_eol = newstr((char const   *)p);
      }
    }
#line 1271
    goto switch_break;
    case_65: /* CIL Label */ 
#line 1274
    if ((int )*p != 0) {
      {
#line 1275
      m->m_argv = makeargv(p);
      }
    }
#line 1276
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 1279
    m->m_maxsize = atol((char const   *)p);
    }
#line 1280
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 1283
    m->m_maxdeliveries = atoi((char const   *)p);
    }
#line 1284
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 1287
    m->m_maxrcpt = atoi((char const   *)p);
    }
#line 1288
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 1291
    m->m_linelimit = atoi((char const   *)p);
    }
#line 1292
    if (m->m_linelimit < 0) {
#line 1293
      m->m_linelimit = 0;
    }
#line 1294
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 1297
    tmp___10 = atoi((char const   *)p);
#line 1297
    m->m_nice = (short )tmp___10;
    }
#line 1298
    goto switch_break;
    case_68: /* CIL Label */ 
#line 1301
    if ((int )*p == 0) {
      {
#line 1302
      syserr("mailer %s: null working directory", m->m_name);
      }
    } else {
      {
#line 1305
      m->m_execdir = newstr((char const   *)p);
      }
    }
#line 1306
    goto switch_break;
    case_67: /* CIL Label */ 
#line 1309
    if ((int )*p == 0) {
      {
#line 1310
      syserr("mailer %s: null charset", m->m_name);
      }
    } else {
      {
#line 1312
      m->m_defcharset = newstr((char const   *)p);
      }
    }
#line 1313
    goto switch_break;
    case_81: /* CIL Label */ 
#line 1316
    if ((int )*p == 0) {
      {
#line 1318
      syserr("mailer %s: null queue", m->m_name);
      }
#line 1319
      goto switch_break;
    }
    {
#line 1321
    s = stab(p, 15, 0);
    }
#line 1322
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
#line 1323
      syserr("mailer %s: unknown queue %s", m->m_name, p);
      }
    } else {
#line 1326
      m->m_qgrp = (s->s_value.sv_queue)->qg_index;
    }
#line 1327
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 1331
    m->m_mtatype = newstr((char const   *)p);
#line 1332
    p = strchr((char const   *)m->m_mtatype, '/');
    }
#line 1333
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1335
      tmp___11 = p;
#line 1335
      p ++;
#line 1335
      *tmp___11 = (char )'\000';
#line 1336
      if ((int )*p == 0) {
#line 1337
        p = (char *)((void *)0);
      }
    }
#line 1339
    if ((int )*(m->m_mtatype) == 0) {
#line 1340
      m->m_mtatype = (char *)"dns";
    }
#line 1343
    m->m_addrtype = p;
#line 1344
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 1345
      p = strchr((char const   *)p, '/');
      }
    }
#line 1346
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1348
      tmp___12 = p;
#line 1348
      p ++;
#line 1348
      *tmp___12 = (char )'\000';
#line 1349
      if ((int )*p == 0) {
#line 1350
        p = (char *)((void *)0);
      }
    }
#line 1352
    if ((unsigned long )m->m_addrtype == (unsigned long )((void *)0)) {
#line 1353
      m->m_addrtype = (char *)"rfc822";
    } else
#line 1352
    if ((int )*(m->m_addrtype) == 0) {
#line 1353
      m->m_addrtype = (char *)"rfc822";
    }
#line 1356
    m->m_diagtype = p;
#line 1357
    if ((unsigned long )m->m_diagtype == (unsigned long )((void *)0)) {
#line 1358
      m->m_diagtype = (char *)"smtp";
    } else
#line 1357
    if ((int )*(m->m_diagtype) == 0) {
#line 1358
      m->m_diagtype = (char *)"smtp";
    }
#line 1359
    goto switch_break;
    case_85: /* CIL Label */ 
#line 1362
    if (((int )*p & -128) == 0) {
      {
#line 1362
      tmp___20 = __ctype_b_loc();
      }
#line 1362
      if ((int const   )*(*tmp___20 + (int )*p) & 2048) {
#line 1362
        goto _L;
      } else {
#line 1364
        q = p;
        {
#line 1367
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1367
          if ((int )*p != 0) {
#line 1367
            if (((int )*p & -128) == 0) {
              {
#line 1367
              tmp___13 = __ctype_b_loc();
              }
#line 1367
              if (! ((int const   )*(*tmp___13 + (int )*p) & 8)) {
                {
#line 1367
                tmp___14 = strchr("-_", (int )*p);
                }
#line 1367
                if (! ((unsigned long )tmp___14 != (unsigned long )((void *)0))) {
#line 1367
                  goto while_break___5;
                }
              }
            } else {
#line 1367
              goto while_break___5;
            }
          } else {
#line 1367
            goto while_break___5;
          }
#line 1369
          p ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 1370
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1370
          if (((int )*p & -128) == 0) {
            {
#line 1370
            tmp___16 = __ctype_b_loc();
            }
#line 1370
            if (! ((int const   )*(*tmp___16 + (int )*p) & 8192)) {
#line 1370
              goto while_break___6;
            }
          } else {
#line 1370
            goto while_break___6;
          }
#line 1371
          tmp___15 = p;
#line 1371
          p ++;
#line 1371
          *tmp___15 = (char )'\000';
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1372
        if ((int )*p != 0) {
#line 1373
          tmp___17 = p;
#line 1373
          p ++;
#line 1373
          *tmp___17 = (char )'\000';
        }
#line 1374
        if ((int )*q == 0) {
          {
#line 1376
          syserr("mailer %s: null user name", m->m_name);
          }
#line 1378
          goto switch_break;
        }
        {
#line 1380
        pw = sm_getpwnam(q);
        }
#line 1381
        if ((unsigned long )pw == (unsigned long )((void *)0)) {
          {
#line 1383
          syserr("readcf: mailer U= flag: unknown user %s", q);
          }
#line 1384
          goto switch_break;
        } else {
#line 1388
          m->m_uid = pw->pw_uid;
#line 1389
          m->m_gid = pw->pw_gid;
        }
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1396
      tmp___18 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& q___0),
                        0);
#line 1396
      m->m_uid = (uid_t )tmp___18;
#line 1397
      p = q___0;
      }
      {
#line 1398
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1398
        if (((int )*p & -128) == 0) {
          {
#line 1398
          tmp___19 = __ctype_b_loc();
          }
#line 1398
          if (! ((int const   )*(*tmp___19 + (int )*p) & 8192)) {
#line 1398
            goto while_break___7;
          }
        } else {
#line 1398
          goto while_break___7;
        }
#line 1399
        p ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1400
      if ((int )*p != 0) {
#line 1401
        p ++;
      }
    }
    {
#line 1403
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1403
      if (((int )*p & -128) == 0) {
        {
#line 1403
        tmp___21 = __ctype_b_loc();
        }
#line 1403
        if (! ((int const   )*(*tmp___21 + (int )*p) & 8192)) {
#line 1403
          goto while_break___8;
        }
      } else {
#line 1403
        goto while_break___8;
      }
#line 1404
      p ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1405
    if ((int )*p == 0) {
#line 1406
      goto switch_break;
    }
#line 1407
    if (((int )*p & -128) == 0) {
      {
#line 1407
      tmp___25 = __ctype_b_loc();
      }
#line 1407
      if ((int const   )*(*tmp___25 + (int )*p) & 2048) {
        {
#line 1432
        tmp___24 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)((void *)0),
                          0);
#line 1432
        m->m_gid = (gid_t )tmp___24;
        }
      } else {
#line 1409
        q___1 = p;
        {
#line 1412
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1412
          if (((int )*p & -128) == 0) {
            {
#line 1412
            tmp___22 = __ctype_b_loc();
            }
#line 1412
            if (! ((int const   )*(*tmp___22 + (int )*p) & 8)) {
#line 1412
              goto while_break___9;
            }
          } else {
#line 1412
            goto while_break___9;
          }
#line 1413
          p ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 1414
        tmp___23 = p;
#line 1414
        p ++;
#line 1414
        *tmp___23 = (char )'\000';
#line 1415
        if ((int )*q___1 == 0) {
          {
#line 1417
          syserr("mailer %s: null group name", m->m_name);
          }
#line 1419
          goto switch_break;
        }
        {
#line 1421
        gr = getgrnam((char const   *)q___1);
        }
#line 1422
        if ((unsigned long )gr == (unsigned long )((void *)0)) {
          {
#line 1424
          syserr("readcf: mailer U= flag: unknown group %s", q___1);
          }
#line 1425
          goto switch_break;
        } else {
#line 1428
          m->m_gid = gr->gr_gid;
        }
      }
    } else {
      {
#line 1432
      tmp___24 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)((void *)0),
                        0);
#line 1432
      m->m_gid = (gid_t )tmp___24;
      }
    }
#line 1434
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 1437
    m->m_wait = convtime(p, 's');
    }
#line 1438
    goto switch_break;
    case_47: /* CIL Label */ 
#line 1441
    if ((int )*p == 0) {
      {
#line 1442
      syserr("mailer %s: null root directory", m->m_name);
      }
    } else {
      {
#line 1445
      m->m_rootdir = newstr((char const   *)p);
      }
    }
#line 1446
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1449
    syserr("M%s: unknown mailer equate %c=", m->m_name, (int )fcode);
    }
#line 1451
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1454
    p = delimptr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1476
  if ((unsigned long )m->m_argv == (unsigned long )((void *)0)) {
    {
#line 1478
    syserr("M%s: A= argument required", m->m_name);
    }
#line 1479
    return;
  }
#line 1481
  if ((unsigned long )m->m_mailer == (unsigned long )((void *)0)) {
    {
#line 1483
    syserr("M%s: P= argument required", m->m_name);
    }
#line 1484
    return;
  }
#line 1487
  if (nextmailer >= 25) {
    {
#line 1489
    syserr("too many mailers defined (%d max)", 25);
    }
#line 1490
    return;
  }
#line 1493
  if (m->m_maxrcpt <= 0) {
#line 1494
    m->m_maxrcpt = 100;
  }
#line 1497
  if (m->m_flags[76UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 76UL % (8UL * sizeof(int )))) {
#line 1499
    if (m->m_linelimit == 0) {
#line 1500
      m->m_linelimit = 990;
    }
#line 1501
    if (ConfigLevel < 2) {
#line 1502
      m->m_flags[55UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 55UL % (8UL * sizeof(int ));
    }
  }
  {
#line 1505
  tmp___26 = strcmp((char const   *)m->m_mailer, "[TCP]");
  }
#line 1505
  if (tmp___26 == 0) {
    {
#line 1507
    syserr("M%s: P=[TCP] must be replaced by P=[IPC]", m->m_name);
    }
#line 1508
    return;
  }
  {
#line 1511
  tmp___33 = strcmp((char const   *)m->m_mailer, "[IPC]");
  }
#line 1511
  if (tmp___33 == 0) {
#line 1514
    if ((unsigned long )*(m->m_argv + 0) == (unsigned long )((void *)0)) {
      {
#line 1517
      syserr("M%s: too few parameters for %s mailer", m->m_name, m->m_mailer);
      }
#line 1519
      return;
    } else
#line 1514
    if ((unsigned long )*(m->m_argv + 1) == (unsigned long )((void *)0)) {
      {
#line 1517
      syserr("M%s: too few parameters for %s mailer", m->m_name, m->m_mailer);
      }
#line 1519
      return;
    } else
#line 1514
    if ((int )*(*(m->m_argv + 1) + 0) == 0) {
      {
#line 1517
      syserr("M%s: too few parameters for %s mailer", m->m_name, m->m_mailer);
      }
#line 1519
      return;
    }
    {
#line 1521
    tmp___27 = strcmp((char const   *)*(m->m_argv + 0), "TCP");
    }
#line 1521
    if (tmp___27 != 0) {
      {
#line 1521
      tmp___28 = strcmp((char const   *)*(m->m_argv + 0), "FILE");
      }
#line 1521
      if (tmp___28 != 0) {
        {
#line 1527
        sm_io_fprintf(& SmIoF[1], -2, "M%s: Warning: first argument in %s mailer must be %s\n",
                      m->m_name, m->m_mailer, "TCP or FILE");
        }
      }
    }
#line 1537
    if ((unsigned long )m->m_mtatype == (unsigned long )((void *)0)) {
#line 1538
      m->m_mtatype = (char *)"dns";
    }
#line 1539
    if ((unsigned long )m->m_addrtype == (unsigned long )((void *)0)) {
#line 1540
      m->m_addrtype = (char *)"rfc822";
    }
#line 1541
    if ((unsigned long )m->m_diagtype == (unsigned long )((void *)0)) {
#line 1543
      if ((unsigned long )*(m->m_argv + 0) != (unsigned long )((void *)0)) {
        {
#line 1543
        tmp___29 = strcmp((char const   *)*(m->m_argv + 0), "FILE");
        }
#line 1543
        if (tmp___29 == 0) {
#line 1545
          m->m_diagtype = (char *)"x-unix";
        } else {
#line 1547
          m->m_diagtype = (char *)"smtp";
        }
      } else {
#line 1547
        m->m_diagtype = (char *)"smtp";
      }
    }
  } else {
    {
#line 1550
    tmp___32 = strcmp((char const   *)m->m_mailer, "[FILE]");
    }
#line 1550
    if (tmp___32 == 0) {
#line 1553
      if ((unsigned long )*(m->m_argv + 0) == (unsigned long )((void *)0)) {
#line 1553
        goto _L___0;
      } else
#line 1553
      if ((unsigned long )*(m->m_argv + 1) == (unsigned long )((void *)0)) {
#line 1553
        goto _L___0;
      } else
#line 1553
      if ((unsigned long )*(m->m_argv + 2) != (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 1556
        if ((unsigned long )*(m->m_argv + 0) == (unsigned long )((void *)0)) {
#line 1556
          tmp___30 = "few";
        } else
#line 1556
        if ((unsigned long )*(m->m_argv + 1) == (unsigned long )((void *)0)) {
#line 1556
          tmp___30 = "few";
        } else {
#line 1556
          tmp___30 = "many";
        }
        {
#line 1556
        syserr("M%s: too %s parameters for [FILE] mailer", m->m_name, tmp___30);
        }
#line 1560
        return;
      } else {
        {
#line 1562
        tmp___31 = strcmp((char const   *)*(m->m_argv + 0), "FILE");
        }
#line 1562
        if (tmp___31 != 0) {
          {
#line 1564
          syserr("M%s: first argument in [FILE] mailer must be FILE", m->m_name);
          }
#line 1566
          return;
        }
      }
    }
  }
#line 1570
  if ((unsigned long )m->m_eol == (unsigned long )((void *)0)) {
#line 1575
    pp = m->m_argv;
    {
#line 1575
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1575
      if (! ((unsigned long )*pp != (unsigned long )((void *)0))) {
#line 1575
        goto while_break___10;
      }
#line 1577
      p = *pp;
      {
#line 1577
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1577
        if (! ((int )*p != 0)) {
#line 1577
          goto while_break___11;
        }
#line 1579
        tmp___34 = p;
#line 1579
        p ++;
#line 1579
        if (((int )*tmp___34 & 255) == 129) {
#line 1579
          if ((int )*p == 117) {
#line 1580
            goto while_break___11;
          }
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1582
      if ((int )*p != 0) {
#line 1583
        goto while_break___10;
      }
#line 1575
      pp ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1585
    if ((unsigned long )*pp == (unsigned long )((void *)0)) {
#line 1586
      m->m_eol = (char *)"\r\n";
    } else {
#line 1588
      m->m_eol = (char *)"\n";
    }
  }
  {
#line 1592
  s = stab(m->m_name, 3, 1);
  }
#line 1593
  if ((unsigned long )s->s_value.sv_mailer != (unsigned long )((void *)0)) {
    {
#line 1595
    i = (int )(s->s_value.sv_mailer)->m_mno;
#line 1596
    sm_free_tagged((void *)s->s_value.sv_mailer, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                   1596);
    }
  } else {
#line 1600
    tmp___35 = nextmailer;
#line 1600
    nextmailer ++;
#line 1600
    i = tmp___35;
  }
#line 1602
  tmp___36 = m;
#line 1602
  s->s_value.sv_mailer = tmp___36;
#line 1602
  Mailer[i] = tmp___36;
#line 1603
  m->m_mno = (short )i;
#line 1604
  return;
}
}
#line 1631 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static char buf___3[2048]  ;
#line 1622 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
char *munchstring(char *p , char **delimptr , int delim ) 
{ 
  register char *q ;
  bool backslash ;
  bool quotemode ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 1629
  backslash = 0;
#line 1630
  quotemode = 0;
#line 1633
  q = buf___3;
  {
#line 1633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1633
    if ((int )*p != 0) {
#line 1633
      if (! ((unsigned long )q < (unsigned long )(& buf___3[sizeof(buf___3) - 1UL]))) {
#line 1633
        goto while_break;
      }
    } else {
#line 1633
      goto while_break;
    }
#line 1635
    if (backslash) {
#line 1638
      backslash = 0;
      {
#line 1641
      if ((int )*p == 114) {
#line 1641
        goto case_114;
      }
#line 1645
      if ((int )*p == 110) {
#line 1645
        goto case_110;
      }
#line 1649
      if ((int )*p == 102) {
#line 1649
        goto case_102;
      }
#line 1653
      if ((int )*p == 98) {
#line 1653
        goto case_98;
      }
#line 1639
      goto switch_break;
      case_114: /* CIL Label */ 
#line 1642
      tmp = q;
#line 1642
      q ++;
#line 1642
      *tmp = (char )'\r';
#line 1643
      goto __Cont;
      case_110: /* CIL Label */ 
#line 1646
      tmp___0 = q;
#line 1646
      q ++;
#line 1646
      *tmp___0 = (char )'\n';
#line 1647
      goto __Cont;
      case_102: /* CIL Label */ 
#line 1650
      tmp___1 = q;
#line 1650
      q ++;
#line 1650
      *tmp___1 = (char )'\f';
#line 1651
      goto __Cont;
      case_98: /* CIL Label */ 
#line 1654
      tmp___2 = q;
#line 1654
      q ++;
#line 1654
      *tmp___2 = (char )'\b';
#line 1655
      goto __Cont;
      switch_break: /* CIL Label */ ;
      }
#line 1657
      tmp___3 = q;
#line 1657
      q ++;
#line 1657
      *tmp___3 = *p;
    } else
#line 1661
    if ((int )*p == 92) {
#line 1662
      backslash = 1;
    } else
#line 1663
    if ((int )*p == 34) {
#line 1664
      quotemode = ! quotemode;
    } else
#line 1665
    if (quotemode) {
#line 1666
      tmp___4 = q;
#line 1666
      q ++;
#line 1666
      *tmp___4 = *p;
    } else
#line 1665
    if ((int )*p != delim) {
#line 1666
      tmp___4 = q;
#line 1666
      q ++;
#line 1666
      *tmp___4 = *p;
    } else {
#line 1668
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 1633
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1672
  if ((unsigned long )delimptr != (unsigned long )((void *)0)) {
#line 1673
    *delimptr = p;
  }
#line 1674
  tmp___5 = q;
#line 1674
  q ++;
#line 1674
  *tmp___5 = (char )'\000';
#line 1675
  return (buf___3);
}
}
#line 1709 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static char buf___4[2048]  ;
#line 1699 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static char *extrquotstr(char *p , char **delimptr , char *delimbuf , bool *st ) 
{ 
  register char *q ;
  bool backslash ;
  bool quotemode ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 1707
  backslash = 0;
#line 1708
  quotemode = 0;
#line 1711
  q = buf___4;
  {
#line 1711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1711
    if ((int )*p != 0) {
#line 1711
      if (! ((unsigned long )q < (unsigned long )(& buf___4[sizeof(buf___4) - 1UL]))) {
#line 1711
        goto while_break;
      }
    } else {
#line 1711
      goto while_break;
    }
#line 1713
    if (backslash) {
#line 1715
      backslash = 0;
#line 1716
      if ((int )*p != 32) {
#line 1717
        tmp = q;
#line 1717
        q ++;
#line 1717
        *tmp = (char )'\\';
      }
    }
#line 1719
    if ((int )*p == 92) {
#line 1720
      backslash = 1;
    } else
#line 1721
    if ((int )*p == 34) {
#line 1722
      quotemode = ! quotemode;
    } else
#line 1723
    if (quotemode) {
#line 1725
      tmp___0 = q;
#line 1725
      q ++;
#line 1725
      *tmp___0 = *p;
    } else {
      {
#line 1723
      tmp___1 = strchr((char const   *)delimbuf, (int )*p);
      }
#line 1723
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1725
        tmp___0 = q;
#line 1725
        q ++;
#line 1725
        *tmp___0 = *p;
      } else {
#line 1727
        goto while_break;
      }
    }
#line 1711
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1730
  if ((unsigned long )delimptr != (unsigned long )((void *)0)) {
#line 1731
    *delimptr = p;
  }
#line 1732
  tmp___2 = q;
#line 1732
  q ++;
#line 1732
  *tmp___2 = (char )'\000';
#line 1733
  if ((unsigned long )st != (unsigned long )((void *)0)) {
#line 1734
    if (quotemode) {
#line 1734
      tmp___3 = 0;
    } else
#line 1734
    if (backslash) {
#line 1734
      tmp___3 = 0;
    } else {
#line 1734
      tmp___3 = 1;
    }
#line 1734
    *st = tmp___3;
  }
#line 1735
  return (buf___4);
}
}
#line 1750 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static char **makeargv(char *p ) 
{ 
  char *q ;
  int i ;
  char **avp ;
  char *argv[257] ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1760
  i = 0;
  {
#line 1761
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1761
    if ((int )*p != 0) {
#line 1761
      if (! (i < 256)) {
#line 1761
        goto while_break;
      }
    } else {
#line 1761
      goto while_break;
    }
#line 1763
    q = p;
    {
#line 1764
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1764
      if ((int )*p != 0) {
#line 1764
        if (((int )*p & -128) == 0) {
          {
#line 1764
          tmp = __ctype_b_loc();
          }
#line 1764
          if ((int const   )*(*tmp + (int )*p) & 8192) {
#line 1764
            goto while_break___0;
          }
        }
      } else {
#line 1764
        goto while_break___0;
      }
#line 1765
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1766
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1766
      if (((int )*p & -128) == 0) {
        {
#line 1766
        tmp___1 = __ctype_b_loc();
        }
#line 1766
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 1766
          goto while_break___1;
        }
      } else {
#line 1766
        goto while_break___1;
      }
#line 1767
      tmp___0 = p;
#line 1767
      p ++;
#line 1767
      *tmp___0 = (char )'\000';
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1768
    tmp___2 = i;
#line 1768
    i ++;
#line 1768
    argv[tmp___2] = newstr((char const   *)q);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1770
  tmp___3 = i;
#line 1770
  i ++;
#line 1770
  argv[tmp___3] = (char *)((void *)0);
#line 1773
  tmp___4 = xalloc_tagged((int )(sizeof(*avp) * (unsigned long )i), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                          1773);
#line 1773
  avp = (char **)tmp___4;
#line 1774
  memmove((void *)((char *)avp), (void const   *)((char *)(argv)), (size_t )(sizeof(*avp) * (unsigned long )i));
  }
#line 1776
  return (avp);
}
}
#line 1791 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
void printrules(void) 
{ 
  register struct rewrite *rwp ;
  register int ruleset ;
  SM_FILE_T *tmp ;
  SM_FILE_T *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1797
  ruleset = 0;
  {
#line 1797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1797
    if (! (ruleset < 10)) {
#line 1797
      goto while_break;
    }
#line 1799
    if ((unsigned long )RewriteRules[ruleset] == (unsigned long )((void *)0)) {
#line 1800
      goto __Cont;
    }
    {
#line 1801
    sm_dprintf((char *)"\n----Rule Set %d:", ruleset);
#line 1803
    rwp = RewriteRules[ruleset];
    }
    {
#line 1803
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1803
      if (! ((unsigned long )rwp != (unsigned long )((void *)0))) {
#line 1803
        goto while_break___0;
      }
      {
#line 1805
      sm_dprintf((char *)"\nLHS:");
#line 1806
      tmp = sm_debug_file();
#line 1806
      printav(tmp, rwp->r_lhs);
#line 1807
      sm_dprintf((char *)"RHS:");
#line 1808
      tmp___0 = sm_debug_file();
#line 1808
      printav(tmp___0, rwp->r_rhs);
#line 1803
      rwp = rwp->r_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1797
    ruleset ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1811
  return;
}
}
#line 1823 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
void printmailer(SM_FILE_T *fp , MAILER *m ) 
{ 
  int j ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char **a ;
  char **tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 1830
  sm_io_fprintf(fp, -2, "mailer %d (%s): P=%s S=", (int )m->m_mno, m->m_name, m->m_mailer);
  }
#line 1833
  if ((unsigned long )RuleSetNames[m->m_se_rwset] == (unsigned long )((void *)0)) {
    {
#line 1834
    sm_io_fprintf(fp, -2, "%d/", (int )m->m_se_rwset);
    }
  } else {
    {
#line 1837
    sm_io_fprintf(fp, -2, "%s/", RuleSetNames[m->m_se_rwset]);
    }
  }
#line 1839
  if ((unsigned long )RuleSetNames[m->m_sh_rwset] == (unsigned long )((void *)0)) {
    {
#line 1840
    sm_io_fprintf(fp, -2, "%d R=", (int )m->m_sh_rwset);
    }
  } else {
    {
#line 1843
    sm_io_fprintf(fp, -2, "%s R=", RuleSetNames[m->m_sh_rwset]);
    }
  }
#line 1845
  if ((unsigned long )RuleSetNames[m->m_re_rwset] == (unsigned long )((void *)0)) {
    {
#line 1846
    sm_io_fprintf(fp, -2, "%d/", (int )m->m_re_rwset);
    }
  } else {
    {
#line 1849
    sm_io_fprintf(fp, -2, "%s/", RuleSetNames[m->m_re_rwset]);
    }
  }
#line 1851
  if ((unsigned long )RuleSetNames[m->m_rh_rwset] == (unsigned long )((void *)0)) {
    {
#line 1852
    sm_io_fprintf(fp, -2, "%d ", (int )m->m_rh_rwset);
    }
  } else {
    {
#line 1855
    sm_io_fprintf(fp, -2, "%s ", RuleSetNames[m->m_rh_rwset]);
    }
  }
  {
#line 1857
  sm_io_fprintf(fp, -2, "M=%ld U=%d:%d F=", m->m_maxsize, (int )m->m_uid, (int )m->m_gid);
#line 1859
  j = '\000';
  }
  {
#line 1859
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1859
    if (! (j <= 127)) {
#line 1859
      goto while_break;
    }
#line 1860
    if (m->m_flags[(unsigned long )((unsigned char )j) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )j) % (8UL * sizeof(int )))) {
      {
#line 1861
      sm_io_putc(fp, -2, j);
      }
    }
#line 1859
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1862
  sm_io_fprintf(fp, -2, " L=%d E=", m->m_linelimit);
#line 1864
  xputs(fp, (char const   *)m->m_eol);
  }
#line 1865
  if ((unsigned long )m->m_defcharset != (unsigned long )((void *)0)) {
    {
#line 1866
    sm_io_fprintf(fp, -2, " C=%s", m->m_defcharset);
    }
  }
#line 1868
  if ((unsigned long )m->m_diagtype == (unsigned long )((void *)0)) {
#line 1868
    tmp = "<undefined>";
  } else {
#line 1868
    tmp = (char const   *)m->m_diagtype;
  }
#line 1868
  if ((unsigned long )m->m_addrtype == (unsigned long )((void *)0)) {
#line 1868
    tmp___0 = "<undefined>";
  } else {
#line 1868
    tmp___0 = (char const   *)m->m_addrtype;
  }
#line 1868
  if ((unsigned long )m->m_mtatype == (unsigned long )((void *)0)) {
#line 1868
    tmp___1 = "<undefined>";
  } else {
#line 1868
    tmp___1 = (char const   *)m->m_mtatype;
  }
  {
#line 1868
  sm_io_fprintf(fp, -2, " T=%s/%s/%s", tmp___1, tmp___0, tmp);
#line 1875
  sm_io_fprintf(fp, -2, " r=%d", m->m_maxrcpt);
  }
#line 1876
  if ((unsigned long )m->m_argv != (unsigned long )((void *)0)) {
    {
#line 1878
    a = m->m_argv;
#line 1880
    sm_io_fprintf(fp, -2, " A=");
    }
    {
#line 1881
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1881
      if (! ((unsigned long )*a != (unsigned long )((void *)0))) {
#line 1881
        goto while_break___0;
      }
#line 1883
      if ((unsigned long )a != (unsigned long )m->m_argv) {
        {
#line 1884
        sm_io_fprintf(fp, -2, " ");
        }
      }
      {
#line 1886
      tmp___2 = a;
#line 1886
      a ++;
#line 1886
      xputs(fp, (char const   *)*tmp___2);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1889
  sm_io_fprintf(fp, -2, "\n");
  }
#line 1890
  return;
}
}
#line 1911 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static BITMAP256 StickyOpt  ;
#line 1915 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static struct resolverflags ResolverFlags[12]  = 
#line 1915
  {      {(char *)"debug", 2L}, 
        {(char *)"aaonly", 4L}, 
        {(char *)"usevc", 8L}, 
        {(char *)"primary", 16L}, 
        {(char *)"igntc", 32L}, 
        {(char *)"recurse", 64L}, 
        {(char *)"defnames", 128L}, 
        {(char *)"stayopen", 256L}, 
        {(char *)"dnsrch", 512L}, 
        {(char *)"use_inet6", 8192L}, 
        {(char *)"true", 0L}, 
        {(char *)((void *)0), 0L}};
#line 1943 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static struct optioninfo OptionTab[128]  = 
#line 1943
  {      {(char *)"SevenBitInput", (unsigned char )'7', (unsigned short)1}, 
        {(char *)"EightBitMode", (unsigned char )'8', (unsigned short)1}, 
        {(char *)"AliasFile", (unsigned char )'A', (unsigned short)0}, 
        {(char *)"AliasWait", (unsigned char )'a', (unsigned short)0}, 
        {(char *)"BlankSub", (unsigned char )'B', (unsigned short)0}, 
        {(char *)"MinFreeBlocks", (unsigned char )'b', (unsigned short)1}, 
        {(char *)"CheckpointInterval", (unsigned char )'C', (unsigned short)1}, 
        {(char *)"HoldExpensive", (unsigned char )'c', (unsigned short)0}, 
        {(char *)"DeliveryMode", (unsigned char )'d', (unsigned short)1}, 
        {(char *)"ErrorHeader", (unsigned char )'E', (unsigned short)0}, 
        {(char *)"ErrorMode", (unsigned char )'e', (unsigned short)1}, 
        {(char *)"TempFileMode", (unsigned char )'F', (unsigned short)0}, 
        {(char *)"SaveFromLine", (unsigned char )'f', (unsigned short)0}, 
        {(char *)"MatchGECOS", (unsigned char )'G', (unsigned short)0}, 
        {(char *)"", (unsigned char )'g', (unsigned short)0}, 
        {(char *)"HelpFile", (unsigned char )'H', (unsigned short)0}, 
        {(char *)"MaxHopCount", (unsigned char )'h', (unsigned short)0}, 
        {(char *)"ResolverOptions", (unsigned char )'I', (unsigned short)0}, 
        {(char *)"IgnoreDots", (unsigned char )'i', (unsigned short)1}, 
        {(char *)"ForwardPath", (unsigned char )'J', (unsigned short)0}, 
        {(char *)"SendMimeErrors", (unsigned char )'j', (unsigned short)1}, 
        {(char *)"ConnectionCacheSize", (unsigned char )'k', (unsigned short)0}, 
        {(char *)"ConnectionCacheTimeout", (unsigned char )'K', (unsigned short)0}, 
        {(char *)"UseErrorsTo", (unsigned char )'l', (unsigned short)0}, 
        {(char *)"LogLevel", (unsigned char )'L', (unsigned short)1}, 
        {(char *)"MeToo", (unsigned char )'m', (unsigned short)1}, 
        {(char *)"", (unsigned char )'M', (unsigned short)0}, 
        {(char *)"CheckAliases", (unsigned char )'n', (unsigned short)0}, 
        {(char *)"OldStyleHeaders", (unsigned char )'o', (unsigned short)1}, 
        {(char *)"DaemonPortOptions", (unsigned char )'O', (unsigned short)0}, 
        {(char *)"PrivacyOptions", (unsigned char )'p', (unsigned short)1}, 
        {(char *)"PostmasterCopy", (unsigned char )'P', (unsigned short)0}, 
        {(char *)"QueueFactor", (unsigned char )'q', (unsigned short)0}, 
        {(char *)"QueueDirectory", (unsigned char )'Q', (unsigned short)0}, 
        {(char *)"DontPruneRoutes", (unsigned char )'R', (unsigned short)0}, 
        {(char *)"Timeout", (unsigned char )'r', (unsigned short)2}, 
        {(char *)"StatusFile", (unsigned char )'S', (unsigned short)0}, 
        {(char *)"SuperSafe", (unsigned char )'s', (unsigned short)1}, 
        {(char *)"QueueTimeout", (unsigned char )'T', (unsigned short)0}, 
        {(char *)"TimeZoneSpec", (unsigned char )'t', (unsigned short)0}, 
        {(char *)"UserDatabaseSpec", (unsigned char )'U', (unsigned short)0}, 
        {(char *)"DefaultUser", (unsigned char )'u', (unsigned short)0}, 
        {(char *)"FallbackMXhost", (unsigned char )'V', (unsigned short)0}, 
        {(char *)"Verbose", (unsigned char )'v', (unsigned short)1}, 
        {(char *)"TryNullMXList", (unsigned char )'w', (unsigned short)0}, 
        {(char *)"QueueLA", (unsigned char )'x', (unsigned short)0}, 
        {(char *)"RefuseLA", (unsigned char )'X', (unsigned short)0}, 
        {(char *)"RecipientFactor", (unsigned char )'y', (unsigned short)0}, 
        {(char *)"ForkEachJob", (unsigned char )'Y', (unsigned short)0}, 
        {(char *)"ClassFactor", (unsigned char )'z', (unsigned short)0}, 
        {(char *)"RetryFactor", (unsigned char )'Z', (unsigned short)0}, 
        {(char *)"QueueSortOrder", (unsigned char)129, (unsigned short)1}, 
        {(char *)"HostsFile", (unsigned char)130, (unsigned short)0}, 
        {(char *)"MinQueueAge", (unsigned char)131, (unsigned short)1}, 
        {(char *)"DefaultCharSet", (unsigned char)133, (unsigned short)1}, 
        {(char *)"ServiceSwitchFile", (unsigned char)134, (unsigned short)0}, 
        {(char *)"DialDelay", (unsigned char)135, (unsigned short)1}, 
        {(char *)"NoRecipientAction", (unsigned char)136, (unsigned short)1}, 
        {(char *)"SafeFileEnvironment", (unsigned char)137, (unsigned short)0}, 
        {(char *)"MaxMessageSize", (unsigned char)138, (unsigned short)0}, 
        {(char *)"ColonOkInAddr", (unsigned char)139, (unsigned short)1}, 
        {(char *)"MaxQueueRunSize", (unsigned char)140, (unsigned short)1}, 
        {(char *)"MaxDaemonChildren", (unsigned char)141, (unsigned short)0}, 
        {(char *)"DontExpandCnames", (unsigned char)142, (unsigned short)0}, 
        {(char *)"MustQuoteChars", (unsigned char)143, (unsigned short)0}, 
        {(char *)"SmtpGreetingMessage", (unsigned char)144, (unsigned short)0}, 
        {(char *)"UnixFromLine", (unsigned char)145, (unsigned short)0}, 
        {(char *)"OperatorChars", (unsigned char)146, (unsigned short)0}, 
        {(char *)"DontInitGroups", (unsigned char)147, (unsigned short)0}, 
        {(char *)"SingleLineFromHeader", (unsigned char)148, (unsigned short)1}, 
        {(char *)"AllowBogusHELO", (unsigned char)149, (unsigned short)1}, 
        {(char *)"ConnectionRateThrottle", (unsigned char)151, (unsigned short)0}, 
        {(char *)"UnsafeGroupWrites", (unsigned char)153, (unsigned short)0}, 
        {(char *)"DoubleBounceAddress", (unsigned char)154, (unsigned short)0}, 
        {(char *)"HostStatusDirectory", (unsigned char)155, (unsigned short)0}, 
        {(char *)"SingleThreadDelivery", (unsigned char)156, (unsigned short)0}, 
        {(char *)"RunAsUser", (unsigned char)157, (unsigned short)0}, 
        {(char *)"RrtImpliesDsn", (unsigned char)158, (unsigned short)0}, 
        {(char *)"PidFile", (unsigned char)159, (unsigned short)0}, 
        {(char *)"DontBlameSendmail", (unsigned char)160, (unsigned short)0}, 
        {(char *)"DontProbeInterfaces", (unsigned char)161, (unsigned short)0}, 
        {(char *)"MaxRecipientsPerMessage", (unsigned char)162, (unsigned short)1}, 
        {(char *)"DeadLetterDrop", (unsigned char)163, (unsigned short)0}, 
        {(char *)"MaxAliasRecursion", (unsigned char)165, (unsigned short)0}, 
        {(char *)"ConnectOnlyTo", (unsigned char)166, (unsigned short)0}, 
        {(char *)"TrustedUser", (unsigned char)167, (unsigned short)0}, 
        {(char *)"MaxMimeHeaderLength", (unsigned char)168, (unsigned short)0}, 
        {(char *)"ControlSocketName", (unsigned char)169, (unsigned short)0}, 
        {(char *)"MaxHeadersLength", (unsigned char)170, (unsigned short)0}, 
        {(char *)"ProcessTitlePrefix", (unsigned char)172, (unsigned short)0}, 
        {(char *)"DefaultAuthInfo", (unsigned char)173, (unsigned short)0}, 
        {(char *)"AuthMechanisms", (unsigned char)174, (unsigned short)0}, 
        {(char *)"ClientPortOptions", (unsigned char)175, (unsigned short)0}, 
        {(char *)"DataFileBufferSize", (unsigned char)176, (unsigned short)0}, 
        {(char *)"XscriptFileBufferSize", (unsigned char)177, (unsigned short)0}, 
        {(char *)"LDAPDefaultSpec", (unsigned char)178, (unsigned short)0}, 
        {(char *)"ServerCertFile", (unsigned char)180, (unsigned short)0}, 
        {(char *)"ServerKeyFile", (unsigned char)181, (unsigned short)0}, 
        {(char *)"ClientCertFile", (unsigned char)182, (unsigned short)0}, 
        {(char *)"ClientKeyFile", (unsigned char)183, (unsigned short)0}, 
        {(char *)"CACertFile", (unsigned char)184, (unsigned short)0}, 
        {(char *)"CACertPath", (unsigned char)185, (unsigned short)0}, 
        {(char *)"DHParameters", (unsigned char)186, (unsigned short)0}, 
        {(char *)"InputMailFilters", (unsigned char)187, (unsigned short)0}, 
        {(char *)"Milter", (unsigned char)188, (unsigned short)2}, 
        {(char *)"AuthOptions", (unsigned char)189, (unsigned short)0}, 
        {(char *)"QueueFileMode", (unsigned char)190, (unsigned short)0}, 
        {(char *)"RandFile", (unsigned char)193, (unsigned short)0}, 
        {(char *)"TLSSrvOptions", (unsigned char)194, (unsigned short)0}, 
        {(char *)"BadRcptThrottle", (unsigned char)195, (unsigned short)1}, 
        {(char *)"DeliverByMin", (unsigned char)196, (unsigned short)0}, 
        {(char *)"MaxQueueChildren", (unsigned char)197, (unsigned short)0}, 
        {(char *)"MaxRunnersPerQueue", (unsigned char)198, (unsigned short)0}, 
        {(char *)"DirectSubmissionModifiers", (unsigned char)199, (unsigned short)0}, 
        {(char *)"NiceQueueRun",
      (unsigned char)200, (unsigned short)0}, 
        {(char *)"SharedMemoryKey", (unsigned char)201, (unsigned short)0}, 
        {(char *)"AuthMaxBits", (unsigned char)202, (unsigned short)0}, 
        {(char *)"MailboxDatabase", (unsigned char)203, (unsigned short)0}, 
        {(char *)"UseMSP", (unsigned char)204, (unsigned short)0}, 
        {(char *)"DelayLA", (unsigned char)205, (unsigned short)0}, 
        {(char *)"FastSplit", (unsigned char)206, (unsigned short)0}, 
        {(char *)"RejectLogInterval", (unsigned char)209, (unsigned short)0}, 
        {(char *)"RequiresDirfsync", (unsigned char)210, (unsigned short)0}, 
        {(char *)"ConnectionRateWindowSize", (unsigned char)211, (unsigned short)0}, 
        {(char *)"CRLFile", (unsigned char)212, (unsigned short)0}, 
        {(char *)"FallbackSmartHost", (unsigned char)213, (unsigned short)0}, 
        {(char *)"AuthRealm", (unsigned char)214, (unsigned short)0}, 
        {(char *)((void *)0), (unsigned char )'\000', (unsigned short)0}};
#line 2250
bool Warn_Q_option ;
#line 2695
struct prival PrivacyValues[16] ;
#line 3233
struct dbsval DontBlameSendmailValues[43] ;
#line 2235 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
void setoption(int opt , char *val , bool safe , bool sticky , ENVELOPE *e ) 
{ 
  register char *p ;
  register struct optioninfo *o ;
  char *subopt ;
  int mid ;
  bool can_setuid ;
  char *ep ;
  char buf___16[50] ;
  int *tmp ;
  struct optioninfo *sel ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int oldVerbose ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___14 ;
  unsigned short const   **tmp___15 ;
  SM_FILE_T *tmp___16 ;
  int dp ;
  char *al ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  register struct group *gr ;
  unsigned short const   **tmp___21 ;
  bool clearmode ;
  char *q ;
  struct resolverflags *rfp ;
  unsigned short const   **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  struct __res_state *tmp___27 ;
  struct __res_state *tmp___28 ;
  struct __res_state *tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  bool tmp___32 ;
  bool tmp___33 ;
  register struct prival *pv ;
  unsigned short const   **tmp___34 ;
  unsigned short const   **tmp___35 ;
  unsigned short const   **tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  bool tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  register struct passwd *pw ;
  unsigned short const   **tmp___47 ;
  bool tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  size_t tmp___59 ;
  char *tmp___60 ;
  long tmp___61 ;
  size_t tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  bool tmp___66 ;
  char *tmp___67 ;
  int tmp___68 ;
  register struct passwd *pw___0 ;
  unsigned short const   **tmp___69 ;
  gid_t runasgid ;
  int tmp___70 ;
  register struct group *gr___0 ;
  unsigned short const   **tmp___71 ;
  char *_newval ;
  char *tmp___72 ;
  register struct dbsval *dbs ;
  unsigned short const   **tmp___73 ;
  unsigned short const   **tmp___74 ;
  unsigned short const   **tmp___75 ;
  char *tmp___76 ;
  int tmp___77 ;
  bool tmp___78 ;
  int tmp___79 ;
  char *_newval___0 ;
  char *tmp___80 ;
  int tmp___81 ;
  register struct passwd *pw___1 ;
  unsigned short const   **tmp___82 ;
  char *tmp___83 ;
  char *_newval___1 ;
  char *tmp___84 ;
  char *_newval___2 ;
  char *tmp___85 ;
  char const   *tmp___86 ;
  char const   *tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  char const   *tmp___90 ;
  int tmp___91 ;
  BITMAP256 m ;
  char *tmp___92 ;
  int tmp___93 ;
  time_t tmp___94 ;
  unsigned short const   **tmp___95 ;
  void *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;

  {
  {
#line 2247
  can_setuid = RunAsUid == 0U;
#line 2259
  tmp = __errno_location();
#line 2259
  *tmp = 0;
  }
#line 2260
  if (opt == 32) {
    {
#line 2265
    p = strchr((char const   *)val, '=');
    }
#line 2266
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 2267
      tmp___0 = strlen((char const   *)val);
#line 2267
      p = val + tmp___0;
      }
    }
    {
#line 2268
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2268
      p --;
#line 2268
      if (! ((int )*p == 32)) {
#line 2268
        goto while_break;
      }
#line 2269
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2270
      p ++;
#line 2270
      if (! ((int )*p == 32)) {
#line 2270
        goto while_break___0;
      }
#line 2271
      *p = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2272
    if ((unsigned long )p == (unsigned long )val) {
      {
#line 2274
      syserr("readcf: null option name");
      }
#line 2275
      return;
    }
#line 2277
    if ((int )*p == 61) {
#line 2278
      tmp___1 = p;
#line 2278
      p ++;
#line 2278
      *tmp___1 = (char )'\000';
    }
    {
#line 2279
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2279
      if (! ((int )*p == 32)) {
#line 2279
        goto while_break___1;
      }
#line 2280
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2281
    subopt = strchr((char const   *)val, '.');
    }
#line 2282
    if ((unsigned long )subopt != (unsigned long )((void *)0)) {
#line 2283
      tmp___2 = subopt;
#line 2283
      subopt ++;
#line 2283
      *tmp___2 = (char )'\000';
    }
#line 2284
    sel = (struct optioninfo *)((void *)0);
#line 2285
    o = OptionTab;
    {
#line 2285
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2285
      if (! ((unsigned long )o->o_name != (unsigned long )((void *)0))) {
#line 2285
        goto while_break___2;
      }
      {
#line 2287
      tmp___3 = strlen((char const   *)val);
#line 2287
      tmp___4 = sm_strncasecmp((char const   *)o->o_name, (char const   *)val, tmp___3);
      }
#line 2287
      if (tmp___4 != 0) {
#line 2288
        goto __Cont;
      }
      {
#line 2289
      tmp___5 = strlen((char const   *)o->o_name);
#line 2289
      tmp___6 = strlen((char const   *)val);
      }
#line 2289
      if (tmp___5 == tmp___6) {
#line 2292
        sel = (struct optioninfo *)((void *)0);
#line 2293
        goto while_break___2;
      }
#line 2295
      if ((unsigned long )sel != (unsigned long )((void *)0)) {
#line 2296
        goto while_break___2;
      }
#line 2297
      sel = o;
      __Cont: /* CIL Label */ 
#line 2285
      o ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2299
    if ((unsigned long )sel != (unsigned long )((void *)0)) {
#line 2299
      if ((unsigned long )o->o_name == (unsigned long )((void *)0)) {
#line 2300
        o = sel;
      } else {
#line 2299
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2301
    if ((unsigned long )o->o_name == (unsigned long )((void *)0)) {
      {
#line 2303
      syserr("readcf: unknown option name %s", val);
      }
#line 2304
      return;
    } else
#line 2306
    if ((unsigned long )sel != (unsigned long )((void *)0)) {
      {
#line 2308
      syserr("readcf: ambiguous option name %s (matches %s and %s)", val, sel->o_name,
             o->o_name);
      }
#line 2310
      return;
    }
    {
#line 2312
    tmp___7 = strlen((char const   *)val);
#line 2312
    tmp___8 = strlen((char const   *)o->o_name);
    }
#line 2312
    if (tmp___7 != tmp___8) {
      {
#line 2314
      oldVerbose = Verbose;
#line 2316
      Verbose = 1;
#line 2317
      message("Option %s used as abbreviation for %s", val, o->o_name);
#line 2319
      Verbose = oldVerbose;
      }
    }
#line 2321
    opt = (int )o->o_code;
#line 2322
    val = p;
  } else {
#line 2326
    o = OptionTab;
    {
#line 2326
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2326
      if (! ((unsigned long )o->o_name != (unsigned long )((void *)0))) {
#line 2326
        goto while_break___3;
      }
#line 2328
      if ((int )o->o_code == opt) {
#line 2329
        goto while_break___3;
      }
#line 2326
      o ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2331
    if ((unsigned long )o->o_name == (unsigned long )((void *)0)) {
      {
#line 2333
      syserr("readcf: unknown option name 0x%x", opt & 255);
      }
#line 2334
      return;
    }
#line 2336
    subopt = (char *)((void *)0);
  }
#line 2339
  if ((unsigned long )subopt != (unsigned long )((void *)0)) {
#line 2339
    if (! (((int )o->o_flags & 2) != 0)) {
#line 2341
      if ((int )tTdvect[37] >= 1) {
#line 2342
        if ((unsigned long )o->o_name == (unsigned long )((void *)0)) {
#line 2342
          tmp___9 = "<unknown>";
        } else {
#line 2342
          tmp___9 = (char const   *)o->o_name;
        }
        {
#line 2342
        sm_dprintf((char *)"setoption: %s does not support suboptions, ignoring .%s\n",
                   tmp___9, subopt);
        }
      }
#line 2344
      subopt = (char *)((void *)0);
    }
  }
#line 2347
  if ((int )tTdvect[37] >= 1) {
#line 2349
    if ((unsigned long )subopt == (unsigned long )((void *)0)) {
#line 2349
      tmp___10 = "";
    } else {
#line 2349
      tmp___10 = (char const   *)subopt;
    }
#line 2349
    if ((unsigned long )subopt == (unsigned long )((void *)0)) {
#line 2349
      tmp___11 = "";
    } else {
#line 2349
      tmp___11 = ".";
    }
#line 2349
    if ((unsigned long )o->o_name == (unsigned long )((void *)0)) {
#line 2349
      tmp___12 = "<unknown>";
    } else {
#line 2349
      tmp___12 = (char const   *)o->o_name;
    }
#line 2349
    if ((opt & -128) == 0) {
      {
#line 2349
      tmp___15 = __ctype_b_loc();
      }
#line 2349
      if ((int const   )*(*tmp___15 + opt) & 16384) {
#line 2349
        tmp___14 = "setoption %s (%c)%s%s=";
      } else {
#line 2349
        tmp___14 = "setoption %s (0x%x)%s%s=";
      }
    } else {
#line 2349
      tmp___14 = "setoption %s (0x%x)%s%s=";
    }
    {
#line 2349
    sm_dprintf((char *)tmp___14, tmp___12, opt, tmp___11, tmp___10);
#line 2354
    tmp___16 = sm_debug_file();
#line 2354
    xputs(tmp___16, (char const   *)val);
    }
  }
#line 2361
  if (! sticky) {
#line 2361
    if (StickyOpt[(unsigned long )((unsigned char )opt) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )opt) % (8UL * sizeof(int )))) {
#line 2363
      if ((int )tTdvect[37] >= 1) {
        {
#line 2364
        sm_dprintf((char *)" (ignored)\n");
        }
      }
#line 2365
      return;
    }
  }
#line 2372
  if (! safe) {
#line 2372
    if (RealUid == 0U) {
#line 2373
      safe = 1;
    }
  }
#line 2374
  if (! safe) {
#line 2374
    if (! (((int )o->o_flags & 1) != 0)) {
#line 2376
      if (opt != 77) {
#line 2376
        goto _L___0;
      } else
#line 2376
      if ((int )*(val + 0) != 114) {
#line 2376
        if ((int )*(val + 0) != 115) {
          _L___0: /* CIL Label */ 
#line 2380
          if ((int )tTdvect[37] >= 1) {
            {
#line 2381
            sm_dprintf((char *)" (unsafe)");
            }
          }
          {
#line 2382
          dp = drop_privileges(1);
          }
#line 2383
          if (ExitStat == 0) {
#line 2383
            ExitStat = dp;
          } else
#line 2383
          if (ExitStat == 75) {
#line 2383
            ExitStat = dp;
          }
        }
      }
    }
  }
#line 2386
  if ((int )tTdvect[37] >= 1) {
    {
#line 2387
    sm_dprintf((char *)"\n");
    }
  }
  {
#line 2391
  if ((opt & 255) == 55) {
#line 2391
    goto case_55;
  }
#line 2395
  if ((opt & 255) == 56) {
#line 2395
    goto case_56;
  }
#line 2440
  if ((opt & 255) == 65) {
#line 2440
    goto case_65;
  }
#line 2452
  if ((opt & 255) == 97) {
#line 2452
    goto case_97;
  }
#line 2459
  if ((opt & 255) == 66) {
#line 2459
    goto case_66;
  }
#line 2465
  if ((opt & 255) == 98) {
#line 2465
    goto case_98;
  }
#line 2475
  if ((opt & 255) == 99) {
#line 2475
    goto case_99;
  }
#line 2479
  if ((opt & 255) == 67) {
#line 2479
    goto case_67;
  }
#line 2484
  if ((opt & 255) == 100) {
#line 2484
    goto case_100;
  }
#line 2508
  if ((opt & 255) == 69) {
#line 2508
    goto case_69;
  }
#line 2513
  if ((opt & 255) == 101) {
#line 2513
    goto case_101;
  }
#line 2526
  if ((opt & 255) == 70) {
#line 2526
    goto case_70;
  }
#line 2530
  if ((opt & 255) == 102) {
#line 2530
    goto case_102;
  }
#line 2534
  if ((opt & 255) == 71) {
#line 2534
    goto case_71;
  }
#line 2538
  if ((opt & 255) == 103) {
#line 2538
    goto g_opt;
  }
#line 2556
  if ((opt & 255) == 72) {
#line 2556
    goto case_72;
  }
#line 2568
  if ((opt & 255) == 104) {
#line 2568
    goto case_104;
  }
#line 2572
  if ((opt & 255) == 73) {
#line 2572
    goto case_73;
  }
#line 2625
  if ((opt & 255) == 105) {
#line 2625
    goto case_105___0;
  }
#line 2629
  if ((opt & 255) == 106) {
#line 2629
    goto case_106;
  }
#line 2633
  if ((opt & 255) == 74) {
#line 2633
    goto case_74;
  }
#line 2638
  if ((opt & 255) == 107) {
#line 2638
    goto case_107;
  }
#line 2644
  if ((opt & 255) == 75) {
#line 2644
    goto case_75;
  }
#line 2648
  if ((opt & 255) == 108) {
#line 2648
    goto case_108;
  }
#line 2652
  if ((opt & 255) == 76) {
#line 2652
    goto case_76;
  }
#line 2657
  if ((opt & 255) == 77) {
#line 2657
    goto case_77;
  }
#line 2668
  if ((opt & 255) == 109) {
#line 2668
    goto case_109___1;
  }
#line 2672
  if ((opt & 255) == 110) {
#line 2672
    goto case_110;
  }
#line 2678
  if ((opt & 255) == 79) {
#line 2678
    goto case_79;
  }
#line 2683
  if ((opt & 255) == 111) {
#line 2683
    goto case_111;
  }
#line 2690
  if ((opt & 255) == 112) {
#line 2690
    goto case_112___1;
  }
#line 2720
  if ((opt & 255) == 80) {
#line 2720
    goto case_80;
  }
#line 2724
  if ((opt & 255) == 113) {
#line 2724
    goto case_113___1;
  }
#line 2728
  if ((opt & 255) == 81) {
#line 2728
    goto case_81;
  }
#line 2741
  if ((opt & 255) == 82) {
#line 2741
    goto case_82;
  }
#line 2745
  if ((opt & 255) == 114) {
#line 2745
    goto case_114;
  }
#line 2752
  if ((opt & 255) == 83) {
#line 2752
    goto case_83;
  }
#line 2764
  if ((opt & 255) == 115) {
#line 2764
    goto case_115___0;
  }
#line 2778
  if ((opt & 255) == 84) {
#line 2778
    goto case_84;
  }
#line 2788
  if ((opt & 255) == 116) {
#line 2788
    goto case_116;
  }
#line 2792
  if ((opt & 255) == 85) {
#line 2792
    goto case_85;
  }
#line 2796
  if ((opt & 255) == 117) {
#line 2796
    goto case_117;
  }
#line 2848
  if ((opt & 255) == 86) {
#line 2848
    goto case_86;
  }
#line 2853
  if ((opt & 255) == 118) {
#line 2853
    goto case_118;
  }
#line 2857
  if ((opt & 255) == 119) {
#line 2857
    goto case_119___0;
  }
#line 2863
  if ((opt & 255) == 120) {
#line 2863
    goto case_120;
  }
#line 2867
  if ((opt & 255) == 88) {
#line 2867
    goto case_88;
  }
#line 2871
  if ((opt & 255) == 205) {
#line 2871
    goto case_205;
  }
#line 2875
  if ((opt & 255) == 121) {
#line 2875
    goto case_121;
  }
#line 2879
  if ((opt & 255) == 89) {
#line 2879
    goto case_89;
  }
#line 2883
  if ((opt & 255) == 122) {
#line 2883
    goto case_122;
  }
#line 2887
  if ((opt & 255) == 90) {
#line 2887
    goto case_90;
  }
#line 2895
  if ((opt & 255) == 129) {
#line 2895
    goto case_129;
  }
#line 2945
  if ((opt & 255) == 130) {
#line 2945
    goto case_130;
  }
#line 2950
  if ((opt & 255) == 131) {
#line 2950
    goto case_131;
  }
#line 2954
  if ((opt & 255) == 133) {
#line 2954
    goto case_133;
  }
#line 2958
  if ((opt & 255) == 134) {
#line 2958
    goto case_134;
  }
#line 2963
  if ((opt & 255) == 135) {
#line 2963
    goto case_135;
  }
#line 2967
  if ((opt & 255) == 136) {
#line 2967
    goto case_136;
  }
#line 2982
  if ((opt & 255) == 137) {
#line 2982
    goto case_137;
  }
#line 2997
  if ((opt & 255) == 138) {
#line 2997
    goto case_138;
  }
#line 3001
  if ((opt & 255) == 139) {
#line 3001
    goto case_139;
  }
#line 3005
  if ((opt & 255) == 140) {
#line 3005
    goto case_140;
  }
#line 3009
  if ((opt & 255) == 141) {
#line 3009
    goto case_141;
  }
#line 3013
  if ((opt & 255) == 197) {
#line 3013
    goto case_197;
  }
#line 3017
  if ((opt & 255) == 198) {
#line 3017
    goto case_198;
  }
#line 3021
  if ((opt & 255) == 200) {
#line 3021
    goto case_200;
  }
#line 3031
  if ((opt & 255) == 201) {
#line 3031
    goto case_201;
  }
#line 3059
  if ((opt & 255) == 142) {
#line 3059
    goto case_142;
  }
#line 3063
  if ((opt & 255) == 143) {
#line 3063
    goto case_143;
  }
#line 3073
  if ((opt & 255) == 144) {
#line 3073
    goto case_144;
  }
#line 3077
  if ((opt & 255) == 145) {
#line 3077
    goto case_145;
  }
#line 3081
  if ((opt & 255) == 146) {
#line 3081
    goto case_146;
  }
#line 3088
  if ((opt & 255) == 147) {
#line 3088
    goto case_147;
  }
#line 3092
  if ((opt & 255) == 148) {
#line 3092
    goto case_148;
  }
#line 3096
  if ((opt & 255) == 149) {
#line 3096
    goto case_149;
  }
#line 3100
  if ((opt & 255) == 151) {
#line 3100
    goto case_151;
  }
#line 3104
  if ((opt & 255) == 153) {
#line 3104
    goto case_153;
  }
#line 3114
  if ((opt & 255) == 154) {
#line 3114
    goto case_154;
  }
#line 3118
  if ((opt & 255) == 155) {
#line 3118
    goto case_155;
  }
#line 3126
  if ((opt & 255) == 156) {
#line 3126
    goto case_156;
  }
#line 3130
  if ((opt & 255) == 157) {
#line 3130
    goto case_157;
  }
#line 3220
  if ((opt & 255) == 158) {
#line 3220
    goto case_158;
  }
#line 3224
  if ((opt & 255) == 159) {
#line 3224
    goto case_159;
  }
#line 3228
  if ((opt & 255) == 160) {
#line 3228
    goto case_160;
  }
#line 3261
  if ((opt & 255) == 161) {
#line 3261
    goto case_161;
  }
#line 3270
  if ((opt & 255) == 162) {
#line 3270
    goto case_162;
  }
#line 3274
  if ((opt & 255) == 195) {
#line 3274
    goto case_195;
  }
#line 3278
  if ((opt & 255) == 163) {
#line 3278
    goto case_163;
  }
#line 3289
  if ((opt & 255) == 165) {
#line 3289
    goto case_165;
  }
#line 3293
  if ((opt & 255) == 166) {
#line 3293
    goto case_166;
  }
#line 3320
  if ((opt & 255) == 167) {
#line 3320
    goto case_167;
  }
#line 3353
  if ((opt & 255) == 168) {
#line 3353
    goto case_168;
  }
#line 3376
  if ((opt & 255) == 169) {
#line 3376
    goto case_169;
  }
#line 3380
  if ((opt & 255) == 170) {
#line 3380
    goto case_170;
  }
#line 3390
  if ((opt & 255) == 172) {
#line 3390
    goto case_172;
  }
#line 3502
  if ((opt & 255) == 202) {
#line 3502
    goto case_202;
  }
#line 3502
  if ((opt & 255) == 189) {
#line 3502
    goto case_202;
  }
#line 3502
  if ((opt & 255) == 214) {
#line 3502
    goto case_202;
  }
#line 3502
  if ((opt & 255) == 174) {
#line 3502
    goto case_202;
  }
#line 3502
  if ((opt & 255) == 173) {
#line 3502
    goto case_202;
  }
#line 3623
  if ((opt & 255) == 193) {
#line 3623
    goto case_193;
  }
#line 3623
  if ((opt & 255) == 212) {
#line 3623
    goto case_193;
  }
#line 3623
  if ((opt & 255) == 186) {
#line 3623
    goto case_193;
  }
#line 3623
  if ((opt & 255) == 185) {
#line 3623
    goto case_193;
  }
#line 3623
  if ((opt & 255) == 184) {
#line 3623
    goto case_193;
  }
#line 3623
  if ((opt & 255) == 183) {
#line 3623
    goto case_193;
  }
#line 3623
  if ((opt & 255) == 182) {
#line 3623
    goto case_193;
  }
#line 3623
  if ((opt & 255) == 181) {
#line 3623
    goto case_193;
  }
#line 3623
  if ((opt & 255) == 180) {
#line 3623
    goto case_193;
  }
#line 3631
  if ((opt & 255) == 175) {
#line 3631
    goto case_175;
  }
#line 3635
  if ((opt & 255) == 176) {
#line 3635
    goto case_176;
  }
#line 3639
  if ((opt & 255) == 177) {
#line 3639
    goto case_177;
  }
#line 3643
  if ((opt & 255) == 178) {
#line 3643
    goto case_178;
  }
#line 3653
  if ((opt & 255) == 187) {
#line 3653
    goto case_187;
  }
#line 3663
  if ((opt & 255) == 188) {
#line 3663
    goto case_188;
  }
#line 3673
  if ((opt & 255) == 190) {
#line 3673
    goto case_190;
  }
#line 3677
  if ((opt & 255) == 196) {
#line 3677
    goto case_196;
  }
#line 3682
  if ((opt & 255) == 199) {
#line 3682
    goto case_199;
  }
#line 3693
  if ((opt & 255) == 206) {
#line 3693
    goto case_206;
  }
#line 3697
  if ((opt & 255) == 203) {
#line 3697
    goto case_203;
  }
#line 3701
  if ((opt & 255) == 204) {
#line 3701
    goto case_204;
  }
#line 3711
  if ((opt & 255) == 209) {
#line 3711
    goto case_209;
  }
#line 3715
  if ((opt & 255) == 210) {
#line 3715
    goto case_210;
  }
#line 3723
  if ((opt & 255) == 211) {
#line 3723
    goto case_211;
  }
#line 3727
  if ((opt & 255) == 213) {
#line 3727
    goto case_213;
  }
#line 3767
  goto switch_default___2;
  case_55: /* CIL Label */ 
  {
#line 2392
  SevenBitInput = atobool(val);
  }
#line 2393
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 2399
  if ((int )*val == 112) {
#line 2399
    goto case_112;
  }
#line 2403
  if ((int )*val == 109) {
#line 2403
    goto case_109;
  }
#line 2407
  if ((int )*val == 115) {
#line 2407
    goto case_115;
  }
#line 2429
  goto switch_default;
  case_112: /* CIL Label */ 
#line 2400
  MimeMode = 3;
#line 2401
  goto switch_break___0;
  case_109: /* CIL Label */ 
#line 2404
  MimeMode = 5;
#line 2405
  goto switch_break___0;
  case_115: /* CIL Label */ 
#line 2408
  MimeMode = 1;
#line 2409
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 2430
  syserr("Unknown 8-bit mode %c", (int )*val);
#line 2431
  finis(0, 1, (int volatile   )64);
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 2438
  goto switch_break;
  case_65: /* CIL Label */ 
#line 2441
  if ((int )*(val + 0) == 0) {
    {
#line 2445
    al = (char *)"aliases";
#line 2446
    setalias(al);
    }
  } else {
    {
#line 2449
    setalias(val);
    }
  }
#line 2450
  goto switch_break;
  case_97: /* CIL Label */ 
#line 2453
  if ((int )*(val + 0) == 0) {
#line 2454
    SafeAlias = (time_t )300;
  } else {
    {
#line 2456
    SafeAlias = convtime(val, 'm');
    }
  }
#line 2457
  goto switch_break;
  case_66: /* CIL Label */ 
#line 2460
  SpaceSub = *(val + 0);
#line 2461
  if ((int )SpaceSub == 0) {
#line 2462
    SpaceSub = (char )' ';
  }
#line 2463
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 2466
  p = strchr((char const   *)val, '/');
  }
#line 2467
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 2469
    tmp___17 = p;
#line 2469
    p ++;
#line 2469
    *tmp___17 = (char )'\000';
#line 2470
    MaxMessageSize = atol((char const   *)p);
    }
  }
  {
#line 2472
  MinBlocksFree = atol((char const   *)val);
  }
#line 2473
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 2476
  NoConnect = atobool(val);
  }
#line 2477
  goto switch_break;
  case_67: /* CIL Label */ 
#line 2480
  if (safe) {
    {
#line 2481
    CheckpointInterval = atoi((char const   *)val);
    }
  } else {
    {
#line 2480
    tmp___18 = atoi((char const   *)val);
    }
#line 2480
    if (CheckpointInterval > tmp___18) {
      {
#line 2481
      CheckpointInterval = atoi((char const   *)val);
      }
    }
  }
#line 2482
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 2487
  if ((int )*val == 0) {
#line 2487
    goto case_0;
  }
#line 2494
  if ((int )*val == 98) {
#line 2494
    goto case_98___0;
  }
#line 2494
  if ((int )*val == 105) {
#line 2494
    goto case_98___0;
  }
#line 2494
  if ((int )*val == 100) {
#line 2494
    goto case_98___0;
  }
#line 2494
  if ((int )*val == 113) {
#line 2494
    goto case_98___0;
  }
#line 2502
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 2488
  set_delivery_mode('i', e);
  }
#line 2489
  goto switch_break___1;
  case_98___0: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_100___0: /* CIL Label */ 
  case_113: /* CIL Label */ 
  {
#line 2499
  set_delivery_mode((int )*val, e);
  }
#line 2500
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 2503
  syserr("Unknown delivery mode %c", (int )*val);
#line 2504
  finis(0, 1, (int volatile   )64);
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 2506
  goto switch_break;
  case_69: /* CIL Label */ 
#line 2509
  if ((int )*val != 0) {
    {
#line 2510
    ErrMsgFile = newstr((char const   *)val);
    }
  }
#line 2511
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 2520
  if ((int )*val == 112) {
#line 2520
    goto case_112___0;
  }
#line 2520
  if ((int )*val == 119) {
#line 2520
    goto case_112___0;
  }
#line 2520
  if ((int )*val == 101) {
#line 2520
    goto case_112___0;
  }
#line 2520
  if ((int )*val == 109) {
#line 2520
    goto case_112___0;
  }
#line 2520
  if ((int )*val == 113) {
#line 2520
    goto case_112___0;
  }
#line 2514
  goto switch_break___2;
  case_112___0: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_101___0: /* CIL Label */ 
  case_109___0: /* CIL Label */ 
  case_113___0: /* CIL Label */ 
#line 2521
  e->e_errormode = (short )*val;
#line 2522
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 2524
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 2527
  tmp___19 = atooct(val);
#line 2527
  FileMode = tmp___19 & 511;
  }
#line 2528
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 2531
  SaveFrom = atobool(val);
  }
#line 2532
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 2535
  MatchGecos = atobool(val);
  }
#line 2536
  goto switch_break;
  g_opt: 
  case_103: /* CIL Label */ 
#line 2540
  if (((int )*val & -128) == 0) {
    {
#line 2540
    tmp___21 = __ctype_b_loc();
    }
#line 2540
    if ((int const   )*(*tmp___21 + (int )*val) & 2048) {
      {
#line 2541
      tmp___20 = atoi((char const   *)val);
#line 2541
      DefGid = (gid_t )tmp___20;
      }
    } else {
#line 2540
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 2546
    DefGid = (gid_t )-1;
#line 2547
    gr = getgrnam((char const   *)val);
    }
#line 2548
    if ((unsigned long )gr == (unsigned long )((void *)0)) {
      {
#line 2549
      syserr("readcf: option %c: unknown group %s", opt, val);
      }
    } else {
#line 2552
      DefGid = gr->gr_gid;
    }
  }
#line 2554
  goto switch_break;
  case_72: /* CIL Label */ 
#line 2557
  if ((int )*(val + 0) == 0) {
#line 2559
    HelpFile = (char *)"helpfile";
  } else {
    {
#line 2564
    HelpFile = newstr((char const   *)val);
    }
  }
#line 2566
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 2569
  MaxHopCount = atoi((char const   *)val);
  }
#line 2570
  goto switch_break;
  case_73: /* CIL Label */ 
#line 2574
  p = val;
  {
#line 2574
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2574
    if (! ((int )*p != 0)) {
#line 2574
      goto while_break___4;
    }
    {
#line 2580
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2580
      if (! ((int )*p == 32)) {
#line 2580
        goto while_break___5;
      }
#line 2581
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2582
    if ((int )*p == 0) {
#line 2583
      goto while_break___4;
    }
#line 2584
    clearmode = 0;
#line 2585
    if ((int )*p == 45) {
#line 2586
      clearmode = 1;
    } else
#line 2587
    if ((int )*p != 43) {
#line 2588
      p --;
    }
#line 2589
    p ++;
#line 2590
    q = p;
    {
#line 2591
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2591
      if ((int )*p != 0) {
#line 2591
        if (((int )*p & -128) == 0) {
          {
#line 2591
          tmp___22 = __ctype_b_loc();
          }
#line 2591
          if ((int const   )*(*tmp___22 + (int )*p) & 8192) {
#line 2591
            goto while_break___6;
          }
        }
      } else {
#line 2591
        goto while_break___6;
      }
#line 2592
      p ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2593
    if ((int )*p != 0) {
#line 2594
      tmp___23 = p;
#line 2594
      p ++;
#line 2594
      *tmp___23 = (char )'\000';
    }
    {
#line 2595
    tmp___24 = sm_strcasecmp((char const   *)q, "HasWildcardMX");
    }
#line 2595
    if (tmp___24 == 0) {
#line 2597
      HasWildcardMX = ! clearmode;
#line 2598
      goto __Cont___0;
    }
    {
#line 2600
    tmp___25 = sm_strcasecmp((char const   *)q, "WorkAroundBrokenAAAA");
    }
#line 2600
    if (tmp___25 == 0) {
#line 2602
      WorkAroundBrokenAAAA = ! clearmode;
#line 2603
      goto __Cont___0;
    }
#line 2605
    rfp = ResolverFlags;
    {
#line 2605
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2605
      if (! ((unsigned long )rfp->rf_name != (unsigned long )((void *)0))) {
#line 2605
        goto while_break___7;
      }
      {
#line 2607
      tmp___26 = sm_strcasecmp((char const   *)q, (char const   *)rfp->rf_name);
      }
#line 2607
      if (tmp___26 == 0) {
#line 2608
        goto while_break___7;
      }
#line 2605
      rfp ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2610
    if ((unsigned long )rfp->rf_name == (unsigned long )((void *)0)) {
      {
#line 2611
      syserr("readcf: I option value %s unrecognized", q);
      }
    } else
#line 2612
    if (clearmode) {
      {
#line 2613
      tmp___27 = __res_state();
#line 2613
      tmp___27->options &= (unsigned long )(~ rfp->rf_bits);
      }
    } else {
      {
#line 2615
      tmp___28 = __res_state();
#line 2615
      tmp___28->options |= (unsigned long )rfp->rf_bits;
      }
    }
    __Cont___0: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2617
  if ((int )tTdvect[8] >= 2) {
    {
#line 2618
    tmp___29 = __res_state();
#line 2618
    sm_dprintf((char *)"_res.options = %x, HasWildcardMX = %d\n", (unsigned int )tmp___29->options,
               HasWildcardMX);
    }
  }
#line 2623
  goto switch_break;
  case_105___0: /* CIL Label */ 
  {
#line 2626
  IgnrDot = atobool(val);
  }
#line 2627
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 2630
  SendMIMEErrors = atobool(val);
  }
#line 2631
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 2635
  ForwardPath = newstr((char const   *)val);
  }
#line 2636
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 2639
  MaxMciCache = atoi((char const   *)val);
  }
#line 2640
  if (MaxMciCache < 0) {
#line 2641
    MaxMciCache = 0;
  }
#line 2642
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 2645
  MciCacheTimeout = convtime(val, 'm');
  }
#line 2646
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 2649
  UseErrorsTo = atobool(val);
  }
#line 2650
  goto switch_break;
  case_76: /* CIL Label */ 
#line 2653
  if (safe) {
    {
#line 2654
    LogLevel = atoi((char const   *)val);
    }
  } else {
    {
#line 2653
    tmp___30 = atoi((char const   *)val);
    }
#line 2653
    if (LogLevel < tmp___30) {
      {
#line 2654
      LogLevel = atoi((char const   *)val);
      }
    }
  }
#line 2655
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 2658
  sticky = 0;
#line 2659
  mid = macid_parse(val, & ep);
  }
#line 2660
  if (mid == 0) {
#line 2661
    goto switch_break;
  }
  {
#line 2662
  p = newstr((char const   *)ep);
  }
#line 2663
  if (! safe) {
    {
#line 2664
    tmp___31 = strlen((char const   *)p);
#line 2664
    cleanstrcpy(p, p, (int )(tmp___31 + 1U));
    }
  }
  {
#line 2665
  macdefine_tagged(& CurEnv->e_macro, (ARGCLASS_T )1, mid, p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                   2665, SmHeapGroup);
  }
#line 2666
  goto switch_break;
  case_109___1: /* CIL Label */ 
  {
#line 2669
  MeToo = atobool(val);
  }
#line 2670
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 2673
  CheckAliases = atobool(val);
  }
#line 2674
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 2679
  tmp___32 = setdaemonoptions(val);
  }
#line 2679
  if (! tmp___32) {
    {
#line 2680
    syserr("too many daemons defined (%d max)", 10);
    }
  }
#line 2681
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 2684
  tmp___33 = atobool(val);
  }
#line 2684
  if (tmp___33) {
#line 2685
    CurEnv->e_flags |= 1UL;
  } else {
#line 2687
    CurEnv->e_flags &= 0xfffffffffffffffeUL;
  }
#line 2688
  goto switch_break;
  case_112___1: /* CIL Label */ 
#line 2691
  p = val;
  {
#line 2692
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 2697
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2697
      if (((int )*p & -128) == 0) {
        {
#line 2697
        tmp___34 = __ctype_b_loc();
        }
#line 2697
        if (! ((int const   )*(*tmp___34 + (int )*p) & 8192)) {
          {
#line 2697
          tmp___35 = __ctype_b_loc();
          }
#line 2697
          if (! ((int const   )*(*tmp___35 + (int )*p) & 4)) {
#line 2697
            goto while_break___9;
          }
        }
      } else {
#line 2697
        goto while_break___9;
      }
#line 2698
      p ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2699
    if ((int )*p == 0) {
#line 2700
      goto while_break___8;
    }
#line 2701
    val = p;
    {
#line 2702
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 2702
      if (((int )*p & -128) == 0) {
        {
#line 2702
        tmp___36 = __ctype_b_loc();
        }
#line 2702
        if (! ((int const   )*(*tmp___36 + (int )*p) & 8)) {
#line 2702
          goto while_break___10;
        }
      } else {
#line 2702
        goto while_break___10;
      }
#line 2703
      p ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 2704
    if ((int )*p != 0) {
#line 2705
      tmp___37 = p;
#line 2705
      p ++;
#line 2705
      *tmp___37 = (char )'\000';
    }
#line 2707
    pv = PrivacyValues;
    {
#line 2707
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 2707
      if (! ((unsigned long )pv->pv_name != (unsigned long )((void *)0))) {
#line 2707
        goto while_break___11;
      }
      {
#line 2709
      tmp___38 = sm_strcasecmp((char const   *)val, (char const   *)pv->pv_name);
      }
#line 2709
      if (tmp___38 == 0) {
#line 2710
        goto while_break___11;
      }
#line 2707
      pv ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 2712
    if ((unsigned long )pv->pv_name == (unsigned long )((void *)0)) {
      {
#line 2713
      syserr("readcf: Op line: %s unrecognized", val);
      }
    } else {
#line 2715
      PrivacyFlags |= pv->pv_flag;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 2717
  sticky = 0;
#line 2718
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 2721
  PostMasterCopy = newstr((char const   *)val);
  }
#line 2722
  goto switch_break;
  case_113___1: /* CIL Label */ 
  {
#line 2725
  tmp___39 = atoi((char const   *)val);
#line 2725
  QueueFactor = (long )tmp___39;
  }
#line 2726
  goto switch_break;
  case_81: /* CIL Label */ 
#line 2729
  if ((int )*(val + 0) == 0) {
#line 2731
    QueueDir = (char *)"mqueue";
  } else {
    {
#line 2735
    QueueDir = newstr((char const   *)val);
    }
  }
#line 2737
  if (RealUid != 0U) {
#line 2737
    if (! safe) {
#line 2738
      Warn_Q_option = 1;
    }
  }
#line 2739
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 2742
  DontPruneRoutes = atobool(val);
  }
#line 2743
  goto switch_break;
  case_114: /* CIL Label */ 
#line 2746
  if ((unsigned long )subopt == (unsigned long )((void *)0)) {
    {
#line 2747
    inittimeouts(val, sticky);
    }
  } else {
    {
#line 2749
    settimeout(subopt, val, sticky);
    }
  }
#line 2750
  goto switch_break;
  case_83: /* CIL Label */ 
#line 2753
  if ((int )*(val + 0) == 0) {
#line 2755
    StatFile = (char *)"statistics";
  } else {
    {
#line 2760
    StatFile = newstr((char const   *)val);
    }
  }
#line 2762
  goto switch_break;
  case_115___0: /* CIL Label */ 
  {
#line 2765
  tmp___43 = tolower((int )*val);
  }
#line 2765
  if (tmp___43 == 105) {
#line 2766
    SuperSafe = 1;
  } else {
    {
#line 2767
    tmp___42 = tolower((int )*val);
    }
#line 2767
    if (tmp___42 == 112) {
#line 2769
      SuperSafe = 3;
    } else {
      {
#line 2775
      tmp___41 = atobool(val);
      }
#line 2775
      if (tmp___41) {
#line 2775
        SuperSafe = 2;
      } else {
#line 2775
        SuperSafe = 0;
      }
    }
  }
#line 2776
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 2779
  p = strchr((char const   *)val, '/');
  }
#line 2780
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 2782
    tmp___44 = p;
#line 2782
    p ++;
#line 2782
    *tmp___44 = (char )'\000';
#line 2783
    settimeout((char *)"queuewarn", p, sticky);
    }
  }
  {
#line 2785
  settimeout((char *)"queuereturn", val, sticky);
  }
#line 2786
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 2789
  TimeZoneSpec = newstr((char const   *)val);
  }
#line 2790
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 2793
  UdbSpec = newstr((char const   *)val);
  }
#line 2794
  goto switch_break;
  case_117: /* CIL Label */ 
#line 2797
  p = val;
  {
#line 2797
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2797
    if (! ((int )*p != 0)) {
#line 2797
      goto while_break___12;
    }
#line 2802
    if ((int )*p == 46) {
#line 2805
      tmp___45 = p;
#line 2805
      p ++;
#line 2805
      *tmp___45 = (char )'\000';
#line 2806
      goto while_break___12;
    } else
#line 2802
    if ((int )*p == 47) {
#line 2805
      tmp___45 = p;
#line 2805
      p ++;
#line 2805
      *tmp___45 = (char )'\000';
#line 2806
      goto while_break___12;
    } else
#line 2802
    if ((int )*p == 58) {
#line 2805
      tmp___45 = p;
#line 2805
      p ++;
#line 2805
      *tmp___45 = (char )'\000';
#line 2806
      goto while_break___12;
    }
#line 2797
    p ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 2809
  if (((int )*val & -128) == 0) {
    {
#line 2809
    tmp___47 = __ctype_b_loc();
    }
#line 2809
    if ((int const   )*(*tmp___47 + (int )*val) & 2048) {
      {
#line 2811
      tmp___46 = atoi((char const   *)val);
#line 2811
      DefUid = (uid_t )tmp___46;
#line 2812
      setdefuser();
      }
    } else {
#line 2809
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 2818
    DefUid = (uid_t )-1;
#line 2819
    pw = sm_getpwnam(val);
    }
#line 2820
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
#line 2822
      syserr("readcf: option u: unknown user %s", val);
      }
#line 2823
      goto switch_break;
    } else {
      {
#line 2827
      DefUid = pw->pw_uid;
#line 2828
      DefGid = pw->pw_gid;
#line 2829
      DefUser = newstr((char const   *)pw->pw_name);
      }
    }
  }
#line 2843
  if ((int )*p == 0) {
#line 2844
    goto switch_break;
  }
#line 2845
  val = p;
#line 2846
  goto g_opt;
  case_86: /* CIL Label */ 
#line 2849
  if ((int )*(val + 0) != 0) {
    {
#line 2850
    FallbackMX = newstr((char const   *)val);
    }
  }
#line 2851
  goto switch_break;
  case_118: /* CIL Label */ 
  {
#line 2854
  tmp___49 = atobool(val);
  }
#line 2854
  if (tmp___49) {
#line 2854
    Verbose = 1;
  } else {
#line 2854
    Verbose = 0;
  }
#line 2855
  goto switch_break;
  case_119___0: /* CIL Label */ 
  {
#line 2858
  TryNullMXList = atobool(val);
  }
#line 2859
  goto switch_break;
  case_120: /* CIL Label */ 
  {
#line 2864
  QueueLA = atoi((char const   *)val);
  }
#line 2865
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 2868
  RefuseLA = atoi((char const   *)val);
  }
#line 2869
  goto switch_break;
  case_205: /* CIL Label */ 
  {
#line 2872
  DelayLA = atoi((char const   *)val);
  }
#line 2873
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 2876
  tmp___50 = atoi((char const   *)val);
#line 2876
  WkRecipFact = (long )tmp___50;
  }
#line 2877
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 2880
  ForkQueueRuns = atobool(val);
  }
#line 2881
  goto switch_break;
  case_122: /* CIL Label */ 
  {
#line 2884
  tmp___51 = atoi((char const   *)val);
#line 2884
  WkClassFact = (long )tmp___51;
  }
#line 2885
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 2888
  tmp___52 = atoi((char const   *)val);
#line 2888
  WkTimeFact = (long )tmp___52;
  }
#line 2889
  goto switch_break;
  case_129: /* CIL Label */ 
  {
#line 2899
  if ((int )*val == 70) {
#line 2899
    goto case_70___0;
  }
#line 2899
  if ((int )*val == 102) {
#line 2899
    goto case_70___0;
  }
#line 2904
  if ((int )*val == 72) {
#line 2904
    goto case_72___0;
  }
#line 2904
  if ((int )*val == 104) {
#line 2904
    goto case_72___0;
  }
#line 2909
  if ((int )*val == 77) {
#line 2909
    goto case_77___0;
  }
#line 2909
  if ((int )*val == 109) {
#line 2909
    goto case_77___0;
  }
#line 2914
  if ((int )*val == 80) {
#line 2914
    goto case_80___0;
  }
#line 2914
  if ((int )*val == 112) {
#line 2914
    goto case_80___0;
  }
#line 2919
  if ((int )*val == 84) {
#line 2919
    goto case_84___0;
  }
#line 2919
  if ((int )*val == 116) {
#line 2919
    goto case_84___0;
  }
#line 2924
  if ((int )*val == 82) {
#line 2924
    goto case_82___0;
  }
#line 2924
  if ((int )*val == 114) {
#line 2924
    goto case_82___0;
  }
#line 2936
  if ((int )*val == 78) {
#line 2936
    goto case_78;
  }
#line 2936
  if ((int )*val == 110) {
#line 2936
    goto case_78;
  }
#line 2940
  goto switch_default___1;
  case_70___0: /* CIL Label */ 
  case_102___0: /* CIL Label */ 
#line 2900
  QueueSortOrder = 3;
#line 2901
  goto switch_break___3;
  case_72___0: /* CIL Label */ 
  case_104___0: /* CIL Label */ 
#line 2905
  QueueSortOrder = 1;
#line 2906
  goto switch_break___3;
  case_77___0: /* CIL Label */ 
  case_109___2: /* CIL Label */ 
#line 2910
  QueueSortOrder = 5;
#line 2911
  goto switch_break___3;
  case_80___0: /* CIL Label */ 
  case_112___2: /* CIL Label */ 
#line 2915
  QueueSortOrder = 0;
#line 2916
  goto switch_break___3;
  case_84___0: /* CIL Label */ 
  case_116___0: /* CIL Label */ 
#line 2920
  QueueSortOrder = 2;
#line 2921
  goto switch_break___3;
  case_82___0: /* CIL Label */ 
  case_114___0: /* CIL Label */ 
#line 2925
  QueueSortOrder = 4;
#line 2926
  goto switch_break___3;
  case_78: /* CIL Label */ 
  case_110___0: /* CIL Label */ 
#line 2937
  QueueSortOrder = 6;
#line 2938
  goto switch_break___3;
  switch_default___1: /* CIL Label */ 
  {
#line 2941
  syserr("Invalid queue sort order \"%s\"", val);
  }
  switch_break___3: /* CIL Label */ ;
  }
#line 2943
  goto switch_break;
  case_130: /* CIL Label */ 
  {
#line 2947
  HostsFile = newstr((char const   *)val);
  }
#line 2948
  goto switch_break;
  case_131: /* CIL Label */ 
  {
#line 2951
  MinQueueAge = convtime(val, 'm');
  }
#line 2952
  goto switch_break;
  case_133: /* CIL Label */ 
  {
#line 2955
  tmp___53 = denlstring(val, 1, 1);
#line 2955
  DefaultCharSet = newstr((char const   *)tmp___53);
  }
#line 2956
  goto switch_break;
  case_134: /* CIL Label */ 
  {
#line 2960
  ServiceSwitchFile = newstr((char const   *)val);
  }
#line 2961
  goto switch_break;
  case_135: /* CIL Label */ 
  {
#line 2964
  DialDelay = convtime(val, 's');
  }
#line 2965
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 2968
  tmp___58 = sm_strcasecmp((char const   *)val, "none");
  }
#line 2968
  if (tmp___58 == 0) {
#line 2969
    NoRecipientAction = 0;
  } else {
    {
#line 2970
    tmp___57 = sm_strcasecmp((char const   *)val, "add-to");
    }
#line 2970
    if (tmp___57 == 0) {
#line 2971
      NoRecipientAction = 1;
    } else {
      {
#line 2972
      tmp___56 = sm_strcasecmp((char const   *)val, "add-apparently-to");
      }
#line 2972
      if (tmp___56 == 0) {
#line 2973
        NoRecipientAction = 2;
      } else {
        {
#line 2974
        tmp___55 = sm_strcasecmp((char const   *)val, "add-bcc");
        }
#line 2974
        if (tmp___55 == 0) {
#line 2975
          NoRecipientAction = 3;
        } else {
          {
#line 2976
          tmp___54 = sm_strcasecmp((char const   *)val, "add-to-undisclosed");
          }
#line 2976
          if (tmp___54 == 0) {
#line 2977
            NoRecipientAction = 4;
          } else {
            {
#line 2979
            syserr("Invalid NoRecipientAction: %s", val);
            }
          }
        }
      }
    }
  }
#line 2980
  goto switch_break;
  case_137: /* CIL Label */ 
#line 2983
  if ((int )*val == 0) {
#line 2984
    goto switch_break;
  }
  {
#line 2987
  tmp___59 = strlen((char const   *)val);
#line 2987
  p = (val + tmp___59) - 1;
  }
  {
#line 2988
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 2988
    if ((unsigned long )p >= (unsigned long )val) {
#line 2988
      if (! ((int )*p == 47)) {
#line 2988
        goto while_break___13;
      }
    } else {
#line 2988
      goto while_break___13;
    }
#line 2989
    tmp___60 = p;
#line 2989
    p --;
#line 2989
    *tmp___60 = (char )'\000';
  }
  while_break___13: /* CIL Label */ ;
  }
#line 2991
  if ((int )*val == 0) {
#line 2992
    goto switch_break;
  }
  {
#line 2994
  SafeFileEnv = newstr((char const   *)val);
  }
#line 2995
  goto switch_break;
  case_138: /* CIL Label */ 
  {
#line 2998
  MaxMessageSize = atol((char const   *)val);
  }
#line 2999
  goto switch_break;
  case_139: /* CIL Label */ 
  {
#line 3002
  ColonOkInAddr = atobool(val);
  }
#line 3003
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 3006
  MaxQueueRun = atoi((char const   *)val);
  }
#line 3007
  goto switch_break;
  case_141: /* CIL Label */ 
  {
#line 3010
  MaxChildren = atoi((char const   *)val);
  }
#line 3011
  goto switch_break;
  case_197: /* CIL Label */ 
  {
#line 3014
  MaxQueueChildren = atoi((char const   *)val);
  }
#line 3015
  goto switch_break;
  case_198: /* CIL Label */ 
  {
#line 3018
  MaxRunnersPerQueue = atoi((char const   *)val);
  }
#line 3019
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 3028
  NiceQueueRun = atoi((char const   *)val);
  }
#line 3029
  goto switch_break;
  case_201: /* CIL Label */ 
  {
#line 3033
  tmp___61 = atol((char const   *)val);
#line 3033
  ShmKey = (key_t )tmp___61;
  }
#line 3039
  goto switch_break;
  case_142: /* CIL Label */ 
  {
#line 3060
  DontExpandCnames = atobool(val);
  }
#line 3061
  goto switch_break;
  case_143: /* CIL Label */ 
  {
#line 3064
  sm_strlcpy(buf___16, "@,;:\\()[]", (ssize_t )sizeof(buf___16));
#line 3065
  tmp___62 = strlen((char const   *)val);
  }
#line 3065
  if ((unsigned long )tmp___62 < sizeof(buf___16) - 10UL) {
    {
#line 3066
    sm_strlcat(buf___16, (char const   *)val, (ssize_t )sizeof(buf___16));
    }
  } else {
    {
#line 3068
    sm_io_fprintf(& SmIoF[1], -2, "Warning: MustQuoteChars too long, ignored.\n");
    }
  }
  {
#line 3070
  MustQuoteChars = newstr((char const   *)(buf___16));
  }
#line 3071
  goto switch_break;
  case_144: /* CIL Label */ 
  {
#line 3074
  tmp___63 = munchstring(val, (char **)((void *)0), '\000');
#line 3074
  SmtpGreeting = newstr((char const   *)tmp___63);
  }
#line 3075
  goto switch_break;
  case_145: /* CIL Label */ 
  {
#line 3078
  tmp___64 = munchstring(val, (char **)((void *)0), '\000');
#line 3078
  UnixFromLine = newstr((char const   *)tmp___64);
  }
#line 3079
  goto switch_break;
  case_146: /* CIL Label */ 
#line 3082
  if ((unsigned long )OperatorChars != (unsigned long )((void *)0)) {
    {
#line 3083
    sm_io_fprintf(& SmIoF[1], -2, "Warning: OperatorChars is being redefined.\n         It should only be set before ruleset definitions.\n");
    }
  }
  {
#line 3085
  tmp___65 = munchstring(val, (char **)((void *)0), '\000');
#line 3085
  OperatorChars = newstr((char const   *)tmp___65);
  }
#line 3086
  goto switch_break;
  case_147: /* CIL Label */ 
  {
#line 3089
  DontInitGroups = atobool(val);
  }
#line 3090
  goto switch_break;
  case_148: /* CIL Label */ 
  {
#line 3093
  SingleLineFromHeader = atobool(val);
  }
#line 3094
  goto switch_break;
  case_149: /* CIL Label */ 
  {
#line 3097
  AllowBogusHELO = atobool(val);
  }
#line 3098
  goto switch_break;
  case_151: /* CIL Label */ 
  {
#line 3101
  ConnRateThrottle = atoi((char const   *)val);
  }
#line 3102
  goto switch_break;
  case_153: /* CIL Label */ 
  {
#line 3105
  tmp___66 = atobool(val);
  }
#line 3105
  if (! tmp___66) {
#line 3107
    DontBlameSendmail[3UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 3UL % (8UL * sizeof(int ));
#line 3109
    DontBlameSendmail[4UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 4UL % (8UL * sizeof(int ));
  }
#line 3112
  goto switch_break;
  case_154: /* CIL Label */ 
  {
#line 3115
  DoubleBounceAddr = newstr((char const   *)val);
  }
#line 3116
  goto switch_break;
  case_155: /* CIL Label */ 
#line 3119
  if ((int )*(val + 0) != 0) {
    {
#line 3122
    HostStatDir = newstr((char const   *)val);
    }
  }
#line 3124
  goto switch_break;
  case_156: /* CIL Label */ 
  {
#line 3127
  SingleThreadDelivery = atobool(val);
  }
#line 3128
  goto switch_break;
  case_157: /* CIL Label */ 
#line 3131
  p = val;
  {
#line 3131
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 3131
    if (! ((int )*p != 0)) {
#line 3131
      goto while_break___14;
    }
#line 3136
    if ((int )*p == 46) {
#line 3139
      tmp___67 = p;
#line 3139
      p ++;
#line 3139
      *tmp___67 = (char )'\000';
#line 3140
      goto while_break___14;
    } else
#line 3136
    if ((int )*p == 47) {
#line 3139
      tmp___67 = p;
#line 3139
      p ++;
#line 3139
      *tmp___67 = (char )'\000';
#line 3140
      goto while_break___14;
    } else
#line 3136
    if ((int )*p == 58) {
#line 3139
      tmp___67 = p;
#line 3139
      p ++;
#line 3139
      *tmp___67 = (char )'\000';
#line 3140
      goto while_break___14;
    }
#line 3131
    p ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 3143
  if (((int )*val & -128) == 0) {
    {
#line 3143
    tmp___69 = __ctype_b_loc();
    }
#line 3143
    if ((int const   )*(*tmp___69 + (int )*val) & 2048) {
#line 3145
      if (can_setuid) {
        {
#line 3146
        tmp___68 = atoi((char const   *)val);
#line 3146
        RunAsUid = (uid_t )tmp___68;
        }
      }
    } else {
#line 3143
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 3152
    pw___0 = sm_getpwnam(val);
    }
#line 3153
    if ((unsigned long )pw___0 == (unsigned long )((void *)0)) {
      {
#line 3155
      syserr("readcf: option RunAsUser: unknown user %s", val);
      }
#line 3156
      goto switch_break;
    } else
#line 3158
    if (can_setuid) {
#line 3160
      if ((int )*p == 0) {
        {
#line 3161
        RunAsUserName = newstr((char const   *)val);
        }
      }
#line 3162
      RunAsUid = pw___0->pw_uid;
#line 3163
      RunAsGid = pw___0->pw_gid;
    } else
#line 3165
    if (EffGid == pw___0->pw_gid) {
#line 3166
      RunAsGid = pw___0->pw_gid;
    } else
#line 3167
    if (UseMSP) {
#line 3167
      if ((int )*p == 0) {
        {
#line 3168
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: RunAsUser for MSP ignored, check group ids (egid=%d, want=%d)\n",
                      (int )EffGid, (int )pw___0->pw_gid);
        }
      }
    }
  }
#line 3181
  if ((int )*p != 0) {
#line 3183
    if (((int )*p & -128) == 0) {
      {
#line 3183
      tmp___71 = __ctype_b_loc();
      }
#line 3183
      if ((int const   )*(*tmp___71 + (int )*p) & 2048) {
        {
#line 3187
        tmp___70 = atoi((char const   *)p);
#line 3187
        runasgid = (gid_t )tmp___70;
        }
#line 3188
        if (can_setuid) {
#line 3189
          RunAsGid = runasgid;
        } else
#line 3188
        if (EffGid == runasgid) {
#line 3189
          RunAsGid = runasgid;
        } else
#line 3190
        if (UseMSP) {
          {
#line 3191
          sm_io_fprintf(& SmIoF[1], -2, "WARNING: RunAsUser for MSP ignored, check group ids (egid=%d, want=%d)\n",
                        (int )EffGid, (int )runasgid);
          }
        }
      } else {
#line 3183
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
      {
#line 3201
      gr___0 = getgrnam((char const   *)p);
      }
#line 3202
      if ((unsigned long )gr___0 == (unsigned long )((void *)0)) {
        {
#line 3203
        syserr("readcf: option RunAsUser: unknown group %s", p);
        }
      } else
#line 3205
      if (can_setuid) {
#line 3206
        RunAsGid = gr___0->gr_gid;
      } else
#line 3205
      if (EffGid == gr___0->gr_gid) {
#line 3206
        RunAsGid = gr___0->gr_gid;
      } else
#line 3207
      if (UseMSP) {
        {
#line 3208
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: RunAsUser for MSP ignored, check group ids (egid=%d, want=%d)\n",
                      (int )EffGid, (int )gr___0->gr_gid);
        }
      }
    }
  }
#line 3215
  if ((int )tTdvect[47] >= 5) {
    {
#line 3216
    sm_dprintf((char *)"readcf: RunAsUser = %d:%d\n", (int )RunAsUid, (int )RunAsGid);
    }
  }
#line 3218
  goto switch_break;
  case_158: /* CIL Label */ 
  {
#line 3221
  RrtImpliesDsn = atobool(val);
  }
#line 3222
  goto switch_break;
  case_159: /* CIL Label */ 
  {
#line 3225
  while (1) {
    while_continue___15: /* CIL Label */ ;
    {
#line 3225
    tmp___72 = sm_pstrdup_x((char const   *)val);
#line 3225
    _newval = tmp___72;
    }
#line 3225
    if ((unsigned long )PidFile != (unsigned long )((void *)0)) {
      {
#line 3225
      sm_free_tagged((void *)PidFile, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                     3225);
      }
    }
#line 3225
    PidFile = _newval;
#line 3225
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 3226
  goto switch_break;
  case_160: /* CIL Label */ 
#line 3229
  p = val;
  {
#line 3230
  while (1) {
    while_continue___16: /* CIL Label */ ;
    {
#line 3235
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 3235
      if (((int )*p & -128) == 0) {
        {
#line 3235
        tmp___73 = __ctype_b_loc();
        }
#line 3235
        if (! ((int const   )*(*tmp___73 + (int )*p) & 8192)) {
          {
#line 3235
          tmp___74 = __ctype_b_loc();
          }
#line 3235
          if (! ((int const   )*(*tmp___74 + (int )*p) & 4)) {
#line 3235
            goto while_break___17;
          }
        }
      } else {
#line 3235
        goto while_break___17;
      }
#line 3236
      p ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 3237
    if ((int )*p == 0) {
#line 3238
      goto while_break___16;
    }
#line 3239
    val = p;
    {
#line 3240
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 3240
      if (((int )*p & -128) == 0) {
        {
#line 3240
        tmp___75 = __ctype_b_loc();
        }
#line 3240
        if (! ((int const   )*(*tmp___75 + (int )*p) & 8)) {
#line 3240
          goto while_break___18;
        }
      } else {
#line 3240
        goto while_break___18;
      }
#line 3241
      p ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 3242
    if ((int )*p != 0) {
#line 3243
      tmp___76 = p;
#line 3243
      p ++;
#line 3243
      *tmp___76 = (char )'\000';
    }
#line 3245
    dbs = DontBlameSendmailValues;
    {
#line 3245
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 3245
      if (! ((unsigned long )dbs->dbs_name != (unsigned long )((void *)0))) {
#line 3245
        goto while_break___19;
      }
      {
#line 3248
      tmp___77 = sm_strcasecmp((char const   *)val, (char const   *)dbs->dbs_name);
      }
#line 3248
      if (tmp___77 == 0) {
#line 3249
        goto while_break___19;
      }
#line 3245
      dbs ++;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 3251
    if ((unsigned long )dbs->dbs_name == (unsigned long )((void *)0)) {
      {
#line 3252
      syserr("readcf: DontBlameSendmail option: %s unrecognized", val);
      }
    } else
#line 3253
    if ((int )dbs->dbs_flag == 0) {
      {
#line 3254
      memset((void *)((char *)(DontBlameSendmail)), '\000', (size_t )32);
      }
    } else {
#line 3256
      DontBlameSendmail[(unsigned long )dbs->dbs_flag / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )dbs->dbs_flag % (8UL * sizeof(int ));
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 3258
  sticky = 0;
#line 3259
  goto switch_break;
  case_161: /* CIL Label */ 
  {
#line 3262
  tmp___79 = sm_strcasecmp((char const   *)val, "loopback");
  }
#line 3262
  if (tmp___79 == 0) {
#line 3263
    DontProbeInterfaces = 2;
  } else {
    {
#line 3264
    tmp___78 = atobool(val);
    }
#line 3264
    if (tmp___78) {
#line 3265
      DontProbeInterfaces = 0;
    } else {
#line 3267
      DontProbeInterfaces = 1;
    }
  }
#line 3268
  goto switch_break;
  case_162: /* CIL Label */ 
  {
#line 3271
  MaxRcptPerMsg = atoi((char const   *)val);
  }
#line 3272
  goto switch_break;
  case_195: /* CIL Label */ 
  {
#line 3275
  BadRcptThrottle = atoi((char const   *)val);
  }
#line 3276
  goto switch_break;
  case_163: /* CIL Label */ ;
  {
#line 3280
  while (1) {
    while_continue___20: /* CIL Label */ ;
    {
#line 3280
    tmp___80 = sm_pstrdup_x((char const   *)val);
#line 3280
    _newval___0 = tmp___80;
    }
#line 3280
    if ((unsigned long )DeadLetterDrop != (unsigned long )((void *)0)) {
      {
#line 3280
      sm_free_tagged((void *)DeadLetterDrop, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                     3280);
      }
    }
#line 3280
    DeadLetterDrop = _newval___0;
#line 3280
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 3281
  goto switch_break;
  case_165: /* CIL Label */ 
  {
#line 3290
  MaxAliasRecursion = atoi((char const   *)val);
  }
#line 3291
  goto switch_break;
  case_166: /* CIL Label */ 
  {
#line 3296
  ConnectOnlyTo.sa.sa_family = (sa_family_t )0;
#line 3305
  ConnectOnlyTo.sin.sin_addr.s_addr = inet_addr((char const   *)val);
  }
#line 3306
  if (ConnectOnlyTo.sin.sin_addr.s_addr != 4294967295U) {
#line 3307
    ConnectOnlyTo.sa.sa_family = (sa_family_t )2;
  }
#line 3311
  if ((int )ConnectOnlyTo.sa.sa_family == 0) {
    {
#line 3313
    syserr("readcf: option ConnectOnlyTo: invalid IP address %s", val);
    }
#line 3315
    goto switch_break;
  }
#line 3318
  goto switch_break;
  case_167: /* CIL Label */ 
#line 3326
  if (((int )*val & -128) == 0) {
    {
#line 3326
    tmp___82 = __ctype_b_loc();
    }
#line 3326
    if ((int const   )*(*tmp___82 + (int )*val) & 2048) {
      {
#line 3327
      tmp___81 = atoi((char const   *)val);
#line 3327
      TrustedUid = (uid_t )tmp___81;
      }
    } else {
#line 3326
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
    {
#line 3332
    TrustedUid = (uid_t )0;
#line 3333
    pw___1 = sm_getpwnam(val);
    }
#line 3334
    if ((unsigned long )pw___1 == (unsigned long )((void *)0)) {
      {
#line 3336
      syserr("readcf: option TrustedUser: unknown user %s", val);
      }
#line 3337
      goto switch_break;
    } else {
#line 3340
      TrustedUid = pw___1->pw_uid;
    }
  }
#line 3351
  goto switch_break;
  case_168: /* CIL Label */ 
  {
#line 3354
  p = strchr((char const   *)val, '/');
  }
#line 3355
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 3356
    tmp___83 = p;
#line 3356
    p ++;
#line 3356
    *tmp___83 = (char )'\000';
  }
  {
#line 3357
  MaxMimeHeaderLength = atoi((char const   *)val);
  }
#line 3358
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 3358
    if ((int )*p != 0) {
      {
#line 3359
      MaxMimeFieldLength = atoi((char const   *)p);
      }
    } else {
#line 3361
      MaxMimeFieldLength = MaxMimeHeaderLength / 2;
    }
  } else {
#line 3361
    MaxMimeFieldLength = MaxMimeHeaderLength / 2;
  }
#line 3363
  if (MaxMimeHeaderLength <= 0) {
#line 3364
    MaxMimeHeaderLength = 0;
  } else
#line 3365
  if (MaxMimeHeaderLength < 128) {
    {
#line 3366
    sm_io_fprintf(& SmIoF[1], -2, "Warning: MaxMimeHeaderLength: header length limit set lower than 128\n");
    }
  }
#line 3369
  if (MaxMimeFieldLength <= 0) {
#line 3370
    MaxMimeFieldLength = 0;
  } else
#line 3371
  if (MaxMimeFieldLength < 40) {
    {
#line 3372
    sm_io_fprintf(& SmIoF[1], -2, "Warning: MaxMimeHeaderLength: field length limit set lower than 40\n");
    }
  }
#line 3374
  goto switch_break;
  case_169: /* CIL Label */ 
  {
#line 3377
  while (1) {
    while_continue___21: /* CIL Label */ ;
    {
#line 3377
    tmp___84 = sm_pstrdup_x((char const   *)val);
#line 3377
    _newval___1 = tmp___84;
    }
#line 3377
    if ((unsigned long )ControlSocketName != (unsigned long )((void *)0)) {
      {
#line 3377
      sm_free_tagged((void *)ControlSocketName, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                     3377);
      }
    }
#line 3377
    ControlSocketName = _newval___1;
#line 3377
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 3378
  goto switch_break;
  case_170: /* CIL Label */ 
  {
#line 3381
  MaxHeadersLength = atoi((char const   *)val);
  }
#line 3383
  if (MaxHeadersLength > 0) {
#line 3383
    if (MaxHeadersLength < 16384) {
      {
#line 3385
      sm_io_fprintf(& SmIoF[1], -2, "Warning: MaxHeadersLength: headers length limit set lower than %d\n",
                    16384);
      }
    }
  }
#line 3388
  goto switch_break;
  case_172: /* CIL Label */ 
  {
#line 3391
  while (1) {
    while_continue___22: /* CIL Label */ ;
    {
#line 3391
    tmp___85 = sm_pstrdup_x((char const   *)val);
#line 3391
    _newval___2 = tmp___85;
    }
#line 3391
    if ((unsigned long )ProcTitlePrefix != (unsigned long )((void *)0)) {
      {
#line 3391
      sm_free_tagged((void *)ProcTitlePrefix, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                     3391);
      }
    }
#line 3391
    ProcTitlePrefix = _newval___2;
#line 3391
    goto while_break___22;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 3392
  goto switch_break;
  case_202: /* CIL Label */ 
  case_189: /* CIL Label */ 
  case_214: /* CIL Label */ 
  case_174: /* CIL Label */ 
  case_173: /* CIL Label */ 
#line 3503
  if ((unsigned long )o->o_name == (unsigned long )((void *)0)) {
#line 3503
    tmp___86 = "<unknown>";
  } else {
#line 3503
    tmp___86 = (char const   *)o->o_name;
  }
  {
#line 3503
  sm_io_fprintf(& SmIoF[1], -2, "Warning: Option: %s requires SASL support (-DSASL)\n",
                tmp___86);
  }
#line 3506
  goto switch_break;
  case_193: /* CIL Label */ 
  case_212: /* CIL Label */ 
  case_186: /* CIL Label */ 
  case_185: /* CIL Label */ 
  case_184: /* CIL Label */ 
  case_183: /* CIL Label */ 
  case_182: /* CIL Label */ 
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
#line 3624
  if ((unsigned long )o->o_name == (unsigned long )((void *)0)) {
#line 3624
    tmp___87 = "<unknown>";
  } else {
#line 3624
    tmp___87 = (char const   *)o->o_name;
  }
  {
#line 3624
  sm_io_fprintf(& SmIoF[1], -2, "Warning: Option: %s requires TLS support\n", tmp___87);
  }
#line 3627
  goto switch_break;
  case_175: /* CIL Label */ 
  {
#line 3632
  setclientoptions(val);
  }
#line 3633
  goto switch_break;
  case_176: /* CIL Label */ 
  {
#line 3636
  tmp___88 = atoi((char const   *)val);
#line 3636
  DataFileBufferSize = (size_t )tmp___88;
  }
#line 3637
  goto switch_break;
  case_177: /* CIL Label */ 
  {
#line 3640
  tmp___89 = atoi((char const   *)val);
#line 3640
  XscriptFileBufferSize = (size_t )tmp___89;
  }
#line 3641
  goto switch_break;
  case_178: /* CIL Label */ 
#line 3647
  if ((unsigned long )o->o_name == (unsigned long )((void *)0)) {
#line 3647
    tmp___90 = "<unknown>";
  } else {
#line 3647
    tmp___90 = (char const   *)o->o_name;
  }
  {
#line 3647
  sm_io_fprintf(& SmIoF[1], -2, "Warning: Option: %s requires LDAP support (-DLDAPMAP)\n",
                tmp___90);
  }
#line 3651
  goto switch_break;
  case_187: /* CIL Label */ 
  {
#line 3655
  InputFilterList = newstr((char const   *)val);
  }
#line 3661
  goto switch_break;
  case_188: /* CIL Label */ 
  {
#line 3665
  milter_set_option(subopt, val, sticky);
  }
#line 3671
  goto switch_break;
  case_190: /* CIL Label */ 
  {
#line 3674
  tmp___91 = atooct(val);
#line 3674
  QueueFileMode = tmp___91 & 511;
  }
#line 3675
  goto switch_break;
  case_196: /* CIL Label */ 
  {
#line 3678
  DeliverByMin = convtime(val, 's');
  }
#line 3679
  goto switch_break;
  case_199: /* CIL Label */ 
  {
#line 3687
  tmp___92 = getmodifiers(val, (unsigned int *)(m));
#line 3687
  tmp___93 = macid_parse((char *)"{daemon_flags}", (char **)((void *)0));
#line 3687
  macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___93, tmp___92, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                   3689, SmHeapGroup);
  }
#line 3691
  goto switch_break;
  case_206: /* CIL Label */ 
  {
#line 3694
  FastSplit = atoi((char const   *)val);
  }
#line 3695
  goto switch_break;
  case_203: /* CIL Label */ 
  {
#line 3698
  Mbdb = newstr((char const   *)val);
  }
#line 3699
  goto switch_break;
  case_204: /* CIL Label */ 
  {
#line 3702
  UseMSP = atobool(val);
  }
#line 3703
  goto switch_break;
  case_209: /* CIL Label */ 
  {
#line 3712
  RejectLogInterval = convtime(val, 'h');
  }
#line 3713
  goto switch_break;
  case_210: /* CIL Label */ 
  {
#line 3717
  RequiresDirfsync = atobool(val);
  }
#line 3721
  goto switch_break;
  case_211: /* CIL Label */ 
  {
#line 3724
  tmp___94 = convtime(val, 's');
#line 3724
  ConnectionRateWindowSize = (int )tmp___94;
  }
#line 3725
  goto switch_break;
  case_213: /* CIL Label */ 
#line 3728
  if ((int )*(val + 0) != 0) {
    {
#line 3729
    FallbackSmartHost = newstr((char const   *)val);
    }
  }
#line 3730
  goto switch_break;
  switch_default___2: /* CIL Label */ 
#line 3768
  if ((int )tTdvect[37] >= 1) {
#line 3770
    if ((opt & -128) == 0) {
      {
#line 3770
      tmp___95 = __ctype_b_loc();
      }
#line 3770
      if ((int const   )*(*tmp___95 + opt) & 16384) {
        {
#line 3771
        sm_dprintf((char *)"Warning: option %c unknown\n", opt);
        }
      } else {
        {
#line 3773
        sm_dprintf((char *)"Warning: option 0x%x unknown\n", opt);
        }
      }
    } else {
      {
#line 3773
      sm_dprintf((char *)"Warning: option 0x%x unknown\n", opt);
      }
    }
  }
#line 3775
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3786
  if (sticky) {
#line 3786
    if (! (((int )o->o_flags & 2) != 0)) {
#line 3787
      StickyOpt[(unsigned long )((unsigned char )opt) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )opt) % (8UL * sizeof(int ));
    }
  }
#line 3788
  return;
}
}
#line 3803 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
void setclass(int class , char *str ) 
{ 
  register STAB *s ;
  int mid ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 3810
  if (((int )*str & 255) == 147) {
    {
#line 3814
    str ++;
#line 3815
    mid = macid_parse(str, (char **)((void *)0));
    }
#line 3816
    if (mid == 0) {
#line 3817
      return;
    }
#line 3819
    if ((int )tTdvect[37] >= 8) {
      {
#line 3820
      tmp = macname(mid);
#line 3820
      tmp___0 = macname(class);
#line 3820
      sm_dprintf((char *)"setclass(%s, $=%s)\n", tmp___0, tmp);
      }
    }
    {
#line 3822
    copy_class(mid, class);
    }
  } else {
#line 3826
    if ((int )tTdvect[37] >= 8) {
      {
#line 3827
      tmp___1 = macname(class);
#line 3827
      sm_dprintf((char *)"setclass(%s, %s)\n", tmp___1, str);
      }
    }
    {
#line 3829
    s = stab(str, 1, 1);
#line 3830
    s->s_value.sv_class[(unsigned long )((unsigned char )((unsigned int )class & 255U)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )((unsigned int )class & 255U)) % (8UL * sizeof(int ));
    }
  }
#line 3832
  return;
}
}
#line 3847 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
struct _map *makemapentry(char *line ) 
{ 
  register char *p ;
  char *mapname ;
  char *classname ;
  register STAB *s ;
  STAB *class ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  bool tmp___8 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 3857
  p = line;
  {
#line 3857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3857
    if (((int )*p & -128) == 0) {
      {
#line 3857
      tmp = __ctype_b_loc();
      }
#line 3857
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 3857
        goto while_break;
      }
    } else {
#line 3857
      goto while_break;
    }
#line 3858
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 3857
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3859
  if (((int )*p & -128) == 0) {
    {
#line 3859
    tmp___0 = __ctype_b_loc();
    }
#line 3859
    if (! ((int const   )*(*tmp___0 + (int )*p) & 8)) {
      {
#line 3861
      syserr("readcf: config K line: no map name");
      }
#line 3862
      return ((struct _map *)((void *)0));
    }
  } else {
    {
#line 3861
    syserr("readcf: config K line: no map name");
    }
#line 3862
    return ((struct _map *)((void *)0));
  }
#line 3865
  mapname = p;
  {
#line 3866
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3866
    p ++;
#line 3866
    if (((int )*p & -128) == 0) {
      {
#line 3866
      tmp___1 = __ctype_b_loc();
      }
#line 3866
      if (! ((int const   )*(*tmp___1 + (int )*p) & 8)) {
#line 3866
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3866
    if (! ((int )*p == 95)) {
#line 3866
      if (! ((int )*p == 46)) {
#line 3866
        goto while_break___0;
      }
    }
#line 3867
    goto while_continue___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3868
  if ((int )*p != 0) {
#line 3869
    tmp___2 = p;
#line 3869
    p ++;
#line 3869
    *tmp___2 = (char )'\000';
  }
  {
#line 3870
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3870
    if (((int )*p & -128) == 0) {
      {
#line 3870
      tmp___3 = __ctype_b_loc();
      }
#line 3870
      if (! ((int const   )*(*tmp___3 + (int )*p) & 8192)) {
#line 3870
        goto while_break___1;
      }
    } else {
#line 3870
      goto while_break___1;
    }
#line 3871
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3872
  if (((int )*p & -128) == 0) {
    {
#line 3872
    tmp___4 = __ctype_b_loc();
    }
#line 3872
    if (! ((int const   )*(*tmp___4 + (int )*p) & 8)) {
      {
#line 3874
      syserr("readcf: config K line, map %s: no map class", mapname);
      }
#line 3875
      return ((struct _map *)((void *)0));
    }
  } else {
    {
#line 3874
    syserr("readcf: config K line, map %s: no map class", mapname);
    }
#line 3875
    return ((struct _map *)((void *)0));
  }
#line 3877
  classname = p;
  {
#line 3878
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3878
    p ++;
#line 3878
    if (((int )*p & -128) == 0) {
      {
#line 3878
      tmp___5 = __ctype_b_loc();
      }
#line 3878
      if (! ((int const   )*(*tmp___5 + (int )*p) & 8)) {
#line 3878
        goto while_break___2;
      }
    } else {
#line 3878
      goto while_break___2;
    }
#line 3879
    goto while_continue___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3880
  if ((int )*p != 0) {
#line 3881
    tmp___6 = p;
#line 3881
    p ++;
#line 3881
    *tmp___6 = (char )'\000';
  }
  {
#line 3882
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3882
    if (((int )*p & -128) == 0) {
      {
#line 3882
      tmp___7 = __ctype_b_loc();
      }
#line 3882
      if (! ((int const   )*(*tmp___7 + (int )*p) & 8192)) {
#line 3882
        goto while_break___3;
      }
    } else {
#line 3882
      goto while_break___3;
    }
#line 3883
    p ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 3886
  class = stab(classname, 5, 0);
  }
#line 3887
  if ((unsigned long )class == (unsigned long )((void *)0)) {
    {
#line 3889
    syserr("readcf: map %s: class %s not available", mapname, classname);
    }
#line 3891
    return ((struct _map *)((void *)0));
  }
  {
#line 3895
  s = stab(mapname, 6, 1);
#line 3896
  s->s_value.sv_map.map_class = & class->s_value.sv_mapclass;
#line 3897
  s->s_value.sv_map.map_mname = newstr((char const   *)mapname);
#line 3899
  tmp___8 = (*(class->s_value.sv_mapclass.map_parse))(& s->s_value.sv_map, p);
  }
#line 3899
  if (tmp___8) {
#line 3900
    s->s_value.sv_map.map_mflags |= 1L;
  }
#line 3902
  if ((int )tTdvect[37] >= 5) {
    {
#line 3904
    sm_dprintf((char *)"map %s, class %s, flags %lx, file %s,\n", s->s_value.sv_map.map_mname,
               (s->s_value.sv_map.map_class)->map_cname, s->s_value.sv_map.map_mflags,
               s->s_value.sv_map.map_file);
#line 3907
    sm_dprintf((char *)"\tapp %s, domain %s, rebuild %s\n", s->s_value.sv_map.map_app,
               s->s_value.sv_map.map_domain, s->s_value.sv_map.map_rebuild);
    }
  }
#line 3911
  return (& s->s_value.sv_map);
}
}
#line 3934 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static int nextruleset  =    200;
#line 3927 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
int strtorwset(char *p , char **endp , int stabmode ) 
{ 
  int ruleset ;
  unsigned short const   **tmp ;
  long tmp___0 ;
  STAB *s ;
  char delim ;
  char *q ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  long tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *h ;
  unsigned short const   **tmp___8 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 3936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3936
    if (((int )*p & -128) == 0) {
      {
#line 3936
      tmp = __ctype_b_loc();
      }
#line 3936
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 3936
        goto while_break;
      }
    } else {
#line 3936
      goto while_break;
    }
#line 3937
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3938
  if (! (((int )*p & -128) == 0)) {
    {
#line 3940
    syserr("invalid ruleset name: \"%.20s\"", p);
    }
#line 3941
    return (-1);
  }
  {
#line 3943
  tmp___8 = __ctype_b_loc();
  }
#line 3943
  if ((int const   )*(*tmp___8 + (int )*p) & 2048) {
    {
#line 3945
    tmp___0 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)endp,
                     10);
#line 3945
    ruleset = (int )tmp___0;
    }
#line 3946
    if (ruleset >= 100) {
      {
#line 3948
      syserr("bad ruleset %d (%d max)", ruleset, 100);
#line 3950
      ruleset = -1;
      }
    } else
#line 3946
    if (ruleset < 0) {
      {
#line 3948
      syserr("bad ruleset %d (%d max)", ruleset, 100);
#line 3950
      ruleset = -1;
      }
    }
  } else {
#line 3957
    q = (char *)((void *)0);
#line 3959
    q = p;
    {
#line 3960
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3960
      if ((int )*p != 0) {
#line 3960
        if (((int )*p & -128) == 0) {
          {
#line 3960
          tmp___1 = __ctype_b_loc();
          }
#line 3960
          if (! ((int const   )*(*tmp___1 + (int )*p) & 8)) {
#line 3960
            if (! ((int )*p == 95)) {
#line 3960
              goto while_break___0;
            }
          }
        } else {
#line 3960
          goto while_break___0;
        }
      } else {
#line 3960
        goto while_break___0;
      }
#line 3962
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3963
    if ((unsigned long )q == (unsigned long )p) {
      {
#line 3966
      syserr("invalid ruleset name: \"%.20s\"", q);
      }
#line 3967
      return (-1);
    } else
#line 3963
    if (((int )*q & -128) == 0) {
      {
#line 3963
      tmp___2 = __ctype_b_loc();
      }
#line 3963
      if (! ((int const   )*(*tmp___2 + (int )*q) & 1024)) {
        {
#line 3966
        syserr("invalid ruleset name: \"%.20s\"", q);
        }
#line 3967
        return (-1);
      }
    } else {
      {
#line 3966
      syserr("invalid ruleset name: \"%.20s\"", q);
      }
#line 3967
      return (-1);
    }
    {
#line 3969
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3969
      if (((int )*p & -128) == 0) {
        {
#line 3969
        tmp___4 = __ctype_b_loc();
        }
#line 3969
        if (! ((int const   )*(*tmp___4 + (int )*p) & 8192)) {
#line 3969
          goto while_break___1;
        }
      } else {
#line 3969
        goto while_break___1;
      }
#line 3970
      tmp___3 = p;
#line 3970
      p ++;
#line 3970
      *tmp___3 = (char )'\000';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3971
    delim = *p;
#line 3972
    if ((int )delim != 0) {
#line 3973
      *p = (char )'\000';
    }
    {
#line 3974
    s = stab(q, 10, stabmode);
    }
#line 3975
    if ((int )delim != 0) {
#line 3976
      *p = delim;
    }
#line 3978
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 3979
      return (-1);
    }
#line 3981
    if (stabmode == 1) {
#line 3981
      if ((int )delim == 61) {
        {
#line 3983
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3983
          p ++;
#line 3983
          if (((int )*p & -128) == 0) {
            {
#line 3983
            tmp___5 = __ctype_b_loc();
            }
#line 3983
            if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 3983
              goto while_break___2;
            }
          } else {
#line 3983
            goto while_break___2;
          }
#line 3984
          goto while_continue___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3985
        if (((int )*p & -128) == 0) {
          {
#line 3985
          tmp___7 = __ctype_b_loc();
          }
#line 3985
          if ((int const   )*(*tmp___7 + (int )*p) & 2048) {
            {
#line 3992
            tmp___6 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)endp,
                             10);
#line 3992
            ruleset = (int )tmp___6;
            }
#line 3993
            if (ruleset >= 100) {
              {
#line 3995
              syserr("bad ruleset number %d in \"%s\" (%d max)", ruleset, q, 100);
#line 3997
              ruleset = -1;
              }
            } else
#line 3993
            if (ruleset < 0) {
              {
#line 3995
              syserr("bad ruleset number %d in \"%s\" (%d max)", ruleset, q, 100);
#line 3997
              ruleset = -1;
              }
            }
          } else {
            {
#line 3987
            syserr("bad ruleset definition \"%s\" (number required after `=\')", q);
#line 3988
            ruleset = -1;
            }
          }
        } else {
          {
#line 3987
          syserr("bad ruleset definition \"%s\" (number required after `=\')", q);
#line 3988
          ruleset = -1;
          }
        }
      } else {
#line 3981
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 4003
      if ((unsigned long )endp != (unsigned long )((void *)0)) {
#line 4004
        *endp = p;
      }
#line 4005
      if (s->s_value.sv_ruleset >= 0) {
#line 4006
        ruleset = s->s_value.sv_ruleset;
      } else {
#line 4007
        nextruleset --;
#line 4007
        ruleset = nextruleset;
#line 4007
        if (ruleset < 100) {
          {
#line 4009
          syserr("%s: too many named rulesets (%d max)", q, 100);
#line 4011
          ruleset = -1;
          }
        }
      }
    }
#line 4014
    if (s->s_value.sv_ruleset >= 0) {
#line 4014
      if (ruleset >= 0) {
#line 4014
        if (ruleset != s->s_value.sv_ruleset) {
          {
#line 4018
          syserr("%s: ruleset changed value (old %d, new %d)", q, s->s_value.sv_ruleset,
                 ruleset);
#line 4020
          ruleset = s->s_value.sv_ruleset;
          }
        } else {
#line 4014
          goto _L___1;
        }
      } else {
#line 4014
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 4022
    if (ruleset >= 0) {
#line 4024
      s->s_value.sv_ruleset = ruleset;
    }
#line 4026
    if (stabmode == 1) {
#line 4026
      if (ruleset >= 0) {
#line 4028
        h = (char *)((void *)0);
#line 4030
        if ((unsigned long )RuleSetNames[ruleset] != (unsigned long )((void *)0)) {
          {
#line 4031
          sm_free_tagged((void *)RuleSetNames[ruleset], (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c",
                         4031);
          }
        }
#line 4032
        if ((int )delim != 0) {
          {
#line 4032
          h = strchr((char const   *)q, (int )delim);
          }
#line 4032
          if ((unsigned long )h != (unsigned long )((void *)0)) {
#line 4033
            *h = (char )'\000';
          }
        }
        {
#line 4034
        RuleSetNames[ruleset] = newstr((char const   *)q);
        }
#line 4035
        if ((int )delim == 47) {
#line 4035
          if ((unsigned long )h != (unsigned long )((void *)0)) {
#line 4036
            *h = delim;
          }
        }
      }
    }
  }
#line 4039
  return (ruleset);
}
}
#line 4055 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static BITMAP256 StickyTimeoutOpt  ;
#line 4057 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static struct timeoutinfo TimeOutTab[40]  = 
#line 4057
  {      {(char *)"initial", (unsigned char)1}, 
        {(char *)"mail", (unsigned char)2}, 
        {(char *)"rcpt", (unsigned char)3}, 
        {(char *)"datainit", (unsigned char)4}, 
        {(char *)"datablock", (unsigned char)5}, 
        {(char *)"datafinal", (unsigned char)6}, 
        {(char *)"command", (unsigned char)7}, 
        {(char *)"rset", (unsigned char)8}, 
        {(char *)"helo", (unsigned char)9}, 
        {(char *)"quit", (unsigned char)10}, 
        {(char *)"misc", (unsigned char)11}, 
        {(char *)"ident", (unsigned char)12}, 
        {(char *)"fileopen", (unsigned char)13}, 
        {(char *)"connect", (unsigned char)14}, 
        {(char *)"iconnect", (unsigned char)15}, 
        {(char *)"queuewarn", (unsigned char)16}, 
        {(char *)"queuewarn.*", (unsigned char)16}, 
        {(char *)"queuewarn.normal", (unsigned char)17}, 
        {(char *)"queuewarn.urgent", (unsigned char)18}, 
        {(char *)"queuewarn.non-urgent", (unsigned char)19}, 
        {(char *)"queuereturn", (unsigned char)20}, 
        {(char *)"queuereturn.*", (unsigned char)20}, 
        {(char *)"queuereturn.normal", (unsigned char)21}, 
        {(char *)"queuereturn.urgent", (unsigned char)22}, 
        {(char *)"queuereturn.non-urgent", (unsigned char)23}, 
        {(char *)"hoststatus", (unsigned char)24}, 
        {(char *)"resolver.retrans", (unsigned char)25}, 
        {(char *)"resolver.retrans.normal", (unsigned char)26}, 
        {(char *)"resolver.retrans.first", (unsigned char)27}, 
        {(char *)"resolver.retry", (unsigned char)28}, 
        {(char *)"resolver.retry.normal", (unsigned char)29}, 
        {(char *)"resolver.retry.first", (unsigned char)30}, 
        {(char *)"control", (unsigned char)31}, 
        {(char *)"lhlo", (unsigned char)32}, 
        {(char *)"auth", (unsigned char)33}, 
        {(char *)"starttls", (unsigned char)34}, 
        {(char *)"aconnect", (unsigned char)35}, 
        {(char *)"queuewarn.dsn", (unsigned char)36}, 
        {(char *)"queuereturn.dsn", (unsigned char)37}, 
        {(char *)((void *)0), (unsigned char)0}};
#line 4143 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
static void settimeout(char *name , char *val , bool sticky ) 
{ 
  register struct timeoutinfo *to ;
  int i ;
  int addopts ;
  time_t toval ;
  int tmp ;
  int *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 4153
  if ((int )tTdvect[37] >= 2) {
    {
#line 4154
    sm_dprintf((char *)"settimeout(%s = %s)", name, val);
    }
  }
#line 4156
  to = TimeOutTab;
  {
#line 4156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4156
    if (! ((unsigned long )to->to_name != (unsigned long )((void *)0))) {
#line 4156
      goto while_break;
    }
    {
#line 4158
    tmp = sm_strcasecmp((char const   *)to->to_name, (char const   *)name);
    }
#line 4158
    if (tmp == 0) {
#line 4159
      goto while_break;
    }
#line 4156
    to ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4162
  if ((unsigned long )to->to_name == (unsigned long )((void *)0)) {
    {
#line 4164
    tmp___0 = __errno_location();
#line 4164
    *tmp___0 = 0;
#line 4165
    syserr("settimeout: invalid timeout %s", name);
    }
#line 4166
    return;
  }
#line 4173
  if (! sticky) {
#line 4173
    if (StickyTimeoutOpt[(unsigned long )to->to_code / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )to->to_code % (8UL * sizeof(int )))) {
#line 4175
      if ((int )tTdvect[37] >= 2) {
        {
#line 4176
        sm_dprintf((char *)" (ignored)\n");
        }
      }
#line 4177
      return;
    }
  }
#line 4180
  if ((int )tTdvect[37] >= 2) {
    {
#line 4181
    sm_dprintf((char *)"\n");
    }
  }
  {
#line 4183
  toval = convtime(val, 'm');
#line 4184
  addopts = 0;
  }
  {
#line 4188
  if ((int )to->to_code == 1) {
#line 4188
    goto case_1;
  }
#line 4192
  if ((int )to->to_code == 2) {
#line 4192
    goto case_2;
  }
#line 4196
  if ((int )to->to_code == 3) {
#line 4196
    goto case_3;
  }
#line 4200
  if ((int )to->to_code == 4) {
#line 4200
    goto case_4;
  }
#line 4204
  if ((int )to->to_code == 5) {
#line 4204
    goto case_5;
  }
#line 4208
  if ((int )to->to_code == 6) {
#line 4208
    goto case_6;
  }
#line 4212
  if ((int )to->to_code == 7) {
#line 4212
    goto case_7;
  }
#line 4216
  if ((int )to->to_code == 8) {
#line 4216
    goto case_8;
  }
#line 4220
  if ((int )to->to_code == 9) {
#line 4220
    goto case_9;
  }
#line 4224
  if ((int )to->to_code == 10) {
#line 4224
    goto case_10;
  }
#line 4228
  if ((int )to->to_code == 11) {
#line 4228
    goto case_11;
  }
#line 4232
  if ((int )to->to_code == 12) {
#line 4232
    goto case_12;
  }
#line 4236
  if ((int )to->to_code == 13) {
#line 4236
    goto case_13;
  }
#line 4240
  if ((int )to->to_code == 14) {
#line 4240
    goto case_14;
  }
#line 4244
  if ((int )to->to_code == 15) {
#line 4244
    goto case_15;
  }
#line 4248
  if ((int )to->to_code == 35) {
#line 4248
    goto case_35;
  }
#line 4252
  if ((int )to->to_code == 16) {
#line 4252
    goto case_16;
  }
#line 4261
  if ((int )to->to_code == 17) {
#line 4261
    goto case_17;
  }
#line 4266
  if ((int )to->to_code == 18) {
#line 4266
    goto case_18;
  }
#line 4271
  if ((int )to->to_code == 19) {
#line 4271
    goto case_19;
  }
#line 4276
  if ((int )to->to_code == 36) {
#line 4276
    goto case_36;
  }
#line 4281
  if ((int )to->to_code == 20) {
#line 4281
    goto case_20;
  }
#line 4290
  if ((int )to->to_code == 21) {
#line 4290
    goto case_21;
  }
#line 4295
  if ((int )to->to_code == 22) {
#line 4295
    goto case_22;
  }
#line 4300
  if ((int )to->to_code == 23) {
#line 4300
    goto case_23;
  }
#line 4305
  if ((int )to->to_code == 37) {
#line 4305
    goto case_37;
  }
#line 4310
  if ((int )to->to_code == 24) {
#line 4310
    goto case_24;
  }
#line 4314
  if ((int )to->to_code == 25) {
#line 4314
    goto case_25;
  }
#line 4322
  if ((int )to->to_code == 28) {
#line 4322
    goto case_28;
  }
#line 4330
  if ((int )to->to_code == 26) {
#line 4330
    goto case_26;
  }
#line 4334
  if ((int )to->to_code == 29) {
#line 4334
    goto case_29;
  }
#line 4338
  if ((int )to->to_code == 27) {
#line 4338
    goto case_27;
  }
#line 4342
  if ((int )to->to_code == 30) {
#line 4342
    goto case_30;
  }
#line 4346
  if ((int )to->to_code == 31) {
#line 4346
    goto case_31;
  }
#line 4350
  if ((int )to->to_code == 32) {
#line 4350
    goto case_32;
  }
#line 4366
  goto switch_default;
  case_1: /* CIL Label */ 
#line 4189
  TimeOuts.to_initial = toval;
#line 4190
  goto switch_break;
  case_2: /* CIL Label */ 
#line 4193
  TimeOuts.to_mail = toval;
#line 4194
  goto switch_break;
  case_3: /* CIL Label */ 
#line 4197
  TimeOuts.to_rcpt = toval;
#line 4198
  goto switch_break;
  case_4: /* CIL Label */ 
#line 4201
  TimeOuts.to_datainit = toval;
#line 4202
  goto switch_break;
  case_5: /* CIL Label */ 
#line 4205
  TimeOuts.to_datablock = toval;
#line 4206
  goto switch_break;
  case_6: /* CIL Label */ 
#line 4209
  TimeOuts.to_datafinal = toval;
#line 4210
  goto switch_break;
  case_7: /* CIL Label */ 
#line 4213
  TimeOuts.to_nextcommand = toval;
#line 4214
  goto switch_break;
  case_8: /* CIL Label */ 
#line 4217
  TimeOuts.to_rset = toval;
#line 4218
  goto switch_break;
  case_9: /* CIL Label */ 
#line 4221
  TimeOuts.to_helo = toval;
#line 4222
  goto switch_break;
  case_10: /* CIL Label */ 
#line 4225
  TimeOuts.to_quit = toval;
#line 4226
  goto switch_break;
  case_11: /* CIL Label */ 
#line 4229
  TimeOuts.to_miscshort = toval;
#line 4230
  goto switch_break;
  case_12: /* CIL Label */ 
#line 4233
  TimeOuts.to_ident = toval;
#line 4234
  goto switch_break;
  case_13: /* CIL Label */ 
#line 4237
  TimeOuts.to_fileopen = toval;
#line 4238
  goto switch_break;
  case_14: /* CIL Label */ 
#line 4241
  TimeOuts.to_connect = toval;
#line 4242
  goto switch_break;
  case_15: /* CIL Label */ 
#line 4245
  TimeOuts.to_iconnect = toval;
#line 4246
  goto switch_break;
  case_35: /* CIL Label */ 
#line 4249
  TimeOuts.to_aconnect = toval;
#line 4250
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 4253
  toval = convtime(val, 'h');
#line 4254
  TimeOuts.to_q_warning[0] = toval;
#line 4255
  TimeOuts.to_q_warning[1] = toval;
#line 4256
  TimeOuts.to_q_warning[2] = toval;
#line 4257
  TimeOuts.to_q_warning[3] = toval;
#line 4258
  addopts = 2;
  }
#line 4259
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 4262
  toval = convtime(val, 'h');
#line 4263
  TimeOuts.to_q_warning[0] = toval;
  }
#line 4264
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 4267
  toval = convtime(val, 'h');
#line 4268
  TimeOuts.to_q_warning[1] = toval;
  }
#line 4269
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 4272
  toval = convtime(val, 'h');
#line 4273
  TimeOuts.to_q_warning[2] = toval;
  }
#line 4274
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 4277
  toval = convtime(val, 'h');
#line 4278
  TimeOuts.to_q_warning[3] = toval;
  }
#line 4279
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 4282
  toval = convtime(val, 'd');
#line 4283
  TimeOuts.to_q_return[0] = toval;
#line 4284
  TimeOuts.to_q_return[1] = toval;
#line 4285
  TimeOuts.to_q_return[2] = toval;
#line 4286
  TimeOuts.to_q_return[3] = toval;
#line 4287
  addopts = 2;
  }
#line 4288
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 4291
  toval = convtime(val, 'd');
#line 4292
  TimeOuts.to_q_return[0] = toval;
  }
#line 4293
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 4296
  toval = convtime(val, 'd');
#line 4297
  TimeOuts.to_q_return[1] = toval;
  }
#line 4298
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 4301
  toval = convtime(val, 'd');
#line 4302
  TimeOuts.to_q_return[2] = toval;
  }
#line 4303
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 4306
  toval = convtime(val, 'd');
#line 4307
  TimeOuts.to_q_return[3] = toval;
  }
#line 4308
  goto switch_break;
  case_24: /* CIL Label */ 
#line 4311
  MciInfoTimeout = toval;
#line 4312
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 4315
  toval = convtime(val, 's');
#line 4316
  TimeOuts.res_retrans[2] = toval;
#line 4317
  TimeOuts.res_retrans[0] = toval;
#line 4318
  TimeOuts.res_retrans[1] = toval;
#line 4319
  addopts = 2;
  }
#line 4320
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 4323
  i = atoi((char const   *)val);
#line 4324
  TimeOuts.res_retry[2] = i;
#line 4325
  TimeOuts.res_retry[0] = i;
#line 4326
  TimeOuts.res_retry[1] = i;
#line 4327
  addopts = 2;
  }
#line 4328
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 4331
  TimeOuts.res_retrans[1] = convtime(val, 's');
  }
#line 4332
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 4335
  TimeOuts.res_retry[1] = atoi((char const   *)val);
  }
#line 4336
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 4339
  TimeOuts.res_retrans[0] = convtime(val, 's');
  }
#line 4340
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 4343
  TimeOuts.res_retry[0] = atoi((char const   *)val);
  }
#line 4344
  goto switch_break;
  case_31: /* CIL Label */ 
#line 4347
  TimeOuts.to_control = toval;
#line 4348
  goto switch_break;
  case_32: /* CIL Label */ 
#line 4351
  TimeOuts.to_lhlo = toval;
#line 4352
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 4367
  syserr("settimeout: invalid timeout %s", name);
  }
#line 4368
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4371
  if (sticky) {
#line 4373
    i = 0;
    {
#line 4373
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4373
      if (! (i <= addopts)) {
#line 4373
        goto while_break___0;
      }
#line 4374
      StickyTimeoutOpt[(unsigned long )((unsigned char )((int )to->to_code + i)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )((int )to->to_code + i)) % (8UL * sizeof(int ));
#line 4373
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 4376
  return;
}
}
#line 4393 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/readcf.c"
void inittimeouts(char *val , bool sticky ) 
{ 
  register char *p ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  register char *q ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 4400
  if ((int )tTdvect[37] >= 2) {
#line 4401
    if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 4401
      tmp = "<NULL>";
    } else {
#line 4401
      tmp = (char const   *)val;
    }
    {
#line 4401
    sm_dprintf((char *)"inittimeouts(%s)\n", tmp);
    }
  }
#line 4402
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 4404
    TimeOuts.to_connect = (time_t )0;
#line 4405
    TimeOuts.to_aconnect = (time_t )0;
#line 4406
    TimeOuts.to_iconnect = (time_t )0;
#line 4407
    TimeOuts.to_initial = 300L;
#line 4408
    TimeOuts.to_helo = 300L;
#line 4409
    TimeOuts.to_mail = 600L;
#line 4410
    TimeOuts.to_rcpt = 3600L;
#line 4411
    TimeOuts.to_datainit = 300L;
#line 4412
    TimeOuts.to_datablock = 3600L;
#line 4413
    TimeOuts.to_datafinal = 3600L;
#line 4414
    TimeOuts.to_rset = 300L;
#line 4415
    TimeOuts.to_quit = 120L;
#line 4416
    TimeOuts.to_nextcommand = 3600L;
#line 4417
    TimeOuts.to_miscshort = 120L;
#line 4419
    TimeOuts.to_ident = (time_t )5;
#line 4423
    TimeOuts.to_fileopen = (time_t )60;
#line 4424
    TimeOuts.to_control = 120L;
#line 4425
    TimeOuts.to_lhlo = 120L;
#line 4432
    if ((int )tTdvect[37] >= 5) {
      {
#line 4434
      sm_dprintf((char *)"Timeouts:\n");
#line 4435
      sm_dprintf((char *)"  connect = %ld\n", TimeOuts.to_connect);
#line 4437
      sm_dprintf((char *)"  aconnect = %ld\n", TimeOuts.to_aconnect);
#line 4439
      sm_dprintf((char *)"  initial = %ld\n", TimeOuts.to_initial);
#line 4441
      sm_dprintf((char *)"  helo = %ld\n", TimeOuts.to_helo);
#line 4442
      sm_dprintf((char *)"  mail = %ld\n", TimeOuts.to_mail);
#line 4443
      sm_dprintf((char *)"  rcpt = %ld\n", TimeOuts.to_rcpt);
#line 4444
      sm_dprintf((char *)"  datainit = %ld\n", TimeOuts.to_datainit);
#line 4446
      sm_dprintf((char *)"  datablock = %ld\n", TimeOuts.to_datablock);
#line 4448
      sm_dprintf((char *)"  datafinal = %ld\n", TimeOuts.to_datafinal);
#line 4450
      sm_dprintf((char *)"  rset = %ld\n", TimeOuts.to_rset);
#line 4451
      sm_dprintf((char *)"  quit = %ld\n", TimeOuts.to_quit);
#line 4452
      sm_dprintf((char *)"  nextcommand = %ld\n", TimeOuts.to_nextcommand);
#line 4454
      sm_dprintf((char *)"  miscshort = %ld\n", TimeOuts.to_miscshort);
#line 4456
      sm_dprintf((char *)"  ident = %ld\n", TimeOuts.to_ident);
#line 4457
      sm_dprintf((char *)"  fileopen = %ld\n", TimeOuts.to_fileopen);
#line 4459
      sm_dprintf((char *)"  lhlo = %ld\n", TimeOuts.to_lhlo);
#line 4461
      sm_dprintf((char *)"  control = %ld\n", TimeOuts.to_control);
      }
    }
#line 4464
    return;
  }
  {
#line 4467
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4469
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4469
      if (((int )*val & -128) == 0) {
        {
#line 4469
        tmp___0 = __ctype_b_loc();
        }
#line 4469
        if (! ((int const   )*(*tmp___0 + (int )*val) & 8192)) {
#line 4469
          goto while_break___0;
        }
      } else {
#line 4469
        goto while_break___0;
      }
#line 4470
      val ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4471
    if ((int )*val == 0) {
#line 4472
      goto while_break;
    }
#line 4473
    p = val;
    {
#line 4473
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4473
      if ((int )*p != 0) {
#line 4473
        if (! ((int )*p != 44)) {
#line 4473
          goto while_break___1;
        }
      } else {
#line 4473
        goto while_break___1;
      }
#line 4474
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 4473
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4475
    if ((int )*p != 0) {
#line 4476
      tmp___1 = p;
#line 4476
      p ++;
#line 4476
      *tmp___1 = (char )'\000';
    }
#line 4478
    if (((int )*val & -128) == 0) {
      {
#line 4478
      tmp___4 = __ctype_b_loc();
      }
#line 4478
      if ((int const   )*(*tmp___4 + (int )*val) & 2048) {
        {
#line 4481
        TimeOuts.to_mail = convtime(val, 'm');
#line 4482
        TimeOuts.to_rcpt = TimeOuts.to_mail;
#line 4483
        TimeOuts.to_datainit = TimeOuts.to_mail;
#line 4484
        TimeOuts.to_datablock = TimeOuts.to_mail;
#line 4485
        TimeOuts.to_datafinal = TimeOuts.to_mail;
#line 4486
        TimeOuts.to_nextcommand = TimeOuts.to_mail;
        }
#line 4487
        if (sticky) {
#line 4489
          StickyTimeoutOpt[2UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 2UL % (8UL * sizeof(int ));
#line 4490
          StickyTimeoutOpt[3UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 3UL % (8UL * sizeof(int ));
#line 4491
          StickyTimeoutOpt[4UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 4UL % (8UL * sizeof(int ));
#line 4492
          StickyTimeoutOpt[5UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 5UL % (8UL * sizeof(int ));
#line 4493
          StickyTimeoutOpt[6UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 6UL % (8UL * sizeof(int ));
#line 4494
          StickyTimeoutOpt[7UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 7UL % (8UL * sizeof(int ));
        }
#line 4496
        goto __Cont___0;
      } else {
#line 4478
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 4500
      tmp___2 = strchr((char const   *)val, ':');
#line 4500
      q = tmp___2;
      }
#line 4502
      if ((unsigned long )q == (unsigned long )((void *)0)) {
        {
#line 4502
        q = strchr((char const   *)val, '=');
        }
#line 4502
        if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 4505
          goto __Cont___0;
        }
      }
      {
#line 4507
      tmp___3 = q;
#line 4507
      q ++;
#line 4507
      *tmp___3 = (char )'\000';
#line 4508
      settimeout(val, q, sticky);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 4467
    val = p;
  }
  while_break: /* CIL Label */ ;
  }
#line 4511
  return;
}
}
#line 2465 "./sendmail.h"
bool connection_rate_check(union bigsockaddr *hostaddr , ENVELOPE *e ) ;
#line 70 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
static int client_rate(time_t now , union bigsockaddr *saddr , bool update ) ;
#line 71
static int total_rate(time_t now , bool update ) ;
#line 107 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
static int clientconn  =    0;
#line 100 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
bool connection_rate_check(union bigsockaddr *hostaddr , ENVELOPE *e ) 
{ 
  time_t now ;
  int totalrate ;
  int clientrate ;
  char s[16] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 109
  now = time((time_t *)((void *)0));
#line 115
  totalrate = total_rate(now, (unsigned long )e == (unsigned long )((void *)0));
#line 121
  clientrate = client_rate(now, hostaddr, (unsigned long )e == (unsigned long )((void *)0));
  }
#line 123
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 124
    clientconn = count_open_connections(hostaddr);
    }
  }
#line 126
  if ((unsigned long )e != (unsigned long )((void *)0)) {
    {
#line 130
    sm_snprintf(s, (size_t )sizeof(s), "%d", clientrate);
#line 131
    tmp = macid_parse((char *)"{client_rate}", (char **)((void *)0));
#line 131
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp, s, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c",
                     131, SmHeapGroup);
#line 132
    sm_snprintf(s, (size_t )sizeof(s), "%d", totalrate);
#line 133
    tmp___0 = macid_parse((char *)"{total_rate}", (char **)((void *)0));
#line 133
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___0, s, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c",
                     133, SmHeapGroup);
#line 134
    sm_snprintf(s, (size_t )sizeof(s), "%d", clientconn);
#line 135
    tmp___1 = macid_parse((char *)"{client_connections}", (char **)((void *)0));
#line 135
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___1, s, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c",
                     136, SmHeapGroup);
    }
  }
#line 138
  return (1);
}
}
#line 145 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
static int CollTime  =    60;
#line 164 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
static int ChtGran  =    -1;
#line 205 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
static CHash_T CHashAry[1024]  ;
#line 206 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
static bool CHashAryOK  =    0;
#line 224 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
static int client_rate(time_t now , union bigsockaddr *saddr , bool update ) 
{ 
  unsigned int hv ;
  int i ;
  int cnt ;
  bool coll ;
  CHash_T *chBest ;
  unsigned int ticks ;
  char *p ;
  int addrlen ;
  int c ;
  int d ;
  CHash_T *ch ;
  CTime_T *ct ;
  CTime_T *ct___0 ;

  {
#line 234
  chBest = (CHash_T *)((void *)0);
#line 237
  cnt = 0;
#line 238
  hv = 2881737231U;
#line 239
  if (ChtGran < 0) {
#line 240
    ChtGran = ConnectionRateWindowSize / 6;
  }
#line 241
  if (ChtGran <= 0) {
#line 242
    ChtGran = 10;
  }
#line 244
  ticks = (unsigned int )(now / (time_t )ChtGran);
#line 246
  if (! CHashAryOK) {
    {
#line 248
    memset((void *)(CHashAry), 0, (size_t )sizeof(CHashAry));
#line 249
    CHashAryOK = 1;
    }
  }
  {
#line 262
  if ((int )saddr->sa.sa_family == 2) {
#line 262
    goto case_2;
  }
#line 273
  goto switch_default;
  case_2: /* CIL Label */ 
#line 263
  p = (char *)(& saddr->sin.sin_addr);
#line 264
  addrlen = (int )sizeof(struct in_addr );
#line 265
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 275
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 279
  i = 0;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (i < addrlen)) {
#line 279
      goto while_break;
    }
#line 285
    d = (int )*p;
#line 286
    c = d;
#line 287
    c ^= c << 6;
#line 288
    hv += (unsigned int )((c << 11) ^ (c >> 1));
#line 289
    hv ^= (unsigned int )((((d << 14) + (d << 7)) + (d << 4)) + d);
#line 279
    i ++;
#line 279
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  coll = 1;
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 307
    if (! (i < 10)) {
#line 307
      goto while_break___0;
    }
#line 309
    ch = & CHashAry[(hv + (unsigned int )i) & 1023U];
#line 312
    if ((int )saddr->sa.sa_family == 2) {
#line 312
      if (ch->ch_Family == 2) {
#line 312
        if (saddr->sin.sin_addr.s_addr == ch->ch_Addr.s_addr) {
#line 317
          chBest = ch;
#line 318
          coll = 0;
#line 319
          goto while_break___0;
        } else
#line 312
        if (ch->ch_Addr.s_addr == 0U) {
#line 317
          chBest = ch;
#line 318
          coll = 0;
#line 319
          goto while_break___0;
        }
      }
    }
#line 334
    if ((unsigned long )chBest == (unsigned long )((void *)0)) {
#line 336
      chBest = ch;
    } else
#line 334
    if (ch->ch_LTime == 0L) {
#line 336
      chBest = ch;
    } else
#line 334
    if (ch->ch_LTime < chBest->ch_LTime) {
#line 336
      chBest = ch;
    }
#line 307
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 340
  if (update) {
#line 342
    if (coll) {
#line 342
      if (now - chBest->ch_LTime < (time_t )CollTime) {
#line 349
        (chBest->ch_colls) ++;
      }
    }
#line 371
    if (coll) {
#line 374
      if ((int )saddr->sa.sa_family == 2) {
#line 376
        chBest->ch_Family = 2;
#line 377
        chBest->ch_Addr = saddr->sin.sin_addr;
      }
      {
#line 388
      memset((void *)(chBest->ch_Times), '\000', (size_t )sizeof(chBest->ch_Times));
      }
    }
#line 393
    chBest->ch_LTime = now;
#line 395
    ct = & chBest->ch_Times[ticks % 6U];
#line 397
    if (ct->ct_Ticks != (unsigned long )ticks) {
#line 399
      ct->ct_Ticks = (unsigned long )ticks;
#line 400
      ct->ct_Count = 0;
    }
#line 402
    (ct->ct_Count) ++;
  }
#line 407
  i = 0;
  {
#line 407
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 407
    if (! (i < 6)) {
#line 407
      goto while_break___1;
    }
#line 409
    ct___0 = & chBest->ch_Times[i];
#line 411
    if (ct___0->ct_Ticks <= (unsigned long )ticks) {
#line 411
      if (ct___0->ct_Ticks >= (unsigned long )(ticks - 6U)) {
#line 412
        cnt += ct___0->ct_Count;
      }
    }
#line 407
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 420
  return (cnt);
}
}
#line 434 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
static CTime_T srv_Times[6]  ;
#line 435 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
static bool srv_Times_OK  =    0;
#line 437 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/ratectrl.c"
static int total_rate(time_t now , bool update ) 
{ 
  int i ;
  int cnt ;
  CTime_T *ct ;
  unsigned int ticks ;

  {
#line 443
  cnt = 0;
#line 447
  if (ChtGran < 0) {
#line 448
    ChtGran = ConnectionRateWindowSize / 6;
  }
#line 449
  if (ChtGran == 0) {
#line 450
    ChtGran = 10;
  }
#line 451
  ticks = (unsigned int )(now / (time_t )ChtGran);
#line 452
  if (! srv_Times_OK) {
    {
#line 454
    memset((void *)(srv_Times), 0, (size_t )sizeof(srv_Times));
#line 455
    srv_Times_OK = 1;
    }
  }
#line 459
  if (update) {
#line 461
    ct = & srv_Times[ticks % 6U];
#line 463
    if (ct->ct_Ticks != (unsigned long )ticks) {
#line 465
      ct->ct_Ticks = (unsigned long )ticks;
#line 466
      ct->ct_Count = 0;
    }
#line 468
    (ct->ct_Count) ++;
  }
#line 472
  i = 0;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! (i < 6)) {
#line 472
      goto while_break;
    }
#line 474
    ct = & srv_Times[i];
#line 476
    if (ct->ct_Ticks <= (unsigned long )ticks) {
#line 476
      if (ct->ct_Ticks >= (unsigned long )(ticks - 6U)) {
#line 477
        cnt += ct->ct_Count;
      }
    }
#line 472
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  return (cnt);
}
}
#line 256 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 519
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 552
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 728
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) link)(char const   *__from ,
                                                                                   char const   *__to ) ;
#line 440 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 773
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 152 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 154
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 229 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 275 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 466 "./sendmail.h"
void runqueueevent(int ignore ) ;
#line 473
MAILER *LocalMailer ;
#line 540
void filesys_update(void) ;
#line 734
void mci_flush(bool doquit , struct mailer_con_info *allbut ) ;
#line 812
bool commaize(HDR *h , char *p , bool oldstyle , struct mailer_con_info *mci , ENVELOPE *e ) ;
#line 813
HDR *copyheader(HDR *header , SM_RPOOL_T *rpool ) ;
#line 963
void clearenvelope(ENVELOPE *e , bool fullclear , SM_RPOOL_T *rpool ) ;
#line 967
void printenvflags(ENVELOPE *e ) ;
#line 1146
int getfallbackmxrr(char *host ) ;
#line 1271
void closemaps(bool bogus ) ;
#line 1949
time_t QueueIntvl ;
#line 1951
QUEUE_CHAR *QueueLimitId ;
#line 1952
QUEUE_CHAR *QueueLimitQuarantine ;
#line 1954
QUEUE_CHAR *QueueLimitSender ;
#line 1958
void assign_queueid(ENVELOPE *e ) ;
#line 1960
void cleanup_queues(void) ;
#line 1961
bool doqueuerun(void) ;
#line 1966
char *qid_printqueue(int qgrp , int qdir ) ;
#line 1967
void quarantine_queue(char *reason , int qgrplimit ) ;
#line 1972
void set_def_queueval(QUEUEGRP *qg , bool all ) ;
#line 1973
void setup_queues(bool owner ) ;
#line 1976
void sync_queue_time(void) ;
#line 1977
void init_qid_alg(void) ;
#line 1978
int print_single_queue(int qgrp , int qdir ) ;
#line 2163
bool GrabTo ;
#line 2167
bool IgnoreHostStatus ;
#line 2189
bool volatile   StopRequest ;
#line 2234
int Numfilesys ;
#line 2263
pid_t DaemonPid ;
#line 2347
void openxscript(ENVELOPE *e ) ;
#line 2399
pid_t dowork(int qgrp , int qdir , char *id , bool forkflag , bool requeueflag , ENVELOPE *e ) ;
#line 2417
void clrcontrol(void) ;
#line 2460
void cleanup_shm(bool owner ) ;
#line 2463
void clrdaemon(void) ;
#line 2479
pid_t dofork(void) ;
#line 2493
long freediskspace(char *dir___0 , long *bsize ) ;
#line 2511
void intsig(int sig ) ;
#line 2521
void makeworkgroups(void) ;
#line 2531
int pickqdir(QUEUEGRP *qg , long fsize , ENVELOPE *e ) ;
#line 2532
char *pintvl(time_t intvl , bool brief ) ;
#line 2535
void printnqe(SM_FILE_T *out , char *prefix ) ;
#line 2537
void printqueue(void) ;
#line 2544
void reapchild(int sig ) ;
#line 2548
void restart_marked_work_groups(void) ;
#line 2576
pid_t sm_wait(int *status ) ;
#line 2578
void stop_sendmail(void) ;
#line 2599
void upd_qs(ENVELOPE *e , int count , int space , char *where ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 142
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 155
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 48 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static char queue_letter(ENVELOPE *e , int type ) ;
#line 49
static bool quarantine_queue_item(int qgrp , int qdir , ENVELOPE *e , char *reason ) ;
#line 73 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static WORK *WorkQ  ;
#line 74 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int NumWorkGroups  ;
#line 75 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static time_t Current_LA_time  =    (time_t )0;
#line 96 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static bool volatile   DoQueueRun  ;
#line 121 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static WORKGRP volatile   WorkGrp[51]  ;
#line 124 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static SM_DEBUG_T DebugLeakQ  =    {SmDebugMagic, (SM_ATOMIC_UINT_T )-1, (char *)"leak_q", (char *)"@(#)$Debug: leak_q - trace memory leaks during queue processing $",
    (SM_DEBUG_T *)((void *)0)};
#line 133 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static char const   EmptyString[1]  = {      (char const   )'\000'};
#line 135
static void grow_wlist(int qgrp , int qdir ) ;
#line 136
static int multiqueue_cache(char *basedir , int blen , QUEUEGRP *qg , int qn , unsigned int *phash ) ;
#line 137
static int gatherq(int qgrp , int qdir , bool doall , bool *full , bool *more ) ;
#line 138
static int sortq(int max ) ;
#line 139
static void printctladdr(ADDRESS *a , SM_FILE_T *tfp ) ;
#line 140
static bool readqf(ENVELOPE *e , bool openonly ) ;
#line 141
static void restart_work_group(int wgrp ) ;
#line 142
static void runner_work(ENVELOPE *e , int sequenceno , bool didfork , int skip , int njobs ) ;
#line 143
static void schedule_queue_runs(bool runall , int wgrp , bool didit ) ;
#line 144
static char *strrev(char *fwd ) ;
#line 145
static ADDRESS *setctluser(char *user , int qfver , ENVELOPE *e ) ;
#line 150
static int workcmpf0(WORK *a , WORK *b___0 ) ;
#line 151
static int workcmpf1(WORK *a , WORK *b___0 ) ;
#line 152
static int workcmpf2(WORK *a , WORK *b___0 ) ;
#line 153
static int workcmpf3(WORK *a , WORK *b___0 ) ;
#line 154
static int workcmpf4(WORK *a , WORK *b___0 ) ;
#line 155 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int randi  =    3;
#line 156
static int workcmpf5(WORK *a , WORK *b___0 ) ;
#line 157
static int workcmpf6(WORK *a , WORK *b___0 ) ;
#line 184 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static FILESYS FileSys[256]  ;
#line 185 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static char *FSPath[256]  ;
#line 216 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void *Pshm  ;
#line 217 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static FILESYS *PtrFileSys  ;
#line 218 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
int ShmId  =    -2;
#line 219 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static QUEUE_SHM_T *QShm  ;
#line 220 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static size_t shms  ;
#line 237 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
int *PRSATmpCnt  ;
#line 247
static unsigned int hash_q(char *p , unsigned int h ) ;
#line 260 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static unsigned int hash_q(char *p , unsigned int h ) 
{ 
  int c ;
  int d ;
  char *tmp ;

  {
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! ((int )*p != 0)) {
#line 267
      goto while_break;
    }
#line 269
    tmp = p;
#line 269
    p ++;
#line 269
    d = (int )*tmp;
#line 270
    c = d;
#line 271
    c ^= c << 6;
#line 272
    h += (unsigned int )((c << 11) ^ (c >> 1));
#line 273
    h ^= (unsigned int )((((d << 14) + (d << 7)) + (d << 4)) + d);
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return (h);
}
}
#line 339 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void queueup(ENVELOPE *e , bool announce , bool msync ) 
{ 
  register SM_FILE_T *tfp ;
  register HDR *h ;
  register ADDRESS *q ;
  int tfd ;
  int i ;
  bool newid ;
  register char *p ;
  MAILER nullmailer ;
  struct mailer_con_info mcibuf ;
  char qf[4096] ;
  char tf[4096] ;
  char df[4096] ;
  char buf___16[2048] ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  mode_t oldumask ;
  int save_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  __uid_t tmp___4 ;
  bool tmp___5 ;
  mode_t oldumask___0 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  __uid_t tmp___9 ;
  int *tmp___10 ;
  char const   *tmp___11 ;
  bool tmp___12 ;
  char *tmp___13 ;
  int save_errno___0 ;
  int *tmp___14 ;
  int *tmp___15 ;
  __uid_t tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  SM_FILE_T *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  __uid_t tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int dfd ;
  mode_t oldumask___1 ;
  register SM_FILE_T *dfp ;
  struct stat stbuf ;
  int tmp___30 ;
  __uid_t tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  __uid_t tmp___35 ;
  int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tag ;
  SM_FILE_T *tmp___58 ;
  char *tmp___59 ;
  int j ;
  bool tmp___60 ;
  char *tmp___61 ;
  bool oldstyle ;
  SM_FILE_T *savetrace ;
  char *tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  char new ;
  char tmp___66 ;
  char *tmp___67 ;
  __uid_t tmp___68 ;
  int *tmp___69 ;
  char const   *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int *tmp___76 ;
  void *__cil_tmp108 ;
  void *__cil_tmp109 ;
  void *__cil_tmp110 ;
  void *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;

  {
#line 348
  tfd = -1;
#line 375
  if ((unsigned long )e->e_id == (unsigned long )((void *)0)) {
#line 375
    tmp = 1;
  } else
#line 375
  if (! ((e->e_flags & 2UL) != 0UL)) {
#line 375
    tmp = 1;
  } else {
#line 375
    tmp = 0;
  }
  {
#line 375
  newid = tmp;
#line 376
  tmp___0 = queuename(e, 't');
#line 376
  sm_strlcpy(tf, (char const   *)tmp___0, (ssize_t )sizeof(tf));
#line 377
  tfp = e->e_lockfp;
  }
#line 378
  if ((unsigned long )tfp == (unsigned long )((void *)0)) {
#line 378
    if (newid) {
      {
#line 386
      tmp___1 = queuename(e, '?');
#line 386
      sm_strlcpy(tf, (char const   *)tmp___1, (ssize_t )sizeof(tf));
      }
      {
#line 387
      while (1) {
        while_continue: /* CIL Label */ ;
#line 387
        oldumask = (mode_t )0;
#line 387
        if ((QueueFileMode & (128 >> 3)) != 0) {
          {
#line 387
          oldumask = umask((__mode_t )2);
          }
        }
        {
#line 387
        tfd = open((char const   *)(tf), 193, QueueFileMode);
        }
#line 387
        if ((QueueFileMode & (128 >> 3)) != 0) {
          {
#line 387
          umask(oldumask);
          }
        }
#line 387
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 388
      if (tfd < 0) {
#line 388
        goto _L;
      } else {
        {
#line 388
        tmp___5 = lockfile(tfd, tf, (char *)((void *)0), 6);
        }
#line 388
        if (tmp___5) {
          {
#line 388
          tfp = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& tfd)),
                           3, (void const   *)((void *)0));
          }
#line 388
          if ((unsigned long )tfp == (unsigned long )((void *)0)) {
            _L: /* CIL Label */ 
            {
#line 396
            tmp___2 = __errno_location();
#line 396
            save_errno = *tmp___2;
#line 398
            printopenfds(1);
#line 399
            tmp___3 = __errno_location();
#line 399
            *tmp___3 = save_errno;
#line 400
            tmp___4 = geteuid();
#line 400
            syserr("!queueup: cannot create queue file %s, euid=%d, fd=%d, fp=%p",
                   tf, (int )tmp___4, tfd, tfp);
            }
          }
        } else {
#line 388
          goto _L;
        }
      }
      {
#line 404
      e->e_lockfp = tfp;
#line 405
      upd_qs(e, 1, 0, (char *)"queueup");
      }
    }
  }
#line 409
  if (! newid) {
#line 412
    i = 0;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! (i < 128)) {
#line 412
        goto while_break___0;
      }
#line 414
      if (tfd < 0) {
        {
#line 416
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 416
          oldumask___0 = (mode_t )0;
#line 416
          if ((QueueFileMode & (128 >> 3)) != 0) {
            {
#line 416
            oldumask___0 = umask((__mode_t )2);
            }
          }
          {
#line 416
          tfd = open((char const   *)(tf), 193, QueueFileMode);
          }
#line 416
          if ((QueueFileMode & (128 >> 3)) != 0) {
            {
#line 416
            umask(oldumask___0);
            }
          }
#line 416
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 417
        if (tfd < 0) {
          {
#line 419
          tmp___6 = __errno_location();
          }
#line 419
          if (*tmp___6 != 17) {
#line 420
            goto while_break___0;
          }
#line 421
          if (LogLevel > 0) {
#line 421
            if (i % 32 == 0) {
              {
#line 422
              tmp___7 = __errno_location();
#line 422
              tmp___8 = sm_errstring(*tmp___7);
#line 422
              tmp___9 = geteuid();
#line 422
              sm_syslog(1, (char const   *)e->e_id, "queueup: cannot create %s, uid=%d: %s",
                        tf, (int )tmp___9, tmp___8);
              }
            }
          }
        }
      }
#line 432
      if (tfd >= 0) {
        {
#line 438
        tmp___12 = lockfile(tfd, tf, (char *)((void *)0), 6);
        }
#line 438
        if (tmp___12) {
#line 439
          goto while_break___0;
        } else
#line 442
        if (LogLevel > 0) {
#line 442
          if (i % 32 == 0) {
            {
#line 443
            tmp___10 = __errno_location();
#line 443
            tmp___11 = sm_errstring(*tmp___10);
#line 443
            sm_syslog(1, (char const   *)e->e_id, "queueup: cannot lock %s: %s", tf,
                      tmp___11);
            }
          }
        }
#line 446
        if (i % 32 == 31) {
          {
#line 448
          close(tfd);
#line 449
          tfd = -1;
          }
        }
      }
#line 453
      if (i % 32 == 31) {
        {
#line 456
        tmp___13 = queuename(e, 'T');
#line 456
        rename((char const   *)(tf), (char const   *)tmp___13);
        }
      } else {
        {
#line 459
        sleep((unsigned int )(i % 32));
        }
      }
#line 412
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 461
    if (tfd < 0) {
#line 461
      goto _L___0;
    } else {
      {
#line 461
      tfp = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& tfd)),
                       3, (void const   *)((void *)0));
      }
#line 461
      if ((unsigned long )tfp == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
        {
#line 465
        tmp___14 = __errno_location();
#line 465
        save_errno___0 = *tmp___14;
#line 467
        printopenfds(1);
#line 468
        tmp___15 = __errno_location();
#line 468
        *tmp___15 = save_errno___0;
#line 469
        tmp___16 = geteuid();
#line 469
        syserr("!queueup: cannot create queue temp file %s, uid=%d", tf, (int )tmp___16);
        }
      }
    }
  }
#line 474
  if ((int )tTdvect[40] >= 1) {
#line 475
    if (newid) {
#line 475
      tmp___17 = " (new id)";
    } else {
#line 475
      tmp___17 = "";
    }
    {
#line 475
    tmp___18 = queuename(e, '?');
#line 475
    tmp___19 = qid_printqueue(e->e_qgrp, e->e_qdir);
#line 475
    sm_dprintf((char *)"\n>>>>> queueing %s/%s%s >>>>>\n", tmp___19, tmp___18, tmp___17);
    }
  }
#line 479
  if ((int )tTdvect[40] >= 3) {
    {
#line 481
    sm_dprintf((char *)"  e_flags=");
#line 482
    printenvflags(e);
    }
  }
#line 484
  if ((int )tTdvect[40] >= 32) {
    {
#line 486
    sm_dprintf((char *)"  sendq=");
#line 487
    tmp___20 = sm_debug_file();
#line 487
    printaddr(tmp___20, e->e_sendqueue, 1);
    }
  }
#line 489
  if ((int )tTdvect[40] >= 9) {
    {
#line 491
    sm_dprintf((char *)"  tfp=");
#line 492
    tmp___21 = sm_io_getinfo(tfp, 3, (void *)0);
#line 492
    dumpfd(tmp___21, 1, 0);
#line 493
    sm_dprintf((char *)"  lockfp=");
    }
#line 494
    if ((unsigned long )e->e_lockfp == (unsigned long )((void *)0)) {
      {
#line 495
      sm_dprintf((char *)"NULL\n");
      }
    } else {
      {
#line 497
      tmp___22 = sm_io_getinfo(e->e_lockfp, 3, (void *)0);
#line 497
      dumpfd(tmp___22, 1, 0);
      }
    }
  }
  {
#line 505
  tmp___23 = queuename(e, 'd');
#line 505
  sm_strlcpy(df, (char const   *)tmp___23, (ssize_t )sizeof(df));
  }
#line 506
  if ((e->e_flags & 2097152UL) != 0UL) {
#line 508
    if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
#line 508
      if (SuperSafe != 2) {
#line 508
        if (SuperSafe != 3) {
          {
#line 508
          tmp___26 = sm_io_setinfo(e->e_dfp, 1001, (void *)0);
          }
#line 508
          if (tmp___26 < 0) {
            {
#line 508
            tmp___27 = __errno_location();
            }
#line 508
            if (*tmp___27 != 22) {
              {
#line 514
              tmp___24 = geteuid();
#line 514
              tmp___25 = queuename(e, 'd');
#line 514
              syserr("!queueup: cannot commit data file %s, uid=%d", tmp___25, (int )tmp___24);
              }
            }
          }
        }
      }
    }
#line 517
    if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
#line 517
      if (SuperSafe == 1) {
#line 517
        if (msync) {
#line 520
          if ((int )tTdvect[40] >= 32) {
            {
#line 521
            sm_syslog(6, (char const   *)e->e_id, "queueup: fsync(e->e_dfp)");
            }
          }
          {
#line 524
          tmp___28 = sm_io_getinfo(e->e_dfp, 3, (void *)0);
#line 524
          tmp___29 = fsync(tmp___28);
          }
#line 524
          if (tmp___29 < 0) {
#line 527
            if (newid) {
              {
#line 528
              syserr("!552 Error writing data file %s", df);
              }
            } else {
              {
#line 531
              syserr("!452 Error writing data file %s", df);
              }
            }
          }
        }
      }
    }
  } else {
#line 539
    oldumask___1 = (mode_t )0;
#line 540
    dfp = (SM_FILE_T *)((void *)0);
#line 543
    if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
      {
#line 543
      tmp___30 = sm_io_getinfo(e->e_dfp, 5, (void *)"SendmailBufferedFile");
      }
#line 543
      if (tmp___30) {
        {
#line 545
        syserr("committing over bf file");
        }
      }
    }
#line 547
    if ((QueueFileMode & (128 >> 3)) != 0) {
      {
#line 548
      oldumask___1 = umask((__mode_t )2);
      }
    }
    {
#line 549
    dfd = open((char const   *)(df), 577, QueueFileMode);
    }
#line 551
    if ((QueueFileMode & (128 >> 3)) != 0) {
      {
#line 552
      umask(oldumask___1);
      }
    }
#line 553
    if (dfd < 0) {
      {
#line 556
      tmp___31 = geteuid();
#line 556
      syserr("!queueup: cannot create data temp file %s, uid=%d", df, (int )tmp___31);
      }
    } else {
      {
#line 553
      dfp = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& dfd)),
                       3, (void const   *)((void *)0));
      }
#line 553
      if ((unsigned long )dfp == (unsigned long )((void *)0)) {
        {
#line 556
        tmp___31 = geteuid();
#line 556
        syserr("!queueup: cannot create data temp file %s, uid=%d", df, (int )tmp___31);
        }
      }
    }
    {
#line 558
    tmp___32 = fstat(dfd, & stbuf);
    }
#line 558
    if (tmp___32 < 0) {
#line 559
      e->e_dfino = (ino_t )-1;
    } else {
#line 562
      e->e_dfdev = stbuf.st_dev;
#line 563
      e->e_dfino = stbuf.st_ino;
    }
    {
#line 565
    e->e_flags |= 2097152UL;
#line 566
    memset((void *)(& mcibuf), '\000', (size_t )sizeof(mcibuf));
#line 567
    mcibuf.mci_out = dfp;
#line 568
    mcibuf.mci_mailer = FileMailer;
#line 569
    (*(e->e_putbody))(& mcibuf, e, (char *)((void *)0));
    }
#line 571
    if (SuperSafe == 2) {
#line 571
      goto _L___1;
    } else
#line 571
    if (SuperSafe == 3) {
#line 571
      goto _L___1;
    } else
#line 571
    if (SuperSafe == 1) {
#line 571
      if (msync) {
        _L___1: /* CIL Label */ 
#line 575
        if ((int )tTdvect[40] >= 32) {
          {
#line 576
          sm_syslog(6, (char const   *)e->e_id, "queueup: fsync(dfp)");
          }
        }
        {
#line 579
        tmp___33 = sm_io_getinfo(dfp, 3, (void *)0);
#line 579
        tmp___34 = fsync(tmp___33);
        }
#line 579
        if (tmp___34 < 0) {
#line 581
          if (newid) {
            {
#line 582
            syserr("!552 Error writing data file %s", df);
            }
          } else {
            {
#line 585
            syserr("!452 Error writing data file %s", df);
            }
          }
        }
      }
    }
    {
#line 590
    tmp___36 = sm_io_close(dfp, -2);
    }
#line 590
    if (tmp___36 < 0) {
      {
#line 591
      tmp___35 = geteuid();
#line 591
      syserr("!queueup: cannot save data temp file %s, uid=%d", df, (int )tmp___35);
      }
    }
#line 593
    e->e_putbody = & putbody;
  }
  {
#line 603
  sm_io_fprintf(tfp, -2, "V%d\n", 8);
#line 606
  sm_io_fprintf(tfp, -2, "T%ld\n", e->e_ctime);
#line 609
  sm_io_fprintf(tfp, -2, "K%ld\n", e->e_dtime);
#line 612
  sm_io_fprintf(tfp, -2, "N%d\n", e->e_ntries);
#line 615
  sm_io_fprintf(tfp, -2, "P%ld\n", e->e_msgpriority);
  }
#line 622
  if (e->e_dfqgrp != e->e_qgrp) {
    {
#line 624
    sm_io_fprintf(tfp, -2, "d%s\n", ((Queue[e->e_dfqgrp])->qg_qpaths + e->e_dfqdir)->qp_name);
    }
  }
#line 630
  if (e->e_dfino != 0xffffffffffffffffUL) {
    {
#line 632
    tmp___37 = gnu_dev_minor(e->e_dfdev);
#line 632
    tmp___38 = gnu_dev_major(e->e_dfdev);
#line 632
    sm_io_fprintf(tfp, -2, "I%ld/%ld/%llu\n", (long )tmp___38, (long )tmp___37, (ULONGLONG_T )e->e_dfino);
    }
  }
#line 639
  if ((unsigned long )e->e_bodytype != (unsigned long )((void *)0)) {
    {
#line 640
    tmp___39 = denlstring(e->e_bodytype, 1, 0);
#line 640
    sm_io_fprintf(tfp, -2, "B%s\n", tmp___39);
    }
  }
#line 644
  if ((unsigned long )e->e_quarmsg != (unsigned long )((void *)0)) {
    {
#line 645
    tmp___40 = denlstring(e->e_quarmsg, 1, 0);
#line 645
    sm_io_fprintf(tfp, -2, "q%s\n", tmp___40);
    }
  }
#line 649
  if ((unsigned long )e->e_message != (unsigned long )((void *)0)) {
    {
#line 650
    tmp___41 = denlstring(e->e_message, 1, 0);
#line 650
    sm_io_fprintf(tfp, -2, "M%s\n", tmp___41);
    }
  }
#line 654
  p = buf___16;
#line 655
  if ((e->e_flags & 1024UL) != 0UL) {
#line 656
    tmp___42 = p;
#line 656
    p ++;
#line 656
    *tmp___42 = (char )'w';
  }
#line 657
  if ((e->e_flags & 128UL) != 0UL) {
#line 658
    tmp___43 = p;
#line 658
    p ++;
#line 658
    *tmp___43 = (char )'r';
  }
#line 659
  if ((e->e_flags & 131072UL) != 0UL) {
#line 660
    tmp___44 = p;
#line 660
    p ++;
#line 660
    *tmp___44 = (char )'8';
  }
#line 661
  if ((e->e_flags & 64UL) != 0UL) {
#line 662
    tmp___45 = p;
#line 662
    p ++;
#line 662
    *tmp___45 = (char )'b';
  }
#line 663
  if ((e->e_flags & 1048576UL) != 0UL) {
#line 664
    tmp___46 = p;
#line 664
    p ++;
#line 664
    *tmp___46 = (char )'d';
  }
#line 665
  if ((e->e_flags & 4UL) != 0UL) {
#line 666
    tmp___47 = p;
#line 666
    p ++;
#line 666
    *tmp___47 = (char )'n';
  }
#line 667
  if ((e->e_flags & 67108864UL) != 0UL) {
#line 668
    tmp___48 = p;
#line 668
    p ++;
#line 668
    *tmp___48 = (char )'s';
  }
#line 669
  tmp___49 = p;
#line 669
  p ++;
#line 669
  *tmp___49 = (char )'\000';
#line 670
  if ((int )buf___16[0] != 0) {
    {
#line 671
    sm_io_fprintf(tfp, -2, "F%s\n", buf___16);
    }
  }
  {
#line 674
  tmp___50 = macid_parse((char *)"{persistentMacros}", (char **)((void *)0));
#line 674
  queueup_macros(tmp___50, tfp, e);
  }
#line 677
  if ((e->e_from.q_mailer)->m_flags[105UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 105UL % (8UL * sizeof(int )))) {
#line 678
    p = e->e_sender;
  } else {
#line 680
    p = e->e_from.q_paddr;
  }
  {
#line 681
  tmp___51 = denlstring(p, 1, 0);
#line 681
  sm_io_fprintf(tfp, -2, "S%s\n", tmp___51);
  }
#line 685
  if ((unsigned long )e->e_envid != (unsigned long )((void *)0)) {
    {
#line 686
    tmp___52 = denlstring(e->e_envid, 1, 0);
#line 686
    sm_io_fprintf(tfp, -2, "Z%s\n", tmp___52);
    }
  }
#line 690
  if ((unsigned long )e->e_auth_param != (unsigned long )((void *)0)) {
    {
#line 691
    tmp___53 = denlstring(e->e_auth_param, 1, 0);
#line 691
    sm_io_fprintf(tfp, -2, "A%s\n", tmp___53);
    }
  }
#line 693
  if (e->e_dlvr_flag != 0) {
    {
#line 694
    sm_io_fprintf(tfp, -2, "!%c %ld\n", (int )((char )e->e_dlvr_flag), e->e_deliver_by);
    }
  }
  {
#line 698
  printctladdr((ADDRESS *)((void *)0), (SM_FILE_T *)((void *)0));
#line 699
  q = e->e_sendqueue;
  }
  {
#line 699
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 699
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 699
      goto while_break___2;
    }
#line 701
    if (! ((int )q->q_state == 0)) {
#line 701
      if (! ((int )q->q_state == 3)) {
#line 701
        if (! ((int )q->q_state == 4)) {
#line 701
          if (! ((int )q->q_state == 5)) {
#line 702
            goto __Cont;
          }
        }
      }
    }
#line 705
    if ((unsigned long )q->q_message != (unsigned long )((void *)0)) {
      {
#line 706
      tmp___54 = denlstring(q->q_message, 1, 0);
#line 706
      sm_io_fprintf(tfp, -2, "M%s\n", tmp___54);
      }
    }
    {
#line 710
    printctladdr(q, tfp);
    }
#line 711
    if ((unsigned long )q->q_orcpt != (unsigned long )((void *)0)) {
      {
#line 712
      tmp___55 = denlstring(q->q_orcpt, 1, 0);
#line 712
      sm_io_fprintf(tfp, -2, "Q%s\n", tmp___55);
      }
    }
#line 715
    if ((unsigned long )q->q_finalrcpt != (unsigned long )((void *)0)) {
      {
#line 716
      tmp___56 = denlstring(q->q_finalrcpt, 1, 0);
#line 716
      sm_io_fprintf(tfp, -2, "r%s\n", tmp___56);
      }
    }
    {
#line 719
    sm_io_putc(tfp, -2, 'R');
    }
#line 720
    if ((q->q_flags & 2UL) != 0UL) {
      {
#line 721
      sm_io_putc(tfp, -2, 'P');
      }
    }
#line 722
    if ((q->q_flags & 512UL) != 0UL) {
      {
#line 723
      sm_io_putc(tfp, -2, 'N');
      }
    }
#line 724
    if ((q->q_flags & 64UL) != 0UL) {
      {
#line 725
      sm_io_putc(tfp, -2, 'S');
      }
    }
#line 726
    if ((q->q_flags & 128UL) != 0UL) {
      {
#line 727
      sm_io_putc(tfp, -2, 'F');
      }
    }
#line 728
    if ((q->q_flags & 256UL) != 0UL) {
      {
#line 729
      sm_io_putc(tfp, -2, 'D');
      }
    }
#line 730
    if ((unsigned long )q->q_alias != (unsigned long )((void *)0)) {
#line 730
      if (((q->q_alias)->q_flags & 16384UL) != 0UL) {
        {
#line 732
        sm_io_putc(tfp, -2, 'A');
        }
      }
    }
    {
#line 733
    sm_io_putc(tfp, -2, ':');
#line 734
    tmp___57 = denlstring(q->q_paddr, 1, 0);
#line 734
    sm_io_fprintf(tfp, -2, "%s\n", tmp___57);
    }
#line 736
    if (announce) {
#line 738
      tag = (char *)"queued";
#line 740
      if ((unsigned long )e->e_quarmsg != (unsigned long )((void *)0)) {
#line 741
        tag = (char *)"quarantined";
      }
      {
#line 743
      e->e_to = q->q_paddr;
#line 744
      message((char const   *)tag);
      }
#line 745
      if (LogLevel > 8) {
        {
#line 746
        logdelivery(q->q_mailer, (struct mailer_con_info *)((void *)0), q->q_status,
                    (char const   *)tag, (ADDRESS *)((void *)0), (time_t )0, e);
        }
      }
#line 748
      e->e_to = (char *)((void *)0);
    }
#line 750
    if ((int )tTdvect[40] >= 1) {
      {
#line 752
      sm_dprintf((char *)"queueing ");
#line 753
      tmp___58 = sm_debug_file();
#line 753
      printaddr(tmp___58, q, 0);
      }
    }
    __Cont: /* CIL Label */ 
#line 699
    q = q->q_next;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 767
  memset((void *)((char *)(& nullmailer)), '\000', (size_t )sizeof(nullmailer));
#line 768
  nullmailer.m_sh_rwset = (short)-1;
#line 768
  nullmailer.m_se_rwset = nullmailer.m_sh_rwset;
#line 768
  nullmailer.m_rh_rwset = nullmailer.m_se_rwset;
#line 768
  nullmailer.m_re_rwset = nullmailer.m_rh_rwset;
#line 770
  nullmailer.m_eol = (char *)"\n";
#line 771
  memset((void *)(& mcibuf), '\000', (size_t )sizeof(mcibuf));
#line 772
  mcibuf.mci_mailer = & nullmailer;
#line 773
  mcibuf.mci_out = tfp;
#line 775
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'g', (char *)"\201f", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                   775, SmHeapGroup);
#line 776
  h = e->e_header;
  }
  {
#line 776
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 776
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 776
      goto while_break___3;
    }
#line 778
    if ((unsigned long )h->h_value == (unsigned long )((void *)0)) {
#line 779
      goto __Cont___0;
    }
#line 782
    if ((h->h_flags & 8UL) != 0UL) {
#line 782
      if (! ((e->e_flags & 256UL) != 0UL)) {
#line 784
        goto __Cont___0;
      }
    }
#line 787
    if ((h->h_flags & 4UL) != 0UL) {
      {
#line 789
      expand(h->h_value, buf___16, (size_t )sizeof(buf___16), e);
      }
#line 790
      if ((int )buf___16[0] == 0) {
#line 791
        goto __Cont___0;
      }
    }
    {
#line 795
    sm_io_fprintf(tfp, -2, "H?");
    }
#line 798
    if ((int )h->h_macro != 0) {
#line 800
      if (((int )h->h_macro & 128) != 0) {
        {
#line 801
        tmp___59 = macname((int )((unsigned int )h->h_macro & 255U));
#line 801
        sm_io_fprintf(tfp, -2, "${%s}", tmp___59);
        }
      } else {
        {
#line 805
        sm_io_fprintf(tfp, -2, "$%c", (int )h->h_macro);
        }
      }
    } else {
      {
#line 808
      tmp___60 = bitzerop((unsigned int *)(h->h_mflags));
      }
#line 808
      if (! tmp___60) {
#line 808
        if ((h->h_flags & 48UL) != 0UL) {
#line 814
          j = '\000';
          {
#line 814
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 814
            if (! (j <= 127)) {
#line 814
              goto while_break___4;
            }
#line 815
            if (h->h_mflags[(unsigned long )((unsigned char )j) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )j) % (8UL * sizeof(int )))) {
              {
#line 816
              sm_io_putc(tfp, -2, j);
              }
            }
#line 814
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 819
    sm_io_putc(tfp, -2, '?');
    }
#line 822
    if ((h->h_flags & 4UL) != 0UL) {
#line 822
      if (! ((h->h_flags & 131072UL) != 0UL)) {
        {
#line 825
        tmp___61 = denlstring(buf___16, 0, 1);
#line 825
        sm_io_fprintf(tfp, -2, "%s: %s\n", h->h_field, tmp___61);
        }
      } else {
#line 822
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 829
    if ((h->h_flags & 258UL) != 0UL) {
#line 829
      if (! ((h->h_flags & 131072UL) != 0UL)) {
#line 832
        oldstyle = (e->e_flags & 1UL) != 0UL;
#line 833
        savetrace = TrafficLogFile;
#line 835
        TrafficLogFile = (SM_FILE_T *)((void *)0);
#line 837
        if ((h->h_flags & 256UL) != 0UL) {
#line 838
          oldstyle = 0;
        }
        {
#line 840
        commaize(h, h->h_value, oldstyle, & mcibuf, e);
#line 842
        TrafficLogFile = savetrace;
        }
      } else {
        {
#line 846
        tmp___62 = denlstring(h->h_value, 0, 1);
#line 846
        sm_io_fprintf(tfp, -2, "%s: %s\n", h->h_field, tmp___62);
        }
      }
    } else {
      {
#line 846
      tmp___62 = denlstring(h->h_value, 0, 1);
#line 846
      sm_io_fprintf(tfp, -2, "%s: %s\n", h->h_field, tmp___62);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 776
    h = h->h_link;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 860
  sm_io_fprintf(tfp, -2, ".\n");
#line 862
  tmp___63 = sm_io_flush(tfp, -2);
  }
#line 862
  if (tmp___63 != 0) {
#line 862
    goto _L___3;
  } else
#line 862
  if (SuperSafe == 2) {
#line 862
    goto _L___5;
  } else
#line 862
  if (SuperSafe == 3) {
#line 862
    goto _L___5;
  } else
#line 862
  if (SuperSafe == 1) {
#line 862
    if (msync) {
      _L___5: /* CIL Label */ 
      {
#line 862
      tmp___64 = sm_io_getinfo(tfp, 3, (void *)0);
#line 862
      tmp___65 = fsync(tmp___64);
      }
#line 862
      if (tmp___65 < 0) {
#line 862
        goto _L___3;
      } else {
#line 862
        goto _L___6;
      }
    } else {
#line 862
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 862
  if ((tfp->f_flags & 256L) != 0L) {
    _L___3: /* CIL Label */ 
#line 869
    if (newid) {
      {
#line 870
      syserr("!552 Error writing control file %s", tf);
      }
    } else {
      {
#line 872
      syserr("!452 Error writing control file %s", tf);
      }
    }
  }
#line 875
  if (! newid) {
    {
#line 877
    tmp___66 = queue_letter(e, '?');
#line 877
    new = tmp___66;
#line 880
    tmp___67 = queuename(e, '?');
#line 880
    sm_strlcpy(qf, (char const   *)tmp___67, (ssize_t )sizeof(qf));
#line 882
    tmp___74 = rename((char const   *)(tf), (char const   *)(qf));
    }
#line 882
    if (tmp___74 < 0) {
      {
#line 883
      tmp___68 = geteuid();
#line 883
      syserr("cannot rename(%s, %s), uid=%d", tf, qf, (int )tmp___68);
      }
    } else
#line 893
    if ((int )e->e_qfletter != 0) {
#line 893
      if ((int )e->e_qfletter != (int )new) {
#line 896
        if ((int )tTdvect[40] >= 5) {
          {
#line 898
          sm_dprintf((char *)"type changed from %c to %c\n", (int )e->e_qfletter,
                     (int )new);
          }
        }
        {
#line 902
        tmp___72 = queuename(e, (int )e->e_qfletter);
#line 902
        tmp___73 = unlink((char const   *)tmp___72);
        }
#line 902
        if (tmp___73 < 0) {
#line 905
          if (LogLevel > 0) {
            {
#line 906
            tmp___69 = __errno_location();
#line 906
            tmp___70 = sm_errstring(*tmp___69);
#line 906
            tmp___71 = queuename(e, (int )e->e_qfletter);
#line 906
            sm_syslog(3, (char const   *)e->e_id, "queueup: unlink(%s) failed: %s",
                      tmp___71, tmp___70);
            }
          }
        }
      }
    }
#line 913
    e->e_qfletter = new;
#line 921
    if (SuperSafe != 0) {
#line 924
      if (tfd >= 0) {
        {
#line 924
        tmp___75 = fsync(tfd);
        }
#line 924
        if (tmp___75 < 0) {
          {
#line 926
          syserr("!queueup: cannot fsync queue temp file %s", tf);
          }
        }
      }
      {
#line 929
      sync_dir(qf, 1);
      }
    }
#line 933
    if ((unsigned long )e->e_lockfp != (unsigned long )((void *)0)) {
      {
#line 934
      sm_io_close(e->e_lockfp, -2);
      }
    }
#line 935
    e->e_lockfp = tfp;
#line 938
    if (LogLevel > 79) {
      {
#line 939
      sm_syslog(7, (char const   *)e->e_id, "queueup %s", qf);
      }
    }
  } else {
#line 944
    if (LogLevel > 79) {
      {
#line 945
      sm_syslog(7, (char const   *)e->e_id, "queueup %s", tf);
      }
    }
    {
#line 947
    e->e_qfletter = queue_letter(e, '?');
    }
  }
  {
#line 950
  tmp___76 = __errno_location();
#line 950
  *tmp___76 = 0;
#line 951
  e->e_flags |= 2UL;
  }
#line 953
  if ((int )tTdvect[40] >= 1) {
    {
#line 954
    sm_dprintf((char *)"<<<<< done queueing %s <<<<<\n\n", e->e_id);
    }
  }
#line 955
  return;
}
}
#line 982 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static ADDRESS *lastctladdr  =    (ADDRESS *)((void *)0);
#line 983 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static uid_t lastuid  ;
#line 973 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void printctladdr(ADDRESS *a , SM_FILE_T *tfp ) 
{ 
  char *user ;
  register ADDRESS *q ;
  uid_t uid ;
  gid_t gid ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 986
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 986
    goto _L;
  } else
#line 986
  if ((unsigned long )a->q_alias == (unsigned long )((void *)0)) {
#line 986
    goto _L;
  } else
#line 986
  if ((unsigned long )tfp == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 988
    if ((unsigned long )lastctladdr != (unsigned long )((void *)0)) {
#line 988
      if ((unsigned long )tfp != (unsigned long )((void *)0)) {
        {
#line 989
        sm_io_fprintf(tfp, -2, "C\n");
        }
      }
    }
#line 990
    lastctladdr = (ADDRESS *)((void *)0);
#line 991
    lastuid = (uid_t )0;
#line 992
    return;
  }
  {
#line 996
  q = getctladdr(a);
  }
#line 997
  if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 999
    user = (char *)((void *)0);
#line 1000
    uid = (uid_t )0;
#line 1001
    gid = (gid_t )0;
  } else {
#line 1005
    if ((unsigned long )q->q_ruser != (unsigned long )((void *)0)) {
#line 1005
      user = q->q_ruser;
    } else {
#line 1005
      user = q->q_user;
    }
#line 1006
    uid = q->q_uid;
#line 1007
    gid = q->q_gid;
  }
#line 1009
  a = a->q_alias;
#line 1012
  if ((unsigned long )lastctladdr != (unsigned long )((void *)0)) {
#line 1012
    if (uid == lastuid) {
      {
#line 1012
      tmp = strcmp((char const   *)lastctladdr->q_paddr, (char const   *)a->q_paddr);
      }
#line 1012
      if (tmp == 0) {
#line 1014
        return;
      }
    }
  }
#line 1015
  lastuid = uid;
#line 1016
  lastctladdr = a;
#line 1018
  if (uid == 0U) {
    {
#line 1019
    sm_io_fprintf(tfp, -2, "C");
    }
  } else
#line 1018
  if ((unsigned long )user == (unsigned long )((void *)0)) {
    {
#line 1019
    sm_io_fprintf(tfp, -2, "C");
    }
  } else
#line 1018
  if ((int )*(user + 0) == 0) {
    {
#line 1019
    sm_io_fprintf(tfp, -2, "C");
    }
  } else {
    {
#line 1021
    tmp___0 = denlstring(user, 1, 0);
#line 1021
    sm_io_fprintf(tfp, -2, "C%s:%ld:%ld", tmp___0, (long )uid, (long )gid);
    }
  }
  {
#line 1024
  tmp___1 = denlstring(a->q_paddr, 1, 0);
#line 1024
  sm_io_fprintf(tfp, -2, ":%s\n", tmp___1);
  }
#line 1026
  return;
}
}
#line 1056 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int volatile   NoMoreRunners  =    (bool volatile   )0;
#line 1057 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void (*Oldsh_term)(int  )  =    (void (*)(int  ))0;
#line 1058 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void (*Oldsh_hup)(int  )  =    (void (*)(int  ))0;
#line 1059 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void (* volatile  Oldsh)(int  )  =    (void (*/* volatile  */)(int  ))((void (*)(int  ))0);
#line 1060 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static bool BlockOldsh  =    0;
#line 1061 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int volatile   Oldsig  =    (int volatile   )0;
#line 1062
static void runners_sigterm(int sig ) ;
#line 1063
static void runners_sighup(int sig ) ;
#line 1065 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void runners_sigterm(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 1069
  tmp = __errno_location();
#line 1069
  save_errno = *tmp;
#line 1072
  tmp___0 = __errno_location();
#line 1072
  *tmp___0 = save_errno;
  }
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1073
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 1073
      if (sig != 0) {
        {
#line 1073
        pend_signal(sig);
        }
#line 1073
        return;
      }
    }
#line 1073
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1074
  NoMoreRunners = (int volatile   )1;
#line 1075
  Oldsh = (void (*/* volatile  */)(int  ))Oldsh_term;
#line 1076
  Oldsig = (int volatile   )sig;
#line 1077
  proc_list_signal(3, sig);
  }
#line 1079
  if (! BlockOldsh) {
#line 1079
    goto _L;
  } else {
    {
#line 1079
    tmp___1 = getppid();
    }
#line 1079
    if (tmp___1 <= 1) {
      _L: /* CIL Label */ 
#line 1082
      if ((unsigned long )Oldsh_term != (unsigned long )((void (*)(int  ))0)) {
#line 1082
        if ((unsigned long )Oldsh_term != (unsigned long )((void (*)(int  ))1)) {
#line 1082
          if ((unsigned long )Oldsh_term != (unsigned long )(& runners_sigterm)) {
            {
#line 1084
            (*Oldsh_term)(sig);
            }
          }
        }
      }
    }
  }
  {
#line 1086
  tmp___2 = __errno_location();
#line 1086
  *tmp___2 = save_errno;
  }
#line 1087
  return;
}
}
#line 1117 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void runners_sighup(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 1121
  tmp = __errno_location();
#line 1121
  save_errno = *tmp;
#line 1124
  tmp___0 = __errno_location();
#line 1124
  *tmp___0 = save_errno;
  }
  {
#line 1125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1125
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 1125
      if (sig != 0) {
        {
#line 1125
        pend_signal(sig);
        }
#line 1125
        return;
      }
    }
#line 1125
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1126
  NoMoreRunners = (int volatile   )1;
#line 1127
  Oldsh = (void (*/* volatile  */)(int  ))Oldsh_hup;
#line 1128
  Oldsig = (int volatile   )sig;
#line 1129
  proc_list_signal(3, sig);
  }
#line 1131
  if (! BlockOldsh) {
#line 1131
    goto _L;
  } else {
    {
#line 1131
    tmp___1 = getppid();
    }
#line 1131
    if (tmp___1 <= 1) {
      _L: /* CIL Label */ 
#line 1134
      if ((unsigned long )Oldsh_hup != (unsigned long )((void (*)(int  ))0)) {
#line 1134
        if ((unsigned long )Oldsh_hup != (unsigned long )((void (*)(int  ))1)) {
#line 1134
          if ((unsigned long )Oldsh_hup != (unsigned long )(& runners_sighup)) {
            {
#line 1136
            (*Oldsh_hup)(sig);
            }
          }
        }
      }
    }
  }
  {
#line 1138
  tmp___2 = __errno_location();
#line 1138
  *tmp___2 = save_errno;
  }
#line 1139
  return;
}
}
#line 1161 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void mark_work_group_restart(int wgrp , int reason ) 
{ 


  {
#line 1166
  if (wgrp < 0) {
#line 1167
    return;
  } else
#line 1166
  if (wgrp > NumWorkGroups) {
#line 1167
    return;
  }
#line 1169
  WorkGrp[wgrp].wg_restart = (int volatile   )reason;
#line 1170
  if (reason >= 0) {
#line 1171
    RestartWorkGroup = (bool volatile   )1;
  }
#line 1172
  return;
}
}
#line 1189 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void restart_marked_work_groups(void) 
{ 
  int i ;
  int wasblocked ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 1195
  if (NoMoreRunners) {
#line 1196
    return;
  }
  {
#line 1199
  wasblocked = sm_blocksignal(17);
#line 1201
  i = 0;
  }
  {
#line 1201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1201
    if (! (i < NumWorkGroups)) {
#line 1201
      goto while_break;
    }
#line 1203
    if (WorkGrp[i].wg_restart >= (int volatile   )0) {
#line 1205
      if (LogLevel > 8) {
        {
#line 1206
        sm_syslog(3, "*~*", "restart queue runner=%d due to signal 0x%x", i, WorkGrp[i].wg_restart);
        }
      }
      {
#line 1209
      restart_work_group(i);
      }
    }
#line 1201
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1212
  RestartWorkGroup = (bool volatile   )0;
#line 1214
  if (wasblocked == 0) {
    {
#line 1215
    sm_releasesignal(17);
    }
  }
#line 1216
  return;
}
}
#line 1236 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void restart_work_group(int wgrp ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 1240
  if (NoMoreRunners) {
#line 1242
    return;
  } else
#line 1240
  if (wgrp < 0) {
#line 1242
    return;
  } else
#line 1240
  if (wgrp > NumWorkGroups) {
#line 1242
    return;
  }
#line 1244
  WorkGrp[wgrp].wg_restart = (int volatile   )-1;
#line 1245
  if (WorkGrp[wgrp].wg_restartcnt < (int volatile   )10) {
    {
#line 1248
    WorkGrp[wgrp].wg_restartcnt += (int volatile   )1;
#line 1249
    run_work_group(wgrp, 21);
    }
  } else {
    {
#line 1253
    sm_syslog(3, "*~*", "ERROR: persistent queue runner=%d restarted too many times, queue runner lost",
              wgrp);
    }
  }
#line 1257
  return;
}
}
#line 1274 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void schedule_queue_runs(bool runall , int wgrp , bool didit ) 
{ 
  int qgrp ;
  int cgrp ;
  int endgrp ;
  time_t now ;
  time_t minqintvl ;
  time_t qintvl ;

  {
  {
#line 1293
  now = curtime();
#line 1294
  minqintvl = (time_t )0;
#line 1295
  endgrp = (int )WorkGrp[wgrp].wg_curqgrp;
#line 1295
  cgrp = endgrp;
  }
  {
#line 1296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1304
    qgrp = (int )(*(WorkGrp[wgrp].wg_qgs + cgrp))->qg_index;
#line 1305
    if ((Queue[qgrp])->qg_queueintvl > 0L) {
#line 1306
      qintvl = (Queue[qgrp])->qg_queueintvl;
    } else
#line 1307
    if (QueueIntvl > 0L) {
#line 1308
      qintvl = QueueIntvl;
    } else {
#line 1310
      qintvl = (time_t )0;
    }
#line 1314
    if (runall) {
#line 1314
      goto _L;
    } else
#line 1314
    if ((Queue[qgrp])->qg_nextrun <= now) {
      _L: /* CIL Label */ 
#line 1314
      if (qintvl > 0L) {
#line 1319
        if (minqintvl == 0L) {
#line 1320
          minqintvl = qintvl;
        } else
#line 1319
        if (qintvl < minqintvl) {
#line 1320
          minqintvl = qintvl;
        }
#line 1329
        if (didit) {
#line 1330
          (Queue[qgrp])->qg_nextrun += qintvl;
        }
      }
    }
#line 1340
    cgrp ++;
#line 1340
    if (cgrp >= (int )WorkGrp[wgrp].wg_numqgrp) {
#line 1340
      cgrp = 0;
    }
#line 1296
    if (! (endgrp != cgrp)) {
#line 1296
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1342
  if (minqintvl > 0L) {
    {
#line 1343
    sm_seteventm((int )(minqintvl * 1000L), & runqueueevent, 0);
    }
  }
#line 1344
  return;
}
}
#line 1425 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static ENVELOPE QueueEnvelope  ;
#line 1426 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static time_t LastQueueTime  =    (time_t )0;
#line 1427 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static pid_t LastQueuePid  =    -1;
#line 1444 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int curnum  =    0;
#line 1435 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
bool runqueue(bool forkflag , bool verbose , bool persistent , bool runall ) 
{ 
  int i ;
  bool ret ;
  void (*cursh)(int  ) ;
  int oldgroup ;
  bool tmp ;
  int rwgflags ;
  int h ;
  bool tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1443
  ret = 1;
#line 1447
  oldgroup = 0;
#line 1449
  if (DebugLeakQ.debug_level >= 1U) {
#line 1449
    if (DebugLeakQ.debug_level != 4294967295U) {
      {
#line 1451
      oldgroup = SmHeapGroup;
#line 1452
      SmHeapMaxGroup ++;
#line 1452
      SmHeapGroup = SmHeapMaxGroup;
#line 1453
      sm_dprintf((char *)"runqueue() heap group #%d\n", SmHeapGroup);
      }
    } else {
      {
#line 1449
      tmp = sm_debug_loadactive(& DebugLeakQ, 1);
      }
#line 1449
      if (tmp) {
        {
#line 1451
        oldgroup = SmHeapGroup;
#line 1452
        SmHeapMaxGroup ++;
#line 1452
        SmHeapGroup = SmHeapMaxGroup;
#line 1453
        sm_dprintf((char *)"runqueue() heap group #%d\n", SmHeapGroup);
        }
      }
    }
  }
#line 1458
  DoQueueRun = (bool volatile   )0;
#line 1461
  if (! forkflag) {
#line 1461
    if (! verbose) {
#line 1461
      if ((*(WorkGrp[0].wg_qgs + 0))->qg_numqueues > 1) {
#line 1464
        forkflag = 1;
      } else
#line 1461
      if (NumWorkGroups > 1) {
#line 1464
        forkflag = 1;
      } else
#line 1461
      if (WorkGrp[0].wg_numqgrp > (int volatile   )1) {
#line 1464
        forkflag = 1;
      }
    }
  }
  {
#line 1478
  cursh = sm_signal(15, & runners_sigterm);
  }
#line 1479
  if ((unsigned long )cursh != (unsigned long )(& runners_sigterm)) {
#line 1480
    Oldsh_term = cursh;
  }
  {
#line 1481
  cursh = sm_signal(1, & runners_sighup);
  }
#line 1482
  if ((unsigned long )cursh != (unsigned long )(& runners_sighup)) {
#line 1483
    Oldsh_hup = cursh;
  }
#line 1485
  i = 0;
  {
#line 1485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1485
    if (i < NumWorkGroups) {
#line 1485
      if (! (! NoMoreRunners)) {
#line 1485
        goto while_break;
      }
    } else {
#line 1485
      goto while_break;
    }
#line 1487
    rwgflags = 0;
#line 1506
    if (MaxQueueChildren > 0) {
#line 1506
      if (CurRunners + WorkGrp[curnum].wg_maxact > (int volatile   )MaxQueueChildren) {
#line 1508
        goto while_break;
      }
    }
#line 1524
    CurRunners += WorkGrp[curnum].wg_maxact;
#line 1525
    if (forkflag) {
#line 1526
      rwgflags |= 1;
    }
#line 1527
    if (verbose) {
#line 1528
      rwgflags |= 2;
    }
#line 1529
    if (persistent) {
#line 1530
      rwgflags |= 4;
    }
#line 1531
    if (runall) {
#line 1532
      rwgflags |= 16;
    }
    {
#line 1533
    ret = run_work_group(curnum, rwgflags);
    }
#line 1542
    if (! ret) {
#line 1544
      CurRunners -= WorkGrp[curnum].wg_maxact;
#line 1545
      goto while_break;
    }
#line 1548
    if (! persistent) {
      {
#line 1549
      schedule_queue_runs(runall, curnum, 1);
      }
    }
#line 1550
    curnum ++;
#line 1550
    if (curnum >= NumWorkGroups) {
#line 1550
      curnum = 0;
    }
#line 1485
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1554
  if (i < NumWorkGroups) {
#line 1554
    if (! NoMoreRunners) {
#line 1554
      if (! persistent) {
#line 1558
        h = curnum;
        {
#line 1558
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1558
          if (! (i < NumWorkGroups)) {
#line 1558
            goto while_break___0;
          }
          {
#line 1560
          schedule_queue_runs(runall, h, 0);
#line 1561
          h ++;
          }
#line 1561
          if (h >= NumWorkGroups) {
#line 1561
            h = 0;
          }
#line 1558
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 1567
  if (DebugLeakQ.debug_level >= 1U) {
#line 1567
    if (DebugLeakQ.debug_level != 4294967295U) {
#line 1568
      SmHeapGroup = oldgroup;
    } else {
      {
#line 1567
      tmp___0 = sm_debug_loadactive(& DebugLeakQ, 1);
      }
#line 1567
      if (tmp___0) {
#line 1568
        SmHeapGroup = oldgroup;
      }
    }
  }
#line 1570
  return (ret);
}
}
#line 1647 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void runner_work(ENVELOPE *e , int sequenceno , bool didfork , int skip , int njobs ) 
{ 
  int n ;
  int seqjump ;
  WORK *w ;
  time_t now ;
  int oldgroup ;
  bool tmp ;
  char *msg ;
  bool tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 1659
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1659
    now = curtime();
    }
#line 1659
    if (Current_LA_time < now - 30L) {
      {
#line 1659
      sm_getla();
#line 1659
      Current_LA_time = now;
      }
    }
#line 1659
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1668
  BlockOldsh = 1;
#line 1669
  seqjump = skip;
  {
#line 1672
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1672
    if (! ((unsigned long )WorkQ != (unsigned long )((void *)0))) {
#line 1672
      goto while_break___0;
    }
#line 1675
    oldgroup = 0;
#line 1677
    if (DebugLeakQ.debug_level >= 1U) {
#line 1677
      if (DebugLeakQ.debug_level != 4294967295U) {
        {
#line 1679
        oldgroup = SmHeapGroup;
#line 1680
        SmHeapMaxGroup ++;
#line 1680
        SmHeapGroup = SmHeapMaxGroup;
#line 1681
        sm_dprintf((char *)"run_queue_group() heap group #%d\n", SmHeapGroup);
        }
      } else {
        {
#line 1677
        tmp = sm_debug_loadactive(& DebugLeakQ, 1);
        }
#line 1677
        if (tmp) {
          {
#line 1679
          oldgroup = SmHeapGroup;
#line 1680
          SmHeapMaxGroup ++;
#line 1680
          SmHeapGroup = SmHeapMaxGroup;
#line 1681
          sm_dprintf((char *)"run_queue_group() heap group #%d\n", SmHeapGroup);
          }
        }
      }
    }
#line 1687
    if (NoMoreRunners) {
#line 1690
      if ((unsigned long )Oldsh != (unsigned long )((void (*)(int  ))0)) {
#line 1690
        if ((unsigned long )Oldsh != (unsigned long )((void (*)(int  ))1)) {
#line 1690
          if ((unsigned long )Oldsh != (unsigned long )(& runners_sighup)) {
#line 1690
            if ((unsigned long )Oldsh != (unsigned long )(& runners_sigterm)) {
              {
#line 1693
              (*Oldsh)((int )Oldsig);
              }
            }
          }
        }
      }
#line 1694
      goto while_break___0;
    }
#line 1697
    w = WorkQ;
#line 1743
    n = 0;
    {
#line 1743
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1743
      if (n < skip) {
#line 1743
        if (! ((unsigned long )WorkQ != (unsigned long )((void *)0))) {
#line 1743
          goto while_break___1;
        }
      } else {
#line 1743
        goto while_break___1;
      }
#line 1744
      WorkQ = WorkQ->w_next;
#line 1743
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1747
    e->e_to = (char *)((void *)0);
    {
#line 1755
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1755
      now = curtime();
      }
#line 1755
      if (Current_LA_time < now - 30L) {
        {
#line 1755
        sm_getla();
#line 1755
        Current_LA_time = now;
        }
      }
#line 1755
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1756
    tmp___0 = shouldqueue(WkRecipFact, Current_LA_time);
    }
#line 1756
    if (tmp___0) {
#line 1758
      msg = (char *)"Aborting queue run: load average too high";
#line 1760
      if (Verbose) {
        {
#line 1761
        message("%s", msg);
        }
      }
#line 1762
      if (LogLevel > 8) {
        {
#line 1763
        sm_syslog(6, "*~*", "runqueue: %s", msg);
        }
      }
#line 1764
      goto while_break___0;
    }
    {
#line 1766
    tmp___7 = shouldqueue(w->w_pri, w->w_ctime);
    }
#line 1766
    if (tmp___7) {
#line 1768
      if (Verbose) {
        {
#line 1769
        message(EmptyString);
        }
      }
#line 1770
      if (QueueSortOrder == 0) {
#line 1772
        if (Verbose) {
          {
#line 1773
          tmp___1 = qid_printqueue(w->w_qgrp, w->w_qdir);
#line 1773
          message("Skipping %s/%s (sequence %d of %d) and flushing rest of queue",
                  tmp___1, w->w_name + 2, sequenceno, njobs);
          }
        }
#line 1778
        if (LogLevel > 8) {
          {
#line 1779
          tmp___2 = qid_printqueue(w->w_qgrp, w->w_qdir);
#line 1779
          sm_syslog(6, "*~*", "runqueue: Flushing queue from %s/%s (pri %ld, LA %d, %d of %d)",
                    tmp___2, w->w_name + 2, w->w_pri, CurrentLA, sequenceno, njobs);
          }
        }
#line 1786
        goto while_break___0;
      } else
#line 1788
      if (Verbose) {
        {
#line 1789
        tmp___3 = qid_printqueue(w->w_qgrp, w->w_qdir);
#line 1789
        message("Skipping %s/%s (sequence %d of %d)", tmp___3, w->w_name + 2, sequenceno,
                njobs);
        }
      }
    } else {
#line 1795
      if (Verbose) {
        {
#line 1797
        message(EmptyString);
#line 1798
        tmp___4 = qid_printqueue(w->w_qgrp, w->w_qdir);
#line 1798
        message("Running %s/%s (sequence %d of %d)", tmp___4, w->w_name + 2, sequenceno,
                njobs);
        }
      }
#line 1802
      if (didfork) {
#line 1802
        if (MaxQueueChildren > 0) {
          {
#line 1804
          sm_blocksignal(17);
#line 1805
          sm_signal(17, & reapchild);
          }
        }
      }
#line 1807
      if ((int )tTdvect[63] >= 100) {
        {
#line 1808
        tmp___5 = qid_printqueue(w->w_qgrp, w->w_qdir);
#line 1808
        sm_syslog(7, "*~*", "runqueue %s dowork(%s)", tmp___5, w->w_name + 2);
        }
      }
      {
#line 1813
      dowork(w->w_qgrp, w->w_qdir, w->w_name + 2, ForkQueueRuns, 0, e);
#line 1815
      tmp___6 = __errno_location();
#line 1815
      *tmp___6 = 0;
      }
    }
    {
#line 1817
    sm_free_tagged((void *)w->w_name, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                   1817);
    }
#line 1818
    if ((unsigned long )w->w_host != (unsigned long )((void *)0)) {
      {
#line 1819
      sm_free_tagged((void *)w->w_host, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     1819);
      }
    }
    {
#line 1820
    sm_free_tagged((void *)((char *)w), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                   1820);
#line 1821
    sequenceno += seqjump;
    }
#line 1823
    if (DebugLeakQ.debug_level >= 1U) {
#line 1823
      if (DebugLeakQ.debug_level != 4294967295U) {
#line 1824
        SmHeapGroup = oldgroup;
      } else {
        {
#line 1823
        tmp___8 = sm_debug_loadactive(& DebugLeakQ, 1);
        }
#line 1823
        if (tmp___8) {
#line 1824
          SmHeapGroup = oldgroup;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1828
  BlockOldsh = 0;
#line 1831
  if (NoMoreRunners) {
#line 1834
    if ((unsigned long )Oldsh != (unsigned long )((void (*)(int  ))0)) {
#line 1834
      if ((unsigned long )Oldsh != (unsigned long )((void (*)(int  ))1)) {
#line 1834
        if ((unsigned long )Oldsh != (unsigned long )(& runners_sighup)) {
#line 1834
          if ((unsigned long )Oldsh != (unsigned long )(& runners_sigterm)) {
            {
#line 1836
            (*Oldsh)((int )Oldsig);
            }
          }
        }
      }
    }
  }
#line 1839
  Oldsh = (void (*/* volatile  */)(int  ))((void (*)(int  ))0);
#line 1840
  return;
}
}
#line 1861 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
bool run_work_group(int wgrp , int flags ) 
{ 
  register ENVELOPE *e ;
  int njobs ;
  int qdir ;
  int sequenceno ;
  int qgrp ;
  int endgrp ;
  int h ;
  int i ;
  time_t now ;
  bool full ;
  bool more ;
  SM_RPOOL_T *rpool ;
  char *msg ;
  bool tmp ;
  char *msg___0 ;
  pid_t pid ;
  char const   *msg___1 ;
  char const   *err ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  __uid_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int loop ;
  int maxrunners ;
  pid_t pid___0 ;
  int status ;
  pid_t ret ;
  char *tmp___6 ;
  SM_FILE_T *out ;
  int tmp___7 ;
  SM_ATOMIC_UINT_T tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  time_t tmp___11 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
#line 1868
  sequenceno = 1;
#line 1877
  if (wgrp < 0) {
#line 1878
    return (0);
  }
  {
#line 1885
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1885
    now = curtime();
    }
#line 1885
    if (Current_LA_time < now - 30L) {
      {
#line 1885
      sm_getla();
#line 1885
      Current_LA_time = now;
      }
    }
#line 1885
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1887
  if (! ((flags & 4) != 0)) {
    {
#line 1887
    tmp = shouldqueue(WkRecipFact, Current_LA_time);
    }
#line 1887
    if (tmp) {
#line 1890
      msg = (char *)"Skipping queue run -- load average too high";
#line 1892
      if ((flags & 2) != 0) {
        {
#line 1893
        message("458 %s\n", msg);
        }
      }
#line 1894
      if (LogLevel > 8) {
        {
#line 1895
        sm_syslog(6, "*~*", "runqueue: %s", msg);
        }
      }
#line 1896
      return (0);
    }
  }
#line 1903
  if ((flags & 1) != 0) {
#line 1903
    if (WorkGrp[wgrp].wg_lowqintvl > (time_t volatile   )0) {
#line 1903
      if (! ((flags & 4) != 0)) {
#line 1903
        if (MaxChildren > 0) {
#line 1903
          if (CurChildren >= (int volatile   )MaxChildren) {
#line 1908
            msg___0 = (char *)"Skipping queue run -- too many children";
#line 1910
            if ((flags & 2) != 0) {
              {
#line 1911
              message("458 %s (%d)\n", msg___0, CurChildren);
              }
            }
#line 1912
            if (LogLevel > 8) {
              {
#line 1913
              sm_syslog(6, "*~*", "runqueue: %s (%d)", msg___0, CurChildren);
              }
            }
#line 1915
            return (0);
          }
        }
      }
    }
  }
#line 1922
  if ((flags & 1) != 0) {
    {
#line 1926
    sm_blocksignal(17);
#line 1927
    sm_signal(17, & reapchild);
#line 1929
    pid = dofork();
    }
#line 1930
    if (pid == -1) {
      {
#line 1932
      msg___1 = "Skipping queue run -- fork() failed";
#line 1933
      tmp___0 = __errno_location();
#line 1933
      tmp___1 = sm_errstring(*tmp___0);
#line 1933
      err = tmp___1;
      }
#line 1935
      if ((flags & 2) != 0) {
        {
#line 1936
        message("458 %s: %s\n", msg___1, err);
        }
      }
#line 1937
      if (LogLevel > 8) {
        {
#line 1938
        sm_syslog(6, "*~*", "runqueue: %s: %s", msg___1, err);
        }
      }
      {
#line 1940
      sm_releasesignal(17);
      }
#line 1941
      return (0);
    }
#line 1943
    if (pid != 0) {
      {
#line 1946
      sm_blocksignal(14);
      }
#line 1949
      if ((flags & 4) != 0) {
#line 1949
        tmp___2 = wgrp;
      } else {
#line 1949
        tmp___2 = -1;
      }
      {
#line 1949
      proc_list_add(pid, (char *)"Queue runner", 3, (int )WorkGrp[wgrp].wg_maxact,
                    tmp___2, (union bigsockaddr *)((void *)0));
#line 1953
      sm_releasesignal(14);
#line 1954
      sm_releasesignal(17);
      }
#line 1955
      return (1);
    }
    {
#line 1961
    RestartRequest = (char */* volatile  */)((void *)0);
#line 1962
    RestartWorkGroup = (bool volatile   )0;
#line 1963
    ShutdownRequest = (char */* volatile  */)((void *)0);
#line 1964
    PendingSignal = (int volatile   )0;
#line 1965
    CurrentPid = getpid();
#line 1966
    close_sendmail_pid();
#line 1973
    sm_exc_newthread(& fatal_error);
#line 1974
    clrcontrol();
#line 1975
    proc_list_clear();
#line 1978
    proc_list_add(CurrentPid, (char *)"Queue runner child process", 3, 0, -1, (union bigsockaddr *)((void *)0));
#line 1980
    sm_releasesignal(17);
#line 1981
    sm_signal(17, (void (*)(int  ))0);
#line 1982
    sm_signal(1, (void (*)(int  ))0);
#line 1983
    sm_signal(15, & intsig);
    }
  }
  {
#line 1990
  clrdaemon();
#line 1993
  NoConnect = 0;
#line 1996
  tmp___3 = geteuid();
  }
#line 1996
  if (tmp___3 == 0U) {
    {
#line 1997
    drop_privileges(0);
    }
  }
  {
#line 2003
  CurEnv = & QueueEnvelope;
#line 2004
  rpool = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 2005
  e = newenvelope(& QueueEnvelope, CurEnv, rpool);
#line 2006
  e->e_flags = BlankEnvelope.e_flags;
#line 2007
  e->e_parent = (ENVELOPE *)((void *)0);
  }
#line 2010
  if ((flags & 1) != 0) {
    {
#line 2012
    disconnect(1, e);
#line 2013
    QuickAbort = 0;
    }
  }
#line 2021
  if ((unsigned long )QueueLimitId != (unsigned long )((void *)0)) {
#line 2025
    IgnoreHostStatus = 1;
#line 2026
    MinQueueAge = (time_t )0;
  } else
#line 2021
  if ((unsigned long )QueueLimitSender != (unsigned long )((void *)0)) {
#line 2025
    IgnoreHostStatus = 1;
#line 2026
    MinQueueAge = (time_t )0;
  } else
#line 2021
  if ((unsigned long )QueueLimitQuarantine != (unsigned long )((void *)0)) {
#line 2025
    IgnoreHostStatus = 1;
#line 2026
    MinQueueAge = (time_t )0;
  } else
#line 2021
  if ((unsigned long )QueueLimitRecipient != (unsigned long )((void *)0)) {
#line 2025
    IgnoreHostStatus = 1;
#line 2026
    MinQueueAge = (time_t )0;
  }
#line 2034
  endgrp = (int )WorkGrp[wgrp].wg_curqgrp;
  domorework: 
  {
#line 2043
  now = curtime();
  }
  {
#line 2044
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2051
    qgrp = (int )(*(WorkGrp[wgrp].wg_qgs + WorkGrp[wgrp].wg_curqgrp))->qg_index;
#line 2052
    WorkGrp[wgrp].wg_curqgrp += (int volatile   )1;
#line 2053
    WorkGrp[wgrp].wg_curqgrp %= WorkGrp[wgrp].wg_numqgrp;
#line 2054
    if ((flags & 16) != 0) {
#line 2057
      goto while_break___0;
    } else
#line 2054
    if ((Queue[qgrp])->qg_nextrun <= now) {
#line 2054
      if ((Queue[qgrp])->qg_nextrun != -1L) {
#line 2057
        goto while_break___0;
      }
    }
#line 2058
    if (endgrp == (int )WorkGrp[wgrp].wg_curqgrp) {
#line 2060
      e->e_id = (char *)((void *)0);
#line 2061
      if ((flags & 1) != 0) {
        {
#line 2062
        finis(1, 1, (int volatile   )ExitStat);
        }
      }
#line 2063
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2067
  qdir = (Queue[qgrp])->qg_curnum;
#line 2078
  if ((int )(Queue[qgrp])->qg_nice > 0) {
    {
#line 2079
    nice((int )(Queue[qgrp])->qg_nice);
    }
  }
  {
#line 2083
  tmp___4 = qid_printqueue(qgrp, qdir);
#line 2083
  sm_setproctitle(1, CurEnv, "running queue: %s", tmp___4);
  }
#line 2086
  if (LogLevel > 69) {
    {
#line 2087
    tmp___5 = qid_printqueue(qgrp, qdir);
#line 2087
    sm_syslog(7, "*~*", "runqueue %s, pid=%d, forkflag=%d", tmp___5, CurrentPid, (flags & 1) != 0);
    }
  } else
#line 2086
  if ((int )tTdvect[63] >= 99) {
    {
#line 2087
    tmp___5 = qid_printqueue(qgrp, qdir);
#line 2087
    sm_syslog(7, "*~*", "runqueue %s, pid=%d, forkflag=%d", tmp___5, CurrentPid, (flags & 1) != 0);
    }
  }
#line 2099
  i = 0;
  {
#line 2099
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2099
    if (! (i < (Queue[qgrp])->qg_numqueues)) {
#line 2099
      goto while_break___1;
    }
    {
#line 2101
    h = gatherq(qgrp, qdir, 0, & full, & more);
    }
#line 2103
    if (ShmId != -2) {
#line 2104
      (QShm + ((Queue[qgrp])->qg_qpaths + qdir)->qp_idx)->qs_entries = h;
    }
#line 2107
    if (! more) {
#line 2110
      qdir ++;
#line 2111
      qdir %= (Queue[qgrp])->qg_numqueues;
    }
#line 2115
    if (full) {
#line 2116
      goto while_break___1;
    }
#line 2099
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2120
  njobs = sortq((Queue[qgrp])->qg_maxlist);
#line 2121
  (Queue[qgrp])->qg_curnum = qdir;
  }
#line 2124
  if (! Verbose) {
#line 2124
    if ((Queue[qgrp])->qg_flags[102UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 102UL % (8UL * sizeof(int )))) {
#line 2140
      maxrunners = (Queue[qgrp])->qg_maxqrun;
#line 2143
      if (maxrunners > njobs) {
#line 2144
        maxrunners = njobs;
      }
#line 2145
      loop = 0;
      {
#line 2145
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2145
        if (! (loop < maxrunners)) {
#line 2145
          goto while_break___2;
        }
        {
#line 2155
        closemaps(0);
#line 2157
        pid___0 = fork();
        }
#line 2158
        if (pid___0 < 0) {
          {
#line 2160
          syserr("run_work_group: cannot fork");
          }
#line 2161
          return (0);
        } else
#line 2163
        if (pid___0 > 0) {
          {
#line 2166
          mci_flush(0, (struct mailer_con_info *)((void *)0));
#line 2176
          WorkQ = WorkQ->w_next;
#line 2177
          sequenceno ++;
#line 2179
          proc_list_add(pid___0, (char *)"Queue child runner process", 3, 0, -1, (union bigsockaddr *)((void *)0));
          }
#line 2183
          if ((unsigned long )WorkQ == (unsigned long )((void *)0)) {
#line 2184
            goto while_break___2;
          }
        } else {
          {
#line 2189
          RestartRequest = (char */* volatile  */)((void *)0);
#line 2190
          RestartWorkGroup = (bool volatile   )0;
#line 2191
          ShutdownRequest = (char */* volatile  */)((void *)0);
#line 2192
          PendingSignal = (int volatile   )0;
#line 2193
          CurrentPid = getpid();
#line 2194
          close_sendmail_pid();
#line 2203
          sm_exc_newthread(& fatal_error);
          }
#line 2219
          if ((int )OpMode == 115) {
            {
#line 2223
            proc_list_clear();
#line 2224
            sm_releasesignal(17);
#line 2225
            sm_signal(17, (void (*)(int  ))0);
            }
          } else
#line 2219
          if ((int )OpMode == 100) {
            {
#line 2223
            proc_list_clear();
#line 2224
            sm_releasesignal(17);
#line 2225
            sm_signal(17, (void (*)(int  ))0);
            }
          } else
#line 2219
          if (MaxQueueChildren > 0) {
            {
#line 2223
            proc_list_clear();
#line 2224
            sm_releasesignal(17);
#line 2225
            sm_signal(17, (void (*)(int  ))0);
            }
          }
          {
#line 2229
          OnlyOneError = 0;
#line 2229
          QuickAbort = OnlyOneError;
#line 2230
          runner_work(e, sequenceno, 1, maxrunners, njobs);
#line 2234
          finis(1, 1, (int volatile   )ExitStat);
          }
        }
#line 2145
        loop ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2239
      sm_releasesignal(17);
      }
      {
#line 2250
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2250
        if (! (CurChildren > (int volatile   )0)) {
#line 2250
          goto while_break___3;
        }
        {
#line 2255
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 2255
          ret = sm_wait(& status);
          }
#line 2255
          if (! (ret <= 0)) {
#line 2255
            goto while_break___4;
          }
#line 2256
          goto while_continue___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 2257
        proc_list_drop(ret, status, (int *)((void *)0));
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 2124
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2260
  if ((Queue[qgrp])->qg_maxqrun > 0) {
    {
#line 2268
    runner_work(e, sequenceno, 0, 1, njobs);
    }
  } else
#line 2260
  if ((flags & 8) != 0) {
    {
#line 2268
    runner_work(e, sequenceno, 0, 1, njobs);
    }
  }
  {
#line 2272
  sm_rpool_free(rpool);
#line 2273
  QueueEnvelope.e_rpool = (SM_RPOOL_T *)((void *)0);
  }
#line 2276
  if (endgrp != (int )WorkGrp[wgrp].wg_curqgrp) {
    {
#line 2278
    rpool = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 2279
    e = newenvelope(& QueueEnvelope, CurEnv, rpool);
#line 2280
    e->e_flags = BlankEnvelope.e_flags;
    }
#line 2281
    goto domorework;
  }
#line 2285
  if ((flags & 4) != 0) {
    {
#line 2287
    sequenceno = 1;
#line 2288
    tmp___6 = qid_printqueue(qgrp, qdir);
#line 2288
    sm_setproctitle(1, CurEnv, "running queue: %s", tmp___6);
#line 2297
    closemaps(1);
#line 2300
    mci_flush(1, (struct mailer_con_info *)((void *)0));
#line 2303
    rmexpstab();
    }
#line 2307
    if ((unsigned long )FallbackMX != (unsigned long )((void *)0)) {
      {
#line 2308
      getfallbackmxrr(FallbackMX);
      }
    }
    {
#line 2313
    _udbx_close();
    }
#line 2317
    if (SmHeapCheck.debug_level >= 2U) {
#line 2317
      if (SmHeapCheck.debug_level != 4294967295U) {
#line 2317
        goto _L___0;
      } else {
        {
#line 2317
        tmp___9 = sm_debug_loadactive(& SmHeapCheck, 2);
        }
#line 2317
        if (tmp___9) {
          _L___0: /* CIL Label */ 
          {
#line 2317
          tmp___10 = access("memdump", 0);
          }
#line 2317
          if (tmp___10 == 0) {
            {
#line 2323
            remove("memdump");
#line 2324
            out = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)"memdump.out",
                             4, (void const   *)((void *)0));
            }
#line 2326
            if ((unsigned long )out != (unsigned long )((void *)0)) {
              {
#line 2328
              sm_io_fprintf(out, -2, "----------------------\n");
              }
#line 2329
              if (SmHeapCheck.debug_level == 4294967295U) {
                {
#line 2329
                tmp___7 = sm_debug_loadlevel(& SmHeapCheck);
#line 2329
                tmp___8 = (SM_ATOMIC_UINT_T )tmp___7;
                }
              } else {
#line 2329
                tmp___8 = SmHeapCheck.debug_level;
              }
              {
#line 2329
              sm_heap_report(out, (int )(tmp___8 - 1U));
#line 2331
              sm_io_close(out, -2);
              }
            }
          }
        }
      }
    }
#line 2337
    if (njobs == 0) {
#line 2337
      if (WorkGrp[wgrp].wg_lowqintvl < (time_t volatile   )5) {
        {
#line 2338
        sleep(5U);
        }
      } else {
#line 2337
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2339
    if (WorkGrp[wgrp].wg_lowqintvl <= (time_t volatile   )0) {
#line 2340
      if (QueueIntvl > 0L) {
#line 2340
        tmp___11 = QueueIntvl;
      } else {
#line 2340
        tmp___11 = (time_t )5;
      }
      {
#line 2340
      sleep((unsigned int )tmp___11);
      }
    } else {
      {
#line 2342
      sleep((unsigned int )WorkGrp[wgrp].wg_lowqintvl);
      }
    }
#line 2353
    if (njobs == 0) {
      {
#line 2354
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 2354
        now = curtime();
        }
#line 2354
        if (Current_LA_time < now - 30L) {
          {
#line 2354
          sm_getla();
#line 2354
          Current_LA_time = now;
          }
        }
#line 2354
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 2355
    rpool = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 2356
    e = newenvelope(& QueueEnvelope, CurEnv, rpool);
#line 2357
    e->e_flags = BlankEnvelope.e_flags;
    }
#line 2358
    goto domorework;
  }
#line 2362
  e->e_id = (char *)((void *)0);
#line 2363
  if ((flags & 1) != 0) {
    {
#line 2364
    finis(1, 1, (int volatile   )ExitStat);
    }
  }
#line 2366
  return (1);
}
}
#line 2373 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
bool doqueuerun(void) 
{ 


  {
#line 2376
  return ((bool )DoQueueRun);
}
}
#line 2403 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void runqueueevent(int ignore ) 
{ 
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 2407
  tmp = __errno_location();
#line 2407
  save_errno = *tmp;
#line 2414
  DoQueueRun = (bool volatile   )1;
#line 2420
  tmp___0 = __errno_location();
#line 2420
  *tmp___0 = save_errno;
#line 2421
  tmp___2 = __errno_location();
  }
#line 2421
  if (*tmp___2 == 4) {
    {
#line 2422
    tmp___1 = __errno_location();
#line 2422
    *tmp___1 = 110;
    }
  }
#line 2423
  return;
}
}
#line 2454 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static WORK *WorkList  =    (WORK *)((void *)0);
#line 2455 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int WorkListSize  =    0;
#line 2456 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int WorkListCount  =    0;
#line 2458 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int gatherq(int qgrp , int qdir , bool doall , bool *full , bool *more ) 
{ 
  register struct dirent *d ;
  register WORK *w ;
  register char *p ;
  DIR *f ;
  int i ;
  int num_ent ;
  int wn ;
  QUEUE_CHAR *check ;
  char qd[4096] ;
  char qf[4096] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  SM_FILE_T *cf___0 ;
  int qfver ;
  char lbuf[257] ;
  struct stat sbuf ;
  size_t tmp___6 ;
  bool tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  bool tmp___14 ;
  int *tmp___15 ;
  char const   *tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  bool tmp___19 ;
  int tmp___20 ;
  int c ;
  time_t age ;
  bool tmp___21 ;
  bool tmp___22 ;
  bool tmp___23 ;
  time_t tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  char *tmp___27 ;
  bool tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;

  {
#line 2476
  wn = WorkListCount - 1;
#line 2477
  num_ent = 0;
#line 2478
  if (qdir == -1) {
    {
#line 2479
    sm_strlcpy(qd, ".", (ssize_t )sizeof(qd));
    }
  } else {
#line 2481
    if (((int )((Queue[qgrp])->qg_qpaths + qdir)->qp_subdirs & 2) != 0) {
#line 2481
      tmp = "/qf";
    } else {
#line 2481
      tmp = "";
    }
    {
#line 2481
    sm_strlcpyn(qd, (ssize_t )sizeof(qd), 2, ((Queue[qgrp])->qg_qpaths + qdir)->qp_name,
                tmp);
    }
  }
#line 2487
  if ((int )tTdvect[41] >= 1) {
    {
#line 2489
    sm_dprintf((char *)"gatherq:\n");
#line 2491
    check = QueueLimitId;
    }
    {
#line 2492
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2492
      if (! ((unsigned long )check != (unsigned long )((void *)0))) {
#line 2492
        goto while_break;
      }
#line 2494
      if (check->queue_negate) {
#line 2494
        tmp___0 = "!";
      } else {
#line 2494
        tmp___0 = "";
      }
      {
#line 2494
      sm_dprintf((char *)"\tQueueLimitId = %s%s\n", tmp___0, check->queue_match);
#line 2497
      check = check->queue_next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2500
    check = QueueLimitSender;
    {
#line 2501
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2501
      if (! ((unsigned long )check != (unsigned long )((void *)0))) {
#line 2501
        goto while_break___0;
      }
#line 2503
      if (check->queue_negate) {
#line 2503
        tmp___1 = "!";
      } else {
#line 2503
        tmp___1 = "";
      }
      {
#line 2503
      sm_dprintf((char *)"\tQueueLimitSender = %s%s\n", tmp___1, check->queue_match);
#line 2506
      check = check->queue_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2509
    check = QueueLimitRecipient;
    {
#line 2510
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2510
      if (! ((unsigned long )check != (unsigned long )((void *)0))) {
#line 2510
        goto while_break___1;
      }
#line 2512
      if (check->queue_negate) {
#line 2512
        tmp___2 = "!";
      } else {
#line 2512
        tmp___2 = "";
      }
      {
#line 2512
      sm_dprintf((char *)"\tQueueLimitRecipient = %s%s\n", tmp___2, check->queue_match);
#line 2515
      check = check->queue_next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2518
    if (QueueMode == 81) {
#line 2520
      check = QueueLimitQuarantine;
      {
#line 2521
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2521
        if (! ((unsigned long )check != (unsigned long )((void *)0))) {
#line 2521
          goto while_break___2;
        }
#line 2523
        if (check->queue_negate) {
#line 2523
          tmp___3 = "!";
        } else {
#line 2523
          tmp___3 = "";
        }
        {
#line 2523
        sm_dprintf((char *)"\tQueueLimitQuarantine = %s%s\n", tmp___3, check->queue_match);
#line 2526
        check = check->queue_next;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 2532
  f = opendir((char const   *)(qd));
  }
#line 2533
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 2535
    tmp___4 = qid_printqueue(qgrp, qdir);
#line 2535
    syserr("gatherq: cannot open \"%s\"", tmp___4);
    }
#line 2537
    if ((unsigned long )full != (unsigned long )((void *)0)) {
#line 2538
      if (WorkListCount >= MaxQueueRun) {
#line 2538
        if (MaxQueueRun > 0) {
#line 2538
          tmp___5 = 1;
        } else {
#line 2538
          tmp___5 = 0;
        }
      } else {
#line 2538
        tmp___5 = 0;
      }
#line 2538
      *full = tmp___5;
    }
#line 2539
    if ((unsigned long )more != (unsigned long )((void *)0)) {
#line 2540
      *more = 0;
    }
#line 2541
    return (0);
  }
  {
#line 2548
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 2548
    d = readdir(f);
    }
#line 2548
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 2548
      goto while_break___3;
    }
#line 2551
    qfver = 0;
#line 2555
    if ((int )tTdvect[41] >= 50) {
      {
#line 2556
      sm_dprintf((char *)"gatherq: checking %s..", d->d_name);
      }
    }
#line 2559
    if (QueueMode == 32) {
#line 2559
      if ((int )d->d_name[0] == 113) {
#line 2559
        goto _L___0;
      } else {
#line 2559
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 2559
    if (QueueMode == 81) {
#line 2559
      if ((int )d->d_name[0] == 104) {
#line 2559
        goto _L___0;
      } else {
#line 2559
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2559
    if (QueueMode == 76) {
#line 2559
      if ((int )d->d_name[0] == 81) {
        _L___0: /* CIL Label */ 
#line 2559
        if (! ((int )d->d_name[1] == 102)) {
#line 2559
          goto _L___1;
        }
      } else {
#line 2559
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 2567
      if ((int )tTdvect[41] >= 50) {
        {
#line 2568
        sm_dprintf((char *)"  skipping\n");
        }
      }
#line 2569
      goto while_continue___3;
    }
#line 2571
    if ((int )tTdvect[41] >= 50) {
      {
#line 2572
      sm_dprintf((char *)"\n");
      }
    }
    {
#line 2574
    tmp___6 = strlen((char const   *)(d->d_name));
    }
#line 2574
    if (tmp___6 >= 21U) {
#line 2576
      if (Verbose) {
        {
#line 2577
        sm_io_fprintf(& SmIoF[1], -2, "gatherq: %s too long, %d max characters\n",
                      d->d_name, 21);
        }
      }
#line 2580
      if (LogLevel > 0) {
        {
#line 2581
        sm_syslog(1, "*~*", "gatherq: %s too long, %d max characters", d->d_name,
                  21);
        }
      }
#line 2584
      goto while_continue___3;
    }
#line 2587
    check = QueueLimitId;
    {
#line 2588
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2588
      if (! ((unsigned long )check != (unsigned long )((void *)0))) {
#line 2588
        goto while_break___4;
      }
      {
#line 2590
      tmp___7 = strcontainedin(0, check->queue_match, d->d_name);
      }
#line 2590
      if (tmp___7 != check->queue_negate) {
#line 2592
        goto while_break___4;
      } else {
#line 2594
        check = check->queue_next;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2596
    if ((unsigned long )QueueLimitId != (unsigned long )((void *)0)) {
#line 2596
      if ((unsigned long )check == (unsigned long )((void *)0)) {
#line 2597
        goto while_continue___3;
      }
    }
#line 2600
    wn ++;
#line 2600
    if (wn >= MaxQueueRun) {
#line 2600
      if (MaxQueueRun > 0) {
#line 2602
        if (wn == MaxQueueRun) {
#line 2602
          if (LogLevel > 0) {
            {
#line 2603
            tmp___8 = qid_printqueue(qgrp, qdir);
#line 2603
            sm_syslog(4, "*~*", "WorkList for %s maxed out at %d", tmp___8, MaxQueueRun);
            }
          }
        }
#line 2607
        if (doall) {
#line 2608
          goto while_continue___3;
        }
#line 2609
        goto while_break___3;
      }
    }
#line 2611
    if (wn >= WorkListSize) {
      {
#line 2613
      grow_wlist(qgrp, qdir);
      }
#line 2614
      if (wn >= WorkListSize) {
#line 2615
        goto while_continue___3;
      }
    }
#line 2617
    if (wn >= 0) {
#line 2617
      tmp___9 = 1;
    } else {
      {
#line 2617
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                  2617, "SM_ASSERT(wn >= 0) failed");
#line 2617
      tmp___9 = 0;
      }
    }
    {
#line 2618
    w = WorkList + wn;
#line 2620
    sm_strlcpyn(qf, (ssize_t )sizeof(qf), 3, qd, "/", d->d_name);
#line 2621
    tmp___12 = stat((char const   */* __restrict  */)(qf), (struct stat */* __restrict  */)(& sbuf));
    }
#line 2621
    if (tmp___12 < 0) {
      {
#line 2623
      tmp___11 = __errno_location();
      }
#line 2623
      if (*tmp___11 != 2) {
        {
#line 2624
        tmp___10 = qid_printqueue(qgrp, qdir);
#line 2624
        sm_syslog(6, "*~*", "gatherq: can\'t stat %s/%s", tmp___10, d->d_name);
        }
      }
#line 2628
      wn --;
#line 2629
      goto while_continue___3;
    }
#line 2631
    if (! ((sbuf.st_mode & 32768U) != 0U)) {
#line 2634
      if ((int )d->d_name[0] == 100) {
#line 2634
        goto _L___4;
      } else
#line 2634
      if ((int )d->d_name[0] == 113) {
#line 2634
        goto _L___4;
      } else
#line 2634
      if ((int )d->d_name[0] == 104) {
#line 2634
        goto _L___4;
      } else
#line 2634
      if ((int )d->d_name[0] == 81) {
#line 2634
        goto _L___4;
      } else
#line 2634
      if ((int )d->d_name[0] == 120) {
        _L___4: /* CIL Label */ 
#line 2634
        if ((int )d->d_name[1] == 102) {
#line 2634
          if (! ((int )d->d_name[2] == 0)) {
            {
#line 2640
            tmp___13 = qid_printqueue(qgrp, qdir);
#line 2640
            syserr("gatherq: %s/%s is not a regular file", tmp___13, d->d_name);
            }
          }
        } else {
          {
#line 2640
          tmp___13 = qid_printqueue(qgrp, qdir);
#line 2640
          syserr("gatherq: %s/%s is not a regular file", tmp___13, d->d_name);
          }
        }
      } else {
        {
#line 2640
        tmp___13 = qid_printqueue(qgrp, qdir);
#line 2640
        syserr("gatherq: %s/%s is not a regular file", tmp___13, d->d_name);
        }
      }
#line 2642
      wn --;
#line 2643
      goto while_continue___3;
    }
#line 2647
    if (QueueSortOrder == 3) {
#line 2647
      goto _L___5;
    } else
#line 2647
    if (QueueSortOrder == 5) {
#line 2647
      goto _L___5;
    } else
#line 2647
    if (QueueSortOrder == 4) {
      _L___5: /* CIL Label */ 
#line 2647
      if ((unsigned long )QueueLimitQuarantine == (unsigned long )((void *)0)) {
#line 2647
        if ((unsigned long )QueueLimitSender == (unsigned long )((void *)0)) {
#line 2647
          if ((unsigned long )QueueLimitRecipient == (unsigned long )((void *)0)) {
            {
#line 2654
            w->w_qgrp = qgrp;
#line 2655
            w->w_qdir = qdir;
#line 2656
            w->w_name = newstr((char const   *)(d->d_name));
#line 2657
            w->w_host = (char *)((void *)0);
#line 2658
            tmp___14 = 0;
#line 2658
            w->w_tooyoung = tmp___14;
#line 2658
            w->w_lock = tmp___14;
#line 2659
            w->w_pri = 0L;
#line 2660
            w->w_ctime = (time_t )0;
#line 2661
            w->w_mtime = sbuf.st_mtim.tv_sec;
#line 2662
            num_ent ++;
            }
#line 2663
            goto while_continue___3;
          }
        }
      }
    }
    {
#line 2667
    cf___0 = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)(qf),
                        2, (void const   *)((void *)0));
    }
#line 2669
    if ((unsigned long )cf___0 == (unsigned long )((void *)0)) {
#line 2669
      if ((int )OpMode != 112) {
#line 2672
        if ((int )tTdvect[41] >= 2) {
          {
#line 2673
          tmp___15 = __errno_location();
#line 2673
          tmp___16 = sm_errstring(*tmp___15);
#line 2673
          sm_dprintf((char *)"gatherq: cannot open %s: %s\n", d->d_name, tmp___16);
          }
        }
        {
#line 2675
        tmp___17 = __errno_location();
#line 2675
        *tmp___17 = 0;
#line 2676
        wn --;
        }
#line 2677
        goto while_continue___3;
      }
    }
    {
#line 2679
    w->w_qgrp = qgrp;
#line 2680
    w->w_qdir = qdir;
#line 2681
    w->w_name = newstr((char const   *)(d->d_name));
#line 2682
    w->w_host = (char *)((void *)0);
    }
#line 2683
    if ((unsigned long )cf___0 != (unsigned long )((void *)0)) {
      {
#line 2685
      tmp___18 = sm_io_getinfo(cf___0, 3, (void *)0);
#line 2685
      tmp___19 = lockfile(tmp___18, w->w_name, (char *)((void *)0), 5);
      }
#line 2685
      if (tmp___19) {
#line 2685
        tmp___20 = 0;
      } else {
#line 2685
        tmp___20 = 1;
      }
#line 2685
      w->w_lock = tmp___20;
    }
#line 2690
    w->w_tooyoung = 0;
#line 2693
    w->w_pri = 2147483647L;
#line 2694
    w->w_ctime = (time_t )0;
#line 2695
    w->w_mtime = sbuf.st_mtim.tv_sec;
#line 2698
    i = 3;
#line 2699
    if (QueueSortOrder == 1) {
#line 2706
      i |= 16;
    }
#line 2708
    if ((unsigned long )QueueLimitSender != (unsigned long )((void *)0)) {
#line 2709
      i |= 8;
    }
#line 2710
    if ((unsigned long )QueueLimitRecipient != (unsigned long )((void *)0)) {
#line 2711
      i |= 4;
    }
#line 2712
    if ((unsigned long )QueueLimitQuarantine != (unsigned long )((void *)0)) {
#line 2713
      i |= 64;
    }
    {
#line 2714
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2714
      if ((unsigned long )cf___0 != (unsigned long )((void *)0)) {
#line 2714
        if (i != 0) {
          {
#line 2714
          tmp___27 = sm_io_fgets(cf___0, -2, lbuf, (int )sizeof(lbuf));
          }
#line 2714
          if (! ((unsigned long )tmp___27 != (unsigned long )((void *)0))) {
#line 2714
            goto while_break___5;
          }
        } else {
#line 2714
          goto while_break___5;
        }
      } else {
#line 2714
        goto while_break___5;
      }
      {
#line 2721
      p = strchr((char const   *)(lbuf), '\n');
      }
#line 2722
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2723
        *p = (char )'\000';
      } else {
        {
#line 2727
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 2727
          c = sm_io_getc(cf___0, -2);
          }
#line 2727
          if (c != -1) {
#line 2727
            if (! (c != 10)) {
#line 2727
              goto while_break___6;
            }
          } else {
#line 2727
            goto while_break___6;
          }
#line 2729
          goto while_continue___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 2734
      if ((int )lbuf[0] == 86) {
#line 2734
        goto case_86;
      }
#line 2738
      if ((int )lbuf[0] == 80) {
#line 2738
        goto case_80;
      }
#line 2743
      if ((int )lbuf[0] == 84) {
#line 2743
        goto case_84;
      }
#line 2748
      if ((int )lbuf[0] == 113) {
#line 2748
        goto case_113;
      }
#line 2781
      if ((int )lbuf[0] == 82) {
#line 2781
        goto case_82;
      }
#line 2824
      if ((int )lbuf[0] == 83) {
#line 2824
        goto case_83;
      }
#line 2840
      if ((int )lbuf[0] == 75) {
#line 2840
        goto case_75;
      }
#line 2847
      if ((int )lbuf[0] == 78) {
#line 2847
        goto case_78;
      }
#line 2732
      goto switch_break;
      case_86: /* CIL Label */ 
      {
#line 2735
      qfver = atoi((char const   *)(& lbuf[1]));
      }
#line 2736
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 2739
      w->w_pri = atol((char const   *)(& lbuf[1]));
#line 2740
      i &= -2;
      }
#line 2741
      goto switch_break;
      case_84: /* CIL Label */ 
      {
#line 2744
      w->w_ctime = atol((char const   *)(& lbuf[1]));
#line 2745
      i &= -3;
      }
#line 2746
      goto switch_break;
      case_113: /* CIL Label */ 
#line 2749
      if (QueueMode != 81) {
#line 2749
        if (QueueMode != 76) {
#line 2752
          if ((int )tTdvect[41] >= 49) {
            {
#line 2753
            sm_dprintf((char *)"%s not marked as quarantined but has a \'q\' line\n",
                       w->w_name);
            }
          }
#line 2755
          i |= 32;
        } else {
#line 2749
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 2757
      if (QueueMode == 81) {
#line 2759
        if ((unsigned long )QueueLimitQuarantine == (unsigned long )((void *)0)) {
#line 2761
          i &= -65;
#line 2762
          goto switch_break;
        }
#line 2764
        p = & lbuf[1];
#line 2765
        check = QueueLimitQuarantine;
        {
#line 2766
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2766
          if (! ((unsigned long )check != (unsigned long )((void *)0))) {
#line 2766
            goto while_break___7;
          }
          {
#line 2768
          tmp___21 = strcontainedin(0, check->queue_match, p);
          }
#line 2768
          if (tmp___21 != check->queue_negate) {
#line 2772
            goto while_break___7;
          } else {
#line 2774
            check = check->queue_next;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
#line 2776
        if ((unsigned long )check != (unsigned long )((void *)0)) {
#line 2777
          i &= -65;
        }
      }
#line 2779
      goto switch_break;
      case_82: /* CIL Label */ 
#line 2782
      if ((unsigned long )w->w_host == (unsigned long )((void *)0)) {
        {
#line 2782
        p = strrchr((char const   *)(& lbuf[1]), '@');
        }
#line 2782
        if ((unsigned long )p != (unsigned long )((void *)0)) {
          {
#line 2790
          w->w_host = strrev(p + 1);
#line 2791
          makelower(w->w_host);
#line 2792
          i &= -17;
          }
        }
      }
#line 2794
      if ((unsigned long )QueueLimitRecipient == (unsigned long )((void *)0)) {
#line 2796
        i &= -5;
#line 2797
        goto switch_break;
      }
#line 2799
      if (qfver > 0) {
        {
#line 2801
        p = strchr((char const   *)(& lbuf[1]), ':');
        }
#line 2802
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2803
          p = & lbuf[1];
        } else {
#line 2805
          p ++;
        }
      } else {
#line 2808
        p = & lbuf[1];
      }
#line 2809
      check = QueueLimitRecipient;
      {
#line 2810
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2810
        if (! ((unsigned long )check != (unsigned long )((void *)0))) {
#line 2810
          goto while_break___8;
        }
        {
#line 2812
        tmp___22 = strcontainedin(1, check->queue_match, p);
        }
#line 2812
        if (tmp___22 != check->queue_negate) {
#line 2816
          goto while_break___8;
        } else {
#line 2818
          check = check->queue_next;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2820
      if ((unsigned long )check != (unsigned long )((void *)0)) {
#line 2821
        i &= -5;
      }
#line 2822
      goto switch_break;
      case_83: /* CIL Label */ 
#line 2825
      check = QueueLimitSender;
      {
#line 2826
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 2826
        if (! ((unsigned long )check != (unsigned long )((void *)0))) {
#line 2826
          goto while_break___9;
        }
        {
#line 2828
        tmp___23 = strcontainedin(1, check->queue_match, & lbuf[1]);
        }
#line 2828
        if (tmp___23 != check->queue_negate) {
#line 2832
          goto while_break___9;
        } else {
#line 2834
          check = check->queue_next;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 2836
      if ((unsigned long )check != (unsigned long )((void *)0)) {
#line 2837
        i &= -9;
      }
#line 2838
      goto switch_break;
      case_75: /* CIL Label */ 
      {
#line 2841
      tmp___24 = curtime();
#line 2841
      tmp___25 = atol((char const   *)(& lbuf[1]));
#line 2841
      age = tmp___24 - tmp___25;
      }
#line 2842
      if (age >= 0L) {
#line 2842
        if (MinQueueAge > 0L) {
#line 2842
          if (age < MinQueueAge) {
#line 2844
            w->w_tooyoung = 1;
          }
        }
      }
#line 2845
      goto switch_break;
      case_78: /* CIL Label */ 
      {
#line 2848
      tmp___26 = atol((char const   *)(& lbuf[1]));
      }
#line 2848
      if (tmp___26 == 0L) {
#line 2849
        w->w_tooyoung = 0;
      }
#line 2850
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2853
    if ((unsigned long )cf___0 != (unsigned long )((void *)0)) {
      {
#line 2854
      sm_io_close(cf___0, -2);
      }
    }
#line 2856
    if (! doall) {
      {
#line 2856
      tmp___28 = shouldqueue(w->w_pri, w->w_ctime);
      }
#line 2856
      if (tmp___28) {
#line 2856
        goto _L___7;
      } else
#line 2856
      if (w->w_tooyoung) {
#line 2856
        goto _L___7;
      } else {
#line 2856
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 2856
    if ((i & 32) != 0) {
#line 2856
      goto _L___7;
    } else
#line 2856
    if ((i & 64) != 0) {
#line 2856
      goto _L___7;
    } else
#line 2856
    if ((i & 12) != 0) {
      _L___7: /* CIL Label */ 
#line 2863
      if ((int )tTdvect[41] >= 49) {
        {
#line 2864
        sm_dprintf((char *)"skipping %s (%x)\n", w->w_name, i);
        }
      }
      {
#line 2865
      sm_free_tagged((void *)w->w_name, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     2865);
      }
#line 2866
      if ((unsigned long )w->w_host != (unsigned long )((void *)0)) {
        {
#line 2867
        sm_free_tagged((void *)w->w_host, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                       2867);
        }
      }
#line 2868
      wn --;
    } else {
#line 2871
      num_ent ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2873
  closedir(f);
#line 2874
  wn ++;
#line 2876
  i = wn - WorkListCount;
  }
#line 2877
  if (num_ent < WorkListSize) {
#line 2877
    tmp___29 = num_ent;
  } else {
#line 2877
    tmp___29 = WorkListSize;
  }
#line 2877
  WorkListCount += tmp___29;
#line 2879
  if ((unsigned long )more != (unsigned long )((void *)0)) {
#line 2880
    *more = WorkListCount < wn;
  }
#line 2882
  if ((unsigned long )full != (unsigned long )((void *)0)) {
#line 2883
    if (wn >= MaxQueueRun) {
#line 2883
      if (MaxQueueRun > 0) {
#line 2883
        tmp___30 = 1;
      } else {
#line 2883
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 2883
    if ((unsigned long )WorkList == (unsigned long )((void *)0)) {
#line 2883
      if (wn > 0) {
#line 2883
        tmp___30 = 1;
      } else {
#line 2883
        tmp___30 = 0;
      }
    } else {
#line 2883
      tmp___30 = 0;
    }
#line 2883
    *full = tmp___30;
  }
#line 2886
  return (i);
}
}
#line 2908 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int sortq(int max ) 
{ 
  register int i ;
  register WORK *w ;
  int wc ;
  WORK *nw ;
  int tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 2914
  wc = WorkListCount;
#line 2916
  if ((unsigned long )WorkQ != (unsigned long )((void *)0)) {
#line 2921
    w = WorkQ;
    {
#line 2921
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2921
      if (! ((unsigned long )w != (unsigned long )((void *)0))) {
#line 2921
        goto while_break;
      }
      {
#line 2923
      nw = w->w_next;
#line 2924
      sm_free_tagged((void *)w->w_name, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     2924);
      }
#line 2925
      if ((unsigned long )w->w_host != (unsigned long )((void *)0)) {
        {
#line 2926
        sm_free_tagged((void *)w->w_host, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                       2926);
        }
      }
      {
#line 2927
      sm_free_tagged((void *)((char *)w), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     2927);
#line 2921
      w = nw;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2929
    WorkQ = (WORK *)((void *)0);
  }
#line 2932
  if ((unsigned long )WorkList == (unsigned long )((void *)0)) {
#line 2933
    return (0);
  } else
#line 2932
  if (wc <= 0) {
#line 2933
    return (0);
  }
#line 2942
  if (QueueSortOrder == 1) {
    {
#line 2949
    qsort((void *)((char *)WorkList), (size_t )wc, (size_t )sizeof(*WorkList), (int (*)(void const   * ,
                                                                                        void const   * ))(& workcmpf1));
#line 2956
    i = 0;
    }
    {
#line 2957
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2957
      if (! (i < wc)) {
#line 2957
        goto while_break___0;
      }
#line 2959
      if (! (WorkList + i)->w_lock) {
#line 2961
        i ++;
#line 2962
        goto while_continue___0;
      }
#line 2964
      w = WorkList + i;
      {
#line 2965
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2965
        i ++;
#line 2965
        if (! (i < wc)) {
#line 2965
          goto while_break___1;
        }
#line 2967
        if ((unsigned long )(WorkList + i)->w_host == (unsigned long )((void *)0)) {
#line 2967
          if ((unsigned long )w->w_host == (unsigned long )((void *)0)) {
#line 2969
            (WorkList + i)->w_lock = 1;
          } else {
#line 2967
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 2970
        if ((unsigned long )(WorkList + i)->w_host != (unsigned long )((void *)0)) {
#line 2970
          if ((unsigned long )w->w_host != (unsigned long )((void *)0)) {
            {
#line 2970
            tmp = sm_strcasecmp((char const   *)(WorkList + i)->w_host, (char const   *)w->w_host);
            }
#line 2970
            if (tmp == 0) {
#line 2974
              (WorkList + i)->w_lock = 1;
            } else {
#line 2976
              goto while_break___1;
            }
          } else {
#line 2976
            goto while_break___1;
          }
        } else {
#line 2976
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2985
    qsort((void *)((char *)WorkList), (size_t )wc, (size_t )sizeof(*WorkList), (int (*)(void const   * ,
                                                                                        void const   * ))(& workcmpf2));
    }
  } else
#line 2987
  if (QueueSortOrder == 2) {
    {
#line 2993
    qsort((void *)((char *)WorkList), (size_t )wc, (size_t )sizeof(*WorkList), (int (*)(void const   * ,
                                                                                        void const   * ))(& workcmpf3));
    }
  } else
#line 2995
  if (QueueSortOrder == 3) {
    {
#line 3001
    qsort((void *)((char *)WorkList), (size_t )wc, (size_t )sizeof(*WorkList), (int (*)(void const   * ,
                                                                                        void const   * ))(& workcmpf4));
    }
  } else
#line 3003
  if (QueueSortOrder == 4) {
    {
#line 3011
    tmp___0 = random();
#line 3011
    randi = (int )(tmp___0 % 21L);
    }
#line 3012
    if (randi < 2) {
#line 3013
      randi = 3;
    }
    {
#line 3014
    qsort((void *)((char *)WorkList), (size_t )wc, (size_t )sizeof(*WorkList), (int (*)(void const   * ,
                                                                                        void const   * ))(& workcmpf5));
    }
  } else
#line 3016
  if (QueueSortOrder == 5) {
    {
#line 3023
    qsort((void *)((char *)WorkList), (size_t )wc, (size_t )sizeof(*WorkList), (int (*)(void const   * ,
                                                                                        void const   * ))(& workcmpf6));
    }
  } else
#line 3036
  if (QueueSortOrder == 0) {
    {
#line 3042
    qsort((void *)((char *)WorkList), (size_t )wc, (size_t )sizeof(*WorkList), (int (*)(void const   * ,
                                                                                        void const   * ))(& workcmpf0));
    }
  }
#line 3047
  if (wc > max) {
#line 3047
    if (max > 0) {
#line 3048
      wc = max;
    }
  }
#line 3057
  i = wc;
  {
#line 3057
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3057
    i --;
#line 3057
    if (! (i >= 0)) {
#line 3057
      goto while_break___2;
    }
    {
#line 3059
    tmp___1 = xalloc_tagged((int )sizeof(*w), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                            3059);
#line 3059
    w = (WORK *)tmp___1;
#line 3060
    w->w_qgrp = (WorkList + i)->w_qgrp;
#line 3061
    w->w_qdir = (WorkList + i)->w_qdir;
#line 3062
    w->w_name = (WorkList + i)->w_name;
#line 3063
    w->w_host = (WorkList + i)->w_host;
#line 3064
    w->w_lock = (WorkList + i)->w_lock;
#line 3065
    w->w_tooyoung = (WorkList + i)->w_tooyoung;
#line 3066
    w->w_pri = (WorkList + i)->w_pri;
#line 3067
    w->w_ctime = (WorkList + i)->w_ctime;
#line 3068
    w->w_mtime = (WorkList + i)->w_mtime;
#line 3069
    w->w_next = WorkQ;
#line 3070
    WorkQ = w;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3074
  i = WorkListCount;
  {
#line 3074
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3074
    i --;
#line 3074
    if (! (i >= wc)) {
#line 3074
      goto while_break___3;
    }
    {
#line 3076
    sm_free_tagged((void *)(WorkList + i)->w_name, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                   3076);
    }
#line 3077
    if ((unsigned long )(WorkList + i)->w_host != (unsigned long )((void *)0)) {
      {
#line 3078
      sm_free_tagged((void *)(WorkList + i)->w_host, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     3078);
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3081
  if ((unsigned long )WorkList != (unsigned long )((void *)0)) {
    {
#line 3082
    sm_free_tagged((void *)WorkList, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                   3082);
    }
  }
#line 3083
  WorkList = (WORK *)((void *)0);
#line 3084
  WorkListSize = 0;
#line 3085
  WorkListCount = 0;
#line 3087
  if ((int )tTdvect[40] >= 1) {
#line 3089
    w = WorkQ;
    {
#line 3089
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3089
      if (! ((unsigned long )w != (unsigned long )((void *)0))) {
#line 3089
        goto while_break___4;
      }
#line 3091
      if ((unsigned long )w->w_host != (unsigned long )((void *)0)) {
        {
#line 3092
        sm_dprintf((char *)"%22s: pri=%ld %s\n", w->w_name, w->w_pri, w->w_host);
        }
      } else {
        {
#line 3095
        sm_dprintf((char *)"%32s: pri=%ld\n", w->w_name, w->w_pri);
        }
      }
#line 3089
      w = w->w_next;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 3100
  return (wc);
}
}
#line 3118 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void grow_wlist(int qgrp , int qdir ) 
{ 
  char *tmp ;
  int newsize ;
  WORK *newlist ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 3123
  if ((int )tTdvect[41] >= 1) {
    {
#line 3124
    sm_dprintf((char *)"grow_wlist: WorkListSize=%d\n", WorkListSize);
    }
  }
#line 3125
  if ((unsigned long )WorkList == (unsigned long )((void *)0)) {
    {
#line 3127
    tmp = xalloc_tagged((int )(sizeof(*WorkList) * 1001UL), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                        3128);
#line 3127
    WorkList = (WORK *)tmp;
#line 3129
    WorkListSize = 1000;
    }
  } else {
    {
#line 3133
    newsize = WorkListSize + 1000;
#line 3134
    tmp___0 = sm_realloc((void *)((char *)WorkList), (unsigned int )sizeof(WORK ) * (unsigned int )(newsize + 1));
#line 3134
    newlist = (WORK *)tmp___0;
    }
#line 3137
    if ((unsigned long )newlist != (unsigned long )((void *)0)) {
#line 3139
      WorkListSize = newsize;
#line 3140
      WorkList = newlist;
#line 3141
      if (LogLevel > 1) {
        {
#line 3143
        tmp___1 = qid_printqueue(qgrp, qdir);
#line 3143
        sm_syslog(6, "*~*", "grew WorkList for %s to %d", tmp___1, WorkListSize);
        }
      }
    } else
#line 3149
    if (LogLevel > 0) {
      {
#line 3151
      tmp___2 = qid_printqueue(qgrp, qdir);
#line 3151
      sm_syslog(1, "*~*", "FAILED to grow WorkList for %s to %d", tmp___2, newsize);
      }
    }
  }
#line 3156
  if ((int )tTdvect[41] >= 1) {
    {
#line 3157
    sm_dprintf((char *)"grow_wlist: WorkListSize now %d\n", WorkListSize);
    }
  }
#line 3158
  return;
}
}
#line 3173 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int workcmpf0(WORK *a , WORK *b___0 ) 
{ 
  long pa ;
  long pb ;

  {
#line 3178
  pa = a->w_pri;
#line 3179
  pb = b___0->w_pri;
#line 3181
  if (pa == pb) {
#line 3182
    return (0);
  } else
#line 3183
  if (pa > pb) {
#line 3184
    return (1);
  } else {
#line 3186
    return (-1);
  }
}
}
#line 3204 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int workcmpf1(WORK *a , WORK *b___0 ) 
{ 
  int i ;
  int tmp ;

  {
#line 3212
  if ((unsigned long )a->w_host != (unsigned long )((void *)0)) {
#line 3212
    if ((unsigned long )b___0->w_host == (unsigned long )((void *)0)) {
#line 3213
      return (1);
    } else {
#line 3212
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3214
  if ((unsigned long )a->w_host == (unsigned long )((void *)0)) {
#line 3214
    if ((unsigned long )b___0->w_host != (unsigned long )((void *)0)) {
#line 3215
      return (-1);
    }
  }
#line 3216
  if ((unsigned long )a->w_host != (unsigned long )((void *)0)) {
#line 3216
    if ((unsigned long )b___0->w_host != (unsigned long )((void *)0)) {
      {
#line 3216
      i = sm_strcasecmp((char const   *)a->w_host, (char const   *)b___0->w_host);
      }
#line 3216
      if (i != 0) {
#line 3218
        return (i);
      }
    }
  }
#line 3221
  if (a->w_lock != b___0->w_lock) {
#line 3222
    return (b___0->w_lock - a->w_lock);
  }
  {
#line 3225
  tmp = workcmpf0(a, b___0);
  }
#line 3225
  return (tmp);
}
}
#line 3243 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int workcmpf2(WORK *a , WORK *b___0 ) 
{ 
  int i ;
  int tmp ;

  {
#line 3251
  if (a->w_lock != b___0->w_lock) {
#line 3252
    return (a->w_lock - b___0->w_lock);
  }
#line 3255
  if ((unsigned long )a->w_host != (unsigned long )((void *)0)) {
#line 3255
    if ((unsigned long )b___0->w_host == (unsigned long )((void *)0)) {
#line 3256
      return (1);
    } else {
#line 3255
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3257
  if ((unsigned long )a->w_host == (unsigned long )((void *)0)) {
#line 3257
    if ((unsigned long )b___0->w_host != (unsigned long )((void *)0)) {
#line 3258
      return (-1);
    }
  }
#line 3259
  if ((unsigned long )a->w_host != (unsigned long )((void *)0)) {
#line 3259
    if ((unsigned long )b___0->w_host != (unsigned long )((void *)0)) {
      {
#line 3259
      i = sm_strcasecmp((char const   *)a->w_host, (char const   *)b___0->w_host);
      }
#line 3259
      if (i != 0) {
#line 3261
        return (i);
      }
    }
  }
  {
#line 3264
  tmp = workcmpf0(a, b___0);
  }
#line 3264
  return (tmp);
}
}
#line 3280 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int workcmpf3(WORK *a , WORK *b___0 ) 
{ 


  {
#line 3285
  if (a->w_ctime > b___0->w_ctime) {
#line 3286
    return (1);
  } else
#line 3287
  if (a->w_ctime < b___0->w_ctime) {
#line 3288
    return (-1);
  } else {
#line 3290
    return (0);
  }
}
}
#line 3306 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int workcmpf4(WORK *a , WORK *b___0 ) 
{ 
  int tmp ;

  {
  {
#line 3311
  tmp = strcmp((char const   *)a->w_name, (char const   *)b___0->w_name);
  }
#line 3311
  return (tmp);
}
}
#line 3325 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int workcmpf5(WORK *a , WORK *b___0 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 3330
  tmp = strlen((char const   *)a->w_name);
  }
#line 3330
  if (tmp < (size_t )randi) {
#line 3331
    return (-1);
  } else {
    {
#line 3330
    tmp___0 = strlen((char const   *)b___0->w_name);
    }
#line 3330
    if (tmp___0 < (size_t )randi) {
#line 3331
      return (-1);
    }
  }
#line 3332
  return ((int )*(a->w_name + randi) - (int )*(b___0->w_name + randi));
}
}
#line 3348 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int workcmpf6(WORK *a , WORK *b___0 ) 
{ 


  {
#line 3353
  if (a->w_mtime > b___0->w_mtime) {
#line 3354
    return (1);
  } else
#line 3355
  if (a->w_mtime < b___0->w_mtime) {
#line 3356
    return (-1);
  } else {
#line 3358
    return (0);
  }
}
}
#line 3415 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static char *strrev(char *fwd ) 
{ 
  char *rev ;
  int len___0 ;
  int cnt ;
  size_t tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 3419
  rev = (char *)((void *)0);
#line 3422
  tmp = strlen((char const   *)fwd);
#line 3422
  len___0 = (int )tmp;
#line 3423
  rev = xalloc_tagged(len___0 + 1, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                      3423);
#line 3424
  cnt = 0;
  }
  {
#line 3424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3424
    if (! (cnt < len___0)) {
#line 3424
      goto while_break;
    }
#line 3425
    *(rev + cnt) = *(fwd + ((len___0 - cnt) - 1));
#line 3424
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3426
  *(rev + len___0) = (char )'\000';
#line 3427
  return (rev);
}
}
#line 3509 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
pid_t dowork(int qgrp , int qdir , char *id , bool forkflag , bool requeueflag , ENVELOPE *e ) 
{ 
  register pid_t pid ;
  SM_RPOOL_T *rpool ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  bool tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 3521
  if ((int )tTdvect[40] >= 1) {
    {
#line 3522
    tmp = qid_printqueue(qgrp, qdir);
#line 3522
    sm_dprintf((char *)"dowork(%s/%s)\n", tmp, id);
    }
  }
#line 3528
  if (forkflag) {
    {
#line 3538
    closemaps(0);
#line 3540
    pid = fork();
    }
#line 3541
    if (pid < 0) {
      {
#line 3543
      syserr("dowork: cannot fork");
      }
#line 3544
      return (0);
    } else
#line 3546
    if (pid > 0) {
      {
#line 3549
      mci_flush(0, (struct mailer_con_info *)((void *)0));
      }
    } else {
      {
#line 3559
      RestartRequest = (char */* volatile  */)((void *)0);
#line 3560
      RestartWorkGroup = (bool volatile   )0;
#line 3561
      ShutdownRequest = (char */* volatile  */)((void *)0);
#line 3562
      PendingSignal = (int volatile   )0;
#line 3563
      CurrentPid = getpid();
#line 3564
      sm_exc_newthread(& fatal_error);
      }
#line 3570
      if ((int )OpMode == 115) {
        {
#line 3574
        proc_list_clear();
#line 3575
        sm_releasesignal(17);
#line 3576
        sm_signal(17, (void (*)(int  ))0);
        }
      } else
#line 3570
      if ((int )OpMode == 100) {
        {
#line 3574
        proc_list_clear();
#line 3575
        sm_releasesignal(17);
#line 3576
        sm_signal(17, (void (*)(int  ))0);
        }
      } else
#line 3570
      if (MaxQueueChildren > 0) {
        {
#line 3574
        proc_list_clear();
#line 3575
        sm_releasesignal(17);
#line 3576
        sm_signal(17, (void (*)(int  ))0);
        }
      }
#line 3580
      OnlyOneError = 0;
#line 3580
      QuickAbort = OnlyOneError;
    }
  } else {
#line 3585
    pid = 0;
  }
#line 3588
  if (pid == 0) {
#line 3598
    if (forkflag) {
#line 3601
      RestartRequest = (char */* volatile  */)((void *)0);
#line 3602
      RestartWorkGroup = (bool volatile   )0;
#line 3603
      ShutdownRequest = (char */* volatile  */)((void *)0);
#line 3604
      PendingSignal = (int volatile   )0;
    }
    {
#line 3608
    sm_clear_events();
#line 3609
    clearstats();
#line 3610
    rpool = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 3611
    clearenvelope(e, 0, rpool);
#line 3612
    e->e_flags |= 6144UL;
#line 3613
    set_delivery_mode('i', e);
#line 3614
    e->e_errormode = (short )'m';
#line 3615
    e->e_id = id;
#line 3616
    e->e_qgrp = qgrp;
#line 3617
    e->e_qdir = qdir;
#line 3618
    UseErrorsTo = 0;
#line 3618
    GrabTo = UseErrorsTo;
#line 3619
    ExitStat = 0;
    }
#line 3620
    if (forkflag) {
      {
#line 3622
      disconnect(1, e);
#line 3623
      set_op_mode('q');
      }
    }
    {
#line 3625
    tmp___0 = qid_printname(e);
#line 3625
    sm_setproctitle(1, e, "%s from queue", tmp___0);
    }
#line 3626
    if (LogLevel > 76) {
      {
#line 3627
      sm_syslog(7, (char const   *)e->e_id, "dowork, pid=%d", CurrentPid);
      }
    }
    {
#line 3631
    e->e_header = (HDR *)((void *)0);
#line 3634
    tmp___2 = readqf(e, 0);
    }
#line 3634
    if (! tmp___2) {
#line 3636
      if ((int )tTdvect[40] >= 4) {
#line 3636
        if ((unsigned long )e->e_id != (unsigned long )((void *)0)) {
          {
#line 3637
          tmp___1 = qid_printname(e);
#line 3637
          sm_dprintf((char *)"readqf(%s) failed\n", tmp___1);
          }
        }
      }
#line 3639
      e->e_id = (char *)((void *)0);
#line 3640
      if (forkflag) {
        {
#line 3641
        finis(0, 1, (int volatile   )0);
        }
      } else {
        {
#line 3645
        clearenvelope(e, 0, rpool);
#line 3648
        sm_rpool_free(rpool);
#line 3649
        e->e_rpool = (SM_RPOOL_T *)((void *)0);
        }
#line 3650
        return (0);
      }
    }
    {
#line 3654
    e->e_flags |= 2UL;
#line 3655
    eatheader(e, requeueflag, 1);
    }
#line 3657
    if (requeueflag) {
      {
#line 3658
      queueup(e, 0, 0);
      }
    }
    {
#line 3661
    sendall(e, 'i');
    }
#line 3664
    if (forkflag) {
      {
#line 3665
      finis(1, 1, (int volatile   )ExitStat);
      }
    } else {
      {
#line 3668
      dropenvelope(e, 1, 0);
#line 3669
      sm_rpool_free(rpool);
#line 3670
      e->e_rpool = (SM_RPOOL_T *)((void *)0);
      }
    }
  }
#line 3673
  e->e_id = (char *)((void *)0);
#line 3674
  return (pid);
}
}
#line 3698 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
pid_t doworklist(ENVELOPE *el , bool forkflag , bool requeueflag ) 
{ 
  register pid_t pid ;
  ENVELOPE *ei ;
  ENVELOPE e ;
  SM_RPOOL_T *rpool ;
  char *tmp ;
  char *tmp___0 ;
  bool tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 3707
  if ((int )tTdvect[40] >= 1) {
    {
#line 3708
    sm_dprintf((char *)"doworklist()\n");
    }
  }
#line 3714
  if (forkflag) {
    {
#line 3724
    closemaps(0);
#line 3726
    pid = fork();
    }
#line 3727
    if (pid < 0) {
      {
#line 3729
      syserr("doworklist: cannot fork");
      }
#line 3730
      return (0);
    } else
#line 3732
    if (pid > 0) {
      {
#line 3735
      mci_flush(0, (struct mailer_con_info *)((void *)0));
      }
    } else {
      {
#line 3745
      RestartRequest = (char */* volatile  */)((void *)0);
#line 3746
      RestartWorkGroup = (bool volatile   )0;
#line 3747
      ShutdownRequest = (char */* volatile  */)((void *)0);
#line 3748
      PendingSignal = (int volatile   )0;
#line 3749
      CurrentPid = getpid();
#line 3750
      sm_exc_newthread(& fatal_error);
      }
#line 3756
      if ((int )OpMode == 115) {
        {
#line 3760
        proc_list_clear();
#line 3761
        sm_releasesignal(17);
#line 3762
        sm_signal(17, (void (*)(int  ))0);
        }
      } else
#line 3756
      if ((int )OpMode == 100) {
        {
#line 3760
        proc_list_clear();
#line 3761
        sm_releasesignal(17);
#line 3762
        sm_signal(17, (void (*)(int  ))0);
        }
      } else
#line 3756
      if (MaxQueueChildren > 0) {
        {
#line 3760
        proc_list_clear();
#line 3761
        sm_releasesignal(17);
#line 3762
        sm_signal(17, (void (*)(int  ))0);
        }
      }
#line 3766
      OnlyOneError = 0;
#line 3766
      QuickAbort = OnlyOneError;
    }
  } else {
#line 3771
    pid = 0;
  }
#line 3774
  if (pid != 0) {
#line 3775
    return (pid);
  }
#line 3785
  if (forkflag) {
#line 3788
    RestartRequest = (char */* volatile  */)((void *)0);
#line 3789
    RestartWorkGroup = (bool volatile   )0;
#line 3790
    ShutdownRequest = (char */* volatile  */)((void *)0);
#line 3791
    PendingSignal = (int volatile   )0;
  }
  {
#line 3795
  sm_clear_events();
#line 3796
  clearstats();
#line 3797
  UseErrorsTo = 0;
#line 3797
  GrabTo = UseErrorsTo;
#line 3798
  ExitStat = 0;
  }
#line 3799
  if (forkflag) {
    {
#line 3801
    disconnect(1, el);
#line 3802
    set_op_mode('q');
    }
  }
#line 3804
  if (LogLevel > 76) {
    {
#line 3805
    sm_syslog(7, (char const   *)el->e_id, "doworklist, pid=%d", CurrentPid);
    }
  }
#line 3808
  ei = el;
  {
#line 3808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3808
    if (! ((unsigned long )ei != (unsigned long )((void *)0))) {
#line 3808
      goto while_break;
    }
#line 3813
    if ((int )ei->e_sendmode == 113) {
#line 3814
      goto __Cont;
    } else
#line 3813
    if ((int )ei->e_sendmode == 100) {
#line 3814
      goto __Cont;
    } else
#line 3815
    if (QueueMode != 81) {
#line 3815
      if ((unsigned long )ei->e_quarmsg != (unsigned long )((void *)0)) {
#line 3817
        goto __Cont;
      }
    }
    {
#line 3819
    rpool = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 3820
    clearenvelope(& e, 1, rpool);
#line 3821
    e.e_flags |= 6144UL;
#line 3822
    set_delivery_mode('i', & e);
#line 3823
    e.e_errormode = (short )'m';
#line 3824
    e.e_id = ei->e_id;
#line 3825
    e.e_qgrp = ei->e_qgrp;
#line 3826
    e.e_qdir = ei->e_qdir;
#line 3827
    openxscript(& e);
#line 3828
    tmp = qid_printname(& e);
#line 3828
    sm_setproctitle(1, & e, "%s from queue", tmp);
#line 3831
    e.e_header = (HDR *)((void *)0);
#line 3832
    CurEnv = & e;
#line 3835
    tmp___1 = readqf(& e, 0);
    }
#line 3835
    if (tmp___1) {
      {
#line 3837
      e.e_flags |= 2UL;
#line 3838
      eatheader(& e, requeueflag, 1);
      }
#line 3840
      if (requeueflag) {
        {
#line 3841
        queueup(& e, 0, 0);
        }
      }
      {
#line 3844
      sendall(& e, 'i');
#line 3845
      dropenvelope(& e, 1, 0);
      }
    } else
#line 3849
    if ((int )tTdvect[40] >= 4) {
#line 3849
      if ((unsigned long )e.e_id != (unsigned long )((void *)0)) {
        {
#line 3850
        tmp___0 = qid_printname(& e);
#line 3850
        sm_dprintf((char *)"readqf(%s) failed\n", tmp___0);
        }
      }
    }
    {
#line 3853
    sm_rpool_free(rpool);
#line 3854
    ei->e_id = (char *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 3808
    ei = ei->e_sibling;
  }
  while_break: /* CIL Label */ ;
  }
#line 3858
  CurEnv = el;
#line 3861
  if (forkflag) {
    {
#line 3862
    finis(1, 1, (int volatile   )ExitStat);
    }
  }
#line 3863
  return (0);
}
}
#line 3880 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static bool readqf(ENVELOPE *e , bool openonly ) 
{ 
  register SM_FILE_T *qfp ;
  ADDRESS *ctladdr ;
  struct stat st ;
  struct stat stf ;
  char *bp___3 ;
  int qfver ;
  long hdrsize ;
  register char *p ;
  char *frcpt ;
  char *orcpt ;
  bool nomore ;
  bool bogus ;
  mode_t qsafe ;
  char *err ;
  char qf[4096] ;
  char buf___16[2048] ;
  char *tmp ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __uid_t tmp___12 ;
  __uid_t tmp___13 ;
  int tmp___14 ;
  char delim ;
  struct stat dst ;
  char const   *tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  __gid_t tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  time_t tmp___22 ;
  __uid_t tmp___23 ;
  unsigned long qflags ;
  ADDRESS *q ;
  int r ;
  time_t now ;
  char *ep ;
  bool tmp___24 ;
  int qgrp ;
  int qdir ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  char *howlong ;
  int tmp___29 ;
  struct __res_state *tmp___30 ;
  struct __res_state *tmp___31 ;
  struct __res_state *tmp___32 ;
  struct __res_state *tmp___33 ;
  long tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  char *p___0 ;
  char *tmp___39 ;
  int *tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;

  {
  {
#line 3889
  qfver = 0;
#line 3890
  hdrsize = 0L;
#line 3892
  frcpt = (char *)((void *)0);
#line 3893
  orcpt = (char *)((void *)0);
#line 3894
  nomore = 0;
#line 3895
  bogus = 0;
#line 3905
  tmp = queuename(e, '?');
#line 3905
  sm_strlcpy(qf, (char const   *)tmp, (ssize_t )sizeof(qf));
#line 3906
  qfp = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)(qf),
                   1, (void const   *)((void *)0));
  }
#line 3907
  if ((unsigned long )qfp == (unsigned long )((void *)0)) {
    {
#line 3909
    tmp___0 = __errno_location();
#line 3909
    save_errno = *tmp___0;
    }
#line 3911
    if ((int )tTdvect[40] >= 8) {
      {
#line 3912
      tmp___1 = __errno_location();
#line 3912
      tmp___2 = sm_errstring(*tmp___1);
#line 3912
      sm_dprintf((char *)"readqf(%s): sm_io_open failure (%s)\n", qf, tmp___2);
      }
    }
    {
#line 3914
    tmp___3 = __errno_location();
#line 3914
    *tmp___3 = save_errno;
#line 3915
    tmp___4 = __errno_location();
    }
#line 3915
    if (*tmp___4 != 2) {
      {
#line 3917
      syserr("readqf: no control file %s", qf);
      }
    }
#line 3919
    return (0);
  }
  {
#line 3922
  tmp___5 = sm_io_getinfo(qfp, 3, (void *)0);
#line 3922
  tmp___6 = lockfile(tmp___5, qf, (char *)((void *)0), 6);
  }
#line 3922
  if (! tmp___6) {
#line 3926
    if (Verbose) {
      {
#line 3927
      sm_io_fprintf(& SmIoF[1], -2, "%s: locked\n", e->e_id);
      }
    }
#line 3929
    if ((int )tTdvect[40] >= 8) {
      {
#line 3930
      sm_dprintf((char *)"%s: locked\n", e->e_id);
      }
    }
#line 3931
    if (LogLevel > 19) {
      {
#line 3932
      sm_syslog(7, (char const   *)e->e_id, "locked");
      }
    }
    {
#line 3933
    sm_io_close(qfp, -2);
    }
#line 3935
    return (0);
  }
  {
#line 3958
  tmp___9 = stat((char const   */* __restrict  */)(qf), (struct stat */* __restrict  */)(& stf));
  }
#line 3958
  if (tmp___9 < 0) {
#line 3958
    goto _L;
  } else {
    {
#line 3958
    tmp___10 = sm_io_getinfo(qfp, 3, (void *)0);
#line 3958
    tmp___11 = fstat(tmp___10, & st);
    }
#line 3958
    if (tmp___11 < 0) {
      _L: /* CIL Label */ 
#line 3962
      if ((int )tTdvect[40] >= 8) {
        {
#line 3963
        tmp___7 = __errno_location();
#line 3963
        tmp___8 = sm_errstring(*tmp___7);
#line 3963
        sm_dprintf((char *)"readqf(%s): [f]stat failure (%s)\n", qf, tmp___8);
        }
      }
      {
#line 3965
      sm_io_close(qfp, -2);
      }
#line 3966
      return (0);
    }
  }
#line 3969
  if (st.st_nlink != stf.st_nlink) {
#line 3969
    goto _L___0;
  } else
#line 3969
  if (st.st_dev != stf.st_dev) {
#line 3969
    goto _L___0;
  } else
#line 3969
  if (st.st_ino != stf.st_ino) {
#line 3969
    goto _L___0;
  } else
#line 3969
  if (st.st_uid != stf.st_uid) {
#line 3969
    goto _L___0;
  } else
#line 3969
  if (st.st_gid != stf.st_gid) {
#line 3969
    goto _L___0;
  } else
#line 3969
  if (st.st_size != stf.st_size) {
    _L___0: /* CIL Label */ 
#line 3980
    if (Verbose) {
      {
#line 3981
      sm_io_fprintf(& SmIoF[1], -2, "%s: changed\n", e->e_id);
      }
    }
#line 3983
    if ((int )tTdvect[40] >= 8) {
      {
#line 3984
      sm_dprintf((char *)"%s: changed\n", e->e_id);
      }
    }
#line 3985
    if (LogLevel > 19) {
      {
#line 3986
      sm_syslog(7, (char const   *)e->e_id, "changed");
      }
    }
    {
#line 3987
    sm_io_close(qfp, -2);
    }
#line 3988
    return (0);
  }
#line 3995
  qsafe = (mode_t )(((128 >> 3) >> 3) | (128 >> 3));
#line 3996
  if ((QueueFileMode & (128 >> 3)) != 0) {
#line 3997
    qsafe &= (unsigned int )(~ (128 >> 3));
  }
  {
#line 3999
  tmp___12 = geteuid();
  }
#line 3999
  if (st.st_uid != tmp___12) {
#line 3999
    if (st.st_uid != TrustedUid) {
      {
#line 3999
      tmp___13 = geteuid();
      }
#line 3999
      if (tmp___13 != RealUid) {
#line 3999
        tmp___14 = 1;
      } else {
#line 3999
        tmp___14 = 0;
      }
    } else {
#line 3999
      tmp___14 = 0;
    }
  } else {
#line 3999
    tmp___14 = 0;
  }
#line 3999
  bogus = tmp___14;
#line 4012
  if (bogus) {
    {
#line 4012
    tmp___19 = getegid();
    }
#line 4012
    if (st.st_gid == tmp___19) {
#line 4012
      if (UseMSP) {
        {
#line 4017
        bp___3 = strrchr((char const   *)(qf), '/');
        }
#line 4018
        if ((unsigned long )bp___3 == (unsigned long )((void *)0)) {
#line 4019
          delim = (char )'\000';
        } else {
#line 4022
          delim = *bp___3;
#line 4023
          *bp___3 = (char )'\000';
        }
#line 4025
        if ((int )delim == 0) {
#line 4025
          tmp___17 = ".";
        } else {
#line 4025
          tmp___17 = (char const   *)(qf);
        }
        {
#line 4025
        tmp___18 = stat((char const   */* __restrict  */)tmp___17, (struct stat */* __restrict  */)(& dst));
        }
#line 4025
        if (tmp___18 < 0) {
#line 4026
          if ((int )delim == 0) {
#line 4026
            tmp___15 = ".";
          } else {
#line 4026
            tmp___15 = (char const   *)(qf);
          }
          {
#line 4026
          syserr("readqf: cannot stat directory %s", tmp___15);
          }
        } else {
#line 4030
          if ((QueueFileMode & (128 >> 3)) != 0) {
#line 4030
            if ((dst.st_mode & (unsigned int )(128 >> 3)) != 0U) {
#line 4030
              if (dst.st_gid == st.st_gid) {
#line 4030
                tmp___16 = 0;
              } else {
#line 4030
                tmp___16 = 1;
              }
            } else {
#line 4030
              tmp___16 = 1;
            }
          } else {
#line 4030
            tmp___16 = 1;
          }
#line 4030
          bogus = tmp___16;
        }
#line 4034
        if ((int )delim != 0) {
#line 4035
          *bp___3 = delim;
        }
      }
    }
  }
#line 4037
  if (! bogus) {
#line 4038
    bogus = (st.st_mode & qsafe) != 0U;
  }
#line 4039
  if (bogus) {
#line 4041
    if (LogLevel > 0) {
      {
#line 4043
      sm_syslog(1, (char const   *)e->e_id, "bogus queue file, uid=%d, gid=%d, mode=%o",
                st.st_uid, st.st_gid, st.st_mode);
      }
    }
#line 4047
    if ((int )tTdvect[40] >= 8) {
      {
#line 4048
      sm_dprintf((char *)"readqf(%s): bogus file\n", qf);
      }
    }
#line 4049
    e->e_flags |= 2UL;
#line 4050
    if (! openonly) {
      {
#line 4051
      loseqfile(e, (char *)"bogus file uid/gid in mqueue");
      }
    }
    {
#line 4052
    sm_io_close(qfp, -2);
    }
#line 4053
    return (0);
  }
#line 4056
  if (st.st_size == 0L) {
#line 4059
    if (! openonly) {
      {
#line 4059
      tmp___22 = curtime();
      }
#line 4059
      if (st.st_ctim.tv_sec + 600L < tmp___22) {
        {
#line 4061
        tmp___20 = queuename(e, 'd');
#line 4061
        xunlink(tmp___20);
#line 4062
        tmp___21 = queuename(e, '?');
#line 4062
        xunlink(tmp___21);
        }
      }
    }
    {
#line 4064
    sm_io_close(qfp, -2);
    }
#line 4065
    return (0);
  }
#line 4068
  if (st.st_nlink == 0U) {
    {
#line 4075
    sm_io_close(qfp, -2);
    }
#line 4076
    return (0);
  }
  {
#line 4090
  tmp___23 = geteuid();
  }
#line 4090
  if (st.st_uid != tmp___23) {
#line 4091
    e->e_flags |= 134217728UL;
  }
#line 4095
  e->e_lockfp = qfp;
#line 4098
  if (openonly) {
#line 4099
    return (1);
  }
  {
#line 4102
  initsys(e);
#line 4103
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'i', e->e_id, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                   4103, SmHeapGroup);
#line 4105
  LineNumber = 0;
#line 4106
  e->e_flags |= 4096UL;
#line 4107
  set_op_mode('q');
#line 4108
  ctladdr = (ADDRESS *)((void *)0);
#line 4109
  e->e_qfletter = queue_letter(e, '?');
#line 4110
  e->e_dfqgrp = e->e_qgrp;
#line 4111
  e->e_dfqdir = e->e_qdir;
#line 4116
  e->e_dfino = (ino_t )-1;
#line 4117
  e->e_msgsize = -1L;
  }
  {
#line 4118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4118
    bp___3 = fgetfolded(buf___16, (int )sizeof(buf___16), qfp);
    }
#line 4118
    if (! ((unsigned long )bp___3 != (unsigned long )((void *)0))) {
#line 4118
      goto while_break;
    }
#line 4126
    if ((int )tTdvect[40] >= 4) {
      {
#line 4127
      sm_dprintf((char *)"+++++ %s\n", bp___3);
      }
    }
#line 4128
    if (nomore) {
      hackattack: 
      {
#line 4132
      syserr("SECURITY ALERT: extra or bogus data in queue file: %s", bp___3);
#line 4134
      err = (char *)"bogus queue line";
      }
#line 4135
      goto fail;
    }
    {
#line 4139
    if ((int )*(bp___3 + 0) == 65) {
#line 4139
      goto case_65;
    }
#line 4145
    if ((int )*(bp___3 + 0) == 66) {
#line 4145
      goto case_66;
    }
#line 4152
    if ((int )*(bp___3 + 0) == 67) {
#line 4152
      goto case_67;
    }
#line 4156
    if ((int )*(bp___3 + 0) == 68) {
#line 4156
      goto case_68;
    }
#line 4160
    if ((int )*(bp___3 + 0) == 100) {
#line 4160
      goto case_100;
    }
#line 4193
    if ((int )*(bp___3 + 0) == 69) {
#line 4193
      goto case_69;
    }
#line 4197
    if ((int )*(bp___3 + 0) == 70) {
#line 4197
      goto case_70;
    }
#line 4240
    if ((int )*(bp___3 + 0) == 113) {
#line 4240
      goto case_113;
    }
#line 4246
    if ((int )*(bp___3 + 0) == 72) {
#line 4246
      goto case_72;
    }
#line 4258
    if ((int )*(bp___3 + 0) == 73) {
#line 4258
      goto case_73;
    }
#line 4262
    if ((int )*(bp___3 + 0) == 75) {
#line 4262
      goto case_75;
    }
#line 4267
    if ((int )*(bp___3 + 0) == 77) {
#line 4267
      goto case_77;
    }
#line 4267
    if ((int )*(bp___3 + 0) == 76) {
#line 4267
      goto case_77;
    }
#line 4271
    if ((int )*(bp___3 + 0) == 78) {
#line 4271
      goto case_78;
    }
#line 4316
    if ((int )*(bp___3 + 0) == 80) {
#line 4316
      goto case_80;
    }
#line 4320
    if ((int )*(bp___3 + 0) == 81) {
#line 4320
      goto case_81;
    }
#line 4324
    if ((int )*(bp___3 + 0) == 114) {
#line 4324
      goto case_114___0;
    }
#line 4328
    if ((int )*(bp___3 + 0) == 82) {
#line 4328
      goto case_82;
    }
#line 4396
    if ((int )*(bp___3 + 0) == 83) {
#line 4396
      goto case_83___0;
    }
#line 4401
    if ((int )*(bp___3 + 0) == 84) {
#line 4401
      goto case_84;
    }
#line 4405
    if ((int )*(bp___3 + 0) == 86) {
#line 4405
      goto case_86;
    }
#line 4416
    if ((int )*(bp___3 + 0) == 90) {
#line 4416
      goto case_90;
    }
#line 4422
    if ((int )*(bp___3 + 0) == 33) {
#line 4422
      goto case_33;
    }
#line 4428
    if ((int )*(bp___3 + 0) == 36) {
#line 4428
      goto case_36;
    }
#line 4441
    if ((int )*(bp___3 + 0) == 46) {
#line 4441
      goto case_46;
    }
#line 4463
    goto switch_default___0;
    case_65: /* CIL Label */ 
    {
#line 4140
    tmp___24 = xtextok(bp___3 + 1);
    }
#line 4140
    if (! tmp___24) {
#line 4141
      goto hackattack;
    }
    {
#line 4142
    e->e_auth_param = sm_rpool_strdup_x(e->e_rpool, (char const   *)(bp___3 + 1));
    }
#line 4143
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 4146
    r = check_bodytype(bp___3 + 1);
    }
#line 4147
    if (! (r == 1)) {
#line 4147
      if (! (r == 2)) {
#line 4148
        goto hackattack;
      }
    }
    {
#line 4149
    e->e_bodytype = sm_rpool_strdup_x(e->e_rpool, (char const   *)(bp___3 + 1));
    }
#line 4150
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 4153
    ctladdr = setctluser(bp___3 + 1, qfver, e);
    }
#line 4154
    goto switch_break;
    case_68: /* CIL Label */ 
#line 4158
    goto switch_break;
    case_100: /* CIL Label */ 
#line 4169
    qgrp = 0;
    {
#line 4169
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4169
      if (qgrp < NumQueue) {
#line 4169
        if (! ((unsigned long )Queue[qgrp] != (unsigned long )((void *)0))) {
#line 4169
          goto while_break___0;
        }
      } else {
#line 4169
        goto while_break___0;
      }
#line 4173
      qdir = 0;
      {
#line 4173
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4173
        if (! (qdir < (Queue[qgrp])->qg_numqueues)) {
#line 4173
          goto while_break___1;
        }
        {
#line 4177
        tmp___25 = strcmp((char const   *)(bp___3 + 1), (char const   *)((Queue[qgrp])->qg_qpaths + qdir)->qp_name);
        }
#line 4177
        if (tmp___25 == 0) {
#line 4181
          e->e_dfqgrp = qgrp;
#line 4182
          e->e_dfqdir = qdir;
#line 4183
          goto done;
        }
#line 4173
        qdir ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4169
      qgrp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4187
    err = (char *)"bogus queue file directory";
#line 4188
    goto fail;
    done: 
#line 4190
    goto switch_break;
    case_69: /* CIL Label */ 
#line 4195
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 4198
    tmp___26 = strncmp((char const   *)bp___3, "From ", (size_t )5);
    }
#line 4198
    if (tmp___26 == 0) {
      {
#line 4201
      syserr("SECURITY ALERT: bogus qf line %s", bp___3);
#line 4202
      err = (char *)"bogus queue line";
      }
#line 4203
      goto fail;
    }
#line 4205
    p = bp___3 + 1;
    {
#line 4205
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4205
      if (! ((int )*p != 0)) {
#line 4205
        goto while_break___2;
      }
      {
#line 4209
      if ((int )*p == 56) {
#line 4209
        goto case_56;
      }
#line 4213
      if ((int )*p == 98) {
#line 4213
        goto case_98;
      }
#line 4217
      if ((int )*p == 100) {
#line 4217
        goto case_100___0;
      }
#line 4221
      if ((int )*p == 110) {
#line 4221
        goto case_110;
      }
#line 4225
      if ((int )*p == 114) {
#line 4225
        goto case_114;
      }
#line 4229
      if ((int )*p == 115) {
#line 4229
        goto case_115;
      }
#line 4233
      if ((int )*p == 119) {
#line 4233
        goto case_119;
      }
#line 4207
      goto switch_break___0;
      case_56: /* CIL Label */ 
#line 4210
      e->e_flags |= 131072UL;
#line 4211
      goto switch_break___0;
      case_98: /* CIL Label */ 
#line 4214
      e->e_flags |= 64UL;
#line 4215
      goto switch_break___0;
      case_100___0: /* CIL Label */ 
#line 4218
      e->e_flags |= 1048576UL;
#line 4219
      goto switch_break___0;
      case_110: /* CIL Label */ 
#line 4222
      e->e_flags |= 4UL;
#line 4223
      goto switch_break___0;
      case_114: /* CIL Label */ 
#line 4226
      e->e_flags |= 128UL;
#line 4227
      goto switch_break___0;
      case_115: /* CIL Label */ 
#line 4230
      e->e_flags |= 67108864UL;
#line 4231
      goto switch_break___0;
      case_119: /* CIL Label */ 
#line 4234
      e->e_flags |= 1024UL;
#line 4235
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 4205
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 4238
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 4241
    e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, (char const   *)(bp___3 + 1));
#line 4242
    tmp___27 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 4242
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___27, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     4243, SmHeapGroup);
    }
#line 4244
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 4254
    tmp___28 = strlen((char const   *)bp___3);
#line 4254
    hdrsize += (long )(tmp___28 - 3U);
#line 4255
    chompheader(bp___3 + 1, 8, (HDR **)((void *)0), e);
    }
#line 4256
    goto switch_break;
    case_73: /* CIL Label */ 
#line 4260
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 4263
    e->e_dtime = atol((char const   *)(& buf___16[1]));
    }
#line 4264
    goto switch_break;
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
#line 4269
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 4272
    e->e_ntries = atoi((char const   *)(& buf___16[1]));
#line 4275
    now = curtime();
    }
#line 4276
    if (e->e_ntries > 0) {
#line 4276
      if (e->e_dtime <= now) {
#line 4276
        if (now < e->e_dtime + MinQueueAge) {
          {
#line 4281
          howlong = pintvl(now - e->e_dtime, 1);
          }
#line 4282
          if (Verbose) {
            {
#line 4283
            sm_io_fprintf(& SmIoF[1], -2, "%s: too young (%s)\n", e->e_id, howlong);
            }
          }
#line 4287
          if ((int )tTdvect[40] >= 8) {
            {
#line 4288
            sm_dprintf((char *)"%s: too young (%s)\n", e->e_id, howlong);
            }
          }
#line 4290
          if (LogLevel > 19) {
            {
#line 4291
            sm_syslog(7, (char const   *)e->e_id, "too young (%s)", howlong);
            }
          }
          {
#line 4294
          e->e_id = (char *)((void *)0);
#line 4295
          unlockqueue(e);
          }
#line 4296
          return (0);
        }
      }
    }
    {
#line 4298
    tmp___29 = macid_parse((char *)"{ntries}", (char **)((void *)0));
#line 4298
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___29, & buf___16[1], (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     4299, SmHeapGroup);
    }
#line 4303
    if (e->e_ntries == 0) {
      {
#line 4305
      tmp___30 = __res_state();
#line 4305
      tmp___30->retry = TimeOuts.res_retry[0];
#line 4306
      tmp___31 = __res_state();
#line 4306
      tmp___31->retrans = (int )TimeOuts.res_retrans[0];
      }
    } else {
      {
#line 4310
      tmp___32 = __res_state();
#line 4310
      tmp___32->retry = TimeOuts.res_retry[1];
#line 4311
      tmp___33 = __res_state();
#line 4311
      tmp___33->retrans = (int )TimeOuts.res_retrans[1];
      }
    }
#line 4314
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 4317
    tmp___34 = atol((char const   *)(bp___3 + 1));
#line 4317
    e->e_msgpriority = tmp___34 + WkTimeFact;
    }
#line 4318
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 4321
    orcpt = sm_rpool_strdup_x(e->e_rpool, (char const   *)(bp___3 + 1));
    }
#line 4322
    goto switch_break;
    case_114___0: /* CIL Label */ 
    {
#line 4325
    frcpt = sm_rpool_strdup_x(e->e_rpool, (char const   *)(bp___3 + 1));
    }
#line 4326
    goto switch_break;
    case_82: /* CIL Label */ 
#line 4329
    p = bp___3;
#line 4330
    qflags = 0UL;
#line 4331
    if (qfver >= 1) {
      {
#line 4334
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 4334
        p ++;
#line 4334
        if ((int )*p != 0) {
#line 4334
          if (! ((int )*p != 58)) {
#line 4334
            goto while_break___3;
          }
        } else {
#line 4334
          goto while_break___3;
        }
        {
#line 4338
        if ((int )*p == 78) {
#line 4338
          goto case_78___0;
        }
#line 4342
        if ((int )*p == 83) {
#line 4342
          goto case_83;
        }
#line 4346
        if ((int )*p == 70) {
#line 4346
          goto case_70___0;
        }
#line 4350
        if ((int )*p == 68) {
#line 4350
          goto case_68___0;
        }
#line 4354
        if ((int )*p == 80) {
#line 4354
          goto case_80___0;
        }
#line 4358
        if ((int )*p == 65) {
#line 4358
          goto case_65___0;
        }
#line 4363
        goto switch_default;
        case_78___0: /* CIL Label */ 
#line 4339
        qflags |= 512UL;
#line 4340
        goto switch_break___1;
        case_83: /* CIL Label */ 
#line 4343
        qflags |= 64UL;
#line 4344
        goto switch_break___1;
        case_70___0: /* CIL Label */ 
#line 4347
        qflags |= 128UL;
#line 4348
        goto switch_break___1;
        case_68___0: /* CIL Label */ 
#line 4351
        qflags |= 256UL;
#line 4352
        goto switch_break___1;
        case_80___0: /* CIL Label */ 
#line 4355
        qflags |= 2UL;
#line 4356
        goto switch_break___1;
        case_65___0: /* CIL Label */ 
#line 4359
        if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
#line 4360
          ctladdr->q_flags |= 16384UL;
        }
#line 4361
        goto switch_break___1;
        switch_default: /* CIL Label */ 
#line 4364
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 4369
      qflags |= 2UL;
    }
    {
#line 4370
    tmp___35 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 4370
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___35, (char *)"e r", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     4371, SmHeapGroup);
    }
#line 4372
    if ((int )*p != 0) {
      {
#line 4373
      p ++;
#line 4373
      q = parseaddr(p, (ADDRESS *)((void *)0), 48, '\000', (char **)((void *)0), e,
                    1);
      }
    } else {
#line 4376
      q = (ADDRESS *)((void *)0);
    }
#line 4377
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 4380
      if (e->e_qgrp >= 0) {
#line 4381
        q->q_qgrp = e->e_qgrp;
      }
#line 4382
      q->q_alias = ctladdr;
#line 4383
      if (qfver >= 1) {
#line 4384
        q->q_flags &= 0xfffffffffffffe3fUL;
      }
      {
#line 4385
      q->q_flags |= qflags;
#line 4386
      q->q_finalrcpt = frcpt;
#line 4387
      q->q_orcpt = orcpt;
#line 4388
      recipient(q, & e->e_sendqueue, 0, e);
      }
    }
    {
#line 4390
    frcpt = (char *)((void *)0);
#line 4391
    orcpt = (char *)((void *)0);
#line 4392
    tmp___36 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 4392
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___36, (char *)((void *)0),
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     4393, SmHeapGroup);
    }
#line 4394
    goto switch_break;
    case_83___0: /* CIL Label */ 
    {
#line 4397
    tmp___37 = sm_rpool_strdup_x(e->e_rpool, (char const   *)(bp___3 + 1));
#line 4397
    setsender(tmp___37, e, (char **)((void *)0), '\000', 1);
    }
#line 4399
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 4402
    e->e_ctime = atol((char const   *)(bp___3 + 1));
    }
#line 4403
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 4406
    qfver = atoi((char const   *)(bp___3 + 1));
    }
#line 4407
    if (qfver <= 8) {
#line 4408
      goto switch_break;
    }
    {
#line 4409
    syserr("Version number in queue file (%d) greater than max (%d)", qfver, 8);
#line 4411
    err = (char *)"unsupported queue file version";
    }
#line 4412
    goto fail;
#line 4414
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 4417
    e->e_envid = sm_rpool_strdup_x(e->e_rpool, (char const   *)(bp___3 + 1));
#line 4418
    tmp___38 = macid_parse((char *)"{dsn_envid}", (char **)((void *)0));
#line 4418
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___38, e->e_envid, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     4419, SmHeapGroup);
    }
#line 4420
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 4425
    e->e_dlvr_flag = (int )buf___16[1];
#line 4426
    e->e_deliver_by = strtol((char const   */* __restrict  */)(& buf___16[3]), (char **/* __restrict  */)((void *)0),
                             10);
    }
    case_36: /* CIL Label */ 
    {
#line 4433
    r = macid_parse(bp___3 + 1, & ep);
    }
#line 4434
    if (r == 0) {
#line 4435
      goto switch_break;
    }
    {
#line 4436
    p___0 = sm_rpool_strdup_x(e->e_rpool, (char const   *)ep);
#line 4437
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, r, p___0, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     4437, SmHeapGroup);
    }
#line 4439
    goto switch_break;
    case_46: /* CIL Label */ 
#line 4442
    nomore = 1;
#line 4443
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 4464
    tmp___39 = shortenstring((char const   *)bp___3, (size_t )203);
#line 4464
    syserr("readqf: %s: line %d: bad line \"%s\"", qf, LineNumber, tmp___39);
#line 4466
    err = (char *)"unrecognized line";
    }
#line 4467
    goto fail;
    switch_break: /* CIL Label */ ;
    }
#line 4470
    if ((unsigned long )bp___3 != (unsigned long )(buf___16)) {
      {
#line 4471
      sm_free_tagged((void *)bp___3, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     4471);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4479
  if (LineNumber == 0) {
    {
#line 4481
    tmp___40 = __errno_location();
#line 4481
    *tmp___40 = 0;
#line 4482
    e->e_flags |= 168UL;
    }
#line 4483
    return (1);
  }
#line 4487
  if (! nomore) {
    {
#line 4489
    syserr("readqf: %s: incomplete queue file read", qf);
#line 4490
    sm_io_close(qfp, -2);
    }
#line 4491
    return (0);
  }
#line 4495
  if ((e->e_flags & 1048576UL) != 0UL) {
#line 4497
    if ((e->e_flags & 4UL) != 0UL) {
      {
#line 4498
      tmp___41 = macid_parse((char *)"{dsn_ret}", (char **)((void *)0));
#line 4498
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___41, (char *)"hdrs", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                       4499, SmHeapGroup);
      }
    } else {
      {
#line 4501
      tmp___42 = macid_parse((char *)"{dsn_ret}", (char **)((void *)0));
#line 4501
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___42, (char *)"full", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                       4502, SmHeapGroup);
      }
    }
  }
  {
#line 4509
  p = queuename(e, 'd');
#line 4510
  e->e_dfp = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)p,
                        2, (void const   *)((void *)0));
  }
#line 4512
  if ((unsigned long )e->e_dfp == (unsigned long )((void *)0)) {
    {
#line 4514
    syserr("readqf: cannot open %s", p);
    }
  } else {
    {
#line 4518
    e->e_flags |= 2097152UL;
#line 4519
    tmp___44 = sm_io_getinfo(e->e_dfp, 3, (void *)0);
#line 4519
    tmp___45 = fstat(tmp___44, & st);
    }
#line 4519
    if (tmp___45 >= 0) {
      {
#line 4522
      e->e_msgsize = st.st_size + hdrsize;
#line 4523
      e->e_dfdev = st.st_dev;
#line 4524
      e->e_dfino = st.st_ino;
#line 4525
      sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%ld", e->e_msgsize);
#line 4527
      tmp___43 = macid_parse((char *)"{msg_size}", (char **)((void *)0));
#line 4527
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___43, buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                       4528, SmHeapGroup);
      }
    }
  }
#line 4532
  return (1);
  fail: 
#line 4544
  if ((unsigned long )qfp != (unsigned long )((void *)0)) {
    {
#line 4545
    sm_io_close(qfp, -2);
    }
  }
  {
#line 4546
  e->e_lockfp = (SM_FILE_T *)((void *)0);
#line 4547
  e->e_flags |= 2UL;
#line 4548
  loseqfile(e, err);
  }
#line 4549
  return (0);
}
}
#line 4565 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void prtstr(char *s , int ml ) 
{ 
  int c ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;

  {
#line 4572
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 4573
    return;
  }
  {
#line 4574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4574
    tmp___1 = ml;
#line 4574
    ml --;
#line 4574
    if (tmp___1 > 0) {
#line 4574
      tmp___2 = s;
#line 4574
      s ++;
#line 4574
      c = (int )*tmp___2;
#line 4574
      if (! (c != 0)) {
#line 4574
        goto while_break;
      }
    } else {
#line 4574
      goto while_break;
    }
#line 4576
    if (c == 92) {
#line 4578
      tmp = ml;
#line 4578
      ml --;
#line 4578
      if (tmp > 0) {
        {
#line 4580
        sm_io_putc(& SmIoF[1], -2, c);
#line 4581
        sm_io_putc(& SmIoF[1], -2, c);
        }
      }
    } else
#line 4584
    if ((c & -128) == 0) {
      {
#line 4584
      tmp___0 = __ctype_b_loc();
      }
#line 4584
      if ((int const   )*(*tmp___0 + c) & 16384) {
        {
#line 4585
        sm_io_putc(& SmIoF[1], -2, c);
        }
      } else {
#line 4584
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 4588
      ml -= 3;
#line 4588
      if (ml > 0) {
        {
#line 4589
        sm_io_fprintf(& SmIoF[1], -2, "\\%03o", c & 255);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4593
  return;
}
}
#line 4605 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void printnqe(SM_FILE_T *out , char *prefix ) 
{ 
  int i ;
  int k ;
  int nrequests ;
  bool unknown ;
  int j ;
  int n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 4611
  k = 0;
#line 4611
  nrequests = 0;
#line 4612
  unknown = 0;
#line 4614
  if (ShmId == -2) {
#line 4616
    if ((unsigned long )prefix == (unsigned long )((void *)0)) {
      {
#line 4617
      sm_io_fprintf(out, -2, "Data unavailable: shared memory not updated\n");
      }
    } else {
      {
#line 4620
      sm_io_fprintf(out, -2, "%sNOTCONFIGURED:-1\r\n", prefix);
      }
    }
#line 4622
    return;
  }
#line 4624
  i = 0;
  {
#line 4624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4624
    if (i < NumQueue) {
#line 4624
      if (! ((unsigned long )Queue[i] != (unsigned long )((void *)0))) {
#line 4624
        goto while_break;
      }
    } else {
#line 4624
      goto while_break;
    }
#line 4628
    k ++;
#line 4629
    j = 0;
    {
#line 4629
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4629
      if (! (j < (Queue[i])->qg_numqueues)) {
#line 4629
        goto while_break___0;
      }
#line 4633
      if (StopRequest) {
        {
#line 4634
        stop_sendmail();
        }
      }
#line 4636
      n = (QShm + ((Queue[i])->qg_qpaths + j)->qp_idx)->qs_entries;
#line 4637
      if ((unsigned long )prefix != (unsigned long )((void *)0)) {
        {
#line 4638
        tmp = qid_printqueue(i, j);
#line 4638
        sm_io_fprintf(out, -2, "%s%s:%d\r\n", prefix, tmp, n);
        }
      } else
#line 4641
      if (n < 0) {
        {
#line 4643
        tmp___0 = qid_printqueue(i, j);
#line 4643
        sm_io_fprintf(out, -2, "%s: unknown number of entries\n", tmp___0);
#line 4646
        unknown = 1;
        }
      } else
#line 4648
      if (n == 0) {
        {
#line 4650
        tmp___1 = qid_printqueue(i, j);
#line 4650
        sm_io_fprintf(out, -2, "%s is empty\n", tmp___1);
        }
      } else
#line 4654
      if (n > 0) {
        {
#line 4656
        tmp___2 = qid_printqueue(i, j);
#line 4656
        sm_io_fprintf(out, -2, "%s: entries=%d\n", tmp___2, n);
#line 4659
        nrequests += n;
#line 4660
        k ++;
        }
      }
#line 4629
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4624
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4664
  if ((unsigned long )prefix == (unsigned long )((void *)0)) {
#line 4664
    if (k > 1) {
#line 4665
      if (unknown) {
#line 4665
        tmp___3 = " (about)";
      } else {
#line 4665
        tmp___3 = "";
      }
      {
#line 4665
      sm_io_fprintf(out, -2, "\t\tTotal requests: %d%s\n", nrequests, tmp___3);
      }
    }
  }
#line 4676
  return;
}
}
#line 4690 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void printqueue(void) 
{ 
  int i ;
  int k ;
  int nrequests ;
  int j ;
  int tmp ;
  char *__cil_tmp6 ;

  {
#line 4693
  k = 0;
#line 4693
  nrequests = 0;
#line 4695
  i = 0;
  {
#line 4695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4695
    if (i < NumQueue) {
#line 4695
      if (! ((unsigned long )Queue[i] != (unsigned long )((void *)0))) {
#line 4695
        goto while_break;
      }
    } else {
#line 4695
      goto while_break;
    }
#line 4699
    k ++;
#line 4700
    j = 0;
    {
#line 4700
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4700
      if (! (j < (Queue[i])->qg_numqueues)) {
#line 4700
        goto while_break___0;
      }
#line 4702
      if (StopRequest) {
        {
#line 4703
        stop_sendmail();
        }
      }
      {
#line 4704
      tmp = print_single_queue(i, j);
#line 4704
      nrequests += tmp;
#line 4705
      k ++;
#line 4700
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4695
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4708
  if (k > 1) {
    {
#line 4709
    sm_io_fprintf(& SmIoF[1], -2, "\t\tTotal requests: %d\n", nrequests);
    }
  }
#line 4712
  return;
}
}
#line 4767
gid_t InitialGidSet[65536] ;
#line 4727 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
int print_single_queue(int qgrp , int qdir ) 
{ 
  register WORK *w ;
  SM_FILE_T *f ;
  int nrequests ;
  char qd[4096] ;
  char qddf[4096] ;
  char buf___16[2048] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  struct stat st ;
  int n ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  struct stat st___0 ;
  time_t submittime ;
  long dfsize ;
  int flags ;
  int qfver ;
  char quarmsg[2048] ;
  char statmsg[2048] ;
  char bodytype[257] ;
  char qf[4096] ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  ENVELOPE e ;
  SM_RPOOL_T *tmp___11 ;
  char *df ;
  char *tmp___12 ;
  int tmp___13 ;
  bool tmp___14 ;
  int tmp___15 ;
  bool tmp___16 ;
  int *tmp___17 ;
  register int i ;
  register char *p ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;

  {
#line 4739
  if (qdir == -1) {
    {
#line 4741
    sm_strlcpy(qd, ".", (ssize_t )sizeof(qd));
#line 4742
    sm_strlcpy(qddf, ".", (ssize_t )sizeof(qddf));
    }
  } else {
#line 4746
    if (((int )((Queue[qgrp])->qg_qpaths + qdir)->qp_subdirs & 2) != 0) {
#line 4746
      tmp = "/qf";
    } else {
#line 4746
      tmp = "";
    }
    {
#line 4746
    sm_strlcpyn(qd, (ssize_t )sizeof(qd), 2, ((Queue[qgrp])->qg_qpaths + qdir)->qp_name,
                tmp);
    }
#line 4751
    if (((int )((Queue[qgrp])->qg_qpaths + qdir)->qp_subdirs & 1) != 0) {
#line 4751
      tmp___0 = "/df";
    } else {
#line 4751
      tmp___0 = "";
    }
    {
#line 4751
    sm_strlcpyn(qddf, (ssize_t )sizeof(qddf), 2, ((Queue[qgrp])->qg_qpaths + qdir)->qp_name,
                tmp___0);
    }
  }
#line 4762
  if ((PrivacyFlags & 65536UL) != 0UL) {
#line 4762
    if (RealUid != 0U) {
      {
#line 4770
      tmp___2 = stat((char const   */* __restrict  */)(qd), (struct stat */* __restrict  */)(& st));
      }
#line 4770
      if (tmp___2 < 0) {
        {
#line 4772
        tmp___1 = qid_printqueue(qgrp, qdir);
#line 4772
        syserr("Cannot stat %s", tmp___1);
        }
#line 4774
        return (0);
      }
#line 4777
      n = 65536;
      {
#line 4778
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4778
        n --;
#line 4778
        if (! (n >= 0)) {
#line 4778
          goto while_break;
        }
#line 4780
        if (InitialGidSet[n] == st.st_gid) {
#line 4781
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 4783
      if (n < 0) {
#line 4783
        if (RealGid != st.st_gid) {
          {
#line 4788
          usrerr("510 You are not permitted to see the queue");
          }
#line 4789
          if (ExitStat == 0) {
#line 4789
            ExitStat = 77;
          } else
#line 4789
          if (ExitStat == 75) {
#line 4789
            ExitStat = 77;
          }
#line 4790
          return (0);
        }
      }
    }
  }
  {
#line 4798
  nrequests = gatherq(qgrp, qdir, 1, (bool *)((void *)0), (bool *)((void *)0));
#line 4799
  sortq((Queue[qgrp])->qg_maxlist);
  }
#line 4806
  if (nrequests <= 0) {
    {
#line 4808
    tmp___3 = qid_printqueue(qgrp, qdir);
#line 4808
    sm_io_fprintf(& SmIoF[1], -2, "%s is empty\n", tmp___3);
    }
#line 4810
    return (0);
  }
  {
#line 4813
  sm_getla();
  }
#line 4815
  if (nrequests == 1) {
#line 4815
    tmp___4 = "";
  } else {
#line 4815
    tmp___4 = "s";
  }
  {
#line 4815
  tmp___5 = qid_printqueue(qgrp, qdir);
#line 4815
  sm_io_fprintf(& SmIoF[1], -2, "\t\t%s (%d request%s", tmp___5, nrequests, tmp___4);
  }
#line 4818
  if (MaxQueueRun > 0) {
#line 4818
    if (nrequests > MaxQueueRun) {
      {
#line 4819
      sm_io_fprintf(& SmIoF[1], -2, ", only %d printed", MaxQueueRun);
      }
    }
  }
#line 4821
  if (Verbose) {
    {
#line 4822
    sm_io_fprintf(& SmIoF[1], -2, ")\n-----Q-ID----- --Size-- -Priority- ---Q-Time--- --------Sender/Recipient--------\n");
    }
  } else {
    {
#line 4825
    sm_io_fprintf(& SmIoF[1], -2, ")\n-----Q-ID----- --Size-- -----Q-Time----- ------------Sender/Recipient-----------\n");
    }
  }
#line 4827
  w = WorkQ;
  {
#line 4827
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4827
    if (! ((unsigned long )w != (unsigned long )((void *)0))) {
#line 4827
      goto while_break___0;
    }
#line 4830
    submittime = (time_t )0;
#line 4832
    flags = 0;
#line 4839
    if (StopRequest) {
      {
#line 4840
      stop_sendmail();
      }
    }
    {
#line 4842
    sm_io_fprintf(& SmIoF[1], -2, "%13s", w->w_name + 2);
#line 4844
    sm_strlcpyn(qf, (ssize_t )sizeof(qf), 3, qd, "/", w->w_name);
#line 4845
    f = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)(qf),
                   2, (void const   *)((void *)0));
    }
#line 4847
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 4849
      tmp___9 = __errno_location();
      }
#line 4849
      if (*tmp___9 == 1) {
        {
#line 4850
        sm_io_fprintf(& SmIoF[1], -2, " (permission denied)\n");
        }
      } else {
        {
#line 4852
        tmp___8 = __errno_location();
        }
#line 4852
        if (*tmp___8 == 2) {
          {
#line 4853
          sm_io_fprintf(& SmIoF[1], -2, " (job completed)\n");
          }
        } else {
          {
#line 4856
          tmp___6 = __errno_location();
#line 4856
          tmp___7 = sm_errstring(*tmp___6);
#line 4856
          sm_io_fprintf(& SmIoF[1], -2, " (%s)\n", tmp___7);
          }
        }
      }
      {
#line 4859
      tmp___10 = __errno_location();
#line 4859
      *tmp___10 = 0;
      }
#line 4860
      goto __Cont;
    }
    {
#line 4862
    *(w->w_name + 0) = (char )'d';
#line 4863
    sm_strlcpyn(qf, (ssize_t )sizeof(qf), 3, qddf, "/", w->w_name);
#line 4864
    tmp___15 = stat((char const   */* __restrict  */)(qf), (struct stat */* __restrict  */)(& st___0));
    }
#line 4864
    if (tmp___15 >= 0) {
#line 4865
      dfsize = st___0.st_size;
    } else {
      {
#line 4876
      tmp___11 = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 4876
      newenvelope(& e, & BlankEnvelope, tmp___11);
#line 4877
      e.e_id = w->w_name + 2;
#line 4878
      e.e_qgrp = qgrp;
#line 4879
      e.e_qdir = qdir;
#line 4880
      dfsize = -1L;
#line 4881
      tmp___14 = readqf(& e, 0);
      }
#line 4881
      if (tmp___14) {
        {
#line 4883
        tmp___12 = queuename(& e, 'd');
#line 4883
        df = tmp___12;
#line 4884
        tmp___13 = stat((char const   */* __restrict  */)df, (struct stat */* __restrict  */)(& st___0));
        }
#line 4884
        if (tmp___13 >= 0) {
#line 4885
          dfsize = st___0.st_size;
        }
      }
#line 4887
      if ((unsigned long )e.e_lockfp != (unsigned long )((void *)0)) {
        {
#line 4889
        sm_io_close(e.e_lockfp, -2);
#line 4890
        e.e_lockfp = (SM_FILE_T *)((void *)0);
        }
      }
      {
#line 4892
      clearenvelope(& e, 0, e.e_rpool);
#line 4893
      sm_rpool_free(e.e_rpool);
      }
    }
#line 4895
    if (w->w_lock) {
      {
#line 4896
      sm_io_fprintf(& SmIoF[1], -2, "*");
      }
    } else
#line 4897
    if (QueueMode == 76) {
      {
#line 4898
      sm_io_fprintf(& SmIoF[1], -2, "?");
      }
    } else
#line 4899
    if (w->w_tooyoung) {
      {
#line 4900
      sm_io_fprintf(& SmIoF[1], -2, "-");
      }
    } else {
      {
#line 4901
      tmp___16 = shouldqueue(w->w_pri, w->w_ctime);
      }
#line 4901
      if (tmp___16) {
        {
#line 4902
        sm_io_fprintf(& SmIoF[1], -2, "X");
        }
      } else {
        {
#line 4904
        sm_io_fprintf(& SmIoF[1], -2, " ");
        }
      }
    }
    {
#line 4906
    tmp___17 = __errno_location();
#line 4906
    *tmp___17 = 0;
#line 4908
    quarmsg[0] = (char )'\000';
#line 4909
    bodytype[0] = (char )'\000';
#line 4909
    statmsg[0] = bodytype[0];
#line 4910
    qfver = 0;
    }
    {
#line 4911
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 4911
      tmp___26 = sm_io_fgets(f, -2, buf___16, (int )sizeof(buf___16));
      }
#line 4911
      if (! ((unsigned long )tmp___26 != (unsigned long )((void *)0))) {
#line 4911
        goto while_break___1;
      }
#line 4916
      if (StopRequest) {
        {
#line 4917
        stop_sendmail();
        }
      }
      {
#line 4919
      fixcrlf(buf___16, 1);
      }
      {
#line 4922
      if ((int )buf___16[0] == 86) {
#line 4922
        goto case_86;
      }
#line 4926
      if ((int )buf___16[0] == 77) {
#line 4926
        goto case_77;
      }
#line 4933
      if ((int )buf___16[0] == 113) {
#line 4933
        goto case_113;
      }
#line 4940
      if ((int )buf___16[0] == 66) {
#line 4940
        goto case_66;
      }
#line 4947
      if ((int )buf___16[0] == 83) {
#line 4947
        goto case_83;
      }
#line 4996
      if ((int )buf___16[0] == 67) {
#line 4996
        goto case_67;
      }
#line 5004
      if ((int )buf___16[0] == 82) {
#line 5004
        goto case_82;
      }
#line 5037
      if ((int )buf___16[0] == 84) {
#line 5037
        goto case_84;
      }
#line 5041
      if ((int )buf___16[0] == 70) {
#line 5041
        goto case_70;
      }
#line 4920
      goto switch_break;
      case_86: /* CIL Label */ 
      {
#line 4923
      qfver = atoi((char const   *)(& buf___16[1]));
      }
#line 4924
      goto switch_break;
      case_77: /* CIL Label */ 
      {
#line 4927
      tmp___18 = strlen((char const   *)(& buf___16[1]));
#line 4927
      i = (int )tmp___18;
      }
#line 4927
      if ((unsigned long )i >= sizeof(statmsg)) {
#line 4928
        i = (int )(sizeof(statmsg) - 1UL);
      }
      {
#line 4929
      memmove((void *)(statmsg), (void const   *)(& buf___16[1]), (size_t )i);
#line 4930
      statmsg[i] = (char )'\000';
      }
#line 4931
      goto switch_break;
      case_113: /* CIL Label */ 
      {
#line 4934
      tmp___19 = strlen((char const   *)(& buf___16[1]));
#line 4934
      i = (int )tmp___19;
      }
#line 4934
      if ((unsigned long )i >= sizeof(quarmsg)) {
#line 4935
        i = (int )(sizeof(quarmsg) - 1UL);
      }
      {
#line 4936
      memmove((void *)(quarmsg), (void const   *)(& buf___16[1]), (size_t )i);
#line 4937
      quarmsg[i] = (char )'\000';
      }
#line 4938
      goto switch_break;
      case_66: /* CIL Label */ 
      {
#line 4941
      tmp___20 = strlen((char const   *)(& buf___16[1]));
#line 4941
      i = (int )tmp___20;
      }
#line 4941
      if ((unsigned long )i >= sizeof(bodytype)) {
#line 4942
        i = (int )(sizeof(bodytype) - 1UL);
      }
      {
#line 4943
      memmove((void *)(bodytype), (void const   *)(& buf___16[1]), (size_t )i);
#line 4944
      bodytype[i] = (char )'\000';
      }
#line 4945
      goto switch_break;
      case_83: /* CIL Label */ 
#line 4948
      if (Verbose) {
        {
#line 4950
        tmp___21 = ctime((time_t const   *)(& submittime));
        }
#line 4950
        if (((long )flags & 1024L) != 0L) {
#line 4950
          tmp___22 = '+';
        } else {
#line 4950
          tmp___22 = ' ';
        }
        {
#line 4950
        sm_io_fprintf(& SmIoF[1], -2, "%8ld %10ld%c%.12s ", dfsize, w->w_pri, tmp___22,
                      tmp___21 + 4);
#line 4958
        prtstr(& buf___16[1], 78);
        }
      } else {
        {
#line 4962
        tmp___23 = ctime((time_t const   *)(& submittime));
#line 4962
        sm_io_fprintf(& SmIoF[1], -2, "%8ld %.16s ", dfsize, tmp___23);
#line 4967
        prtstr(& buf___16[1], 39);
        }
      }
#line 4970
      if ((int )quarmsg[0] != 0) {
#line 4972
        if (Verbose) {
#line 4972
          tmp___24 = 100;
        } else {
#line 4972
          tmp___24 = 60;
        }
        {
#line 4972
        sm_io_fprintf(& SmIoF[1], -2, "\n     QUARANTINE: %.*s", tmp___24, quarmsg);
#line 4977
        quarmsg[0] = (char )'\000';
        }
      }
#line 4980
      if ((int )statmsg[0] != 0) {
#line 4980
        goto _L;
      } else
#line 4980
      if ((int )bodytype[0] != 0) {
        _L: /* CIL Label */ 
        {
#line 4982
        sm_io_fprintf(& SmIoF[1], -2, "\n    %10.10s", bodytype);
        }
#line 4986
        if ((int )statmsg[0] != 0) {
#line 4987
          if (Verbose) {
#line 4987
            tmp___25 = 100;
          } else {
#line 4987
            tmp___25 = 60;
          }
          {
#line 4987
          sm_io_fprintf(& SmIoF[1], -2, "   (%.*s)", tmp___25, statmsg);
          }
        }
#line 4992
        statmsg[0] = (char )'\000';
      }
#line 4994
      goto switch_break;
      case_67: /* CIL Label */ 
#line 4997
      if (Verbose) {
        {
#line 4998
        sm_io_fprintf(& SmIoF[1], -2, "\n\t\t\t\t\t\t(---%.64s---)", & buf___16[1]);
        }
      }
#line 5002
      goto switch_break;
      case_82: /* CIL Label */ 
#line 5005
      p = & buf___16[1];
#line 5006
      if (qfver >= 1) {
        {
#line 5008
        p = strchr((char const   *)p, ':');
        }
#line 5009
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5010
          goto switch_break;
        }
#line 5011
        p ++;
      }
#line 5013
      if (Verbose) {
        {
#line 5015
        sm_io_fprintf(& SmIoF[1], -2, "\n\t\t\t\t\t\t");
#line 5018
        prtstr(p, 71);
        }
      } else {
        {
#line 5022
        sm_io_fprintf(& SmIoF[1], -2, "\n\t\t\t\t\t ");
#line 5025
        prtstr(p, 38);
        }
      }
#line 5027
      if (Verbose) {
#line 5027
        if ((int )statmsg[0] != 0) {
          {
#line 5029
          sm_io_fprintf(& SmIoF[1], -2, "\n\t\t (%.100s)", statmsg);
#line 5033
          statmsg[0] = (char )'\000';
          }
        }
      }
#line 5035
      goto switch_break;
      case_84: /* CIL Label */ 
      {
#line 5038
      submittime = atol((char const   *)(& buf___16[1]));
      }
#line 5039
      goto switch_break;
      case_70: /* CIL Label */ 
#line 5042
      p = & buf___16[1];
      {
#line 5042
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 5042
        if (! ((int )*p != 0)) {
#line 5042
          goto while_break___2;
        }
        {
#line 5046
        if ((int )*p == 119) {
#line 5046
          goto case_119;
        }
#line 5044
        goto switch_break___0;
        case_119: /* CIL Label */ 
#line 5047
        flags = (int )((long )flags | 1024L);
#line 5048
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 5042
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5053
    if (submittime == 0L) {
      {
#line 5054
      sm_io_fprintf(& SmIoF[1], -2, " (no control file)");
      }
    }
    {
#line 5056
    sm_io_fprintf(& SmIoF[1], -2, "\n");
#line 5057
    sm_io_close(f, -2);
    }
    __Cont: /* CIL Label */ 
#line 4827
    w = w->w_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5059
  return (nrequests);
}
}
#line 5074 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static char queue_letter(ENVELOPE *e , int type ) 
{ 


  {
#line 5080
  if (type == 63) {
#line 5082
    if ((unsigned long )e->e_quarmsg != (unsigned long )((void *)0)) {
#line 5083
      type = 'h';
    } else {
      {
#line 5088
      if (QueueMode == 32) {
#line 5088
        goto case_32;
      }
#line 5092
      if (QueueMode == 81) {
#line 5092
        goto case_81;
      }
#line 5096
      if (QueueMode == 76) {
#line 5096
        goto case_76;
      }
#line 5100
      goto switch_default;
      case_32: /* CIL Label */ 
#line 5089
      type = 'q';
#line 5090
      goto switch_break;
      case_81: /* CIL Label */ 
#line 5093
      type = 'h';
#line 5094
      goto switch_break;
      case_76: /* CIL Label */ 
#line 5097
      type = 'Q';
#line 5098
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 5102
      abort();
      }
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 5107
  return ((char )type);
}
}
#line 5135 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static char buf___5[4096]  ;
#line 5127 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
char *queuename(ENVELOPE *e , int type ) 
{ 
  int qd ;
  int qg ;
  char *sub ;
  char pref[3] ;
  char tmp ;
  long tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 5133
  sub = (char *)"/";
#line 5138
  if ((unsigned long )e->e_id == (unsigned long )((void *)0)) {
    {
#line 5139
    assign_queueid(e);
    }
  }
  {
#line 5140
  tmp = queue_letter(e, type);
#line 5140
  type = (int )tmp;
#line 5143
  pref[0] = (char )type;
#line 5144
  pref[1] = (char )'f';
#line 5145
  pref[2] = (char )'\000';
  }
#line 5148
  if (type == 120) {
#line 5158
    if (e->e_xfqgrp == -1) {
#line 5158
      goto _L___0;
    } else
#line 5158
    if (e->e_xfqdir == -1) {
      _L___0: /* CIL Label */ 
#line 5160
      if (e->e_qgrp != -1) {
#line 5160
        if (e->e_qdir != -1) {
#line 5162
          e->e_xfqgrp = e->e_qgrp;
#line 5163
          e->e_xfqdir = e->e_qdir;
        } else {
#line 5160
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 5167
        e->e_xfqgrp = 0;
#line 5168
        if ((Queue[e->e_xfqgrp])->qg_numqueues <= 1) {
#line 5169
          e->e_xfqdir = 0;
        } else {
          {
#line 5172
          tmp___0 = random();
#line 5172
          e->e_xfqdir = (int )(tmp___0 % (long )(Queue[e->e_xfqgrp])->qg_numqueues);
          }
        }
      }
    }
#line 5177
    qd = e->e_xfqdir;
#line 5178
    qg = e->e_xfqgrp;
  } else {
#line 5182
    if (e->e_qgrp == -1) {
      {
#line 5183
      setnewqueue(e);
      }
    } else
#line 5182
    if (e->e_qdir == -1) {
      {
#line 5183
      setnewqueue(e);
      }
    }
#line 5184
    if (type == 100) {
#line 5186
      qd = e->e_dfqdir;
#line 5187
      qg = e->e_dfqgrp;
    } else {
#line 5191
      qd = e->e_qdir;
#line 5192
      qg = e->e_qgrp;
    }
  }
#line 5197
  if (e->e_qdir == -1) {
#line 5197
    if (type != 120) {
      {
#line 5198
      sm_strlcpyn(buf___5, (ssize_t )sizeof(buf___5), 2, pref, e->e_id);
      }
    } else {
#line 5197
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 5203
    if (type == 100) {
#line 5203
      goto case_100;
    }
#line 5212
    if (type == 113) {
#line 5212
      goto case_113;
    }
#line 5212
    if (type == 81) {
#line 5212
      goto case_113;
    }
#line 5212
    if (type == 116) {
#line 5212
      goto case_113;
    }
#line 5212
    if (type == 84) {
#line 5212
      goto case_113;
    }
#line 5212
    if (type == 104) {
#line 5212
      goto case_113;
    }
#line 5217
    if (type == 120) {
#line 5217
      goto case_120;
    }
#line 5222
    goto switch_default;
    case_100: /* CIL Label */ 
#line 5204
    if (((int )((Queue[qg])->qg_qpaths + qd)->qp_subdirs & 1) != 0) {
#line 5205
      sub = (char *)"/df/";
    }
#line 5206
    goto switch_break;
    case_113: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_104: /* CIL Label */ 
#line 5213
    if (((int )((Queue[qg])->qg_qpaths + qd)->qp_subdirs & 2) != 0) {
#line 5214
      sub = (char *)"/qf/";
    }
#line 5215
    goto switch_break;
    case_120: /* CIL Label */ 
#line 5218
    if (((int )((Queue[qg])->qg_qpaths + qd)->qp_subdirs & 4) != 0) {
#line 5219
      sub = (char *)"/xf/";
    }
#line 5220
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 5223
    sm_abort((char *)"queuename: bad queue file type %d", type);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 5226
    sm_strlcpyn(buf___5, (ssize_t )sizeof(buf___5), 4, ((Queue[qg])->qg_qpaths + qd)->qp_name,
                sub, pref, e->e_id);
    }
  }
#line 5231
  if ((int )tTdvect[7] >= 2) {
    {
#line 5232
    sm_dprintf((char *)"queuename: %s\n", buf___5);
    }
  }
#line 5233
  return (buf___5);
}
}
#line 5258 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void init_qid_alg(void) 
{ 


  {
#line 5261
  LastQueueTime = (time_t )0;
#line 5262
  LastQueuePid = -1;
#line 5263
  return;
}
}
#line 5281 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static char const   QueueIdChars[63]  = 
#line 5281
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'\000'};
#line 5303 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int cX  =    0;
#line 5304 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static long random_offset  ;
#line 5298 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void assign_queueid(ENVELOPE *e ) 
{ 
  pid_t pid ;
  struct tm *tm ;
  char idbuf___0[19] ;
  int seq ;
  time_t then ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 5302
  pid = CurrentPid;
#line 5309
  if ((unsigned long )e->e_id != (unsigned long )((void *)0)) {
#line 5310
    return;
  }
#line 5313
  if (cX >= 3600) {
#line 5313
    goto _L;
  } else
#line 5313
  if (LastQueueTime == 0L) {
#line 5313
    goto _L;
  } else
#line 5313
  if (LastQueuePid != pid) {
    _L: /* CIL Label */ 
#line 5316
    then = LastQueueTime;
#line 5319
    if (LastQueueTime == 0L) {
      {
#line 5320
      random_offset = random();
      }
    }
    {
#line 5322
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 5322
      LastQueueTime = curtime();
      }
#line 5322
      if (LastQueueTime == then) {
#line 5322
        if (! (LastQueuePid == pid)) {
#line 5322
          goto while_break;
        }
      } else {
#line 5322
        goto while_break;
      }
      {
#line 5325
      sleep(1U);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 5327
    LastQueuePid = CurrentPid;
#line 5328
    cX = 0;
  }
#line 5338
  seq = (int )(((long )cX + random_offset) % 3600L);
#line 5339
  cX ++;
#line 5340
  if ((int )tTdvect[7] >= 50) {
    {
#line 5341
    sm_dprintf((char *)"assign_queueid: random_offset = %ld (%d)\n", random_offset,
               seq);
    }
  }
  {
#line 5344
  tm = gmtime((time_t const   *)(& LastQueueTime));
#line 5345
  idbuf___0[0] = (char )QueueIdChars[tm->tm_year % 60];
#line 5346
  idbuf___0[1] = (char )QueueIdChars[tm->tm_mon];
#line 5347
  idbuf___0[2] = (char )QueueIdChars[tm->tm_mday];
#line 5348
  idbuf___0[3] = (char )QueueIdChars[tm->tm_hour];
#line 5349
  idbuf___0[4] = (char )QueueIdChars[tm->tm_min % 62];
#line 5350
  idbuf___0[5] = (char )QueueIdChars[tm->tm_sec % 62];
#line 5351
  idbuf___0[6] = (char )QueueIdChars[seq / 60];
#line 5352
  idbuf___0[7] = (char )QueueIdChars[seq % 60];
#line 5353
  sm_snprintf(& idbuf___0[8], (size_t )(sizeof(idbuf___0) - 8UL), "%06d", LastQueuePid);
#line 5355
  e->e_id = sm_rpool_strdup_x(e->e_rpool, (char const   *)(idbuf___0));
#line 5356
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'i', e->e_id, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                   5356, SmHeapGroup);
#line 5365
  e->e_qfletter = (char )'\000';
  }
#line 5367
  if ((int )tTdvect[7] >= 1) {
    {
#line 5368
    sm_dprintf((char *)"assign_queueid: assigned id %s, e=%p\n", e->e_id, e);
    }
  }
#line 5370
  if (LogLevel > 93) {
    {
#line 5371
    sm_syslog(7, (char const   *)e->e_id, "assigned id");
    }
  }
#line 5372
  return;
}
}
#line 5389 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void sync_queue_time(void) 
{ 


  {
#line 5400
  return;
}
}
#line 5414 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void unlockqueue(ENVELOPE *e ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 5418
  if ((int )tTdvect[51] >= 4) {
#line 5419
    if ((unsigned long )e->e_id == (unsigned long )((void *)0)) {
#line 5419
      tmp = "NOQUEUE";
    } else {
#line 5419
      tmp = (char const   *)e->e_id;
    }
    {
#line 5419
    sm_dprintf((char *)"unlockqueue(%s)\n", tmp);
    }
  }
#line 5424
  if ((unsigned long )e->e_lockfp != (unsigned long )((void *)0)) {
    {
#line 5425
    sm_io_close(e->e_lockfp, -2);
    }
  }
#line 5426
  e->e_lockfp = (SM_FILE_T *)((void *)0);
#line 5429
  if ((unsigned long )e->e_id == (unsigned long )((void *)0)) {
#line 5430
    return;
  }
#line 5433
  if (LogLevel > 87) {
    {
#line 5434
    sm_syslog(7, (char const   *)e->e_id, "unlock");
    }
  }
#line 5435
  if (! ((int )tTdvect[51] >= 104)) {
    {
#line 5436
    tmp___0 = queuename(e, 'x');
#line 5436
    xunlink(tmp___0);
    }
  }
#line 5437
  return;
}
}
#line 5455 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static ADDRESS *setctluser(char *user , int qfver , ENVELOPE *e ) 
{ 
  register ADDRESS *a ;
  struct passwd *pw ;
  char *p ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *o ;
  int tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 5469
  if ((unsigned long )user == (unsigned long )((void *)0)) {
#line 5470
    return ((ADDRESS *)((void *)0));
  } else
#line 5469
  if ((int )*user == 0) {
#line 5470
    return ((ADDRESS *)((void *)0));
  }
  {
#line 5476
  tmp = sm_rpool_malloc_tagged_x(e->e_rpool, (size_t )sizeof(*a), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                                 5476, SmHeapGroup);
#line 5476
  a = (ADDRESS *)tmp;
#line 5477
  memset((void *)((char *)a), '\000', (size_t )sizeof(*a));
  }
#line 5479
  if ((int )*user == 58) {
    {
#line 5481
    p = user + 1;
#line 5482
    a->q_user = sm_rpool_strdup_x(e->e_rpool, (char const   *)p);
    }
  } else {
    {
#line 5486
    p = strtok((char */* __restrict  */)user, (char const   */* __restrict  */)":");
#line 5487
    a->q_user = sm_rpool_strdup_x(e->e_rpool, (char const   *)user);
    }
#line 5488
    if (qfver >= 2) {
      {
#line 5490
      p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
      }
#line 5490
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 5491
        tmp___0 = atoi((char const   *)p);
#line 5491
        a->q_uid = (uid_t )tmp___0;
        }
      }
      {
#line 5492
      p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
      }
#line 5492
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 5493
        tmp___1 = atoi((char const   *)p);
#line 5493
        a->q_gid = (gid_t )tmp___1;
        }
      }
      {
#line 5494
      p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
      }
#line 5494
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 5498
        a->q_flags |= 1UL;
#line 5501
        o = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
        }
#line 5501
        if ((unsigned long )o != (unsigned long )((void *)0)) {
#line 5501
          if ((unsigned long )o > (unsigned long )p) {
#line 5502
            *(o + -1) = (char )':';
          }
        }
      }
    } else {
      {
#line 5505
      pw = sm_getpwnam(user);
      }
#line 5505
      if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 5507
        if ((int )*(pw->pw_dir) == 0) {
#line 5508
          a->q_home = (char *)((void *)0);
        } else {
          {
#line 5509
          tmp___2 = strcmp((char const   *)pw->pw_dir, "/");
          }
#line 5509
          if (tmp___2 == 0) {
#line 5510
            a->q_home = (char *)"";
          } else {
            {
#line 5512
            a->q_home = sm_rpool_strdup_x(e->e_rpool, (char const   *)pw->pw_dir);
            }
          }
        }
#line 5513
        a->q_uid = pw->pw_uid;
#line 5514
        a->q_gid = pw->pw_gid;
#line 5515
        a->q_flags |= 1UL;
      }
    }
  }
#line 5519
  a->q_flags |= 2UL;
#line 5520
  a->q_mailer = LocalMailer;
#line 5521
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 5522
    a->q_paddr = sm_rpool_strdup_x(e->e_rpool, (char const   *)a->q_user);
    }
  } else {
    {
#line 5524
    a->q_paddr = sm_rpool_strdup_x(e->e_rpool, (char const   *)p);
    }
  }
#line 5525
  return (a);
}
}
#line 5538 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void loseqfile(ENVELOPE *e , char *why ) 
{ 
  bool loseit ;
  char *p ;
  char buf___16[4096] ;
  size_t tmp ;
  __uid_t tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 5543
  loseit = 1;
#line 5547
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 5548
    return;
  } else
#line 5547
  if ((unsigned long )e->e_id == (unsigned long )((void *)0)) {
#line 5548
    return;
  }
  {
#line 5549
  p = queuename(e, '?');
#line 5550
  tmp = sm_strlcpy(buf___16, (char const   *)p, (ssize_t )sizeof(buf___16));
  }
#line 5550
  if ((unsigned long )tmp >= sizeof(buf___16)) {
#line 5551
    return;
  }
#line 5552
  if (! ((e->e_flags & 2UL) != 0UL)) {
    {
#line 5553
    queueup(e, 0, 1);
    }
  } else
#line 5554
  if (QueueMode == 76) {
#line 5555
    loseit = 0;
  }
#line 5558
  if (loseit) {
    {
#line 5560
    p = queuename(e, 'Q');
#line 5561
    tmp___1 = rename((char const   *)(buf___16), (char const   *)p);
    }
#line 5561
    if (tmp___1 < 0) {
      {
#line 5562
      tmp___0 = geteuid();
#line 5562
      syserr("cannot rename(%s, %s), uid=%d", buf___16, p, (int )tmp___0);
      }
    } else
#line 5564
    if (LogLevel > 0) {
      {
#line 5565
      sm_syslog(1, (char const   *)e->e_id, "Losing %s: %s", buf___16, why);
      }
    }
  }
#line 5568
  if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
    {
#line 5570
    sm_io_close(e->e_dfp, -2);
#line 5571
    e->e_dfp = (SM_FILE_T *)((void *)0);
    }
  }
#line 5573
  e->e_flags &= 0xffffffffffdfffffUL;
#line 5574
  return;
}
}
#line 5586 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
int name2qid(char *queuename___0 ) 
{ 
  register STAB *s ;

  {
  {
#line 5592
  s = stab(queuename___0, 15, 0);
  }
#line 5593
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 5594
    return (-1);
  }
#line 5595
  return ((int )(s->s_value.sv_queue)->qg_index);
}
}
#line 5612 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static char idbuf[55]  ;
#line 5607 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
char *qid_printname(ENVELOPE *e ) 
{ 
  char *id ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 5614
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 5615
    return ((char *)"");
  }
#line 5617
  if ((unsigned long )e->e_id == (unsigned long )((void *)0)) {
#line 5618
    id = (char *)"";
  } else {
#line 5620
    id = e->e_id;
  }
#line 5622
  if (e->e_qdir == -1) {
#line 5623
    return (id);
  }
  {
#line 5625
  sm_snprintf(idbuf, (size_t )sizeof(idbuf), "%.32s/%s", ((Queue[e->e_qgrp])->qg_qpaths + e->e_qdir)->qp_name,
              id);
  }
#line 5628
  return (idbuf);
}
}
#line 5647 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static char dir[4096]  ;
#line 5641 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
char *qid_printqueue(int qgrp , int qdir ) 
{ 
  char *subdir ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 5649
  if (qdir == -1) {
#line 5650
    return ((Queue[qgrp])->qg_qdir);
  }
  {
#line 5652
  tmp = strcmp((char const   *)((Queue[qgrp])->qg_qpaths + qdir)->qp_name, ".");
  }
#line 5652
  if (tmp == 0) {
#line 5653
    subdir = (char *)((void *)0);
  } else {
#line 5655
    subdir = ((Queue[qgrp])->qg_qpaths + qdir)->qp_name;
  }
#line 5657
  if (((int )((Queue[qgrp])->qg_qpaths + qdir)->qp_subdirs & 1) != 0) {
#line 5657
    tmp___0 = "/df";
  } else {
#line 5657
    tmp___0 = "";
  }
#line 5657
  if ((unsigned long )subdir == (unsigned long )((void *)0)) {
#line 5657
    tmp___1 = "";
  } else {
#line 5657
    tmp___1 = (char const   *)subdir;
  }
#line 5657
  if ((unsigned long )subdir == (unsigned long )((void *)0)) {
#line 5657
    tmp___2 = "";
  } else {
#line 5657
    tmp___2 = "/";
  }
  {
#line 5657
  sm_strlcpyn(dir, (ssize_t )sizeof(dir), 4, (Queue[qgrp])->qg_qdir, tmp___2, tmp___1,
              tmp___0);
  }
#line 5664
  return (dir);
}
}
#line 5688 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
int pickqdir(QUEUEGRP *qg , long fsize , ENVELOPE *e ) 
{ 
  int qdir ;
  int i ;
  long avail ;
  long tmp ;
  QPATHS *qp ;
  long needed ;
  long fsavail ;
  int tmp___0 ;
  long blksize ;
  char const   *tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 5696
  avail = 0L;
#line 5699
  if (qg->qg_numqueues <= 1) {
#line 5700
    qdir = 0;
  } else {
    {
#line 5702
    tmp = random();
#line 5702
    qdir = (int )(tmp % (long )qg->qg_numqueues);
    }
  }
#line 5704
  if (MinBlocksFree <= 0L) {
#line 5704
    if (fsize <= 0L) {
#line 5705
      return (qdir);
    }
  }
#line 5712
  i = qdir;
  {
#line 5713
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5715
    qp = qg->qg_qpaths + i;
#line 5716
    needed = 0L;
#line 5717
    fsavail = 0L;
#line 5719
    if (fsize > 0L) {
#line 5720
      if (fsize % (PtrFileSys + qp->qp_fsysidx)->fs_blksize > 0L) {
#line 5720
        tmp___0 = 1;
      } else {
#line 5720
        tmp___0 = 0;
      }
#line 5720
      needed += fsize / (PtrFileSys + qp->qp_fsysidx)->fs_blksize + (long )tmp___0;
    }
#line 5723
    if (MinBlocksFree > 0L) {
#line 5724
      needed += MinBlocksFree;
    }
#line 5725
    fsavail = (PtrFileSys + qp->qp_fsysidx)->fs_avail;
#line 5727
    if (fsavail <= 0L) {
      {
#line 5736
      fsavail = freediskspace(FSPath[qp->qp_fsysidx], & blksize);
      }
#line 5738
      if (fsavail < 0L) {
#line 5739
        fsavail = 0L;
      }
    }
#line 5742
    if (needed <= fsavail) {
#line 5743
      return (i);
    }
#line 5744
    if (avail < fsavail) {
#line 5745
      avail = fsavail;
    }
#line 5747
    if (qg->qg_numqueues > 0) {
#line 5748
      i = (i + 1) % qg->qg_numqueues;
    }
#line 5713
    if (! (i != qdir)) {
#line 5713
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5751
  if ((unsigned long )e != (unsigned long )((void *)0)) {
#line 5751
    if (LogLevel > 0) {
#line 5752
      if ((unsigned long )CurHostName == (unsigned long )((void *)0)) {
#line 5752
        tmp___1 = "SMTP-DAEMON";
      } else {
#line 5752
        tmp___1 = (char const   *)CurHostName;
      }
      {
#line 5752
      sm_syslog(1, (char const   *)e->e_id, "low on space (%s needs %ld bytes + %ld blocks in %s), max avail: %ld",
                tmp___1, fsize, MinBlocksFree, qg->qg_qdir, avail);
      }
    }
  }
#line 5757
  return (-1);
}
}
#line 5779 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
bool setnewqueue(ENVELOPE *e ) 
{ 
  ADDRESS *q ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 5783
  if ((int )tTdvect[41] >= 20) {
    {
#line 5784
    sm_dprintf((char *)"setnewqueue: called\n");
    }
  }
#line 5787
  if (e->e_qgrp == -1) {
#line 5803
    q = e->e_sendqueue;
    {
#line 5804
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5804
      if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 5804
        if (! ((int )q->q_state == 2)) {
#line 5804
          if (! ((int )q->q_state >= 6)) {
#line 5804
            goto while_break;
          }
        }
      } else {
#line 5804
        goto while_break;
      }
#line 5807
      q = q->q_next;
    }
    while_break: /* CIL Label */ ;
    }
#line 5809
    if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 5810
      e->e_qgrp = 0;
    } else
#line 5811
    if (q->q_qgrp >= 0) {
#line 5812
      e->e_qgrp = q->q_qgrp;
    } else
#line 5813
    if ((unsigned long )q->q_mailer != (unsigned long )((void *)0)) {
#line 5813
      if ((int )(q->q_mailer)->m_qgrp >= 0) {
#line 5815
        e->e_qgrp = (int )(q->q_mailer)->m_qgrp;
      } else {
#line 5817
        e->e_qgrp = 0;
      }
    } else {
#line 5817
      e->e_qgrp = 0;
    }
#line 5818
    e->e_dfqgrp = e->e_qgrp;
  }
#line 5821
  if (e->e_qdir >= 0) {
#line 5821
    if (e->e_dfqdir >= 0) {
#line 5823
      if ((int )tTdvect[41] >= 20) {
        {
#line 5824
        tmp = qid_printqueue(e->e_qgrp, e->e_qdir);
#line 5824
        sm_dprintf((char *)"setnewqueue: e_qdir already assigned (%s)\n", tmp);
        }
      }
#line 5826
      return (1);
    }
  }
  {
#line 5829
  filesys_update();
#line 5830
  e->e_qdir = pickqdir(Queue[e->e_qgrp], e->e_msgsize, e);
  }
#line 5831
  if (e->e_qdir == -1) {
#line 5833
    e->e_qgrp = -1;
#line 5834
    if (! ((e->e_flags & 32UL) != 0UL)) {
      {
#line 5835
      usrerr("452 4.4.5 Insufficient disk space; try again later");
      }
    }
#line 5836
    e->e_flags |= 32UL;
#line 5837
    return (0);
  }
#line 5840
  if ((int )tTdvect[41] >= 3) {
    {
#line 5841
    tmp___0 = qid_printqueue(e->e_qgrp, e->e_qdir);
#line 5841
    sm_dprintf((char *)"setnewqueue: Assigned queue directory %s\n", tmp___0);
    }
  }
#line 5844
  if (e->e_xfqgrp == -1) {
#line 5846
    e->e_xfqgrp = e->e_qgrp;
#line 5847
    e->e_xfqdir = e->e_qdir;
  } else
#line 5844
  if (e->e_xfqdir == -1) {
#line 5846
    e->e_xfqgrp = e->e_qgrp;
#line 5847
    e->e_xfqdir = e->e_qdir;
  }
#line 5849
  e->e_dfqdir = e->e_qdir;
#line 5850
  return (1);
}
}
#line 5863 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static bool chkqdir(char *name , long sff ) 
{ 
  struct stat statb ;
  int i ;
  int *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 5872
  if ((int )*(name + 0) == 46) {
#line 5872
    if ((int )*(name + 1) == 0) {
#line 5874
      return (0);
    } else
#line 5872
    if ((int )*(name + 1) == 46) {
#line 5872
      if ((int )*(name + 2) == 0) {
#line 5874
        return (0);
      }
    }
  }
  {
#line 5876
  tmp___1 = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& statb));
  }
#line 5876
  if (tmp___1 < 0) {
#line 5881
    if ((int )tTdvect[41] >= 2) {
      {
#line 5882
      tmp = __errno_location();
#line 5882
      tmp___0 = sm_errstring(*tmp);
#line 5882
      sm_dprintf((char *)"chkqdir: stat(\"%s\"): %s\n", name, tmp___0);
      }
    }
#line 5884
    return (0);
  }
#line 5887
  if ((statb.st_mode & 61440U) == 40960U) {
    {
#line 5894
    tmp___4 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& statb));
    }
#line 5894
    if (tmp___4 < 0) {
#line 5896
      if ((int )tTdvect[41] >= 2) {
        {
#line 5897
        tmp___2 = __errno_location();
#line 5897
        tmp___3 = sm_errstring(*tmp___2);
#line 5897
        sm_dprintf((char *)"chkqdir: stat(\"%s\"): %s\n", name, tmp___3);
        }
      }
#line 5899
      return (0);
    }
  }
#line 5904
  if (! ((statb.st_mode & 61440U) == 16384U)) {
#line 5906
    if ((int )tTdvect[41] >= 2) {
      {
#line 5907
      sm_dprintf((char *)"chkqdir: \"%s\": Not a directory\n", name);
      }
    }
#line 5909
    return (0);
  }
  {
#line 5914
  i = safedirpath(name, RunAsUid, RunAsGid, (char *)((void *)0), sff, 0, 0);
  }
#line 5915
  if (i != 0) {
#line 5917
    if ((int )tTdvect[41] >= 2) {
      {
#line 5918
      tmp___5 = sm_errstring(i);
#line 5918
      sm_dprintf((char *)"chkqdir: \"%s\": Not safe: %s\n", name, tmp___5);
      }
    }
  }
#line 5927
  return (1);
}
}
#line 5954 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int multiqueue_cache(char *basedir , int blen , QUEUEGRP *qg , int qn , unsigned int *phash ) 
{ 
  char *cp ;
  int i ;
  int len___0 ;
  int slotsleft ;
  long sff ;
  char qpath[4096] ;
  char subdir[4096] ;
  char prefix[4096] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  register DIR *dp ;
  register struct dirent *d ;
  int off ;
  char *delim ;
  char relpath[4096] ;
  char *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int *tmp___11 ;
  char const   *tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  bool tmp___16 ;
  char *tmp___17 ;
  void *tmp___18 ;
  bool tmp___19 ;
  bool tmp___20 ;
  bool tmp___21 ;
  char *tmp___22 ;
  char const   *tmp___23 ;
  bool tmp___24 ;
  bool tmp___25 ;
  bool tmp___26 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;

  {
#line 5964
  slotsleft = 0;
#line 5965
  sff = 0L;
#line 5970
  if ((int )tTdvect[41] >= 20) {
    {
#line 5971
    sm_dprintf((char *)"multiqueue_cache: called\n");
    }
  }
#line 5974
  prefix[0] = (char )'.';
#line 5975
  prefix[1] = (char )'\000';
#line 5976
  if (qg->qg_numqueues != 0) {
#line 5976
    if ((unsigned long )qg->qg_qpaths != (unsigned long )((void *)0)) {
#line 5978
      i = 0;
      {
#line 5978
      while (1) {
        while_continue: /* CIL Label */ ;
#line 5978
        if (! (i < qg->qg_numqueues)) {
#line 5978
          goto while_break;
        }
#line 5980
        if ((unsigned long )(qg->qg_qpaths + i)->qp_name != (unsigned long )((void *)0)) {
          {
#line 5981
          sm_free_tagged((void *)(qg->qg_qpaths + i)->qp_name, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                         5981);
          }
        }
#line 5978
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 5983
      sm_free_tagged((void *)((char *)qg->qg_qpaths), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     5983);
#line 5984
      qg->qg_qpaths = (QPATHS *)((void *)0);
#line 5985
      qg->qg_numqueues = 0;
      }
    }
  }
#line 5989
  if (RunAsUid == 0U) {
#line 5990
    sff |= 4L;
  }
#line 5997
  if (! ((int )*(qg->qg_qdir + 0) == 47)) {
    {
#line 6004
    syserr("QueuePath %s not absolute", qg->qg_qdir);
#line 6005
    ExitStat = 78;
    }
#line 6006
    return (qn);
  }
  {
#line 6010
  tmp = sm_strlcpy(qpath, (char const   *)qg->qg_qdir, (ssize_t )sizeof(qpath));
#line 6010
  len___0 = (int )tmp;
  }
#line 6011
  if ((unsigned long )len___0 >= sizeof(qpath)) {
    {
#line 6013
    syserr("QueuePath %.256s too long (%d max)", qg->qg_qdir, (int )sizeof(qpath));
#line 6015
    ExitStat = 78;
    }
#line 6016
    return (qn);
  }
  {
#line 6020
  tmp___0 = strncmp((char const   *)basedir, (char const   *)(qpath), (size_t )blen);
  }
#line 6020
  if (tmp___0 != 0) {
    {
#line 6020
    tmp___1 = strncmp((char const   *)basedir, (char const   *)(qpath), (size_t )(blen - 1));
    }
#line 6020
    if (tmp___1 != 0) {
      {
#line 6023
      syserr("QueuePath %s not subpath of QueueDirectory %s", qpath, basedir);
#line 6025
      ExitStat = 78;
      }
#line 6026
      return (qn);
    } else
#line 6020
    if (len___0 != blen - 1) {
      {
#line 6023
      syserr("QueuePath %s not subpath of QueueDirectory %s", qpath, basedir);
#line 6025
      ExitStat = 78;
      }
#line 6026
      return (qn);
    }
  }
#line 6030
  if (blen < len___0) {
    {
#line 6030
    tmp___4 = strchr((char const   *)(qg->qg_qdir + blen), '/');
    }
#line 6030
    if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
      {
#line 6034
      tmp___2 = sm_strlcpy(prefix, (char const   *)(qg->qg_qdir + blen), (ssize_t )sizeof(prefix));
      }
#line 6034
      if ((unsigned long )tmp___2 >= sizeof(prefix)) {
        {
#line 6037
        syserr("QueuePath %.256s too long (%d max)", qg->qg_qdir, (int )sizeof(qpath));
#line 6039
        ExitStat = 78;
        }
#line 6040
        return (qn);
      }
      {
#line 6042
      cp = strrchr((char const   *)(prefix), '/');
      }
#line 6043
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 6043
        tmp___3 = 1;
      } else {
        {
#line 6043
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                    6043, "SM_ASSERT(cp != NULL) failed");
#line 6043
        tmp___3 = 0;
        }
      }
#line 6044
      *cp = (char )'\000';
    }
  }
#line 6048
  if (len___0 >= blen - 1) {
#line 6048
    tmp___5 = 1;
  } else {
    {
#line 6048
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                6048, "SM_ASSERT(len >= blen - 1) failed");
#line 6048
    tmp___5 = 0;
    }
  }
#line 6049
  cp = & qpath[len___0 - 1];
#line 6050
  if ((int )*cp == 42) {
    {
#line 6058
    *cp = (char )'\000';
#line 6059
    cp = strrchr((char const   *)(qpath), '/');
    }
#line 6059
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
#line 6061
      syserr("QueueDirectory: can not wildcard relative path");
      }
#line 6062
      if ((int )tTdvect[41] >= 2) {
        {
#line 6063
        sm_dprintf((char *)"multiqueue_cache: \"%s*\": Can not wildcard relative path.\n",
                   qpath);
        }
      }
#line 6065
      ExitStat = 78;
#line 6066
      return (qn);
    }
#line 6068
    if ((unsigned long )cp == (unsigned long )(qpath)) {
      {
#line 6075
      sm_strlcpy(qpath + 1, (char const   *)(qpath), (ssize_t )(sizeof(qpath) - 1UL));
#line 6076
      cp ++;
      }
    }
    {
#line 6078
    delim = cp;
#line 6079
    tmp___6 = cp;
#line 6079
    cp ++;
#line 6079
    *tmp___6 = (char )'\000';
#line 6080
    tmp___7 = strlen((char const   *)cp);
#line 6080
    len___0 = (int )tmp___7;
#line 6088
    tmp___8 = sm_strlcpyn(relpath, (ssize_t )sizeof(relpath), 2, prefix, "/");
#line 6088
    off = (int )tmp___8;
    }
#line 6089
    if ((unsigned long )off < sizeof(relpath)) {
#line 6089
      tmp___9 = 1;
    } else {
      {
#line 6089
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                  6089, "SM_ASSERT(off < sizeof relpath) failed");
#line 6089
      tmp___9 = 0;
      }
    }
#line 6091
    if ((int )tTdvect[41] >= 2) {
      {
#line 6092
      sm_dprintf((char *)"multiqueue_cache: prefix=\"%s%s\"\n", relpath, cp);
      }
    }
    {
#line 6097
    qg->qg_qdir = newstr((char const   *)basedir);
#line 6098
    *(qg->qg_qdir + (blen - 1)) = (char )'\000';
    }
#line 6106
    if (qn == 0) {
      {
#line 6109
      i = safedirpath(basedir, RunAsUid, RunAsGid, (char *)((void *)0), sff, 0, 0);
      }
#line 6111
      if (i != 0) {
#line 6111
        if ((int )tTdvect[41] >= 2) {
          {
#line 6112
          tmp___10 = sm_errstring(i);
#line 6112
          sm_dprintf((char *)"multiqueue_cache: \"%s\": Not safe: %s\n", basedir,
                     tmp___10);
          }
        }
      }
    }
    {
#line 6116
    dp = opendir((char const   *)(prefix));
    }
#line 6116
    if ((unsigned long )dp == (unsigned long )((void *)0)) {
      {
#line 6118
      syserr("can not opendir(%s/%s)", qg->qg_qdir, prefix);
      }
#line 6119
      if ((int )tTdvect[41] >= 2) {
        {
#line 6120
        tmp___11 = __errno_location();
#line 6120
        tmp___12 = sm_errstring(*tmp___11);
#line 6120
        sm_dprintf((char *)"multiqueue_cache: opendir(\"%s/%s\"): %s\n", qg->qg_qdir,
                   prefix, tmp___12);
        }
      }
#line 6123
      ExitStat = 78;
#line 6124
      return (qn);
    }
    {
#line 6126
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 6126
      d = readdir(dp);
      }
#line 6126
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 6126
        goto while_break___0;
      }
      {
#line 6128
      tmp___13 = strlen((char const   *)(d->d_name));
#line 6128
      i = (int )tmp___13;
      }
#line 6129
      if (i < len___0) {
#line 6129
        goto _L;
      } else {
        {
#line 6129
        tmp___14 = strncmp((char const   *)(d->d_name), (char const   *)cp, (size_t )len___0);
        }
#line 6129
        if (tmp___14 != 0) {
          _L: /* CIL Label */ 
#line 6131
          if ((int )tTdvect[41] >= 5) {
            {
#line 6132
            sm_dprintf((char *)"multiqueue_cache: \"%s\", skipped\n", d->d_name);
            }
          }
#line 6134
          goto while_continue___0;
        }
      }
      {
#line 6138
      i = (int )(sizeof(relpath) - (unsigned long )off);
#line 6139
      tmp___15 = sm_strlcpy(relpath + off, (char const   *)(d->d_name), i);
      }
#line 6139
      if (tmp___15 >= (size_t )i) {
#line 6140
        goto while_continue___0;
      }
      {
#line 6142
      tmp___16 = chkqdir(relpath, sff);
      }
#line 6142
      if (! tmp___16) {
#line 6143
        goto while_continue___0;
      }
#line 6145
      if ((unsigned long )qg->qg_qpaths == (unsigned long )((void *)0)) {
        {
#line 6147
        slotsleft = 20;
#line 6148
        tmp___17 = xalloc_tagged((int )(sizeof(*(qg->qg_qpaths)) * (unsigned long )slotsleft),
                                 (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                                 6149);
#line 6148
        qg->qg_qpaths = (QPATHS *)tmp___17;
#line 6150
        qg->qg_numqueues = 0;
        }
      } else
#line 6152
      if (slotsleft < 1) {
        {
#line 6154
        tmp___18 = sm_realloc((void *)((char *)qg->qg_qpaths), (size_t )(sizeof(*(qg->qg_qpaths)) * (unsigned long )(qg->qg_numqueues + 10)));
#line 6154
        qg->qg_qpaths = (QPATHS *)tmp___18;
        }
#line 6158
        if ((unsigned long )qg->qg_qpaths == (unsigned long )((void *)0)) {
          {
#line 6160
          closedir(dp);
          }
#line 6161
          return (qn);
        }
#line 6163
        slotsleft += 10;
      }
      {
#line 6167
      (qg->qg_qpaths + qg->qg_numqueues)->qp_subdirs = (short)0;
#line 6176
      sm_strlcpyn(subdir, (ssize_t )sizeof(subdir), 3, relpath, "/", "qf");
#line 6176
      tmp___19 = chkqdir(subdir, sff);
      }
#line 6176
      if (tmp___19) {
#line 6176
        (qg->qg_qpaths + qg->qg_numqueues)->qp_subdirs = (short )((int )(qg->qg_qpaths + qg->qg_numqueues)->qp_subdirs | 2);
      }
      {
#line 6177
      sm_strlcpyn(subdir, (ssize_t )sizeof(subdir), 3, relpath, "/", "df");
#line 6177
      tmp___20 = chkqdir(subdir, sff);
      }
#line 6177
      if (tmp___20) {
#line 6177
        (qg->qg_qpaths + qg->qg_numqueues)->qp_subdirs = (short )((int )(qg->qg_qpaths + qg->qg_numqueues)->qp_subdirs | 1);
      }
      {
#line 6178
      sm_strlcpyn(subdir, (ssize_t )sizeof(subdir), 3, relpath, "/", "xf");
#line 6178
      tmp___21 = chkqdir(subdir, sff);
      }
#line 6178
      if (tmp___21) {
#line 6178
        (qg->qg_qpaths + qg->qg_numqueues)->qp_subdirs = (short )((int )(qg->qg_qpaths + qg->qg_numqueues)->qp_subdirs | 4);
      }
#line 6183
      if ((int )prefix[0] != 46) {
        {
#line 6184
        (qg->qg_qpaths + qg->qg_numqueues)->qp_name = newstr((char const   *)(relpath));
        }
      } else {
        {
#line 6187
        (qg->qg_qpaths + qg->qg_numqueues)->qp_name = newstr((char const   *)(d->d_name));
        }
      }
#line 6190
      if ((int )tTdvect[41] >= 2) {
        {
#line 6191
        sm_dprintf((char *)"multiqueue_cache: %d: \"%s\" cached (%x).\n", qg->qg_numqueues,
                   relpath, (int )(qg->qg_qpaths + qg->qg_numqueues)->qp_subdirs);
        }
      }
      {
#line 6195
      (qg->qg_qpaths + qg->qg_numqueues)->qp_idx = qn;
#line 6196
      *phash = hash_q(relpath, *phash);
#line 6198
      (qg->qg_numqueues) ++;
#line 6199
      qn ++;
#line 6200
      slotsleft --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 6202
    closedir(dp);
#line 6205
    *delim = (char )'/';
    }
  }
#line 6207
  if (qg->qg_numqueues == 0) {
    {
#line 6209
    tmp___22 = xalloc_tagged((int )sizeof(*(qg->qg_qpaths)), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                             6209);
#line 6209
    qg->qg_qpaths = (QPATHS *)tmp___22;
#line 6212
    i = safedirpath(qpath, RunAsUid, RunAsGid, (char *)((void *)0), sff, 0, 0);
    }
#line 6213
    if (i == 2) {
      {
#line 6215
      syserr("can not opendir(%s)", qpath);
      }
#line 6216
      if ((int )tTdvect[41] >= 2) {
        {
#line 6217
        tmp___23 = sm_errstring(i);
#line 6217
        sm_dprintf((char *)"multiqueue_cache: opendir(\"%s\"): %s\n", qpath, tmp___23);
        }
      }
#line 6219
      ExitStat = 78;
#line 6220
      return (qn);
    }
    {
#line 6223
    (qg->qg_qpaths + 0)->qp_subdirs = (short)0;
#line 6224
    qg->qg_numqueues = 1;
#line 6233
    sm_strlcpyn(subdir, (ssize_t )sizeof(subdir), 3, qg->qg_qdir, "/", "qf");
#line 6233
    tmp___24 = chkqdir(subdir, sff);
    }
#line 6233
    if (tmp___24) {
#line 6233
      (qg->qg_qpaths + 0)->qp_subdirs = (short )((int )(qg->qg_qpaths + 0)->qp_subdirs | 2);
    }
    {
#line 6234
    sm_strlcpyn(subdir, (ssize_t )sizeof(subdir), 3, qg->qg_qdir, "/", "df");
#line 6234
    tmp___25 = chkqdir(subdir, sff);
    }
#line 6234
    if (tmp___25) {
#line 6234
      (qg->qg_qpaths + 0)->qp_subdirs = (short )((int )(qg->qg_qpaths + 0)->qp_subdirs | 1);
    }
    {
#line 6235
    sm_strlcpyn(subdir, (ssize_t )sizeof(subdir), 3, qg->qg_qdir, "/", "xf");
#line 6235
    tmp___26 = chkqdir(subdir, sff);
    }
#line 6235
    if (tmp___26) {
#line 6235
      (qg->qg_qpaths + 0)->qp_subdirs = (short )((int )(qg->qg_qpaths + 0)->qp_subdirs | 4);
    }
#line 6237
    if ((int )*(qg->qg_qdir + (blen - 1)) != 0) {
#line 6237
      if ((int )*(qg->qg_qdir + blen) != 0) {
        {
#line 6245
        (qg->qg_qpaths + 0)->qp_name = newstr((char const   *)(qg->qg_qdir + blen));
#line 6246
        *(qg->qg_qdir + (blen - 1)) = (char )'\000';
        }
      } else {
        {
#line 6249
        (qg->qg_qpaths + 0)->qp_name = newstr(".");
        }
      }
    } else {
      {
#line 6249
      (qg->qg_qpaths + 0)->qp_name = newstr(".");
      }
    }
    {
#line 6252
    (qg->qg_qpaths + 0)->qp_idx = qn;
#line 6253
    *phash = hash_q((qg->qg_qpaths + 0)->qp_name, *phash);
#line 6255
    qn ++;
    }
  }
#line 6257
  return (qn);
}
}
#line 6282
static short filesys_find(char *name , char *path , bool add ) ;
#line 6288 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static short filesys_find(char *name , char *path , bool add ) 
{ 
  struct stat st ;
  short i ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 6297
  tmp = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
  }
#line 6297
  if (tmp < 0) {
    {
#line 6299
    syserr("cannot stat queue directory %s", path);
    }
#line 6300
    return ((short)-2);
  }
#line 6302
  i = (short)0;
  {
#line 6302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6302
    if (! ((int )i < *PNumFileSys)) {
#line 6302
      goto while_break;
    }
#line 6304
    if ((PtrFileSys + i)->fs_dev == st.st_dev) {
#line 6305
      return (i);
    }
#line 6302
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 6307
  if ((int )i >= 256) {
    {
#line 6309
    syserr("too many queue file systems (%d max)", 256);
    }
#line 6310
    return ((short)-3);
  }
#line 6312
  if (! add) {
#line 6313
    return ((short)-1);
  }
#line 6315
  (*PNumFileSys) ++;
#line 6316
  FSPath[i] = name;
#line 6317
  (PtrFileSys + i)->fs_dev = st.st_dev;
#line 6318
  (PtrFileSys + i)->fs_avail = 0L;
#line 6319
  (PtrFileSys + i)->fs_blksize = 1024L;
#line 6320
  return (i);
}
}
#line 6340
static int filesys_setup(bool add ) ;
#line 6342 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int filesys_setup(bool add ) 
{ 
  int i ;
  int j ;
  short fs ;
  int ret ;
  QPATHS *qp ;
  char qddf[4096] ;
  char const   *tmp ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 6350
  ret = 0;
#line 6351
  i = 0;
  {
#line 6351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6351
    if (i < NumQueue) {
#line 6351
      if (! ((unsigned long )Queue[i] != (unsigned long )((void *)0))) {
#line 6351
        goto while_break;
      }
    } else {
#line 6351
      goto while_break;
    }
#line 6353
    j = 0;
    {
#line 6353
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6353
      if (! (j < (Queue[i])->qg_numqueues)) {
#line 6353
        goto while_break___0;
      }
#line 6355
      qp = (Queue[i])->qg_qpaths + j;
#line 6358
      if (((int )qp->qp_subdirs & 1) != 0) {
#line 6358
        tmp = "/df";
      } else {
#line 6358
        tmp = "";
      }
      {
#line 6358
      sm_strlcpyn(qddf, (ssize_t )sizeof(qddf), 2, qp->qp_name, tmp);
#line 6361
      fs = filesys_find(qp->qp_name, qddf, add);
      }
#line 6362
      if ((int )fs >= 0) {
#line 6363
        qp->qp_fsysidx = fs;
      } else {
#line 6365
        qp->qp_fsysidx = (short)0;
      }
#line 6366
      if ((int )fs < ret) {
#line 6367
        ret = (int )fs;
      }
#line 6353
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6351
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6370
  return (ret);
}
}
#line 6396 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static time_t nextupdate  =    (time_t )0;
#line 6390 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void filesys_update(void) 
{ 
  int i ;
  long avail ;
  long blksize ;
  time_t now ;
  FILESYS *fs ;
  int *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 6400
  if (ShmId != -2) {
#line 6400
    if (DaemonPid != CurrentPid) {
#line 6401
      return;
    }
  }
  {
#line 6403
  now = curtime();
  }
#line 6404
  if (now < nextupdate) {
#line 6405
    return;
  }
#line 6406
  nextupdate = now + 300L;
#line 6407
  i = 0;
  {
#line 6407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6407
    if (! (i < *PNumFileSys)) {
#line 6407
      goto while_break;
    }
    {
#line 6409
    fs = PtrFileSys + i;
#line 6411
    avail = freediskspace(FSPath[i], & blksize);
    }
#line 6412
    if (avail < 0L) {
#line 6412
      goto _L;
    } else
#line 6412
    if (blksize <= 0L) {
      _L: /* CIL Label */ 
#line 6414
      if (LogLevel > 5) {
        {
#line 6415
        tmp = __errno_location();
#line 6415
        tmp___0 = sm_errstring(*tmp);
#line 6415
        sm_syslog(3, "*~*", "filesys_update failed: %s, fs=%s, avail=%ld, blocksize=%ld",
                  tmp___0, FSPath[i], avail, blksize);
        }
      }
#line 6419
      fs->fs_avail = 0L;
#line 6420
      fs->fs_blksize = 1024L;
#line 6421
      nextupdate = now + 2L;
    } else {
#line 6425
      fs->fs_avail = avail;
#line 6426
      fs->fs_blksize = blksize;
    }
#line 6407
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6429
  return;
}
}
#line 6526
static void init_sem(bool owner ) ;
#line 6528 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void init_sem(bool owner ) 
{ 


  {
#line 6544
  return;
}
}
#line 6557
static void stop_sem(bool owner ) ;
#line 6559 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void stop_sem(bool owner ) 
{ 


  {
#line 6569
  return;
}
}
#line 6590 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void upd_qs(ENVELOPE *e , int count , int space , char *where ) 
{ 
  short fidx ;
  int idx ;
  long s ;
  char *__cil_tmp8 ;

  {
#line 6604
  if (ShmId == -2) {
#line 6605
    return;
  } else
#line 6604
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 6605
    return;
  }
#line 6606
  if (e->e_qgrp == -1) {
#line 6607
    return;
  } else
#line 6606
  if (e->e_qdir == -1) {
#line 6607
    return;
  }
#line 6608
  idx = ((Queue[e->e_qgrp])->qg_qpaths + e->e_qdir)->qp_idx;
#line 6609
  if ((int )tTdvect[73] >= 2) {
    {
#line 6610
    sm_dprintf((char *)"func=upd_qs, count=%d, space=%d, where=%s, idx=%d, entries=%d\n",
               count, space, where, idx, (QShm + idx)->qs_entries);
    }
  }
#line 6614
  if ((QShm + idx)->qs_entries >= 0) {
#line 6614
    if (count != 0) {
#line 6619
      (QShm + idx)->qs_entries += count;
    }
  }
#line 6626
  fidx = ((Queue[e->e_qgrp])->qg_qpaths + e->e_qdir)->qp_fsysidx;
#line 6627
  if ((int )fidx < 0) {
#line 6628
    return;
  }
#line 6631
  if (space == 0) {
#line 6632
    return;
  }
#line 6635
  s = e->e_msgsize / (PtrFileSys + fidx)->fs_blksize;
#line 6636
  if (s == 0L) {
#line 6637
    return;
  }
#line 6640
  if (space > 0) {
#line 6641
    (PtrFileSys + fidx)->fs_avail += s;
  } else {
#line 6643
    (PtrFileSys + fidx)->fs_avail -= s;
  }
#line 6645
  return;
}
}
#line 6772
static void init_shm(int qn , bool owner , unsigned int hash ) ;
#line 6774 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static void init_shm(int qn , bool owner , unsigned int hash ) 
{ 
  int i ;
  int count ;
  int save_errno ;
  int *tmp ;
  int *p ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 6787
  PtrFileSys = & FileSys[0];
#line 6788
  PNumFileSys = & Numfilesys;
#line 6796
  if (ShmKey == 0) {
#line 6797
    return;
  }
#line 6799
  count = 0;
#line 6800
  shms = (size_t )((((sizeof(pid_t ) + sizeof(int ) * 2UL) + sizeof(FileSys)) + sizeof(int ) * 2UL) + (unsigned long )qn * sizeof(QUEUE_SHM_T ));
  {
#line 6816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 6819
    Pshm = sm_shmstart(ShmKey, (int )shms, (384 | (256 >> 3)) | (128 >> 3), & ShmId,
                       owner);
#line 6822
    tmp = __errno_location();
#line 6822
    save_errno = *tmp;
    }
#line 6823
    if ((unsigned long )Pshm != (unsigned long )((void *)0)) {
#line 6824
      goto while_break;
    } else
#line 6823
    if (! (save_errno == 17)) {
#line 6824
      goto while_break;
    }
#line 6825
    count ++;
#line 6825
    if (count >= 3) {
#line 6838
      goto while_break;
    }
    {
#line 6844
    sleep((unsigned int )count);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6846
  if ((unsigned long )Pshm != (unsigned long )((void *)0)) {
#line 6854
    if (owner) {
#line 6854
      if (RunAsUid != 0U) {
        {
#line 6856
        i = sm_shmsetowner(ShmId, RunAsUid, RunAsGid, (mode_t )432);
        }
#line 6857
        if (i != 0) {
          {
#line 6858
          sm_syslog(3, "*~*", "key=%ld, sm_shmsetowner=%d, RunAsUid=%d, RunAsGid=%d",
                    (long )ShmKey, i, RunAsUid, RunAsGid);
          }
        }
      }
    }
#line 6862
    p = (int *)Pshm;
#line 6863
    if (owner) {
#line 6865
      *p = (int )shms;
#line 6866
      *((pid_t *)((char *)Pshm + sizeof(int ))) = CurrentPid;
#line 6867
      p = (int *)(((char *)Pshm + sizeof(pid_t )) + sizeof(int ));
#line 6868
      *p = (int )hash;
    } else {
#line 6872
      if (*p != (int )shms) {
        {
#line 6874
        save_errno = 22;
#line 6875
        cleanup_shm(0);
        }
#line 6876
        goto error;
      }
#line 6878
      p = (int *)(((char *)Pshm + sizeof(pid_t )) + sizeof(int ));
#line 6879
      if (*p != (int )hash) {
        {
#line 6881
        save_errno = 22;
#line 6882
        cleanup_shm(0);
        }
#line 6883
        goto error;
      }
    }
#line 6895
    PtrFileSys = (FILESYS *)((char *)Pshm + (sizeof(pid_t ) + sizeof(int ) * 2UL));
#line 6896
    PNumFileSys = (int *)(((char *)Pshm + (sizeof(pid_t ) + sizeof(int ) * 2UL)) + sizeof(FileSys));
#line 6897
    QShm = (QUEUE_SHM_T *)((((char *)Pshm + (sizeof(pid_t ) + sizeof(int ) * 2UL)) + sizeof(FileSys)) + sizeof(int ) * 2UL);
#line 6898
    PRSATmpCnt = (int *)((((char *)Pshm + (sizeof(pid_t ) + sizeof(int ) * 2UL)) + sizeof(FileSys)) + sizeof(int ));
#line 6899
    *PRSATmpCnt = 0;
#line 6900
    if (owner) {
#line 6903
      *PNumFileSys = 0;
#line 6904
      i = 0;
      {
#line 6904
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 6904
        if (! (i < qn)) {
#line 6904
          goto while_break___0;
        }
#line 6905
        (QShm + i)->qs_entries = -1;
#line 6904
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 6907
    init_sem(owner);
    }
#line 6908
    return;
  }
  error: 
#line 6911
  if (owner) {
#line 6911
    tmp___3 = 8;
  } else {
#line 6911
    tmp___3 = 11;
  }
#line 6911
  if (LogLevel > tmp___3) {
    {
#line 6913
    tmp___0 = sm_errstring(save_errno);
    }
#line 6913
    if (owner) {
#line 6913
      tmp___1 = "initialize";
    } else {
#line 6913
      tmp___1 = "attach to";
    }
#line 6913
    if (owner) {
#line 6913
      tmp___2 = 3;
    } else {
#line 6913
      tmp___2 = 5;
    }
    {
#line 6913
    sm_syslog(tmp___2, "*~*", "can\'t %s shared memory, key=%ld: %s", tmp___1, (long )ShmKey,
              tmp___0);
    }
  }
#line 6918
  return;
}
}
#line 6937 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void setup_queues(bool owner ) 
{ 
  int i ;
  int qn ;
  int len___0 ;
  unsigned int hashval ;
  time_t now ;
  char basedir[4096] ;
  struct stat st ;
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *cp ;
  int tmp___2 ;
  int save_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  long sff ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
  {
#line 6954
  hashval = 0U;
#line 6955
  tmp = __errno_location();
#line 6955
  *tmp = 0;
#line 6956
  tmp___0 = sm_strlcpy(basedir, (char const   *)QueueDir, (ssize_t )sizeof(basedir));
#line 6956
  len___0 = (int )tmp___0;
  }
#line 6959
  if ((unsigned long )len___0 >= sizeof(basedir) - 1UL) {
    {
#line 6961
    syserr("QueueDirectory: path too long: %d,  max %d", len___0, (int )sizeof(basedir) - 1);
#line 6963
    ExitStat = 78;
    }
#line 6964
    return;
  }
#line 6966
  if (len___0 > 0) {
#line 6966
    tmp___1 = 1;
  } else {
    {
#line 6966
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                6966, "SM_ASSERT(len > 0) failed");
#line 6966
    tmp___1 = 0;
    }
  }
#line 6967
  if ((int )basedir[len___0 - 1] == 42) {
    {
#line 6971
    cp = strrchr((char const   *)(basedir), '/');
    }
#line 6972
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
#line 6974
      syserr("QueueDirectory: can not wildcard relative path \"%s\"", QueueDir);
      }
#line 6976
      if ((int )tTdvect[41] >= 2) {
        {
#line 6977
        sm_dprintf((char *)"setup_queues: \"%s\": Can not wildcard relative path.\n",
                   QueueDir);
        }
      }
#line 6979
      ExitStat = 78;
#line 6980
      return;
    }
#line 6984
    cp ++;
#line 6984
    *cp = (char )'\000';
#line 6985
    len___0 = (int )(cp - basedir);
  } else
#line 6987
  if (! ((int )basedir[len___0 - 1] == 47)) {
#line 6990
    basedir[len___0] = (char )'/';
#line 6991
    len___0 ++;
#line 6991
    basedir[len___0] = (char )'\000';
  }
#line 6995
  if ((int )basedir[len___0 - 1] == 47) {
#line 6995
    tmp___2 = 1;
  } else {
    {
#line 6995
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                6995, "SM_ASSERT(basedir[len - 1] == \'/\') failed");
#line 6995
    tmp___2 = 0;
    }
  }
  {
#line 6997
  tmp___6 = chdir((char const   *)(basedir));
  }
#line 6997
  if (tmp___6 < 0) {
    {
#line 6999
    tmp___3 = __errno_location();
#line 6999
    save_errno = *tmp___3;
#line 7001
    syserr("can not chdir(%s)", basedir);
    }
#line 7002
    if (save_errno == 13) {
      {
#line 7003
      sm_io_fprintf(& SmIoF[2], -2, "Program mode requires special privileges, e.g., root or TrustedUser.\n");
      }
    }
#line 7005
    if ((int )tTdvect[41] >= 2) {
      {
#line 7006
      tmp___4 = __errno_location();
#line 7006
      tmp___5 = sm_errstring(*tmp___4);
#line 7006
      sm_dprintf((char *)"setup_queues: \"%s\": %s\n", basedir, tmp___5);
      }
    }
#line 7008
    ExitStat = 78;
#line 7009
    return;
  }
  {
#line 7012
  hashval = hash_q(basedir, hashval);
#line 7016
  DoQueueRun = (bool volatile   )0;
#line 7017
  now = curtime();
#line 7018
  i = 0;
  }
  {
#line 7018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7018
    if (i < NumQueue) {
#line 7018
      if (! ((unsigned long )Queue[i] != (unsigned long )((void *)0))) {
#line 7018
        goto while_break;
      }
    } else {
#line 7018
      goto while_break;
    }
#line 7019
    (Queue[i])->qg_nextrun = now;
#line 7018
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 7022
  if (UseMSP) {
#line 7022
    if ((int )OpMode != 116) {
      {
#line 7024
      sff = 64L;
#line 7026
      tmp___9 = stat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& st));
      }
#line 7026
      if (tmp___9 < 0) {
        {
#line 7028
        syserr("can not stat(%s)", basedir);
        }
#line 7029
        if ((int )tTdvect[41] >= 2) {
          {
#line 7030
          tmp___7 = __errno_location();
#line 7030
          tmp___8 = sm_errstring(*tmp___7);
#line 7030
          sm_dprintf((char *)"setup_queues: \"%s\": %s\n", basedir, tmp___8);
          }
        }
#line 7032
        ExitStat = 78;
#line 7033
        return;
      }
#line 7035
      if (RunAsUid == 0U) {
#line 7036
        sff |= 4L;
      }
#line 7043
      if ((QueueFileMode & (128 >> 3)) != 0) {
#line 7043
        if ((st.st_mode & (unsigned int )(128 >> 3)) != 0U) {
          {
#line 7043
          tmp___10 = safefile((char *)" ", RunAsUid, RunAsGid, RunAsUserName, sff,
                              QueueFileMode, (struct stat *)((void *)0));
          }
#line 7043
          if (tmp___10 != 0) {
            {
#line 7048
            syserr("can not write to queue directory %s (RunAsGid=%d, required=%d)",
                   basedir, (int )RunAsGid, (int )st.st_gid);
            }
          }
        }
      }
#line 7051
      if ((st.st_mode & (unsigned int )(((128 >> 3) >> 3) | ((64 >> 3) >> 3))) != 0U) {
#line 7057
        if (LogLevel > 0) {
          {
#line 7058
          sm_syslog(3, "*~*", "dangerous permissions=%o on queue directory %s", (int )st.st_mode,
                    basedir);
          }
        }
      }
    }
  }
#line 7070
  qn = 0;
#line 7071
  i = 0;
  {
#line 7071
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7071
    if (i < NumQueue) {
#line 7071
      if (! ((unsigned long )Queue[i] != (unsigned long )((void *)0))) {
#line 7071
        goto while_break___0;
      }
    } else {
#line 7071
      goto while_break___0;
    }
    {
#line 7072
    qn = multiqueue_cache(basedir, len___0, Queue[i], qn, & hashval);
#line 7071
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 7075
  init_shm(qn, owner, hashval);
  }
#line 7076
  if (owner) {
#line 7076
    tmp___11 = 1;
  } else
#line 7076
  if (ShmId == -2) {
#line 7076
    tmp___11 = 1;
  } else {
#line 7076
    tmp___11 = 0;
  }
  {
#line 7076
  i = filesys_setup(tmp___11);
  }
#line 7077
  if (i == -1) {
#line 7085
    if (! owner) {
#line 7085
      tmp___12 = 1;
    } else {
      {
#line 7085
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                  7085, "SM_ASSERT(!owner) failed");
#line 7085
      tmp___12 = 0;
      }
    }
    {
#line 7086
    cleanup_shm(0);
#line 7087
    i = filesys_setup(0);
    }
#line 7088
    if (i < 0) {
      {
#line 7089
      syserr("filesys_setup failed twice, result=%d", i);
      }
    } else
#line 7090
    if (LogLevel > 8) {
      {
#line 7091
      sm_syslog(4, "*~*", "shared memory does not contain expected data, ignored");
      }
    }
  }
#line 7097
  if (i < 0) {
#line 7098
    ExitStat = 78;
  }
#line 7099
  return;
}
}
#line 7115 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void cleanup_shm(bool owner ) 
{ 
  int *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 7119
  if (ShmId != -2) {
    {
#line 7121
    tmp___1 = sm_shmstop(Pshm, ShmId, owner);
    }
#line 7121
    if (tmp___1 < 0) {
#line 7121
      if (LogLevel > 8) {
        {
#line 7122
        tmp = __errno_location();
#line 7122
        tmp___0 = sm_errstring(*tmp);
#line 7122
        sm_syslog(6, "*~*", "sm_shmstop failed=%s", tmp___0);
        }
      }
    }
#line 7124
    Pshm = (void *)0;
#line 7125
    ShmId = -2;
  }
  {
#line 7127
  stop_sem(owner);
  }
#line 7128
  return;
}
}
#line 7142 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void cleanup_queues(void) 
{ 


  {
  {
#line 7145
  sync_queue_time();
  }
#line 7146
  return;
}
}
#line 7161 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void set_def_queueval(QUEUEGRP *qg , bool all ) 
{ 


  {
#line 7166
  if (qg->qg_flags[1UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 1UL % (8UL * sizeof(int )))) {
#line 7167
    return;
  }
#line 7168
  if (all) {
#line 7169
    qg->qg_qdir = QueueDir;
  }
#line 7173
  if (all) {
#line 7173
    qg->qg_maxqrun = MaxRunnersPerQueue;
  } else {
#line 7173
    qg->qg_maxqrun = -1;
  }
#line 7174
  qg->qg_nice = (short )NiceQueueRun;
#line 7175
  return;
}
}
#line 7201 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void makequeue(char *line , bool qdef ) 
{ 
  register char *p ;
  register QUEUEGRP *qg ;
  register STAB *s ;
  int i ;
  char fcode ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *delimptr ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  QUEUEGRP *tmp___8 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 7213
  tmp = xalloc_tagged((int )sizeof(*qg), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                      7213);
#line 7213
  qg = (QUEUEGRP *)tmp;
#line 7214
  memset((void *)((char *)qg), '\000', (size_t )sizeof(*qg));
  }
#line 7216
  if ((int )*(line + 0) == 0) {
    {
#line 7218
    syserr("name required for queue");
    }
#line 7219
    return;
  }
#line 7223
  p = line;
  {
#line 7223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7223
    if ((int )*p != 0) {
#line 7223
      if ((int )*p != 44) {
#line 7223
        if (((int )*p & -128) == 0) {
          {
#line 7223
          tmp___0 = __ctype_b_loc();
          }
#line 7223
          if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
#line 7223
            goto while_break;
          }
        }
      } else {
#line 7223
        goto while_break;
      }
    } else {
#line 7223
      goto while_break;
    }
#line 7226
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 7223
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 7227
  if ((int )*p != 0) {
#line 7228
    tmp___1 = p;
#line 7228
    p ++;
#line 7228
    *tmp___1 = (char )'\000';
  }
  {
#line 7229
  qg->qg_name = newstr((char const   *)line);
#line 7232
  set_def_queueval(qg, 0);
  }
  {
#line 7235
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7235
    if (! ((int )*p != 0)) {
#line 7235
      goto while_break___0;
    }
    {
#line 7239
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7239
      if ((int )*p != 0) {
#line 7239
        if (! ((int )*p == 44)) {
#line 7239
          if (((int )*p & -128) == 0) {
            {
#line 7239
            tmp___2 = __ctype_b_loc();
            }
#line 7239
            if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 7239
              goto while_break___1;
            }
          } else {
#line 7239
            goto while_break___1;
          }
        }
      } else {
#line 7239
        goto while_break___1;
      }
#line 7241
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 7244
    fcode = *p;
    {
#line 7245
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 7245
      if ((int )*p != 0) {
#line 7245
        if ((int )*p != 61) {
#line 7245
          if (! ((int )*p != 44)) {
#line 7245
            goto while_break___2;
          }
        } else {
#line 7245
          goto while_break___2;
        }
      } else {
#line 7245
        goto while_break___2;
      }
#line 7246
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 7247
    tmp___3 = p;
#line 7247
    p ++;
#line 7247
    if ((int )*tmp___3 != 61) {
      {
#line 7249
      syserr("queue %s: `=\' expected", qg->qg_name);
      }
#line 7250
      return;
    }
    {
#line 7252
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 7252
      if (((int )*p & -128) == 0) {
        {
#line 7252
        tmp___4 = __ctype_b_loc();
        }
#line 7252
        if (! ((int const   )*(*tmp___4 + (int )*p) & 8192)) {
#line 7252
          goto while_break___3;
        }
      } else {
#line 7252
        goto while_break___3;
      }
#line 7253
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 7256
    p = munchstring(p, & delimptr, ',');
    }
    {
#line 7261
    if ((int )fcode == 80) {
#line 7261
      goto case_80;
    }
#line 7269
    if ((int )fcode == 70) {
#line 7269
      goto case_70;
    }
#line 7281
    if ((int )fcode == 73) {
#line 7281
      goto case_73;
    }
#line 7285
    if ((int )fcode == 78) {
#line 7285
      goto case_78;
    }
#line 7289
    if ((int )fcode == 82) {
#line 7289
      goto case_82;
    }
#line 7305
    if ((int )fcode == 74) {
#line 7305
      goto case_74;
    }
#line 7309
    if ((int )fcode == 114) {
#line 7309
      goto case_114;
    }
#line 7365
    goto switch_default;
    case_80: /* CIL Label */ 
#line 7262
    if ((int )*p == 0) {
      {
#line 7263
      syserr("queue %s: empty path name", qg->qg_name);
      }
    } else {
      {
#line 7266
      qg->qg_qdir = newstr((char const   *)p);
      }
    }
#line 7267
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 7270
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 7270
      if (! ((int )*p != 0)) {
#line 7270
        goto while_break___4;
      }
#line 7271
      if (((int )*p & -128) == 0) {
        {
#line 7271
        tmp___5 = __ctype_b_loc();
        }
#line 7271
        if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 7272
          qg->qg_flags[(unsigned long )((unsigned char )*p) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )*p) % (8UL * sizeof(int ));
        }
      } else {
#line 7272
        qg->qg_flags[(unsigned long )((unsigned char )*p) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )*p) % (8UL * sizeof(int ));
      }
#line 7270
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 7273
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 7282
    qg->qg_queueintvl = convtime(p, 'm');
    }
#line 7283
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 7286
    tmp___6 = atoi((char const   *)p);
#line 7286
    qg->qg_nice = (short )tmp___6;
    }
#line 7287
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 7290
    i = atoi((char const   *)p);
    }
#line 7293
    if (MaxQueueChildren > 0) {
#line 7293
      if (i > MaxQueueChildren) {
        {
#line 7295
        qg->qg_maxqrun = MaxQueueChildren;
#line 7296
        sm_io_fprintf(& SmIoF[1], -2, "Q=%s: R=%d exceeds MaxQueueChildren=%d, set to MaxQueueChildren\n",
                      qg->qg_name, i, MaxQueueChildren);
        }
      } else {
#line 7302
        qg->qg_maxqrun = i;
      }
    } else {
#line 7302
      qg->qg_maxqrun = i;
    }
#line 7303
    goto switch_break;
    case_74: /* CIL Label */ 
    {
#line 7306
    qg->qg_maxlist = atoi((char const   *)p);
    }
#line 7307
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 7310
    qg->qg_maxrcpt = atoi((char const   *)p);
    }
#line 7311
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 7366
    syserr("Q%s: unknown queue equate %c=", qg->qg_name, (int )fcode);
    }
#line 7368
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 7371
    p = delimptr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 7384
  if (NumQueue >= 50) {
    {
#line 7386
    syserr("too many queue groups defined (%d max)", 50);
    }
#line 7388
    return;
  }
#line 7391
  if ((unsigned long )qg->qg_qdir == (unsigned long )((void *)0)) {
#line 7393
    if ((unsigned long )QueueDir == (unsigned long )((void *)0)) {
      {
#line 7395
      syserr("QueueDir must be defined before queue groups");
      }
#line 7396
      return;
    } else
#line 7393
    if ((int )*QueueDir == 0) {
      {
#line 7395
      syserr("QueueDir must be defined before queue groups");
      }
#line 7396
      return;
    }
    {
#line 7398
    qg->qg_qdir = newstr((char const   *)QueueDir);
    }
  }
#line 7401
  if (qg->qg_maxqrun > 1) {
#line 7401
    if (! (qg->qg_flags[102UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 102UL % (8UL * sizeof(int ))))) {
      {
#line 7403
      sm_io_fprintf(& SmIoF[1], -2, "Warning: Q=%s: R=%d: multiple queue runners specified\n\tbut flag \'%c\' is not set\n",
                    qg->qg_name, qg->qg_maxqrun, 'f');
      }
    }
  }
#line 7409
  if ((int )tTdvect[37] >= 8) {
    {
#line 7410
    sm_syslog(6, "*~*", "Adding %s to stab, path: %s", qg->qg_name, qg->qg_qdir);
    }
  }
  {
#line 7413
  s = stab(qg->qg_name, 15, 1);
  }
#line 7414
  if ((unsigned long )s->s_value.sv_queue != (unsigned long )((void *)0)) {
    {
#line 7416
    i = (int )(s->s_value.sv_queue)->qg_index;
#line 7419
    sm_free_tagged((void *)s->s_value.sv_queue, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                   7419);
    }
  } else {
#line 7422
    tmp___7 = NumQueue;
#line 7422
    NumQueue ++;
#line 7422
    i = tmp___7;
  }
#line 7423
  tmp___8 = qg;
#line 7423
  s->s_value.sv_queue = tmp___8;
#line 7423
  Queue[i] = tmp___8;
#line 7424
  qg->qg_index = (short )i;
#line 7427
  if (qg->qg_maxqrun < 0) {
#line 7429
    if (MaxRunnersPerQueue > 0) {
#line 7430
      qg->qg_maxqrun = MaxRunnersPerQueue;
    } else {
#line 7432
      qg->qg_maxqrun = 1;
    }
  }
#line 7434
  if (qdef) {
#line 7435
    qg->qg_flags[1UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 1UL % (8UL * sizeof(int ));
  }
#line 7436
  return;
}
}
#line 7495
static int cmpidx(void const   *a , void const   *b___0 ) ;
#line 7497 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int cmpidx(void const   *a , void const   *b___0 ) 
{ 


  {
#line 7503
  if (((SORTQGRP_T *)a)->sg_maxqrun < ((SORTQGRP_T *)b___0)->sg_maxqrun) {
#line 7504
    return (1);
  } else
#line 7505
  if (((SORTQGRP_T *)a)->sg_maxqrun > ((SORTQGRP_T *)b___0)->sg_maxqrun) {
#line 7506
    return (-1);
  } else {
#line 7508
    return (0);
  }
}
}
#line 7533 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void makeworkgroups(void) 
{ 
  int i ;
  int j ;
  int total_runners ;
  int dir___0 ;
  int h ;
  SORTQGRP_T si[51] ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 7539
  total_runners = 0;
#line 7540
  if (NumQueue == 1) {
    {
#line 7540
    tmp___0 = strcmp((char const   *)(Queue[0])->qg_name, "mqueue");
    }
#line 7540
    if (tmp___0 == 0) {
      {
#line 7553
      NumWorkGroups = 1;
#line 7554
      WorkGrp[0].wg_numqgrp = (int volatile   )1;
#line 7555
      tmp = xalloc_tagged((int )sizeof(QUEUEGRP *), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                          7555);
#line 7555
      WorkGrp[0].wg_qgs = (QUEUEGRP **/* volatile  */)((QUEUEGRP **)tmp);
#line 7556
      *(WorkGrp[0].wg_qgs + 0) = Queue[0];
      }
#line 7557
      if (MaxQueueChildren > 0) {
#line 7557
        if ((Queue[0])->qg_numqueues > MaxQueueChildren) {
#line 7559
          WorkGrp[0].wg_runners = (int volatile   )MaxQueueChildren;
        } else {
#line 7561
          WorkGrp[0].wg_runners = (int volatile   )(Queue[0])->qg_numqueues;
        }
      } else {
#line 7561
        WorkGrp[0].wg_runners = (int volatile   )(Queue[0])->qg_numqueues;
      }
#line 7563
      (Queue[0])->qg_wgrp = 0;
#line 7566
      if (MaxQueueChildren > 0) {
#line 7566
        if ((Queue[0])->qg_maxqrun > MaxQueueChildren) {
#line 7568
          (Queue[0])->qg_maxqrun = MaxQueueChildren;
        }
      }
#line 7569
      WorkGrp[0].wg_maxact = (int volatile   )(Queue[0])->qg_maxqrun;
#line 7570
      WorkGrp[0].wg_lowqintvl = (time_t volatile   )(Queue[0])->qg_queueintvl;
#line 7571
      return;
    }
  }
#line 7574
  i = 0;
  {
#line 7574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7574
    if (! (i < NumQueue)) {
#line 7574
      goto while_break;
    }
#line 7576
    si[i].sg_maxqrun = (Queue[i])->qg_maxqrun;
#line 7577
    si[i].sg_idx = i;
#line 7574
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7579
  qsort((void *)(si), (size_t )NumQueue, (size_t )sizeof(si[0]), & cmpidx);
#line 7581
  NumWorkGroups = 0;
#line 7582
  i = 0;
  }
  {
#line 7582
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7582
    if (! (i < NumQueue)) {
#line 7582
      goto while_break___0;
    }
#line 7584
    total_runners += si[i].sg_maxqrun;
#line 7585
    if (MaxQueueChildren <= 0) {
#line 7586
      NumWorkGroups ++;
    } else
#line 7585
    if (total_runners <= MaxQueueChildren) {
#line 7586
      NumWorkGroups ++;
    } else {
#line 7588
      goto while_break___0;
    }
#line 7582
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 7591
  if (NumWorkGroups < 1) {
#line 7592
    NumWorkGroups = 1;
  } else
#line 7593
  if (NumWorkGroups > 50) {
#line 7594
    NumWorkGroups = 50;
  }
#line 7605
  j = 0;
#line 7606
  dir___0 = 1;
#line 7607
  i = 0;
  {
#line 7607
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 7607
    if (! (i < NumQueue)) {
#line 7607
      goto while_break___1;
    }
#line 7610
    if (j >= NumWorkGroups) {
#line 7612
      dir___0 = -1;
#line 7613
      j = NumWorkGroups - 1;
    } else
#line 7615
    if (j < 0) {
#line 7617
      j = 0;
#line 7618
      dir___0 = 1;
    }
#line 7621
    if ((unsigned long )WorkGrp[j].wg_qgs == (unsigned long )((void *)0)) {
      {
#line 7622
      tmp___1 = sm_malloc_tagged((size_t )(sizeof(QUEUEGRP *) * (unsigned long )(WorkGrp[j].wg_numqgrp + (int volatile   )1)),
                                 (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                                 7623, SmHeapGroup);
#line 7622
      WorkGrp[j].wg_qgs = (QUEUEGRP **/* volatile  */)((QUEUEGRP **)tmp___1);
      }
    } else {
      {
#line 7625
      tmp___2 = sm_realloc((void *)WorkGrp[j].wg_qgs, (size_t )(sizeof(QUEUEGRP *) * (unsigned long )(WorkGrp[j].wg_numqgrp + (int volatile   )1)));
#line 7625
      WorkGrp[j].wg_qgs = (QUEUEGRP **/* volatile  */)((QUEUEGRP **)tmp___2);
      }
    }
#line 7628
    if ((unsigned long )WorkGrp[j].wg_qgs == (unsigned long )((void *)0)) {
      {
#line 7630
      syserr("!cannot allocate memory for work queues, need %d bytes", (int )(sizeof(QUEUEGRP *) * (unsigned long )(WorkGrp[j].wg_numqgrp + (int volatile   )1)));
      }
    }
#line 7635
    h = si[i].sg_idx;
#line 7636
    *(WorkGrp[j].wg_qgs + WorkGrp[j].wg_numqgrp) = Queue[h];
#line 7637
    WorkGrp[j].wg_numqgrp += (int volatile   )1;
#line 7638
    WorkGrp[j].wg_runners += (int volatile   )(Queue[h])->qg_maxqrun;
#line 7639
    (Queue[h])->qg_wgrp = j;
#line 7641
    if (WorkGrp[j].wg_maxact == (int volatile   )0) {
#line 7644
      if (MaxQueueChildren > 0) {
#line 7644
        if ((Queue[h])->qg_maxqrun > MaxQueueChildren) {
#line 7646
          (Queue[h])->qg_maxqrun = MaxQueueChildren;
        }
      }
#line 7647
      WorkGrp[j].wg_maxact = (int volatile   )(Queue[h])->qg_maxqrun;
    }
#line 7657
    if ((Queue[h])->qg_queueintvl > 0L) {
#line 7657
      if (WorkGrp[j].wg_lowqintvl < (time_t volatile   )(Queue[h])->qg_queueintvl) {
#line 7659
        WorkGrp[j].wg_lowqintvl = (time_t volatile   )(Queue[h])->qg_queueintvl;
      }
    }
#line 7660
    j += dir___0;
#line 7607
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 7662
  if ((int )tTdvect[41] >= 9) {
#line 7664
    i = 0;
    {
#line 7664
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 7664
      if (! (i < NumWorkGroups)) {
#line 7664
        goto while_break___2;
      }
      {
#line 7666
      sm_dprintf((char *)"Workgroup[%d]=", i);
#line 7667
      j = 0;
      }
      {
#line 7667
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 7667
        if (! (j < (int )WorkGrp[i].wg_numqgrp)) {
#line 7667
          goto while_break___3;
        }
        {
#line 7669
        sm_dprintf((char *)"%s, ", (*(WorkGrp[i].wg_qgs + j))->qg_name);
#line 7667
        j ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 7672
      sm_dprintf((char *)"\n");
#line 7664
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 7675
  return;
}
}
#line 7701
static bool dup_df(ENVELOPE *old , ENVELOPE *new ) ;
#line 7703 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static bool dup_df(ENVELOPE *old , ENVELOPE *new ) 
{ 
  int ofs ;
  int nfs ;
  int r ;
  char opath[4096] ;
  char npath[4096] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char const   *tmp___10 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 7712
  if (! ((old->e_flags & 2097152UL) != 0UL)) {
    {
#line 7719
    queueup(old, 0, 1);
    }
  }
#line 7721
  if (old->e_qgrp >= 0) {
#line 7721
    if (old->e_qdir >= 0) {
#line 7721
      tmp = 1;
    } else {
      {
#line 7721
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                  7721, "SM_REQUIRE(ISVALIDQGRP(old->e_qgrp) && ISVALIDQDIR(old->e_qdir)) failed");
#line 7721
      tmp = 0;
      }
    }
  } else {
    {
#line 7721
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                7721, "SM_REQUIRE(ISVALIDQGRP(old->e_qgrp) && ISVALIDQDIR(old->e_qdir)) failed");
#line 7721
    tmp = 0;
    }
  }
#line 7722
  if (new->e_qgrp >= 0) {
#line 7722
    if (new->e_qdir >= 0) {
#line 7722
      tmp___0 = 1;
    } else {
      {
#line 7722
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                  7722, "SM_REQUIRE(ISVALIDQGRP(new->e_qgrp) && ISVALIDQDIR(new->e_qdir)) failed");
#line 7722
      tmp___0 = 0;
      }
    }
  } else {
    {
#line 7722
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                7722, "SM_REQUIRE(ISVALIDQGRP(new->e_qgrp) && ISVALIDQDIR(new->e_qdir)) failed");
#line 7722
    tmp___0 = 0;
    }
  }
  {
#line 7724
  tmp___1 = queuename(old, 'd');
#line 7724
  sm_strlcpy(opath, (char const   *)tmp___1, (ssize_t )sizeof(opath));
#line 7725
  tmp___2 = queuename(new, 'd');
#line 7725
  sm_strlcpy(npath, (char const   *)tmp___2, (ssize_t )sizeof(npath));
  }
#line 7727
  if ((unsigned long )old->e_dfp != (unsigned long )((void *)0)) {
    {
#line 7729
    r = sm_io_setinfo(old->e_dfp, 1001, (void *)0);
    }
#line 7730
    if (r < 0) {
      {
#line 7730
      tmp___3 = __errno_location();
      }
#line 7730
      if (*tmp___3 != 22) {
        {
#line 7732
        syserr("@can\'t commit %s", opath);
#line 7733
        old->e_flags |= 32UL;
        }
#line 7734
        return (0);
      }
    }
  }
#line 7746
  if (old->e_dfqgrp >= 0) {
#line 7746
    if (old->e_dfqdir >= 0) {
#line 7746
      tmp___4 = 1;
    } else {
      {
#line 7746
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                  7746, "SM_REQUIRE(ISVALIDQGRP(old->e_dfqgrp) && ISVALIDQDIR(old->e_dfqdir)) failed");
#line 7746
      tmp___4 = 0;
      }
    }
  } else {
    {
#line 7746
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                7746, "SM_REQUIRE(ISVALIDQGRP(old->e_dfqgrp) && ISVALIDQDIR(old->e_dfqdir)) failed");
#line 7746
    tmp___4 = 0;
    }
  }
#line 7747
  if (new->e_dfqgrp >= 0) {
#line 7747
    if (new->e_dfqdir >= 0) {
#line 7747
      tmp___5 = 1;
    } else {
      {
#line 7747
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                  7747, "SM_REQUIRE(ISVALIDQGRP(new->e_dfqgrp) && ISVALIDQDIR(new->e_dfqdir)) failed");
#line 7747
      tmp___5 = 0;
      }
    }
  } else {
    {
#line 7747
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                7747, "SM_REQUIRE(ISVALIDQGRP(new->e_dfqgrp) && ISVALIDQDIR(new->e_dfqdir)) failed");
#line 7747
    tmp___5 = 0;
    }
  }
#line 7749
  ofs = (int )((Queue[old->e_dfqgrp])->qg_qpaths + old->e_dfqdir)->qp_fsysidx;
#line 7750
  nfs = (int )((Queue[new->e_dfqgrp])->qg_qpaths + new->e_dfqdir)->qp_fsysidx;
#line 7751
  if ((PtrFileSys + ofs)->fs_dev == (PtrFileSys + nfs)->fs_dev) {
    {
#line 7753
    tmp___6 = link((char const   *)(opath), (char const   *)(npath));
    }
#line 7753
    if (tmp___6 == 0) {
      {
#line 7755
      new->e_flags |= 2097152UL;
#line 7756
      sync_dir(npath, 1);
      }
#line 7757
      return (1);
    }
#line 7759
    goto error;
  }
  {
#line 7768
  new->e_dfqgrp = old->e_dfqgrp;
#line 7769
  new->e_dfqdir = old->e_dfqdir;
#line 7770
  tmp___7 = queuename(new, 'd');
#line 7770
  sm_strlcpy(npath, (char const   *)tmp___7, (ssize_t )sizeof(npath));
#line 7771
  tmp___8 = link((char const   *)(opath), (char const   *)(npath));
  }
#line 7771
  if (tmp___8 == 0) {
    {
#line 7773
    new->e_flags |= 2097152UL;
#line 7774
    sync_dir(npath, 1);
    }
#line 7775
    return (1);
  }
  error: 
#line 7779
  if (LogLevel > 0) {
    {
#line 7780
    tmp___9 = __errno_location();
#line 7780
    tmp___10 = sm_errstring(*tmp___9);
#line 7780
    sm_syslog(3, (char const   *)old->e_id, "dup_df: can\'t link %s to %s, error=%s, envelope splitting failed",
              opath, npath, tmp___10);
    }
  }
#line 7783
  return (0);
}
}
#line 7800
static ENVELOPE *split_env(ENVELOPE *e , ADDRESS *sendqueue , int qgrp , int qdir ) ;
#line 7802 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static ENVELOPE *split_env(ENVELOPE *e , ADDRESS *sendqueue , int qgrp , int qdir ) 
{ 
  ENVELOPE *ee ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;

  {
  {
#line 7811
  tmp = sm_rpool_malloc_tagged_x(e->e_rpool, (size_t )sizeof(*ee), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                                 7811, SmHeapGroup);
#line 7811
  ee = (ENVELOPE *)tmp;
#line 7812
  *ee = *e;
#line 7813
  ee->e_message = (char *)((void *)0);
#line 7814
  ee->e_id = (char *)((void *)0);
#line 7815
  assign_queueid(ee);
#line 7816
  ee->e_sendqueue = sendqueue;
#line 7817
  ee->e_flags &= 0xffffffffffcfffc5UL;
#line 7819
  ee->e_flags |= 65536UL;
#line 7820
  ee->e_from.q_state = (short)8;
#line 7821
  ee->e_dfp = (SM_FILE_T *)((void *)0);
#line 7822
  ee->e_lockfp = (SM_FILE_T *)((void *)0);
  }
#line 7823
  if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
    {
#line 7824
    ee->e_xfp = sm_io_dup(e->e_xfp);
    }
  }
#line 7827
  if ((unsigned long )ee->e_xfp == (unsigned long )((void *)0)) {
    {
#line 7828
    openxscript(ee);
    }
  }
#line 7830
  tmp___0 = qgrp;
#line 7830
  ee->e_dfqgrp = tmp___0;
#line 7830
  ee->e_qgrp = tmp___0;
#line 7831
  tmp___1 = qdir;
#line 7831
  ee->e_dfqdir = tmp___1;
#line 7831
  ee->e_qdir = tmp___1;
#line 7832
  ee->e_errormode = (short )'m';
#line 7833
  ee->e_statmsg = (char *)((void *)0);
#line 7834
  if ((unsigned long )e->e_quarmsg != (unsigned long )((void *)0)) {
    {
#line 7835
    ee->e_quarmsg = sm_rpool_strdup_x(ee->e_rpool, (char const   *)e->e_quarmsg);
    }
  }
  {
#line 7846
  ee->e_header = copyheader(e->e_header, ee->e_rpool);
#line 7847
  ee->e_errorqueue = copyqueue(e->e_errorqueue, ee->e_rpool);
  }
#line 7849
  return (ee);
}
}
#line 7882
static int q_qgrp_compare(void const   *p1 , void const   *p2 ) ;
#line 7883
static int e_filesys_compare(void const   *p1 , void const   *p2 ) ;
#line 7885 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int q_qgrp_compare(void const   *p1 , void const   *p2 ) 
{ 
  ADDRESS **pq1 ;
  ADDRESS **pq2 ;

  {
#line 7890
  pq1 = (ADDRESS **)p1;
#line 7891
  pq2 = (ADDRESS **)p2;
#line 7893
  return ((*pq1)->q_qgrp - (*pq2)->q_qgrp);
}
}
#line 7896 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int e_filesys_compare(void const   *p1 , void const   *p2 ) 
{ 
  ENVELOPE **pe1 ;
  ENVELOPE **pe2 ;
  int fs1 ;
  int fs2 ;

  {
#line 7901
  pe1 = (ENVELOPE **)p1;
#line 7902
  pe2 = (ENVELOPE **)p2;
#line 7905
  fs1 = (int )((Queue[(*pe1)->e_qgrp])->qg_qpaths + (*pe1)->e_qdir)->qp_fsysidx;
#line 7906
  fs2 = (int )((Queue[(*pe2)->e_qgrp])->qg_qpaths + (*pe2)->e_qdir)->qp_fsysidx;
#line 7907
  if ((PtrFileSys + fs1)->fs_dev < (PtrFileSys + fs2)->fs_dev) {
#line 7908
    return (-1);
  }
#line 7909
  if ((PtrFileSys + fs1)->fs_dev > (PtrFileSys + fs2)->fs_dev) {
#line 7910
    return (1);
  }
#line 7911
  return (0);
}
}
#line 7914 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int split_across_queue_groups(ENVELOPE *e ) 
{ 
  int naddrs ;
  int nsplits ;
  int i ;
  bool changed ;
  char **pvp ;
  ADDRESS *q ;
  ADDRESS **addrs ;
  ENVELOPE *ee ;
  ENVELOPE *es ;
  ENVELOPE *splits[50] ;
  char pvpbuf[1256] ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int j ;
  char *tmp___6 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 7926
  if (e->e_qgrp >= 0) {
#line 7926
    tmp = 1;
  } else {
    {
#line 7926
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                7926, "SM_REQUIRE(ISVALIDQGRP(e->e_qgrp)) failed");
#line 7926
    tmp = 0;
    }
  }
#line 7929
  naddrs = 0;
#line 7930
  changed = 0;
#line 7931
  q = e->e_sendqueue;
  {
#line 7931
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7931
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 7931
      goto while_break;
    }
#line 7933
    if ((int )q->q_state >= 6) {
#line 7934
      goto __Cont;
    }
#line 7935
    naddrs ++;
#line 7938
    if ((int )q->q_state == 2) {
#line 7940
      q->q_qgrp = e->e_qgrp;
    } else
#line 7938
    if ((int )q->q_state == 1) {
#line 7940
      q->q_qgrp = e->e_qgrp;
    } else
#line 7941
    if (! (q->q_qgrp >= 0)) {
      {
#line 7944
      i = rscap((char *)"queuegroup", q->q_user, (char *)((void *)0), e, & pvp, pvpbuf,
                (int )sizeof(pvpbuf));
      }
#line 7946
      if (i == 0) {
#line 7946
        if ((unsigned long )pvp != (unsigned long )((void *)0)) {
#line 7946
          if ((unsigned long )*(pvp + 0) != (unsigned long )((void *)0)) {
#line 7946
            if (((int )*(*(pvp + 0) + 0) & 255) == 150) {
#line 7946
              if ((unsigned long )*(pvp + 1) != (unsigned long )((void *)0)) {
#line 7946
                if ((int )*(*(pvp + 1) + 0) != 0) {
                  {
#line 7951
                  i = name2qid(*(pvp + 1));
                  }
#line 7952
                  if (i >= 0) {
#line 7954
                    q->q_qgrp = i;
#line 7955
                    changed = 1;
#line 7956
                    if ((int )tTdvect[20] >= 4) {
                      {
#line 7957
                      sm_syslog(6, "*~*", "queue group name %s -> %d", *(pvp + 1),
                                i);
                      }
                    }
#line 7960
                    goto __Cont;
                  } else
#line 7962
                  if (LogLevel > 10) {
                    {
#line 7963
                    sm_syslog(6, "*~*", "can\'t find queue group name %s, selection ignored",
                              *(pvp + 1));
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 7967
      if ((unsigned long )q->q_mailer != (unsigned long )((void *)0)) {
#line 7967
        if ((int )(q->q_mailer)->m_qgrp >= 0) {
#line 7970
          changed = 1;
#line 7971
          q->q_qgrp = (int )(q->q_mailer)->m_qgrp;
        } else {
#line 7967
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 7973
      if (e->e_qgrp >= 0) {
#line 7974
        q->q_qgrp = e->e_qgrp;
      } else {
#line 7976
        q->q_qgrp = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 7931
    q = q->q_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 7981
  if (naddrs <= 1) {
#line 7981
    if (! changed) {
#line 7982
      return (1);
    }
  }
  {
#line 7985
  tmp___0 = sm_rpool_malloc_tagged_x(e->e_rpool, (size_t )((unsigned long )naddrs * sizeof(ADDRESS *)),
                                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                                     7985, SmHeapGroup);
#line 7985
  addrs = (ADDRESS **)tmp___0;
#line 7986
  i = 0;
#line 7986
  q = e->e_sendqueue;
  }
  {
#line 7986
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7986
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 7986
      goto while_break___0;
    }
#line 7988
    if ((int )q->q_state >= 6) {
#line 7989
      goto __Cont___0;
    }
#line 7990
    tmp___1 = i;
#line 7990
    i ++;
#line 7990
    *(addrs + tmp___1) = q;
    __Cont___0: /* CIL Label */ 
#line 7986
    q = q->q_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 7992
  qsort((void *)addrs, (size_t )naddrs, (size_t )sizeof(ADDRESS *), & q_qgrp_compare);
#line 7995
  nsplits = 0;
#line 7996
  es = (ENVELOPE *)((void *)0);
#line 7997
  e->e_sendqueue = (ADDRESS *)((void *)0);
#line 7998
  i = 0;
  }
  {
#line 7998
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 7998
    if (! (i < naddrs)) {
#line 7998
      goto while_break___1;
    }
#line 8000
    if (i == naddrs - 1) {
#line 8001
      (*(addrs + i))->q_next = (struct address *)((void *)0);
    } else
#line 8000
    if ((*(addrs + i))->q_qgrp != (*(addrs + (i + 1)))->q_qgrp) {
#line 8001
      (*(addrs + i))->q_next = (struct address *)((void *)0);
    } else {
#line 8003
      (*(addrs + i))->q_next = *(addrs + (i + 1));
    }
#line 8006
    if ((*(addrs + i))->q_qgrp == e->e_qgrp) {
#line 8008
      if ((unsigned long )e->e_sendqueue == (unsigned long )((void *)0)) {
#line 8009
        e->e_sendqueue = *(addrs + i);
      }
#line 8010
      goto __Cont___1;
    }
#line 8014
    if ((unsigned long )es == (unsigned long )((void *)0)) {
      {
#line 8016
      ee = split_env(e, *(addrs + i), (*(addrs + i))->q_qgrp, -1);
#line 8017
      es = ee;
#line 8018
      tmp___2 = nsplits;
#line 8018
      nsplits ++;
#line 8018
      splits[tmp___2] = ee;
      }
    } else
#line 8014
    if ((*(addrs + i))->q_qgrp != es->e_qgrp) {
      {
#line 8016
      ee = split_env(e, *(addrs + i), (*(addrs + i))->q_qgrp, -1);
#line 8017
      es = ee;
#line 8018
      tmp___2 = nsplits;
#line 8018
      nsplits ++;
#line 8018
      splits[tmp___2] = ee;
      }
    }
    __Cont___1: /* CIL Label */ 
#line 7998
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 8023
  if (nsplits <= 0) {
#line 8024
    return (1);
  }
#line 8027
  i = 0;
  {
#line 8027
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 8027
    if (! (i < nsplits)) {
#line 8027
      goto while_break___2;
    }
    {
#line 8029
    es = splits[i];
#line 8033
    tmp___3 = setnewqueue(es);
    }
#line 8033
    if (! tmp___3) {
#line 8034
      goto failure;
    }
#line 8027
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 8038
  qsort((void *)(splits), (size_t )nsplits, (size_t )sizeof(ENVELOPE *), & e_filesys_compare);
#line 8041
  tmp___4 = dup_df(e, splits[0]);
  }
#line 8041
  if (! tmp___4) {
#line 8043
    i = 0;
#line 8044
    goto failure;
  }
#line 8046
  i = 1;
  {
#line 8046
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 8046
    if (! (i < nsplits)) {
#line 8046
      goto while_break___3;
    }
    {
#line 8049
    tmp___5 = dup_df(splits[i - 1], splits[i]);
    }
#line 8049
    if (! tmp___5) {
#line 8050
      goto failure;
    }
#line 8046
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 8054
  i = 0;
  {
#line 8054
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 8054
    if (! (i < nsplits)) {
#line 8054
      goto while_break___4;
    }
#line 8056
    es = splits[i];
#line 8057
    es->e_sibling = e->e_sibling;
#line 8058
    e->e_sibling = es;
#line 8054
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 8060
  return (1 + nsplits);
  failure: 
#line 8064
  if (i > 0) {
#line 8068
    j = 0;
    {
#line 8068
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 8068
      if (! (j < i)) {
#line 8068
        goto while_break___5;
      }
      {
#line 8069
      tmp___6 = queuename(splits[j], 'd');
#line 8069
      unlink((char const   *)tmp___6);
#line 8068
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 8071
  e->e_sendqueue = *(addrs + 0);
#line 8072
  i = 0;
  {
#line 8072
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 8072
    if (! (i < naddrs - 1)) {
#line 8072
      goto while_break___6;
    }
#line 8073
    (*(addrs + i))->q_next = *(addrs + (i + 1));
#line 8072
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 8074
  (*(addrs + (naddrs - 1)))->q_next = (struct address *)((void *)0);
#line 8075
  return (0);
}
}
#line 8096
static int split_within_queue(ENVELOPE *e ) ;
#line 8098 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static int split_within_queue(ENVELOPE *e ) 
{ 
  int maxrcpt ;
  int nrcpt ;
  int ndead ;
  int nsplit ;
  int i ;
  int j ;
  int l ;
  char *lsplits ;
  ADDRESS *q ;
  ADDRESS **addrs ;
  ENVELOPE *ee ;
  ENVELOPE *firstsibling ;
  void *tmp ;
  int tmp___0 ;
  ADDRESS *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  bool tmp___4 ;
  char *p ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 8108
  if (! (e->e_qgrp >= 0)) {
#line 8109
    return (1);
  } else
#line 8108
  if ((e->e_flags & 67108864UL) != 0UL) {
#line 8109
    return (1);
  }
#line 8112
  maxrcpt = (Queue[e->e_qgrp])->qg_maxrcpt;
#line 8113
  if (maxrcpt <= 0) {
#line 8114
    return (1);
  }
#line 8117
  nrcpt = 0;
#line 8118
  q = e->e_sendqueue;
  {
#line 8118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8118
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 8118
      goto while_break;
    }
#line 8120
    if ((int )q->q_state >= 6) {
#line 8121
      goto __Cont;
    }
#line 8122
    nrcpt ++;
    __Cont: /* CIL Label */ 
#line 8118
    q = q->q_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 8124
  if (nrcpt <= maxrcpt) {
#line 8125
    return (1);
  }
  {
#line 8133
  tmp = sm_rpool_malloc_tagged_x(e->e_rpool, (size_t )((unsigned long )nrcpt * sizeof(ADDRESS *)),
                                 (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                                 8133, SmHeapGroup);
#line 8133
  addrs = (ADDRESS **)tmp;
#line 8134
  i = 0;
#line 8134
  q = e->e_sendqueue;
  }
  {
#line 8134
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 8134
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 8134
      goto while_break___0;
    }
#line 8136
    if ((int )q->q_state >= 6) {
#line 8137
      goto __Cont___0;
    }
#line 8138
    tmp___0 = i;
#line 8138
    i ++;
#line 8138
    *(addrs + tmp___0) = q;
    __Cont___0: /* CIL Label */ 
#line 8134
    q = q->q_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 8148
  ndead = 0;
#line 8149
  i = 0;
  {
#line 8149
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 8149
    if (! (i < nrcpt)) {
#line 8149
      goto while_break___1;
    }
#line 8151
    if ((int )(*(addrs + i))->q_state == 2) {
#line 8151
      goto _L;
    } else
#line 8151
    if ((int )(*(addrs + i))->q_state == 1) {
#line 8151
      goto _L;
    } else
#line 8151
    if ((int )(*(addrs + i))->q_state >= 6) {
      _L: /* CIL Label */ 
#line 8155
      if (i > ndead) {
#line 8157
        tmp___1 = *(addrs + i);
#line 8159
        *(addrs + i) = *(addrs + ndead);
#line 8160
        *(addrs + ndead) = tmp___1;
      }
#line 8162
      ndead ++;
    }
#line 8149
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 8167
  if (nrcpt - ndead <= maxrcpt) {
#line 8168
    return (1);
  }
#line 8171
  i = 0;
  {
#line 8171
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 8171
    if (! (i < nrcpt - 1)) {
#line 8171
      goto while_break___2;
    }
#line 8172
    (*(addrs + i))->q_next = *(addrs + (i + 1));
#line 8171
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 8173
  (*(addrs + (nrcpt - 1)))->q_next = (struct address *)((void *)0);
#line 8174
  e->e_sendqueue = *(addrs + 0);
#line 8177
  if (LogLevel > 8) {
    {
#line 8179
    l = 2048;
#line 8180
    tmp___2 = sm_malloc_tagged((size_t )l, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                               8180, SmHeapGroup);
#line 8180
    lsplits = (char *)tmp___2;
    }
#line 8181
    if ((unsigned long )lsplits != (unsigned long )((void *)0)) {
#line 8182
      *lsplits = (char )'\000';
    }
#line 8183
    j = 0;
  } else {
#line 8188
    lsplits = (char *)((void *)0);
#line 8189
    l = 0;
#line 8189
    j = l;
  }
#line 8193
  firstsibling = e->e_sibling;
#line 8194
  i = maxrcpt + ndead;
#line 8195
  nsplit = 0;
  {
#line 8196
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 8198
    (*(addrs + (i - 1)))->q_next = (struct address *)((void *)0);
#line 8199
    ee = split_env(e, *(addrs + i), e->e_qgrp, e->e_qdir);
#line 8200
    tmp___4 = dup_df(e, ee);
    }
#line 8200
    if (! tmp___4) {
#line 8203
      ee = firstsibling;
      {
#line 8204
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 8204
        if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 8204
          goto while_break___4;
        }
        {
#line 8206
        tmp___3 = queuename(ee, 'd');
#line 8206
        unlink((char const   *)tmp___3);
#line 8207
        ee = ee->e_sibling;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 8211
      e->e_sibling = firstsibling;
#line 8212
      i = 0;
      {
#line 8212
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 8212
        if (! (i < nrcpt - 1)) {
#line 8212
          goto while_break___5;
        }
#line 8213
        (*(addrs + i))->q_next = *(addrs + (i + 1));
#line 8212
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 8214
      if ((unsigned long )lsplits != (unsigned long )((void *)0)) {
        {
#line 8215
        sm_free_tagged((void *)lsplits, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                       8215);
        }
      }
#line 8216
      return (0);
    }
#line 8220
    ee->e_sibling = e->e_sibling;
#line 8221
    e->e_sibling = ee;
#line 8222
    nsplit ++;
#line 8223
    if (LogLevel > 8) {
#line 8223
      if ((unsigned long )lsplits != (unsigned long )((void *)0)) {
        {
#line 8225
        tmp___6 = strlen((char const   *)ee->e_id);
        }
#line 8225
        if ((size_t )j >= ((size_t )l - tmp___6) - 3U) {
          {
#line 8229
          l += 2048;
#line 8230
          tmp___5 = sm_realloc((void *)lsplits, (size_t )l);
#line 8230
          p = (char *)tmp___5;
          }
#line 8231
          if ((unsigned long )p == (unsigned long )((void *)0)) {
            {
#line 8234
            sm_free_tagged((void *)lsplits, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                           8234);
#line 8235
            lsplits = (char *)((void *)0);
            }
          } else {
#line 8238
            lsplits = p;
          }
        }
#line 8240
        if ((unsigned long )lsplits != (unsigned long )((void *)0)) {
#line 8242
          if (j == 0) {
            {
#line 8243
            tmp___7 = sm_strlcat(lsplits + j, (char const   *)ee->e_id, l - j);
#line 8243
            j = (int )((size_t )j + tmp___7);
            }
          } else {
            {
#line 8247
            tmp___8 = sm_strlcat2(lsplits + j, "; ", (char const   *)ee->e_id, l - j);
#line 8247
            j = (int )((size_t )j + tmp___8);
            }
          }
#line 8251
          if (j < l) {
#line 8251
            tmp___9 = 1;
          } else {
            {
#line 8251
            sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                        8251, "SM_ASSERT(j < l) failed");
#line 8251
            tmp___9 = 0;
            }
          }
        }
      }
    }
#line 8254
    if (nrcpt - i <= maxrcpt) {
#line 8255
      goto while_break___3;
    }
#line 8256
    i += maxrcpt;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 8258
  if (LogLevel > 8) {
#line 8258
    if ((unsigned long )lsplits != (unsigned long )((void *)0)) {
#line 8260
      if (nsplit > 0) {
#line 8262
        if (nsplit > 1) {
#line 8262
          tmp___10 = "s";
        } else {
#line 8262
          tmp___10 = "";
        }
        {
#line 8262
        sm_syslog(5, (char const   *)e->e_id, "split: maxrcpts=%d, rcpts=%d, count=%d, id%s=%s",
                  maxrcpt, nrcpt - ndead, nsplit, tmp___10, lsplits);
        }
      }
      {
#line 8267
      sm_free_tagged((void *)lsplits, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                     8267);
      }
    }
  }
#line 8269
  return (1 + nsplit);
}
}
#line 8287 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
bool split_by_recipient(ENVELOPE *e ) 
{ 
  int split ;
  int n ;
  int i ;
  int j ;
  int l ;
  char *lsplits ;
  ENVELOPE *ee ;
  ENVELOPE *next ;
  ENVELOPE *firstsibling ;
  void *tmp ;
  int tmp___0 ;
  char *p ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 8295
  if ((int )OpMode == 118) {
#line 8297
    return (1);
  } else
#line 8295
  if (! (e->e_qgrp >= 0)) {
#line 8297
    return (1);
  } else
#line 8295
  if ((e->e_flags & 67108864UL) != 0UL) {
#line 8297
    return (1);
  }
  {
#line 8298
  n = split_across_queue_groups(e);
  }
#line 8299
  if (n == 0) {
#line 8300
    return (0);
  }
#line 8301
  ee = e->e_sibling;
#line 8301
  firstsibling = ee;
#line 8302
  if (n > 1) {
#line 8302
    if (LogLevel > 8) {
      {
#line 8304
      l = 2048;
#line 8305
      tmp = sm_malloc_tagged((size_t )l, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                             8305, SmHeapGroup);
#line 8305
      lsplits = (char *)tmp;
      }
#line 8306
      if ((unsigned long )lsplits != (unsigned long )((void *)0)) {
#line 8307
        *lsplits = (char )'\000';
      }
#line 8308
      j = 0;
    } else {
#line 8313
      lsplits = (char *)((void *)0);
#line 8314
      l = 0;
#line 8314
      j = l;
    }
  } else {
#line 8313
    lsplits = (char *)((void *)0);
#line 8314
    l = 0;
#line 8314
    j = l;
  }
#line 8316
  i = 1;
  {
#line 8316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8316
    if (! (i < n)) {
#line 8316
      goto while_break;
    }
    {
#line 8318
    next = ee->e_sibling;
#line 8319
    tmp___0 = split_within_queue(ee);
    }
#line 8319
    if (tmp___0 == 0) {
#line 8321
      e->e_sibling = firstsibling;
#line 8322
      return (0);
    }
#line 8324
    ee->e_flags |= 67108864UL;
#line 8325
    if (LogLevel > 8) {
#line 8325
      if ((unsigned long )lsplits != (unsigned long )((void *)0)) {
        {
#line 8327
        tmp___2 = strlen((char const   *)ee->e_id);
        }
#line 8327
        if ((size_t )j >= ((size_t )l - tmp___2) - 3U) {
          {
#line 8331
          l += 2048;
#line 8332
          tmp___1 = sm_realloc((void *)lsplits, (size_t )l);
#line 8332
          p = (char *)tmp___1;
          }
#line 8333
          if ((unsigned long )p == (unsigned long )((void *)0)) {
            {
#line 8336
            sm_free_tagged((void *)lsplits, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                           8336);
#line 8337
            lsplits = (char *)((void *)0);
            }
          } else {
#line 8340
            lsplits = p;
          }
        }
#line 8342
        if ((unsigned long )lsplits != (unsigned long )((void *)0)) {
#line 8344
          if (j == 0) {
            {
#line 8345
            tmp___3 = sm_strlcat(lsplits + j, (char const   *)ee->e_id, l - j);
#line 8345
            j = (int )((size_t )j + tmp___3);
            }
          } else {
            {
#line 8348
            tmp___4 = sm_strlcat2(lsplits + j, "; ", (char const   *)ee->e_id, l - j);
#line 8348
            j = (int )((size_t )j + tmp___4);
            }
          }
#line 8350
          if (j < l) {
#line 8350
            tmp___5 = 1;
          } else {
            {
#line 8350
            sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                        8350, "SM_ASSERT(j < l) failed");
#line 8350
            tmp___5 = 0;
            }
          }
        }
      }
    }
#line 8353
    ee = next;
#line 8316
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 8355
  if (LogLevel > 8) {
#line 8355
    if ((unsigned long )lsplits != (unsigned long )((void *)0)) {
#line 8355
      if (n > 1) {
#line 8357
        if (n > 2) {
#line 8357
          tmp___6 = "s";
        } else {
#line 8357
          tmp___6 = "";
        }
        {
#line 8357
        sm_syslog(5, (char const   *)e->e_id, "split: count=%d, id%s=%s", n - 1, tmp___6,
                  lsplits);
#line 8359
        sm_free_tagged((void *)lsplits, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                       8359);
        }
      }
    }
  }
  {
#line 8361
  tmp___7 = split_within_queue(e);
#line 8361
  split = tmp___7 != 0;
  }
#line 8362
  if (split) {
#line 8363
    e->e_flags |= 67108864UL;
  }
#line 8364
  return (split);
}
}
#line 8385 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
static bool quarantine_queue_item(int qgrp , int qdir , ENVELOPE *e , char *reason ) 
{ 
  bool dirty ;
  bool failing ;
  bool foundq ;
  bool finished ;
  int fd ;
  int flags ;
  int oldtype ;
  int newtype ;
  int save_errno ;
  mode_t oldumask ;
  SM_FILE_T *oldqfp ;
  SM_FILE_T *tempqfp ;
  char *bp___3 ;
  char oldqf[4096] ;
  char tempqf[4096] ;
  char newqf[4096] ;
  char buf___16[2048] ;
  char tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  bool tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  bool tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int *tmp___28 ;
  int *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  int *tmp___33 ;
  int *tmp___34 ;
  char const   *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;

  {
  {
#line 8392
  dirty = 0;
#line 8393
  failing = 0;
#line 8394
  foundq = 0;
#line 8395
  finished = 0;
#line 8401
  oldumask = (mode_t )0;
#line 8409
  tmp = queue_letter(e, '?');
#line 8409
  oldtype = (int )tmp;
#line 8410
  tmp___0 = queuename(e, '?');
#line 8410
  sm_strlcpy(oldqf, (char const   *)tmp___0, (ssize_t )sizeof(oldqf));
#line 8411
  tmp___1 = queuename(e, 't');
#line 8411
  sm_strlcpy(tempqf, (char const   *)tmp___1, (ssize_t )sizeof(tempqf));
#line 8422
  tmp___3 = readqf(e, 1);
  }
#line 8422
  if (! tmp___3) {
    {
#line 8424
    tmp___2 = qid_printname(e);
#line 8424
    sm_io_fprintf(& SmIoF[1], -2, "Skipping %s\n", tmp___2);
    }
#line 8426
    return (0);
  }
#line 8428
  oldqfp = e->e_lockfp;
#line 8431
  flags = 193;
#line 8432
  if ((QueueFileMode & (128 >> 3)) != 0) {
    {
#line 8433
    oldumask = umask((__mode_t )2);
    }
  }
  {
#line 8434
  fd = open((char const   *)(tempqf), flags, QueueFileMode);
  }
#line 8435
  if ((QueueFileMode & (128 >> 3)) != 0) {
    {
#line 8436
    umask(oldumask);
    }
  }
#line 8439
  if (fd < 0) {
    {
#line 8441
    tmp___4 = __errno_location();
#line 8441
    save_errno = *tmp___4;
#line 8442
    tmp___5 = sm_errstring(save_errno);
#line 8442
    tmp___6 = qid_printname(e);
#line 8442
    sm_io_fprintf(& SmIoF[1], -2, "Skipping %s: Could not open %s: %s\n", tmp___6,
                  tempqf, tmp___5);
#line 8446
    sm_io_close(oldqfp, -2);
    }
#line 8447
    return (0);
  }
  {
#line 8449
  tmp___8 = lockfile(fd, tempqf, (char *)((void *)0), 6);
  }
#line 8449
  if (! tmp___8) {
    {
#line 8451
    tmp___7 = qid_printname(e);
#line 8451
    sm_io_fprintf(& SmIoF[1], -2, "Skipping %s: Could not lock %s\n", tmp___7, tempqf);
#line 8454
    close(fd);
#line 8455
    sm_io_close(oldqfp, -2);
    }
#line 8456
    return (0);
  }
  {
#line 8459
  tempqfp = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& fd)),
                       3, (void const   *)((void *)0));
  }
#line 8461
  if ((unsigned long )tempqfp == (unsigned long )((void *)0)) {
    {
#line 8463
    tmp___9 = qid_printname(e);
#line 8463
    sm_io_fprintf(& SmIoF[1], -2, "Skipping %s: Could not lock %s\n", tmp___9, tempqf);
#line 8466
    close(fd);
#line 8467
    sm_io_close(oldqfp, -2);
    }
#line 8468
    return (0);
  }
  {
#line 8472
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 8472
    bp___3 = fgetfolded(buf___16, (int )sizeof(buf___16), oldqfp);
    }
#line 8472
    if (! ((unsigned long )bp___3 != (unsigned long )((void *)0))) {
#line 8472
      goto while_break;
    }
#line 8474
    if ((int )tTdvect[40] >= 4) {
      {
#line 8475
      sm_dprintf((char *)"+++++ %s\n", bp___3);
      }
    }
    {
#line 8478
    if ((int )*(bp___3 + 0) == 113) {
#line 8478
      goto case_113;
    }
#line 8523
    if ((int )*(bp___3 + 0) == 83) {
#line 8523
      goto case_83;
    }
#line 8552
    if ((int )*(bp___3 + 0) == 46) {
#line 8552
      goto case_46;
    }
#line 8556
    goto switch_default;
    case_113: /* CIL Label */ 
#line 8479
    foundq = 1;
#line 8480
    if ((unsigned long )reason == (unsigned long )((void *)0)) {
#line 8482
      if (Verbose) {
        {
#line 8484
        sm_io_fprintf(& SmIoF[1], -2, "%s: Removed quarantine of \"%s\"\n", e->e_id,
                      bp___3 + 1);
        }
      }
      {
#line 8489
      sm_syslog(6, (char const   *)e->e_id, "unquarantine");
#line 8490
      dirty = 1;
      }
#line 8491
      goto while_continue;
    } else {
      {
#line 8493
      tmp___10 = strcmp((char const   *)reason, (char const   *)(bp___3 + 1));
      }
#line 8493
      if (tmp___10 == 0) {
#line 8495
        if (Verbose) {
          {
#line 8497
          sm_io_fprintf(& SmIoF[1], -2, "%s: Already quarantined with \"%s\"\n", e->e_id,
                        reason);
          }
        }
        {
#line 8502
        sm_io_fprintf(tempqfp, -2, "q%s\n", reason);
        }
      } else {
#line 8507
        if (Verbose) {
          {
#line 8509
          sm_io_fprintf(& SmIoF[1], -2, "%s: Quarantine changed from \"%s\" to \"%s\"\n",
                        e->e_id, bp___3 + 1, reason);
          }
        }
        {
#line 8515
        sm_io_fprintf(tempqfp, -2, "q%s\n", reason);
#line 8517
        sm_syslog(6, (char const   *)e->e_id, "quarantine=%s", reason);
#line 8519
        dirty = 1;
        }
      }
    }
#line 8521
    goto switch_break;
    case_83: /* CIL Label */ 
#line 8530
    if (! foundq) {
#line 8530
      if ((unsigned long )reason != (unsigned long )((void *)0)) {
#line 8532
        if (Verbose) {
          {
#line 8534
          sm_io_fprintf(& SmIoF[1], -2, "%s: Quarantined with \"%s\"\n", e->e_id,
                        reason);
          }
        }
        {
#line 8539
        sm_io_fprintf(tempqfp, -2, "q%s\n", reason);
#line 8541
        sm_syslog(6, (char const   *)e->e_id, "quarantine=%s", reason);
#line 8543
        foundq = 1;
#line 8544
        dirty = 1;
        }
      }
    }
    {
#line 8548
    sm_io_fprintf(tempqfp, -2, "%s\n", bp___3);
    }
#line 8550
    goto switch_break;
    case_46: /* CIL Label */ 
#line 8553
    finished = 1;
    switch_default: /* CIL Label */ 
    {
#line 8558
    sm_io_fprintf(tempqfp, -2, "%s\n", bp___3);
    }
#line 8560
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 8565
  tmp___11 = __errno_location();
#line 8565
  *tmp___11 = (tempqfp->f_flags & 256L) != 0L;
#line 8566
  tmp___15 = __errno_location();
  }
#line 8566
  if (*tmp___15 != 0) {
    {
#line 8566
    tmp___16 = __errno_location();
    }
#line 8566
    if (*tmp___16 != -1) {
      {
#line 8568
      tmp___12 = __errno_location();
#line 8568
      save_errno = *tmp___12;
#line 8569
      tmp___13 = sm_errstring(save_errno);
#line 8569
      tmp___14 = qid_printname(e);
#line 8569
      sm_io_fprintf(& SmIoF[1], -2, "Skipping %s: Error reading %s: %s\n", tmp___14,
                    oldqf, tmp___13);
#line 8573
      failing = 1;
      }
    }
  }
#line 8576
  if (! failing) {
#line 8576
    if (! finished) {
      {
#line 8578
      tmp___17 = qid_printname(e);
#line 8578
      sm_io_fprintf(& SmIoF[1], -2, "Skipping %s: Incomplete file: %s\n", tmp___17,
                    oldqf);
#line 8581
      failing = 1;
      }
    }
  }
#line 8585
  if (! dirty) {
#line 8588
    failing = 1;
  }
#line 8592
  if (! failing) {
    {
#line 8592
    tmp___21 = sm_io_flush(tempqfp, -2);
    }
#line 8592
    if (tmp___21 != 0) {
#line 8592
      goto _L;
    } else
#line 8592
    if (SuperSafe == 2) {
#line 8592
      goto _L___1;
    } else
#line 8592
    if (SuperSafe == 3) {
#line 8592
      goto _L___1;
    } else
#line 8592
    if (SuperSafe == 1) {
      _L___1: /* CIL Label */ 
      {
#line 8592
      tmp___22 = sm_io_getinfo(tempqfp, 3, (void *)0);
#line 8592
      tmp___23 = fsync(tmp___22);
      }
#line 8592
      if (tmp___23 < 0) {
#line 8592
        goto _L;
      } else {
#line 8592
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 8592
      tmp___24 = __errno_location();
#line 8592
      tmp___25 = (tempqfp->f_flags & 256L) != 0L;
#line 8592
      *tmp___24 = tmp___25;
      }
#line 8592
      if (tmp___25 != 0) {
        _L: /* CIL Label */ 
        {
#line 8600
        tmp___18 = __errno_location();
#line 8600
        save_errno = *tmp___18;
#line 8601
        tmp___19 = sm_errstring(save_errno);
#line 8601
        tmp___20 = qid_printname(e);
#line 8601
        sm_io_fprintf(& SmIoF[1], -2, "Skipping %s: Error writing %s: %s\n", tmp___20,
                      tempqf, tmp___19);
#line 8605
        failing = 1;
        }
      }
    }
  }
#line 8610
  if ((unsigned long )reason == (unsigned long )((void *)0)) {
#line 8610
    newtype = 'q';
  } else {
#line 8610
    newtype = 'h';
  }
#line 8611
  if (oldtype == newtype) {
    {
#line 8614
    sm_strlcpy(newqf, (char const   *)(oldqf), (ssize_t )sizeof(newqf));
    }
  } else {
    {
#line 8619
    tmp___26 = queuename(e, newtype);
#line 8619
    sm_strlcpy(newqf, (char const   *)tmp___26, (ssize_t )sizeof(newqf));
    }
  }
#line 8622
  save_errno = 0;
#line 8625
  if (! failing) {
    {
#line 8625
    tmp___30 = rename((char const   *)(tempqf), (char const   *)(newqf));
    }
#line 8625
    if (tmp___30 < 0) {
      {
#line 8627
      tmp___29 = __errno_location();
      }
#line 8627
      if (*tmp___29 == 0) {
#line 8627
        save_errno = 22;
      } else {
        {
#line 8627
        tmp___28 = __errno_location();
#line 8627
        save_errno = *tmp___28;
        }
      }
    }
  }
#line 8630
  if (! failing) {
#line 8630
    if (save_errno != 0) {
      {
#line 8632
      tmp___31 = sm_errstring(save_errno);
#line 8632
      sm_syslog(7, (char const   *)e->e_id, "quarantine_queue_item: rename(%s, %s): %s",
                tempqf, newqf, tmp___31);
#line 8636
      tmp___32 = sm_errstring(save_errno);
#line 8636
      sm_io_fprintf(& SmIoF[1], -2, "Error renaming %s to %s: %s\n", tempqf, newqf,
                    tmp___32);
      }
#line 8640
      if (oldtype == newtype) {
        {
#line 8649
        tmp___33 = __errno_location();
#line 8649
        *tmp___33 = save_errno;
#line 8650
        syserr("!452 Error renaming control file %s", tempqf);
        }
      } else {
        {
#line 8656
        tmp___36 = xunlink(newqf);
        }
#line 8656
        if (tmp___36 < 0) {
          {
#line 8658
          tmp___34 = __errno_location();
#line 8658
          save_errno = *tmp___34;
#line 8659
          tmp___35 = sm_errstring(save_errno);
#line 8659
          sm_io_fprintf(& SmIoF[1], -2, "Error removing %s: %s\n", newqf, tmp___35);
          }
        }
#line 8666
        failing = 1;
      }
    }
  }
#line 8672
  if (! failing) {
#line 8672
    if (oldtype != newtype) {
      {
#line 8674
      tmp___39 = xunlink(oldqf);
      }
#line 8674
      if (tmp___39 < 0) {
        {
#line 8676
        tmp___37 = __errno_location();
#line 8676
        save_errno = *tmp___37;
#line 8677
        tmp___38 = sm_errstring(save_errno);
#line 8677
        sm_io_fprintf(& SmIoF[1], -2, "Error removing %s: %s\n", oldqf, tmp___38);
        }
      }
    }
  }
#line 8684
  if (failing) {
    {
#line 8687
    xunlink(tempqf);
    }
  }
#line 8696
  if (SuperSafe != 0) {
    {
#line 8699
    tmp___40 = sm_io_getinfo(tempqfp, 3, (void *)0);
#line 8699
    fsync(tmp___40);
    }
#line 8702
    if (! failing) {
      {
#line 8705
      tmp___41 = sm_io_getinfo(oldqfp, 3, (void *)0);
#line 8705
      fsync(tmp___41);
      }
    }
    {
#line 8710
    sync_dir(tempqf, 0);
    }
  }
#line 8715
  if ((unsigned long )tempqfp != (unsigned long )((void *)0)) {
    {
#line 8716
    sm_io_close(tempqfp, -2);
    }
  }
#line 8717
  if ((unsigned long )oldqfp != (unsigned long )((void *)0)) {
    {
#line 8718
    sm_io_close(oldqfp, -2);
    }
  }
#line 8721
  return (! failing);
}
}
#line 8741 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c"
void quarantine_queue(char *reason , int qgrplimit ) 
{ 
  int changed ;
  int qgrp ;
  char *tmp ;
  int qdir ;
  int i ;
  int nrequests ;
  char *tmp___0 ;
  char *tmp___1 ;
  ENVELOPE e ;
  SM_RPOOL_T *tmp___2 ;
  bool tmp___3 ;
  char const   *tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 8746
  changed = 0;
#line 8750
  if ((unsigned long )reason != (unsigned long )((void *)0)) {
#line 8750
    if ((int )*(reason + 0) == 46) {
#line 8750
      if ((int )*(reason + 1) == 0) {
#line 8751
        reason = (char *)((void *)0);
      }
    }
  }
#line 8753
  if ((unsigned long )reason != (unsigned long )((void *)0)) {
    {
#line 8756
    tmp = denlstring(reason, 1, 1);
#line 8756
    reason = newstr((char const   *)tmp);
    }
  }
#line 8759
  qgrp = 0;
  {
#line 8759
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8759
    if (qgrp < NumQueue) {
#line 8759
      if (! ((unsigned long )Queue[qgrp] != (unsigned long )((void *)0))) {
#line 8759
        goto while_break;
      }
    } else {
#line 8759
      goto while_break;
    }
#line 8763
    if (qgrplimit != -1) {
#line 8763
      if (qgrplimit != qgrp) {
#line 8764
        goto __Cont;
      }
    }
#line 8766
    qdir = 0;
    {
#line 8766
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 8766
      if (! (qdir < (Queue[qgrp])->qg_numqueues)) {
#line 8766
        goto while_break___0;
      }
#line 8771
      if (StopRequest) {
        {
#line 8772
        stop_sendmail();
        }
      }
      {
#line 8774
      nrequests = gatherq(qgrp, qdir, 1, (bool *)((void *)0), (bool *)((void *)0));
      }
#line 8777
      if (nrequests <= 0) {
#line 8779
        if (Verbose) {
          {
#line 8781
          tmp___0 = qid_printqueue(qgrp, qdir);
#line 8781
          sm_io_fprintf(& SmIoF[1], -2, "%s: no matches\n", tmp___0);
          }
        }
#line 8785
        goto __Cont___0;
      }
#line 8788
      if (Verbose) {
        {
#line 8790
        tmp___1 = qid_printqueue(qgrp, qdir);
#line 8790
        sm_io_fprintf(& SmIoF[1], -2, "Processing %s:\n", tmp___1);
        }
      }
#line 8795
      i = 0;
      {
#line 8795
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 8795
        if (! (i < WorkListCount)) {
#line 8795
          goto while_break___1;
        }
#line 8799
        if (StopRequest) {
          {
#line 8800
          stop_sendmail();
          }
        }
        {
#line 8803
        tmp___2 = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 8803
        clearenvelope(& e, 1, tmp___2);
#line 8804
        e.e_id = (WorkList + i)->w_name + 2;
#line 8805
        e.e_qgrp = qgrp;
#line 8806
        e.e_qdir = qdir;
        }
#line 8808
        if ((int )tTdvect[70] >= 101) {
          {
#line 8810
          sm_io_fprintf(& SmIoF[1], -2, "Would do %s\n", e.e_id);
#line 8812
          changed ++;
          }
        } else {
          {
#line 8814
          tmp___3 = quarantine_queue_item(qgrp, qdir, & e, reason);
          }
#line 8814
          if (tmp___3) {
#line 8816
            changed ++;
          }
        }
        {
#line 8819
        sm_rpool_free(e.e_rpool);
#line 8820
        e.e_rpool = (SM_RPOOL_T *)((void *)0);
#line 8795
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 8822
      if ((unsigned long )WorkList != (unsigned long )((void *)0)) {
        {
#line 8823
        sm_free_tagged((void *)WorkList, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/queue.c",
                       8823);
        }
      }
#line 8824
      WorkList = (WORK *)((void *)0);
#line 8825
      WorkListSize = 0;
#line 8826
      WorkListCount = 0;
      __Cont___0: /* CIL Label */ 
#line 8766
      qdir ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 8759
    qgrp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 8829
  if (Verbose) {
#line 8831
    if (changed == 0) {
      {
#line 8832
      sm_io_fprintf(& SmIoF[1], -2, "No changes\n");
      }
    } else {
#line 8835
      if (changed == 1) {
#line 8835
        tmp___4 = "";
      } else {
#line 8835
        tmp___4 = "s";
      }
      {
#line 8835
      sm_io_fprintf(& SmIoF[1], -2, "%d change%s\n", changed, tmp___4);
      }
    }
  }
#line 8840
  return;
}
}
#line 335 "./sendmail.h"
void cataddr(char **pvp , char **evp , char *buf___16 , int sz , int spacesub ) ;
#line 336
char *crackaddr(char *addr , ENVELOPE *e ) ;
#line 340
bool invalidaddr(char *addr , char *delimptr , bool isrcpt ) ;
#line 346
char *remotename(char *name , struct mailer *m , int flags , int *pstat , ENVELOPE *e ) ;
#line 347
int rewrite(char **pvp , int ruleset , int reclevel , ENVELOPE *e , int maxatom ) ;
#line 463
void initerrmailers(void) ;
#line 1093
void macset(MACROS_T *mac , int i , char *value ) ;
#line 1280
bool openmap(struct _map *map___0 ) ;
#line 2205
int DefaultNotify ;
#line 2225
int MaxRuleRecursion ;
#line 18 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static void allocaddr(ADDRESS *a , int flags , char *paddr , ENVELOPE *e ) ;
#line 19
static int callsubr(char **pvp , int reclevel , ENVELOPE *e ) ;
#line 20
static char *map_lookup(STAB *smap , char *key , char **argvect , int *pstat , ENVELOPE *e ) ;
#line 21
static ADDRESS *buildaddr(char **tv , ADDRESS *a , int flags , ENVELOPE *e ) ;
#line 22
static bool hasctrlchar(char *addr , bool isrcpt , bool complain ) ;
#line 67 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
ADDRESS *parseaddr(char *addr , ADDRESS *a , int flags , int delim , char **delimptr ,
                   ENVELOPE *e , bool isrcpt ) 
{ 
  char **pvp ;
  char *delimptrbuf ;
  bool qup ;
  char pvpbuf[1256] ;
  char *tmp ;
  bool tmp___0 ;
  char savec ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int r ;
  char *msg ;
  SM_FILE_T *tmp___4 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 86
  e->e_to = addr;
#line 87
  if ((int )tTdvect[20] >= 1) {
    {
#line 88
    sm_dprintf((char *)"\n--parseaddr(%s)\n", addr);
    }
  }
#line 90
  if ((unsigned long )delimptr == (unsigned long )((void *)0)) {
#line 91
    delimptr = & delimptrbuf;
  }
  {
#line 93
  pvp = prescan(addr, delim, pvpbuf, (int )sizeof(pvpbuf), delimptr, (unsigned char *)((void *)0),
                0);
  }
#line 94
  if ((unsigned long )pvp == (unsigned long )((void *)0)) {
#line 96
    if ((int )tTdvect[20] >= 1) {
      {
#line 97
      sm_dprintf((char *)"parseaddr-->NULL\n");
      }
    }
#line 98
    return ((ADDRESS *)((void *)0));
  }
#line 101
  if (delim == 0) {
#line 101
    tmp = (char *)((void *)0);
  } else {
#line 101
    tmp = *delimptr;
  }
  {
#line 101
  tmp___0 = invalidaddr(addr, tmp, isrcpt);
  }
#line 101
  if (tmp___0) {
#line 103
    if ((int )tTdvect[20] >= 1) {
      {
#line 104
      sm_dprintf((char *)"parseaddr-->bad address\n");
      }
    }
#line 105
    return ((ADDRESS *)((void *)0));
  }
#line 116
  if ((flags & 32) != 0) {
#line 116
    if ((unsigned long )addr != (unsigned long )((void *)0)) {
#line 118
      savec = *(*delimptr);
#line 120
      if ((int )savec != 0) {
#line 121
        *(*delimptr) = (char )'\000';
      }
      {
#line 122
      addr = sm_rpool_strdup_x(e->e_rpool, (char const   *)addr);
#line 122
      e->e_to = addr;
      }
#line 123
      if ((int )savec != 0) {
#line 124
        *(*delimptr) = savec;
      }
    }
  }
  {
#line 132
  qup = 0;
#line 133
  tmp___1 = rewrite(pvp, 3, 0, e, 1000);
  }
#line 133
  if (tmp___1 == 75) {
#line 134
    qup = 1;
  }
  {
#line 135
  tmp___2 = rewrite(pvp, 0, 0, e, 1000);
  }
#line 135
  if (tmp___2 == 75) {
#line 136
    qup = 1;
  }
  {
#line 142
  a = buildaddr(pvp, a, flags, e);
#line 144
  tmp___3 = hasctrlchar(a->q_user, isrcpt, 1);
  }
#line 144
  if (tmp___3) {
#line 146
    if ((int )tTdvect[20] >= 1) {
      {
#line 147
      sm_dprintf((char *)"parseaddr-->bad q_user\n");
      }
    }
#line 155
    a->q_state = (short)2;
  }
  {
#line 163
  allocaddr(a, flags, addr, e);
  }
#line 164
  if ((int )a->q_state == 2) {
    {
#line 167
    hasctrlchar(a->q_paddr, isrcpt, 0);
    }
#line 168
    return (a);
  }
#line 178
  if (a->q_qgrp == -3) {
#line 178
    goto _L;
  } else
#line 178
  if (a->q_qgrp == -2) {
    _L: /* CIL Label */ 
#line 178
    if (! ((flags & 3) != 0)) {
#line 178
      if ((int )OpMode != 105) {
        {
#line 185
        r = rscap((char *)"queuegroup", a->q_user, (char *)((void *)0), e, & pvp,
                  pvpbuf, (int )sizeof(pvpbuf));
        }
#line 187
        if (r == 0) {
#line 187
          if ((unsigned long )pvp != (unsigned long )((void *)0)) {
#line 187
            if ((unsigned long )*(pvp + 0) != (unsigned long )((void *)0)) {
#line 187
              if (((int )*(*(pvp + 0) + 0) & 255) == 150) {
#line 187
                if ((unsigned long )*(pvp + 1) != (unsigned long )((void *)0)) {
#line 187
                  if ((int )*(*(pvp + 1) + 0) != 0) {
                    {
#line 192
                    r = name2qid(*(pvp + 1));
                    }
#line 193
                    if (r == -1) {
#line 193
                      if (LogLevel > 10) {
                        {
#line 194
                        sm_syslog(6, "*~*", "can\'t find queue group name %s, selection ignored",
                                  *(pvp + 1));
                        }
                      }
                    }
#line 197
                    if ((int )tTdvect[20] >= 4) {
#line 197
                      if (r != -1) {
                        {
#line 198
                        sm_syslog(6, "*~*", "queue group name %s -> %d", *(pvp + 1),
                                  r);
                        }
                      }
                    }
#line 201
                    if (r == -1) {
#line 201
                      a->q_qgrp = -2;
                    } else {
#line 201
                      a->q_qgrp = r;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 209
  if (qup) {
#line 209
    if ((int )OpMode != 105) {
#line 211
      msg = (char *)"Transient parse error -- message queued for future delivery";
#line 213
      if ((int )e->e_sendmode == 100) {
#line 214
        msg = (char *)"Deferring message until queue run";
      }
#line 215
      if ((int )tTdvect[20] >= 1) {
        {
#line 216
        sm_dprintf((char *)"parseaddr: queuing message\n");
        }
      }
      {
#line 217
      message((char const   *)msg);
      }
#line 218
      if ((unsigned long )e->e_message == (unsigned long )((void *)0)) {
#line 218
        if ((int )e->e_sendmode != 100) {
          {
#line 219
          e->e_message = sm_rpool_strdup_x(e->e_rpool, (char const   *)msg);
          }
        }
      }
#line 220
      a->q_state = (short)3;
#line 221
      a->q_status = (char *)"4.4.3";
    }
  }
#line 228
  if ((int )tTdvect[20] >= 1) {
    {
#line 230
    sm_dprintf((char *)"parseaddr-->");
#line 231
    tmp___4 = sm_debug_file();
#line 231
    printaddr(tmp___4, a, 0);
    }
  }
#line 234
  return (a);
}
}
#line 251 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
bool invalidaddr(char *addr , char *delimptr , bool isrcpt ) 
{ 
  bool result___0 ;
  char savedelim ;
  char *b___0 ;
  int len___0 ;
  char saved ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 257
  result___0 = 0;
#line 258
  savedelim = (char )'\000';
#line 259
  b___0 = addr;
#line 260
  len___0 = 0;
#line 262
  if ((unsigned long )delimptr != (unsigned long )((void *)0)) {
#line 265
    savedelim = *delimptr;
#line 266
    if ((int )savedelim != 0) {
#line 267
      *delimptr = (char )'\000';
    }
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! ((int )*addr != 0)) {
#line 269
      goto while_break;
    }
#line 271
    if (((int )*addr & 224) == 128) {
#line 273
      if (ExitStat == 0) {
#line 273
        ExitStat = 64;
      } else
#line 273
      if (ExitStat == 75) {
#line 273
        ExitStat = 64;
      }
#line 274
      result___0 = 1;
#line 275
      *addr = (char )'?';
    }
#line 277
    len___0 ++;
#line 277
    if (len___0 > 255) {
      {
#line 279
      saved = *addr;
#line 281
      *addr = (char )'\000';
#line 282
      usrerr("553 5.1.0 Address \"%s\" too long (%d bytes max)", b___0, 255);
#line 284
      *addr = saved;
#line 285
      result___0 = 1;
      }
#line 286
      goto delim;
    }
#line 269
    addr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  if (result___0) {
#line 291
    if (isrcpt) {
      {
#line 292
      usrerr("501 5.1.3 8-bit character in mailbox address \"%s\"", b___0);
      }
    } else {
      {
#line 295
      usrerr("501 5.1.7 8-bit character in mailbox address \"%s\"", b___0);
      }
    }
  }
  delim: 
#line 299
  if ((unsigned long )delimptr != (unsigned long )((void *)0)) {
#line 299
    if ((int )savedelim != 0) {
#line 300
      *delimptr = savedelim;
    }
  }
#line 301
  return (result___0);
}
}
#line 323 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static bool hasctrlchar(char *addr , bool isrcpt , bool complain ) 
{ 
  bool quoted ;
  int len___0 ;
  char *result___0 ;
  char *b___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 328
  quoted = 0;
#line 329
  len___0 = 0;
#line 330
  result___0 = (char *)((void *)0);
#line 331
  b___0 = addr;
#line 333
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 334
    return (0);
  }
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! ((int )*addr != 0)) {
#line 335
      goto while_break;
    }
#line 337
    len___0 ++;
#line 337
    if (len___0 > 255) {
#line 339
      if (complain) {
        {
#line 341
        shorten_rfc822_string(b___0, (size_t )255);
#line 342
        usrerr("553 5.1.0 Address \"%s\" too long (%d bytes max)", b___0, 255);
        }
#line 344
        return (1);
      }
#line 346
      result___0 = (char *)"too long";
    }
#line 348
    if (! quoted) {
#line 348
      if ((int )*addr < 32) {
#line 350
        result___0 = (char *)"non-printable character";
#line 351
        *addr = (char )'?';
#line 352
        goto __Cont;
      } else
#line 348
      if ((int )*addr == 127) {
#line 350
        result___0 = (char *)"non-printable character";
#line 351
        *addr = (char )'?';
#line 352
        goto __Cont;
      }
    }
#line 354
    if ((int )*addr == 34) {
#line 355
      quoted = ! quoted;
    } else
#line 356
    if ((int )*addr == 92) {
#line 359
      addr ++;
#line 359
      if ((int )*addr == 0) {
#line 361
        result___0 = (char *)"trailing \\ character";
#line 362
        addr --;
#line 362
        *addr = (char )'?';
#line 363
        goto while_break;
      }
    }
#line 366
    if (((int )*addr & 224) == 128) {
#line 368
      if (ExitStat == 0) {
#line 368
        ExitStat = 64;
      } else
#line 368
      if (ExitStat == 75) {
#line 368
        ExitStat = 64;
      }
#line 369
      result___0 = (char *)"8-bit character";
#line 370
      *addr = (char )'?';
#line 371
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 335
    addr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  if (quoted) {
#line 375
    result___0 = (char *)"unbalanced quote";
  }
#line 376
  if ((unsigned long )result___0 != (unsigned long )((void *)0)) {
#line 376
    if (complain) {
#line 378
      if (isrcpt) {
        {
#line 379
        usrerr("501 5.1.3 Syntax error in mailbox address \"%s\" (%s)", b___0, result___0);
        }
      } else {
        {
#line 382
        usrerr("501 5.1.7 Syntax error in mailbox address \"%s\" (%s)", b___0, result___0);
        }
      }
    }
  }
#line 385
  return ((unsigned long )result___0 != (unsigned long )((void *)0));
}
}
#line 406 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static void allocaddr(ADDRESS *a , int flags , char *paddr , ENVELOPE *e ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 413
  if ((int )tTdvect[24] >= 4) {
    {
#line 414
    sm_dprintf((char *)"allocaddr(flags=%x, paddr=%s)\n", flags, paddr);
    }
  }
#line 416
  a->q_paddr = paddr;
#line 418
  if ((unsigned long )a->q_user == (unsigned long )((void *)0)) {
#line 419
    a->q_user = (char *)"";
  }
#line 420
  if ((unsigned long )a->q_host == (unsigned long )((void *)0)) {
#line 421
    a->q_host = (char *)"";
  }
#line 423
  if ((flags & 16) != 0) {
    {
#line 425
    a->q_host = sm_rpool_strdup_x(e->e_rpool, (char const   *)a->q_host);
    }
#line 426
    if ((unsigned long )a->q_user != (unsigned long )a->q_paddr) {
      {
#line 427
      a->q_user = sm_rpool_strdup_x(e->e_rpool, (char const   *)a->q_user);
      }
    }
  }
#line 430
  if ((unsigned long )a->q_paddr == (unsigned long )((void *)0)) {
    {
#line 431
    a->q_paddr = sm_rpool_strdup_x(e->e_rpool, (char const   *)a->q_user);
    }
  }
#line 432
  a->q_qgrp = -3;
#line 433
  return;
}
}
#line 486 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static short StateTab[6][6]  = { {        (short)32,        (short)33,        (short)34,        (short)51, 
            (short)36,        (short)53}, 
   {        (short)32,        (short)1,        (short)34,        (short)51, 
            (short)36,        (short)53}, 
   {        (short)2,        (short)2,        (short)0,        (short)2, 
            (short)2,        (short)2}, 
   {        (short)0,        (short)1,        (short)2,        (short)19, 
            (short)4,        (short)53}, 
   {        (short)0,        (short)0,        (short)0,        (short)0, 
            (short)0,        (short)53}, 
   {        (short)32,        (short)33,        (short)34,        (short)51, 
            (short)36,        (short)21}};
#line 498 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static unsigned char TokTypeTab[256]  = 
#line 498
  {      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)3,      (unsigned char)3,      (unsigned char)3, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)3,      (unsigned char)1,      (unsigned char)2,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)4,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1};
#line 536 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
unsigned char MimeTokenTab[256]  = 
#line 536
  {      (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)3,      (unsigned char)3,      (unsigned char)3, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)3,      (unsigned char)1,      (unsigned char)2,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5};
#line 574 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
unsigned char TokTypeNoC[256]  = 
#line 574
  {      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)3,      (unsigned char)3,      (unsigned char)3, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)3,      (unsigned char)1,      (unsigned char)2,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)4,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1};
#line 636 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static char *av[1001]  ;
#line 637 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static bool firsttime  =    1;
#line 614 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
char **prescan(char *addr , int delim , char *pvpbuf , int pvpbsize , char **delimptr ,
               unsigned char *toktab , bool ignore ) 
{ 
  register char *p ;
  register char *q ;
  register int c ;
  char **avp ;
  bool bslashmode ;
  bool route_syntax ;
  int cmntcnt ;
  int anglecnt ;
  char *tok ;
  int state ;
  int newstate ;
  char *saveto ;
  char obuf[50] ;
  int *tmp ;
  SM_FILE_T *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *ptr ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  SM_FILE_T *tmp___9 ;
  char **tmp___10 ;
  SM_FILE_T *tmp___11 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
#line 635
  saveto = CurEnv->e_to;
#line 639
  if (firsttime) {
#line 644
    firsttime = 0;
#line 645
    if ((unsigned long )OperatorChars == (unsigned long )((void *)0)) {
#line 647
      if (ConfigLevel < 7) {
        {
#line 648
        OperatorChars = macvalue('o', CurEnv);
        }
      }
#line 649
      if ((unsigned long )OperatorChars == (unsigned long )((void *)0)) {
#line 650
        OperatorChars = (char *)".:@[]";
      }
    }
    {
#line 652
    expand(OperatorChars, obuf, (size_t )(sizeof(obuf) - sizeof("()<>,;\r\n")), CurEnv);
#line 654
    sm_strlcat(obuf, "()<>,;\r\n", (ssize_t )sizeof(obuf));
#line 655
    p = obuf;
    }
    {
#line 655
    while (1) {
      while_continue: /* CIL Label */ ;
#line 655
      if (! ((int )*p != 0)) {
#line 655
        goto while_break;
      }
#line 657
      if ((int )TokTypeTab[(int )*p & 255] == 1) {
#line 658
        TokTypeTab[(int )*p & 255] = (unsigned char)0;
      }
#line 659
      if ((int )TokTypeNoC[(int )*p & 255] == 1) {
#line 660
        TokTypeNoC[(int )*p & 255] = (unsigned char)0;
      }
#line 655
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 663
  if ((unsigned long )toktab == (unsigned long )((void *)0)) {
#line 664
    toktab = TokTypeTab;
  }
  {
#line 667
  tmp = __errno_location();
#line 667
  *tmp = 0;
#line 669
  q = pvpbuf;
#line 670
  bslashmode = 0;
#line 671
  route_syntax = 0;
#line 672
  cmntcnt = 0;
#line 673
  anglecnt = 0;
#line 674
  avp = av;
#line 675
  state = 1;
#line 676
  c = -1;
#line 677
  p = addr;
#line 678
  CurEnv->e_to = p;
  }
#line 679
  if ((int )tTdvect[22] >= 11) {
    {
#line 681
    sm_dprintf((char *)"prescan: ");
#line 682
    tmp___0 = sm_debug_file();
#line 682
    xputs(tmp___0, (char const   *)p);
#line 683
    sm_dprintf((char *)"\n");
    }
  }
  {
#line 686
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    tok = q;
    {
#line 690
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 693
      if (c != -1) {
#line 693
        if (! bslashmode) {
#line 696
          if ((unsigned long )q >= (unsigned long )(pvpbuf + (pvpbsize - 5))) {
            addrtoolong: 
            {
#line 699
            usrerr("553 5.1.1 Address too long");
#line 700
            tmp___1 = strlen((char const   *)addr);
            }
#line 700
            if (tmp___1 > 256U) {
#line 701
              *(addr + 256) = (char )'\000';
            }
            returnnull: 
#line 703
            if ((unsigned long )delimptr != (unsigned long )((void *)0)) {
#line 705
              if ((unsigned long )p > (unsigned long )addr) {
#line 706
                p --;
              }
#line 707
              *delimptr = p;
            }
#line 709
            CurEnv->e_to = saveto;
#line 710
            return ((char **)((void *)0));
          }
#line 715
          if ((int )((char )c) == -1) {
#line 715
            if (! ((int )tTdvect[82] >= 101)) {
#line 716
              c &= 127;
            }
          }
#line 718
          tmp___2 = q;
#line 718
          q ++;
#line 718
          *tmp___2 = (char )c;
        }
      }
#line 722
      tmp___3 = p;
#line 722
      p ++;
#line 722
      c = (int )*tmp___3 & 255;
#line 723
      if (c == 0) {
#line 726
        if (ignore) {
#line 727
          goto while_break___1;
        } else
#line 728
        if (state == 2) {
          {
#line 730
          usrerr("553 Unbalanced \'\"\'");
#line 731
          c = '\"';
          }
        } else
#line 733
        if (cmntcnt > 0) {
          {
#line 735
          usrerr("553 Unbalanced \'(\'");
#line 736
          c = ')';
          }
        } else
#line 738
        if (anglecnt > 0) {
          {
#line 740
          c = '>';
#line 741
          usrerr("553 Unbalanced \'<\'");
          }
        } else {
#line 744
          goto while_break___1;
        }
#line 746
        p --;
      } else
#line 748
      if (c == delim) {
#line 748
        if (cmntcnt <= 0) {
#line 748
          if (state != 2) {
#line 750
            if (anglecnt <= 0) {
#line 751
              goto while_break___1;
            }
#line 754
            if (delim == 44) {
#line 754
              if (! route_syntax) {
#line 754
                if (! ignore) {
                  {
#line 756
                  usrerr("553 Unbalanced \'<\'");
#line 757
                  c = '>';
#line 758
                  p --;
                  }
                }
              }
            }
          }
        }
      }
#line 762
      if ((int )tTdvect[22] >= 101) {
        {
#line 763
        sm_dprintf((char *)"c=%c, s=%d; ", c, state);
        }
      }
#line 766
      *q = (char )'\000';
#line 767
      if (bslashmode) {
#line 769
        bslashmode = 0;
#line 772
        if (cmntcnt > 0) {
#line 774
          c = -1;
#line 775
          goto __Cont;
        } else
#line 777
        if (c != 33) {
#line 777
          goto _L;
        } else
#line 777
        if (state == 2) {
          _L: /* CIL Label */ 
#line 780
          if ((unsigned long )q >= (unsigned long )(pvpbuf + (pvpbsize - 5))) {
#line 781
            goto addrtoolong;
          }
#line 782
          tmp___4 = q;
#line 782
          q ++;
#line 782
          *tmp___4 = (char )'\\';
#line 783
          goto __Cont;
        }
      }
#line 787
      if (c == 92) {
#line 789
        bslashmode = 1;
      } else
#line 791
      if (! (state == 2)) {
#line 796
        if (c == 40) {
#line 796
          if ((int )*(toktab + 40) == 3) {
#line 798
            cmntcnt ++;
#line 799
            c = -1;
          } else {
#line 796
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 801
        if (c == 41) {
#line 801
          if ((int )*(toktab + 40) == 3) {
#line 803
            if (cmntcnt <= 0) {
#line 805
              if (! ignore) {
                {
#line 807
                usrerr("553 Unbalanced \')\'");
#line 808
                c = -1;
                }
              }
            } else {
#line 812
              cmntcnt --;
            }
          } else {
#line 801
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 814
        if (cmntcnt > 0) {
#line 816
          c = -1;
        } else
#line 818
        if (c == 60) {
#line 820
          ptr = p;
#line 822
          anglecnt ++;
          {
#line 823
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 823
            if (((int )*ptr & -128) == 0) {
              {
#line 823
              tmp___5 = __ctype_b_loc();
              }
#line 823
              if (! ((int const   )*(*tmp___5 + (int )*ptr) & 8192)) {
#line 823
                goto while_break___2;
              }
            } else {
#line 823
              goto while_break___2;
            }
#line 824
            ptr ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 825
          if ((int )*ptr == 64) {
#line 826
            route_syntax = 1;
          }
        } else
#line 828
        if (c == 62) {
#line 830
          if (anglecnt <= 0) {
#line 832
            if (! ignore) {
              {
#line 834
              usrerr("553 Unbalanced \'>\'");
#line 835
              c = -1;
              }
            }
          } else {
#line 839
            anglecnt --;
          }
#line 840
          route_syntax = 0;
        } else
#line 842
        if (delim == 32) {
#line 842
          if ((c & -128) == 0) {
            {
#line 842
            tmp___6 = __ctype_b_loc();
            }
#line 842
            if ((int const   )*(*tmp___6 + c) & 8192) {
#line 843
              c = ' ';
            }
          }
        }
      }
#line 845
      if (c == -1) {
#line 846
        goto __Cont;
      }
#line 849
      if (c == delim) {
#line 849
        if (anglecnt <= 0) {
#line 849
          if (state != 2) {
#line 850
            goto while_break___1;
          }
        }
      }
#line 852
      newstate = (int )StateTab[state][*(toktab + (c & 255))];
#line 853
      if ((int )tTdvect[22] >= 101) {
        {
#line 854
        sm_dprintf((char *)"ns=%02o\n", newstate);
        }
      }
#line 855
      state = newstate & 15;
#line 856
      if (state == 5) {
#line 858
        if ((c & -128) == 0) {
          {
#line 858
          tmp___7 = __ctype_b_loc();
          }
#line 858
          if ((int const   )*(*tmp___7 + c) & 16384) {
            {
#line 859
            usrerr("553 Illegal character %c", c);
            }
          } else {
            {
#line 861
            usrerr("553 Illegal character 0x%02x", c & 255);
            }
          }
        } else {
          {
#line 861
          usrerr("553 Illegal character 0x%02x", c & 255);
          }
        }
      }
#line 864
      if ((newstate & 16) != 0) {
#line 865
        c = -1;
      }
#line 866
      if ((newstate & 32) != 0) {
#line 867
        goto while_break___1;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 871
    if ((unsigned long )tok != (unsigned long )q) {
#line 874
      if ((unsigned long )q >= (unsigned long )(pvpbuf + (pvpbsize - 5))) {
#line 875
        goto addrtoolong;
      }
#line 876
      tmp___8 = q;
#line 876
      q ++;
#line 876
      *tmp___8 = (char )'\000';
#line 877
      if ((int )tTdvect[22] >= 36) {
        {
#line 879
        sm_dprintf((char *)"tok=");
#line 880
        tmp___9 = sm_debug_file();
#line 880
        xputs(tmp___9, (char const   *)tok);
#line 881
        sm_dprintf((char *)"\n");
        }
      }
#line 883
      if ((unsigned long )avp >= (unsigned long )(& av[1000])) {
        {
#line 885
        usrerr("553 5.1.0 prescan: too many tokens");
        }
#line 886
        goto returnnull;
      }
#line 888
      if (q - tok > 256L) {
        {
#line 890
        usrerr("553 5.1.0 prescan: token too long");
        }
#line 891
        goto returnnull;
      }
#line 893
      tmp___10 = avp;
#line 893
      avp ++;
#line 893
      *tmp___10 = tok;
    }
#line 686
    if (c != 0) {
#line 686
      if (! (c != delim)) {
#line 686
        if (! (anglecnt > 0)) {
#line 686
          goto while_break___0;
        }
      }
    } else {
#line 686
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 896
  *avp = (char *)((void *)0);
#line 897
  if ((unsigned long )delimptr != (unsigned long )((void *)0)) {
#line 899
    if ((unsigned long )p > (unsigned long )addr) {
#line 900
      p --;
    }
#line 901
    *delimptr = p;
  }
#line 903
  if ((int )tTdvect[22] >= 12) {
    {
#line 905
    sm_dprintf((char *)"prescan==>");
#line 906
    tmp___11 = sm_debug_file();
#line 906
    printav(tmp___11, av);
    }
  }
#line 908
  CurEnv->e_to = saveto;
#line 909
  if ((unsigned long )av[0] == (unsigned long )((void *)0)) {
#line 911
    if ((int )tTdvect[22] >= 1) {
      {
#line 912
      sm_dprintf((char *)"prescan: null leading token\n");
      }
    }
#line 913
    return ((char **)((void *)0));
  }
#line 915
  return (av);
}
}
#line 1341 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static size_t pvpb1_size  =    (size_t )0;
#line 1342 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static char **pvpb1  =    (char **)((void *)0);
#line 961 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
int rewrite(char **pvp , int ruleset , int reclevel , ENVELOPE *e , int maxatom ) 
{ 
  register char *ap ;
  register char *rp ;
  register char *rulename ;
  register char *prefix ;
  register char **avp ;
  register char **rvp ;
  register struct match *mlp ;
  register struct rewrite *rwr ;
  int ruleno ;
  int rstat ;
  int loopcount ;
  struct match mlist[9] ;
  char *npvp[1001] ;
  char buf___16[2048] ;
  char name[6] ;
  SM_FILE_T *tmp ;
  int tmp___0 ;
  int status ;
  SM_FILE_T *tmp___1 ;
  SM_FILE_T *tmp___2 ;
  SM_FILE_T *tmp___3 ;
  SM_FILE_T *tmp___4 ;
  char **tmp___5 ;
  SM_FILE_T *tmp___6 ;
  SM_FILE_T *tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  char **tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  char **tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  SM_FILE_T *tmp___18 ;
  SM_FILE_T *tmp___19 ;
  char **tmp___20 ;
  SM_FILE_T *tmp___21 ;
  register struct match *m ;
  register char **pp ;
  char **tmp___22 ;
  char **tmp___23 ;
  char **tmp___24 ;
  char **tmp___25 ;
  char *mval ;
  char *tmp___26 ;
  char **xpvp ;
  size_t trsize ;
  char pvpbuf[1256] ;
  char const   *tmp___27 ;
  char *tmp___28 ;
  void *tmp___29 ;
  char **tmp___30 ;
  char **tmp___31 ;
  char **hbrvp ;
  char **xpvp___0 ;
  size_t trsize___0 ;
  char *replac ;
  int endtoken ;
  STAB *map___0 ;
  char *mapname ;
  char **key_rvp ;
  char **arg_rvp ;
  char **default_rvp ;
  char cbuf[257] ;
  char *pvpb1___0[1001] ;
  char *argvect[10] ;
  char pvpbuf___0[1256] ;
  char *nullpvp[1] ;
  int nodetype ;
  char **tmp___32 ;
  size_t tmp___33 ;
  char **tmp___34 ;
  int tmp___35 ;
  char **tmp___36 ;
  char **tmp___37 ;
  char *tmp___38 ;
  char **tmp___39 ;
  char **tmp___40 ;
  SM_FILE_T *tmp___41 ;
  SM_FILE_T *tmp___42 ;
  void *__cil_tmp88 ;
  int __cil_tmp89 ;
  void *__cil_tmp90 ;
  void *__cil_tmp91 ;
  void *__cil_tmp92 ;
  void *__cil_tmp93 ;
  void *__cil_tmp94 ;
  void *__cil_tmp95 ;
  void *__cil_tmp96 ;
  void *__cil_tmp97 ;
  void *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;

  {
#line 978
  rstat = 0;
#line 990
  if (ruleset < 0) {
    {
#line 992
    syserr("554 5.3.5 rewrite: illegal ruleset number %d", ruleset);
    }
#line 993
    return (78);
  } else
#line 990
  if (ruleset >= 200) {
    {
#line 992
    syserr("554 5.3.5 rewrite: illegal ruleset number %d", ruleset);
    }
#line 993
    return (78);
  }
#line 995
  rulename = RuleSetNames[ruleset];
#line 996
  if ((unsigned long )rulename == (unsigned long )((void *)0)) {
    {
#line 998
    sm_snprintf(name, (size_t )sizeof(name), "%d", ruleset);
#line 999
    rulename = name;
    }
  }
#line 1001
  if ((int )OpMode == 116) {
#line 1002
    prefix = (char *)"";
  } else {
#line 1004
    prefix = (char *)"rewrite: ruleset ";
  }
#line 1005
  if ((int )OpMode == 116) {
    {
#line 1007
    sm_io_fprintf(& SmIoF[1], -2, "%s%-16.16s   input:", prefix, rulename);
#line 1009
    printav(& SmIoF[1], pvp);
    }
  } else
#line 1011
  if ((int )tTdvect[21] >= 1) {
    {
#line 1013
    sm_dprintf((char *)"%s%-16.16s   input:", prefix, rulename);
#line 1014
    tmp = sm_debug_file();
#line 1014
    printav(tmp, pvp);
    }
  }
#line 1016
  tmp___0 = reclevel;
#line 1016
  reclevel ++;
#line 1016
  if (tmp___0 > MaxRuleRecursion) {
    {
#line 1018
    syserr("rewrite: excessive recursion (max %d), ruleset %s", MaxRuleRecursion,
           rulename);
    }
#line 1020
    return (78);
  }
#line 1022
  if ((unsigned long )pvp == (unsigned long )((void *)0)) {
#line 1023
    return (64);
  }
#line 1024
  if (maxatom <= 0) {
#line 1025
    return (64);
  }
#line 1032
  ruleno = 1;
#line 1033
  loopcount = 0;
#line 1034
  rwr = RewriteRules[ruleset];
  {
#line 1034
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1034
    if (! ((unsigned long )rwr != (unsigned long )((void *)0))) {
#line 1034
      goto while_break;
    }
#line 1039
    if ((unsigned long )*(pvp + 0) != (unsigned long )((void *)0)) {
#line 1039
      if (((int )*(*(pvp + 0) + 0) & 255) == 150) {
#line 1040
        goto while_break;
      }
    }
#line 1042
    if ((int )tTdvect[21] >= 12) {
#line 1044
      if ((int )tTdvect[21] >= 15) {
        {
#line 1045
        sm_dprintf((char *)"-----trying rule (line %d):", rwr->r_line);
        }
      } else {
        {
#line 1048
        sm_dprintf((char *)"-----trying rule:");
        }
      }
      {
#line 1049
      tmp___1 = sm_debug_file();
#line 1049
      printav(tmp___1, rwr->r_lhs);
      }
    }
#line 1053
    mlp = mlist;
#line 1054
    rvp = rwr->r_lhs;
#line 1055
    avp = pvp;
#line 1056
    loopcount ++;
#line 1056
    if (loopcount > 100) {
      {
#line 1058
      syserr("554 5.3.5 Infinite loop in ruleset %s, rule %d", rulename, ruleno);
      }
#line 1060
      if ((int )tTdvect[21] >= 1) {
        {
#line 1062
        sm_dprintf((char *)"workspace: ");
#line 1063
        tmp___2 = sm_debug_file();
#line 1063
        printav(tmp___2, pvp);
        }
      }
#line 1065
      goto while_break;
    }
    {
#line 1068
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1068
      ap = *avp;
#line 1068
      if (! ((unsigned long )ap != (unsigned long )((void *)0))) {
#line 1068
        if (! ((unsigned long )*rvp != (unsigned long )((void *)0))) {
#line 1068
          goto while_break___0;
        }
      }
#line 1070
      rp = *rvp;
#line 1071
      if ((int )tTdvect[21] >= 35) {
        {
#line 1073
        sm_dprintf((char *)"ADVANCE rp=");
#line 1074
        tmp___3 = sm_debug_file();
#line 1074
        xputs(tmp___3, (char const   *)rp);
#line 1075
        sm_dprintf((char *)", ap=");
#line 1076
        tmp___4 = sm_debug_file();
#line 1076
        xputs(tmp___4, (char const   *)ap);
#line 1077
        sm_dprintf((char *)"\n");
        }
      }
#line 1079
      if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 1082
        goto backup;
      }
#line 1084
      if ((unsigned long )ap == (unsigned long )((void *)0)) {
#line 1084
        if (((int )*rp & 255) != 144) {
#line 1084
          if (((int )*rp & 255) != 151) {
#line 1088
            goto backup;
          }
        }
      }
      {
#line 1093
      if (((int )*rp & 255) == 147) {
#line 1093
        goto case_147;
      }
#line 1121
      if (((int )*rp & 255) == 148) {
#line 1121
        goto case_148;
      }
#line 1129
      if (((int )*rp & 255) == 145) {
#line 1129
        goto case_145;
      }
#line 1129
      if (((int )*rp & 255) == 146) {
#line 1129
        goto case_145;
      }
#line 1137
      if (((int )*rp & 255) == 144) {
#line 1137
        goto case_144;
      }
#line 1145
      if (((int )*rp & 255) == 151) {
#line 1145
        goto case_151;
      }
#line 1149
      if (((int )*rp & 255) == 130) {
#line 1149
        goto case_130;
      }
#line 1183
      goto switch_default;
      case_147: /* CIL Label */ 
#line 1095
      mlp->match_pattern = rvp;
#line 1096
      mlp->match_first = avp;
      extendclass: 
#line 1098
      ap = *avp;
#line 1099
      if ((unsigned long )ap == (unsigned long )((void *)0)) {
#line 1100
        goto backup;
      }
      {
#line 1101
      tmp___5 = avp;
#line 1101
      avp ++;
#line 1101
      mlp->match_last = tmp___5;
#line 1102
      cataddr(mlp->match_first, mlp->match_last, buf___16, (int )sizeof(buf___16),
              '\000');
#line 1104
      tmp___8 = wordinclass(buf___16, (int )*(rp + 1));
      }
#line 1104
      if (! tmp___8) {
#line 1106
        if ((int )tTdvect[21] >= 36) {
          {
#line 1108
          sm_dprintf((char *)"EXTEND  rp=");
#line 1109
          tmp___6 = sm_debug_file();
#line 1109
          xputs(tmp___6, (char const   *)rp);
#line 1110
          sm_dprintf((char *)", ap=");
#line 1111
          tmp___7 = sm_debug_file();
#line 1111
          xputs(tmp___7, (char const   *)ap);
#line 1112
          sm_dprintf((char *)"\n");
          }
        }
#line 1114
        goto extendclass;
      }
#line 1116
      if ((int )tTdvect[21] >= 36) {
        {
#line 1117
        sm_dprintf((char *)"CLMATCH\n");
        }
      }
#line 1118
      mlp ++;
#line 1119
      goto switch_break;
      case_148: /* CIL Label */ 
      {
#line 1123
      tmp___9 = wordinclass(ap, (int )*(rp + 1));
      }
#line 1123
      if (tmp___9) {
#line 1124
        goto backup;
      }
      case_145: /* CIL Label */ 
      case_146: /* CIL Label */ 
#line 1131
      mlp->match_pattern = rvp;
#line 1132
      mlp->match_first = avp;
#line 1133
      tmp___10 = avp;
#line 1133
      avp ++;
#line 1133
      mlp->match_last = tmp___10;
#line 1134
      mlp ++;
#line 1135
      goto switch_break;
      case_144: /* CIL Label */ 
#line 1139
      mlp->match_pattern = rvp;
#line 1140
      mlp->match_first = avp;
#line 1141
      mlp->match_last = avp - 1;
#line 1142
      mlp ++;
#line 1143
      goto switch_break;
      case_151: /* CIL Label */ 
#line 1147
      goto switch_break;
      case_130: /* CIL Label */ 
      {
#line 1158
      ap = macvalue((int )*(rp + 1), e);
#line 1159
      mlp->match_first = avp;
      }
#line 1160
      if ((int )tTdvect[21] >= 2) {
#line 1161
        if ((unsigned long )ap == (unsigned long )((void *)0)) {
#line 1161
          tmp___11 = "(NULL)";
        } else {
#line 1161
          tmp___11 = (char const   *)ap;
        }
        {
#line 1161
        tmp___12 = macname((int )*(rp + 1));
#line 1161
        sm_dprintf((char *)"rewrite: LHS $&{%s} => \"%s\"\n", tmp___12, tmp___11);
        }
      }
#line 1165
      if ((unsigned long )ap == (unsigned long )((void *)0)) {
#line 1166
        goto switch_break;
      }
      {
#line 1167
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1167
        if (! ((int )*ap != 0)) {
#line 1167
          goto while_break___1;
        }
#line 1169
        if ((unsigned long )*avp == (unsigned long )((void *)0)) {
#line 1174
          avp = mlp->match_first;
#line 1175
          goto backup;
        } else {
          {
#line 1169
          tmp___13 = strlen((char const   *)*avp);
#line 1169
          tmp___14 = sm_strncasecmp((char const   *)ap, (char const   *)*avp, tmp___13);
          }
#line 1169
          if (tmp___14 != 0) {
#line 1174
            avp = mlp->match_first;
#line 1175
            goto backup;
          }
        }
        {
#line 1177
        tmp___15 = avp;
#line 1177
        avp ++;
#line 1177
        tmp___16 = strlen((char const   *)*tmp___15);
#line 1177
        ap += tmp___16;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1181
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1185
      tmp___17 = sm_strcasecmp((char const   *)rp, (char const   *)ap);
      }
#line 1185
      if (tmp___17) {
#line 1186
        goto backup;
      }
#line 1187
      avp ++;
#line 1188
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1192
      rvp ++;
#line 1193
      goto while_continue___0;
      backup: 
      {
#line 1197
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1197
        mlp --;
#line 1197
        if (! ((unsigned long )mlp >= (unsigned long )(mlist))) {
#line 1197
          goto while_break___2;
        }
#line 1199
        rvp = mlp->match_pattern;
#line 1200
        rp = *rvp;
#line 1201
        avp = mlp->match_last + 1;
#line 1202
        ap = *avp;
#line 1204
        if ((int )tTdvect[21] >= 36) {
          {
#line 1206
          sm_dprintf((char *)"BACKUP  rp=");
#line 1207
          tmp___18 = sm_debug_file();
#line 1207
          xputs(tmp___18, (char const   *)rp);
#line 1208
          sm_dprintf((char *)", ap=");
#line 1209
          tmp___19 = sm_debug_file();
#line 1209
          xputs(tmp___19, (char const   *)ap);
#line 1210
          sm_dprintf((char *)"\n");
          }
        }
#line 1213
        if ((unsigned long )ap == (unsigned long )((void *)0)) {
#line 1216
          goto while_continue___2;
        }
#line 1218
        if (((int )*rp & 255) == 145) {
#line 1218
          goto _L;
        } else
#line 1218
        if (((int )*rp & 255) == 144) {
          _L: /* CIL Label */ 
#line 1222
          tmp___20 = avp;
#line 1222
          avp ++;
#line 1222
          mlp->match_last = tmp___20;
#line 1223
          rvp ++;
#line 1224
          mlp ++;
#line 1225
          goto while_break___2;
        }
#line 1227
        if (((int )*rp & 255) == 147) {
#line 1230
          mlp->match_last = avp;
#line 1231
          goto extendclass;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1235
      if ((unsigned long )mlp < (unsigned long )(mlist)) {
#line 1238
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1246
    if ((unsigned long )mlp < (unsigned long )(mlist)) {
#line 1246
      goto _L___0;
    } else
#line 1246
    if ((unsigned long )*rvp != (unsigned long )((void *)0)) {
      _L___0: /* CIL Label */ 
#line 1248
      if ((int )tTdvect[21] >= 10) {
        {
#line 1249
        sm_dprintf((char *)"----- rule fails\n");
        }
      }
#line 1250
      rwr = rwr->r_next;
#line 1251
      ruleno ++;
#line 1252
      loopcount = 0;
#line 1253
      goto __Cont;
    }
#line 1256
    rvp = rwr->r_rhs;
#line 1257
    if ((int )tTdvect[21] >= 12) {
      {
#line 1259
      sm_dprintf((char *)"-----rule matches:");
#line 1260
      tmp___21 = sm_debug_file();
#line 1260
      printav(tmp___21, rvp);
      }
    }
#line 1263
    rp = *rvp;
#line 1264
    if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 1266
      if (((int )*rp & 255) == 152) {
#line 1268
        rvp ++;
#line 1269
        rwr = rwr->r_next;
#line 1270
        ruleno ++;
#line 1271
        loopcount = 0;
      } else
#line 1273
      if (((int )*rp & 255) == 151) {
#line 1275
        rvp ++;
#line 1276
        rwr = (struct rewrite *)((void *)0);
      }
    }
#line 1281
    avp = npvp;
    {
#line 1281
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1281
      if (! ((unsigned long )*rvp != (unsigned long )((void *)0))) {
#line 1281
        goto while_break___3;
      }
#line 1286
      rp = *rvp;
#line 1287
      if (((int )*rp & 255) == 149) {
#line 1290
        m = & mlist[(int )*(rp + 1) - 49];
#line 1291
        if ((unsigned long )m < (unsigned long )(mlist)) {
          {
#line 1293
          syserr("554 5.3.5 rewrite: ruleset %s: replacement $%c out of bounds", rulename,
                 (int )*(rp + 1));
          }
#line 1295
          return (78);
        } else
#line 1291
        if ((unsigned long )m >= (unsigned long )mlp) {
          {
#line 1293
          syserr("554 5.3.5 rewrite: ruleset %s: replacement $%c out of bounds", rulename,
                 (int )*(rp + 1));
          }
#line 1295
          return (78);
        }
#line 1297
        if ((int )tTdvect[21] >= 15) {
          {
#line 1299
          sm_dprintf((char *)"$%c:", (int )*(rp + 1));
#line 1300
          pp = m->match_first;
          }
          {
#line 1301
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1301
            if (! ((unsigned long )pp <= (unsigned long )m->match_last)) {
#line 1301
              goto while_break___4;
            }
            {
#line 1303
            sm_dprintf((char *)" %p=\"", *pp);
#line 1304
            sm_dflush();
#line 1305
            tmp___22 = pp;
#line 1305
            pp ++;
#line 1305
            sm_dprintf((char *)"%s\"", *tmp___22);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 1307
          sm_dprintf((char *)"\n");
          }
        }
#line 1309
        pp = m->match_first;
        {
#line 1310
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1310
          if (! ((unsigned long )pp <= (unsigned long )m->match_last)) {
#line 1310
            goto while_break___5;
          }
#line 1312
          if ((unsigned long )avp >= (unsigned long )(& npvp[maxatom])) {
#line 1313
            goto toolong;
          }
#line 1314
          tmp___23 = avp;
#line 1314
          avp ++;
#line 1314
          tmp___24 = pp;
#line 1314
          pp ++;
#line 1314
          *tmp___23 = *tmp___24;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
#line 1320
        if ((unsigned long )avp >= (unsigned long )(& npvp[maxatom])) {
          toolong: 
          {
#line 1323
          syserr("554 5.3.0 rewrite: expansion too long");
          }
#line 1324
          if (LogLevel > 9) {
            {
#line 1325
            sm_syslog(3, (char const   *)e->e_id, "rewrite: expansion too long, ruleset=%s, ruleno=%d",
                      rulename, ruleno);
            }
          }
#line 1328
          return (65);
        }
#line 1330
        if (((int )*rp & 255) != 130) {
#line 1333
          tmp___25 = avp;
#line 1333
          avp ++;
#line 1333
          *tmp___25 = rp;
        } else {
          {
#line 1338
          tmp___26 = macvalue((int )*(rp + 1), e);
#line 1338
          mval = tmp___26;
#line 1340
          trsize = (size_t )0;
          }
#line 1345
          if ((int )tTdvect[21] >= 2) {
#line 1346
            if ((unsigned long )mval == (unsigned long )((void *)0)) {
#line 1346
              tmp___27 = "(NULL)";
            } else {
#line 1346
              tmp___27 = (char const   *)mval;
            }
            {
#line 1346
            tmp___28 = macname((int )*(rp + 1));
#line 1346
            sm_dprintf((char *)"rewrite: RHS $&{%s} => \"%s\"\n", tmp___28, tmp___27);
            }
          }
#line 1349
          if ((unsigned long )mval == (unsigned long )((void *)0)) {
#line 1350
            goto __Cont___0;
          } else
#line 1349
          if ((int )*mval == 0) {
#line 1350
            goto __Cont___0;
          }
#line 1353
          xpvp = pvp;
          {
#line 1353
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1353
            if (! ((unsigned long )*xpvp != (unsigned long )((void *)0))) {
#line 1353
              goto while_break___6;
            }
#line 1354
            trsize = (size_t )((unsigned long )trsize + sizeof(*xpvp));
#line 1353
            xpvp ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1355
          if (trsize > pvpb1_size) {
#line 1357
            if ((unsigned long )pvpb1 != (unsigned long )((void *)0)) {
              {
#line 1358
              sm_free_tagged((void *)pvpb1, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                             1358);
              }
            }
            {
#line 1359
            tmp___29 = sm_malloc_tagged_x(trsize, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                                          1360, 0);
#line 1359
            pvpb1 = (char **)tmp___29;
#line 1361
            pvpb1_size = trsize;
            }
          }
          {
#line 1364
          memmove((void *)((char *)pvpb1), (void const   *)((char *)pvp), trsize);
#line 1369
          xpvp = prescan(mval, '\000', pvpbuf, (int )sizeof(pvpbuf), (char **)((void *)0),
                         (unsigned char *)((void *)0), 0);
          }
#line 1372
          if ((unsigned long )xpvp == (unsigned long )((void *)0)) {
#line 1375
            return (65);
          }
          {
#line 1379
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1379
            if (! ((unsigned long )*xpvp != (unsigned long )((void *)0))) {
#line 1379
              goto while_break___7;
            }
#line 1381
            if ((int )tTdvect[21] >= 19) {
              {
#line 1382
              sm_dprintf((char *)" ... %s\n", *xpvp);
              }
            }
            {
#line 1384
            tmp___30 = avp;
#line 1384
            avp ++;
#line 1384
            *tmp___30 = sm_rpool_strdup_x(e->e_rpool, (char const   *)*xpvp);
            }
#line 1386
            if ((unsigned long )avp >= (unsigned long )(& npvp[maxatom])) {
#line 1387
              goto toolong;
            }
#line 1388
            xpvp ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1390
          if ((int )tTdvect[21] >= 19) {
            {
#line 1391
            sm_dprintf((char *)" ... DONE\n");
            }
          }
          {
#line 1394
          memmove((void *)((char *)pvp), (void const   *)((char *)pvpb1), trsize);
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 1281
      rvp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1400
    tmp___31 = avp;
#line 1400
    avp ++;
#line 1400
    *tmp___31 = (char *)((void *)0);
#line 1406
    rvp = npvp;
    {
#line 1406
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1406
      if (! ((unsigned long )*rvp != (unsigned long )((void *)0))) {
#line 1406
        goto while_break___8;
      }
#line 1424
      if (((int )*(*rvp) & 255) != 157) {
#line 1424
        if (((int )*(*rvp) & 255) != 133) {
#line 1426
          goto __Cont___1;
        }
      }
#line 1434
      hbrvp = rvp;
#line 1435
      if (((int )*(*rvp) & 255) == 157) {
#line 1437
        endtoken = 158;
#line 1438
        mapname = (char *)"host";
      } else {
#line 1442
        endtoken = 134;
#line 1443
        rvp ++;
#line 1443
        mapname = *rvp;
#line 1444
        if ((unsigned long )mapname == (unsigned long )((void *)0)) {
          {
#line 1445
          syserr("554 5.3.0 rewrite: missing mapname");
          }
        }
      }
      {
#line 1447
      map___0 = stab(mapname, 6, 0);
      }
#line 1448
      if ((unsigned long )map___0 == (unsigned long )((void *)0)) {
        {
#line 1449
        syserr("554 5.3.0 rewrite: map %s not found", mapname);
        }
      }
#line 1453
      rvp ++;
#line 1453
      key_rvp = rvp;
#line 1454
      if ((unsigned long )key_rvp == (unsigned long )((void *)0)) {
        {
#line 1455
        syserr("554 5.3.0 rewrite: missing key for map %s", mapname);
        }
      }
#line 1457
      default_rvp = (char **)((void *)0);
#line 1458
      arg_rvp = argvect;
#line 1459
      xpvp___0 = (char **)((void *)0);
#line 1460
      replac = pvpbuf___0;
      {
#line 1461
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1461
        if ((unsigned long )*rvp != (unsigned long )((void *)0)) {
#line 1461
          if (! (((int )*(*rvp) & 255) != endtoken)) {
#line 1461
            goto while_break___9;
          }
        } else {
#line 1461
          goto while_break___9;
        }
#line 1463
        nodetype = (int )*(*rvp) & 255;
#line 1465
        if (nodetype != 151) {
#line 1465
          if (nodetype != 152) {
#line 1468
            rvp ++;
#line 1469
            goto while_continue___9;
          }
        }
#line 1472
        tmp___32 = rvp;
#line 1472
        rvp ++;
#line 1472
        *tmp___32 = (char *)((void *)0);
#line 1474
        if ((unsigned long )xpvp___0 != (unsigned long )((void *)0)) {
          {
#line 1476
          cataddr(xpvp___0, (char **)((void *)0), replac, (int )(& pvpbuf___0[sizeof(pvpbuf___0)] - replac),
                  '\000');
          }
#line 1479
          if ((unsigned long )arg_rvp < (unsigned long )(& argvect[9])) {
#line 1481
            arg_rvp ++;
#line 1481
            *arg_rvp = replac;
          }
          {
#line 1482
          tmp___33 = strlen((char const   *)replac);
#line 1482
          replac += tmp___33 + 1U;
#line 1483
          xpvp___0 = (char **)((void *)0);
          }
        }
        {
#line 1487
        if (nodetype == 151) {
#line 1487
          goto case_151___0;
        }
#line 1491
        if (nodetype == 152) {
#line 1491
          goto case_152;
        }
#line 1485
        goto switch_break___0;
        case_151___0: /* CIL Label */ 
#line 1488
        xpvp___0 = rvp;
#line 1489
        goto switch_break___0;
        case_152: /* CIL Label */ 
#line 1492
        default_rvp = rvp;
#line 1493
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1496
      if ((unsigned long )*rvp != (unsigned long )((void *)0)) {
#line 1497
        tmp___34 = rvp;
#line 1497
        rvp ++;
#line 1497
        *tmp___34 = (char *)((void *)0);
      }
#line 1498
      if ((unsigned long )xpvp___0 != (unsigned long )((void *)0)) {
        {
#line 1500
        cataddr(xpvp___0, (char **)((void *)0), replac, (int )(& pvpbuf___0[sizeof(pvpbuf___0)] - replac),
                '\000');
        }
#line 1503
        if ((unsigned long )arg_rvp < (unsigned long )(& argvect[9])) {
#line 1504
          arg_rvp ++;
#line 1504
          *arg_rvp = replac;
        }
      }
#line 1506
      if ((unsigned long )arg_rvp >= (unsigned long )(& argvect[9])) {
#line 1507
        argvect[9] = (char *)((void *)0);
      } else {
#line 1509
        arg_rvp ++;
#line 1509
        *arg_rvp = (char *)((void *)0);
      }
      {
#line 1512
      trsize___0 = (size_t )((unsigned long )((avp - rvp) + 1L) * sizeof(*rvp));
#line 1513
      memmove((void *)((char *)(pvpb1___0)), (void const   *)((char *)rvp), trsize___0);
      }
#line 1516
      if ((unsigned long )map___0 == (unsigned long )((void *)0)) {
#line 1516
        tmp___35 = '\000';
      } else {
#line 1516
        tmp___35 = (int )map___0->s_value.sv_map.map_spacesub;
      }
      {
#line 1516
      cataddr(key_rvp, (char **)((void *)0), cbuf, (int )sizeof(cbuf), tmp___35);
#line 1518
      argvect[0] = cbuf;
#line 1519
      replac = map_lookup(map___0, cbuf, argvect, & rstat, e);
      }
#line 1522
      if ((unsigned long )replac == (unsigned long )((void *)0)) {
#line 1522
        if ((unsigned long )default_rvp != (unsigned long )((void *)0)) {
          {
#line 1525
          cataddr(default_rvp, (char **)((void *)0), cbuf, (int )sizeof(cbuf), '\000');
#line 1526
          replac = cbuf;
          }
        }
      }
#line 1529
      if ((unsigned long )replac == (unsigned long )((void *)0)) {
#line 1531
        xpvp___0 = key_rvp;
      } else
#line 1533
      if ((int )*replac == 0) {
#line 1536
        nullpvp[0] = (char *)((void *)0);
#line 1537
        xpvp___0 = nullpvp;
      } else {
        {
#line 1542
        xpvp___0 = prescan(replac, '\000', pvpbuf___0, (int )sizeof(pvpbuf___0), (char **)((void *)0),
                           (unsigned char *)((void *)0), 0);
        }
#line 1544
        if ((unsigned long )xpvp___0 == (unsigned long )((void *)0)) {
#line 1547
          return (65);
        }
      }
#line 1552
      avp = hbrvp;
      {
#line 1552
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1552
        if (! ((unsigned long )*xpvp___0 != (unsigned long )((void *)0))) {
#line 1552
          goto while_break___10;
        }
        {
#line 1554
        tmp___36 = avp;
#line 1554
        avp ++;
#line 1554
        *tmp___36 = sm_rpool_strdup_x(e->e_rpool, (char const   *)*xpvp___0);
        }
#line 1555
        if ((unsigned long )avp >= (unsigned long )(& npvp[maxatom])) {
#line 1556
          goto toolong;
        }
#line 1552
        xpvp___0 ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1560
      rvp = avp - 1;
#line 1561
      xpvp___0 = pvpb1___0;
      {
#line 1561
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1561
        tmp___37 = avp;
#line 1561
        avp ++;
#line 1561
        tmp___39 = xpvp___0;
#line 1561
        xpvp___0 ++;
#line 1561
        tmp___38 = *tmp___39;
#line 1561
        *tmp___37 = tmp___38;
#line 1561
        if (! ((unsigned long )tmp___38 != (unsigned long )((void *)0))) {
#line 1561
          goto while_break___11;
        }
#line 1562
        if ((unsigned long )avp >= (unsigned long )(& npvp[maxatom])) {
#line 1563
          goto toolong;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      __Cont___1: /* CIL Label */ 
#line 1406
      rvp ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1570
    status = callsubr(npvp, reclevel, e);
    }
#line 1571
    if (rstat == 0) {
#line 1572
      rstat = status;
    } else
#line 1571
    if (status == 75) {
#line 1572
      rstat = status;
    }
#line 1575
    avp = npvp;
    {
#line 1575
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1575
      tmp___40 = avp;
#line 1575
      avp ++;
#line 1575
      if (! ((unsigned long )*tmp___40 != (unsigned long )((void *)0))) {
#line 1575
        goto while_break___12;
      }
#line 1576
      goto __Cont___2;
      __Cont___2: /* CIL Label */ ;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 1577
    memmove((void *)((char *)pvp), (void const   *)((char *)(npvp)), (size_t )((unsigned long )((int )(avp - npvp)) * sizeof(*avp)));
    }
#line 1580
    if ((int )tTdvect[21] >= 4) {
      {
#line 1582
      sm_dprintf((char *)"rewritten as:");
#line 1583
      tmp___41 = sm_debug_file();
#line 1583
      printav(tmp___41, pvp);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1587
  if ((int )OpMode == 116) {
    {
#line 1589
    sm_io_fprintf(& SmIoF[1], -2, "%s%-16.16s returns:", prefix, rulename);
#line 1591
    printav(& SmIoF[1], pvp);
    }
  } else
#line 1593
  if ((int )tTdvect[21] >= 1) {
    {
#line 1595
    sm_dprintf((char *)"%s%-16.16s returns:", prefix, rulename);
#line 1596
    tmp___42 = sm_debug_file();
#line 1596
    printav(tmp___42, pvp);
    }
  }
#line 1598
  return (rstat);
}
}
#line 1615 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static int callsubr(char **pvp , int reclevel , ENVELOPE *e ) 
{ 
  char **avp ;
  register int i ;
  int subr ;
  int j ;
  int nsubr ;
  int status ;
  int rstat ;
  int subrnumber[16] ;
  int subrindex[16] ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1626
  rstat = 0;
#line 1631
  nsubr = 0;
#line 1640
  avp = pvp;
#line 1640
  j = 0;
  {
#line 1640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1640
    if (! ((unsigned long )*avp != (unsigned long )((void *)0))) {
#line 1640
      goto while_break;
    }
#line 1642
    if (((int )*(*avp) & 255) == 153) {
#line 1642
      if ((unsigned long )*(avp + 1) != (unsigned long )((void *)0)) {
        {
#line 1644
        stripquotes(*(avp + 1));
#line 1645
        subr = strtorwset(*(avp + 1), (char **)((void *)0), 0);
        }
#line 1646
        if (subr < 0) {
          {
#line 1648
          syserr("554 5.3.5 Unknown ruleset %s", *(avp + 1));
          }
#line 1649
          return (78);
        }
#line 1659
        if ((unsigned long )RewriteRules[subr] == (unsigned long )((void *)0)) {
#line 1661
          if ((int )tTdvect[21] >= 3) {
            {
#line 1662
            sm_dprintf((char *)"-----skip subr %s (%d)\n", *(avp + 1), subr);
            }
          }
#line 1664
          i = 2;
          {
#line 1664
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1664
            if (! ((unsigned long )*(avp + i) != (unsigned long )((void *)0))) {
#line 1664
              goto while_break___0;
            }
#line 1665
            *(avp + (i - 2)) = *(avp + i);
#line 1664
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1666
          *(avp + (i - 2)) = (char *)((void *)0);
#line 1667
          goto __Cont;
        }
#line 1669
        nsubr ++;
#line 1669
        if (nsubr >= 16) {
          {
#line 1671
          syserr("554 5.3.0 Too many subroutine calls (%d max)", 16);
          }
#line 1673
          return (78);
        }
#line 1675
        subrnumber[nsubr] = subr;
#line 1676
        subrindex[nsubr] = j;
      }
    }
    __Cont: /* CIL Label */ 
#line 1640
    avp ++;
#line 1640
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1686
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1686
    if (! (nsubr > 0)) {
#line 1686
      goto while_break___1;
    }
#line 1688
    subr = subrnumber[nsubr];
#line 1689
    avp = pvp + subrindex[nsubr];
#line 1692
    i = 2;
    {
#line 1692
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1692
      if (! ((unsigned long )*(avp + i) != (unsigned long )((void *)0))) {
#line 1692
        goto while_break___2;
      }
#line 1693
      *(avp + (i - 2)) = *(avp + i);
#line 1692
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1694
    *(avp + (i - 2)) = (char *)((void *)0);
#line 1702
    status = rewrite(avp, subr, reclevel, e, 1000 - subrindex[nsubr]);
    }
#line 1704
    if (status != 0) {
#line 1704
      if (status != 75) {
#line 1705
        return (status);
      }
    }
#line 1706
    if (rstat == 0) {
#line 1707
      rstat = status;
    } else
#line 1706
    if (status == 75) {
#line 1707
      rstat = status;
    }
#line 1686
    nsubr --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1709
  return (rstat);
}
}
#line 1798 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static char *rwbuf  =    (char *)((void *)0);
#line 1799 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static size_t rwbuflen  =    (size_t )0;
#line 1727 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static char *map_lookup(STAB *smap , char *key , char **argvect , int *pstat , ENVELOPE *e ) 
{ 
  int status ;
  struct _map *map___0 ;
  char *replac ;
  bool tmp ;
  int i ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char mbuf___0[320] ;
  char *tmp___2 ;
  size_t i___0 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 1735
  status = 0;
#line 1739
  if ((unsigned long )smap == (unsigned long )((void *)0)) {
#line 1740
    return ((char *)((void *)0));
  }
#line 1742
  map___0 = & smap->s_value.sv_map;
#line 1743
  if (! ((map___0->map_mflags & 32L) != 0L)) {
    {
#line 1743
    tmp = openmap(map___0);
    }
#line 1743
    if (! tmp) {
#line 1743
      return ((char *)((void *)0));
    }
  }
#line 1745
  if ((int )e->e_sendmode == 100) {
#line 1745
    if ((map___0->map_mflags & 524288L) != 0L) {
#line 1749
      if ((int )tTdvect[60] >= 1) {
        {
#line 1750
        sm_dprintf((char *)"map_lookup(%s, %s) => DEFERRED\n", smap->s_name, key);
        }
      }
#line 1752
      *pstat = 75;
#line 1753
      return ((char *)((void *)0));
    }
  }
#line 1756
  if (! ((map___0->map_mflags & 65536L) != 0L)) {
    {
#line 1757
    stripquotes(key);
    }
  }
#line 1759
  if ((int )tTdvect[60] >= 1) {
    {
#line 1761
    sm_dprintf((char *)"map_lookup(%s, %s", smap->s_name, key);
    }
#line 1762
    if ((int )tTdvect[60] >= 5) {
#line 1766
      i = 0;
      {
#line 1766
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1766
        if (! ((unsigned long )*(argvect + i) != (unsigned long )((void *)0))) {
#line 1766
          goto while_break;
        }
        {
#line 1767
        sm_dprintf((char *)", %%%d=%s", i, *(argvect + i));
#line 1766
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1769
    sm_dprintf((char *)") => ");
    }
  }
  {
#line 1771
  replac = (*((map___0->map_class)->map_lookup))(map___0, key, argvect, & status);
  }
#line 1772
  if ((int )tTdvect[60] >= 1) {
#line 1773
    if ((unsigned long )replac != (unsigned long )((void *)0)) {
#line 1773
      tmp___0 = (char const   *)replac;
    } else {
#line 1773
      tmp___0 = "NOT FOUND";
    }
    {
#line 1773
    sm_dprintf((char *)"%s (%d)\n", tmp___0, status);
    }
  }
#line 1778
  if (status == 75) {
#line 1778
    if (! ((map___0->map_mflags & 131072L) != 0L)) {
#line 1780
      *pstat = 75;
#line 1781
      if ((int )tTdvect[60] >= 1) {
        {
#line 1782
        tmp___1 = __errno_location();
#line 1782
        sm_dprintf((char *)"map_lookup(%s, %s) tempfail: errno=%d\n", smap->s_name,
                   key, *tmp___1);
        }
      }
#line 1784
      if ((unsigned long )e->e_message == (unsigned long )((void *)0)) {
        {
#line 1788
        tmp___2 = shortenstring((char const   *)key, (size_t )203);
#line 1788
        sm_snprintf(mbuf___0, (size_t )sizeof(mbuf___0), "%.80s map: lookup (%s): deferred",
                    smap->s_name, tmp___2);
#line 1792
        e->e_message = sm_rpool_strdup_x(e->e_rpool, (char const   *)(mbuf___0));
        }
      }
    }
  }
#line 1795
  if (status == 75) {
#line 1795
    if ((unsigned long )map___0->map_tapp != (unsigned long )((void *)0)) {
      {
#line 1797
      tmp___3 = strlen((char const   *)key);
#line 1797
      tmp___4 = strlen((char const   *)map___0->map_tapp);
#line 1797
      i___0 = (tmp___3 + tmp___4) + 1U;
      }
#line 1801
      if (i___0 > rwbuflen) {
#line 1803
        if ((unsigned long )rwbuf != (unsigned long )((void *)0)) {
          {
#line 1804
          sm_free_tagged((void *)rwbuf, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                         1804);
          }
        }
        {
#line 1805
        rwbuflen = i___0;
#line 1806
        tmp___5 = sm_malloc_tagged_x(rwbuflen, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                                     1806, 0);
#line 1806
        rwbuf = (char *)tmp___5;
        }
      }
      {
#line 1808
      sm_strlcpyn(rwbuf, (ssize_t )rwbuflen, 2, key, map___0->map_tapp);
      }
#line 1809
      if ((int )tTdvect[60] >= 4) {
        {
#line 1810
        sm_dprintf((char *)"map_lookup tempfail: returning \"%s\"\n", rwbuf);
        }
      }
#line 1812
      return (rwbuf);
    }
  }
#line 1814
  return (replac);
}
}
#line 1829 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static MAILER discardmailer  ;
#line 1830 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static MAILER errormailer  ;
#line 1831 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static char *discardargv[2]  = {      (char *)"DISCARD",      (char *)((void *)0)};
#line 1832 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static char *errorargv[2]  = {      (char *)"ERROR",      (char *)((void *)0)};
#line 1834 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
void initerrmailers(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 1837
  if ((unsigned long )discardmailer.m_name == (unsigned long )((void *)0)) {
#line 1840
    discardmailer.m_name = (char *)"*discard*";
#line 1841
    discardmailer.m_mailer = (char *)"DISCARD";
#line 1842
    discardmailer.m_argv = discardargv;
  }
#line 1844
  if ((unsigned long )errormailer.m_name == (unsigned long )((void *)0)) {
#line 1847
    errormailer.m_name = (char *)"*error*";
#line 1848
    errormailer.m_mailer = (char *)"ERROR";
#line 1849
    errormailer.m_argv = errorargv;
  }
#line 1851
  return;
}
}
#line 1871 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static struct errcodes ErrorCodes[9]  = 
#line 1871
  {      {(char *)"usage", 64}, 
        {(char *)"nouser", 67}, 
        {(char *)"nohost", 68}, 
        {(char *)"unavailable", 69}, 
        {(char *)"software", 70}, 
        {(char *)"tempfail", 75}, 
        {(char *)"protocol", 76}, 
        {(char *)"config", 78}, 
        {(char *)((void *)0), 69}};
#line 1903 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static char ubuf[258]  ;
#line 1888 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static ADDRESS *buildaddr(char **tv , ADDRESS *a , int flags , ENVELOPE *e ) 
{ 
  bool tempfail ;
  int maxatom ;
  struct mailer **mp ;
  register struct mailer *m ;
  register char *p ;
  char *mname ;
  char **hostp ;
  char hbuf___0[257] ;
  SM_FILE_T *tmp ;
  void *tmp___0 ;
  register struct errcodes *ep ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char fmt[16] ;
  int off ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct mailer **tmp___10 ;
  int tmp___11 ;
  SM_FILE_T *tmp___12 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
#line 1895
  tempfail = 0;
#line 1905
  if ((int )tTdvect[24] >= 5) {
    {
#line 1907
    sm_dprintf((char *)"buildaddr, flags=%x, tv=", flags);
#line 1908
    tmp = sm_debug_file();
#line 1908
    printav(tmp, tv);
    }
  }
#line 1911
  maxatom = 1000;
#line 1912
  if ((unsigned long )a == (unsigned long )((void *)0)) {
    {
#line 1913
    tmp___0 = sm_rpool_malloc_tagged_x(e->e_rpool, (size_t )sizeof(*a), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                                       1913, SmHeapGroup);
#line 1913
    a = (ADDRESS *)tmp___0;
    }
  }
  {
#line 1914
  memset((void *)((char *)a), '\000', (size_t )sizeof(*a));
#line 1915
  hbuf___0[0] = (char )'\000';
#line 1918
  a->q_flags |= (unsigned long )DefaultNotify;
  }
#line 1921
  if ((unsigned long )*tv == (unsigned long )((void *)0)) {
#line 1921
    goto _L;
  } else
#line 1921
  if (((int )*(*tv) & 255) != 150) {
    _L: /* CIL Label */ 
    {
#line 1923
    syserr("554 5.3.5 buildaddr: no mailer in parsed address");
    }
    badaddr: 
#line 1936
    if (ExitStat == 75) {
#line 1937
      a->q_state = (short)3;
    } else
#line 1936
    if (tempfail) {
#line 1937
      a->q_state = (short)3;
    } else {
#line 1940
      a->q_state = (short)2;
#line 1941
      a->q_mailer = & errormailer;
    }
#line 1943
    return (a);
  }
#line 1945
  tv ++;
#line 1945
  mname = *tv;
#line 1946
  maxatom --;
#line 1949
  tv ++;
#line 1949
  if ((unsigned long )*tv != (unsigned long )((void *)0)) {
#line 1949
    if (((int )*(*tv) & 255) == 151) {
#line 1951
      tv ++;
#line 1951
      hostp = tv;
#line 1952
      maxatom --;
    } else {
#line 1955
      hostp = (char **)((void *)0);
    }
  } else {
#line 1955
    hostp = (char **)((void *)0);
  }
#line 1956
  maxatom --;
  {
#line 1957
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1957
    if ((unsigned long )*tv != (unsigned long )((void *)0)) {
#line 1957
      if (! (((int )*(*tv) & 255) != 152)) {
#line 1957
        goto while_break;
      }
    } else {
#line 1957
      goto while_break;
    }
#line 1959
    tv ++;
#line 1960
    maxatom --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1962
  if ((unsigned long )*tv == (unsigned long )((void *)0)) {
    {
#line 1964
    syserr("554 5.3.5 buildaddr: no user");
    }
#line 1965
    goto badaddr;
  }
#line 1967
  if ((unsigned long )tv == (unsigned long )hostp) {
#line 1968
    hostp = (char **)((void *)0);
  } else
#line 1969
  if ((unsigned long )hostp != (unsigned long )((void *)0)) {
    {
#line 1970
    cataddr(hostp, tv - 1, hbuf___0, (int )sizeof(hbuf___0), '\000');
    }
  }
  {
#line 1971
  tv ++;
#line 1971
  cataddr(tv, (char **)((void *)0), ubuf, (int )sizeof(ubuf), ' ');
#line 1972
  maxatom --;
#line 1975
  tmp___8 = sm_strcasecmp((char const   *)mname, "error");
  }
#line 1975
  if (tmp___8 == 0) {
    {
#line 1978
    a->q_mailer = & errormailer;
#line 1979
    a->q_user = sm_rpool_strdup_x(e->e_rpool, (char const   *)(ubuf));
    }
#line 1982
    if ((unsigned long )hostp != (unsigned long )((void *)0)) {
      {
#line 1986
      a->q_host = sm_rpool_strdup_x(e->e_rpool, (char const   *)(hbuf___0));
#line 1987
      tmp___3 = strchr((char const   *)(hbuf___0), '.');
      }
#line 1987
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
        {
#line 1989
        a->q_status = sm_rpool_strdup_x(e->e_rpool, (char const   *)(hbuf___0));
        }
#line 1991
        if (ExitStat == 0) {
          {
#line 1991
          ExitStat = dsntoexitstat(hbuf___0);
          }
        } else
#line 1991
        if (ExitStat == 75) {
          {
#line 1991
          ExitStat = dsntoexitstat(hbuf___0);
          }
        }
      } else
#line 1993
      if (((int )hbuf___0[0] & -128) == 0) {
        {
#line 1993
        tmp___2 = __ctype_b_loc();
        }
#line 1993
        if ((int const   )*(*tmp___2 + (int )hbuf___0[0]) & 2048) {
#line 1995
          if (ExitStat == 0) {
            {
#line 1995
            ExitStat = atoi((char const   *)(hbuf___0));
            }
          } else
#line 1995
          if (ExitStat == 75) {
            {
#line 1995
            ExitStat = atoi((char const   *)(hbuf___0));
            }
          }
        } else {
#line 1993
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 1999
        ep = ErrorCodes;
        {
#line 1999
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1999
          if (! ((unsigned long )ep->ec_name != (unsigned long )((void *)0))) {
#line 1999
            goto while_break___0;
          }
          {
#line 2000
          tmp___1 = sm_strcasecmp((char const   *)ep->ec_name, (char const   *)(hbuf___0));
          }
#line 2000
          if (tmp___1 == 0) {
#line 2001
            goto while_break___0;
          }
#line 1999
          ep ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2002
        if (ExitStat == 0) {
#line 2002
          ExitStat = ep->ec_code;
        } else
#line 2002
        if (ExitStat == 75) {
#line 2002
          ExitStat = ep->ec_code;
        }
      }
    } else {
#line 2007
      a->q_host = (char *)((void *)0);
#line 2008
      if (ExitStat == 0) {
#line 2008
        ExitStat = 69;
      } else
#line 2008
      if (ExitStat == 75) {
#line 2008
        ExitStat = 69;
      }
    }
    {
#line 2010
    stripquotes(ubuf);
    }
#line 2011
    if (((int )ubuf[0] & -128) == 0) {
      {
#line 2011
      tmp___5 = __ctype_b_loc();
      }
#line 2011
      if ((int const   )*(*tmp___5 + (int )ubuf[0]) & 2048) {
#line 2011
        if (((int )ubuf[1] & -128) == 0) {
          {
#line 2011
          tmp___6 = __ctype_b_loc();
          }
#line 2011
          if ((int const   )*(*tmp___6 + (int )ubuf[1]) & 2048) {
#line 2011
            if (((int )ubuf[2] & -128) == 0) {
              {
#line 2011
              tmp___7 = __ctype_b_loc();
              }
#line 2011
              if ((int const   )*(*tmp___7 + (int )ubuf[2]) & 2048) {
#line 2011
                if ((int )ubuf[3] == 32) {
                  {
#line 2016
                  off = isenhsc((char const   *)(ubuf + 4), ' ');
                  }
#line 2016
                  if (off > 0) {
#line 2018
                    ubuf[off + 4] = (char )'\000';
#line 2019
                    off += 5;
                  } else {
#line 2023
                    off = 4;
#line 2024
                    ubuf[3] = (char )'\000';
                  }
                  {
#line 2026
                  sm_strlcpyn(fmt, (ssize_t )sizeof(fmt), 2, ubuf, " %s");
                  }
#line 2027
                  if (off > 4) {
                    {
#line 2028
                    usrerr((char const   *)(fmt), ubuf + off);
                    }
                  } else {
                    {
#line 2029
                    tmp___4 = isenhsc((char const   *)(hbuf___0), '\000');
                    }
#line 2029
                    if (tmp___4 > 0) {
                      {
#line 2030
                      usrerrenh(hbuf___0, (char const   *)(fmt), ubuf + off);
                      }
                    } else {
                      {
#line 2032
                      usrerr((char const   *)(fmt), ubuf + off);
                      }
                    }
                  }
#line 2034
                  if ((int )ubuf[0] == 52) {
#line 2035
                    tempfail = 1;
                  }
                } else {
                  {
#line 2039
                  usrerr("553 5.3.0 %s", ubuf);
                  }
                }
              } else {
                {
#line 2039
                usrerr("553 5.3.0 %s", ubuf);
                }
              }
            } else {
              {
#line 2039
              usrerr("553 5.3.0 %s", ubuf);
              }
            }
          } else {
            {
#line 2039
            usrerr("553 5.3.0 %s", ubuf);
            }
          }
        } else {
          {
#line 2039
          usrerr("553 5.3.0 %s", ubuf);
          }
        }
      } else {
        {
#line 2039
        usrerr("553 5.3.0 %s", ubuf);
        }
      }
    } else {
      {
#line 2039
      usrerr("553 5.3.0 %s", ubuf);
      }
    }
#line 2041
    goto badaddr;
  }
#line 2044
  mp = Mailer;
  {
#line 2044
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2044
    tmp___10 = mp;
#line 2044
    mp ++;
#line 2044
    m = *tmp___10;
#line 2044
    if (! ((unsigned long )m != (unsigned long )((void *)0))) {
#line 2044
      goto while_break___1;
    }
    {
#line 2046
    tmp___9 = sm_strcasecmp((char const   *)m->m_name, (char const   *)mname);
    }
#line 2046
    if (tmp___9 == 0) {
#line 2047
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2049
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 2051
    syserr("554 5.3.5 buildaddr: unknown mailer %s", mname);
    }
#line 2052
    goto badaddr;
  }
#line 2054
  a->q_mailer = m;
#line 2057
  if ((unsigned long )hostp == (unsigned long )((void *)0)) {
#line 2059
    if (! (m->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int ))))) {
      {
#line 2061
      syserr("554 5.3.5 buildaddr: no host");
      }
#line 2062
      goto badaddr;
    }
#line 2064
    a->q_host = (char *)((void *)0);
  } else {
    {
#line 2067
    a->q_host = sm_rpool_strdup_x(e->e_rpool, (char const   *)(hbuf___0));
    }
  }
#line 2070
  p = ubuf;
#line 2071
  if (m->m_flags[64UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 64UL % (8UL * sizeof(int )))) {
#line 2071
    if ((int )*p == 64) {
#line 2073
      p ++;
#line 2074
      tv ++;
#line 2075
      maxatom --;
#line 2076
      a->q_flags |= 4UL;
    }
  }
#line 2080
  if ((int )*p == 34) {
#line 2081
    p ++;
  }
#line 2082
  if ((int )*p == 124) {
#line 2082
    if (m->m_flags[124UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 124UL % (8UL * sizeof(int )))) {
#line 2083
      m = ProgMailer;
#line 2083
      a->q_mailer = m;
    } else {
#line 2082
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2084
  if ((int )*p == 47) {
#line 2084
    if (m->m_flags[47UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 47UL % (8UL * sizeof(int )))) {
#line 2085
      m = FileMailer;
#line 2085
      a->q_mailer = m;
    } else {
#line 2084
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2086
  if ((int )*p == 58) {
#line 2086
    if (m->m_flags[58UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 58UL % (8UL * sizeof(int )))) {
      {
#line 2089
      stripquotes(ubuf);
#line 2090
      tmp___11 = sm_strncasecmp((char const   *)(ubuf), ":include:", (size_t )9);
      }
#line 2090
      if (tmp___11 == 0) {
        {
#line 2093
        m = InclMailer;
#line 2093
        a->q_mailer = m;
#line 2094
        a->q_user = sm_rpool_strdup_x(e->e_rpool, (char const   *)(& ubuf[9]));
        }
#line 2095
        return (a);
      }
    }
  }
  {
#line 2100
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'h', a->q_host, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                   2100, SmHeapGroup);
  }
#line 2102
  if (ConfigLevel >= 10) {
#line 2102
    goto _L___3;
  } else
#line 2102
  if (! ((flags & 3) != 0)) {
    _L___3: /* CIL Label */ 
    {
#line 2106
    rewrite(tv, 2, 0, e, maxatom);
    }
#line 2107
    if ((int )m->m_re_rwset > 0) {
      {
#line 2108
      rewrite(tv, (int )m->m_re_rwset, 0, e, maxatom);
      }
    }
  }
  {
#line 2110
  rewrite(tv, 4, 0, e, maxatom);
#line 2113
  cataddr(tv, (char **)((void *)0), ubuf, (int )sizeof(ubuf), '\000');
#line 2114
  a->q_user = sm_rpool_strdup_x(e->e_rpool, (char const   *)(ubuf));
  }
#line 2120
  if ((unsigned long )a->q_host != (unsigned long )((void *)0)) {
#line 2120
    if (! (m->m_flags[104UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 104UL % (8UL * sizeof(int ))))) {
      {
#line 2121
      makelower(a->q_host);
      }
    }
  }
#line 2122
  if (! (m->m_flags[117UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 117UL % (8UL * sizeof(int ))))) {
    {
#line 2123
    makelower(a->q_user);
    }
  }
#line 2125
  if ((int )tTdvect[24] >= 6) {
    {
#line 2127
    sm_dprintf((char *)"buildaddr => ");
#line 2128
    tmp___12 = sm_debug_file();
#line 2128
    printaddr(tmp___12, a, 0);
    }
  }
#line 2130
  return (a);
}
}
#line 2152 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
void cataddr(char **pvp , char **evp , char *buf___16 , int sz , int spacesub ) 
{ 
  bool oatomtok ;
  bool natomtok ;
  register int i ;
  register char *p ;
  char *tmp ;
  size_t tmp___0 ;
  char **tmp___1 ;

  {
#line 2160
  oatomtok = 0;
#line 2161
  natomtok = 0;
#line 2165
  if (sz <= 0) {
#line 2166
    return;
  }
#line 2168
  if (spacesub == 0) {
#line 2169
    spacesub = (int )SpaceSub;
  }
#line 2171
  if ((unsigned long )pvp == (unsigned long )((void *)0)) {
#line 2173
    *buf___16 = (char )'\000';
#line 2174
    return;
  }
#line 2176
  p = buf___16;
#line 2177
  sz -= 2;
  {
#line 2178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2178
    if ((unsigned long )*pvp != (unsigned long )((void *)0)) {
#line 2178
      if (! (sz > 0)) {
#line 2178
        goto while_break;
      }
    } else {
#line 2178
      goto while_break;
    }
#line 2180
    natomtok = (int )TokTypeTab[(int )*(*pvp) & 255] == 1;
#line 2181
    if (oatomtok) {
#line 2181
      if (natomtok) {
#line 2183
        tmp = p;
#line 2183
        p ++;
#line 2183
        *tmp = (char )spacesub;
#line 2184
        sz --;
#line 2184
        if (sz <= 0) {
#line 2185
          goto while_break;
        }
      }
    }
    {
#line 2187
    tmp___0 = sm_strlcpy(p, (char const   *)*pvp, sz);
#line 2187
    i = (int )tmp___0;
#line 2188
    sz -= i;
    }
#line 2189
    if (sz <= 0) {
#line 2190
      goto while_break;
    }
#line 2191
    oatomtok = natomtok;
#line 2192
    p += i;
#line 2193
    tmp___1 = pvp;
#line 2193
    pvp ++;
#line 2193
    if ((unsigned long )tmp___1 == (unsigned long )evp) {
#line 2194
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2213
  *p = (char )'\000';
#line 2214
  return;
}
}
#line 2232 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
bool sameaddr(ADDRESS *a , ADDRESS *b___0 ) 
{ 
  register ADDRESS *ca ;
  register ADDRESS *cb ;
  int tmp ;
  int tmp___0 ;

  {
#line 2240
  if ((unsigned long )a->q_mailer != (unsigned long )b___0->q_mailer) {
#line 2241
    return (0);
  }
  {
#line 2244
  tmp = strcmp((char const   *)a->q_user, (char const   *)b___0->q_user);
  }
#line 2244
  if (tmp != 0) {
#line 2245
    return (0);
  }
#line 2248
  if ((unsigned long )a->q_mailer == (unsigned long )ProgMailer) {
    {
#line 2250
    ca = getctladdr(a);
#line 2251
    cb = getctladdr(b___0);
    }
#line 2252
    if ((unsigned long )ca != (unsigned long )((void *)0)) {
#line 2252
      if ((unsigned long )cb != (unsigned long )((void *)0)) {
#line 2252
        if (((ca->q_flags & cb->q_flags) & 1UL) != 0UL) {
#line 2252
          if (ca->q_uid != cb->q_uid) {
#line 2255
            return (0);
          }
        }
      }
    }
  }
#line 2259
  if ((unsigned long )a->q_host == (unsigned long )b___0->q_host) {
#line 2262
    return (1);
  }
#line 2264
  if ((unsigned long )a->q_host == (unsigned long )((void *)0)) {
#line 2267
    return (0);
  } else
#line 2264
  if ((unsigned long )b___0->q_host == (unsigned long )((void *)0)) {
#line 2267
    return (0);
  }
  {
#line 2269
  tmp___0 = strcmp((char const   *)a->q_host, (char const   *)b___0->q_host);
  }
#line 2269
  if (tmp___0 != 0) {
#line 2270
    return (0);
  }
#line 2272
  return (1);
}
}
#line 2294 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static struct qflags AddressFlags[17]  = 
#line 2294
  {      {(char *)"QGOODUID", 1UL}, 
        {(char *)"QPRIMARY", 2UL}, 
        {(char *)"QNOTREMOTE", 4UL}, 
        {(char *)"QSELFREF", 8UL}, 
        {(char *)"QBOGUSSHELL", 16UL}, 
        {(char *)"QUNSAFEADDR", 32UL}, 
        {(char *)"QPINGONSUCCESS", 64UL}, 
        {(char *)"QPINGONFAILURE", 128UL}, 
        {(char *)"QPINGONDELAY", 256UL}, 
        {(char *)"QHASNOTIFY", 512UL}, 
        {(char *)"QRELAYED", 1024UL}, 
        {(char *)"QEXPANDED", 2048UL}, 
        {(char *)"QDELIVERED", 4096UL}, 
        {(char *)"QDELAYED", 8192UL}, 
        {(char *)"QTHISPASS", 1073741824UL}, 
        {(char *)"QRCPTOK", 2147483648UL}, 
        {(char *)((void *)0), 0UL}};
#line 2315 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
void printaddr(SM_FILE_T *fp , ADDRESS *a , bool follow ) 
{ 
  register MAILER *m ;
  MAILER pseudomailer ;
  register struct qflags *qfp ;
  bool firstone ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
#line 2326
  if ((unsigned long )a == (unsigned long )((void *)0)) {
    {
#line 2328
    sm_io_fprintf(fp, -2, "[NULL]\n");
    }
#line 2329
    return;
  }
  {
#line 2332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2332
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 2332
      goto while_break;
    }
    {
#line 2334
    sm_io_fprintf(fp, -2, "%p=", a);
#line 2335
    sm_io_flush(fp, -2);
#line 2338
    m = a->q_mailer;
    }
#line 2339
    if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 2341
      m = & pseudomailer;
#line 2342
      m->m_mno = (short)-1;
#line 2343
      m->m_name = (char *)"NULL";
    }
#line 2346
    if ((unsigned long )a->q_host == (unsigned long )((void *)0)) {
#line 2346
      tmp = "<null>";
    } else {
#line 2346
      tmp = (char const   *)a->q_host;
    }
#line 2346
    if ((unsigned long )a->q_paddr == (unsigned long )((void *)0)) {
#line 2346
      tmp___0 = "<null>";
    } else {
#line 2346
      tmp___0 = (char const   *)a->q_paddr;
    }
    {
#line 2346
    sm_io_fprintf(fp, -2, "%s:\n\tmailer %d (%s), host `%s\'\n", tmp___0, (int )m->m_mno,
                  m->m_name, tmp);
    }
#line 2351
    if ((unsigned long )a->q_ruser == (unsigned long )((void *)0)) {
#line 2351
      tmp___1 = "<null>";
    } else {
#line 2351
      tmp___1 = (char const   *)a->q_ruser;
    }
    {
#line 2351
    sm_io_fprintf(fp, -2, "\tuser `%s\', ruser `%s\'\n", a->q_user, tmp___1);
#line 2355
    sm_io_fprintf(fp, -2, "\tstate=");
    }
    {
#line 2358
    if ((int )a->q_state == 0) {
#line 2358
      goto case_0;
    }
#line 2362
    if ((int )a->q_state == 6) {
#line 2362
      goto case_6;
    }
#line 2367
    if ((int )a->q_state == 2) {
#line 2367
      goto case_2;
    }
#line 2372
    if ((int )a->q_state == 3) {
#line 2372
      goto case_3;
    }
#line 2377
    if ((int )a->q_state == 4) {
#line 2377
      goto case_4;
    }
#line 2381
    if ((int )a->q_state == 1) {
#line 2381
      goto case_1;
    }
#line 2385
    if ((int )a->q_state == 5) {
#line 2385
      goto case_5;
    }
#line 2390
    if ((int )a->q_state == 7) {
#line 2390
      goto case_7;
    }
#line 2395
    if ((int )a->q_state == 8) {
#line 2395
      goto case_8;
    }
#line 2400
    if ((int )a->q_state == 9) {
#line 2400
      goto case_9;
    }
#line 2405
    if ((int )a->q_state == 10) {
#line 2405
      goto case_10;
    }
#line 2410
    if ((int )a->q_state == 11) {
#line 2410
      goto case_11;
    }
#line 2415
    if ((int )a->q_state == 12) {
#line 2415
      goto case_12;
    }
#line 2420
    if ((int )a->q_state == 13) {
#line 2420
      goto case_13;
    }
#line 2425
    if ((int )a->q_state == 14) {
#line 2425
      goto case_14;
    }
#line 2430
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 2359
    sm_io_fprintf(fp, -2, "OK");
    }
#line 2360
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 2363
    sm_io_fprintf(fp, -2, "DONTSEND");
    }
#line 2365
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 2368
    sm_io_fprintf(fp, -2, "BADADDR");
    }
#line 2370
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 2373
    sm_io_fprintf(fp, -2, "QUEUEUP");
    }
#line 2375
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 2378
    sm_io_fprintf(fp, -2, "RETRY");
    }
#line 2379
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 2382
    sm_io_fprintf(fp, -2, "SENT");
    }
#line 2383
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 2386
    sm_io_fprintf(fp, -2, "VERIFIED");
    }
#line 2388
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 2391
    sm_io_fprintf(fp, -2, "EXPANDED");
    }
#line 2393
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 2396
    sm_io_fprintf(fp, -2, "SENDER");
    }
#line 2398
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 2401
    sm_io_fprintf(fp, -2, "CLONED");
    }
#line 2403
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 2406
    sm_io_fprintf(fp, -2, "DISCARDED");
    }
#line 2408
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 2411
    sm_io_fprintf(fp, -2, "REPLACED");
    }
#line 2413
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 2416
    sm_io_fprintf(fp, -2, "REMOVED");
    }
#line 2418
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 2421
    sm_io_fprintf(fp, -2, "DUPLICATE");
    }
#line 2423
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 2426
    sm_io_fprintf(fp, -2, "INCLUDED");
    }
#line 2428
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2431
    sm_io_fprintf(fp, -2, "%d", (int )a->q_state);
    }
#line 2433
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2435
    sm_io_fprintf(fp, -2, ", next=%p, alias %p, uid %d, gid %d\n", a->q_next, a->q_alias,
                  (int )a->q_uid, (int )a->q_gid);
#line 2439
    sm_io_fprintf(fp, -2, "\tflags=%lx<", a->q_flags);
#line 2441
    firstone = 1;
#line 2442
    qfp = AddressFlags;
    }
    {
#line 2442
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2442
      if (! ((unsigned long )qfp->qf_name != (unsigned long )((void *)0))) {
#line 2442
        goto while_break___0;
      }
#line 2444
      if (! ((a->q_flags & qfp->qf_bit) != 0UL)) {
#line 2445
        goto __Cont;
      }
#line 2446
      if (! firstone) {
        {
#line 2447
        sm_io_fprintf(fp, -2, ",");
        }
      }
      {
#line 2449
      firstone = 0;
#line 2450
      sm_io_fprintf(fp, -2, "%s", qfp->qf_name);
      }
      __Cont: /* CIL Label */ 
#line 2442
      qfp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2453
    sm_io_fprintf(fp, -2, ">\n");
    }
#line 2454
    if ((unsigned long )a->q_fullname == (unsigned long )((void *)0)) {
#line 2454
      tmp___2 = "(none)";
    } else {
#line 2454
      tmp___2 = (char const   *)a->q_fullname;
    }
#line 2454
    if ((unsigned long )a->q_home == (unsigned long )((void *)0)) {
#line 2454
      tmp___3 = "(none)";
    } else {
#line 2454
      tmp___3 = (char const   *)a->q_home;
    }
#line 2454
    if ((unsigned long )a->q_owner == (unsigned long )((void *)0)) {
#line 2454
      tmp___4 = "(none)";
    } else {
#line 2454
      tmp___4 = (char const   *)a->q_owner;
    }
    {
#line 2454
    sm_io_fprintf(fp, -2, "\towner=%s, home=\"%s\", fullname=\"%s\"\n", tmp___4, tmp___3,
                  tmp___2);
    }
#line 2459
    if ((unsigned long )a->q_status == (unsigned long )((void *)0)) {
#line 2459
      tmp___5 = "(none)";
    } else {
#line 2459
      tmp___5 = (char const   *)a->q_status;
    }
#line 2459
    if ((unsigned long )a->q_statmta == (unsigned long )((void *)0)) {
#line 2459
      tmp___6 = "(none)";
    } else {
#line 2459
      tmp___6 = (char const   *)a->q_statmta;
    }
#line 2459
    if ((unsigned long )a->q_orcpt == (unsigned long )((void *)0)) {
#line 2459
      tmp___7 = "(none)";
    } else {
#line 2459
      tmp___7 = (char const   *)a->q_orcpt;
    }
    {
#line 2459
    sm_io_fprintf(fp, -2, "\torcpt=\"%s\", statmta=%s, status=%s\n", tmp___7, tmp___6,
                  tmp___5);
    }
#line 2464
    if ((unsigned long )a->q_finalrcpt == (unsigned long )((void *)0)) {
#line 2464
      tmp___8 = "(none)";
    } else {
#line 2464
      tmp___8 = (char const   *)a->q_finalrcpt;
    }
    {
#line 2464
    sm_io_fprintf(fp, -2, "\tfinalrcpt=\"%s\"\n", tmp___8);
    }
#line 2467
    if ((unsigned long )a->q_rstatus == (unsigned long )((void *)0)) {
#line 2467
      tmp___9 = "(none)";
    } else {
#line 2467
      tmp___9 = (char const   *)a->q_rstatus;
    }
    {
#line 2467
    sm_io_fprintf(fp, -2, "\trstatus=\"%s\"\n", tmp___9);
    }
#line 2470
    if (a->q_statdate == 0L) {
#line 2470
      tmp___11 = "(none)";
    } else {
      {
#line 2470
      tmp___10 = ctime((time_t const   *)(& a->q_statdate));
#line 2470
      tmp___11 = (char const   *)tmp___10;
      }
    }
    {
#line 2470
    sm_io_fprintf(fp, -2, "\tstatdate=%s\n", tmp___11);
    }
#line 2474
    if (! follow) {
#line 2475
      return;
    }
#line 2476
    a = a->q_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2478
  return;
}
}
#line 2491 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
bool emptyaddr(ADDRESS *a ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 2495
  if ((unsigned long )a->q_paddr == (unsigned long )((void *)0)) {
#line 2495
    tmp___1 = 1;
  } else {
    {
#line 2495
    tmp = strcmp((char const   *)a->q_paddr, "<>");
    }
#line 2495
    if (tmp == 0) {
#line 2495
      tmp___1 = 1;
    } else
#line 2495
    if ((unsigned long )a->q_user == (unsigned long )((void *)0)) {
#line 2495
      tmp___1 = 1;
    } else {
      {
#line 2495
      tmp___0 = strcmp((char const   *)a->q_user, "<>");
      }
#line 2495
      if (tmp___0 == 0) {
#line 2495
        tmp___1 = 1;
      } else {
#line 2495
        tmp___1 = 0;
      }
    }
  }
#line 2495
  return (tmp___1);
}
}
#line 2532 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static char buf___6[257]  ;
#line 2520 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
char *remotename(char *name , struct mailer *m , int flags , int *pstat , ENVELOPE *e ) 
{ 
  register char **pvp ;
  char *fancy ;
  char *oldg ;
  int rwset ;
  char lbuf[257] ;
  char pvpbuf[1256] ;
  char addrtype[4] ;
  int tmp ;
  int tmp___0 ;
  register char **pxp ;
  int l ;
  int tmp___1 ;
  register char **qxq ;
  char **tmp___2 ;
  char *tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  SM_EXC_HANDLER_T _h ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 2537
  if ((int )tTdvect[12] >= 1) {
    {
#line 2538
    sm_dprintf((char *)"remotename(%s)\n", name);
    }
  }
#line 2541
  if ((flags & 1) != 0) {
#line 2543
    if ((flags & 2) != 0) {
#line 2543
      rwset = (int )m->m_sh_rwset;
    } else {
#line 2543
      rwset = (int )m->m_se_rwset;
    }
#line 2545
    addrtype[2] = (char )'s';
  } else {
#line 2549
    if ((flags & 2) != 0) {
#line 2549
      rwset = (int )m->m_rh_rwset;
    } else {
#line 2549
      rwset = (int )m->m_re_rwset;
    }
#line 2551
    addrtype[2] = (char )'r';
  }
#line 2553
  if (rwset < 0) {
#line 2554
    return (name);
  }
#line 2555
  addrtype[1] = (char )' ';
#line 2556
  addrtype[3] = (char )'\000';
#line 2557
  if ((flags & 2) != 0) {
#line 2557
    addrtype[0] = (char )'h';
  } else {
#line 2557
    addrtype[0] = (char )'e';
  }
  {
#line 2558
  tmp = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 2558
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp, addrtype, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                   2558, SmHeapGroup);
  }
#line 2565
  if ((flags & 4) != 0) {
#line 2566
    fancy = (char *)"\201g";
  } else
#line 2565
  if (m->m_flags[99UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 99UL % (8UL * sizeof(int )))) {
#line 2566
    fancy = (char *)"\201g";
  } else {
    {
#line 2568
    fancy = crackaddr(name, e);
    }
  }
  {
#line 2578
  pvp = prescan(name, '\000', pvpbuf, (int )sizeof(pvpbuf), (char **)((void *)0),
                (unsigned char *)((void *)0), 0);
  }
#line 2579
  if ((unsigned long )pvp == (unsigned long )((void *)0)) {
#line 2580
    return (name);
  }
  {
#line 2581
  tmp___0 = rewrite(pvp, 3, 0, e, 1000);
  }
#line 2581
  if (tmp___0 == 75) {
#line 2582
    *pstat = 75;
  }
#line 2583
  if ((flags & 8) != 0) {
#line 2583
    if ((unsigned long )e->e_fromdomain != (unsigned long )((void *)0)) {
#line 2586
      pxp = pvp;
#line 2587
      l = 1000;
      {
#line 2590
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2590
        if ((unsigned long )*pxp != (unsigned long )((void *)0)) {
          {
#line 2590
          tmp___1 = strcmp((char const   *)*pxp, "@");
          }
#line 2590
          if (! (tmp___1 != 0)) {
#line 2590
            goto while_break;
          }
        } else {
#line 2590
          goto while_break;
        }
#line 2592
        pxp ++;
#line 2593
        l --;
      }
      while_break: /* CIL Label */ ;
      }
#line 2595
      if ((unsigned long )*pxp == (unsigned long )((void *)0)) {
#line 2598
        qxq = e->e_fromdomain;
        {
#line 2600
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2600
          tmp___2 = pxp;
#line 2600
          pxp ++;
#line 2600
          tmp___4 = qxq;
#line 2600
          qxq ++;
#line 2600
          tmp___3 = *tmp___4;
#line 2600
          *tmp___2 = tmp___3;
#line 2600
          if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 2600
            goto while_break___0;
          }
#line 2602
          l --;
#line 2602
          if (l <= 0) {
            {
#line 2604
            pxp --;
#line 2604
            *pxp = (char *)((void *)0);
#line 2605
            usrerr("553 5.1.0 remotename: too many tokens");
#line 2606
            *pstat = 69;
            }
#line 2607
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 2610
        tmp___5 = rewrite(pvp, 3, 0, e, 1000);
        }
#line 2610
        if (tmp___5 == 75) {
#line 2611
          *pstat = 75;
        }
      }
    }
  }
#line 2622
  if ((flags & 1) != 0) {
    {
#line 2624
    tmp___6 = rewrite(pvp, 1, 0, e, 1000);
    }
#line 2624
    if (tmp___6 == 75) {
#line 2625
      *pstat = 75;
    }
  } else {
    {
#line 2629
    tmp___7 = rewrite(pvp, 2, 0, e, 1000);
    }
#line 2629
    if (tmp___7 == 75) {
#line 2630
      *pstat = 75;
    }
  }
#line 2632
  if (rwset > 0) {
    {
#line 2634
    tmp___8 = rewrite(pvp, rwset, 0, e, 1000);
    }
#line 2634
    if (tmp___8 == 75) {
#line 2635
      *pstat = 75;
    }
  }
  {
#line 2645
  tmp___9 = rewrite(pvp, 4, 0, e, 1000);
  }
#line 2645
  if (tmp___9 == 75) {
#line 2646
    *pstat = 75;
  }
  {
#line 2652
  cataddr(pvp, (char **)((void *)0), lbuf, (int )sizeof(lbuf), '\000');
#line 2653
  oldg = e->e_macro.mac_table['g'];
#line 2654
  macset(& e->e_macro, 'g', lbuf);
  }
  {
#line 2656
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2656
    _h.eh_value = (SM_EXC_T *)((void *)0);
#line 2656
    _h.eh_parent = SmExcHandler;
#line 2656
    _h.eh_state = 2;
#line 2656
    SmExcHandler = & _h;
#line 2656
    tmp___11 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 2656
    if (tmp___11 == 0) {
#line 2658
      if ((flags & 4) != 0) {
#line 2658
        if ((int )lbuf[0] == 64) {
          {
#line 2659
          expand((char *)"<\201g>", buf___6, (size_t )sizeof(buf___6), e);
          }
        } else {
          {
#line 2661
          expand(fancy, buf___6, (size_t )sizeof(buf___6), e);
          }
        }
      } else {
        {
#line 2661
        expand(fancy, buf___6, (size_t )sizeof(buf___6), e);
        }
      }
#line 2662
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 2662
        tmp___10 = 1;
      } else {
        {
#line 2662
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                    2662, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2662
        tmp___10 = 0;
        }
      }
    }
    {
#line 2662
    tmp___12 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 2662
    if (tmp___12 == 0) {
      {
#line 2663
      macset(& e->e_macro, 'g', oldg);
      }
    }
#line 2656
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2664
  if (_h.eh_state == 2) {
#line 2664
    if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 2664
      tmp___13 = 1;
    } else {
      {
#line 2664
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                  2664, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2664
      tmp___13 = 0;
      }
    }
#line 2664
    SmExcHandler = _h.eh_parent;
#line 2664
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 2664
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else
#line 2664
  if (_h.eh_state == 0) {
#line 2664
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 2664
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else {
    {
#line 2664
    sm_exc_free(_h.eh_value);
    }
  }
#line 2666
  if ((int )tTdvect[12] >= 1) {
    {
#line 2667
    sm_dprintf((char *)"remotename => `%s\'\n", buf___6);
    }
  }
#line 2668
  return (buf___6);
}
}
#line 2689 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
void maplocaluser(ADDRESS *a , ADDRESS **sendq , int aliaslevel , ENVELOPE *e ) 
{ 
  register char **pvp ;
  register ADDRESS *a1 ;
  char pvpbuf[1256] ;
  SM_FILE_T *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  SM_EXC_HANDLER_T _h ;
  int tmp___2 ;
  int tmp___3 ;
  bool tmp___5 ;
  SM_EXC_T *exc  __attribute__((__unused__)) ;
  int tmp___6 ;
  bool tmp___7 ;
  SM_FILE_T *tmp___8 ;
  char *tmp___9 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 2697
  a1 = (ADDRESS *)((void *)0);
#line 2700
  if ((int )tTdvect[29] >= 1) {
    {
#line 2702
    sm_dprintf((char *)"maplocaluser: ");
#line 2703
    tmp = sm_debug_file();
#line 2703
    printaddr(tmp, a, 0);
    }
  }
  {
#line 2705
  pvp = prescan(a->q_user, '\000', pvpbuf, (int )sizeof(pvpbuf), (char **)((void *)0),
                (unsigned char *)((void *)0), 0);
  }
#line 2706
  if ((unsigned long )pvp == (unsigned long )((void *)0)) {
#line 2708
    if ((int )tTdvect[29] >= 9) {
      {
#line 2709
      sm_dprintf((char *)"maplocaluser: cannot prescan %s\n", a->q_user);
      }
    }
#line 2711
    return;
  }
  {
#line 2714
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'h', a->q_host, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                   2714, SmHeapGroup);
#line 2715
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'u', a->q_user, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                   2715, SmHeapGroup);
#line 2716
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'z', a->q_home, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                   2716, SmHeapGroup);
#line 2718
  tmp___0 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 2718
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___0, (char *)"e r", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                   2718, SmHeapGroup);
#line 2719
  tmp___1 = rewrite(pvp, 5, 0, e, 1000);
  }
#line 2719
  if (tmp___1 == 75) {
#line 2721
    if ((int )tTdvect[29] >= 9) {
      {
#line 2722
      sm_dprintf((char *)"maplocaluser: rewrite tempfail\n");
      }
    }
#line 2723
    a->q_state = (short)3;
#line 2724
    a->q_status = (char *)"4.4.3";
#line 2725
    return;
  }
#line 2727
  if ((unsigned long )*(pvp + 0) == (unsigned long )((void *)0)) {
#line 2727
    goto _L;
  } else
#line 2727
  if (((int )*(*(pvp + 0) + 0) & 255) != 150) {
    _L: /* CIL Label */ 
#line 2729
    if ((int )tTdvect[29] >= 9) {
      {
#line 2730
      sm_dprintf((char *)"maplocaluser: doesn\'t resolve\n");
      }
    }
#line 2731
    return;
  }
  {
#line 2734
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2734
    _h.eh_value = (SM_EXC_T *)((void *)0);
#line 2734
    _h.eh_parent = SmExcHandler;
#line 2734
    _h.eh_state = 2;
#line 2734
    SmExcHandler = & _h;
#line 2734
    tmp___2 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 2734
    if (tmp___2 == 0) {
      {
#line 2735
      a1 = buildaddr(pvp, (ADDRESS *)((void *)0), 0, e);
      }
    }
#line 2736
    if (_h.eh_state == 1) {
#line 2736
      goto while_break;
    }
#line 2736
    if (_h.eh_state == 2) {
#line 2736
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 2736
        tmp___3 = 1;
      } else {
        {
#line 2736
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                    2736, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2736
        tmp___3 = 0;
        }
      }
#line 2736
      SmExcHandler = _h.eh_parent;
    }
    {
#line 2736
    tmp___5 = sm_exc_match(_h.eh_value, "E:mta.quickabort");
    }
#line 2736
    if (tmp___5) {
#line 2736
      _h.eh_state = 1;
    } else {
#line 2736
      _h.eh_state = 0;
    }
#line 2736
    if (_h.eh_state == 1) {
      {
#line 2736
      exc = _h.eh_value;
#line 2743
      a->q_state = (short)6;
#line 2744
      sm_exc_raisenew_x(& EtypeQuickAbort, 2);
      }
    }
#line 2734
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2745
  if (_h.eh_state == 2) {
#line 2745
    if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 2745
      tmp___6 = 1;
    } else {
      {
#line 2745
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                  2745, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2745
      tmp___6 = 0;
      }
    }
#line 2745
    SmExcHandler = _h.eh_parent;
#line 2745
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 2745
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else
#line 2745
  if (_h.eh_state == 0) {
#line 2745
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 2745
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else {
    {
#line 2745
    sm_exc_free(_h.eh_value);
    }
  }
#line 2748
  if ((unsigned long )a1 == (unsigned long )((void *)0)) {
#line 2748
    goto _L___0;
  } else {
    {
#line 2748
    tmp___7 = sameaddr(a, a1);
    }
#line 2748
    if (tmp___7) {
      _L___0: /* CIL Label */ 
#line 2750
      if ((int )tTdvect[29] >= 9) {
        {
#line 2751
        sm_dprintf((char *)"maplocaluser: address unchanged\n");
        }
      }
#line 2752
      return;
    }
  }
  {
#line 2756
  a1->q_flags &= 0xfffffffffffc400dUL;
#line 2757
  a1->q_flags |= a->q_flags & 245746UL;
#line 2758
  a1->q_paddr = sm_rpool_strdup_x(e->e_rpool, (char const   *)a->q_paddr);
#line 2759
  a1->q_finalrcpt = a->q_finalrcpt;
#line 2760
  a1->q_orcpt = a->q_orcpt;
#line 2763
  a->q_state = (short)11;
  }
#line 2764
  if ((int )tTdvect[29] >= 5) {
    {
#line 2766
    sm_dprintf((char *)"maplocaluser: QS_REPLACED ");
#line 2767
    tmp___8 = sm_debug_file();
#line 2767
    printaddr(tmp___8, a, 0);
    }
  }
  {
#line 2769
  a1->q_alias = a;
#line 2770
  tmp___9 = sm_rpool_strdup_x(e->e_rpool, (char const   *)a->q_paddr);
#line 2770
  allocaddr(a1, 48, tmp___9, e);
#line 2771
  recipient(a1, sendq, aliaslevel, e);
  }
#line 2772
  return;
}
}
#line 2784 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
bool dequote_init(struct _map *map___0 , char *args ) 
{ 
  register char *p ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 2789
  p = args;
#line 2792
  map___0->map_mflags |= 65536L;
  {
#line 2793
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2795
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2795
      if (((int )*p & -128) == 0) {
        {
#line 2795
        tmp = __ctype_b_loc();
        }
#line 2795
        if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 2795
          goto while_break___0;
        }
      } else {
#line 2795
        goto while_break___0;
      }
#line 2796
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2797
    if ((int )*p != 45) {
#line 2798
      goto while_break;
    }
#line 2799
    p ++;
    {
#line 2801
    if ((int )*p == 97) {
#line 2801
      goto case_97;
    }
#line 2805
    if ((int )*p == 68) {
#line 2805
      goto case_68;
    }
#line 2810
    if ((int )*p == 115) {
#line 2810
      goto case_115;
    }
#line 2810
    if ((int )*p == 83) {
#line 2810
      goto case_115;
    }
#line 2799
    goto switch_break;
    case_97: /* CIL Label */ 
#line 2802
    p ++;
#line 2802
    map___0->map_app = p;
#line 2803
    goto switch_break;
    case_68: /* CIL Label */ 
#line 2806
    map___0->map_mflags |= 524288L;
#line 2807
    goto switch_break;
    case_115: /* CIL Label */ 
    case_83: /* CIL Label */ 
#line 2811
    p ++;
#line 2811
    map___0->map_spacesub = *p;
#line 2812
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2814
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2814
      if ((int )*p != 0) {
#line 2814
        if (((int )*p & -128) == 0) {
          {
#line 2814
          tmp___0 = __ctype_b_loc();
          }
#line 2814
          if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
#line 2814
            goto while_break___1;
          }
        }
      } else {
#line 2814
        goto while_break___1;
      }
#line 2815
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2816
    if ((int )*p != 0) {
#line 2817
      *p = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2819
  if ((unsigned long )map___0->map_app != (unsigned long )((void *)0)) {
    {
#line 2820
    map___0->map_app = newstr((char const   *)map___0->map_app);
    }
  }
#line 2822
  return (1);
}
}
#line 2840 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
char *dequote_map(struct _map *map___0 , char *name , char **av___0 , int *statp ) 
{ 
  register char *p ;
  register char *q ;
  register char c ;
  int anglecnt ;
  int cmntcnt ;
  int quotecnt ;
  int spacecnt ;
  bool quotemode ;
  bool bslashmode ;
  char spacesub ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;

  {
#line 2850
  anglecnt = 0;
#line 2851
  cmntcnt = 0;
#line 2852
  quotecnt = 0;
#line 2853
  spacecnt = 0;
#line 2854
  quotemode = 0;
#line 2855
  bslashmode = 0;
#line 2856
  spacesub = map___0->map_spacesub;
#line 2858
  q = name;
#line 2858
  p = q;
  {
#line 2858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2858
    tmp___4 = p;
#line 2858
    p ++;
#line 2858
    c = *tmp___4;
#line 2858
    if (! ((int )c != 0)) {
#line 2858
      goto while_break;
    }
#line 2860
    if (bslashmode) {
#line 2862
      bslashmode = 0;
#line 2863
      tmp = q;
#line 2863
      q ++;
#line 2863
      *tmp = c;
#line 2864
      goto __Cont;
    }
#line 2867
    if ((int )c == 32) {
#line 2867
      if ((int )spacesub != 0) {
#line 2868
        c = spacesub;
      }
    }
    {
#line 2872
    if ((int )c == 92) {
#line 2872
      goto case_92;
    }
#line 2876
    if ((int )c == 40) {
#line 2876
      goto case_40;
    }
#line 2880
    if ((int )c == 41) {
#line 2880
      goto case_41;
    }
#line 2886
    if ((int )c == 9) {
#line 2886
      goto case_9;
    }
#line 2886
    if ((int )c == 32) {
#line 2886
      goto case_9;
    }
#line 2870
    goto switch_break;
    case_92: /* CIL Label */ 
#line 2873
    bslashmode = 1;
#line 2874
    goto switch_break;
    case_40: /* CIL Label */ 
#line 2877
    cmntcnt ++;
#line 2878
    goto switch_break;
    case_41: /* CIL Label */ 
#line 2881
    tmp___0 = cmntcnt;
#line 2881
    cmntcnt --;
#line 2881
    if (tmp___0 <= 0) {
#line 2882
      return ((char *)((void *)0));
    }
#line 2883
    goto switch_break;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 2887
    spacecnt ++;
#line 2888
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2891
    if (cmntcnt > 0) {
#line 2893
      tmp___1 = q;
#line 2893
      q ++;
#line 2893
      *tmp___1 = c;
#line 2894
      goto __Cont;
    }
    {
#line 2899
    if ((int )c == 34) {
#line 2899
      goto case_34;
    }
#line 2904
    if ((int )c == 60) {
#line 2904
      goto case_60;
    }
#line 2908
    if ((int )c == 62) {
#line 2908
      goto case_62;
    }
#line 2897
    goto switch_break___0;
    case_34: /* CIL Label */ 
#line 2900
    quotemode = ! quotemode;
#line 2901
    quotecnt ++;
#line 2902
    goto __Cont;
    case_60: /* CIL Label */ 
#line 2905
    anglecnt ++;
#line 2906
    goto switch_break___0;
    case_62: /* CIL Label */ 
#line 2909
    tmp___2 = anglecnt;
#line 2909
    anglecnt --;
#line 2909
    if (tmp___2 <= 0) {
#line 2910
      return ((char *)((void *)0));
    }
#line 2911
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 2913
    tmp___3 = q;
#line 2913
    q ++;
#line 2913
    *tmp___3 = c;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2916
  if (anglecnt != 0) {
#line 2918
    return ((char *)((void *)0));
  } else
#line 2916
  if (cmntcnt != 0) {
#line 2918
    return ((char *)((void *)0));
  } else
#line 2916
  if (bslashmode) {
#line 2918
    return ((char *)((void *)0));
  } else
#line 2916
  if (quotemode) {
#line 2918
    return ((char *)((void *)0));
  } else
#line 2916
  if (quotecnt <= 0) {
#line 2918
    return ((char *)((void *)0));
  } else
#line 2916
  if (spacecnt != 0) {
#line 2918
    return ((char *)((void *)0));
  }
  {
#line 2919
  tmp___5 = q;
#line 2919
  q ++;
#line 2919
  *tmp___5 = (char )'\000';
#line 2920
  tmp___6 = strlen((char const   *)name);
#line 2920
  tmp___7 = map_rewrite(map___0, (char const   *)name, tmp___6, (char **)((void *)0));
  }
#line 2920
  return (tmp___7);
}
}
#line 3060 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
static bool logged  =    0;
#line 2940 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
int rscheck(char *rwset , char *p1 , char *p2 , ENVELOPE *e , int flags , int logl ,
            char *host , char *logid ) 
{ 
  char * volatile  buf___16 ;
  size_t bufsize ;
  int saveexitstat ;
  int volatile   rstat ;
  char **pvp ;
  int rsno ;
  bool volatile   discard ;
  ADDRESS a1 ;
  bool saveQuickAbort ;
  bool saveSuprErrs ;
  bool quarantine ;
  char ubuf___0[16384] ;
  char buf0[2048] ;
  char pvpbuf[1256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  SM_EXC_HANDLER_T _h ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int savelogusrerrs ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *relay ;
  char *p ;
  char lbuf[2048] ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;

  {
#line 2954
  rstat = (int volatile   )0;
#line 2957
  discard = (bool volatile   )0;
#line 2959
  saveQuickAbort = QuickAbort;
#line 2960
  saveSuprErrs = SuprErrs;
#line 2961
  quarantine = 0;
#line 2967
  if ((int )tTdvect[48] >= 2) {
#line 2968
    if ((unsigned long )p2 == (unsigned long )((void *)0)) {
#line 2968
      tmp = "(NULL)";
    } else {
#line 2968
      tmp = (char const   *)p2;
    }
    {
#line 2968
    sm_dprintf((char *)"rscheck(%s, %s, %s)\n", rwset, p1, tmp);
    }
  }
  {
#line 2971
  rsno = strtorwset(rwset, (char **)((void *)0), 0);
  }
#line 2972
  if (rsno < 0) {
#line 2973
    return (0);
  }
#line 2975
  if ((unsigned long )p2 != (unsigned long )((void *)0)) {
    {
#line 2977
    tmp___0 = strlen((char const   *)p1);
#line 2977
    tmp___1 = strlen((char const   *)p2);
#line 2977
    bufsize = (tmp___0 + tmp___1) + 2U;
    }
#line 2978
    if ((unsigned long )bufsize > sizeof(buf0)) {
      {
#line 2979
      tmp___2 = sm_malloc_tagged_x(bufsize, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                                   2979, SmHeapGroup);
#line 2979
      buf___16 = (char */* volatile  */)tmp___2;
      }
    } else {
#line 2982
      buf___16 = (char */* volatile  */)(buf0);
#line 2983
      bufsize = (size_t )sizeof(buf0);
    }
    {
#line 2985
    sm_snprintf((char *)buf___16, bufsize, "%s%c%s", p1, 155, p2);
    }
  } else {
    {
#line 2989
    tmp___3 = strlen((char const   *)p1);
#line 2989
    bufsize = tmp___3 + 1U;
    }
#line 2990
    if ((unsigned long )bufsize > sizeof(buf0)) {
      {
#line 2991
      tmp___4 = sm_malloc_tagged_x(bufsize, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                                   2991, SmHeapGroup);
#line 2991
      buf___16 = (char */* volatile  */)tmp___4;
      }
    } else {
#line 2994
      buf___16 = (char */* volatile  */)(buf0);
#line 2995
      bufsize = (size_t )sizeof(buf0);
    }
    {
#line 2997
    sm_strlcpy((char *)buf___16, (char const   *)p1, (ssize_t )bufsize);
    }
  }
  {
#line 2999
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2999
    _h.eh_value = (SM_EXC_T *)((void *)0);
#line 2999
    _h.eh_parent = SmExcHandler;
#line 2999
    _h.eh_state = 2;
#line 2999
    SmExcHandler = & _h;
#line 2999
    tmp___16 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 2999
    if (tmp___16 == 0) {
#line 3001
      SuprErrs = 1;
#line 3002
      QuickAbort = 0;
#line 3003
      if ((flags & 1) != 0) {
#line 3003
        tmp___5 = 0;
      } else {
#line 3003
        tmp___5 = 1;
      }
#line 3003
      if ((flags & 1) != 0) {
#line 3003
        tmp___6 = (unsigned char *)((void *)0);
      } else {
#line 3003
        tmp___6 = TokTypeNoC;
      }
      {
#line 3003
      pvp = prescan((char *)buf___16, '\000', pvpbuf, (int )sizeof(pvpbuf), (char **)((void *)0),
                    tmp___6, tmp___5);
#line 3006
      SuprErrs = saveSuprErrs;
      }
#line 3007
      if ((unsigned long )pvp == (unsigned long )((void *)0)) {
#line 3009
        if ((int )tTdvect[48] >= 2) {
          {
#line 3010
          sm_dprintf((char *)"rscheck: cannot prescan input\n");
          }
        }
#line 3016
        goto finis;
      }
#line 3018
      if ((flags & 2) != 0) {
#line 3019
        SuprErrs = 1;
      }
      {
#line 3020
      rewrite(pvp, rsno, 0, e, 1000);
      }
#line 3021
      if ((flags & 2) != 0) {
#line 3022
        SuprErrs = saveSuprErrs;
      }
#line 3023
      if ((unsigned long )*(pvp + 0) == (unsigned long )((void *)0)) {
#line 3027
        goto finis;
      } else
#line 3023
      if (((int )*(*(pvp + 0) + 0) & 255) != 150) {
#line 3027
        goto finis;
      } else
#line 3023
      if ((unsigned long )*(pvp + 1) == (unsigned long )((void *)0)) {
#line 3027
        goto finis;
      } else {
        {
#line 3023
        tmp___7 = strcmp((char const   *)*(pvp + 1), "error");
        }
#line 3023
        if (tmp___7 != 0) {
          {
#line 3023
          tmp___8 = strcmp((char const   *)*(pvp + 1), "discard");
          }
#line 3023
          if (tmp___8 != 0) {
#line 3027
            goto finis;
          }
        }
      }
      {
#line 3030
      tmp___12 = strcmp((char const   *)*(pvp + 1), "discard");
      }
#line 3030
      if (tmp___12 == 0) {
#line 3032
        if ((int )tTdvect[48] >= 2) {
          {
#line 3033
          sm_dprintf((char *)"rscheck: discard mailer selected\n");
          }
        }
#line 3034
        e->e_flags |= 16777216UL;
#line 3035
        discard = (bool volatile   )1;
      } else {
        {
#line 3037
        tmp___10 = strcmp((char const   *)*(pvp + 1), "error");
        }
#line 3037
        if (tmp___10 == 0) {
#line 3037
          if ((unsigned long )*(pvp + 2) != (unsigned long )((void *)0)) {
#line 3037
            if (((int )*(*(pvp + 2) + 0) & 255) == 151) {
#line 3037
              if ((unsigned long )*(pvp + 3) != (unsigned long )((void *)0)) {
                {
#line 3037
                tmp___11 = strcmp((char const   *)*(pvp + 3), "quarantine");
                }
#line 3037
                if (tmp___11 == 0) {
#line 3041
                  if ((unsigned long )*(pvp + 4) == (unsigned long )((void *)0)) {
                    {
#line 3044
                    e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, (char const   *)rwset);
                    }
                  } else
#line 3041
                  if (((int )*(*(pvp + 4) + 0) & 255) != 152) {
                    {
#line 3044
                    e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, (char const   *)rwset);
                    }
                  } else
#line 3041
                  if ((unsigned long )*(pvp + 5) == (unsigned long )((void *)0)) {
                    {
#line 3044
                    e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, (char const   *)rwset);
                    }
                  } else {
                    {
#line 3048
                    cataddr(pvp + 5, (char **)((void *)0), ubuf___0, (int )sizeof(ubuf___0),
                            ' ');
#line 3050
                    e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, (char const   *)(ubuf___0));
                    }
                  }
                  {
#line 3053
                  tmp___9 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 3053
                  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___9, e->e_quarmsg,
                                   (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                                   3054, SmHeapGroup);
#line 3055
                  quarantine = 1;
                  }
                } else {
#line 3037
                  goto _L___2;
                }
              } else {
#line 3037
                goto _L___2;
              }
            } else {
#line 3037
              goto _L___2;
            }
          } else {
#line 3037
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          {
#line 3059
          savelogusrerrs = LogUsrErrs;
#line 3063
          saveexitstat = ExitStat;
#line 3064
          LogUsrErrs = 0;
#line 3065
          buildaddr(pvp, & a1, 0, e);
#line 3066
          LogUsrErrs = savelogusrerrs;
#line 3067
          rstat = (int volatile   )ExitStat;
#line 3068
          ExitStat = saveexitstat;
          }
#line 3069
          if (! logged) {
#line 3071
            if ((flags & 4) != 0) {
              {
#line 3072
              markstats(e, & a1, 'r');
              }
            }
#line 3073
            logged = 1;
          }
        }
      }
#line 3077
      if (LogLevel > logl) {
#line 3083
        p = lbuf;
#line 3084
        if ((unsigned long )p2 != (unsigned long )((void *)0)) {
          {
#line 3086
          sm_snprintf(p, (size_t )(sizeof(lbuf) - (unsigned long )(p - lbuf)), ", arg2=%s",
                      p2);
#line 3089
          tmp___13 = strlen((char const   *)p);
#line 3089
          p += tmp___13;
          }
        }
#line 3092
        if ((unsigned long )host != (unsigned long )((void *)0)) {
#line 3093
          relay = host;
        } else {
          {
#line 3095
          relay = macvalue('_', e);
          }
        }
#line 3096
        if ((unsigned long )relay != (unsigned long )((void *)0)) {
          {
#line 3098
          sm_snprintf(p, (size_t )(sizeof(lbuf) - (unsigned long )(p - lbuf)), ", relay=%s",
                      relay);
#line 3100
          tmp___14 = strlen((char const   *)p);
#line 3100
          p += tmp___14;
          }
        }
#line 3102
        *p = (char )'\000';
#line 3103
        if (discard) {
          {
#line 3104
          sm_syslog(5, (char const   *)logid, "ruleset=%s, arg1=%s%s, discard", rwset,
                    p1, lbuf);
          }
        } else
#line 3107
        if (quarantine) {
          {
#line 3108
          sm_syslog(5, (char const   *)logid, "ruleset=%s, arg1=%s%s, quarantine=%s",
                    rwset, p1, lbuf, ubuf___0);
          }
        } else {
          {
#line 3112
          sm_syslog(5, (char const   *)logid, "ruleset=%s, arg1=%s%s, reject=%s",
                    rwset, p1, lbuf, MsgBuf);
          }
        }
      }
      finis: ;
#line 3119
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 3119
        tmp___15 = 1;
      } else {
        {
#line 3119
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                    3119, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 3119
        tmp___15 = 0;
        }
      }
    }
    {
#line 3119
    tmp___17 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 3119
    if (tmp___17 == 0) {
#line 3122
      if ((unsigned long )buf___16 != (unsigned long )(buf0)) {
        {
#line 3123
        sm_free_tagged((void *)buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                       3123);
        }
      }
#line 3124
      QuickAbort = saveQuickAbort;
    }
#line 2999
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3126
  if (_h.eh_state == 2) {
#line 3126
    if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 3126
      tmp___18 = 1;
    } else {
      {
#line 3126
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                  3126, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 3126
      tmp___18 = 0;
      }
    }
#line 3126
    SmExcHandler = _h.eh_parent;
#line 3126
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 3126
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else
#line 3126
  if (_h.eh_state == 0) {
#line 3126
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 3126
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else {
    {
#line 3126
    sm_exc_free(_h.eh_value);
    }
  }
#line 3128
  if (ExitStat == 0) {
#line 3128
    ExitStat = (int )rstat;
  } else
#line 3128
  if (ExitStat == 75) {
#line 3128
    ExitStat = (int )rstat;
  }
  {
#line 3131
  tmp___19 = __errno_location();
#line 3131
  *tmp___19 = 0;
  }
#line 3132
  if (rstat != (int volatile   )0) {
#line 3132
    if (QuickAbort) {
      {
#line 3133
      sm_exc_raisenew_x(& EtypeQuickAbort, 2);
      }
    }
  }
#line 3134
  return ((int )rstat);
}
}
#line 3155 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c"
int rscap(char *rwset , char *p1 , char *p2 , ENVELOPE *e , char ***pvp , char *pvpbuf ,
          int size ) 
{ 
  char * volatile  buf___16 ;
  size_t bufsize ;
  int volatile   rstat ;
  int rsno ;
  bool saveQuickAbort ;
  bool saveSuprErrs ;
  char buf0[2048] ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  SM_EXC_HANDLER_T _h ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 3167
  rstat = (int volatile   )0;
#line 3169
  saveQuickAbort = QuickAbort;
#line 3170
  saveSuprErrs = SuprErrs;
#line 3174
  if ((int )tTdvect[48] >= 2) {
#line 3175
    if ((unsigned long )p2 == (unsigned long )((void *)0)) {
#line 3175
      tmp = "(NULL)";
    } else {
#line 3175
      tmp = (char const   *)p2;
    }
    {
#line 3175
    sm_dprintf((char *)"rscap(%s, %s, %s)\n", rwset, p1, tmp);
    }
  }
#line 3178
  if ((unsigned long )pvp != (unsigned long )((void *)0)) {
#line 3179
    *pvp = (char **)((void *)0);
  }
  {
#line 3180
  rsno = strtorwset(rwset, (char **)((void *)0), 0);
  }
#line 3181
  if (rsno < 0) {
#line 3182
    return (69);
  }
#line 3184
  if ((unsigned long )p2 != (unsigned long )((void *)0)) {
    {
#line 3186
    tmp___0 = strlen((char const   *)p1);
#line 3186
    tmp___1 = strlen((char const   *)p2);
#line 3186
    bufsize = (tmp___0 + tmp___1) + 2U;
    }
#line 3187
    if ((unsigned long )bufsize > sizeof(buf0)) {
      {
#line 3188
      tmp___2 = sm_malloc_tagged_x(bufsize, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                                   3188, SmHeapGroup);
#line 3188
      buf___16 = (char */* volatile  */)tmp___2;
      }
    } else {
#line 3191
      buf___16 = (char */* volatile  */)(buf0);
#line 3192
      bufsize = (size_t )sizeof(buf0);
    }
    {
#line 3194
    sm_snprintf((char *)buf___16, bufsize, "%s%c%s", p1, 155, p2);
    }
  } else {
    {
#line 3198
    tmp___3 = strlen((char const   *)p1);
#line 3198
    bufsize = tmp___3 + 1U;
    }
#line 3199
    if ((unsigned long )bufsize > sizeof(buf0)) {
      {
#line 3200
      tmp___4 = sm_malloc_tagged_x(bufsize, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                                   3200, SmHeapGroup);
#line 3200
      buf___16 = (char */* volatile  */)tmp___4;
      }
    } else {
#line 3203
      buf___16 = (char */* volatile  */)(buf0);
#line 3204
      bufsize = (size_t )sizeof(buf0);
    }
    {
#line 3206
    sm_strlcpy((char *)buf___16, (char const   *)p1, (ssize_t )bufsize);
    }
  }
  {
#line 3208
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3208
    _h.eh_value = (SM_EXC_T *)((void *)0);
#line 3208
    _h.eh_parent = SmExcHandler;
#line 3208
    _h.eh_state = 2;
#line 3208
    SmExcHandler = & _h;
#line 3208
    tmp___7 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 3208
    if (tmp___7 == 0) {
      {
#line 3210
      SuprErrs = 1;
#line 3211
      QuickAbort = 0;
#line 3212
      *pvp = prescan((char *)buf___16, '\000', pvpbuf, size, (char **)((void *)0),
                     (unsigned char *)((void *)0), 0);
      }
#line 3213
      if ((unsigned long )*pvp != (unsigned long )((void *)0)) {
        {
#line 3214
        tmp___5 = rewrite(*pvp, rsno, 0, e, size);
#line 3214
        rstat = (int volatile   )tmp___5;
        }
      } else {
#line 3217
        if ((int )tTdvect[48] >= 2) {
          {
#line 3218
          sm_dprintf((char *)"rscap: cannot prescan input\n");
          }
        }
#line 3219
        rstat = (int volatile   )65;
      }
#line 3222
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 3222
        tmp___6 = 1;
      } else {
        {
#line 3222
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                    3222, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 3222
        tmp___6 = 0;
        }
      }
    }
    {
#line 3222
    tmp___8 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 3222
    if (tmp___8 == 0) {
#line 3225
      if ((unsigned long )buf___16 != (unsigned long )(buf0)) {
        {
#line 3226
        sm_free_tagged((void *)buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                       3226);
        }
      }
#line 3227
      SuprErrs = saveSuprErrs;
#line 3228
      QuickAbort = saveQuickAbort;
#line 3231
      MsgBuf[0] = (char )'\000';
    }
#line 3208
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3233
  if (_h.eh_state == 2) {
#line 3233
    if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 3233
      tmp___9 = 1;
    } else {
      {
#line 3233
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/parseaddr.c",
                  3233, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 3233
      tmp___9 = 0;
      }
    }
#line 3233
    SmExcHandler = _h.eh_parent;
#line 3233
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 3233
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else
#line 3233
  if (_h.eh_state == 0) {
#line 3233
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 3233
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else {
    {
#line 3233
    sm_exc_free(_h.eh_value);
    }
  }
#line 3234
  return ((int )rstat);
}
}
#line 1657 "./sendmail.h"
bool mime7to8(struct mailer_con_info *mci , HDR *header , ENVELOPE *e ) ;
#line 1658
int mime8to7(struct mailer_con_info *mci , HDR *header , ENVELOPE *e , char **boundaries ,
             int flags ) ;
#line 2471
char *defcharset(ENVELOPE *e ) ;
#line 42 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static int isboundary(char *line , char **boundaries ) ;
#line 43
static int mimeboundary(char *line , char **boundaries ) ;
#line 44
static int mime_getchar(SM_FILE_T *fp , char **boundaries , int *btp ) ;
#line 45
static int mime_getchar_crlf(SM_FILE_T *fp , char **boundaries , int *btp ) ;
#line 48 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static char Base16Code[17]  = 
#line 48
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'A',      (char )'B', 
        (char )'C',      (char )'D',      (char )'E',      (char )'F', 
        (char )'\000'};
#line 49 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static char Base64Code[65]  = 
#line 49
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/', 
        (char )'\000'};
#line 57 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static char *MimeBoundaryNames[4]  = {      (char *)"SYNTAX",      (char *)"NOTSEP",      (char *)"INTERMED",      (char *)"FINAL"};
#line 62 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static bool MapNLtoCRLF  ;
#line 98 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
int mime8to7(struct mailer_con_info *mci , HDR *header , ENVELOPE *e , char **boundaries ,
             int flags ) 
{ 
  register char *p ;
  int linelen ;
  int bt___0 ;
  off_t offset ;
  size_t sectionsize ;
  size_t sectionhighbits ;
  int i ;
  char *type ;
  char *subtype ;
  char *cte ;
  char **pvp ;
  int argc ;
  char *bp___3 ;
  bool use_qp ;
  struct args argv[20] ;
  char bbuf[128] ;
  char buf___16[2048] ;
  char pvpbuf[2048] ;
  char **tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char **tmp___3 ;
  int tmp___4 ;
  char **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  size_t tmp___15 ;
  bool tmp___16 ;
  size_t tmp___17 ;
  bool tmp___18 ;
  char *tmp___19 ;
  HDR *hdr ;
  bool tmp___20 ;
  bool tmp___21 ;
  bool tmp___22 ;
  size_t tmp___23 ;
  bool tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  HDR *hdr___0 ;
  bool tmp___27 ;
  bool tmp___28 ;
  char *tmp___29 ;
  bool tmp___30 ;
  bool tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  bool tmp___40 ;
  bool tmp___41 ;
  bool tmp___42 ;
  char *tmp___43 ;
  int c1 ;
  int c2 ;
  bool tmp___44 ;
  bool tmp___45 ;
  bool tmp___46 ;
  bool tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  bool tmp___57 ;
  int c1___0 ;
  int c2___0 ;
  int fromstate ;
  BITMAP256 badchars ;
  bool tmp___58 ;
  bool tmp___59 ;
  bool tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  bool tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  bool tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  bool tmp___81 ;
  void *__cil_tmp115 ;
  int __cil_tmp116 ;
  void *__cil_tmp117 ;
  void *__cil_tmp118 ;
  void *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;

  {
#line 116
  argc = 0;
#line 118
  use_qp = 0;
#line 125
  if ((int )tTdvect[43] >= 1) {
    {
#line 127
    sm_dprintf((char *)"mime8to7: flags = %x, boundaries =", flags);
    }
#line 128
    if ((unsigned long )*(boundaries + 0) == (unsigned long )((void *)0)) {
      {
#line 129
      sm_dprintf((char *)" <none>");
      }
    } else {
#line 132
      i = 0;
      {
#line 132
      while (1) {
        while_continue: /* CIL Label */ ;
#line 132
        if (! ((unsigned long )*(boundaries + i) != (unsigned long )((void *)0))) {
#line 132
          goto while_break;
        }
        {
#line 133
        sm_dprintf((char *)" %s", *(boundaries + i));
#line 132
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 135
    sm_dprintf((char *)"\n");
    }
  }
  {
#line 137
  MapNLtoCRLF = 1;
#line 138
  p = hvalue((char *)"Content-Transfer-Encoding", header);
  }
#line 139
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 144
    cte = (char *)((void *)0);
  } else {
    {
#line 139
    pvp = prescan(p, '\000', pvpbuf, (int )sizeof(pvpbuf), (char **)((void *)0), MimeTokenTab,
                  0);
    }
#line 139
    if ((unsigned long )pvp == (unsigned long )((void *)0)) {
#line 144
      cte = (char *)((void *)0);
    } else
#line 139
    if ((unsigned long )*(pvp + 0) == (unsigned long )((void *)0)) {
#line 144
      cte = (char *)((void *)0);
    } else {
      {
#line 148
      cataddr(pvp, (char **)((void *)0), buf___16, (int )sizeof(buf___16), '\000');
#line 149
      cte = sm_rpool_strdup_x(e->e_rpool, (char const   *)(buf___16));
      }
    }
  }
  {
#line 152
  subtype = (char *)((void *)0);
#line 152
  type = subtype;
#line 153
  p = hvalue((char *)"Content-Type", header);
  }
#line 154
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 156
    if ((flags & 2) != 0) {
#line 157
      p = (char *)"message/rfc822";
    } else {
#line 159
      p = (char *)"text/plain";
    }
  }
#line 161
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 161
    pvp = prescan(p, '\000', pvpbuf, (int )sizeof(pvpbuf), (char **)((void *)0), MimeTokenTab,
                  0);
    }
#line 161
    if ((unsigned long )pvp != (unsigned long )((void *)0)) {
#line 161
      if ((unsigned long )*(pvp + 0) != (unsigned long )((void *)0)) {
#line 166
        if ((int )tTdvect[43] >= 40) {
#line 168
          i = 0;
          {
#line 168
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 168
            if (! ((unsigned long )*(pvp + i) != (unsigned long )((void *)0))) {
#line 168
              goto while_break___0;
            }
            {
#line 169
            sm_dprintf((char *)"pvp[%d] = \"%s\"\n", i, *(pvp + i));
#line 168
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 171
        tmp = pvp;
#line 171
        pvp ++;
#line 171
        type = *tmp;
#line 172
        if ((unsigned long )*pvp != (unsigned long )((void *)0)) {
          {
#line 172
          tmp___1 = strcmp((char const   *)*pvp, "/");
          }
#line 172
          if (tmp___1 == 0) {
#line 172
            pvp ++;
#line 172
            if ((unsigned long )*pvp != (unsigned long )((void *)0)) {
#line 175
              tmp___0 = pvp;
#line 175
              pvp ++;
#line 175
              subtype = *tmp___0;
            }
          }
        }
        {
#line 179
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 179
          if ((unsigned long )*pvp != (unsigned long )((void *)0)) {
#line 179
            if (! (argc < 20)) {
#line 179
              goto while_break___1;
            }
          } else {
#line 179
            goto while_break___1;
          }
          {
#line 182
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 182
            if ((unsigned long )*pvp != (unsigned long )((void *)0)) {
              {
#line 182
              tmp___2 = strcmp((char const   *)*pvp, ";");
              }
#line 182
              if (! (tmp___2 != 0)) {
#line 182
                goto while_break___2;
              }
            } else {
#line 182
              goto while_break___2;
            }
#line 183
            pvp ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 184
          tmp___3 = pvp;
#line 184
          pvp ++;
#line 184
          if ((unsigned long )*tmp___3 == (unsigned long )((void *)0)) {
#line 185
            goto while_break___1;
          } else
#line 184
          if ((unsigned long )*pvp == (unsigned long )((void *)0)) {
#line 185
            goto while_break___1;
          }
          {
#line 188
          tmp___4 = strcmp((char const   *)*pvp, ";");
          }
#line 188
          if (tmp___4 == 0) {
            {
#line 190
            usrerr("mime8to7: Empty parameter in Content-Type header");
#line 193
            e->e_flags |= 8388608UL;
            }
#line 194
            goto while_continue___1;
          }
#line 198
          tmp___5 = pvp;
#line 198
          pvp ++;
#line 198
          argv[argc].a_field = *tmp___5;
#line 201
          if ((unsigned long )*pvp != (unsigned long )((void *)0)) {
            {
#line 201
            tmp___6 = strcmp((char const   *)*pvp, "=");
            }
#line 201
            if (tmp___6 == 0) {
#line 201
              pvp ++;
#line 201
              if ((unsigned long )*pvp == (unsigned long )((void *)0)) {
#line 204
                argv[argc].a_value = *pvp;
#line 205
                argc ++;
              } else {
                {
#line 201
                tmp___7 = strcmp((char const   *)*pvp, ";");
                }
#line 201
                if (tmp___7 != 0) {
#line 204
                  argv[argc].a_value = *pvp;
#line 205
                  argc ++;
                }
              }
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 211
  if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 212
    type = (char *)"-none-";
  }
#line 213
  if ((unsigned long )subtype == (unsigned long )((void *)0)) {
#line 214
    subtype = (char *)"-none-";
  }
  {
#line 217
  flags &= -3;
#line 227
  sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%.100s/%.100s", type, subtype);
#line 228
  tmp___8 = wordinclass(buf___16, 'n');
  }
#line 228
  if (tmp___8) {
#line 229
    flags |= 1;
  } else
#line 228
  if ((unsigned long )cte != (unsigned long )((void *)0)) {
    {
#line 228
    tmp___9 = wordinclass(cte, 'e');
    }
#line 228
    if (! tmp___9) {
#line 229
      flags |= 1;
    }
  }
  {
#line 235
  tmp___10 = wordinclass(buf___16, 'q');
  }
#line 235
  if (tmp___10) {
#line 236
    use_qp = 1;
  } else {
    {
#line 235
    tmp___11 = wordinclass(type, 'q');
    }
#line 235
    if (tmp___11) {
#line 236
      use_qp = 1;
    }
  }
  {
#line 244
  tmp___26 = sm_strcasecmp((char const   *)type, "multipart");
  }
#line 244
  if (tmp___26 == 0) {
#line 244
    if (! ((flags & 1) != 0)) {
#line 244
      goto _L___0;
    } else
#line 244
    if ((flags & 4) != 0) {
      _L___0: /* CIL Label */ 
      {
#line 248
      tmp___12 = sm_strcasecmp((char const   *)subtype, "digest");
      }
#line 248
      if (tmp___12 == 0) {
#line 249
        flags |= 2;
      }
#line 251
      i = 0;
      {
#line 251
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 251
        if (! (i < argc)) {
#line 251
          goto while_break___3;
        }
        {
#line 253
        tmp___13 = sm_strcasecmp((char const   *)argv[i].a_field, "boundary");
        }
#line 253
        if (tmp___13 == 0) {
#line 254
          goto while_break___3;
        }
#line 251
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 256
      if (i >= argc) {
#line 256
        goto _L;
      } else
#line 256
      if ((unsigned long )argv[i].a_value == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 258
        if (i >= argc) {
#line 258
          tmp___14 = "missing";
        } else {
#line 258
          tmp___14 = "bogus";
        }
        {
#line 258
        usrerr("mime8to7: Content-Type: \"%s\": %s boundary", tmp___14, p);
#line 260
        p = (char *)"---";
#line 263
        e->e_flags |= 8388608UL;
        }
      } else {
        {
#line 267
        p = argv[i].a_value;
#line 268
        stripquotes(p);
        }
      }
      {
#line 270
      tmp___15 = sm_strlcpy(bbuf, (char const   *)p, (ssize_t )sizeof(bbuf));
      }
#line 270
      if ((unsigned long )tmp___15 >= sizeof(bbuf)) {
        {
#line 272
        usrerr("mime8to7: multipart boundary \"%s\" too long", p);
#line 276
        e->e_flags |= 8388608UL;
        }
      }
#line 279
      if ((int )tTdvect[43] >= 1) {
        {
#line 280
        sm_dprintf((char *)"mime8to7: multipart boundary \"%s\"\n", bbuf);
        }
      }
#line 282
      i = 0;
      {
#line 282
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 282
        if (! (i < 20)) {
#line 282
          goto while_break___4;
        }
#line 284
        if ((unsigned long )*(boundaries + i) == (unsigned long )((void *)0)) {
#line 285
          goto while_break___4;
        }
#line 282
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 287
      if (i >= 20) {
        {
#line 289
        usrerr("mime8to7: multipart nesting boundary too deep");
#line 292
        e->e_flags |= 8388608UL;
        }
      } else {
#line 296
        *(boundaries + i) = bbuf;
#line 297
        *(boundaries + (i + 1)) = (char *)((void *)0);
      }
      {
#line 299
      mci->mci_flags |= 16384UL;
#line 302
      tmp___16 = putline((char *)"", mci);
      }
#line 302
      if (! tmp___16) {
#line 303
        goto writeerr;
      }
#line 304
      mci->mci_flags &= 0xfffffffffffffdffUL;
#line 305
      bt___0 = 3;
      {
#line 306
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 306
        tmp___19 = sm_io_fgets(e->e_dfp, -2, buf___16, (int )sizeof(buf___16));
        }
#line 306
        if (! ((unsigned long )tmp___19 != (unsigned long )((void *)0))) {
#line 306
          goto while_break___5;
        }
        {
#line 309
        bt___0 = mimeboundary(buf___16, boundaries);
        }
#line 310
        if (bt___0 != 1) {
#line 311
          goto while_break___5;
        }
        {
#line 312
        tmp___17 = strlen((char const   *)(buf___16));
#line 312
        tmp___18 = putxline(buf___16, tmp___17, mci, 3);
        }
#line 312
        if (! tmp___18) {
#line 314
          goto writeerr;
        }
#line 315
        if ((int )tTdvect[43] >= 99) {
          {
#line 316
          sm_dprintf((char *)"  ...%s", buf___16);
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 318
      if (((e->e_dfp)->f_flags & 128L) != 0L) {
#line 319
        bt___0 = 3;
      }
      {
#line 320
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 320
        if (! (bt___0 != 3)) {
#line 320
          goto while_break___6;
        }
        {
#line 322
        hdr = (HDR *)((void *)0);
#line 324
        sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, "--", bbuf);
#line 325
        tmp___20 = putline(buf___16, mci);
        }
#line 325
        if (! tmp___20) {
#line 326
          goto writeerr;
        }
#line 327
        if ((int )tTdvect[43] >= 35) {
          {
#line 328
          sm_dprintf((char *)"  ...%s\n", buf___16);
          }
        }
        {
#line 329
        collect(e->e_dfp, 0, & hdr, e, 0);
        }
#line 330
        if ((int )tTdvect[43] >= 101) {
          {
#line 331
          putline((char *)"+++after collect", mci);
          }
        }
        {
#line 332
        tmp___21 = putheader(mci, hdr, e, flags);
        }
#line 332
        if (! tmp___21) {
#line 333
          goto writeerr;
        }
#line 334
        if ((int )tTdvect[43] >= 101) {
          {
#line 335
          putline((char *)"+++after putheader", mci);
          }
        }
        {
#line 336
        bt___0 = mime8to7(mci, hdr, e, boundaries, flags);
        }
#line 337
        if (bt___0 == -1) {
#line 338
          goto writeerr;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 340
      sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 3, "--", bbuf, "--");
#line 341
      tmp___22 = putline(buf___16, mci);
      }
#line 341
      if (! tmp___22) {
#line 342
        goto writeerr;
      }
#line 343
      if ((int )tTdvect[43] >= 35) {
        {
#line 344
        sm_dprintf((char *)"  ...%s\n", buf___16);
        }
      }
#line 345
      *(boundaries + i) = (char *)((void *)0);
#line 346
      mci->mci_flags &= 0xffffffffffffbfffUL;
      {
#line 349
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 349
        tmp___25 = sm_io_fgets(e->e_dfp, -2, buf___16, (int )sizeof(buf___16));
        }
#line 349
        if (! ((unsigned long )tmp___25 != (unsigned long )((void *)0))) {
#line 349
          goto while_break___7;
        }
        {
#line 352
        bt___0 = mimeboundary(buf___16, boundaries);
        }
#line 353
        if (bt___0 != 1) {
#line 354
          goto while_break___7;
        }
        {
#line 355
        tmp___23 = strlen((char const   *)(buf___16));
#line 355
        tmp___24 = putxline(buf___16, tmp___23, mci, 3);
        }
#line 355
        if (! tmp___24) {
#line 357
          goto writeerr;
        }
#line 358
        if ((int )tTdvect[43] >= 99) {
          {
#line 359
          sm_dprintf((char *)"  ...%s", buf___16);
          }
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 361
      if (((e->e_dfp)->f_flags & 128L) != 0L) {
#line 362
        bt___0 = 3;
      }
#line 363
      if ((int )tTdvect[43] >= 3) {
        {
#line 364
        sm_dprintf((char *)"\t\t\tmime8to7=>%s (multipart)\n", MimeBoundaryNames[bt___0]);
        }
      }
#line 366
      return (bt___0);
    }
  }
  {
#line 375
  tmp___32 = sm_strcasecmp((char const   *)type, "message");
  }
#line 375
  if (tmp___32 == 0) {
    {
#line 377
    tmp___31 = wordinclass(subtype, 's');
    }
#line 377
    if (tmp___31) {
      {
#line 383
      hdr___0 = (HDR *)((void *)0);
#line 385
      tmp___27 = putline((char *)"", mci);
      }
#line 385
      if (! tmp___27) {
#line 386
        goto writeerr;
      }
      {
#line 388
      mci->mci_flags |= 16384UL;
#line 389
      collect(e->e_dfp, 0, & hdr___0, e, 0);
      }
#line 390
      if ((int )tTdvect[43] >= 101) {
        {
#line 391
        putline((char *)"+++after collect", mci);
        }
      }
      {
#line 392
      tmp___28 = putheader(mci, hdr___0, e, flags);
      }
#line 392
      if (! tmp___28) {
#line 393
        goto writeerr;
      }
#line 394
      if ((int )tTdvect[43] >= 101) {
        {
#line 395
        putline((char *)"+++after putheader", mci);
        }
      }
      {
#line 396
      tmp___29 = hvalue((char *)"MIME-Version", hdr___0);
      }
#line 396
      if ((unsigned long )tmp___29 == (unsigned long )((void *)0)) {
#line 396
        if (! ((flags & 4) != 0)) {
          {
#line 396
          tmp___30 = putline((char *)"MIME-Version: 1.0", mci);
          }
#line 396
          if (! tmp___30) {
#line 399
            goto writeerr;
          }
        }
      }
      {
#line 400
      bt___0 = mime8to7(mci, hdr___0, e, boundaries, flags);
#line 401
      mci->mci_flags &= 0xffffffffffffbfffUL;
      }
#line 402
      return (bt___0);
    } else {
#line 379
      flags |= 1;
    }
  }
#line 414
  sectionhighbits = (size_t )0;
#line 414
  sectionsize = sectionhighbits;
#line 415
  if (! ((flags & 5) != 0)) {
    {
#line 418
    offset = sm_io_tell(e->e_dfp, -2);
    }
#line 419
    if (offset == -1L) {
      {
#line 420
      syserr("mime8to7: cannot sm_io_tell on %cf%s", 'd', e->e_id);
      }
    }
    {
#line 424
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 424
      tmp___34 = sm_io_fgets(e->e_dfp, -2, buf___16, (int )sizeof(buf___16));
      }
#line 424
      if (! ((unsigned long )tmp___34 != (unsigned long )((void *)0))) {
#line 424
        goto while_break___8;
      }
      {
#line 427
      tmp___33 = mimeboundary(buf___16, boundaries);
      }
#line 427
      if (tmp___33 != 1) {
#line 428
        goto while_break___8;
      }
#line 429
      p = buf___16;
      {
#line 429
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 429
        if (! ((int )*p != 0)) {
#line 429
          goto while_break___9;
        }
#line 432
        sectionsize ++;
#line 433
        if (((int )*p & 128) != 0) {
#line 434
          sectionhighbits ++;
        }
#line 429
        p ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 443
      if (sectionsize >= 4096U) {
#line 443
        if (sectionhighbits > sectionsize / 4U) {
#line 445
          goto while_break___8;
        }
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 450
    tmp___35 = sm_io_seek(e->e_dfp, -2, offset, 0);
    }
#line 450
    if (tmp___35 < 0) {
      {
#line 451
      syserr("mime8to7: cannot sm_io_fseek on %cf%s", 'd', e->e_id);
      }
    } else {
#line 454
      (e->e_dfp)->f_flags &= -385L;
    }
  }
#line 465
  if ((int )tTdvect[43] >= 8) {
#line 467
    if ((unsigned long )subtype == (unsigned long )((void *)0)) {
#line 467
      tmp___36 = "[none]";
    } else {
#line 467
      tmp___36 = (char const   *)subtype;
    }
#line 467
    if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 467
      tmp___37 = "[none]";
    } else {
#line 467
      tmp___37 = (char const   *)type;
    }
#line 467
    if ((unsigned long )cte == (unsigned long )((void *)0)) {
#line 467
      tmp___38 = "[none]";
    } else {
#line 467
      tmp___38 = (char const   *)cte;
    }
    {
#line 467
    sm_dprintf((char *)"mime8to7: %ld high bit(s) in %ld byte(s), cte=%s, type=%s/%s\n",
               (long )sectionhighbits, (long )sectionsize, tmp___38, tmp___37, tmp___36);
    }
  }
#line 473
  if ((unsigned long )cte != (unsigned long )((void *)0)) {
    {
#line 473
    tmp___39 = sm_strcasecmp((char const   *)cte, "binary");
    }
#line 473
    if (tmp___39 == 0) {
#line 474
      sectionsize = sectionhighbits;
    }
  }
#line 475
  linelen = 0;
#line 476
  bp___3 = buf___16;
#line 477
  if (sectionhighbits == 0U) {
#line 480
    if ((unsigned long )cte != (unsigned long )((void *)0)) {
#line 480
      if ((mci->mci_flags & 25600UL) != 0UL) {
#line 480
        if (! ((flags & 4) != 0)) {
          {
#line 493
          sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Content-Transfer-Encoding: %.200s",
                      cte);
#line 495
          tmp___40 = putline(buf___16, mci);
          }
#line 495
          if (! tmp___40) {
#line 496
            goto writeerr;
          }
#line 497
          if ((int )tTdvect[43] >= 36) {
            {
#line 498
            sm_dprintf((char *)"  ...%s\n", buf___16);
            }
          }
        }
      }
    }
    {
#line 500
    tmp___41 = putline((char *)"", mci);
    }
#line 500
    if (! tmp___41) {
#line 501
      goto writeerr;
    }
#line 502
    mci->mci_flags &= 0xfffffffffffffdffUL;
    {
#line 503
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 503
      tmp___43 = sm_io_fgets(e->e_dfp, -2, buf___16, (int )sizeof(buf___16));
      }
#line 503
      if (! ((unsigned long )tmp___43 != (unsigned long )((void *)0))) {
#line 503
        goto while_break___10;
      }
      {
#line 506
      bt___0 = mimeboundary(buf___16, boundaries);
      }
#line 507
      if (bt___0 != 1) {
#line 508
        goto while_break___10;
      }
      {
#line 509
      tmp___42 = putline(buf___16, mci);
      }
#line 509
      if (! tmp___42) {
#line 510
        goto writeerr;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 512
    if (((e->e_dfp)->f_flags & 128L) != 0L) {
#line 513
      bt___0 = 3;
    }
  } else
#line 515
  if (! MapNLtoCRLF) {
#line 515
    goto _L___8;
  } else
#line 515
  if (sectionsize / 8U < sectionhighbits) {
#line 515
    if (! use_qp) {
      _L___8: /* CIL Label */ 
#line 521
      if ((int )tTdvect[43] >= 36) {
        {
#line 522
        sm_dprintf((char *)"  ...Content-Transfer-Encoding: base64\n");
        }
      }
      {
#line 523
      tmp___44 = putline((char *)"Content-Transfer-Encoding: base64", mci);
      }
#line 523
      if (! tmp___44) {
#line 524
        goto writeerr;
      }
      {
#line 525
      sm_snprintf(buf___16, (size_t )sizeof(buf___16), "X-MIME-Autoconverted: from 8bit to base64 by %s id %s",
                  MyHostName, e->e_id);
#line 528
      tmp___45 = putline(buf___16, mci);
      }
#line 528
      if (tmp___45) {
        {
#line 528
        tmp___46 = putline((char *)"", mci);
        }
#line 528
        if (! tmp___46) {
#line 529
          goto writeerr;
        }
      } else {
#line 529
        goto writeerr;
      }
#line 530
      mci->mci_flags &= 0xfffffffffffffdffUL;
      {
#line 531
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 531
        c1 = mime_getchar_crlf(e->e_dfp, boundaries, & bt___0);
        }
#line 531
        if (! (c1 != -1)) {
#line 531
          goto while_break___11;
        }
#line 534
        if (linelen > 71) {
          {
#line 536
          *bp___3 = (char )'\000';
#line 537
          tmp___47 = putline(buf___16, mci);
          }
#line 537
          if (! tmp___47) {
#line 538
            goto writeerr;
          }
#line 539
          linelen = 0;
#line 540
          bp___3 = buf___16;
        }
        {
#line 542
        linelen += 4;
#line 543
        tmp___48 = bp___3;
#line 543
        bp___3 ++;
#line 543
        *tmp___48 = Base64Code[c1 >> 2];
#line 544
        c1 = (c1 & 3) << 4;
#line 545
        c2 = mime_getchar_crlf(e->e_dfp, boundaries, & bt___0);
        }
#line 546
        if (c2 == -1) {
#line 548
          tmp___49 = bp___3;
#line 548
          bp___3 ++;
#line 548
          *tmp___49 = Base64Code[c1];
#line 549
          tmp___50 = bp___3;
#line 549
          bp___3 ++;
#line 549
          *tmp___50 = (char )'=';
#line 550
          tmp___51 = bp___3;
#line 550
          bp___3 ++;
#line 550
          *tmp___51 = (char )'=';
#line 551
          goto while_break___11;
        }
        {
#line 553
        c1 |= (c2 >> 4) & 15;
#line 554
        tmp___52 = bp___3;
#line 554
        bp___3 ++;
#line 554
        *tmp___52 = Base64Code[c1];
#line 555
        c1 = (c2 & 15) << 2;
#line 556
        c2 = mime_getchar_crlf(e->e_dfp, boundaries, & bt___0);
        }
#line 557
        if (c2 == -1) {
#line 559
          tmp___53 = bp___3;
#line 559
          bp___3 ++;
#line 559
          *tmp___53 = Base64Code[c1];
#line 560
          tmp___54 = bp___3;
#line 560
          bp___3 ++;
#line 560
          *tmp___54 = (char )'=';
#line 561
          goto while_break___11;
        }
#line 563
        c1 |= (c2 >> 6) & 3;
#line 564
        tmp___55 = bp___3;
#line 564
        bp___3 ++;
#line 564
        *tmp___55 = Base64Code[c1];
#line 565
        tmp___56 = bp___3;
#line 565
        bp___3 ++;
#line 565
        *tmp___56 = Base64Code[c2 & 63];
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 567
      *bp___3 = (char )'\000';
#line 568
      tmp___57 = putline(buf___16, mci);
      }
#line 568
      if (! tmp___57) {
#line 569
        goto writeerr;
      }
    } else {
#line 515
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ 
    {
#line 579
    memset((void *)((char *)(badchars)), '\000', (size_t )32);
#line 580
    c1___0 = 0;
    }
    {
#line 580
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 580
      if (! (c1___0 < 32)) {
#line 580
        goto while_break___12;
      }
#line 581
      badchars[(unsigned long )((unsigned char )c1___0) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )c1___0) % (8UL * sizeof(int ));
#line 580
      c1___0 ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 582
    badchars[9UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] &= ~ (1U << 9UL % (8UL * sizeof(int )));
#line 583
    c1___0 = 127;
    {
#line 583
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 583
      if (! (c1___0 < 256)) {
#line 583
        goto while_break___13;
      }
#line 584
      badchars[(unsigned long )((unsigned char )c1___0) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )c1___0) % (8UL * sizeof(int ));
#line 583
      c1___0 ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 585
    badchars[61UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 61UL % (8UL * sizeof(int ));
#line 586
    if ((mci->mci_mailer)->m_flags[51UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 51UL % (8UL * sizeof(int )))) {
#line 587
      p = (char *)"!\"#$@[\\]^`{|}~";
      {
#line 587
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 587
        if (! ((int )*p != 0)) {
#line 587
          goto while_break___14;
        }
#line 588
        badchars[(unsigned long )((unsigned char )*p) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )*p) % (8UL * sizeof(int ));
#line 587
        p ++;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 590
    if ((int )tTdvect[43] >= 36) {
      {
#line 591
      sm_dprintf((char *)"  ...Content-Transfer-Encoding: quoted-printable\n");
      }
    }
    {
#line 592
    tmp___58 = putline((char *)"Content-Transfer-Encoding: quoted-printable", mci);
    }
#line 592
    if (! tmp___58) {
#line 594
      goto writeerr;
    }
    {
#line 595
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "X-MIME-Autoconverted: from 8bit to quoted-printable by %s id %s",
                MyHostName, e->e_id);
#line 598
    tmp___59 = putline(buf___16, mci);
    }
#line 598
    if (tmp___59) {
      {
#line 598
      tmp___60 = putline((char *)"", mci);
      }
#line 598
      if (! tmp___60) {
#line 599
        goto writeerr;
      }
    } else {
#line 599
      goto writeerr;
    }
#line 600
    mci->mci_flags &= 0xfffffffffffffdffUL;
#line 601
    fromstate = 0;
#line 602
    c2___0 = '\n';
    {
#line 603
    while (1) {
      while_continue___15: /* CIL Label */ ;
      {
#line 603
      c1___0 = mime_getchar(e->e_dfp, boundaries, & bt___0);
      }
#line 603
      if (! (c1___0 != -1)) {
#line 603
        goto while_break___15;
      }
#line 606
      if (c1___0 == 10) {
#line 608
        if (c2___0 == 32) {
#line 608
          goto _L___1;
        } else
#line 608
        if (c2___0 == 9) {
          _L___1: /* CIL Label */ 
#line 610
          tmp___61 = bp___3;
#line 610
          bp___3 ++;
#line 610
          *tmp___61 = (char )'=';
#line 611
          tmp___62 = bp___3;
#line 611
          bp___3 ++;
#line 611
          *tmp___62 = Base16Code[(c2___0 >> 4) & 15];
#line 612
          tmp___63 = bp___3;
#line 612
          bp___3 ++;
#line 612
          *tmp___63 = Base16Code[c2___0 & 15];
        }
#line 614
        if ((int )buf___16[0] == 46) {
#line 614
          if ((unsigned long )bp___3 == (unsigned long )(& buf___16[1])) {
#line 616
            buf___16[0] = (char )'=';
#line 617
            tmp___64 = bp___3;
#line 617
            bp___3 ++;
#line 617
            *tmp___64 = Base16Code[(46 >> 4) & 15];
#line 618
            tmp___65 = bp___3;
#line 618
            bp___3 ++;
#line 618
            *tmp___65 = Base16Code[14];
          }
        }
        {
#line 620
        *bp___3 = (char )'\000';
#line 621
        tmp___66 = putline(buf___16, mci);
        }
#line 621
        if (! tmp___66) {
#line 622
          goto writeerr;
        }
#line 623
        fromstate = 0;
#line 623
        linelen = fromstate;
#line 624
        bp___3 = buf___16;
#line 625
        c2___0 = c1___0;
#line 626
        goto while_continue___15;
      }
#line 628
      if (c2___0 == 32) {
#line 628
        if (linelen == 4) {
#line 628
          if (fromstate == 4) {
#line 628
            if ((mci->mci_mailer)->m_flags[69UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 69UL % (8UL * sizeof(int )))) {
#line 631
              tmp___67 = bp___3;
#line 631
              bp___3 ++;
#line 631
              *tmp___67 = (char )'=';
#line 632
              tmp___68 = bp___3;
#line 632
              bp___3 ++;
#line 632
              *tmp___68 = (char )'2';
#line 633
              tmp___69 = bp___3;
#line 633
              bp___3 ++;
#line 633
              *tmp___69 = (char )'0';
#line 634
              linelen += 3;
            } else {
#line 628
              goto _L___4;
            }
          } else {
#line 628
            goto _L___4;
          }
        } else {
#line 628
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 636
      if (c2___0 == 32) {
#line 638
        tmp___70 = bp___3;
#line 638
        bp___3 ++;
#line 638
        *tmp___70 = (char )c2___0;
#line 639
        linelen ++;
      } else
#line 636
      if (c2___0 == 9) {
#line 638
        tmp___70 = bp___3;
#line 638
        bp___3 ++;
#line 638
        *tmp___70 = (char )c2___0;
#line 639
        linelen ++;
      }
#line 641
      if (linelen > 72) {
#line 641
        if (linelen > 75) {
#line 641
          goto _L___5;
        } else
#line 641
        if (c1___0 != 46) {
#line 641
          goto _L___5;
        } else
#line 641
        if (linelen > 73) {
#line 641
          if (c2___0 == 46) {
            _L___5: /* CIL Label */ 
#line 645
            if (linelen > 73) {
#line 645
              if (c2___0 == 46) {
#line 646
                bp___3 --;
              } else {
#line 648
                c2___0 = '\n';
              }
            } else {
#line 648
              c2___0 = '\n';
            }
            {
#line 649
            tmp___71 = bp___3;
#line 649
            bp___3 ++;
#line 649
            *tmp___71 = (char )'=';
#line 650
            *bp___3 = (char )'\000';
#line 651
            tmp___72 = putline(buf___16, mci);
            }
#line 651
            if (! tmp___72) {
#line 652
              goto writeerr;
            }
#line 653
            fromstate = 0;
#line 653
            linelen = fromstate;
#line 654
            bp___3 = buf___16;
#line 655
            if (c2___0 == 46) {
#line 657
              tmp___73 = bp___3;
#line 657
              bp___3 ++;
#line 657
              *tmp___73 = (char )'.';
#line 658
              linelen ++;
            }
          }
        }
      }
#line 661
      if (badchars[(unsigned long )((unsigned char )((unsigned int )c1___0 & 255U)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )((unsigned int )c1___0 & 255U)) % (8UL * sizeof(int )))) {
#line 663
        tmp___74 = bp___3;
#line 663
        bp___3 ++;
#line 663
        *tmp___74 = (char )'=';
#line 664
        tmp___75 = bp___3;
#line 664
        bp___3 ++;
#line 664
        *tmp___75 = Base16Code[(c1___0 >> 4) & 15];
#line 665
        tmp___76 = bp___3;
#line 665
        bp___3 ++;
#line 665
        *tmp___76 = Base16Code[c1___0 & 15];
#line 666
        linelen += 3;
      } else
#line 668
      if (c1___0 != 32) {
#line 668
        if (c1___0 != 9) {
#line 670
          if (linelen < 4) {
#line 670
            if (c1___0 == (int )*("From" + linelen)) {
#line 671
              fromstate ++;
            }
          }
#line 672
          tmp___77 = bp___3;
#line 672
          bp___3 ++;
#line 672
          *tmp___77 = (char )c1___0;
#line 673
          linelen ++;
        }
      }
#line 675
      c2___0 = c1___0;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 679
    if (c2___0 == 32) {
#line 679
      goto _L___6;
    } else
#line 679
    if (c2___0 == 9) {
      _L___6: /* CIL Label */ 
#line 681
      tmp___78 = bp___3;
#line 681
      bp___3 ++;
#line 681
      *tmp___78 = (char )'=';
#line 682
      tmp___79 = bp___3;
#line 682
      bp___3 ++;
#line 682
      *tmp___79 = Base16Code[(c2___0 >> 4) & 15];
#line 683
      tmp___80 = bp___3;
#line 683
      bp___3 ++;
#line 683
      *tmp___80 = Base16Code[c2___0 & 15];
#line 684
      linelen += 3;
    }
#line 687
    if (linelen > 0) {
#line 687
      goto _L___7;
    } else
#line 687
    if ((unsigned long )*(boundaries + 0) != (unsigned long )((void *)0)) {
      _L___7: /* CIL Label */ 
      {
#line 689
      *bp___3 = (char )'\000';
#line 690
      tmp___81 = putline(buf___16, mci);
      }
#line 690
      if (! tmp___81) {
#line 691
        goto writeerr;
      }
    }
  }
#line 695
  if ((int )tTdvect[43] >= 3) {
    {
#line 696
    sm_dprintf((char *)"\t\t\tmime8to7=>%s (basic)\n", MimeBoundaryNames[bt___0]);
    }
  }
#line 697
  return (bt___0);
  writeerr: 
#line 700
  return (-1);
}
}
#line 724 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static unsigned char *bp___2  =    (unsigned char *)((void *)0);
#line 725 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static int buflen  =    0;
#line 726 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static bool atbol  =    1;
#line 727 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static int bt  =    0;
#line 728 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static unsigned char buf___7[128]  ;
#line 717 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static int mime_getchar(SM_FILE_T *fp , char **boundaries , int *btp ) 
{ 
  int c ;
  int start ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;

  {
#line 729
  start = 0;
#line 731
  if (buflen == 1) {
#line 731
    if ((int )*bp___2 == 10) {
#line 734
      c = (int )*bp___2;
    } else {
#line 731
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 736
  if (buflen > 0) {
#line 738
    buflen --;
#line 739
    tmp = bp___2;
#line 739
    bp___2 ++;
#line 739
    return ((int )*tmp);
  } else {
    {
#line 742
    c = sm_io_getc(fp, -2);
    }
  }
#line 743
  bp___2 = buf___7;
#line 744
  buflen = 0;
#line 745
  if (c == 10) {
    {
#line 748
    tmp___0 = bp___2;
#line 748
    bp___2 ++;
#line 748
    *tmp___0 = (unsigned char )c;
#line 749
    atbol = 1;
#line 750
    c = sm_io_getc(fp, -2);
    }
#line 751
    if (c == 10) {
      {
#line 753
      sm_io_ungetc(fp, -2, c);
      }
#line 754
      return (c);
    }
#line 756
    start = 1;
  }
#line 758
  if (c != -1) {
#line 759
    tmp___1 = bp___2;
#line 759
    bp___2 ++;
#line 759
    *tmp___1 = (unsigned char )c;
  } else {
#line 761
    bt = 3;
  }
#line 762
  if (atbol) {
#line 762
    if (c == 45) {
      {
#line 765
      c = sm_io_getc(fp, -2);
      }
#line 766
      if (c != 45) {
#line 768
        if (c != -1) {
#line 769
          tmp___2 = bp___2;
#line 769
          bp___2 ++;
#line 769
          *tmp___2 = (unsigned char )c;
        } else {
#line 771
          bt = 3;
        }
#line 772
        buflen = (int )((bp___2 - buf___7) - 1L);
#line 773
        bp___2 = buf___7;
#line 774
        tmp___3 = bp___2;
#line 774
        bp___2 ++;
#line 774
        return ((int )*tmp___3);
      }
#line 778
      tmp___4 = bp___2;
#line 778
      bp___2 ++;
#line 778
      *tmp___4 = (unsigned char )'-';
      {
#line 779
      while (1) {
        while_continue: /* CIL Label */ ;
#line 779
        if ((unsigned long )bp___2 < (unsigned long )(& buf___7[sizeof(buf___7) - 2UL])) {
          {
#line 779
          c = sm_io_getc(fp, -2);
          }
#line 779
          if (c != -1) {
#line 779
            if (! (c != 10)) {
#line 779
              goto while_break;
            }
          } else {
#line 779
            goto while_break;
          }
        } else {
#line 779
          goto while_break;
        }
#line 783
        tmp___5 = bp___2;
#line 783
        bp___2 ++;
#line 783
        *tmp___5 = (unsigned char )c;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 785
      *bp___2 = (unsigned char )'\000';
#line 786
      bt = mimeboundary((char *)(& buf___7[start]), boundaries);
      }
      {
#line 790
      if (bt == 2) {
#line 790
        goto case_2;
      }
#line 790
      if (bt == 3) {
#line 790
        goto case_2;
      }
#line 787
      goto switch_break;
      case_2: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 792
      buflen = 0;
#line 793
      *btp = bt;
#line 794
      return (-1);
      switch_break: /* CIL Label */ ;
      }
#line 797
      if ((unsigned long )bp___2 < (unsigned long )(& buf___7[sizeof(buf___7) - 2UL])) {
#line 797
        if (c != -1) {
#line 798
          tmp___6 = bp___2;
#line 798
          bp___2 ++;
#line 798
          *tmp___6 = (unsigned char )c;
        }
      }
    }
  }
#line 801
  atbol = c == 10;
#line 802
  buflen = (int )((bp___2 - buf___7) - 1L);
#line 803
  if (buflen < 0) {
#line 805
    *btp = bt;
#line 806
    return (-1);
  }
#line 808
  bp___2 = buf___7;
#line 809
  tmp___7 = bp___2;
#line 809
  bp___2 ++;
#line 809
  return ((int )*tmp___7);
}
}
#line 830 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static bool sendlf  =    0;
#line 824 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static int mime_getchar_crlf(SM_FILE_T *fp , char **boundaries , int *btp ) 
{ 
  int c ;

  {
#line 833
  if (sendlf) {
#line 835
    sendlf = 0;
#line 836
    return ('\n');
  }
  {
#line 838
  c = mime_getchar(fp, boundaries, btp);
  }
#line 839
  if (c == 10) {
#line 839
    if (MapNLtoCRLF) {
#line 841
      sendlf = 1;
#line 842
      return ('\r');
    }
  }
#line 844
  return (c);
}
}
#line 861 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static int mimeboundary(char *line , char **boundaries ) 
{ 
  int type ;
  int i ;
  int savec ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 866
  type = 1;
#line 870
  if ((int )*(line + 0) != 45) {
#line 871
    return (1);
  } else
#line 870
  if ((int )*(line + 1) != 45) {
#line 871
    return (1);
  } else
#line 870
  if ((unsigned long )boundaries == (unsigned long )((void *)0)) {
#line 871
    return (1);
  }
  {
#line 872
  tmp = strlen((char const   *)line);
#line 872
  i = (int )tmp;
  }
#line 873
  if (i > 0) {
#line 873
    if ((int )*(line + (i - 1)) == 10) {
#line 874
      i --;
    }
  }
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    if (i > 0) {
#line 877
      if (! ((int )*(line + (i - 1)) == 32)) {
#line 877
        if (! ((int )*(line + (i - 1)) == 9)) {
#line 877
          goto while_break;
        }
      }
    } else {
#line 877
      goto while_break;
    }
#line 882
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  savec = (int )*(line + i);
#line 884
  *(line + i) = (char )'\000';
#line 886
  if ((int )tTdvect[43] >= 5) {
    {
#line 887
    sm_dprintf((char *)"mimeboundary: line=\"%s\"... ", line);
    }
  }
  {
#line 890
  tmp___2 = isboundary(line + 2, boundaries);
  }
#line 890
  if (tmp___2 >= 0) {
#line 891
    type = 2;
  } else
#line 892
  if (i > 2) {
    {
#line 892
    tmp___1 = strncmp((char const   *)(line + (i - 2)), "--", (size_t )2);
    }
#line 892
    if (tmp___1 == 0) {
      {
#line 895
      *(line + (i - 2)) = (char )'\000';
#line 896
      tmp___0 = isboundary(line + 2, boundaries);
      }
#line 896
      if (tmp___0 >= 0) {
#line 897
        type = 3;
      }
#line 898
      *(line + (i - 2)) = (char )'-';
    }
  }
#line 901
  *(line + i) = (char )savec;
#line 902
  if ((int )tTdvect[43] >= 5) {
    {
#line 903
    sm_dprintf((char *)"%s\n", MimeBoundaryNames[type]);
    }
  }
#line 904
  return (type);
}
}
#line 922 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
char *defcharset(ENVELOPE *e ) 
{ 
  char *__cil_tmp2 ;

  {
#line 926
  if ((unsigned long )e != (unsigned long )((void *)0)) {
#line 926
    if ((unsigned long )e->e_from.q_mailer != (unsigned long )((void *)0)) {
#line 926
      if ((unsigned long )(e->e_from.q_mailer)->m_defcharset != (unsigned long )((void *)0)) {
#line 928
        return ((e->e_from.q_mailer)->m_defcharset);
      }
    }
  }
#line 929
  if ((unsigned long )DefaultCharSet != (unsigned long )((void *)0)) {
#line 930
    return (DefaultCharSet);
  }
#line 931
  return ((char *)"unknown-8bit");
}
}
#line 946 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static int isboundary(char *line , char **boundaries ) 
{ 
  register int i ;
  int tmp ;

  {
#line 953
  i = 0;
  {
#line 953
  while (1) {
    while_continue: /* CIL Label */ ;
#line 953
    if (i <= 20) {
#line 953
      if (! ((unsigned long )*(boundaries + i) != (unsigned long )((void *)0))) {
#line 953
        goto while_break;
      }
    } else {
#line 953
      goto while_break;
    }
    {
#line 955
    tmp = strcmp((char const   *)line, (char const   *)*(boundaries + i));
    }
#line 955
    if (tmp == 0) {
#line 956
      return (i);
    }
#line 953
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 958
  return (-1);
}
}
#line 963
static int mime_fromqp(unsigned char *infile , unsigned char **outfile , int maxlen ) ;
#line 990 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static char index_64[128]  = 
#line 990
  {      (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)62, 
        (char)-1,      (char)-1,      (char)-1,      (char)63, 
        (char)52,      (char)53,      (char)54,      (char)55, 
        (char)56,      (char)57,      (char)58,      (char)59, 
        (char)60,      (char)61,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)0,      (char)1,      (char)2, 
        (char)3,      (char)4,      (char)5,      (char)6, 
        (char)7,      (char)8,      (char)9,      (char)10, 
        (char)11,      (char)12,      (char)13,      (char)14, 
        (char)15,      (char)16,      (char)17,      (char)18, 
        (char)19,      (char)20,      (char)21,      (char)22, 
        (char)23,      (char)24,      (char)25,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)26,      (char)27,      (char)28, 
        (char)29,      (char)30,      (char)31,      (char)32, 
        (char)33,      (char)34,      (char)35,      (char)36, 
        (char)37,      (char)38,      (char)39,      (char)40, 
        (char)41,      (char)42,      (char)43,      (char)44, 
        (char)45,      (char)46,      (char)47,      (char)48, 
        (char)49,      (char)50,      (char)51,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1};
#line 1004 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
bool mime7to8(struct mailer_con_info *mci , HDR *header , ENVELOPE *e ) 
{ 
  int pxflags ;
  register char *p ;
  char *cte ;
  char **pvp ;
  unsigned char *fbufp ;
  char buf___16[2048] ;
  unsigned char fbuf[2049] ;
  char pvpbuf[2048] ;
  char const   *tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  char *tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  int c1 ;
  int c2 ;
  int c3 ;
  int c4 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  bool tmp___11 ;
  unsigned char *tmp___12 ;
  bool tmp___13 ;
  unsigned char *tmp___14 ;
  bool tmp___15 ;
  unsigned char *tmp___16 ;
  int off ;
  bool tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  bool tmp___20 ;
  bool tmp___21 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
  {
#line 1020
  p = hvalue((char *)"Content-Transfer-Encoding", header);
  }
#line 1021
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1021
    goto _L;
  } else {
    {
#line 1021
    pvp = prescan(p, '\000', pvpbuf, (int )sizeof(pvpbuf), (char **)((void *)0), MimeTokenTab,
                  0);
    }
#line 1021
    if ((unsigned long )pvp == (unsigned long )((void *)0)) {
#line 1021
      goto _L;
    } else
#line 1021
    if ((unsigned long )*(pvp + 0) == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 1027
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1027
        tmp = "<NULL>";
      } else {
#line 1027
        tmp = (char const   *)p;
      }
      {
#line 1027
      syserr("mime7to8: unparsable CTE %s", tmp);
#line 1030
      e->e_flags |= 8388608UL;
      }
#line 1033
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 1035
        sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Content-Transfer-Encoding: %s",
                    p);
#line 1037
        tmp___0 = putline(buf___16, mci);
        }
#line 1037
        if (! tmp___0) {
#line 1038
          goto writeerr;
        }
      }
      {
#line 1040
      tmp___1 = putline((char *)"", mci);
      }
#line 1040
      if (! tmp___1) {
#line 1041
        goto writeerr;
      }
#line 1042
      mci->mci_flags &= 0xfffffffffffffdffUL;
      {
#line 1043
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1043
        tmp___3 = sm_io_fgets(e->e_dfp, -2, buf___16, (int )sizeof(buf___16));
        }
#line 1043
        if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 1043
          goto while_break;
        }
        {
#line 1046
        tmp___2 = putline(buf___16, mci);
        }
#line 1046
        if (! tmp___2) {
#line 1047
          goto writeerr;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1049
      return (1);
    }
  }
  {
#line 1051
  cataddr(pvp, (char **)((void *)0), buf___16, (int )sizeof(buf___16), '\000');
#line 1052
  cte = sm_rpool_strdup_x(e->e_rpool, (char const   *)(buf___16));
#line 1054
  mci->mci_flags |= 512UL;
#line 1055
  tmp___4 = putline((char *)"Content-Transfer-Encoding: 8bit", mci);
  }
#line 1055
  if (! tmp___4) {
#line 1056
    goto writeerr;
  }
  {
#line 1057
  sm_snprintf(buf___16, (size_t )sizeof(buf___16), "X-MIME-Autoconverted: from %.200s to 8bit by %s id %s",
              cte, MyHostName, e->e_id);
#line 1060
  tmp___5 = putline(buf___16, mci);
  }
#line 1060
  if (tmp___5) {
    {
#line 1060
    tmp___6 = putline((char *)"", mci);
    }
#line 1060
    if (! tmp___6) {
#line 1061
      goto writeerr;
    }
  } else {
#line 1061
    goto writeerr;
  }
  {
#line 1062
  mci->mci_flags &= 0xfffffffffffffdffUL;
#line 1070
  pxflags = 1;
#line 1071
  tmp___19 = sm_strcasecmp((char const   *)cte, "base64");
  }
#line 1071
  if (tmp___19 == 0) {
#line 1075
    fbufp = fbuf;
    {
#line 1076
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1076
      c1 = sm_io_getc(e->e_dfp, -2);
      }
#line 1076
      if (! (c1 != -1)) {
#line 1076
        goto while_break___0;
      }
#line 1079
      if ((c1 & -128) == 0) {
        {
#line 1079
        tmp___7 = __ctype_b_loc();
        }
#line 1079
        if ((int const   )*(*tmp___7 + c1) & 8192) {
#line 1080
          goto while_continue___0;
        }
      }
      {
#line 1082
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1084
        c2 = sm_io_getc(e->e_dfp, -2);
        }
#line 1082
        if ((c2 & -128) == 0) {
          {
#line 1082
          tmp___8 = __ctype_b_loc();
          }
#line 1082
          if (! ((int const   )*(*tmp___8 + c2) & 8192)) {
#line 1082
            goto while_break___1;
          }
        } else {
#line 1082
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1086
      if (c2 == -1) {
#line 1087
        goto while_break___0;
      }
      {
#line 1089
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1091
        c3 = sm_io_getc(e->e_dfp, -2);
        }
#line 1089
        if ((c3 & -128) == 0) {
          {
#line 1089
          tmp___9 = __ctype_b_loc();
          }
#line 1089
          if (! ((int const   )*(*tmp___9 + c3) & 8192)) {
#line 1089
            goto while_break___2;
          }
        } else {
#line 1089
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1093
      if (c3 == -1) {
#line 1094
        goto while_break___0;
      }
      {
#line 1096
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1098
        c4 = sm_io_getc(e->e_dfp, -2);
        }
#line 1096
        if ((c4 & -128) == 0) {
          {
#line 1096
          tmp___10 = __ctype_b_loc();
          }
#line 1096
          if (! ((int const   )*(*tmp___10 + c4) & 8192)) {
#line 1096
            goto while_break___3;
          }
        } else {
#line 1096
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1100
      if (c4 == -1) {
#line 1101
        goto while_break___0;
      }
#line 1103
      if (c1 == 61) {
#line 1104
        goto while_continue___0;
      } else
#line 1103
      if (c2 == 61) {
#line 1104
        goto while_continue___0;
      }
#line 1105
      if (c1 < 0) {
#line 1105
        c1 = -1;
      } else
#line 1105
      if (c1 > 127) {
#line 1105
        c1 = -1;
      } else {
#line 1105
        c1 = (int )index_64[c1];
      }
#line 1106
      if (c2 < 0) {
#line 1106
        c2 = -1;
      } else
#line 1106
      if (c2 > 127) {
#line 1106
        c2 = -1;
      } else {
#line 1106
        c2 = (int )index_64[c2];
      }
#line 1132
      *fbufp = (unsigned char )((c1 << 2) | ((c2 & 48) >> 4));
      {
#line 1133
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1133
        tmp___12 = fbufp;
#line 1133
        fbufp ++;
#line 1133
        if ((int )*tmp___12 == 10) {
#line 1133
          goto _L___0;
        } else
#line 1133
        if ((unsigned long )fbufp >= (unsigned long )(& fbuf[2048])) {
          _L___0: /* CIL Label */ 
#line 1133
          fbufp --;
#line 1133
          if ((int )*fbufp != 10) {
#line 1133
            fbufp ++;
          } else
#line 1133
          if ((unsigned long )fbufp > (unsigned long )(fbuf)) {
#line 1133
            fbufp --;
#line 1133
            if ((int )*fbufp != 13) {
#line 1133
              fbufp ++;
            }
          }
          {
#line 1133
          tmp___11 = putxline((char *)(fbuf), (size_t )(fbufp - fbuf), mci, pxflags);
          }
#line 1133
          if (! tmp___11) {
#line 1133
            goto writeerr;
          }
#line 1133
          pxflags &= -9;
#line 1133
          fbufp = fbuf;
        }
#line 1133
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1134
      if (c3 == 61) {
#line 1135
        goto while_continue___0;
      }
#line 1136
      if (c3 < 0) {
#line 1136
        c3 = -1;
      } else
#line 1136
      if (c3 > 127) {
#line 1136
        c3 = -1;
      } else {
#line 1136
        c3 = (int )index_64[c3];
      }
#line 1137
      *fbufp = (unsigned char )(((c2 & 15) << 4) | ((c3 & 60) >> 2));
      {
#line 1138
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1138
        tmp___14 = fbufp;
#line 1138
        fbufp ++;
#line 1138
        if ((int )*tmp___14 == 10) {
#line 1138
          goto _L___1;
        } else
#line 1138
        if ((unsigned long )fbufp >= (unsigned long )(& fbuf[2048])) {
          _L___1: /* CIL Label */ 
#line 1138
          fbufp --;
#line 1138
          if ((int )*fbufp != 10) {
#line 1138
            fbufp ++;
          } else
#line 1138
          if ((unsigned long )fbufp > (unsigned long )(fbuf)) {
#line 1138
            fbufp --;
#line 1138
            if ((int )*fbufp != 13) {
#line 1138
              fbufp ++;
            }
          }
          {
#line 1138
          tmp___13 = putxline((char *)(fbuf), (size_t )(fbufp - fbuf), mci, pxflags);
          }
#line 1138
          if (! tmp___13) {
#line 1138
            goto writeerr;
          }
#line 1138
          pxflags &= -9;
#line 1138
          fbufp = fbuf;
        }
#line 1138
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1139
      if (c4 == 61) {
#line 1140
        goto while_continue___0;
      }
#line 1141
      if (c4 < 0) {
#line 1141
        c4 = -1;
      } else
#line 1141
      if (c4 > 127) {
#line 1141
        c4 = -1;
      } else {
#line 1141
        c4 = (int )index_64[c4];
      }
#line 1142
      *fbufp = (unsigned char )(((c3 & 3) << 6) | c4);
      {
#line 1143
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1143
        tmp___16 = fbufp;
#line 1143
        fbufp ++;
#line 1143
        if ((int )*tmp___16 == 10) {
#line 1143
          goto _L___2;
        } else
#line 1143
        if ((unsigned long )fbufp >= (unsigned long )(& fbuf[2048])) {
          _L___2: /* CIL Label */ 
#line 1143
          fbufp --;
#line 1143
          if ((int )*fbufp != 10) {
#line 1143
            fbufp ++;
          } else
#line 1143
          if ((unsigned long )fbufp > (unsigned long )(fbuf)) {
#line 1143
            fbufp --;
#line 1143
            if ((int )*fbufp != 13) {
#line 1143
              fbufp ++;
            }
          }
          {
#line 1143
          tmp___15 = putxline((char *)(fbuf), (size_t )(fbufp - fbuf), mci, pxflags);
          }
#line 1143
          if (! tmp___15) {
#line 1143
            goto writeerr;
          }
#line 1143
          pxflags &= -9;
#line 1143
          fbufp = fbuf;
        }
#line 1143
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1151
    pxflags |= 8;
#line 1152
    fbufp = fbuf;
    {
#line 1153
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 1153
      tmp___18 = sm_io_fgets(e->e_dfp, -2, buf___16, (int )sizeof(buf___16));
      }
#line 1153
      if (! ((unsigned long )tmp___18 != (unsigned long )((void *)0))) {
#line 1153
        goto while_break___7;
      }
      {
#line 1156
      off = mime_fromqp((unsigned char *)(buf___16), & fbufp, (int )(& fbuf[2048] - fbufp));
      }
      again: 
#line 1159
      if (off < -1) {
#line 1160
        goto while_continue___7;
      }
#line 1162
      if (fbufp - fbuf > 0L) {
        {
#line 1164
        tmp___17 = putxline((char *)(fbuf), (size_t )((fbufp - fbuf) - 1L), mci, pxflags);
        }
#line 1164
        if (! tmp___17) {
#line 1166
          goto writeerr;
        }
      }
#line 1168
      fbufp = fbuf;
#line 1169
      if (off >= 0) {
#line 1169
        if ((int )buf___16[off] != 0) {
          {
#line 1171
          off = mime_fromqp((unsigned char *)(buf___16 + off), & fbufp, (int )(& fbuf[2048] - fbufp));
          }
#line 1174
          goto again;
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 1180
  if ((unsigned long )fbufp > (unsigned long )(fbuf)) {
    {
#line 1182
    *fbufp = (unsigned char )'\000';
#line 1183
    tmp___20 = putxline((char *)(fbuf), (size_t )(fbufp - fbuf), mci, pxflags);
    }
#line 1183
    if (! tmp___20) {
#line 1184
      goto writeerr;
    }
  }
  {
#line 1194
  tmp___21 = putline((char *)"", mci);
  }
#line 1194
  if (! tmp___21) {
#line 1195
    goto writeerr;
  }
#line 1197
  if ((int )tTdvect[43] >= 3) {
    {
#line 1198
    sm_dprintf((char *)"\t\t\tmime7to8 => %s to 8bit done\n", cte);
    }
  }
#line 1199
  return (1);
  writeerr: 
#line 1202
  return (0);
}
}
#line 1213 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static char index_hex[128]  = 
#line 1213
  {      (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)0,      (char)1,      (char)2,      (char)3, 
        (char)4,      (char)5,      (char)6,      (char)7, 
        (char)8,      (char)9,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)10,      (char)11,      (char)12, 
        (char)13,      (char)14,      (char)15,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)10,      (char)11,      (char)12, 
        (char)13,      (char)14,      (char)15,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1};
#line 1242 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mime.c"
static int mime_fromqp(unsigned char *infile , unsigned char **outfile , int maxlen ) 
{ 
  int c1 ;
  int c2 ;
  int nchar ;
  unsigned char *b___0 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;

  {
#line 1249
  nchar = 0;
#line 1253
  maxlen --;
#line 1253
  if (maxlen < 1) {
#line 1254
    return (0);
  }
#line 1256
  b___0 = infile;
  {
#line 1257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1257
    tmp___3 = infile;
#line 1257
    infile ++;
#line 1257
    c1 = (int )*tmp___3;
#line 1257
    if (c1 != 0) {
#line 1257
      if (! (nchar < maxlen)) {
#line 1257
        goto while_break;
      }
    } else {
#line 1257
      goto while_break;
    }
#line 1259
    if (c1 == 61) {
#line 1261
      tmp = infile;
#line 1261
      infile ++;
#line 1261
      c1 = (int )*tmp;
#line 1261
      if (c1 == 0) {
#line 1262
        goto while_break;
      }
#line 1264
      if (c1 == 10) {
#line 1267
        return (-2);
      } else {
#line 1264
        if (c1 < 0) {
#line 1264
          c1 = -1;
        } else
#line 1264
        if (c1 > 127) {
#line 1264
          c1 = -1;
        } else {
#line 1264
          c1 = (int )index_hex[c1];
        }
#line 1264
        if (c1 == -1) {
#line 1267
          return (-2);
        } else {
          {
#line 1271
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1273
            tmp___0 = infile;
#line 1273
            infile ++;
#line 1273
            c2 = (int )*tmp___0;
#line 1273
            if (c2 == 0) {
#line 1275
              c2 = -1;
#line 1276
              goto while_break___0;
            }
#line 1271
            if (c2 < 0) {
#line 1271
              c2 = -1;
            } else
#line 1271
            if (c2 > 127) {
#line 1271
              c2 = -1;
            } else {
#line 1271
              c2 = (int )index_hex[c2];
            }
#line 1271
            if (! (c2 == -1)) {
#line 1271
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1280
          if (c2 == -1) {
#line 1281
            goto while_break;
          }
#line 1282
          nchar ++;
#line 1283
          tmp___1 = *outfile;
#line 1283
          (*outfile) ++;
#line 1283
          *tmp___1 = (unsigned char )((c1 << 4) | c2);
        }
      }
    } else {
#line 1288
      nchar ++;
#line 1289
      tmp___2 = *outfile;
#line 1289
      (*outfile) ++;
#line 1289
      *tmp___2 = (unsigned char )c1;
#line 1290
      if (c1 == 10) {
#line 1291
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1294
  tmp___4 = *outfile;
#line 1294
  (*outfile) ++;
#line 1294
  *tmp___4 = (unsigned char )'\000';
#line 1295
  if (nchar >= maxlen) {
#line 1296
    return ((int )((infile - b___0) - 1L));
  }
#line 1297
  return (-1);
}
}
#line 50 "/usr/include/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 354 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
#line 357
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 359
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 284 "/usr/include/netdb.h"
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 816 "./sendmail.h"
void insheader(int idx , char *field , char *value , int flags , ENVELOPE *e ) ;
#line 1717
struct milter *InputFilters[25] ;
#line 2423
void milter_config(char *spec , struct milter **list , int max ) ;
#line 2570
struct hostent *sm_gethostbyname(char *name , int family ) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 32 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_connect_timeout(int ignore ) ;
#line 33
static void milter_error(struct milter *m , ENVELOPE *e ) ;
#line 34
static int milter_open(struct milter *m , bool parseonly , ENVELOPE *e ) ;
#line 35
static void milter_parse_timeouts(char *spec , struct milter *m ) ;
#line 37 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *MilterConnectMacros[51]  ;
#line 38 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *MilterHeloMacros[51]  ;
#line 39 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *MilterEnvFromMacros[51]  ;
#line 40 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *MilterEnvRcptMacros[51]  ;
#line 41 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *MilterDataMacros[51]  ;
#line 42 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *MilterEOMMacros[51]  ;
#line 43 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static size_t MilterMaxDataSize  =    (size_t )65535;
#line 248 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *milter_sysread(struct milter *m , char *buf___16 , ssize_t sz , time_t to ,
                            ENVELOPE *e ) 
{ 
  time_t readstart ;
  ssize_t len___0 ;
  ssize_t curl ;
  bool started ;
  time_t now ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int ret ;
  int save_errno ;
  fd_set fds ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  register char __result ;
  int save_errno___0 ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
#line 256
  readstart = (time_t )0;
#line 258
  started = 0;
#line 260
  curl = 0;
#line 262
  if (to > 0L) {
    {
#line 263
    readstart = curtime();
    }
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (to > 0L) {
      {
#line 271
      now = curtime();
      }
#line 272
      if (now - readstart >= to) {
#line 274
        if ((int )tTdvect[64] >= 5) {
#line 275
          if (started) {
#line 275
            tmp = "during";
          } else {
#line 275
            tmp = "before";
          }
          {
#line 275
          sm_dprintf((char *)"milter_read (%s): %s %s %s", m->mf_name, "timeout",
                     tmp, "data read");
          }
        }
#line 279
        if (MilterLogLevel > 0) {
#line 280
          if (started) {
#line 280
            tmp___0 = "during";
          } else {
#line 280
            tmp___0 = "before";
          }
          {
#line 280
          sm_syslog(3, (char const   *)e->e_id, "Milter (%s): %s %s %s", m->mf_name,
                    "timeout", tmp___0, "data read");
          }
        }
        {
#line 285
        milter_error(m, e);
        }
#line 286
        return ((char *)((void *)0));
      }
#line 288
      to -= now - readstart;
#line 289
      readstart = now;
#line 290
      if (m->mf_sock >= 1024) {
#line 290
        if ((int )tTdvect[64] >= 5) {
          {
#line 290
          sm_dprintf((char *)"milter_%s(%s): socket %d is larger than FD_SETSIZE %d\n",
                     "read", m->mf_name, m->mf_sock, 1024);
          }
        }
#line 290
        if (MilterLogLevel > 0) {
          {
#line 290
          sm_syslog(3, (char const   *)e->e_id, "Milter (%s): socket(%s) %d is larger than FD_SETSIZE %d",
                    m->mf_name, "read", m->mf_sock, 1024);
          }
        }
        {
#line 290
        milter_error(m, e);
        }
#line 290
        return ((char *)((void *)0));
      }
      {
#line 290
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 290
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 290
          __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& fds.__fds_bits[0]): "memory");
#line 290
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 290
        __asm__  volatile   ("btsl %1,%0": "=m" (fds.__fds_bits[(unsigned long )m->mf_sock / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )m->mf_sock % (8UL * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 290
        tv.tv_sec = to;
#line 290
        tv.tv_usec = (__suseconds_t )0;
#line 290
        ret = select(m->mf_sock + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((fd_set *)((void *)0)),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
        }
#line 290
        if (ret < 0) {
          {
#line 290
          tmp___1 = __errno_location();
          }
#line 290
          if (! (*tmp___1 == 4)) {
#line 290
            goto while_break___0;
          }
        } else {
#line 290
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 290
      if (ret == 0) {
#line 290
        goto case_0;
      }
#line 290
      if (ret == -1) {
#line 290
        goto case_neg_1;
      }
#line 290
      goto switch_default;
      case_0: /* CIL Label */ 
#line 290
      if ((int )tTdvect[64] >= 5) {
        {
#line 290
        sm_dprintf((char *)"milter_%s(%s): timeout\n", "read", m->mf_name);
        }
      }
#line 290
      if (MilterLogLevel > 0) {
#line 290
        if (started) {
#line 290
          tmp___2 = "during";
        } else {
#line 290
          tmp___2 = "before";
        }
        {
#line 290
        sm_syslog(3, (char const   *)e->e_id, "Milter (%s): %s %s %s %s", m->mf_name,
                  "timeout", tmp___2, "data", "read");
        }
      }
      {
#line 290
      milter_error(m, e);
      }
#line 290
      return ((char *)((void *)0));
      case_neg_1: /* CIL Label */ 
      {
#line 290
      tmp___3 = __errno_location();
#line 290
      save_errno = *tmp___3;
      }
#line 290
      if ((int )tTdvect[64] >= 5) {
        {
#line 290
        tmp___4 = sm_errstring(save_errno);
#line 290
        sm_dprintf((char *)"milter_%s(%s): select: %s\n", "read", m->mf_name, tmp___4);
        }
      }
#line 290
      if (MilterLogLevel > 0) {
        {
#line 290
        tmp___5 = sm_errstring(save_errno);
#line 290
        sm_syslog(3, (char const   *)e->e_id, "Milter (%s): select(%s): %s", m->mf_name,
                  "read", tmp___5);
        }
      }
      {
#line 290
      milter_error(m, e);
      }
#line 290
      return ((char *)((void *)0));
      switch_default: /* CIL Label */ 
#line 290
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned long )m->mf_sock % (8UL * sizeof(__fd_mask ))),
                           "m" (fds.__fds_bits[(unsigned long )m->mf_sock / (8UL * sizeof(__fd_mask ))]): "cc");
#line 290
      if (__result) {
#line 290
        goto switch_break;
      }
#line 290
      if ((int )tTdvect[64] >= 5) {
        {
#line 290
        sm_dprintf((char *)"milter_%s(%s): socket not ready\n", "read", m->mf_name);
        }
      }
#line 290
      if (MilterLogLevel > 0) {
        {
#line 290
        sm_syslog(3, (char const   *)e->e_id, "Milter (%s): socket(%s) not ready",
                  m->mf_name, "read");
        }
      }
      {
#line 290
      milter_error(m, e);
      }
#line 290
      return ((char *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 293
    len___0 = read(m->mf_sock, (void *)(buf___16 + curl), (size_t )(sz - curl));
    }
#line 295
    if (len___0 < 0) {
      {
#line 297
      tmp___6 = __errno_location();
#line 297
      save_errno___0 = *tmp___6;
      }
#line 299
      if ((int )tTdvect[64] >= 5) {
        {
#line 300
        tmp___7 = sm_errstring(save_errno___0);
#line 300
        sm_dprintf((char *)"milter_read(%s): read returned %ld: %s\n", m->mf_name,
                   (long )len___0, tmp___7);
        }
      }
#line 303
      if (MilterLogLevel > 0) {
        {
#line 304
        tmp___8 = sm_errstring(save_errno___0);
#line 304
        sm_syslog(3, (char const   *)e->e_id, "Milter (%s): read returned %ld: %s",
                  m->mf_name, (long )len___0, tmp___8);
        }
      }
      {
#line 308
      milter_error(m, e);
      }
#line 309
      return ((char *)((void *)0));
    }
#line 312
    started = 1;
#line 313
    curl += len___0;
#line 314
    if (len___0 == 0) {
#line 315
      goto while_break;
    } else
#line 314
    if (curl >= sz) {
#line 315
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  if (curl != sz) {
#line 321
    if ((int )tTdvect[64] >= 5) {
      {
#line 322
      sm_dprintf((char *)"milter_read(%s): cmd read returned %ld, expecting %ld\n",
                 m->mf_name, (long )curl, (long )sz);
      }
    }
#line 324
    if (MilterLogLevel > 0) {
      {
#line 325
      sm_syslog(3, (char const   *)e->e_id, "milter_read(%s): cmd read returned %ld, expecting %ld",
                m->mf_name, (long )curl, (long )sz);
      }
    }
    {
#line 328
    milter_error(m, e);
    }
#line 329
    return ((char *)((void *)0));
  }
#line 331
  return (buf___16);
}
}
#line 334 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *milter_read(struct milter *m , char *cmd , ssize_t *rlen , time_t to ,
                         ENVELOPE *e ) 
{ 
  time_t readstart ;
  ssize_t expl ;
  mi_int32 i ;
  char *buf___16 ;
  char data[5] ;
  char *tmp ;
  time_t now ;
  uint32_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 342
  readstart = (time_t )0;
#line 353
  if (m->mf_sock < 0) {
#line 355
    if (MilterLogLevel > 0) {
      {
#line 356
      sm_syslog(3, (char const   *)e->e_id, "milter_read(%s): socket closed", m->mf_name);
      }
    }
    {
#line 359
    milter_error(m, e);
    }
#line 360
    return ((char *)((void *)0));
  }
#line 363
  *rlen = 0;
#line 364
  *cmd = (char )'\000';
#line 366
  if (to > 0L) {
    {
#line 367
    readstart = curtime();
    }
  }
  {
#line 376
  tmp = milter_sysread(m, data, (ssize_t )sizeof(data), to, e);
  }
#line 376
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 377
    return ((char *)((void *)0));
  }
#line 388
  if (to > 0L) {
    {
#line 392
    now = curtime();
    }
#line 393
    if (now - readstart >= to) {
#line 395
      if ((int )tTdvect[64] >= 5) {
        {
#line 396
        sm_dprintf((char *)"milter_read(%s): timeout before data read\n", m->mf_name);
        }
      }
#line 398
      if (MilterLogLevel > 0) {
        {
#line 399
        sm_syslog(3, (char const   *)e->e_id, "Milter read(%s): timeout before data read",
                  m->mf_name);
        }
      }
      {
#line 402
      milter_error(m, e);
      }
#line 403
      return ((char *)((void *)0));
    }
#line 405
    to -= now - readstart;
  }
  {
#line 408
  *cmd = data[4];
#line 409
  data[4] = (char )'\000';
#line 410
  memcpy((void */* __restrict  */)(& i), (void const   */* __restrict  */)(data),
         (size_t )4);
#line 411
  tmp___0 = ntohl((uint32_t )i);
#line 411
  expl = (ssize_t )(tmp___0 - 1U);
  }
#line 413
  if ((int )tTdvect[64] >= 25) {
    {
#line 414
    sm_dprintf((char *)"milter_read(%s): expecting %ld bytes\n", m->mf_name, (long )expl);
    }
  }
#line 417
  if (expl < 0) {
#line 419
    if ((int )tTdvect[64] >= 5) {
      {
#line 420
      sm_dprintf((char *)"milter_read(%s): read size %ld out of range\n", m->mf_name,
                 (long )expl);
      }
    }
#line 422
    if (MilterLogLevel > 0) {
      {
#line 423
      sm_syslog(3, (char const   *)e->e_id, "milter_read(%s): read size %ld out of range",
                m->mf_name, (long )expl);
      }
    }
    {
#line 426
    milter_error(m, e);
    }
#line 427
    return ((char *)((void *)0));
  }
#line 430
  if (expl == 0) {
#line 431
    return ((char *)((void *)0));
  }
  {
#line 433
  tmp___1 = xalloc_tagged(expl, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                          433);
#line 433
  buf___16 = tmp___1;
#line 435
  tmp___2 = milter_sysread(m, buf___16, expl, to, e);
  }
#line 435
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 437
    sm_free_tagged((void *)buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                   437);
    }
#line 438
    return ((char *)((void *)0));
  }
#line 441
  if ((int )tTdvect[64] >= 50) {
    {
#line 442
    sm_dprintf((char *)"milter_read(%s): Returning %*s\n", m->mf_name, expl, buf___16);
    }
  }
#line 444
  *rlen = expl;
#line 445
  return (buf___16);
}
}
#line 465 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *milter_write(struct milter *m , char cmd , char *buf___16 , ssize_t len___0 ,
                          time_t to , ENVELOPE *e ) 
{ 
  time_t writestart ;
  ssize_t sl ;
  ssize_t i ;
  int num_vectors ;
  mi_int32 nl ;
  char data[5] ;
  bool started ;
  struct iovec vector[2] ;
  uint32_t tmp ;
  int ret ;
  int save_errno ;
  fd_set fds ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  register char __result ;
  int save_errno___0 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  int __cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
#line 474
  writestart = (time_t )0;
#line 479
  started = 0;
#line 488
  if (len___0 < 0) {
#line 488
    goto _L;
  } else
#line 488
  if ((size_t )len___0 > MilterMaxDataSize) {
    _L: /* CIL Label */ 
#line 490
    if ((int )tTdvect[64] >= 5) {
      {
#line 491
      sm_dprintf((char *)"milter_write(%s): length %ld out of range\n", m->mf_name,
                 (long )len___0);
      }
    }
#line 493
    if (MilterLogLevel > 0) {
      {
#line 494
      sm_syslog(3, (char const   *)e->e_id, "milter_write(%s): length %ld out of range",
                m->mf_name, (long )len___0);
      }
    }
    {
#line 497
    milter_error(m, e);
    }
#line 498
    return ((char *)((void *)0));
  }
#line 500
  if (m->mf_sock < 0) {
#line 502
    if (MilterLogLevel > 0) {
      {
#line 503
      sm_syslog(3, (char const   *)e->e_id, "milter_write(%s): socket closed", m->mf_name);
      }
    }
    {
#line 506
    milter_error(m, e);
    }
#line 507
    return ((char *)((void *)0));
  }
#line 510
  if ((int )tTdvect[64] >= 20) {
    {
#line 511
    sm_dprintf((char *)"milter_write(%s): cmd %c, len %ld\n", m->mf_name, (int )cmd,
               (long )len___0);
    }
  }
  {
#line 514
  tmp = htonl((uint32_t )(len___0 + 1));
#line 514
  nl = (mi_int32 )tmp;
#line 515
  memcpy((void */* __restrict  */)(data), (void const   */* __restrict  */)((char *)(& nl)),
         (size_t )4);
#line 516
  data[4] = cmd;
#line 517
  sl = 5;
#line 520
  vector[0].iov_base = (void *)(data);
#line 521
  vector[0].iov_len = (size_t )sl;
  }
#line 530
  if (len___0 <= 0) {
#line 533
    num_vectors = 1;
  } else
#line 530
  if ((unsigned long )buf___16 == (unsigned long )((void *)0)) {
#line 533
    num_vectors = 1;
  } else {
#line 542
    num_vectors = 2;
#line 543
    sl += len___0;
#line 544
    vector[1].iov_base = (void *)buf___16;
#line 545
    vector[1].iov_len = (size_t )len___0;
#line 547
    if ((int )tTdvect[64] >= 50) {
      {
#line 548
      sm_dprintf((char *)"milter_write(%s): Sending %*s\n", m->mf_name, len___0, buf___16);
      }
    }
  }
#line 552
  if (to > 0L) {
    {
#line 554
    writestart = curtime();
    }
#line 555
    if (m->mf_sock >= 1024) {
#line 555
      if ((int )tTdvect[64] >= 5) {
        {
#line 555
        sm_dprintf((char *)"milter_%s(%s): socket %d is larger than FD_SETSIZE %d\n",
                   "write", m->mf_name, m->mf_sock, 1024);
        }
      }
#line 555
      if (MilterLogLevel > 0) {
        {
#line 555
        sm_syslog(3, (char const   *)e->e_id, "Milter (%s): socket(%s) %d is larger than FD_SETSIZE %d",
                  m->mf_name, "write", m->mf_sock, 1024);
        }
      }
      {
#line 555
      milter_error(m, e);
      }
#line 555
      return ((char *)((void *)0));
    }
    {
#line 555
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 555
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 555
        __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0),
                             "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& fds.__fds_bits[0]): "memory");
#line 555
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 555
      __asm__  volatile   ("btsl %1,%0": "=m" (fds.__fds_bits[(unsigned long )m->mf_sock / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )m->mf_sock % (8UL * sizeof(__fd_mask ))): "cc",
                           "memory");
#line 555
      tv.tv_sec = to;
#line 555
      tv.tv_usec = (__suseconds_t )0;
#line 555
      ret = select(m->mf_sock + 1, (fd_set */* __restrict  */)((fd_set *)((void *)0)),
                   (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                   (struct timeval */* __restrict  */)(& tv));
      }
#line 555
      if (ret < 0) {
        {
#line 555
        tmp___0 = __errno_location();
        }
#line 555
        if (! (*tmp___0 == 4)) {
#line 555
          goto while_break;
        }
      } else {
#line 555
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 555
    if (ret == 0) {
#line 555
      goto case_0;
    }
#line 555
    if (ret == -1) {
#line 555
      goto case_neg_1;
    }
#line 555
    goto switch_default;
    case_0: /* CIL Label */ 
#line 555
    if ((int )tTdvect[64] >= 5) {
      {
#line 555
      sm_dprintf((char *)"milter_%s(%s): timeout\n", "write", m->mf_name);
      }
    }
#line 555
    if (MilterLogLevel > 0) {
#line 555
      if (started) {
#line 555
        tmp___1 = "during";
      } else {
#line 555
        tmp___1 = "before";
      }
      {
#line 555
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): %s %s %s %s", m->mf_name,
                "timeout", tmp___1, "data", "write");
      }
    }
    {
#line 555
    milter_error(m, e);
    }
#line 555
    return ((char *)((void *)0));
    case_neg_1: /* CIL Label */ 
    {
#line 555
    tmp___2 = __errno_location();
#line 555
    save_errno = *tmp___2;
    }
#line 555
    if ((int )tTdvect[64] >= 5) {
      {
#line 555
      tmp___3 = sm_errstring(save_errno);
#line 555
      sm_dprintf((char *)"milter_%s(%s): select: %s\n", "write", m->mf_name, tmp___3);
      }
    }
#line 555
    if (MilterLogLevel > 0) {
      {
#line 555
      tmp___4 = sm_errstring(save_errno);
#line 555
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): select(%s): %s", m->mf_name,
                "write", tmp___4);
      }
    }
    {
#line 555
    milter_error(m, e);
    }
#line 555
    return ((char *)((void *)0));
    switch_default: /* CIL Label */ 
#line 555
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned long )m->mf_sock % (8UL * sizeof(__fd_mask ))),
                         "m" (fds.__fds_bits[(unsigned long )m->mf_sock / (8UL * sizeof(__fd_mask ))]): "cc");
#line 555
    if (__result) {
#line 555
      goto switch_break;
    }
#line 555
    if ((int )tTdvect[64] >= 5) {
      {
#line 555
      sm_dprintf((char *)"milter_%s(%s): socket not ready\n", "write", m->mf_name);
      }
    }
#line 555
    if (MilterLogLevel > 0) {
      {
#line 555
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): socket(%s) not ready", m->mf_name,
                "write");
      }
    }
    {
#line 555
    milter_error(m, e);
    }
#line 555
    return ((char *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 559
  i = writev(m->mf_sock, (struct iovec  const  *)(vector), num_vectors);
  }
#line 560
  if (i != sl) {
    {
#line 562
    tmp___5 = __errno_location();
#line 562
    save_errno___0 = *tmp___5;
    }
#line 564
    if ((int )tTdvect[64] >= 5) {
      {
#line 565
      tmp___6 = sm_errstring(save_errno___0);
#line 565
      sm_dprintf((char *)"milter_write(%s): write(%c) returned %ld, expected %ld: %s\n",
                 m->mf_name, (int )cmd, (long )i, (long )sl, tmp___6);
      }
    }
#line 568
    if (MilterLogLevel > 0) {
      {
#line 569
      tmp___7 = sm_errstring(save_errno___0);
#line 569
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): write(%c) returned %ld, expected %ld: %s",
                m->mf_name, (int )cmd, (long )i, (long )sl, tmp___7);
      }
    }
    {
#line 573
    milter_error(m, e);
    }
#line 574
    return ((char *)((void *)0));
  }
#line 576
  return (buf___16);
}
}
#line 597 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static sigjmp_buf MilterConnectTimeout  ;
#line 599 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static int milter_open(struct milter *m , bool parseonly , ENVELOPE *e ) 
{ 
  int sock ;
  int addrlen ;
  int addrno ;
  int save_errno ;
  char *p ;
  char *colon ;
  char *at ;
  struct hostent *hp ;
  union bigsockaddr addr ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  long sff ;
  int *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  unsigned short port ;
  int tmp___11 ;
  register struct servent *sp ;
  int *tmp___12 ;
  int *tmp___13 ;
  unsigned short const   **tmp___14 ;
  char *tmp___15 ;
  char *end ;
  bool found ;
  unsigned long hid ;
  in_addr_t tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  SM_EVENT *ev ;
  int i ;
  int *tmp___22 ;
  int *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;

  {
#line 605
  sock = 0;
#line 606
  addrlen = 0;
#line 607
  addrno = 0;
#line 612
  hp = (struct hostent *)((void *)0);
#line 615
  if ((unsigned long )m->mf_conn == (unsigned long )((void *)0)) {
#line 615
    goto _L;
  } else
#line 615
  if ((int )*(m->mf_conn + 0) == 0) {
    _L: /* CIL Label */ 
#line 617
    if ((int )tTdvect[64] >= 5) {
      {
#line 618
      sm_dprintf((char *)"X%s: empty or missing socket information\n", m->mf_name);
      }
    }
#line 620
    if (parseonly) {
      {
#line 621
      syserr("X%s: empty or missing socket information", m->mf_name);
      }
    } else
#line 623
    if (MilterLogLevel > 0) {
      {
#line 624
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): empty or missing socket information",
                m->mf_name);
      }
    }
    {
#line 627
    milter_error(m, e);
    }
#line 628
    return (-1);
  }
  {
#line 632
  memset((void *)(& addr), '\000', (size_t )sizeof(addr));
#line 633
  p = m->mf_conn;
#line 634
  colon = strchr((char const   *)p, ':');
  }
#line 635
  if ((unsigned long )colon != (unsigned long )((void *)0)) {
#line 637
    *colon = (char )'\000';
#line 639
    if ((int )*p == 0) {
#line 643
      addr.sa.sa_family = (sa_family_t )1;
    } else {
      {
#line 665
      tmp___1 = sm_strcasecmp((char const   *)p, "unix");
      }
#line 665
      if (tmp___1 == 0) {
#line 667
        addr.sa.sa_family = (sa_family_t )1;
      } else {
        {
#line 665
        tmp___2 = sm_strcasecmp((char const   *)p, "local");
        }
#line 665
        if (tmp___2 == 0) {
#line 667
          addr.sa.sa_family = (sa_family_t )1;
        } else {
          {
#line 670
          tmp___0 = sm_strcasecmp((char const   *)p, "inet");
          }
#line 670
          if (tmp___0 == 0) {
#line 671
            addr.sa.sa_family = (sa_family_t )2;
          } else {
            {
#line 680
            tmp = __errno_location();
#line 680
            *tmp = 93;
            }
#line 684
            if ((int )tTdvect[64] >= 5) {
              {
#line 685
              sm_dprintf((char *)"X%s: unknown socket type %s\n", m->mf_name, p);
              }
            }
#line 687
            if (parseonly) {
              {
#line 688
              syserr("X%s: unknown socket type %s", m->mf_name, p);
              }
            } else
#line 690
            if (MilterLogLevel > 0) {
              {
#line 691
              sm_syslog(3, (char const   *)e->e_id, "Milter (%s): unknown socket type %s",
                        m->mf_name, p);
              }
            }
            {
#line 694
            milter_error(m, e);
            }
#line 695
            return (-1);
          }
        }
      }
    }
#line 697
    tmp___3 = colon;
#line 697
    colon ++;
#line 697
    *tmp___3 = (char )':';
  } else {
#line 702
    addr.sa.sa_family = (sa_family_t )1;
#line 703
    colon = p;
  }
#line 707
  if ((int )addr.sa.sa_family == 1) {
    {
#line 709
    sff = 271106L;
#line 711
    at = colon;
#line 712
    tmp___5 = strlen((char const   *)colon);
    }
#line 712
    if ((unsigned long )tmp___5 >= sizeof(addr.sunix.sun_path)) {
#line 714
      if ((int )tTdvect[64] >= 5) {
        {
#line 715
        sm_dprintf((char *)"X%s: local socket name %s too long\n", m->mf_name, colon);
        }
      }
      {
#line 717
      tmp___4 = __errno_location();
#line 717
      *tmp___4 = 22;
      }
#line 718
      if (parseonly) {
        {
#line 719
        syserr("X%s: local socket name %s too long", m->mf_name, colon);
        }
      } else
#line 721
      if (MilterLogLevel > 0) {
        {
#line 722
        sm_syslog(3, (char const   *)e->e_id, "Milter (%s): local socket name %s too long",
                  m->mf_name, colon);
        }
      }
      {
#line 725
      milter_error(m, e);
      }
#line 726
      return (-1);
    }
    {
#line 728
    tmp___6 = __errno_location();
#line 728
    *tmp___6 = safefile(colon, RunAsUid, RunAsGid, RunAsUserName, sff, 384, (struct stat *)((void *)0));
    }
#line 732
    if (parseonly) {
      {
#line 732
      tmp___10 = __errno_location();
      }
#line 732
      if (*tmp___10 == 2) {
#line 734
        if ((int )OpMode == 100) {
          {
#line 736
          sm_io_fprintf(& SmIoF[2], -2, "WARNING: X%s: local socket name %s missing\n",
                        m->mf_name, colon);
          }
        } else
#line 734
        if ((int )OpMode == 68) {
          {
#line 736
          sm_io_fprintf(& SmIoF[2], -2, "WARNING: X%s: local socket name %s missing\n",
                        m->mf_name, colon);
          }
        }
      } else {
#line 732
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 740
      tmp___9 = __errno_location();
      }
#line 740
      if (*tmp___9 != 0) {
        {
#line 743
        tmp___7 = __errno_location();
#line 743
        save_errno = *tmp___7;
        }
#line 744
        if ((int )tTdvect[64] >= 5) {
          {
#line 745
          sm_dprintf((char *)"X%s: local socket name %s unsafe\n", m->mf_name, colon);
          }
        }
        {
#line 747
        tmp___8 = __errno_location();
#line 747
        *tmp___8 = save_errno;
        }
#line 748
        if (parseonly) {
#line 750
          if ((int )OpMode == 100) {
            {
#line 753
            syserr("X%s: local socket name %s unsafe", m->mf_name, colon);
            }
          } else
#line 750
          if ((int )OpMode == 68) {
            {
#line 753
            syserr("X%s: local socket name %s unsafe", m->mf_name, colon);
            }
          } else
#line 750
          if ((int )OpMode == 115) {
            {
#line 753
            syserr("X%s: local socket name %s unsafe", m->mf_name, colon);
            }
          }
        } else
#line 756
        if (MilterLogLevel > 0) {
          {
#line 757
          sm_syslog(3, (char const   *)e->e_id, "Milter (%s): local socket name %s unsafe",
                    m->mf_name, colon);
          }
        }
        {
#line 760
        milter_error(m, e);
        }
#line 761
        return (-1);
      }
    }
    {
#line 764
    sm_strlcpy(addr.sunix.sun_path, (char const   *)colon, (ssize_t )sizeof(addr.sunix.sun_path));
#line 766
    addrlen = (int )sizeof(struct sockaddr_un );
    }
  } else
#line 771
  if ((int )addr.sa.sa_family == 2) {
    {
#line 783
    at = strchr((char const   *)colon, '@');
    }
#line 784
    if ((unsigned long )at == (unsigned long )((void *)0)) {
#line 786
      if ((int )tTdvect[64] >= 5) {
        {
#line 787
        sm_dprintf((char *)"X%s: bad address %s (expected port@host)\n", m->mf_name,
                   colon);
        }
      }
#line 789
      if (parseonly) {
        {
#line 790
        syserr("X%s: bad address %s (expected port@host)", m->mf_name, colon);
        }
      } else
#line 792
      if (MilterLogLevel > 0) {
        {
#line 793
        sm_syslog(3, (char const   *)e->e_id, "Milter (%s): bad address %s (expected port@host)",
                  m->mf_name, colon);
        }
      }
      {
#line 796
      milter_error(m, e);
      }
#line 797
      return (-1);
    }
#line 799
    *at = (char )'\000';
#line 800
    if (((int )*colon & -128) == 0) {
      {
#line 800
      tmp___14 = __ctype_b_loc();
      }
#line 800
      if ((int const   )*(*tmp___14 + (int )*colon) & 2048) {
        {
#line 801
        tmp___11 = atoi((char const   *)colon);
#line 801
        port = htons((unsigned short )tmp___11);
        }
      } else {
#line 800
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 820
      sp = getservbyname((char const   *)colon, "tcp");
      }
#line 821
      if ((unsigned long )sp == (unsigned long )((void *)0)) {
        {
#line 823
        tmp___12 = __errno_location();
#line 823
        save_errno = *tmp___12;
        }
#line 824
        if ((int )tTdvect[64] >= 5) {
          {
#line 825
          sm_dprintf((char *)"X%s: unknown port name %s\n", m->mf_name, colon);
          }
        }
        {
#line 827
        tmp___13 = __errno_location();
#line 827
        *tmp___13 = save_errno;
        }
#line 828
        if (parseonly) {
          {
#line 829
          syserr("X%s: unknown port name %s", m->mf_name, colon);
          }
        } else
#line 831
        if (MilterLogLevel > 0) {
          {
#line 832
          sm_syslog(3, (char const   *)e->e_id, "Milter (%s): unknown port name %s",
                    m->mf_name, colon);
          }
        }
        {
#line 835
        milter_error(m, e);
        }
#line 836
        return (-1);
      }
#line 838
      port = (unsigned short )sp->s_port;
    }
#line 841
    tmp___15 = at;
#line 841
    at ++;
#line 841
    *tmp___15 = (char )'@';
#line 842
    if ((int )*at == 91) {
      {
#line 846
      end = strchr((char const   *)at, ']');
      }
#line 847
      if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 849
        found = 0;
#line 851
        hid = 4294967295UL;
#line 857
        *end = (char )'\000';
#line 859
        if ((int )addr.sa.sa_family == 2) {
          {
#line 859
          tmp___16 = inet_addr((char const   *)(at + 1));
#line 859
          hid = (unsigned long )tmp___16;
          }
#line 859
          if (hid != 4294967295UL) {
#line 862
            addr.sin.sin_addr.s_addr = (in_addr_t )hid;
#line 863
            addr.sin.sin_port = port;
#line 864
            found = 1;
          }
        }
#line 878
        *end = (char )']';
#line 879
        if (! found) {
#line 881
          if ((int )tTdvect[64] >= 5) {
            {
#line 882
            sm_dprintf((char *)"X%s: Invalid numeric domain spec \"%s\"\n", m->mf_name,
                       at);
            }
          }
#line 884
          if (parseonly) {
            {
#line 885
            syserr("X%s: Invalid numeric domain spec \"%s\"", m->mf_name, at);
            }
          } else
#line 887
          if (MilterLogLevel > 0) {
            {
#line 888
            sm_syslog(3, (char const   *)e->e_id, "Milter (%s): Invalid numeric domain spec \"%s\"",
                      m->mf_name, at);
            }
          }
          {
#line 891
          milter_error(m, e);
          }
#line 892
          return (-1);
        }
      } else {
#line 897
        if ((int )tTdvect[64] >= 5) {
          {
#line 898
          sm_dprintf((char *)"X%s: Invalid numeric domain spec \"%s\"\n", m->mf_name,
                     at);
          }
        }
#line 900
        if (parseonly) {
          {
#line 901
          syserr("X%s: Invalid numeric domain spec \"%s\"", m->mf_name, at);
          }
        } else
#line 903
        if (MilterLogLevel > 0) {
          {
#line 904
          sm_syslog(3, (char const   *)e->e_id, "Milter (%s): Invalid numeric domain spec \"%s\"",
                    m->mf_name, at);
          }
        }
        {
#line 907
        milter_error(m, e);
        }
#line 908
        return (-1);
      }
    } else {
      {
#line 913
      hp = sm_gethostbyname(at, (int )addr.sa.sa_family);
      }
#line 914
      if ((unsigned long )hp == (unsigned long )((void *)0)) {
        {
#line 916
        tmp___17 = __errno_location();
#line 916
        save_errno = *tmp___17;
        }
#line 917
        if ((int )tTdvect[64] >= 5) {
          {
#line 918
          sm_dprintf((char *)"X%s: Unknown host name %s\n", m->mf_name, at);
          }
        }
        {
#line 920
        tmp___18 = __errno_location();
#line 920
        *tmp___18 = save_errno;
        }
#line 921
        if (parseonly) {
          {
#line 922
          syserr("X%s: Unknown host name %s", m->mf_name, at);
          }
        } else
#line 924
        if (MilterLogLevel > 0) {
          {
#line 925
          sm_syslog(3, (char const   *)e->e_id, "Milter (%s): Unknown host name %s",
                    m->mf_name, at);
          }
        }
        {
#line 928
        milter_error(m, e);
        }
#line 929
        return (-1);
      }
#line 931
      addr.sa.sa_family = (sa_family_t )hp->h_addrtype;
      {
#line 935
      if (hp->h_addrtype == 2) {
#line 935
        goto case_2;
      }
#line 954
      goto switch_default;
      case_2: /* CIL Label */ 
      {
#line 936
      memmove((void *)(& addr.sin.sin_addr), (void const   *)*(hp->h_addr_list + 0),
              (size_t )4);
#line 938
      addr.sin.sin_port = port;
#line 939
      addrlen = (int )sizeof(struct sockaddr_in );
#line 940
      addrno = 1;
      }
#line 941
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 955
      if ((int )tTdvect[64] >= 5) {
        {
#line 956
        sm_dprintf((char *)"X%s: Unknown protocol for %s (%d)\n", m->mf_name, at,
                   hp->h_addrtype);
        }
      }
#line 959
      if (parseonly) {
        {
#line 960
        syserr("X%s: Unknown protocol for %s (%d)", m->mf_name, at, hp->h_addrtype);
        }
      } else
#line 962
      if (MilterLogLevel > 0) {
        {
#line 963
        sm_syslog(3, (char const   *)e->e_id, "Milter (%s): Unknown protocol for %s (%d)",
                  m->mf_name, at, hp->h_addrtype);
        }
      }
      {
#line 967
      milter_error(m, e);
      }
#line 971
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
#line 978
    if ((int )tTdvect[64] >= 5) {
      {
#line 979
      sm_dprintf((char *)"X%s: unknown socket protocol\n", m->mf_name);
      }
    }
#line 981
    if (parseonly) {
      {
#line 982
      syserr("X%s: unknown socket protocol", m->mf_name);
      }
    } else
#line 983
    if (MilterLogLevel > 0) {
      {
#line 984
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): unknown socket protocol",
                m->mf_name);
      }
    }
    {
#line 987
    milter_error(m, e);
    }
#line 988
    return (-1);
  }
#line 992
  if (parseonly) {
#line 994
    m->mf_state = (char )'R';
#line 999
    return (0);
  }
#line 1003
  if ((int )m->mf_state != 82) {
#line 1003
    if ((int )m->mf_state != 67) {
#line 1007
      if ((int )tTdvect[64] >= 1) {
        {
#line 1008
        sm_dprintf((char *)"Milter (%s): Trying to open filter in state %c\n", m->mf_name,
                   (int )m->mf_state);
        }
      }
      {
#line 1010
      milter_error(m, e);
      }
#line 1015
      return (-1);
    }
  }
  {
#line 1019
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1021
    sock = socket((int )addr.sa.sa_family, 1, 0);
    }
#line 1022
    if (sock < 0) {
      {
#line 1024
      tmp___19 = __errno_location();
#line 1024
      save_errno = *tmp___19;
      }
#line 1025
      if ((int )tTdvect[64] >= 5) {
        {
#line 1026
        tmp___20 = sm_errstring(save_errno);
#line 1026
        sm_dprintf((char *)"Milter (%s): error creating socket: %s\n", m->mf_name,
                   tmp___20);
        }
      }
#line 1029
      if (MilterLogLevel > 0) {
        {
#line 1030
        tmp___21 = sm_errstring(save_errno);
#line 1030
        sm_syslog(3, (char const   *)e->e_id, "Milter (%s): error creating socket: %s",
                  m->mf_name, tmp___21);
        }
      }
      {
#line 1033
      milter_error(m, e);
      }
#line 1038
      return (-1);
    }
    {
#line 1041
    tmp___24 = __sigsetjmp((struct __jmp_buf_tag *)(MilterConnectTimeout), 1);
    }
#line 1041
    if (tmp___24 == 0) {
#line 1043
      ev = (SM_EVENT *)((void *)0);
#line 1046
      if (m->mf_timeout[3] > 0L) {
        {
#line 1047
        ev = sm_seteventm((int )(m->mf_timeout[3] * 1000L), & milter_connect_timeout,
                          0);
        }
      }
      {
#line 1050
      i = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                  (socklen_t )addrlen);
#line 1051
      tmp___22 = __errno_location();
#line 1051
      save_errno = *tmp___22;
      }
#line 1052
      if ((unsigned long )ev != (unsigned long )((void *)0)) {
        {
#line 1053
        sm_clrevent(ev);
        }
      }
      {
#line 1054
      tmp___23 = __errno_location();
#line 1054
      *tmp___23 = save_errno;
      }
#line 1055
      if (i >= 0) {
#line 1056
        goto while_break;
      }
    }
    {
#line 1060
    tmp___25 = __errno_location();
#line 1060
    save_errno = *tmp___25;
#line 1061
    p = CurHostName;
#line 1062
    CurHostName = at;
    }
#line 1063
    if ((int )tTdvect[64] >= 5) {
      {
#line 1064
      tmp___26 = sm_errstring(save_errno);
#line 1064
      sm_dprintf((char *)"milter_open (%s): open %s failed: %s\n", m->mf_name, at,
                 tmp___26);
      }
    }
#line 1066
    if (MilterLogLevel > 13) {
      {
#line 1067
      tmp___27 = sm_errstring(save_errno);
#line 1067
      sm_syslog(6, (char const   *)e->e_id, "Milter (%s): open %s failed: %s", m->mf_name,
                at, tmp___27);
      }
    }
    {
#line 1070
    CurHostName = p;
#line 1071
    close(sock);
    }
#line 1074
    if ((unsigned long )hp != (unsigned long )((void *)0)) {
#line 1074
      if ((unsigned long )*(hp->h_addr_list + addrno) != (unsigned long )((void *)0)) {
        {
#line 1079
        if ((int )addr.sa.sa_family == 2) {
#line 1079
          goto case_2___0;
        }
#line 1094
        goto switch_default___0;
        case_2___0: /* CIL Label */ 
        {
#line 1080
        tmp___28 = addrno;
#line 1080
        addrno ++;
#line 1080
        memmove((void *)(& addr.sin.sin_addr), (void const   *)*(hp->h_addr_list + tmp___28),
                (size_t )4);
        }
#line 1083
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 1095
        if ((int )tTdvect[64] >= 5) {
          {
#line 1096
          sm_dprintf((char *)"X%s: Unknown protocol for %s (%d)\n", m->mf_name, at,
                     hp->h_addrtype);
          }
        }
#line 1099
        if (MilterLogLevel > 0) {
          {
#line 1100
          sm_syslog(3, (char const   *)e->e_id, "Milter (%s): Unknown protocol for %s (%d)",
                    m->mf_name, at, hp->h_addrtype);
          }
        }
        {
#line 1104
        milter_error(m, e);
        }
#line 1108
        return (-1);
        switch_break___0: /* CIL Label */ ;
        }
#line 1110
        goto __Cont;
      }
    }
#line 1112
    p = CurHostName;
#line 1113
    CurHostName = at;
#line 1114
    if ((int )tTdvect[64] >= 5) {
      {
#line 1115
      tmp___29 = sm_errstring(save_errno);
#line 1115
      sm_dprintf((char *)"X%s: error connecting to filter: %s\n", m->mf_name, tmp___29);
      }
    }
#line 1117
    if (MilterLogLevel > 0) {
      {
#line 1118
      tmp___30 = sm_errstring(save_errno);
#line 1118
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): error connecting to filter: %s",
                m->mf_name, tmp___30);
      }
    }
    {
#line 1121
    CurHostName = p;
#line 1122
    milter_error(m, e);
    }
#line 1127
    return (-1);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1129
  m->mf_state = (char )'O';
#line 1147
  return (sock);
}
}
#line 1150 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_connect_timeout(int ignore ) 
{ 
  int *tmp ;

  {
  {
#line 1160
  tmp = __errno_location();
#line 1160
  *tmp = 110;
#line 1161
  siglongjmp((struct __jmp_buf_tag *)(MilterConnectTimeout), 1);
  }
}
}
#line 1173 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
void milter_setup(char *line ) 
{ 
  char fcode ;
  register char *p ;
  register struct milter *m ;
  STAB *s ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *delimptr ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1183
  p = line;
  {
#line 1183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1183
    if ((int )*p != 0) {
#line 1183
      if ((int )*p != 44) {
#line 1183
        if (((int )*p & -128) == 0) {
          {
#line 1183
          tmp = __ctype_b_loc();
          }
#line 1183
          if ((int const   )*(*tmp + (int )*p) & 8192) {
#line 1183
            goto while_break;
          }
        }
      } else {
#line 1183
        goto while_break;
      }
    } else {
#line 1183
      goto while_break;
    }
#line 1186
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1183
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1187
  if ((int )*p != 0) {
#line 1188
    tmp___0 = p;
#line 1188
    p ++;
#line 1188
    *tmp___0 = (char )'\000';
  }
#line 1189
  if ((int )*(line + 0) == 0) {
    {
#line 1191
    syserr("name required for mail filter");
    }
#line 1192
    return;
  }
  {
#line 1194
  tmp___1 = xalloc_tagged((int )sizeof(*m), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                          1194);
#line 1194
  m = (struct milter *)tmp___1;
#line 1195
  memset((void *)((char *)m), '\000', (size_t )sizeof(*m));
#line 1196
  m->mf_name = newstr((char const   *)line);
#line 1197
  m->mf_state = (char )'R';
#line 1198
  m->mf_sock = -1;
#line 1199
  m->mf_timeout[3] = (time_t )300;
#line 1200
  m->mf_timeout[0] = (time_t )10;
#line 1201
  m->mf_timeout[1] = (time_t )10;
#line 1202
  m->mf_timeout[2] = (time_t )300;
  }
  {
#line 1205
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1205
    if (! ((int )*p != 0)) {
#line 1205
      goto while_break___0;
    }
    {
#line 1209
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1209
      if ((int )*p != 0) {
#line 1209
        if (! ((int )*p == 44)) {
#line 1209
          if (((int )*p & -128) == 0) {
            {
#line 1209
            tmp___2 = __ctype_b_loc();
            }
#line 1209
            if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 1209
              goto while_break___1;
            }
          } else {
#line 1209
            goto while_break___1;
          }
        }
      } else {
#line 1209
        goto while_break___1;
      }
#line 1211
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1214
    fcode = *p;
    {
#line 1215
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1215
      if ((int )*p != 0) {
#line 1215
        if ((int )*p != 61) {
#line 1215
          if (! ((int )*p != 44)) {
#line 1215
            goto while_break___2;
          }
        } else {
#line 1215
          goto while_break___2;
        }
      } else {
#line 1215
        goto while_break___2;
      }
#line 1216
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1217
    tmp___3 = p;
#line 1217
    p ++;
#line 1217
    if ((int )*tmp___3 != 61) {
      {
#line 1219
      syserr("X%s: `=\' expected", m->mf_name);
      }
#line 1220
      return;
    }
    {
#line 1222
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1222
      if (((int )*p & -128) == 0) {
        {
#line 1222
        tmp___4 = __ctype_b_loc();
        }
#line 1222
        if (! ((int const   )*(*tmp___4 + (int )*p) & 8192)) {
#line 1222
          goto while_break___3;
        }
      } else {
#line 1222
        goto while_break___3;
      }
#line 1223
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1226
    p = munchstring(p, & delimptr, ',');
    }
    {
#line 1231
    if ((int )fcode == 83) {
#line 1231
      goto case_83;
    }
#line 1238
    if ((int )fcode == 70) {
#line 1238
      goto case_70;
    }
#line 1246
    if ((int )fcode == 84) {
#line 1246
      goto case_84;
    }
#line 1250
    goto switch_default;
    case_83: /* CIL Label */ 
#line 1232
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1233
      m->mf_conn = (char *)((void *)0);
    } else {
      {
#line 1235
      m->mf_conn = newstr((char const   *)p);
      }
    }
#line 1236
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 1239
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1239
      if (! ((int )*p != 0)) {
#line 1239
        goto while_break___4;
      }
#line 1241
      if (((int )*p & -128) == 0) {
        {
#line 1241
        tmp___5 = __ctype_b_loc();
        }
#line 1241
        if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 1242
          m->mf_flags[(unsigned long )((unsigned char )((unsigned int )*p & 255U)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )((unsigned int )*p & 255U)) % (8UL * sizeof(int ));
        }
      } else {
#line 1242
        m->mf_flags[(unsigned long )((unsigned char )((unsigned int )*p & 255U)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )((unsigned int )*p & 255U)) % (8UL * sizeof(int ));
      }
#line 1239
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1244
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 1247
    milter_parse_timeouts(p, m);
    }
#line 1248
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1251
    syserr("X%s: unknown filter equate %c=", m->mf_name, (int )fcode);
    }
#line 1253
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1255
    p = delimptr;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1259
  milter_open(m, 1, CurEnv);
#line 1262
  s = stab(m->mf_name, 14, 1);
  }
#line 1263
  if ((unsigned long )s->s_value.sv_milter != (unsigned long )((void *)0)) {
    {
#line 1264
    syserr("X%s: duplicate filter definition", m->mf_name);
    }
  } else {
#line 1266
    s->s_value.sv_milter = m;
  }
#line 1267
  return;
}
}
#line 1282 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
void milter_config(char *spec , struct milter **list , int max ) 
{ 
  int numitems ;
  register char *p ;
  STAB *s ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1288
  numitems = 0;
#line 1292
  max --;
#line 1294
  p = spec;
  {
#line 1294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1294
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1294
      goto while_break;
    }
    {
#line 1298
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1298
      if (((int )*p & -128) == 0) {
        {
#line 1298
        tmp = __ctype_b_loc();
        }
#line 1298
        if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 1298
          goto while_break___0;
        }
      } else {
#line 1298
        goto while_break___0;
      }
#line 1299
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1300
    if ((int )*p == 0) {
#line 1301
      goto while_break;
    }
#line 1302
    spec = p;
#line 1304
    if (numitems >= max) {
      {
#line 1306
      syserr("Too many filters defined, %d max", max);
      }
#line 1307
      if (max > 0) {
#line 1308
        *(list + 0) = (struct milter *)((void *)0);
      }
#line 1309
      return;
    }
    {
#line 1311
    p = strpbrk((char const   *)p, ";,");
    }
#line 1312
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1313
      tmp___0 = p;
#line 1313
      p ++;
#line 1313
      *tmp___0 = (char )'\000';
    }
    {
#line 1315
    s = stab(spec, 14, 0);
    }
#line 1316
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
#line 1318
      syserr("InputFilter %s not defined", spec);
#line 1319
      ExitStat = 78;
      }
#line 1320
      return;
    }
#line 1322
    tmp___1 = numitems;
#line 1322
    numitems ++;
#line 1322
    *(list + tmp___1) = s->s_value.sv_milter;
  }
  while_break: /* CIL Label */ ;
  }
#line 1324
  *(list + numitems) = (struct milter *)((void *)0);
#line 1327
  if (MilterLogLevel == -1) {
#line 1328
    MilterLogLevel = LogLevel;
  }
#line 1329
  return;
}
}
#line 1343 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_parse_timeouts(char *spec , struct milter *m ) 
{ 
  char fcode ;
  int tcode ;
  register char *p ;
  char *delimptr ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1352
  p = spec;
  {
#line 1355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1355
    if (! ((int )*p != 0)) {
#line 1355
      goto while_break;
    }
    {
#line 1359
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1359
      if ((int )*p != 0) {
#line 1359
        if (! ((int )*p == 59)) {
#line 1359
          if (((int )*p & -128) == 0) {
            {
#line 1359
            tmp = __ctype_b_loc();
            }
#line 1359
            if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 1359
              goto while_break___0;
            }
          } else {
#line 1359
            goto while_break___0;
          }
        }
      } else {
#line 1359
        goto while_break___0;
      }
#line 1361
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1364
    fcode = *p;
    {
#line 1365
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1365
      if ((int )*p != 0) {
#line 1365
        if (! ((int )*p != 58)) {
#line 1365
          goto while_break___1;
        }
      } else {
#line 1365
        goto while_break___1;
      }
#line 1366
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1367
    tmp___0 = p;
#line 1367
    p ++;
#line 1367
    if ((int )*tmp___0 != 58) {
      {
#line 1369
      syserr("X%s, T=: `:\' expected", m->mf_name);
      }
#line 1370
      return;
    }
    {
#line 1372
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1372
      if (((int )*p & -128) == 0) {
        {
#line 1372
        tmp___1 = __ctype_b_loc();
        }
#line 1372
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 1372
          goto while_break___2;
        }
      } else {
#line 1372
        goto while_break___2;
      }
#line 1373
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1376
    p = munchstring(p, & delimptr, ';');
#line 1377
    tcode = -1;
    }
    {
#line 1382
    if ((int )fcode == 67) {
#line 1382
      goto case_67;
    }
#line 1386
    if ((int )fcode == 83) {
#line 1386
      goto case_83;
    }
#line 1390
    if ((int )fcode == 82) {
#line 1390
      goto case_82;
    }
#line 1394
    if ((int )fcode == 69) {
#line 1394
      goto case_69;
    }
#line 1398
    goto switch_default;
    case_67: /* CIL Label */ 
#line 1383
    tcode = 3;
#line 1384
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1387
    tcode = 0;
#line 1388
    goto switch_break;
    case_82: /* CIL Label */ 
#line 1391
    tcode = 1;
#line 1392
    goto switch_break;
    case_69: /* CIL Label */ 
#line 1395
    tcode = 2;
#line 1396
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1399
    if ((int )tTdvect[64] >= 5) {
      {
#line 1400
      sm_dprintf((char *)"X%s: %c unknown\n", m->mf_name, (int )fcode);
      }
    }
    {
#line 1402
    syserr("X%s: unknown filter timeout %c", m->mf_name, (int )fcode);
    }
#line 1404
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1406
    if (tcode >= 0) {
      {
#line 1408
      m->mf_timeout[tcode] = convtime(p, 's');
      }
#line 1409
      if ((int )tTdvect[64] >= 5) {
        {
#line 1410
        sm_dprintf((char *)"X%s: %c=%ld\n", m->mf_name, (int )fcode, (u_long )m->mf_timeout[tcode]);
        }
      }
    }
#line 1414
    p = delimptr;
  }
  while_break: /* CIL Label */ ;
  }
#line 1416
  return;
}
}
#line 1431 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static BITMAP256 StickyMilterOpt  ;
#line 1433 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static struct milteropt MilterOptTab[8]  = 
#line 1433
  {      {(char *)"macros.connect", (unsigned char)1}, 
        {(char *)"macros.helo", (unsigned char)2}, 
        {(char *)"macros.envfrom", (unsigned char)3}, 
        {(char *)"macros.envrcpt", (unsigned char)4}, 
        {(char *)"macros.data", (unsigned char)5}, 
        {(char *)"macros.eom", (unsigned char)6}, 
        {(char *)"loglevel", (unsigned char)7}, 
        {(char *)((void *)0), (unsigned char)0}};
#line 1460 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
void milter_set_option(char *name , char *val , bool sticky ) 
{ 
  int nummac ;
  register struct milteropt *mo ;
  char *p ;
  char **macros ;
  int tmp ;
  char *macro ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 1466
  nummac = 0;
#line 1469
  macros = (char **)((void *)0);
#line 1471
  if ((int )tTdvect[37] >= 2) {
    {
#line 1472
    sm_dprintf((char *)"milter_set_option(%s = %s)", name, val);
    }
  } else
#line 1471
  if ((int )tTdvect[64] >= 5) {
    {
#line 1472
    sm_dprintf((char *)"milter_set_option(%s = %s)", name, val);
    }
  }
#line 1474
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 1476
    syserr("milter_set_option: invalid Milter option, must specify suboption");
    }
#line 1477
    return;
  }
#line 1480
  mo = MilterOptTab;
  {
#line 1480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1480
    if (! ((unsigned long )mo->mo_name != (unsigned long )((void *)0))) {
#line 1480
      goto while_break;
    }
    {
#line 1482
    tmp = sm_strcasecmp((char const   *)mo->mo_name, (char const   *)name);
    }
#line 1482
    if (tmp == 0) {
#line 1483
      goto while_break;
    }
#line 1480
    mo ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1486
  if ((unsigned long )mo->mo_name == (unsigned long )((void *)0)) {
    {
#line 1488
    syserr("milter_set_option: invalid Milter option %s", name);
    }
#line 1489
    return;
  }
#line 1496
  if (! sticky) {
#line 1496
    if (StickyMilterOpt[(unsigned long )mo->mo_code / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )mo->mo_code % (8UL * sizeof(int )))) {
#line 1498
      if ((int )tTdvect[37] >= 2) {
        {
#line 1499
        sm_dprintf((char *)" (ignored)\n");
        }
      } else
#line 1498
      if ((int )tTdvect[64] >= 5) {
        {
#line 1499
        sm_dprintf((char *)" (ignored)\n");
        }
      }
#line 1500
      return;
    }
  }
#line 1503
  if ((int )tTdvect[37] >= 2) {
    {
#line 1504
    sm_dprintf((char *)"\n");
    }
  } else
#line 1503
  if ((int )tTdvect[64] >= 5) {
    {
#line 1504
    sm_dprintf((char *)"\n");
    }
  }
  {
#line 1508
  if ((int )mo->mo_code == 7) {
#line 1508
    goto case_7;
  }
#line 1518
  if ((int )mo->mo_code == 1) {
#line 1518
    goto case_1;
  }
#line 1523
  if ((int )mo->mo_code == 2) {
#line 1523
    goto case_2;
  }
#line 1528
  if ((int )mo->mo_code == 3) {
#line 1528
    goto case_3;
  }
#line 1533
  if ((int )mo->mo_code == 4) {
#line 1533
    goto case_4;
  }
#line 1538
  if ((int )mo->mo_code == 6) {
#line 1538
    goto case_6;
  }
#line 1543
  if ((int )mo->mo_code == 5) {
#line 1543
    goto case_5;
  }
#line 1580
  goto switch_default;
  case_7: /* CIL Label */ 
  {
#line 1509
  MilterLogLevel = atoi((char const   *)val);
  }
#line 1510
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1519
  if ((unsigned long )macros == (unsigned long )((void *)0)) {
#line 1520
    macros = MilterConnectMacros;
  }
  case_2: /* CIL Label */ 
#line 1524
  if ((unsigned long )macros == (unsigned long )((void *)0)) {
#line 1525
    macros = MilterHeloMacros;
  }
  case_3: /* CIL Label */ 
#line 1529
  if ((unsigned long )macros == (unsigned long )((void *)0)) {
#line 1530
    macros = MilterEnvFromMacros;
  }
  case_4: /* CIL Label */ 
#line 1534
  if ((unsigned long )macros == (unsigned long )((void *)0)) {
#line 1535
    macros = MilterEnvRcptMacros;
  }
  case_6: /* CIL Label */ 
#line 1539
  if ((unsigned long )macros == (unsigned long )((void *)0)) {
#line 1540
    macros = MilterEOMMacros;
  }
  case_5: /* CIL Label */ 
#line 1544
  if ((unsigned long )macros == (unsigned long )((void *)0)) {
#line 1545
    macros = MilterDataMacros;
  }
  {
#line 1547
  p = newstr((char const   *)val);
  }
  {
#line 1548
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1548
    if (! ((int )*p != 0)) {
#line 1548
      goto while_break___0;
    }
    {
#line 1553
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1553
      if ((int )*p != 0) {
#line 1553
        if (! ((int )*p == 44)) {
#line 1553
          if (((int )*p & -128) == 0) {
            {
#line 1553
            tmp___0 = __ctype_b_loc();
            }
#line 1553
            if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 1553
              goto while_break___1;
            }
          } else {
#line 1553
            goto while_break___1;
          }
        }
      } else {
#line 1553
        goto while_break___1;
      }
#line 1555
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1557
    if ((int )*p == 0) {
#line 1558
      goto while_break___0;
    }
#line 1561
    macro = p;
    {
#line 1562
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1562
      if ((int )*p != 0) {
#line 1562
        if ((int )*p != 44) {
#line 1562
          if (((int )*p & -128) == 0) {
            {
#line 1562
            tmp___1 = __ctype_b_loc();
            }
#line 1562
            if ((int const   )*(*tmp___1 + (int )*p) & 8192) {
#line 1562
              goto while_break___2;
            }
          } else {
#line 1562
            goto while_break___2;
          }
        } else {
#line 1562
          goto while_break___2;
        }
      } else {
#line 1562
        goto while_break___2;
      }
#line 1564
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1565
    if ((int )*p != 0) {
#line 1566
      tmp___2 = p;
#line 1566
      p ++;
#line 1566
      *tmp___2 = (char )'\000';
    }
#line 1568
    if (nummac >= 50) {
      {
#line 1570
      syserr("milter_set_option: too many macros in Milter.%s (max %d)", name, 50);
#line 1572
      *(macros + nummac) = (char *)((void *)0);
      }
#line 1573
      goto while_break___0;
    }
#line 1575
    tmp___3 = nummac;
#line 1575
    nummac ++;
#line 1575
    *(macros + tmp___3) = macro;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1577
  *(macros + nummac) = (char *)((void *)0);
#line 1578
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1581
  syserr("milter_set_option: invalid Milter option %s", name);
  }
#line 1582
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1584
  if (sticky) {
#line 1585
    StickyMilterOpt[(unsigned long )mo->mo_code / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )mo->mo_code % (8UL * sizeof(int ));
  }
#line 1586
  return;
}
}
#line 1597 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static int milter_reopen_df(ENVELOPE *e ) 
{ 
  char dfname[4096] ;
  char *tmp ;
  int save_errno ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  SM_FILE_T *tmp___4 ;
  int *tmp___5 ;
  int save_errno___0 ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int *tmp___9 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 1603
  tmp = queuename(e, 'd');
#line 1603
  sm_strlcpy(dfname, (char const   *)tmp, (ssize_t )sizeof(dfname));
  }
#line 1615
  if (SuperSafe == 2) {
#line 1618
    if ((e->e_flags & 2097152UL) != 0UL) {
#line 1618
      if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
        {
#line 1620
        sm_io_close(e->e_dfp, -2);
#line 1621
        e->e_flags &= 0xffffffffffdfffffUL;
        }
      }
    }
    {
#line 1625
    tmp___4 = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)(dfname),
                         1, (void const   *)((void *)0));
#line 1625
    e->e_dfp = tmp___4;
    }
#line 1625
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
      {
#line 1628
      tmp___0 = __errno_location();
#line 1628
      save_errno = *tmp___0;
      }
#line 1628
      if ((int )tTdvect[64] >= 5) {
        {
#line 1628
        tmp___1 = sm_errstring(save_errno);
#line 1628
        sm_dprintf((char *)"milter_reopen_df: sm_io_open %s: %s", dfname, tmp___1);
#line 1628
        sm_dprintf((char *)"\n");
        }
      }
#line 1628
      if (MilterLogLevel > 0) {
        {
#line 1628
        tmp___2 = sm_errstring(save_errno);
#line 1628
        sm_syslog(3, (char const   *)e->e_id, "milter_reopen_df: sm_io_open %s: %s",
                  dfname, tmp___2);
        }
      }
#line 1628
      if (SuperSafe == 2) {
#line 1628
        if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
          {
#line 1628
          sm_io_close(e->e_dfp, -2);
#line 1628
          e->e_dfp = (SM_FILE_T *)((void *)0);
          }
        }
#line 1628
        e->e_flags &= 0xffffffffffdfffffUL;
      }
      {
#line 1628
      tmp___3 = __errno_location();
#line 1628
      *tmp___3 = save_errno;
      }
#line 1629
      return (-1);
    }
  } else
#line 1632
  if ((unsigned long )e->e_dfp == (unsigned long )((void *)0)) {
    {
#line 1635
    tmp___5 = __errno_location();
#line 1635
    *tmp___5 = 2;
#line 1636
    tmp___6 = __errno_location();
#line 1636
    save_errno___0 = *tmp___6;
    }
#line 1636
    if ((int )tTdvect[64] >= 5) {
      {
#line 1636
      tmp___7 = sm_errstring(save_errno___0);
#line 1636
      sm_dprintf((char *)"milter_reopen_df: NULL e_dfp (%s: %s)", dfname, tmp___7);
#line 1636
      sm_dprintf((char *)"\n");
      }
    }
#line 1636
    if (MilterLogLevel > 0) {
      {
#line 1636
      tmp___8 = sm_errstring(save_errno___0);
#line 1636
      sm_syslog(3, (char const   *)e->e_id, "milter_reopen_df: NULL e_dfp (%s: %s)",
                dfname, tmp___8);
      }
    }
#line 1636
    if (SuperSafe == 2) {
#line 1636
      if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
        {
#line 1636
        sm_io_close(e->e_dfp, -2);
#line 1636
        e->e_dfp = (SM_FILE_T *)((void *)0);
        }
      }
#line 1636
      e->e_flags &= 0xffffffffffdfffffUL;
    }
    {
#line 1636
    tmp___9 = __errno_location();
#line 1636
    *tmp___9 = save_errno___0;
    }
#line 1637
    return (-1);
  }
#line 1639
  return (0);
}
}
#line 1651 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static int milter_reset_df(ENVELOPE *e ) 
{ 
  int afd ;
  char dfname[4096] ;
  char *tmp ;
  int save_errno ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int save_errno___0 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int *tmp___7 ;
  int save_errno___1 ;
  int *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  int *tmp___11 ;
  int save_errno___2 ;
  int *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  int *tmp___15 ;
  SM_FILE_T *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
#line 1658
  tmp = queuename(e, 'd');
#line 1658
  sm_strlcpy(dfname, (char const   *)tmp, (ssize_t )sizeof(dfname));
#line 1660
  tmp___19 = sm_io_flush(e->e_dfp, -2);
  }
#line 1660
  if (tmp___19 != 0) {
#line 1660
    goto _L___0;
  } else
#line 1660
  if (((e->e_dfp)->f_flags & 256L) != 0L) {
    _L___0: /* CIL Label */ 
    {
#line 1663
    tmp___0 = __errno_location();
#line 1663
    save_errno = *tmp___0;
    }
#line 1663
    if ((int )tTdvect[64] >= 5) {
      {
#line 1663
      tmp___1 = sm_errstring(save_errno);
#line 1663
      sm_dprintf((char *)"milter_reset_df: error writing/flushing %s: %s", dfname,
                 tmp___1);
#line 1663
      sm_dprintf((char *)"\n");
      }
    }
#line 1663
    if (MilterLogLevel > 0) {
      {
#line 1663
      tmp___2 = sm_errstring(save_errno);
#line 1663
      sm_syslog(3, (char const   *)e->e_id, "milter_reset_df: error writing/flushing %s: %s",
                dfname, tmp___2);
      }
    }
#line 1663
    if (SuperSafe == 2) {
#line 1663
      if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
        {
#line 1663
        sm_io_close(e->e_dfp, -2);
#line 1663
        e->e_dfp = (SM_FILE_T *)((void *)0);
        }
      }
#line 1663
      e->e_flags &= 0xffffffffffdfffffUL;
    }
    {
#line 1663
    tmp___3 = __errno_location();
#line 1663
    *tmp___3 = save_errno;
    }
#line 1664
    return (-1);
  } else
#line 1666
  if (! (SuperSafe != 2)) {
    {
#line 1671
    afd = sm_io_getinfo(e->e_dfp, 3, (void *)0);
    }
#line 1671
    if (afd >= 0) {
      {
#line 1671
      tmp___18 = fsync(afd);
      }
#line 1671
      if (tmp___18 < 0) {
        {
#line 1674
        tmp___4 = __errno_location();
#line 1674
        save_errno___0 = *tmp___4;
        }
#line 1674
        if ((int )tTdvect[64] >= 5) {
          {
#line 1674
          tmp___5 = sm_errstring(save_errno___0);
#line 1674
          sm_dprintf((char *)"milter_reset_df: error sync\'ing %s: %s", dfname, tmp___5);
#line 1674
          sm_dprintf((char *)"\n");
          }
        }
#line 1674
        if (MilterLogLevel > 0) {
          {
#line 1674
          tmp___6 = sm_errstring(save_errno___0);
#line 1674
          sm_syslog(3, (char const   *)e->e_id, "milter_reset_df: error sync\'ing %s: %s",
                    dfname, tmp___6);
          }
        }
#line 1674
        if (SuperSafe == 2) {
#line 1674
          if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
            {
#line 1674
            sm_io_close(e->e_dfp, -2);
#line 1674
            e->e_dfp = (SM_FILE_T *)((void *)0);
            }
          }
#line 1674
          e->e_flags &= 0xffffffffffdfffffUL;
        }
        {
#line 1674
        tmp___7 = __errno_location();
#line 1674
        *tmp___7 = save_errno___0;
        }
#line 1675
        return (-1);
      } else {
#line 1671
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1677
      tmp___17 = sm_io_close(e->e_dfp, -2);
      }
#line 1677
      if (tmp___17 < 0) {
        {
#line 1679
        tmp___8 = __errno_location();
#line 1679
        save_errno___1 = *tmp___8;
        }
#line 1679
        if ((int )tTdvect[64] >= 5) {
          {
#line 1679
          tmp___9 = sm_errstring(save_errno___1);
#line 1679
          sm_dprintf((char *)"milter_reset_df: error closing %s: %s", dfname, tmp___9);
#line 1679
          sm_dprintf((char *)"\n");
          }
        }
#line 1679
        if (MilterLogLevel > 0) {
          {
#line 1679
          tmp___10 = sm_errstring(save_errno___1);
#line 1679
          sm_syslog(3, (char const   *)e->e_id, "milter_reset_df: error closing %s: %s",
                    dfname, tmp___10);
          }
        }
#line 1679
        if (SuperSafe == 2) {
#line 1679
          if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
            {
#line 1679
            sm_io_close(e->e_dfp, -2);
#line 1679
            e->e_dfp = (SM_FILE_T *)((void *)0);
            }
          }
#line 1679
          e->e_flags &= 0xffffffffffdfffffUL;
        }
        {
#line 1679
        tmp___11 = __errno_location();
#line 1679
        *tmp___11 = save_errno___1;
        }
#line 1680
        return (-1);
      } else {
        {
#line 1682
        tmp___16 = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)(dfname),
                              2, (void const   *)((void *)0));
#line 1682
        e->e_dfp = tmp___16;
        }
#line 1682
        if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
          {
#line 1685
          tmp___12 = __errno_location();
#line 1685
          save_errno___2 = *tmp___12;
          }
#line 1685
          if ((int )tTdvect[64] >= 5) {
            {
#line 1685
            tmp___13 = sm_errstring(save_errno___2);
#line 1685
            sm_dprintf((char *)"milter_reset_df: error reopening %s: %s", dfname,
                       tmp___13);
#line 1685
            sm_dprintf((char *)"\n");
            }
          }
#line 1685
          if (MilterLogLevel > 0) {
            {
#line 1685
            tmp___14 = sm_errstring(save_errno___2);
#line 1685
            sm_syslog(3, (char const   *)e->e_id, "milter_reset_df: error reopening %s: %s",
                      dfname, tmp___14);
            }
          }
#line 1685
          if (SuperSafe == 2) {
#line 1685
            if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
              {
#line 1685
              sm_io_close(e->e_dfp, -2);
#line 1685
              e->e_dfp = (SM_FILE_T *)((void *)0);
              }
            }
#line 1685
            e->e_flags &= 0xffffffffffdfffffUL;
          }
          {
#line 1685
          tmp___15 = __errno_location();
#line 1685
          *tmp___15 = save_errno___2;
          }
#line 1686
          return (-1);
        } else {
#line 1689
          e->e_flags |= 2097152UL;
        }
      }
    }
  }
#line 1690
  return (0);
}
}
#line 1702 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
bool milter_can_delrcpts(void) 
{ 
  bool can ;
  int i ;
  struct milter *m ;
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1705
  can = 0;
#line 1708
  if ((int )tTdvect[64] >= 10) {
    {
#line 1709
    sm_dprintf((char *)"milter_can_delrcpts:");
    }
  }
#line 1711
  i = 0;
  {
#line 1711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1711
    if (! ((unsigned long )InputFilters[i] != (unsigned long )((void *)0))) {
#line 1711
      goto while_break;
    }
#line 1713
    m = InputFilters[i];
#line 1715
    if (((long )m->mf_fflags & 8L) != 0L) {
#line 1717
      can = 1;
#line 1718
      goto while_break;
    }
#line 1711
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1721
  if ((int )tTdvect[64] >= 10) {
#line 1722
    if (can) {
#line 1722
      tmp = "true";
    } else {
#line 1722
      tmp = "false";
    }
    {
#line 1722
    sm_dprintf((char *)"%s\n", tmp);
    }
  }
#line 1724
  return (can);
}
}
#line 1737 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_quit_filter(struct milter *m , ENVELOPE *e ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 1742
  if ((int )tTdvect[64] >= 10) {
    {
#line 1743
    sm_dprintf((char *)"milter_quit_filter(%s)\n", m->mf_name);
    }
  }
#line 1744
  if (MilterLogLevel > 18) {
    {
#line 1745
    sm_syslog(6, (char const   *)e->e_id, "Milter (%s): quit filter", m->mf_name);
    }
  }
#line 1749
  if ((int )m->mf_state == 69) {
#line 1750
    return;
  }
#line 1752
  if (m->mf_sock < 0) {
#line 1756
    m->mf_sock = -1;
#line 1757
    m->mf_state = (char )'C';
#line 1758
    return;
  } else
#line 1752
  if ((int )m->mf_state == 67) {
#line 1756
    m->mf_sock = -1;
#line 1757
    m->mf_state = (char )'C';
#line 1758
    return;
  } else
#line 1752
  if ((int )m->mf_state == 82) {
#line 1756
    m->mf_sock = -1;
#line 1757
    m->mf_state = (char )'C';
#line 1758
    return;
  }
  {
#line 1761
  milter_write(m, (char )'Q', (char *)((void *)0), 0, m->mf_timeout[0], e);
  }
#line 1763
  if (m->mf_sock >= 0) {
    {
#line 1765
    close(m->mf_sock);
#line 1766
    m->mf_sock = -1;
    }
  }
#line 1768
  if ((int )m->mf_state != 69) {
#line 1769
    m->mf_state = (char )'C';
  }
#line 1770
  return;
}
}
#line 1782 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_abort_filter(struct milter *m , ENVELOPE *e ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 1787
  if ((int )tTdvect[64] >= 10) {
    {
#line 1788
    sm_dprintf((char *)"milter_abort_filter(%s)\n", m->mf_name);
    }
  }
#line 1789
  if (MilterLogLevel > 10) {
    {
#line 1790
    sm_syslog(6, (char const   *)e->e_id, "Milter (%s): abort filter", m->mf_name);
    }
  }
#line 1793
  if (m->mf_sock < 0) {
#line 1795
    return;
  } else
#line 1793
  if ((int )m->mf_state != 77) {
#line 1795
    return;
  }
  {
#line 1797
  milter_write(m, (char )'A', (char *)((void *)0), 0, m->mf_timeout[0], e);
  }
#line 1799
  if ((int )m->mf_state != 69) {
#line 1800
    m->mf_state = (char )'D';
  }
#line 1801
  return;
}
}
#line 1815 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_send_macros(struct milter *m , char **macros , char cmd , ENVELOPE *e ) 
{ 
  int i ;
  int mid ;
  char *v ;
  char *buf___16 ;
  char *bp___3 ;
  char exp[2048] ;
  ssize_t s ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 1830
  if ((unsigned long )macros == (unsigned long )((void *)0)) {
#line 1831
    return;
  } else
#line 1830
  if ((unsigned long )*(macros + 0) == (unsigned long )((void *)0)) {
#line 1831
    return;
  }
#line 1834
  s = 1;
#line 1835
  i = 0;
  {
#line 1835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1835
    if (! ((unsigned long )*(macros + i) != (unsigned long )((void *)0))) {
#line 1835
      goto while_break;
    }
    {
#line 1837
    mid = macid_parse(*(macros + i), (char **)((void *)0));
    }
#line 1838
    if (mid == 0) {
#line 1839
      goto __Cont;
    }
    {
#line 1840
    v = macvalue(mid, e);
    }
#line 1841
    if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 1842
      goto __Cont;
    }
    {
#line 1843
    expand(v, exp, (size_t )sizeof(exp), e);
#line 1844
    tmp = strlen((char const   *)*(macros + i));
#line 1844
    tmp___0 = strlen((char const   *)(exp));
#line 1844
    s = (ssize_t )((size_t )s + (((tmp + 1U) + tmp___0) + 1U));
    }
    __Cont: /* CIL Label */ 
#line 1835
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1847
  if (s < 0) {
#line 1848
    return;
  }
  {
#line 1850
  tmp___1 = xalloc_tagged(s, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                          1850);
#line 1850
  buf___16 = tmp___1;
#line 1851
  bp___3 = buf___16;
#line 1852
  tmp___2 = bp___3;
#line 1852
  bp___3 ++;
#line 1852
  *tmp___2 = cmd;
#line 1853
  i = 0;
  }
  {
#line 1853
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1853
    if (! ((unsigned long )*(macros + i) != (unsigned long )((void *)0))) {
#line 1853
      goto while_break___0;
    }
    {
#line 1855
    mid = macid_parse(*(macros + i), (char **)((void *)0));
    }
#line 1856
    if (mid == 0) {
#line 1857
      goto __Cont___0;
    }
    {
#line 1858
    v = macvalue(mid, e);
    }
#line 1859
    if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 1860
      goto __Cont___0;
    }
    {
#line 1861
    expand(v, exp, (size_t )sizeof(exp), e);
    }
#line 1863
    if ((int )tTdvect[64] >= 10) {
      {
#line 1864
      sm_dprintf((char *)"milter_send_macros(%s, %c): %s=%s\n", m->mf_name, (int )cmd,
                 *(macros + i), exp);
      }
    }
    {
#line 1867
    sm_strlcpy(bp___3, (char const   *)*(macros + i), (ssize_t )((long )s - (bp___3 - buf___16)));
#line 1868
    tmp___3 = strlen((char const   *)bp___3);
#line 1868
    bp___3 += tmp___3 + 1U;
#line 1869
    sm_strlcpy(bp___3, (char const   *)(exp), (ssize_t )((long )s - (bp___3 - buf___16)));
#line 1870
    tmp___4 = strlen((char const   *)bp___3);
#line 1870
    bp___3 += tmp___4 + 1U;
    }
    __Cont___0: /* CIL Label */ 
#line 1853
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1872
  milter_write(m, (char )'D', buf___16, s, m->mf_timeout[0], e);
#line 1874
  sm_free_tagged((void *)buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                 1874);
  }
#line 1875
  return;
}
}
#line 1892 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *milter_send_command(struct milter *m , char command , void *data , ssize_t sz ,
                                 ENVELOPE *e , char *state ) 
{ 
  char rcmd___0 ;
  ssize_t rlen ;
  unsigned long skipflag ;
  char *action ;
  char *defresponse ;
  char *response ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *ptr ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
#line 1911
  if ((int )tTdvect[64] >= 10) {
    {
#line 1912
    sm_dprintf((char *)"milter_send_command(%s): cmd %c len %ld\n", m->mf_name, (int )command,
               (long )sz);
    }
  }
  {
#line 1918
  if ((int )command == 67) {
#line 1918
    goto case_67;
  }
#line 1924
  if ((int )command == 72) {
#line 1924
    goto case_72;
  }
#line 1930
  if ((int )command == 77) {
#line 1930
    goto case_77;
  }
#line 1936
  if ((int )command == 82) {
#line 1936
    goto case_82;
  }
#line 1942
  if ((int )command == 76) {
#line 1942
    goto case_76;
  }
#line 1951
  if ((int )command == 66) {
#line 1951
    goto case_66;
  }
#line 1957
  if ((int )command == 78) {
#line 1957
    goto case_78;
  }
#line 1987
  goto switch_default;
  case_67: /* CIL Label */ 
#line 1919
  skipflag = 1UL;
#line 1920
  action = (char *)"connect";
#line 1921
  defresponse = (char *)"554 Command rejected";
#line 1922
  goto switch_break;
  case_72: /* CIL Label */ 
#line 1925
  skipflag = 2UL;
#line 1926
  action = (char *)"helo";
#line 1927
  defresponse = (char *)"550 Command rejected";
#line 1928
  goto switch_break;
  case_77: /* CIL Label */ 
#line 1931
  skipflag = 4UL;
#line 1932
  action = (char *)"mail";
#line 1933
  defresponse = (char *)"550 5.7.1 Command rejected";
#line 1934
  goto switch_break;
  case_82: /* CIL Label */ 
#line 1937
  skipflag = 8UL;
#line 1938
  action = (char *)"rcpt";
#line 1939
  defresponse = (char *)"550 5.7.1 Command rejected";
#line 1940
  goto switch_break;
  case_76: /* CIL Label */ 
#line 1943
  skipflag = 32UL;
#line 1947
  action = (char *)"header";
#line 1948
  defresponse = (char *)"550 5.7.1 Command rejected";
#line 1949
  goto switch_break;
  case_66: /* CIL Label */ 
#line 1952
  skipflag = 16UL;
#line 1953
  action = (char *)"body";
#line 1954
  defresponse = (char *)"554 5.7.1 Command rejected";
#line 1955
  goto switch_break;
  case_78: /* CIL Label */ 
#line 1958
  skipflag = 64UL;
#line 1959
  action = (char *)"eoh";
#line 1960
  defresponse = (char *)"550 5.7.1 Command rejected";
#line 1961
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1988
  skipflag = 0UL;
#line 1989
  action = (char *)"default";
#line 1990
  defresponse = (char *)"550 5.7.1 Command rejected";
#line 1991
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1995
  if (skipflag != 0UL) {
#line 1995
    if (((unsigned long )m->mf_pflags & skipflag) != 0UL) {
#line 1997
      return ((char *)((void *)0));
    }
  }
  {
#line 2000
  milter_write(m, command, (char *)data, sz, m->mf_timeout[0], e);
  }
#line 2002
  if ((int )m->mf_state == 69) {
#line 2004
    if ((int )tTdvect[71] >= 100) {
#line 2004
      if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
        {
#line 2004
        e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 2004
        tmp = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 2004
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                         2004, SmHeapGroup);
        }
      }
    } else
#line 2004
    if ((int )tTdvect[71] >= 101) {
#line 2004
      if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
        {
#line 2004
        e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 2004
        tmp___0 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 2004
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___0, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                         2004, SmHeapGroup);
        }
      }
    } else
#line 2004
    if (m->mf_flags[84UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 84UL % (8UL * sizeof(int )))) {
#line 2004
      *state = (char )'t';
    } else
#line 2004
    if (m->mf_flags[52UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 52UL % (8UL * sizeof(int )))) {
#line 2004
      *state = (char )'4';
    } else
#line 2004
    if (m->mf_flags[82UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 82UL % (8UL * sizeof(int )))) {
#line 2004
      *state = (char )'r';
    } else {
#line 2004
      return ((char *)((void *)0));
    }
#line 2005
    return ((char *)((void *)0));
  }
  {
#line 2015
  response = milter_read(m, & rcmd___0, & rlen, m->mf_timeout[1], e);
  }
#line 2017
  if ((int )m->mf_state == 69) {
#line 2019
    if ((int )tTdvect[71] >= 100) {
#line 2019
      if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
        {
#line 2019
        e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 2019
        tmp___1 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 2019
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___1, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                         2019, SmHeapGroup);
        }
      }
    } else
#line 2019
    if ((int )tTdvect[71] >= 101) {
#line 2019
      if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
        {
#line 2019
        e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 2019
        tmp___2 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 2019
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___2, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                         2019, SmHeapGroup);
        }
      }
    } else
#line 2019
    if (m->mf_flags[84UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 84UL % (8UL * sizeof(int )))) {
#line 2019
      *state = (char )'t';
    } else
#line 2019
    if (m->mf_flags[52UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 52UL % (8UL * sizeof(int )))) {
#line 2019
      *state = (char )'4';
    } else
#line 2019
    if (m->mf_flags[82UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 82UL % (8UL * sizeof(int )))) {
#line 2019
      *state = (char )'r';
    } else {
#line 2019
      return ((char *)((void *)0));
    }
#line 2020
    return ((char *)((void *)0));
  }
#line 2023
  if ((int )tTdvect[64] >= 10) {
    {
#line 2024
    sm_dprintf((char *)"milter_send_command(%s): returned %c\n", m->mf_name, (int )rcmd___0);
    }
  }
  {
#line 2029
  if ((int )rcmd___0 == 121) {
#line 2029
    goto case_121;
  }
#line 2037
  if ((int )rcmd___0 == 114) {
#line 2037
    goto case_114;
  }
#line 2044
  if ((int )rcmd___0 == 100) {
#line 2044
    goto case_100;
  }
#line 2051
  if ((int )rcmd___0 == 116) {
#line 2051
    goto case_116;
  }
#line 2058
  if ((int )rcmd___0 == 97) {
#line 2058
    goto case_97;
  }
#line 2070
  if ((int )rcmd___0 == 99) {
#line 2070
    goto case_99;
  }
#line 2079
  goto switch_default___0;
  case_121: /* CIL Label */ 
#line 2030
  if ((unsigned long )response == (unsigned long )((void *)0)) {
#line 2030
    goto _L;
  } else {
    {
#line 2030
    tmp___3 = strlen((char const   *)response);
    }
#line 2030
    if (tmp___3 + 1U != (size_t )rlen) {
#line 2030
      goto _L;
    } else
#line 2030
    if (rlen < 3) {
#line 2030
      goto _L;
    } else
#line 2030
    if ((int )*(response + 0) != 52) {
#line 2030
      if ((int )*(response + 0) != 53) {
#line 2030
        goto _L;
      } else {
#line 2030
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2030
    if (! (((int )*(response + 1) & -128) == 0)) {
#line 2030
      goto _L;
    } else {
      {
#line 2030
      tmp___4 = __ctype_b_loc();
      }
#line 2030
      if ((int const   )*(*tmp___4 + (int )*(response + 1)) & 2048) {
#line 2030
        if (! (((int )*(response + 2) & -128) == 0)) {
#line 2030
          goto _L;
        } else {
          {
#line 2030
          tmp___5 = __ctype_b_loc();
          }
#line 2030
          if ((int const   )*(*tmp___5 + (int )*(response + 2)) & 2048) {
#line 2030
            ptr = response;
            {
#line 2030
            while (1) {
              while_continue: /* CIL Label */ ;
#line 2030
              if (! ((int )*ptr != 0)) {
#line 2030
                goto while_break;
              }
#line 2030
              if ((int )*ptr == 37) {
#line 2030
                ptr ++;
#line 2030
                if ((int )*ptr != 37) {
                  {
#line 2030
                  sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                                 2030);
#line 2030
                  response = newstr((char const   *)defresponse);
                  }
#line 2030
                  goto while_break;
                }
              }
#line 2030
              ptr ++;
            }
            while_break: /* CIL Label */ ;
            }
          } else {
            _L: /* CIL Label */ 
#line 2030
            if ((unsigned long )response != (unsigned long )((void *)0)) {
              {
#line 2030
              sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                             2030);
              }
            }
            {
#line 2030
            response = newstr((char const   *)defresponse);
            }
          }
        }
      } else {
#line 2030
        goto _L;
      }
    }
  }
#line 2031
  if (MilterLogLevel > 10) {
    {
#line 2032
    sm_syslog(6, (char const   *)e->e_id, "milter=%s, action=%s, reject=%s", m->mf_name,
              action, response);
    }
  }
#line 2034
  *state = rcmd___0;
#line 2035
  goto switch_break___0;
  case_114: /* CIL Label */ 
#line 2038
  if (MilterLogLevel > 10) {
    {
#line 2039
    sm_syslog(6, (char const   *)e->e_id, "milter=%s, action=%s, reject", m->mf_name,
              action);
    }
  }
#line 2041
  *state = rcmd___0;
#line 2042
  goto switch_break___0;
  case_100: /* CIL Label */ 
#line 2045
  if (MilterLogLevel > 10) {
    {
#line 2046
    sm_syslog(6, (char const   *)e->e_id, "milter=%s, action=%s, discard", m->mf_name,
              action);
    }
  }
#line 2048
  *state = rcmd___0;
#line 2049
  goto switch_break___0;
  case_116: /* CIL Label */ 
#line 2052
  if (MilterLogLevel > 10) {
    {
#line 2053
    sm_syslog(6, (char const   *)e->e_id, "milter=%s, action=%s, tempfail", m->mf_name,
              action);
    }
  }
#line 2055
  *state = rcmd___0;
#line 2056
  goto switch_break___0;
  case_97: /* CIL Label */ 
#line 2060
  if ((int )command == 72) {
#line 2062
    m->mf_state = (char )'Q';
  } else
#line 2060
  if ((int )command == 67) {
#line 2062
    m->mf_state = (char )'Q';
  } else {
#line 2064
    m->mf_state = (char )'D';
  }
#line 2065
  if (MilterLogLevel > 10) {
    {
#line 2066
    sm_syslog(6, (char const   *)e->e_id, "milter=%s, action=%s, accepted", m->mf_name,
              action);
    }
  }
#line 2068
  goto switch_break___0;
  case_99: /* CIL Label */ 
#line 2072
  if ((int )command == 77) {
#line 2073
    m->mf_state = (char )'M';
  }
#line 2074
  if (MilterLogLevel > 12) {
    {
#line 2075
    sm_syslog(6, (char const   *)e->e_id, "milter=%s, action=%s, continue", m->mf_name,
              action);
    }
  }
#line 2077
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 2081
  if (MilterLogLevel > 0) {
    {
#line 2082
    sm_syslog(3, (char const   *)e->e_id, "milter_send_command(%s): action=%s returned bogus response %c",
              m->mf_name, action, (int )rcmd___0);
    }
  }
  {
#line 2085
  milter_error(m, e);
  }
#line 2086
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2089
  if ((int )*state != 121) {
#line 2089
    if ((unsigned long )response != (unsigned long )((void *)0)) {
      {
#line 2092
      sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                     2092);
#line 2093
      response = (char *)((void *)0);
      }
    }
  }
#line 2095
  return (response);
}
}
#line 2113 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *milter_command(char command , void *data , ssize_t sz , char **macros ,
                            ENVELOPE *e , char *state ) 
{ 
  int i ;
  char *response ;
  time_t tn ;
  struct milter *m ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  time_t tmp___3 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 2123
  response = (char *)((void *)0);
#line 2124
  tn = (time_t )0;
#line 2126
  if ((int )tTdvect[64] >= 10) {
    {
#line 2127
    sm_dprintf((char *)"milter_command: cmd %c len %ld\n", (int )command, (long )sz);
    }
  }
#line 2130
  *state = (char )'c';
#line 2131
  i = 0;
  {
#line 2131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2131
    if (! ((unsigned long )InputFilters[i] != (unsigned long )((void *)0))) {
#line 2131
      goto while_break;
    }
#line 2133
    m = InputFilters[i];
#line 2136
    if ((int )m->mf_state == 69) {
#line 2138
      if ((int )tTdvect[71] >= 100) {
#line 2138
        if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
          {
#line 2138
          e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 2138
          tmp = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 2138
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                           2138, SmHeapGroup);
          }
        }
      } else
#line 2138
      if ((int )tTdvect[71] >= 101) {
#line 2138
        if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
          {
#line 2138
          e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 2138
          tmp___0 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 2138
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___0, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                           2138, SmHeapGroup);
          }
        }
      } else
#line 2138
      if (m->mf_flags[84UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 84UL % (8UL * sizeof(int )))) {
#line 2138
        *state = (char )'t';
      } else
#line 2138
      if (m->mf_flags[52UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 52UL % (8UL * sizeof(int )))) {
#line 2138
        *state = (char )'4';
      } else
#line 2138
      if (m->mf_flags[82UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 82UL % (8UL * sizeof(int )))) {
#line 2138
        *state = (char )'r';
      } else {
#line 2138
        goto __Cont;
      }
#line 2139
      goto while_break;
    }
#line 2143
    if (m->mf_sock < 0) {
#line 2145
      goto __Cont;
    } else
#line 2143
    if ((int )m->mf_state != 79) {
#line 2143
      if ((int )m->mf_state != 77) {
#line 2145
        goto __Cont;
      }
    }
#line 2148
    if ((unsigned long )macros != (unsigned long )((void *)0)) {
#line 2148
      if ((unsigned long )*(macros + 0) != (unsigned long )((void *)0)) {
        {
#line 2150
        milter_send_macros(m, macros, command, e);
        }
#line 2151
        if ((int )m->mf_state == 69) {
#line 2153
          if ((int )tTdvect[71] >= 100) {
#line 2153
            if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
              {
#line 2153
              e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 2153
              tmp___1 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 2153
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___1, e->e_quarmsg,
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                               2153, SmHeapGroup);
              }
            }
          } else
#line 2153
          if ((int )tTdvect[71] >= 101) {
#line 2153
            if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
              {
#line 2153
              e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 2153
              tmp___2 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 2153
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___2, e->e_quarmsg,
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                               2153, SmHeapGroup);
              }
            }
          } else
#line 2153
          if (m->mf_flags[84UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 84UL % (8UL * sizeof(int )))) {
#line 2153
            *state = (char )'t';
          } else
#line 2153
          if (m->mf_flags[52UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 52UL % (8UL * sizeof(int )))) {
#line 2153
            *state = (char )'4';
          } else
#line 2153
          if (m->mf_flags[82UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 82UL % (8UL * sizeof(int )))) {
#line 2153
            *state = (char )'r';
          } else {
#line 2153
            goto __Cont;
          }
#line 2154
          goto while_break;
        }
      }
    }
#line 2158
    if (MilterLogLevel > 21) {
      {
#line 2159
      tn = curtime();
      }
    }
    {
#line 2161
    response = milter_send_command(m, command, data, sz, e, state);
    }
#line 2163
    if (MilterLogLevel > 21) {
      {
#line 2166
      tmp___3 = curtime();
#line 2166
      sm_syslog(6, (char const   *)e->e_id, "Milter (%s): time command (%c), %d",
                m->mf_name, (int )command, (int )(tn - tmp___3));
      }
    }
#line 2171
    if ((int )*state != 99) {
#line 2172
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2174
  return (response);
}
}
#line 2187 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static int milter_negotiate(struct milter *m , ENVELOPE *e ) 
{ 
  char rcmd___0 ;
  mi_int32 fvers ;
  mi_int32 fflags ;
  mi_int32 pflags ;
  mi_int32 curr_prot ;
  ssize_t rlen ;
  char *response ;
  char data[12] ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 2202
  if (m->mf_sock < 0) {
#line 2202
    goto _L;
  } else
#line 2202
  if ((int )m->mf_state != 79) {
    _L: /* CIL Label */ 
#line 2204
    if (MilterLogLevel > 0) {
      {
#line 2205
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): negotiate, impossible state",
                m->mf_name);
      }
    }
    {
#line 2208
    milter_error(m, e);
    }
#line 2209
    return (-1);
  }
  {
#line 2212
  tmp = htonl((uint32_t )2);
#line 2212
  fvers = (mi_int32 )tmp;
#line 2213
  tmp___0 = htonl((uint32_t )63L);
#line 2213
  fflags = (mi_int32 )tmp___0;
#line 2214
  curr_prot = (mi_int32 )127L;
#line 2225
  tmp___1 = htonl((uint32_t )curr_prot);
#line 2225
  pflags = (mi_int32 )tmp___1;
#line 2226
  memcpy((void */* __restrict  */)(data), (void const   */* __restrict  */)((char *)(& fvers)),
         (size_t )4);
#line 2227
  memcpy((void */* __restrict  */)(data + 4), (void const   */* __restrict  */)((char *)(& fflags)),
         (size_t )4);
#line 2229
  memcpy((void */* __restrict  */)(data + 8), (void const   */* __restrict  */)((char *)(& pflags)),
         (size_t )4);
#line 2231
  milter_write(m, (char )'O', data, (ssize_t )sizeof(data), m->mf_timeout[0], e);
  }
#line 2234
  if ((int )m->mf_state == 69) {
#line 2235
    return (-1);
  }
  {
#line 2237
  response = milter_read(m, & rcmd___0, & rlen, m->mf_timeout[1], e);
  }
#line 2238
  if ((int )m->mf_state == 69) {
#line 2239
    return (-1);
  }
#line 2241
  if ((int )rcmd___0 != 79) {
#line 2243
    if ((int )tTdvect[64] >= 5) {
      {
#line 2244
      sm_dprintf((char *)"milter_negotiate(%s): returned %c instead of %c\n", m->mf_name,
                 (int )rcmd___0, 'O');
      }
    }
#line 2246
    if (MilterLogLevel > 0) {
      {
#line 2247
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): negotiate: returned %c instead of %c",
                m->mf_name, (int )rcmd___0, 'O');
      }
    }
#line 2250
    if ((unsigned long )response != (unsigned long )((void *)0)) {
      {
#line 2251
      sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                     2251);
      }
    }
    {
#line 2252
    milter_error(m, e);
    }
#line 2253
    return (-1);
  }
#line 2257
  if ((unsigned long )response == (unsigned long )((void *)0)) {
#line 2257
    goto _L___0;
  } else
#line 2257
  if (rlen < 4) {
    _L___0: /* CIL Label */ 
#line 2259
    if ((int )tTdvect[64] >= 5) {
      {
#line 2260
      sm_dprintf((char *)"milter_negotiate(%s): did not return valid info\n", m->mf_name);
      }
    }
#line 2262
    if (MilterLogLevel > 0) {
      {
#line 2263
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): negotiate: did not return valid info",
                m->mf_name);
      }
    }
#line 2266
    if ((unsigned long )response != (unsigned long )((void *)0)) {
      {
#line 2267
      sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                     2267);
      }
    }
    {
#line 2268
    milter_error(m, e);
    }
#line 2269
    return (-1);
  }
  {
#line 2273
  memcpy((void */* __restrict  */)((char *)(& fvers)), (void const   */* __restrict  */)response,
         (size_t )4);
  }
#line 2276
  if (rlen != 12) {
#line 2278
    if ((int )tTdvect[64] >= 5) {
      {
#line 2279
      sm_dprintf((char *)"milter_negotiate(%s): did not return enough info\n", m->mf_name);
      }
    }
#line 2281
    if (MilterLogLevel > 0) {
      {
#line 2282
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): negotiate: did not return enough info",
                m->mf_name);
      }
    }
#line 2285
    if ((unsigned long )response != (unsigned long )((void *)0)) {
      {
#line 2286
      sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                     2286);
      }
    }
    {
#line 2287
    milter_error(m, e);
    }
#line 2288
    return (-1);
  }
  {
#line 2291
  memcpy((void */* __restrict  */)((char *)(& fflags)), (void const   */* __restrict  */)(response + 4),
         (size_t )4);
#line 2293
  memcpy((void */* __restrict  */)((char *)(& pflags)), (void const   */* __restrict  */)(response + 8),
         (size_t )4);
#line 2295
  sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                 2295);
#line 2296
  response = (char *)((void *)0);
#line 2298
  tmp___2 = ntohl((uint32_t )fvers);
#line 2298
  m->mf_fvers = (mi_int32 )tmp___2;
#line 2299
  tmp___3 = ntohl((uint32_t )fflags);
#line 2299
  m->mf_fflags = (mi_int32 )tmp___3;
#line 2300
  tmp___4 = ntohl((uint32_t )pflags);
#line 2300
  m->mf_pflags = (mi_int32 )tmp___4;
  }
#line 2303
  if (m->mf_fvers == 1) {
#line 2303
    goto _L___1;
  } else
#line 2303
  if (m->mf_fvers > 2) {
    _L___1: /* CIL Label */ 
#line 2306
    if ((int )tTdvect[64] >= 5) {
      {
#line 2307
      sm_dprintf((char *)"milter_negotiate(%s): version %d != MTA milter version %d\n",
                 m->mf_name, m->mf_fvers, 2);
      }
    }
#line 2309
    if (MilterLogLevel > 0) {
      {
#line 2310
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): negotiate: version %d != MTA milter version %d",
                m->mf_name, m->mf_fvers, 2);
      }
    }
    {
#line 2313
    milter_error(m, e);
    }
#line 2314
    return (-1);
  }
#line 2318
  if (((long )m->mf_fflags & 63L) != (long )m->mf_fflags) {
#line 2320
    if ((int )tTdvect[64] >= 5) {
      {
#line 2321
      sm_dprintf((char *)"milter_negotiate(%s): filter abilities 0x%x != MTA milter abilities 0x%lx\n",
                 m->mf_name, m->mf_fflags, 63L);
      }
    }
#line 2324
    if (MilterLogLevel > 0) {
      {
#line 2325
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): negotiate: filter abilities 0x%x != MTA milter abilities 0x%lx",
                m->mf_name, m->mf_fflags, 63UL);
      }
    }
    {
#line 2329
    milter_error(m, e);
    }
#line 2330
    return (-1);
  }
#line 2334
  if ((m->mf_pflags & curr_prot) != m->mf_pflags) {
#line 2336
    if ((int )tTdvect[64] >= 5) {
      {
#line 2337
      sm_dprintf((char *)"milter_negotiate(%s): protocol abilities 0x%x != MTA milter abilities 0x%lx\n",
                 m->mf_name, m->mf_pflags, (unsigned long )curr_prot);
      }
    }
#line 2340
    if (MilterLogLevel > 0) {
      {
#line 2341
      sm_syslog(3, (char const   *)e->e_id, "Milter (%s): negotiate: protocol abilities 0x%x != MTA milter abilities 0x%lx",
                m->mf_name, m->mf_pflags, (unsigned long )curr_prot);
      }
    }
    {
#line 2345
    milter_error(m, e);
    }
#line 2346
    return (-1);
  }
#line 2349
  if (m->mf_fvers <= 2) {
#line 2350
    m->mf_pflags = (mi_int32 )((long )m->mf_pflags | 256L);
  }
#line 2351
  if (m->mf_fvers <= 3) {
#line 2352
    m->mf_pflags = (mi_int32 )((long )m->mf_pflags | 512L);
  }
#line 2354
  if ((int )tTdvect[64] >= 5) {
    {
#line 2355
    sm_dprintf((char *)"milter_negotiate(%s): version %u, fflags 0x%x, pflags 0x%x\n",
               m->mf_name, m->mf_fvers, m->mf_fflags, m->mf_pflags);
    }
  }
#line 2357
  return (0);
}
}
#line 2371 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_per_connection_check(ENVELOPE *e ) 
{ 
  int i ;
  struct milter *m ;

  {
#line 2378
  i = 0;
  {
#line 2378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2378
    if (! ((unsigned long )InputFilters[i] != (unsigned long )((void *)0))) {
#line 2378
      goto while_break;
    }
#line 2380
    m = InputFilters[i];
#line 2382
    if ((int )m->mf_state == 81) {
      {
#line 2383
      milter_quit_filter(m, e);
      }
    }
#line 2378
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2385
  return;
}
}
#line 2397 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_error(struct milter *m , ENVELOPE *e ) 
{ 
  char *__cil_tmp3 ;

  {
#line 2407
  if (m->mf_sock >= 0) {
    {
#line 2409
    close(m->mf_sock);
#line 2410
    m->mf_sock = -1;
    }
  }
#line 2412
  m->mf_state = (char )'E';
#line 2414
  if (MilterLogLevel > 0) {
    {
#line 2415
    sm_syslog(6, (char const   *)e->e_id, "Milter (%s): to error state", m->mf_name);
    }
  }
#line 2417
  return;
}
}
#line 2430 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *milter_headers(struct milter *m , ENVELOPE *e , char *state ) 
{ 
  char *response ;
  HDR *h ;
  char *buf___16 ;
  ssize_t s ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 2436
  response = (char *)((void *)0);
#line 2439
  if (MilterLogLevel > 17) {
    {
#line 2440
    sm_syslog(6, (char const   *)e->e_id, "Milter (%s): headers, send", m->mf_name);
    }
  }
#line 2443
  h = e->e_header;
  {
#line 2443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2443
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 2443
      goto while_break;
    }
#line 2449
    if ((unsigned long )h->h_value == (unsigned long )((void *)0)) {
#line 2452
      h->h_flags &= 0xfffffffffffbffffUL;
#line 2453
      goto __Cont;
    }
#line 2457
    if (! ((h->h_flags & 262144UL) != 0UL)) {
#line 2458
      goto __Cont;
    }
#line 2460
    if ((int )tTdvect[64] >= 10) {
      {
#line 2461
      sm_dprintf((char *)"milter_headers: %s: %s\n", h->h_field, h->h_value);
      }
    }
#line 2463
    if (MilterLogLevel > 21) {
      {
#line 2464
      sm_syslog(6, (char const   *)e->e_id, "Milter (%s): header, %s", m->mf_name,
                h->h_field);
      }
    }
    {
#line 2467
    tmp = strlen((char const   *)h->h_field);
#line 2467
    tmp___0 = strlen((char const   *)h->h_value);
#line 2467
    s = (ssize_t )(((tmp + 1U) + tmp___0) + 1U);
    }
#line 2468
    if (s < 0) {
#line 2469
      goto __Cont;
    }
    {
#line 2470
    tmp___1 = xalloc_tagged(s, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                            2470);
#line 2470
    buf___16 = tmp___1;
#line 2471
    sm_snprintf(buf___16, (size_t )s, "%s%c%s", h->h_field, '\000', h->h_value);
#line 2475
    response = milter_send_command(m, (char )'L', (void *)buf___16, s, e, state);
#line 2477
    sm_free_tagged((void *)buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                   2477);
    }
#line 2478
    if ((int )m->mf_state == 69) {
#line 2481
      goto while_break;
    } else
#line 2478
    if ((int )m->mf_state == 68) {
#line 2481
      goto while_break;
    } else
#line 2478
    if ((int )*state != 99) {
#line 2481
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 2443
    h = h->h_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 2483
  if (MilterLogLevel > 17) {
    {
#line 2484
    sm_syslog(6, (char const   *)e->e_id, "Milter (%s): headers, sent", m->mf_name);
    }
  }
#line 2486
  return (response);
}
}
#line 2500 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char *milter_body(struct milter *m , ENVELOPE *e , char *state ) 
{ 
  char bufchar ;
  char prevchar___0 ;
  int c ;
  char *response ;
  char *bp___3 ;
  char buf___16[65535] ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 2506
  bufchar = (char )'\000';
#line 2507
  prevchar___0 = (char )'\000';
#line 2509
  response = (char *)((void *)0);
#line 2513
  if ((int )tTdvect[64] >= 10) {
    {
#line 2514
    sm_dprintf((char *)"milter_body\n");
    }
  }
  {
#line 2516
  tmp___0 = bfrewind(e->e_dfp);
  }
#line 2516
  if (tmp___0 < 0) {
    {
#line 2518
    ExitStat = 74;
#line 2519
    *state = (char )'t';
#line 2520
    tmp = qid_printqueue(e->e_qgrp, e->e_qdir);
#line 2520
    syserr("milter_body: %s/%cf%s: rewind error", tmp, 'd', e->e_id);
    }
#line 2523
    return ((char *)((void *)0));
  }
#line 2526
  if (MilterLogLevel > 17) {
    {
#line 2527
    sm_syslog(6, (char const   *)e->e_id, "Milter (%s): body, send", m->mf_name);
    }
  }
#line 2529
  bp___3 = buf___16;
  {
#line 2530
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2530
    c = sm_io_getc(e->e_dfp, -2);
    }
#line 2530
    if (! (c != -1)) {
#line 2530
      goto while_break;
    }
#line 2533
    if (c == 10) {
#line 2536
      if ((int )prevchar___0 != 13) {
#line 2539
        if ((unsigned long )(bp___3 + 2) > (unsigned long )(& buf___16[sizeof(buf___16)])) {
#line 2542
          bufchar = (char )c;
#line 2545
          c = '\r';
        } else {
#line 2550
          tmp___1 = bp___3;
#line 2550
          bp___3 ++;
#line 2550
          *tmp___1 = (char )'\r';
#line 2551
          prevchar___0 = (char )'\r';
        }
      }
    }
#line 2555
    tmp___2 = bp___3;
#line 2555
    bp___3 ++;
#line 2555
    *tmp___2 = (char )c;
#line 2556
    prevchar___0 = (char )c;
#line 2557
    if ((unsigned long )bp___3 >= (unsigned long )(& buf___16[sizeof(buf___16)])) {
      {
#line 2560
      response = milter_send_command(m, (char )'B', (void *)(buf___16), (ssize_t )(bp___3 - buf___16),
                                     e, state);
#line 2562
      bp___3 = buf___16;
      }
#line 2563
      if ((int )bufchar != 0) {
#line 2565
        tmp___3 = bp___3;
#line 2565
        bp___3 ++;
#line 2565
        *tmp___3 = bufchar;
#line 2566
        bufchar = (char )'\000';
#line 2567
        prevchar___0 = bufchar;
      }
    }
#line 2570
    if ((int )m->mf_state == 69) {
#line 2573
      goto while_break;
    } else
#line 2570
    if ((int )m->mf_state == 68) {
#line 2573
      goto while_break;
    } else
#line 2570
    if ((int )*state != 99) {
#line 2573
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2577
  if (((e->e_dfp)->f_flags & 256L) != 0L) {
#line 2579
    ExitStat = 74;
#line 2580
    if ((int )*state == 99) {
#line 2580
      goto _L;
    } else
#line 2580
    if ((int )*state == 97) {
      _L: /* CIL Label */ 
#line 2583
      *state = (char )'t';
#line 2584
      if ((unsigned long )response != (unsigned long )((void *)0)) {
        {
#line 2586
        sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                       2586);
#line 2587
        response = (char *)((void *)0);
        }
      }
    }
    {
#line 2590
    tmp___4 = qid_printqueue(e->e_qgrp, e->e_qdir);
#line 2590
    syserr("milter_body: %s/%cf%s: read error", tmp___4, 'd', e->e_id);
    }
#line 2593
    return (response);
  }
#line 2597
  if ((unsigned long )bp___3 > (unsigned long )(buf___16)) {
#line 2597
    if ((int )m->mf_state != 69) {
#line 2597
      if ((int )m->mf_state != 68) {
#line 2597
        if ((int )*state == 99) {
          {
#line 2603
          response = milter_send_command(m, (char )'B', (void *)(buf___16), (ssize_t )(bp___3 - buf___16),
                                         e, state);
#line 2605
          bp___3 = buf___16;
          }
        }
      }
    }
  }
#line 2607
  if (MilterLogLevel > 17) {
    {
#line 2608
    sm_syslog(6, (char const   *)e->e_id, "Milter (%s): body, sent", m->mf_name);
    }
  }
#line 2610
  return (response);
}
}
#line 2629 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_addheader(char *response , ssize_t rlen , ENVELOPE *e ) 
{ 
  char *val ;
  HDR *h ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 2638
  if ((int )tTdvect[64] >= 10) {
    {
#line 2639
    sm_dprintf((char *)"milter_addheader: ");
    }
  }
#line 2642
  if ((unsigned long )response == (unsigned long )((void *)0)) {
#line 2644
    if ((int )tTdvect[64] >= 10) {
      {
#line 2645
      sm_dprintf((char *)"NULL response\n");
      }
    }
#line 2646
    return;
  }
#line 2649
  if (rlen < 2) {
#line 2649
    goto _L;
  } else {
    {
#line 2649
    tmp = strlen((char const   *)response);
    }
#line 2649
    if (tmp + 1U >= (size_t )rlen) {
      _L: /* CIL Label */ 
#line 2651
      if ((int )tTdvect[64] >= 10) {
        {
#line 2652
        sm_dprintf((char *)"didn\'t follow protocol (total len)\n");
        }
      }
#line 2653
      return;
    }
  }
  {
#line 2657
  tmp___0 = strlen((char const   *)response);
#line 2657
  val = (response + tmp___0) + 1;
#line 2660
  tmp___1 = strlen((char const   *)response);
#line 2660
  tmp___2 = strlen((char const   *)val);
  }
#line 2660
  if ((tmp___1 + tmp___2) + 2U != (size_t )rlen) {
#line 2662
    if ((int )tTdvect[64] >= 10) {
      {
#line 2663
      sm_dprintf((char *)"didn\'t follow protocol (part len)\n");
      }
    }
#line 2664
    return;
  }
#line 2667
  if ((int )*response == 0) {
#line 2669
    if ((int )tTdvect[64] >= 10) {
      {
#line 2670
      sm_dprintf((char *)"empty field name\n");
      }
    }
#line 2671
    return;
  }
#line 2674
  h = e->e_header;
  {
#line 2674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2674
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 2674
      goto while_break;
    }
    {
#line 2676
    tmp___3 = sm_strcasecmp((char const   *)h->h_field, (char const   *)response);
    }
#line 2676
    if (tmp___3 == 0) {
#line 2676
      if (! ((h->h_flags & 262144UL) != 0UL)) {
#line 2676
        if (! ((h->h_flags & 128UL) != 0UL)) {
#line 2679
          goto while_break;
        }
      }
    }
#line 2674
    h = h->h_link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2683
  tmp___4 = strlen((char const   *)response);
#line 2683
  tmp___5 = strlen((char const   *)val);
#line 2683
  e->e_msgsize += (long )((tmp___4 + 2U) + tmp___5);
  }
#line 2685
  if ((unsigned long )h != (unsigned long )((void *)0)) {
#line 2687
    if ((int )tTdvect[64] >= 10) {
      {
#line 2688
      sm_dprintf((char *)"Replace default header %s value with %s\n", h->h_field,
                 val);
      }
    }
#line 2690
    if (MilterLogLevel > 8) {
      {
#line 2691
      sm_syslog(6, (char const   *)e->e_id, "Milter change: default header %s value with %s",
                h->h_field, val);
      }
    }
    {
#line 2694
    h->h_value = newstr((char const   *)val);
#line 2695
    h->h_flags |= 262144UL;
    }
  } else {
#line 2699
    if ((int )tTdvect[64] >= 10) {
      {
#line 2700
      sm_dprintf((char *)"Add %s: %s\n", response, val);
      }
    }
#line 2701
    if (MilterLogLevel > 8) {
      {
#line 2702
      sm_syslog(6, (char const   *)e->e_id, "Milter add: header: %s: %s", response,
                val);
      }
    }
    {
#line 2704
    tmp___6 = newstr((char const   *)response);
#line 2704
    addheader(tmp___6, val, 262144, e);
    }
  }
#line 2706
  return;
}
}
#line 2724 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_insheader(char *response , ssize_t rlen , ENVELOPE *e ) 
{ 
  mi_int32 idx ;
  mi_int32 i ;
  char *field ;
  char *val ;
  size_t tmp ;
  uint32_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 2734
  if ((int )tTdvect[64] >= 10) {
    {
#line 2735
    sm_dprintf((char *)"milter_insheader: ");
    }
  }
#line 2738
  if ((unsigned long )response == (unsigned long )((void *)0)) {
#line 2740
    if ((int )tTdvect[64] >= 10) {
      {
#line 2741
      sm_dprintf((char *)"NULL response\n");
      }
    }
#line 2742
    return;
  }
#line 2745
  if (rlen < 2) {
#line 2745
    goto _L;
  } else {
    {
#line 2745
    tmp = strlen((char const   *)response);
    }
#line 2745
    if (tmp + 1U >= (size_t )rlen) {
      _L: /* CIL Label */ 
#line 2747
      if ((int )tTdvect[64] >= 10) {
        {
#line 2748
        sm_dprintf((char *)"didn\'t follow protocol (total len)\n");
        }
      }
#line 2749
      return;
    }
  }
  {
#line 2753
  memcpy((void */* __restrict  */)((char *)(& i)), (void const   */* __restrict  */)response,
         (size_t )4);
#line 2754
  tmp___0 = ntohl((uint32_t )i);
#line 2754
  idx = (mi_int32 )tmp___0;
#line 2755
  field = response + 4;
#line 2756
  tmp___1 = strlen((char const   *)field);
#line 2756
  val = (field + tmp___1) + 1;
#line 2759
  tmp___2 = strlen((char const   *)field);
#line 2759
  tmp___3 = strlen((char const   *)val);
  }
#line 2759
  if ((((4U + tmp___2) + 1U) + tmp___3) + 1U != (size_t )rlen) {
#line 2762
    if ((int )tTdvect[64] >= 10) {
      {
#line 2763
      sm_dprintf((char *)"didn\'t follow protocol (part len)\n");
      }
    }
#line 2764
    return;
  }
#line 2767
  if ((int )*field == 0) {
#line 2769
    if ((int )tTdvect[64] >= 10) {
      {
#line 2770
      sm_dprintf((char *)"empty field name\n");
      }
    }
#line 2771
    return;
  }
  {
#line 2775
  tmp___4 = strlen((char const   *)response);
#line 2775
  tmp___5 = strlen((char const   *)val);
#line 2775
  e->e_msgsize += (long )((tmp___4 + 2U) + tmp___5);
  }
#line 2777
  if ((int )tTdvect[64] >= 10) {
    {
#line 2778
    sm_dprintf((char *)"Insert (%d) %s: %s\n", idx, response, val);
    }
  }
#line 2779
  if (MilterLogLevel > 8) {
    {
#line 2780
    sm_syslog(6, (char const   *)e->e_id, "Milter insert (%d): header: %s: %s", idx,
              field, val);
    }
  }
  {
#line 2783
  tmp___6 = newstr((char const   *)field);
#line 2783
  insheader(idx, tmp___6, val, 262144, e);
  }
#line 2784
  return;
}
}
#line 2797 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_changeheader(char *response , ssize_t rlen , ENVELOPE *e ) 
{ 
  mi_int32 i ;
  mi_int32 index___0 ;
  char *field ;
  char *val ;
  HDR *h ;
  HDR *sysheader ;
  size_t tmp ;
  uint32_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  size_t l ;
  size_t l___0 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 2807
  if ((int )tTdvect[64] >= 10) {
    {
#line 2808
    sm_dprintf((char *)"milter_changeheader: ");
    }
  }
#line 2811
  if ((unsigned long )response == (unsigned long )((void *)0)) {
#line 2813
    if ((int )tTdvect[64] >= 10) {
      {
#line 2814
      sm_dprintf((char *)"NULL response\n");
      }
    }
#line 2815
    return;
  }
#line 2818
  if (rlen < 2) {
#line 2818
    goto _L;
  } else {
    {
#line 2818
    tmp = strlen((char const   *)response);
    }
#line 2818
    if (tmp + 1U >= (size_t )rlen) {
      _L: /* CIL Label */ 
#line 2820
      if ((int )tTdvect[64] >= 10) {
        {
#line 2821
        sm_dprintf((char *)"didn\'t follow protocol (total len)\n");
        }
      }
#line 2822
      return;
    }
  }
  {
#line 2826
  memcpy((void */* __restrict  */)((char *)(& i)), (void const   */* __restrict  */)response,
         (size_t )4);
#line 2827
  tmp___0 = ntohl((uint32_t )i);
#line 2827
  index___0 = (mi_int32 )tmp___0;
#line 2828
  field = response + 4;
#line 2829
  tmp___1 = strlen((char const   *)field);
#line 2829
  val = (field + tmp___1) + 1;
#line 2832
  tmp___2 = strlen((char const   *)field);
#line 2832
  tmp___3 = strlen((char const   *)val);
  }
#line 2832
  if ((((4U + tmp___2) + 1U) + tmp___3) + 1U != (size_t )rlen) {
#line 2835
    if ((int )tTdvect[64] >= 10) {
      {
#line 2836
      sm_dprintf((char *)"didn\'t follow protocol (part len)\n");
      }
    }
#line 2837
    return;
  }
#line 2840
  if ((int )*field == 0) {
#line 2842
    if ((int )tTdvect[64] >= 10) {
      {
#line 2843
      sm_dprintf((char *)"empty field name\n");
      }
    }
#line 2844
    return;
  }
#line 2847
  sysheader = (HDR *)((void *)0);
#line 2848
  h = e->e_header;
  {
#line 2848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2848
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 2848
      goto while_break;
    }
    {
#line 2850
    tmp___4 = sm_strcasecmp((char const   *)h->h_field, (char const   *)field);
    }
#line 2850
    if (tmp___4 == 0) {
#line 2852
      if ((h->h_flags & 262144UL) != 0UL) {
#line 2852
        index___0 --;
#line 2852
        if (index___0 <= 0) {
#line 2855
          sysheader = (HDR *)((void *)0);
#line 2856
          goto while_break;
        } else {
#line 2852
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2858
      if (! ((h->h_flags & 262144UL) != 0UL)) {
#line 2858
        if (! ((h->h_flags & 128UL) != 0UL)) {
#line 2868
          sysheader = h;
        }
      }
    }
#line 2848
    h = h->h_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 2874
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 2875
    h = sysheader;
  }
#line 2877
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 2879
    if ((int )*val == 0) {
#line 2881
      if ((int )tTdvect[64] >= 10) {
        {
#line 2882
        sm_dprintf((char *)"Delete (noop) %s\n", field);
        }
      }
#line 2883
      if (MilterLogLevel > 8) {
        {
#line 2884
        sm_syslog(6, (char const   *)e->e_id, "Milter delete (noop): header: %s",
                  field);
        }
      }
    } else {
#line 2891
      if ((int )tTdvect[64] >= 10) {
        {
#line 2892
        sm_dprintf((char *)"Add %s: %s\n", field, val);
        }
      }
#line 2893
      if (MilterLogLevel > 8) {
        {
#line 2894
        sm_syslog(6, (char const   *)e->e_id, "Milter change (add): header: %s: %s",
                  field, val);
        }
      }
      {
#line 2897
      tmp___5 = newstr((char const   *)field);
#line 2897
      addheader(tmp___5, val, 262144, e);
      }
    }
#line 2899
    return;
  }
#line 2902
  if ((int )tTdvect[64] >= 10) {
#line 2904
    if ((int )*val == 0) {
#line 2906
      if ((unsigned long )h->h_value == (unsigned long )((void *)0)) {
#line 2906
        tmp___6 = "<NULL>";
      } else {
#line 2906
        tmp___6 = (char const   *)h->h_value;
      }
#line 2906
      if ((unsigned long )h == (unsigned long )sysheader) {
#line 2906
        tmp___7 = " (default header)";
      } else {
#line 2906
        tmp___7 = "";
      }
      {
#line 2906
      sm_dprintf((char *)"Delete%s %s: %s\n", tmp___7, field, tmp___6);
      }
    } else {
#line 2913
      if ((unsigned long )h->h_value == (unsigned long )((void *)0)) {
#line 2913
        tmp___8 = "<NULL>";
      } else {
#line 2913
        tmp___8 = (char const   *)h->h_value;
      }
#line 2913
      if ((unsigned long )h == (unsigned long )sysheader) {
#line 2913
        tmp___9 = " (default header)";
      } else {
#line 2913
        tmp___9 = "";
      }
      {
#line 2913
      sm_dprintf((char *)"Change%s %s: from %s to %s\n", tmp___9, field, tmp___8,
                 val);
      }
    }
  }
#line 2921
  if (MilterLogLevel > 8) {
#line 2923
    if ((int )*val == 0) {
#line 2925
      if ((unsigned long )h->h_value == (unsigned long )((void *)0)) {
#line 2925
        tmp___10 = "<NULL>";
      } else {
#line 2925
        tmp___10 = (char const   *)h->h_value;
      }
#line 2925
      if ((unsigned long )h == (unsigned long )sysheader) {
#line 2925
        tmp___11 = " (default header)";
      } else {
#line 2925
        tmp___11 = "";
      }
      {
#line 2925
      sm_syslog(6, (char const   *)e->e_id, "Milter delete: header%s %s: %s", tmp___11,
                field, tmp___10);
      }
    } else {
#line 2933
      if ((unsigned long )h->h_value == (unsigned long )((void *)0)) {
#line 2933
        tmp___12 = "<NULL>";
      } else {
#line 2933
        tmp___12 = (char const   *)h->h_value;
      }
#line 2933
      if ((unsigned long )h == (unsigned long )sysheader) {
#line 2933
        tmp___13 = " (default header)";
      } else {
#line 2933
        tmp___13 = "";
      }
      {
#line 2933
      sm_syslog(6, (char const   *)e->e_id, "Milter change: header%s %s: from %s to %s",
                tmp___13, field, tmp___12, val);
      }
    }
  }
#line 2942
  if ((unsigned long )h != (unsigned long )sysheader) {
#line 2942
    if ((unsigned long )h->h_value != (unsigned long )((void *)0)) {
      {
#line 2946
      l = strlen((char const   *)h->h_value);
      }
#line 2947
      if ((long )l > e->e_msgsize) {
#line 2948
        e->e_msgsize = 0L;
      } else {
#line 2950
        e->e_msgsize -= (long )l;
      }
    }
  }
#line 2954
  if ((int )*val == 0) {
#line 2957
    if ((unsigned long )h != (unsigned long )sysheader) {
      {
#line 2961
      tmp___14 = strlen((char const   *)h->h_field);
#line 2961
      l___0 = tmp___14 + 2U;
      }
#line 2962
      if ((long )l___0 > e->e_msgsize) {
#line 2963
        e->e_msgsize = 0L;
      } else {
#line 2965
        e->e_msgsize -= (long )l___0;
      }
    }
#line 2967
    h->h_value = (char *)((void *)0);
  } else {
    {
#line 2971
    h->h_value = newstr((char const   *)val);
#line 2972
    h->h_flags |= 262144UL;
#line 2973
    tmp___15 = strlen((char const   *)h->h_value);
#line 2973
    e->e_msgsize += (long )tmp___15;
    }
  }
#line 2975
  return;
}
}
#line 2988 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_addrcpt(char *response , ssize_t rlen , ENVELOPE *e ) 
{ 
  int olderrors ;
  size_t tmp ;
  size_t tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 2996
  if ((int )tTdvect[64] >= 10) {
    {
#line 2997
    sm_dprintf((char *)"milter_addrcpt: ");
    }
  }
#line 3000
  if ((unsigned long )response == (unsigned long )((void *)0)) {
#line 3002
    if ((int )tTdvect[64] >= 10) {
      {
#line 3003
      sm_dprintf((char *)"NULL response\n");
      }
    }
#line 3004
    return;
  }
#line 3007
  if ((int )*response == 0) {
#line 3007
    goto _L;
  } else {
    {
#line 3007
    tmp___0 = strlen((char const   *)response);
    }
#line 3007
    if (tmp___0 + 1U != (size_t )rlen) {
      _L: /* CIL Label */ 
#line 3010
      if ((int )tTdvect[64] >= 10) {
        {
#line 3011
        tmp = strlen((char const   *)response);
#line 3011
        sm_dprintf((char *)"didn\'t follow protocol (total len %d != rlen %d)\n",
                   (int )tmp, rlen - 1);
        }
      }
#line 3013
      return;
    }
  }
#line 3016
  if ((int )tTdvect[64] >= 10) {
    {
#line 3017
    sm_dprintf((char *)"%s\n", response);
    }
  }
#line 3018
  if (MilterLogLevel > 8) {
    {
#line 3019
    sm_syslog(6, (char const   *)e->e_id, "Milter add: rcpt: %s", response);
    }
  }
  {
#line 3020
  olderrors = Errors;
#line 3021
  sendtolist(response, (ADDRESS *)((void *)0), & e->e_sendqueue, 0, e);
#line 3022
  Errors = olderrors;
  }
#line 3023
  return;
}
}
#line 3037 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static void milter_delrcpt(char *response , ssize_t rlen , ENVELOPE *e ) 
{ 
  size_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 3043
  if ((int )tTdvect[64] >= 10) {
    {
#line 3044
    sm_dprintf((char *)"milter_delrcpt: ");
    }
  }
#line 3047
  if ((unsigned long )response == (unsigned long )((void *)0)) {
#line 3049
    if ((int )tTdvect[64] >= 10) {
      {
#line 3050
      sm_dprintf((char *)"NULL response\n");
      }
    }
#line 3051
    return;
  }
#line 3054
  if ((int )*response == 0) {
#line 3054
    goto _L;
  } else {
    {
#line 3054
    tmp = strlen((char const   *)response);
    }
#line 3054
    if (tmp + 1U != (size_t )rlen) {
      _L: /* CIL Label */ 
#line 3057
      if ((int )tTdvect[64] >= 10) {
        {
#line 3058
        sm_dprintf((char *)"didn\'t follow protocol (total len)\n");
        }
      }
#line 3059
      return;
    }
  }
#line 3062
  if ((int )tTdvect[64] >= 10) {
    {
#line 3063
    sm_dprintf((char *)"%s\n", response);
    }
  }
#line 3064
  if (MilterLogLevel > 8) {
    {
#line 3065
    sm_syslog(6, (char const   *)e->e_id, "Milter delete: rcpt %s", response);
    }
  }
  {
#line 3067
  removefromlist(response, & e->e_sendqueue, e);
  }
#line 3068
  return;
}
}
#line 3090 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static char prevchar  ;
#line 3083 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
static int milter_replbody(char *response , ssize_t rlen , bool newfilter , ENVELOPE *e ) 
{ 
  int i ;
  off_t prevsize ;
  char dfname[4096] ;
  char *tmp ;
  int tmp___0 ;
  int save_errno ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int err ;
  int save_errno___0 ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int save_errno___1 ;
  int *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 3093
  if ((int )tTdvect[64] >= 10) {
    {
#line 3094
    sm_dprintf((char *)"milter_replbody\n");
    }
  }
#line 3097
  if (newfilter) {
    {
#line 3102
    tmp = queuename(e, 'd');
#line 3102
    sm_strlcpy(dfname, (char const   *)tmp, (ssize_t )sizeof(dfname));
#line 3106
    prevchar = (char )'\000';
#line 3109
    tmp___0 = sm_io_getinfo(e->e_dfp, 8, (void *)0);
#line 3109
    prevsize = (off_t )tmp___0;
    }
#line 3110
    if (prevsize < 0L) {
#line 3111
      prevsize = (off_t )0;
    }
    {
#line 3114
    tmp___15 = sm_io_getinfo(e->e_dfp, 5, (void *)"SendmailBufferedFile");
    }
#line 3114
    if (tmp___15) {
      {
#line 3116
      tmp___5 = sm_io_setinfo(e->e_dfp, 1002, (void *)0);
      }
#line 3116
      if (tmp___5 < 0) {
        {
#line 3118
        tmp___1 = __errno_location();
#line 3118
        save_errno = *tmp___1;
        }
#line 3118
        if ((int )tTdvect[64] >= 5) {
          {
#line 3118
          tmp___2 = sm_errstring(save_errno);
#line 3118
          sm_dprintf((char *)"milter_replbody: sm_io truncate %s: %s", dfname, tmp___2);
#line 3118
          sm_dprintf((char *)"\n");
          }
        }
#line 3118
        if (MilterLogLevel > 0) {
          {
#line 3118
          tmp___3 = sm_errstring(save_errno);
#line 3118
          sm_syslog(3, (char const   *)e->e_id, "milter_replbody: sm_io truncate %s: %s",
                    dfname, tmp___3);
          }
        }
#line 3118
        if (SuperSafe == 2) {
#line 3118
          if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
            {
#line 3118
            sm_io_close(e->e_dfp, -2);
#line 3118
            e->e_dfp = (SM_FILE_T *)((void *)0);
            }
          }
#line 3118
          e->e_flags &= 0xffffffffffdfffffUL;
        }
        {
#line 3118
        tmp___4 = __errno_location();
#line 3118
        *tmp___4 = save_errno;
        }
#line 3119
        return (-1);
      }
    } else {
      {
#line 3126
      err = ((e->e_dfp)->f_flags & 256L) != 0L;
#line 3127
      sm_io_flush(e->e_dfp, -2);
      }
#line 3135
      if (err == 0) {
#line 3136
        (e->e_dfp)->f_flags &= -385L;
      }
      {
#line 3139
      err = sm_io_seek(e->e_dfp, -2, 0L, 0);
      }
#line 3141
      if (err < 0) {
        {
#line 3143
        tmp___6 = __errno_location();
#line 3143
        save_errno___0 = *tmp___6;
        }
#line 3143
        if ((int )tTdvect[64] >= 5) {
          {
#line 3143
          tmp___7 = sm_errstring(save_errno___0);
#line 3143
          sm_dprintf((char *)"milter_replbody: sm_io_seek %s: %s", dfname, tmp___7);
#line 3143
          sm_dprintf((char *)"\n");
          }
        }
#line 3143
        if (MilterLogLevel > 0) {
          {
#line 3143
          tmp___8 = sm_errstring(save_errno___0);
#line 3143
          sm_syslog(3, (char const   *)e->e_id, "milter_replbody: sm_io_seek %s: %s",
                    dfname, tmp___8);
          }
        }
#line 3143
        if (SuperSafe == 2) {
#line 3143
          if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
            {
#line 3143
            sm_io_close(e->e_dfp, -2);
#line 3143
            e->e_dfp = (SM_FILE_T *)((void *)0);
            }
          }
#line 3143
          e->e_flags &= 0xffffffffffdfffffUL;
        }
        {
#line 3143
        tmp___9 = __errno_location();
#line 3143
        *tmp___9 = save_errno___0;
        }
#line 3144
        return (-1);
      }
      {
#line 3152
      tmp___10 = sm_io_getinfo(e->e_dfp, 3, (void *)0);
#line 3152
      err = ftruncate(tmp___10, (__off_t )0);
      }
#line 3155
      if (err < 0) {
        {
#line 3157
        tmp___11 = __errno_location();
#line 3157
        save_errno___1 = *tmp___11;
        }
#line 3157
        if ((int )tTdvect[64] >= 5) {
          {
#line 3157
          tmp___12 = sm_errstring(save_errno___1);
#line 3157
          sm_dprintf((char *)"milter_replbody: sm_io ftruncate %s: %s", dfname, tmp___12);
#line 3157
          sm_dprintf((char *)"\n");
          }
        }
#line 3157
        if (MilterLogLevel > 0) {
          {
#line 3157
          tmp___13 = sm_errstring(save_errno___1);
#line 3157
          sm_syslog(3, (char const   *)e->e_id, "milter_replbody: sm_io ftruncate %s: %s",
                    dfname, tmp___13);
          }
        }
#line 3157
        if (SuperSafe == 2) {
#line 3157
          if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
            {
#line 3157
            sm_io_close(e->e_dfp, -2);
#line 3157
            e->e_dfp = (SM_FILE_T *)((void *)0);
            }
          }
#line 3157
          e->e_flags &= 0xffffffffffdfffffUL;
        }
        {
#line 3157
        tmp___14 = __errno_location();
#line 3157
        *tmp___14 = save_errno___1;
        }
#line 3158
        return (-1);
      }
    }
#line 3163
    if (prevsize > e->e_msgsize) {
#line 3164
      e->e_msgsize = 0L;
    } else {
#line 3166
      e->e_msgsize -= prevsize;
    }
  }
#line 3169
  if (newfilter) {
#line 3169
    if (MilterLogLevel > 8) {
      {
#line 3170
      sm_syslog(6, (char const   *)e->e_id, "Milter message: body replaced");
      }
    }
  }
#line 3172
  if ((unsigned long )response == (unsigned long )((void *)0)) {
#line 3175
    if ((int )prevchar == 13) {
      {
#line 3177
      sm_io_putc(e->e_dfp, -2, (int )prevchar);
#line 3178
      (e->e_msgsize) ++;
      }
    }
#line 3180
    return (0);
  }
#line 3183
  i = 0;
  {
#line 3183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3183
    if (! (i < rlen)) {
#line 3183
      goto while_break;
    }
#line 3186
    if (i == 0) {
#line 3186
      if ((int )prevchar == 13) {
#line 3189
        if ((int )*(response + i) != 10) {
          {
#line 3191
          sm_io_putc(e->e_dfp, -2, (int )prevchar);
#line 3193
          (e->e_msgsize) ++;
          }
        }
#line 3195
        prevchar = (char )'\000';
      }
    }
#line 3199
    if ((int )*(response + i) == 13) {
#line 3202
      if (i + 1 < rlen) {
#line 3205
        if ((int )*(response + (i + 1)) == 10) {
#line 3206
          i ++;
        }
      } else {
#line 3211
        prevchar = (char )'\r';
#line 3212
        goto __Cont;
      }
    }
    {
#line 3215
    sm_io_putc(e->e_dfp, -2, (int )*(response + i));
#line 3216
    (e->e_msgsize) ++;
    }
    __Cont: /* CIL Label */ 
#line 3183
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3218
  return (0);
}
}
#line 3237 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
bool milter_init(ENVELOPE *e , char *state ) 
{ 
  int i ;
  struct milter *m ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 3244
  if ((int )tTdvect[64] >= 10) {
    {
#line 3245
    sm_dprintf((char *)"milter_init\n");
    }
  }
#line 3247
  *state = (char )'c';
#line 3248
  if ((unsigned long )InputFilters[0] == (unsigned long )((void *)0)) {
#line 3250
    if (MilterLogLevel > 10) {
      {
#line 3251
      sm_syslog(6, (char const   *)e->e_id, "Milter: no active filter");
      }
    }
#line 3253
    return (0);
  }
#line 3256
  i = 0;
  {
#line 3256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3256
    if (! ((unsigned long )InputFilters[i] != (unsigned long )((void *)0))) {
#line 3256
      goto while_break;
    }
    {
#line 3258
    m = InputFilters[i];
#line 3260
    m->mf_sock = milter_open(m, 0, e);
    }
#line 3261
    if ((int )m->mf_state == 69) {
#line 3263
      if ((int )tTdvect[71] >= 101) {
#line 3263
        if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
          {
#line 3263
          e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 3263
          tmp___0 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 3263
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___0, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                           3263, SmHeapGroup);
          }
        }
      } else
#line 3263
      if (m->mf_flags[84UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 84UL % (8UL * sizeof(int )))) {
#line 3263
        *state = (char )'t';
      } else
#line 3263
      if (m->mf_flags[52UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 52UL % (8UL * sizeof(int )))) {
#line 3263
        *state = (char )'4';
      } else
#line 3263
      if (m->mf_flags[82UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 82UL % (8UL * sizeof(int )))) {
#line 3263
        *state = (char )'r';
      } else {
#line 3263
        goto __Cont;
      }
#line 3264
      goto while_break;
    }
#line 3267
    if (m->mf_sock < 0) {
#line 3267
      goto _L;
    } else {
      {
#line 3267
      tmp___5 = milter_negotiate(m, e);
      }
#line 3267
      if (tmp___5 < 0) {
#line 3267
        goto _L;
      } else
#line 3267
      if ((int )m->mf_state == 69) {
        _L: /* CIL Label */ 
#line 3271
        if ((int )tTdvect[64] >= 5) {
#line 3272
          if (m->mf_sock < 0) {
#line 3272
            tmp___1 = "open";
          } else {
#line 3272
            tmp___1 = "negotiate";
          }
          {
#line 3272
          sm_dprintf((char *)"milter_init(%s): failed to %s\n", m->mf_name, tmp___1);
          }
        }
#line 3276
        if (MilterLogLevel > 0) {
#line 3277
          if (m->mf_sock < 0) {
#line 3277
            tmp___2 = "open";
          } else {
#line 3277
            tmp___2 = "negotiate";
          }
          {
#line 3277
          sm_syslog(3, (char const   *)e->e_id, "Milter (%s): init failed to %s",
                    m->mf_name, tmp___2);
          }
        }
        {
#line 3284
        milter_error(m, e);
        }
#line 3285
        if ((int )tTdvect[71] >= 101) {
#line 3285
          if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
            {
#line 3285
            e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 3285
            tmp___4 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 3285
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___4, e->e_quarmsg,
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                             3285, SmHeapGroup);
            }
          }
        } else
#line 3285
        if (m->mf_flags[84UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 84UL % (8UL * sizeof(int )))) {
#line 3285
          *state = (char )'t';
        } else
#line 3285
        if (m->mf_flags[52UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 52UL % (8UL * sizeof(int )))) {
#line 3285
          *state = (char )'4';
        } else
#line 3285
        if (m->mf_flags[82UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 82UL % (8UL * sizeof(int )))) {
#line 3285
          *state = (char )'r';
        } else {
#line 3285
          goto __Cont;
        }
#line 3286
        goto __Cont;
      }
    }
#line 3288
    if (MilterLogLevel > 9) {
#line 3289
      if (m->mf_sock < 0) {
#line 3289
        tmp___6 = "open";
      } else {
#line 3289
        tmp___6 = "negotiate";
      }
      {
#line 3289
      sm_syslog(6, (char const   *)e->e_id, "Milter (%s): init success to %s", m->mf_name,
                tmp___6);
      }
    }
    __Cont: /* CIL Label */ 
#line 3256
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3301
  if ((int )*state != 99) {
    {
#line 3302
    milter_quit(e);
    }
  }
#line 3304
  return (1);
}
}
#line 3319 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
char *milter_connect(char *hostname , union bigsockaddr addr , ENVELOPE *e , char *state ) 
{ 
  char family ;
  unsigned short port ;
  char *buf___16 ;
  char *bp___3 ;
  char *response ;
  char *sockinfo ;
  ssize_t s ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 3330
  sockinfo = (char *)((void *)0);
#line 3336
  if ((int )tTdvect[64] >= 10) {
    {
#line 3337
    sm_dprintf((char *)"milter_connect(%s)\n", hostname);
    }
  }
#line 3338
  if (MilterLogLevel > 9) {
    {
#line 3339
    sm_syslog(6, (char const   *)e->e_id, "Milter: connect to filters");
    }
  }
  {
#line 3345
  if ((int )addr.sa.sa_family == 1) {
#line 3345
    goto case_1;
  }
#line 3353
  if ((int )addr.sa.sa_family == 2) {
#line 3353
    goto case_2;
  }
#line 3374
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 3346
  family = (char )'L';
#line 3347
  port = htons((uint16_t )0);
#line 3348
  sockinfo = addr.sunix.sun_path;
  }
#line 3349
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3354
  family = (char )'4';
#line 3355
  port = addr.sin.sin_port;
#line 3356
  tmp = inet_ntoa(addr.sin.sin_addr);
#line 3356
  sockinfo = tmp;
  }
#line 3357
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3375
  family = (char )'U';
#line 3376
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 3379
  tmp___0 = strlen((char const   *)hostname);
#line 3379
  s = (ssize_t )((unsigned long )(tmp___0 + 1U) + sizeof(family));
  }
#line 3380
  if ((int )family != 85) {
    {
#line 3381
    tmp___1 = strlen((char const   *)sockinfo);
#line 3381
    s = (ssize_t )((unsigned long )s + ((sizeof(port) + (unsigned long )tmp___1) + 1UL));
    }
  }
  {
#line 3383
  tmp___2 = xalloc_tagged(s, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                          3383);
#line 3383
  buf___16 = tmp___2;
#line 3384
  bp___3 = buf___16;
#line 3387
  tmp___3 = strlen((char const   *)hostname);
#line 3387
  memcpy((void */* __restrict  */)bp___3, (void const   */* __restrict  */)hostname,
         tmp___3);
#line 3388
  tmp___4 = strlen((char const   *)hostname);
#line 3388
  bp___3 += tmp___4;
#line 3389
  tmp___5 = bp___3;
#line 3389
  bp___3 ++;
#line 3389
  *tmp___5 = (char )'\000';
#line 3390
  memcpy((void */* __restrict  */)bp___3, (void const   */* __restrict  */)(& family),
         (size_t )sizeof(family));
#line 3391
  bp___3 += sizeof(family);
  }
#line 3392
  if ((int )family != 85) {
    {
#line 3394
    memcpy((void */* __restrict  */)bp___3, (void const   */* __restrict  */)(& port),
           (size_t )sizeof(port));
#line 3395
    bp___3 += sizeof(port);
#line 3398
    tmp___6 = strlen((char const   *)sockinfo);
#line 3398
    memcpy((void */* __restrict  */)bp___3, (void const   */* __restrict  */)sockinfo,
           tmp___6 + 1U);
    }
  }
  {
#line 3401
  response = milter_command((char )'C', (void *)buf___16, s, MilterConnectMacros,
                            e, state);
#line 3403
  sm_free_tagged((void *)buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                 3403);
  }
#line 3410
  if ((int )*state != 99) {
#line 3412
    if (MilterLogLevel > 9) {
      {
#line 3413
      sm_syslog(6, (char const   *)e->e_id, "Milter: connect, ending");
      }
    }
    {
#line 3414
    milter_quit(e);
    }
  } else {
    {
#line 3417
    milter_per_connection_check(e);
    }
  }
#line 3425
  if ((int )*state == 121) {
#line 3427
    if ((unsigned long )response != (unsigned long )((void *)0)) {
#line 3427
      if ((int )*response == 52) {
        {
#line 3430
        tmp___7 = strncmp((char const   *)response, "421 ", (size_t )4);
        }
#line 3430
        if (tmp___7 == 0) {
#line 3431
          *state = (char )'4';
        } else {
#line 3433
          *state = (char )'t';
        }
      } else {
#line 3436
        *state = (char )'r';
      }
    } else {
#line 3436
      *state = (char )'r';
    }
#line 3437
    if ((unsigned long )response != (unsigned long )((void *)0)) {
      {
#line 3439
      sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                     3439);
#line 3440
      response = (char *)((void *)0);
      }
    }
  }
#line 3443
  return (response);
}
}
#line 3457 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
char *milter_helo(char *helo , ENVELOPE *e , char *state ) 
{ 
  int i ;
  char *response ;
  struct milter *m ;
  size_t tmp ;
  char *__cil_tmp8 ;

  {
#line 3466
  if ((int )tTdvect[64] >= 10) {
    {
#line 3467
    sm_dprintf((char *)"milter_helo(%s)\n", helo);
    }
  }
#line 3470
  i = 0;
  {
#line 3470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3470
    if (! ((unsigned long )InputFilters[i] != (unsigned long )((void *)0))) {
#line 3470
      goto while_break;
    }
#line 3472
    m = InputFilters[i];
    {
#line 3476
    if ((int )m->mf_state == 77) {
#line 3476
      goto case_77;
    }
#line 3481
    if ((int )m->mf_state == 68) {
#line 3481
      goto case_68;
    }
#line 3474
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 3478
    milter_abort_filter(m, e);
    }
    case_68: /* CIL Label */ 
#line 3483
    m->mf_state = (char )'O';
#line 3484
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3470
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3488
  tmp = strlen((char const   *)helo);
#line 3488
  response = milter_command((char )'H', (void *)helo, (ssize_t )(tmp + 1U), MilterHeloMacros,
                            e, state);
#line 3490
  milter_per_connection_check(e);
  }
#line 3491
  return (response);
}
}
#line 3505 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
char *milter_envfrom(char **args , ENVELOPE *e , char *state ) 
{ 
  int i ;
  char *buf___16 ;
  char *bp___3 ;
  char *response ;
  ssize_t s ;
  struct milter *m ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 3516
  if ((int )tTdvect[64] >= 10) {
    {
#line 3518
    sm_dprintf((char *)"milter_envfrom:");
#line 3519
    i = 0;
    }
    {
#line 3519
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3519
      if (! ((unsigned long )*(args + i) != (unsigned long )((void *)0))) {
#line 3519
        goto while_break;
      }
      {
#line 3520
      sm_dprintf((char *)" %s", *(args + i));
#line 3519
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3521
    sm_dprintf((char *)"\n");
    }
  }
#line 3525
  if ((unsigned long )*(args + 0) == (unsigned long )((void *)0)) {
#line 3527
    *state = (char )'r';
#line 3528
    if (MilterLogLevel > 10) {
      {
#line 3529
      sm_syslog(6, (char const   *)e->e_id, "Milter: reject, no sender");
      }
    }
#line 3531
    return ((char *)((void *)0));
  }
#line 3535
  i = 0;
  {
#line 3535
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3535
    if (! ((unsigned long )InputFilters[i] != (unsigned long )((void *)0))) {
#line 3535
      goto while_break___0;
    }
#line 3537
    m = InputFilters[i];
    {
#line 3541
    if ((int )m->mf_state == 77) {
#line 3541
      goto case_77;
    }
#line 3546
    if ((int )m->mf_state == 68) {
#line 3546
      goto case_68;
    }
#line 3539
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 3543
    milter_abort_filter(m, e);
    }
    case_68: /* CIL Label */ 
#line 3548
    m->mf_state = (char )'O';
#line 3549
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3535
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3554
  s = 0;
#line 3555
  i = 0;
  {
#line 3555
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3555
    if (! ((unsigned long )*(args + i) != (unsigned long )((void *)0))) {
#line 3555
      goto while_break___1;
    }
    {
#line 3556
    tmp = strlen((char const   *)*(args + i));
#line 3556
    s = (ssize_t )((size_t )s + (tmp + 1U));
#line 3555
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3558
  if (s < 0) {
#line 3560
    *state = (char )'t';
#line 3561
    return ((char *)((void *)0));
  }
  {
#line 3564
  tmp___0 = xalloc_tagged(s, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                          3564);
#line 3564
  buf___16 = tmp___0;
#line 3565
  bp___3 = buf___16;
#line 3566
  i = 0;
  }
  {
#line 3566
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3566
    if (! ((unsigned long )*(args + i) != (unsigned long )((void *)0))) {
#line 3566
      goto while_break___2;
    }
    {
#line 3568
    sm_strlcpy(bp___3, (char const   *)*(args + i), (ssize_t )((long )s - (bp___3 - buf___16)));
#line 3569
    tmp___1 = strlen((char const   *)bp___3);
#line 3569
    bp___3 += tmp___1 + 1U;
#line 3566
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3572
  if (MilterLogLevel > 14) {
    {
#line 3573
    sm_syslog(6, (char const   *)e->e_id, "Milter: senders: %s", buf___16);
    }
  }
  {
#line 3576
  response = milter_command((char )'M', (void *)buf___16, s, MilterEnvFromMacros,
                            e, state);
#line 3578
  sm_free_tagged((void *)buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                 3578);
  }
#line 3586
  if ((int )*state == 121) {
    {
#line 3586
    milter_abort(e);
    }
  } else
#line 3586
  if ((int )*state == 114) {
    {
#line 3586
    milter_abort(e);
    }
  } else
#line 3586
  if ((int )*state == 100) {
    {
#line 3586
    milter_abort(e);
    }
  } else
#line 3586
  if ((int )*state == 116) {
    {
#line 3586
    milter_abort(e);
    }
  }
#line 3587
  if (MilterLogLevel > 10) {
#line 3587
    if ((int )*state == 114) {
      {
#line 3588
      sm_syslog(6, (char const   *)e->e_id, "Milter: reject, senders");
      }
    }
  }
#line 3589
  return (response);
}
}
#line 3604 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
char *milter_envrcpt(char **args , ENVELOPE *e , char *state ) 
{ 
  int i ;
  char *buf___16 ;
  char *bp___3 ;
  char *response ;
  ssize_t s ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 3615
  if ((int )tTdvect[64] >= 10) {
    {
#line 3617
    sm_dprintf((char *)"milter_envrcpt:");
#line 3618
    i = 0;
    }
    {
#line 3618
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3618
      if (! ((unsigned long )*(args + i) != (unsigned long )((void *)0))) {
#line 3618
        goto while_break;
      }
      {
#line 3619
      sm_dprintf((char *)" %s", *(args + i));
#line 3618
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3620
    sm_dprintf((char *)"\n");
    }
  }
#line 3624
  if ((unsigned long )*(args + 0) == (unsigned long )((void *)0)) {
#line 3626
    *state = (char )'r';
#line 3627
    if (MilterLogLevel > 10) {
      {
#line 3628
      sm_syslog(6, (char const   *)e->e_id, "Milter: reject, no rcpt");
      }
    }
#line 3629
    return ((char *)((void *)0));
  }
#line 3633
  s = 0;
#line 3634
  i = 0;
  {
#line 3634
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3634
    if (! ((unsigned long )*(args + i) != (unsigned long )((void *)0))) {
#line 3634
      goto while_break___0;
    }
    {
#line 3635
    tmp = strlen((char const   *)*(args + i));
#line 3635
    s = (ssize_t )((size_t )s + (tmp + 1U));
#line 3634
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3637
  if (s < 0) {
#line 3639
    *state = (char )'t';
#line 3640
    return ((char *)((void *)0));
  }
  {
#line 3643
  tmp___0 = xalloc_tagged(s, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                          3643);
#line 3643
  buf___16 = tmp___0;
#line 3644
  bp___3 = buf___16;
#line 3645
  i = 0;
  }
  {
#line 3645
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3645
    if (! ((unsigned long )*(args + i) != (unsigned long )((void *)0))) {
#line 3645
      goto while_break___1;
    }
    {
#line 3647
    sm_strlcpy(bp___3, (char const   *)*(args + i), (ssize_t )((long )s - (bp___3 - buf___16)));
#line 3648
    tmp___1 = strlen((char const   *)bp___3);
#line 3648
    bp___3 += tmp___1 + 1U;
#line 3645
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3651
  if (MilterLogLevel > 14) {
    {
#line 3652
    sm_syslog(6, (char const   *)e->e_id, "Milter: rcpts: %s", buf___16);
    }
  }
  {
#line 3655
  response = milter_command((char )'R', (void *)buf___16, s, MilterEnvRcptMacros,
                            e, state);
#line 3657
  sm_free_tagged((void *)buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                 3657);
  }
#line 3658
  return (response);
}
}
#line 3717 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
char *milter_data(ENVELOPE *e , char *state ) 
{ 
  bool replbody ;
  bool replfailed ;
  bool rewind___0 ;
  bool dfopen___0 ;
  bool newfilter ;
  char rcmd___0 ;
  int i ;
  int save_errno ;
  char *response ;
  time_t eomsent ;
  ssize_t rlen ;
  struct milter *m ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  time_t tmp___3 ;
  char *ptr ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;

  {
#line 3722
  replbody = 0;
#line 3723
  replfailed = 0;
#line 3724
  rewind___0 = 0;
#line 3725
  dfopen___0 = 0;
#line 3730
  response = (char *)((void *)0);
#line 3734
  if ((int )tTdvect[64] >= 10) {
    {
#line 3735
    sm_dprintf((char *)"milter_data\n");
    }
  }
#line 3737
  *state = (char )'c';
#line 3746
  i = 0;
  {
#line 3746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3746
    if (! ((unsigned long )InputFilters[i] != (unsigned long )((void *)0))) {
#line 3746
      goto while_break;
    }
#line 3748
    m = InputFilters[i];
#line 3750
    if ((int )*state != 99) {
#line 3750
      if ((int )*state != 97) {
#line 3758
        goto while_break;
      }
    }
#line 3762
    *state = (char )'c';
#line 3763
    newfilter = 1;
#line 3766
    if ((int )m->mf_state == 69) {
#line 3768
      if ((int )tTdvect[71] >= 100) {
#line 3768
        if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
          {
#line 3768
          e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 3768
          tmp = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 3768
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                           3768, SmHeapGroup);
          }
        }
      } else
#line 3768
      if ((int )tTdvect[71] >= 101) {
#line 3768
        if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
          {
#line 3768
          e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 3768
          tmp___0 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 3768
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___0, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                           3768, SmHeapGroup);
          }
        }
      } else
#line 3768
      if (m->mf_flags[84UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 84UL % (8UL * sizeof(int )))) {
#line 3768
        *state = (char )'t';
      } else
#line 3768
      if (m->mf_flags[52UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 52UL % (8UL * sizeof(int )))) {
#line 3768
        *state = (char )'4';
      } else
#line 3768
      if (m->mf_flags[82UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 82UL % (8UL * sizeof(int )))) {
#line 3768
        *state = (char )'r';
      } else {
#line 3768
        goto __Cont;
      }
#line 3769
      goto while_break;
    }
#line 3773
    if (m->mf_sock < 0) {
#line 3775
      goto __Cont;
    } else
#line 3773
    if ((int )m->mf_state != 79) {
#line 3773
      if ((int )m->mf_state != 77) {
#line 3775
        goto __Cont;
      }
    }
#line 3777
    m->mf_state = (char )'M';
#line 3780
    if (! (((long )m->mf_pflags & 32L) != 0L)) {
      {
#line 3782
      response = milter_headers(m, e, state);
      }
#line 3783
      if ((int )*state == 97) {
#line 3783
        goto _L;
      } else
#line 3783
      if ((int )m->mf_state == 68) {
#line 3783
        goto _L;
      } else
#line 3783
      if ((int )m->mf_state == 69) {
        _L: /* CIL Label */ 
#line 3783
        if ((int )m->mf_state != 69) {
#line 3783
          m->mf_state = (char )'D';
        }
#line 3783
        goto __Cont;
      }
#line 3783
      if ((int )*state != 99) {
#line 3783
        m->mf_state = (char )'D';
#line 3783
        goto finishup;
      }
    }
#line 3787
    if (! (((long )m->mf_pflags & 64L) != 0L)) {
#line 3789
      if ((int )tTdvect[64] >= 10) {
        {
#line 3790
        sm_dprintf((char *)"milter_data: eoh\n");
        }
      }
      {
#line 3793
      response = milter_send_command(m, (char )'N', (void *)0, 0, e, state);
      }
#line 3795
      if ((int )*state == 97) {
#line 3795
        goto _L___0;
      } else
#line 3795
      if ((int )m->mf_state == 68) {
#line 3795
        goto _L___0;
      } else
#line 3795
      if ((int )m->mf_state == 69) {
        _L___0: /* CIL Label */ 
#line 3795
        if ((int )m->mf_state != 69) {
#line 3795
          m->mf_state = (char )'D';
        }
#line 3795
        goto __Cont;
      }
#line 3795
      if ((int )*state != 99) {
#line 3795
        m->mf_state = (char )'D';
#line 3795
        goto finishup;
      }
    }
#line 3799
    if (! (((long )m->mf_pflags & 16L) != 0L)) {
#line 3799
      if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
        {
#line 3802
        rewind___0 = 1;
#line 3803
        response = milter_body(m, e, state);
        }
#line 3804
        if ((int )*state == 97) {
#line 3804
          goto _L___1;
        } else
#line 3804
        if ((int )m->mf_state == 68) {
#line 3804
          goto _L___1;
        } else
#line 3804
        if ((int )m->mf_state == 69) {
          _L___1: /* CIL Label */ 
#line 3804
          if ((int )m->mf_state != 69) {
#line 3804
            m->mf_state = (char )'D';
          }
#line 3804
          goto __Cont;
        }
#line 3804
        if ((int )*state != 99) {
#line 3804
          m->mf_state = (char )'D';
#line 3804
          goto finishup;
        }
      }
    }
#line 3807
    if ((unsigned long )MilterEOMMacros[0] != (unsigned long )((void *)0)) {
      {
#line 3809
      milter_send_macros(m, MilterEOMMacros, (char )'E', e);
      }
#line 3811
      if ((int )*state == 97) {
#line 3811
        goto _L___2;
      } else
#line 3811
      if ((int )m->mf_state == 68) {
#line 3811
        goto _L___2;
      } else
#line 3811
      if ((int )m->mf_state == 69) {
        _L___2: /* CIL Label */ 
#line 3811
        if ((int )m->mf_state != 69) {
#line 3811
          m->mf_state = (char )'D';
        }
#line 3811
        goto __Cont;
      }
#line 3811
      if ((int )*state != 99) {
#line 3811
        m->mf_state = (char )'D';
#line 3811
        goto finishup;
      }
    }
    {
#line 3815
    milter_write(m, (char )'E', (char *)((void *)0), 0, m->mf_timeout[0], e);
#line 3819
    eomsent = curtime();
    }
    {
#line 3822
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3822
      if (! ((int )*state == 99)) {
#line 3822
        goto while_break___0;
      }
#line 3825
      if (m->mf_timeout[2] > 0L) {
        {
#line 3825
        tmp___3 = curtime();
        }
#line 3825
        if (tmp___3 - eomsent >= m->mf_timeout[2]) {
#line 3828
          if ((int )tTdvect[64] >= 5) {
            {
#line 3829
            sm_dprintf((char *)"milter_data(%s): EOM ACK/NAK timeout\n", m->mf_name);
            }
          }
#line 3831
          if (MilterLogLevel > 0) {
            {
#line 3832
            sm_syslog(3, (char const   *)e->e_id, "milter_data(%s): EOM ACK/NAK timeout",
                      m->mf_name);
            }
          }
          {
#line 3835
          milter_error(m, e);
          }
#line 3836
          if ((int )tTdvect[71] >= 100) {
#line 3836
            if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
              {
#line 3836
              e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 3836
              tmp___1 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 3836
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___1, e->e_quarmsg,
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                               3836, SmHeapGroup);
              }
            }
          } else
#line 3836
          if ((int )tTdvect[71] >= 101) {
#line 3836
            if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
              {
#line 3836
              e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 3836
              tmp___2 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 3836
              macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___2, e->e_quarmsg,
                               (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                               3836, SmHeapGroup);
              }
            }
          } else
#line 3836
          if (m->mf_flags[84UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 84UL % (8UL * sizeof(int )))) {
#line 3836
            *state = (char )'t';
          } else
#line 3836
          if (m->mf_flags[52UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 52UL % (8UL * sizeof(int )))) {
#line 3836
            *state = (char )'4';
          } else
#line 3836
          if (m->mf_flags[82UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 82UL % (8UL * sizeof(int )))) {
#line 3836
            *state = (char )'r';
          } else {
#line 3836
            goto while_break___0;
          }
#line 3837
          goto while_break___0;
        }
      }
      {
#line 3840
      response = milter_read(m, & rcmd___0, & rlen, m->mf_timeout[1], e);
      }
#line 3842
      if ((int )m->mf_state == 69) {
#line 3843
        goto while_break___0;
      }
#line 3845
      if ((int )tTdvect[64] >= 10) {
        {
#line 3846
        sm_dprintf((char *)"milter_data(%s): state %c\n", m->mf_name, (int )rcmd___0);
        }
      }
      {
#line 3851
      if ((int )rcmd___0 == 121) {
#line 3851
        goto case_121;
      }
#line 3860
      if ((int )rcmd___0 == 114) {
#line 3860
        goto case_114;
      }
#line 3868
      if ((int )rcmd___0 == 100) {
#line 3868
        goto case_100;
      }
#line 3876
      if ((int )rcmd___0 == 116) {
#line 3876
        goto case_116;
      }
#line 3885
      if ((int )rcmd___0 == 97) {
#line 3885
        goto case_97;
      }
#line 3885
      if ((int )rcmd___0 == 99) {
#line 3885
        goto case_97;
      }
#line 3894
      if ((int )rcmd___0 == 112) {
#line 3894
        goto case_112;
      }
#line 3897
      if ((int )rcmd___0 == 113) {
#line 3897
        goto case_113;
      }
#line 3917
      if ((int )rcmd___0 == 104) {
#line 3917
        goto case_104;
      }
#line 3928
      if ((int )rcmd___0 == 105) {
#line 3928
        goto case_105;
      }
#line 3939
      if ((int )rcmd___0 == 109) {
#line 3939
        goto case_109;
      }
#line 3950
      if ((int )rcmd___0 == 43) {
#line 3950
        goto case_43;
      }
#line 3961
      if ((int )rcmd___0 == 45) {
#line 3961
        goto case_45;
      }
#line 3972
      if ((int )rcmd___0 == 98) {
#line 3972
        goto case_98;
      }
#line 4005
      goto switch_default;
      case_121: /* CIL Label */ 
#line 3852
      if ((unsigned long )response == (unsigned long )((void *)0)) {
#line 3852
        goto _L___3;
      } else {
        {
#line 3852
        tmp___4 = strlen((char const   *)response);
        }
#line 3852
        if (tmp___4 + 1U != (size_t )rlen) {
#line 3852
          goto _L___3;
        } else
#line 3852
        if (rlen < 3) {
#line 3852
          goto _L___3;
        } else
#line 3852
        if ((int )*(response + 0) != 52) {
#line 3852
          if ((int )*(response + 0) != 53) {
#line 3852
            goto _L___3;
          } else {
#line 3852
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 3852
        if (! (((int )*(response + 1) & -128) == 0)) {
#line 3852
          goto _L___3;
        } else {
          {
#line 3852
          tmp___5 = __ctype_b_loc();
          }
#line 3852
          if ((int const   )*(*tmp___5 + (int )*(response + 1)) & 2048) {
#line 3852
            if (! (((int )*(response + 2) & -128) == 0)) {
#line 3852
              goto _L___3;
            } else {
              {
#line 3852
              tmp___6 = __ctype_b_loc();
              }
#line 3852
              if ((int const   )*(*tmp___6 + (int )*(response + 2)) & 2048) {
#line 3852
                ptr = response;
                {
#line 3852
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 3852
                  if (! ((int )*ptr != 0)) {
#line 3852
                    goto while_break___1;
                  }
#line 3852
                  if ((int )*ptr == 37) {
#line 3852
                    ptr ++;
#line 3852
                    if ((int )*ptr != 37) {
                      {
#line 3852
                      sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                                     3852);
#line 3852
                      response = newstr("554 5.7.1 Command rejected");
                      }
#line 3852
                      goto while_break___1;
                    }
                  }
#line 3852
                  ptr ++;
                }
                while_break___1: /* CIL Label */ ;
                }
              } else {
                _L___3: /* CIL Label */ 
#line 3852
                if ((unsigned long )response != (unsigned long )((void *)0)) {
                  {
#line 3852
                  sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                                 3852);
                  }
                }
                {
#line 3852
                response = newstr("554 5.7.1 Command rejected");
                }
              }
            }
          } else {
#line 3852
            goto _L___3;
          }
        }
      }
#line 3853
      if (MilterLogLevel > 12) {
        {
#line 3854
        sm_syslog(6, (char const   *)e->e_id, "milter=%s, reject=%s", m->mf_name,
                  response);
        }
      }
#line 3856
      *state = rcmd___0;
#line 3857
      m->mf_state = (char )'D';
#line 3858
      goto switch_break;
      case_114: /* CIL Label */ 
#line 3861
      if (MilterLogLevel > 12) {
        {
#line 3862
        sm_syslog(6, (char const   *)e->e_id, "milter=%s, reject", m->mf_name);
        }
      }
#line 3864
      *state = rcmd___0;
#line 3865
      m->mf_state = (char )'D';
#line 3866
      goto switch_break;
      case_100: /* CIL Label */ 
#line 3869
      if (MilterLogLevel > 12) {
        {
#line 3870
        sm_syslog(6, (char const   *)e->e_id, "milter=%s, discard", m->mf_name);
        }
      }
#line 3872
      *state = rcmd___0;
#line 3873
      m->mf_state = (char )'D';
#line 3874
      goto switch_break;
      case_116: /* CIL Label */ 
#line 3877
      if (MilterLogLevel > 12) {
        {
#line 3878
        sm_syslog(6, (char const   *)e->e_id, "milter=%s, tempfail", m->mf_name);
        }
      }
#line 3880
      *state = rcmd___0;
#line 3881
      m->mf_state = (char )'D';
#line 3882
      goto switch_break;
      case_97: /* CIL Label */ 
      case_99: /* CIL Label */ 
#line 3887
      if (replfailed) {
#line 3888
        *state = (char )'t';
      } else {
#line 3890
        *state = (char )'a';
      }
#line 3891
      m->mf_state = (char )'D';
#line 3892
      goto switch_break;
      case_112: /* CIL Label */ 
#line 3895
      goto switch_break;
      case_113: /* CIL Label */ 
#line 3898
      if (! (((long )m->mf_fflags & 32L) != 0L)) {
#line 3900
        if (MilterLogLevel > 9) {
          {
#line 3901
          sm_syslog(4, (char const   *)e->e_id, "milter_data(%s): lied about quarantining, honoring request anyway",
                    m->mf_name);
          }
        }
      }
#line 3905
      if ((unsigned long )response == (unsigned long )((void *)0)) {
        {
#line 3906
        response = newstr("");
        }
      }
#line 3907
      if (MilterLogLevel > 3) {
        {
#line 3908
        sm_syslog(6, (char const   *)e->e_id, "milter=%s, quarantine=%s", m->mf_name,
                  response);
        }
      }
      {
#line 3911
      e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, (char const   *)response);
#line 3913
      tmp___7 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 3913
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___7, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                       3914, SmHeapGroup);
      }
#line 3915
      goto switch_break;
      case_104: /* CIL Label */ 
#line 3918
      if (! (((long )m->mf_fflags & 1L) != 0L)) {
#line 3920
        if (MilterLogLevel > 9) {
          {
#line 3921
          sm_syslog(4, (char const   *)e->e_id, "milter_data(%s): lied about adding headers, honoring request anyway",
                    m->mf_name);
          }
        }
      }
      {
#line 3925
      milter_addheader(response, rlen, e);
      }
#line 3926
      goto switch_break;
      case_105: /* CIL Label */ 
#line 3929
      if (! (((long )m->mf_fflags & 1L) != 0L)) {
#line 3931
        if (MilterLogLevel > 9) {
          {
#line 3932
          sm_syslog(4, (char const   *)e->e_id, "milter_data(%s): lied about adding headers, honoring request anyway",
                    m->mf_name);
          }
        }
      }
      {
#line 3936
      milter_insheader(response, rlen, e);
      }
#line 3937
      goto switch_break;
      case_109: /* CIL Label */ 
#line 3940
      if (! (((long )m->mf_fflags & 16L) != 0L)) {
#line 3942
        if (MilterLogLevel > 9) {
          {
#line 3943
          sm_syslog(4, (char const   *)e->e_id, "milter_data(%s): lied about changing headers, honoring request anyway",
                    m->mf_name);
          }
        }
      }
      {
#line 3947
      milter_changeheader(response, rlen, e);
      }
#line 3948
      goto switch_break;
      case_43: /* CIL Label */ 
#line 3951
      if (! (((long )m->mf_fflags & 4L) != 0L)) {
#line 3953
        if (MilterLogLevel > 9) {
          {
#line 3954
          sm_syslog(4, (char const   *)e->e_id, "milter_data(%s) lied about adding recipients, honoring request anyway",
                    m->mf_name);
          }
        }
      }
      {
#line 3958
      milter_addrcpt(response, rlen, e);
      }
#line 3959
      goto switch_break;
      case_45: /* CIL Label */ 
#line 3962
      if (! (((long )m->mf_fflags & 8L) != 0L)) {
#line 3964
        if (MilterLogLevel > 9) {
          {
#line 3965
          sm_syslog(4, (char const   *)e->e_id, "milter_data(%s): lied about removing recipients, honoring request anyway",
                    m->mf_name);
          }
        }
      }
      {
#line 3969
      milter_delrcpt(response, rlen, e);
      }
#line 3970
      goto switch_break;
      case_98: /* CIL Label */ 
#line 3973
      if (! (((long )m->mf_fflags & 2L) != 0L)) {
#line 3975
        if (MilterLogLevel > 0) {
          {
#line 3976
          sm_syslog(3, (char const   *)e->e_id, "milter_data(%s): lied about replacing body, rejecting request and tempfailing message",
                    m->mf_name);
          }
        }
#line 3979
        replfailed = 1;
#line 3980
        goto switch_break;
      }
#line 3984
      if (replfailed) {
#line 3985
        goto switch_break;
      }
#line 3987
      if (! dfopen___0) {
        {
#line 3989
        tmp___8 = milter_reopen_df(e);
        }
#line 3989
        if (tmp___8 < 0) {
#line 3991
          replfailed = 1;
#line 3992
          goto switch_break;
        }
#line 3994
        dfopen___0 = 1;
#line 3995
        rewind___0 = 1;
      }
      {
#line 3998
      tmp___9 = milter_replbody(response, rlen, newfilter, e);
      }
#line 3998
      if (tmp___9 < 0) {
#line 4000
        replfailed = 1;
      }
#line 4001
      newfilter = 0;
#line 4002
      replbody = 1;
#line 4003
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 4007
      if (MilterLogLevel > 0) {
        {
#line 4008
        sm_syslog(3, (char const   *)e->e_id, "milter_data(%s): returned bogus response %c",
                  m->mf_name, (int )rcmd___0);
        }
      }
      {
#line 4011
      milter_error(m, e);
      }
#line 4012
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 4014
      if ((int )rcmd___0 != 121) {
#line 4014
        if ((unsigned long )response != (unsigned long )((void *)0)) {
          {
#line 4016
          sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                         4016);
#line 4017
          response = (char *)((void *)0);
          }
        }
      }
#line 4020
      if ((int )m->mf_state == 69) {
#line 4021
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4024
    if (replbody) {
#line 4024
      if (! replfailed) {
        {
#line 4027
        milter_replbody((char *)((void *)0), 0, ! replbody, e);
#line 4028
        replbody = 0;
        }
      }
    }
#line 4031
    if ((int )m->mf_state == 69) {
#line 4033
      if ((int )tTdvect[71] >= 100) {
#line 4033
        if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
          {
#line 4033
          e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 4033
          tmp___10 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 4033
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___10, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                           4033, SmHeapGroup);
          }
        }
      } else
#line 4033
      if ((int )tTdvect[71] >= 101) {
#line 4033
        if ((unsigned long )e->e_quarmsg == (unsigned long )((void *)0)) {
          {
#line 4033
          e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, "filter failure");
#line 4033
          tmp___11 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 4033
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___11, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                           4033, SmHeapGroup);
          }
        }
      } else
#line 4033
      if (m->mf_flags[84UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 84UL % (8UL * sizeof(int )))) {
#line 4033
        *state = (char )'t';
      } else
#line 4033
      if (m->mf_flags[52UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 52UL % (8UL * sizeof(int )))) {
#line 4033
        *state = (char )'4';
      } else
#line 4033
      if (m->mf_flags[82UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 82UL % (8UL * sizeof(int )))) {
#line 4033
        *state = (char )'r';
      } else {
#line 4033
        goto __Cont;
      }
#line 4034
      goto finishup;
    }
    __Cont: /* CIL Label */ 
#line 3746
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  finishup: 
#line 4040
  if (replfailed) {
#line 4042
    if ((int )*state == 99) {
#line 4042
      goto _L___5;
    } else
#line 4042
    if ((int )*state == 97) {
      _L___5: /* CIL Label */ 
#line 4045
      *state = (char )'t';
#line 4046
      if ((unsigned long )response != (unsigned long )((void *)0)) {
        {
#line 4046
        sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                       4046);
#line 4046
        response = (char *)((void *)0);
        }
      }
    }
#line 4049
    if (dfopen___0) {
      {
#line 4051
      sm_io_close(e->e_dfp, -2);
#line 4052
      e->e_dfp = (SM_FILE_T *)((void *)0);
#line 4053
      e->e_flags &= 0xffffffffffdfffffUL;
#line 4054
      dfopen___0 = 0;
      }
    }
#line 4056
    rewind___0 = 0;
  }
#line 4059
  if (dfopen___0) {
    {
#line 4059
    tmp___15 = milter_reset_df(e);
    }
#line 4059
    if (tmp___15 < 0) {
#line 4059
      goto _L___7;
    } else {
#line 4059
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 4059
  if (rewind___0) {
    {
#line 4059
    tmp___16 = bfrewind(e->e_dfp);
    }
#line 4059
    if (tmp___16 < 0) {
      _L___7: /* CIL Label */ 
      {
#line 4062
      tmp___12 = __errno_location();
#line 4062
      save_errno = *tmp___12;
#line 4063
      ExitStat = 74;
      }
#line 4070
      if ((int )*state == 99) {
#line 4070
        goto _L___6;
      } else
#line 4070
      if ((int )*state == 97) {
        _L___6: /* CIL Label */ 
#line 4073
        *state = (char )'t';
#line 4074
        if ((unsigned long )response != (unsigned long )((void *)0)) {
          {
#line 4074
          sm_free_tagged((void *)response, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c",
                         4074);
#line 4074
          response = (char *)((void *)0);
          }
        }
      }
      {
#line 4077
      tmp___13 = __errno_location();
#line 4077
      *tmp___13 = save_errno;
#line 4078
      tmp___14 = qid_printqueue(e->e_qgrp, e->e_qdir);
#line 4078
      syserr("milter_data: %s/%cf%s: read error", tmp___14, 'd', e->e_id);
      }
    }
  }
#line 4083
  if ((int )*state == 121) {
    {
#line 4083
    milter_abort(e);
    }
  } else
#line 4083
  if ((int )*state == 114) {
    {
#line 4083
    milter_abort(e);
    }
  } else
#line 4083
  if ((int )*state == 100) {
    {
#line 4083
    milter_abort(e);
    }
  } else
#line 4083
  if ((int )*state == 116) {
    {
#line 4083
    milter_abort(e);
    }
  }
#line 4084
  if (MilterLogLevel > 10) {
#line 4084
    if ((int )*state == 114) {
      {
#line 4085
      sm_syslog(6, (char const   *)e->e_id, "Milter: reject, data");
      }
    }
  }
#line 4086
  return (response);
}
}
#line 4128 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
void milter_quit(ENVELOPE *e ) 
{ 
  int i ;
  char *__cil_tmp3 ;

  {
#line 4134
  if ((int )tTdvect[64] >= 10) {
    {
#line 4135
    sm_dprintf((char *)"milter_quit(%s)\n", e->e_id);
    }
  }
#line 4137
  i = 0;
  {
#line 4137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4137
    if (! ((unsigned long )InputFilters[i] != (unsigned long )((void *)0))) {
#line 4137
      goto while_break;
    }
    {
#line 4138
    milter_quit_filter(InputFilters[i], e);
#line 4137
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4139
  return;
}
}
#line 4150 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/milter.c"
void milter_abort(ENVELOPE *e ) 
{ 
  int i ;
  struct milter *m ;
  char *__cil_tmp4 ;

  {
#line 4156
  if ((int )tTdvect[64] >= 10) {
    {
#line 4157
    sm_dprintf((char *)"milter_abort\n");
    }
  }
#line 4159
  i = 0;
  {
#line 4159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4159
    if (! ((unsigned long )InputFilters[i] != (unsigned long )((void *)0))) {
#line 4159
      goto while_break;
    }
#line 4161
    m = InputFilters[i];
#line 4164
    if (m->mf_sock < 0) {
#line 4165
      goto __Cont;
    } else
#line 4164
    if ((int )m->mf_state != 77) {
#line 4165
      goto __Cont;
    }
    {
#line 4167
    milter_abort_filter(m, e);
    }
    __Cont: /* CIL Label */ 
#line 4159
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4169
  return;
}
}
#line 747 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) rmdir)(char const   *__path ) ;
#line 730 "./sendmail.h"
void mci_cache(struct mailer_con_info *mci ) ;
#line 733
void mci_dump_all(SM_FILE_T *fp , bool logit ) ;
#line 735
struct mailer_con_info *mci_get(char *host , MAILER *m ) ;
#line 736
int mci_lock_host(struct mailer_con_info *mci ) ;
#line 737
bool mci_match(char *host , MAILER *m ) ;
#line 738
int mci_print_persistent(char *pathname , char *hostname ) ;
#line 739
int mci_purge_persistent(char *pathname , char *hostname ) ;
#line 740
struct mailer_con_info **mci_scan(struct mailer_con_info *savemci ) ;
#line 742
void mci_store_persistent(struct mailer_con_info *mci ) ;
#line 743
int mci_traverse_persistent(int (*action)(char * , char * ) , char *pathname ) ;
#line 744
void mci_unlock_host(struct mailer_con_info *mci ) ;
#line 201 "/usr/include/dirent.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1))) rewinddir)(DIR *__dirp ) ;
#line 24 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
static int mci_generate_persistent_path(char const   *host , char *path , int pathlen ,
                                        bool createflag ) ;
#line 26
static bool mci_load_persistent(struct mailer_con_info *mci ) ;
#line 27
static void mci_uncache(struct mailer_con_info **mcislot , bool doquit ) ;
#line 28
static int mci_lock_host_statfile(struct mailer_con_info *mci ) ;
#line 29
static int mci_read_persistent(SM_FILE_T *fp , struct mailer_con_info *mci ) ;
#line 60 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
static struct mailer_con_info **MciCache  ;
#line 74 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
void mci_cache(struct mailer_con_info *mci ) 
{ 
  register struct mailer_con_info **mcislot ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 85
  mcislot = mci_scan(mci);
  }
#line 86
  if ((unsigned long )mcislot == (unsigned long )((void *)0)) {
#line 89
    return;
  }
#line 92
  if ((unsigned long )mci->mci_host == (unsigned long )((void *)0)) {
#line 93
    return;
  }
#line 96
  if ((mci->mci_flags & 4UL) != 0UL) {
#line 97
    return;
  }
#line 100
  if ((unsigned long )*mcislot != (unsigned long )((void *)0)) {
    {
#line 101
    mci_uncache(mcislot, 1);
    }
  }
#line 103
  if ((int )tTdvect[42] >= 5) {
    {
#line 104
    sm_dprintf((char *)"mci_cache: caching %p (%s) in slot %d\n", mci, mci->mci_host,
               (int )(mcislot - MciCache));
    }
  }
#line 106
  if ((int )tTdvect[91] >= 100) {
    {
#line 107
    sm_syslog(7, (char const   *)CurEnv->e_id, "mci_cache: caching %lx (%.100s) in slot %d",
              (unsigned long )mci, mci->mci_host, (int )(mcislot - MciCache));
    }
  }
#line 112
  *mcislot = mci;
#line 113
  mci->mci_flags |= 4UL;
#line 114
  return;
}
}
#line 125 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
struct mailer_con_info **mci_scan(struct mailer_con_info *savemci ) 
{ 
  time_t now ;
  register struct mailer_con_info **bestmci ;
  register struct mailer_con_info *mci ;
  register int i ;
  void *tmp ;
  char *__cil_tmp7 ;

  {
#line 134
  if (MaxMciCache <= 0) {
#line 137
    return ((struct mailer_con_info **)((void *)0));
  }
#line 140
  if ((unsigned long )MciCache == (unsigned long )((void *)0)) {
    {
#line 143
    tmp = sm_malloc_tagged_x((size_t )((unsigned long )MaxMciCache * sizeof(*MciCache)),
                             (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c",
                             143, 0);
#line 143
    MciCache = (struct mailer_con_info **)tmp;
#line 144
    memset((void *)((char *)MciCache), '\000', (size_t )((unsigned long )MaxMciCache * sizeof(*MciCache)));
    }
#line 145
    return (MciCache + 0);
  }
  {
#line 148
  now = curtime();
#line 149
  bestmci = MciCache + 0;
#line 150
  i = 0;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i < MaxMciCache)) {
#line 150
      goto while_break;
    }
#line 152
    mci = *(MciCache + i);
#line 153
    if ((unsigned long )mci == (unsigned long )((void *)0)) {
#line 155
      bestmci = MciCache + i;
#line 156
      goto __Cont;
    } else
#line 153
    if ((int )mci->mci_state == 0) {
#line 155
      bestmci = MciCache + i;
#line 156
      goto __Cont;
    }
#line 158
    if (mci->mci_lastuse + MciCacheTimeout <= now) {
#line 158
      goto _L;
    } else
#line 158
    if ((unsigned long )mci->mci_mailer != (unsigned long )((void *)0)) {
#line 158
      if ((mci->mci_mailer)->m_maxdeliveries > 0) {
#line 158
        if (mci->mci_deliveries + 1 >= (mci->mci_mailer)->m_maxdeliveries) {
          _L: /* CIL Label */ 
#line 158
          if ((unsigned long )mci != (unsigned long )savemci) {
            {
#line 165
            bestmci = MciCache + i;
#line 168
            mci_uncache(bestmci, 1);
            }
#line 169
            goto __Cont;
          }
        }
      }
    }
#line 171
    if ((unsigned long )*bestmci == (unsigned long )((void *)0)) {
#line 172
      goto __Cont;
    }
#line 173
    if (mci->mci_lastuse < (*bestmci)->mci_lastuse) {
#line 174
      bestmci = MciCache + i;
    }
    __Cont: /* CIL Label */ 
#line 150
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (bestmci);
}
}
#line 193 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
static void mci_uncache(struct mailer_con_info **mcislot , bool doquit ) 
{ 
  register struct mailer_con_info *mci ;
  SM_FILE_T *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 201
  mci = *mcislot;
#line 202
  if ((unsigned long )mci == (unsigned long )((void *)0)) {
#line 203
    return;
  }
#line 204
  *mcislot = (struct mailer_con_info *)((void *)0);
#line 205
  if ((unsigned long )mci->mci_host == (unsigned long )((void *)0)) {
#line 206
    return;
  }
  {
#line 208
  mci_unlock_host(mci);
  }
#line 210
  if ((int )tTdvect[42] >= 5) {
    {
#line 211
    sm_dprintf((char *)"mci_uncache: uncaching %p (%s) from slot %d (%d)\n", mci,
               mci->mci_host, (int )(mcislot - MciCache), doquit);
    }
  }
#line 214
  if ((int )tTdvect[91] >= 100) {
    {
#line 215
    sm_syslog(7, (char const   *)CurEnv->e_id, "mci_uncache: uncaching %lx (%.100s) from slot %d (%d)",
              (unsigned long )mci, mci->mci_host, (int )(mcislot - MciCache), doquit);
    }
  }
#line 220
  mci->mci_deliveries = 0;
#line 221
  if (doquit) {
    {
#line 223
    message("Closing connection to %s", mci->mci_host);
#line 225
    mci->mci_flags &= 0xfffffffffffffffbUL;
    }
#line 228
    if ((int )mci->mci_state != 0) {
      {
#line 229
      smtpquit(mci->mci_mailer, mci, & BlankEnvelope);
      }
    }
  } else {
#line 236
    if ((unsigned long )mci->mci_in != (unsigned long )((void *)0)) {
      {
#line 237
      sm_io_close(mci->mci_in, -2);
      }
    }
#line 238
    if ((unsigned long )mci->mci_out != (unsigned long )((void *)0)) {
      {
#line 239
      sm_io_close(mci->mci_out, -2);
      }
    }
#line 240
    tmp = (SM_FILE_T *)((void *)0);
#line 240
    mci->mci_out = tmp;
#line 240
    mci->mci_in = tmp;
#line 241
    mci->mci_state = (short)0;
#line 242
    mci->mci_exitstat = (short)0;
#line 243
    mci->mci_errno = (short)0;
#line 244
    mci->mci_flags = 0UL;
#line 246
    mci->mci_retryrcpt = 0;
#line 247
    mci->mci_tolist = (char *)((void *)0);
#line 249
    mci->mci_okrcpts = 0;
  }
#line 253
  if ((unsigned long )mci->mci_status != (unsigned long )((void *)0)) {
    {
#line 253
    sm_free_tagged((void *)mci->mci_status, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c",
                   253);
#line 253
    mci->mci_status = (char *)((void *)0);
    }
  }
#line 254
  if ((unsigned long )mci->mci_rstatus != (unsigned long )((void *)0)) {
    {
#line 254
    sm_free_tagged((void *)mci->mci_rstatus, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c",
                   254);
#line 254
    mci->mci_rstatus = (char *)((void *)0);
    }
  }
#line 255
  if ((unsigned long )mci->mci_heloname != (unsigned long )((void *)0)) {
    {
#line 255
    sm_free_tagged((void *)mci->mci_heloname, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c",
                   255);
#line 255
    mci->mci_heloname = (char *)((void *)0);
    }
  }
#line 256
  if ((unsigned long )mci->mci_rpool != (unsigned long )((void *)0)) {
    {
#line 258
    sm_rpool_free(mci->mci_rpool);
#line 259
    mci->mci_macro.mac_rpool = (SM_RPOOL_T *)((void *)0);
#line 260
    mci->mci_rpool = (SM_RPOOL_T *)((void *)0);
    }
  }
#line 262
  return;
}
}
#line 275 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
void mci_flush(bool doquit , struct mailer_con_info *allbut ) 
{ 
  register int i ;

  {
#line 282
  if ((unsigned long )MciCache == (unsigned long )((void *)0)) {
#line 283
    return;
  }
#line 285
  i = 0;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! (i < MaxMciCache)) {
#line 285
      goto while_break;
    }
#line 287
    if ((unsigned long )allbut != (unsigned long )*(MciCache + i)) {
      {
#line 288
      mci_uncache(MciCache + i, doquit);
      }
    }
#line 285
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return;
}
}
#line 309
union bigsockaddr CurHostAddr ;
#line 302 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
struct mailer_con_info *mci_get(char *host , MAILER *m ) 
{ 
  register struct mailer_con_info *mci ;
  register STAB *s ;
  char *tmp ;
  bool tmp___0 ;
  int socklen ;
  int tmp___1 ;
  time_t now ;
  time_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 312
  memset((void *)(& CurHostAddr), '\000', (size_t )sizeof(CurHostAddr));
#line 315
  mci_scan((struct mailer_con_info *)((void *)0));
  }
#line 317
  if ((int )m->m_mno < 0) {
    {
#line 318
    syserr("!negative mno %d (%s)", (int )m->m_mno, m->m_name);
    }
  }
  {
#line 320
  s = stab(host, 17 + (int )m->m_mno, 1);
#line 321
  mci = & s->s_value.sv_mci;
#line 324
  mci->mci_retryrcpt = 0;
#line 325
  mci->mci_tolist = (char *)((void *)0);
#line 327
  mci->mci_okrcpts = 0;
  }
#line 330
  if ((unsigned long )mci->mci_rpool == (unsigned long )((void *)0)) {
    {
#line 331
    mci->mci_rpool = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
    }
  }
#line 333
  if ((unsigned long )mci->mci_macro.mac_rpool == (unsigned long )((void *)0)) {
#line 334
    mci->mci_macro.mac_rpool = mci->mci_rpool;
  }
#line 341
  if ((unsigned long )mci->mci_host == (unsigned long )((void *)0)) {
#line 341
    tmp = s->s_name;
#line 341
    mci->mci_host = tmp;
#line 341
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 341
      tmp___0 = mci_load_persistent(mci);
      }
#line 341
      if (! tmp___0) {
#line 345
        if ((int )tTdvect[42] >= 2) {
          {
#line 346
          sm_dprintf((char *)"mci_get(%s %s): lock failed\n", host, m->m_name);
          }
        }
#line 348
        mci->mci_exitstat = (short)75;
#line 349
        mci->mci_state = (short)0;
#line 350
        mci->mci_statfile = (SM_FILE_T *)((void *)0);
#line 351
        return (mci);
      }
    }
  }
#line 354
  if ((int )tTdvect[42] >= 2) {
    {
#line 356
    sm_dprintf((char *)"mci_get(%s %s): mci_state=%d, _flags=%lx, _exitstat=%d, _errno=%d\n",
               host, m->m_name, (int )mci->mci_state, mci->mci_flags, (int )mci->mci_exitstat,
               (int )mci->mci_errno);
    }
  }
#line 361
  if ((int )mci->mci_state == 2) {
    {
#line 364
    smtpprobe(mci);
    }
#line 367
    if ((int )mci->mci_state != 2) {
#line 369
      mci->mci_errno = (short)0;
#line 370
      mci->mci_exitstat = (short)0;
#line 371
      mci->mci_state = (short)0;
    } else {
      {
#line 377
      socklen = (int )sizeof(CurHostAddr);
#line 379
      tmp___1 = sm_io_getinfo(mci->mci_in, 3, (void *)0);
#line 379
      getpeername(tmp___1, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& CurHostAddr)),
                  (socklen_t */* __restrict  */)(& socklen));
      }
    }
  }
#line 384
  if ((int )mci->mci_state == 0) {
    {
#line 386
    tmp___2 = curtime();
#line 386
    now = tmp___2;
    }
#line 389
    if (mci->mci_lastuse + MciInfoTimeout <= now) {
#line 391
      mci->mci_lastuse = now;
#line 392
      mci->mci_errno = (short)0;
#line 393
      mci->mci_exitstat = (short)0;
    }
  }
#line 397
  return (mci);
}
}
#line 413 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
void mci_close(struct mailer_con_info *mci , char *where ) 
{ 
  bool dumped ;
  SM_FILE_T *tmp ;
  SM_FILE_T *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 420
  if ((unsigned long )mci == (unsigned long )((void *)0)) {
#line 421
    return;
  }
#line 422
  dumped = 0;
#line 423
  if ((unsigned long )mci->mci_out != (unsigned long )((void *)0)) {
#line 425
    if ((int )tTdvect[56] >= 1) {
      {
#line 427
      sm_dprintf((char *)"mci_close: mci_out!=NULL, where=%s\n", where);
#line 429
      tmp = sm_debug_file();
#line 429
      mci_dump(tmp, mci, 0);
#line 430
      dumped = 1;
      }
    }
    {
#line 432
    sm_io_close(mci->mci_out, -2);
#line 433
    mci->mci_out = (SM_FILE_T *)((void *)0);
    }
  }
#line 435
  if ((unsigned long )mci->mci_in != (unsigned long )((void *)0)) {
#line 437
    if ((int )tTdvect[56] >= 1) {
      {
#line 439
      sm_dprintf((char *)"mci_close: mci_in!=NULL, where=%s\n", where);
      }
#line 441
      if (! dumped) {
        {
#line 442
        tmp___0 = sm_debug_file();
#line 442
        mci_dump(tmp___0, mci, 0);
        }
      }
    }
    {
#line 444
    sm_io_close(mci->mci_in, -2);
#line 445
    mci->mci_in = (SM_FILE_T *)((void *)0);
    }
  }
#line 447
  mci->mci_state = (short)0;
#line 448
  return;
}
}
#line 460 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
struct mailer_con_info *mci_new(SM_RPOOL_T *rpool ) 
{ 
  register struct mailer_con_info *mci ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 466
  if ((unsigned long )rpool == (unsigned long )((void *)0)) {
    {
#line 467
    tmp = sm_malloc_tagged_x((size_t )sizeof(*mci), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c",
                             467, SmHeapGroup);
#line 467
    mci = (struct mailer_con_info *)tmp;
    }
  } else {
    {
#line 469
    tmp___0 = sm_rpool_malloc_tagged_x(rpool, (size_t )sizeof(*mci), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c",
                                       469, SmHeapGroup);
#line 469
    mci = (struct mailer_con_info *)tmp___0;
    }
  }
  {
#line 470
  memset((void *)((char *)mci), '\000', (size_t )sizeof(*mci));
#line 471
  mci->mci_rpool = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 472
  mci->mci_macro.mac_rpool = mci->mci_rpool;
  }
#line 473
  return (mci);
}
}
#line 486 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
bool mci_match(char *host , MAILER *m ) 
{ 
  register struct mailer_con_info *mci ;
  register STAB *s ;

  {
#line 494
  if ((int )m->m_mno < 0) {
#line 495
    return (0);
  } else
#line 494
  if ((int )m->m_mno > 25) {
#line 495
    return (0);
  }
  {
#line 496
  s = stab(host, 17 + (int )m->m_mno, 0);
  }
#line 497
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 498
    return (0);
  }
#line 500
  mci = & s->s_value.sv_mci;
#line 501
  return ((int )mci->mci_state == 2);
}
}
#line 516 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
void mci_setstat(struct mailer_con_info *mci , int xstat , char *dstat , char *rstat ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 524
  if (xstat != -5) {
#line 524
    if (xstat != 76) {
#line 525
      mci->mci_exitstat = (short )xstat;
    }
  }
#line 527
  if ((unsigned long )mci->mci_status != (unsigned long )((void *)0)) {
    {
#line 527
    sm_free_tagged((void *)mci->mci_status, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c",
                   527);
#line 527
    mci->mci_status = (char *)((void *)0);
    }
  }
#line 528
  if ((unsigned long )dstat != (unsigned long )((void *)0)) {
    {
#line 529
    mci->mci_status = sm_strdup_x((char const   *)dstat);
    }
  }
#line 531
  if ((unsigned long )mci->mci_rstatus != (unsigned long )((void *)0)) {
    {
#line 531
    sm_free_tagged((void *)mci->mci_rstatus, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c",
                   531);
#line 531
    mci->mci_rstatus = (char *)((void *)0);
    }
  }
#line 532
  if ((unsigned long )rstat != (unsigned long )((void *)0)) {
    {
#line 533
    mci->mci_rstatus = sm_strdup_x((char const   *)rstat);
    }
  }
#line 534
  return;
}
}
#line 554 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
static struct mcifbits MciFlags[19]  = 
#line 554
  {      {1, (char *)"VALID"}, 
        {4, (char *)"CACHED"}, 
        {8, (char *)"ESMTP"}, 
        {16, (char *)"EXPN"}, 
        {32, (char *)"SIZE"}, 
        {64, (char *)"8BITMIME"}, 
        {128, (char *)"7BIT"}, 
        {512, (char *)"INHEADER"}, 
        {1024, (char *)"CVT8TO7"}, 
        {2048, (char *)"DSN"}, 
        {4096, (char *)"8BITOK"}, 
        {8192, (char *)"CVT7TO8"}, 
        {16384, (char *)"INMIME"}, 
        {32768, (char *)"AUTH"}, 
        {65536, (char *)"AUTHACT"}, 
        {131072, (char *)"ENHSTAT"}, 
        {262144, (char *)"PIPELINED"}, 
        {4194304, (char *)"DLVR_BY"}, 
        {0, (char *)((void *)0)}};
#line 581 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
void mci_dump(SM_FILE_T *fp , struct mailer_con_info *mci , bool logit ) 
{ 
  register char *p ;
  char *sep ;
  char buf___16[4000] ;
  size_t tmp ;
  size_t tmp___0 ;
  struct mcifbits *f ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 591
  if (logit) {
#line 591
    sep = (char *)" ";
  } else {
#line 591
    sep = (char *)"\n\t";
  }
  {
#line 592
  p = buf___16;
#line 593
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "MCI@%p: ",
              mci);
#line 594
  tmp = strlen((char const   *)p);
#line 594
  p += tmp;
  }
#line 595
  if ((unsigned long )mci == (unsigned long )((void *)0)) {
    {
#line 597
    sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "NULL");
    }
#line 598
    goto printit;
  }
  {
#line 600
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "flags=%lx",
              mci->mci_flags);
#line 601
  tmp___0 = strlen((char const   *)p);
#line 601
  p += tmp___0;
  }
#line 610
  if ((unsigned long )p >= (unsigned long )((buf___16 + sizeof(buf___16)) - 4)) {
#line 611
    goto printit;
  }
#line 612
  if (mci->mci_flags != 0UL) {
#line 616
    tmp___1 = p;
#line 616
    p ++;
#line 616
    *tmp___1 = (char )'<';
#line 617
    f = MciFlags;
    {
#line 617
    while (1) {
      while_continue: /* CIL Label */ ;
#line 617
      if (! (f->mcif_bit != 0)) {
#line 617
        goto while_break;
      }
#line 619
      if (! ((mci->mci_flags & (unsigned long )f->mcif_bit) != 0UL)) {
#line 620
        goto __Cont;
      }
      {
#line 621
      sm_strlcpyn(p, (ssize_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)),
                  2, f->mcif_name, ",");
#line 623
      tmp___2 = strlen((char const   *)p);
#line 623
      p += tmp___2;
      }
      __Cont: /* CIL Label */ 
#line 617
      f ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 625
    *(p + -1) = (char )'>';
  }
  {
#line 629
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), ",%serrno=%d, herrno=%d, exitstat=%d, state=%d, pid=%d,%s",
              sep, (int )mci->mci_errno, (int )mci->mci_herrno, (int )mci->mci_exitstat,
              (int )mci->mci_state, mci->mci_pid, sep);
#line 633
  tmp___3 = strlen((char const   *)p);
#line 633
  p += tmp___3;
  }
#line 634
  if ((unsigned long )mci->mci_mailer == (unsigned long )((void *)0)) {
#line 634
    tmp___4 = "NULL";
  } else {
#line 634
    tmp___4 = (char const   *)(mci->mci_mailer)->m_name;
  }
  {
#line 634
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "maxsize=%ld, phase=%s, mailer=%s,%s",
              mci->mci_maxsize, mci->mci_phase, tmp___4, sep);
#line 639
  tmp___5 = strlen((char const   *)p);
#line 639
  p += tmp___5;
#line 640
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "status=%s, rstatus=%s,%s",
              mci->mci_status, mci->mci_rstatus, sep);
#line 643
  tmp___6 = strlen((char const   *)p);
#line 643
  p += tmp___6;
#line 644
  tmp___7 = ctime((time_t const   *)(& mci->mci_lastuse));
#line 644
  sm_snprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), "host=%s, lastuse=%s",
              mci->mci_host, tmp___7);
  }
  printit: 
#line 648
  if (logit) {
    {
#line 649
    sm_syslog(7, (char const   *)CurEnv->e_id, "%.1000s", buf___16);
    }
  } else {
    {
#line 651
    sm_io_fprintf(fp, -2, "%s\n", buf___16);
    }
  }
#line 652
  return;
}
}
#line 665 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
void mci_dump_all(SM_FILE_T *fp , bool logit ) 
{ 
  register int i ;

  {
#line 672
  if ((unsigned long )MciCache == (unsigned long )((void *)0)) {
#line 673
    return;
  }
#line 675
  i = 0;
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (! (i < MaxMciCache)) {
#line 675
      goto while_break;
    }
    {
#line 676
    mci_dump(fp, *(MciCache + i), logit);
#line 675
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  return;
}
}
#line 697 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
int mci_lock_host(struct mailer_con_info *mci ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
#line 701
  if ((unsigned long )mci == (unsigned long )((void *)0)) {
#line 703
    if ((int )tTdvect[56] >= 1) {
      {
#line 704
      sm_dprintf((char *)"mci_lock_host: NULL mci\n");
      }
    }
#line 705
    return (0);
  }
#line 708
  if (! SingleThreadDelivery) {
#line 709
    return (0);
  }
  {
#line 711
  tmp = mci_lock_host_statfile(mci);
  }
#line 711
  return (tmp);
}
}
#line 714 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
static int mci_lock_host_statfile(struct mailer_con_info *mci ) 
{ 
  int save_errno ;
  int *tmp ;
  int retVal ;
  char fname[4096] ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int *tmp___3 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 718
  tmp = __errno_location();
#line 718
  save_errno = *tmp;
#line 719
  retVal = 0;
  }
#line 722
  if ((unsigned long )HostStatDir == (unsigned long )((void *)0)) {
#line 723
    return (0);
  } else
#line 722
  if ((unsigned long )mci->mci_host == (unsigned long )((void *)0)) {
#line 723
    return (0);
  }
#line 725
  if ((int )tTdvect[56] >= 2) {
    {
#line 726
    sm_dprintf((char *)"mci_lock_host: attempting to lock %s\n", mci->mci_host);
    }
  }
  {
#line 729
  tmp___0 = mci_generate_persistent_path((char const   *)mci->mci_host, fname, (int )sizeof(fname),
                                         1);
  }
#line 729
  if (tmp___0 < 0) {
#line 733
    if ((int )tTdvect[56] >= 2) {
      {
#line 734
      sm_dprintf((char *)"mci_lock_host: Failed to generate host path for %s\n", mci->mci_host);
      }
    }
#line 737
    retVal = 75;
#line 738
    goto cleanup;
  }
  {
#line 741
  mci->mci_statfile = safefopen(fname, 2, FileMode, 25538L);
  }
#line 744
  if ((unsigned long )mci->mci_statfile == (unsigned long )((void *)0)) {
    {
#line 746
    syserr("mci_lock_host: cannot create host lock file %s", fname);
    }
#line 747
    goto cleanup;
  }
  {
#line 750
  tmp___1 = sm_io_getinfo(mci->mci_statfile, 3, (void *)0);
#line 750
  tmp___2 = lockfile(tmp___1, fname, (char *)"", 6);
  }
#line 750
  if (! tmp___2) {
#line 753
    if ((int )tTdvect[56] >= 2) {
      {
#line 754
      sm_dprintf((char *)"mci_lock_host: couldn\'t get lock on %s\n", fname);
      }
    }
    {
#line 756
    sm_io_close(mci->mci_statfile, -2);
#line 757
    mci->mci_statfile = (SM_FILE_T *)((void *)0);
#line 758
    retVal = 75;
    }
#line 759
    goto cleanup;
  }
#line 762
  if ((int )tTdvect[56] >= 12) {
#line 762
    if ((unsigned long )mci->mci_statfile != (unsigned long )((void *)0)) {
      {
#line 763
      sm_dprintf((char *)"mci_lock_host: Sanity check -- lock is good\n");
      }
    }
  }
  cleanup: 
  {
#line 766
  tmp___3 = __errno_location();
#line 766
  *tmp___3 = save_errno;
  }
#line 767
  return (retVal);
}
}
#line 782 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
void mci_unlock_host(struct mailer_con_info *mci ) 
{ 
  int save_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 786
  tmp = __errno_location();
#line 786
  save_errno = *tmp;
  }
#line 788
  if ((unsigned long )mci == (unsigned long )((void *)0)) {
#line 790
    if ((int )tTdvect[56] >= 1) {
      {
#line 791
      sm_dprintf((char *)"mci_unlock_host: NULL mci\n");
      }
    }
#line 792
    return;
  }
#line 795
  if ((unsigned long )HostStatDir == (unsigned long )((void *)0)) {
#line 796
    return;
  } else
#line 795
  if ((unsigned long )mci->mci_host == (unsigned long )((void *)0)) {
#line 796
    return;
  }
#line 798
  if (! SingleThreadDelivery) {
    {
#line 798
    tmp___0 = mci_lock_host_statfile(mci);
    }
#line 798
    if (tmp___0 == 75) {
#line 800
      if ((int )tTdvect[56] >= 1) {
        {
#line 801
        sm_dprintf((char *)"mci_unlock_host: stat file already locked\n");
        }
      }
    } else {
#line 798
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 805
    if ((int )tTdvect[56] >= 2) {
      {
#line 806
      sm_dprintf((char *)"mci_unlock_host: store prior to unlock\n");
      }
    }
    {
#line 807
    mci_store_persistent(mci);
    }
  }
#line 810
  if ((unsigned long )mci->mci_statfile != (unsigned long )((void *)0)) {
    {
#line 812
    sm_io_close(mci->mci_statfile, -2);
#line 813
    mci->mci_statfile = (SM_FILE_T *)((void *)0);
    }
  }
  {
#line 816
  tmp___1 = __errno_location();
#line 816
  *tmp___1 = save_errno;
  }
#line 817
  return;
}
}
#line 832 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
static bool mci_load_persistent(struct mailer_con_info *mci ) 
{ 
  int save_errno ;
  int *tmp ;
  bool locked ;
  SM_FILE_T *fp ;
  char fname[4096] ;
  int tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 836
  tmp = __errno_location();
#line 836
  save_errno = *tmp;
#line 837
  locked = 1;
  }
#line 841
  if ((unsigned long )mci == (unsigned long )((void *)0)) {
#line 843
    if ((int )tTdvect[56] >= 1) {
      {
#line 844
      sm_dprintf((char *)"mci_load_persistent: NULL mci\n");
      }
    }
#line 845
    return (1);
  }
#line 848
  if (IgnoreHostStatus) {
#line 849
    return (1);
  } else
#line 848
  if ((unsigned long )HostStatDir == (unsigned long )((void *)0)) {
#line 849
    return (1);
  } else
#line 848
  if ((unsigned long )mci->mci_host == (unsigned long )((void *)0)) {
#line 849
    return (1);
  }
#line 852
  if (SingleThreadDelivery) {
#line 852
    if ((unsigned long )mci->mci_statfile != (unsigned long )((void *)0)) {
#line 853
      return (1);
    }
  }
#line 855
  if ((int )tTdvect[56] >= 1) {
    {
#line 856
    sm_dprintf((char *)"mci_load_persistent: Attempting to load persistent information for %s\n",
               mci->mci_host);
    }
  }
  {
#line 859
  tmp___0 = mci_generate_persistent_path((char const   *)mci->mci_host, fname, (int )sizeof(fname),
                                         0);
  }
#line 859
  if (tmp___0 < 0) {
#line 863
    if ((int )tTdvect[56] >= 1) {
      {
#line 864
      sm_dprintf((char *)"mci_load_persistent: Couldn\'t generate host path\n");
      }
    }
#line 865
    goto cleanup;
  }
  {
#line 868
  fp = safefopen(fname, 0, FileMode, 25474L);
  }
#line 870
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 873
    if ((int )tTdvect[56] >= 1) {
      {
#line 874
      tmp___1 = __errno_location();
#line 874
      tmp___2 = sm_errstring(*tmp___1);
#line 874
      sm_dprintf((char *)"mci_load_persistent: open(%s): %s\n", fname, tmp___2);
      }
    }
#line 876
    goto cleanup;
  }
  {
#line 879
  FileName = fname;
#line 880
  tmp___3 = sm_io_getinfo(fp, 3, (void *)0);
#line 880
  locked = lockfile(tmp___3, fname, (char *)"", 5);
  }
#line 882
  if (locked) {
    {
#line 884
    mci_read_persistent(fp, mci);
#line 885
    tmp___4 = sm_io_getinfo(fp, 3, (void *)0);
#line 885
    lockfile(tmp___4, fname, (char *)"", 8);
    }
  }
  {
#line 888
  FileName = (char *)((void *)0);
#line 889
  sm_io_close(fp, -2);
  }
  cleanup: 
  {
#line 892
  tmp___5 = __errno_location();
#line 892
  *tmp___5 = save_errno;
  }
#line 893
  return (locked);
}
}
#line 914 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
static int mci_read_persistent(SM_FILE_T *fp , struct mailer_con_info *mci ) 
{ 
  int ver ;
  register char *p ;
  int saveLineNumber ;
  char buf___16[2048] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  SM_FILE_T *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 921
  saveLineNumber = LineNumber;
#line 924
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 925
    syserr("mci_read_persistent: NULL fp");
    }
  }
#line 926
  if ((unsigned long )mci == (unsigned long )((void *)0)) {
    {
#line 927
    syserr("mci_read_persistent: NULL mci");
    }
  }
#line 928
  if ((int )tTdvect[56] >= 93) {
    {
#line 930
    sm_dprintf((char *)"mci_read_persistent: fp=%lx, mci=", (unsigned long )fp);
    }
  }
#line 934
  if ((unsigned long )mci->mci_status != (unsigned long )((void *)0)) {
    {
#line 934
    sm_free_tagged((void *)mci->mci_status, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c",
                   934);
#line 934
    mci->mci_status = (char *)((void *)0);
    }
  }
#line 935
  if ((unsigned long )mci->mci_rstatus != (unsigned long )((void *)0)) {
    {
#line 935
    sm_free_tagged((void *)mci->mci_rstatus, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c",
                   935);
#line 935
    mci->mci_rstatus = (char *)((void *)0);
    }
  }
  {
#line 937
  sm_io_rewind(fp, -2);
#line 938
  ver = -1;
#line 939
  LineNumber = 0;
  }
  {
#line 940
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 940
    tmp___4 = sm_io_fgets(fp, -2, buf___16, (int )sizeof(buf___16));
    }
#line 940
    if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 940
      goto while_break;
    }
    {
#line 942
    LineNumber ++;
#line 943
    p = strchr((char const   *)(buf___16), '\n');
    }
#line 944
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 945
      *p = (char )'\000';
    }
    {
#line 948
    if ((int )buf___16[0] == 86) {
#line 948
      goto case_86;
    }
#line 955
    if ((int )buf___16[0] == 69) {
#line 955
      goto case_69;
    }
#line 959
    if ((int )buf___16[0] == 72) {
#line 959
      goto case_72;
    }
#line 963
    if ((int )buf___16[0] == 83) {
#line 963
      goto case_83;
    }
#line 967
    if ((int )buf___16[0] == 68) {
#line 967
      goto case_68;
    }
#line 971
    if ((int )buf___16[0] == 82) {
#line 971
      goto case_82;
    }
#line 975
    if ((int )buf___16[0] == 85) {
#line 975
      goto case_85;
    }
#line 979
    if ((int )buf___16[0] == 46) {
#line 979
      goto case_46;
    }
#line 984
    goto switch_default;
    case_86: /* CIL Label */ 
    {
#line 949
    ver = atoi((char const   *)(& buf___16[1]));
    }
#line 950
    if (ver < 0) {
      {
#line 951
      syserr("Unknown host status version %d: %d max", ver, 0);
      }
    } else
#line 950
    if (ver > 0) {
      {
#line 951
      syserr("Unknown host status version %d: %d max", ver, 0);
      }
    }
#line 953
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 956
    tmp = atoi((char const   *)(& buf___16[1]));
#line 956
    mci->mci_errno = (short )tmp;
    }
#line 957
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 960
    tmp___0 = atoi((char const   *)(& buf___16[1]));
#line 960
    mci->mci_herrno = (short )tmp___0;
    }
#line 961
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 964
    tmp___1 = atoi((char const   *)(& buf___16[1]));
#line 964
    mci->mci_exitstat = (short )tmp___1;
    }
#line 965
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 968
    mci->mci_status = newstr((char const   *)(& buf___16[1]));
    }
#line 969
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 972
    mci->mci_rstatus = newstr((char const   *)(& buf___16[1]));
    }
#line 973
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 976
    mci->mci_lastuse = atol((char const   *)(& buf___16[1]));
    }
#line 977
    goto switch_break;
    case_46: /* CIL Label */ 
#line 980
    if ((int )tTdvect[56] >= 93) {
      {
#line 981
      tmp___2 = sm_debug_file();
#line 981
      mci_dump(tmp___2, mci, 0);
      }
    }
#line 982
    return (0);
    switch_default: /* CIL Label */ 
#line 985
    if ((unsigned long )FileName == (unsigned long )((void *)0)) {
#line 985
      tmp___3 = mci->mci_host;
    } else {
#line 985
      tmp___3 = FileName;
    }
    {
#line 985
    sm_syslog(2, "*~*", "%s: line %d: Unknown host status line \"%s\"", tmp___3, LineNumber,
              buf___16);
#line 989
    LineNumber = saveLineNumber;
    }
#line 990
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 993
  LineNumber = saveLineNumber;
#line 994
  if ((int )tTdvect[56] >= 93) {
    {
#line 995
    sm_dprintf((char *)"incomplete (missing dot for EOF)\n");
    }
  }
#line 996
  if (ver < 0) {
#line 997
    return (-1);
  }
#line 998
  return (0);
}
}
#line 1013 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
void mci_store_persistent(struct mailer_con_info *mci ) 
{ 
  int save_errno ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 1017
  tmp = __errno_location();
#line 1017
  save_errno = *tmp;
  }
#line 1019
  if ((unsigned long )mci == (unsigned long )((void *)0)) {
#line 1021
    if ((int )tTdvect[56] >= 1) {
      {
#line 1022
      sm_dprintf((char *)"mci_store_persistent: NULL mci\n");
      }
    }
#line 1023
    return;
  }
#line 1026
  if ((unsigned long )HostStatDir == (unsigned long )((void *)0)) {
#line 1027
    return;
  } else
#line 1026
  if ((unsigned long )mci->mci_host == (unsigned long )((void *)0)) {
#line 1027
    return;
  }
#line 1029
  if ((int )tTdvect[56] >= 1) {
    {
#line 1030
    sm_dprintf((char *)"mci_store_persistent: Storing information for %s\n", mci->mci_host);
    }
  }
#line 1033
  if ((unsigned long )mci->mci_statfile == (unsigned long )((void *)0)) {
#line 1035
    if ((int )tTdvect[56] >= 1) {
      {
#line 1036
      sm_dprintf((char *)"mci_store_persistent: no statfile\n");
      }
    }
#line 1037
    return;
  }
  {
#line 1040
  sm_io_rewind(mci->mci_statfile, -2);
#line 1042
  tmp___0 = sm_io_getinfo(mci->mci_statfile, 3, (void *)0);
#line 1042
  ftruncate(tmp___0, (off_t )0);
#line 1046
  sm_io_fprintf(mci->mci_statfile, -2, "V0\n");
#line 1047
  sm_io_fprintf(mci->mci_statfile, -2, "E%d\n", (int )mci->mci_errno);
#line 1049
  sm_io_fprintf(mci->mci_statfile, -2, "H%d\n", (int )mci->mci_herrno);
#line 1051
  sm_io_fprintf(mci->mci_statfile, -2, "S%d\n", (int )mci->mci_exitstat);
  }
#line 1053
  if ((unsigned long )mci->mci_status != (unsigned long )((void *)0)) {
    {
#line 1054
    tmp___1 = denlstring(mci->mci_status, 1, 0);
#line 1054
    sm_io_fprintf(mci->mci_statfile, -2, "D%.80s\n", tmp___1);
    }
  }
#line 1057
  if ((unsigned long )mci->mci_rstatus != (unsigned long )((void *)0)) {
    {
#line 1058
    tmp___2 = denlstring(mci->mci_rstatus, 1, 0);
#line 1058
    sm_io_fprintf(mci->mci_statfile, -2, "R%.80s\n", tmp___2);
    }
  }
  {
#line 1061
  sm_io_fprintf(mci->mci_statfile, -2, "U%ld\n", mci->mci_lastuse);
#line 1063
  sm_io_fprintf(mci->mci_statfile, -2, ".\n");
#line 1065
  sm_io_flush(mci->mci_statfile, -2);
#line 1067
  tmp___3 = __errno_location();
#line 1067
  *tmp___3 = save_errno;
  }
#line 1068
  return;
}
}
#line 1095 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
int mci_traverse_persistent(int (*action)(char * , char * ) , char *pathname ) 
{ 
  struct stat statbuf ;
  DIR *d ;
  int ret ;
  int *tmp ;
  char const   *tmp___0 ;
  bool leftone ;
  bool removedone ;
  size_t len___0 ;
  char *newptr ;
  struct dirent *e ;
  char newpath[4096] ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *end ;
  size_t tmp___6 ;
  char *start ;
  char *scan ;
  char host[64] ;
  char *hostptr ;
  char *tmp___7 ;
  char *tmp___8 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 1104
  if ((unsigned long )pathname == (unsigned long )((void *)0)) {
#line 1105
    pathname = HostStatDir;
  }
#line 1106
  if ((unsigned long )pathname == (unsigned long )((void *)0)) {
#line 1107
    return (-1);
  }
#line 1109
  if ((int )tTdvect[56] >= 1) {
    {
#line 1110
    sm_dprintf((char *)"mci_traverse: pathname is %s\n", pathname);
    }
  }
  {
#line 1112
  ret = stat((char const   */* __restrict  */)pathname, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1113
  if (ret < 0) {
#line 1115
    if ((int )tTdvect[56] >= 2) {
      {
#line 1116
      tmp = __errno_location();
#line 1116
      tmp___0 = sm_errstring(*tmp);
#line 1116
      sm_dprintf((char *)"mci_traverse: Failed to stat %s: %s\n", pathname, tmp___0);
      }
    }
#line 1118
    return (ret);
  }
#line 1120
  if ((statbuf.st_mode & 61440U) == 16384U) {
    {
#line 1131
    d = opendir((char const   *)pathname);
    }
#line 1131
    if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 1133
      if ((int )tTdvect[56] >= 2) {
        {
#line 1134
        tmp___1 = __errno_location();
#line 1134
        tmp___2 = sm_errstring(*tmp___1);
#line 1134
        sm_dprintf((char *)"mci_traverse: opendir %s: %s\n", pathname, tmp___2);
        }
      }
#line 1136
      return (-1);
    }
    {
#line 1138
    len___0 = (size_t )((sizeof(newpath) - 255UL) - 3UL);
#line 1139
    tmp___3 = sm_strlcpy(newpath, (char const   *)pathname, (ssize_t )len___0);
    }
#line 1139
    if (tmp___3 >= len___0) {
#line 1141
      if ((int )tTdvect[56] >= 2) {
        {
#line 1142
        sm_dprintf((char *)"mci_traverse: path \"%s\" too long", pathname);
        }
      }
#line 1144
      return (-1);
    }
    {
#line 1146
    tmp___4 = strlen((char const   *)(newpath));
#line 1146
    newptr = newpath + tmp___4;
#line 1147
    tmp___5 = newptr;
#line 1147
    newptr ++;
#line 1147
    *tmp___5 = (char )'/';
    }
    {
#line 1156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1158
      removedone = 0;
#line 1158
      leftone = removedone;
      {
#line 1159
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1159
        e = readdir(d);
        }
#line 1159
        if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 1159
          goto while_break___0;
        }
#line 1161
        if ((int )e->d_name[0] == 46) {
#line 1162
          goto while_continue___0;
        }
        {
#line 1164
        sm_strlcpy(newptr, (char const   *)(e->d_name), (ssize_t )(sizeof(newpath) - (unsigned long )(newptr - newpath)));
        }
#line 1168
        if (StopRequest) {
          {
#line 1169
          stop_sendmail();
          }
        }
        {
#line 1170
        ret = mci_traverse_persistent(action, newpath);
        }
#line 1171
        if (ret < 0) {
#line 1172
          goto while_break___0;
        }
#line 1173
        if (ret == 1) {
#line 1174
          leftone = 1;
        }
#line 1175
        if (! removedone) {
#line 1175
          if (ret == 0) {
#line 1175
            if ((unsigned long )action == (unsigned long )(& mci_purge_persistent)) {
#line 1177
              removedone = 1;
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1179
      if (ret < 0) {
#line 1180
        goto while_break;
      }
#line 1188
      if (removedone) {
        {
#line 1189
        rewinddir(d);
        }
      }
#line 1190
      if ((int )tTdvect[56] >= 40) {
        {
#line 1191
        sm_dprintf((char *)"mci_traverse: path %s: ret %d removed %d left %d\n", pathname,
                   ret, removedone, leftone);
        }
      }
#line 1156
      if (! removedone) {
#line 1156
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1196
    if (! leftone) {
      {
#line 1198
      newptr --;
#line 1198
      *newptr = (char )'\000';
#line 1199
      ret = (*action)(newpath, (char *)((void *)0));
      }
    }
    {
#line 1201
    closedir(d);
    }
  } else
#line 1203
  if ((statbuf.st_mode & 61440U) == 32768U) {
    {
#line 1205
    tmp___6 = strlen((char const   *)pathname);
#line 1205
    end = (pathname + tmp___6) - 1;
#line 1209
    hostptr = host;
    }
    {
#line 1216
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1218
      if ((unsigned long )hostptr != (unsigned long )(host)) {
#line 1219
        tmp___7 = hostptr;
#line 1219
        hostptr ++;
#line 1219
        *tmp___7 = (char )'.';
      }
#line 1220
      start = end;
      {
#line 1221
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1221
        if ((unsigned long )start > (unsigned long )pathname) {
#line 1221
          if (! ((int )*(start - 1) != 47)) {
#line 1221
            goto while_break___2;
          }
        } else {
#line 1221
          goto while_break___2;
        }
#line 1222
        start --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1224
      if ((int )*end == 46) {
#line 1225
        end --;
      }
#line 1227
      scan = start;
      {
#line 1227
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1227
        if (! ((unsigned long )scan <= (unsigned long )end)) {
#line 1227
          goto while_break___3;
        }
#line 1228
        tmp___8 = hostptr;
#line 1228
        hostptr ++;
#line 1228
        *tmp___8 = *scan;
#line 1227
        scan ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1230
      end = start - 2;
#line 1216
      if ((unsigned long )end > (unsigned long )pathname) {
#line 1216
        if (! ((int )*end == 46)) {
#line 1216
          goto while_break___1;
        }
      } else {
#line 1216
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1233
    *hostptr = (char )'\000';
#line 1240
    ret = (*action)(pathname, host);
    }
  }
#line 1243
  return (ret);
}
}
#line 1263 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
static bool initflag  =    0;
#line 1258 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
int mci_print_persistent(char *pathname , char *hostname ) 
{ 
  SM_FILE_T *fp ;
  int width ;
  int tmp ;
  bool locked ;
  struct mailer_con_info mcib ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  time_t tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *exmsg ;
  char *tmp___10 ;
  char buf___16[80] ;
  char const   *tmp___11 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 1265
  if (Verbose) {
#line 1265
    tmp = 78;
  } else {
#line 1265
    tmp = 25;
  }
#line 1265
  width = tmp;
#line 1270
  if ((unsigned long )hostname == (unsigned long )((void *)0)) {
#line 1271
    return (0);
  }
#line 1273
  if (StopRequest) {
    {
#line 1274
    stop_sendmail();
    }
  }
#line 1276
  if (! initflag) {
    {
#line 1278
    initflag = 1;
#line 1279
    sm_io_fprintf(& SmIoF[1], -2, " -------------- Hostname --------------- How long ago ---------Results---------\n");
    }
  }
  {
#line 1283
  fp = safefopen(pathname, 0, FileMode, 25474L);
  }
#line 1286
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1288
    if ((int )tTdvect[56] >= 1) {
      {
#line 1289
      tmp___0 = __errno_location();
#line 1289
      tmp___1 = sm_errstring(*tmp___0);
#line 1289
      sm_dprintf((char *)"mci_print_persistent: cannot open %s: %s\n", pathname, tmp___1);
      }
    }
#line 1291
    return (0);
  }
  {
#line 1294
  FileName = pathname;
#line 1295
  memset((void *)(& mcib), '\000', (size_t )sizeof(mcib));
#line 1296
  tmp___2 = mci_read_persistent(fp, & mcib);
  }
#line 1296
  if (tmp___2 < 0) {
    {
#line 1298
    syserr("%s: could not read status file", pathname);
#line 1299
    sm_io_close(fp, -2);
#line 1300
    FileName = (char *)((void *)0);
    }
#line 1301
    return (0);
  }
  {
#line 1304
  tmp___3 = sm_io_getinfo(fp, 3, (void *)0);
#line 1304
  tmp___4 = lockfile(tmp___3, pathname, (char *)"", 5);
  }
#line 1304
  if (tmp___4) {
#line 1304
    tmp___5 = 0;
  } else {
#line 1304
    tmp___5 = 1;
  }
  {
#line 1304
  locked = tmp___5;
#line 1306
  sm_io_close(fp, -2);
#line 1307
  FileName = (char *)((void *)0);
#line 1309
  tmp___6 = curtime();
#line 1309
  tmp___7 = pintvl(tmp___6 - mcib.mci_lastuse, 1);
  }
#line 1309
  if (locked) {
#line 1309
    tmp___8 = '*';
  } else {
#line 1309
    tmp___8 = ' ';
  }
  {
#line 1309
  sm_io_fprintf(& SmIoF[1], -2, "%c%-39s %12s ", tmp___8, hostname, tmp___7);
  }
#line 1312
  if ((unsigned long )mcib.mci_rstatus != (unsigned long )((void *)0)) {
    {
#line 1313
    sm_io_fprintf(& SmIoF[1], -2, "%.*s\n", width, mcib.mci_rstatus);
    }
  } else
#line 1315
  if ((int )mcib.mci_exitstat == 75) {
#line 1315
    if ((int )mcib.mci_errno != 0) {
      {
#line 1316
      tmp___9 = sm_errstring((int )mcib.mci_errno);
#line 1316
      sm_io_fprintf(& SmIoF[1], -2, "Deferred: %.*s\n", width - 10, tmp___9);
      }
    } else {
#line 1315
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1319
  if ((int )mcib.mci_exitstat != 0) {
    {
#line 1321
    tmp___10 = sm_sysexmsg((int )mcib.mci_exitstat);
#line 1321
    exmsg = tmp___10;
    }
#line 1323
    if ((unsigned long )exmsg == (unsigned long )((void *)0)) {
      {
#line 1327
      sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Unknown mailer error %d",
                  (int )mcib.mci_exitstat);
#line 1330
      sm_io_fprintf(& SmIoF[1], -2, "%.*s\n", width, buf___16);
      }
    } else {
      {
#line 1334
      sm_io_fprintf(& SmIoF[1], -2, "%.*s\n", width, exmsg + 5);
      }
    }
  } else
#line 1337
  if ((int )mcib.mci_errno == 0) {
    {
#line 1338
    sm_io_fprintf(& SmIoF[1], -2, "OK\n");
    }
  } else {
    {
#line 1340
    tmp___11 = sm_errstring((int )mcib.mci_errno);
#line 1340
    sm_io_fprintf(& SmIoF[1], -2, "OK: %.*s\n", width - 4, tmp___11);
    }
  }
#line 1343
  return (0);
}
}
#line 1359 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
int mci_purge_persistent(char *pathname , char *hostname ) 
{ 
  struct stat statbuf ;
  char *end ;
  size_t tmp ;
  int ret ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  time_t tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 1365
  tmp = strlen((char const   *)pathname);
#line 1365
  end = (pathname + tmp) - 1;
  }
#line 1368
  if ((int )tTdvect[56] >= 1) {
    {
#line 1369
    sm_dprintf((char *)"mci_purge_persistent: purging %s\n", pathname);
    }
  }
  {
#line 1371
  ret = stat((char const   */* __restrict  */)pathname, (struct stat */* __restrict  */)(& statbuf));
  }
#line 1372
  if (ret < 0) {
#line 1374
    if ((int )tTdvect[56] >= 2) {
      {
#line 1375
      tmp___0 = __errno_location();
#line 1375
      tmp___1 = sm_errstring(*tmp___0);
#line 1375
      sm_dprintf((char *)"mci_purge_persistent: Failed to stat %s: %s\n", pathname,
                 tmp___1);
      }
    }
#line 1377
    return (ret);
  }
  {
#line 1379
  tmp___2 = curtime();
  }
#line 1379
  if (tmp___2 - statbuf.st_mtim.tv_sec <= MciInfoTimeout) {
#line 1380
    return (1);
  }
#line 1381
  if ((unsigned long )hostname != (unsigned long )((void *)0)) {
    {
#line 1384
    ret = unlink((char const   *)pathname);
    }
#line 1385
    if (ret < 0) {
#line 1387
      if (LogLevel > 8) {
        {
#line 1388
        tmp___3 = __errno_location();
#line 1388
        tmp___4 = sm_errstring(*tmp___3);
#line 1388
        sm_syslog(3, "*~*", "mci_purge_persistent: failed to unlink %s: %s", pathname,
                  tmp___4);
        }
      }
#line 1391
      if ((int )tTdvect[56] >= 2) {
        {
#line 1392
        tmp___5 = __errno_location();
#line 1392
        tmp___6 = sm_errstring(*tmp___5);
#line 1392
        sm_dprintf((char *)"mci_purge_persistent: failed to unlink %s: %s\n", pathname,
                   tmp___6);
        }
      }
#line 1394
      return (ret);
    }
  } else {
#line 1400
    if ((int )*end != 46) {
#line 1401
      return (1);
    }
#line 1403
    if ((int )tTdvect[56] >= 1) {
      {
#line 1404
      sm_dprintf((char *)"mci_purge_persistent: dpurge %s\n", pathname);
      }
    }
    {
#line 1406
    ret = rmdir((char const   *)pathname);
    }
#line 1407
    if (ret < 0) {
#line 1409
      if ((int )tTdvect[56] >= 2) {
        {
#line 1410
        tmp___7 = __errno_location();
#line 1410
        tmp___8 = sm_errstring(*tmp___7);
#line 1410
        sm_dprintf((char *)"mci_purge_persistent: rmdir %s: %s\n", pathname, tmp___8);
        }
      }
#line 1412
      return (ret);
    }
  }
#line 1416
  return (0);
}
}
#line 1437 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/mci.c"
static int mci_generate_persistent_path(char const   *host , char *path , int pathlen ,
                                        bool createflag ) 
{ 
  char *elem ;
  char *p ;
  char *x ;
  char ch ;
  int ret ;
  int len___0 ;
  char t_host[64] ;
  size_t tmp ;
  size_t tmp___0 ;
  bool good ;
  in_addr_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  bool tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 1445
  ret = 0;
#line 1456
  if ((unsigned long )host == (unsigned long )((void *)0)) {
    {
#line 1458
    syserr("mci_generate_persistent_path: null host");
    }
#line 1459
    return (-1);
  }
#line 1461
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 1463
    syserr("mci_generate_persistent_path: null path");
    }
#line 1464
    return (-1);
  }
#line 1467
  if ((int )tTdvect[56] >= 80) {
    {
#line 1468
    sm_dprintf((char *)"mci_generate_persistent_path(%s): ", host);
    }
  }
#line 1470
  if ((int const   )*host == 0) {
#line 1471
    return (-1);
  } else
#line 1470
  if ((int const   )*host == 46) {
#line 1471
    return (-1);
  }
  {
#line 1474
  tmp = strlen(host);
  }
#line 1474
  if ((unsigned long )tmp > sizeof(t_host) - 1UL) {
#line 1475
    return (-1);
  }
#line 1476
  if ((int const   )*(host + 0) == 91) {
    {
#line 1477
    sm_strlcpy(t_host, host + 1, (ssize_t )sizeof(t_host));
    }
  } else {
    {
#line 1479
    sm_strlcpy(t_host, host, (ssize_t )sizeof(t_host));
    }
  }
  {
#line 1486
  tmp___0 = strlen((char const   *)(t_host));
#line 1486
  elem = t_host + tmp___0;
  }
  {
#line 1487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1487
    if ((unsigned long )elem > (unsigned long )(t_host)) {
#line 1487
      if (! ((int )*(elem + -1) == 46)) {
#line 1487
        if ((int const   )*(host + 0) == 91) {
#line 1487
          if (! ((int )*(elem + -1) == 93)) {
#line 1487
            goto while_break;
          }
        } else {
#line 1487
          goto while_break;
        }
      }
    } else {
#line 1487
      goto while_break;
    }
#line 1489
    elem --;
#line 1489
    *elem = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 1492
  if ((int const   )*(host + 0) == 91) {
    {
#line 1494
    good = 0;
#line 1500
    tmp___1 = inet_addr((char const   *)(t_host));
    }
#line 1500
    if (tmp___1 != 4294967295U) {
#line 1501
      good = 1;
    }
#line 1503
    if (! good) {
#line 1504
      return (-1);
    }
  }
  {
#line 1508
  tmp___2 = strlen((char const   *)HostStatDir);
#line 1508
  len___0 = (int )(tmp___2 + 2U);
#line 1509
  p = t_host;
  }
  {
#line 1509
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1509
    if (! ((int )*p != 0)) {
#line 1509
      goto while_break___0;
    }
#line 1511
    if ((int )*p == 46) {
#line 1512
      len___0 ++;
    }
#line 1513
    len___0 ++;
#line 1514
    if ((int )*(p + 0) == 46) {
#line 1514
      if ((int )*(p + 1) == 46) {
#line 1515
        return (-1);
      }
    }
#line 1509
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1517
  if (len___0 > pathlen) {
#line 1518
    return (-1);
  } else
#line 1517
  if (len___0 < 1) {
#line 1518
    return (-1);
  }
  {
#line 1519
  sm_strlcpy(path, (char const   *)HostStatDir, pathlen);
#line 1520
  tmp___3 = strlen((char const   *)path);
#line 1520
  p = path + tmp___3;
  }
  {
#line 1521
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1521
    if (! ((unsigned long )elem > (unsigned long )(t_host))) {
#line 1521
      goto while_break___1;
    }
    {
#line 1523
    tmp___4 = path_is_dir(path, createflag);
    }
#line 1523
    if (! tmp___4) {
#line 1525
      ret = -1;
#line 1526
      goto while_break___1;
    }
#line 1528
    elem --;
    {
#line 1529
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1529
      if ((unsigned long )elem >= (unsigned long )(t_host)) {
#line 1529
        if (! ((int )*elem != 46)) {
#line 1529
          goto while_break___2;
        }
      } else {
#line 1529
        goto while_break___2;
      }
#line 1530
      elem --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1531
    tmp___5 = p;
#line 1531
    p ++;
#line 1531
    *tmp___5 = (char )'/';
#line 1532
    x = elem + 1;
    {
#line 1533
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1533
      tmp___9 = x;
#line 1533
      x ++;
#line 1533
      ch = *tmp___9;
#line 1533
      if ((int )ch != 0) {
#line 1533
        if (! ((int )ch != 46)) {
#line 1533
          goto while_break___3;
        }
      } else {
#line 1533
        goto while_break___3;
      }
#line 1535
      if (((int )ch & -128) == 0) {
        {
#line 1535
        tmp___7 = __ctype_b_loc();
        }
#line 1535
        if ((int const   )*(*tmp___7 + (int )ch) & 256) {
          {
#line 1536
          tmp___6 = tolower((int )ch);
#line 1536
          ch = (char )tmp___6;
          }
        }
      }
#line 1537
      if ((int )ch == 47) {
#line 1538
        ch = (char )':';
      }
#line 1539
      tmp___8 = p;
#line 1539
      p ++;
#line 1539
      *tmp___8 = ch;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1541
    if ((unsigned long )elem >= (unsigned long )(t_host)) {
#line 1542
      tmp___10 = p;
#line 1542
      p ++;
#line 1542
      *tmp___10 = (char )'.';
    }
#line 1543
    *p = (char )'\000';
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1545
  if ((int )tTdvect[56] >= 80) {
#line 1547
    if (ret < 0) {
      {
#line 1548
      sm_dprintf((char *)"FAILURE %d\n", ret);
      }
    } else {
      {
#line 1550
      sm_dprintf((char *)"SUCCESS %s\n", path);
      }
    }
  }
#line 1552
  return (ret);
}
}
#line 423 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 1143 "./sendmail.h"
bool getcanonname(char *host , int hbsize , bool trymx , int *pttl ) ;
#line 1272
bool impl_map_open(struct _map *map___0 , int mode ) ;
#line 1273
void initmaps(void) ;
#line 2362
bool aliaswait(struct _map *map___0 , char *ext , bool isopen ) ;
#line 2364
void readaliases(struct _map *map___0 , SM_FILE_T *af , bool announcestats , bool logstats ) ;
#line 2365
bool rebuildaliases(struct _map *map___0 , bool automatic ) ;
#line 2478
bool dns_getcanonname(char *host , int hbsize , bool trymx , int *statp , int *pttl ) ;
#line 50 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
static bool db_map_open(struct _map *map___0 , int mode , char *mapclassname , DBTYPE dbtype ,
                        void **openinfo ) ;
#line 53
static bool extract_canonname(char *name , char *dot , char *line , char *cbuf , int cbuflen ) ;
#line 54
static void map_close(STAB *s , int bogus ) ;
#line 55
static void map_init(STAB *s , int unused ) ;
#line 68
static bool text_getcanonname(char *name , int hbsize , int *statp ) ;
#line 150 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool map_parseargs(struct _map *map___0 , char *ap ) 
{ 
  register char *p ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 155
  p = ap;
#line 162
  map___0->map_mflags |= 768L;
#line 163
  map___0->map_spacesub = SpaceSub;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 166
      if (((int )*p & -128) == 0) {
        {
#line 166
        tmp = __ctype_b_loc();
        }
#line 166
        if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 166
          goto while_break___0;
        }
      } else {
#line 166
        goto while_break___0;
      }
#line 167
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 168
    if ((int )*p != 45) {
#line 169
      goto while_break;
    }
#line 170
    p ++;
    {
#line 172
    if ((int )*p == 78) {
#line 172
      goto case_78;
    }
#line 177
    if ((int )*p == 79) {
#line 177
      goto case_79;
    }
#line 181
    if ((int )*p == 111) {
#line 181
      goto case_111;
    }
#line 185
    if ((int )*p == 102) {
#line 185
      goto case_102;
    }
#line 189
    if ((int )*p == 109) {
#line 189
      goto case_109;
    }
#line 193
    if ((int )*p == 65) {
#line 193
      goto case_65;
    }
#line 197
    if ((int )*p == 113) {
#line 197
      goto case_113;
    }
#line 201
    if ((int )*p == 97) {
#line 201
      goto case_97;
    }
#line 205
    if ((int )*p == 84) {
#line 205
      goto case_84;
    }
#line 209
    if ((int )*p == 107) {
#line 209
      goto case_107;
    }
#line 215
    if ((int )*p == 118) {
#line 215
      goto case_118;
    }
#line 221
    if ((int )*p == 122) {
#line 221
      goto case_122;
    }
#line 242
    if ((int )*p == 116) {
#line 242
      goto case_116___0;
    }
#line 247
    if ((int )*p == 83) {
#line 247
      goto case_83;
    }
#line 251
    if ((int )*p == 68) {
#line 251
      goto case_68;
    }
#line 255
    goto switch_default___0;
    case_78: /* CIL Label */ 
#line 173
    map___0->map_mflags |= 2L;
#line 174
    map___0->map_mflags &= -257L;
#line 175
    goto switch_break;
    case_79: /* CIL Label */ 
#line 178
    map___0->map_mflags &= -513L;
#line 179
    goto switch_break;
    case_111: /* CIL Label */ 
#line 182
    map___0->map_mflags |= 4L;
#line 183
    goto switch_break;
    case_102: /* CIL Label */ 
#line 186
    map___0->map_mflags |= 8L;
#line 187
    goto switch_break;
    case_109: /* CIL Label */ 
#line 190
    map___0->map_mflags |= 16L;
#line 191
    goto switch_break;
    case_65: /* CIL Label */ 
#line 194
    map___0->map_mflags |= 32768L;
#line 195
    goto switch_break;
    case_113: /* CIL Label */ 
#line 198
    map___0->map_mflags |= 65536L;
#line 199
    goto switch_break;
    case_97: /* CIL Label */ 
#line 202
    p ++;
#line 202
    map___0->map_app = p;
#line 203
    goto switch_break;
    case_84: /* CIL Label */ 
#line 206
    p ++;
#line 206
    map___0->map_tapp = p;
#line 207
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 210
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 210
      p ++;
#line 210
      if (((int )*p & -128) == 0) {
        {
#line 210
        tmp___0 = __ctype_b_loc();
        }
#line 210
        if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 210
          goto while_break___1;
        }
      } else {
#line 210
        goto while_break___1;
      }
#line 211
      goto while_continue___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 212
    map___0->map_keycolnm = p;
#line 213
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 216
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 216
      p ++;
#line 216
      if (((int )*p & -128) == 0) {
        {
#line 216
        tmp___1 = __ctype_b_loc();
        }
#line 216
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 216
          goto while_break___2;
        }
      } else {
#line 216
        goto while_break___2;
      }
#line 217
      goto while_continue___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 218
    map___0->map_valcolnm = p;
#line 219
    goto switch_break;
    case_122: /* CIL Label */ 
#line 222
    p ++;
#line 222
    if ((int )*p != 92) {
#line 223
      map___0->map_coldelim = *p;
    } else {
#line 226
      p ++;
      {
#line 228
      if ((int )*p == 110) {
#line 228
        goto case_110;
      }
#line 232
      if ((int )*p == 116) {
#line 232
        goto case_116;
      }
#line 236
      goto switch_default;
      case_110: /* CIL Label */ 
#line 229
      map___0->map_coldelim = (char )'\n';
#line 230
      goto switch_break___0;
      case_116: /* CIL Label */ 
#line 233
      map___0->map_coldelim = (char )'\t';
#line 234
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 237
      map___0->map_coldelim = (char )'\\';
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 240
    goto switch_break;
    case_116___0: /* CIL Label */ 
#line 243
    map___0->map_mflags |= 131072L;
#line 244
    goto switch_break;
    case_83: /* CIL Label */ 
#line 248
    p ++;
#line 248
    map___0->map_spacesub = *p;
#line 249
    goto switch_break;
    case_68: /* CIL Label */ 
#line 252
    map___0->map_mflags |= 524288L;
#line 253
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 256
    syserr("Illegal option %c map %s", (int )*p, map___0->map_mname);
    }
#line 257
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 259
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 259
      if ((int )*p != 0) {
#line 259
        if (((int )*p & -128) == 0) {
          {
#line 259
          tmp___2 = __ctype_b_loc();
          }
#line 259
          if ((int const   )*(*tmp___2 + (int )*p) & 8192) {
#line 259
            goto while_break___3;
          }
        }
      } else {
#line 259
        goto while_break___3;
      }
#line 260
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 261
    if ((int )*p != 0) {
#line 262
      tmp___3 = p;
#line 262
      p ++;
#line 262
      *tmp___3 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  if ((unsigned long )map___0->map_app != (unsigned long )((void *)0)) {
    {
#line 265
    map___0->map_app = newstr((char const   *)map___0->map_app);
    }
  }
#line 266
  if ((unsigned long )map___0->map_tapp != (unsigned long )((void *)0)) {
    {
#line 267
    map___0->map_tapp = newstr((char const   *)map___0->map_tapp);
    }
  }
#line 268
  if ((unsigned long )map___0->map_keycolnm != (unsigned long )((void *)0)) {
    {
#line 269
    map___0->map_keycolnm = newstr((char const   *)map___0->map_keycolnm);
    }
  }
#line 270
  if ((unsigned long )map___0->map_valcolnm != (unsigned long )((void *)0)) {
    {
#line 271
    map___0->map_valcolnm = newstr((char const   *)map___0->map_valcolnm);
    }
  }
#line 273
  if ((int )*p != 0) {
#line 275
    map___0->map_file = p;
    {
#line 276
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 276
      if ((int )*p != 0) {
#line 276
        if (((int )*p & -128) == 0) {
          {
#line 276
          tmp___4 = __ctype_b_loc();
          }
#line 276
          if ((int const   )*(*tmp___4 + (int )*p) & 8192) {
#line 276
            goto while_break___4;
          }
        }
      } else {
#line 276
        goto while_break___4;
      }
#line 277
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 278
    if ((int )*p != 0) {
#line 279
      tmp___5 = p;
#line 279
      p ++;
#line 279
      *tmp___5 = (char )'\000';
    }
    {
#line 280
    map___0->map_file = newstr((char const   *)map___0->map_file);
    }
  }
  {
#line 283
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 283
    if ((int )*p != 0) {
#line 283
      if (((int )*p & -128) == 0) {
        {
#line 283
        tmp___6 = __ctype_b_loc();
        }
#line 283
        if (! ((int const   )*(*tmp___6 + (int )*p) & 8192)) {
#line 283
          goto while_break___5;
        }
      } else {
#line 283
        goto while_break___5;
      }
    } else {
#line 283
      goto while_break___5;
    }
#line 284
    p ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 285
  if ((int )*p != 0) {
    {
#line 286
    map___0->map_rebuild = newstr((char const   *)p);
    }
  }
#line 288
  if ((unsigned long )map___0->map_file == (unsigned long )((void *)0)) {
#line 288
    if (! (((int )(map___0->map_class)->map_cflags & 8) != 0)) {
      {
#line 291
      syserr("No file name for %s map %s", (map___0->map_class)->map_cname, map___0->map_mname);
      }
#line 293
      return (0);
    }
  }
#line 295
  return (1);
}
}
#line 327 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
static size_t buflen___0  =    (size_t )0;
#line 328 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
static char *buf___8  =    (char *)((void *)0);
#line 314 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *map_rewrite(struct _map *map___0 , char const   *s , size_t slen , char **av___0 ) 
{ 
  register char *bp___3 ;
  register char c ;
  char **avp ;
  register char *ap ;
  size_t l ;
  size_t len___0 ;
  char const   *sp ;
  size_t tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char const   *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  char const   *tmp___17 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 330
  if ((int )tTdvect[39] >= 1) {
    {
#line 332
    sm_dprintf((char *)"map_rewrite(%.*s), av =", (int )slen, s);
    }
#line 333
    if ((unsigned long )av___0 == (unsigned long )((void *)0)) {
      {
#line 334
      sm_dprintf((char *)" (nullv)");
      }
    } else {
#line 337
      avp = av___0;
      {
#line 337
      while (1) {
        while_continue: /* CIL Label */ ;
#line 337
        if (! ((unsigned long )*avp != (unsigned long )((void *)0))) {
#line 337
          goto while_break;
        }
        {
#line 338
        sm_dprintf((char *)"\n\t%s", *avp);
#line 337
        avp ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 340
    sm_dprintf((char *)"\n");
    }
  }
#line 344
  len___0 = slen;
#line 344
  l = len___0;
#line 345
  if ((unsigned long )av___0 != (unsigned long )((void *)0)) {
#line 347
    sp = s;
    {
#line 349
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 349
      tmp___3 = l;
#line 349
      l --;
#line 349
      if (tmp___3 > 0U) {
#line 349
        tmp___4 = sp;
#line 349
        sp ++;
#line 349
        c = (char )*tmp___4;
#line 349
        if (! ((int )c != 0)) {
#line 349
          goto while_break___0;
        }
      } else {
#line 349
        goto while_break___0;
      }
#line 351
      if ((int )c != 37) {
#line 352
        goto while_continue___0;
      }
#line 353
      tmp = l;
#line 353
      l --;
#line 353
      if (tmp <= 0U) {
#line 354
        goto while_break___0;
      }
#line 355
      tmp___0 = sp;
#line 355
      sp ++;
#line 355
      c = (char )*tmp___0;
#line 356
      if (((int )c & -128) == 0) {
        {
#line 356
        tmp___1 = __ctype_b_loc();
        }
#line 356
        if (! ((int const   )*(*tmp___1 + (int )c) & 2048)) {
#line 357
          goto while_continue___0;
        }
      } else {
#line 357
        goto while_continue___0;
      }
#line 358
      avp = av___0;
      {
#line 358
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 358
        c = (char )((int )c - 1);
#line 358
        if ((int )c >= 48) {
#line 358
          if (! ((unsigned long )*avp != (unsigned long )((void *)0))) {
#line 358
            goto while_break___1;
          }
        } else {
#line 358
          goto while_break___1;
        }
#line 359
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 358
        avp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 360
      if ((unsigned long )*avp == (unsigned long )((void *)0)) {
#line 361
        goto while_continue___0;
      }
      {
#line 362
      tmp___2 = strlen((char const   *)*avp);
#line 362
      len___0 += tmp___2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 365
  if ((unsigned long )map___0->map_app != (unsigned long )((void *)0)) {
    {
#line 366
    tmp___5 = strlen((char const   *)map___0->map_app);
#line 366
    len___0 += tmp___5;
    }
  }
#line 367
  len___0 ++;
#line 367
  if (buflen___0 < len___0) {
#line 370
    buflen___0 = len___0;
#line 371
    if ((unsigned long )buf___8 != (unsigned long )((void *)0)) {
      {
#line 372
      sm_free_tagged((void *)buf___8, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c",
                     372);
      }
    }
    {
#line 373
    tmp___6 = sm_malloc_tagged_x(buflen___0, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c",
                                 373, 0);
#line 373
    buf___8 = (char *)tmp___6;
    }
  }
#line 376
  bp___3 = buf___8;
#line 377
  if ((unsigned long )av___0 == (unsigned long )((void *)0)) {
    {
#line 379
    memmove((void *)bp___3, (void const   *)s, slen);
#line 380
    bp___3 += slen;
#line 383
    len___0 -= slen;
    }
  } else {
    {
#line 387
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 387
      tmp___16 = slen;
#line 387
      slen --;
#line 387
      if (tmp___16 > 0U) {
#line 387
        tmp___17 = s;
#line 387
        s ++;
#line 387
        c = (char )*tmp___17;
#line 387
        if (! ((int )c != 0)) {
#line 387
          goto while_break___2;
        }
      } else {
#line 387
        goto while_break___2;
      }
#line 389
      if ((int )c != 37) {
        pushc: 
#line 392
        tmp___7 = len___0;
#line 392
        len___0 --;
#line 392
        if (tmp___7 <= 1U) {
#line 393
          goto while_break___2;
        }
#line 394
        tmp___8 = bp___3;
#line 394
        bp___3 ++;
#line 394
        *tmp___8 = c;
#line 395
        goto while_continue___2;
      }
#line 397
      tmp___9 = slen;
#line 397
      slen --;
#line 397
      if (tmp___9 <= 0U) {
#line 398
        c = (char )'%';
      } else {
#line 397
        tmp___10 = s;
#line 397
        s ++;
#line 397
        c = (char )*tmp___10;
#line 397
        if ((int )c == 0) {
#line 398
          c = (char )'%';
        }
      }
#line 399
      if ((int )c == 37) {
#line 400
        goto pushc;
      }
#line 401
      if (((int )c & -128) == 0) {
        {
#line 401
        tmp___13 = __ctype_b_loc();
        }
#line 401
        if (! ((int const   )*(*tmp___13 + (int )c) & 2048)) {
#line 401
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 403
        tmp___11 = len___0;
#line 403
        len___0 --;
#line 403
        if (tmp___11 <= 1U) {
#line 404
          goto while_break___2;
        }
#line 405
        tmp___12 = bp___3;
#line 405
        bp___3 ++;
#line 405
        *tmp___12 = (char )'%';
#line 406
        goto pushc;
      }
#line 408
      avp = av___0;
      {
#line 408
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 408
        c = (char )((int )c - 1);
#line 408
        if ((int )c >= 48) {
#line 408
          if (! ((unsigned long )*avp != (unsigned long )((void *)0))) {
#line 408
            goto while_break___3;
          }
        } else {
#line 408
          goto while_break___3;
        }
#line 409
        goto __Cont___0;
        __Cont___0: /* CIL Label */ 
#line 408
        avp ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 410
      if ((unsigned long )*avp == (unsigned long )((void *)0)) {
#line 411
        goto while_continue___2;
      }
#line 414
      ap = *avp;
      {
#line 414
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 414
        tmp___15 = ap;
#line 414
        ap ++;
#line 414
        c = *tmp___15;
#line 414
        if ((int )c != 0) {
#line 414
          if (! (len___0 > 0U)) {
#line 414
            goto while_break___4;
          }
        } else {
#line 414
          goto while_break___4;
        }
#line 415
        tmp___14 = bp___3;
#line 415
        bp___3 ++;
#line 415
        *tmp___14 = c;
#line 414
        len___0 --;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 418
  if ((unsigned long )map___0->map_app != (unsigned long )((void *)0)) {
#line 418
    if (len___0 > 0U) {
      {
#line 419
      sm_strlcpy(bp___3, (char const   *)map___0->map_app, (ssize_t )len___0);
      }
    } else {
#line 421
      *bp___3 = (char )'\000';
    }
  } else {
#line 421
    *bp___3 = (char )'\000';
  }
#line 422
  if ((int )tTdvect[39] >= 1) {
    {
#line 423
    sm_dprintf((char *)"map_rewrite => %s\n", buf___8);
    }
  }
#line 424
  return (buf___8);
}
}
#line 436 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
void initmaps(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
#line 440
  checkfd012((char *)"entering initmaps");
#line 442
  stabapply(& map_init, 0);
#line 444
  checkfd012((char *)"exiting initmaps");
  }
#line 446
  return;
}
}
#line 462 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
static void map_init(STAB *s , int unused ) 
{ 
  register struct _map *map___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 470
  if ((int )s->s_symtype != 6) {
#line 471
    return;
  }
#line 473
  map___0 = & s->s_value.sv_map;
#line 474
  if (! ((map___0->map_mflags & 1L) != 0L)) {
#line 475
    return;
  }
#line 477
  if ((int )tTdvect[38] >= 2) {
#line 478
    if ((unsigned long )map___0->map_file == (unsigned long )((void *)0)) {
#line 478
      tmp = "NULL";
    } else {
#line 478
      tmp = (char const   *)map___0->map_file;
    }
#line 478
    if ((unsigned long )map___0->map_mname == (unsigned long )((void *)0)) {
#line 478
      tmp___0 = "NULL";
    } else {
#line 478
      tmp___0 = (char const   *)map___0->map_mname;
    }
#line 478
    if ((unsigned long )(map___0->map_class)->map_cname == (unsigned long )((void *)0)) {
#line 478
      tmp___1 = "NULL";
    } else {
#line 478
      tmp___1 = (char const   *)(map___0->map_class)->map_cname;
    }
    {
#line 478
    sm_dprintf((char *)"map_init(%s:%s, %s)\n", tmp___1, tmp___0, tmp);
    }
  }
#line 484
  if (! ((map___0->map_mflags & 128L) != 0L)) {
#line 484
    goto _L;
  } else
#line 484
  if (! (((int )(map___0->map_class)->map_cflags & 4) != 0)) {
    _L: /* CIL Label */ 
#line 487
    if ((int )tTdvect[38] >= 3) {
      {
#line 488
      sm_dprintf((char *)"\tnot rebuildable\n");
      }
    }
#line 489
    return;
  }
#line 493
  if ((map___0->map_mflags & 32L) != 0L) {
    {
#line 495
    map___0->map_mflags |= 16777216L;
#line 496
    (*((map___0->map_class)->map_close))(map___0);
#line 497
    map___0->map_mflags &= -16777313L;
    }
  }
  {
#line 500
  rebuildaliases(map___0, 0);
  }
#line 501
  return;
}
}
#line 566
struct _mapclass BogusMapClass ;
#line 513 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool openmap(struct _map *map___0 ) 
{ 
  bool restore ;
  bool savehold ;
  bool savequick ;
  int saveerrors ;
  int *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___9 ;
  int *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  bool tmp___14 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 517
  restore = 0;
#line 518
  savehold = HoldErrs;
#line 519
  savequick = QuickAbort;
#line 520
  saveerrors = Errors;
#line 522
  if (! ((map___0->map_mflags & 1L) != 0L)) {
#line 523
    return (0);
  }
#line 526
  if ((map___0->map_mflags & 32L) != 0L) {
#line 527
    return (1);
  }
#line 530
  if (OnlyOneError) {
#line 530
    goto _L;
  } else
#line 530
  if (QuickAbort) {
    _L: /* CIL Label */ 
#line 530
    if ((int )OpMode == 115) {
#line 533
      restore = 1;
#line 534
      HoldErrs = 1;
#line 535
      QuickAbort = 0;
    } else
#line 530
    if ((int )OpMode == 100) {
#line 533
      restore = 1;
#line 534
      HoldErrs = 1;
#line 535
      QuickAbort = 0;
    }
  }
  {
#line 538
  tmp = __errno_location();
#line 538
  *tmp = 0;
#line 539
  tmp___14 = (*((map___0->map_class)->map_open))(map___0, 0);
  }
#line 539
  if (tmp___14) {
#line 541
    if ((int )tTdvect[38] >= 4) {
#line 542
      if ((unsigned long )map___0->map_file == (unsigned long )((void *)0)) {
#line 542
        tmp___0 = "NULL";
      } else {
#line 542
        tmp___0 = (char const   *)map___0->map_file;
      }
#line 542
      if ((unsigned long )map___0->map_mname == (unsigned long )((void *)0)) {
#line 542
        tmp___1 = "NULL";
      } else {
#line 542
        tmp___1 = (char const   *)map___0->map_mname;
      }
#line 542
      if ((unsigned long )(map___0->map_class)->map_cname == (unsigned long )((void *)0)) {
#line 542
        tmp___2 = "NULL";
      } else {
#line 542
        tmp___2 = (char const   *)(map___0->map_class)->map_cname;
      }
      {
#line 542
      sm_dprintf((char *)"openmap()\t%s:%s %s: valid\n", tmp___2, tmp___1, tmp___0);
      }
    }
#line 549
    map___0->map_mflags |= 32L;
#line 550
    map___0->map_pid = CurrentPid;
  } else {
#line 554
    if ((int )tTdvect[38] >= 4) {
      {
#line 555
      tmp___7 = __errno_location();
      }
#line 555
      if (*tmp___7 == 0) {
#line 555
        tmp___6 = "";
      } else {
        {
#line 555
        tmp___4 = __errno_location();
#line 555
        tmp___5 = sm_errstring(*tmp___4);
#line 555
        tmp___6 = tmp___5;
        }
      }
      {
#line 555
      tmp___10 = __errno_location();
      }
#line 555
      if (*tmp___10 == 0) {
#line 555
        tmp___9 = "";
      } else {
#line 555
        tmp___9 = ": ";
      }
#line 555
      if ((unsigned long )map___0->map_file == (unsigned long )((void *)0)) {
#line 555
        tmp___11 = "NULL";
      } else {
#line 555
        tmp___11 = (char const   *)map___0->map_file;
      }
#line 555
      if ((unsigned long )map___0->map_mname == (unsigned long )((void *)0)) {
#line 555
        tmp___12 = "NULL";
      } else {
#line 555
        tmp___12 = (char const   *)map___0->map_mname;
      }
#line 555
      if ((unsigned long )(map___0->map_class)->map_cname == (unsigned long )((void *)0)) {
#line 555
        tmp___13 = "NULL";
      } else {
#line 555
        tmp___13 = (char const   *)(map___0->map_class)->map_cname;
      }
      {
#line 555
      sm_dprintf((char *)"openmap()\t%s:%s %s: invalid%s%s\n", tmp___13, tmp___12,
                 tmp___11, tmp___9, tmp___6);
      }
    }
#line 564
    if (! ((map___0->map_mflags & 4L) != 0L)) {
#line 568
      map___0->map_orgclass = map___0->map_class;
#line 569
      map___0->map_class = & BogusMapClass;
#line 570
      map___0->map_mflags |= 8388640L;
#line 571
      map___0->map_pid = CurrentPid;
    } else {
#line 576
      map___0->map_mflags &= -2L;
    }
  }
#line 580
  if (restore) {
#line 582
    Errors = saveerrors;
#line 583
    HoldErrs = savehold;
#line 584
    QuickAbort = savequick;
  }
#line 587
  return ((map___0->map_mflags & 32L) != 0L);
}
}
#line 599 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
void closemaps(bool bogus ) 
{ 


  {
  {
#line 603
  stabapply(& map_close, bogus);
  }
#line 604
  return;
}
}
#line 617 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
static void map_close(STAB *s , int bogus ) 
{ 
  struct _map *map___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 625
  if ((int )s->s_symtype != 6) {
#line 626
    return;
  }
#line 628
  map___0 = & s->s_value.sv_map;
#line 639
  if (! ((map___0->map_mflags & 1L) != 0L)) {
#line 645
    return;
  } else
#line 639
  if (! ((map___0->map_mflags & 32L) != 0L)) {
#line 645
    return;
  } else
#line 639
  if ((map___0->map_mflags & 16777216L) != 0L) {
#line 645
    return;
  } else
#line 639
  if (map___0->map_pid != CurrentPid) {
#line 645
    return;
  } else
#line 639
  if (bogus) {
#line 639
    if ((unsigned long )map___0->map_class != (unsigned long )(& BogusMapClass)) {
#line 639
      if (! (((int )(map___0->map_class)->map_cflags & 16) != 0)) {
#line 645
        return;
      }
    }
  }
#line 647
  if ((unsigned long )map___0->map_class == (unsigned long )(& BogusMapClass)) {
#line 647
    if ((unsigned long )map___0->map_orgclass != (unsigned long )((void *)0)) {
#line 647
      if ((unsigned long )map___0->map_orgclass != (unsigned long )(& BogusMapClass)) {
#line 649
        map___0->map_class = map___0->map_orgclass;
      }
    }
  }
#line 650
  if ((int )tTdvect[38] >= 5) {
#line 651
    if ((unsigned long )map___0->map_file == (unsigned long )((void *)0)) {
#line 651
      tmp = "NULL";
    } else {
#line 651
      tmp = (char const   *)map___0->map_file;
    }
#line 651
    if ((unsigned long )map___0->map_mname == (unsigned long )((void *)0)) {
#line 651
      tmp___0 = "NULL";
    } else {
#line 651
      tmp___0 = (char const   *)map___0->map_mname;
    }
    {
#line 651
    sm_dprintf((char *)"closemaps: closing %s (%s)\n", tmp___0, tmp);
    }
  }
#line 655
  if (! ((map___0->map_mflags & 8388608L) != 0L)) {
    {
#line 657
    map___0->map_mflags |= 16777216L;
#line 658
    (*((map___0->map_class)->map_close))(map___0);
    }
  }
#line 660
  map___0->map_mflags &= -25165921L;
#line 661
  return;
}
}
#line 676 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool getcanonname(char *host , int hbsize , bool trymx , int *pttl ) 
{ 
  int nmaps ;
  int mapno ;
  bool found ;
  bool got_tempfail ;
  int status ;
  char *maptype[12] ;
  short mapreturn[5] ;
  int i ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *d ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 685
  found = 0;
#line 686
  got_tempfail = 0;
#line 691
  nmaps = switch_map_find((char *)"hosts", maptype, mapreturn);
  }
#line 692
  if ((unsigned long )pttl != (unsigned long )((int *)0)) {
#line 693
    *pttl = 3600;
  }
#line 694
  mapno = 0;
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 694
    if (! (mapno < nmaps)) {
#line 694
      goto while_break;
    }
#line 698
    if ((int )tTdvect[38] >= 20) {
      {
#line 699
      sm_dprintf((char *)"getcanonname(%s), trying %s\n", host, maptype[mapno]);
      }
    }
    {
#line 701
    tmp___0 = strcmp("files", (char const   *)maptype[mapno]);
    }
#line 701
    if (tmp___0 == 0) {
      {
#line 703
      found = text_getcanonname(host, hbsize, & status);
      }
    } else {
      {
#line 718
      tmp = strcmp("dns", (char const   *)maptype[mapno]);
      }
#line 718
      if (tmp == 0) {
        {
#line 720
        found = dns_getcanonname(host, hbsize, trymx, & status, pttl);
        }
      } else {
#line 731
        found = 0;
#line 732
        status = 69;
      }
    }
#line 743
    if (found) {
      {
#line 743
      tmp___1 = macvalue('m', CurEnv);
      }
#line 743
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 745
        goto while_break;
      } else {
        {
#line 743
        tmp___2 = strchr((char const   *)host, '.');
        }
#line 743
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 745
          goto while_break;
        }
      }
    }
#line 748
    if (status == 75) {
#line 750
      i = 2;
#line 751
      got_tempfail = 1;
    } else
#line 753
    if (status == 68) {
#line 754
      i = 0;
    } else {
#line 756
      i = 1;
    }
#line 757
    if (((int )mapreturn[i] & (1 << mapno)) != 0) {
#line 758
      goto while_break;
    }
#line 694
    mapno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 761
  if (found) {
#line 765
    if ((int )tTdvect[38] >= 20) {
      {
#line 766
      sm_dprintf((char *)"getcanonname(%s), found\n", host);
      }
    }
    {
#line 774
    d = strchr((char const   *)host, '.');
    }
#line 774
    if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 774
      goto _L;
    } else
#line 774
    if ((int )*(d + 1) == 0) {
      _L: /* CIL Label */ 
      {
#line 776
      d = macvalue('m', CurEnv);
      }
#line 777
      if ((unsigned long )d != (unsigned long )((void *)0)) {
        {
#line 777
        tmp___4 = strlen((char const   *)host);
#line 777
        tmp___5 = strlen((char const   *)d);
        }
#line 777
        if (hbsize > (int )((tmp___4 + tmp___5) + 1U)) {
          {
#line 780
          tmp___3 = strlen((char const   *)host);
          }
#line 780
          if ((int )*(host + (tmp___3 - 1U)) != 46) {
            {
#line 781
            sm_strlcat2(host, ".", (char const   *)d, hbsize);
            }
          } else {
            {
#line 784
            sm_strlcat(host, (char const   *)d, hbsize);
            }
          }
        } else {
#line 787
          return (0);
        }
      } else {
#line 787
        return (0);
      }
    }
#line 789
    return (1);
  }
#line 792
  if ((int )tTdvect[38] >= 20) {
    {
#line 793
    sm_dprintf((char *)"getcanonname(%s), failed, status=%d\n", host, status);
    }
  }
#line 796
  if (got_tempfail) {
    {
#line 797
    tmp___6 = __h_errno_location();
#line 797
    *tmp___6 = 2;
    }
  } else {
    {
#line 799
    tmp___7 = __h_errno_location();
#line 799
    *tmp___7 = 1;
    }
  }
#line 801
  return (0);
}
}
#line 818 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
static bool extract_canonname(char *name , char *dot , char *line , char *cbuf , int cbuflen ) 
{ 
  int i ;
  char *p ;
  bool found ;
  char nbuf[257] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *domain ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp20 ;

  {
#line 828
  found = 0;
#line 830
  *(cbuf + 0) = (char )'\000';
#line 831
  if ((int )*(line + 0) == 35) {
#line 832
    return (0);
  }
#line 834
  i = 1;
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 838
    p = get_column(line, i, '\000', nbuf, (int )sizeof(nbuf));
    }
#line 839
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 840
      goto while_break;
    }
#line 841
    if ((int )*p == 0) {
#line 842
      goto __Cont;
    }
#line 843
    if ((int )*(cbuf + 0) == 0) {
      {
#line 846
      sm_strlcpy(cbuf, (char const   *)p, cbuflen);
      }
    } else {
      {
#line 843
      tmp = strchr((char const   *)cbuf, '.');
      }
#line 843
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 843
        tmp___0 = strchr((char const   *)p, '.');
        }
#line 843
        if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
          {
#line 846
          sm_strlcpy(cbuf, (char const   *)p, cbuflen);
          }
        }
      }
    }
    {
#line 848
    tmp___2 = sm_strcasecmp((char const   *)name, (char const   *)p);
    }
#line 848
    if (tmp___2 == 0) {
#line 849
      found = 1;
    } else
#line 850
    if ((unsigned long )dot != (unsigned long )((void *)0)) {
      {
#line 853
      *dot = (char )'.';
#line 854
      tmp___1 = sm_strcasecmp((char const   *)name, (char const   *)p);
      }
#line 854
      if (tmp___1 == 0) {
#line 855
        found = 1;
      }
#line 856
      *dot = (char )'\000';
    }
    __Cont: /* CIL Label */ 
#line 834
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 859
  if (found) {
    {
#line 859
    tmp___7 = strchr((char const   *)cbuf, '.');
    }
#line 859
    if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
      {
#line 862
      tmp___3 = macvalue('m', CurEnv);
#line 862
      domain = tmp___3;
      }
#line 864
      if ((unsigned long )domain != (unsigned long )((void *)0)) {
        {
#line 864
        tmp___5 = strlen((char const   *)domain);
#line 864
        tmp___6 = strlen((char const   *)cbuf);
#line 864
        i = (int )tmp___6;
        }
#line 864
        if ((tmp___5 + (size_t )i) + 1U < (size_t )cbuflen) {
          {
#line 867
          p = cbuf + i;
#line 868
          tmp___4 = p;
#line 868
          p ++;
#line 868
          *tmp___4 = (char )'.';
#line 869
          sm_strlcpy(p, (char const   *)domain, (cbuflen - i) - 1);
          }
        }
      }
    }
  }
#line 872
  return (found);
}
}
#line 891 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool dns_map_open(struct _map *map___0 , int mode ) 
{ 
  int *tmp ;
  char *__cil_tmp4 ;

  {
#line 896
  if ((int )tTdvect[38] >= 2) {
    {
#line 897
    sm_dprintf((char *)"dns_map_open(%s, %d)\n", map___0->map_mname, mode);
    }
  }
#line 899
  mode &= 3;
#line 900
  if (mode != 0) {
    {
#line 903
    tmp = __errno_location();
#line 903
    *tmp = 38;
    }
#line 904
    return (0);
  }
#line 906
  return (1);
}
}
#line 938 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool dns_map_parseargs(struct _map *map___0 , char *args ) 
{ 
  register char *p ;
  struct dns_map *map_p ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char *h ;
  unsigned short const   **tmp___1 ;
  char *h___0 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 943
  p = args;
#line 946
  tmp = xalloc_tagged((int )sizeof(*map_p), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c",
                      946);
#line 946
  map_p = (struct dns_map *)tmp;
#line 947
  map_p->dns_m_type = -1;
#line 948
  map___0->map_mflags |= 768L;
  }
  {
#line 950
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 952
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 952
      if (((int )*p & -128) == 0) {
        {
#line 952
        tmp___0 = __ctype_b_loc();
        }
#line 952
        if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 952
          goto while_break___0;
        }
      } else {
#line 952
        goto while_break___0;
      }
#line 953
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 954
    if ((int )*p != 45) {
#line 955
      goto while_break;
    }
#line 956
    p ++;
    {
#line 958
    if ((int )*p == 78) {
#line 958
      goto case_78;
    }
#line 963
    if ((int )*p == 79) {
#line 963
      goto case_79;
    }
#line 967
    if ((int )*p == 111) {
#line 967
      goto case_111;
    }
#line 971
    if ((int )*p == 102) {
#line 971
      goto case_102;
    }
#line 975
    if ((int )*p == 109) {
#line 975
      goto case_109;
    }
#line 979
    if ((int )*p == 65) {
#line 979
      goto case_65;
    }
#line 983
    if ((int )*p == 113) {
#line 983
      goto case_113;
    }
#line 987
    if ((int )*p == 116) {
#line 987
      goto case_116;
    }
#line 991
    if ((int )*p == 97) {
#line 991
      goto case_97;
    }
#line 995
    if ((int )*p == 84) {
#line 995
      goto case_84;
    }
#line 999
    if ((int )*p == 100) {
#line 999
      goto case_100;
    }
#line 1013
    if ((int )*p == 114) {
#line 1013
      goto case_114;
    }
#line 1051
    if ((int )*p == 82) {
#line 1051
      goto case_82;
    }
#line 956
    goto switch_break;
    case_78: /* CIL Label */ 
#line 959
    map___0->map_mflags |= 2L;
#line 960
    map___0->map_mflags &= -257L;
#line 961
    goto switch_break;
    case_79: /* CIL Label */ 
#line 964
    map___0->map_mflags &= -513L;
#line 965
    goto switch_break;
    case_111: /* CIL Label */ 
#line 968
    map___0->map_mflags |= 4L;
#line 969
    goto switch_break;
    case_102: /* CIL Label */ 
#line 972
    map___0->map_mflags |= 8L;
#line 973
    goto switch_break;
    case_109: /* CIL Label */ 
#line 976
    map___0->map_mflags |= 16L;
#line 977
    goto switch_break;
    case_65: /* CIL Label */ 
#line 980
    map___0->map_mflags |= 32768L;
#line 981
    goto switch_break;
    case_113: /* CIL Label */ 
#line 984
    map___0->map_mflags |= 65536L;
#line 985
    goto switch_break;
    case_116: /* CIL Label */ 
#line 988
    map___0->map_mflags |= 131072L;
#line 989
    goto switch_break;
    case_97: /* CIL Label */ 
#line 992
    p ++;
#line 992
    map___0->map_app = p;
#line 993
    goto switch_break;
    case_84: /* CIL Label */ 
#line 996
    p ++;
#line 996
    map___0->map_tapp = p;
#line 997
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 1003
    p ++;
#line 1004
    h = strchr((char const   *)p, ' ');
    }
#line 1005
    if ((unsigned long )h != (unsigned long )((void *)0)) {
#line 1006
      *h = (char )'\000';
    }
    {
#line 1007
    map___0->map_timeout = convtime(p, 's');
    }
#line 1008
    if ((unsigned long )h != (unsigned long )((void *)0)) {
#line 1009
      *h = (char )' ';
    }
#line 1011
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 1014
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1014
      p ++;
#line 1014
      if (((int )*p & -128) == 0) {
        {
#line 1014
        tmp___1 = __ctype_b_loc();
        }
#line 1014
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 1014
          goto while_break___1;
        }
      } else {
#line 1014
        goto while_break___1;
      }
#line 1015
      goto while_continue___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1016
    map___0->map_retry = atoi((char const   *)p);
    }
#line 1017
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 1055
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1055
      p ++;
#line 1055
      if (((int )*p & -128) == 0) {
        {
#line 1055
        tmp___2 = __ctype_b_loc();
        }
#line 1055
        if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 1055
          goto while_break___2;
        }
      } else {
#line 1055
        goto while_break___2;
      }
#line 1056
      goto while_continue___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1057
    h___0 = strchr((char const   *)p, ' ');
    }
#line 1058
    if ((unsigned long )h___0 != (unsigned long )((void *)0)) {
#line 1059
      *h___0 = (char )'\000';
    }
    {
#line 1060
    map_p->dns_m_type = dns_string_to_type((char const   *)p);
    }
#line 1061
    if ((unsigned long )h___0 != (unsigned long )((void *)0)) {
#line 1062
      *h___0 = (char )' ';
    }
#line 1063
    if (map_p->dns_m_type < 0) {
      {
#line 1064
      syserr("dns map %s: wrong type %s", map___0->map_mname, p);
      }
    }
#line 1067
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1093
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1093
      if ((int )*p != 0) {
#line 1093
        if (((int )*p & -128) == 0) {
          {
#line 1093
          tmp___3 = __ctype_b_loc();
          }
#line 1093
          if ((int const   )*(*tmp___3 + (int )*p) & 8192) {
#line 1093
            goto while_break___3;
          }
        }
      } else {
#line 1093
        goto while_break___3;
      }
#line 1094
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1095
    if ((int )*p != 0) {
#line 1096
      tmp___4 = p;
#line 1096
      p ++;
#line 1096
      *tmp___4 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1098
  if (map_p->dns_m_type < 0) {
    {
#line 1099
    syserr("dns map %s: missing -R type", map___0->map_mname);
    }
  }
#line 1100
  if ((unsigned long )map___0->map_app != (unsigned long )((void *)0)) {
    {
#line 1101
    map___0->map_app = newstr((char const   *)map___0->map_app);
    }
  }
#line 1102
  if ((unsigned long )map___0->map_tapp != (unsigned long )((void *)0)) {
    {
#line 1103
    map___0->map_tapp = newstr((char const   *)map___0->map_tapp);
    }
  }
#line 1111
  map___0->map_db1 = (void *)map_p;
#line 1112
  return (1);
}
}
#line 1129 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *dns_map_lookup(struct _map *map___0 , char *name , char **av___0 , int *statp ) 
{ 
  char *vp ;
  char *result___0 ;
  size_t vsize ;
  struct dns_map *map_p ;
  RESOURCE_RECORD_T *rr ;
  DNS_REPLY_T *r ;
  int *tmp ;
  int *tmp___0 ;
  bool tmp___1 ;
  char *type ;
  char *value ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 1141
  vp = (char *)((void *)0);
#line 1141
  result___0 = (char *)((void *)0);
#line 1144
  rr = (RESOURCE_RECORD_T *)((void *)0);
#line 1145
  r = (DNS_REPLY_T *)((void *)0);
#line 1150
  if ((int )tTdvect[38] >= 20) {
    {
#line 1151
    sm_dprintf((char *)"dns_map_lookup(%s, %s)\n", map___0->map_mname, name);
    }
  }
  {
#line 1154
  map_p = (struct dns_map *)map___0->map_db1;
#line 1176
  r = dns_lookup_int((char const   *)name, 1, map_p->dns_m_type, map___0->map_timeout,
                     map___0->map_retry);
  }
#line 1180
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 1182
    result___0 = (char *)((void *)0);
#line 1183
    tmp = __h_errno_location();
    }
#line 1183
    if (*tmp == 2) {
#line 1184
      *statp = 75;
    } else {
      {
#line 1183
      tmp___0 = __errno_location();
#line 1183
      tmp___1 = transienterror(*tmp___0);
      }
#line 1183
      if (tmp___1) {
#line 1184
        *statp = 75;
      } else {
#line 1186
        *statp = 68;
      }
    }
#line 1187
    goto cleanup;
  }
#line 1189
  *statp = 0;
#line 1190
  rr = r->dns_r_head;
  {
#line 1190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1190
    if (! ((unsigned long )rr != (unsigned long )((void *)0))) {
#line 1190
      goto while_break;
    }
#line 1192
    type = (char *)((void *)0);
#line 1193
    value = (char *)((void *)0);
    {
#line 1197
    if (rr->rr_type == 2U) {
#line 1197
      goto case_2;
    }
#line 1201
    if (rr->rr_type == 5U) {
#line 1201
      goto case_5;
    }
#line 1205
    if (rr->rr_type == 18U) {
#line 1205
      goto case_18;
    }
#line 1209
    if (rr->rr_type == 33U) {
#line 1209
      goto case_33;
    }
#line 1213
    if (rr->rr_type == 12U) {
#line 1213
      goto case_12;
    }
#line 1217
    if (rr->rr_type == 16U) {
#line 1217
      goto case_16;
    }
#line 1221
    if (rr->rr_type == 15U) {
#line 1221
      goto case_15;
    }
#line 1226
    if (rr->rr_type == 1U) {
#line 1226
      goto case_1;
    }
#line 1195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1198
    type = (char *)"T_NS";
#line 1199
    value = rr->rr_u.rr_txt;
#line 1200
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1202
    type = (char *)"T_CNAME";
#line 1203
    value = rr->rr_u.rr_txt;
#line 1204
    goto switch_break;
    case_18: /* CIL Label */ 
#line 1206
    type = (char *)"T_AFSDB";
#line 1207
    value = (rr->rr_u.rr_mx)->mx_r_domain;
#line 1208
    goto switch_break;
    case_33: /* CIL Label */ 
#line 1210
    type = (char *)"T_SRV";
#line 1211
    value = (rr->rr_u.rr_srv)->srv_r_target;
#line 1212
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1214
    type = (char *)"T_PTR";
#line 1215
    value = rr->rr_u.rr_txt;
#line 1216
    goto switch_break;
    case_16: /* CIL Label */ 
#line 1218
    type = (char *)"T_TXT";
#line 1219
    value = rr->rr_u.rr_txt;
#line 1220
    goto switch_break;
    case_15: /* CIL Label */ 
#line 1222
    type = (char *)"T_MX";
#line 1223
    value = (rr->rr_u.rr_mx)->mx_r_domain;
#line 1224
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1227
    type = (char *)"T_A";
#line 1228
    value = inet_ntoa(*(rr->rr_u.rr_a));
    }
#line 1229
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1240
    strreplnonprt(value, 'X');
    }
#line 1241
    if ((unsigned int )map_p->dns_m_type != rr->rr_type) {
#line 1243
      if ((int )tTdvect[38] >= 40) {
#line 1244
        if ((unsigned long )value != (unsigned long )((void *)0)) {
#line 1244
          tmp___2 = (char const   *)value;
        } else {
#line 1244
          tmp___2 = "<NO VALUE>";
        }
#line 1244
        if ((unsigned long )type != (unsigned long )((void *)0)) {
#line 1244
          tmp___3 = (char const   *)type;
        } else {
#line 1244
          tmp___3 = "<UNKNOWN>";
        }
        {
#line 1244
        sm_dprintf((char *)"\tskipping type %s (%d) value %s\n", tmp___3, rr->rr_type,
                   tmp___2);
        }
      }
#line 1248
      goto __Cont;
    }
#line 1261
    if ((int )tTdvect[38] >= 40) {
#line 1262
      if ((unsigned long )value != (unsigned long )((void *)0)) {
#line 1262
        tmp___4 = (char const   *)value;
      } else {
#line 1262
        tmp___4 = "<NO VALUE>";
      }
#line 1262
      if ((unsigned long )type != (unsigned long )((void *)0)) {
#line 1262
        tmp___5 = (char const   *)type;
      } else {
#line 1262
        tmp___5 = "<UNKNOWN>";
      }
      {
#line 1262
      sm_dprintf((char *)"\tfound type %s (%d) value %s\n", tmp___5, rr->rr_type,
                 tmp___4);
      }
    }
#line 1302
    vp = value;
#line 1303
    goto while_break;
    __Cont: /* CIL Label */ 
#line 1190
    rr = rr->rr_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1306
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
#line 1308
    result___0 = (char *)((void *)0);
#line 1309
    *statp = 68;
#line 1310
    if ((int )tTdvect[38] >= 40) {
      {
#line 1311
      sm_dprintf((char *)"\tno match found\n");
      }
    }
#line 1312
    goto cleanup;
  }
  {
#line 1320
  vsize = strlen((char const   *)vp);
  }
#line 1322
  if (LogLevel > 9) {
    {
#line 1323
    sm_syslog(6, (char const   *)CurEnv->e_id, "dns %.100s => %s", name, vp);
    }
  }
#line 1325
  if ((map___0->map_mflags & 16L) != 0L) {
    {
#line 1326
    tmp___6 = strlen((char const   *)name);
#line 1326
    result___0 = map_rewrite(map___0, (char const   *)name, tmp___6, (char **)((void *)0));
    }
  } else {
    {
#line 1328
    result___0 = map_rewrite(map___0, (char const   *)vp, vsize, av___0);
    }
  }
  cleanup: 
#line 1335
  if ((unsigned long )r != (unsigned long )((void *)0)) {
    {
#line 1336
    dns_free_data(r);
    }
  }
#line 1337
  return (result___0);
}
}
#line 1873 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool bt_map_open(struct _map *map___0 , int mode ) 
{ 
  void *btinfo ;
  bool tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1885
  btinfo = (void *)0;
#line 1888
  if ((int )tTdvect[38] >= 2) {
    {
#line 1889
    sm_dprintf((char *)"bt_map_open(%s, %s, %d)\n", map___0->map_mname, map___0->map_file,
               mode);
    }
  }
  {
#line 1899
  tmp = db_map_open(map___0, mode, (char *)"btree", (DBTYPE )1, & btinfo);
  }
#line 1899
  return (tmp);
}
}
#line 1902 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool hash_map_open(struct _map *map___0 , int mode ) 
{ 
  void *hinfo ;
  bool tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1914
  hinfo = (void *)0;
#line 1917
  if ((int )tTdvect[38] >= 2) {
    {
#line 1918
    sm_dprintf((char *)"hash_map_open(%s, %s, %d)\n", map___0->map_mname, map___0->map_file,
               mode);
    }
  }
  {
#line 1931
  tmp = db_map_open(map___0, mode, (char *)"hash", (DBTYPE )2, & hinfo);
  }
#line 1931
  return (tmp);
}
}
#line 1934 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
static bool db_map_open(struct _map *map___0 , int mode , char *mapclassname , DBTYPE dbtype ,
                        void **openinfo ) 
{ 
  DB *db ;
  int i ;
  int omode ;
  int smode ;
  int fd ;
  long sff ;
  int save_errno ;
  struct stat st ;
  char buf___16[4096] ;
  int *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *prob ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  bool tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  bool tmp___14 ;
  int flags ;
  int ret ;
  int *tmp___15 ;
  int *tmp___16 ;
  bool tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  int *tmp___22 ;
  bool tmp___23 ;
  int err ;
  int *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  __uid_t tmp___28 ;
  int tmp___29 ;
  bool tmp___30 ;
  void *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
  {
#line 1950
  db = (DB *)((void *)0);
#line 1953
  smode = 256;
#line 1961
  tmp___0 = sm_strlcpy(buf___16, (char const   *)map___0->map_file, (ssize_t )sizeof(buf___16));
  }
#line 1961
  if ((unsigned long )tmp___0 >= sizeof(buf___16)) {
    {
#line 1963
    tmp = __errno_location();
#line 1963
    *tmp = 0;
    }
#line 1964
    if (! ((map___0->map_mflags & 4L) != 0L)) {
      {
#line 1965
      syserr("map \"%s\": map file %s name too long", map___0->map_mname, map___0->map_file);
      }
    }
#line 1967
    return (0);
  }
  {
#line 1969
  tmp___1 = strlen((char const   *)(buf___16));
#line 1969
  i = (int )tmp___1;
  }
#line 1970
  if (i < 3) {
#line 1970
    goto _L;
  } else {
    {
#line 1970
    tmp___4 = strcmp((char const   *)(& buf___16[i - 3]), ".db");
    }
#line 1970
    if (tmp___4 != 0) {
      _L: /* CIL Label */ 
      {
#line 1972
      tmp___3 = sm_strlcat(buf___16, ".db", (ssize_t )sizeof(buf___16));
      }
#line 1972
      if ((unsigned long )tmp___3 >= sizeof(buf___16)) {
        {
#line 1974
        tmp___2 = __errno_location();
#line 1974
        *tmp___2 = 0;
        }
#line 1975
        if (! ((map___0->map_mflags & 4L) != 0L)) {
          {
#line 1976
          syserr("map \"%s\": map file %s name too long", map___0->map_mname, map___0->map_file);
          }
        }
#line 1978
        return (0);
      }
    }
  }
#line 1982
  mode &= 3;
#line 1983
  omode = mode;
#line 1985
  sff = 132L;
#line 1986
  if (mode == 2) {
#line 1988
    sff |= 64L;
#line 1989
    if (! (DontBlameSendmail[18UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 18UL % (8UL * sizeof(int ))))) {
#line 1990
      sff |= 2L;
    }
#line 1991
    if (! (DontBlameSendmail[17UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 17UL % (8UL * sizeof(int ))))) {
#line 1992
      sff |= 512L;
    }
#line 1993
    smode = 128;
  } else
#line 1997
  if (! (DontBlameSendmail[13UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 13UL % (8UL * sizeof(int ))))) {
#line 1998
    sff |= 1024L;
  }
#line 2000
  if (! (DontBlameSendmail[8UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 8UL % (8UL * sizeof(int ))))) {
#line 2001
    sff |= 256L;
  }
  {
#line 2002
  i = safefile(buf___16, RunAsUid, RunAsGid, RunAsUserName, sff, smode, & st);
  }
#line 2004
  if (i != 0) {
#line 2006
    prob = (char *)"unsafe";
#line 2009
    if (i == 2) {
#line 2010
      prob = (char *)"missing";
    }
#line 2011
    if ((int )tTdvect[38] >= 2) {
      {
#line 2012
      tmp___5 = sm_errstring(i);
#line 2012
      sm_dprintf((char *)"\t%s map file: %s\n", prob, tmp___5);
      }
    }
    {
#line 2013
    tmp___6 = __errno_location();
#line 2013
    *tmp___6 = i;
    }
#line 2014
    if (! ((map___0->map_mflags & 4L) != 0L)) {
      {
#line 2015
      syserr("%s map \"%s\": %s map file %s", mapclassname, map___0->map_mname, prob,
             buf___16);
      }
    }
#line 2017
    return (0);
  }
#line 2019
  if (st.st_mode == 62055U) {
#line 2020
    omode |= 192;
  }
  {
#line 2022
  map___0->map_lockfd = -1;
#line 2036
  fd = open((char const   *)(buf___16), omode, 416);
  }
#line 2037
  if (fd < 0) {
#line 2039
    if (! ((map___0->map_mflags & 4L) != 0L)) {
      {
#line 2040
      syserr("db_map_open: cannot pre-open database %s", buf___16);
      }
    }
#line 2041
    return (0);
  }
  {
#line 2045
  tmp___9 = filechanged(buf___16, fd, & st);
  }
#line 2045
  if (tmp___9) {
    {
#line 2047
    tmp___7 = __errno_location();
#line 2047
    save_errno = *tmp___7;
#line 2048
    close(fd);
#line 2049
    tmp___8 = __errno_location();
#line 2049
    *tmp___8 = save_errno;
#line 2050
    syserr("db_map_open(%s): file changed after pre-open", buf___16);
    }
#line 2051
    return (0);
  }
#line 2055
  if (st.st_mode == 62055U) {
    {
#line 2055
    tmp___12 = fstat(fd, & st);
    }
#line 2055
    if (tmp___12 < 0) {
      {
#line 2057
      tmp___10 = __errno_location();
#line 2057
      save_errno = *tmp___10;
#line 2058
      close(fd);
#line 2059
      tmp___11 = __errno_location();
#line 2059
      *tmp___11 = save_errno;
#line 2060
      syserr("db_map_open(%s): cannot fstat pre-opened file", buf___16);
      }
#line 2062
      return (0);
    }
  }
#line 2066
  if (mode == 0) {
#line 2066
    tmp___13 = 1;
  } else {
#line 2066
    tmp___13 = 2;
  }
  {
#line 2066
  tmp___14 = lockfile(fd, buf___16, (char *)((void *)0), tmp___13);
  }
#line 2066
  if (! tmp___14) {
    {
#line 2067
    syserr("db_map_open: cannot lock %s", buf___16);
    }
  }
#line 2070
  if (mode == 2) {
#line 2071
    omode |= 512;
  }
#line 2072
  omode &= -193;
#line 2079
  flags = 0;
#line 2084
  if (mode == 0) {
#line 2085
    flags |= 16;
  }
#line 2086
  if ((omode & 64) != 0) {
#line 2087
    flags |= 1;
  }
#line 2088
  if ((omode & 512) != 0) {
#line 2089
    flags |= 16384;
  }
  {
#line 2090
  flags |= 2048;
#line 2093
  ret = db_create(& db, (DB_ENV *)((void *)0), (u_int32_t )0);
  }
#line 2116
  if (ret == 0) {
#line 2116
    if ((unsigned long )db != (unsigned long )((void *)0)) {
      {
#line 2118
      ret = (*(db->open))(db, (char const   *)(buf___16), (char const   *)((void *)0),
                          dbtype, (u_int32_t )flags, 416);
      }
#line 2121
      if (ret != 0) {
#line 2124
        if (ret == -30990) {
#line 2125
          ret = 22;
        }
        {
#line 2127
        (*(db->close))(db, (u_int32_t )0);
#line 2128
        db = (DB *)((void *)0);
        }
      }
    }
  }
  {
#line 2131
  tmp___15 = __errno_location();
#line 2131
  *tmp___15 = ret;
#line 2138
  tmp___16 = __errno_location();
#line 2138
  save_errno = *tmp___16;
  }
#line 2141
  if (mode == 2) {
#line 2142
    map___0->map_lockfd = fd;
  } else {
    {
#line 2144
    close(fd);
    }
  }
#line 2147
  if ((unsigned long )db == (unsigned long )((void *)0)) {
#line 2149
    if (mode == 0) {
#line 2149
      if ((map___0->map_mflags & 128L) != 0L) {
        {
#line 2149
        tmp___17 = aliaswait(map___0, (char *)".db", 0);
        }
#line 2149
        if (tmp___17) {
#line 2151
          return (1);
        }
      }
    }
#line 2153
    if (map___0->map_lockfd >= 0) {
      {
#line 2154
      close(map___0->map_lockfd);
      }
    }
    {
#line 2156
    tmp___18 = __errno_location();
#line 2156
    *tmp___18 = save_errno;
    }
#line 2157
    if (! ((map___0->map_mflags & 4L) != 0L)) {
      {
#line 2158
      syserr("Cannot open %s database %s", mapclassname, buf___16);
      }
    }
#line 2160
    return (0);
  }
  {
#line 2166
  fd = -1;
#line 2167
  tmp___19 = __errno_location();
#line 2167
  *tmp___19 = (*(db->fd))(db, & fd);
#line 2169
  tmp___23 = filechanged(buf___16, fd, & st);
  }
#line 2169
  if (tmp___23) {
    {
#line 2171
    tmp___20 = __errno_location();
#line 2171
    save_errno = *tmp___20;
#line 2175
    tmp___21 = __errno_location();
#line 2175
    *tmp___21 = (*(db->close))(db, (u_int32_t )0);
    }
#line 2178
    if (map___0->map_lockfd >= 0) {
      {
#line 2179
      close(map___0->map_lockfd);
      }
    }
    {
#line 2181
    tmp___22 = __errno_location();
#line 2181
    *tmp___22 = save_errno;
#line 2182
    syserr("db_map_open(%s): file changed after open", buf___16);
    }
#line 2183
    return (0);
  }
#line 2186
  if (mode == 2) {
#line 2187
    map___0->map_mflags |= 1024L;
  }
#line 2196
  if (mode == 2) {
    {
#line 2198
    (*(db->sync))(db, (u_int32_t )0);
#line 2199
    tmp___28 = geteuid();
    }
#line 2199
    if (tmp___28 == 0U) {
#line 2199
      if (TrustedUid != 0U) {
        {
#line 2202
        tmp___27 = fchown(fd, TrustedUid, (__gid_t )-1);
        }
#line 2202
        if (tmp___27 < 0) {
          {
#line 2204
          tmp___24 = __errno_location();
#line 2204
          err = *tmp___24;
#line 2206
          tmp___25 = sm_errstring(err);
#line 2206
          sm_syslog(1, "*~*", "ownership change on %s failed: %s", buf___16, tmp___25);
#line 2209
          tmp___26 = sm_errstring(err);
#line 2209
          message("050 ownership change on %s failed: %s", buf___16, tmp___26);
          }
        }
      }
    }
  }
#line 2222
  map___0->map_db2 = (void *)db;
#line 2230
  if (fd >= 0) {
    {
#line 2230
    tmp___29 = fstat(fd, & st);
    }
#line 2230
    if (tmp___29 >= 0) {
#line 2231
      map___0->map_mtime = st.st_mtim.tv_sec;
    }
  }
#line 2233
  if (mode == 0) {
#line 2233
    if ((map___0->map_mflags & 128L) != 0L) {
      {
#line 2233
      tmp___30 = aliaswait(map___0, (char *)".db", 1);
      }
#line 2233
      if (! tmp___30) {
#line 2235
        return (0);
      }
    }
  }
#line 2236
  return (1);
}
}
#line 2244 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *db_map_lookup(struct _map *map___0 , char *name , char **av___0 , int *statp ) 
{ 
  DBT key ;
  DBT val ;
  register DB *db ;
  int i ;
  int st ;
  int save_errno ;
  int fd ;
  struct stat stbuf ;
  char keybuf[257] ;
  char buf___16[4096] ;
  int *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int omode ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 2252
  db = (DB *)map___0->map_db2;
#line 2261
  memset((void *)(& key), '\000', (size_t )sizeof(key));
#line 2262
  memset((void *)(& val), '\000', (size_t )sizeof(val));
  }
#line 2264
  if ((int )tTdvect[38] >= 20) {
    {
#line 2265
    sm_dprintf((char *)"db_map_lookup(%s, %s)\n", map___0->map_mname, name);
    }
  }
  {
#line 2268
  tmp___0 = sm_strlcpy(buf___16, (char const   *)map___0->map_file, (ssize_t )sizeof(buf___16));
  }
#line 2268
  if ((unsigned long )tmp___0 >= sizeof(buf___16)) {
    {
#line 2270
    tmp = __errno_location();
#line 2270
    *tmp = 0;
    }
#line 2271
    if (! ((map___0->map_mflags & 4L) != 0L)) {
      {
#line 2272
      syserr("map \"%s\": map file %s name too long", map___0->map_mname, map___0->map_file);
      }
    }
#line 2274
    return ((char *)((void *)0));
  }
  {
#line 2276
  tmp___1 = strlen((char const   *)(buf___16));
#line 2276
  i = (int )tmp___1;
  }
#line 2277
  if (i > 3) {
    {
#line 2277
    tmp___2 = strcmp((char const   *)(& buf___16[i - 3]), ".db");
    }
#line 2277
    if (tmp___2 == 0) {
#line 2278
      buf___16[i - 3] = (char )'\000';
    }
  }
  {
#line 2280
  key.size = strlen((char const   *)name);
  }
#line 2281
  if ((unsigned long )key.size > sizeof(keybuf) - 1UL) {
#line 2282
    key.size = (u_int32_t )(sizeof(keybuf) - 1UL);
  }
  {
#line 2283
  key.data = (void *)(keybuf);
#line 2284
  memmove((void *)(keybuf), (void const   *)name, key.size);
#line 2285
  keybuf[key.size] = (char )'\000';
  }
#line 2286
  if (! ((map___0->map_mflags & 8L) != 0L)) {
    {
#line 2287
    makelower(keybuf);
    }
  }
  lockdb: 
  {
#line 2292
  fd = -1;
#line 2293
  tmp___3 = __errno_location();
#line 2293
  *tmp___3 = (*(db->fd))(db, & fd);
  }
#line 2295
  if (fd >= 0) {
#line 2295
    if (! ((map___0->map_mflags & 1024L) != 0L)) {
      {
#line 2296
      lockfile(fd, buf___16, (char *)".db", 1);
      }
    }
  }
#line 2297
  if (fd < 0) {
#line 2297
    goto _L;
  } else {
    {
#line 2297
    tmp___7 = fstat(fd, & stbuf);
    }
#line 2297
    if (tmp___7 < 0) {
#line 2297
      goto _L;
    } else
#line 2297
    if (stbuf.st_mtim.tv_sec > map___0->map_mtime) {
      _L: /* CIL Label */ 
#line 2300
      if ((64L & map___0->map_mflags) != 0L) {
#line 2300
        tmp___4 = 2;
      } else {
#line 2300
        tmp___4 = 0;
      }
#line 2300
      omode = tmp___4;
#line 2303
      if (fd >= 0) {
#line 2303
        if (! ((map___0->map_mflags & 1024L) != 0L)) {
          {
#line 2304
          lockfile(fd, buf___16, (char *)".db", 8);
          }
        }
      }
      {
#line 2305
      map___0->map_mflags |= 16777216L;
#line 2306
      (*((map___0->map_class)->map_close))(map___0);
#line 2307
      map___0->map_mflags &= -16777313L;
#line 2308
      tmp___6 = (*((map___0->map_class)->map_open))(map___0, omode);
      }
#line 2308
      if (tmp___6) {
#line 2310
        map___0->map_mflags |= 32L;
#line 2311
        map___0->map_pid = CurrentPid;
#line 2312
        if (omode) {
#line 2312
          tmp___5 = 1;
        } else {
#line 2312
          tmp___5 = 0;
        }
#line 2312
        if (tmp___5 == 2) {
#line 2313
          map___0->map_mflags |= 64L;
        }
#line 2314
        db = (DB *)map___0->map_db2;
#line 2315
        goto lockdb;
      } else {
#line 2319
        if (! ((map___0->map_mflags & 4L) != 0L)) {
          {
#line 2323
          *statp = 75;
#line 2324
          map___0->map_orgclass = map___0->map_class;
#line 2325
          map___0->map_class = & BogusMapClass;
#line 2326
          map___0->map_mflags |= 32L;
#line 2327
          map___0->map_pid = CurrentPid;
#line 2328
          syserr("Cannot reopen DB database %s", map___0->map_file);
          }
        }
#line 2331
        return ((char *)((void *)0));
      }
    }
  }
#line 2335
  st = 1;
#line 2336
  if ((map___0->map_mflags & 256L) != 0L) {
    {
#line 2341
    tmp___8 = __errno_location();
#line 2341
    *tmp___8 = (*(db->get))(db, (DB_TXN *)((void *)0), & key, & val, (u_int32_t )0);
#line 2342
    tmp___9 = __errno_location();
    }
    {
#line 2345
    if (*tmp___9 == -30998) {
#line 2345
      goto case_neg_30998;
    }
#line 2345
    if (*tmp___9 == -30991) {
#line 2345
      goto case_neg_30998;
    }
#line 2349
    if (*tmp___9 == 0) {
#line 2349
      goto case_0;
    }
#line 2353
    goto switch_default;
    case_neg_30998: /* CIL Label */ 
    case_neg_30991: /* CIL Label */ 
#line 2346
    st = 1;
#line 2347
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2350
    st = 0;
#line 2351
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2354
    st = -1;
#line 2355
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2358
    if (st == 0) {
#line 2359
      map___0->map_mflags &= -513L;
    }
  }
#line 2361
  if (st != 0) {
#line 2361
    if ((map___0->map_mflags & 512L) != 0L) {
      {
#line 2363
      (key.size) ++;
#line 2367
      tmp___10 = __errno_location();
#line 2367
      *tmp___10 = (*(db->get))(db, (DB_TXN *)((void *)0), & key, & val, (u_int32_t )0);
#line 2368
      tmp___11 = __errno_location();
      }
      {
#line 2371
      if (*tmp___11 == -30998) {
#line 2371
        goto case_neg_30998___0;
      }
#line 2371
      if (*tmp___11 == -30991) {
#line 2371
        goto case_neg_30998___0;
      }
#line 2375
      if (*tmp___11 == 0) {
#line 2375
        goto case_0___0;
      }
#line 2379
      goto switch_default___0;
      case_neg_30998___0: /* CIL Label */ 
      case_neg_30991___0: /* CIL Label */ 
#line 2372
      st = 1;
#line 2373
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 2376
      st = 0;
#line 2377
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 2380
      st = -1;
#line 2381
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 2384
      if (st == 0) {
#line 2385
        map___0->map_mflags &= -257L;
      }
    }
  }
  {
#line 2387
  tmp___12 = __errno_location();
#line 2387
  save_errno = *tmp___12;
  }
#line 2388
  if (fd >= 0) {
#line 2388
    if (! ((map___0->map_mflags & 1024L) != 0L)) {
      {
#line 2389
      lockfile(fd, buf___16, (char *)".db", 8);
      }
    }
  }
#line 2390
  if (st != 0) {
    {
#line 2392
    tmp___13 = __errno_location();
#line 2392
    *tmp___13 = save_errno;
    }
#line 2393
    if (st < 0) {
      {
#line 2394
      syserr("db_map_lookup: get (%s)", name);
      }
    }
#line 2395
    return ((char *)((void *)0));
  }
#line 2397
  if ((map___0->map_mflags & 16L) != 0L) {
    {
#line 2398
    tmp___14 = strlen((char const   *)name);
#line 2398
    tmp___15 = map_rewrite(map___0, (char const   *)name, tmp___14, (char **)((void *)0));
    }
#line 2398
    return (tmp___15);
  } else {
    {
#line 2400
    tmp___16 = map_rewrite(map___0, (char const   *)val.data, val.size, av___0);
    }
#line 2400
    return (tmp___16);
  }
}
}
#line 2473
void db_map_store(struct _map *map___0 , char *lhs , char *rhs ) ;
#line 2473 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
static char *buf___9  =    (char *)((void *)0);
#line 2474 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
static int bufsiz  =    0;
#line 2408 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
void db_map_store(struct _map *map___0 , char *lhs , char *rhs ) 
{ 
  int status ;
  DBT key ;
  DBT data ;
  register DB *db ;
  char keybuf[257] ;
  int *tmp ;
  int *tmp___0 ;
  DBT old ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 2417
  db = (DB *)map___0->map_db2;
#line 2420
  memset((void *)(& key), '\000', (size_t )sizeof(key));
#line 2421
  memset((void *)(& data), '\000', (size_t )sizeof(data));
  }
#line 2423
  if ((int )tTdvect[38] >= 12) {
    {
#line 2424
    sm_dprintf((char *)"db_map_store(%s, %s, %s)\n", map___0->map_mname, lhs, rhs);
    }
  }
  {
#line 2427
  key.size = strlen((char const   *)lhs);
#line 2428
  key.data = (void *)lhs;
  }
#line 2429
  if (! ((map___0->map_mflags & 8L) != 0L)) {
#line 2431
    if ((unsigned long )key.size > sizeof(keybuf) - 1UL) {
#line 2432
      key.size = (u_int32_t )(sizeof(keybuf) - 1UL);
    }
    {
#line 2433
    memmove((void *)(keybuf), (void const   *)key.data, key.size);
#line 2434
    keybuf[key.size] = (char )'\000';
#line 2435
    makelower(keybuf);
#line 2436
    key.data = (void *)(keybuf);
    }
  }
  {
#line 2439
  data.size = strlen((char const   *)rhs);
#line 2440
  data.data = (void *)rhs;
  }
#line 2442
  if ((map___0->map_mflags & 2L) != 0L) {
#line 2444
    (key.size) ++;
#line 2445
    (data.size) ++;
  }
  {
#line 2451
  tmp = __errno_location();
#line 2451
  *tmp = (*(db->put))(db, (DB_TXN *)((void *)0), & key, & data, (u_int32_t )23);
#line 2452
  tmp___0 = __errno_location();
  }
  {
#line 2454
  if (*tmp___0 == -30997) {
#line 2454
    goto case_neg_30997;
  }
#line 2458
  if (*tmp___0 == 0) {
#line 2458
    goto case_0;
  }
#line 2462
  goto switch_default;
  case_neg_30997: /* CIL Label */ 
#line 2455
  status = 1;
#line 2456
  goto switch_break;
  case_0: /* CIL Label */ 
#line 2459
  status = 0;
#line 2460
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2463
  status = -1;
#line 2464
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2467
  if (status > 0) {
#line 2469
    if (! ((map___0->map_mflags & 32768L) != 0L)) {
      {
#line 2470
      message("050 Warning: duplicate alias name %s", lhs);
      }
    } else {
      {
#line 2477
      memset((void *)(& old), '\000', (size_t )sizeof(old));
#line 2479
      tmp___1 = db_map_lookup(map___0, (char *)key.data, (char **)((void *)0), & status);
#line 2479
      old.data = (void *)tmp___1;
      }
#line 2481
      if ((unsigned long )old.data != (unsigned long )((void *)0)) {
        {
#line 2483
        old.size = strlen((char const   *)old.data);
        }
#line 2484
        if ((data.size + old.size) + 2U > (size_t )bufsiz) {
#line 2486
          if ((unsigned long )buf___9 != (unsigned long )((void *)0)) {
            {
#line 2487
            sm_free_tagged((void *)buf___9, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c",
                           2487);
            }
          }
          {
#line 2488
          bufsiz = (int )((data.size + old.size) + 2U);
#line 2489
          tmp___2 = sm_malloc_tagged_x((size_t )bufsiz, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c",
                                       2489, 0);
#line 2489
          buf___9 = (char *)tmp___2;
          }
        }
        {
#line 2491
        sm_strlcpyn(buf___9, bufsiz, 3, (char *)data.data, ",", (char *)old.data);
#line 2494
        data.size = (data.size + old.size) + 1U;
#line 2495
        data.data = (void *)buf___9;
        }
#line 2496
        if ((int )tTdvect[38] >= 9) {
          {
#line 2497
          sm_dprintf((char *)"db_map_store append=%s\n", (char *)data.data);
          }
        }
      }
    }
    {
#line 2504
    tmp___3 = __errno_location();
#line 2504
    tmp___4 = (*(db->put))(db, (DB_TXN *)((void *)0), & key, & data, (u_int32_t )0);
#line 2504
    *tmp___3 = tmp___4;
#line 2504
    status = tmp___4;
    }
  }
#line 2507
  if (status != 0) {
    {
#line 2508
    syserr("readaliases: db put (%s)", lhs);
    }
  }
#line 2509
  return;
}
}
#line 2516 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
void db_map_close(struct _map *map___0 ) 
{ 
  register DB *db ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 2520
  db = (DB *)map___0->map_db2;
#line 2522
  if ((int )tTdvect[38] >= 9) {
    {
#line 2523
    sm_dprintf((char *)"db_map_close(%s, %s, %lx)\n", map___0->map_mname, map___0->map_file,
               map___0->map_mflags);
    }
  }
#line 2526
  if ((map___0->map_mflags & 64L) != 0L) {
    {
#line 2529
    db_map_store(map___0, (char *)"@", (char *)"@");
    }
  }
  {
#line 2532
  (*(db->sync))(db, (u_int32_t )0);
  }
#line 2535
  if (map___0->map_lockfd >= 0) {
    {
#line 2536
    close(map___0->map_lockfd);
    }
  }
#line 2556
  if (map___0->map_pid != CurrentPid) {
    {
#line 2558
    fd = -1;
#line 2560
    tmp = __errno_location();
#line 2560
    *tmp = (*(db->fd))(db, & fd);
    }
#line 2561
    if (fd >= 0) {
      {
#line 2562
      close(fd);
      }
    }
#line 2563
    return;
  }
  {
#line 2566
  tmp___0 = __errno_location();
#line 2566
  tmp___1 = (*(db->close))(db, (u_int32_t )0);
#line 2566
  *tmp___0 = tmp___1;
  }
#line 2566
  if (tmp___1 != 0) {
    {
#line 2568
    syserr("db_map_close(%s, %s, %lx): db close failure", map___0->map_mname, map___0->map_file,
           map___0->map_mflags);
    }
  }
#line 2570
  return;
}
}
#line 4974 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool syslog_map_parseargs(struct _map *map___0 , char *args ) 
{ 
  char *p ;
  char *priority ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 4979
  p = args;
#line 4980
  priority = (char *)((void *)0);
  {
#line 4983
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4983
    if (! ((int )*p != 0)) {
#line 4983
      goto while_break;
    }
    {
#line 4985
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4985
      if (((int )*p & -128) == 0) {
        {
#line 4985
        tmp = __ctype_b_loc();
        }
#line 4985
        if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 4985
          goto while_break___0;
        }
      } else {
#line 4985
        goto while_break___0;
      }
#line 4986
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4987
    if ((int )*p != 45) {
#line 4988
      goto while_break;
    }
#line 4989
    p ++;
#line 4990
    if ((int )*p == 68) {
#line 4992
      map___0->map_mflags |= 524288L;
#line 4993
      p ++;
    } else
#line 4995
    if ((int )*p == 83) {
#line 4997
      p ++;
#line 4997
      map___0->map_spacesub = *p;
#line 4998
      if ((int )*p != 0) {
#line 4999
        p ++;
      }
    } else
#line 5001
    if ((int )*p == 76) {
      {
#line 5003
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5003
        p ++;
#line 5003
        if ((int )*p != 0) {
#line 5003
          if (((int )*p & -128) == 0) {
            {
#line 5003
            tmp___0 = __ctype_b_loc();
            }
#line 5003
            if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 5003
              goto while_break___1;
            }
          } else {
#line 5003
            goto while_break___1;
          }
        } else {
#line 5003
          goto while_break___1;
        }
#line 5004
        goto while_continue___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 5005
      if ((int )*p == 0) {
#line 5006
        goto while_break;
      }
#line 5007
      priority = p;
      {
#line 5008
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 5008
        if ((int )*p != 0) {
#line 5008
          if (((int )*p & -128) == 0) {
            {
#line 5008
            tmp___1 = __ctype_b_loc();
            }
#line 5008
            if ((int const   )*(*tmp___1 + (int )*p) & 8192) {
#line 5008
              goto while_break___2;
            }
          }
        } else {
#line 5008
          goto while_break___2;
        }
#line 5009
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 5010
      if ((int )*p != 0) {
#line 5011
        tmp___2 = p;
#line 5011
        p ++;
#line 5011
        *tmp___2 = (char )'\000';
      }
    } else {
      {
#line 5015
      syserr("Illegal option %c map syslog", (int )*p);
#line 5016
      p ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5020
  if ((unsigned long )priority == (unsigned long )((void *)0)) {
#line 5021
    map___0->map_lockfd = 6;
  } else {
    {
#line 5024
    tmp___3 = sm_strncasecmp("LOG_", (char const   *)priority, (size_t )4);
    }
#line 5024
    if (tmp___3 == 0) {
#line 5025
      priority += 4;
    }
    {
#line 5028
    tmp___11 = sm_strcasecmp("EMERG", (char const   *)priority);
    }
#line 5028
    if (tmp___11 == 0) {
#line 5029
      map___0->map_lockfd = 0;
    } else {
      {
#line 5033
      tmp___10 = sm_strcasecmp("ALERT", (char const   *)priority);
      }
#line 5033
      if (tmp___10 == 0) {
#line 5034
        map___0->map_lockfd = 1;
      } else {
        {
#line 5038
        tmp___9 = sm_strcasecmp("CRIT", (char const   *)priority);
        }
#line 5038
        if (tmp___9 == 0) {
#line 5039
          map___0->map_lockfd = 2;
        } else {
          {
#line 5043
          tmp___8 = sm_strcasecmp("ERR", (char const   *)priority);
          }
#line 5043
          if (tmp___8 == 0) {
#line 5044
            map___0->map_lockfd = 3;
          } else {
            {
#line 5048
            tmp___7 = sm_strcasecmp("WARNING", (char const   *)priority);
            }
#line 5048
            if (tmp___7 == 0) {
#line 5049
              map___0->map_lockfd = 4;
            } else {
              {
#line 5053
              tmp___6 = sm_strcasecmp("NOTICE", (char const   *)priority);
              }
#line 5053
              if (tmp___6 == 0) {
#line 5054
                map___0->map_lockfd = 5;
              } else {
                {
#line 5058
                tmp___5 = sm_strcasecmp("INFO", (char const   *)priority);
                }
#line 5058
                if (tmp___5 == 0) {
#line 5059
                  map___0->map_lockfd = 6;
                } else {
                  {
#line 5063
                  tmp___4 = sm_strcasecmp("DEBUG", (char const   *)priority);
                  }
#line 5063
                  if (tmp___4 == 0) {
#line 5064
                    map___0->map_lockfd = 7;
                  } else {
                    {
#line 5068
                    syserr("syslog_map_parseargs: Unknown priority %s", priority);
                    }
#line 5070
                    return (0);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 5073
  return (1);
}
}
#line 5080 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *syslog_map_lookup(struct _map *map___0 , char *string , char **args , int *statp ) 
{ 
  char *ptr ;
  size_t tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 5087
  tmp = strlen((char const   *)string);
#line 5087
  tmp___0 = map_rewrite(map___0, (char const   *)string, tmp, args);
#line 5087
  ptr = tmp___0;
  }
#line 5089
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 5091
    if ((int )tTdvect[38] >= 20) {
      {
#line 5092
      sm_dprintf((char *)"syslog_map_lookup(%s (priority %d): %s\n", map___0->map_mname,
                 map___0->map_lockfd, ptr);
      }
    }
    {
#line 5095
    sm_syslog(map___0->map_lockfd, (char const   *)CurEnv->e_id, "%s", ptr);
    }
  }
#line 5098
  *statp = 0;
#line 5099
  return ((char *)"");
}
}
#line 5406 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool text_map_open(struct _map *map___0 , int mode ) 
{ 
  long sff ;
  int i ;
  int *tmp ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 5414
  if ((int )tTdvect[38] >= 2) {
    {
#line 5415
    sm_dprintf((char *)"text_map_open(%s, %s, %d)\n", map___0->map_mname, map___0->map_file,
               mode);
    }
  }
#line 5418
  mode &= 3;
#line 5419
  if (mode != 0) {
    {
#line 5421
    tmp = __errno_location();
#line 5421
    *tmp = 1;
    }
#line 5422
    return (0);
  }
#line 5425
  if ((int )*(map___0->map_file) == 0) {
    {
#line 5427
    syserr("text map \"%s\": file name required", map___0->map_mname);
    }
#line 5429
    return (0);
  }
#line 5432
  if ((int )*(map___0->map_file + 0) != 47) {
    {
#line 5434
    syserr("text map \"%s\": file name must be fully qualified", map___0->map_mname);
    }
#line 5436
    return (0);
  }
#line 5439
  sff = 132L;
#line 5440
  if (! (DontBlameSendmail[13UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 13UL % (8UL * sizeof(int ))))) {
#line 5441
    sff |= 1024L;
  }
#line 5442
  if (! (DontBlameSendmail[8UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 8UL % (8UL * sizeof(int ))))) {
#line 5443
    sff |= 256L;
  }
  {
#line 5444
  i = safefile(map___0->map_file, RunAsUid, RunAsGid, RunAsUserName, sff, 256, (struct stat *)((void *)0));
  }
#line 5444
  if (i != 0) {
    {
#line 5447
    tmp___0 = __errno_location();
#line 5447
    save_errno = *tmp___0;
    }
#line 5450
    if ((int )tTdvect[38] >= 2) {
      {
#line 5451
      sm_dprintf((char *)"\tunsafe map file: %d\n", i);
      }
    }
    {
#line 5452
    tmp___1 = __errno_location();
#line 5452
    *tmp___1 = save_errno;
    }
#line 5453
    if (! ((map___0->map_mflags & 4L) != 0L)) {
      {
#line 5454
      syserr("text map \"%s\": unsafe map file %s", map___0->map_mname, map___0->map_file);
      }
    }
#line 5456
    return (0);
  }
#line 5459
  if ((unsigned long )map___0->map_keycolnm == (unsigned long )((void *)0)) {
#line 5460
    map___0->map_keycolno = (unsigned char)0;
  } else {
#line 5463
    if (((int )*(map___0->map_keycolnm) & -128) == 0) {
      {
#line 5463
      tmp___2 = __ctype_b_loc();
      }
#line 5463
      if (! ((int const   )*(*tmp___2 + (int )*(map___0->map_keycolnm)) & 2048)) {
        {
#line 5465
        syserr("text map \"%s\", file %s: -k should specify a number, not %s", map___0->map_mname,
               map___0->map_file, map___0->map_keycolnm);
        }
#line 5468
        return (0);
      }
    } else {
      {
#line 5465
      syserr("text map \"%s\", file %s: -k should specify a number, not %s", map___0->map_mname,
             map___0->map_file, map___0->map_keycolnm);
      }
#line 5468
      return (0);
    }
    {
#line 5470
    tmp___3 = atoi((char const   *)map___0->map_keycolnm);
#line 5470
    map___0->map_keycolno = (unsigned char )tmp___3;
    }
  }
#line 5473
  if ((unsigned long )map___0->map_valcolnm == (unsigned long )((void *)0)) {
#line 5474
    map___0->map_valcolno = (unsigned char)0;
  } else {
#line 5477
    if (((int )*(map___0->map_valcolnm) & -128) == 0) {
      {
#line 5477
      tmp___4 = __ctype_b_loc();
      }
#line 5477
      if (! ((int const   )*(*tmp___4 + (int )*(map___0->map_valcolnm)) & 2048)) {
        {
#line 5479
        syserr("text map \"%s\", file %s: -v should specify a number, not %s", map___0->map_mname,
               map___0->map_file, map___0->map_valcolnm);
        }
#line 5482
        return (0);
      }
    } else {
      {
#line 5479
      syserr("text map \"%s\", file %s: -v should specify a number, not %s", map___0->map_mname,
             map___0->map_file, map___0->map_valcolnm);
      }
#line 5482
      return (0);
    }
    {
#line 5484
    tmp___5 = atoi((char const   *)map___0->map_valcolnm);
#line 5484
    map___0->map_valcolno = (unsigned char )tmp___5;
    }
  }
#line 5487
  if ((int )tTdvect[38] >= 2) {
    {
#line 5489
    sm_dprintf((char *)"text_map_open(%s, %s): delimiter = ", map___0->map_mname,
               map___0->map_file);
    }
#line 5491
    if ((int )map___0->map_coldelim == 0) {
      {
#line 5492
      sm_dprintf((char *)"(white space)\n");
      }
    } else {
      {
#line 5494
      sm_dprintf((char *)"%c\n", (int )map___0->map_coldelim);
      }
    }
  }
#line 5497
  map___0->map_lockfd = (int )sff;
#line 5498
  return (1);
}
}
#line 5506 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *text_map_lookup(struct _map *map___0 , char *name , char **av___0 , int *statp ) 
{ 
  char *vp ;
  int vsize ;
  int buflen___1 ;
  SM_FILE_T *f ;
  char delim ;
  int key_idx ;
  bool found_it ;
  long sff ;
  char search_key[257] ;
  char linebuf[2048] ;
  char buf___16[257] ;
  size_t tmp ;
  char *p ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 5520
  sff = (long )map___0->map_lockfd;
#line 5525
  found_it = 0;
#line 5526
  if ((int )tTdvect[38] >= 20) {
    {
#line 5527
    sm_dprintf((char *)"text_map_lookup(%s, %s)\n", map___0->map_mname, name);
    }
  }
  {
#line 5529
  tmp = strlen((char const   *)name);
#line 5529
  buflen___1 = (int )tmp;
  }
#line 5530
  if ((unsigned long )buflen___1 > sizeof(search_key) - 1UL) {
#line 5531
    buflen___1 = (int )(sizeof(search_key) - 1UL);
  }
  {
#line 5532
  memmove((void *)(search_key), (void const   *)name, (size_t )buflen___1);
#line 5533
  search_key[buflen___1] = (char )'\000';
  }
#line 5534
  if (! ((map___0->map_mflags & 8L) != 0L)) {
    {
#line 5535
    makelower(search_key);
    }
  }
  {
#line 5537
  f = safefopen(map___0->map_file, 0, FileMode, sff);
  }
#line 5538
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 5540
    map___0->map_mflags &= -34L;
#line 5541
    *statp = 69;
#line 5542
    return ((char *)((void *)0));
  }
#line 5544
  key_idx = (int )map___0->map_keycolno;
#line 5545
  delim = map___0->map_coldelim;
  {
#line 5546
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5546
    tmp___1 = sm_io_fgets(f, -2, linebuf, (int )sizeof(linebuf));
    }
#line 5546
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 5546
      goto while_break;
    }
#line 5552
    if ((int )linebuf[0] == 35) {
#line 5553
      goto while_continue;
    }
    {
#line 5554
    p = strchr((char const   *)(linebuf), '\n');
    }
#line 5555
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 5556
      *p = (char )'\000';
    }
    {
#line 5557
    p = get_column(linebuf, key_idx, (int )delim, buf___16, (int )sizeof(buf___16));
    }
#line 5558
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 5558
      tmp___0 = sm_strcasecmp((char const   *)(search_key), (char const   *)p);
      }
#line 5558
      if (tmp___0 == 0) {
#line 5560
        found_it = 1;
#line 5561
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5564
  sm_io_close(f, -2);
  }
#line 5565
  if (! found_it) {
#line 5567
    *statp = 68;
#line 5568
    return ((char *)((void *)0));
  }
  {
#line 5570
  vp = get_column(linebuf, (int )map___0->map_valcolno, (int )delim, buf___16, (int )sizeof(buf___16));
  }
#line 5571
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
#line 5573
    *statp = 68;
#line 5574
    return ((char *)((void *)0));
  }
  {
#line 5576
  tmp___2 = strlen((char const   *)vp);
#line 5576
  vsize = (int )tmp___2;
#line 5577
  *statp = 0;
  }
#line 5578
  if ((map___0->map_mflags & 16L) != 0L) {
    {
#line 5579
    tmp___3 = strlen((char const   *)name);
#line 5579
    tmp___4 = map_rewrite(map___0, (char const   *)name, tmp___3, (char **)((void *)0));
    }
#line 5579
    return (tmp___4);
  } else {
    {
#line 5581
    tmp___5 = map_rewrite(map___0, (char const   *)vp, (size_t )vsize, av___0);
    }
#line 5581
    return (tmp___5);
  }
}
}
#line 5588 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
static bool text_getcanonname(char *name , int hbsize , int *statp ) 
{ 
  bool found ;
  char *dot ;
  SM_FILE_T *f ;
  char linebuf[2048] ;
  char cbuf[257] ;
  char nbuf[257] ;
  size_t tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 5601
  if ((int )tTdvect[38] >= 20) {
    {
#line 5602
    sm_dprintf((char *)"text_getcanonname(%s)\n", name);
    }
  }
  {
#line 5604
  tmp = sm_strlcpy(nbuf, (char const   *)name, (ssize_t )sizeof(nbuf));
  }
#line 5604
  if ((unsigned long )tmp >= sizeof(nbuf)) {
#line 5606
    *statp = 69;
#line 5607
    return (0);
  }
  {
#line 5609
  dot = shorten_hostname(nbuf);
#line 5611
  f = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)HostsFile,
                 2, (void const   *)((void *)0));
  }
#line 5613
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 5615
    *statp = 69;
#line 5616
    return (0);
  }
#line 5618
  found = 0;
  {
#line 5619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5619
    if (! found) {
      {
#line 5619
      tmp___1 = sm_io_fgets(f, -2, linebuf, (int )sizeof(linebuf));
      }
#line 5619
      if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 5619
        goto while_break;
      }
    } else {
#line 5619
      goto while_break;
    }
    {
#line 5623
    tmp___0 = strpbrk((char const   *)(linebuf), "#\n");
#line 5623
    p = tmp___0;
    }
#line 5625
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 5626
      *p = (char )'\000';
    }
#line 5627
    if ((int )linebuf[0] != 0) {
      {
#line 5628
      found = extract_canonname(nbuf, dot, linebuf, cbuf, (int )sizeof(cbuf));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5631
  sm_io_close(f, -2);
  }
#line 5632
  if (! found) {
#line 5634
    *statp = 68;
#line 5635
    return (0);
  }
  {
#line 5638
  tmp___2 = sm_strlcpy(name, (char const   *)(cbuf), hbsize);
  }
#line 5638
  if (tmp___2 >= (size_t )hbsize) {
#line 5640
    *statp = 69;
#line 5641
    return (0);
  }
#line 5643
  *statp = 0;
#line 5644
  return (1);
}
}
#line 5656 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *stab_map_lookup(struct _map *map___0 , char *name , char **av___0 , int *pstat ) 
{ 
  register STAB *s ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp10 ;

  {
#line 5665
  if ((int )tTdvect[38] >= 20) {
    {
#line 5666
    sm_dprintf((char *)"stab_lookup(%s, %s)\n", map___0->map_mname, name);
    }
  }
  {
#line 5669
  s = stab(name, 4, 0);
  }
#line 5670
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 5671
    return ((char *)((void *)0));
  }
#line 5672
  if ((map___0->map_mflags & 16L) != 0L) {
    {
#line 5673
    tmp = strlen((char const   *)name);
#line 5673
    tmp___0 = map_rewrite(map___0, (char const   *)name, tmp, (char **)((void *)0));
    }
#line 5673
    return (tmp___0);
  } else {
    {
#line 5675
    tmp___1 = strlen((char const   *)s->s_value.sv_alias);
#line 5675
    tmp___2 = map_rewrite(map___0, (char const   *)s->s_value.sv_alias, tmp___1, av___0);
    }
#line 5675
    return (tmp___2);
  }
}
}
#line 5682 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
void stab_map_store(struct _map *map___0 , char *lhs , char *rhs ) 
{ 
  register STAB *s ;

  {
  {
#line 5690
  s = stab(lhs, 4, 1);
#line 5691
  s->s_value.sv_alias = newstr((char const   *)rhs);
  }
#line 5692
  return;
}
}
#line 5704 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool stab_map_open(struct _map *map___0 , int mode ) 
{ 
  SM_FILE_T *af ;
  long sff ;
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;

  {
#line 5713
  if ((int )tTdvect[38] >= 2) {
    {
#line 5714
    sm_dprintf((char *)"stab_map_open(%s, %s, %d)\n", map___0->map_mname, map___0->map_file,
               mode);
    }
  }
#line 5717
  mode &= 3;
#line 5718
  if (mode != 0) {
    {
#line 5720
    tmp = __errno_location();
#line 5720
    *tmp = 1;
    }
#line 5721
    return (0);
  }
#line 5724
  sff = 132L;
#line 5725
  if (! (DontBlameSendmail[13UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 13UL % (8UL * sizeof(int ))))) {
#line 5726
    sff |= 1024L;
  }
#line 5727
  if (! (DontBlameSendmail[8UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 8UL % (8UL * sizeof(int ))))) {
#line 5728
    sff |= 256L;
  }
  {
#line 5729
  af = safefopen(map___0->map_file, 0, 292, sff);
  }
#line 5730
  if ((unsigned long )af == (unsigned long )((void *)0)) {
#line 5731
    return (0);
  }
  {
#line 5732
  readaliases(map___0, af, 0, 0);
#line 5734
  tmp___0 = sm_io_getinfo(af, 3, (void *)0);
#line 5734
  tmp___1 = fstat(tmp___0, & st);
  }
#line 5734
  if (tmp___1 >= 0) {
#line 5735
    map___0->map_mtime = st.st_mtim.tv_sec;
  }
  {
#line 5736
  sm_io_close(af, -2);
  }
#line 5738
  return (1);
}
}
#line 5751 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *impl_map_lookup(struct _map *map___0 , char *name , char **av___0 , int *pstat ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 5758
  if ((int )tTdvect[38] >= 20) {
    {
#line 5759
    sm_dprintf((char *)"impl_map_lookup(%s, %s)\n", map___0->map_mname, name);
    }
  }
#line 5763
  if ((map___0->map_mflags & 4096L) != 0L) {
    {
#line 5764
    tmp = db_map_lookup(map___0, name, av___0, pstat);
    }
#line 5764
    return (tmp);
  }
  {
#line 5770
  tmp___0 = stab_map_lookup(map___0, name, av___0, pstat);
  }
#line 5770
  return (tmp___0);
}
}
#line 5777 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
void impl_map_store(struct _map *map___0 , char *lhs , char *rhs ) 
{ 
  char *__cil_tmp4 ;

  {
#line 5783
  if ((int )tTdvect[38] >= 12) {
    {
#line 5784
    sm_dprintf((char *)"impl_map_store(%s, %s, %s)\n", map___0->map_mname, lhs, rhs);
    }
  }
#line 5787
  if ((map___0->map_mflags & 4096L) != 0L) {
    {
#line 5788
    db_map_store(map___0, lhs, rhs);
    }
  }
  {
#line 5794
  stab_map_store(map___0, lhs, rhs);
  }
#line 5795
  return;
}
}
#line 5801 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool impl_map_open(struct _map *map___0 , int mode ) 
{ 
  bool tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 5806
  if ((int )tTdvect[38] >= 2) {
    {
#line 5807
    sm_dprintf((char *)"impl_map_open(%s, %s, %d)\n", map___0->map_mname, map___0->map_file,
               mode);
    }
  }
  {
#line 5810
  mode &= 3;
#line 5812
  map___0->map_mflags |= 4096L;
#line 5813
  tmp = hash_map_open(map___0, mode);
  }
#line 5813
  if (tmp) {
#line 5818
    return (1);
  } else {
#line 5821
    map___0->map_mflags &= -4097L;
  }
#line 5834
  if (Verbose) {
#line 5835
    if (mode == 0) {
#line 5835
      tmp___0 = "; reading text version";
    } else {
#line 5835
      tmp___0 = "";
    }
    {
#line 5835
    message("WARNING: cannot open alias database %s%s", map___0->map_file, tmp___0);
    }
  }
#line 5843
  if (mode == 0) {
    {
#line 5844
    tmp___1 = stab_map_open(map___0, mode);
    }
#line 5844
    return (tmp___1);
  } else {
#line 5846
    return (0);
  }
}
}
#line 5854 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
void impl_map_close(struct _map *map___0 ) 
{ 
  char *__cil_tmp2 ;

  {
#line 5858
  if ((int )tTdvect[38] >= 9) {
    {
#line 5859
    sm_dprintf((char *)"impl_map_close(%s, %s, %lx)\n", map___0->map_mname, map___0->map_file,
               map___0->map_mflags);
    }
  }
#line 5862
  if ((map___0->map_mflags & 4096L) != 0L) {
    {
#line 5864
    db_map_close(map___0);
#line 5865
    map___0->map_mflags &= -4097L;
    }
  }
#line 5876
  return;
}
}
#line 5889 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool user_map_open(struct _map *map___0 , int mode ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 5894
  if ((int )tTdvect[38] >= 2) {
    {
#line 5895
    sm_dprintf((char *)"user_map_open(%s, %d)\n", map___0->map_mname, mode);
    }
  }
#line 5898
  mode &= 3;
#line 5899
  if (mode != 0) {
    {
#line 5902
    tmp = __errno_location();
#line 5902
    *tmp = 38;
    }
#line 5903
    return (0);
  }
#line 5905
  if (! ((unsigned long )map___0->map_valcolnm == (unsigned long )((void *)0))) {
    {
#line 5908
    tmp___6 = sm_strcasecmp((char const   *)map___0->map_valcolnm, "name");
    }
#line 5908
    if (tmp___6 == 0) {
#line 5909
      map___0->map_valcolno = (unsigned char)1;
    } else {
      {
#line 5910
      tmp___5 = sm_strcasecmp((char const   *)map___0->map_valcolnm, "passwd");
      }
#line 5910
      if (tmp___5 == 0) {
#line 5911
        map___0->map_valcolno = (unsigned char)2;
      } else {
        {
#line 5912
        tmp___4 = sm_strcasecmp((char const   *)map___0->map_valcolnm, "uid");
        }
#line 5912
        if (tmp___4 == 0) {
#line 5913
          map___0->map_valcolno = (unsigned char)3;
        } else {
          {
#line 5914
          tmp___3 = sm_strcasecmp((char const   *)map___0->map_valcolnm, "gid");
          }
#line 5914
          if (tmp___3 == 0) {
#line 5915
            map___0->map_valcolno = (unsigned char)4;
          } else {
            {
#line 5916
            tmp___2 = sm_strcasecmp((char const   *)map___0->map_valcolnm, "gecos");
            }
#line 5916
            if (tmp___2 == 0) {
#line 5917
              map___0->map_valcolno = (unsigned char)5;
            } else {
              {
#line 5918
              tmp___1 = sm_strcasecmp((char const   *)map___0->map_valcolnm, "dir");
              }
#line 5918
              if (tmp___1 == 0) {
#line 5919
                map___0->map_valcolno = (unsigned char)6;
              } else {
                {
#line 5920
                tmp___0 = sm_strcasecmp((char const   *)map___0->map_valcolnm, "shell");
                }
#line 5920
                if (tmp___0 == 0) {
#line 5921
                  map___0->map_valcolno = (unsigned char)7;
                } else {
                  {
#line 5924
                  syserr("User map %s: unknown column name %s", map___0->map_mname,
                         map___0->map_valcolnm);
                  }
#line 5926
                  return (0);
                }
              }
            }
          }
        }
      }
    }
  }
#line 5928
  return (1);
}
}
#line 5937 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *user_map_lookup(struct _map *map___0 , char *key , char **av___0 , int *statp ) 
{ 
  bool fuzzy ;
  SM_MBDB_T user ;
  size_t tmp ;
  char *tmp___0 ;
  char *rwval ;
  char buf___16[30] ;
  size_t tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 5947
  if ((int )tTdvect[38] >= 20) {
    {
#line 5948
    sm_dprintf((char *)"user_map_lookup(%s, %s)\n", map___0->map_mname, key);
    }
  }
  {
#line 5951
  *statp = finduser(key, & fuzzy, & user);
  }
#line 5952
  if (*statp != 0) {
#line 5953
    return ((char *)((void *)0));
  }
#line 5954
  if ((map___0->map_mflags & 16L) != 0L) {
    {
#line 5955
    tmp = strlen((char const   *)key);
#line 5955
    tmp___0 = map_rewrite(map___0, (char const   *)key, tmp, (char **)((void *)0));
    }
#line 5955
    return (tmp___0);
  } else {
#line 5958
    rwval = (char *)((void *)0);
    {
#line 5964
    if ((int )map___0->map_valcolno == 1) {
#line 5964
      goto case_1;
    }
#line 5964
    if ((int )map___0->map_valcolno == 0) {
#line 5964
      goto case_1;
    }
#line 5968
    if ((int )map___0->map_valcolno == 2) {
#line 5968
      goto case_2;
    }
#line 5972
    if ((int )map___0->map_valcolno == 3) {
#line 5972
      goto case_3;
    }
#line 5978
    if ((int )map___0->map_valcolno == 4) {
#line 5978
      goto case_4;
    }
#line 5984
    if ((int )map___0->map_valcolno == 5) {
#line 5984
      goto case_5;
    }
#line 5988
    if ((int )map___0->map_valcolno == 6) {
#line 5988
      goto case_6;
    }
#line 5992
    if ((int )map___0->map_valcolno == 7) {
#line 5992
      goto case_7;
    }
#line 5961
    goto switch_break;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 5965
    rwval = user.mbdb_name;
#line 5966
    goto switch_break;
    case_2: /* CIL Label */ 
#line 5969
    rwval = (char *)"x";
#line 5970
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 5973
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%d", (int )user.mbdb_uid);
#line 5975
    rwval = buf___16;
    }
#line 5976
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 5979
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%d", (int )user.mbdb_gid);
#line 5981
    rwval = buf___16;
    }
#line 5982
    goto switch_break;
    case_5: /* CIL Label */ 
#line 5985
    rwval = user.mbdb_fullname;
#line 5986
    goto switch_break;
    case_6: /* CIL Label */ 
#line 5989
    rwval = user.mbdb_homedir;
#line 5990
    goto switch_break;
    case_7: /* CIL Label */ 
#line 5993
    rwval = user.mbdb_shell;
#line 5994
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 5996
    tmp___1 = strlen((char const   *)rwval);
#line 5996
    tmp___2 = map_rewrite(map___0, (char const   *)rwval, tmp___1, av___0);
    }
#line 5996
    return (tmp___2);
  }
}
}
#line 6007 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *prog_map_lookup(struct _map *map___0 , char *name , char **av___0 , int *statp ) 
{ 
  int i ;
  int save_errno ;
  int fd ;
  int status ;
  pid_t pid ;
  register char *p ;
  char *rval ;
  char *argv[257] ;
  char buf___16[2048] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  union __anonunion___u_83 __u ;
  union __anonunion___u_84 __u___0 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
#line 6024
  if ((int )tTdvect[38] >= 20) {
    {
#line 6025
    sm_dprintf((char *)"prog_map_lookup(%s, %s) %s\n", map___0->map_mname, name, map___0->map_file);
    }
  }
#line 6028
  i = 0;
#line 6029
  tmp = i;
#line 6029
  i ++;
#line 6029
  argv[tmp] = map___0->map_file;
#line 6030
  if ((unsigned long )map___0->map_rebuild != (unsigned long )((void *)0)) {
    {
#line 6032
    sm_strlcpy(buf___16, (char const   *)map___0->map_rebuild, (ssize_t )sizeof(buf___16));
#line 6033
    p = strtok((char */* __restrict  */)(buf___16), (char const   */* __restrict  */)" \t");
    }
    {
#line 6033
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6033
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 6033
        goto while_break;
      }
#line 6035
      if (i >= 255) {
#line 6036
        goto while_break;
      }
      {
#line 6037
      tmp___0 = i;
#line 6037
      i ++;
#line 6037
      argv[tmp___0] = p;
#line 6033
      p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t");
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 6040
  tmp___1 = i;
#line 6040
  i ++;
#line 6040
  argv[tmp___1] = name;
#line 6041
  argv[i] = (char *)((void *)0);
#line 6042
  if ((int )tTdvect[38] >= 21) {
    {
#line 6044
    sm_dprintf((char *)"prog_open:");
#line 6045
    i = 0;
    }
    {
#line 6045
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6045
      if (! ((unsigned long )argv[i] != (unsigned long )((void *)0))) {
#line 6045
        goto while_break___0;
      }
      {
#line 6046
      sm_dprintf((char *)" %s", argv[i]);
#line 6045
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 6047
    sm_dprintf((char *)"\n");
    }
  }
  {
#line 6049
  sm_blocksignal(17);
#line 6050
  pid = prog_open(argv, & fd, CurEnv);
  }
#line 6051
  if (pid < 0) {
#line 6053
    if (! ((map___0->map_mflags & 4L) != 0L)) {
      {
#line 6054
      tmp___2 = __errno_location();
#line 6054
      tmp___3 = sm_errstring(*tmp___2);
#line 6054
      syserr("prog_map_lookup(%s) failed (%s) -- closing", map___0->map_mname, tmp___3);
      }
    } else
#line 6056
    if ((int )tTdvect[38] >= 9) {
      {
#line 6057
      tmp___4 = __errno_location();
#line 6057
      tmp___5 = sm_errstring(*tmp___4);
#line 6057
      sm_dprintf((char *)"prog_map_lookup(%s) failed (%s) -- closing", map___0->map_mname,
                 tmp___5);
      }
    }
#line 6059
    map___0->map_mflags &= -34L;
#line 6060
    *statp = 72;
#line 6061
    return ((char *)((void *)0));
  }
  {
#line 6063
  i = read(fd, (void *)(buf___16), (size_t )(sizeof(buf___16) - 1UL));
  }
#line 6064
  if (i < 0) {
    {
#line 6066
    tmp___6 = __errno_location();
#line 6066
    tmp___7 = sm_errstring(*tmp___6);
#line 6066
    syserr("prog_map_lookup(%s): read error %s", map___0->map_mname, tmp___7);
#line 6068
    rval = (char *)((void *)0);
    }
  } else
#line 6070
  if (i == 0) {
#line 6072
    if ((int )tTdvect[38] >= 20) {
      {
#line 6073
      sm_dprintf((char *)"prog_map_lookup(%s): empty answer\n", map___0->map_mname);
      }
    }
#line 6075
    rval = (char *)((void *)0);
  } else {
    {
#line 6079
    buf___16[i] = (char )'\000';
#line 6080
    p = strchr((char const   *)(buf___16), '\n');
    }
#line 6081
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 6082
      *p = (char )'\000';
    }
#line 6085
    if ((map___0->map_mflags & 16L) != 0L) {
      {
#line 6086
      tmp___8 = strlen((char const   *)name);
#line 6086
      rval = map_rewrite(map___0, (char const   *)name, tmp___8, (char **)((void *)0));
      }
    } else {
      {
#line 6088
      tmp___9 = strlen((char const   *)(buf___16));
#line 6088
      rval = map_rewrite(map___0, (char const   *)(buf___16), tmp___9, av___0);
      }
    }
    {
#line 6091
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 6091
      i = read(fd, (void *)(buf___16), (size_t )sizeof(buf___16));
      }
#line 6091
      if (! (i > 0)) {
#line 6091
        goto while_break___1;
      }
#line 6092
      goto while_continue___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 6096
  close(fd);
#line 6097
  status = waitfor(pid);
#line 6098
  tmp___10 = __errno_location();
#line 6098
  save_errno = *tmp___10;
#line 6099
  sm_releasesignal(17);
#line 6100
  tmp___11 = __errno_location();
#line 6100
  *tmp___11 = save_errno;
  }
#line 6102
  if (status == -1) {
    {
#line 6104
    tmp___12 = __errno_location();
#line 6104
    tmp___13 = sm_errstring(*tmp___12);
#line 6104
    syserr("prog_map_lookup(%s): wait error %s", map___0->map_mname, tmp___13);
#line 6106
    *statp = 70;
#line 6107
    rval = (char *)((void *)0);
    }
  } else {
#line 6109
    __u___0.__in = status;
#line 6109
    if ((__u___0.__i & 127) == 0) {
#line 6111
      __u.__in = status;
#line 6111
      tmp___14 = (__u.__i & 65280) >> 8;
#line 6111
      *statp = tmp___14;
#line 6111
      if (tmp___14 != 0) {
#line 6112
        rval = (char *)((void *)0);
      }
    } else {
      {
#line 6116
      syserr("prog_map_lookup(%s): child died on signal %d", map___0->map_mname, status);
#line 6118
      *statp = 69;
#line 6119
      rval = (char *)((void *)0);
      }
    }
  }
#line 6121
  return (rval);
}
}
#line 6144 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool seq_map_parse(struct _map *map___0 , char *ap ) 
{ 
  int maxmap ;
  register char *p ;
  STAB *s ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 6151
  if ((int )tTdvect[38] >= 2) {
    {
#line 6152
    sm_dprintf((char *)"seq_map_parse(%s, %s)\n", map___0->map_mname, ap);
    }
  }
#line 6153
  maxmap = 0;
  {
#line 6154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6154
    if (! ((int )*ap != 0)) {
#line 6154
      goto while_break;
    }
    {
#line 6160
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6160
      if (((int )*ap & -128) == 0) {
        {
#line 6160
        tmp = __ctype_b_loc();
        }
#line 6160
        if (! ((int const   )*(*tmp + (int )*ap) & 8192)) {
#line 6160
          goto while_break___0;
        }
      } else {
#line 6160
        goto while_break___0;
      }
#line 6161
      ap ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6162
    p = ap;
    {
#line 6162
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 6162
      if (((int )*p & -128) == 0) {
        {
#line 6162
        tmp___0 = __ctype_b_loc();
        }
#line 6162
        if (! ((int const   )*(*tmp___0 + (int )*p) & 8)) {
#line 6162
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 6162
      if (! ((int )*p == 95)) {
#line 6162
        if (! ((int )*p == 46)) {
#line 6162
          goto while_break___1;
        }
      }
#line 6165
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 6162
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 6166
    if ((int )*p != 0) {
#line 6167
      tmp___1 = p;
#line 6167
      p ++;
#line 6167
      *tmp___1 = (char )'\000';
    }
    {
#line 6168
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6168
      if ((int )*p != 0) {
#line 6168
        if (! (! (((int )*p & -128) == 0))) {
          {
#line 6168
          tmp___2 = __ctype_b_loc();
          }
#line 6168
          if ((int const   )*(*tmp___2 + (int )*p) & 8) {
#line 6168
            goto while_break___2;
          }
        }
      } else {
#line 6168
        goto while_break___2;
      }
#line 6169
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 6170
    if ((int )*ap == 0) {
#line 6172
      ap = p;
#line 6173
      goto while_continue;
    }
    {
#line 6175
    s = stab(ap, 6, 0);
    }
#line 6176
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
#line 6178
      syserr("Sequence map %s: unknown member map %s", map___0->map_mname, ap);
      }
    } else
#line 6181
    if (maxmap >= 12) {
      {
#line 6183
      syserr("Sequence map %s: too many member maps (%d max)", map___0->map_mname,
             12);
#line 6185
      maxmap ++;
      }
    } else
#line 6187
    if (maxmap < 12) {
#line 6189
      tmp___3 = maxmap;
#line 6189
      maxmap ++;
#line 6189
      map___0->map_stack[tmp___3] = & s->s_value.sv_map;
    }
#line 6191
    ap = p;
  }
  while_break: /* CIL Label */ ;
  }
#line 6193
  return (1);
}
}
#line 6207 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool switch_map_open(struct _map *map___0 , int mode ) 
{ 
  int mapno ;
  int nmaps ;
  char *maptype[12] ;
  register STAB *s ;
  char nbuf[257] ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 6216
  if ((int )tTdvect[38] >= 2) {
    {
#line 6217
    sm_dprintf((char *)"switch_map_open(%s, %s, %d)\n", map___0->map_mname, map___0->map_file,
               mode);
    }
  }
  {
#line 6220
  mode &= 3;
#line 6221
  nmaps = switch_map_find(map___0->map_file, maptype, map___0->map_return);
  }
#line 6222
  if ((int )tTdvect[38] >= 19) {
    {
#line 6224
    sm_dprintf((char *)"\tswitch_map_find => %d\n", nmaps);
#line 6225
    mapno = 0;
    }
    {
#line 6225
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6225
      if (! (mapno < nmaps)) {
#line 6225
        goto while_break;
      }
      {
#line 6226
      sm_dprintf((char *)"\t\t%s\n", maptype[mapno]);
#line 6225
      mapno ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 6228
  if (nmaps <= 0) {
#line 6229
    return (0);
  } else
#line 6228
  if (nmaps > 12) {
#line 6229
    return (0);
  }
#line 6231
  mapno = 0;
  {
#line 6231
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6231
    if (! (mapno < nmaps)) {
#line 6231
      goto while_break___0;
    }
#line 6236
    if ((unsigned long )maptype[mapno] == (unsigned long )((void *)0)) {
#line 6237
      goto __Cont;
    }
    {
#line 6238
    sm_strlcpyn(nbuf, (ssize_t )sizeof(nbuf), 3, map___0->map_mname, ".", maptype[mapno]);
#line 6240
    s = stab(nbuf, 6, 0);
    }
#line 6241
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
#line 6243
      syserr("Switch map %s: unknown member map %s", map___0->map_mname, nbuf);
      }
    } else {
#line 6248
      map___0->map_stack[mapno] = & s->s_value.sv_map;
#line 6249
      if ((int )tTdvect[38] >= 4) {
        {
#line 6250
        sm_dprintf((char *)"\tmap_stack[%d] = %s:%s\n", mapno, (s->s_value.sv_map.map_class)->map_cname,
                   nbuf);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 6231
    mapno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6256
  return (1);
}
}
#line 6290 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *seq_map_lookup(struct _map *map___0 , char *key , char **args , int *pstat ) 
{ 
  int mapno ;
  int mapbit ;
  bool tempfail ;
  struct _map *mm ;
  char *rv ;
  bool tmp ;
  char *__cil_tmp11 ;

  {
#line 6298
  mapbit = 1;
#line 6299
  tempfail = 0;
#line 6301
  if ((int )tTdvect[38] >= 20) {
    {
#line 6302
    sm_dprintf((char *)"seq_map_lookup(%s, %s)\n", map___0->map_mname, key);
    }
  }
#line 6304
  mapno = 0;
  {
#line 6304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6304
    if (! (mapno < 12)) {
#line 6304
      goto while_break;
    }
#line 6306
    mm = map___0->map_stack[mapno];
#line 6309
    if ((unsigned long )mm == (unsigned long )((void *)0)) {
#line 6310
      goto __Cont;
    }
#line 6311
    if (! ((mm->map_mflags & 32L) != 0L)) {
      {
#line 6311
      tmp = openmap(mm);
      }
#line 6311
      if (! tmp) {
#line 6314
        if (((int )map___0->map_return[1] & mapbit) != 0) {
#line 6316
          *pstat = 69;
#line 6317
          return ((char *)((void *)0));
        }
#line 6319
        goto __Cont;
      }
    }
    {
#line 6321
    *pstat = 0;
#line 6322
    rv = (*((mm->map_class)->map_lookup))(mm, key, args, pstat);
    }
#line 6323
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 6324
      return (rv);
    }
#line 6325
    if (*pstat == 75) {
#line 6327
      if (((int )map___0->map_return[2] & mapbit) != 0) {
#line 6328
        return ((char *)((void *)0));
      }
#line 6329
      tempfail = 1;
    } else
#line 6331
    if (((int )map___0->map_return[0] & mapbit) != 0) {
#line 6332
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 6304
    mapbit <<= 1;
#line 6304
    mapno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6334
  if (tempfail) {
#line 6335
    *pstat = 75;
  } else
#line 6336
  if (*pstat == 0) {
#line 6337
    *pstat = 68;
  }
#line 6338
  return ((char *)((void *)0));
}
}
#line 6345 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
void seq_map_store(struct _map *map___0 , char *key , char *val ) 
{ 
  int mapno ;
  struct _map *mm ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 6353
  if ((int )tTdvect[38] >= 12) {
    {
#line 6354
    sm_dprintf((char *)"seq_map_store(%s, %s, %s)\n", map___0->map_mname, key, val);
    }
  }
#line 6357
  mapno = 0;
  {
#line 6357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6357
    if (! (mapno < 12)) {
#line 6357
      goto while_break;
    }
#line 6359
    mm = map___0->map_stack[mapno];
#line 6361
    if ((unsigned long )mm == (unsigned long )((void *)0)) {
#line 6362
      goto __Cont;
    } else
#line 6361
    if (! ((mm->map_mflags & 64L) != 0L)) {
#line 6362
      goto __Cont;
    }
    {
#line 6364
    (*((mm->map_class)->map_store))(mm, key, val);
    }
#line 6365
    return;
    __Cont: /* CIL Label */ 
#line 6357
    mapno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6367
  syserr("seq_map_store(%s, %s, %s): no writable map", map___0->map_mname, key, val);
  }
#line 6369
  return;
}
}
#line 6375 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
bool null_map_open(struct _map *map___0 , int mode ) 
{ 


  {
#line 6380
  return (1);
}
}
#line 6384 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
void null_map_close(struct _map *map___0 ) 
{ 


  {
#line 6388
  return;
}
}
#line 6391 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *null_map_lookup(struct _map *map___0 , char *key , char **args , int *pstat ) 
{ 


  {
#line 6398
  *pstat = 68;
#line 6399
  return ((char *)((void *)0));
}
}
#line 6403 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
void null_map_store(struct _map *map___0 , char *key , char *val ) 
{ 


  {
#line 6409
  return;
}
}
#line 6416 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *bogus_map_lookup(struct _map *map___0 , char *key , char **args , int *pstat ) 
{ 


  {
#line 6423
  *pstat = 75;
#line 6424
  return ((char *)((void *)0));
}
}
#line 6427 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
struct _mapclass BogusMapClass  = 
#line 6427
     {(char *)"bogus-map", (char *)((void *)0), (short)0, (bool (*)(struct _map * ,
                                                                  char * ))((void *)0),
    & bogus_map_lookup, & null_map_store, & null_map_open, & null_map_close};
#line 6437 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *macro_map_lookup(struct _map *map___0 , char *name , char **av___0 , int *statp ) 
{ 
  int mid ;
  char const   *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 6446
  if ((int )tTdvect[38] >= 20) {
#line 6447
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 6447
      tmp = "NULL";
    } else {
#line 6447
      tmp = (char const   *)name;
    }
    {
#line 6447
    sm_dprintf((char *)"macro_map_lookup(%s, %s)\n", map___0->map_mname, tmp);
    }
  }
#line 6450
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 6454
    *statp = 78;
#line 6455
    return ((char *)((void *)0));
  } else
#line 6450
  if ((int )*name == 0) {
#line 6454
    *statp = 78;
#line 6455
    return ((char *)((void *)0));
  } else {
    {
#line 6450
    mid = macid_parse(name, (char **)((void *)0));
    }
#line 6450
    if (mid == 0) {
#line 6454
      *statp = 78;
#line 6455
      return ((char *)((void *)0));
    }
  }
#line 6458
  if ((unsigned long )*(av___0 + 1) == (unsigned long )((void *)0)) {
    {
#line 6459
    macdefine_tagged(& CurEnv->e_macro, (ARGCLASS_T )2, mid, (char *)((void *)0),
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c",
                     6459, SmHeapGroup);
    }
  } else {
    {
#line 6461
    macdefine_tagged(& CurEnv->e_macro, (ARGCLASS_T )1, mid, *(av___0 + 1), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c",
                     6461, SmHeapGroup);
    }
  }
#line 6463
  *statp = 0;
#line 6464
  return ((char *)"");
}
}
#line 6968 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
static char result[16]  ;
#line 6957 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/map.c"
char *arith_map_lookup(struct _map *map___0 , char *name , char **av___0 , int *statp ) 
{ 
  long r ;
  long v[2] ;
  bool res ;
  bool boolres ;
  char **cpp ;
  long tmp ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 6966
  res = 0;
#line 6971
  if ((int )tTdvect[38] >= 2) {
    {
#line 6973
    sm_dprintf((char *)"arith_map_lookup: key \'%s\'\n", name);
#line 6974
    cpp = av___0;
    }
    {
#line 6974
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6974
      if ((unsigned long )cpp != (unsigned long )((void *)0)) {
#line 6974
        if (! ((unsigned long )*cpp != (unsigned long )((void *)0))) {
#line 6974
          goto while_break;
        }
      } else {
#line 6974
        goto while_break;
      }
      {
#line 6975
      sm_dprintf((char *)"arith_map_lookup: arg \'%s\'\n", *cpp);
#line 6974
      cpp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 6977
  r = 0L;
#line 6978
  boolres = 0;
#line 6979
  cpp = av___0;
#line 6980
  *statp = 0;
#line 6988
  cpp ++;
  {
#line 6988
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6988
    if ((unsigned long )cpp != (unsigned long )((void *)0)) {
#line 6988
      if ((unsigned long )*cpp != (unsigned long )((void *)0)) {
#line 6988
        if (! (r < 2L)) {
#line 6988
          goto while_break___0;
        }
      } else {
#line 6988
        goto while_break___0;
      }
    } else {
#line 6988
      goto while_break___0;
    }
    {
#line 6989
    tmp = r;
#line 6989
    r ++;
#line 6989
    v[tmp] = strtol((char const   */* __restrict  */)*cpp, (char **/* __restrict  */)((void *)0),
                    0);
#line 6988
    cpp ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6992
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 6992
    if (r == 2L) {
      {
#line 6996
      if ((int )*name == 124) {
#line 6996
        goto case_124;
      }
#line 7000
      if ((int )*name == 38) {
#line 7000
        goto case_38;
      }
#line 7004
      if ((int )*name == 37) {
#line 7004
        goto case_37;
      }
#line 7009
      if ((int )*name == 43) {
#line 7009
        goto case_43;
      }
#line 7013
      if ((int )*name == 45) {
#line 7013
        goto case_45;
      }
#line 7017
      if ((int )*name == 42) {
#line 7017
        goto case_42;
      }
#line 7021
      if ((int )*name == 47) {
#line 7021
        goto case_47;
      }
#line 7027
      if ((int )*name == 108) {
#line 7027
        goto case_108;
      }
#line 7032
      if ((int )*name == 61) {
#line 7032
        goto case_61;
      }
#line 7037
      goto switch_default;
      case_124: /* CIL Label */ 
#line 6997
      r = v[0] | v[1];
#line 6998
      goto switch_break;
      case_38: /* CIL Label */ 
#line 7001
      r = v[0] & v[1];
#line 7002
      goto switch_break;
      case_37: /* CIL Label */ 
#line 7005
      if (v[1] == 0L) {
#line 7006
        return ((char *)((void *)0));
      }
#line 7007
      r = v[0] % v[1];
#line 7008
      goto switch_break;
      case_43: /* CIL Label */ 
#line 7010
      r = v[0] + v[1];
#line 7011
      goto switch_break;
      case_45: /* CIL Label */ 
#line 7014
      r = v[0] - v[1];
#line 7015
      goto switch_break;
      case_42: /* CIL Label */ 
#line 7018
      r = v[0] * v[1];
#line 7019
      goto switch_break;
      case_47: /* CIL Label */ 
#line 7022
      if (v[1] == 0L) {
#line 7023
        return ((char *)((void *)0));
      }
#line 7024
      r = v[0] / v[1];
#line 7025
      goto switch_break;
      case_108: /* CIL Label */ 
#line 7028
      res = v[0] < v[1];
#line 7029
      boolres = 1;
#line 7030
      goto switch_break;
      case_61: /* CIL Label */ 
#line 7033
      res = v[0] == v[1];
#line 7034
      boolres = 1;
#line 7035
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 7039
      *statp = 78;
#line 7040
      if (LogLevel > 10) {
        {
#line 7041
        tmp___2 = __ctype_b_loc();
        }
#line 7041
        if ((int const   )*(*tmp___2 + (int )*name) & 16384) {
#line 7041
          tmp___1 = (int )*name;
        } else {
#line 7041
          tmp___1 = '?';
        }
        {
#line 7041
        sm_syslog(4, "*~*", "arith_map: unknown operator %c", tmp___1);
        }
      }
#line 7044
      return ((char *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
#line 7046
      if (boolres) {
#line 7047
        if (res) {
#line 7047
          tmp___3 = "TRUE";
        } else {
#line 7047
          tmp___3 = "FALSE";
        }
        {
#line 7047
        sm_snprintf(result, (size_t )sizeof(result), tmp___3);
        }
      } else {
        {
#line 7050
        sm_snprintf(result, (size_t )sizeof(result), "%ld", r);
        }
      }
#line 7051
      return (result);
    }
  }
#line 7053
  *statp = 78;
#line 7054
  return ((char *)((void *)0));
}
}
#line 632 "./sendmail.h"
MACROS_T GlobalMacros ;
#line 2219
int MaxMacroRecursion ;
#line 2508
void initmacros(ENVELOPE *e ) ;
#line 22 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
static char *MacroName[256]  ;
#line 23 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
int NextMacroId  =    160;
#line 41 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
struct metamac MetaMacros[18]  = 
#line 41
  {      {(char )'*', (unsigned char)144}, 
        {(char )'+', (unsigned char)145}, 
        {(char )'-', (unsigned char)146}, 
        {(char )'=', (unsigned char)147}, 
        {(char )'~', (unsigned char)148}, 
        {(char )'#', (unsigned char)150}, 
        {(char )'@', (unsigned char)151}, 
        {(char )':', (unsigned char)152}, 
        {(char )'>', (unsigned char)153}, 
        {(char )'?', (unsigned char)154}, 
        {(char )'|', (unsigned char)155}, 
        {(char )'.', (unsigned char)156}, 
        {(char )'[', (unsigned char)157}, 
        {(char )']', (unsigned char)158}, 
        {(char )'(', (unsigned char)133}, 
        {(char )')', (unsigned char)134}, 
        {(char )'&', (unsigned char)130}, 
        {(char )'\000', (unsigned char )'\000'}};
#line 68 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
void initmacros(ENVELOPE *e ) 
{ 
  register struct metamac *m ;
  register int c ;
  char buf___16[5] ;
  STAB *tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 76
  m = MetaMacros;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((int )m->metaname != 0)) {
#line 76
      goto while_break;
    }
    {
#line 78
    buf___16[0] = (char )m->metaval;
#line 79
    buf___16[1] = (char )'\000';
#line 80
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, (int )m->metaname, buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c",
                     80, SmHeapGroup);
#line 76
    m ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  buf___16[0] = (char)-107;
#line 83
  buf___16[2] = (char )'\000';
#line 84
  c = '0';
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (c <= 57)) {
#line 84
      goto while_break___0;
    }
    {
#line 86
    buf___16[1] = (char )c;
#line 87
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, c, buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c",
                     87, SmHeapGroup);
#line 84
    c ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 91
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'n', (char *)"MAILER-DAEMON", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c",
                   91, SmHeapGroup);
#line 94
  tmp = stab((char *)"opMode", 9, 1);
#line 94
  tmp->s_value.sv_macro = 130;
#line 94
  MacroName[130] = (char *)"opMode";
  }
#line 96
  return;
}
}
#line 128 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
static int explevel  =    0;
#line 113 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
void expand(char *s , char *buf___16 , size_t bufsize , ENVELOPE *e ) 
{ 
  register char *xp ;
  register char *q ;
  bool skipping ;
  bool recurse ;
  size_t i ;
  int skiplev ;
  int iflev ;
  char xbuf[4096] ;
  SM_FILE_T *tmp ;
  int c ;
  char *mv ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  SM_FILE_T *tmp___4 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 130
  if ((int )tTdvect[35] >= 24) {
    {
#line 132
    sm_dprintf((char *)"expand(");
#line 133
    tmp = sm_debug_file();
#line 133
    xputs(tmp, (char const   *)s);
#line 134
    sm_dprintf((char *)")\n");
    }
  }
#line 137
  recurse = 0;
#line 138
  skipping = 0;
#line 139
  skiplev = 0;
#line 140
  iflev = 0;
#line 141
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 142
    s = (char *)"";
  }
#line 143
  xp = xbuf;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((int )*s != 0)) {
#line 143
      goto while_break;
    }
#line 152
    q = (char *)((void *)0);
#line 153
    c = (int )*s;
    {
#line 156
    if ((c & 255) == 154) {
#line 156
      goto case_154;
    }
#line 170
    if ((c & 255) == 155) {
#line 170
      goto case_155;
    }
#line 177
    if ((c & 255) == 156) {
#line 177
      goto case_156;
    }
#line 187
    if ((c & 255) == 129) {
#line 187
      goto case_129;
    }
#line 154
    goto switch_break;
    case_154: /* CIL Label */ 
#line 157
    iflev ++;
#line 158
    s ++;
#line 158
    c = (int )*s;
#line 159
    if (skipping) {
#line 160
      skiplev ++;
    } else {
      {
#line 165
      mv = macvalue(c, e);
      }
#line 166
      if ((unsigned long )mv == (unsigned long )((void *)0)) {
#line 166
        tmp___0 = 1;
      } else
#line 166
      if ((int )*mv == 0) {
#line 166
        tmp___0 = 1;
      } else {
#line 166
        tmp___0 = 0;
      }
#line 166
      skipping = tmp___0;
    }
#line 168
    goto __Cont;
    case_155: /* CIL Label */ 
#line 171
    if (iflev == 0) {
#line 172
      goto switch_break;
    }
#line 173
    if (skiplev == 0) {
#line 174
      skipping = ! skipping;
    }
#line 175
    goto __Cont;
    case_156: /* CIL Label */ 
#line 178
    if (iflev == 0) {
#line 179
      goto switch_break;
    }
#line 180
    iflev --;
#line 181
    if (skiplev == 0) {
#line 182
      skipping = 0;
    }
#line 183
    if (skipping) {
#line 184
      skiplev --;
    }
#line 185
    goto __Cont;
    case_129: /* CIL Label */ 
#line 188
    s ++;
#line 188
    c = (int )((unsigned int )*s & 255U);
#line 189
    if (c != 0) {
      {
#line 190
      q = macvalue(c, e);
      }
    } else {
#line 193
      s --;
#line 194
      q = (char *)((void *)0);
    }
#line 196
    if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 197
      goto __Cont;
    }
#line 198
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 205
    if (skipping) {
#line 206
      goto __Cont;
    } else
#line 205
    if ((unsigned long )xp >= (unsigned long )(& xbuf[sizeof(xbuf) - 1UL])) {
#line 206
      goto __Cont;
    }
#line 207
    if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 208
      tmp___1 = xp;
#line 208
      xp ++;
#line 208
      *tmp___1 = (char )c;
    } else {
      {
#line 212
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 212
        tmp___3 = q;
#line 212
        q ++;
#line 212
        c = (int )*tmp___3;
#line 212
        if (c != 0) {
#line 212
          if (! ((unsigned long )xp < (unsigned long )(& xbuf[sizeof(xbuf) - 1UL]))) {
#line 212
            goto while_break___0;
          }
        } else {
#line 212
          goto while_break___0;
        }
#line 215
        if ((c & 224) == 128) {
#line 216
          recurse = 1;
        }
#line 217
        tmp___2 = xp;
#line 217
        xp ++;
#line 217
        *tmp___2 = (char )c;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 143
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  *xp = (char )'\000';
#line 223
  if ((int )tTdvect[35] >= 24) {
    {
#line 225
    sm_dprintf((char *)"expand ==> ");
#line 226
    tmp___4 = sm_debug_file();
#line 226
    xputs(tmp___4, (char const   *)(xbuf));
#line 227
    sm_dprintf((char *)"\n");
    }
  }
#line 231
  if (recurse) {
#line 233
    if (explevel < MaxMacroRecursion) {
      {
#line 235
      explevel ++;
#line 236
      expand(xbuf, buf___16, bufsize, e);
#line 237
      explevel --;
      }
#line 238
      return;
    }
    {
#line 240
    syserr("expand: recursion too deep (%d max)", MaxMacroRecursion);
    }
  }
#line 245
  i = (size_t )(xp - xbuf);
#line 246
  if (i >= bufsize) {
#line 247
    i = bufsize - 1U;
  }
  {
#line 248
  memmove((void *)buf___16, (void const   *)(xbuf), i);
#line 249
  *(buf___16 + i) = (char )'\000';
  }
#line 250
  return;
}
}
#line 283 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
void macdefine_tagged(MACROS_T *mac , ARGCLASS_T vclass , int id , char *value , char *file ,
                      int line , int grp ) 
{ 
  char *newvalue ;
  char *tmp ;
  char const   *tmp___0 ;
  SM_FILE_T *tmp___1 ;
  char *freeit ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 301
  if (id < 0) {
#line 302
    return;
  } else
#line 301
  if (id > 255) {
#line 302
    return;
  }
#line 304
  if ((int )tTdvect[35] >= 9) {
    {
#line 306
    tmp = macname(id);
    }
#line 306
    if ((unsigned long )mac->mac_table[id] == (unsigned long )((void *)0)) {
#line 306
      tmp___0 = "";
    } else {
#line 306
      tmp___0 = "re";
    }
    {
#line 306
    sm_dprintf((char *)"%sdefine(%s as ", tmp___0, tmp);
#line 308
    tmp___1 = sm_debug_file();
#line 308
    xputs(tmp___1, (char const   *)value);
#line 309
    sm_dprintf((char *)")\n");
    }
  }
#line 312
  if ((unsigned long )mac->mac_rpool == (unsigned long )((void *)0)) {
#line 314
    freeit = (char *)((void *)0);
#line 316
    if ((unsigned long )mac->mac_table[id] != (unsigned long )((void *)0)) {
#line 316
      if (mac->mac_allocated[(unsigned long )((unsigned char )id) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )id) % (8UL * sizeof(int )))) {
#line 318
        freeit = mac->mac_table[id];
      }
    }
#line 320
    if ((unsigned long )value == (unsigned long )((void *)0)) {
      {
#line 322
      sm_heap_checkptr_tagged((void *)value, file, line);
#line 323
      newvalue = value;
#line 324
      mac->mac_allocated[(unsigned long )((unsigned char )id) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] &= ~ (1U << (unsigned long )((unsigned char )id) % (8UL * sizeof(int )));
      }
    } else
#line 320
    if ((unsigned int )vclass == 0U) {
      {
#line 322
      sm_heap_checkptr_tagged((void *)value, file, line);
#line 323
      newvalue = value;
#line 324
      mac->mac_allocated[(unsigned long )((unsigned char )id) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] &= ~ (1U << (unsigned long )((unsigned char )id) % (8UL * sizeof(int )));
      }
    } else {
      {
#line 329
      newvalue = sm_strdup_tagged_x((char const   *)value, file, line, 0);
#line 333
      mac->mac_allocated[(unsigned long )((unsigned char )id) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )id) % (8UL * sizeof(int ));
      }
    }
#line 335
    mac->mac_table[id] = newvalue;
#line 336
    if ((unsigned long )freeit != (unsigned long )((void *)0)) {
      {
#line 337
      sm_free_tagged((void *)freeit, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c",
                     337);
      }
    }
  } else {
#line 341
    if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 342
      newvalue = value;
    } else
#line 341
    if ((unsigned int )vclass == 2U) {
#line 342
      newvalue = value;
    } else {
      {
#line 344
      newvalue = sm_rpool_strdup_x(mac->mac_rpool, (char const   *)value);
      }
    }
#line 345
    mac->mac_table[id] = newvalue;
#line 346
    if ((unsigned int )vclass == 0U) {
      {
#line 347
      sm_free_tagged((void *)value, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c",
                     347);
      }
    }
  }
#line 358
  return;
}
}
#line 372 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
void macset(MACROS_T *mac , int i , char *value ) 
{ 
  char *tmp ;
  SM_FILE_T *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 378
  if (i < 0) {
#line 379
    return;
  } else
#line 378
  if (i > 255) {
#line 379
    return;
  }
#line 381
  if ((int )tTdvect[35] >= 9) {
    {
#line 383
    tmp = macname(i);
#line 383
    sm_dprintf((char *)"macset(%s as ", tmp);
#line 384
    tmp___0 = sm_debug_file();
#line 384
    xputs(tmp___0, (char const   *)value);
#line 385
    sm_dprintf((char *)")\n");
    }
  }
#line 387
  mac->mac_table[i] = value;
#line 388
  return;
}
}
#line 407 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
char *macvalue(int n , ENVELOPE *e ) 
{ 
  register char *p ;
  register char *p___0 ;

  {
#line 412
  n = (int )((unsigned int )n & 255U);
#line 413
  if ((unsigned long )e != (unsigned long )((void *)0)) {
#line 413
    if ((unsigned long )e->e_mci != (unsigned long )((void *)0)) {
#line 415
      p = (e->e_mci)->mci_macro.mac_table[n];
#line 417
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 418
        return (p);
      }
    }
  }
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 420
      goto while_break;
    }
#line 422
    p___0 = e->e_macro.mac_table[n];
#line 424
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
#line 425
      return (p___0);
    }
#line 426
    if ((unsigned long )e == (unsigned long )e->e_parent) {
#line 427
      goto while_break;
    }
#line 428
    e = e->e_parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  return (GlobalMacros.mac_table[n]);
}
}
#line 449 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
static char mbuf[2]  ;
#line 445 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
char *macname(int n ) 
{ 
  char *p ;
  char *__cil_tmp3 ;

  {
#line 451
  n = (int )((unsigned int )n & 255U);
#line 452
  if ((n & 128) != 0) {
#line 454
    p = MacroName[n];
#line 456
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 457
      return (p);
    }
#line 458
    return ((char *)"***UNDEFINED MACRO***");
  }
#line 460
  mbuf[0] = (char )n;
#line 461
  mbuf[1] = (char )'\000';
#line 462
  return (mbuf);
}
}
#line 482 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
int macid_parse(char *p , char **ep ) 
{ 
  int mid ;
  register char *bp___3 ;
  char mbuf___0[26] ;
  SM_FILE_T *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  register STAB *s ;
  int tmp___2 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 491
  if ((int )tTdvect[35] >= 14) {
    {
#line 493
    sm_dprintf((char *)"macid(");
#line 494
    tmp = sm_debug_file();
#line 494
    xputs(tmp, (char const   *)p);
#line 495
    sm_dprintf((char *)") => ");
    }
  }
#line 498
  if ((int )*p == 0) {
#line 498
    goto _L;
  } else
#line 498
  if ((int )*(p + 0) == 123) {
#line 498
    if ((int )*(p + 1) == 125) {
      _L: /* CIL Label */ 
      {
#line 500
      syserr("Name required for macro/class");
      }
#line 501
      if ((unsigned long )ep != (unsigned long )((void *)0)) {
#line 502
        *ep = p;
      }
#line 503
      if ((int )tTdvect[35] >= 14) {
        {
#line 504
        sm_dprintf((char *)"NULL\n");
        }
      }
#line 505
      return (0);
    }
  }
#line 507
  if ((int )*p != 123) {
#line 510
    if ((unsigned long )ep != (unsigned long )((void *)0)) {
#line 511
      *ep = p + 1;
    }
#line 512
    if ((int )tTdvect[35] >= 14) {
      {
#line 513
      sm_dprintf((char *)"%c\n", (unsigned int )*p & 255U);
      }
    }
#line 514
    return ((int )((unsigned int )*p & 255U));
  }
#line 516
  bp___3 = mbuf___0;
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    p ++;
#line 517
    if ((int )*p != 0) {
#line 517
      if ((int )*p != 125) {
#line 517
        if (! ((unsigned long )bp___3 < (unsigned long )(& mbuf___0[sizeof(mbuf___0) - 1UL]))) {
#line 517
          goto while_break;
        }
      } else {
#line 517
        goto while_break;
      }
    } else {
#line 517
      goto while_break;
    }
#line 519
    if (((int )*p & -128) == 0) {
      {
#line 519
      tmp___1 = __ctype_b_loc();
      }
#line 519
      if ((int const   )*(*tmp___1 + (int )*p) & 8) {
#line 520
        tmp___0 = bp___3;
#line 520
        bp___3 ++;
#line 520
        *tmp___0 = *p;
      } else
#line 519
      if ((int )*p == 95) {
#line 520
        tmp___0 = bp___3;
#line 520
        bp___3 ++;
#line 520
        *tmp___0 = *p;
      } else {
        {
#line 522
        syserr("Invalid macro/class character %c", (int )*p);
        }
      }
    } else {
      {
#line 522
      syserr("Invalid macro/class character %c", (int )*p);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 524
  *bp___3 = (char )'\000';
#line 525
  mid = -1;
#line 526
  if ((int )*p == 0) {
    {
#line 528
    syserr("Unbalanced { on %s", mbuf___0);
    }
  } else
#line 530
  if ((int )*p != 125) {
    {
#line 532
    syserr("Macro/class name ({%s}) too long (%d chars max)", mbuf___0, (int )(sizeof(mbuf___0) - 1UL));
    }
  } else
#line 535
  if ((int )mbuf___0[1] == 0) {
#line 538
    mid = (int )((unsigned int )mbuf___0[0] & 255U);
#line 539
    p ++;
  } else {
    {
#line 545
    s = stab(mbuf___0, 9, 1);
    }
#line 546
    if (s->s_value.sv_macro != 0) {
#line 547
      mid = s->s_value.sv_macro;
    } else
#line 550
    if (NextMacroId > 255) {
      {
#line 552
      syserr("Macro/class {%s}: too many long names", mbuf___0);
#line 554
      s->s_value.sv_macro = -1;
      }
    } else {
#line 558
      MacroName[NextMacroId] = s->s_name;
#line 559
      tmp___2 = NextMacroId;
#line 559
      NextMacroId ++;
#line 559
      mid = tmp___2;
#line 559
      s->s_value.sv_macro = mid;
    }
#line 562
    p ++;
  }
#line 564
  if ((unsigned long )ep != (unsigned long )((void *)0)) {
#line 565
    *ep = p;
  }
#line 566
  if (mid < 0) {
#line 566
    goto _L___0;
  } else
#line 566
  if (mid > 255) {
    _L___0: /* CIL Label */ 
    {
#line 568
    syserr("Unable to assign macro/class ID (mid = 0x%x)", mid);
    }
#line 569
    if ((int )tTdvect[35] >= 14) {
      {
#line 570
      sm_dprintf((char *)"NULL\n");
      }
    }
#line 571
    return (0);
  }
#line 573
  if ((int )tTdvect[35] >= 14) {
    {
#line 574
    sm_dprintf((char *)"0x%x\n", mid);
    }
  }
#line 575
  return (mid);
}
}
#line 589 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/macro.c"
bool wordinclass(char *str , int cl ) 
{ 
  register STAB *s ;
  int tmp ;

  {
  {
#line 596
  s = stab(str, 1, 0);
  }
#line 597
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 597
    if (s->s_value.sv_class[(unsigned long )((unsigned char )((unsigned int )cl & 255U)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )((unsigned int )cl & 255U)) % (8UL * sizeof(int )))) {
#line 597
      tmp = 1;
    } else {
#line 597
      tmp = 0;
    }
  } else {
#line 597
    tmp = 0;
  }
#line 597
  return (tmp);
}
}
#line 780 "./sendmail.h"
struct hdrinfo HdrInfo[36] ;
#line 817
bool isheader(char *h ) ;
#line 819
void setupheaders(void) ;
#line 18 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
static HDR *allocheader(char *field , char *value , int flags , SM_RPOOL_T *rp ) ;
#line 19
static size_t fix_mime_header(HDR *h , ENVELOPE *e ) ;
#line 20
static int priencode(char *p ) ;
#line 21
static bool put_vanilla_header(HDR *h , char *v , struct mailer_con_info *mci ) ;
#line 33 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
void setupheaders(void) 
{ 
  struct hdrinfo *hi ;
  STAB *s ;

  {
#line 39
  hi = HdrInfo;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! ((unsigned long )hi->hi_field != (unsigned long )((void *)0))) {
#line 39
      goto while_break;
    }
    {
#line 41
    s = stab(hi->hi_field, 12, 1);
#line 42
    s->s_value.sv_header.hi_flags = hi->hi_flags;
#line 43
    s->s_value.sv_header.hi_ruleset = (char *)((void *)0);
#line 39
    hi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 65 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
static struct hdrinfo NormalHeader  =    {(char *)((void *)0), 0UL, (char *)((void *)0)};
#line 67 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
unsigned long chompheader(char *line , int pflag , HDR **hdrp , ENVELOPE *e ) 
{ 
  unsigned char mid ;
  register char *p ;
  register HDR *h ;
  HDR **hp ;
  char *fname ;
  char *fvalue ;
  bool cond ;
  bool dropfrom ;
  bool headeronly ;
  STAB *s ;
  struct hdrinfo *hi ;
  bool nullheader ;
  BITMAP256 mopts ;
  SM_FILE_T *tmp ;
  int c ;
  register char *q ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  char hbuf___0[50] ;
  unsigned short const   **tmp___10 ;
  char *endp ;
  bool strc ;
  int tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  int rscheckflags ;
  char *rs ;
  int l ;
  int k ;
  char qval[256] ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  void *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;

  {
#line 74
  mid = (unsigned char )'\000';
#line 80
  cond = 0;
#line 85
  nullheader = 0;
#line 88
  if ((int )tTdvect[31] >= 6) {
    {
#line 90
    sm_dprintf((char *)"chompheader: ");
#line 91
    tmp = sm_debug_file();
#line 91
    xputs(tmp, (char const   *)line);
#line 92
    sm_dprintf((char *)"\n");
    }
  }
#line 95
  headeronly = (unsigned long )hdrp != (unsigned long )((void *)0);
#line 96
  if (! headeronly) {
#line 97
    hdrp = & e->e_header;
  }
  {
#line 100
  memset((void *)((char *)(mopts)), '\000', (size_t )32);
#line 101
  p = line;
  }
#line 102
  if (! ((4 & pflag) != 0)) {
#line 102
    if ((int )*p == 63) {
      {
#line 107
      p ++;
#line 107
      q = strchr((char const   *)p, '?');
      }
#line 108
      if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 109
        goto hse;
      }
#line 111
      *q = (char )'\000';
#line 112
      c = (int )*p & 255;
#line 115
      if (c == 129) {
#line 118
        p ++;
#line 118
        if ((int )*p == 0) {
#line 120
          *q = (char )'?';
#line 121
          goto hse;
        }
#line 124
        tmp___0 = p;
#line 124
        p ++;
#line 124
        mid = (unsigned char )*tmp___0;
#line 127
        if ((int )*p != 0) {
#line 129
          *q = (char )'?';
#line 130
          goto hse;
        }
      } else
#line 133
      if ((int )*p == 36) {
#line 136
        p ++;
#line 136
        if ((int )*p == 0) {
#line 138
          *q = (char )'?';
#line 139
          goto hse;
        }
        {
#line 142
        tmp___1 = macid_parse(p, (char **)((void *)0));
#line 142
        mid = (unsigned char )tmp___1;
        }
#line 143
        if (((int )mid & 128) != 0) {
          {
#line 145
          tmp___2 = macname((int )mid);
#line 145
          tmp___3 = strlen((char const   *)tmp___2);
#line 145
          p += tmp___3 + 2U;
          }
#line 146
          if ((unsigned long )p <= (unsigned long )q) {
#line 146
            tmp___4 = 1;
          } else {
            {
#line 146
            sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                        146, "SM_ASSERT(p <= q) failed");
#line 146
            tmp___4 = 0;
            }
          }
        } else {
#line 149
          p ++;
        }
#line 152
        if ((int )*p != 0) {
#line 154
          *q = (char )'?';
#line 155
          goto hse;
        }
      } else {
        {
#line 160
        while (1) {
          while_continue: /* CIL Label */ ;
#line 160
          if (! ((int )*p != 0)) {
#line 160
            goto while_break;
          }
#line 162
          if (! (((int )*p & -128) == 0)) {
#line 164
            *q = (char )'?';
#line 165
            goto hse;
          }
#line 168
          mopts[(unsigned long )((unsigned char )((unsigned int )*p & 255U)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )((unsigned int )*p & 255U)) % (8UL * sizeof(int ));
#line 169
          cond = 1;
#line 170
          p ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 173
      p = q + 1;
    }
  }
#line 177
  fname = p;
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (((int )*p & -128) == 0) {
      {
#line 178
      tmp___5 = __ctype_b_loc();
      }
#line 178
      if ((int const   )*(*tmp___5 + (int )*p) & 32768) {
#line 178
        if (! ((int )*p != 58)) {
#line 178
          goto while_break___0;
        }
      } else {
#line 178
        goto while_break___0;
      }
    } else {
#line 178
      goto while_break___0;
    }
#line 179
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 180
  fvalue = p;
  {
#line 181
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 181
    if (((int )*p & -128) == 0) {
      {
#line 181
      tmp___6 = __ctype_b_loc();
      }
#line 181
      if (! ((int const   )*(*tmp___6 + (int )*p) & 8192)) {
#line 181
        goto while_break___1;
      }
    } else {
#line 181
      goto while_break___1;
    }
#line 182
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 183
  tmp___7 = p;
#line 183
  p ++;
#line 183
  if ((int )*tmp___7 != 58) {
#line 183
    goto hse;
  } else
#line 183
  if ((unsigned long )fname == (unsigned long )fvalue) {
    hse: 
    {
#line 186
    syserr("553 5.3.0 header syntax error, line \"%s\"", line);
    }
#line 187
    return (0UL);
  }
#line 189
  *fvalue = (char )'\000';
#line 192
  if ((int )*p == 32) {
#line 193
    p ++;
  }
#line 194
  fvalue = p;
  {
#line 197
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 197
    if (((int )*p & -128) == 0) {
      {
#line 197
      tmp___8 = __ctype_b_loc();
      }
#line 197
      if (! ((int const   )*(*tmp___8 + (int )*p) & 8192)) {
#line 197
        goto while_break___2;
      }
    } else {
#line 197
      goto while_break___2;
    }
#line 198
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 199
  if ((int )*p == 0) {
#line 200
    nullheader = 1;
  }
  {
#line 203
  tmp___9 = strlen((char const   *)fname);
  }
#line 203
  if (tmp___9 > 100U) {
#line 204
    return (1UL);
  }
#line 207
  if ((1 & pflag) != 0) {
    {
#line 211
    expand(fvalue, hbuf___0, (size_t )sizeof(hbuf___0), e);
#line 212
    p = hbuf___0;
    }
    {
#line 212
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 212
      if (((int )*p & -128) == 0) {
        {
#line 212
        tmp___10 = __ctype_b_loc();
        }
#line 212
        if (! ((int const   )*(*tmp___10 + (int )*p) & 8192)) {
#line 212
          goto while_break___3;
        }
      } else {
#line 212
        goto while_break___3;
      }
#line 213
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 214
    tmp___12 = p;
#line 214
    p ++;
#line 214
    if (((int )*tmp___12 & 255) == 153) {
#line 219
      strc = (int )*p == 43;
#line 220
      if (strc) {
#line 221
        p ++;
      }
      {
#line 222
      tmp___11 = strtorwset(p, & endp, 1);
      }
#line 222
      if (tmp___11 > 0) {
        {
#line 224
        *endp = (char )'\000';
#line 225
        s = stab(fname, 12, 1);
        }
#line 226
        if (LogLevel > 9) {
#line 226
          if ((unsigned long )s->s_value.sv_header.hi_ruleset != (unsigned long )((void *)0)) {
            {
#line 228
            sm_syslog(4, "*~*", "Warning: redefined ruleset for header=%s, old=%s, new=%s",
                      fname, s->s_value.sv_header.hi_ruleset, p);
            }
          }
        }
        {
#line 232
        s->s_value.sv_header.hi_ruleset = newstr((char const   *)p);
        }
#line 233
        if (! strc) {
#line 234
          s->s_value.sv_header.hi_flags |= 65536UL;
        }
      }
#line 236
      return (0UL);
    }
  }
  {
#line 241
  s = stab(fname, 12, 0);
  }
#line 242
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 243
    hi = & s->s_value.sv_header;
  } else {
#line 245
    hi = & NormalHeader;
  }
#line 247
  if ((int )tTdvect[31] >= 9) {
#line 249
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
#line 250
      sm_dprintf((char *)"no header flags match\n");
      }
    } else {
#line 252
      if ((unsigned long )hi->hi_ruleset == (unsigned long )((void *)0)) {
#line 252
        tmp___13 = "<NULL>";
      } else {
#line 252
        tmp___13 = (char const   *)hi->hi_ruleset;
      }
      {
#line 252
      sm_dprintf((char *)"header match, flags=%lx, ruleset=%s\n", hi->hi_flags, tmp___13);
      }
    }
  }
#line 259
  if (! ((1 & pflag) != 0)) {
#line 259
    if (! headeronly) {
#line 259
      if ((hi->hi_flags & 8UL) != 0UL) {
#line 261
        e->e_flags |= 256UL;
      }
    }
  }
#line 264
  if (UseErrorsTo) {
#line 264
    if (! ((1 & pflag) != 0)) {
#line 264
      if (! headeronly) {
#line 264
        if ((hi->hi_flags & 2048UL) != 0UL) {
          {
#line 266
          sendtolist(fvalue, (ADDRESS *)((void *)0), & e->e_errorqueue, 0, e);
          }
        }
      }
    }
  }
#line 269
  if (! headeronly) {
#line 269
    if ((hi->hi_flags & 1UL) != 0UL) {
#line 270
      return (hi->hi_flags);
    }
  }
#line 280
  if ((hi->hi_flags & 256UL) != 0UL) {
#line 280
    if (SingleLineFromHeader) {
      {
#line 282
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 282
        p = strchr((char const   *)fvalue, '\n');
        }
#line 282
        if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 282
          goto while_break___4;
        }
#line 283
        *p = (char )' ';
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 290
  if ((2 & pflag) != 0) {
#line 295
    rscheckflags = 4;
#line 296
    if (! ((258UL & hi->hi_flags) != 0UL)) {
#line 297
      rscheckflags |= 2;
    }
#line 300
    rs = hi->hi_ruleset;
#line 301
    if ((unsigned long )rs == (unsigned long )((void *)0)) {
      {
#line 303
      s = stab((char *)"*", 12, 0);
      }
#line 304
      if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 306
        rs = s->s_value.sv_header.hi_ruleset;
#line 307
        if ((65536UL & s->s_value.sv_header.hi_flags) != 0UL) {
#line 309
          rscheckflags |= 1;
        }
      }
    } else
#line 312
    if ((65536UL & hi->hi_flags) != 0UL) {
#line 313
      rscheckflags |= 1;
    }
#line 314
    if ((unsigned long )rs != (unsigned long )((void *)0)) {
#line 319
      l = 0;
#line 320
      tmp___14 = l;
#line 320
      l ++;
#line 320
      qval[tmp___14] = (char )'\"';
#line 324
      k = 0;
      {
#line 324
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 324
        if ((int )*(fvalue + k) != 0) {
#line 324
          if (! (l < 253)) {
#line 324
            goto while_break___5;
          }
        } else {
#line 324
          goto while_break___5;
        }
        {
#line 333
        if ((int )*(fvalue + k) == 13) {
#line 333
          goto case_13;
        }
#line 333
        if ((int )*(fvalue + k) == 12) {
#line 333
          goto case_13;
        }
#line 333
        if ((int )*(fvalue + k) == 11) {
#line 333
          goto case_13;
        }
#line 333
        if ((int )*(fvalue + k) == 10) {
#line 333
          goto case_13;
        }
#line 333
        if ((int )*(fvalue + k) == 9) {
#line 333
          goto case_13;
        }
#line 336
        if ((int )*(fvalue + k) == 34) {
#line 336
          goto case_34;
        }
#line 339
        goto switch_default;
        case_13: /* CIL Label */ 
        case_12: /* CIL Label */ 
        case_11: /* CIL Label */ 
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
#line 334
        tmp___15 = l;
#line 334
        l ++;
#line 334
        qval[tmp___15] = (char )' ';
#line 335
        goto switch_break;
        case_34: /* CIL Label */ 
#line 337
        tmp___16 = l;
#line 337
        l ++;
#line 337
        qval[tmp___16] = (char )'\\';
        switch_default: /* CIL Label */ 
#line 340
        tmp___17 = l;
#line 340
        l ++;
#line 340
        qval[tmp___17] = *(fvalue + k);
#line 341
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 324
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 344
      tmp___18 = l;
#line 344
      l ++;
#line 344
      qval[tmp___18] = (char )'\"';
#line 345
      qval[l] = (char )'\000';
#line 346
      tmp___19 = strlen((char const   *)(fvalue + k));
#line 346
      k = (int )((size_t )k + tmp___19);
      }
#line 347
      if (k >= 256) {
#line 349
        if (LogLevel > 9) {
          {
#line 350
          sm_syslog(4, (char const   *)e->e_id, "Warning: truncated header \'%s\' before check with \'%s\' len=%d max=%d",
                    fname, rs, k, 255);
          }
        }
      }
      {
#line 354
      tmp___20 = macid_parse((char *)"{currHeader}", (char **)((void *)0));
#line 354
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___20, qval, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                       355, SmHeapGroup);
#line 356
      tmp___21 = macid_parse((char *)"{hdr_name}", (char **)((void *)0));
#line 356
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___21, fname, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                       357, SmHeapGroup);
#line 359
      sm_snprintf(qval, (size_t )sizeof(qval), "%d", k);
#line 360
      tmp___22 = macid_parse((char *)"{hdrlen}", (char **)((void *)0));
#line 360
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___22, qval, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                       360, SmHeapGroup);
#line 370
      tmp___23 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 370
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___23, (char *)"h", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                       371, SmHeapGroup);
#line 372
      rscheck(rs, fvalue, (char *)((void *)0), e, rscheckflags, 3, (char *)((void *)0),
              e->e_id);
      }
    }
  }
#line 383
  dropfrom = 0;
#line 384
  p = (char *)"resent-from";
#line 385
  if (! ((e->e_flags & 256UL) != 0UL)) {
#line 386
    p += 7;
  }
#line 387
  if (! ((1 & pflag) != 0)) {
#line 387
    if (! headeronly) {
#line 387
      if (! ((e->e_flags & 2048UL) != 0UL)) {
        {
#line 387
        tmp___26 = sm_strcasecmp((char const   *)fname, (char const   *)p);
        }
#line 387
        if (tmp___26 == 0) {
#line 390
          if ((int )tTdvect[31] >= 2) {
            {
#line 392
            sm_dprintf((char *)"comparing header from (%s) against default (%s or %s)\n",
                       fvalue, e->e_from.q_paddr, e->e_from.q_user);
            }
          }
#line 395
          if ((unsigned long )e->e_from.q_paddr != (unsigned long )((void *)0)) {
#line 395
            if ((unsigned long )e->e_from.q_mailer != (unsigned long )((void *)0)) {
#line 395
              if ((e->e_from.q_mailer)->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int )))) {
                {
#line 395
                tmp___24 = strcmp((char const   *)fvalue, (char const   *)e->e_from.q_paddr);
                }
#line 395
                if (tmp___24 == 0) {
#line 400
                  dropfrom = 1;
                } else {
                  {
#line 395
                  tmp___25 = strcmp((char const   *)fvalue, (char const   *)e->e_from.q_user);
                  }
#line 395
                  if (tmp___25 == 0) {
#line 400
                    dropfrom = 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 404
  hp = hdrp;
  {
#line 404
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 404
    h = *hp;
#line 404
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 404
      goto while_break___6;
    }
    {
#line 406
    tmp___27 = sm_strcasecmp((char const   *)fname, (char const   *)h->h_field);
    }
#line 406
    if (tmp___27 == 0) {
#line 406
      if (! ((h->h_flags & 262144UL) != 0UL)) {
#line 406
        if (! ((h->h_flags & 64UL) != 0UL)) {
#line 410
          if (nullheader) {
#line 413
            return (0UL);
          }
#line 415
          if (dropfrom) {
#line 418
            h->h_flags |= 262144UL;
#line 419
            return (hi->hi_flags);
          }
#line 421
          h->h_value = (char *)((void *)0);
#line 422
          if (! cond) {
            {
#line 425
            memmove((void *)((char *)(mopts)), (void const   *)((char *)(h->h_mflags)),
                    (size_t )sizeof(mopts));
            }
          }
#line 428
          h->h_macro = mid;
        }
      }
    }
#line 404
    hp = & h->h_link;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 433
  tmp___28 = sm_rpool_malloc_tagged_x(e->e_rpool, (size_t )sizeof(*h), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                                      433, SmHeapGroup);
#line 433
  h = (HDR *)tmp___28;
#line 434
  h->h_field = sm_rpool_strdup_x(e->e_rpool, (char const   *)fname);
#line 435
  h->h_value = sm_rpool_strdup_x(e->e_rpool, (char const   *)fvalue);
#line 436
  h->h_link = (struct header *)((void *)0);
#line 437
  memmove((void *)((char *)(h->h_mflags)), (void const   *)((char *)(mopts)), (size_t )sizeof(mopts));
#line 438
  h->h_macro = mid;
#line 439
  *hp = h;
#line 440
  h->h_flags = hi->hi_flags;
  }
#line 441
  if ((4 & pflag) != 0) {
#line 442
    h->h_flags |= 262144UL;
  } else
#line 441
  if ((8 & pflag) != 0) {
#line 442
    h->h_flags |= 262144UL;
  }
#line 445
  if (headeronly) {
#line 446
    h->h_flags &= 0xfffffffffffffffeUL;
  }
#line 447
  if ((1 & pflag) != 0) {
#line 448
    h->h_flags |= 4UL;
  }
#line 449
  if (cond) {
#line 450
    h->h_flags |= 16UL;
  } else
#line 449
  if ((int )mid != 0) {
#line 450
    h->h_flags |= 16UL;
  }
#line 453
  if (! ((1 & pflag) != 0)) {
#line 453
    if (! headeronly) {
#line 453
      if ((h->h_flags & 258UL) != 0UL) {
        {
#line 453
        tmp___29 = strchr((char const   *)fvalue, ',');
        }
#line 453
        if ((unsigned long )tmp___29 != (unsigned long )((void *)0)) {
#line 458
          e->e_flags &= 0xfffffffffffffffeUL;
        } else {
          {
#line 453
          tmp___30 = strchr((char const   *)fvalue, '(');
          }
#line 453
          if ((unsigned long )tmp___30 != (unsigned long )((void *)0)) {
#line 458
            e->e_flags &= 0xfffffffffffffffeUL;
          } else {
            {
#line 453
            tmp___31 = strchr((char const   *)fvalue, '<');
            }
#line 453
            if ((unsigned long )tmp___31 != (unsigned long )((void *)0)) {
#line 458
              e->e_flags &= 0xfffffffffffffffeUL;
            } else {
              {
#line 453
              tmp___32 = strchr((char const   *)fvalue, ';');
              }
#line 453
              if ((unsigned long )tmp___32 != (unsigned long )((void *)0)) {
#line 458
                e->e_flags &= 0xfffffffffffffffeUL;
              }
            }
          }
        }
      }
    }
  }
#line 461
  return (h->h_flags);
}
}
#line 476 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
static HDR *allocheader(char *field , char *value , int flags , SM_RPOOL_T *rp ) 
{ 
  HDR *h ;
  STAB *s ;
  void *tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 487
  s = stab(field, 12, 0);
#line 490
  tmp = sm_rpool_malloc_tagged_x(rp, (size_t )sizeof(*h), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                                 490, SmHeapGroup);
#line 490
  h = (HDR *)tmp;
#line 491
  h->h_field = field;
#line 492
  h->h_value = sm_rpool_strdup_x(rp, (char const   *)value);
#line 493
  h->h_flags = (unsigned long )flags;
  }
#line 494
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 495
    h->h_flags |= s->s_value.sv_header.hi_flags;
  }
  {
#line 496
  memset((void *)((char *)(h->h_mflags)), '\000', (size_t )32);
#line 497
  h->h_macro = (unsigned char )'\000';
  }
#line 499
  return (h);
}
}
#line 519 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
void addheader(char *field , char *value , int flags , ENVELOPE *e ) 
{ 
  register HDR *h ;
  HDR **hp ;
  HDR **hdrlist ;
  int tmp ;

  {
#line 528
  hdrlist = & e->e_header;
#line 531
  hp = hdrlist;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    h = *hp;
#line 531
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 531
      goto while_break;
    }
    {
#line 533
    tmp = sm_strcasecmp((char const   *)field, (char const   *)h->h_field);
    }
#line 533
    if (tmp == 0) {
#line 534
      goto while_break;
    }
#line 531
    hp = & h->h_link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 538
  h = allocheader(field, value, flags, e->e_rpool);
#line 539
  h->h_link = *hp;
#line 540
  *hp = h;
  }
#line 541
  return;
}
}
#line 561 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
void insheader(int idx , char *field , char *value , int flags , ENVELOPE *e ) 
{ 
  HDR *h ;
  HDR *srch ;
  HDR *last ;
  int tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 569
  last = (HDR *)((void *)0);
#line 572
  h = allocheader(field, value, flags, e->e_rpool);
#line 575
  srch = e->e_header;
  }
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 575
    if ((unsigned long )srch != (unsigned long )((void *)0)) {
#line 575
      if (! (idx > 0)) {
#line 575
        goto while_break;
      }
    } else {
#line 575
      goto while_break;
    }
#line 577
    last = srch;
#line 575
    srch = srch->h_link;
#line 575
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 579
  if ((unsigned long )e->e_header == (unsigned long )((void *)0)) {
#line 581
    e->e_header = h;
#line 582
    h->h_link = (struct header *)((void *)0);
  } else
#line 584
  if ((unsigned long )srch == (unsigned long )((void *)0)) {
#line 586
    if ((unsigned long )last != (unsigned long )((void *)0)) {
#line 586
      tmp = 1;
    } else {
      {
#line 586
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                  586, "SM_ASSERT(last != NULL) failed");
#line 586
      tmp = 0;
      }
    }
#line 587
    last->h_link = h;
#line 588
    h->h_link = (struct header *)((void *)0);
  } else {
#line 592
    h->h_link = srch->h_link;
#line 593
    srch->h_link = h;
  }
#line 595
  return;
}
}
#line 614 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
char *hvalue(char *field , HDR *header ) 
{ 
  register HDR *h ;
  int tmp ;

  {
#line 621
  h = header;
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 621
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 621
      goto while_break;
    }
#line 623
    if (! ((h->h_flags & 4UL) != 0UL)) {
      {
#line 623
      tmp = sm_strcasecmp((char const   *)h->h_field, (char const   *)field);
      }
#line 623
      if (tmp == 0) {
#line 625
        return (h->h_value);
      }
    }
#line 621
    h = h->h_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 627
  return ((char *)((void *)0));
}
}
#line 652 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
bool isheader(char *h ) 
{ 
  register char *s ;
  unsigned short const   **tmp ;

  {
#line 656
  s = h;
#line 658
  if ((int )*(s + 0) == 45) {
#line 658
    if ((int )*(s + 1) == 45) {
#line 659
      return (0);
    }
  }
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if ((int )*s > 32) {
#line 661
      if ((int )*s != 58) {
#line 661
        if (! ((int )*s != 0)) {
#line 661
          goto while_break;
        }
      } else {
#line 661
        goto while_break;
      }
    } else {
#line 661
      goto while_break;
    }
#line 662
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 664
  if ((unsigned long )h == (unsigned long )s) {
#line 665
    return (0);
  }
  {
#line 668
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 668
    if (((int )*s & -128) == 0) {
      {
#line 668
      tmp = __ctype_b_loc();
      }
#line 668
      if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
#line 668
        goto while_break___0;
      }
    } else {
#line 668
      goto while_break___0;
    }
#line 669
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 671
  return ((int )*s == 58);
}
}
#line 692 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
void eatheader(ENVELOPE *e , bool full , bool log ) 
{ 
  register HDR *h ;
  register char *p ;
  int hopcnt ;
  char buf___16[2048] ;
  bool tmp ;
  SM_FILE_T *tmp___0 ;
  char *tmp___1 ;
  SM_FILE_T *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  bool oldsupr ;
  char **pvp ;
  char pvpbuf[2048] ;
  int tmp___8 ;
  char **tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  register struct hdrinfo *hi ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;

  {
  {
#line 700
  hopcnt = 0;
#line 707
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'f', e->e_sender, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                   707, SmHeapGroup);
#line 708
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'g', e->e_sender, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                   708, SmHeapGroup);
  }
#line 709
  if ((unsigned long )e->e_origrcpt != (unsigned long )((void *)0)) {
#line 709
    if ((int )*(e->e_origrcpt) != 0) {
      {
#line 710
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'u', e->e_origrcpt, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                       710, SmHeapGroup);
      }
    } else {
      {
#line 712
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'u', (char *)((void *)0), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                       712, SmHeapGroup);
      }
    }
  } else {
    {
#line 712
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'u', (char *)((void *)0), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                     712, SmHeapGroup);
    }
  }
  {
#line 715
  p = hvalue((char *)"full-name", e->e_header);
  }
#line 716
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 718
    tmp = rfc822_string(p);
    }
#line 718
    if (! tmp) {
      {
#line 726
      p = addquotes(p, e->e_rpool);
      }
    }
    {
#line 728
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'x', p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                     728, SmHeapGroup);
    }
  }
#line 731
  if ((int )tTdvect[32] >= 1) {
    {
#line 732
    sm_dprintf((char *)"----- collected header -----\n");
    }
  }
#line 733
  e->e_msgid = (char *)((void *)0);
#line 734
  h = e->e_header;
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 734
      goto while_break;
    }
#line 736
    if ((int )tTdvect[32] >= 1) {
      {
#line 737
      sm_dprintf((char *)"%s: ", h->h_field);
      }
    }
#line 738
    if ((unsigned long )h->h_value == (unsigned long )((void *)0)) {
#line 740
      if ((int )tTdvect[32] >= 1) {
        {
#line 741
        sm_dprintf((char *)"<NULL>\n");
        }
      }
#line 742
      goto __Cont;
    }
#line 746
    if ((h->h_flags & 4UL) != 0UL) {
#line 746
      if (! ((h->h_flags & 131072UL) != 0UL)) {
#line 749
        if ((int )tTdvect[32] >= 1) {
          {
#line 751
          sm_dprintf((char *)"(");
#line 752
          tmp___0 = sm_debug_file();
#line 752
          xputs(tmp___0, (char const   *)h->h_value);
#line 753
          sm_dprintf((char *)") ");
          }
        }
        {
#line 755
        expand(h->h_value, buf___16, (size_t )sizeof(buf___16), e);
        }
#line 756
        if ((int )buf___16[0] != 0) {
#line 758
          if ((h->h_flags & 256UL) != 0UL) {
            {
#line 759
            tmp___1 = crackaddr(buf___16, e);
#line 759
            expand(tmp___1, buf___16, (size_t )sizeof(buf___16), e);
            }
          }
          {
#line 761
          h->h_value = sm_rpool_strdup_x(e->e_rpool, (char const   *)(buf___16));
#line 762
          h->h_flags &= 0xfffffffffffffffbUL;
          }
        }
      }
    }
#line 765
    if ((int )tTdvect[32] >= 1) {
      {
#line 767
      tmp___2 = sm_debug_file();
#line 767
      xputs(tmp___2, (char const   *)h->h_value);
#line 768
      sm_dprintf((char *)"\n");
      }
    }
#line 772
    if ((h->h_flags & 128UL) != 0UL) {
#line 773
      hopcnt ++;
    }
#line 776
    if (GrabTo) {
#line 776
      if ((h->h_flags & 2UL) != 0UL) {
#line 776
        if (! ((h->h_flags & 4UL) != 0UL)) {
#line 776
          if (! ((e->e_flags & 256UL) != 0UL)) {
            {
#line 785
            tmp___3 = denlstring(h->h_value, 1, 0);
#line 785
            sendtolist(tmp___3, (ADDRESS *)((void *)0), & e->e_sendqueue, 0, e);
            }
          } else
#line 776
          if ((h->h_flags & 8UL) != 0UL) {
            {
#line 785
            tmp___3 = denlstring(h->h_value, 1, 0);
#line 785
            sendtolist(tmp___3, (ADDRESS *)((void *)0), & e->e_sendqueue, 0, e);
            }
          }
        }
      }
    }
#line 801
    p = (char *)"resent-message-id";
#line 802
    if (! ((e->e_flags & 256UL) != 0UL)) {
#line 803
      p += 7;
    }
    {
#line 804
    tmp___6 = sm_strcasecmp((char const   *)h->h_field, (char const   *)p);
    }
#line 804
    if (tmp___6 == 0) {
#line 806
      e->e_msgid = h->h_value;
      {
#line 807
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 807
        if (((int )*(e->e_msgid) & -128) == 0) {
          {
#line 807
          tmp___4 = __ctype_b_loc();
          }
#line 807
          if (! ((int const   )*(*tmp___4 + (int )*(e->e_msgid)) & 8192)) {
#line 807
            goto while_break___0;
          }
        } else {
#line 807
          goto while_break___0;
        }
#line 808
        (e->e_msgid) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 809
      tmp___5 = macid_parse((char *)"{msg_id}", (char **)((void *)0));
#line 809
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___5, e->e_msgid, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                       810, SmHeapGroup);
      }
    }
    __Cont: /* CIL Label */ 
#line 734
    h = h->h_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 813
  if ((int )tTdvect[32] >= 1) {
    {
#line 814
    sm_dprintf((char *)"----------------------------\n");
    }
  }
#line 817
  if ((int )OpMode == 118) {
#line 818
    return;
  }
#line 821
  if (hopcnt > (int )e->e_hopcount) {
    {
#line 823
    e->e_hopcount = (short )hopcnt;
#line 824
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%d", (int )e->e_hopcount);
#line 825
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, 'c', buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                     825, SmHeapGroup);
    }
  }
  {
#line 829
  p = hvalue((char *)"precedence", e->e_header);
  }
#line 830
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 831
    tmp___7 = priencode(p);
#line 831
    e->e_class = (short )tmp___7;
    }
  }
#line 832
  if ((int )e->e_class < 0) {
#line 833
    e->e_timeoutclass = (short)2;
  } else
#line 834
  if ((int )e->e_class > 0) {
#line 835
    e->e_timeoutclass = (short)1;
  }
#line 836
  if (full) {
#line 838
    e->e_msgpriority = (e->e_msgsize - (long )e->e_class * WkClassFact) + (long )e->e_nrcpts * WkRecipFact;
  }
  {
#line 844
  p = hvalue((char *)"content-type", e->e_header);
  }
#line 845
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 853
    oldsupr = SuprErrs;
#line 854
    SuprErrs = 1;
#line 855
    pvp = prescan(p, '\000', pvpbuf, (int )sizeof(pvpbuf), (char **)((void *)0), MimeTokenTab,
                  0);
#line 857
    SuprErrs = oldsupr;
    }
#line 860
    if ((unsigned long )pvp != (unsigned long )((void *)0)) {
#line 860
      if ((unsigned long )*(pvp + 0) != (unsigned long )((void *)0)) {
#line 860
        if ((unsigned long )*(pvp + 1) != (unsigned long )((void *)0)) {
#line 860
          if ((unsigned long )*(pvp + 2) != (unsigned long )((void *)0)) {
            {
#line 860
            tmp___14 = pvp;
#line 860
            pvp ++;
#line 860
            tmp___15 = sm_strcasecmp((char const   *)*tmp___14, "multipart");
            }
#line 860
            if (tmp___15 == 0) {
              {
#line 860
              tmp___16 = pvp;
#line 860
              pvp ++;
#line 860
              tmp___17 = strcmp((char const   *)*tmp___16, "/");
              }
#line 860
              if (tmp___17 == 0) {
                {
#line 860
                tmp___18 = pvp;
#line 860
                pvp ++;
#line 860
                tmp___19 = sm_strcasecmp((char const   *)*tmp___18, "report");
                }
#line 860
                if (tmp___19 == 0) {
                  {
#line 867
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
#line 867
                    if (! ((unsigned long )*pvp != (unsigned long )((void *)0))) {
#line 867
                      goto while_break___1;
                    }
                    {
#line 870
                    while (1) {
                      while_continue___2: /* CIL Label */ ;
#line 870
                      if ((unsigned long )*pvp != (unsigned long )((void *)0)) {
                        {
#line 870
                        tmp___8 = strcmp((char const   *)*pvp, ";");
                        }
#line 870
                        if (! (tmp___8 != 0)) {
#line 870
                          goto while_break___2;
                        }
                      } else {
#line 870
                        goto while_break___2;
                      }
#line 871
                      pvp ++;
                    }
                    while_break___2: /* CIL Label */ ;
                    }
#line 874
                    tmp___9 = pvp;
#line 874
                    pvp ++;
#line 874
                    if ((unsigned long )*tmp___9 == (unsigned long )((void *)0)) {
#line 875
                      goto while_break___1;
                    } else
#line 874
                    if ((unsigned long )*pvp == (unsigned long )((void *)0)) {
#line 875
                      goto while_break___1;
                    }
                    {
#line 878
                    tmp___10 = pvp;
#line 878
                    pvp ++;
#line 878
                    tmp___11 = sm_strcasecmp((char const   *)*tmp___10, "report-type");
                    }
#line 878
                    if (tmp___11 != 0) {
#line 879
                      goto while_continue___1;
                    }
#line 882
                    if ((unsigned long )*pvp == (unsigned long )((void *)0)) {
#line 883
                      goto while_continue___1;
                    } else {
                      {
#line 882
                      tmp___12 = strcmp((char const   *)*pvp, "=");
                      }
#line 882
                      if (tmp___12 != 0) {
#line 883
                        goto while_continue___1;
                      }
                    }
#line 886
                    pvp ++;
#line 886
                    if ((unsigned long )*pvp != (unsigned long )((void *)0)) {
                      {
#line 886
                      tmp___13 = sm_strcasecmp((char const   *)*pvp, "delivery-status");
                      }
#line 886
                      if (tmp___13 == 0) {
#line 889
                        e->e_timeoutclass = (short)3;
                      }
                    }
#line 892
                    goto while_break___1;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 898
  p = hvalue((char *)"priority", e->e_header);
  }
#line 899
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 902
    tmp___22 = sm_strcasecmp((char const   *)p, "urgent");
    }
#line 902
    if (tmp___22 == 0) {
#line 903
      e->e_timeoutclass = (short)1;
    } else {
      {
#line 904
      tmp___21 = sm_strcasecmp((char const   *)p, "normal");
      }
#line 904
      if (tmp___21 == 0) {
#line 905
        e->e_timeoutclass = (short)0;
      } else {
        {
#line 906
        tmp___20 = sm_strcasecmp((char const   *)p, "non-urgent");
        }
#line 906
        if (tmp___20 == 0) {
#line 907
          e->e_timeoutclass = (short)2;
        } else
#line 908
        if ((e->e_flags & 128UL) != 0UL) {
#line 909
          e->e_timeoutclass = (short)3;
        }
      }
    }
  } else
#line 911
  if ((e->e_flags & 128UL) != 0UL) {
#line 912
    e->e_timeoutclass = (short)3;
  }
  {
#line 915
  p = hvalue((char *)"posted-date", e->e_header);
  }
#line 916
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 917
    p = hvalue((char *)"date", e->e_header);
    }
  }
#line 918
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 919
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'a', p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                     919, SmHeapGroup);
    }
  }
#line 922
  if ((unsigned long )e->e_bodytype != (unsigned long )((void *)0)) {
    {
#line 922
    tmp___23 = sm_strcasecmp((char const   *)e->e_bodytype, "8BITMIME");
    }
#line 922
    if (tmp___23 == 0) {
#line 922
      goto _L;
    } else {
#line 922
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 922
    tmp___24 = hvalue((char *)"MIME-Version", e->e_header);
    }
#line 922
    if ((unsigned long )tmp___24 != (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 926
      e->e_flags |= 4194304UL;
#line 927
      if (HasEightBits) {
#line 928
        e->e_bodytype = (char *)"8BITMIME";
      }
    } else {
      {
#line 930
      p = hvalue((char *)"Content-Type", e->e_header);
      }
#line 930
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 933
        p = strpbrk((char const   *)p, ";/");
        }
#line 934
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 937
          e->e_flags |= 8388608UL;
        } else
#line 934
        if ((int )*p == 59) {
#line 937
          e->e_flags |= 8388608UL;
        }
      }
    }
  }
#line 946
  if ((int )OpMode == 97) {
#line 950
    hi = HdrInfo;
    {
#line 950
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 950
      if (! ((unsigned long )hi->hi_field != (unsigned long )((void *)0))) {
#line 950
        goto while_break___3;
      }
#line 952
      if ((hi->hi_flags & 256UL) != 0UL) {
#line 952
        if (! ((hi->hi_flags & 8UL) != 0UL)) {
#line 952
          goto _L___1;
        } else
#line 952
        if ((e->e_flags & 256UL) != 0UL) {
          _L___1: /* CIL Label */ 
          {
#line 952
          p = hvalue(hi->hi_field, e->e_header);
          }
#line 952
          if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 956
            goto while_break___3;
          }
        }
      }
#line 950
      hi ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 958
    if ((unsigned long )hi->hi_field != (unsigned long )((void *)0)) {
#line 960
      if ((int )tTdvect[32] >= 2) {
        {
#line 961
        sm_dprintf((char *)"eatheader: setsender(*%s == %s)\n", hi->hi_field, p);
        }
      }
      {
#line 963
      setsender(p, e, (char **)((void *)0), '\000', 1);
      }
    }
  }
#line 971
  if (log) {
#line 971
    if ((e->e_flags & 32768UL) != 0UL) {
#line 971
      if (LogLevel > 4) {
        {
#line 973
        logsender(e, e->e_msgid);
#line 974
        e->e_flags &= 0xffffffffffff7fffUL;
        }
      }
    }
  }
#line 976
  return;
}
}
#line 988 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
void logsender(ENVELOPE *e , char *msgid ) 
{ 
  char *name ;
  register char *sbp ;
  register char *p ;
  char hbuf___0[257] ;
  char sbuf[2049] ;
  char mbuf___0[257] ;
  size_t l ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 1002
  if ((unsigned long )msgid != (unsigned long )((void *)0)) {
    {
#line 1006
    l = strlen((char const   *)msgid);
    }
#line 1007
    if ((unsigned long )l > sizeof(mbuf___0) - 1UL) {
#line 1008
      l = (size_t )(sizeof(mbuf___0) - 1UL);
    }
    {
#line 1009
    memmove((void *)(mbuf___0), (void const   *)msgid, l);
#line 1010
    mbuf___0[l] = (char )'\000';
#line 1011
    p = mbuf___0;
    }
    {
#line 1012
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1012
      p = strchr((char const   *)p, '\n');
      }
#line 1012
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1012
        goto while_break;
      }
#line 1013
      tmp = p;
#line 1013
      p ++;
#line 1013
      *tmp = (char )' ';
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1016
  if ((e->e_flags & 128UL) != 0UL) {
#line 1017
    name = (char *)"[RESPONSE]";
  } else {
    {
#line 1018
    name = macvalue('_', e);
    }
#line 1018
    if (! ((unsigned long )name != (unsigned long )((void *)0))) {
#line 1021
      if ((unsigned long )RealHostName == (unsigned long )((void *)0)) {
#line 1022
        name = (char *)"localhost";
      } else
#line 1023
      if ((int )*(RealHostName + 0) == 91) {
#line 1024
        name = RealHostName;
      } else {
        {
#line 1027
        name = hbuf___0;
#line 1028
        sm_snprintf(hbuf___0, (size_t )sizeof(hbuf___0), "%.80s", RealHostName);
        }
#line 1029
        if ((int )RealHostAddr.sa.sa_family != 0) {
          {
#line 1031
          tmp___0 = strlen((char const   *)(hbuf___0));
#line 1031
          p = & hbuf___0[tmp___0];
#line 1032
          tmp___1 = anynet_ntoa(& RealHostAddr);
#line 1032
          sm_snprintf(p, (size_t )(sizeof(hbuf___0) - (unsigned long )(p - hbuf___0)),
                      " (%.100s)", tmp___1);
          }
        }
      }
    }
  }
#line 1040
  sbp = sbuf;
#line 1041
  if ((unsigned long )e->e_from.q_paddr == (unsigned long )((void *)0)) {
#line 1041
    tmp___2 = "<NONE>";
  } else {
#line 1041
    tmp___2 = (char const   *)e->e_from.q_paddr;
  }
  {
#line 1041
  sm_snprintf(sbp, (size_t )(sizeof(sbuf) - (unsigned long )(sbp - sbuf)), "from=%.200s, size=%ld, class=%d, nrcpts=%d",
              tmp___2, e->e_msgsize, (int )e->e_class, e->e_nrcpts);
#line 1045
  tmp___3 = strlen((char const   *)sbp);
#line 1045
  sbp += tmp___3;
  }
#line 1046
  if ((unsigned long )msgid != (unsigned long )((void *)0)) {
    {
#line 1048
    sm_snprintf(sbp, (size_t )(sizeof(sbuf) - (unsigned long )(sbp - sbuf)), ", msgid=%.100s",
                mbuf___0);
#line 1050
    tmp___4 = strlen((char const   *)sbp);
#line 1050
    sbp += tmp___4;
    }
  }
#line 1052
  if ((unsigned long )e->e_bodytype != (unsigned long )((void *)0)) {
    {
#line 1054
    sm_snprintf(sbp, (size_t )(sizeof(sbuf) - (unsigned long )(sbp - sbuf)), ", bodytype=%.20s",
                e->e_bodytype);
#line 1056
    tmp___5 = strlen((char const   *)sbp);
#line 1056
    sbp += tmp___5;
    }
  }
  {
#line 1058
  p = macvalue('r', e);
  }
#line 1059
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1061
    sm_snprintf(sbp, (size_t )(sizeof(sbuf) - (unsigned long )(sbp - sbuf)), ", proto=%.20s",
                p);
#line 1063
    tmp___6 = strlen((char const   *)sbp);
#line 1063
    sbp += tmp___6;
    }
  }
  {
#line 1065
  tmp___7 = macid_parse((char *)"{daemon_name}", (char **)((void *)0));
#line 1065
  p = macvalue(tmp___7, e);
  }
#line 1066
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1068
    sm_snprintf(sbp, (size_t )(sizeof(sbuf) - (unsigned long )(sbp - sbuf)), ", daemon=%.20s",
                p);
#line 1070
    tmp___8 = strlen((char const   *)sbp);
#line 1070
    sbp += tmp___8;
    }
  }
  {
#line 1072
  sm_syslog(6, (char const   *)e->e_id, "%.850s, relay=%s", sbuf, name);
  }
#line 1106
  return;
}
}
#line 1120 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
static int priencode(char *p ) 
{ 
  register int i ;
  int tmp ;

  {
#line 1126
  i = 0;
  {
#line 1126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1126
    if (! (i < NumPriorities)) {
#line 1126
      goto while_break;
    }
    {
#line 1128
    tmp = sm_strcasecmp((char const   *)p, (char const   *)Priorities[i].pri_name);
    }
#line 1128
    if (tmp == 0) {
#line 1129
      return (Priorities[i].pri_val);
    }
#line 1126
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1133
  return (0);
}
}
#line 1212 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
static char buf___10[257]  ;
#line 1188 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
char *crackaddr(char *addr , ENVELOPE *e ) 
{ 
  register char *p ;
  register char c ;
  int cmtlev ;
  int realcmtlev ;
  int anglelev ;
  int copylev ;
  int bracklev ;
  bool addangle ;
  bool qmode ;
  bool realqmode ;
  bool putgmac ;
  bool quoteit ;
  bool gotangle ;
  bool gotcolon ;
  register char *bp___3 ;
  char *buflim ;
  char *bufhead ;
  char *addrhead ;
  char *bufend ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  register char *q ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  unsigned short const   **tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  register char *q___0 ;
  char *tmp___21 ;
  unsigned short const   **tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  char *tmp___40 ;
  SM_FILE_T *tmp___41 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
#line 1203
  putgmac = 0;
#line 1204
  quoteit = 0;
#line 1205
  gotangle = 0;
#line 1206
  gotcolon = 0;
#line 1214
  if ((int )tTdvect[33] >= 1) {
    {
#line 1215
    sm_dprintf((char *)"crackaddr(%s)\n", addr);
    }
  }
  {
#line 1218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1218
    if ((int )*addr != 0) {
#line 1218
      if (((int )*addr & -128) == 0) {
        {
#line 1218
        tmp = __ctype_b_loc();
        }
#line 1218
        if (! ((int const   )*(*tmp + (int )*addr) & 8192)) {
#line 1218
          goto while_break;
        }
      } else {
#line 1218
        goto while_break;
      }
    } else {
#line 1218
      goto while_break;
    }
#line 1219
    addr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1226
  bufend = & buf___10[sizeof(buf___10) - 1UL];
#line 1226
  buflim = bufend;
#line 1227
  bufhead = buf___10;
#line 1227
  bp___3 = bufhead;
#line 1228
  addrhead = addr;
#line 1228
  p = addrhead;
#line 1229
  realcmtlev = 0;
#line 1229
  cmtlev = realcmtlev;
#line 1229
  anglelev = cmtlev;
#line 1229
  copylev = anglelev;
#line 1230
  bracklev = 0;
#line 1231
  addangle = 0;
#line 1231
  realqmode = addangle;
#line 1231
  qmode = realqmode;
  {
#line 1233
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1233
    tmp___36 = p;
#line 1233
    p ++;
#line 1233
    c = *tmp___36;
#line 1233
    if (! ((int )c != 0)) {
#line 1233
      goto while_break___0;
    }
#line 1240
    if (copylev > 0) {
      {
#line 1241
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1241
        if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1241
          if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1241
            tmp___0 = bp___3;
#line 1241
            bp___3 ++;
#line 1241
            *tmp___0 = c;
          } else {
#line 1241
            goto returng;
          }
        } else {
#line 1241
          goto returng;
        }
#line 1241
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1244
    if ((int )c == 92) {
#line 1247
      if (cmtlev <= 0) {
#line 1247
        if (! qmode) {
#line 1248
          quoteit = 1;
        }
      }
#line 1250
      tmp___1 = p;
#line 1250
      p ++;
#line 1250
      c = *tmp___1;
#line 1250
      if ((int )c == 0) {
#line 1253
        p --;
#line 1254
        goto putg;
      }
#line 1256
      if (copylev > 0) {
        {
#line 1257
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1257
          if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1257
            if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1257
              tmp___2 = bp___3;
#line 1257
              bp___3 ++;
#line 1257
              *tmp___2 = c;
            } else {
#line 1257
              goto returng;
            }
          } else {
#line 1257
            goto returng;
          }
#line 1257
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1258
      goto putg;
    }
#line 1262
    if ((int )c == 34) {
#line 1262
      if (cmtlev <= 0) {
#line 1264
        qmode = ! qmode;
#line 1265
        if (copylev > 0) {
#line 1265
          if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1265
            if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1267
              if (realqmode) {
#line 1268
                buflim --;
              } else {
#line 1270
                buflim ++;
              }
#line 1271
              realqmode = ! realqmode;
            }
          }
        }
#line 1273
        goto while_continue___0;
      }
    }
#line 1275
    if (qmode) {
#line 1276
      goto putg;
    }
#line 1279
    if ((int )c == 40) {
#line 1281
      cmtlev ++;
#line 1284
      if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1284
        if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1286
          buflim --;
#line 1287
          realcmtlev ++;
#line 1288
          tmp___5 = copylev;
#line 1288
          copylev ++;
#line 1288
          if (tmp___5 <= 0) {
#line 1290
            if ((unsigned long )bp___3 != (unsigned long )bufhead) {
              {
#line 1291
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1291
                if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1291
                  if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1291
                    tmp___3 = bp___3;
#line 1291
                    bp___3 ++;
#line 1291
                    *tmp___3 = (char )' ';
                  } else {
#line 1291
                    goto returng;
                  }
                } else {
#line 1291
                  goto returng;
                }
#line 1291
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
            {
#line 1292
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1292
              if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1292
                if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1292
                  tmp___4 = bp___3;
#line 1292
                  bp___3 ++;
#line 1292
                  *tmp___4 = c;
                } else {
#line 1292
                  goto returng;
                }
              } else {
#line 1292
                goto returng;
              }
#line 1292
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 1296
    if (cmtlev > 0) {
#line 1298
      if ((int )c == 41) {
#line 1300
        cmtlev --;
#line 1301
        copylev --;
#line 1302
        if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1302
          if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1304
            realcmtlev --;
#line 1305
            buflim ++;
          }
        }
      }
#line 1308
      goto while_continue___0;
    } else
#line 1310
    if ((int )c == 41) {
#line 1313
      if (copylev > 0) {
#line 1313
        if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1313
          if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1313
            if ((unsigned long )bp___3 > (unsigned long )bufhead) {
#line 1314
              bp___3 --;
            }
          }
        }
      }
    }
#line 1318
    if ((int )c == 91) {
#line 1319
      bracklev ++;
    } else
#line 1320
    if ((int )c == 93) {
#line 1321
      bracklev --;
    }
#line 1324
    if ((int )c == 58) {
#line 1324
      if (anglelev <= 0) {
#line 1324
        if (bracklev <= 0) {
#line 1324
          if (! gotcolon) {
#line 1324
            if (! ColonOkInAddr) {
#line 1336
              if ((int )*p == 58) {
#line 1336
                goto _L;
              } else
#line 1336
              if ((int )*p == 46) {
                _L: /* CIL Label */ 
#line 1338
                if (cmtlev <= 0) {
#line 1338
                  if (! qmode) {
#line 1339
                    quoteit = 1;
                  }
                }
#line 1340
                if (copylev > 0) {
                  {
#line 1342
                  while (1) {
                    while_continue___5: /* CIL Label */ ;
#line 1342
                    if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1342
                      if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1342
                        tmp___6 = bp___3;
#line 1342
                        bp___3 ++;
#line 1342
                        *tmp___6 = c;
                      } else {
#line 1342
                        goto returng;
                      }
                    } else {
#line 1342
                      goto returng;
                    }
#line 1342
                    goto while_break___5;
                  }
                  while_break___5: /* CIL Label */ ;
                  }
                  {
#line 1343
                  while (1) {
                    while_continue___6: /* CIL Label */ ;
#line 1343
                    if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1343
                      if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1343
                        tmp___7 = bp___3;
#line 1343
                        bp___3 ++;
#line 1343
                        *tmp___7 = *p;
                      } else {
#line 1343
                        goto returng;
                      }
                    } else {
#line 1343
                      goto returng;
                    }
#line 1343
                    goto while_break___6;
                  }
                  while_break___6: /* CIL Label */ ;
                  }
                }
#line 1345
                p ++;
#line 1346
                goto putg;
              }
#line 1349
              gotcolon = 1;
#line 1351
              bp___3 = bufhead;
#line 1352
              if (quoteit) {
                {
#line 1354
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 1354
                  if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1354
                    if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1354
                      tmp___8 = bp___3;
#line 1354
                      bp___3 ++;
#line 1354
                      *tmp___8 = (char )'\"';
                    } else {
#line 1354
                      goto returng;
                    }
                  } else {
#line 1354
                    goto returng;
                  }
#line 1354
                  goto while_break___7;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 1357
                p --;
                {
#line 1358
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 1358
                  if ((unsigned long )p > (unsigned long )addr) {
#line 1358
                    p --;
#line 1358
                    if (((int )*p & -128) == 0) {
                      {
#line 1358
                      tmp___9 = __ctype_b_loc();
                      }
#line 1358
                      if (! ((int const   )*(*tmp___9 + (int )*p) & 8192)) {
#line 1358
                        goto while_break___8;
                      }
                    } else {
#line 1358
                      goto while_break___8;
                    }
                  } else {
#line 1358
                    goto while_break___8;
                  }
#line 1360
                  goto while_continue___8;
                }
                while_break___8: /* CIL Label */ ;
                }
#line 1361
                p ++;
              }
#line 1363
              q = addrhead;
              {
#line 1363
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 1363
                if (! ((unsigned long )q < (unsigned long )p)) {
#line 1363
                  goto while_break___9;
                }
#line 1365
                tmp___10 = q;
#line 1365
                q ++;
#line 1365
                c = *tmp___10;
#line 1366
                if (quoteit) {
#line 1366
                  if ((int )c == 34) {
                    {
#line 1367
                    while (1) {
                      while_continue___10: /* CIL Label */ ;
#line 1367
                      if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1367
                        if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1367
                          tmp___11 = bp___3;
#line 1367
                          bp___3 ++;
#line 1367
                          *tmp___11 = (char )'\\';
                        } else {
#line 1367
                          goto returng;
                        }
                      } else {
#line 1367
                        goto returng;
                      }
#line 1367
                      goto while_break___10;
                    }
                    while_break___10: /* CIL Label */ ;
                    }
                  }
                }
                {
#line 1368
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 1368
                  if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1368
                    if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1368
                      tmp___12 = bp___3;
#line 1368
                      bp___3 ++;
#line 1368
                      *tmp___12 = c;
                    } else {
#line 1368
                      goto returng;
                    }
                  } else {
#line 1368
                    goto returng;
                  }
#line 1368
                  goto while_break___11;
                }
                while_break___11: /* CIL Label */ ;
                }
              }
              while_break___9: /* CIL Label */ ;
              }
#line 1370
              if (quoteit) {
#line 1372
                if ((unsigned long )bp___3 == (unsigned long )(bufhead + 1)) {
#line 1373
                  bp___3 --;
                } else {
                  {
#line 1375
                  while (1) {
                    while_continue___12: /* CIL Label */ ;
#line 1375
                    if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1375
                      if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1375
                        tmp___13 = bp___3;
#line 1375
                        bp___3 ++;
#line 1375
                        *tmp___13 = (char )'\"';
                      } else {
#line 1375
                        goto returng;
                      }
                    } else {
#line 1375
                      goto returng;
                    }
#line 1375
                    goto while_break___12;
                  }
                  while_break___12: /* CIL Label */ ;
                  }
                }
                {
#line 1376
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 1376
                  tmp___15 = p;
#line 1376
                  p ++;
#line 1376
                  c = *tmp___15;
#line 1376
                  if (! ((int )c != 58)) {
#line 1376
                    goto while_break___13;
                  }
                  {
#line 1377
                  while (1) {
                    while_continue___14: /* CIL Label */ ;
#line 1377
                    if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1377
                      if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1377
                        tmp___14 = bp___3;
#line 1377
                        bp___3 ++;
#line 1377
                        *tmp___14 = c;
                      } else {
#line 1377
                        goto returng;
                      }
                    } else {
#line 1377
                      goto returng;
                    }
#line 1377
                    goto while_break___14;
                  }
                  while_break___14: /* CIL Label */ ;
                  }
                }
                while_break___13: /* CIL Label */ ;
                }
                {
#line 1378
                while (1) {
                  while_continue___15: /* CIL Label */ ;
#line 1378
                  if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1378
                    if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1378
                      tmp___16 = bp___3;
#line 1378
                      bp___3 ++;
#line 1378
                      *tmp___16 = c;
                    } else {
#line 1378
                      goto returng;
                    }
                  } else {
#line 1378
                    goto returng;
                  }
#line 1378
                  goto while_break___15;
                }
                while_break___15: /* CIL Label */ ;
                }
              }
              {
#line 1382
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 1382
                if (((int )*p & -128) == 0) {
                  {
#line 1382
                  tmp___18 = __ctype_b_loc();
                  }
#line 1382
                  if (! ((int const   )*(*tmp___18 + (int )*p) & 8192)) {
#line 1382
                    goto while_break___16;
                  }
                } else {
#line 1382
                  goto while_break___16;
                }
                {
#line 1384
                while (1) {
                  while_continue___17: /* CIL Label */ ;
#line 1384
                  if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1384
                    if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1384
                      tmp___17 = bp___3;
#line 1384
                      bp___3 ++;
#line 1384
                      *tmp___17 = *p;
                    } else {
#line 1384
                      goto returng;
                    }
                  } else {
#line 1384
                    goto returng;
                  }
#line 1384
                  goto while_break___17;
                }
                while_break___17: /* CIL Label */ ;
                }
#line 1385
                p ++;
              }
              while_break___16: /* CIL Label */ ;
              }
#line 1387
              copylev = 0;
#line 1388
              quoteit = 0;
#line 1388
              putgmac = quoteit;
#line 1389
              bufhead = bp___3;
#line 1390
              addrhead = p;
#line 1391
              goto while_continue___0;
            }
          }
        }
      }
    }
#line 1394
    if ((int )c == 59) {
#line 1394
      if (copylev <= 0) {
#line 1394
        if (! ColonOkInAddr) {
          {
#line 1395
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 1395
            if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1395
              if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1395
                tmp___19 = bp___3;
#line 1395
                bp___3 ++;
#line 1395
                *tmp___19 = c;
              } else {
#line 1395
                goto returng;
              }
            } else {
#line 1395
              goto returng;
            }
#line 1395
            goto while_break___18;
          }
          while_break___18: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 1398
    tmp___20 = strchr((char const   *)MustQuoteChars, (int )c);
    }
#line 1398
    if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
#line 1407
      if (cmtlev <= 0) {
#line 1407
        if (! qmode) {
#line 1408
          quoteit = 1;
        }
      }
    }
#line 1412
    if ((int )c == 60) {
#line 1417
      if (gotangle) {
#line 1418
        quoteit = 1;
      }
#line 1419
      gotangle = 1;
#line 1422
      anglelev = 1;
#line 1423
      if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1423
        if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1425
          if (! addangle) {
#line 1426
            buflim --;
          }
#line 1427
          addangle = 1;
        }
      }
#line 1430
      bp___3 = bufhead;
#line 1431
      if (quoteit) {
        {
#line 1433
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 1433
          if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1433
            if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1433
              tmp___21 = bp___3;
#line 1433
              bp___3 ++;
#line 1433
              *tmp___21 = (char )'\"';
            } else {
#line 1433
              goto returng;
            }
          } else {
#line 1433
            goto returng;
          }
#line 1433
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 1436
        p --;
        {
#line 1437
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 1437
          if ((unsigned long )p > (unsigned long )addr) {
#line 1437
            p --;
#line 1437
            if (((int )*p & -128) == 0) {
              {
#line 1437
              tmp___22 = __ctype_b_loc();
              }
#line 1437
              if (! ((int const   )*(*tmp___22 + (int )*p) & 8192)) {
#line 1437
                goto while_break___20;
              }
            } else {
#line 1437
              goto while_break___20;
            }
          } else {
#line 1437
            goto while_break___20;
          }
#line 1439
          goto while_continue___20;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 1440
        p ++;
      }
#line 1442
      q___0 = addrhead;
      {
#line 1442
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 1442
        if (! ((unsigned long )q___0 < (unsigned long )p)) {
#line 1442
          goto while_break___21;
        }
#line 1444
        tmp___23 = q___0;
#line 1444
        q___0 ++;
#line 1444
        c = *tmp___23;
#line 1445
        if (quoteit) {
#line 1445
          if ((int )c == 34) {
            {
#line 1447
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 1447
              if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1447
                if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1447
                  tmp___24 = bp___3;
#line 1447
                  bp___3 ++;
#line 1447
                  *tmp___24 = (char )'\\';
                } else {
#line 1447
                  goto returng;
                }
              } else {
#line 1447
                goto returng;
              }
#line 1447
              goto while_break___22;
            }
            while_break___22: /* CIL Label */ ;
            }
            {
#line 1448
            while (1) {
              while_continue___23: /* CIL Label */ ;
#line 1448
              if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1448
                if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1448
                  tmp___25 = bp___3;
#line 1448
                  bp___3 ++;
#line 1448
                  *tmp___25 = c;
                } else {
#line 1448
                  goto returng;
                }
              } else {
#line 1448
                goto returng;
              }
#line 1448
              goto while_break___23;
            }
            while_break___23: /* CIL Label */ ;
            }
          } else {
#line 1445
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 1451
          while (1) {
            while_continue___24: /* CIL Label */ ;
#line 1451
            if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1451
              if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1451
                tmp___26 = bp___3;
#line 1451
                bp___3 ++;
#line 1451
                *tmp___26 = c;
              } else {
#line 1451
                goto returng;
              }
            } else {
#line 1451
              goto returng;
            }
#line 1451
            goto while_break___24;
          }
          while_break___24: /* CIL Label */ ;
          }
        }
      }
      while_break___21: /* CIL Label */ ;
      }
#line 1453
      if (quoteit) {
#line 1455
        if ((unsigned long )bp___3 == (unsigned long )(& buf___10[1])) {
#line 1456
          bp___3 --;
        } else {
          {
#line 1458
          while (1) {
            while_continue___25: /* CIL Label */ ;
#line 1458
            if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1458
              if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1458
                tmp___27 = bp___3;
#line 1458
                bp___3 ++;
#line 1458
                *tmp___27 = (char )'\"';
              } else {
#line 1458
                goto returng;
              }
            } else {
#line 1458
              goto returng;
            }
#line 1458
            goto while_break___25;
          }
          while_break___25: /* CIL Label */ ;
          }
        }
        {
#line 1459
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 1459
          tmp___29 = p;
#line 1459
          p ++;
#line 1459
          c = *tmp___29;
#line 1459
          if (! ((int )c != 60)) {
#line 1459
            goto while_break___26;
          }
          {
#line 1460
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 1460
            if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1460
              if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1460
                tmp___28 = bp___3;
#line 1460
                bp___3 ++;
#line 1460
                *tmp___28 = c;
              } else {
#line 1460
                goto returng;
              }
            } else {
#line 1460
              goto returng;
            }
#line 1460
            goto while_break___27;
          }
          while_break___27: /* CIL Label */ ;
          }
        }
        while_break___26: /* CIL Label */ ;
        }
        {
#line 1461
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 1461
          if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1461
            if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1461
              tmp___30 = bp___3;
#line 1461
              bp___3 ++;
#line 1461
              *tmp___30 = c;
            } else {
#line 1461
              goto returng;
            }
          } else {
#line 1461
            goto returng;
          }
#line 1461
          goto while_break___28;
        }
        while_break___28: /* CIL Label */ ;
        }
      }
#line 1463
      copylev = 0;
#line 1464
      quoteit = 0;
#line 1464
      putgmac = quoteit;
#line 1465
      goto while_continue___0;
    }
#line 1468
    if ((int )c == 62) {
#line 1470
      if (anglelev > 0) {
#line 1472
        anglelev --;
#line 1473
        if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1473
          if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1475
            if (addangle) {
#line 1476
              buflim ++;
            }
#line 1477
            addangle = 0;
          }
        }
      } else
#line 1480
      if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1480
        if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1483
          if (copylev > 0) {
#line 1483
            if ((unsigned long )bp___3 > (unsigned long )bufhead) {
#line 1484
              bp___3 --;
            }
          }
#line 1485
          quoteit = 1;
#line 1486
          goto while_continue___0;
        }
      }
#line 1488
      tmp___32 = copylev;
#line 1488
      copylev ++;
#line 1488
      if (tmp___32 <= 0) {
        {
#line 1489
        while (1) {
          while_continue___29: /* CIL Label */ ;
#line 1489
          if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1489
            if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1489
              tmp___31 = bp___3;
#line 1489
              bp___3 ++;
#line 1489
              *tmp___31 = c;
            } else {
#line 1489
              goto returng;
            }
          } else {
#line 1489
            goto returng;
          }
#line 1489
          goto while_break___29;
        }
        while_break___29: /* CIL Label */ ;
        }
      }
#line 1490
      goto while_continue___0;
    }
    putg: 
#line 1495
    if (copylev <= 0) {
#line 1495
      if (! putgmac) {
#line 1497
        if ((unsigned long )bp___3 > (unsigned long )(buf___10)) {
#line 1497
          if ((int )*(bp___3 + -1) == 41) {
            {
#line 1498
            while (1) {
              while_continue___30: /* CIL Label */ ;
#line 1498
              if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1498
                if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1498
                  tmp___33 = bp___3;
#line 1498
                  bp___3 ++;
#line 1498
                  *tmp___33 = (char )' ';
                } else {
#line 1498
                  goto returng;
                }
              } else {
#line 1498
                goto returng;
              }
#line 1498
              goto while_break___30;
            }
            while_break___30: /* CIL Label */ ;
            }
          }
        }
        {
#line 1499
        while (1) {
          while_continue___31: /* CIL Label */ ;
#line 1499
          if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1499
            if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1499
              tmp___34 = bp___3;
#line 1499
              bp___3 ++;
#line 1499
              *tmp___34 = (char)-127;
            } else {
#line 1499
              goto returng;
            }
          } else {
#line 1499
            goto returng;
          }
#line 1499
          goto while_break___31;
        }
        while_break___31: /* CIL Label */ ;
        }
        {
#line 1500
        while (1) {
          while_continue___32: /* CIL Label */ ;
#line 1500
          if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 1500
            if ((unsigned long )buflim <= (unsigned long )bufend) {
#line 1500
              tmp___35 = bp___3;
#line 1500
              bp___3 ++;
#line 1500
              *tmp___35 = (char )'g';
            } else {
#line 1500
              goto returng;
            }
          } else {
#line 1500
            goto returng;
          }
#line 1500
          goto while_break___32;
        }
        while_break___32: /* CIL Label */ ;
        }
#line 1501
        putgmac = 1;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1506
  if (realqmode) {
#line 1506
    if ((unsigned long )bp___3 < (unsigned long )bufend) {
#line 1507
      tmp___37 = bp___3;
#line 1507
      bp___3 ++;
#line 1507
      *tmp___37 = (char )'\"';
    }
  }
  {
#line 1508
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 1508
    tmp___39 = realcmtlev;
#line 1508
    realcmtlev --;
#line 1508
    if (tmp___39 > 0) {
#line 1508
      if (! ((unsigned long )bp___3 < (unsigned long )bufend)) {
#line 1508
        goto while_break___33;
      }
    } else {
#line 1508
      goto while_break___33;
    }
#line 1509
    tmp___38 = bp___3;
#line 1509
    bp___3 ++;
#line 1509
    *tmp___38 = (char )')';
  }
  while_break___33: /* CIL Label */ ;
  }
#line 1510
  if (addangle) {
#line 1510
    if ((unsigned long )bp___3 < (unsigned long )bufend) {
#line 1511
      tmp___40 = bp___3;
#line 1511
      bp___3 ++;
#line 1511
      *tmp___40 = (char )'>';
    }
  }
#line 1512
  *bp___3 = (char )'\000';
#line 1513
  if ((unsigned long )bp___3 < (unsigned long )bufend) {
#line 1514
    goto success;
  }
  returng: 
  {
#line 1518
  buf___10[0] = (char )'<';
#line 1519
  buf___10[1] = (char)-127;
#line 1520
  buf___10[2] = (char )'g';
#line 1521
  buf___10[3] = (char )'>';
#line 1522
  buf___10[4] = (char )'\000';
#line 1523
  sm_syslog(1, (char const   *)e->e_id, "Dropped invalid comments from header address");
  }
  success: 
#line 1527
  if ((int )tTdvect[33] >= 1) {
    {
#line 1529
    sm_dprintf((char *)"crackaddr=>`");
#line 1530
    tmp___41 = sm_debug_file();
#line 1530
    xputs(tmp___41, (char const   *)(buf___10));
#line 1531
    sm_dprintf((char *)"\'\n");
    }
  }
#line 1533
  return (buf___10);
}
}
#line 1551 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
bool putheader(struct mailer_con_info *mci , HDR *hdr , ENVELOPE *e , int flags ) 
{ 
  register HDR *h ;
  char buf___16[8192] ;
  char obuf[2048] ;
  register char *p ;
  char *q ;
  SM_FILE_T *tmp ;
  size_t len___0 ;
  int tmp___0 ;
  bool tmp___1 ;
  size_t len___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  size_t len___2 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool oldstyle ;
  bool tmp___10 ;
  bool tmp___11 ;
  char *tmp___12 ;
  bool tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  bool tmp___16 ;
  char *tmp___17 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
#line 1562
  if ((int )tTdvect[34] >= 1) {
    {
#line 1563
    sm_dprintf((char *)"--- putheader, mailer = %s ---\n", (mci->mci_mailer)->m_name);
    }
  }
#line 1572
  if (! ((mci->mci_flags & 16384UL) != 0UL)) {
#line 1573
    mci->mci_flags |= 512UL;
  }
#line 1575
  h = hdr;
  {
#line 1575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1575
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 1575
      goto while_break;
    }
#line 1577
    p = h->h_value;
#line 1580
    if ((int )tTdvect[34] >= 11) {
      {
#line 1582
      sm_dprintf((char *)"  %s: ", h->h_field);
#line 1583
      tmp = sm_debug_file();
#line 1583
      xputs(tmp, (char const   *)p);
      }
    }
#line 1587
    if ((unsigned long )h->h_value == (unsigned long )((void *)0)) {
#line 1588
      goto __Cont;
    }
#line 1591
    if (MaxMimeFieldLength > 0) {
      {
#line 1591
      tmp___0 = macid_parse((char *)"{checkMIMEFieldHeaders}", (char **)((void *)0));
#line 1591
      tmp___1 = wordinclass(h->h_field, tmp___0);
      }
#line 1591
      if (tmp___1) {
        {
#line 1597
        len___0 = fix_mime_header(h, e);
        }
#line 1598
        if (len___0 > 0U) {
          {
#line 1600
          sm_syslog(1, (char const   *)e->e_id, "Truncated MIME %s header due to field size (length = %ld) (possible attack)",
                    h->h_field, (unsigned long )len___0);
          }
#line 1603
          if ((int )tTdvect[34] >= 11) {
            {
#line 1604
            sm_dprintf((char *)"  truncated MIME %s header due to field size  (length = %ld) (possible attack)\n",
                       h->h_field, (unsigned long )len___0);
            }
          }
        }
      }
    }
#line 1610
    if (MaxMimeHeaderLength > 0) {
      {
#line 1610
      tmp___2 = macid_parse((char *)"{checkMIMETextHeaders}", (char **)((void *)0));
#line 1610
      tmp___3 = wordinclass(h->h_field, tmp___2);
      }
#line 1610
      if (tmp___3) {
        {
#line 1616
        len___1 = strlen((char const   *)h->h_value);
        }
#line 1617
        if (len___1 > (size_t )MaxMimeHeaderLength) {
          {
#line 1619
          *(h->h_value + (MaxMimeHeaderLength - 1)) = (char )'\000';
#line 1620
          sm_syslog(1, (char const   *)e->e_id, "Truncated long MIME %s header (length = %ld) (possible attack)",
                    h->h_field, (unsigned long )len___1);
          }
#line 1623
          if ((int )tTdvect[34] >= 11) {
            {
#line 1624
            sm_dprintf((char *)"  truncated long MIME %s header (length = %ld) (possible attack)\n",
                       h->h_field, (unsigned long )len___1);
            }
          }
        }
      }
    }
#line 1630
    if (MaxMimeHeaderLength > 0) {
      {
#line 1630
      tmp___5 = macid_parse((char *)"{checkMIMEHeaders}", (char **)((void *)0));
#line 1630
      tmp___6 = wordinclass(h->h_field, tmp___5);
      }
#line 1630
      if (tmp___6) {
        {
#line 1636
        len___2 = strlen((char const   *)h->h_value);
#line 1637
        tmp___4 = shorten_rfc822_string(h->h_value, (size_t )MaxMimeHeaderLength);
        }
#line 1637
        if (tmp___4) {
#line 1640
          if (len___2 < (size_t )MaxMimeHeaderLength) {
            {
#line 1643
            sm_syslog(1, (char const   *)e->e_id, "Fixed MIME %s header (possible attack)",
                      h->h_field);
            }
#line 1646
            if ((int )tTdvect[34] >= 11) {
              {
#line 1647
              sm_dprintf((char *)"  fixed MIME %s header (possible attack)\n", h->h_field);
              }
            }
          } else {
            {
#line 1653
            sm_syslog(1, (char const   *)e->e_id, "Truncated long MIME %s header (length = %ld) (possible attack)",
                      h->h_field, (unsigned long )len___2);
            }
#line 1657
            if ((int )tTdvect[34] >= 11) {
              {
#line 1658
              sm_dprintf((char *)"  truncated long MIME %s header (length = %ld) (possible attack)\n",
                         h->h_field, (unsigned long )len___2);
              }
            }
          }
        }
      }
    }
#line 1672
    if ((h->h_flags & 4096UL) != 0UL) {
#line 1672
      if ((mci->mci_flags & 25600UL) != 0UL) {
#line 1672
        if (! ((flags & 4) != 0)) {
#line 1677
          if ((int )tTdvect[34] >= 11) {
            {
#line 1678
            sm_dprintf((char *)" (skipped (content-transfer-encoding))\n");
            }
          }
#line 1679
          goto __Cont;
        }
      }
    }
#line 1682
    if ((mci->mci_flags & 16384UL) != 0UL) {
#line 1684
      if ((int )tTdvect[34] >= 11) {
        {
#line 1685
        sm_dprintf((char *)"\n");
        }
      }
      {
#line 1686
      tmp___7 = put_vanilla_header(h, p, mci);
      }
#line 1686
      if (! tmp___7) {
#line 1687
        goto writeerr;
      }
#line 1688
      goto __Cont;
    }
#line 1691
    if ((h->h_flags & 48UL) != 0UL) {
      {
#line 1691
      tmp___8 = bitintersect((unsigned int *)(h->h_mflags), (unsigned int *)((mci->mci_mailer)->m_flags));
      }
#line 1691
      if (! tmp___8) {
#line 1691
        if ((int )h->h_macro == 0) {
#line 1691
          goto _L;
        } else {
          {
#line 1691
          q = macvalue((int )((unsigned int )h->h_macro & 255U), e);
          }
#line 1691
          if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 1691
            goto _L;
          } else
#line 1691
          if ((int )*q == 0) {
            _L: /* CIL Label */ 
#line 1697
            if ((int )tTdvect[34] >= 11) {
              {
#line 1698
              sm_dprintf((char *)" (skipped)\n");
              }
            }
#line 1699
            goto __Cont;
          }
        }
      }
    }
#line 1703
    if ((h->h_flags & 8UL) != 0UL) {
#line 1703
      if (! ((e->e_flags & 256UL) != 0UL)) {
#line 1705
        if ((int )tTdvect[34] >= 11) {
          {
#line 1706
          sm_dprintf((char *)" (skipped (resent))\n");
          }
        }
#line 1707
        goto __Cont;
      }
    }
#line 1711
    if ((h->h_flags & 1024UL) != 0UL) {
#line 1711
      if (RrtImpliesDsn) {
#line 1711
        goto _L___0;
      } else
#line 1711
      if ((e->e_flags & 65536UL) != 0UL) {
        _L___0: /* CIL Label */ 
#line 1714
        if ((int )tTdvect[34] >= 11) {
          {
#line 1715
          sm_dprintf((char *)" (skipped (receipt))\n");
          }
        }
#line 1716
        goto __Cont;
      }
    }
#line 1720
    if ((h->h_flags & 4UL) != 0UL) {
#line 1720
      goto _L___1;
    } else
#line 1720
    if ((h->h_flags & 131072UL) != 0UL) {
      _L___1: /* CIL Label */ 
      {
#line 1723
      expand(p, buf___16, (size_t )sizeof(buf___16), e);
#line 1724
      p = buf___16;
      }
#line 1725
      if ((int )*p == 0) {
#line 1727
        if ((int )tTdvect[34] >= 11) {
          {
#line 1728
          sm_dprintf((char *)" (skipped -- null value)\n");
          }
        }
#line 1729
        goto __Cont;
      }
    }
#line 1733
    if ((h->h_flags & 16384UL) != 0UL) {
#line 1736
      if ((e->e_flags & 64UL) != 0UL) {
#line 1738
        if ((int )tTdvect[34] >= 11) {
          {
#line 1739
          sm_dprintf((char *)" (skipped -- bcc)\n");
          }
        }
      } else {
        {
#line 1744
        sm_strlcpyn(obuf, (ssize_t )sizeof(obuf), 2, h->h_field, ":");
#line 1746
        tmp___9 = putline(obuf, mci);
        }
#line 1746
        if (! tmp___9) {
#line 1747
          goto writeerr;
        }
      }
#line 1749
      goto __Cont;
    }
#line 1752
    if ((int )tTdvect[34] >= 11) {
      {
#line 1753
      sm_dprintf((char *)"\n");
      }
    }
#line 1755
    if ((h->h_flags & 258UL) != 0UL) {
#line 1758
      oldstyle = (e->e_flags & 1UL) != 0UL;
#line 1760
      if ((h->h_flags & 256UL) != 0UL) {
#line 1761
        oldstyle = 0;
      }
      {
#line 1762
      commaize(h, p, oldstyle, mci, e);
      }
    } else {
      {
#line 1766
      tmp___10 = put_vanilla_header(h, p, mci);
      }
#line 1766
      if (! tmp___10) {
#line 1767
        goto writeerr;
      }
    }
    __Cont: /* CIL Label */ 
#line 1575
    h = h->h_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 1777
  if ((MimeMode & 4) != 0) {
#line 1777
    if ((e->e_flags & 131072UL) != 0UL) {
#line 1777
      if (! ((e->e_flags & 8388608UL) != 0UL)) {
#line 1777
        if (! ((mci->mci_mailer)->m_flags[56UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 56UL % (8UL * sizeof(int ))))) {
#line 1777
          if (! ((mci->mci_flags & 25600UL) != 0UL)) {
            {
#line 1777
            tmp___17 = hvalue((char *)"MIME-Version", e->e_header);
            }
#line 1777
            if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
              {
#line 1784
              tmp___11 = putline((char *)"MIME-Version: 1.0", mci);
              }
#line 1784
              if (! tmp___11) {
#line 1785
                goto writeerr;
              }
              {
#line 1786
              tmp___14 = hvalue((char *)"Content-Type", e->e_header);
              }
#line 1786
              if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
                {
#line 1788
                tmp___12 = defcharset(e);
#line 1788
                sm_snprintf(obuf, (size_t )sizeof(obuf), "Content-Type: text/plain; charset=%s",
                            tmp___12);
#line 1791
                tmp___13 = putline(obuf, mci);
                }
#line 1791
                if (! tmp___13) {
#line 1792
                  goto writeerr;
                }
              }
              {
#line 1794
              tmp___15 = hvalue((char *)"Content-Transfer-Encoding", e->e_header);
              }
#line 1794
              if ((unsigned long )tmp___15 == (unsigned long )((void *)0)) {
                {
#line 1794
                tmp___16 = putline((char *)"Content-Transfer-Encoding: 8bit", mci);
                }
#line 1794
                if (! tmp___16) {
#line 1796
                  goto writeerr;
                }
              }
            }
          }
        }
      }
    }
  }
#line 1799
  return (1);
  writeerr: 
#line 1802
  return (0);
}
}
#line 1816 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
static bool put_vanilla_header(HDR *h , char *v , struct mailer_con_info *mci ) 
{ 
  register char *nlp ;
  register char *obp ;
  int putflags ;
  char obuf[2304] ;
  size_t tmp ;
  int l ;
  size_t tmp___0 ;
  bool tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  bool tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1827
  putflags = 4;
#line 1828
  if ((mci->mci_mailer)->m_flags[54UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 54UL % (8UL * sizeof(int )))) {
#line 1829
    putflags |= 2;
  }
  {
#line 1830
  sm_snprintf(obuf, (size_t )sizeof(obuf), "%.200s: ", h->h_field);
#line 1831
  tmp = strlen((char const   *)(obuf));
#line 1831
  obp = obuf + tmp;
  }
  {
#line 1832
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1832
    nlp = strchr((char const   *)v, '\n');
    }
#line 1832
    if (! ((unsigned long )nlp != (unsigned long )((void *)0))) {
#line 1832
      goto while_break;
    }
#line 1836
    l = (int )(nlp - v);
#line 1843
    if ((sizeof(obuf) - (unsigned long )(obp - obuf)) - 1UL < (unsigned long )((size_t )l)) {
#line 1844
      l = (int )((sizeof(obuf) - (unsigned long )(obp - obuf)) - 1UL);
    }
    {
#line 1846
    sm_snprintf(obp, (size_t )(sizeof(obuf) - (unsigned long )(obp - obuf)), "%.*s",
                l, v);
#line 1847
    tmp___0 = strlen((char const   *)(obuf));
#line 1847
    tmp___1 = putxline(obuf, tmp___0, mci, putflags);
    }
#line 1847
    if (! tmp___1) {
#line 1848
      goto writeerr;
    }
#line 1849
    v += l + 1;
#line 1850
    obp = obuf;
#line 1851
    if ((int )*v != 32) {
#line 1851
      if ((int )*v != 9) {
#line 1852
        tmp___2 = obp;
#line 1852
        obp ++;
#line 1852
        *tmp___2 = (char )' ';
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1856
  sm_snprintf(obp, (size_t )(sizeof(obuf) - (unsigned long )(obp - obuf)), "%.*s",
              (int )((sizeof(obuf) - (unsigned long )(obp - obuf)) - 1UL), v);
#line 1858
  tmp___3 = strlen((char const   *)(obuf));
#line 1858
  tmp___4 = putxline(obuf, tmp___3, mci, putflags);
  }
#line 1858
  return (tmp___4);
  writeerr: 
#line 1861
  return (0);
}
}
#line 1880 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
bool commaize(HDR *h , char *p , bool oldstyle , struct mailer_con_info *mci , ENVELOPE *e ) 
{ 
  register char *obp ;
  int opos ;
  int omax ;
  bool firstone ;
  int putflags ;
  char **res ;
  char obuf[2051] ;
  size_t tmp ;
  register char *name ;
  register int c ;
  char savechar ;
  int flags ;
  int status ;
  unsigned short const   **tmp___0 ;
  char *oldp ;
  char pvpbuf[1256] ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *q ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  bool tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  bool tmp___14 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 1891
  firstone = 1;
#line 1892
  putflags = 4;
#line 1901
  if ((int )tTdvect[14] >= 2) {
    {
#line 1902
    sm_dprintf((char *)"commaize(%s: %s)\n", h->h_field, p);
    }
  }
#line 1904
  if ((mci->mci_mailer)->m_flags[54UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 54UL % (8UL * sizeof(int )))) {
#line 1905
    putflags |= 2;
  }
  {
#line 1907
  obp = obuf;
#line 1908
  sm_snprintf(obp, (size_t )(sizeof(obuf) - (unsigned long )(obp - obuf)), "%.200s: ",
              h->h_field);
#line 1912
  tmp = strlen((char const   *)h->h_field);
#line 1912
  opos = (int )(tmp + 2U);
  }
#line 1913
  if (opos > 202) {
#line 1914
    opos = 202;
  }
#line 1915
  obp += opos;
#line 1916
  omax = (mci->mci_mailer)->m_linelimit - 2;
#line 1917
  if (omax < 0) {
#line 1918
    omax = 78;
  } else
#line 1917
  if (omax > 78) {
#line 1918
    omax = 78;
  }
  {
#line 1924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1924
    if (! ((int )*p != 0)) {
#line 1924
      goto while_break;
    }
    {
#line 1941
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1941
      if (((int )*p & -128) == 0) {
        {
#line 1941
        tmp___0 = __ctype_b_loc();
        }
#line 1941
        if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 1941
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1941
      if (! ((int )*p == 44)) {
#line 1941
        goto while_break___0;
      }
#line 1942
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1943
    name = p;
#line 1944
    res = (char **)((void *)0);
    {
#line 1945
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1950
      if (oldstyle) {
#line 1950
        tmp___1 = ' ';
      } else {
#line 1950
        tmp___1 = ',';
      }
      {
#line 1950
      res = prescan(p, tmp___1, pvpbuf, (int )sizeof(pvpbuf), & oldp, (unsigned char *)((void *)0),
                    0);
#line 1952
      p = oldp;
      }
      {
#line 1963
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1963
        if ((int )*p != 0) {
#line 1963
          if (((int )*p & -128) == 0) {
            {
#line 1963
            tmp___2 = __ctype_b_loc();
            }
#line 1963
            if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 1963
              goto while_break___2;
            }
          } else {
#line 1963
            goto while_break___2;
          }
        } else {
#line 1963
          goto while_break___2;
        }
#line 1964
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1966
      if ((int )*p != 64) {
#line 1968
        p = oldp;
#line 1969
        goto while_break___1;
      }
#line 1971
      p ++;
      {
#line 1972
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1972
        if ((int )*p != 0) {
#line 1972
          if (((int )*p & -128) == 0) {
            {
#line 1972
            tmp___3 = __ctype_b_loc();
            }
#line 1972
            if (! ((int const   )*(*tmp___3 + (int )*p) & 8192)) {
#line 1972
              goto while_break___3;
            }
          } else {
#line 1972
            goto while_break___3;
          }
        } else {
#line 1972
          goto while_break___3;
        }
#line 1973
        p ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1978
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1978
      if ((unsigned long )p >= (unsigned long )name) {
#line 1978
        if (((int )*p & -128) == 0) {
          {
#line 1978
          tmp___4 = __ctype_b_loc();
          }
#line 1978
          if (! ((int const   )*(*tmp___4 + (int )*p) & 8192)) {
#line 1978
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1978
        if (! ((int )*p == 44)) {
#line 1978
          if (! ((int )*p == 0)) {
#line 1978
            goto while_break___4;
          }
        }
      } else {
#line 1978
        goto while_break___4;
      }
#line 1980
      p --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1981
    p ++;
#line 1981
    if ((unsigned long )p == (unsigned long )name) {
#line 1982
      goto while_continue;
    }
#line 1989
    if ((unsigned long )res == (unsigned long )((void *)0)) {
#line 1989
      if ((unsigned long )p > (unsigned long )name) {
#line 1989
        if (((int )*p & -128) == 0) {
          {
#line 1989
          tmp___5 = __ctype_b_loc();
          }
#line 1989
          if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 1989
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1989
        if (! ((int )*p == 44)) {
#line 1989
          if (! ((int )*p == 0)) {
#line 1991
            p --;
          }
        }
      }
    }
#line 1992
    savechar = *p;
#line 1993
    *p = (char )'\000';
#line 1996
    flags = 10;
#line 1997
    if ((h->h_flags & 256UL) != 0UL) {
#line 1998
      flags |= 1;
    } else
#line 2000
    if ((unsigned long )e->e_from.q_mailer != (unsigned long )((void *)0)) {
#line 2000
      if ((e->e_from.q_mailer)->m_flags[106UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 106UL % (8UL * sizeof(int )))) {
        {
#line 2005
        q = udbsender(name, e->e_rpool);
        }
#line 2006
        if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 2007
          name = q;
        }
      }
    }
    {
#line 2010
    status = 0;
#line 2011
    name = remotename(name, mci->mci_mailer, flags, & status, e);
    }
#line 2012
    if ((int )*name == 0) {
#line 2014
      *p = savechar;
#line 2015
      goto while_continue;
    }
    {
#line 2017
    name = denlstring(name, 0, 1);
#line 2020
    tmp___6 = strlen((char const   *)name);
#line 2020
    opos = (int )((size_t )opos + tmp___6);
    }
#line 2021
    if (! firstone) {
#line 2022
      opos += 2;
    }
#line 2023
    if (opos > omax) {
#line 2023
      if (! firstone) {
        {
#line 2025
        sm_strlcpy(obp, ",\n", (ssize_t )(sizeof(obuf) - (unsigned long )(obp - obuf)));
#line 2026
        tmp___7 = strlen((char const   *)(obuf));
#line 2026
        tmp___8 = putxline(obuf, tmp___7, mci, putflags);
        }
#line 2026
        if (! tmp___8) {
#line 2027
          goto writeerr;
        }
        {
#line 2028
        obp = obuf;
#line 2029
        sm_strlcpy(obp, "        ", (ssize_t )sizeof(obuf));
#line 2030
        tmp___9 = strlen((char const   *)obp);
#line 2030
        opos = (int )tmp___9;
#line 2031
        obp += opos;
#line 2032
        tmp___10 = strlen((char const   *)name);
#line 2032
        opos = (int )((size_t )opos + tmp___10);
        }
      } else {
#line 2023
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2034
    if (! firstone) {
      {
#line 2036
      sm_strlcpy(obp, ", ", (ssize_t )(sizeof(obuf) - (unsigned long )(obp - obuf)));
#line 2037
      obp += 2;
      }
    }
    {
#line 2040
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2040
      tmp___12 = name;
#line 2040
      name ++;
#line 2040
      c = (int )*tmp___12;
#line 2040
      if (c != 0) {
#line 2040
        if (! ((unsigned long )obp < (unsigned long )(& obuf[2048]))) {
#line 2040
          goto while_break___5;
        }
      } else {
#line 2040
        goto while_break___5;
      }
#line 2041
      tmp___11 = obp;
#line 2041
      obp ++;
#line 2041
      *tmp___11 = (char )c;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2042
    firstone = 0;
#line 2043
    *p = savechar;
  }
  while_break: /* CIL Label */ ;
  }
#line 2045
  if ((unsigned long )obp < (unsigned long )(& obuf[sizeof(obuf)])) {
#line 2046
    *obp = (char )'\000';
  } else {
#line 2048
    obuf[sizeof(obuf) - 1UL] = (char )'\000';
  }
  {
#line 2049
  tmp___13 = strlen((char const   *)(obuf));
#line 2049
  tmp___14 = putxline(obuf, tmp___13, mci, putflags);
  }
#line 2049
  return (tmp___14);
  writeerr: 
#line 2052
  return (0);
}
}
#line 2071 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
HDR *copyheader(HDR *header , SM_RPOOL_T *rpool ) 
{ 
  register HDR *newhdr ;
  HDR *ret ;
  register HDR **tail ;
  void *tmp ;
  char *__cil_tmp7 ;

  {
#line 2078
  tail = & ret;
  {
#line 2080
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2080
    if (! ((unsigned long )header != (unsigned long )((void *)0))) {
#line 2080
      goto while_break;
    }
    {
#line 2082
    tmp = sm_rpool_malloc_tagged_x(rpool, (size_t )sizeof(*newhdr), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c",
                                   2082, SmHeapGroup);
#line 2082
    newhdr = (HDR *)tmp;
#line 2083
    *newhdr = *header;
#line 2084
    *tail = newhdr;
#line 2085
    tail = & newhdr->h_link;
#line 2086
    header = header->h_link;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2088
  *tail = (HDR *)((void *)0);
#line 2090
  return (ret);
}
}
#line 2110 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/headers.c"
static size_t fix_mime_header(HDR *h , ENVELOPE *e ) 
{ 
  char *begin ;
  char *end ;
  size_t len___0 ;
  size_t retlen ;
  char save ;
  char *bp___3 ;
  bool tmp ;
  size_t tmp___0 ;
  char *ep ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2115
  begin = h->h_value;
#line 2117
  len___0 = (size_t )0;
#line 2118
  retlen = (size_t )0;
#line 2120
  if ((unsigned long )begin == (unsigned long )((void *)0)) {
#line 2121
    return ((size_t )0);
  } else
#line 2120
  if ((int )*begin == 0) {
#line 2121
    return ((size_t )0);
  }
  {
#line 2125
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2125
    end = find_character(begin, ';');
    }
#line 2125
    if (! ((unsigned long )end != (unsigned long )((void *)0))) {
#line 2125
      goto while_break;
    }
    {
#line 2127
    save = *end;
#line 2130
    *end = (char )'\000';
#line 2132
    len___0 = strlen((char const   *)begin);
#line 2135
    tmp = shorten_rfc822_string(begin, (size_t )MaxMimeFieldLength);
    }
#line 2135
    if (tmp) {
#line 2137
      if (len___0 < (size_t )MaxMimeFieldLength) {
        {
#line 2140
        sm_syslog(1, (char const   *)e->e_id, "Fixed MIME %s header field (possible attack)",
                  h->h_field);
        }
#line 2143
        if ((int )tTdvect[34] >= 11) {
          {
#line 2144
          sm_dprintf((char *)"  fixed MIME %s header field (possible attack)\n", h->h_field);
          }
        }
      } else {
#line 2150
        retlen = len___0;
      }
    }
    {
#line 2155
    tmp___0 = strlen((char const   *)begin);
#line 2155
    bp___3 = begin + tmp___0;
    }
#line 2156
    if ((unsigned long )bp___3 != (unsigned long )end) {
#line 2158
      ep = end;
#line 2160
      *end = save;
#line 2161
      end = bp___3;
      {
#line 2164
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2164
        if (! ((int )*ep != 0)) {
#line 2164
          goto while_break___0;
        }
#line 2165
        tmp___1 = bp___3;
#line 2165
        bp___3 ++;
#line 2165
        tmp___2 = ep;
#line 2165
        ep ++;
#line 2165
        *tmp___1 = *tmp___2;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2166
      *bp___3 = (char )'\000';
    } else {
#line 2169
      *end = save;
    }
#line 2170
    if ((int )*end == 0) {
#line 2171
      goto while_break;
    }
#line 2174
    begin = end + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 2176
  return (retlen);
}
}
#line 2156 "./sendmail.h"
bool DisConnected ;
#line 23 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
static void putoutmsg(char *msg , bool holdmsg , bool heldmsg ) ;
#line 24
static void puterrmsg(char *msg ) ;
#line 25
static char *fmtmsg(char *eb , char const   *to , char const   *num , char const   *enhsc ,
                    int eno , char const   *fmt , va_list ap ) ;
#line 55 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
static char buf___11[256]  ;
#line 51 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
void fatal_error(SM_EXC_T *exc ) 
{ 
  SM_FILE_T f ;
  int *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 58
  sm_strio_init(& f, buf___11, (size_t )sizeof(buf___11));
#line 59
  sm_exc_write(exc, & f);
#line 60
  sm_io_flush(& f, -2);
#line 61
  tmp = __errno_location();
#line 61
  *tmp = 12;
#line 62
  syserr("!%s", buf___11);
  }
#line 63
  return;
}
}
#line 65 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
char MsgBuf[16384]  ;
#line 66 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
static char HeldMessageBuf[sizeof(MsgBuf)]  ;
#line 277 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
void usrerr(char const   *fmt  , ...) 
{ 
  char *enhsc ;
  char *errtxt ;
  va_list ap ;
  char buf___16[2048] ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 290
  if ((int const   )*(fmt + 0) == 53) {
#line 291
    enhsc = (char *)"5.0.0";
  } else
#line 290
  if ((int const   )*(fmt + 0) == 54) {
#line 291
    enhsc = (char *)"5.0.0";
  } else
#line 292
  if ((int const   )*(fmt + 0) == 52) {
#line 293
    enhsc = (char *)"4.0.0";
  } else
#line 292
  if ((int const   )*(fmt + 0) == 56) {
#line 293
    enhsc = (char *)"4.0.0";
  } else
#line 294
  if ((int const   )*(fmt + 0) == 50) {
#line 295
    enhsc = (char *)"2.0.0";
  } else {
#line 297
    enhsc = (char *)((void *)0);
  }
  {
#line 298
  __builtin_va_start(ap, fmt);
#line 299
  errtxt = fmtmsg(MsgBuf, (char const   *)CurEnv->e_to, "550", (char const   *)enhsc,
                  0, fmt, ap);
#line 300
  __builtin_va_end(ap);
  }
#line 302
  if (SuprErrs) {
#line 303
    return;
  }
  {
#line 309
  if ((int )MsgBuf[0] == 56) {
#line 309
    goto case_56;
  }
#line 309
  if ((int )MsgBuf[0] == 52) {
#line 309
    goto case_56;
  }
#line 316
  if ((int )MsgBuf[0] == 54) {
#line 316
    goto case_54;
  }
#line 316
  if ((int )MsgBuf[0] == 53) {
#line 316
    goto case_54;
  }
#line 306
  goto switch_break;
  case_56: /* CIL Label */ 
  case_52: /* CIL Label */ 
#line 310
  if ((unsigned long )CurEnv->e_message != (unsigned long )((void *)0)) {
#line 311
    goto switch_break;
  }
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
#line 317
  if ((unsigned long )CurEnv->e_rpool == (unsigned long )((void *)0)) {
#line 317
    if ((unsigned long )CurEnv->e_message != (unsigned long )((void *)0)) {
      {
#line 318
      sm_free_tagged((void *)CurEnv->e_message, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c",
                     318);
      }
    }
  }
#line 319
  if ((int )MsgBuf[0] == 54) {
    {
#line 323
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Postmaster warning: %.*s", (int )sizeof(buf___16) - 22,
                errtxt);
#line 326
    CurEnv->e_message = sm_rpool_strdup_x(CurEnv->e_rpool, (char const   *)(buf___16));
    }
  } else {
    {
#line 331
    CurEnv->e_message = sm_rpool_strdup_x(CurEnv->e_rpool, (char const   *)errtxt);
    }
  }
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 337
  puterrmsg(MsgBuf);
  }
#line 338
  if (LogLevel > 3) {
#line 338
    if (LogUsrErrs) {
      {
#line 339
      sm_syslog(5, (char const   *)CurEnv->e_id, "%.900s", errtxt);
      }
    }
  }
#line 340
  if (QuickAbort) {
    {
#line 341
    sm_exc_raisenew_x(& EtypeQuickAbort, 1);
    }
  }
#line 342
  return;
}
}
#line 363 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
void usrerrenh(char *enhsc , char const   *fmt  , ...) 
{ 
  char *errtxt ;
  va_list ap ;
  char buf___16[2048] ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 376
  if ((unsigned long )enhsc == (unsigned long )((void *)0)) {
#line 376
    goto _L;
  } else
#line 376
  if ((int )*enhsc == 0) {
    _L: /* CIL Label */ 
#line 378
    if ((int const   )*(fmt + 0) == 53) {
#line 379
      enhsc = (char *)"5.0.0";
    } else
#line 378
    if ((int const   )*(fmt + 0) == 54) {
#line 379
      enhsc = (char *)"5.0.0";
    } else
#line 380
    if ((int const   )*(fmt + 0) == 52) {
#line 381
      enhsc = (char *)"4.0.0";
    } else
#line 380
    if ((int const   )*(fmt + 0) == 56) {
#line 381
      enhsc = (char *)"4.0.0";
    } else
#line 382
    if ((int const   )*(fmt + 0) == 50) {
#line 383
      enhsc = (char *)"2.0.0";
    }
  }
  {
#line 385
  __builtin_va_start(ap, fmt);
#line 386
  errtxt = fmtmsg(MsgBuf, (char const   *)CurEnv->e_to, "550", (char const   *)enhsc,
                  0, fmt, ap);
#line 387
  __builtin_va_end(ap);
  }
#line 389
  if (SuprErrs) {
#line 390
    return;
  }
  {
#line 396
  if ((int )MsgBuf[0] == 56) {
#line 396
    goto case_56;
  }
#line 396
  if ((int )MsgBuf[0] == 52) {
#line 396
    goto case_56;
  }
#line 403
  if ((int )MsgBuf[0] == 54) {
#line 403
    goto case_54;
  }
#line 403
  if ((int )MsgBuf[0] == 53) {
#line 403
    goto case_54;
  }
#line 393
  goto switch_break;
  case_56: /* CIL Label */ 
  case_52: /* CIL Label */ 
#line 397
  if ((unsigned long )CurEnv->e_message != (unsigned long )((void *)0)) {
#line 398
    goto switch_break;
  }
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
#line 404
  if ((unsigned long )CurEnv->e_rpool == (unsigned long )((void *)0)) {
#line 404
    if ((unsigned long )CurEnv->e_message != (unsigned long )((void *)0)) {
      {
#line 405
      sm_free_tagged((void *)CurEnv->e_message, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c",
                     405);
      }
    }
  }
#line 406
  if ((int )MsgBuf[0] == 54) {
    {
#line 410
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Postmaster warning: %.*s", (int )sizeof(buf___16) - 22,
                errtxt);
#line 413
    CurEnv->e_message = sm_rpool_strdup_x(CurEnv->e_rpool, (char const   *)(buf___16));
    }
  } else {
    {
#line 418
    CurEnv->e_message = sm_rpool_strdup_x(CurEnv->e_rpool, (char const   *)errtxt);
    }
  }
#line 421
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 424
  puterrmsg(MsgBuf);
  }
#line 425
  if (LogLevel > 3) {
#line 425
    if (LogUsrErrs) {
      {
#line 426
      sm_syslog(5, (char const   *)CurEnv->e_id, "%.900s", errtxt);
      }
    }
  }
#line 427
  if (QuickAbort) {
    {
#line 428
    sm_exc_raisenew_x(& EtypeQuickAbort, 1);
    }
  }
#line 429
  return;
}
}
#line 500 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
void nmessage(char const   *msg  , ...) 
{ 
  char *errtxt ;
  va_list ap ;
  int *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 512
  tmp = __errno_location();
#line 512
  *tmp = 0;
#line 513
  __builtin_va_start(ap, msg);
#line 514
  errtxt = fmtmsg(MsgBuf, (char const   *)((char *)((void *)0)), "050", (char const   *)((char *)((void *)0)),
                  0, msg, ap);
#line 516
  __builtin_va_end(ap);
#line 517
  putoutmsg(MsgBuf, 0, 0);
  }
  {
#line 523
  if ((int )MsgBuf[0] == 56) {
#line 523
    goto case_56;
  }
#line 523
  if ((int )MsgBuf[0] == 52) {
#line 523
    goto case_56;
  }
#line 528
  if ((int )MsgBuf[0] == 53) {
#line 528
    goto case_53;
  }
#line 520
  goto switch_break;
  case_56: /* CIL Label */ 
  case_52: /* CIL Label */ 
#line 524
  if ((unsigned long )CurEnv->e_message != (unsigned long )((void *)0)) {
#line 525
    goto switch_break;
  }
  case_53: /* CIL Label */ 
#line 529
  if ((unsigned long )CurEnv->e_rpool == (unsigned long )((void *)0)) {
#line 529
    if ((unsigned long )CurEnv->e_message != (unsigned long )((void *)0)) {
      {
#line 530
      sm_free_tagged((void *)CurEnv->e_message, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c",
                     530);
      }
    }
  }
  {
#line 531
  CurEnv->e_message = sm_rpool_strdup_x(CurEnv->e_rpool, (char const   *)errtxt);
  }
#line 533
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 535
  return;
}
}
#line 555 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
static void putoutmsg(char *msg , bool holdmsg , bool heldmsg ) 
{ 
  char *errtxt ;
  char msgcode ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int l ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 561
  errtxt = msg;
#line 562
  msgcode = *(msg + 0);
#line 565
  if ((int )tTdvect[54] >= 8) {
#line 566
    if (heldmsg) {
#line 566
      tmp = " (held)";
    } else {
#line 566
      tmp = "";
    }
#line 566
    if (holdmsg) {
#line 566
      tmp___0 = " (hold)";
    } else {
#line 566
      tmp___0 = "";
    }
    {
#line 566
    sm_dprintf((char *)"--- %s%s%s\n", msg, tmp___0, tmp);
    }
  }
#line 570
  if ((int )msgcode == 54) {
#line 571
    *(msg + 0) = (char )'5';
  } else
#line 572
  if ((int )msgcode == 56) {
#line 573
    *(msg + 0) = (char )'4';
  }
#line 576
  if (! heldmsg) {
#line 576
    if ((unsigned long )CurEnv != (unsigned long )((void *)0)) {
#line 576
      if ((unsigned long )CurEnv->e_xfp != (unsigned long )((void *)0)) {
        {
#line 576
        tmp___1 = strchr("45", (int )*(msg + 0));
        }
#line 576
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
          {
#line 578
          sm_io_fprintf(CurEnv->e_xfp, -2, "%s\n", msg);
          }
        }
      }
    }
  }
#line 581
  if (LogLevel > 14) {
#line 581
    if ((int )OpMode == 115) {
#line 581
      goto _L;
    } else
#line 581
    if ((int )OpMode == 100) {
      _L: /* CIL Label */ 
#line 582
      if (heldmsg) {
#line 582
        tmp___2 = " (held)";
      } else {
#line 582
        tmp___2 = "";
      }
#line 582
      if (holdmsg) {
#line 582
        tmp___3 = " (hold)";
      } else {
#line 582
        tmp___3 = "";
      }
      {
#line 582
      sm_syslog(6, (char const   *)CurEnv->e_id, "--- %s%s%s", msg, tmp___3, tmp___2);
      }
    }
  }
#line 586
  if ((int )msgcode == 56) {
#line 587
    *(msg + 0) = (char )'0';
  }
#line 590
  if (! Verbose) {
#line 590
    if ((int )*(msg + 0) == 48) {
#line 591
      return;
    }
  }
#line 592
  if (holdmsg) {
#line 595
    *(msg + 0) = msgcode;
#line 596
    if ((int )HeldMessageBuf[0] == 53) {
#line 596
      if ((int )msgcode == 52) {
#line 597
        return;
      }
    }
    {
#line 598
    sm_strlcpy(HeldMessageBuf, (char const   *)msg, (ssize_t )sizeof(HeldMessageBuf));
    }
#line 599
    return;
  }
  {
#line 602
  sm_io_flush(& SmIoF[1], -2);
  }
#line 604
  if ((unsigned long )OutChannel == (unsigned long )((void *)0)) {
#line 605
    return;
  }
#line 608
  if (((int )*(errtxt + 0) & -128) == 0) {
    {
#line 608
    tmp___4 = __ctype_b_loc();
    }
#line 608
    if ((int const   )*(*tmp___4 + (int )*(errtxt + 0)) & 2048) {
#line 608
      if (((int )*(errtxt + 1) & -128) == 0) {
        {
#line 608
        tmp___5 = __ctype_b_loc();
        }
#line 608
        if ((int const   )*(*tmp___5 + (int )*(errtxt + 1)) & 2048) {
#line 608
          if (((int )*(errtxt + 2) & -128) == 0) {
            {
#line 608
            tmp___6 = __ctype_b_loc();
            }
#line 608
            if ((int const   )*(*tmp___6 + (int )*(errtxt + 2)) & 2048) {
#line 608
              if ((int )*(errtxt + 3) == 32) {
#line 608
                goto _L___0;
              } else
#line 608
              if ((int )*(errtxt + 3) == 45) {
#line 608
                goto _L___0;
              } else
#line 608
              if ((int )*(errtxt + 3) == 0) {
                _L___0: /* CIL Label */ 
                {
#line 612
                errtxt += 4;
#line 613
                l = isenhsc((char const   *)errtxt, ' ');
                }
#line 614
                if (l <= 0) {
                  {
#line 615
                  l = isenhsc((char const   *)errtxt, '\000');
                  }
                }
#line 616
                if (l > 0) {
#line 617
                  errtxt += l + 1;
                }
              }
            }
          }
        }
      }
    }
  }
#line 621
  if (! DisConnected) {
#line 621
    if ((int )OpMode == 115) {
      {
#line 623
      sm_io_fprintf(OutChannel, -2, "%s\r\n", msg);
      }
    } else
#line 621
    if ((int )OpMode == 100) {
      {
#line 623
      sm_io_fprintf(OutChannel, -2, "%s\r\n", msg);
      }
    } else
#line 621
    if ((int )OpMode == 97) {
      {
#line 623
      sm_io_fprintf(OutChannel, -2, "%s\r\n", msg);
      }
    } else {
      {
#line 626
      sm_io_fprintf(OutChannel, -2, "%s\n", errtxt);
      }
    }
  } else {
    {
#line 626
    sm_io_fprintf(OutChannel, -2, "%s\n", errtxt);
    }
  }
#line 628
  if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
#line 629
    if ((int )OpMode == 115) {
#line 629
      tmp___7 = msg;
    } else
#line 629
    if ((int )OpMode == 100) {
#line 629
      tmp___7 = msg;
    } else {
#line 629
      tmp___7 = errtxt;
    }
    {
#line 629
    sm_io_fprintf(TrafficLogFile, -2, "%05d >>> %s\n", CurrentPid, tmp___7);
    }
  }
#line 658
  return;
}
}
#line 672 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
static void puterrmsg(char *msg ) 
{ 
  char msgcode ;

  {
  {
#line 676
  msgcode = *(msg + 0);
#line 679
  putoutmsg(msg, HoldErrs, 0);
  }
#line 682
  if (OnlyOneError) {
#line 683
    HoldErrs = 1;
  }
#line 686
  Errors ++;
#line 688
  if ((unsigned long )CurEnv == (unsigned long )((void *)0)) {
#line 689
    return;
  }
#line 691
  if ((int )msgcode == 54) {
#line 694
    CurEnv->e_flags |= 8192UL;
  } else
#line 696
  if ((int )msgcode == 53) {
#line 696
    if ((CurEnv->e_flags & 4096UL) != 0UL) {
#line 699
      CurEnv->e_flags |= 32UL;
    }
  }
#line 701
  return;
}
}
#line 716 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
int isenhsc(char const   *s , int delim ) 
{ 
  int l ;
  int h ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 723
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 724
    return (0);
  }
#line 725
  if ((int const   )*s == 50) {
#line 725
    goto _L;
  } else
#line 725
  if ((int const   )*s == 52) {
#line 725
    goto _L;
  } else
#line 725
  if ((int const   )*s == 53) {
    _L: /* CIL Label */ 
#line 725
    if (! ((int const   )*(s + 1) == 46)) {
#line 726
      return (0);
    }
  } else {
#line 726
    return (0);
  }
#line 727
  h = 0;
#line 728
  l = 2;
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 729
    if (h < 3) {
#line 729
      if (((int const   )*(s + (l + h)) & -128) == 0) {
        {
#line 729
        tmp = __ctype_b_loc();
        }
#line 729
        if (! ((int const   )*(*tmp + (int )*(s + (l + h))) & 2048)) {
#line 729
          goto while_break;
        }
      } else {
#line 729
        goto while_break;
      }
    } else {
#line 729
      goto while_break;
    }
#line 730
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 731
  if (h == 0) {
#line 732
    return (0);
  } else
#line 731
  if ((int const   )*(s + (l + h)) != 46) {
#line 732
    return (0);
  }
#line 733
  l += h + 1;
#line 734
  h = 0;
  {
#line 735
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 735
    if (h < 3) {
#line 735
      if (((int const   )*(s + (l + h)) & -128) == 0) {
        {
#line 735
        tmp___0 = __ctype_b_loc();
        }
#line 735
        if (! ((int const   )*(*tmp___0 + (int )*(s + (l + h))) & 2048)) {
#line 735
          goto while_break___0;
        }
      } else {
#line 735
        goto while_break___0;
      }
    } else {
#line 735
      goto while_break___0;
    }
#line 736
    h ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 737
  if (h == 0) {
#line 738
    return (0);
  } else
#line 737
  if ((int const   )*(s + (l + h)) != (int const   )delim) {
#line 738
    return (0);
  }
#line 739
  return (l + h);
}
}
#line 759 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
int extenhsc(char const   *s , int delim , char *e ) 
{ 
  int l ;
  int h ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 767
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 768
    return (0);
  }
#line 769
  if ((int const   )*s == 50) {
#line 769
    goto _L;
  } else
#line 769
  if ((int const   )*s == 52) {
#line 769
    goto _L;
  } else
#line 769
  if ((int const   )*s == 53) {
    _L: /* CIL Label */ 
#line 769
    if (! ((int const   )*(s + 1) == 46)) {
#line 770
      return (0);
    }
  } else {
#line 770
    return (0);
  }
#line 771
  h = 0;
#line 772
  l = 2;
#line 773
  *(e + 0) = (char )*(s + 0);
#line 774
  *(e + 1) = (char )'.';
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    if (h < 3) {
#line 775
      if (((int const   )*(s + (l + h)) & -128) == 0) {
        {
#line 775
        tmp = __ctype_b_loc();
        }
#line 775
        if (! ((int const   )*(*tmp + (int )*(s + (l + h))) & 2048)) {
#line 775
          goto while_break;
        }
      } else {
#line 775
        goto while_break;
      }
    } else {
#line 775
      goto while_break;
    }
#line 777
    *(e + (l + h)) = (char )*(s + (l + h));
#line 778
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 780
  if (h == 0) {
#line 781
    return (0);
  } else
#line 780
  if ((int const   )*(s + (l + h)) != 46) {
#line 781
    return (0);
  }
#line 782
  *(e + (l + h)) = (char )'.';
#line 783
  l += h + 1;
#line 784
  h = 0;
  {
#line 785
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 785
    if (h < 3) {
#line 785
      if (((int const   )*(s + (l + h)) & -128) == 0) {
        {
#line 785
        tmp___0 = __ctype_b_loc();
        }
#line 785
        if (! ((int const   )*(*tmp___0 + (int )*(s + (l + h))) & 2048)) {
#line 785
          goto while_break___0;
        }
      } else {
#line 785
        goto while_break___0;
      }
    } else {
#line 785
      goto while_break___0;
    }
#line 787
    *(e + (l + h)) = (char )*(s + (l + h));
#line 788
    h ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 790
  if (h == 0) {
#line 791
    return (0);
  } else
#line 790
  if ((int const   )*(s + (l + h)) != (int const   )delim) {
#line 791
    return (0);
  }
#line 792
  *(e + (l + h)) = (char )'\000';
#line 793
  return (l + h);
}
}
#line 814 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
static char *fmtmsg(char *eb , char const   *to , char const   *num , char const   *enhsc ,
                    int eno , char const   *fmt , va_list ap ) 
{ 
  char del ;
  int l ;
  int spaceleft ;
  char *errtxt ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 826
  spaceleft = (int )sizeof(MsgBuf);
#line 830
  if (((int const   )*(fmt + 0) & -128) == 0) {
    {
#line 830
    tmp = __ctype_b_loc();
    }
#line 830
    if ((int const   )*(*tmp + (int )*(fmt + 0)) & 2048) {
#line 830
      if (((int const   )*(fmt + 1) & -128) == 0) {
        {
#line 830
        tmp___0 = __ctype_b_loc();
        }
#line 830
        if ((int const   )*(*tmp___0 + (int )*(fmt + 1)) & 2048) {
#line 830
          if (((int const   )*(fmt + 2) & -128) == 0) {
            {
#line 830
            tmp___1 = __ctype_b_loc();
            }
#line 830
            if ((int const   )*(*tmp___1 + (int )*(fmt + 2)) & 2048) {
#line 832
              num = fmt;
#line 833
              fmt += 4;
            }
          }
        }
      }
    }
  }
#line 835
  if ((int const   )*(num + 3) == 45) {
#line 836
    del = (char )'-';
  } else {
#line 838
    del = (char )' ';
  }
  {
#line 847
  sm_snprintf(eb, (size_t )spaceleft, "%3.3s%c", num, (int )del);
#line 848
  eb += 4;
#line 849
  spaceleft -= 4;
#line 851
  l = isenhsc(fmt, ' ');
  }
#line 851
  if (l > 0) {
#line 851
    if (l < spaceleft - 4) {
      {
#line 854
      l ++;
#line 855
      sm_strlcpy(eb, fmt, l + 1);
#line 856
      eb += l;
#line 857
      spaceleft -= l;
#line 858
      fmt += l;
      }
    } else {
#line 851
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 860
    l = isenhsc(enhsc, '\000');
    }
#line 860
    if (l > 0) {
#line 860
      if (l < spaceleft - 4) {
        {
#line 863
        sm_strlcpy(eb, enhsc, l + 1);
#line 864
        *(eb + l) = (char )' ';
#line 865
        l ++;
#line 865
        *(eb + l) = (char )'\000';
#line 866
        eb += l;
#line 867
        spaceleft -= l;
        }
      }
    }
  }
#line 876
  errtxt = eb;
#line 879
  if ((unsigned long )FileName != (unsigned long )((void *)0)) {
    {
#line 881
    tmp___2 = shortenstring((char const   *)FileName, (size_t )83);
#line 881
    sm_snprintf(eb, (size_t )spaceleft, "%s: line %d: ", tmp___2, LineNumber);
#line 883
    tmp___3 = strlen((char const   *)eb);
#line 883
    l = (int )tmp___3;
#line 883
    eb += l;
#line 884
    spaceleft -= l;
    }
  }
#line 901
  if ((unsigned long )to != (unsigned long )((void *)0)) {
#line 901
    if ((int const   )*(to + 0) != 0) {
      {
#line 901
      tmp___7 = strncmp(num, "050", (size_t )3);
      }
#line 901
      if (tmp___7 == 0) {
#line 901
        goto _L___0;
      } else {
        {
#line 901
        tmp___8 = strncmp(num, "250", (size_t )3);
        }
#line 901
        if (tmp___8 == 0) {
#line 901
          goto _L___0;
        } else {
          {
#line 901
          tmp___9 = strncmp(num, "252", (size_t )3);
          }
#line 901
          if (tmp___9 == 0) {
#line 901
            goto _L___0;
          } else {
            {
#line 901
            tmp___10 = strncmp(num, "450", (size_t )3);
            }
#line 901
            if (tmp___10 == 0) {
#line 901
              goto _L___0;
            } else {
              {
#line 901
              tmp___11 = strncmp(num, "550", (size_t )3);
              }
#line 901
              if (tmp___11 == 0) {
#line 901
                goto _L___0;
              } else {
                {
#line 901
                tmp___12 = strncmp(num, "553", (size_t )3);
                }
#line 901
                if (tmp___12 == 0) {
                  _L___0: /* CIL Label */ 
                  {
#line 909
                  tmp___4 = shortenstring(to, (size_t )203);
#line 909
                  sm_strlcpyn(eb, spaceleft, 2, tmp___4, "... ");
#line 911
                  tmp___5 = strlen((char const   *)eb);
#line 911
                  spaceleft = (int )((size_t )spaceleft - tmp___5);
                  }
                  {
#line 912
                  while (1) {
                    while_continue: /* CIL Label */ ;
#line 912
                    if (! ((int )*eb != 0)) {
#line 912
                      goto while_break;
                    }
#line 913
                    tmp___6 = eb;
#line 913
                    eb ++;
#line 913
                    *tmp___6 = (char )((int )*tmp___6 & 127);
                  }
                  while_break: /* CIL Label */ ;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 917
  sm_vsnprintf(eb, (size_t )spaceleft, fmt, ap);
#line 918
  tmp___13 = strlen((char const   *)eb);
#line 918
  spaceleft = (int )((size_t )spaceleft - tmp___13);
  }
  {
#line 919
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 919
    if (! ((int )*eb != 0)) {
#line 919
      goto while_break___0;
    }
#line 920
    tmp___14 = eb;
#line 920
    eb ++;
#line 920
    *tmp___14 = (char )((int )*tmp___14 & 127);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 923
  if (eno != 0) {
    {
#line 924
    tmp___15 = sm_errstring(eno);
#line 924
    sm_strlcpyn(eb, spaceleft, 2, ": ", tmp___15);
    }
  }
#line 926
  return (errtxt);
}
}
#line 938 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
void buffer_errors(void) 
{ 


  {
#line 941
  HeldMessageBuf[0] = (char )'\000';
#line 942
  HoldErrs = 1;
#line 943
  return;
}
}
#line 955 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
void flush_errors(bool print ) 
{ 


  {
#line 959
  if (print) {
#line 959
    if ((int )HeldMessageBuf[0] != 0) {
      {
#line 960
      putoutmsg(HeldMessageBuf, 0, 1);
      }
    }
  }
#line 961
  HeldMessageBuf[0] = (char )'\000';
#line 962
  HoldErrs = 0;
#line 963
  return;
}
}
#line 983 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/err.c"
static char buf___12[2048]  ;
#line 654 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 18 "./bf.h"
SM_FILE_T *bfopen(char *filename , mode_t fmode , size_t bsize , long flags ) ;
#line 332 "./sendmail.h"
ADDRESS NullAddress ;
#line 2162
bool FromFlag ;
#line 2606
char *username(void) ;
#line 28 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c"
void clrsessenvelope(ENVELOPE *e ) 
{ 


  {
#line 51
  return;
}
}
#line 72 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c"
ENVELOPE *newenvelope(ENVELOPE *e , ENVELOPE *parent , SM_RPOOL_T *rpool ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 98
  if ((unsigned long )e == (unsigned long )parent) {
#line 99
    parent = e->e_parent;
  }
  {
#line 100
  clearenvelope(e, 1, rpool);
  }
#line 101
  if ((unsigned long )e == (unsigned long )CurEnv) {
    {
#line 102
    memmove((void *)((char *)(& e->e_from)), (void const   *)((char *)(& NullAddress)),
            (size_t )sizeof(e->e_from));
    }
  } else {
    {
#line 106
    memmove((void *)((char *)(& e->e_from)), (void const   *)((char *)(& CurEnv->e_from)),
            (size_t )sizeof(e->e_from));
    }
  }
  {
#line 109
  e->e_parent = parent;
#line 110
  assign_queueid(e);
#line 111
  e->e_ctime = curtime();
  }
#line 112
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 114
    e->e_msgpriority = parent->e_msgsize;
#line 115
    if ((unsigned long )parent->e_quarmsg == (unsigned long )((void *)0)) {
      {
#line 117
      e->e_quarmsg = (char *)((void *)0);
#line 118
      tmp = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 118
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp, (char *)"", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                       119, SmHeapGroup);
      }
    } else {
      {
#line 123
      e->e_quarmsg = sm_rpool_strdup_x(rpool, (char const   *)parent->e_quarmsg);
#line 125
      tmp___0 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 125
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___0, e->e_quarmsg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                       126, SmHeapGroup);
      }
    }
  }
#line 129
  e->e_puthdr = & putheader;
#line 130
  e->e_putbody = & putbody;
#line 131
  if ((unsigned long )CurEnv->e_xfp != (unsigned long )((void *)0)) {
    {
#line 132
    sm_io_flush(CurEnv->e_xfp, -2);
    }
  }
#line 138
  return (e);
}
}
#line 170 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c"
void dropenvelope(ENVELOPE *e , bool fulldrop , bool split ) 
{ 
  bool panic ;
  bool queueit ;
  int msg_timeout ;
  bool failure_return ;
  bool delay_return ;
  bool success_return ;
  bool pmnotify ;
  bool done ;
  register ADDRESS *q ;
  char *id ;
  time_t now ;
  char buf___16[2048] ;
  SM_FILE_T *tmp ;
  SM_FILE_T *tmp___0 ;
  bool tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  ADDRESS *rlist ;
  int tmp___12 ;
  ADDRESS *rlist___0 ;
  char pcopy[256] ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  time_t tmp___17 ;
  char *tmp___18 ;
  ENVELOPE *oldsib ;
  ENVELOPE *ee ;
  __uid_t tmp___19 ;
  char *tmp___20 ;
  bool tmp___21 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;

  {
#line 176
  panic = 0;
#line 177
  queueit = 0;
#line 178
  msg_timeout = 0;
#line 179
  failure_return = 0;
#line 180
  delay_return = 0;
#line 181
  success_return = 0;
#line 182
  pmnotify = (e->e_flags & 8192UL) != 0UL;
#line 183
  done = 0;
#line 185
  id = e->e_id;
#line 189
  if ((int )tTdvect[50] >= 1) {
    {
#line 191
    sm_dprintf((char *)"dropenvelope %p: id=", e);
#line 192
    tmp = sm_debug_file();
#line 192
    xputs(tmp, (char const   *)e->e_id);
#line 193
    sm_dprintf((char *)", flags=");
#line 194
    printenvflags(e);
    }
#line 195
    if ((int )tTdvect[50] >= 10) {
      {
#line 197
      sm_dprintf((char *)"sendq=");
#line 198
      tmp___0 = sm_debug_file();
#line 198
      printaddr(tmp___0, e->e_sendqueue, 1);
      }
    }
  }
#line 202
  if (LogLevel > 84) {
    {
#line 203
    sm_syslog(7, (char const   *)id, "dropenvelope, e_flags=0x%lx, OpMode=%c, pid=%d",
              e->e_flags, (int )OpMode, CurrentPid);
    }
  }
#line 208
  if ((unsigned long )id == (unsigned long )((void *)0)) {
#line 209
    return;
  }
#line 212
  if ((int )OpMode == 118) {
#line 213
    goto simpledrop;
  }
#line 215
  if (LogLevel > 4) {
#line 215
    if ((e->e_flags & 32768UL) != 0UL) {
      {
#line 216
      logsender(e, (char *)((void *)0));
      }
    }
  }
  {
#line 217
  e->e_flags &= 0xffffffffffff7fffUL;
#line 220
  poststats(StatFile);
#line 226
  now = curtime();
  }
#line 227
  if (now >= e->e_ctime + TimeOuts.to_q_return[e->e_timeoutclass]) {
#line 228
    msg_timeout = 1;
  }
#line 229
  if ((e->e_dlvr_flag & 2) != 0) {
#line 229
    if (e->e_deliver_by > 0L) {
#line 229
      if (now >= e->e_ctime + e->e_deliver_by) {
#line 229
        if (! ((e->e_flags & 128UL) != 0UL)) {
#line 233
          msg_timeout = 4;
#line 234
          e->e_flags |= 40UL;
        } else {
#line 229
          goto _L___1;
        }
      } else {
#line 229
        goto _L___1;
      }
    } else {
#line 229
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 236
  if (TimeOuts.to_q_return[e->e_timeoutclass] == -1L) {
#line 236
    if (! ((e->e_flags & 128UL) != 0UL)) {
#line 239
      msg_timeout = 2;
#line 240
      e->e_flags |= 40UL;
    }
  }
#line 243
  e->e_flags &= 0xfffffffffffff7ffUL;
#line 244
  q = e->e_sendqueue;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 244
      goto while_break;
    }
#line 246
    if ((int )q->q_state == 0) {
#line 247
      queueit = 1;
    } else
#line 246
    if ((int )q->q_state == 3) {
#line 247
      queueit = 1;
    } else
#line 246
    if ((int )q->q_state == 4) {
#line 247
      queueit = 1;
    } else
#line 246
    if ((int )q->q_state == 5) {
#line 247
      queueit = 1;
    }
#line 250
    if ((q->q_flags & 128UL) != 0UL) {
#line 250
      if ((msg_timeout & 15) != 0) {
#line 250
        if ((int )q->q_state == 0) {
#line 250
          goto _L___5;
        } else
#line 250
        if ((int )q->q_state == 3) {
#line 250
          goto _L___5;
        } else
#line 250
        if ((int )q->q_state == 4) {
#line 250
          goto _L___5;
        } else
#line 250
        if ((int )q->q_state == 5) {
#line 250
          goto _L___5;
        } else {
#line 250
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 250
      if ((int )q->q_state == 2) {
#line 250
        goto _L___5;
      } else
#line 250
      if ((msg_timeout & 6) != 0) {
        _L___5: /* CIL Label */ 
#line 256
        failure_return = 1;
#line 257
        if (! done) {
#line 257
          if ((unsigned long )q->q_owner == (unsigned long )((void *)0)) {
            {
#line 257
            tmp___1 = emptyaddr(& e->e_from);
            }
#line 257
            if (! tmp___1) {
              {
#line 260
              sendtolist(e->e_from.q_paddr, (ADDRESS *)((void *)0), & e->e_errorqueue,
                         0, e);
#line 262
              done = 1;
              }
            }
          }
        }
      } else {
#line 250
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 265
    if ((q->q_flags & 64UL) != 0UL) {
#line 265
      if ((int )q->q_state == 1) {
#line 265
        if ((q->q_mailer)->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int )))) {
#line 272
          success_return = 1;
        } else {
#line 265
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 265
      if ((q->q_flags & 7168UL) != 0UL) {
#line 272
        success_return = 1;
      } else {
#line 265
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 265
    if ((q->q_flags & 32768UL) != 0UL) {
#line 272
      success_return = 1;
    } else
#line 265
    if ((q->q_flags & 131072UL) != 0UL) {
#line 272
      success_return = 1;
    }
#line 244
    q = q->q_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  if ((int )e->e_class < 0) {
#line 277
    e->e_flags |= 4UL;
  }
#line 283
  if (! (! queueit)) {
#line 286
    if ((msg_timeout & 15) != 0) {
#line 288
      if (failure_return) {
#line 290
        if (msg_timeout == 4) {
          {
#line 292
          sm_snprintf(buf___16, (size_t )sizeof(buf___16), "delivery time expired %lds",
                      e->e_deliver_by);
          }
        } else {
          {
#line 298
          tmp___2 = pintvl(TimeOuts.to_q_return[e->e_timeoutclass], 0);
#line 298
          sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Cannot send message for %s",
                      tmp___2);
          }
        }
        {
#line 305
        e->e_message = sm_rpool_strdup_x(e->e_rpool, (char const   *)(buf___16));
#line 306
        message((char const   *)(buf___16));
#line 307
        e->e_flags |= 8UL;
        }
      }
#line 309
      if (msg_timeout == 4) {
        {
#line 311
        sm_io_fprintf(e->e_xfp, -2, "Delivery time (%lds) expired\n", e->e_deliver_by);
        }
      } else {
        {
#line 316
        tmp___3 = pintvl(TimeOuts.to_q_return[e->e_timeoutclass], 0);
#line 316
        sm_io_fprintf(e->e_xfp, -2, "Message could not be delivered for %s\n", tmp___3);
        }
      }
      {
#line 320
      sm_io_fprintf(e->e_xfp, -2, "Message will be deleted from queue\n");
#line 322
      q = e->e_sendqueue;
      }
      {
#line 322
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 322
        if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 322
          goto while_break___0;
        }
#line 324
        if ((int )q->q_state == 0) {
#line 324
          goto _L___7;
        } else
#line 324
        if ((int )q->q_state == 3) {
#line 324
          goto _L___7;
        } else
#line 324
        if ((int )q->q_state == 4) {
#line 324
          goto _L___7;
        } else
#line 324
        if ((int )q->q_state == 5) {
          _L___7: /* CIL Label */ 
#line 326
          q->q_state = (short)2;
#line 327
          if (msg_timeout == 4) {
#line 328
            q->q_status = (char *)"5.4.7";
          } else {
#line 330
            q->q_status = (char *)"4.4.7";
          }
        }
#line 322
        q = q->q_next;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 336
      if (TimeOuts.to_q_warning[e->e_timeoutclass] > 0L) {
#line 336
        if (now >= e->e_ctime + TimeOuts.to_q_warning[e->e_timeoutclass]) {
#line 339
          msg_timeout = 16;
        } else {
#line 336
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 340
      if ((e->e_dlvr_flag & 1) != 0) {
#line 340
        if (e->e_deliver_by > 0L) {
#line 340
          if (now >= e->e_ctime + e->e_deliver_by) {
#line 343
            msg_timeout = 32;
          }
        }
      }
#line 345
      if ((msg_timeout & 240) != 0) {
#line 347
        if (! ((e->e_flags & 1152UL) != 0UL)) {
#line 347
          if ((int )e->e_class >= 0) {
#line 347
            if ((unsigned long )e->e_from.q_paddr != (unsigned long )((void *)0)) {
              {
#line 347
              tmp___4 = strcmp((char const   *)e->e_from.q_paddr, "<>");
              }
#line 347
              if (tmp___4 != 0) {
                {
#line 347
                tmp___5 = sm_strncasecmp((char const   *)e->e_from.q_paddr, "owner-",
                                         (size_t )6);
                }
#line 347
                if (tmp___5 != 0) {
                  {
#line 347
                  tmp___6 = strlen((char const   *)e->e_from.q_paddr);
                  }
#line 347
                  if (tmp___6 <= 8U) {
#line 347
                    goto _L___10;
                  } else {
                    {
#line 347
                    tmp___7 = strlen((char const   *)e->e_from.q_paddr);
#line 347
                    tmp___8 = sm_strcasecmp((char const   *)(e->e_from.q_paddr + (tmp___7 - 8U)),
                                            "-request");
                    }
#line 347
                    if (tmp___8 != 0) {
                      _L___10: /* CIL Label */ 
#line 356
                      q = e->e_sendqueue;
                      {
#line 356
                      while (1) {
                        while_continue___1: /* CIL Label */ ;
#line 356
                        if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 356
                          goto while_break___1;
                        }
#line 359
                        if ((int )q->q_state == 0) {
#line 359
                          goto _L___9;
                        } else
#line 359
                        if ((int )q->q_state == 3) {
#line 359
                          goto _L___9;
                        } else
#line 359
                        if ((int )q->q_state == 4) {
#line 359
                          goto _L___9;
                        } else
#line 359
                        if ((int )q->q_state == 5) {
                          _L___9: /* CIL Label */ 
#line 366
                          if (msg_timeout == 32) {
#line 366
                            if ((q->q_flags & 256UL) != 0UL) {
#line 374
                              q->q_flags |= 65536UL;
#line 375
                              delay_return = 1;
                            } else
#line 366
                            if (! ((q->q_flags & 512UL) != 0UL)) {
#line 374
                              q->q_flags |= 65536UL;
#line 375
                              delay_return = 1;
                            }
                          }
#line 377
                          if ((q->q_flags & 256UL) != 0UL) {
#line 380
                            q->q_flags |= 8192UL;
#line 381
                            delay_return = 1;
                          }
                        }
#line 356
                        q = q->q_next;
                      }
                      while_break___1: /* CIL Label */ ;
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 386
        if (delay_return) {
#line 388
          if (msg_timeout == 32) {
            {
#line 390
            sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Warning: Delivery time (%lds) exceeded",
                        e->e_deliver_by);
            }
          } else {
            {
#line 395
            tmp___9 = pintvl(TimeOuts.to_q_warning[e->e_timeoutclass], 0);
#line 395
            sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Warning: could not send message for past %s",
                        tmp___9);
            }
          }
          {
#line 401
          e->e_message = sm_rpool_strdup_x(e->e_rpool, (char const   *)(buf___16));
#line 403
          message((char const   *)(buf___16));
#line 404
          e->e_flags |= 1024UL;
          }
        }
#line 406
        if (msg_timeout == 32) {
          {
#line 408
          sm_io_fprintf(e->e_xfp, -2, "Warning: Delivery time (%lds) exceeded\n",
                        e->e_deliver_by);
          }
        } else {
          {
#line 413
          tmp___10 = pintvl(TimeOuts.to_q_warning[e->e_timeoutclass], 0);
#line 413
          sm_io_fprintf(e->e_xfp, -2, "Warning: message still undelivered after %s\n",
                        tmp___10);
          }
        }
        {
#line 417
        tmp___11 = pintvl(TimeOuts.to_q_return[e->e_timeoutclass], 0);
#line 417
        sm_io_fprintf(e->e_xfp, -2, "Will keep trying until message is %s old\n",
                      tmp___11);
        }
      }
    }
  }
#line 424
  if ((int )tTdvect[50] >= 2) {
    {
#line 425
    sm_dprintf((char *)"failure_return=%d delay_return=%d success_return=%d queueit=%d\n",
               failure_return, delay_return, success_return, queueit);
    }
  }
#line 433
  if ((e->e_flags & 32UL) != 0UL) {
#line 433
    if (! failure_return) {
#line 435
      q = e->e_sendqueue;
      {
#line 435
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 435
        if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 435
          goto while_break___2;
        }
#line 437
        if ((int )q->q_state == 0) {
#line 437
          goto _L___11;
        } else
#line 437
        if ((int )q->q_state == 5) {
          _L___11: /* CIL Label */ 
#line 437
          if ((q->q_flags & 128UL) != 0UL) {
#line 441
            failure_return = 1;
#line 442
            q->q_state = (short)2;
          }
        }
#line 435
        q = q->q_next;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 451
  if (success_return) {
#line 451
    if (! failure_return) {
#line 451
      if (! delay_return) {
#line 451
        if (fulldrop) {
#line 451
          if (! ((PrivacyFlags & 2097152UL) != 0UL)) {
            {
#line 451
            tmp___12 = strcmp((char const   *)e->e_from.q_paddr, "<>");
            }
#line 451
            if (tmp___12 != 0) {
#line 455
              rlist = (ADDRESS *)((void *)0);
#line 457
              if ((int )tTdvect[50] >= 8) {
                {
#line 458
                sm_dprintf((char *)"dropenvelope(%s): sending return receipt\n", id);
                }
              }
              {
#line 460
              e->e_flags |= 16UL;
#line 461
              sendtolist(e->e_from.q_paddr, (ADDRESS *)((void *)0), & rlist, 0, e);
#line 462
              returntosender((char *)"Return receipt", rlist, 0, e);
              }
            }
          }
        }
      }
    }
  }
#line 464
  e->e_flags &= 0xffffffffffffffefUL;
#line 470
  if (failure_return) {
#line 470
    goto _L___12;
  } else
#line 470
  if (delay_return) {
    _L___12: /* CIL Label */ 
#line 470
    if ((int )e->e_errormode != 113) {
#line 472
      if ((int )tTdvect[50] >= 8) {
        {
#line 473
        sm_dprintf((char *)"dropenvelope(%s): saving mail\n", id);
        }
      }
      {
#line 474
      panic = savemail(e, ! ((e->e_flags & 4UL) != 0UL));
      }
    }
  }
#line 481
  if (failure_return) {
#line 481
    goto _L___13;
  } else
#line 481
  if (pmnotify) {
    _L___13: /* CIL Label */ 
#line 481
    if ((unsigned long )PostMasterCopy != (unsigned long )((void *)0)) {
#line 481
      if (! ((e->e_flags & 128UL) != 0UL)) {
#line 481
        if ((int )e->e_class >= 0) {
#line 486
          rlist___0 = (ADDRESS *)((void *)0);
#line 489
          if (failure_return) {
            {
#line 491
            expand(PostMasterCopy, pcopy, (size_t )sizeof(pcopy), e);
            }
#line 493
            if ((int )tTdvect[50] >= 8) {
              {
#line 494
              sm_dprintf((char *)"dropenvelope(%s): sending postmaster copy to %s\n",
                         id, pcopy);
              }
            }
            {
#line 496
            sendtolist(pcopy, (ADDRESS *)((void *)0), & rlist___0, 0, e);
            }
          }
#line 498
          if (pmnotify) {
            {
#line 499
            sendtolist((char *)"postmaster", (ADDRESS *)((void *)0), & rlist___0,
                       0, e);
            }
          }
          {
#line 501
          returntosender(e->e_message, rlist___0, 2, e);
          }
        }
      }
    }
  }
  simpledrop: 
#line 510
  if ((int )tTdvect[50] >= 8) {
    {
#line 511
    sm_dprintf((char *)"dropenvelope(%s): at simpledrop, queueit=%d\n", id, queueit);
    }
  }
#line 513
  if (! queueit) {
#line 513
    goto _L___16;
  } else
#line 513
  if ((e->e_flags & 8UL) != 0UL) {
    _L___16: /* CIL Label */ 
#line 515
    if ((int )tTdvect[50] >= 1) {
      {
#line 517
      sm_dprintf((char *)"\n===== Dropping queue files for %s... queueit=%d, e_flags=",
                 e->e_id, queueit);
#line 519
      printenvflags(e);
      }
    }
#line 521
    if (! panic) {
      {
#line 522
      tmp___13 = queuename(e, 'd');
#line 522
      xunlink(tmp___13);
      }
    }
#line 523
    if (panic) {
#line 523
      if (! (QueueMode == 76)) {
#line 523
        goto _L___14;
      }
    } else {
      _L___14: /* CIL Label */ 
      {
#line 533
      tmp___15 = queuename(e, '?');
#line 533
      tmp___16 = xunlink(tmp___15);
      }
#line 533
      if (tmp___16 == 0) {
#line 536
        if (panic) {
#line 536
          tmp___14 = 0;
        } else {
#line 536
          tmp___14 = -1;
        }
        {
#line 536
        upd_qs(e, -1, tmp___14, (char *)"dropenvelope");
        }
      }
    }
#line 539
    if (e->e_ntries > 0) {
#line 539
      if (LogLevel > 9) {
        {
#line 540
        tmp___17 = curtime();
#line 540
        tmp___18 = pintvl(tmp___17 - e->e_ctime, 1);
#line 540
        sm_syslog(6, (char const   *)id, "done; delay=%s, ntries=%d", tmp___18, e->e_ntries);
        }
      }
    }
  } else
#line 544
  if (queueit) {
#line 544
    goto _L___15;
  } else
#line 544
  if (! ((e->e_flags & 2UL) != 0UL)) {
    _L___15: /* CIL Label */ 
#line 546
    if (! split) {
      {
#line 547
      queueup(e, 0, 1);
      }
    } else {
      {
#line 560
      oldsib = e->e_sibling;
#line 561
      e->e_sibling = (ENVELOPE *)((void *)0);
#line 562
      tmp___21 = split_by_recipient(e);
      }
#line 562
      if (! tmp___21) {
#line 562
        if ((e->e_flags & 32UL) != 0UL) {
          {
#line 565
          tmp___19 = geteuid();
#line 565
          tmp___20 = queuename(e, 'd');
#line 565
          syserr("!dropenvelope(%s): cannot commit data file %s, uid=%d", e->e_id,
                 tmp___20, (int )tmp___19);
          }
        }
      }
#line 569
      ee = e->e_sibling;
      {
#line 569
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 569
        if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 569
          goto while_break___3;
        }
        {
#line 570
        queueup(ee, 0, 1);
#line 569
        ee = ee->e_sibling;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 571
      queueup(e, 0, 1);
#line 574
      ee = e->e_sibling;
      }
      {
#line 574
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 574
        if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 574
          goto while_break___4;
        }
#line 577
        if ((int )tTdvect[50] >= 8) {
          {
#line 578
          sm_dprintf((char *)"dropenvelope(%s): unlocking job\n", ee->e_id);
          }
        }
        {
#line 580
        closexscript(ee);
#line 581
        unlockqueue(ee);
        }
#line 584
        if ((unsigned long )ee->e_dfp != (unsigned long )((void *)0)) {
          {
#line 586
          sm_io_close(ee->e_dfp, -2);
#line 588
          ee->e_dfp = (SM_FILE_T *)((void *)0);
          }
        }
#line 590
        ee->e_id = (char *)((void *)0);
#line 591
        ee->e_flags &= 0xffffffffffdfffffUL;
#line 574
        ee = ee->e_sibling;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 593
      e->e_sibling = oldsib;
    }
  }
#line 598
  if ((int )tTdvect[50] >= 8) {
    {
#line 599
    sm_dprintf((char *)"dropenvelope(%s): unlocking job\n", id);
    }
  }
  {
#line 600
  closexscript(e);
#line 601
  unlockqueue(e);
  }
#line 604
  if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
    {
#line 606
    sm_io_close(e->e_dfp, -2);
#line 607
    e->e_dfp = (SM_FILE_T *)((void *)0);
    }
  }
#line 609
  e->e_id = (char *)((void *)0);
#line 610
  e->e_flags &= 0xffffffffffdfffffUL;
#line 611
  return;
}
}
#line 635 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c"
void clearenvelope(ENVELOPE *e , bool fullclear , SM_RPOOL_T *rpool ) 
{ 
  register HDR *bh ;
  register HDR **nhp ;
  char **p ;
  SM_FILE_T *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 646
  if (! fullclear) {
#line 649
    if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
      {
#line 650
      sm_io_close(e->e_xfp, -2);
      }
    }
#line 651
    if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
      {
#line 652
      sm_io_close(e->e_dfp, -2);
      }
    }
#line 653
    tmp = (SM_FILE_T *)((void *)0);
#line 653
    e->e_dfp = tmp;
#line 653
    e->e_xfp = tmp;
  }
  {
#line 667
  *e = BlankEnvelope;
#line 668
  e->e_message = (char *)((void *)0);
#line 669
  e->e_qfletter = (char )'\000';
#line 670
  e->e_quarmsg = (char *)((void *)0);
#line 671
  tmp___0 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 671
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___0, (char *)"", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                   671, SmHeapGroup);
#line 680
  p = & e->e_macro.mac_table[0];
  }
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 680
    if (! ((unsigned long )p <= (unsigned long )(& e->e_macro.mac_table[255]))) {
#line 680
      goto while_break;
    }
#line 684
    if ((unsigned long )*p != (unsigned long )((void *)0)) {
      {
#line 685
      *p = sm_rpool_strdup_x(rpool, (char const   *)*p);
      }
    }
#line 680
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  e->e_rpool = rpool;
#line 695
  e->e_macro.mac_rpool = rpool;
#line 696
  if (Verbose) {
    {
#line 697
    set_delivery_mode('i', e);
    }
  }
#line 698
  bh = BlankEnvelope.e_header;
#line 699
  nhp = & e->e_header;
  {
#line 700
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 700
    if (! ((unsigned long )bh != (unsigned long )((void *)0))) {
#line 700
      goto while_break___0;
    }
    {
#line 702
    tmp___1 = sm_rpool_malloc_tagged_x(rpool, (size_t )sizeof(*bh), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                                       702, SmHeapGroup);
#line 702
    *nhp = (HDR *)tmp___1;
#line 703
    memmove((void *)((char *)*nhp), (void const   *)((char *)bh), (size_t )sizeof(*bh));
#line 704
    bh = bh->h_link;
#line 705
    nhp = & (*nhp)->h_link;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 707
  return;
}
}
#line 725 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c"
void initsys(ENVELOPE *e ) 
{ 
  char buf___16[10] ;
  void *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 742
  openxscript(e);
#line 743
  e->e_ctime = curtime();
#line 744
  e->e_qfletter = (char )'\000';
  }
#line 753
  if ((int )OpMode == 100) {
#line 753
    if ((e->e_flags & 2048UL) != 0UL) {
#line 753
      if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
#line 755
        OutChannel = e->e_xfp;
      }
    }
  }
  {
#line 762
  sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%d", CurrentPid);
#line 763
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, 'p', buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                   763, SmHeapGroup);
#line 766
  sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%d", (int )e->e_hopcount);
#line 767
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, 'c', buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                   767, SmHeapGroup);
#line 770
  settime(e);
#line 773
  sm_getla();
  }
#line 789
  return;
}
}
#line 803 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c"
void settime(ENVELOPE *e ) 
{ 
  register char *p ;
  time_t now ;
  char buf___16[30] ;
  register struct tm *tm ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 812
  now = curtime();
#line 813
  sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%ld", now);
#line 814
  tmp = macid_parse((char *)"{time}", (char **)((void *)0));
#line 814
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp, buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                   814, SmHeapGroup);
#line 815
  tm = gmtime((time_t const   *)(& now));
#line 816
  sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%04d%02d%02d%02d%02d", tm->tm_year + 1900,
              tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min);
#line 819
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, 't', buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                   819, SmHeapGroup);
#line 820
  tmp___0 = ctime((time_t const   *)(& now));
#line 820
  sm_strlcpy(buf___16, (char const   *)tmp___0, (ssize_t )sizeof(buf___16));
#line 821
  p = strchr((char const   *)(buf___16), '\n');
  }
#line 822
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 823
    *p = (char )'\000';
  }
  {
#line 824
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, 'd', buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                   824, SmHeapGroup);
#line 825
  tmp___1 = arpadate(buf___16);
#line 825
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, 'b', tmp___1, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                   825, SmHeapGroup);
#line 826
  tmp___3 = macvalue('a', e);
  }
#line 826
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 827
    tmp___2 = macvalue('b', e);
#line 827
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'a', tmp___2, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                     827, SmHeapGroup);
    }
  }
#line 828
  return;
}
}
#line 849 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c"
void openxscript(ENVELOPE *e ) 
{ 
  register char *p ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 855
  if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
#line 856
    return;
  }
  {
#line 863
  p = queuename(e, 'x');
#line 864
  e->e_xfp = bfopen(p, (mode_t )FileMode, XscriptFileBufferSize, 139264L);
  }
#line 867
  if ((unsigned long )e->e_xfp == (unsigned long )((void *)0)) {
    {
#line 869
    syserr("Can\'t create transcript file %s", p);
#line 870
    e->e_xfp = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)"/dev/null",
                          1, (void const   *)((void *)0));
    }
#line 872
    if ((unsigned long )e->e_xfp == (unsigned long )((void *)0)) {
      {
#line 873
      syserr("!Can\'t open %s", "/dev/null");
      }
    }
  }
  {
#line 875
  sm_io_setvbuf(e->e_xfp, -2, (char *)((void *)0), 1, (size_t )0);
  }
#line 876
  if ((int )tTdvect[46] >= 9) {
    {
#line 878
    sm_dprintf((char *)"openxscript(%s):\n  ", p);
#line 879
    tmp = sm_io_getinfo(e->e_xfp, 3, (void *)0);
#line 879
    dumpfd(tmp, 1, 0);
    }
  }
#line 882
  return;
}
}
#line 896 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c"
void closexscript(ENVELOPE *e ) 
{ 


  {
#line 900
  if ((unsigned long )e->e_xfp == (unsigned long )((void *)0)) {
#line 901
    return;
  }
  {
#line 906
  sm_io_close(e->e_xfp, -2);
#line 907
  e->e_xfp = (SM_FILE_T *)((void *)0);
  }
#line 908
  return;
}
}
#line 948 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c"
void setsender(char *from , ENVELOPE *e , char **delimptr , int delimchar , bool internal ) 
{ 
  register char **pvp ;
  char *realname ;
  char *bp___3 ;
  char buf___16[258] ;
  char pvpbuf[1256] ;
  char const   *tmp ;
  int tmp___0 ;
  char *p ;
  char ebuf[514] ;
  char *host ;
  char *tmp___1 ;
  char nbuf[100] ;
  ADDRESS *tmp___2 ;
  ADDRESS *tmp___3 ;
  ADDRESS *tmp___4 ;
  ADDRESS *tmp___5 ;
  SM_FILE_T *tmp___6 ;
  register char *p___0 ;
  SM_MBDB_T user ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **lastat ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  SM_FILE_T *tmp___16 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;

  {
#line 957
  realname = (char *)((void *)0);
#line 963
  if ((int )tTdvect[45] >= 1) {
#line 964
    if ((unsigned long )from == (unsigned long )((void *)0)) {
#line 964
      tmp = "";
    } else {
#line 964
      tmp = (char const   *)from;
    }
    {
#line 964
    sm_dprintf((char *)"setsender(%s)\n", tmp);
    }
  }
  {
#line 967
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'x', (char *)"", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                   967, SmHeapGroup);
  }
#line 974
  if ((e->e_flags & 2048UL) != 0UL) {
#line 976
    realname = from;
  } else
#line 974
  if ((int )OpMode == 115) {
#line 976
    realname = from;
  } else
#line 974
  if ((int )OpMode == 97) {
#line 976
    realname = from;
  } else
#line 974
  if ((int )OpMode == 100) {
#line 976
    realname = from;
  }
#line 977
  if ((unsigned long )realname == (unsigned long )((void *)0)) {
    {
#line 978
    realname = username();
    }
  } else
#line 977
  if ((int )*(realname + 0) == 0) {
    {
#line 978
    realname = username();
    }
  }
#line 980
  if (ConfigLevel < 2) {
#line 981
    SuprErrs = 1;
  }
  {
#line 983
  tmp___0 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 983
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___0, (char *)"e s", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                   983, SmHeapGroup);
#line 986
  e->e_from.q_state = (short)2;
#line 987
  e->e_from.q_flags = 0UL;
  }
#line 988
  if ((unsigned long )from == (unsigned long )((void *)0)) {
#line 988
    goto _L___0;
  } else {
    {
#line 988
    tmp___5 = parseaddr(from, & e->e_from, 49, delimchar, delimptr, e, 0);
    }
#line 988
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 988
      goto _L___0;
    } else
#line 988
    if ((int )e->e_from.q_state == 2) {
#line 988
      goto _L___0;
    } else
#line 988
    if ((unsigned long )e->e_from.q_mailer == (unsigned long )ProgMailer) {
#line 988
      goto _L___0;
    } else
#line 988
    if ((unsigned long )e->e_from.q_mailer == (unsigned long )FileMailer) {
#line 988
      goto _L___0;
    } else
#line 988
    if ((unsigned long )e->e_from.q_mailer == (unsigned long )InclMailer) {
      _L___0: /* CIL Label */ 
#line 997
      if ((unsigned long )from != (unsigned long )((void *)0)) {
#line 997
        if (LogLevel > 2) {
          {
#line 1002
          p = macvalue('_', e);
          }
#line 1003
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1005
            host = RealHostName;
#line 1007
            if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 1008
              host = MyHostName;
            }
            {
#line 1009
            sm_snprintf(ebuf, (size_t )sizeof(ebuf), "%.*s@%.*s", 256, realname, 256,
                        host);
#line 1012
            p = ebuf;
            }
          }
          {
#line 1014
          tmp___1 = shortenstring((char const   *)from, (size_t )83);
#line 1014
          sm_syslog(5, (char const   *)e->e_id, "setsender: %s: invalid or unparsable, received from %s",
                    tmp___1, p);
          }
        }
      }
#line 1018
      if ((unsigned long )from != (unsigned long )((void *)0)) {
#line 1020
        if (! ((int )e->e_from.q_state == 2)) {
          {
#line 1023
          e->e_status = (char *)"5.1.7";
#line 1024
          usrerrenh(e->e_status, "553 Invalid sender address");
          }
        }
#line 1027
        SuprErrs = 1;
      }
#line 1029
      if ((unsigned long )from == (unsigned long )realname) {
#line 1029
        goto _L;
      } else {
        {
#line 1029
        from = realname;
#line 1029
        tmp___4 = parseaddr(from, & e->e_from, 49, ' ', (char **)((void *)0), e, 0);
        }
#line 1029
        if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
          {
#line 1036
          SuprErrs = 1;
#line 1037
          expand((char *)"\201n", nbuf, (size_t )sizeof(nbuf), e);
#line 1038
          from = sm_rpool_strdup_x(e->e_rpool, (char const   *)(nbuf));
#line 1039
          tmp___2 = parseaddr(from, & e->e_from, 48, ' ', (char **)((void *)0), e,
                              0);
          }
#line 1039
          if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
            {
#line 1039
            from = (char *)"postmaster";
#line 1039
            tmp___3 = parseaddr(from, & e->e_from, 48, ' ', (char **)((void *)0),
                                e, 0);
            }
#line 1039
            if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
              {
#line 1043
              syserr("553 5.3.0 setsender: can\'t even parse postmaster!");
              }
            }
          }
        }
      }
    } else {
#line 1047
      FromFlag = 1;
    }
  }
#line 1048
  e->e_from.q_state = (short)8;
#line 1049
  if ((int )tTdvect[45] >= 5) {
    {
#line 1051
    sm_dprintf((char *)"setsender: QS_SENDER ");
#line 1052
    tmp___6 = sm_debug_file();
#line 1052
    printaddr(tmp___6, & e->e_from, 0);
    }
  }
#line 1054
  SuprErrs = 0;
#line 1057
  if ((e->e_from.q_mailer)->m_flags[64UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 64UL % (8UL * sizeof(int )))) {
    {
#line 1061
    p___0 = udbsender(e->e_from.q_user, e->e_rpool);
    }
#line 1062
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
#line 1063
      from = p___0;
    }
  }
#line 1067
  if ((e->e_from.q_mailer)->m_flags[119UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 119UL % (8UL * sizeof(int )))) {
#line 1071
    if (! internal) {
#line 1074
      if ((unsigned long )FullName == (unsigned long )((void *)0)) {
        {
#line 1075
        FullName = macvalue('x', e);
        }
      }
#line 1076
      if ((unsigned long )FullName != (unsigned long )((void *)0)) {
#line 1078
        if ((int )*(FullName + 0) == 0) {
#line 1079
          FullName = (char *)((void *)0);
        } else {
          {
#line 1081
          FullName = newstr((char const   *)FullName);
          }
        }
      }
    }
#line 1085
    if ((int )*(e->e_from.q_user + 0) != 0) {
      {
#line 1085
      tmp___9 = sm_mbdb_lookup(e->e_from.q_user, & user);
      }
#line 1085
      if (tmp___9 == 0) {
#line 1093
        if ((int )user.mbdb_homedir[0] == 0) {
#line 1094
          e->e_from.q_home = (char *)((void *)0);
        } else {
          {
#line 1095
          tmp___7 = strcmp((char const   *)(user.mbdb_homedir), "/");
          }
#line 1095
          if (tmp___7 == 0) {
#line 1096
            e->e_from.q_home = (char *)"";
          } else {
            {
#line 1098
            e->e_from.q_home = sm_rpool_strdup_x(e->e_rpool, (char const   *)(user.mbdb_homedir));
            }
          }
        }
        {
#line 1100
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'z', e->e_from.q_home, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                         1100, SmHeapGroup);
        }
#line 1103
        if (user.mbdb_uid != 4294967295U) {
#line 1105
          e->e_from.q_uid = user.mbdb_uid;
#line 1106
          e->e_from.q_gid = user.mbdb_gid;
#line 1107
          e->e_from.q_flags |= 1UL;
        }
#line 1111
        if ((unsigned long )FullName == (unsigned long )((void *)0)) {
#line 1111
          if (! internal) {
#line 1111
            if ((int )user.mbdb_fullname[0] != 0) {
              {
#line 1111
              tmp___8 = strcmp((char const   *)(user.mbdb_name), (char const   *)e->e_from.q_user);
              }
#line 1111
              if (tmp___8 == 0) {
                {
#line 1115
                FullName = newstr((char const   *)(user.mbdb_fullname));
                }
              }
            }
          }
        }
      } else {
#line 1120
        e->e_from.q_home = (char *)((void *)0);
      }
    } else {
#line 1120
      e->e_from.q_home = (char *)((void *)0);
    }
#line 1122
    if ((unsigned long )FullName != (unsigned long )((void *)0)) {
#line 1122
      if (! internal) {
        {
#line 1123
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, 'x', FullName, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                         1123, SmHeapGroup);
        }
      }
    }
  } else
#line 1125
  if (! internal) {
#line 1125
    if ((int )OpMode != 100) {
#line 1125
      if ((int )OpMode != 115) {
#line 1127
        if ((unsigned long )e->e_from.q_home == (unsigned long )((void *)0)) {
          {
#line 1129
          e->e_from.q_home = getenv("HOME");
          }
#line 1130
          if ((unsigned long )e->e_from.q_home != (unsigned long )((void *)0)) {
#line 1132
            if ((int )*(e->e_from.q_home) == 0) {
#line 1133
              e->e_from.q_home = (char *)((void *)0);
            } else {
              {
#line 1134
              tmp___10 = strcmp((char const   *)e->e_from.q_home, "/");
              }
#line 1134
              if (tmp___10 == 0) {
#line 1135
                (e->e_from.q_home) ++;
              }
            }
          }
        }
#line 1138
        e->e_from.q_uid = RealUid;
#line 1139
        e->e_from.q_gid = RealGid;
#line 1140
        e->e_from.q_flags |= 1UL;
      }
    }
  }
  {
#line 1148
  pvp = prescan(from, delimchar, pvpbuf, (int )sizeof(pvpbuf), (char **)((void *)0),
                (unsigned char *)((void *)0), 0);
  }
#line 1149
  if ((unsigned long )pvp == (unsigned long )((void *)0)) {
#line 1152
    if (LogLevel > 2) {
      {
#line 1153
      tmp___11 = shortenstring((char const   *)from, (size_t )203);
#line 1153
      sm_syslog(5, (char const   *)e->e_id, "cannot prescan from (%s)", tmp___11);
      }
    }
    {
#line 1156
    finis(1, 1, (int volatile   )ExitStat);
    }
  }
  {
#line 1158
  rewrite(pvp, 3, 0, e, 1000);
#line 1159
  rewrite(pvp, 1, 0, e, 1000);
#line 1160
  rewrite(pvp, 4, 0, e, 1000);
#line 1161
  tmp___12 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 1161
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___12, (char *)((void *)0), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                   1161, SmHeapGroup);
#line 1162
  bp___3 = buf___16 + 1;
#line 1163
  cataddr(pvp, (char **)((void *)0), bp___3, (int )(sizeof(buf___16) - 2UL), '\000');
  }
#line 1164
  if ((int )*bp___3 == 64) {
#line 1164
    if (! ((e->e_from.q_mailer)->m_flags[100UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 100UL % (8UL * sizeof(int ))))) {
      {
#line 1167
      sm_strlcat(bp___3, ">", (ssize_t )(sizeof(buf___16) - 1UL));
#line 1168
      bp___3 --;
#line 1168
      *bp___3 = (char )'<';
      }
    }
  }
  {
#line 1170
  e->e_sender = sm_rpool_strdup_x(e->e_rpool, (char const   *)bp___3);
#line 1171
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'f', e->e_sender, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                   1171, SmHeapGroup);
  }
#line 1174
  if ((unsigned long )e->e_from.q_mailer != (unsigned long )((void *)0)) {
#line 1174
    if ((e->e_from.q_mailer)->m_flags[67UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 67UL % (8UL * sizeof(int )))) {
      {
#line 1180
      tmp___13 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 1180
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___13, (char *)"e s", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                       1180, SmHeapGroup);
#line 1181
      rewrite(pvp, 3, 0, e, 1000);
#line 1182
      rewrite(pvp, 1, 0, e, 1000);
#line 1183
      rewrite(pvp, 4, 0, e, 1000);
#line 1184
      tmp___14 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 1184
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___14, (char *)((void *)0),
                       (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c",
                       1184, SmHeapGroup);
#line 1187
      lastat = (char **)((void *)0);
      }
      {
#line 1187
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1187
        if (! ((unsigned long )*pvp != (unsigned long )((void *)0))) {
#line 1187
          goto while_break;
        }
        {
#line 1189
        tmp___15 = strcmp((char const   *)*pvp, "@");
        }
#line 1189
        if (tmp___15 == 0) {
#line 1190
          lastat = pvp;
        }
#line 1187
        pvp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1192
      if ((unsigned long )lastat != (unsigned long )((void *)0)) {
        {
#line 1194
        e->e_fromdomain = copyplist(lastat, 1, e->e_rpool);
        }
#line 1195
        if ((int )tTdvect[45] >= 3) {
          {
#line 1197
          sm_dprintf((char *)"Saving from domain: ");
#line 1198
          tmp___16 = sm_debug_file();
#line 1198
          printav(tmp___16, e->e_fromdomain);
          }
        }
      }
    }
  }
#line 1202
  return;
}
}
#line 1219 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c"
static struct eflags EnvelopeFlags[29]  = 
#line 1219
  {      {(char *)"OLDSTYLE", 1UL}, 
        {(char *)"INQUEUE", 2UL}, 
        {(char *)"NO_BODY_RETN", 4UL}, 
        {(char *)"CLRQUEUE", 8UL}, 
        {(char *)"SENDRECEIPT", 16UL}, 
        {(char *)"FATALERRS", 32UL}, 
        {(char *)"DELETE_BCC", 64UL}, 
        {(char *)"RESPONSE", 128UL}, 
        {(char *)"RESENT", 256UL}, 
        {(char *)"VRFYONLY", 512UL}, 
        {(char *)"WARNING", 1024UL}, 
        {(char *)"QUEUERUN", 2048UL}, 
        {(char *)"GLOBALERRS", 4096UL}, 
        {(char *)"PM_NOTIFY", 8192UL}, 
        {(char *)"METOO", 16384UL}, 
        {(char *)"LOGSENDER", 32768UL}, 
        {(char *)"NORECEIPT", 65536UL}, 
        {(char *)"HAS8BIT", 131072UL}, 
        {(char *)"NL_NOT_EOL", 262144UL}, 
        {(char *)"CRLF_NOT_EOL", 524288UL}, 
        {(char *)"RET_PARAM", 1048576UL}, 
        {(char *)"HAS_DF", 2097152UL}, 
        {(char *)"IS_MIME", 4194304UL}, 
        {(char *)"DONT_MIME", 8388608UL}, 
        {(char *)"DISCARD", 16777216UL}, 
        {(char *)"TOOBIG", 33554432UL}, 
        {(char *)"SPLIT", 67108864UL}, 
        {(char *)"UNSAFE", 134217728UL}, 
        {(char *)((void *)0), 0UL}};
#line 1252 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/envelope.c"
void printenvflags(ENVELOPE *e ) 
{ 
  register struct eflags *ef ;
  bool first ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1257
  first = 1;
#line 1259
  sm_dprintf((char *)"%lx", e->e_flags);
#line 1260
  ef = EnvelopeFlags;
  }
  {
#line 1260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1260
    if (! ((unsigned long )ef->ef_name != (unsigned long )((void *)0))) {
#line 1260
      goto while_break;
    }
#line 1262
    if (! ((e->e_flags & ef->ef_bit) != 0UL)) {
#line 1263
      goto __Cont;
    }
#line 1264
    if (first) {
      {
#line 1265
      sm_dprintf((char *)"<%s", ef->ef_name);
      }
    } else {
      {
#line 1267
      sm_dprintf((char *)",%s", ef->ef_name);
      }
    }
#line 1268
    first = 0;
    __Cont: /* CIL Label */ 
#line 1260
    ef ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1270
  if (! first) {
    {
#line 1271
    sm_dprintf((char *)">\n");
    }
  }
#line 1272
  return;
}
}
#line 261 "/usr/include/resolv.h"
extern  __attribute__((__nothrow__)) int __res_init(void) ;
#line 265
extern  __attribute__((__nothrow__)) int __res_query(char const   * , int  , int  ,
                                                     u_char * , int  ) ;
#line 266
extern  __attribute__((__nothrow__)) int __res_querydomain(char const   * , char const   * ,
                                                           int  , int  , u_char * ,
                                                           int  ) ;
#line 327
extern  __attribute__((__nothrow__)) int __dn_skipname(u_char const   * , u_char const   * ) ;
#line 50 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
static char MXHostBuf[12800]  ;
#line 79
static int mxrand(char *host ) ;
#line 80
static int fallbackmxrr(int nmx , unsigned short *prefs , char **mxhosts ) ;
#line 102 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
int NumFallbackMXHosts  =    0;
#line 103 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
static char *fbhosts[101]  ;
#line 111 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
static time_t renew  =    (time_t )0;
#line 105 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
int getfallbackmxrr(char *host ) 
{ 
  int i ;
  int rcode ;
  int ttl ;
  time_t tmp ;
  time_t tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 118
  if (NumFallbackMXHosts > 0) {
    {
#line 118
    tmp = curtime();
    }
#line 118
    if (renew > tmp) {
#line 119
      return (NumFallbackMXHosts);
    }
  }
#line 120
  if ((int )*(host + 0) == 91) {
#line 122
    fbhosts[0] = host;
#line 123
    NumFallbackMXHosts = 1;
  } else {
#line 128
    i = 0;
    {
#line 128
    while (1) {
      while_continue: /* CIL Label */ ;
#line 128
      if (! (i < NumFallbackMXHosts)) {
#line 128
        goto while_break;
      }
      {
#line 129
      sm_free_tagged((void *)fbhosts[i], (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c",
                     129);
#line 128
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 132
    NumFallbackMXHosts = getmxrr(host, fbhosts, (unsigned short *)((void *)0), 0,
                                 & rcode, 0, & ttl);
#line 134
    tmp___0 = curtime();
#line 134
    renew = tmp___0 + (time_t )ttl;
#line 135
    i = 0;
    }
    {
#line 135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 135
      if (! (i < NumFallbackMXHosts)) {
#line 135
        goto while_break___0;
      }
      {
#line 136
      fbhosts[i] = newstr((char const   *)fbhosts[i]);
#line 135
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 138
  return (NumFallbackMXHosts);
}
}
#line 157 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
static int fallbackmxrr(int nmx , unsigned short *prefs , char **mxhosts ) 
{ 
  int i ;
  int tmp ;

  {
#line 165
  i = 0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (i < NumFallbackMXHosts) {
#line 165
      if (! (nmx < 100)) {
#line 165
        goto while_break;
      }
    } else {
#line 165
      goto while_break;
    }
#line 167
    if (nmx > 0) {
#line 168
      *(prefs + nmx) = (unsigned short )((int )*(prefs + (nmx - 1)) + 1);
    } else {
#line 170
      *(prefs + nmx) = (unsigned short)0;
    }
#line 171
    tmp = nmx;
#line 171
    nmx ++;
#line 171
    *(mxhosts + tmp) = fbhosts[i];
#line 165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (nmx);
}
}
#line 203 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
int getmxrr(char *host , char **mxhosts , unsigned short *mxprefs , bool droplocalhost ,
            int *rcode , bool tryfallback , int *pttl ) 
{ 
  register unsigned char *eom ;
  register unsigned char *cp ;
  register int i ;
  register int j ;
  register int n ;
  int nmx ;
  register char *bp___3 ;
  HEADER *hp ;
  querybuf answer ;
  int ancount ;
  int qdcount ;
  int buflen___1 ;
  bool seenlocal ;
  unsigned short pref ;
  unsigned short type ;
  unsigned short localpref ;
  char *fallbackMX ;
  bool trycanon ;
  unsigned short *prefs ;
  int (*resfunc)(char const   * , int  , int  , u_char * , int  ) ;
  unsigned short prefer[100] ;
  int weight[100] ;
  int ttl ;
  bool tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  uint16_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  uint16_t tmp___10 ;
  register u_char *t_cp ;
  register u_char *t_cp___0 ;
  register u_char *t_cp___1 ;
  struct __res_state *tmp___11 ;
  register u_char *t_cp___2 ;
  size_t tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  register int temp ;
  register char *temp1 ;
  int tmp___17 ;
  struct hostent *h ;
  int *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  size_t tmp___24 ;
  register char *p ;
  in_addr_t tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  bool tmp___28 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;

  {
#line 215
  nmx = 0;
#line 220
  seenlocal = 0;
#line 222
  localpref = (unsigned short)256;
#line 223
  fallbackMX = FallbackMX;
#line 224
  trycanon = 0;
#line 229
  ttl = 0;
#line 232
  if ((int )tTdvect[8] >= 2) {
    {
#line 233
    sm_dprintf((char *)"getmxrr(%s, droplocalhost=%d)\n", host, droplocalhost);
    }
  }
#line 235
  *rcode = 0;
#line 236
  if ((unsigned long )pttl != (unsigned long )((void *)0)) {
#line 237
    *pttl = 3600;
  }
#line 238
  if ((int )*host == 0) {
#line 239
    return (0);
  }
#line 241
  if ((unsigned long )fallbackMX != (unsigned long )((void *)0)) {
#line 241
    if (droplocalhost) {
      {
#line 241
      tmp = wordinclass(fallbackMX, 'w');
      }
#line 241
      if (tmp) {
#line 245
        fallbackMX = (char *)((void *)0);
      } else {
#line 241
        goto _L___0;
      }
    } else {
#line 241
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 241
  if (! tryfallback) {
#line 245
    fallbackMX = (char *)((void *)0);
  }
#line 248
  if ((unsigned long )mxprefs != (unsigned long )((void *)0)) {
#line 249
    prefs = mxprefs;
  } else {
#line 251
    prefs = prefer;
  }
#line 254
  if ((int )*(host + 0) == 91) {
#line 255
    goto punt;
  }
#line 265
  if (! UseNameServer) {
#line 266
    goto punt;
  }
#line 267
  if (HasWildcardMX) {
#line 267
    if (ConfigLevel >= 6) {
#line 268
      resfunc = & __res_query;
    } else {
#line 270
      resfunc = & __res_search;
    }
  } else {
#line 270
    resfunc = & __res_search;
  }
  {
#line 272
  tmp___0 = __errno_location();
#line 272
  *tmp___0 = 0;
#line 273
  n = (*resfunc)((char const   *)host, 1, 15, (unsigned char *)(& answer), (int )sizeof(answer));
  }
#line 275
  if (n < 0) {
#line 277
    if ((int )tTdvect[8] >= 1) {
      {
#line 278
      tmp___1 = __h_errno_location();
#line 278
      tmp___2 = __errno_location();
      }
#line 278
      if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 278
        tmp___3 = "<NULL>";
      } else {
#line 278
        tmp___3 = (char const   *)host;
      }
      {
#line 278
      sm_dprintf((char *)"getmxrr: res_search(%s) failed (errno=%d, h_errno=%d)\n",
                 tmp___3, *tmp___2, *tmp___1);
      }
    }
    {
#line 280
    tmp___4 = __h_errno_location();
    }
    {
#line 282
    if (*tmp___4 == 4) {
#line 282
      goto case_4;
    }
#line 286
    if (*tmp___4 == 3) {
#line 286
      goto case_3;
    }
#line 290
    if (*tmp___4 == 1) {
#line 290
      goto case_1;
    }
#line 300
    if (*tmp___4 == -1) {
#line 300
      goto case_neg_1;
    }
#line 300
    if (*tmp___4 == 2) {
#line 300
      goto case_neg_1;
    }
#line 311
    goto switch_default;
    case_4: /* CIL Label */ 
#line 283
    trycanon = 1;
    case_3: /* CIL Label */ 
#line 288
    goto punt;
    case_1: /* CIL Label */ 
#line 295
    trycanon = 1;
#line 296
    *rcode = 68;
#line 297
    goto punt;
    case_neg_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 302
    if ((unsigned long )fallbackMX != (unsigned long )((void *)0)) {
      {
#line 305
      tmp___5 = fallbackmxrr(nmx, prefs, mxhosts);
      }
#line 305
      return (tmp___5);
    }
#line 308
    *rcode = 75;
#line 309
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 312
    tmp___6 = __h_errno_location();
#line 312
    syserr("getmxrr: res_search (%s) failed with impossible h_errno (%d)", host, *tmp___6);
#line 314
    *rcode = 71;
    }
#line 315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 319
    return (-1);
  }
#line 323
  if ((unsigned long )n > sizeof(answer)) {
#line 324
    n = (int )sizeof(answer);
  }
  {
#line 327
  hp = (HEADER *)(& answer);
#line 328
  cp = (unsigned char *)(& answer) + 12;
#line 329
  eom = (unsigned char *)(& answer) + n;
#line 330
  tmp___7 = ntohs((unsigned short )hp->qdcount);
#line 330
  qdcount = (int )tmp___7;
  }
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    tmp___8 = qdcount;
#line 330
    qdcount --;
#line 330
    if (! tmp___8) {
#line 330
      goto while_break;
    }
    {
#line 334
    n = __dn_skipname((u_char const   *)cp, (u_char const   *)eom);
    }
#line 334
    if (n < 0) {
#line 335
      goto punt;
    }
#line 330
    cp += n + 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  buflen___1 = (int )(sizeof(MXHostBuf) - 1UL);
#line 340
  if (buflen___1 > 0) {
#line 340
    tmp___9 = 1;
  } else {
    {
#line 340
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c",
                340, "SM_ASSERT(buflen > 0) failed");
#line 340
    tmp___9 = 0;
    }
  }
  {
#line 341
  bp___3 = MXHostBuf;
#line 342
  tmp___10 = ntohs((unsigned short )hp->ancount);
#line 342
  ancount = (int )tmp___10;
  }
  {
#line 346
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 346
    ancount --;
#line 346
    if (ancount >= 0) {
#line 346
      if ((unsigned long )cp < (unsigned long )eom) {
#line 346
        if (! (nmx < 99)) {
#line 346
          goto while_break___0;
        }
      } else {
#line 346
        goto while_break___0;
      }
    } else {
#line 346
      goto while_break___0;
    }
    {
#line 348
    n = __dn_expand((u_char const   *)((unsigned char *)(& answer)), (u_char const   *)eom,
                    (u_char const   *)cp, bp___3, buflen___1);
    }
#line 348
    if (n < 0) {
#line 350
      goto while_break___0;
    }
#line 351
    cp += n;
    {
#line 352
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 352
      t_cp = cp;
#line 352
      type = (unsigned short )(((int )((u_int16_t )*(t_cp + 0)) << 8) | (int )((u_int16_t )*(t_cp + 1)));
#line 352
      cp += 2;
#line 352
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 353
    cp += 2;
    {
#line 354
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 354
      t_cp___0 = cp;
#line 354
      ttl = (int )(((((u_int32_t )*(t_cp___0 + 0) << 24) | ((u_int32_t )*(t_cp___0 + 1) << 16)) | ((u_int32_t )*(t_cp___0 + 2) << 8)) | (u_int32_t )*(t_cp___0 + 3));
#line 354
      cp += 4;
#line 354
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 355
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 355
      t_cp___1 = cp;
#line 355
      n = ((int )((u_int16_t )*(t_cp___1 + 0)) << 8) | (int )((u_int16_t )*(t_cp___1 + 1));
#line 355
      cp += 2;
#line 355
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 356
    if ((int )type != 15) {
#line 358
      if ((int )tTdvect[8] >= 8) {
        {
#line 359
        sm_dprintf((char *)"unexpected answer type %d, size %d\n", (int )type, n);
        }
      } else {
        {
#line 358
        tmp___11 = __res_state();
        }
#line 358
        if (tmp___11->options & 2UL) {
          {
#line 359
          sm_dprintf((char *)"unexpected answer type %d, size %d\n", (int )type, n);
          }
        }
      }
#line 361
      cp += n;
#line 362
      goto while_continue___0;
    }
    {
#line 364
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 364
      t_cp___2 = cp;
#line 364
      pref = (unsigned short )(((int )((u_int16_t )*(t_cp___2 + 0)) << 8) | (int )((u_int16_t )*(t_cp___2 + 1)));
#line 364
      cp += 2;
#line 364
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 365
    n = __dn_expand((u_char const   *)((unsigned char *)(& answer)), (u_char const   *)eom,
                    (u_char const   *)cp, bp___3, buflen___1);
    }
#line 365
    if (n < 0) {
#line 367
      goto while_break___0;
    }
    {
#line 368
    cp += n;
#line 369
    tmp___12 = strlen((char const   *)bp___3);
#line 369
    n = (int )tmp___12;
#line 381
    tmp___13 = wordinclass(bp___3, 'w');
    }
#line 381
    if (tmp___13) {
#line 383
      if ((int )tTdvect[8] >= 3) {
        {
#line 384
        sm_dprintf((char *)"found localhost (%s) in MX list, pref=%d\n", bp___3, (int )pref);
        }
      }
#line 386
      if (droplocalhost) {
#line 388
        if (! seenlocal) {
#line 389
          localpref = pref;
        } else
#line 388
        if ((int )pref < (int )localpref) {
#line 389
          localpref = pref;
        }
#line 390
        seenlocal = 1;
#line 391
        goto while_continue___0;
      }
#line 393
      weight[nmx] = 0;
    } else {
      {
#line 396
      weight[nmx] = mxrand(bp___3);
      }
    }
#line 397
    *(prefs + nmx) = pref;
#line 398
    tmp___14 = nmx;
#line 398
    nmx ++;
#line 398
    *(mxhosts + tmp___14) = bp___3;
#line 399
    bp___3 += n;
#line 400
    if ((int )*(bp___3 + -1) != 46) {
#line 402
      tmp___15 = bp___3;
#line 402
      bp___3 ++;
#line 402
      *tmp___15 = (char )'.';
#line 403
      n ++;
    }
#line 405
    tmp___16 = bp___3;
#line 405
    bp___3 ++;
#line 405
    *tmp___16 = (char )'\000';
#line 406
    if (buflen___1 < n + 1) {
#line 409
      goto while_break___0;
    }
#line 411
    buflen___1 -= n + 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 415
  if (ttl > 0) {
#line 415
    if ((unsigned long )pttl != (unsigned long )((void *)0)) {
#line 416
      *pttl = ttl;
    }
  }
#line 419
  i = 0;
  {
#line 419
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 419
    if (! (i < nmx)) {
#line 419
      goto while_break___5;
    }
#line 421
    j = i + 1;
    {
#line 421
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 421
      if (! (j < nmx)) {
#line 421
        goto while_break___6;
      }
#line 423
      if ((int )*(prefs + i) > (int )*(prefs + j)) {
#line 423
        goto _L___1;
      } else
#line 423
      if ((int )*(prefs + i) == (int )*(prefs + j)) {
#line 423
        if (weight[i] > weight[j]) {
          _L___1: /* CIL Label */ 
#line 429
          temp = (int )*(prefs + i);
#line 430
          *(prefs + i) = *(prefs + j);
#line 431
          *(prefs + j) = (unsigned short )temp;
#line 432
          temp1 = *(mxhosts + i);
#line 433
          *(mxhosts + i) = *(mxhosts + j);
#line 434
          *(mxhosts + j) = temp1;
#line 435
          temp = weight[i];
#line 436
          weight[i] = weight[j];
#line 437
          weight[j] = temp;
        }
      }
#line 421
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 440
    if (seenlocal) {
#line 440
      if ((int )*(prefs + i) >= (int )localpref) {
#line 443
        nmx = i;
      }
    }
#line 419
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 448
  i = 0;
  {
#line 448
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 448
    if (! (i < nmx - 1)) {
#line 448
      goto while_break___7;
    }
    {
#line 450
    tmp___17 = sm_strcasecmp((char const   *)*(mxhosts + i), (char const   *)*(mxhosts + (i + 1)));
    }
#line 450
    if (tmp___17 != 0) {
#line 451
      i ++;
    } else {
#line 455
      j = i + 1;
      {
#line 455
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 455
        if (! (j < nmx)) {
#line 455
          goto while_break___8;
        }
#line 457
        *(mxhosts + j) = *(mxhosts + (j + 1));
#line 458
        *(prefs + j) = *(prefs + (j + 1));
#line 455
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 460
      nmx --;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 464
  if (nmx == 0) {
    punt: 
#line 467
    if (seenlocal) {
#line 469
      h = (struct hostent *)((void *)0);
#line 483
      if (TryNullMXList) {
        {
#line 485
        tmp___18 = __h_errno_location();
#line 485
        *tmp___18 = 0;
#line 486
        tmp___19 = __errno_location();
#line 486
        *tmp___19 = 0;
#line 487
        h = sm_gethostbyname(host, 2);
        }
#line 488
        if ((unsigned long )h == (unsigned long )((void *)0)) {
          {
#line 490
          tmp___20 = __errno_location();
          }
#line 490
          if (*tmp___20 == 110) {
#line 495
            *rcode = 75;
#line 496
            return (-1);
          } else {
            {
#line 490
            tmp___21 = __h_errno_location();
            }
#line 490
            if (*tmp___21 == 2) {
#line 495
              *rcode = 75;
#line 496
              return (-1);
            } else {
              {
#line 490
              tmp___22 = __errno_location();
              }
#line 490
              if (*tmp___22 == 111) {
#line 490
                if (UseNameServer) {
#line 495
                  *rcode = 75;
#line 496
                  return (-1);
                }
              }
            }
          }
        }
      }
#line 515
      if ((unsigned long )h == (unsigned long )((void *)0)) {
        {
#line 517
        *rcode = 78;
#line 518
        syserr("MX list for %s points back to %s", host, MyHostName);
        }
#line 520
        return (-1);
      }
    }
    {
#line 527
    tmp___24 = strlen((char const   *)host);
    }
#line 527
    if ((unsigned long )tmp___24 >= sizeof(MXHostBuf)) {
      {
#line 529
      *rcode = 78;
#line 530
      tmp___23 = shortenstring((char const   *)host, (size_t )203);
#line 530
      syserr("Host name %s too long", tmp___23);
      }
#line 532
      return (-1);
    }
    {
#line 534
    sm_strlcpy(MXHostBuf, (char const   *)host, (ssize_t )sizeof(MXHostBuf));
#line 535
    *(mxhosts + 0) = MXHostBuf;
#line 536
    *(prefs + 0) = (unsigned short)0;
    }
#line 537
    if ((int )*(host + 0) == 91) {
      {
#line 545
      p = strchr((char const   *)(MXHostBuf), ']');
      }
#line 546
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 548
        *p = (char )'\000';
#line 550
        tmp___25 = inet_addr((char const   *)(& MXHostBuf[1]));
        }
#line 550
        if (tmp___25 != 4294967295U) {
#line 552
          nmx ++;
#line 553
          *p = (char )']';
        } else {
#line 565
          trycanon = 1;
#line 566
          (*(mxhosts + 0)) ++;
        }
      }
    }
#line 570
    if (trycanon) {
      {
#line 570
      tmp___28 = getcanonname(*(mxhosts + 0), (int )(sizeof(MXHostBuf) - 2UL), 0,
                              pttl);
      }
#line 570
      if (tmp___28) {
        {
#line 574
        tmp___26 = strlen((char const   *)(MXHostBuf));
#line 574
        bp___3 = & MXHostBuf[tmp___26];
        }
#line 575
        if ((int )*(bp___3 + -1) != 46) {
#line 577
          tmp___27 = bp___3;
#line 577
          bp___3 ++;
#line 577
          *tmp___27 = (char )'.';
#line 578
          *bp___3 = (char )'\000';
        }
#line 580
        nmx = 1;
      }
    }
  }
#line 585
  if ((unsigned long )fallbackMX != (unsigned long )((void *)0)) {
#line 585
    if (! seenlocal) {
      {
#line 587
      nmx = fallbackmxrr(nmx, prefs, mxhosts);
      }
    }
  }
#line 589
  return (nmx);
}
}
#line 611 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
static unsigned int seed  ;
#line 606 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
static int mxrand(char *host ) 
{ 
  int hfunc ;
  time_t tmp ;
  int c ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 613
  if (seed == 0U) {
    {
#line 615
    tmp = curtime();
#line 615
    seed = (unsigned int )((int )tmp & 65535);
    }
#line 616
    if (seed == 0U) {
#line 617
      seed ++;
    }
  }
#line 620
  if ((int )tTdvect[17] >= 9) {
    {
#line 621
    sm_dprintf((char *)"mxrand(%s)", host);
    }
  }
#line 623
  hfunc = (int )seed;
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    if (! ((int )*host != 0)) {
#line 624
      goto while_break;
    }
#line 626
    tmp___0 = host;
#line 626
    host ++;
#line 626
    c = (int )*tmp___0;
#line 628
    if ((c & -128) == 0) {
      {
#line 628
      tmp___1 = __ctype_b_loc();
      }
#line 628
      if ((int const   )*(*tmp___1 + c) & 256) {
        {
#line 629
        c = tolower(c);
        }
      }
    }
#line 630
    hfunc = ((hfunc << 1) ^ c) % 2003;
  }
  while_break: /* CIL Label */ ;
  }
#line 633
  hfunc &= 255;
#line 634
  hfunc ++;
#line 636
  if ((int )tTdvect[17] >= 9) {
    {
#line 637
    sm_dprintf((char *)" = %d\n", hfunc);
    }
  }
#line 638
  return (hfunc);
}
}
#line 648 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
char *bestmx_map_lookup(struct _map *map___0 , char *name , char **av___0 , int *statp ) 
{ 
  int nmx ;
  int saveopts ;
  struct __res_state *tmp ;
  int i ;
  ssize_t len___0 ;
  char *result___0 ;
  char *mxhosts[101] ;
  char *p ;
  char buf___16[628] ;
  struct __res_state *tmp___0 ;
  struct __res_state *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t slen ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 656
  tmp = __res_state();
#line 656
  saveopts = (int )tmp->options;
#line 658
  len___0 = 0;
#line 668
  tmp___0 = __res_state();
#line 668
  tmp___0->options &= 0xfffffffffffffd7fUL;
#line 669
  nmx = getmxrr(name, mxhosts, (unsigned short *)((void *)0), 0, statp, 0, (int *)((void *)0));
#line 670
  tmp___1 = __res_state();
#line 670
  tmp___1->options = (u_long )saveopts;
  }
#line 671
  if (nmx <= 0) {
#line 672
    return ((char *)((void *)0));
  }
#line 673
  if ((map___0->map_mflags & 16L) != 0L) {
    {
#line 674
    tmp___2 = strlen((char const   *)name);
#line 674
    tmp___3 = map_rewrite(map___0, (char const   *)name, tmp___2, (char **)((void *)0));
    }
#line 674
    return (tmp___3);
  }
#line 675
  if ((int )map___0->map_coldelim == 0) {
    {
#line 676
    tmp___4 = strlen((char const   *)mxhosts[0]);
#line 676
    tmp___5 = map_rewrite(map___0, (char const   *)mxhosts[0], tmp___4, av___0);
    }
#line 676
    return (tmp___5);
  } else
#line 675
  if (nmx == 1) {
    {
#line 676
    tmp___4 = strlen((char const   *)mxhosts[0]);
#line 676
    tmp___5 = map_rewrite(map___0, (char const   *)mxhosts[0], tmp___4, av___0);
    }
#line 676
    return (tmp___5);
  }
#line 721
  p = buf___16;
#line 722
  i = 0;
  {
#line 722
  while (1) {
    while_continue: /* CIL Label */ ;
#line 722
    if (! (i < nmx)) {
#line 722
      goto while_break;
    }
    {
#line 726
    tmp___6 = strchr((char const   *)mxhosts[i], (int )map___0->map_coldelim);
    }
#line 726
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
      {
#line 728
      syserr("bestmx_map_lookup: MX host %.64s includes map delimiter character 0x%02X",
             mxhosts[i], (int )map___0->map_coldelim);
      }
#line 730
      return ((char *)((void *)0));
    }
    {
#line 732
    slen = strlen((char const   *)mxhosts[i]);
    }
#line 733
    if ((unsigned long )(((size_t )len___0 + slen) + 2U) > sizeof(buf___16)) {
#line 734
      goto while_break;
    }
#line 735
    if (i > 0) {
#line 737
      tmp___7 = p;
#line 737
      p ++;
#line 737
      *tmp___7 = map___0->map_coldelim;
#line 738
      len___0 ++;
    }
    {
#line 740
    sm_strlcpy(p, (char const   *)mxhosts[i], (ssize_t )(sizeof(buf___16) - (unsigned long )len___0));
#line 741
    p += slen;
#line 742
    len___0 = (ssize_t )((size_t )len___0 + slen);
#line 722
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 746
  result___0 = map_rewrite(map___0, (char const   *)(buf___16), (size_t )len___0,
                           av___0);
  }
#line 750
  return (result___0);
}
}
#line 783 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/domain.c"
bool dns_getcanonname(char *host , int hbsize , bool trymx , int *statp , int *pttl ) 
{ 
  register unsigned char *eom ;
  register unsigned char *ap ;
  register char *cp ;
  register int n ;
  HEADER *hp ;
  querybuf answer ;
  int ancount ;
  int qdcount ;
  int ret ;
  char **domain ;
  int type ;
  int ttl ;
  char **dp ;
  char *mxmatch ;
  bool amatch ;
  bool gotmx ;
  int qtype ;
  int initial ;
  int loopcnt ;
  char nbuf[8192] ;
  char *searchlist[8] ;
  struct __res_state *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  struct __res_state *tmp___2 ;
  char **tmp___3 ;
  char **tmp___4 ;
  char **tmp___5 ;
  struct __res_state *tmp___6 ;
  struct __res_state *tmp___7 ;
  struct __res_state *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  int *tmp___11 ;
  int save_errno ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  uint16_t tmp___17 ;
  uint16_t tmp___18 ;
  int tmp___19 ;
  uint16_t tmp___20 ;
  register u_char *t_cp ;
  register u_char *t_cp___0 ;
  register u_char *t_cp___1 ;
  char ebuf[2048] ;
  int *tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;

  {
#line 800
  ttl = 0;
#line 804
  gotmx = 0;
#line 811
  if ((int )tTdvect[8] >= 2) {
    {
#line 812
    sm_dprintf((char *)"dns_getcanonname(%s, trymx=%d)\n", host, trymx);
    }
  }
  {
#line 814
  tmp = __res_state();
  }
#line 814
  if ((tmp->options & 1UL) == 0UL) {
    {
#line 814
    tmp___0 = __res_init();
    }
#line 814
    if (tmp___0 == -1) {
#line 816
      *statp = 69;
#line 817
      return (0);
    }
  }
#line 820
  *statp = 0;
#line 834
  loopcnt = 0;
  cnameloop: 
#line 837
  cp = host;
#line 837
  n = 0;
  {
#line 837
  while (1) {
    while_continue: /* CIL Label */ ;
#line 837
    if (! ((int )*cp != 0)) {
#line 837
      goto while_break;
    }
#line 838
    if ((int )*cp == 46) {
#line 839
      n ++;
    }
#line 837
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  dp = searchlist;
#line 853
  if (n > 0) {
#line 854
    tmp___1 = dp;
#line 854
    dp ++;
#line 854
    *tmp___1 = (char *)"";
  }
#line 855
  if (n >= 0) {
#line 855
    cp --;
#line 855
    if ((int )*cp != 46) {
      {
#line 855
      tmp___8 = __res_state();
      }
#line 855
      if ((tmp___8->options & 512UL) != 0UL) {
        {
#line 858
        tmp___2 = __res_state();
#line 858
        domain = tmp___2->dnsrch;
#line 858
        ret = 0;
        }
        {
#line 858
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 858
          if ((unsigned long )*domain != (unsigned long )((void *)0)) {
#line 858
            if (! (ret < 6)) {
#line 858
              goto while_break___0;
            }
          } else {
#line 858
            goto while_break___0;
          }
#line 861
          tmp___3 = dp;
#line 861
          dp ++;
#line 861
          tmp___4 = domain;
#line 861
          domain ++;
#line 861
          *tmp___3 = *tmp___4;
#line 858
          ret ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 855
        goto _L___1;
      }
    } else {
#line 855
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 863
  if (n == 0) {
    {
#line 863
    tmp___7 = __res_state();
    }
#line 863
    if ((tmp___7->options & 128UL) != 0UL) {
      {
#line 865
      tmp___5 = dp;
#line 865
      dp ++;
#line 865
      tmp___6 = __res_state();
#line 865
      *tmp___5 = tmp___6->defdname;
      }
    } else {
#line 863
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 867
  if ((int )*cp == 46) {
#line 869
    *cp = (char )'\000';
  }
#line 871
  *dp = (char *)((void *)0);
#line 878
  mxmatch = (char *)((void *)0);
#line 879
  initial = 1;
#line 884
  qtype = initial;
#line 886
  dp = searchlist;
  {
#line 886
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 886
    if (! ((unsigned long )*dp != (unsigned long )((void *)0))) {
#line 886
      goto while_break___1;
    }
#line 888
    if (qtype == initial) {
#line 889
      gotmx = 0;
    }
#line 890
    if ((int )tTdvect[8] >= 5) {
#line 891
      if (qtype == 1) {
#line 891
        tmp___10 = "A";
      } else {
#line 891
        if (qtype == 15) {
#line 891
          tmp___9 = "MX";
        } else {
#line 891
          tmp___9 = "???";
        }
#line 891
        tmp___10 = tmp___9;
      }
      {
#line 891
      sm_dprintf((char *)"dns_getcanonname: trying %s.%s (%s)\n", host, *dp, tmp___10);
      }
    }
    {
#line 899
    tmp___11 = __errno_location();
#line 899
    *tmp___11 = 0;
#line 900
    ret = __res_querydomain((char const   *)host, (char const   *)*dp, 1, qtype, answer.qb2,
                            (int )sizeof(answer.qb2));
    }
#line 902
    if (ret <= 0) {
      {
#line 904
      tmp___12 = __errno_location();
#line 904
      save_errno = *tmp___12;
      }
#line 906
      if ((int )tTdvect[8] >= 7) {
        {
#line 907
        tmp___13 = __h_errno_location();
#line 907
        sm_dprintf((char *)"\tNO: errno=%d, h_errno=%d\n", save_errno, *tmp___13);
        }
      }
#line 910
      if (save_errno == 111) {
#line 910
        goto _L___2;
      } else {
        {
#line 910
        tmp___15 = __h_errno_location();
        }
#line 910
        if (*tmp___15 == 2) {
          _L___2: /* CIL Label */ 
          {
#line 916
          tmp___14 = __h_errno_location();
#line 916
          *tmp___14 = 2;
          }
#line 917
          if ((int )*(*dp) == 0) {
#line 919
            if (*statp == 0) {
#line 920
              *statp = 75;
            }
#line 921
            goto nexttype;
          }
#line 923
          *statp = 75;
#line 925
          if (WorkAroundBrokenAAAA) {
#line 937
            if (save_errno != 110) {
#line 938
              return (0);
            }
          } else {
#line 941
            return (0);
          }
        }
      }
      nexttype: 
      {
#line 945
      tmp___16 = __h_errno_location();
      }
#line 945
      if (*tmp___16 != 1) {
#line 956
        if (qtype == 1) {
#line 956
          if (! gotmx) {
#line 956
            if (trymx) {
#line 959
              qtype = 15;
#line 960
              goto __Cont;
            } else
#line 956
            if ((int )*(*dp) == 0) {
#line 959
              qtype = 15;
#line 960
              goto __Cont;
            }
          }
        }
      }
#line 965
      dp ++;
#line 966
      qtype = initial;
#line 967
      goto __Cont;
    } else
#line 969
    if ((int )tTdvect[8] >= 7) {
      {
#line 970
      sm_dprintf((char *)"\tYES\n");
      }
    }
#line 973
    if ((unsigned long )ret > sizeof(answer)) {
#line 974
      ret = (int )sizeof(answer);
    }
#line 975
    if (ret < 0) {
#line 977
      *statp = 70;
#line 978
      return (0);
    }
    {
#line 987
    hp = (HEADER *)(& answer);
#line 988
    ap = (unsigned char *)(& answer) + 12;
#line 989
    eom = (unsigned char *)(& answer) + ret;
#line 992
    tmp___17 = ntohs((unsigned short )hp->qdcount);
#line 992
    qdcount = (int )tmp___17;
    }
    {
#line 992
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 992
      tmp___19 = qdcount;
#line 992
      qdcount --;
#line 992
      if (! tmp___19) {
#line 992
        goto while_break___2;
      }
      {
#line 996
      ret = __dn_skipname((u_char const   *)ap, (u_char const   *)eom);
      }
#line 996
      if (ret < 0) {
#line 998
        if ((int )tTdvect[8] >= 20) {
          {
#line 999
          tmp___18 = ntohs((unsigned short )hp->qdcount);
#line 999
          sm_dprintf((char *)"qdcount failure (%d)\n", (int )tmp___18);
          }
        }
#line 1001
        *statp = 70;
#line 1002
        return (0);
      }
#line 992
      ap += ret + 4;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1006
    amatch = 0;
#line 1007
    tmp___20 = ntohs((unsigned short )hp->ancount);
#line 1007
    ancount = (int )tmp___20;
    }
    {
#line 1007
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1007
      ancount --;
#line 1007
      if (ancount >= 0) {
#line 1007
        if (! ((unsigned long )ap < (unsigned long )eom)) {
#line 1007
          goto while_break___3;
        }
      } else {
#line 1007
        goto while_break___3;
      }
      {
#line 1011
      n = __dn_expand((u_char const   *)((unsigned char *)(& answer)), (u_char const   *)eom,
                      (u_char const   *)ap, nbuf, (int )sizeof(nbuf));
      }
#line 1013
      if (n < 0) {
#line 1014
        goto while_break___3;
      }
#line 1015
      ap += n;
      {
#line 1016
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1016
        t_cp = ap;
#line 1016
        type = ((int )((u_int16_t )*(t_cp + 0)) << 8) | (int )((u_int16_t )*(t_cp + 1));
#line 1016
        ap += 2;
#line 1016
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1017
      ap += 2;
      {
#line 1018
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1018
        t_cp___0 = ap;
#line 1018
        ttl = (int )(((((u_int32_t )*(t_cp___0 + 0) << 24) | ((u_int32_t )*(t_cp___0 + 1) << 16)) | ((u_int32_t )*(t_cp___0 + 2) << 8)) | (u_int32_t )*(t_cp___0 + 3));
#line 1018
        ap += 4;
#line 1018
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 1019
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1019
        t_cp___1 = ap;
#line 1019
        n = ((int )((u_int16_t )*(t_cp___1 + 0)) << 8) | (int )((u_int16_t )*(t_cp___1 + 1));
#line 1019
        ap += 2;
#line 1019
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1022
      if (type == 15) {
#line 1022
        goto case_15;
      }
#line 1052
      if (type == 1) {
#line 1052
        goto case_1;
      }
#line 1059
      if (type == 5) {
#line 1059
        goto case_5;
      }
#line 1104
      goto switch_default;
      case_15: /* CIL Label */ 
#line 1023
      gotmx = 1;
#line 1024
      if ((int )*(*dp) != 0) {
#line 1024
        if (HasWildcardMX) {
#line 1033
          if (trymx) {
#line 1033
            if ((unsigned long )mxmatch == (unsigned long )((void *)0)) {
#line 1034
              mxmatch = *dp;
            }
          }
#line 1035
          goto __Cont___0;
        }
      }
      case_1: /* CIL Label */ 
#line 1054
      amatch = 1;
#line 1057
      goto __Cont___0;
      case_5: /* CIL Label */ 
#line 1060
      if (DontExpandCnames) {
#line 1063
        amatch = 1;
#line 1064
        goto switch_break;
      }
#line 1067
      tmp___22 = loopcnt;
#line 1067
      loopcnt ++;
#line 1067
      if (tmp___22 > 10) {
        {
#line 1070
        message("DNS failure: CNAME loop for %s", host);
        }
#line 1072
        if ((unsigned long )CurEnv->e_message == (unsigned long )((void *)0)) {
          {
#line 1076
          sm_snprintf(ebuf, (size_t )sizeof(ebuf), "Deferred: DNS failure: CNAME loop for %.100s",
                      host);
#line 1080
          CurEnv->e_message = sm_rpool_strdup_x(CurEnv->e_rpool, (char const   *)(ebuf));
          }
        }
        {
#line 1084
        tmp___21 = __h_errno_location();
#line 1084
        *tmp___21 = 3;
#line 1085
        *statp = 78;
        }
#line 1086
        return (0);
      }
      {
#line 1090
      ret = __dn_expand((u_char const   *)((unsigned char *)(& answer)), (u_char const   *)eom,
                        (u_char const   *)ap, nbuf, (int )sizeof(nbuf));
      }
#line 1090
      if (ret < 0) {
#line 1093
        goto switch_break;
      }
      {
#line 1094
      sm_strlcpy(host, (char const   *)(nbuf), hbsize);
      }
#line 1102
      goto cnameloop;
      switch_default: /* CIL Label */ 
#line 1106
      goto __Cont___0;
      switch_break: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 1007
      ap += n;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1110
    if (amatch) {
#line 1117
      mxmatch = *dp;
#line 1118
      goto while_break___1;
    }
#line 1133
    if (qtype == 1) {
#line 1133
      if (! gotmx) {
#line 1133
        if (trymx) {
#line 1134
          qtype = 15;
        } else
#line 1133
        if ((int )*(*dp) == 0) {
#line 1134
          qtype = 15;
        } else {
#line 1137
          qtype = initial;
#line 1138
          dp ++;
        }
      } else {
#line 1137
        qtype = initial;
#line 1138
        dp ++;
      }
    } else {
#line 1137
      qtype = initial;
#line 1138
      dp ++;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1143
  if ((unsigned long )mxmatch == (unsigned long )((void *)0)) {
#line 1145
    if (*statp == 0) {
#line 1146
      *statp = 68;
    }
#line 1147
    return (0);
  }
#line 1156
  if ((int )*mxmatch == 0) {
#line 1156
    tmp___23 = "";
  } else {
#line 1156
    tmp___23 = ".";
  }
  {
#line 1156
  sm_snprintf(nbuf, (size_t )sizeof(nbuf), "%.*s%s%.*s", 1025, host, tmp___23, 1025,
              mxmatch);
#line 1159
  sm_strlcpy(host, (char const   *)(nbuf), hbsize);
  }
#line 1160
  if ((int )tTdvect[8] >= 5) {
    {
#line 1161
    sm_dprintf((char *)"dns_getcanonname: %s\n", host);
    }
  }
#line 1162
  *statp = 0;
#line 1165
  if (ttl > 0) {
#line 1165
    if ((unsigned long )pttl != (unsigned long )((void *)0)) {
#line 1166
      *pttl = ttl;
    }
  }
#line 1167
  return (1);
}
}
#line 610 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 269 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 1749 "./sendmail.h"
void vendor_set_uid(uid_t uid ) ;
#line 2275
mode_t OldUmask ;
#line 2451
int checkcompat(ADDRESS *to , ENVELOPE *e ) ;
#line 2519
int makeconnection_ds(char *mux_path , struct mailer_con_info *mci ) ;
#line 2520
int makeconnection(char *host , unsigned int volatile   port , struct mailer_con_info *mci ,
                   ENVELOPE *e , time_t enough ) ;
#line 31 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static int deliver(ENVELOPE *e , ADDRESS *firstto ) ;
#line 32
static void dup_queue_file(ENVELOPE *e , ENVELOPE *ee , int type ) ;
#line 33
static void mailfiletimeout(int ignore ) ;
#line 34
static void endwaittimeout(int ignore ) ;
#line 35
static int parse_hostsignature(char *sig , char **mxhosts , MAILER *mailer ) ;
#line 36
static void sendenvelope(ENVELOPE *e , int mode ) ;
#line 38
static int coloncmp(char const   *a , char const   *b___0 ) ;
#line 66 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
void sendall(ENVELOPE *e , int mode ) 
{ 
  register ADDRESS *q ;
  char *owner ;
  int otherowners ;
  int save_errno ;
  register ENVELOPE *ee ;
  ENVELOPE *splitenv ;
  int oldverbose ;
  bool somedeliveries ;
  bool expensive ;
  pid_t pid ;
  bool tmp ;
  SM_FILE_T *tmp___0 ;
  SM_FILE_T *tmp___1 ;
  char *recip ;
  int *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  SM_FILE_T *tmp___5 ;
  register struct address *a ;
  int tmp___6 ;
  SM_FILE_T *tmp___7 ;
  SM_FILE_T *tmp___8 ;
  SM_FILE_T *tmp___9 ;
  int tmp___10 ;
  MAILER *m ;
  int len___0 ;
  char *p ;
  size_t tmp___11 ;
  void *tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  SM_FILE_T *tmp___17 ;
  SM_FILE_T *tmp___18 ;
  time_t now ;
  bool msync ;
  int tmp___19 ;
  int tmp___20 ;
  SM_FILE_T *tmp___21 ;
  SM_FILE_T *tmp___22 ;
  char *qid ;
  char *qid___0 ;
  int *tmp___23 ;
  int *tmp___24 ;
  ENVELOPE *sibling ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;

  {
#line 76
  splitenv = (ENVELOPE *)((void *)0);
#line 77
  oldverbose = Verbose;
#line 78
  somedeliveries = 0;
#line 78
  expensive = 0;
#line 86
  if ((e->e_flags & 16777216UL) != 0UL) {
#line 88
    if ((int )tTdvect[13] >= 1) {
      {
#line 89
      sm_dprintf((char *)"sendall: discarding id %s\n", e->e_id);
      }
    }
#line 90
    e->e_flags |= 8UL;
#line 91
    if (LogLevel > 9) {
      {
#line 92
      logundelrcpts(e, (char *)"discarded", 9, 1);
      }
    } else
#line 93
    if (LogLevel > 4) {
      {
#line 94
      sm_syslog(6, (char const   *)e->e_id, "discarded");
      }
    }
    {
#line 95
    markstats(e, (ADDRESS *)((void *)0), 'r');
    }
#line 96
    return;
  }
#line 106
  if ((e->e_flags & 32UL) != 0UL) {
#line 106
    if ((int )OpMode == 115) {
#line 109
      e->e_flags |= 8UL;
#line 110
      return;
    } else
#line 106
    if ((int )OpMode == 100) {
#line 109
      e->e_flags |= 8UL;
#line 110
      return;
    }
  }
#line 114
  if (mode == 0) {
#line 116
    mode = (int )e->e_sendmode;
#line 117
    if (mode != 118) {
#line 117
      if (mode != 100) {
        {
#line 117
        tmp = shouldqueue(e->e_msgpriority, e->e_ctime);
        }
#line 117
        if (tmp) {
#line 119
          mode = 'q';
        }
      }
    }
  }
#line 122
  if ((int )tTdvect[13] >= 1) {
    {
#line 124
    sm_dprintf((char *)"\n===== SENDALL: mode %c, id %s, e_from ", mode, e->e_id);
#line 126
    tmp___0 = sm_debug_file();
#line 126
    printaddr(tmp___0, & e->e_from, 0);
#line 127
    sm_dprintf((char *)"\te_flags = ");
#line 128
    printenvflags(e);
#line 129
    sm_dprintf((char *)"sendqueue:\n");
#line 130
    tmp___1 = sm_debug_file();
#line 130
    printaddr(tmp___1, e->e_sendqueue, 1);
    }
  }
#line 139
  CurEnv = e;
#line 140
  if ((int )tTdvect[62] >= 1) {
    {
#line 141
    checkfds((char *)((void *)0));
    }
  }
#line 143
  if ((int )e->e_hopcount > MaxHopCount) {
#line 147
    if ((unsigned long )e->e_sendqueue != (unsigned long )((void *)0)) {
#line 147
      if ((unsigned long )(e->e_sendqueue)->q_paddr != (unsigned long )((void *)0)) {
#line 149
        recip = (e->e_sendqueue)->q_paddr;
      } else {
#line 151
        recip = (char *)"(nobody)";
      }
    } else {
#line 151
      recip = (char *)"(nobody)";
    }
    {
#line 153
    tmp___2 = __errno_location();
#line 153
    *tmp___2 = 0;
    }
#line 154
    if (mode == 113) {
#line 154
      tmp___3 = 1;
    } else
#line 154
    if (mode == 100) {
#line 154
      tmp___3 = 1;
    } else {
#line 154
      tmp___3 = 0;
    }
    {
#line 154
    queueup(e, tmp___3, 0);
#line 155
    e->e_flags |= 8232UL;
#line 156
    ExitStat = 69;
    }
#line 157
    if ((unsigned long )RealHostName == (unsigned long )((void *)0)) {
#line 157
      tmp___4 = "localhost";
    } else {
#line 157
      tmp___4 = (char const   *)RealHostName;
    }
    {
#line 157
    syserr("554 5.4.6 Too many hops %d (%d max): from %s via %s, to %s", (int )e->e_hopcount,
           MaxHopCount, e->e_from.q_paddr, tmp___4, recip);
#line 161
    q = e->e_sendqueue;
    }
    {
#line 161
    while (1) {
      while_continue: /* CIL Label */ ;
#line 161
      if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 161
        goto while_break;
      }
#line 163
      if ((int )q->q_state >= 6) {
#line 164
        goto __Cont;
      }
#line 165
      q->q_state = (short)2;
#line 166
      q->q_status = (char *)"5.4.6";
#line 167
      q->q_rstatus = (char *)"554 5.4.6 Too many hops";
      __Cont: /* CIL Label */ 
#line 161
      q = q->q_next;
    }
    while_break: /* CIL Label */ ;
    }
#line 169
    return;
  }
#line 181
  if (! ((e->e_flags & 16384UL) != 0UL)) {
#line 181
    if (! ((int )e->e_from.q_state == 3)) {
#line 184
      if ((int )tTdvect[13] >= 5) {
        {
#line 186
        sm_dprintf((char *)"sendall: QS_SENDER ");
#line 187
        tmp___5 = sm_debug_file();
#line 187
        printaddr(tmp___5, & e->e_from, 0);
        }
      }
      {
#line 189
      e->e_from.q_state = (short)8;
#line 190
      recipient(& e->e_from, & e->e_sendqueue, 0, e);
      }
    }
  }
#line 200
  q = e->e_sendqueue;
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 200
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 200
      goto while_break___0;
    }
#line 204
    a = q;
    {
#line 204
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 204
      if ((unsigned long )a != (unsigned long )((void *)0)) {
#line 204
        if (! ((unsigned long )a->q_owner == (unsigned long )((void *)0))) {
#line 204
          goto while_break___1;
        }
      } else {
#line 204
        goto while_break___1;
      }
#line 205
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 204
      a = a->q_alias;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 206
    if ((unsigned long )a != (unsigned long )((void *)0)) {
#line 207
      q->q_owner = a->q_owner;
    }
#line 209
    if ((unsigned long )q->q_owner != (unsigned long )((void *)0)) {
#line 209
      if (! ((int )q->q_state >= 6)) {
        {
#line 209
        tmp___6 = strcmp((char const   *)q->q_owner, (char const   *)e->e_from.q_paddr);
        }
#line 209
        if (tmp___6 == 0) {
#line 212
          q->q_owner = (char *)((void *)0);
        }
      }
    }
#line 200
    q = q->q_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 215
  if ((int )tTdvect[13] >= 25) {
    {
#line 217
    sm_dprintf((char *)"\nAfter first owner pass, sendq =\n");
#line 218
    tmp___7 = sm_debug_file();
#line 218
    printaddr(tmp___7, e->e_sendqueue, 1);
    }
  }
#line 221
  owner = (char *)"";
#line 222
  otherowners = 1;
  {
#line 223
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 223
    if ((unsigned long )owner != (unsigned long )((void *)0)) {
#line 223
      if (! (otherowners > 0)) {
#line 223
        goto while_break___2;
      }
    } else {
#line 223
      goto while_break___2;
    }
#line 225
    if ((int )tTdvect[13] >= 28) {
      {
#line 226
      sm_dprintf((char *)"owner = \"%s\", otherowners = %d\n", owner, otherowners);
      }
    }
#line 228
    owner = (char *)((void *)0);
#line 229
    if ((e->e_flags & 16UL) != 0UL) {
#line 229
      otherowners = 1;
    } else {
#line 229
      otherowners = 0;
    }
#line 231
    q = e->e_sendqueue;
    {
#line 231
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 231
      if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 231
        goto while_break___3;
      }
#line 233
      if ((int )tTdvect[13] >= 30) {
        {
#line 235
        sm_dprintf((char *)"Checking ");
#line 236
        tmp___8 = sm_debug_file();
#line 236
        printaddr(tmp___8, q, 0);
        }
      }
#line 238
      if ((int )q->q_state >= 6) {
#line 240
        if ((int )tTdvect[13] >= 30) {
          {
#line 241
          sm_dprintf((char *)"    ... QS_IS_DEAD\n");
          }
        }
#line 242
        goto __Cont___1;
      }
#line 244
      if ((int )tTdvect[13] >= 29) {
#line 244
        if (! ((int )tTdvect[13] >= 30)) {
          {
#line 246
          sm_dprintf((char *)"Checking ");
#line 247
          tmp___9 = sm_debug_file();
#line 247
          printaddr(tmp___9, q, 0);
          }
        }
      }
#line 250
      if ((unsigned long )q->q_owner != (unsigned long )((void *)0)) {
#line 252
        if ((unsigned long )owner == (unsigned long )((void *)0)) {
#line 254
          if ((int )tTdvect[13] >= 40) {
            {
#line 255
            sm_dprintf((char *)"    ... First owner = \"%s\"\n", q->q_owner);
            }
          }
#line 257
          owner = q->q_owner;
        } else
#line 259
        if ((unsigned long )owner != (unsigned long )q->q_owner) {
          {
#line 261
          tmp___10 = strcmp((char const   *)owner, (char const   *)q->q_owner);
          }
#line 261
          if (tmp___10 == 0) {
#line 263
            if ((int )tTdvect[13] >= 40) {
              {
#line 264
              sm_dprintf((char *)"    ... Same owner = \"%s\"\n", owner);
              }
            }
#line 268
            q->q_owner = owner;
          } else {
#line 272
            if ((int )tTdvect[13] >= 40) {
              {
#line 273
              sm_dprintf((char *)"    ... Another owner \"%s\"\n", q->q_owner);
              }
            }
#line 275
            otherowners ++;
          }
#line 277
          owner = q->q_owner;
        } else
#line 279
        if ((int )tTdvect[13] >= 40) {
          {
#line 280
          sm_dprintf((char *)"    ... Same owner = \"%s\"\n", owner);
          }
        }
      } else {
#line 285
        if ((int )tTdvect[13] >= 40) {
          {
#line 286
          sm_dprintf((char *)"    ... Null owner\n");
          }
        }
#line 287
        otherowners ++;
      }
#line 290
      if ((int )q->q_state == 2) {
#line 292
        if ((int )tTdvect[13] >= 30) {
          {
#line 293
          sm_dprintf((char *)"    ... QS_IS_BADADDR\n");
          }
        }
#line 294
        goto __Cont___1;
      }
#line 297
      if ((int )q->q_state == 3) {
#line 299
        m = q->q_mailer;
#line 307
        if ((unsigned long )FallbackMX != (unsigned long )((void *)0)) {
          {
#line 307
          tmp___13 = wordinclass(FallbackMX, 'w');
          }
#line 307
          if (tmp___13) {
#line 307
            goto _L___4;
          } else
#line 307
          if (mode != 118) {
#line 307
            if (! (m->m_flags[48UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 48UL % (8UL * sizeof(int ))))) {
              {
#line 307
              tmp___14 = strcmp((char const   *)m->m_mailer, "[IPC]");
              }
#line 307
              if (tmp___14 == 0) {
#line 307
                if ((unsigned long )*(m->m_argv + 0) != (unsigned long )((void *)0)) {
                  {
#line 307
                  tmp___15 = strcmp((char const   *)*(m->m_argv + 0), "TCP");
                  }
#line 307
                  if (tmp___15 == 0) {
#line 318
                    if ((int )tTdvect[13] >= 30) {
                      {
#line 319
                      sm_dprintf((char *)"    ... FallbackMX\n");
                      }
                    }
                    {
#line 321
                    tmp___11 = strlen((char const   *)FallbackMX);
#line 321
                    len___0 = (int )(tmp___11 + 1U);
#line 322
                    tmp___12 = sm_rpool_malloc_tagged_x(e->e_rpool, (size_t )len___0,
                                                        (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                                                        322, SmHeapGroup);
#line 322
                    p = (char *)tmp___12;
#line 323
                    sm_strlcpy(p, (char const   *)FallbackMX, len___0);
#line 324
                    q->q_state = (short)0;
#line 325
                    q->q_host = p;
                    }
                  } else {
#line 307
                    goto _L___4;
                  }
                } else {
#line 307
                  goto _L___4;
                }
              } else {
#line 307
                goto _L___4;
              }
            } else {
#line 307
              goto _L___4;
            }
          } else {
#line 307
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
#line 329
          if ((int )tTdvect[13] >= 30) {
            {
#line 330
            sm_dprintf((char *)"    ... QS_IS_QUEUEUP\n");
            }
          }
#line 331
          goto __Cont___1;
        }
      }
#line 344
      if (NoConnect) {
#line 344
        if (! Verbose) {
#line 344
          if ((q->q_mailer)->m_flags[101UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 101UL % (8UL * sizeof(int )))) {
#line 347
            if ((int )tTdvect[13] >= 30) {
              {
#line 348
              sm_dprintf((char *)"    ... expensive\n");
              }
            }
#line 349
            q->q_state = (short)3;
#line 350
            expensive = 1;
          } else {
#line 344
            goto _L___10;
          }
        } else {
#line 344
          goto _L___10;
        }
      } else
      _L___10: /* CIL Label */ 
#line 352
      if ((q->q_mailer)->m_flags[37UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 37UL % (8UL * sizeof(int )))) {
#line 352
        if ((unsigned long )QueueLimitId == (unsigned long )((void *)0)) {
#line 352
          if ((unsigned long )QueueLimitSender == (unsigned long )((void *)0)) {
#line 352
            if ((unsigned long )QueueLimitRecipient == (unsigned long )((void *)0)) {
#line 357
              if ((int )tTdvect[13] >= 30) {
                {
#line 358
                sm_dprintf((char *)"    ... hold\n");
                }
              }
#line 359
              q->q_state = (short)3;
#line 360
              expensive = 1;
            } else {
#line 352
              goto _L___8;
            }
          } else {
#line 352
            goto _L___8;
          }
        } else {
#line 352
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 362
      if (QueueMode != 81) {
#line 362
        if ((unsigned long )e->e_quarmsg != (unsigned long )((void *)0)) {
#line 365
          if ((int )tTdvect[13] >= 30) {
            {
#line 366
            sm_dprintf((char *)"    ... quarantine: %s\n", e->e_quarmsg);
            }
          }
#line 368
          q->q_state = (short)3;
#line 369
          expensive = 1;
        } else {
#line 362
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
#line 373
        if ((int )tTdvect[13] >= 30) {
          {
#line 374
          sm_dprintf((char *)"    ... deliverable\n");
          }
        }
#line 375
        somedeliveries = 1;
      }
      __Cont___1: /* CIL Label */ 
#line 231
      q = q->q_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 379
    if ((unsigned long )owner != (unsigned long )((void *)0)) {
#line 379
      if (otherowners > 0) {
        {
#line 385
        tmp___16 = sm_rpool_malloc_tagged_x(e->e_rpool, (size_t )sizeof(*ee), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                                            386, SmHeapGroup);
#line 385
        ee = (ENVELOPE *)tmp___16;
#line 387
        *ee = *e;
#line 388
        ee->e_message = (char *)((void *)0);
#line 389
        ee->e_id = (char *)((void *)0);
#line 390
        assign_queueid(ee);
        }
#line 392
        if ((int )tTdvect[13] >= 1) {
          {
#line 393
          sm_dprintf((char *)"sendall: split %s into %s, owner = \"%s\", otherowners = %d\n",
                     e->e_id, ee->e_id, owner, otherowners);
          }
        }
        {
#line 397
        ee->e_header = copyheader(e->e_header, ee->e_rpool);
#line 398
        ee->e_sendqueue = copyqueue(e->e_sendqueue, ee->e_rpool);
#line 400
        ee->e_errorqueue = copyqueue(e->e_errorqueue, ee->e_rpool);
#line 402
        ee->e_flags = e->e_flags & 0xffffffffffefffc5UL;
#line 403
        ee->e_flags |= 65536UL;
#line 404
        setsender(owner, ee, (char **)((void *)0), '\000', 1);
        }
#line 405
        if ((int )tTdvect[13] >= 5) {
          {
#line 407
          sm_dprintf((char *)"sendall(split): QS_SENDER ");
#line 408
          tmp___17 = sm_debug_file();
#line 408
          printaddr(tmp___17, & ee->e_from, 0);
          }
        }
#line 410
        ee->e_from.q_state = (short)8;
#line 411
        ee->e_dfp = (SM_FILE_T *)((void *)0);
#line 412
        ee->e_lockfp = (SM_FILE_T *)((void *)0);
#line 413
        ee->e_xfp = (SM_FILE_T *)((void *)0);
#line 414
        ee->e_qgrp = e->e_qgrp;
#line 415
        ee->e_qdir = e->e_qdir;
#line 416
        ee->e_errormode = (short )'m';
#line 417
        ee->e_sibling = splitenv;
#line 418
        ee->e_statmsg = (char *)((void *)0);
#line 419
        if ((unsigned long )e->e_quarmsg != (unsigned long )((void *)0)) {
          {
#line 420
          ee->e_quarmsg = sm_rpool_strdup_x(ee->e_rpool, (char const   *)e->e_quarmsg);
          }
        }
#line 422
        splitenv = ee;
#line 424
        q = e->e_sendqueue;
        {
#line 424
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 424
          if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 424
            goto while_break___4;
          }
#line 426
          if ((unsigned long )q->q_owner == (unsigned long )owner) {
#line 428
            q->q_state = (short)9;
#line 429
            if ((int )tTdvect[13] >= 6) {
              {
#line 430
              sm_dprintf((char *)"\t... stripping %s from original envelope\n", q->q_paddr);
              }
            }
          }
#line 424
          q = q->q_next;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 434
        q = ee->e_sendqueue;
        {
#line 434
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 434
          if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 434
            goto while_break___5;
          }
#line 436
          if ((unsigned long )q->q_owner != (unsigned long )owner) {
#line 438
            q->q_state = (short)9;
#line 439
            if ((int )tTdvect[13] >= 6) {
              {
#line 440
              sm_dprintf((char *)"\t... dropping %s from cloned envelope\n", q->q_paddr);
              }
            }
          } else {
#line 446
            q->q_flags &= 0xfffffffffffffc3fUL;
#line 447
            q->q_flags |= (unsigned long )(DefaultNotify & -65);
#line 448
            if ((int )tTdvect[13] >= 6) {
              {
#line 449
              sm_dprintf((char *)"\t... moving %s to cloned envelope\n", q->q_paddr);
              }
            }
          }
#line 434
          q = q->q_next;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 454
        if (mode != 118) {
#line 454
          if ((e->e_flags & 2097152UL) != 0UL) {
            {
#line 455
            dup_queue_file(e, ee, 'd');
            }
          }
        }
#line 464
        if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
          {
#line 465
          ee->e_xfp = sm_io_dup(e->e_xfp);
          }
        }
#line 468
        if ((unsigned long )ee->e_xfp == (unsigned long )((void *)0)) {
          {
#line 469
          openxscript(ee);
          }
        }
#line 471
        if (mode != 118) {
#line 471
          if (LogLevel > 4) {
            {
#line 472
            sm_syslog(6, (char const   *)e->e_id, "%s: clone: owner=%s", ee->e_id,
                      owner);
            }
          }
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 478
  if ((unsigned long )owner != (unsigned long )((void *)0)) {
    {
#line 480
    setsender(owner, e, (char **)((void *)0), '\000', 1);
    }
#line 481
    if ((int )tTdvect[13] >= 5) {
      {
#line 483
      sm_dprintf((char *)"sendall(owner): QS_SENDER ");
#line 484
      tmp___18 = sm_debug_file();
#line 484
      printaddr(tmp___18, & e->e_from, 0);
      }
    }
#line 486
    e->e_from.q_state = (short)8;
#line 487
    e->e_errormode = (short )'m';
#line 488
    e->e_flags |= 65536UL;
#line 489
    e->e_flags &= 0xffffffffffffffdfUL;
  }
#line 493
  if (! somedeliveries) {
#line 493
    if (! (mode == 113)) {
#line 493
      if (! (mode == 100)) {
#line 493
        if (mode != 118) {
#line 498
          if ((int )tTdvect[13] >= 29) {
            {
#line 499
            sm_dprintf((char *)"No deliveries: auto-queuing\n");
            }
          }
          {
#line 500
          mode = 'q';
#line 501
          now = curtime();
#line 504
          e->e_dtime = now;
          }
#line 505
          if (! expensive) {
#line 506
            (e->e_ntries) ++;
          }
#line 507
          ee = splitenv;
          {
#line 507
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 507
            if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 507
              goto while_break___6;
            }
#line 509
            ee->e_dtime = now;
#line 510
            if (! expensive) {
#line 511
              (ee->e_ntries) ++;
            }
#line 507
            ee = ee->e_sibling;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 515
  if (mode == 113) {
#line 515
    goto _L___13;
  } else
#line 515
  if (mode == 100) {
#line 515
    goto _L___13;
  } else
#line 515
  if (mode == 98) {
#line 515
    goto _L___13;
  } else
#line 515
  if (mode != 118) {
#line 515
    if (SuperSafe == 2) {
#line 515
      goto _L___13;
    } else
#line 515
    if (SuperSafe == 3) {
      _L___13: /* CIL Label */ 
#line 515
      if (! ((e->e_flags & 2UL) != 0UL)) {
#line 515
        goto _L___11;
      } else
#line 515
      if ((unsigned long )splitenv != (unsigned long )((void *)0)) {
        _L___11: /* CIL Label */ 
#line 531
        msync = 0;
#line 536
        ee = splitenv;
        {
#line 536
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 536
          if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 536
            goto while_break___7;
          }
#line 537
          if (mode == 113) {
#line 537
            tmp___19 = 1;
          } else
#line 537
          if (mode == 100) {
#line 537
            tmp___19 = 1;
          } else {
#line 537
            tmp___19 = 0;
          }
          {
#line 537
          queueup(ee, tmp___19, msync);
#line 536
          ee = ee->e_sibling;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
#line 538
        if (mode == 113) {
#line 538
          tmp___20 = 1;
        } else
#line 538
        if (mode == 100) {
#line 538
          tmp___20 = 1;
        } else {
#line 538
          tmp___20 = 0;
        }
        {
#line 538
        queueup(e, tmp___20, msync);
        }
      }
    }
  }
#line 541
  if ((int )tTdvect[62] >= 10) {
    {
#line 542
    checkfds((char *)"after envelope splitting");
    }
  }
#line 548
  if ((int )tTdvect[13] >= 20) {
    {
#line 550
    sm_dprintf((char *)"sendall: final mode = %c\n", mode);
    }
#line 551
    if ((int )tTdvect[13] >= 21) {
      {
#line 553
      sm_dprintf((char *)"\n================ Final Send Queue(s) =====================\n");
#line 554
      sm_dprintf((char *)"\n  *** Envelope %s, e_from=%s ***\n", e->e_id, e->e_from.q_paddr);
#line 556
      tmp___21 = sm_debug_file();
#line 556
      printaddr(tmp___21, e->e_sendqueue, 1);
#line 557
      ee = splitenv;
      }
      {
#line 557
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 557
        if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 557
          goto while_break___8;
        }
        {
#line 559
        sm_dprintf((char *)"\n  *** Envelope %s, e_from=%s ***\n", ee->e_id, ee->e_from.q_paddr);
#line 561
        tmp___22 = sm_debug_file();
#line 561
        printaddr(tmp___22, ee->e_sendqueue, 1);
#line 557
        ee = ee->e_sibling;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 563
      sm_dprintf((char *)"==========================================================\n\n");
      }
    }
  }
  {
#line 568
  if (mode == 118) {
#line 568
    goto case_118;
  }
#line 573
  if (mode == 100) {
#line 573
    goto case_100;
  }
#line 573
  if (mode == 113) {
#line 573
    goto case_100;
  }
#line 588
  if (mode == 98) {
#line 588
    goto case_98;
  }
#line 566
  goto switch_break;
  case_118: /* CIL Label */ 
#line 569
  Verbose = 2;
#line 570
  goto switch_break;
  case_100: /* CIL Label */ 
  case_113: /* CIL Label */ 
#line 577
  if (e->e_nrcpts > 0) {
#line 578
    e->e_flags |= 2UL;
  }
  {
#line 579
  dropenvelope(e, (unsigned long )splitenv != (unsigned long )((void *)0), 1);
#line 580
  ee = splitenv;
  }
  {
#line 580
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 580
    if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 580
      goto while_break___9;
    }
#line 582
    if (ee->e_nrcpts > 0) {
#line 583
      ee->e_flags |= 2UL;
    }
    {
#line 584
    dropenvelope(ee, 0, 1);
#line 580
    ee = ee->e_sibling;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 586
  return;
  case_98: /* CIL Label */ 
#line 589
  if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
    {
#line 590
    sm_io_flush(e->e_xfp, -2);
    }
  }
  {
#line 602
  qid = e->e_id;
#line 605
  e->e_flags |= 2UL;
#line 606
  dropenvelope(e, (unsigned long )splitenv != (unsigned long )((void *)0), 0);
#line 609
  e->e_id = qid;
#line 612
  ee = splitenv;
  }
  {
#line 612
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 612
    if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 612
      goto while_break___10;
    }
    {
#line 615
    qid___0 = ee->e_id;
#line 618
    ee->e_flags |= 2UL;
#line 619
    dropenvelope(ee, 0, 0);
#line 622
    ee->e_id = qid___0;
#line 612
    ee = ee->e_sibling;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 635
  closemaps(0);
#line 637
  pid = fork();
  }
#line 638
  if (pid < 0) {
    {
#line 640
    syserr("deliver: fork 1");
#line 644
    e->e_id = (char *)((void *)0);
#line 645
    ee = splitenv;
    }
    {
#line 645
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 645
      if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 645
        goto while_break___11;
      }
#line 646
      ee->e_id = (char *)((void *)0);
#line 645
      ee = ee->e_sibling;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 647
    return;
  } else
#line 650
  if (pid > 0) {
    {
#line 670
    e->e_id = (char *)((void *)0);
#line 674
    waitfor(pid);
    }
#line 676
    return;
  }
  {
#line 680
  RestartRequest = (char */* volatile  */)((void *)0);
#line 681
  RestartWorkGroup = (bool volatile   )0;
#line 682
  ShutdownRequest = (char */* volatile  */)((void *)0);
#line 683
  PendingSignal = (int volatile   )0;
#line 690
  sm_exc_newthread(& fatal_error);
#line 699
  sm_signal(15, (void (*)(int  ))0);
#line 703
  pid = fork();
  }
#line 704
  if (pid > 0) {
    {
#line 705
    exit(0);
    }
  }
  {
#line 706
  tmp___23 = __errno_location();
#line 706
  save_errno = *tmp___23;
#line 709
  CurrentPid = getpid();
#line 712
  disconnect(2, e);
#line 713
  clearstats();
  }
#line 716
  if (pid < 0) {
    {
#line 718
    tmp___24 = __errno_location();
#line 718
    *tmp___24 = save_errno;
#line 719
    syserr("deliver: fork 2");
#line 723
    e->e_id = (char *)((void *)0);
#line 725
    finis(1, 1, (int volatile   )ExitStat);
    }
  }
  {
#line 729
  QuickAbort = 0;
#line 741
  mci_flush(0, (struct mailer_con_info *)((void *)0));
#line 751
  ee = splitenv;
  }
  {
#line 751
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 751
    if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 751
      goto while_break___12;
    }
    {
#line 753
    sibling = ee->e_sibling;
#line 755
    dowork(ee->e_qgrp, ee->e_qdir, ee->e_id, 0, 0, ee);
#line 757
    ee->e_sibling = sibling;
#line 751
    ee = ee->e_sibling;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 759
  dowork(e->e_qgrp, e->e_qdir, e->e_id, 0, 0, e);
#line 761
  finis(1, 1, (int volatile   )ExitStat);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 765
  sendenvelope(e, mode);
#line 766
  dropenvelope(e, 1, 1);
#line 767
  ee = splitenv;
  }
  {
#line 767
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 767
    if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 767
      goto while_break___13;
    }
#line 769
    CurEnv = ee;
#line 770
    if (mode != 118) {
      {
#line 771
      openxscript(ee);
      }
    }
    {
#line 772
    sendenvelope(ee, mode);
#line 773
    dropenvelope(ee, 1, 1);
#line 767
    ee = ee->e_sibling;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 775
  CurEnv = e;
#line 777
  Verbose = oldverbose;
#line 778
  if (mode == 98) {
    {
#line 779
    finis(1, 1, (int volatile   )ExitStat);
    }
  }
#line 780
  return;
}
}
#line 782 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static void sendenvelope(ENVELOPE *e , int mode ) 
{ 
  register ADDRESS *q ;
  bool didany ;
  char const   *tmp ;
  time_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ENVELOPE *oldsib ;
  ENVELOPE *ee ;
  bool tmp___3 ;
  char wbuf[276] ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 790
  if ((int )tTdvect[13] >= 10) {
#line 791
    if ((unsigned long )e->e_id == (unsigned long )((void *)0)) {
#line 791
      tmp = "[NOQUEUE]";
    } else {
#line 791
      tmp = (char const   *)e->e_id;
    }
    {
#line 791
    sm_dprintf((char *)"sendenvelope(%s) e_flags=0x%lx\n", tmp, e->e_flags);
    }
  }
#line 794
  if (LogLevel > 80) {
    {
#line 795
    sm_syslog(7, (char const   *)e->e_id, "sendenvelope, flags=0x%lx", e->e_flags);
    }
  }
#line 806
  if ((e->e_flags & 32UL) != 0UL) {
#line 806
    if ((int )OpMode == 115) {
#line 809
      e->e_flags |= 8UL;
#line 810
      return;
    } else
#line 806
    if ((int )OpMode == 100) {
#line 809
      e->e_flags |= 8UL;
#line 810
      return;
    }
  }
#line 818
  if (! ((e->e_flags & 128UL) != 0UL)) {
#line 818
    if (TimeOuts.to_q_return[e->e_timeoutclass] == -1L) {
#line 822
      return;
    } else
#line 818
    if ((e->e_dlvr_flag & 2) != 0) {
#line 818
      if (e->e_deliver_by > 0L) {
        {
#line 818
        tmp___0 = curtime();
        }
#line 818
        if (tmp___0 > e->e_ctime + e->e_deliver_by) {
#line 822
          return;
        }
      }
    }
  }
  {
#line 831
  e->e_nsent = (short)0;
#line 832
  e->e_flags |= 4096UL;
#line 834
  tmp___1 = macid_parse((char *)"{envid}", (char **)((void *)0));
#line 834
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___1, e->e_envid, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                   834, SmHeapGroup);
#line 835
  tmp___2 = macid_parse((char *)"{bodytype}", (char **)((void *)0));
#line 835
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___2, e->e_bodytype, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                   835, SmHeapGroup);
#line 836
  didany = 0;
  }
#line 838
  if (! ((e->e_flags & 67108864UL) != 0UL)) {
    {
#line 850
    oldsib = e->e_sibling;
#line 851
    e->e_sibling = (ENVELOPE *)((void *)0);
#line 852
    tmp___3 = split_by_recipient(e);
    }
#line 852
    if (! tmp___3) {
#line 852
      if ((e->e_flags & 32UL) != 0UL) {
#line 855
        if ((int )OpMode == 115) {
#line 856
          e->e_flags |= 8UL;
        } else
#line 855
        if ((int )OpMode == 100) {
#line 856
          e->e_flags |= 8UL;
        }
#line 857
        return;
      }
    }
#line 859
    ee = e->e_sibling;
    {
#line 859
    while (1) {
      while_continue: /* CIL Label */ ;
#line 859
      if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 859
        goto while_break;
      }
      {
#line 860
      queueup(ee, 0, 1);
#line 859
      ee = ee->e_sibling;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 863
    ee = e->e_sibling;
    {
#line 863
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 863
      if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 863
        goto while_break___0;
      }
      {
#line 866
      closexscript(ee);
#line 867
      unlockqueue(ee);
      }
#line 870
      if ((unsigned long )ee->e_dfp != (unsigned long )((void *)0)) {
        {
#line 872
        sm_io_close(ee->e_dfp, -2);
#line 873
        ee->e_dfp = (SM_FILE_T *)((void *)0);
        }
      }
#line 875
      ee->e_id = (char *)((void *)0);
#line 876
      ee->e_flags &= 0xffffffffffdfffffUL;
#line 863
      ee = ee->e_sibling;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 878
    e->e_sibling = oldsib;
  }
#line 882
  q = e->e_sendqueue;
  {
#line 882
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 882
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 882
      goto while_break___1;
    }
    {
#line 887
    sm_snprintf(wbuf, (size_t )sizeof(wbuf), "sendall(%.*s)", 256, q->q_paddr);
#line 889
    checkfd012(wbuf);
    }
#line 891
    if (mode == 118) {
#line 893
      e->e_to = q->q_paddr;
#line 894
      if ((int )q->q_state == 0) {
#line 894
        goto _L;
      } else
#line 894
      if ((int )q->q_state == 3) {
#line 894
        goto _L;
      } else
#line 894
      if ((int )q->q_state == 4) {
        _L: /* CIL Label */ 
#line 896
        if ((unsigned long )q->q_host != (unsigned long )((void *)0)) {
#line 896
          if ((int )*(q->q_host + 0) != 0) {
            {
#line 897
            message("deliverable: mailer %s, host %s, user %s", (q->q_mailer)->m_name,
                    q->q_host, q->q_user);
            }
          } else {
            {
#line 902
            message("deliverable: mailer %s, user %s", (q->q_mailer)->m_name, q->q_user);
            }
          }
        } else {
          {
#line 902
          message("deliverable: mailer %s, user %s", (q->q_mailer)->m_name, q->q_user);
          }
        }
      }
    } else
#line 907
    if ((int )q->q_state == 0) {
#line 913
      if (CheckpointInterval > 0) {
#line 913
        if ((int )e->e_nsent >= CheckpointInterval) {
          {
#line 916
          queueup(e, 0, 0);
#line 917
          e->e_nsent = (short)0;
          }
        }
      }
      {
#line 919
      deliver(e, q);
#line 920
      didany = 1;
      }
    }
#line 882
    q = q->q_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 923
  if (didany) {
    {
#line 925
    e->e_dtime = curtime();
#line 926
    (e->e_ntries) ++;
    }
  }
  {
#line 930
  checkfd012((char *)"end of sendenvelope");
  }
#line 932
  return;
}
}
#line 946 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
void sync_dir(char *filename , bool panic ) 
{ 
  int dirfd ;
  char *dirp ;
  char dir___0[4096] ;
  size_t tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 955
  if (! RequiresDirfsync) {
#line 956
    return;
  }
  {
#line 959
  dirp = strrchr((char const   *)filename, '/');
  }
#line 960
  if ((unsigned long )dirp != (unsigned long )((void *)0)) {
    {
#line 962
    tmp = sm_strlcpy(dir___0, (char const   *)filename, (ssize_t )sizeof(dir___0));
    }
#line 962
    if ((unsigned long )tmp >= sizeof(dir___0)) {
#line 963
      return;
    }
#line 964
    dir___0[dirp - filename] = (char )'\000';
#line 965
    dirp = dir___0;
  } else {
#line 968
    dirp = (char *)".";
  }
  {
#line 969
  dirfd = open((char const   *)dirp, 0, 448);
  }
#line 970
  if ((int )tTdvect[40] >= 32) {
    {
#line 971
    sm_syslog(6, "*~*", "sync_dir: %s: fsync(%d)", dirp, dirfd);
    }
  }
#line 973
  if (dirfd >= 0) {
    {
#line 975
    tmp___2 = fsync(dirfd);
    }
#line 975
    if (tmp___2 < 0) {
#line 977
      if (panic) {
        {
#line 978
        syserr("!sync_dir: cannot fsync directory %s", dirp);
        }
      } else
#line 980
      if (LogLevel > 1) {
        {
#line 981
        tmp___0 = __errno_location();
#line 981
        tmp___1 = sm_errstring(*tmp___0);
#line 981
        sm_syslog(3, "*~*", "sync_dir: cannot fsync directory %s: %s", dirp, tmp___1);
        }
      }
    }
    {
#line 985
    close(dirfd);
    }
  }
#line 987
  return;
}
}
#line 1001 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static void dup_queue_file(ENVELOPE *e , ENVELOPE *ee , int type ) 
{ 
  char f1buf[4096] ;
  char f2buf[4096] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int save_errno ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 1008
  ee->e_dfp = (SM_FILE_T *)((void *)0);
#line 1009
  ee->e_xfp = (SM_FILE_T *)((void *)0);
#line 1015
  tmp = queuename(e, type);
#line 1015
  sm_strlcpy(f1buf, (char const   *)tmp, (ssize_t )sizeof(f1buf));
#line 1016
  tmp___0 = queuename(ee, type);
#line 1016
  sm_strlcpy(f2buf, (char const   *)tmp___0, (ssize_t )sizeof(f2buf));
  }
#line 1019
  if (type == 100) {
#line 1019
    if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
      {
#line 1019
      tmp___1 = sm_io_setinfo(e->e_dfp, 1001, (void *)0);
      }
#line 1019
      if (tmp___1 < 0) {
        {
#line 1019
        tmp___2 = __errno_location();
        }
#line 1019
        if (*tmp___2 != 22) {
          {
#line 1023
          syserr("!dup_queue_file: can\'t commit %s", f1buf);
          }
        }
      }
    }
  }
  {
#line 1027
  tmp___6 = link((char const   *)(f1buf), (char const   *)(f2buf));
  }
#line 1027
  if (tmp___6 < 0) {
    {
#line 1029
    tmp___3 = __errno_location();
#line 1029
    save_errno = *tmp___3;
#line 1031
    syserr("sendall: link(%s, %s)", f1buf, f2buf);
    }
#line 1032
    if (save_errno == 17) {
      {
#line 1034
      tmp___4 = unlink((char const   *)(f2buf));
      }
#line 1034
      if (tmp___4 < 0) {
        {
#line 1036
        syserr("!sendall: unlink(%s): permanent", f2buf);
        }
      }
      {
#line 1040
      tmp___5 = link((char const   *)(f1buf), (char const   *)(f2buf));
      }
#line 1040
      if (tmp___5 < 0) {
        {
#line 1042
        syserr("!sendall: link(%s, %s): permanent", f1buf, f2buf);
        }
      }
    }
  }
  {
#line 1048
  sync_dir(f2buf, 1);
  }
#line 1049
  return;
}
}
#line 1106 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
pid_t dofork(void) 
{ 
  register pid_t pid ;
  register int i ;

  {
#line 1109
  pid = -1;
#line 1111
  i = 5;
  {
#line 1111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1111
    i --;
#line 1111
    if (! (i >= 0)) {
#line 1111
      goto while_break;
    }
    {
#line 1111
    pid = fork();
    }
#line 1111
    if (pid >= 0) {
#line 1111
      goto while_break;
    }
#line 1111
    if (i > 0) {
      {
#line 1111
      sleep(5U - (unsigned int )i);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1112
  return (pid);
}
}
#line 1145 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static int coloncmp(char const   *a , char const   *b___0 ) 
{ 
  int ret ;
  int braclev ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 1150
  ret = 0;
#line 1151
  braclev = 0;
  {
#line 1153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1153
    tmp = b___0;
#line 1153
    b___0 ++;
#line 1153
    if (! ((int const   )*a == (int const   )*tmp)) {
#line 1153
      goto while_break;
    }
#line 1156
    if ((int const   )*a == 91) {
#line 1157
      braclev ++;
    } else
#line 1158
    if ((int const   )*a == 93) {
#line 1158
      if (braclev > 0) {
#line 1159
        braclev --;
      } else {
#line 1158
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1160
    if ((int const   )*a == 58) {
#line 1160
      if (braclev <= 0) {
#line 1162
        ret = 1;
#line 1163
        a ++;
#line 1164
        goto while_break;
      } else {
#line 1160
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1166
    if ((int const   )*a == 0) {
#line 1167
      return (2);
    }
#line 1168
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1170
  if (ret == 0) {
#line 1170
    if (braclev <= 0) {
#line 1170
      if ((int const   )*a == 0) {
#line 1170
        if ((int const   )*(b___0 - 1) == 58) {
#line 1174
          return (1);
        } else {
#line 1170
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1170
      if ((int const   )*a == 58) {
#line 1170
        if ((int const   )*(b___0 - 1) == 0) {
#line 1174
          return (1);
        }
      }
    }
  }
#line 1175
  if (ret == 1) {
    {
#line 1175
    tmp___0 = strcmp(a, b___0);
    }
#line 1175
    if (tmp___0 == 0) {
#line 1176
      return (2);
    }
  }
#line 1178
  return (ret);
}
}
#line 1195 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static bool should_try_fbsh(ENVELOPE *e , bool *tried_fallbacksmarthost , char *hostbuf___1 ,
                            size_t hbsz , int status ) 
{ 
  bool tmp ;
  char *__cil_tmp7 ;

  {
#line 1209
  if (status == 68) {
#line 1209
    goto _L;
  } else
#line 1209
  if (status == 75) {
    _L: /* CIL Label */ 
#line 1209
    if ((unsigned long )FallbackSmartHost != (unsigned long )((void *)0)) {
#line 1209
      if (! *tried_fallbacksmarthost) {
        {
#line 1212
        *tried_fallbacksmarthost = 1;
#line 1213
        expand(FallbackSmartHost, hostbuf___1, hbsz, e);
#line 1214
        tmp = wordinclass(hostbuf___1, 'w');
        }
#line 1214
        if (! tmp) {
#line 1216
          if ((int )tTdvect[11] >= 1) {
            {
#line 1217
            sm_dprintf((char *)"one last try with FallbackSmartHost %s\n", hostbuf___1);
            }
          }
#line 1219
          return (1);
        }
      }
    }
  }
#line 1222
  return (0);
}
}
#line 1325 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static int tobufsize  =    0;
#line 1326 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static char *tobuf  =    (char *)((void *)0);
#line 2015 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static char hostbuf[257]  ;
#line 1285 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static int deliver(ENVELOPE *e , ADDRESS *firstto ) 
{ 
  char *host ;
  char *user ;
  char **pvp ;
  register char **mvp ;
  register char *p ;
  register MAILER *m ;
  ADDRESS * volatile  ctladdr ;
  register struct mailer_con_info * volatile  mci ;
  register ADDRESS *to ;
  bool volatile   clever ;
  ADDRESS * volatile  tochain ;
  int rcode ;
  int lmtp_rcode ;
  int nummxhosts ;
  int hostnum ;
  char *firstsig ;
  pid_t volatile   pid ;
  char * volatile  curhost ;
  unsigned short port ;
  time_t enough ;
  char *mux_path ;
  time_t xstart ;
  bool suidwarn ;
  bool anyok ;
  bool goodmxfound ;
  bool ovr ;
  bool quarantine ;
  int strsize ;
  int rcptcount ;
  int ret ;
  char *rpath ;
  int mpvect[2] ;
  int rpvect[2] ;
  char *mxhosts[101] ;
  char *pv[257] ;
  char buf___16[257] ;
  char cbuf[4096] ;
  int *tmp ;
  __uid_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  SM_EXC_HANDLER_T _h ;
  ADDRESS *skip_back ;
  int *tmp___6 ;
  size_t tmp___7 ;
  char **tmp___8 ;
  char **tmp___9 ;
  char **tmp___10 ;
  char **tmp___11 ;
  char *tmp___12 ;
  char **tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  SM_FILE_T *tmp___16 ;
  ADDRESS *tmp___17 ;
  SM_FILE_T *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  SM_FILE_T *tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  char notify[2048] ;
  size_t tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char **tmp___27 ;
  size_t tmp___28 ;
  void *tmp___29 ;
  size_t tmp___30 ;
  char **tmp___31 ;
  char **tmp___32 ;
  struct __res_state *tmp___33 ;
  SM_FILE_T *tmp___34 ;
  int *tmp___35 ;
  int *tmp___36 ;
  char wbuf[2048] ;
  char *tmp___37 ;
  struct mailer_con_info *tmp___38 ;
  struct mailer_con_info *tmp___39 ;
  register int i ;
  char *tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  struct servent *sp ;
  struct servent *tmp___43 ;
  time_t tmp___44 ;
  char sep ;
  char *endp ;
  bool tried_fallbacksmarthost ;
  struct mailer_con_info *tmp___45 ;
  char *type ;
  SM_FILE_T *tmp___46 ;
  bool tmp___47 ;
  int tmp___48 ;
  char *tmp___49 ;
  uint16_t tmp___50 ;
  int *tmp___51 ;
  int *tmp___52 ;
  int h ;
  bool tmp___53 ;
  int *tmp___54 ;
  struct mailer_con_info *tmp___55 ;
  char **av___0 ;
  char *tmp___56 ;
  int tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  int tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  register int i___0 ;
  __pid_t tmp___66 ;
  char *tmp___67 ;
  int save_errno ;
  int sff ;
  int new_euid ;
  int new_ruid ;
  int new_gid ;
  char *user___0 ;
  struct stat stb ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  gid_t gidset[1] ;
  int tmp___71 ;
  int tmp___72 ;
  gid_t gidset___0[1] ;
  int tmp___73 ;
  __gid_t tmp___74 ;
  __gid_t tmp___75 ;
  __gid_t tmp___76 ;
  __gid_t tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  __uid_t tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  __gid_t tmp___84 ;
  __gid_t tmp___85 ;
  __uid_t tmp___86 ;
  __uid_t tmp___87 ;
  char *q ;
  char *tmp___88 ;
  int tmp___89 ;
  __gid_t tmp___90 ;
  __uid_t tmp___91 ;
  char const   *tmp___92 ;
  char *tmp___93 ;
  int tmp___94 ;
  char *tmp___95 ;
  int tmp___96 ;
  char *tmp___97 ;
  int tmp___98 ;
  int *tmp___99 ;
  bool tmp___100 ;
  struct mailer_con_info *tmp___101 ;
  struct mailer_con_info *tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  time_t tmp___105 ;
  time_t tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  SM_FILE_T *tmp___110 ;
  int *tmp___111 ;
  int *tmp___112 ;
  int *tmp___113 ;
  bool ok ;
  int *tmp___114 ;
  int *tmp___115 ;
  register int i___1 ;
  ADDRESS * volatile  pchain ;
  struct __res_state *tmp___116 ;
  size_t tmp___117 ;
  int tmp___118 ;
  char *tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  char wbuf___0[2048] ;
  char *tmp___122 ;
  char const   *tmp___123 ;
  int *tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  void *__cil_tmp195 ;
  void *__cil_tmp196 ;
  void *__cil_tmp197 ;
  void *__cil_tmp198 ;
  void *__cil_tmp199 ;
  void *__cil_tmp200 ;
  void *__cil_tmp201 ;
  void *__cil_tmp202 ;
  void *__cil_tmp203 ;
  void *__cil_tmp204 ;
  void *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;
  char *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;
  char *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;
  char *__cil_tmp273 ;
  char *__cil_tmp274 ;
  char *__cil_tmp275 ;
  char *__cil_tmp276 ;
  char *__cil_tmp277 ;
  char *__cil_tmp278 ;
  char *__cil_tmp279 ;
  char *__cil_tmp280 ;
  char *__cil_tmp281 ;
  char *__cil_tmp282 ;
  char *__cil_tmp283 ;
  char *__cil_tmp284 ;
  char *__cil_tmp285 ;
  char *__cil_tmp286 ;
  char *__cil_tmp287 ;
  char *__cil_tmp288 ;
  char *__cil_tmp289 ;
  char *__cil_tmp290 ;
  char *__cil_tmp291 ;
  char *__cil_tmp292 ;
  char *__cil_tmp293 ;
  char *__cil_tmp294 ;
  char *__cil_tmp295 ;
  char *__cil_tmp296 ;
  char *__cil_tmp297 ;
  char *__cil_tmp298 ;
  char *__cil_tmp299 ;
  char *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;
  char *__cil_tmp345 ;
  char *__cil_tmp346 ;
  char *__cil_tmp347 ;
  char *__cil_tmp348 ;
  char *__cil_tmp349 ;
  char *__cil_tmp350 ;
  char *__cil_tmp351 ;
  char *__cil_tmp352 ;
  char *__cil_tmp353 ;
  char *__cil_tmp354 ;
  char *__cil_tmp355 ;
  char *__cil_tmp356 ;
  char *__cil_tmp357 ;
  char *__cil_tmp358 ;
  char *__cil_tmp359 ;
  char *__cil_tmp360 ;
  char *__cil_tmp361 ;
  char *__cil_tmp362 ;
  char *__cil_tmp363 ;
  char *__cil_tmp364 ;
  char *__cil_tmp365 ;
  char *__cil_tmp366 ;
  char *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;
  char *__cil_tmp370 ;
  char *__cil_tmp371 ;
  char *__cil_tmp372 ;
  char *__cil_tmp373 ;
  char *__cil_tmp374 ;
  char *__cil_tmp375 ;
  char *__cil_tmp376 ;
  char *__cil_tmp377 ;
  char *__cil_tmp378 ;
  char *__cil_tmp379 ;

  {
  {
#line 1301
  to = firstto;
#line 1302
  clever = (bool volatile   )0;
#line 1303
  tochain = (ADDRESS */* volatile  */)((void *)0);
#line 1305
  lmtp_rcode = 0;
#line 1306
  nummxhosts = 0;
#line 1307
  hostnum = 0;
#line 1309
  pid = (pid_t volatile   )-1;
#line 1311
  port = (unsigned short)0;
#line 1312
  enough = (time_t )0;
#line 1314
  mux_path = (char *)((void *)0);
#line 1319
  goodmxfound = 0;
#line 1335
  tmp = __errno_location();
#line 1335
  *tmp = 0;
  }
#line 1336
  if (! ((int )to->q_state == 0)) {
#line 1337
    return (0);
  }
  {
#line 1339
  tmp___0 = geteuid();
#line 1339
  suidwarn = tmp___0 == 0U;
#line 1341
  m = to->q_mailer;
#line 1342
  host = to->q_host;
#line 1343
  CurEnv = e;
#line 1344
  e->e_statmsg = (char *)((void *)0);
#line 1345
  SmtpError[0] = (char )'\000';
#line 1346
  xstart = curtime();
  }
#line 1348
  if ((int )tTdvect[10] >= 1) {
    {
#line 1349
    sm_dprintf((char *)"\n--deliver, id=%s, mailer=%s, host=`%s\', first user=`%s\'\n",
               e->e_id, m->m_name, host, to->q_user);
    }
  }
#line 1351
  if ((int )tTdvect[10] >= 100) {
    {
#line 1352
    printopenfds(0);
    }
  }
#line 1359
  if ((e->e_flags & 128UL) != 0UL) {
    {
#line 1361
    tmp___1 = macid_parse((char *)"{client_name}", (char **)((void *)0));
#line 1361
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___1, (char *)"", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                     1361, SmHeapGroup);
#line 1362
    tmp___2 = macid_parse((char *)"{client_ptr}", (char **)((void *)0));
#line 1362
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___2, (char *)"", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                     1362, SmHeapGroup);
#line 1363
    tmp___3 = macid_parse((char *)"{client_addr}", (char **)((void *)0));
#line 1363
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___3, (char *)"", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                     1363, SmHeapGroup);
#line 1364
    tmp___4 = macid_parse((char *)"{client_port}", (char **)((void *)0));
#line 1364
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___4, (char *)"", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                     1364, SmHeapGroup);
#line 1365
    tmp___5 = macid_parse((char *)"{client_resolve}", (char **)((void *)0));
#line 1365
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___5, (char *)"", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                     1365, SmHeapGroup);
    }
  }
  {
#line 1368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1368
    _h.eh_value = (SM_EXC_T *)((void *)0);
#line 1368
    _h.eh_parent = SmExcHandler;
#line 1368
    _h.eh_state = 2;
#line 1368
    SmExcHandler = & _h;
#line 1368
    tmp___121 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 1368
    if (tmp___121 == 0) {
#line 1370
      skip_back = (ADDRESS *)((void *)0);
#line 1384
      rcode = 0;
#line 1385
      if ((e->e_from.q_mailer)->m_flags[105UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 105UL % (8UL * sizeof(int )))) {
#line 1386
        p = e->e_sender;
      } else {
#line 1388
        p = e->e_from.q_paddr;
      }
      {
#line 1389
      rpath = remotename(p, m, 5, & rcode, e);
#line 1390
      tmp___7 = strlen((char const   *)rpath);
      }
#line 1390
      if (tmp___7 > 203U) {
        {
#line 1392
        rpath = shortenstring((char const   *)rpath, (size_t )203);
#line 1395
        tmp___6 = __errno_location();
#line 1395
        *tmp___6 = 0;
#line 1396
        syserr("remotename: huge return path %s", rpath);
        }
      }
      {
#line 1398
      rpath = sm_rpool_strdup_x(e->e_rpool, (char const   *)rpath);
#line 1399
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'g', rpath, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                       1399, SmHeapGroup);
#line 1400
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'h', host, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                       1400, SmHeapGroup);
#line 1401
      Errors = 0;
#line 1402
      pvp = pv;
#line 1403
      tmp___8 = pvp;
#line 1403
      pvp ++;
#line 1403
      *tmp___8 = *(m->m_argv + 0);
      }
#line 1406
      if (m->m_flags[87UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 87UL % (8UL * sizeof(int )))) {
#line 1407
        IgnoreHostStatus = 1;
      }
#line 1410
      if (FromFlag) {
#line 1410
        if (m->m_flags[102UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 102UL % (8UL * sizeof(int )))) {
#line 1410
          goto _L;
        } else
#line 1410
        if (m->m_flags[114UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 114UL % (8UL * sizeof(int )))) {
          _L: /* CIL Label */ 
#line 1414
          if (m->m_flags[102UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 102UL % (8UL * sizeof(int )))) {
#line 1415
            tmp___9 = pvp;
#line 1415
            pvp ++;
#line 1415
            *tmp___9 = (char *)"-f";
          } else {
#line 1417
            tmp___10 = pvp;
#line 1417
            pvp ++;
#line 1417
            *tmp___10 = (char *)"-r";
          }
#line 1418
          tmp___11 = pvp;
#line 1418
          pvp ++;
#line 1418
          *tmp___11 = rpath;
        }
      }
#line 1428
      mvp = m->m_argv;
      {
#line 1428
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1428
        mvp ++;
#line 1428
        p = *mvp;
#line 1428
        if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1428
          goto while_break___0;
        }
        {
#line 1431
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1431
          if (! ((int )*p != 0)) {
#line 1431
            goto while_break___1;
          }
#line 1433
          tmp___12 = p;
#line 1433
          p ++;
#line 1433
          if (((int )*tmp___12 & 255) == 129) {
#line 1435
            if ((int )*p == 117) {
#line 1436
              goto while_break___1;
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1440
        if ((int )*p != 0) {
#line 1441
          goto while_break___0;
        }
        {
#line 1444
        expand(*mvp, buf___16, (size_t )sizeof(buf___16), e);
#line 1445
        tmp___13 = pvp;
#line 1445
        pvp ++;
#line 1445
        *tmp___13 = sm_rpool_strdup_x(e->e_rpool, (char const   *)(buf___16));
        }
#line 1446
        if ((unsigned long )pvp >= (unsigned long )(& pv[253])) {
          {
#line 1448
          syserr("554 5.3.5 Too many parameters to %s before $u", pv[0]);
#line 1450
          rcode = -1;
          }
#line 1451
          goto cleanup;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1461
      if ((unsigned long )*mvp == (unsigned long )((void *)0)) {
#line 1464
        clever = (bool volatile   )1;
#line 1465
        *pvp = (char *)((void *)0);
      } else
#line 1467
      if (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int )))) {
        {
#line 1470
        sm_syslog(3, (char const   *)((void *)0), "Warning: mailer %s: LMTP flag (F=z) turned off",
                  m->m_name);
#line 1473
        m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] &= ~ (1U << 122UL % (8UL * sizeof(int )));
        }
      }
#line 1483
      e->e_to = (char *)((void *)0);
#line 1484
      strsize = 2;
#line 1485
      rcptcount = 0;
#line 1486
      ctladdr = (ADDRESS */* volatile  */)((void *)0);
#line 1487
      if ((unsigned long )firstto->q_signature == (unsigned long )((void *)0)) {
        {
#line 1488
        firstto->q_signature = hostsignature(firstto->q_mailer, firstto->q_host);
        }
      }
#line 1490
      firstsig = firstto->q_signature;
      {
#line 1492
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1492
        if (! ((unsigned long )to != (unsigned long )((void *)0))) {
#line 1492
          goto while_break___2;
        }
#line 1495
        if ((unsigned long )tochain != (unsigned long )((void *)0)) {
#line 1495
          if (! (m->m_flags[109UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 109UL % (8UL * sizeof(int ))))) {
#line 1496
            goto while_break___2;
          }
        }
#line 1499
        if (! ((int )to->q_state == 0)) {
#line 1500
          goto __Cont;
        }
#line 1508
        if ((unsigned long )to->q_mailer != (unsigned long )firstto->q_mailer) {
#line 1509
          goto __Cont;
        }
#line 1511
        if ((unsigned long )to->q_signature == (unsigned long )((void *)0)) {
          {
#line 1512
          to->q_signature = hostsignature(to->q_mailer, to->q_host);
          }
        }
#line 1526
        if ((unsigned long )firstto == (unsigned long )to) {
#line 1526
          ret = 2;
        } else {
          {
#line 1526
          tmp___14 = coloncmp((char const   *)to->q_signature, (char const   *)firstsig);
#line 1526
          ret = tmp___14;
          }
        }
#line 1528
        if (ret == 2) {
#line 1529
          skip_back = to;
        } else
#line 1530
        if (ret == 0) {
#line 1531
          goto while_break___2;
        }
#line 1533
        if (! clever) {
          {
#line 1536
          tmp___15 = strlen((char const   *)to->q_paddr);
#line 1536
          strsize = (int )((size_t )strsize + (tmp___15 + 1U));
          }
#line 1537
          if (strsize > 4096) {
#line 1538
            goto while_break___2;
          }
        }
#line 1541
        rcptcount ++;
#line 1541
        if (rcptcount > (to->q_mailer)->m_maxrcpt) {
#line 1542
          goto while_break___2;
        }
#line 1544
        if ((int )tTdvect[10] >= 1) {
          {
#line 1546
          sm_dprintf((char *)"\nsend to ");
#line 1547
          tmp___16 = sm_debug_file();
#line 1547
          printaddr(tmp___16, to, 0);
          }
        }
#line 1551
        if ((to->q_mailer)->m_flags[111UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 111UL % (8UL * sizeof(int )))) {
          {
#line 1555
          tmp___17 = getctladdr(to);
#line 1555
          ctladdr = (ADDRESS */* volatile  */)tmp___17;
          }
        }
#line 1558
        if ((int )tTdvect[10] >= 2) {
          {
#line 1560
          sm_dprintf((char *)"ctladdr=");
#line 1561
          tmp___18 = sm_debug_file();
#line 1561
          printaddr(tmp___18, (ADDRESS *)ctladdr, 0);
          }
        }
#line 1564
        user = to->q_user;
#line 1565
        e->e_to = to->q_paddr;
#line 1573
        if (m->m_maxsize != 0L) {
#line 1573
          if (e->e_msgsize > m->m_maxsize) {
#line 1573
            goto _L___0;
          } else
#line 1573
          if (e->e_msgsize < 0L) {
            _L___0: /* CIL Label */ 
#line 1576
            e->e_flags |= 4UL;
#line 1577
            if ((to->q_mailer)->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int )))) {
#line 1578
              to->q_status = (char *)"5.2.3";
            } else {
#line 1580
              to->q_status = (char *)"5.3.4";
            }
            {
#line 1583
            usrerrenh(to->q_status, "552 Message is too large; %ld bytes max", m->m_maxsize);
#line 1586
            markfailure(e, to, (struct mailer_con_info *)((void *)0), 69, 0);
#line 1587
            giveresponse(69, to->q_status, m, (struct mailer_con_info *)((void *)0),
                         (ADDRESS *)ctladdr, xstart, e, to);
            }
#line 1589
            goto __Cont;
          }
        }
        {
#line 1591
        tmp___19 = __h_errno_location();
#line 1591
        *tmp___19 = 0;
#line 1592
        ovr = 1;
#line 1595
        quarantine = (unsigned long )e->e_quarmsg != (unsigned long )((void *)0);
#line 1596
        rcode = rscheck((char *)"check_compat", e->e_from.q_paddr, to->q_paddr, e,
                        5, 3, (char *)((void *)0), e->e_id);
        }
#line 1599
        if (rcode == 0) {
#line 1602
          if (! ((e->e_flags & 16777216UL) != 0UL)) {
            {
#line 1604
            rcode = checkcompat(to, e);
#line 1605
            ovr = 0;
            }
          }
        }
#line 1608
        if (rcode != 0) {
          {
#line 1610
          markfailure(e, to, (struct mailer_con_info *)((void *)0), rcode, ovr);
#line 1611
          giveresponse(rcode, to->q_status, m, (struct mailer_con_info *)((void *)0),
                       (ADDRESS *)ctladdr, xstart, e, to);
          }
#line 1613
          goto __Cont;
        }
#line 1615
        if (! quarantine) {
#line 1615
          if ((unsigned long )e->e_quarmsg != (unsigned long )((void *)0)) {
            {
#line 1623
            e->e_quarmsg = (char *)((void *)0);
#line 1624
            tmp___20 = macid_parse((char *)"{quarantine}", (char **)((void *)0));
#line 1624
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___20, (char *)"", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                             1625, SmHeapGroup);
            }
          }
        }
#line 1627
        if ((e->e_flags & 16777216UL) != 0UL) {
#line 1629
          if ((int )tTdvect[10] >= 5) {
            {
#line 1631
            sm_dprintf((char *)"deliver: discarding recipient ");
#line 1632
            tmp___21 = sm_debug_file();
#line 1632
            printaddr(tmp___21, to, 0);
            }
          }
#line 1637
          to->q_state = (short)10;
#line 1646
          e->e_flags &= 0xfffffffffeffffffUL;
#line 1647
          goto __Cont;
        }
#line 1655
        if (m->m_flags[115UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 115UL % (8UL * sizeof(int )))) {
          {
#line 1657
          stripquotes(user);
#line 1658
          stripquotes(host);
          }
        }
#line 1667
        if (m->m_flags[66UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 66UL % (8UL * sizeof(int )))) {
#line 1667
          if ((int )*(user + 0) == 92) {
            {
#line 1668
            stripbackslash(user);
            }
          }
        }
#line 1671
        if ((unsigned long )m == (unsigned long )ProgMailer) {
#line 1671
          if ((int )*user == 124) {
#line 1672
            user ++;
          }
        }
#line 1683
        if (! ((int )to->q_state == 0)) {
#line 1684
          goto __Cont;
        }
        {
#line 1694
        tmp___23 = strcmp((char const   *)m->m_mailer, "[FILE]");
        }
#line 1694
        if (tmp___23 == 0) {
          {
#line 1696
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'u', user, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                           1696, SmHeapGroup);
#line 1697
          p = to->q_home;
          }
#line 1698
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1698
            if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
#line 1699
              p = ctladdr->q_home;
            }
          }
          {
#line 1700
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'z', p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                           1700, SmHeapGroup);
#line 1701
          expand(*(m->m_argv + 1), buf___16, (size_t )sizeof(buf___16), e);
#line 1702
          tmp___22 = strlen((char const   *)(buf___16));
          }
#line 1702
          if (tmp___22 > 0U) {
            {
#line 1703
            rcode = mailfile((char */* volatile  */)(buf___16), (MAILER */* volatile  */)m,
                             (ADDRESS *)ctladdr, (long volatile   )64L, e);
            }
          } else {
            {
#line 1706
            syserr("empty filename specification for mailer %s", m->m_name);
#line 1708
            rcode = 78;
            }
          }
          {
#line 1710
          giveresponse(rcode, to->q_status, m, (struct mailer_con_info *)((void *)0),
                       (ADDRESS *)ctladdr, xstart, e, to);
#line 1712
          markfailure(e, to, (struct mailer_con_info *)((void *)0), rcode, 1);
#line 1713
          e->e_nsent = (short )((int )e->e_nsent + 1);
          }
#line 1714
          if (rcode == 0) {
#line 1716
            to->q_state = (short)1;
#line 1717
            if (m->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int )))) {
#line 1717
              if ((to->q_flags & 64UL) != 0UL) {
                {
#line 1720
                to->q_flags |= 4096UL;
#line 1721
                to->q_status = (char *)"2.1.5";
#line 1722
                sm_io_fprintf(e->e_xfp, -2, "%s... Successfully delivered\n", to->q_paddr);
                }
              }
            }
          }
          {
#line 1728
          to->q_statdate = curtime();
#line 1729
          markstats(e, to, 'n');
          }
#line 1730
          goto __Cont;
        }
        {
#line 1739
        to->q_tchain = (struct address *)tochain;
#line 1740
        tochain = (ADDRESS */* volatile  */)to;
#line 1741
        e->e_to = (char *)"[CHAIN]";
#line 1743
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'u', user, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                         1743, SmHeapGroup);
#line 1744
        p = to->q_home;
        }
#line 1745
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1745
          if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
#line 1746
            p = ctladdr->q_home;
          }
        }
        {
#line 1747
        macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'z', p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                         1747, SmHeapGroup);
        }
#line 1750
        if ((to->q_flags & 512UL) != 0UL) {
#line 1754
          notify[0] = (char )'\000';
#line 1755
          if ((to->q_flags & 64UL) != 0UL) {
            {
#line 1756
            sm_strlcat(notify, "SUCCESS,", (ssize_t )sizeof(notify));
            }
          }
#line 1758
          if ((to->q_flags & 128UL) != 0UL) {
            {
#line 1759
            sm_strlcat(notify, "FAILURE,", (ssize_t )sizeof(notify));
            }
          }
#line 1761
          if ((to->q_flags & 256UL) != 0UL) {
            {
#line 1762
            sm_strlcat(notify, "DELAY,", (ssize_t )sizeof(notify));
            }
          }
#line 1766
          if ((int )notify[0] == 0) {
            {
#line 1767
            sm_strlcat(notify, "NEVER", (ssize_t )sizeof(notify));
            }
          } else {
            {
#line 1770
            tmp___24 = strlen((char const   *)(notify));
#line 1770
            notify[tmp___24 - 1U] = (char )'\000';
            }
          }
          {
#line 1772
          tmp___25 = macid_parse((char *)"{dsn_notify}", (char **)((void *)0));
#line 1772
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___25, notify, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                           1773, SmHeapGroup);
          }
        } else {
          {
#line 1776
          tmp___26 = macid_parse((char *)"{dsn_notify}", (char **)((void *)0));
#line 1776
          macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, tmp___26, (char *)((void *)0),
                           (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                           1777, SmHeapGroup);
          }
        }
#line 1783
        if (! clever) {
          {
#line 1785
          expand(*mvp, buf___16, (size_t )sizeof(buf___16), e);
#line 1786
          tmp___27 = pvp;
#line 1786
          pvp ++;
#line 1786
          *tmp___27 = sm_rpool_strdup_x(e->e_rpool, (char const   *)(buf___16));
          }
#line 1787
          if ((unsigned long )pvp >= (unsigned long )(& pv[254])) {
#line 1790
            goto while_break___2;
          }
        }
        __Cont: /* CIL Label */ 
#line 1492
        to = to->q_next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1796
      if ((unsigned long )tochain == (unsigned long )((void *)0)) {
#line 1798
        rcode = 0;
#line 1799
        goto cleanup;
      }
#line 1803
      strsize = 1;
#line 1804
      to = (ADDRESS *)tochain;
      {
#line 1804
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1804
        if (! ((unsigned long )to != (unsigned long )((void *)0))) {
#line 1804
          goto while_break___3;
        }
        {
#line 1805
        tmp___28 = strlen((char const   *)to->q_paddr);
#line 1805
        strsize = (int )((size_t )strsize + (tmp___28 + 1U));
#line 1804
        to = to->q_tchain;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1806
      if (strsize < 4096) {
#line 1807
        strsize = 4096;
      }
#line 1808
      if (strsize > tobufsize) {
#line 1810
        if ((unsigned long )tobuf != (unsigned long )((void *)0)) {
          {
#line 1810
          sm_free_tagged((void *)tobuf, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                         1810);
#line 1810
          tobuf = (char *)((void *)0);
          }
        }
        {
#line 1811
        tmp___29 = sm_malloc_tagged_x((size_t )strsize, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                                      1811, 0);
#line 1811
        tobuf = (char *)tmp___29;
#line 1812
        tobufsize = strsize;
        }
      }
#line 1814
      p = tobuf;
#line 1815
      *p = (char )'\000';
#line 1816
      to = (ADDRESS *)tochain;
      {
#line 1816
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1816
        if (! ((unsigned long )to != (unsigned long )((void *)0))) {
#line 1816
          goto while_break___4;
        }
        {
#line 1818
        sm_strlcpyn(p, (ssize_t )((long )tobufsize - (p - tobuf)), 2, ",", to->q_paddr);
#line 1820
        tmp___30 = strlen((char const   *)p);
#line 1820
        p += tmp___30;
#line 1816
        to = to->q_tchain;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1822
      e->e_to = tobuf + 1;
#line 1828
      if (! clever) {
        {
#line 1830
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1830
          mvp ++;
#line 1830
          if (! ((unsigned long )*mvp != (unsigned long )((void *)0))) {
#line 1830
            goto while_break___5;
          }
          {
#line 1832
          expand(*mvp, buf___16, (size_t )sizeof(buf___16), e);
#line 1833
          tmp___31 = pvp;
#line 1833
          pvp ++;
#line 1833
          *tmp___31 = sm_rpool_strdup_x(e->e_rpool, (char const   *)(buf___16));
          }
#line 1834
          if ((unsigned long )pvp >= (unsigned long )(& pv[256])) {
            {
#line 1835
            syserr("554 5.3.0 deliver: pv overflow after $u for %s", pv[0]);
            }
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 1839
      tmp___32 = pvp;
#line 1839
      pvp ++;
#line 1839
      *tmp___32 = (char *)((void *)0);
#line 1850
      if ((unsigned long )ctladdr == (unsigned long )((void *)0)) {
#line 1850
        if ((unsigned long )m != (unsigned long )ProgMailer) {
#line 1850
          if ((unsigned long )m != (unsigned long )FileMailer) {
#line 1850
            if ((e->e_from.q_flags & 1UL) != 0UL) {
#line 1852
              ctladdr = (ADDRESS */* volatile  */)(& e->e_from);
            }
          }
        }
      }
#line 1855
      if (ConfigLevel < 2) {
        {
#line 1856
        tmp___33 = __res_state();
#line 1856
        tmp___33->options &= 0xfffffffffffffd7fUL;
        }
      }
#line 1859
      if ((int )tTdvect[11] >= 1) {
        {
#line 1861
        sm_dprintf((char *)"openmailer:");
#line 1862
        tmp___34 = sm_debug_file();
#line 1862
        printav(tmp___34, pv);
        }
      }
      {
#line 1864
      tmp___35 = __errno_location();
#line 1864
      *tmp___35 = 0;
#line 1865
      tmp___36 = __h_errno_location();
#line 1865
      *tmp___36 = 0;
#line 1866
      CurHostName = (char *)((void *)0);
#line 1877
      curhost = (char */* volatile  */)((void *)0);
#line 1878
      SmtpPhase = (char *)((void *)0);
#line 1879
      mci = (struct mailer_con_info */* volatile  */)((void *)0);
#line 1886
      tmp___37 = shortenstring((char const   *)e->e_to, (size_t )203);
#line 1886
      sm_snprintf(wbuf, (size_t )sizeof(wbuf), "%s... openmailer(%s)", tmp___37, m->m_name);
#line 1889
      checkfd012(wbuf);
      }
#line 1894
      if ((e->e_flags & 131072UL) != 0UL) {
#line 1894
        if (m->m_flags[55UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 55UL % (8UL * sizeof(int )))) {
#line 1894
          if ((e->e_flags & 8388608UL) != 0UL) {
            {
#line 1901
            e->e_status = (char *)"5.6.3";
#line 1902
            usrerrenh(e->e_status, "554 Cannot send 8-bit data to 7-bit destination");
#line 1904
            rcode = 65;
            }
#line 1905
            goto give_up;
          } else
#line 1894
          if (! ((MimeMode & 4) != 0)) {
#line 1894
            if ((e->e_flags & 4194304UL) != 0UL) {
#line 1894
              if (! ((MimeMode & 1) != 0)) {
                {
#line 1901
                e->e_status = (char *)"5.6.3";
#line 1902
                usrerrenh(e->e_status, "554 Cannot send 8-bit data to 7-bit destination");
#line 1904
                rcode = 65;
                }
#line 1905
                goto give_up;
              }
            } else {
              {
#line 1901
              e->e_status = (char *)"5.6.3";
#line 1902
              usrerrenh(e->e_status, "554 Cannot send 8-bit data to 7-bit destination");
#line 1904
              rcode = 65;
              }
#line 1905
              goto give_up;
            }
          }
        }
      }
#line 1908
      if ((int )tTdvect[62] >= 8) {
        {
#line 1909
        checkfds((char *)"before delivery");
        }
      }
      {
#line 1912
      tmp___104 = strcmp((char const   *)m->m_mailer, "[LPC]");
      }
#line 1912
      if (tmp___104 == 0) {
#line 1914
        if (clever) {
          {
#line 1917
          mci_scan((struct mailer_con_info *)((void *)0));
#line 1920
          tmp___38 = mci_get(m->m_name, m);
#line 1920
          mci = (struct mailer_con_info */* volatile  */)tmp___38;
          }
#line 1921
          if ((unsigned long )mci->mci_host == (unsigned long )((void *)0)) {
#line 1922
            mci->mci_host = m->m_name;
          }
#line 1923
          CurHostName = mci->mci_host;
#line 1924
          if ((int )mci->mci_state != 0) {
            {
#line 1926
            message("Using cached SMTP/LPC connection for %s...", m->m_name);
#line 1928
            (mci->mci_deliveries) ++;
            }
#line 1929
            goto do_transfer;
          }
        } else {
          {
#line 1934
          tmp___39 = mci_new(e->e_rpool);
#line 1934
          mci = (struct mailer_con_info */* volatile  */)tmp___39;
          }
        }
#line 1936
        mci->mci_in = & SmIoF[0];
#line 1937
        mci->mci_out = & SmIoF[1];
#line 1938
        mci->mci_mailer = m;
#line 1939
        mci->mci_host = m->m_name;
#line 1940
        if (clever) {
          {
#line 1942
          mci->mci_state = (short)1;
#line 1943
          mci_cache((struct mailer_con_info *)mci);
          }
        } else {
#line 1946
          mci->mci_state = (short)2;
        }
      } else {
        {
#line 1948
        tmp___103 = strcmp((char const   *)m->m_mailer, "[IPC]");
        }
#line 1948
        if (tmp___103 == 0) {
#line 1952
          if ((unsigned long )pv[0] == (unsigned long )((void *)0)) {
            {
#line 1954
            syserr("null destination for %s mailer", m->m_mailer);
#line 1955
            rcode = 78;
            }
#line 1956
            goto give_up;
          } else
#line 1952
          if ((unsigned long )pv[1] == (unsigned long )((void *)0)) {
            {
#line 1954
            syserr("null destination for %s mailer", m->m_mailer);
#line 1955
            rcode = 78;
            }
#line 1956
            goto give_up;
          } else
#line 1952
          if ((int )*(pv[1] + 0) == 0) {
            {
#line 1954
            syserr("null destination for %s mailer", m->m_mailer);
#line 1955
            rcode = 78;
            }
#line 1956
            goto give_up;
          }
          {
#line 1960
          tmp___41 = strcmp((char const   *)pv[0], "FILE");
          }
#line 1960
          if (tmp___41 == 0) {
#line 1962
            CurHostName = (char *)"localhost";
#line 1962
            curhost = (char */* volatile  */)CurHostName;
#line 1963
            mux_path = pv[1];
          } else {
            {
#line 1968
            CurHostName = pv[1];
#line 1969
            tmp___40 = hostsignature(m, pv[1]);
#line 1969
            curhost = (char */* volatile  */)tmp___40;
            }
          }
#line 1972
          if ((unsigned long )curhost == (unsigned long )((void *)0)) {
            {
#line 1974
            syserr("null host signature for %s", pv[1]);
#line 1975
            rcode = 78;
            }
#line 1976
            goto give_up;
          } else
#line 1972
          if ((int )*(curhost + 0) == 0) {
            {
#line 1974
            syserr("null host signature for %s", pv[1]);
#line 1975
            rcode = 78;
            }
#line 1976
            goto give_up;
          }
#line 1979
          if (! clever) {
            {
#line 1981
            syserr("554 5.3.5 non-clever IPC");
#line 1982
            rcode = 78;
            }
#line 1983
            goto give_up;
          }
#line 1985
          if ((unsigned long )pv[2] != (unsigned long )((void *)0)) {
#line 1985
            if ((unsigned long )mux_path == (unsigned long )((void *)0)) {
              {
#line 1991
              tmp___42 = atoi((char const   *)pv[2]);
#line 1991
              port = htons((unsigned short )tmp___42);
              }
#line 1992
              if ((int )port == 0) {
                {
#line 1997
                tmp___43 = getservbyname((char const   *)pv[2], "tcp");
#line 1997
                sp = tmp___43;
                }
#line 1999
                if ((unsigned long )sp == (unsigned long )((void *)0)) {
                  {
#line 2000
                  syserr("Service %s unknown", pv[2]);
                  }
                } else {
#line 2002
                  port = (unsigned short )sp->s_port;
                }
              }
            }
          }
          {
#line 2007
          nummxhosts = parse_hostsignature((char *)curhost, mxhosts, m);
          }
#line 2008
          if (TimeOuts.to_aconnect > 0L) {
            {
#line 2009
            tmp___44 = curtime();
#line 2009
            enough = tmp___44 + TimeOuts.to_aconnect;
            }
          }
          tryhost: 
          {
#line 2011
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2011
            if (! (hostnum < nummxhosts)) {
#line 2011
              goto while_break___6;
            }
            {
#line 2013
            sep = (char )':';
#line 2016
            tried_fallbacksmarthost = 0;
#line 2028
            endp = strpbrk((char const   *)mxhosts[hostnum], ":,");
            }
#line 2030
            if ((unsigned long )endp != (unsigned long )((void *)0)) {
#line 2032
              sep = *endp;
#line 2033
              *endp = (char )'\000';
            }
#line 2036
            if (hostnum == 1) {
#line 2036
              if ((unsigned long )skip_back != (unsigned long )((void *)0)) {
#line 2051
                tochain = (ADDRESS */* volatile  */)skip_back;
              }
            }
#line 2054
            if ((int )*(mxhosts[hostnum]) == 0) {
              {
#line 2056
              syserr("deliver: null host name in signature");
#line 2057
              hostnum ++;
              }
#line 2058
              if ((unsigned long )endp != (unsigned long )((void *)0)) {
#line 2059
                *endp = sep;
              }
#line 2060
              goto while_continue___6;
            }
            {
#line 2062
            sm_strlcpy(hostbuf, (char const   *)mxhosts[hostnum], (ssize_t )sizeof(hostbuf));
#line 2064
            hostnum ++;
            }
#line 2065
            if ((unsigned long )endp != (unsigned long )((void *)0)) {
#line 2066
              *endp = sep;
            }
            one_last_try: 
            {
#line 2070
            CurHostName = hostbuf;
#line 2071
            tmp___45 = mci_get(hostbuf, m);
#line 2071
            mci = (struct mailer_con_info */* volatile  */)tmp___45;
            }
#line 2072
            if ((int )mci->mci_state != 0) {
#line 2076
              if ((int )tTdvect[11] >= 1) {
                {
#line 2078
                sm_dprintf((char *)"openmailer: ");
#line 2079
                tmp___46 = sm_debug_file();
#line 2079
                mci_dump(tmp___46, (struct mailer_con_info *)mci, 0);
                }
              }
#line 2081
              CurHostName = mci->mci_host;
#line 2082
              if (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int )))) {
#line 2083
                type = (char *)"L";
              } else
#line 2084
              if ((mci->mci_flags & 8UL) != 0UL) {
#line 2085
                type = (char *)"ES";
              } else {
#line 2087
                type = (char *)"S";
              }
              {
#line 2088
              message("Using cached %sMTP connection to %s via %s...", type, hostbuf,
                      m->m_name);
#line 2090
              (mci->mci_deliveries) ++;
              }
#line 2091
              goto while_break___6;
            }
#line 2093
            mci->mci_mailer = m;
#line 2094
            if ((int )mci->mci_exitstat != 0) {
#line 2096
              if ((int )mci->mci_exitstat == 75) {
#line 2097
                goodmxfound = 1;
              }
              {
#line 2100
              tmp___47 = should_try_fbsh(e, & tried_fallbacksmarthost, hostbuf, (size_t )sizeof(hostbuf),
                                         (int )mci->mci_exitstat);
              }
#line 2100
              if (tmp___47) {
#line 2103
                goto one_last_try;
              }
#line 2105
              goto while_continue___6;
            }
            {
#line 2108
            tmp___48 = mci_lock_host((struct mailer_con_info *)mci);
            }
#line 2108
            if (tmp___48 != 0) {
              {
#line 2110
              mci_setstat((struct mailer_con_info *)mci, 75, (char *)"4.4.5", (char *)((void *)0));
#line 2111
              goodmxfound = 1;
              }
#line 2112
              goto while_continue___6;
            }
            {
#line 2116
            tmp___49 = qid_printname(e);
#line 2116
            sm_setproctitle(1, e, "%s %s: %s", tmp___49, hostbuf, "user open");
            }
#line 2120
            if ((unsigned long )mux_path != (unsigned long )((void *)0)) {
              {
#line 2122
              message("Connecting to %s via %s...", mux_path, m->m_name);
#line 2124
              i = makeconnection_ds(mux_path, (struct mailer_con_info *)mci);
              }
            } else {
#line 2129
              if ((int )port == 0) {
                {
#line 2130
                message("Connecting to %s via %s...", hostbuf, m->m_name);
                }
              } else {
                {
#line 2133
                tmp___50 = ntohs(port);
#line 2133
                message("Connecting to %s port %d via %s...", hostbuf, (int )tmp___50,
                        m->m_name);
                }
              }
              {
#line 2136
              i = makeconnection(hostbuf, (unsigned int volatile   )port, (struct mailer_con_info *)mci,
                                 e, enough);
              }
            }
            {
#line 2139
            tmp___51 = __errno_location();
#line 2139
            mci->mci_errno = (short )*tmp___51;
#line 2140
            mci->mci_lastuse = curtime();
#line 2141
            mci->mci_deliveries = 0;
#line 2142
            mci->mci_exitstat = (short )i;
#line 2144
            tmp___52 = __h_errno_location();
#line 2144
            mci->mci_herrno = (short )*tmp___52;
            }
#line 2153
            if (enough > 0L) {
#line 2153
              if (mci->mci_lastuse >= enough) {
#line 2162
                if (hostnum < nummxhosts) {
#line 2162
                  if (LogLevel > 9) {
                    {
#line 2163
                    sm_syslog(6, (char const   *)e->e_id, "Timeout.to_aconnect occurred before exhausting all addresses");
                    }
                  }
                }
#line 2167
                if (NumFallbackMXHosts > 0) {
#line 2168
                  enough = (time_t )0;
                }
#line 2171
                h = nummxhosts - NumFallbackMXHosts;
#line 2172
                if (hostnum < h) {
#line 2173
                  hostnum = h;
                }
              }
            }
#line 2175
            if (i == 0) {
              {
#line 2177
              goodmxfound = 1;
#line 2178
              markstats(e, firstto, 'c');
#line 2179
              mci->mci_state = (short)1;
#line 2180
              mci_cache((struct mailer_con_info *)mci);
              }
#line 2181
              if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
                {
#line 2182
                sm_io_fprintf(TrafficLogFile, -2, "%05d === CONNECT %s\n", CurrentPid,
                              hostbuf);
                }
              }
#line 2187
              goto while_break___6;
            } else {
              {
#line 2192
              tmp___53 = should_try_fbsh(e, & tried_fallbacksmarthost, hostbuf, (size_t )sizeof(hostbuf),
                                         i);
              }
#line 2192
              if (tmp___53) {
#line 2194
                goto one_last_try;
              }
#line 2196
              if ((int )tTdvect[11] >= 1) {
                {
#line 2197
                tmp___54 = __errno_location();
#line 2197
                sm_dprintf((char *)"openmailer: makeconnection => stat=%d, errno=%d\n",
                           i, *tmp___54);
                }
              }
#line 2199
              if (i == 75) {
#line 2200
                goodmxfound = 1;
              }
              {
#line 2201
              mci_unlock_host((struct mailer_con_info *)mci);
              }
            }
#line 2205
            if (ExitStat == 0) {
#line 2205
              ExitStat = i;
            } else
#line 2205
            if (ExitStat == 75) {
#line 2205
              ExitStat = i;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
#line 2209
          if ((unsigned long )mci == (unsigned long )((void *)0)) {
            {
#line 2211
            syserr("deliver: no host name");
#line 2212
            rcode = 70;
            }
#line 2213
            goto give_up;
          }
#line 2215
          mci->mci_pid = 0;
        } else {
          {
#line 2220
          mci_scan((struct mailer_con_info *)((void *)0));
#line 2221
          mci = (struct mailer_con_info */* volatile  */)((void *)0);
          }
#line 2223
          if (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int )))) {
            {
#line 2226
            tmp___55 = mci_get(m->m_name, m);
#line 2226
            mci = (struct mailer_con_info */* volatile  */)tmp___55;
            }
#line 2227
            if ((unsigned long )mci->mci_host == (unsigned long )((void *)0)) {
#line 2228
              mci->mci_host = m->m_name;
            }
#line 2229
            CurHostName = mci->mci_host;
#line 2230
            if ((int )mci->mci_state != 0) {
              {
#line 2232
              message("Using cached LMTP connection for %s...", m->m_name);
#line 2234
              (mci->mci_deliveries) ++;
              }
#line 2235
              goto do_transfer;
            }
          }
#line 2240
          if ((unsigned long )host == (unsigned long )((void *)0)) {
            {
#line 2241
            message("Connecting to %s...", m->m_name);
            }
          } else
#line 2240
          if ((int )*(host + 0) == 0) {
            {
#line 2241
            message("Connecting to %s...", m->m_name);
            }
          } else {
            {
#line 2243
            message("Connecting to %s via %s...", host, m->m_name);
            }
          }
#line 2244
          if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
            {
#line 2248
            sm_io_fprintf(TrafficLogFile, -2, "%05d === EXEC", CurrentPid);
#line 2250
            av___0 = pv;
            }
            {
#line 2250
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 2250
              if (! ((unsigned long )*av___0 != (unsigned long )((void *)0))) {
#line 2250
                goto while_break___7;
              }
              {
#line 2251
              sm_io_fprintf(TrafficLogFile, -2, " %s", *av___0);
#line 2250
              av___0 ++;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
            {
#line 2254
            sm_io_fprintf(TrafficLogFile, -2, "\n");
            }
          }
          {
#line 2259
          checkfd012((char *)"before creating mail pipe");
#line 2263
          tmp___57 = pipe((int *)(mpvect));
          }
#line 2263
          if (tmp___57 < 0) {
            {
#line 2265
            tmp___56 = shortenstring((char const   *)e->e_to, (size_t )203);
#line 2265
            syserr("%s... openmailer(%s): pipe (to mailer)", tmp___56, m->m_name);
            }
#line 2267
            if ((int )tTdvect[11] >= 1) {
              {
#line 2268
              sm_dprintf((char *)"openmailer: NULL\n");
              }
            }
#line 2269
            rcode = 71;
#line 2270
            goto give_up;
          }
#line 2275
          if (mpvect[0] < 3) {
#line 2275
            goto _L___1;
          } else
#line 2275
          if (mpvect[1] < 3) {
            _L___1: /* CIL Label */ 
            {
#line 2277
            tmp___58 = shortenstring((char const   *)e->e_to, (size_t )203);
#line 2277
            syserr("%s... openmailer(%s): bogus mpvect %d %d", tmp___58, m->m_name,
                   mpvect[0], mpvect[1]);
#line 2280
            printopenfds(1);
            }
#line 2281
            if ((int )tTdvect[11] >= 1) {
              {
#line 2282
              sm_dprintf((char *)"openmailer: NULL\n");
              }
            }
#line 2283
            rcode = 71;
#line 2284
            goto give_up;
          }
          {
#line 2288
          checkfdopen(mpvect[0], (char *)"mpvect[0]");
#line 2289
          checkfdopen(mpvect[1], (char *)"mpvect[1]");
          }
#line 2290
          if (mpvect[0] == mpvect[1]) {
#line 2290
            goto _L___3;
          } else
#line 2290
          if ((unsigned long )e->e_lockfp != (unsigned long )((void *)0)) {
            {
#line 2290
            tmp___62 = sm_io_getinfo(e->e_lockfp, 3, (void *)0);
            }
#line 2290
            if (mpvect[0] == tmp___62) {
#line 2290
              goto _L___3;
            } else {
              {
#line 2290
              tmp___63 = sm_io_getinfo(e->e_lockfp, 3, (void *)0);
              }
#line 2290
              if (mpvect[1] == tmp___63) {
                _L___3: /* CIL Label */ 
#line 2297
                if ((unsigned long )e->e_lockfp == (unsigned long )((void *)0)) {
                  {
#line 2298
                  tmp___59 = shortenstring((char const   *)e->e_to, (size_t )203);
#line 2298
                  syserr("%s... openmailer(%s): overlapping mpvect %d %d", tmp___59,
                         m->m_name, mpvect[0], mpvect[1]);
                  }
                } else {
                  {
#line 2302
                  tmp___60 = sm_io_getinfo(e->e_lockfp, 3, (void *)0);
#line 2302
                  tmp___61 = shortenstring((char const   *)e->e_to, (size_t )203);
#line 2302
                  syserr("%s... openmailer(%s): overlapping mpvect %d %d, lockfp = %d",
                         tmp___61, m->m_name, mpvect[0], mpvect[1], tmp___60);
                  }
                }
              }
            }
          }
          {
#line 2311
          tmp___65 = pipe((int *)(rpvect));
          }
#line 2311
          if (tmp___65 < 0) {
            {
#line 2313
            tmp___64 = shortenstring((char const   *)e->e_to, (size_t )203);
#line 2313
            syserr("%s... openmailer(%s): pipe (from mailer)", tmp___64, m->m_name);
#line 2316
            close(mpvect[0]);
#line 2317
            close(mpvect[1]);
            }
#line 2318
            if ((int )tTdvect[11] >= 1) {
              {
#line 2319
              sm_dprintf((char *)"openmailer: NULL\n");
              }
            }
#line 2320
            rcode = 71;
#line 2321
            goto give_up;
          }
          {
#line 2324
          checkfdopen(rpvect[0], (char *)"rpvect[0]");
#line 2325
          checkfdopen(rpvect[1], (char *)"rpvect[1]");
          }
#line 2336
          if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
            {
#line 2337
            sm_io_flush(e->e_xfp, -2);
            }
          }
          {
#line 2338
          sm_io_flush(& SmIoF[1], -2);
#line 2339
          sm_signal(17, (void (*)(int  ))0);
#line 2342
          i___0 = 5;
          }
          {
#line 2342
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 2342
            i___0 --;
#line 2342
            if (! (i___0 >= 0)) {
#line 2342
              goto while_break___8;
            }
            {
#line 2342
            tmp___66 = fork();
#line 2342
            pid = (pid_t volatile   )tmp___66;
            }
#line 2342
            if (pid >= (pid_t volatile   )0) {
#line 2342
              goto while_break___8;
            }
#line 2342
            if (i___0 > 0) {
              {
#line 2342
              sleep(5U - (unsigned int )i___0);
              }
            }
          }
          while_break___8: /* CIL Label */ ;
          }
#line 2345
          if (pid < (pid_t volatile   )0) {
            {
#line 2348
            tmp___67 = shortenstring((char const   *)e->e_to, (size_t )203);
#line 2348
            syserr("%s... openmailer(%s): cannot fork", tmp___67, m->m_name);
#line 2350
            close(mpvect[0]);
#line 2351
            close(mpvect[1]);
#line 2352
            close(rpvect[0]);
#line 2353
            close(rpvect[1]);
            }
#line 2354
            if ((int )tTdvect[11] >= 1) {
              {
#line 2355
              sm_dprintf((char *)"openmailer: NULL\n");
              }
            }
#line 2356
            rcode = 71;
#line 2357
            goto give_up;
          } else
#line 2359
          if (pid == (pid_t volatile   )0) {
            {
#line 2363
            new_euid = -1;
#line 2364
            new_ruid = -1;
#line 2365
            new_gid = -1;
#line 2366
            user___0 = (char *)((void *)0);
#line 2370
            CurrentPid = getpid();
#line 2373
            sm_clear_events();
#line 2376
            RestartRequest = (char */* volatile  */)((void *)0);
#line 2377
            RestartWorkGroup = (bool volatile   )0;
#line 2378
            ShutdownRequest = (char */* volatile  */)((void *)0);
#line 2379
            PendingSignal = (int volatile   )0;
            }
#line 2381
            if ((unsigned long )e->e_lockfp != (unsigned long )((void *)0)) {
              {
#line 2382
              tmp___68 = sm_io_getinfo(e->e_lockfp, 3, (void *)0);
#line 2382
              close(tmp___68);
              }
            }
            {
#line 2387
            sm_signal(14, & sm_signal_noop);
#line 2388
            sm_signal(17, (void (*)(int  ))0);
#line 2389
            sm_signal(1, (void (*)(int  ))1);
#line 2390
            sm_signal(2, (void (*)(int  ))1);
#line 2391
            sm_signal(15, (void (*)(int  ))0);
#line 2393
            sm_signal(10, & sm_signal_noop);
            }
#line 2396
            if ((unsigned long )m != (unsigned long )FileMailer) {
#line 2397
              stb.st_mode = (__mode_t )0;
            } else {
              {
#line 2396
              tmp___69 = stat((char const   */* __restrict  */)tochain->q_user, (struct stat */* __restrict  */)(& stb));
              }
#line 2396
              if (tmp___69 < 0) {
#line 2397
                stb.st_mode = (__mode_t )0;
              }
            }
#line 2430
            if ((int )m->m_nice != 0) {
              {
#line 2431
              nice((int )m->m_nice);
              }
            }
#line 2435
            if (m->m_flags[83UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 83UL % (8UL * sizeof(int )))) {
#line 2437
              if (m->m_gid == 4294967295U) {
#line 2438
                new_gid = (int )RunAsGid;
              } else {
#line 2440
                new_gid = (int )m->m_gid;
              }
            } else
#line 2442
            if ((stb.st_mode & 1024U) != 0U) {
#line 2443
              new_gid = (int )stb.st_gid;
            } else
#line 2444
            if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
#line 2444
              if (ctladdr->q_gid != 0U) {
#line 2446
                if (! DontInitGroups) {
#line 2448
                  user___0 = ctladdr->q_ruser;
#line 2449
                  if ((unsigned long )user___0 == (unsigned long )((void *)0)) {
#line 2450
                    user___0 = ctladdr->q_user;
                  }
                  {
#line 2452
                  tmp___70 = initgroups((char const   *)user___0, ctladdr->q_gid);
                  }
#line 2452
                  if (tmp___70 == -1) {
#line 2452
                    if (suidwarn) {
                      {
#line 2456
                      syserr("openmailer: initgroups(%s, %d) failed", user___0, ctladdr->q_gid);
#line 2458
                      exit(75);
                      }
                    }
                  }
                } else {
                  {
#line 2465
                  gidset[0] = ctladdr->q_gid;
#line 2466
                  tmp___71 = setgroups((size_t )1, (__gid_t const   *)(gidset));
                  }
#line 2466
                  if (tmp___71 == -1) {
#line 2466
                    if (suidwarn) {
                      {
#line 2469
                      syserr("openmailer: setgroups() failed");
#line 2470
                      exit(75);
                      }
                    }
                  }
                }
#line 2473
                new_gid = (int )ctladdr->q_gid;
              } else {
#line 2444
                goto _L___4;
              }
            } else {
              _L___4: /* CIL Label */ 
#line 2477
              if (! DontInitGroups) {
                {
#line 2479
                user___0 = DefUser;
#line 2480
                tmp___72 = initgroups((char const   *)DefUser, DefGid);
                }
#line 2480
                if (tmp___72 == -1) {
#line 2480
                  if (suidwarn) {
                    {
#line 2483
                    syserr("openmailer: initgroups(%s, %d) failed", DefUser, DefGid);
#line 2485
                    exit(75);
                    }
                  }
                }
              } else {
                {
#line 2492
                gidset___0[0] = DefGid;
#line 2493
                tmp___73 = setgroups((size_t )1, (__gid_t const   *)(gidset___0));
                }
#line 2493
                if (tmp___73 == -1) {
#line 2493
                  if (suidwarn) {
                    {
#line 2496
                    syserr("openmailer: setgroups() failed");
#line 2497
                    exit(75);
                    }
                  }
                }
              }
#line 2500
              if (m->m_gid == 4294967295U) {
#line 2501
                new_gid = (int )DefGid;
              } else {
#line 2503
                new_gid = (int )m->m_gid;
              }
            }
#line 2505
            if (new_gid != -1) {
#line 2507
              if (RunAsUid != 0U) {
#line 2507
                if (m->m_flags[83UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 83UL % (8UL * sizeof(int )))) {
                  {
#line 2507
                  tmp___76 = getgid();
                  }
#line 2507
                  if ((__gid_t )new_gid != tmp___76) {
                    {
#line 2507
                    tmp___77 = getegid();
                    }
#line 2507
                    if ((__gid_t )new_gid != tmp___77) {
                      {
#line 2513
                      tmp___74 = getegid();
#line 2513
                      tmp___75 = getgid();
#line 2513
                      syserr("openmailer: insufficient privileges to change gid, RunAsUid=%d, new_gid=%d, gid=%d, egid=%d",
                             (int )RunAsUid, new_gid, (int )tmp___75, (int )tmp___74);
#line 2516
                      exit(75);
                      }
                    }
                  }
                }
              }
              {
#line 2519
              tmp___78 = setgid((__gid_t )new_gid);
              }
#line 2519
              if (tmp___78 < 0) {
#line 2519
                if (suidwarn) {
                  {
#line 2521
                  syserr("openmailer: setgid(%ld) failed", (long )new_gid);
#line 2523
                  exit(75);
                  }
                }
              }
            }
#line 2528
            if ((unsigned long )m->m_rootdir != (unsigned long )((void *)0)) {
              {
#line 2530
              expand(m->m_rootdir, cbuf, (size_t )sizeof(cbuf), e);
              }
#line 2531
              if ((int )tTdvect[11] >= 20) {
                {
#line 2532
                sm_dprintf((char *)"openmailer: chroot %s\n", cbuf);
                }
              }
              {
#line 2534
              tmp___79 = chroot((char const   *)(cbuf));
              }
#line 2534
              if (tmp___79 < 0) {
                {
#line 2536
                syserr("openmailer: Cannot chroot(%s)", cbuf);
#line 2538
                exit(75);
                }
              }
              {
#line 2540
              tmp___80 = chdir("/");
              }
#line 2540
              if (tmp___80 < 0) {
                {
#line 2542
                syserr("openmailer: cannot chdir(/)");
#line 2543
                exit(75);
                }
              }
            }
            {
#line 2548
            endpwent();
#line 2549
            sm_mbdb_terminate();
            }
#line 2550
            if (m->m_flags[83UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 83UL % (8UL * sizeof(int )))) {
#line 2552
              if (m->m_uid == 4294967295U) {
#line 2553
                new_euid = (int )RunAsUid;
              } else {
#line 2555
                new_euid = (int )m->m_uid;
              }
#line 2564
              if (RealUid != 0U) {
                {
#line 2564
                tmp___81 = getuid();
                }
#line 2564
                if (RealUid != tmp___81) {
#line 2577
                  new_ruid = (int )RealUid;
                }
              }
            } else
#line 2581
            if ((stb.st_mode & 2048U) != 0U) {
#line 2582
              new_ruid = (int )stb.st_uid;
            } else
#line 2583
            if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
#line 2583
              if (ctladdr->q_uid != 0U) {
#line 2584
                new_ruid = (int )ctladdr->q_uid;
              } else {
#line 2583
                goto _L___5;
              }
            } else
            _L___5: /* CIL Label */ 
#line 2585
            if (m->m_uid != 4294967295U) {
#line 2586
              new_ruid = (int )m->m_uid;
            } else {
#line 2588
              new_ruid = (int )DefUid;
            }
#line 2605
            if (new_euid != -1) {
#line 2607
              if (RunAsUid != 0U) {
#line 2607
                if ((uid_t )new_euid != RunAsUid) {
                  {
#line 2610
                  syserr("openmailer: insufficient privileges to change uid, new_euid=%d, RunAsUid=%d",
                         new_euid, (int )RunAsUid);
#line 2612
                  exit(75);
                  }
                }
              }
              {
#line 2615
              vendor_set_uid((uid_t )new_euid);
#line 2625
              tmp___82 = setreuid((__uid_t )new_ruid, (__uid_t )new_euid);
              }
#line 2625
              if (tmp___82 < 0) {
#line 2625
                if (suidwarn) {
                  {
#line 2627
                  syserr("openmailer: setreuid(%ld, %ld) failed", (long )new_ruid,
                         (long )new_euid);
#line 2629
                  exit(75);
                  }
                }
              }
            } else
#line 2641
            if (new_ruid != -1) {
              {
#line 2643
              vendor_set_uid((uid_t )new_ruid);
#line 2644
              tmp___83 = setuid((__uid_t )new_ruid);
              }
#line 2644
              if (tmp___83 < 0) {
#line 2644
                if (suidwarn) {
                  {
#line 2646
                  syserr("openmailer: setuid(%ld) failed", (long )new_ruid);
#line 2648
                  exit(75);
                  }
                }
              }
            }
#line 2652
            if ((int )tTdvect[11] >= 2) {
              {
#line 2653
              tmp___84 = getegid();
#line 2653
              tmp___85 = getgid();
#line 2653
              tmp___86 = geteuid();
#line 2653
              tmp___87 = getuid();
#line 2653
              sm_dprintf((char *)"openmailer: running as r/euid=%d/%d, r/egid=%d/%d\n",
                         (int )tmp___87, (int )tmp___86, (int )tmp___85, (int )tmp___84);
              }
            }
#line 2658
            if ((unsigned long )m->m_execdir != (unsigned long )((void *)0)) {
#line 2662
              p = m->m_execdir;
              {
#line 2662
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 2662
                if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 2662
                  goto while_break___9;
                }
                {
#line 2664
                q = strchr((char const   *)p, ':');
                }
#line 2665
                if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 2666
                  *q = (char )'\000';
                }
                {
#line 2667
                expand(p, cbuf, (size_t )sizeof(cbuf), e);
                }
#line 2668
                if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 2669
                  tmp___88 = q;
#line 2669
                  q ++;
#line 2669
                  *tmp___88 = (char )':';
                }
#line 2670
                if ((int )tTdvect[11] >= 20) {
                  {
#line 2671
                  sm_dprintf((char *)"openmailer: trydir %s\n", cbuf);
                  }
                }
#line 2673
                if ((int )cbuf[0] != 0) {
                  {
#line 2673
                  tmp___89 = chdir((char const   *)(cbuf));
                  }
#line 2673
                  if (tmp___89 >= 0) {
#line 2675
                    goto while_break___9;
                  }
                }
#line 2662
                p = q;
              }
              while_break___9: /* CIL Label */ ;
              }
            }
#line 2680
            sff = 262148;
#line 2681
            if (! (DontBlameSendmail[29UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 29UL % (8UL * sizeof(int ))))) {
#line 2683
              sff = (int )((long )sff | 6144L);
            }
#line 2684
            if (DontBlameSendmail[28UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 28UL % (8UL * sizeof(int )))) {
#line 2686
              sff = (int )((long )sff | 16L);
            } else {
#line 2688
              sff = (int )((long )sff | 256L);
            }
            {
#line 2689
            tmp___90 = getgid();
#line 2689
            tmp___91 = getuid();
#line 2689
            ret = safefile(m->m_mailer, tmp___91, tmp___90, user___0, (long )sff,
                           0, (struct stat *)((void *)0));
            }
#line 2691
            if (ret != 0) {
              {
#line 2692
              tmp___92 = sm_errstring(ret);
#line 2692
              sm_syslog(6, (char const   *)e->e_id, "Warning: program %s unsafe: %s",
                        m->m_mailer, tmp___92);
              }
            }
            {
#line 2697
            close(rpvect[0]);
#line 2698
            tmp___94 = dup2(rpvect[1], 1);
            }
#line 2698
            if (tmp___94 < 0) {
              {
#line 2700
              tmp___93 = shortenstring((char const   *)e->e_to, (size_t )203);
#line 2700
              syserr("%s... openmailer(%s): cannot dup pipe %d for stdout", tmp___93,
                     m->m_name, rpvect[1]);
#line 2703
              _exit(71);
              }
            }
            {
#line 2705
            close(rpvect[1]);
#line 2707
            tmp___96 = dup2(1, 2);
            }
#line 2707
            if (tmp___96 < 0) {
              {
#line 2709
              tmp___95 = shortenstring((char const   *)e->e_to, (size_t )203);
#line 2709
              syserr("%s... openmailer(%s): cannot dup stdout for stderr", tmp___95,
                     m->m_name);
#line 2712
              _exit(71);
              }
            }
            {
#line 2716
            close(mpvect[1]);
#line 2717
            tmp___98 = dup2(mpvect[0], 0);
            }
#line 2717
            if (tmp___98 < 0) {
              {
#line 2719
              tmp___97 = shortenstring((char const   *)e->e_to, (size_t )203);
#line 2719
              syserr("%s... openmailer(%s): cannot dup pipe %d for stdin", tmp___97,
                     m->m_name, mpvect[0]);
#line 2722
              _exit(71);
              }
            }
            {
#line 2724
            close(mpvect[0]);
#line 2727
            sm_close_on_exec(3, DtableSize);
#line 2731
            setsid();
#line 2735
            execve((char const   *)m->m_mailer, (char * const  *)(pv), (char * const  *)(UserEnviron));
#line 2737
            tmp___99 = __errno_location();
#line 2737
            save_errno = *tmp___99;
#line 2738
            syserr("Cannot exec %s", m->m_mailer);
            }
#line 2739
            if (m->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int )))) {
              {
#line 2741
              _exit(71);
              }
            } else {
              {
#line 2739
              tmp___100 = transienterror(save_errno);
              }
#line 2739
              if (tmp___100) {
                {
#line 2741
                _exit(71);
                }
              }
            }
            {
#line 2742
            _exit(69);
            }
          }
#line 2749
          if ((unsigned long )mci == (unsigned long )((void *)0)) {
#line 2751
            if (clever) {
              {
#line 2759
              tmp___101 = mci_new((SM_RPOOL_T *)((void *)0));
#line 2759
              mci = (struct mailer_con_info */* volatile  */)tmp___101;
              }
            } else {
              {
#line 2768
              tmp___102 = mci_new(e->e_rpool);
#line 2768
              mci = (struct mailer_con_info */* volatile  */)tmp___102;
              }
            }
          }
#line 2771
          mci->mci_mailer = m;
#line 2772
          if (clever) {
            {
#line 2774
            mci->mci_state = (short)1;
#line 2775
            mci_cache((struct mailer_con_info *)mci);
            }
          } else {
#line 2779
            mci->mci_state = (short)2;
          }
          {
#line 2781
          mci->mci_pid = (pid_t )pid;
#line 2782
          close(mpvect[0]);
#line 2783
          mci->mci_out = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2,
                                    (void const   *)((void *)(& mpvect[1])), 3, (void const   *)((void *)0));
          }
#line 2786
          if ((unsigned long )mci->mci_out == (unsigned long )((void *)0)) {
            {
#line 2788
            syserr("deliver: cannot create mailer output channel, fd=%d", mpvect[1]);
#line 2790
            close(mpvect[1]);
#line 2791
            close(rpvect[0]);
#line 2792
            close(rpvect[1]);
#line 2793
            rcode = 71;
            }
#line 2794
            goto give_up;
          }
          {
#line 2797
          close(rpvect[1]);
#line 2798
          mci->mci_in = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& rpvect[0])),
                                   2, (void const   *)((void *)0));
          }
#line 2801
          if ((unsigned long )mci->mci_in == (unsigned long )((void *)0)) {
            {
#line 2803
            syserr("deliver: cannot create mailer input channel, fd=%d", mpvect[1]);
#line 2805
            close(rpvect[0]);
#line 2806
            sm_io_close(mci->mci_out, -2);
#line 2807
            mci->mci_out = (SM_FILE_T *)((void *)0);
#line 2808
            rcode = 71;
            }
#line 2809
            goto give_up;
          }
        }
      }
#line 2817
      if (m->m_flags[55UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 55UL % (8UL * sizeof(int )))) {
#line 2817
        if (! clever) {
#line 2819
          mci->mci_flags |= 128UL;
        } else
#line 2817
        if ((int )mci->mci_state == 1) {
#line 2819
          mci->mci_flags |= 128UL;
        }
      }
#line 2820
      if (clever) {
#line 2820
        if ((int )mci->mci_state != 0) {
          {
#line 2896
          e->e_mci = (struct mailer_con_info *)mci;
#line 2900
          smtpinit(m, (struct mailer_con_info *)mci, e, (mci->mci_flags & 268435456UL) != 0UL);
#line 2901
          mci->mci_flags &= 0xffffffffefffffffUL;
          }
#line 2903
          if ((e->e_dlvr_flag & 2) != 0) {
#line 2910
            if (! ((mci->mci_flags & 4194304UL) != 0UL)) {
              {
#line 2912
              e->e_status = (char *)"5.4.7";
#line 2913
              usrerrenh(e->e_status, "554 Server does not support Deliver By");
#line 2915
              rcode = 69;
              }
#line 2916
              goto give_up;
            }
#line 2918
            if (e->e_deliver_by > 0L) {
              {
#line 2918
              tmp___106 = curtime();
              }
#line 2918
              if (e->e_deliver_by - (tmp___106 - e->e_ctime) < mci->mci_min_by) {
                {
#line 2922
                e->e_status = (char *)"5.4.7";
#line 2923
                tmp___105 = curtime();
#line 2923
                usrerrenh(e->e_status, "554 Message can\'t be delivered in time; %ld < %ld",
                          e->e_deliver_by - (tmp___105 - e->e_ctime), mci->mci_min_by);
#line 2927
                rcode = 69;
                }
#line 2928
                goto give_up;
              }
            }
          }
        }
      }
      do_transfer: 
#line 3180
      mci->mci_flags &= 0xffffffffffffdbffUL;
#line 3182
      if ((e->e_flags & 131072UL) != 0UL) {
#line 3182
        if (! ((e->e_flags & 8388608UL) != 0UL)) {
#line 3182
          if (m->m_flags[55UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 55UL % (8UL * sizeof(int )))) {
#line 3185
            mci->mci_flags |= 1024UL;
          }
        }
      }
#line 3188
      if (m->m_flags[57UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 57UL % (8UL * sizeof(int )))) {
#line 3188
        if (! ((mci->mci_flags & 128UL) != 0UL)) {
          {
#line 3188
          p = hvalue((char *)"Content-Transfer-Encoding", e->e_header);
          }
#line 3188
          if ((unsigned long )p != (unsigned long )((void *)0)) {
            {
#line 3188
            tmp___108 = sm_strcasecmp((char const   *)p, "quoted-printable");
            }
#line 3188
            if (tmp___108 == 0) {
#line 3188
              goto _L___6;
            } else {
              {
#line 3188
              tmp___109 = sm_strcasecmp((char const   *)p, "base64");
              }
#line 3188
              if (tmp___109 == 0) {
                _L___6: /* CIL Label */ 
                {
#line 3188
                p = hvalue((char *)"Content-Type", e->e_header);
                }
#line 3188
                if ((unsigned long )p != (unsigned long )((void *)0)) {
                  {
#line 3197
                  tmp___107 = sm_strncasecmp((char const   *)p, "text/plain", (size_t )10);
                  }
#line 3197
                  if (tmp___107 == 0) {
#line 3197
                    if ((int )*(p + 10) == 0) {
#line 3199
                      mci->mci_flags |= 8192UL;
                    } else
#line 3197
                    if ((int )*(p + 10) == 32) {
#line 3199
                      mci->mci_flags |= 8192UL;
                    } else
#line 3197
                    if ((int )*(p + 10) == 59) {
#line 3199
                      mci->mci_flags |= 8192UL;
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 3203
      if ((int )tTdvect[11] >= 1) {
        {
#line 3205
        sm_dprintf((char *)"openmailer: ");
#line 3206
        tmp___110 = sm_debug_file();
#line 3206
        mci_dump(tmp___110, (struct mailer_con_info *)mci, 0);
        }
      }
#line 3240
      if ((int )mci->mci_state != 2) {
        {
#line 3243
        rcode = (int )mci->mci_exitstat;
#line 3244
        tmp___111 = __errno_location();
#line 3244
        *tmp___111 = (int )mci->mci_errno;
#line 3245
        tmp___112 = __h_errno_location();
#line 3245
        *tmp___112 = (int )mci->mci_herrno;
        }
#line 3246
        if (rcode == 0) {
          {
#line 3249
          tmp___113 = __errno_location();
#line 3249
          syserr("554 5.3.5 deliver: mci=%lx rcode=%d errno=%d state=%d sig=%s", (unsigned long )mci,
                 rcode, *tmp___113, (int )mci->mci_state, firstsig);
#line 3252
          mci_dump_all(& SmIoF[1], 1);
#line 3253
          rcode = 70;
          }
        } else
#line 3255
        if (nummxhosts > hostnum) {
#line 3258
          goto tryhost;
        }
      } else
#line 3261
      if (! clever) {
        {
#line 3269
        rcode = 0;
#line 3270
        tmp___114 = __errno_location();
#line 3270
        *tmp___114 = 0;
#line 3271
        ok = putfromline((struct mailer_con_info *)mci, e);
        }
#line 3272
        if (ok) {
          {
#line 3273
          ok = (*(e->e_puthdr))((struct mailer_con_info *)mci, e->e_header, e, 0);
          }
        }
#line 3274
        if (ok) {
          {
#line 3275
          ok = (*(e->e_putbody))((struct mailer_con_info *)mci, e, (char *)((void *)0));
          }
        }
#line 3283
        if (! ok) {
#line 3283
          if (((mci->mci_out)->f_flags & 256L) != 0L) {
            {
#line 3283
            tmp___115 = __errno_location();
            }
#line 3283
            if (*tmp___115 == 32) {
#line 3284
              ok = 1;
            }
          }
        }
        {
#line 3287
        rcode = endmailer((struct mailer_con_info *)mci, e, pv);
        }
#line 3288
        if (! ok) {
#line 3289
          rcode = 75;
        }
#line 3290
        if (rcode == 75) {
#line 3290
          if ((int )SmtpError[0] == 0) {
            {
#line 3297
            sm_snprintf(SmtpError, (size_t )sizeof(SmtpError), "%s mailer (%s) exited with EX_TEMPFAIL",
                        m->m_name, m->m_mailer);
            }
          }
        }
      } else {
        {
#line 3309
        rcode = smtpmailfrom(m, (struct mailer_con_info *)mci, e);
        }
#line 3310
        if (rcode == 0) {
#line 3318
          *(tobuf + 0) = (char )'\000';
#line 3319
          mci->mci_retryrcpt = 0;
#line 3320
          mci->mci_tolist = tobuf;
#line 3322
          pchain = (ADDRESS */* volatile  */)((void *)0);
#line 3323
          mci->mci_nextaddr = (ADDRESS *)((void *)0);
#line 3326
          to = (ADDRESS *)tochain;
          {
#line 3326
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 3326
            if (! ((unsigned long )to != (unsigned long )((void *)0))) {
#line 3326
              goto while_break___10;
            }
#line 3328
            if (! ((int )to->q_state == 0)) {
#line 3328
              if (! ((int )to->q_state == 4)) {
#line 3329
                goto __Cont___0;
              }
            }
            {
#line 3332
            to->q_state = (short)0;
#line 3333
            e->e_to = to->q_paddr;
#line 3352
            i___1 = smtprcpt(to, m, (struct mailer_con_info *)mci, e, (ADDRESS *)ctladdr,
                             xstart);
            }
#line 3354
            if (i___1 == 0) {
#line 3354
              if ((mci->mci_flags & 262144UL) != 0UL) {
#line 3362
                to->q_pchain = (struct address *)((void *)0);
#line 3363
                if ((unsigned long )mci->mci_nextaddr == (unsigned long )((void *)0)) {
#line 3364
                  mci->mci_nextaddr = to;
                }
#line 3365
                if ((unsigned long )pchain == (unsigned long )((void *)0)) {
#line 3366
                  pchain = (ADDRESS */* volatile  */)to;
                } else {
#line 3369
                  pchain->q_pchain = to;
#line 3370
                  pchain = (ADDRESS */* volatile  */)pchain->q_pchain;
                }
              }
            }
#line 3374
            if (i___1 != 0) {
              {
#line 3376
              markfailure(e, to, (struct mailer_con_info *)mci, i___1, 0);
#line 3377
              giveresponse(i___1, to->q_status, m, (struct mailer_con_info *)mci,
                           (ADDRESS *)ctladdr, xstart, e, to);
              }
#line 3379
              if (i___1 == 75) {
#line 3380
                to->q_state = (short)4;
              }
            }
            __Cont___0: /* CIL Label */ 
#line 3326
            to = to->q_tchain;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 3385
          if ((int )*(tobuf + 0) == 0) {
#line 3385
            if ((unsigned long )mci->mci_nextaddr == (unsigned long )((void *)0)) {
#line 3391
              rcode = 0;
#line 3392
              e->e_to = (char *)((void *)0);
#line 3393
              if ((mci->mci_flags & 4UL) != 0UL) {
                {
#line 3394
                smtprset(m, (struct mailer_con_info *)mci, e);
                }
              }
            } else {
              {
#line 3398
              e->e_to = tobuf + 1;
#line 3399
              rcode = smtpdata(m, (struct mailer_con_info *)mci, e, (ADDRESS *)ctladdr,
                               xstart);
              }
            }
          } else {
            {
#line 3398
            e->e_to = tobuf + 1;
#line 3399
            rcode = smtpdata(m, (struct mailer_con_info *)mci, e, (ADDRESS *)ctladdr,
                             xstart);
            }
          }
        }
#line 3402
        if (rcode == 75) {
#line 3402
          if (nummxhosts > hostnum) {
#line 3405
            goto tryhost;
          }
        }
      }
#line 3409
      if (ConfigLevel < 2) {
        {
#line 3410
        tmp___116 = __res_state();
#line 3410
        tmp___116->options |= 640UL;
        }
      }
#line 3413
      if ((int )tTdvect[62] >= 1) {
        {
#line 3414
        checkfds((char *)"after delivery");
        }
      }
      give_up: 
#line 3424
      if (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int )))) {
#line 3426
        lmtp_rcode = rcode;
#line 3427
        *(tobuf + 0) = (char )'\000';
#line 3428
        anyok = 0;
#line 3429
        strsize = 0;
      } else {
#line 3432
        anyok = rcode == 0;
      }
#line 3434
      to = (ADDRESS *)tochain;
      {
#line 3434
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 3434
        if (! ((unsigned long )to != (unsigned long )((void *)0))) {
#line 3434
          goto while_break___11;
        }
#line 3437
        if (! ((int )to->q_state == 0)) {
#line 3438
          goto __Cont___1;
        }
#line 3441
        if (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int )))) {
#line 3443
          if (lmtp_rcode == 0) {
            {
#line 3444
            rcode = smtpgetstat(m, (struct mailer_con_info *)mci, e);
            }
          }
#line 3445
          if (rcode == 0) {
            {
#line 3447
            tmp___117 = sm_strlcat2(tobuf + strsize, ",", (char const   *)to->q_paddr,
                                    tobufsize - strsize);
#line 3447
            strsize = (int )((size_t )strsize + tmp___117);
            }
#line 3450
            if (strsize < tobufsize) {
#line 3450
              tmp___118 = 1;
            } else {
              {
#line 3450
              sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                          3450, "SM_ASSERT(strsize < tobufsize) failed");
#line 3450
              tmp___118 = 0;
              }
            }
#line 3451
            anyok = 1;
          } else {
            {
#line 3455
            e->e_to = to->q_paddr;
#line 3456
            markfailure(e, to, (struct mailer_con_info *)mci, rcode, 1);
#line 3457
            giveresponse(rcode, to->q_status, m, (struct mailer_con_info *)mci, (ADDRESS *)ctladdr,
                         xstart, e, to);
#line 3459
            e->e_to = tobuf + 1;
            }
#line 3460
            goto __Cont___1;
          }
        } else
#line 3466
        if (rcode != 0) {
#line 3468
          if (goodmxfound) {
#line 3468
            if (rcode == 68) {
#line 3469
              rcode = 75;
            }
          }
          {
#line 3470
          markfailure(e, to, (struct mailer_con_info *)mci, rcode, 1);
          }
#line 3471
          goto __Cont___1;
        }
        {
#line 3476
        to->q_state = (short)1;
#line 3477
        to->q_statdate = curtime();
#line 3478
        e->e_nsent = (short )((int )e->e_nsent + 1);
        }
#line 3484
        if (CheckpointInterval > 0) {
#line 3484
          if ((int )e->e_nsent >= CheckpointInterval) {
            {
#line 3486
            queueup(e, 0, 0);
#line 3487
            e->e_nsent = (short)0;
            }
          }
        }
#line 3490
        if (m->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int )))) {
#line 3490
          if ((to->q_flags & 64UL) != 0UL) {
            {
#line 3493
            to->q_flags |= 4096UL;
#line 3494
            to->q_status = (char *)"2.1.5";
#line 3495
            sm_io_fprintf(e->e_xfp, -2, "%s... Successfully delivered\n", to->q_paddr);
            }
          } else {
#line 3490
            goto _L___13;
          }
        } else
        _L___13: /* CIL Label */ 
#line 3499
        if ((to->q_flags & 64UL) != 0UL) {
#line 3499
          if ((to->q_flags & 2UL) != 0UL) {
#line 3499
            if (! ((mci->mci_flags & 2048UL) != 0UL)) {
              {
#line 3503
              to->q_flags |= 1024UL;
#line 3504
              sm_io_fprintf(e->e_xfp, -2, "%s... relayed; expect no further notifications\n",
                            to->q_paddr);
              }
            } else {
#line 3499
              goto _L___12;
            }
          } else {
#line 3499
            goto _L___12;
          }
        } else
        _L___12: /* CIL Label */ 
#line 3508
        if ((e->e_dlvr_flag & 1) != 0) {
#line 3508
          if (! ((mci->mci_flags & 4194304UL) != 0UL)) {
#line 3508
            if ((to->q_flags & 2UL) != 0UL) {
#line 3508
              if (! ((to->q_flags & 512UL) != 0UL)) {
                {
#line 3517
                to->q_flags |= 131072UL;
#line 3518
                sm_io_fprintf(e->e_xfp, -2, "%s... Deliver-by notify: relayed\n",
                              to->q_paddr);
                }
              } else
#line 3508
              if ((to->q_flags & 64UL) != 0UL) {
                {
#line 3517
                to->q_flags |= 131072UL;
#line 3518
                sm_io_fprintf(e->e_xfp, -2, "%s... Deliver-by notify: relayed\n",
                              to->q_paddr);
                }
              } else
#line 3508
              if ((to->q_flags & 128UL) != 0UL) {
                {
#line 3517
                to->q_flags |= 131072UL;
#line 3518
                sm_io_fprintf(e->e_xfp, -2, "%s... Deliver-by notify: relayed\n",
                              to->q_paddr);
                }
              } else
#line 3508
              if ((to->q_flags & 256UL) != 0UL) {
                {
#line 3517
                to->q_flags |= 131072UL;
#line 3518
                sm_io_fprintf(e->e_xfp, -2, "%s... Deliver-by notify: relayed\n",
                              to->q_paddr);
                }
              } else {
#line 3508
                goto _L___10;
              }
            } else {
#line 3508
              goto _L___10;
            }
          } else {
#line 3508
            goto _L___10;
          }
        } else
        _L___10: /* CIL Label */ 
#line 3522
        if ((e->e_dlvr_flag & 16) != 0) {
#line 3522
          if (! ((to->q_flags & 512UL) != 0UL)) {
#line 3522
            goto _L___7;
          } else
#line 3522
          if ((to->q_flags & 64UL) != 0UL) {
#line 3522
            goto _L___7;
          } else
#line 3522
          if ((to->q_flags & 128UL) != 0UL) {
#line 3522
            goto _L___7;
          } else
#line 3522
          if ((to->q_flags & 256UL) != 0UL) {
            _L___7: /* CIL Label */ 
#line 3522
            if ((to->q_flags & 2UL) != 0UL) {
              {
#line 3530
              to->q_flags |= 32768UL;
#line 3531
              sm_io_fprintf(e->e_xfp, -2, "%s... Deliver-By trace: relayed\n", to->q_paddr);
              }
            }
          }
        }
        __Cont___1: /* CIL Label */ 
#line 3434
        to = to->q_tchain;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 3537
      if (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int )))) {
#line 3544
        rcode = 0;
#line 3545
        e->e_statmsg = (char *)((void *)0);
#line 3548
        if ((unsigned long )mci != (unsigned long )((void *)0)) {
#line 3548
          if ((int )mci->mci_state == 3) {
            {
#line 3553
            mci->mci_state = (short)2;
#line 3554
            tmp___119 = (char *)"idle";
#line 3554
            mci->mci_phase = tmp___119;
#line 3554
            SmtpPhase = tmp___119;
#line 3555
            sm_setproctitle(1, e, "%s: %s", CurHostName, mci->mci_phase);
            }
          } else
#line 3548
          if ((int )mci->mci_state == 4) {
            {
#line 3553
            mci->mci_state = (short)2;
#line 3554
            tmp___119 = (char *)"idle";
#line 3554
            mci->mci_phase = tmp___119;
#line 3554
            SmtpPhase = tmp___119;
#line 3555
            sm_setproctitle(1, e, "%s: %s", CurHostName, mci->mci_phase);
            }
          } else
#line 3548
          if ((int )mci->mci_state == 5) {
            {
#line 3553
            mci->mci_state = (short)2;
#line 3554
            tmp___119 = (char *)"idle";
#line 3554
            mci->mci_phase = tmp___119;
#line 3554
            SmtpPhase = tmp___119;
#line 3555
            sm_setproctitle(1, e, "%s: %s", CurHostName, mci->mci_phase);
            }
          }
        }
      }
#line 3560
      if ((int )*(tobuf + 0) != 0) {
        {
#line 3562
        giveresponse(rcode, (char *)((void *)0), m, (struct mailer_con_info *)mci,
                     (ADDRESS *)ctladdr, xstart, e, (ADDRESS *)tochain);
        }
      }
#line 3585
      if (anyok) {
        {
#line 3586
        markstats(e, (ADDRESS *)tochain, 'n');
        }
      }
      {
#line 3587
      mci_store_persistent((struct mailer_con_info *)mci);
      }
#line 3590
      if ((unsigned long )mci != (unsigned long )((void *)0)) {
#line 3590
        if (mci->mci_retryrcpt) {
#line 3590
          if (nummxhosts > hostnum) {
#line 3593
            goto tryhost;
          }
        }
      }
#line 3597
      if (clever) {
#line 3597
        if ((unsigned long )mci != (unsigned long )((void *)0)) {
#line 3597
          if ((int )mci->mci_state != 0) {
#line 3597
            if (! ((mci->mci_flags & 4UL) != 0UL)) {
              {
#line 3599
              smtpquit(m, (struct mailer_con_info *)mci, e);
              }
            }
          }
        }
      }
      cleanup: ;
#line 3603
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 3603
        tmp___120 = 1;
      } else {
        {
#line 3603
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                    3603, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 3603
        tmp___120 = 0;
        }
      }
    }
    {
#line 3603
    tmp___125 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 3603
    if (tmp___125 == 0) {
#line 3612
      if ((unsigned long )e->e_to == (unsigned long )((void *)0)) {
#line 3612
        tmp___123 = "NO-TO-LIST";
      } else {
        {
#line 3612
        tmp___122 = shortenstring((char const   *)e->e_to, (size_t )203);
#line 3612
        tmp___123 = (char const   *)tmp___122;
        }
      }
      {
#line 3612
      sm_snprintf(wbuf___0, (size_t )sizeof(wbuf___0), "%s... end of deliver(%s)",
                  tmp___123, m->m_name);
#line 3618
      checkfd012(wbuf___0);
#line 3621
      tmp___124 = __errno_location();
#line 3621
      *tmp___124 = 0;
#line 3629
      macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'g', (char *)((void *)0), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                       3629, SmHeapGroup);
#line 3630
      e->e_to = (char *)((void *)0);
      }
    }
#line 1368
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3632
  if (_h.eh_state == 2) {
#line 3632
    if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 3632
      tmp___126 = 1;
    } else {
      {
#line 3632
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                  3632, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 3632
      tmp___126 = 0;
      }
    }
#line 3632
    SmExcHandler = _h.eh_parent;
#line 3632
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 3632
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else
#line 3632
  if (_h.eh_state == 0) {
#line 3632
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 3632
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else {
    {
#line 3632
    sm_exc_free(_h.eh_value);
    }
  }
#line 3633
  return (rcode);
}
}
#line 3655 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
void markfailure(ENVELOPE *e , ADDRESS *q , struct mailer_con_info *mci , int rcode ,
                 bool ovr ) 
{ 
  int save_errno ;
  int *tmp ;
  char *status ;
  char *rstatus ;
  char buf___16[16] ;
  int tmp___0 ;
  int *tmp___1 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 3663
  tmp = __errno_location();
#line 3663
  save_errno = *tmp;
#line 3664
  status = (char *)((void *)0);
#line 3665
  rstatus = (char *)((void *)0);
  }
  {
#line 3669
  if (rcode == 0) {
#line 3669
    goto case_0;
  }
#line 3674
  if (rcode == 71) {
#line 3674
    goto case_71;
  }
#line 3674
  if (rcode == 74) {
#line 3674
    goto case_71;
  }
#line 3674
  if (rcode == 75) {
#line 3674
    goto case_71;
  }
#line 3678
  goto switch_default;
  case_0: /* CIL Label */ 
#line 3670
  goto switch_break;
  case_71: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_75: /* CIL Label */ 
#line 3675
  q->q_state = (short)3;
#line 3676
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3679
  q->q_state = (short)2;
#line 3680
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3684
  if ((unsigned long )mci != (unsigned long )((void *)0)) {
#line 3684
    if ((unsigned long )mci->mci_status != (unsigned long )((void *)0)) {
      {
#line 3686
      status = sm_rpool_strdup_x(e->e_rpool, (char const   *)mci->mci_status);
      }
#line 3687
      if ((unsigned long )mci->mci_rstatus != (unsigned long )((void *)0)) {
        {
#line 3688
        rstatus = sm_rpool_strdup_x(e->e_rpool, (char const   *)mci->mci_rstatus);
        }
      } else {
#line 3691
        rstatus = (char *)((void *)0);
      }
    } else {
#line 3684
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3693
  if ((unsigned long )e->e_status != (unsigned long )((void *)0)) {
#line 3695
    status = e->e_status;
#line 3696
    rstatus = (char *)((void *)0);
  } else {
    {
#line 3702
    if (rcode == 64) {
#line 3702
      goto case_64;
    }
#line 3706
    if (rcode == 65) {
#line 3706
      goto case_65;
    }
#line 3710
    if (rcode == 67) {
#line 3710
      goto case_67;
    }
#line 3714
    if (rcode == 68) {
#line 3714
      goto case_68;
    }
#line 3720
    if (rcode == 77) {
#line 3720
      goto case_77;
    }
#line 3720
    if (rcode == 73) {
#line 3720
      goto case_77;
    }
#line 3720
    if (rcode == 66) {
#line 3720
      goto case_77;
    }
#line 3728
    if (rcode == 78) {
#line 3728
      goto case_78;
    }
#line 3728
    if (rcode == 76) {
#line 3728
      goto case_78;
    }
#line 3728
    if (rcode == 72) {
#line 3728
      goto case_78;
    }
#line 3728
    if (rcode == 70) {
#line 3728
      goto case_78;
    }
#line 3728
    if (rcode == 69) {
#line 3728
      goto case_78;
    }
#line 3733
    if (rcode == 74) {
#line 3733
      goto case_74___0;
    }
#line 3733
    if (rcode == 71) {
#line 3733
      goto case_74___0;
    }
#line 3737
    if (rcode == 75) {
#line 3737
      goto case_75___0;
    }
#line 3700
    goto switch_break___0;
    case_64: /* CIL Label */ 
#line 3703
    status = (char *)"5.5.4";
#line 3704
    goto switch_break___0;
    case_65: /* CIL Label */ 
#line 3707
    status = (char *)"5.5.2";
#line 3708
    goto switch_break___0;
    case_67: /* CIL Label */ 
#line 3711
    status = (char *)"5.1.1";
#line 3712
    goto switch_break___0;
    case_68: /* CIL Label */ 
#line 3715
    status = (char *)"5.1.2";
#line 3716
    goto switch_break___0;
    case_77: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_66: /* CIL Label */ 
#line 3721
    status = (char *)"5.3.0";
#line 3722
    goto switch_break___0;
    case_78: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 3729
    status = (char *)"5.5.0";
#line 3730
    goto switch_break___0;
    case_74___0: /* CIL Label */ 
    case_71___0: /* CIL Label */ 
#line 3734
    status = (char *)"4.5.0";
#line 3735
    goto switch_break___0;
    case_75___0: /* CIL Label */ 
#line 3738
    status = (char *)"4.2.0";
#line 3739
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 3744
  if ((unsigned long )status != (unsigned long )((void *)0)) {
#line 3744
    if ((int )*status != 0) {
#line 3744
      if (ovr) {
#line 3747
        q->q_status = status;
#line 3748
        q->q_rstatus = rstatus;
      } else
#line 3744
      if ((unsigned long )q->q_status == (unsigned long )((void *)0)) {
#line 3747
        q->q_status = status;
#line 3748
        q->q_rstatus = rstatus;
      } else
#line 3744
      if ((int )*(q->q_status) == 0) {
#line 3747
        q->q_status = status;
#line 3748
        q->q_rstatus = rstatus;
      } else
#line 3744
      if ((int )*(q->q_status) < (int )*status) {
#line 3747
        q->q_status = status;
#line 3748
        q->q_rstatus = rstatus;
      }
    }
  }
#line 3750
  if (rcode != 0) {
#line 3750
    if ((unsigned long )q->q_rstatus == (unsigned long )((void *)0)) {
#line 3750
      if ((unsigned long )q->q_mailer != (unsigned long )((void *)0)) {
#line 3750
        if ((unsigned long )(q->q_mailer)->m_diagtype != (unsigned long )((void *)0)) {
          {
#line 3750
          tmp___0 = sm_strcasecmp((char const   *)(q->q_mailer)->m_diagtype, "X-UNIX");
          }
#line 3750
          if (tmp___0 == 0) {
            {
#line 3756
            sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%d", rcode);
#line 3757
            q->q_rstatus = sm_rpool_strdup_x(e->e_rpool, (char const   *)(buf___16));
            }
          }
        }
      }
    }
  }
  {
#line 3760
  q->q_statdate = curtime();
  }
#line 3761
  if ((unsigned long )CurHostName != (unsigned long )((void *)0)) {
#line 3761
    if ((int )*(CurHostName + 0) != 0) {
#line 3761
      if ((unsigned long )mci != (unsigned long )((void *)0)) {
#line 3761
        if (! ((mci->mci_flags & 108UL) != 0UL)) {
          {
#line 3763
          q->q_statmta = sm_rpool_strdup_x(e->e_rpool, (char const   *)CurHostName);
          }
        }
      }
    }
  }
  {
#line 3766
  tmp___1 = __errno_location();
#line 3766
  *tmp___1 = save_errno;
  }
#line 3767
  return;
}
}
#line 3789 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static sigjmp_buf EndWaitTimeout  ;
#line 3791 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static void endwaittimeout(int ignore ) 
{ 
  int *tmp ;

  {
  {
#line 3801
  tmp = __errno_location();
#line 3801
  *tmp = 110;
#line 3802
  siglongjmp((struct __jmp_buf_tag *)(EndWaitTimeout), 1);
  }
}
}
#line 3805 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
int endmailer(struct mailer_con_info *mci , ENVELOPE *e , char **pv ) 
{ 
  int st ;
  int save_errno ;
  int *tmp ;
  char buf___16[2048] ;
  SM_EVENT *ev ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  union __anonunion___u_65___0 __u ;
  union __anonunion___u_66___0 __u___0 ;
  char const   *tmp___5 ;
  union __anonunion___u_69 __u___3 ;
  char const   *tmp___6 ;
  union __anonunion___u_70 __u___4 ;
  union __anonunion___u_71 __u___5 ;
  register char **av___0 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 3812
  tmp = __errno_location();
#line 3812
  save_errno = *tmp;
#line 3814
  ev = (SM_EVENT *)((void *)0);
#line 3817
  mci_unlock_host(mci);
  }
#line 3820
  if ((unsigned long )mci->mci_out != (unsigned long )((void *)0)) {
    {
#line 3822
    sm_io_close(mci->mci_out, -2);
#line 3823
    mci->mci_out = (SM_FILE_T *)((void *)0);
    }
  }
#line 3827
  if ((unsigned long )mci->mci_in != (unsigned long )((void *)0)) {
#line 3827
    if ((int )mci->mci_state != 8) {
#line 3827
      if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
        {
#line 3830
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 3830
          tmp___0 = sfgets(buf___16, (int )sizeof(buf___16), mci->mci_in, TimeOuts.to_quit,
                           (char *)"Draining Input");
          }
#line 3830
          if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 3830
            goto while_break;
          }
          {
#line 3832
          sm_io_fputs(e->e_xfp, -2, (char const   *)(buf___16));
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 3850
  if ((unsigned long )mci->mci_in != (unsigned long )((void *)0)) {
    {
#line 3852
    sm_io_close(mci->mci_in, -2);
#line 3853
    mci->mci_in = (SM_FILE_T *)((void *)0);
    }
  }
  {
#line 3855
  mci->mci_state = (short)0;
#line 3857
  tmp___1 = __errno_location();
#line 3857
  *tmp___1 = save_errno;
  }
#line 3860
  if (mci->mci_pid == 0) {
#line 3861
    return (0);
  }
#line 3864
  if ((mci->mci_mailer)->m_wait > 0L) {
    {
#line 3866
    tmp___2 = __sigsetjmp((struct __jmp_buf_tag *)(EndWaitTimeout), 1);
    }
#line 3866
    if (tmp___2 == 0) {
      {
#line 3867
      ev = sm_seteventm((int )((mci->mci_mailer)->m_wait * 1000L), & endwaittimeout,
                        0);
      }
    } else {
      {
#line 3871
      syserr("endmailer %s: wait timeout (%ld)", (mci->mci_mailer)->m_name, (mci->mci_mailer)->m_wait);
      }
#line 3874
      return (75);
    }
  }
  {
#line 3879
  st = waitfor(mci->mci_pid);
#line 3880
  tmp___3 = __errno_location();
#line 3880
  save_errno = *tmp___3;
  }
#line 3881
  if ((unsigned long )ev != (unsigned long )((void *)0)) {
    {
#line 3882
    sm_clrevent(ev);
    }
  }
  {
#line 3883
  tmp___4 = __errno_location();
#line 3883
  *tmp___4 = save_errno;
  }
#line 3885
  if (st == -1) {
    {
#line 3887
    syserr("endmailer %s: wait", (mci->mci_mailer)->m_name);
    }
#line 3888
    return (70);
  }
#line 3891
  __u___0.__in = st;
#line 3891
  if ((__u___0.__i & 127) == 0) {
#line 3894
    __u.__in = st;
#line 3894
    return ((__u.__i & 65280) >> 8);
  }
#line 3900
  __u___4.__in = st;
#line 3900
  if (__u___4.__i & 128) {
#line 3901
    tmp___6 = " (core dumped)";
  } else {
#line 3901
    __u___3.__in = st;
#line 3901
    if ((__u___3.__i & 255) == 127) {
#line 3901
      tmp___5 = " (stopped)";
    } else {
#line 3901
      tmp___5 = "";
    }
#line 3901
    tmp___6 = tmp___5;
  }
  {
#line 3899
  __u___5.__in = st;
#line 3899
  syserr("451 4.3.0 mailer %s died with signal %d%s", (mci->mci_mailer)->m_name, __u___5.__i & 127,
         tmp___6);
  }
#line 3904
  if ((unsigned long )pv != (unsigned long )((void *)0)) {
#line 3904
    if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
      {
#line 3908
      sm_io_fprintf(e->e_xfp, -2, "Arguments:");
#line 3909
      av___0 = pv;
      }
      {
#line 3909
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3909
        if (! ((unsigned long )*av___0 != (unsigned long )((void *)0))) {
#line 3909
          goto while_break___0;
        }
        {
#line 3910
        sm_io_fprintf(e->e_xfp, -2, " %s", *av___0);
#line 3909
        av___0 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 3912
      sm_io_fprintf(e->e_xfp, -2, "\n");
      }
    }
  }
#line 3915
  ExitStat = 75;
#line 3916
  return (75);
}
}
#line 3944 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
void giveresponse(int status , char *dsn , MAILER *m , struct mailer_con_info *mci ,
                  ADDRESS *ctladdr , time_t xstart , ENVELOPE *e , ADDRESS *to ) 
{ 
  register char const   *statmsg ;
  int errnum ;
  int *tmp ;
  int off ;
  bool usestat ;
  char dsnbuf[10] ;
  char buf___16[2048] ;
  char *exmsg ;
  char *tmp___0 ;
  char *bp___3 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  size_t tmp___4 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  int *tmp___9 ;
  char mbuf___0[14] ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 3956
  tmp = __errno_location();
#line 3956
  errnum = *tmp;
#line 3957
  off = 4;
#line 3958
  usestat = 0;
  }
#line 3963
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 3964
    syserr("giveresponse: null envelope");
    }
  }
  {
#line 3970
  exmsg = sm_sysexmsg(status);
  }
#line 3971
  if (status == 0) {
#line 3973
    statmsg = "250 2.0.0 Sent";
#line 3974
    if ((unsigned long )e->e_statmsg != (unsigned long )((void *)0)) {
      {
#line 3976
      tmp___0 = shortenstring((char const   *)e->e_statmsg, (size_t )403);
#line 3976
      sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%s (%s)", statmsg, tmp___0);
#line 3979
      statmsg = (char const   *)(buf___16);
      }
    }
  } else
#line 3982
  if ((unsigned long )exmsg == (unsigned long )((void *)0)) {
    {
#line 3984
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "554 5.3.0 unknown mailer error %d",
                status);
#line 3987
    status = 69;
#line 3988
    statmsg = (char const   *)(buf___16);
#line 3989
    usestat = 1;
    }
  } else
#line 3991
  if (status == 75) {
    {
#line 3993
    bp___3 = buf___16;
#line 3995
    sm_strlcpy(bp___3, (char const   *)(exmsg + 1), (ssize_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)));
#line 3996
    tmp___1 = strlen((char const   *)bp___3);
#line 3996
    bp___3 += tmp___1;
#line 3998
    tmp___3 = __h_errno_location();
    }
#line 3998
    if (*tmp___3 == 2) {
      {
#line 3999
      tmp___2 = __h_errno_location();
#line 3999
      statmsg = sm_errstring(*tmp___2 + 276);
      }
    } else
#line 4003
    if (errnum != 0) {
      {
#line 4004
      statmsg = sm_errstring(errnum);
      }
    } else {
#line 4006
      statmsg = (char const   *)(SmtpError);
    }
#line 4008
    if ((unsigned long )statmsg != (unsigned long )((void *)0)) {
#line 4008
      if ((int const   )*(statmsg + 0) != 0) {
        {
#line 4028
        if (errnum == 113) {
#line 4028
          goto case_113;
        }
#line 4028
        if (errnum == 112) {
#line 4028
          goto case_113;
        }
#line 4028
        if (errnum == 103) {
#line 4028
          goto case_113;
        }
#line 4028
        if (errnum == 102) {
#line 4028
          goto case_113;
        }
#line 4028
        if (errnum == 101) {
#line 4028
          goto case_113;
        }
#line 4028
        if (errnum == 100) {
#line 4028
          goto case_113;
        }
#line 4010
        goto switch_break;
        case_113: /* CIL Label */ 
        case_112: /* CIL Label */ 
        case_103: /* CIL Label */ 
        case_102: /* CIL Label */ 
        case_101: /* CIL Label */ 
        case_100: /* CIL Label */ 
#line 4030
        if ((unsigned long )mci != (unsigned long )((void *)0)) {
#line 4030
          if ((unsigned long )mci->mci_host != (unsigned long )((void *)0)) {
            {
#line 4032
            sm_strlcpyn(bp___3, (ssize_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
                        2, ": ", mci->mci_host);
#line 4036
            tmp___4 = strlen((char const   *)bp___3);
#line 4036
            bp___3 += tmp___4;
            }
          }
        }
#line 4038
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 4040
        sm_strlcpyn(bp___3, (ssize_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
                    2, ": ", statmsg);
#line 4042
        usestat = 1;
        }
      }
    }
#line 4044
    statmsg = (char const   *)(buf___16);
  } else
#line 4047
  if (status == 68) {
    {
#line 4047
    tmp___9 = __h_errno_location();
    }
#line 4047
    if (*tmp___9 != 0) {
      {
#line 4049
      tmp___5 = __h_errno_location();
#line 4049
      statmsg = sm_errstring(*tmp___5 + 276);
#line 4050
      sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%s (%s)", exmsg + 1, statmsg);
#line 4052
      statmsg = (char const   *)(buf___16);
#line 4053
      usestat = 1;
      }
    } else {
#line 4047
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 4058
    statmsg = (char const   *)exmsg;
#line 4059
    tmp___8 = statmsg;
#line 4059
    statmsg ++;
#line 4059
    if ((int const   )*tmp___8 == 58) {
#line 4059
      if (errnum != 0) {
        {
#line 4061
        tmp___6 = sm_errstring(errnum);
#line 4061
        sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%s: %s", statmsg, tmp___6);
#line 4063
        statmsg = (char const   *)(buf___16);
#line 4064
        usestat = 1;
        }
      } else {
#line 4059
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 4066
    if (m->m_flags[122UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 122UL % (8UL * sizeof(int )))) {
#line 4066
      if ((unsigned long )e->e_statmsg != (unsigned long )((void *)0)) {
        {
#line 4068
        tmp___7 = shortenstring((char const   *)e->e_statmsg, (size_t )403);
#line 4068
        sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%s (%s)", statmsg, tmp___7);
#line 4070
        statmsg = (char const   *)(buf___16);
#line 4071
        usestat = 1;
        }
      }
    }
  }
#line 4079
  if (status == 0) {
#line 4079
    goto _L___1;
  } else
#line 4079
  if (status == 75) {
    _L___1: /* CIL Label */ 
    {
#line 4083
    off = isenhsc(statmsg + 4, ' ');
    }
#line 4083
    if (off > 0) {
#line 4085
      if ((unsigned long )dsn == (unsigned long )((void *)0)) {
        {
#line 4087
        sm_snprintf(dsnbuf, (size_t )sizeof(dsnbuf), "%.*s", off, statmsg + 4);
#line 4089
        dsn = dsnbuf;
        }
      }
#line 4091
      off += 5;
    } else {
#line 4095
      off = 4;
    }
    {
#line 4097
    message("%s", statmsg + off);
    }
#line 4098
    if (status == 75) {
#line 4098
      if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
        {
#line 4099
        sm_io_fprintf(e->e_xfp, -2, "%s\n", & MsgBuf[4]);
        }
      }
    }
  } else {
    {
#line 4106
    Errors ++;
#line 4107
    off = isenhsc(statmsg + 4, ' ');
    }
#line 4107
    if (off > 0) {
#line 4107
      if ((unsigned long )off < sizeof(mbuf___0) - 4UL) {
#line 4110
        if ((unsigned long )dsn == (unsigned long )((void *)0)) {
          {
#line 4112
          sm_snprintf(dsnbuf, (size_t )sizeof(dsnbuf), "%.*s", off, statmsg + 4);
#line 4114
          dsn = dsnbuf;
          }
        }
        {
#line 4116
        off += 5;
#line 4119
        sm_strlcpy(mbuf___0, statmsg, off);
#line 4120
        sm_strlcat(mbuf___0, " %s", (ssize_t )sizeof(mbuf___0));
        }
      } else {
        {
#line 4124
        dsnbuf[0] = (char )'\000';
#line 4125
        sm_snprintf(mbuf___0, (size_t )sizeof(mbuf___0), "%.3s %%s", statmsg);
#line 4127
        off = 4;
        }
      }
    } else {
      {
#line 4124
      dsnbuf[0] = (char )'\000';
#line 4125
      sm_snprintf(mbuf___0, (size_t )sizeof(mbuf___0), "%.3s %%s", statmsg);
#line 4127
      off = 4;
      }
    }
    {
#line 4129
    usrerr((char const   *)(mbuf___0), statmsg + off);
    }
  }
#line 4139
  if ((int )OpMode != 118) {
#line 4139
    if (! ((e->e_flags & 512UL) != 0UL)) {
#line 4139
      if (status == 75) {
#line 4139
        tmp___11 = 8;
      } else {
#line 4139
        if (status == 0) {
#line 4139
          tmp___10 = 7;
        } else {
#line 4139
          tmp___10 = 6;
        }
#line 4139
        tmp___11 = tmp___10;
      }
#line 4139
      if (LogLevel > tmp___11) {
        {
#line 4141
        logdelivery(m, mci, dsn, statmsg + off, ctladdr, xstart, e);
        }
      }
    }
  }
#line 4143
  if ((int )tTdvect[11] >= 2) {
#line 4144
    if ((unsigned long )e->e_message == (unsigned long )((void *)0)) {
#line 4144
      tmp___12 = "<NULL>";
    } else {
#line 4144
      tmp___12 = (char const   *)e->e_message;
    }
#line 4144
    if ((unsigned long )dsn == (unsigned long )((void *)0)) {
#line 4144
      tmp___13 = "<NULL>";
    } else {
#line 4144
      tmp___13 = (char const   *)dsn;
    }
    {
#line 4144
    sm_dprintf((char *)"giveresponse: status=%d, dsn=%s, e->e_message=%s, errnum=%d\n",
               status, tmp___13, tmp___12, errnum);
    }
  }
#line 4150
  if (status != 75) {
#line 4151
    if (ExitStat == 0) {
#line 4151
      ExitStat = status;
    } else
#line 4151
    if (ExitStat == 75) {
#line 4151
      ExitStat = status;
    }
  }
#line 4152
  if (status != 0) {
#line 4152
    if (status != 75) {
      {
#line 4153
      e->e_message = sm_rpool_strdup_x(e->e_rpool, statmsg + off);
      }
    } else
#line 4152
    if ((unsigned long )e->e_message == (unsigned long )((void *)0)) {
      {
#line 4153
      e->e_message = sm_rpool_strdup_x(e->e_rpool, statmsg + off);
      }
    }
  }
#line 4154
  if (status != 0) {
#line 4154
    if ((unsigned long )to != (unsigned long )((void *)0)) {
#line 4154
      if ((unsigned long )to->q_message == (unsigned long )((void *)0)) {
#line 4156
        if (! usestat) {
#line 4156
          if ((unsigned long )e->e_message != (unsigned long )((void *)0)) {
            {
#line 4157
            to->q_message = sm_rpool_strdup_x(e->e_rpool, (char const   *)e->e_message);
            }
          } else {
            {
#line 4160
            to->q_message = sm_rpool_strdup_x(e->e_rpool, statmsg + off);
            }
          }
        } else {
          {
#line 4160
          to->q_message = sm_rpool_strdup_x(e->e_rpool, statmsg + off);
          }
        }
      }
    }
  }
  {
#line 4163
  tmp___14 = __errno_location();
#line 4163
  *tmp___14 = 0;
#line 4164
  tmp___15 = __h_errno_location();
#line 4164
  *tmp___15 = 0;
  }
#line 4165
  return;
}
}
#line 4191 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
void logdelivery(MAILER *m , struct mailer_con_info *mci , char *dsn , char const   *status ,
                 ADDRESS *ctladdr , time_t xstart , ENVELOPE *e ) 
{ 
  register char *bp___3 ;
  register char *p ;
  int l ;
  time_t now ;
  time_t tmp ;
  char buf___16[1024] ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  register char *q ;
  size_t tmp___22 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 4204
  tmp = curtime();
#line 4204
  now = tmp;
#line 4209
  bp___3 = buf___16;
  }
#line 4210
  if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
    {
#line 4212
    tmp___0 = shortenstring((char const   *)ctladdr->q_paddr, (size_t )83);
#line 4212
    sm_strlcpyn(bp___3, (ssize_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
                2, ", ctladdr=", tmp___0);
#line 4214
    tmp___1 = strlen((char const   *)bp___3);
#line 4214
    bp___3 += tmp___1;
    }
#line 4215
    if ((ctladdr->q_flags & 1UL) != 0UL) {
      {
#line 4217
      sm_snprintf(bp___3, (size_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
                  " (%d/%d)", (int )ctladdr->q_uid, (int )ctladdr->q_gid);
#line 4220
      tmp___2 = strlen((char const   *)bp___3);
#line 4220
      bp___3 += tmp___2;
      }
    }
  }
  {
#line 4225
  tmp___3 = pintvl(now - e->e_ctime, 1);
#line 4225
  sm_strlcpyn(bp___3, (ssize_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
              2, ", delay=", tmp___3);
#line 4227
  tmp___4 = strlen((char const   *)bp___3);
#line 4227
  bp___3 += tmp___4;
  }
#line 4229
  if (xstart != 0L) {
    {
#line 4231
    tmp___5 = pintvl(now - xstart, 1);
#line 4231
    sm_strlcpyn(bp___3, (ssize_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
                2, ", xdelay=", tmp___5);
#line 4233
    tmp___6 = strlen((char const   *)bp___3);
#line 4233
    bp___3 += tmp___6;
    }
  }
#line 4237
  if ((unsigned long )m != (unsigned long )((void *)0)) {
    {
#line 4239
    sm_strlcpyn(bp___3, (ssize_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
                2, ", mailer=", m->m_name);
#line 4241
    tmp___7 = strlen((char const   *)bp___3);
#line 4241
    bp___3 += tmp___7;
    }
  }
  {
#line 4245
  sm_snprintf(bp___3, (size_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
              ", pri=%ld", e->e_msgpriority);
#line 4247
  tmp___8 = strlen((char const   *)bp___3);
#line 4247
  bp___3 += tmp___8;
  }
#line 4250
  if ((unsigned long )mci != (unsigned long )((void *)0)) {
#line 4250
    if ((unsigned long )mci->mci_host != (unsigned long )((void *)0)) {
      {
#line 4254
      tmp___9 = shortenstring((char const   *)mci->mci_host, (size_t )40);
#line 4254
      sm_strlcpyn(bp___3, (ssize_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
                  2, ", relay=", tmp___9);
#line 4256
      tmp___10 = strlen((char const   *)bp___3);
#line 4256
      bp___3 += tmp___10;
      }
#line 4258
      if ((int )CurHostAddr.sa.sa_family != 0) {
        {
#line 4260
        tmp___11 = anynet_ntoa(& CurHostAddr);
#line 4260
        sm_snprintf(bp___3, (size_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
                    " [%s]", tmp___11);
        }
      }
    } else {
#line 4250
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 4264
    tmp___15 = strcmp(status, "quarantined");
    }
#line 4264
    if (tmp___15 == 0) {
#line 4266
      if ((unsigned long )e->e_quarmsg != (unsigned long )((void *)0)) {
        {
#line 4267
        tmp___12 = shortenstring((char const   *)e->e_quarmsg, (size_t )40);
#line 4267
        sm_snprintf(bp___3, (size_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
                    ", quarantine=%s", tmp___12);
        }
      }
    } else {
      {
#line 4271
      tmp___14 = strcmp(status, "queued");
      }
#line 4271
      if (tmp___14 != 0) {
        {
#line 4273
        p = macvalue('h', e);
        }
#line 4274
        if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 4274
          if ((int )*(p + 0) != 0) {
            {
#line 4276
            tmp___13 = shortenstring((char const   *)p, (size_t )40);
#line 4276
            sm_snprintf(bp___3, (size_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
                        ", relay=%s", tmp___13);
            }
          }
        }
      }
    }
  }
  {
#line 4280
  tmp___16 = strlen((char const   *)bp___3);
#line 4280
  bp___3 += tmp___16;
  }
#line 4283
  if ((unsigned long )dsn != (unsigned long )((void *)0)) {
#line 4283
    if ((int )*dsn != 0) {
      {
#line 4285
      tmp___17 = shortenstring((char const   *)dsn, (size_t )10);
#line 4285
      sm_strlcpyn(bp___3, (ssize_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)),
                  2, ", dsn=", tmp___17);
#line 4287
      tmp___18 = strlen((char const   *)bp___3);
#line 4287
      bp___3 += tmp___18;
      }
    }
  }
#line 4311
  if ((unsigned long )(bp___3 - buf___16) > sizeof(buf___16) - 223UL) {
    {
#line 4314
    bp___3 = (buf___16 + sizeof(buf___16)) - 220;
#line 4315
    sm_strlcpy(bp___3, "...", (ssize_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)));
#line 4316
    bp___3 += 3;
    }
  }
  {
#line 4319
  sm_strlcpy(bp___3, ", stat=", (ssize_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)));
#line 4320
  tmp___19 = strlen((char const   *)bp___3);
#line 4320
  bp___3 += tmp___19;
#line 4322
  tmp___20 = shortenstring(status, (size_t )203);
#line 4322
  sm_strlcpy(bp___3, (char const   *)tmp___20, (ssize_t )(sizeof(buf___16) - (unsigned long )(bp___3 - buf___16)));
#line 4326
  tmp___21 = strlen((char const   *)(buf___16));
#line 4326
  l = (int )(924U - tmp___21);
  }
#line 4327
  if (l < 0) {
#line 4328
    l = 0;
  }
#line 4329
  if ((unsigned long )e->e_to == (unsigned long )((void *)0)) {
#line 4329
    p = (char *)"NO-TO-LIST";
  } else {
#line 4329
    p = e->e_to;
  }
  {
#line 4330
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4330
    tmp___22 = strlen((char const   *)p);
    }
#line 4330
    if (! (tmp___22 >= (size_t )l)) {
#line 4330
      goto while_break;
    }
#line 4334
    q = p + l;
    {
#line 4334
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4334
      if (! ((unsigned long )q > (unsigned long )p)) {
#line 4334
        goto while_break___0;
      }
#line 4336
      if ((int )*q == 44) {
#line 4337
        goto while_break___0;
      }
#line 4334
      q --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4339
    if ((unsigned long )p == (unsigned long )q) {
#line 4340
      goto while_break;
    }
    {
#line 4341
    q ++;
#line 4341
    sm_syslog(6, (char const   *)e->e_id, "to=%.*s [more]%s", (int )(q - p), p, buf___16);
#line 4343
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4345
  sm_syslog(6, (char const   *)e->e_id, "to=%.*s%s", l, p, buf___16);
  }
#line 4437
  return;
}
}
#line 4459 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
bool putfromline(struct mailer_con_info *mci , ENVELOPE *e ) 
{ 
  char *template ;
  char buf___16[2048] ;
  char xbuf[2048] ;
  char *bang ;
  char *at ;
  char hname[256] ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  bool tmp___2 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 4464
  template = UnixFromLine;
#line 4468
  if ((mci->mci_mailer)->m_flags[110UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 110UL % (8UL * sizeof(int )))) {
#line 4469
    return (1);
  }
#line 4471
  mci->mci_flags |= 512UL;
#line 4473
  if ((mci->mci_mailer)->m_flags[85UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 85UL % (8UL * sizeof(int )))) {
    {
#line 4477
    expand((char *)"\201g", buf___16, (size_t )sizeof(buf___16), e);
#line 4478
    bang = strchr((char const   *)(buf___16), '!');
    }
#line 4479
    if ((unsigned long )bang == (unsigned long )((void *)0)) {
      {
#line 4488
      at = strrchr((char const   *)(buf___16), '@');
      }
#line 4489
      if ((unsigned long )at == (unsigned long )((void *)0)) {
        {
#line 4491
        expand((char *)"\201k", hname, (size_t )sizeof(hname), e);
#line 4492
        at = hname;
        }
      } else {
#line 4495
        tmp = at;
#line 4495
        at ++;
#line 4495
        *tmp = (char )'\000';
      }
      {
#line 4496
      sm_snprintf(xbuf, (size_t )sizeof(xbuf), "From %.800s  \201d remote from %.100s\n",
                  buf___16, at);
      }
    } else {
      {
#line 4502
      tmp___0 = bang;
#line 4502
      bang ++;
#line 4502
      *tmp___0 = (char )'\000';
#line 4503
      sm_snprintf(xbuf, (size_t )sizeof(xbuf), "From %.800s  \201d remote from %.100s\n",
                  bang, buf___16);
#line 4506
      template = xbuf;
      }
    }
  }
  {
#line 4509
  expand(template, buf___16, (size_t )sizeof(buf___16), e);
#line 4510
  tmp___1 = strlen((char const   *)(buf___16));
#line 4510
  tmp___2 = putxline(buf___16, tmp___1, mci, 4);
  }
#line 4510
  return (tmp___2);
}
}
#line 4534 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
bool putbody(struct mailer_con_info *mci , ENVELOPE *e , char *separator ) 
{ 
  bool dead ;
  bool ioerr ;
  int save_errno ;
  char buf___16[2048] ;
  char *boundaries[21] ;
  char *df ;
  char *tmp ;
  char *msg ;
  int *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  struct stat stbuf ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  bool tmp___6 ;
  char *tmp___7 ;
  bool tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  bool oldsuprerrs ;
  int tmp___12 ;
  int ostate ;
  register char *bp___3 ;
  register char *pbp ;
  register int c ;
  register char *xp ;
  int padc ;
  char *buflim ;
  int pos ;
  char peekbuf[12] ;
  bool tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int sl ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int d ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  int *tmp___38 ;
  bool tmp___39 ;
  int *tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  int *tmp___43 ;
  int tmp___44 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;

  {
#line 4540
  dead = 0;
#line 4541
  ioerr = 0;
#line 4552
  if ((unsigned long )e->e_dfp == (unsigned long )((void *)0)) {
#line 4552
    if ((e->e_flags & 2097152UL) != 0UL) {
      {
#line 4554
      tmp = queuename(e, 'd');
#line 4554
      df = tmp;
#line 4556
      e->e_dfp = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)df,
                            2, (void const   *)((void *)0));
      }
#line 4558
      if ((unsigned long )e->e_dfp == (unsigned long )((void *)0)) {
        {
#line 4560
        msg = (char *)"!putbody: Cannot open %s for %s from %s";
#line 4562
        tmp___0 = __errno_location();
        }
#line 4562
        if (*tmp___0 == 2) {
#line 4563
          msg ++;
        }
        {
#line 4564
        syserr((char const   *)msg, df, e->e_to, e->e_from.q_paddr);
        }
      }
    }
  }
#line 4568
  if ((unsigned long )e->e_dfp == (unsigned long )((void *)0)) {
#line 4570
    if ((mci->mci_flags & 512UL) != 0UL) {
      {
#line 4572
      tmp___1 = putline((char *)"", mci);
      }
#line 4572
      if (! tmp___1) {
#line 4573
        goto writeerr;
      }
#line 4574
      mci->mci_flags &= 0xfffffffffffffdffUL;
    }
    {
#line 4576
    tmp___2 = putline((char *)"<<< No Message Collected >>>", mci);
    }
#line 4576
    if (! tmp___2) {
#line 4577
      goto writeerr;
    }
#line 4578
    goto endofmessage;
  }
#line 4581
  if (e->e_dfino == 0UL) {
    {
#line 4585
    tmp___3 = sm_io_getinfo(e->e_dfp, 3, (void *)0);
#line 4585
    tmp___4 = fstat(tmp___3, & stbuf);
    }
#line 4585
    if (tmp___4 < 0) {
#line 4587
      e->e_dfino = (ino_t )-1;
    } else {
#line 4590
      e->e_dfdev = stbuf.st_dev;
#line 4591
      e->e_dfino = stbuf.st_ino;
    }
  }
  {
#line 4596
  bfrewind(e->e_dfp);
  }
#line 4599
  if ((int )tTdvect[84] >= 101) {
    {
#line 4600
    sleep(319U);
    }
  }
#line 4603
  if ((mci->mci_flags & 1024UL) != 0UL) {
    {
#line 4610
    tmp___5 = hvalue((char *)"MIME-Version", e->e_header);
    }
#line 4610
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
      {
#line 4610
      tmp___6 = putline((char *)"MIME-Version: 1.0", mci);
      }
#line 4610
      if (! tmp___6) {
#line 4612
        goto writeerr;
      }
    }
    {
#line 4614
    tmp___9 = hvalue((char *)"Content-Type", e->e_header);
    }
#line 4614
    if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
      {
#line 4616
      tmp___7 = defcharset(e);
#line 4616
      sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Content-Type: text/plain; charset=%s",
                  tmp___7);
#line 4619
      tmp___8 = putline(buf___16, mci);
      }
#line 4619
      if (! tmp___8) {
#line 4620
        goto writeerr;
      }
    }
    {
#line 4624
    boundaries[0] = (char *)((void *)0);
#line 4625
    mci->mci_flags |= 512UL;
#line 4626
    tmp___10 = mime8to7(mci, e->e_header, e, boundaries, 0);
    }
#line 4626
    if (tmp___10 == -1) {
#line 4628
      goto writeerr;
    }
  } else
#line 4631
  if ((mci->mci_flags & 8192UL) != 0UL) {
    {
#line 4633
    tmp___11 = mime7to8(mci, e->e_header, e);
    }
#line 4633
    if (! tmp___11) {
#line 4634
      goto writeerr;
    }
  } else
#line 4637
  if (MaxMimeHeaderLength > 0) {
#line 4637
    goto _L___0;
  } else
#line 4637
  if (MaxMimeFieldLength > 0) {
    _L___0: /* CIL Label */ 
#line 4639
    oldsuprerrs = SuprErrs;
#line 4642
    boundaries[0] = (char *)((void *)0);
#line 4643
    mci->mci_flags |= 512UL;
#line 4653
    if ((e->e_flags & 8388608UL) != 0UL) {
#line 4654
      SuprErrs = 1;
    }
    {
#line 4656
    tmp___12 = mime8to7(mci, e->e_header, e, boundaries, 4);
    }
#line 4656
    if (tmp___12 == -1) {
#line 4658
      goto writeerr;
    }
#line 4661
    SuprErrs = oldsuprerrs;
  } else {
#line 4673
    pos = 0;
#line 4676
    if ((mci->mci_flags & 512UL) != 0UL) {
      {
#line 4678
      tmp___13 = putline((char *)"", mci);
      }
#line 4678
      if (! tmp___13) {
#line 4679
        goto writeerr;
      }
#line 4680
      mci->mci_flags &= 0xfffffffffffffdffUL;
    }
#line 4684
    buflim = & buf___16[sizeof(buf___16) - 1UL];
#line 4685
    if ((mci->mci_mailer)->m_linelimit > 0) {
#line 4685
      if ((unsigned long )(mci->mci_mailer)->m_linelimit < sizeof(buf___16) - 1UL) {
#line 4687
        buflim = & buf___16[(mci->mci_mailer)->m_linelimit - 1];
      }
    }
#line 4690
    ostate = 0;
#line 4691
    bp___3 = buf___16;
#line 4692
    pbp = peekbuf;
    {
#line 4693
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4693
      if (! (((mci->mci_out)->f_flags & 256L) != 0L)) {
#line 4693
        if (! (! dead)) {
#line 4693
          goto while_break;
        }
      } else {
#line 4693
        goto while_break;
      }
#line 4695
      if ((unsigned long )pbp > (unsigned long )(peekbuf)) {
#line 4696
        pbp --;
#line 4696
        c = (int )*pbp;
      } else {
        {
#line 4697
        c = sm_io_getc(e->e_dfp, -2);
        }
#line 4697
        if (c == -1) {
#line 4699
          goto while_break;
        }
      }
#line 4700
      if ((mci->mci_flags & 128UL) != 0UL) {
#line 4701
        c &= 127;
      }
      {
#line 4704
      if (ostate == 0) {
#line 4704
        goto case_0;
      }
#line 4816
      if (ostate == 1) {
#line 4816
        goto case_1;
      }
#line 4843
      if (ostate == 2) {
#line 4843
        goto case_2;
      }
#line 4702
      goto switch_break;
      case_0: /* CIL Label */ 
#line 4705
      if (c == 0) {
#line 4705
        if ((mci->mci_mailer)->m_flags[49UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 49UL % (8UL * sizeof(int )))) {
#line 4708
          goto switch_break;
        }
      }
#line 4709
      if (c != 13) {
#line 4709
        if (c != 10) {
#line 4709
          if ((unsigned long )bp___3 < (unsigned long )buflim) {
#line 4711
            tmp___14 = bp___3;
#line 4711
            bp___3 ++;
#line 4711
            *tmp___14 = (char )c;
#line 4712
            goto switch_break;
          }
        }
      }
#line 4716
      *bp___3 = (char )'\000';
#line 4717
      pos = 0;
#line 4718
      padc = -1;
#line 4719
      if ((int )buf___16[0] == 70) {
#line 4719
        if ((mci->mci_mailer)->m_flags[69UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 69UL % (8UL * sizeof(int )))) {
          {
#line 4719
          tmp___15 = strncmp((char const   *)(buf___16), "From ", (size_t )5);
          }
#line 4719
          if (tmp___15 == 0) {
#line 4723
            padc = '>';
          }
        }
      }
#line 4725
      if ((int )buf___16[0] == 45) {
#line 4725
        if ((int )buf___16[1] == 45) {
#line 4725
          if ((unsigned long )separator != (unsigned long )((void *)0)) {
            {
#line 4729
            tmp___16 = strlen((char const   *)separator);
#line 4729
            sl = (int )tmp___16;
#line 4731
            tmp___17 = strncmp((char const   *)(& buf___16[2]), (char const   *)separator,
                               (size_t )sl);
            }
#line 4731
            if (tmp___17 == 0) {
#line 4733
              padc = ' ';
            }
          }
        }
      }
#line 4735
      if ((int )buf___16[0] == 46) {
#line 4735
        if ((mci->mci_mailer)->m_flags[88UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 88UL % (8UL * sizeof(int )))) {
#line 4738
          padc = '.';
        }
      }
#line 4742
      if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
        {
#line 4744
        sm_io_fprintf(TrafficLogFile, -2, "%05d >>> ", CurrentPid);
        }
#line 4748
        if (padc != -1) {
          {
#line 4749
          sm_io_putc(TrafficLogFile, -2, padc);
          }
        }
#line 4752
        xp = buf___16;
        {
#line 4752
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4752
          if (! ((unsigned long )xp < (unsigned long )bp___3)) {
#line 4752
            goto while_break___0;
          }
          {
#line 4753
          sm_io_putc(TrafficLogFile, -2, (int )((unsigned char )*xp));
#line 4752
          xp ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 4756
        if (c == 10) {
          {
#line 4757
          sm_io_fputs(TrafficLogFile, -2, (char const   *)(mci->mci_mailer)->m_eol);
          }
        }
      }
#line 4761
      if (padc != -1) {
        {
#line 4763
        tmp___18 = sm_io_putc(mci->mci_out, -2, padc);
        }
#line 4763
        if (tmp___18 == -1) {
#line 4767
          dead = 1;
#line 4768
          goto while_continue;
        }
#line 4770
        pos ++;
      }
#line 4772
      xp = buf___16;
      {
#line 4772
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4772
        if (! ((unsigned long )xp < (unsigned long )bp___3)) {
#line 4772
          goto while_break___1;
        }
        {
#line 4774
        tmp___19 = sm_io_putc(mci->mci_out, -2, (int )((unsigned char )*xp));
        }
#line 4774
        if (tmp___19 == -1) {
#line 4779
          dead = 1;
#line 4780
          goto while_break___1;
        }
#line 4772
        xp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4783
      if (dead) {
#line 4784
        goto while_continue;
      }
#line 4785
      if (c == 10) {
        {
#line 4787
        tmp___20 = sm_io_fputs(mci->mci_out, -2, (char const   *)(mci->mci_mailer)->m_eol);
        }
#line 4787
        if (tmp___20 == -1) {
#line 4791
          goto switch_break;
        }
#line 4792
        pos = 0;
      } else {
#line 4796
        pos = (int )((long )pos + (bp___3 - buf___16));
#line 4797
        if (c != 13) {
#line 4799
          if ((unsigned long )pbp < (unsigned long )(peekbuf + sizeof(peekbuf))) {
#line 4799
            tmp___21 = 1;
          } else {
            {
#line 4799
            sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                        4800, "SM_ASSERT(pbp < peekbuf + sizeof(peekbuf)) failed");
#line 4799
            tmp___21 = 0;
            }
          }
#line 4801
          tmp___22 = pbp;
#line 4801
          pbp ++;
#line 4801
          *tmp___22 = (char )c;
        }
      }
#line 4805
      bp___3 = buf___16;
#line 4808
      if (c == 10) {
#line 4809
        ostate = 0;
      } else
#line 4810
      if (c == 13) {
#line 4811
        ostate = 1;
      } else {
#line 4813
        ostate = 2;
      }
#line 4814
      goto while_continue;
      case_1: /* CIL Label */ 
#line 4817
      if (c == 10) {
        {
#line 4820
        tmp___23 = sm_io_fputs(mci->mci_out, -2, (char const   *)(mci->mci_mailer)->m_eol);
        }
#line 4820
        if (tmp___23 == -1) {
#line 4824
          goto while_continue;
        }
#line 4826
        if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
          {
#line 4828
          sm_io_fputs(TrafficLogFile, -2, (char const   *)(mci->mci_mailer)->m_eol);
          }
        }
#line 4832
        ostate = 0;
#line 4833
        goto while_continue;
      }
#line 4837
      if ((unsigned long )pbp < (unsigned long )(peekbuf + sizeof(peekbuf))) {
#line 4837
        tmp___24 = 1;
      } else {
        {
#line 4837
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                    4837, "SM_ASSERT(pbp < peekbuf + sizeof(peekbuf)) failed");
#line 4837
        tmp___24 = 0;
        }
      }
#line 4838
      tmp___25 = pbp;
#line 4838
      pbp ++;
#line 4838
      *tmp___25 = (char )c;
#line 4839
      c = '\r';
#line 4840
      ostate = 2;
#line 4841
      goto putch;
      case_2: /* CIL Label */ 
#line 4844
      if (c == 13) {
#line 4846
        ostate = 1;
#line 4847
        goto while_continue;
      }
#line 4849
      if (c == 0) {
#line 4849
        if ((mci->mci_mailer)->m_flags[49UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 49UL % (8UL * sizeof(int )))) {
#line 4852
          goto switch_break;
        }
      }
      putch: 
#line 4854
      if ((mci->mci_mailer)->m_linelimit > 0) {
#line 4854
        if (pos >= (mci->mci_mailer)->m_linelimit - 1) {
#line 4854
          if (c != 10) {
#line 4861
            if ((unsigned long )pbp > (unsigned long )(peekbuf)) {
#line 4862
              d = (int )*(pbp - 1);
            } else {
              {
#line 4863
              d = sm_io_getc(e->e_dfp, -2);
              }
#line 4863
              if (d != -1) {
#line 4867
                if ((unsigned long )pbp < (unsigned long )(peekbuf + sizeof(peekbuf))) {
#line 4867
                  tmp___26 = 1;
                } else {
                  {
#line 4867
                  sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                              4868, "SM_ASSERT(pbp < peekbuf + sizeof(peekbuf)) failed");
#line 4867
                  tmp___26 = 0;
                  }
                }
#line 4869
                tmp___27 = pbp;
#line 4869
                pbp ++;
#line 4869
                *tmp___27 = (char )d;
              }
            }
#line 4872
            if (d == 10) {
#line 4872
              goto _L;
            } else
#line 4872
            if (d == -1) {
              _L: /* CIL Label */ 
#line 4874
              if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
                {
#line 4875
                sm_io_putc(TrafficLogFile, -2, (int )((unsigned char )c));
                }
              }
              {
#line 4878
              tmp___28 = sm_io_putc(mci->mci_out, -2, (int )((unsigned char )c));
              }
#line 4878
              if (tmp___28 == -1) {
#line 4883
                dead = 1;
#line 4884
                goto while_continue;
              }
#line 4886
              pos ++;
#line 4887
              goto while_continue;
            }
            {
#line 4890
            tmp___29 = sm_io_putc(mci->mci_out, -2, '!');
            }
#line 4890
            if (tmp___29 == -1) {
#line 4898
              dead = 1;
#line 4899
              goto while_continue;
            } else {
              {
#line 4890
              tmp___30 = sm_io_fputs(mci->mci_out, -2, (char const   *)(mci->mci_mailer)->m_eol);
              }
#line 4890
              if (tmp___30 == -1) {
#line 4898
                dead = 1;
#line 4899
                goto while_continue;
              }
            }
#line 4902
            if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
              {
#line 4904
              sm_io_fprintf(TrafficLogFile, -2, "!%s", (mci->mci_mailer)->m_eol);
              }
            }
#line 4909
            ostate = 0;
#line 4910
            if ((unsigned long )pbp < (unsigned long )(peekbuf + sizeof(peekbuf))) {
#line 4910
              tmp___31 = 1;
            } else {
              {
#line 4910
              sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                          4911, "SM_ASSERT(pbp < peekbuf + sizeof(peekbuf)) failed");
#line 4910
              tmp___31 = 0;
              }
            }
#line 4912
            tmp___32 = pbp;
#line 4912
            pbp ++;
#line 4912
            *tmp___32 = (char )c;
#line 4913
            goto while_continue;
          }
        }
      }
#line 4915
      if (c == 10) {
#line 4917
        if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
          {
#line 4918
          sm_io_fputs(TrafficLogFile, -2, (char const   *)(mci->mci_mailer)->m_eol);
          }
        }
        {
#line 4921
        tmp___33 = sm_io_fputs(mci->mci_out, -2, (char const   *)(mci->mci_mailer)->m_eol);
        }
#line 4921
        if (tmp___33 == -1) {
#line 4925
          goto while_continue;
        }
#line 4926
        pos = 0;
#line 4927
        ostate = 0;
      } else {
#line 4931
        if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
          {
#line 4932
          sm_io_putc(TrafficLogFile, -2, (int )((unsigned char )c));
          }
        }
        {
#line 4935
        tmp___34 = sm_io_putc(mci->mci_out, -2, (int )((unsigned char )c));
        }
#line 4935
        if (tmp___34 == -1) {
#line 4940
          dead = 1;
#line 4941
          goto while_continue;
        }
#line 4943
        pos ++;
#line 4944
        ostate = 2;
      }
#line 4946
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 4951
    if ((unsigned long )bp___3 > (unsigned long )(buf___16)) {
#line 4953
      if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
#line 4955
        xp = buf___16;
        {
#line 4955
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 4955
          if (! ((unsigned long )xp < (unsigned long )bp___3)) {
#line 4955
            goto while_break___2;
          }
          {
#line 4956
          sm_io_putc(TrafficLogFile, -2, (int )((unsigned char )*xp));
#line 4955
          xp ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 4960
      xp = buf___16;
      {
#line 4960
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 4960
        if (! ((unsigned long )xp < (unsigned long )bp___3)) {
#line 4960
          goto while_break___3;
        }
        {
#line 4962
        tmp___35 = sm_io_putc(mci->mci_out, -2, (int )((unsigned char )*xp));
        }
#line 4962
        if (tmp___35 == -1) {
#line 4966
          dead = 1;
#line 4967
          goto while_break___3;
        }
#line 4960
        xp ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 4970
      pos = (int )((long )pos + (bp___3 - buf___16));
    }
#line 4972
    if (! dead) {
#line 4972
      if (pos > 0) {
#line 4974
        if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
          {
#line 4975
          sm_io_fputs(TrafficLogFile, -2, (char const   *)(mci->mci_mailer)->m_eol);
          }
        }
        {
#line 4978
        tmp___36 = sm_io_fputs(mci->mci_out, -2, (char const   *)(mci->mci_mailer)->m_eol);
        }
#line 4978
        if (tmp___36 == -1) {
#line 4980
          goto writeerr;
        }
      }
    }
  }
#line 4984
  if (((e->e_dfp)->f_flags & 256L) != 0L) {
    {
#line 4986
    tmp___37 = qid_printqueue(e->e_dfqgrp, e->e_dfqdir);
#line 4986
    syserr("putbody: %s/%cf%s: read error", tmp___37, 'd', e->e_id);
#line 4989
    ExitStat = 74;
#line 4990
    ioerr = 1;
    }
  }
  endofmessage: 
  {
#line 5005
  tmp___38 = __errno_location();
#line 5005
  save_errno = *tmp___38;
  }
#line 5006
  if ((unsigned long )e->e_dfp != (unsigned long )((void *)0)) {
    {
#line 5007
    bfrewind(e->e_dfp);
    }
  }
#line 5010
  if (! dead) {
#line 5010
    if ((mci->mci_mailer)->m_flags[98UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 98UL % (8UL * sizeof(int )))) {
#line 5010
      if ((int )buf___16[0] != 0) {
#line 5010
        if ((int )buf___16[0] != 10) {
          {
#line 5013
          tmp___39 = putline((char *)"", mci);
          }
#line 5013
          if (! tmp___39) {
#line 5014
            goto writeerr;
          }
        }
      }
    }
  }
#line 5017
  if (! dead) {
    {
#line 5017
    tmp___41 = sm_io_flush(mci->mci_out, -2);
    }
#line 5017
    if (tmp___41 == -1) {
      {
#line 5021
      tmp___40 = __errno_location();
#line 5021
      save_errno = *tmp___40;
#line 5022
      syserr("putbody: write error");
#line 5023
      ExitStat = 74;
#line 5024
      ioerr = 1;
      }
    } else
#line 5017
    if (((mci->mci_out)->f_flags & 256L) != 0L) {
      {
#line 5017
      tmp___42 = __errno_location();
      }
#line 5017
      if (*tmp___42 != 32) {
        {
#line 5021
        tmp___40 = __errno_location();
#line 5021
        save_errno = *tmp___40;
#line 5022
        syserr("putbody: write error");
#line 5023
        ExitStat = 74;
#line 5024
        ioerr = 1;
        }
      }
    }
  }
  {
#line 5027
  tmp___43 = __errno_location();
#line 5027
  *tmp___43 = save_errno;
  }
#line 5028
  if (! dead) {
#line 5028
    if (! ioerr) {
#line 5028
      tmp___44 = 1;
    } else {
#line 5028
      tmp___44 = 0;
    }
  } else {
#line 5028
    tmp___44 = 0;
  }
#line 5028
  return (tmp___44);
  writeerr: 
#line 5031
  return (0);
}
}
#line 5066 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static sigjmp_buf CtxMailfileTimeout  ;
#line 5068 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
int mailfile(char * volatile  filename , MAILER * volatile  mailer , ADDRESS *ctladdr ,
             long volatile   sfflags , ENVELOPE *e ) 
{ 
  register SM_FILE_T *f ;
  register pid_t pid ;
  int volatile   mode ;
  int len___0 ;
  off_t curoff ;
  bool suidwarn ;
  __uid_t tmp ;
  char *p ;
  char * volatile  realfile ;
  SM_EVENT *ev ;
  char buf___16[4096] ;
  char targetfile[4096] ;
  SM_FILE_T *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  register int i ;
  struct stat stb ;
  struct mailer_con_info mcibuf ;
  int err ;
  int volatile   oflags ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *df ;
  char *tmp___14 ;
  __gid_t tmp___15 ;
  __gid_t tmp___16 ;
  __gid_t tmp___17 ;
  __gid_t tmp___18 ;
  int tmp___19 ;
  gid_t gidset[1] ;
  int tmp___20 ;
  char save ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  __gid_t tmp___25 ;
  __gid_t tmp___26 ;
  __uid_t tmp___27 ;
  __uid_t tmp___28 ;
  char *q ;
  char *tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  char const   *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char const   *tmp___35 ;
  char *tmp___36 ;
  int *tmp___37 ;
  bool tmp___38 ;
  int tmp___39 ;
  bool tmp___40 ;
  int *tmp___41 ;
  char const   *tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  bool tmp___49 ;
  bool tmp___50 ;
  bool tmp___51 ;
  bool tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int st ;
  int *tmp___58 ;
  union __anonunion___u_72 __u ;
  union __anonunion___u_73 __u___0 ;
  void *__cil_tmp89 ;
  void *__cil_tmp90 ;
  void *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;

  {
  {
#line 5077
  pid = -1;
#line 5081
  tmp = geteuid();
#line 5081
  suidwarn = tmp == 0U;
  }
#line 5088
  if ((int )tTdvect[11] >= 1) {
    {
#line 5090
    sm_dprintf((char *)"mailfile %s\n  ctladdr=", filename);
#line 5091
    tmp___0 = sm_debug_file();
#line 5091
    printaddr(tmp___0, ctladdr, 0);
    }
  }
#line 5094
  if ((unsigned long )mailer == (unsigned long )((void *)0)) {
#line 5095
    mailer = (MAILER */* volatile  */)FileMailer;
  }
#line 5097
  if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
    {
#line 5098
    sm_io_flush(e->e_xfp, -2);
    }
  }
  {
#line 5105
  tmp___1 = strcmp((char const   *)filename, "/dev/null");
  }
#line 5105
  if (tmp___1 == 0) {
#line 5106
    return (0);
  }
#line 5109
  if ((e->e_flags & 131072UL) != 0UL) {
#line 5109
    if (mailer->m_flags[55UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 55UL % (8UL * sizeof(int )))) {
#line 5109
      if ((e->e_flags & 8388608UL) != 0UL) {
        {
#line 5116
        e->e_status = (char *)"5.6.3";
#line 5117
        usrerrenh(e->e_status, "554 Cannot send 8-bit data to 7-bit destination");
#line 5119
        tmp___2 = __errno_location();
#line 5119
        *tmp___2 = 0;
        }
#line 5120
        return (65);
      } else
#line 5109
      if (! ((MimeMode & 4) != 0)) {
#line 5109
        if ((e->e_flags & 4194304UL) != 0UL) {
#line 5109
          if (! ((MimeMode & 1) != 0)) {
            {
#line 5116
            e->e_status = (char *)"5.6.3";
#line 5117
            usrerrenh(e->e_status, "554 Cannot send 8-bit data to 7-bit destination");
#line 5119
            tmp___2 = __errno_location();
#line 5119
            *tmp___2 = 0;
            }
#line 5120
            return (65);
          }
        } else {
          {
#line 5116
          e->e_status = (char *)"5.6.3";
#line 5117
          usrerrenh(e->e_status, "554 Cannot send 8-bit data to 7-bit destination");
#line 5119
          tmp___2 = __errno_location();
#line 5119
          *tmp___2 = 0;
          }
#line 5120
          return (65);
        }
      }
    }
  }
#line 5124
  if ((unsigned long )SafeFileEnv != (unsigned long )((void *)0)) {
#line 5124
    if ((int )*(SafeFileEnv + 0) != 0) {
      {
#line 5126
      tmp___3 = strlen((char const   *)SafeFileEnv);
#line 5126
      len___0 = (int )tmp___3;
#line 5128
      tmp___4 = strncmp((char const   *)SafeFileEnv, (char const   *)filename, (size_t )len___0);
      }
#line 5128
      if (tmp___4 == 0) {
#line 5129
        filename += len___0;
      }
      {
#line 5131
      tmp___5 = strlen((char const   *)filename);
      }
#line 5131
      if ((unsigned long )(((size_t )len___0 + tmp___5) + 1U) >= sizeof(targetfile)) {
        {
#line 5133
        syserr("mailfile: filename too long (%s/%s)", SafeFileEnv, filename);
        }
#line 5135
        return (73);
      }
      {
#line 5137
      sm_strlcpy(targetfile, (char const   *)SafeFileEnv, (ssize_t )sizeof(targetfile));
#line 5138
      realfile = (char */* volatile  */)(targetfile + len___0);
      }
#line 5139
      if ((int )*filename == 47) {
#line 5140
        filename ++;
      }
#line 5141
      if ((int )*filename != 0) {
#line 5144
        if ((int )targetfile[len___0 - 1] != 47) {
          {
#line 5145
          sm_strlcat(targetfile, "/", (ssize_t )sizeof(targetfile));
          }
        }
        {
#line 5147
        sm_strlcat(targetfile, (char const   *)filename, (ssize_t )sizeof(targetfile));
        }
      }
    } else {
#line 5124
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 5151
  if ((unsigned long )mailer->m_rootdir != (unsigned long )((void *)0)) {
    {
#line 5153
    expand(mailer->m_rootdir, targetfile, (size_t )sizeof(targetfile), e);
#line 5154
    tmp___6 = strlen((char const   *)(targetfile));
#line 5154
    len___0 = (int )tmp___6;
#line 5156
    tmp___7 = strncmp((char const   *)(targetfile), (char const   *)filename, (size_t )len___0);
    }
#line 5156
    if (tmp___7 == 0) {
#line 5157
      filename += len___0;
    }
    {
#line 5159
    tmp___8 = strlen((char const   *)filename);
    }
#line 5159
    if ((unsigned long )(((size_t )len___0 + tmp___8) + 1U) >= sizeof(targetfile)) {
      {
#line 5161
      syserr("mailfile: filename too long (%s/%s)", targetfile, filename);
      }
#line 5163
      return (73);
    }
#line 5165
    realfile = (char */* volatile  */)(targetfile + len___0);
#line 5166
    if ((int )targetfile[len___0 - 1] != 47) {
      {
#line 5167
      sm_strlcat(targetfile, "/", (ssize_t )sizeof(targetfile));
      }
    }
#line 5168
    if ((int )*filename == 47) {
      {
#line 5169
      sm_strlcat(targetfile, (char const   *)(filename + 1), (ssize_t )sizeof(targetfile));
      }
    } else {
      {
#line 5172
      sm_strlcat(targetfile, (char const   *)filename, (ssize_t )sizeof(targetfile));
      }
    }
  } else {
    {
#line 5177
    tmp___9 = sm_strlcpy(targetfile, (char const   *)filename, (ssize_t )sizeof(targetfile));
    }
#line 5177
    if ((unsigned long )tmp___9 >= sizeof(targetfile)) {
      {
#line 5180
      syserr("mailfile: filename too long (%s)", filename);
      }
#line 5181
      return (73);
    }
#line 5183
    realfile = (char */* volatile  */)(targetfile);
  }
  {
#line 5198
  sm_signal(17, (void (*)(int  ))0);
#line 5200
  i = 5;
  }
  {
#line 5200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5200
    i --;
#line 5200
    if (! (i >= 0)) {
#line 5200
      goto while_break;
    }
    {
#line 5200
    pid = fork();
    }
#line 5200
    if (pid >= 0) {
#line 5200
      goto while_break;
    }
#line 5200
    if (i > 0) {
      {
#line 5200
      sleep(5U - (unsigned int )i);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5202
  if (pid < 0) {
#line 5203
    return (71);
  } else
#line 5204
  if (pid == 0) {
    {
#line 5210
    oflags = (int volatile   )1025;
#line 5213
    RestartRequest = (char */* volatile  */)((void *)0);
#line 5214
    RestartWorkGroup = (bool volatile   )0;
#line 5215
    ShutdownRequest = (char */* volatile  */)((void *)0);
#line 5216
    PendingSignal = (int volatile   )0;
#line 5217
    CurrentPid = getpid();
    }
#line 5219
    if ((unsigned long )e->e_lockfp != (unsigned long )((void *)0)) {
      {
#line 5220
      tmp___10 = sm_io_getinfo(e->e_lockfp, 3, (void *)0);
#line 5220
      close(tmp___10);
      }
    }
    {
#line 5223
    sm_signal(2, (void (*)(int  ))0);
#line 5224
    sm_signal(1, (void (*)(int  ))0);
#line 5225
    sm_signal(15, (void (*)(int  ))0);
#line 5226
    umask(OldUmask);
#line 5227
    e->e_to = (char *)filename;
#line 5228
    ExitStat = 0;
#line 5230
    tmp___11 = __sigsetjmp((struct __jmp_buf_tag *)(CtxMailfileTimeout), 1);
    }
#line 5230
    if (tmp___11 != 0) {
      {
#line 5232
      exit(75);
      }
    }
#line 5235
    if (TimeOuts.to_fileopen > 0L) {
      {
#line 5236
      ev = sm_seteventm((int )(TimeOuts.to_fileopen * 1000L), & mailfiletimeout, 0);
      }
    } else {
#line 5239
      ev = (SM_EVENT *)((void *)0);
    }
    {
#line 5242
    tmp___12 = stat((char const   */* __restrict  */)(targetfile), (struct stat */* __restrict  */)(& stb));
    }
#line 5242
    if (tmp___12 < 0) {
#line 5243
      mode = (int volatile   )FileMode;
    } else {
#line 5245
      mode = (int volatile   )stb.st_mode;
    }
    {
#line 5248
    tmp___13 = __errno_location();
#line 5248
    *tmp___13 = 0;
#line 5249
    ExitStat = 0;
    }
#line 5252
    if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
#line 5252
      if (! ((ctladdr->q_flags & 16384UL) != 0UL)) {
#line 5252
        goto _L___0;
      } else {
#line 5252
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 5252
    if ((sfflags & (long volatile   )8L) != (long volatile   )0) {
      _L___0: /* CIL Label */ 
#line 5256
      mode &= (int volatile   )-3073;
#line 5257
      if ((int )tTdvect[11] >= 20) {
        {
#line 5258
        sm_dprintf((char *)"mailfile: ignoring set-user-ID/set-group-ID bits\n");
        }
      }
    }
#line 5262
    if ((unsigned long )e->e_dfp == (unsigned long )((void *)0)) {
#line 5262
      if ((e->e_flags & 2097152UL) != 0UL) {
        {
#line 5264
        tmp___14 = queuename(e, 'd');
#line 5264
        df = tmp___14;
#line 5266
        e->e_dfp = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)df,
                              2, (void const   *)((void *)0));
        }
#line 5268
        if ((unsigned long )e->e_dfp == (unsigned long )((void *)0)) {
          {
#line 5270
          syserr("mailfile: Cannot open %s for %s from %s", df, e->e_to, e->e_from.q_paddr);
          }
        }
      }
    }
#line 5276
    if (! ((sfflags & (long volatile   )8L) != (long volatile   )0)) {
#line 5278
      if (mailer->m_flags[83UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 83UL % (8UL * sizeof(int )))) {
#line 5280
        RealUserName = (char *)((void *)0);
#line 5281
        if (mailer->m_uid == 4294967295U) {
#line 5282
          RealUid = RunAsUid;
        } else {
#line 5284
          RealUid = mailer->m_uid;
        }
#line 5285
        if (RunAsUid != 0U) {
#line 5285
          if (RealUid != RunAsUid) {
            {
#line 5288
            syserr("mailfile: insufficient privileges to change uid, RunAsUid=%d, RealUid=%d",
                   (int )RunAsUid, (int )RealUid);
#line 5290
            exit(75);
            }
          }
        }
      } else
#line 5293
      if ((mode & (int volatile   )2048) != (int volatile   )0) {
#line 5295
        RealUserName = (char *)((void *)0);
#line 5296
        RealUid = stb.st_uid;
      } else
#line 5298
      if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
#line 5298
        if (ctladdr->q_uid != 0U) {
#line 5300
          if ((unsigned long )ctladdr->q_ruser != (unsigned long )((void *)0)) {
#line 5301
            RealUserName = ctladdr->q_ruser;
          } else {
#line 5303
            RealUserName = ctladdr->q_user;
          }
#line 5304
          RealUid = ctladdr->q_uid;
        } else {
#line 5298
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 5306
      if ((unsigned long )mailer != (unsigned long )((void *)0)) {
#line 5306
        if (mailer->m_uid != 4294967295U) {
#line 5308
          RealUserName = DefUser;
#line 5309
          RealUid = mailer->m_uid;
        } else {
#line 5313
          RealUserName = DefUser;
#line 5314
          RealUid = DefUid;
        }
      } else {
#line 5313
        RealUserName = DefUser;
#line 5314
        RealUid = DefUid;
      }
#line 5318
      if (mailer->m_flags[83UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 83UL % (8UL * sizeof(int )))) {
#line 5320
        if (mailer->m_gid == 4294967295U) {
#line 5321
          RealGid = RunAsGid;
        } else {
#line 5323
          RealGid = mailer->m_gid;
        }
#line 5324
        if (RunAsUid != 0U) {
          {
#line 5324
          tmp___17 = getgid();
          }
#line 5324
          if (RealGid != tmp___17) {
            {
#line 5329
            tmp___15 = getegid();
#line 5329
            tmp___16 = getgid();
#line 5329
            syserr("mailfile: insufficient privileges to change gid, RealGid=%d, RunAsUid=%d, gid=%d, egid=%d",
                   (int )RealGid, (int )RunAsUid, (int )tmp___16, (int )tmp___15);
#line 5332
            exit(75);
            }
          } else {
            {
#line 5324
            tmp___18 = getegid();
            }
#line 5324
            if (RealGid != tmp___18) {
              {
#line 5329
              tmp___15 = getegid();
#line 5329
              tmp___16 = getgid();
#line 5329
              syserr("mailfile: insufficient privileges to change gid, RealGid=%d, RunAsUid=%d, gid=%d, egid=%d",
                     (int )RealGid, (int )RunAsUid, (int )tmp___16, (int )tmp___15);
#line 5332
              exit(75);
              }
            }
          }
        }
      } else
#line 5335
      if ((mode & (int volatile   )1024) != (int volatile   )0) {
#line 5336
        RealGid = stb.st_gid;
      } else
#line 5337
      if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
#line 5337
        if (ctladdr->q_uid == DefUid) {
#line 5337
          if (ctladdr->q_gid == 0U) {
#line 5347
            RealGid = DefGid;
#line 5348
            RealUserName = DefUser;
          } else {
#line 5337
            goto _L___5;
          }
        } else {
#line 5337
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 5350
      if ((unsigned long )ctladdr != (unsigned long )((void *)0)) {
#line 5350
        if (ctladdr->q_uid != 0U) {
#line 5351
          RealGid = ctladdr->q_gid;
        } else {
#line 5350
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 5352
      if ((unsigned long )mailer != (unsigned long )((void *)0)) {
#line 5352
        if (mailer->m_gid != 4294967295U) {
#line 5353
          RealGid = mailer->m_gid;
        } else {
#line 5355
          RealGid = DefGid;
        }
      } else {
#line 5355
        RealGid = DefGid;
      }
    }
#line 5359
    if (! ((sfflags & (long volatile   )4L) != (long volatile   )0)) {
#line 5361
      if (RealUid == 0U) {
#line 5362
        RealUid = DefUid;
      }
#line 5363
      if (RealGid == 0U) {
#line 5364
        RealGid = DefGid;
      }
    }
#line 5368
    if ((unsigned long )RealUserName != (unsigned long )((void *)0)) {
#line 5368
      if (! DontInitGroups) {
        {
#line 5370
        tmp___19 = initgroups((char const   *)RealUserName, RealGid);
        }
#line 5370
        if (tmp___19 == -1) {
#line 5370
          if (suidwarn) {
            {
#line 5372
            syserr("mailfile: initgroups(%s, %d) failed", RealUserName, RealGid);
#line 5374
            exit(75);
            }
          }
        }
      } else {
#line 5368
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
      {
#line 5381
      gidset[0] = RealGid;
#line 5382
      tmp___20 = setgroups((size_t )1, (__gid_t const   *)(gidset));
      }
#line 5382
      if (tmp___20 == -1) {
#line 5382
        if (suidwarn) {
          {
#line 5384
          syserr("mailfile: setgroups() failed");
#line 5385
          exit(75);
          }
        }
      }
    }
#line 5393
    if ((unsigned long )realfile != (unsigned long )(targetfile)) {
#line 5397
      save = *realfile;
#line 5398
      *realfile = (char )'\000';
#line 5399
      if ((int )tTdvect[11] >= 20) {
        {
#line 5400
        sm_dprintf((char *)"mailfile: chroot %s\n", targetfile);
        }
      }
      {
#line 5401
      tmp___21 = chroot((char const   *)(targetfile));
      }
#line 5401
      if (tmp___21 < 0) {
        {
#line 5403
        syserr("mailfile: Cannot chroot(%s)", targetfile);
#line 5405
        exit(73);
        }
      }
#line 5407
      *realfile = save;
    }
#line 5410
    if ((int )tTdvect[11] >= 40) {
      {
#line 5411
      sm_dprintf((char *)"mailfile: deliver to %s\n", realfile);
      }
    }
    {
#line 5413
    tmp___22 = chdir("/");
    }
#line 5413
    if (tmp___22 < 0) {
      {
#line 5415
      syserr("mailfile: cannot chdir(/)");
#line 5416
      exit(73);
      }
    }
    {
#line 5420
    endpwent();
#line 5421
    sm_mbdb_terminate();
#line 5422
    tmp___23 = setgid(RealGid);
    }
#line 5422
    if (tmp___23 < 0) {
#line 5422
      if (suidwarn) {
        {
#line 5424
        syserr("mailfile: setgid(%ld) failed", (long )RealGid);
#line 5425
        exit(75);
        }
      }
    }
    {
#line 5427
    vendor_set_uid(RealUid);
#line 5428
    tmp___24 = setuid(RealUid);
    }
#line 5428
    if (tmp___24 < 0) {
#line 5428
      if (suidwarn) {
        {
#line 5430
        syserr("mailfile: setuid(%ld) failed", (long )RealUid);
#line 5431
        exit(75);
        }
      }
    }
#line 5434
    if ((int )tTdvect[11] >= 2) {
      {
#line 5435
      tmp___25 = getegid();
#line 5435
      tmp___26 = getgid();
#line 5435
      tmp___27 = geteuid();
#line 5435
      tmp___28 = getuid();
#line 5435
      sm_dprintf((char *)"mailfile: running as r/euid=%d/%d, r/egid=%d/%d\n", (int )tmp___28,
                 (int )tmp___27, (int )tmp___26, (int )tmp___25);
      }
    }
#line 5441
    if ((unsigned long )mailer->m_execdir != (unsigned long )((void *)0)) {
#line 5445
      p = mailer->m_execdir;
      {
#line 5445
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5445
        if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 5445
          goto while_break___0;
        }
        {
#line 5447
        q = strchr((char const   *)p, ':');
        }
#line 5448
        if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 5449
          *q = (char )'\000';
        }
        {
#line 5450
        expand(p, buf___16, (size_t )sizeof(buf___16), e);
        }
#line 5451
        if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 5452
          tmp___29 = q;
#line 5452
          q ++;
#line 5452
          *tmp___29 = (char )':';
        }
#line 5453
        if ((int )tTdvect[11] >= 20) {
          {
#line 5454
          sm_dprintf((char *)"mailfile: trydir %s\n", buf___16);
          }
        }
#line 5456
        if ((int )buf___16[0] != 0) {
          {
#line 5456
          tmp___30 = chdir((char const   *)(buf___16));
          }
#line 5456
          if (tmp___30 >= 0) {
#line 5457
            goto while_break___0;
          }
        }
#line 5445
        p = q;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 5470
    if (DontBlameSendmail[16UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 16UL % (8UL * sizeof(int )))) {
      {
#line 5471
      err = stat((char const   */* __restrict  */)realfile, (struct stat */* __restrict  */)(& stb));
      }
    } else {
      {
#line 5473
      err = lstat((char const   */* __restrict  */)realfile, (struct stat */* __restrict  */)(& stb));
      }
    }
#line 5478
    if (err < 0) {
#line 5480
      stb.st_mode = (__mode_t )62055;
#line 5481
      mode = (int volatile   )FileMode;
#line 5482
      oflags |= (int volatile   )192;
    } else
#line 5484
    if ((mode & (int volatile   )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) != (int volatile   )0) {
      {
#line 5489
      exit(73);
      }
    } else
#line 5484
    if (! (DontBlameSendmail[15UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 15UL % (8UL * sizeof(int ))))) {
#line 5484
      if (stb.st_nlink != 1U) {
        {
#line 5489
        exit(73);
        }
      } else {
#line 5484
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 5484
    if ((unsigned long )realfile != (unsigned long )(targetfile)) {
#line 5484
      if (! ((mode & (int volatile   )61440) == (int volatile   )32768)) {
        {
#line 5489
        exit(73);
        }
      } else {
#line 5491
        mode = (int volatile   )stb.st_mode;
      }
    } else {
#line 5491
      mode = (int volatile   )stb.st_mode;
    }
#line 5493
    if (! (DontBlameSendmail[16UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 16UL % (8UL * sizeof(int ))))) {
#line 5494
      sfflags |= (long volatile   )2L;
    }
#line 5495
    if (! (DontBlameSendmail[15UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 15UL % (8UL * sizeof(int ))))) {
#line 5496
      sfflags |= (long volatile   )512L;
    }
    {
#line 5497
    sfflags &= (long volatile   )-8193L;
#line 5498
    f = safefopen((char *)realfile, (int )oflags, (int )mode, (long )sfflags);
    }
#line 5499
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 5501
      tmp___37 = __errno_location();
#line 5501
      tmp___38 = transienterror(*tmp___37);
      }
#line 5501
      if (tmp___38) {
        {
#line 5503
        tmp___31 = __errno_location();
#line 5503
        tmp___32 = sm_errstring(*tmp___31);
#line 5503
        tmp___33 = shortenstring((char const   *)realfile, (size_t )203);
#line 5503
        usrerr("454 4.3.0 cannot open %s: %s", tmp___33, tmp___32);
#line 5506
        exit(75);
        }
      } else {
        {
#line 5510
        tmp___34 = __errno_location();
#line 5510
        tmp___35 = sm_errstring(*tmp___34);
#line 5510
        tmp___36 = shortenstring((char const   *)realfile, (size_t )203);
#line 5510
        usrerr("554 5.3.0 cannot open %s: %s", tmp___36, tmp___35);
#line 5513
        exit(73);
        }
      }
    }
    {
#line 5516
    tmp___39 = sm_io_getinfo(f, 3, (void *)0);
#line 5516
    tmp___40 = filechanged((char *)realfile, tmp___39, & stb);
    }
#line 5516
    if (tmp___40) {
      {
#line 5519
      syserr("554 5.3.0 file changed after open");
#line 5520
      exit(73);
      }
    }
    {
#line 5522
    tmp___43 = sm_io_getinfo(f, 3, (void *)0);
#line 5522
    tmp___44 = fstat(tmp___43, & stb);
    }
#line 5522
    if (tmp___44 < 0) {
      {
#line 5524
      tmp___41 = __errno_location();
#line 5524
      tmp___42 = sm_errstring(*tmp___41);
#line 5524
      syserr("554 5.3.0 cannot fstat %s", tmp___42);
#line 5526
      exit(73);
      }
    }
#line 5529
    curoff = stb.st_size;
#line 5531
    if ((unsigned long )ev != (unsigned long )((void *)0)) {
      {
#line 5532
      sm_clrevent(ev);
      }
    }
    {
#line 5534
    memset((void *)(& mcibuf), '\000', (size_t )sizeof(mcibuf));
#line 5535
    mcibuf.mci_mailer = (struct mailer *)mailer;
#line 5536
    mcibuf.mci_out = f;
    }
#line 5537
    if (mailer->m_flags[55UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 55UL % (8UL * sizeof(int )))) {
#line 5538
      mcibuf.mci_flags |= 128UL;
    }
#line 5541
    mcibuf.mci_flags &= 0xffffffffffffdbffUL;
#line 5543
    if ((e->e_flags & 131072UL) != 0UL) {
#line 5543
      if (! ((e->e_flags & 8388608UL) != 0UL)) {
#line 5543
        if (mailer->m_flags[55UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 55UL % (8UL * sizeof(int )))) {
#line 5546
          mcibuf.mci_flags |= 1024UL;
        }
      }
    }
#line 5549
    if (mailer->m_flags[57UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 57UL % (8UL * sizeof(int )))) {
#line 5549
      if (! ((mcibuf.mci_flags & 128UL) != 0UL)) {
        {
#line 5549
        p = hvalue((char *)"Content-Transfer-Encoding", e->e_header);
        }
#line 5549
        if ((unsigned long )p != (unsigned long )((void *)0)) {
          {
#line 5549
          tmp___46 = sm_strcasecmp((char const   *)p, "quoted-printable");
          }
#line 5549
          if (tmp___46 == 0) {
#line 5549
            goto _L___8;
          } else {
            {
#line 5549
            tmp___47 = sm_strcasecmp((char const   *)p, "base64");
            }
#line 5549
            if (tmp___47 == 0) {
              _L___8: /* CIL Label */ 
              {
#line 5549
              p = hvalue((char *)"Content-Type", e->e_header);
              }
#line 5549
              if ((unsigned long )p != (unsigned long )((void *)0)) {
                {
#line 5558
                tmp___45 = sm_strncasecmp((char const   *)p, "text/plain", (size_t )10);
                }
#line 5558
                if (tmp___45 == 0) {
#line 5558
                  if ((int )*(p + 10) == 0) {
#line 5560
                    mcibuf.mci_flags |= 8192UL;
                  } else
#line 5558
                  if ((int )*(p + 10) == 32) {
#line 5560
                    mcibuf.mci_flags |= 8192UL;
                  } else
#line 5558
                  if ((int )*(p + 10) == 59) {
#line 5560
                    mcibuf.mci_flags |= 8192UL;
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 5564
    tmp___49 = putfromline(& mcibuf, e);
    }
#line 5564
    if (tmp___49) {
      {
#line 5564
      tmp___50 = (*(e->e_puthdr))(& mcibuf, e->e_header, e, 0);
      }
#line 5564
      if (tmp___50) {
        {
#line 5564
        tmp___51 = (*(e->e_putbody))(& mcibuf, e, (char *)((void *)0));
        }
#line 5564
        if (tmp___51) {
          {
#line 5564
          tmp___52 = putline((char *)"\n", & mcibuf);
          }
#line 5564
          if (tmp___52) {
            {
#line 5564
            tmp___53 = sm_io_flush(f, -2);
            }
#line 5564
            if (tmp___53 != 0) {
#line 5564
              goto _L___10;
            } else
#line 5564
            if (SuperSafe != 0) {
              {
#line 5564
              tmp___54 = sm_io_getinfo(f, 3, (void *)0);
#line 5564
              tmp___55 = fsync(tmp___54);
              }
#line 5564
              if (tmp___55 < 0) {
#line 5564
                goto _L___10;
              } else {
#line 5564
                goto _L___11;
              }
            } else
            _L___11: /* CIL Label */ 
#line 5564
            if ((f->f_flags & 256L) != 0L) {
              _L___10: /* CIL Label */ 
#line 5573
              if (ExitStat == 0) {
#line 5573
                ExitStat = 74;
              } else
#line 5573
              if (ExitStat == 75) {
#line 5573
                ExitStat = 74;
              }
              {
#line 5575
              tmp___48 = sm_io_getinfo(f, 3, (void *)0);
#line 5575
              ftruncate(tmp___48, curoff);
              }
            }
          } else {
#line 5564
            goto _L___10;
          }
        } else {
#line 5564
          goto _L___10;
        }
      } else {
#line 5564
        goto _L___10;
      }
    } else {
#line 5564
      goto _L___10;
    }
    {
#line 5582
    tmp___56 = sm_io_getinfo(f, 3, (void *)0);
#line 5582
    fchmod(tmp___56, (mode_t )mode);
#line 5587
    tmp___57 = sm_io_close(f, -2);
    }
#line 5587
    if (tmp___57 < 0) {
#line 5588
      if (ExitStat == 0) {
#line 5588
        ExitStat = 74;
      } else
#line 5588
      if (ExitStat == 75) {
#line 5588
        ExitStat = 74;
      }
    }
    {
#line 5589
    sm_io_flush(& SmIoF[1], -2);
#line 5590
    setuid(RealUid);
#line 5591
    exit(ExitStat);
    }
  } else {
    {
#line 5599
    st = waitfor(pid);
    }
#line 5600
    if (st == -1) {
      {
#line 5602
      syserr("mailfile: %s: wait", mailer->m_name);
      }
#line 5603
      return (70);
    }
#line 5605
    __u___0.__in = st;
#line 5605
    if ((__u___0.__i & 127) == 0) {
      {
#line 5607
      tmp___58 = __errno_location();
#line 5607
      *tmp___58 = 0;
#line 5608
      __u.__in = st;
      }
#line 5608
      return ((__u.__i & 65280) >> 8);
    } else {
      {
#line 5612
      syserr("mailfile: %s: child died on signal %d", mailer->m_name, st);
      }
#line 5614
      return (69);
    }
  }
#line 5618
  return (69);
}
}
#line 5621 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static void mailfiletimeout(int ignore ) 
{ 
  int *tmp ;

  {
  {
#line 5631
  tmp = __errno_location();
#line 5631
  *tmp = 110;
#line 5632
  siglongjmp((struct __jmp_buf_tag *)(CtxMailfileTimeout), 1);
  }
}
}
#line 5654 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
char *hostsignature(MAILER *m , char *host ) 
{ 
  register char *p ;
  register STAB *s ;
  time_t now ;
  char sep ;
  char prevsep ;
  int i ;
  int len___0 ;
  int nmx ;
  int hl ;
  char *hp ;
  char *endp ;
  int oldoptions ;
  struct __res_state *tmp ;
  char *mxhosts[101] ;
  unsigned short mxprefs[101] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct __res_state *tmp___4 ;
  int rcode ;
  int ttl ;
  int save_errno ;
  register struct mailer_con_info *mci ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  struct __res_state *tmp___17 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
  {
#line 5663
  sep = (char )':';
#line 5664
  prevsep = (char )':';
#line 5671
  tmp = __res_state();
#line 5671
  oldoptions = (int )tmp->options;
  }
#line 5676
  if ((int )tTdvect[17] >= 3) {
    {
#line 5677
    sm_dprintf((char *)"hostsignature(%s)\n", host);
    }
  }
#line 5683
  if (m->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int )))) {
    {
#line 5683
    tmp___0 = strcmp((char const   *)m->m_mailer, "[IPC]");
    }
#line 5683
    if (tmp___0 != 0) {
#line 5683
      if ((unsigned long )*(m->m_argv + 0) != (unsigned long )((void *)0)) {
        {
#line 5683
        tmp___1 = strcmp((char const   *)*(m->m_argv + 0), "TCP");
        }
#line 5683
        if (! (tmp___1 == 0)) {
#line 5686
          return ((char *)"localhost");
        }
      } else {
#line 5686
        return ((char *)"localhost");
      }
    }
  }
#line 5689
  if ((int )*host == 0) {
#line 5690
    return ((char *)"_empty_");
  }
  {
#line 5696
  tmp___3 = strcmp((char const   *)m->m_mailer, "[IPC]");
  }
#line 5696
  if (tmp___3 != 0) {
#line 5700
    return (host);
  } else
#line 5696
  if ((int )CurEnv->e_sendmode == 100) {
#line 5700
    return (host);
  } else
#line 5703
  if ((unsigned long )*(m->m_argv + 0) != (unsigned long )((void *)0)) {
    {
#line 5703
    tmp___2 = strcmp((char const   *)*(m->m_argv + 0), "FILE");
    }
#line 5703
    if (tmp___2 == 0) {
#line 5707
      return (host);
    }
  }
  {
#line 5715
  now = curtime();
#line 5716
  s = stab(host, 7, 1);
  }
#line 5717
  if ((unsigned long )s->s_value.sv_hostsig.hs_sig != (unsigned long )((void *)0)) {
#line 5719
    if (s->s_value.sv_hostsig.hs_exp >= now) {
#line 5721
      if ((int )tTdvect[17] >= 3) {
        {
#line 5722
        sm_dprintf((char *)"hostsignature(): stab(%s) found %s\n", host, s->s_value.sv_hostsig.hs_sig);
        }
      }
#line 5724
      return (s->s_value.sv_hostsig.hs_sig);
    }
    {
#line 5728
    sm_free_tagged((void *)s->s_value.sv_hostsig.hs_sig, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                   5728);
#line 5729
    s->s_value.sv_hostsig.hs_sig = (char *)((void *)0);
    }
  }
#line 5733
  s->s_value.sv_hostsig.hs_exp = now + 3600L;
#line 5740
  if (ConfigLevel < 2) {
    {
#line 5741
    tmp___4 = __res_state();
#line 5741
    tmp___4->options &= 0xfffffffffffffd7fUL;
    }
  }
#line 5743
  hp = host;
  {
#line 5743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5743
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
#line 5743
      goto while_break;
    }
    {
#line 5755
    endp = strpbrk((char const   *)hp, ":,");
    }
#line 5757
    if ((unsigned long )endp != (unsigned long )((void *)0)) {
#line 5759
      sep = *endp;
#line 5760
      *endp = (char )'\000';
    }
#line 5763
    if (m->m_flags[48UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 48UL % (8UL * sizeof(int )))) {
#line 5766
      nmx = 1;
#line 5767
      mxhosts[0] = hp;
    } else {
      {
#line 5774
      nmx = getmxrr(hp, mxhosts, mxprefs, 1, & rcode, 1, & ttl);
      }
#line 5776
      if (nmx <= 0) {
        {
#line 5782
        tmp___5 = __errno_location();
#line 5782
        save_errno = *tmp___5;
#line 5783
        mci = mci_get(hp, m);
#line 5784
        mci->mci_errno = (short )save_errno;
#line 5785
        tmp___6 = __h_errno_location();
#line 5785
        mci->mci_herrno = (short )*tmp___6;
#line 5786
        mci->mci_lastuse = now;
        }
#line 5787
        if (rcode == 68) {
          {
#line 5788
          mci_setstat(mci, rcode, (char *)"5.1.2", (char *)"550 Host unknown");
          }
        } else {
          {
#line 5791
          mci_setstat(mci, rcode, (char *)((void *)0), (char *)((void *)0));
          }
        }
#line 5794
        nmx = 1;
#line 5795
        mxhosts[0] = hp;
      }
#line 5797
      if ((int )tTdvect[17] >= 3) {
        {
#line 5798
        sm_dprintf((char *)"hostsignature(): getmxrr() returned %d, mxhosts[0]=%s\n",
                   nmx, mxhosts[0]);
        }
      }
#line 5806
      if (ttl < 3600) {
#line 5806
        tmp___7 = ttl;
      } else {
#line 5806
        tmp___7 = 3600;
      }
#line 5806
      s->s_value.sv_hostsig.hs_exp = now + (time_t )tmp___7;
    }
#line 5809
    len___0 = 0;
#line 5810
    i = 0;
    {
#line 5810
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5810
      if (! (i < nmx)) {
#line 5810
        goto while_break___0;
      }
      {
#line 5811
      tmp___8 = strlen((char const   *)mxhosts[i]);
#line 5811
      len___0 = (int )((size_t )len___0 + (tmp___8 + 1U));
#line 5810
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5812
    if ((unsigned long )s->s_value.sv_hostsig.hs_sig != (unsigned long )((void *)0)) {
      {
#line 5813
      tmp___9 = strlen((char const   *)s->s_value.sv_hostsig.hs_sig);
#line 5813
      len___0 = (int )((size_t )len___0 + (tmp___9 + 1U));
      }
    }
#line 5814
    if (len___0 < 0) {
      {
#line 5816
      sm_syslog(4, "*~*", "hostsignature for host \'%s\' exceeds maxlen (%d): %d",
                host, 8192, len___0);
#line 5818
      len___0 = 8192;
      }
    } else
#line 5814
    if (len___0 >= 8192) {
      {
#line 5816
      sm_syslog(4, "*~*", "hostsignature for host \'%s\' exceeds maxlen (%d): %d",
                host, 8192, len___0);
#line 5818
      len___0 = 8192;
      }
    }
    {
#line 5820
    tmp___10 = sm_malloc_tagged_x((size_t )len___0, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                                  5820, 0);
#line 5820
    p = (char *)tmp___10;
    }
#line 5821
    if ((unsigned long )s->s_value.sv_hostsig.hs_sig != (unsigned long )((void *)0)) {
      {
#line 5823
      sm_strlcpy(p, (char const   *)s->s_value.sv_hostsig.hs_sig, len___0);
#line 5824
      sm_free_tagged((void *)s->s_value.sv_hostsig.hs_sig, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c",
                     5824);
#line 5825
      s->s_value.sv_hostsig.hs_sig = p;
#line 5826
      tmp___11 = strlen((char const   *)p);
#line 5826
      hl = (int )tmp___11;
#line 5827
      p += hl;
#line 5828
      tmp___12 = p;
#line 5828
      p ++;
#line 5828
      *tmp___12 = prevsep;
#line 5829
      len___0 -= hl + 1;
      }
    } else {
#line 5832
      s->s_value.sv_hostsig.hs_sig = p;
    }
#line 5833
    i = 0;
    {
#line 5833
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5833
      if (! (i < nmx)) {
#line 5833
        goto while_break___1;
      }
      {
#line 5835
      tmp___13 = strlen((char const   *)mxhosts[i]);
#line 5835
      hl = (int )tmp___13;
      }
#line 5836
      if (len___0 - 1 < hl) {
#line 5839
        len___0 = -1;
#line 5840
        goto while_break___1;
      } else
#line 5836
      if (len___0 <= 1) {
#line 5839
        len___0 = -1;
#line 5840
        goto while_break___1;
      }
#line 5842
      if (i != 0) {
#line 5844
        if ((int )mxprefs[i] == (int )mxprefs[i - 1]) {
#line 5845
          tmp___14 = p;
#line 5845
          p ++;
#line 5845
          *tmp___14 = (char )',';
        } else {
#line 5847
          tmp___15 = p;
#line 5847
          p ++;
#line 5847
          *tmp___15 = (char )':';
        }
#line 5848
        len___0 --;
      }
      {
#line 5850
      sm_strlcpy(p, (char const   *)mxhosts[i], len___0);
#line 5851
      p += hl;
#line 5852
      len___0 -= hl;
#line 5833
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5861
    if (len___0 < 0) {
#line 5862
      goto while_break;
    }
#line 5863
    if ((unsigned long )endp != (unsigned long )((void *)0)) {
#line 5864
      tmp___16 = endp;
#line 5864
      endp ++;
#line 5864
      *tmp___16 = sep;
    }
#line 5865
    prevsep = sep;
#line 5743
    hp = endp;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5867
  makelower(s->s_value.sv_hostsig.hs_sig);
  }
#line 5868
  if (ConfigLevel < 2) {
    {
#line 5869
    tmp___17 = __res_state();
#line 5869
    tmp___17->options = (u_long )oldoptions;
    }
  }
#line 5878
  if ((int )tTdvect[17] >= 1) {
    {
#line 5879
    sm_dprintf((char *)"hostsignature(%s) = %s\n", host, s->s_value.sv_hostsig.hs_sig);
    }
  }
#line 5880
  return (s->s_value.sv_hostsig.hs_sig);
}
}
#line 5902 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/deliver.c"
static int parse_hostsignature(char *sig , char **mxhosts , MAILER *mailer ) 
{ 
  unsigned short curpref ;
  int nmx ;
  int i ;
  int j ;
  char *hp ;
  char *endp ;
  unsigned short prefer[100] ;
  long rndm[100] ;
  char sep ;
  bool tmp ;
  char *tmp___0 ;
  register unsigned short tempp ;
  register long tempr ;
  register char *temp1 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 5908
  curpref = (unsigned short)0;
#line 5909
  nmx = 0;
#line 5914
  hp = sig;
  {
#line 5914
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5914
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
#line 5914
      goto while_break;
    }
    {
#line 5916
    sep = (char )':';
#line 5928
    endp = strpbrk((char const   *)hp, ":,");
    }
#line 5930
    if ((unsigned long )endp != (unsigned long )((void *)0)) {
#line 5932
      sep = *endp;
#line 5933
      *endp = (char )'\000';
    }
    {
#line 5936
    *(mxhosts + nmx) = hp;
#line 5937
    prefer[nmx] = curpref;
#line 5938
    tmp = mci_match(hp, mailer);
    }
#line 5938
    if (tmp) {
#line 5939
      rndm[nmx] = 0L;
    } else {
      {
#line 5941
      rndm[nmx] = random();
      }
    }
#line 5943
    if ((unsigned long )endp != (unsigned long )((void *)0)) {
#line 5952
      if ((int )sep == 58) {
#line 5953
        curpref = (unsigned short )((int )curpref + 1);
      }
#line 5955
      tmp___0 = endp;
#line 5955
      endp ++;
#line 5955
      *tmp___0 = sep;
    }
#line 5957
    nmx ++;
#line 5957
    if (nmx >= 100) {
#line 5958
      goto while_break;
    }
#line 5914
    hp = endp;
  }
  while_break: /* CIL Label */ ;
  }
#line 5962
  i = 0;
  {
#line 5962
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5962
    if (! (i < nmx)) {
#line 5962
      goto while_break___0;
    }
#line 5964
    j = i + 1;
    {
#line 5964
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5964
      if (! (j < nmx)) {
#line 5964
        goto while_break___1;
      }
#line 5971
      if ((int )prefer[i] < (int )prefer[j]) {
#line 5972
        goto while_break___1;
      }
#line 5974
      if ((int )prefer[i] > (int )prefer[j]) {
#line 5974
        goto _L;
      } else
#line 5974
      if ((int )prefer[i] == (int )prefer[j]) {
#line 5974
        if (rndm[i] > rndm[j]) {
          _L: /* CIL Label */ 
#line 5981
          tempp = prefer[i];
#line 5982
          prefer[i] = prefer[j];
#line 5983
          prefer[j] = tempp;
#line 5984
          temp1 = *(mxhosts + i);
#line 5985
          *(mxhosts + i) = *(mxhosts + j);
#line 5986
          *(mxhosts + j) = temp1;
#line 5987
          tempr = rndm[i];
#line 5988
          rndm[i] = rndm[j];
#line 5989
          rndm[j] = tempr;
        }
      }
#line 5964
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5962
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5993
  return (nmx);
}
}
#line 466 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 791
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 192
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 522 "/usr/include/netdb.h"
extern int rresvport(int *__alport ) ;
#line 1722 "./sendmail.h"
void setup_daemon_milters(void) ;
#line 2196
char InetMode ;
#line 2320
char **ExternalEnviron ;
#line 2321
char **SaveArgv ;
#line 2416
void closecontrolsocket(bool fullclose ) ;
#line 2418
void control_command(int sock , ENVELOPE *e ) ;
#line 2419
int opencontrolsocket(void) ;
#line 2449
bool chkclientmodifiers(int flag ) ;
#line 2450
bool chkdaemonmodifiers(int flag ) ;
#line 2483
void dumpstate(char *when ) ;
#line 2498
char *getauthinfo(int fd , bool *may_be_forged ) ;
#line 2502
BITMAP256 *getrequests(ENVELOPE *e ) ;
#line 2512
bool isloopback(union bigsockaddr sa ) ;
#line 2525
struct hostent *myhostname(char *hostbuf___1 , int size ) ;
#line 2547
void restart_daemon(void) ;
#line 2567
void shutdown_daemon(void) ;
#line 2571
struct hostent *sm_gethostbyaddr(char *addr , int len___0 , int type ) ;
#line 93 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static void connecttimeout(int ignore ) ;
#line 94
static int opendaemonsocket(DAEMON_T *d , bool firsttime___0 ) ;
#line 95
static unsigned short setupdaemon(union bigsockaddr *daemonaddr ) ;
#line 96
static void getrequests_checkdiskspace(ENVELOPE *e ) ;
#line 97
static void setsockaddroptions(char *p , DAEMON_T *d ) ;
#line 98
static void printdaemonflags(DAEMON_T *d ) ;
#line 99
static int addr_family(char *addr ) ;
#line 100
static int addrcmp(struct hostent *hp , char *ha , union bigsockaddr *sa ) ;
#line 101
static void authtimeout(int ignore ) ;
#line 131 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static DAEMON_T Daemons[10]  ;
#line 132 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static int NDaemons  =    0;
#line 134 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static time_t NextDiskSpaceCheck  =    (time_t )0;
#line 173
int ControlSocket ;
#line 176
bool refuseconnections(char *name , ENVELOPE *e , int d , bool active ) ;
#line 156 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
BITMAP256 *getrequests(ENVELOPE *e ) 
{ 
  int t ;
  int idx ;
  int curdaemon ;
  int i ;
  int olddaemon ;
  bool j_has_dot ;
  char status[2048] ;
  union bigsockaddr sa ;
  int len___0 ;
  uint16_t tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char jbuf[64] ;
  char *tmp___3 ;
  register pid_t pid ;
  int lotherend ;
  bool timedout ;
  bool control ;
  int save_errno ;
  int pipefd[2] ;
  time_t now ;
  bool tmp___4 ;
  char jbuf___0[64] ;
  char *tmp___5 ;
  bool tmp___6 ;
  bool setproc ;
  int highest ;
  fd_set readfds ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  bool tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  register char __result ;
  struct sockaddr_un sa_un ;
  int *tmp___10 ;
  register char __result___0 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *p ;
  SM_FILE_T *inchannel ;
  SM_FILE_T *outchannel ;
  char *tmp___20 ;
  int tmp___21 ;
  uint16_t tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char c ;
  ssize_t tmp___25 ;
  int *tmp___26 ;
  size_t tmp___27 ;
  char const   *tmp___29 ;
  int *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *addr ;
  char family[5] ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  bool tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  void *__cil_tmp81 ;
  void *__cil_tmp82 ;
  void *__cil_tmp83 ;
  void *__cil_tmp84 ;
  void *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;

  {
  {
#line 161
  curdaemon = -1;
#line 162
  olddaemon = 0;
#line 168
  len___0 = (int )sizeof(sa);
#line 180
  init_qid_alg();
#line 181
  idx = 0;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (idx < NDaemons)) {
#line 181
      goto while_break;
    }
    {
#line 183
    Daemons[idx].d_port = setupdaemon(& Daemons[idx].d_addr);
#line 184
    Daemons[idx].d_firsttime = 1;
#line 185
    Daemons[idx].d_refuse_connections_until = (time_t )0;
#line 181
    idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if ((int )tTdvect[15] >= 1) {
#line 194
    idx = 0;
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 194
      if (! (idx < NDaemons)) {
#line 194
        goto while_break___0;
      }
      {
#line 196
      tmp = ntohs(Daemons[idx].d_port);
#line 196
      sm_dprintf((char *)"getrequests: daemon %s: port %d\n", Daemons[idx].d_name,
                 (int )tmp);
#line 194
      idx ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 203
  idx = 0;
  {
#line 203
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 203
    if (! (idx < NDaemons)) {
#line 203
      goto while_break___1;
    }
    {
#line 204
    Daemons[idx].d_socksize = opendaemonsocket(& Daemons[idx], 1);
#line 203
    idx ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 206
  tmp___2 = opencontrolsocket();
  }
#line 206
  if (tmp___2 < 0) {
    {
#line 207
    tmp___0 = __errno_location();
#line 207
    tmp___1 = sm_errstring(*tmp___0);
#line 207
    sm_syslog(4, "*~*", "daemon could not open control socket %s: %s", ControlSocketName,
              tmp___1);
    }
  }
  {
#line 212
  sm_signal(17, & reapchild);
#line 215
  log_sendmail_pid(e);
#line 221
  expand((char *)"\201j", jbuf, (size_t )sizeof(jbuf), e);
#line 222
  tmp___3 = strchr((char const   *)(jbuf), '.');
#line 222
  j_has_dot = (unsigned long )tmp___3 != (unsigned long )((void *)0);
#line 227
  proc_list_add(CurrentPid, (char *)"Sendmail daemon", 1, 0, -1, (union bigsockaddr *)((void *)0));
  }
#line 229
  if ((int )tTdvect[15] >= 1) {
#line 231
    idx = 0;
    {
#line 231
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 231
      if (! (idx < NDaemons)) {
#line 231
        goto while_break___2;
      }
      {
#line 232
      sm_dprintf((char *)"getrequests: daemon %s: %d\n", Daemons[idx].d_name, Daemons[idx].d_socket);
#line 231
      idx ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 237
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 241
    timedout = 0;
#line 242
    control = 0;
#line 251
    sm_blocksignal(14);
    }
    {
#line 252
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 252
      if ((unsigned long )ShutdownRequest != (unsigned long )((void *)0)) {
        {
#line 252
        shutdown_daemon();
        }
      } else
#line 252
      if ((unsigned long )RestartRequest != (unsigned long )((void *)0)) {
        {
#line 252
        restart_daemon();
        }
      } else
#line 252
      if (RestartWorkGroup) {
        {
#line 252
        restart_marked_work_groups();
        }
      }
#line 252
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 254
    idx = 0;
    {
#line 254
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 254
      if (! (idx < NDaemons)) {
#line 254
        goto while_break___5;
      }
      {
#line 261
      now = curtime();
      }
#line 262
      if (now < Daemons[idx].d_refuse_connections_until) {
#line 263
        goto __Cont;
      }
#line 264
      if (Daemons[idx].d_flags[2UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 2UL % (8UL * sizeof(int )))) {
#line 265
        goto __Cont;
      }
      {
#line 266
      tmp___4 = refuseconnections(Daemons[idx].d_name, e, idx, curdaemon == idx);
      }
#line 266
      if (tmp___4) {
#line 269
        if (Daemons[idx].d_socket >= 0) {
          {
#line 272
          close(Daemons[idx].d_socket);
#line 273
          Daemons[idx].d_socket = -1;
          }
        }
#line 277
        Daemons[idx].d_refuse_connections_until = now + 15L;
      } else
#line 279
      if (Daemons[idx].d_socket < 0) {
#line 279
        goto _L;
      } else
#line 279
      if (Daemons[idx].d_firsttime) {
        _L: /* CIL Label */ 
#line 282
        if (! Daemons[idx].d_firsttime) {
#line 282
          if (LogLevel > 8) {
            {
#line 283
            sm_syslog(6, "*~*", "accepting connections again for daemon %s", Daemons[idx].d_name);
            }
          }
        }
        {
#line 288
        opendaemonsocket(& Daemons[idx], 0);
#line 289
        Daemons[idx].d_firsttime = 0;
        }
      }
      __Cont: /* CIL Label */ 
#line 254
      idx ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 294
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 294
      if ((unsigned long )ShutdownRequest != (unsigned long )((void *)0)) {
        {
#line 294
        shutdown_daemon();
        }
      } else
#line 294
      if ((unsigned long )RestartRequest != (unsigned long )((void *)0)) {
        {
#line 294
        restart_daemon();
        }
      } else
#line 294
      if (RestartWorkGroup) {
        {
#line 294
        restart_marked_work_groups();
        }
      }
#line 294
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 296
    getrequests_checkdiskspace(e);
#line 303
    expand((char *)"\201j", jbuf___0, (size_t )sizeof(jbuf___0), e);
#line 304
    tmp___6 = wordinclass(jbuf___0, 'w');
    }
#line 304
    if (tmp___6) {
#line 311
      if (j_has_dot) {
        {
#line 311
        tmp___5 = strchr((char const   *)(jbuf___0), '.');
        }
#line 311
        if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
          {
#line 313
          dumpstate((char *)"daemon $j lost dot");
#line 314
          sm_syslog(1, "*~*", "daemon process $j lost dot; see syslog");
#line 316
          abort();
          }
        }
      }
    } else {
      {
#line 306
      dumpstate((char *)"daemon lost $j");
#line 307
      sm_syslog(1, "*~*", "daemon process doesn\'t have $j in $=w; see syslog");
#line 309
      abort();
      }
    }
    {
#line 332
    sm_releasesignal(14);
    }
    {
#line 334
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 336
      setproc = 0;
#line 337
      highest = -1;
      {
#line 341
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 341
        if ((unsigned long )ShutdownRequest != (unsigned long )((void *)0)) {
          {
#line 341
          shutdown_daemon();
          }
        } else
#line 341
        if ((unsigned long )RestartRequest != (unsigned long )((void *)0)) {
          {
#line 341
          restart_daemon();
          }
        } else
#line 341
        if (RestartWorkGroup) {
          {
#line 341
          restart_marked_work_groups();
          }
        }
#line 341
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 342
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 342
        __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0),
                             "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& readfds.__fds_bits[0]): "memory");
#line 342
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 343
      idx = 0;
      {
#line 343
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 343
        if (! (idx < NDaemons)) {
#line 343
          goto while_break___10;
        }
#line 346
        if (Daemons[idx].d_socket >= 0) {
#line 348
          if (! setproc) {
#line 348
            if (! (Daemons[idx].d_flags[1UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 1UL % (8UL * sizeof(int ))))) {
              {
#line 352
              sm_setproctitle(1, e, "accepting connections");
#line 354
              setproc = 1;
              }
            }
          }
#line 356
          if (Daemons[idx].d_socket > highest) {
#line 357
            highest = Daemons[idx].d_socket;
          }
#line 358
          __asm__  volatile   ("btsl %1,%0": "=m" (readfds.__fds_bits[(unsigned long )Daemons[idx].d_socket / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )Daemons[idx].d_socket % (8UL * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
#line 343
        idx ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 364
      if (ControlSocket >= 0) {
#line 366
        if (ControlSocket > highest) {
#line 367
          highest = ControlSocket;
        }
#line 368
        __asm__  volatile   ("btsl %1,%0": "=m" (readfds.__fds_bits[(unsigned long )ControlSocket / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )ControlSocket % (8UL * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
      {
#line 372
      timeout.tv_sec = (__time_t )5;
#line 373
      timeout.tv_usec = (__suseconds_t )0;
#line 375
      t = select(highest + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
      }
      {
#line 379
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 379
        if ((unsigned long )ShutdownRequest != (unsigned long )((void *)0)) {
          {
#line 379
          shutdown_daemon();
          }
        } else
#line 379
        if ((unsigned long )RestartRequest != (unsigned long )((void *)0)) {
          {
#line 379
          restart_daemon();
          }
        } else
#line 379
        if (RestartWorkGroup) {
          {
#line 379
          restart_marked_work_groups();
          }
        }
#line 379
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 381
      curdaemon = -1;
#line 382
      tmp___7 = doqueuerun();
      }
#line 382
      if (tmp___7) {
        {
#line 384
        runqueue(1, 0, 0, 0);
        }
      }
#line 406
      if (t <= 0) {
#line 408
        timedout = 1;
#line 409
        goto while_break___7;
      }
      {
#line 412
      control = 0;
#line 413
      tmp___8 = __errno_location();
#line 413
      *tmp___8 = 0;
#line 416
      idx = olddaemon + 1;
      }
#line 416
      if (idx >= NDaemons) {
#line 417
        idx = 0;
      }
#line 418
      i = 0;
      {
#line 418
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 418
        if (! (i < NDaemons)) {
#line 418
          goto while_break___12;
        }
#line 421
        if (Daemons[idx].d_socket >= 0) {
#line 421
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned long )Daemons[idx].d_socket % (8UL * sizeof(__fd_mask ))),
                               "m" (readfds.__fds_bits[(unsigned long )Daemons[idx].d_socket / (8UL * sizeof(__fd_mask ))]): "cc");
#line 421
          if (__result) {
            {
#line 424
            lotherend = Daemons[idx].d_socksize;
#line 425
            memset((void *)(& RealHostAddr), '\000', (size_t )sizeof(RealHostAddr));
#line 427
            t = accept(Daemons[idx].d_socket, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& RealHostAddr)),
                       (socklen_t */* __restrict  */)(& lotherend));
            }
#line 437
            if (t >= 0) {
#line 437
              if (lotherend == 0) {
                {
#line 444
                close(t);
#line 445
                t = -1;
#line 446
                tmp___9 = __errno_location();
#line 446
                *tmp___9 = 22;
                }
              } else
#line 437
              if ((int )RealHostAddr.sa.sa_family != (int )Daemons[idx].d_addr.sa.sa_family) {
                {
#line 444
                close(t);
#line 445
                t = -1;
#line 446
                tmp___9 = __errno_location();
#line 446
                *tmp___9 = 22;
                }
              }
            }
#line 448
            curdaemon = idx;
#line 448
            olddaemon = curdaemon;
#line 449
            goto while_break___12;
          }
        }
#line 451
        idx ++;
#line 451
        if (idx >= NDaemons) {
#line 452
          idx = 0;
        }
#line 418
        i ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 456
      if (curdaemon == -1) {
#line 456
        if (ControlSocket >= 0) {
#line 456
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned long )ControlSocket % (8UL * sizeof(__fd_mask ))),
                               "m" (readfds.__fds_bits[(unsigned long )ControlSocket / (8UL * sizeof(__fd_mask ))]): "cc");
#line 456
          if (__result___0) {
            {
#line 460
            lotherend = (int )sizeof(sa_un);
#line 461
            memset((void *)(& sa_un), '\000', (size_t )sizeof(sa_un));
#line 462
            t = accept(ControlSocket, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sa_un)),
                       (socklen_t */* __restrict  */)(& lotherend));
            }
#line 472
            if (t >= 0) {
#line 472
              if (lotherend == 0) {
                {
#line 479
                close(t);
#line 480
                t = -1;
#line 481
                tmp___10 = __errno_location();
#line 481
                *tmp___10 = 22;
                }
              } else
#line 472
              if ((int )sa_un.sun_family != 1) {
                {
#line 479
                close(t);
#line 480
                t = -1;
#line 481
                tmp___10 = __errno_location();
#line 481
                *tmp___10 = 22;
                }
              }
            }
#line 483
            if (t >= 0) {
#line 484
              control = 1;
            }
          }
        }
      }
#line 493
      if (t >= 0) {
#line 494
        goto while_break___7;
      } else {
        {
#line 493
        tmp___11 = __errno_location();
        }
#line 493
        if (*tmp___11 != 4) {
#line 494
          goto while_break___7;
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 496
    if (timedout) {
#line 498
      timedout = 0;
#line 499
      goto __Cont___0;
    }
    {
#line 501
    tmp___12 = __errno_location();
#line 501
    save_errno = *tmp___12;
#line 502
    sm_blocksignal(14);
    }
#line 503
    if (t < 0) {
      {
#line 505
      tmp___13 = __errno_location();
#line 505
      *tmp___13 = save_errno;
      }
#line 508
      if (save_errno == 4) {
#line 519
        goto __Cont___0;
      } else
#line 508
      if (save_errno == 11) {
#line 519
        goto __Cont___0;
      } else
#line 508
      if (save_errno == 103) {
#line 519
        goto __Cont___0;
      } else
#line 508
      if (save_errno == 11) {
#line 519
        goto __Cont___0;
      }
      {
#line 521
      syserr("getrequests: accept");
#line 524
      close(Daemons[curdaemon].d_socket);
#line 525
      Daemons[curdaemon].d_socket = -1;
      }
#line 535
      goto __Cont___0;
    }
#line 538
    if (! control) {
      {
#line 543
      if ((int )Daemons[curdaemon].d_addr.sa.sa_family == 0) {
#line 543
        goto case_0;
      }
#line 556
      if ((int )Daemons[curdaemon].d_addr.sa.sa_family == 2) {
#line 556
        goto case_2;
      }
#line 541
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 544
      tmp___14 = macid_parse((char *)"{daemon_family}", (char **)((void *)0));
#line 544
      macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___14, (char *)"unspec",
                       (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                       545, SmHeapGroup);
      }
#line 546
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 557
      tmp___15 = macid_parse((char *)"{daemon_family}", (char **)((void *)0));
#line 557
      macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___15, (char *)"inet",
                       (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                       558, SmHeapGroup);
      }
#line 559
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 586
      tmp___16 = macid_parse((char *)"{daemon_name}", (char **)((void *)0));
#line 586
      macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___16, Daemons[curdaemon].d_name,
                       (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                       588, SmHeapGroup);
      }
#line 589
      if ((unsigned long )Daemons[curdaemon].d_mflags != (unsigned long )((void *)0)) {
        {
#line 590
        tmp___17 = macid_parse((char *)"{daemon_flags}", (char **)((void *)0));
#line 590
        macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___17, Daemons[curdaemon].d_mflags,
                         (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                         592, SmHeapGroup);
        }
      } else {
        {
#line 594
        tmp___18 = macid_parse((char *)"{daemon_flags}", (char **)((void *)0));
#line 594
        macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___18, (char *)"",
                         (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                         595, SmHeapGroup);
        }
      }
    }
    {
#line 606
    connection_rate_check(& RealHostAddr, (ENVELOPE *)((void *)0));
    }
#line 612
    if ((int )tTdvect[15] >= 2) {
      {
#line 613
      sm_dprintf((char *)"getrequests: forking (fd = %d)\n", t);
      }
    }
    {
#line 630
    random();
    }
#line 640
    if ((unsigned long )FallbackMX != (unsigned long )((void *)0)) {
      {
#line 641
      getfallbackmxrr(FallbackMX);
      }
    }
#line 644
    if ((int )tTdvect[93] >= 100) {
#line 647
      pid = 0;
#line 648
      pipefd[1] = -1;
#line 648
      pipefd[0] = pipefd[1];
    } else {
      {
#line 659
      tmp___19 = pipe((int *)(pipefd));
      }
#line 659
      if (tmp___19 < 0) {
#line 660
        pipefd[1] = -1;
#line 660
        pipefd[0] = pipefd[1];
      }
      {
#line 662
      sm_blocksignal(17);
#line 663
      pid = fork();
      }
#line 664
      if (pid < 0) {
        {
#line 666
        syserr("daemon: cannot fork");
        }
#line 667
        if (pipefd[0] != -1) {
          {
#line 669
          close(pipefd[0]);
#line 670
          close(pipefd[1]);
          }
        }
        {
#line 672
        sm_releasesignal(17);
#line 673
        sleep(10U);
#line 674
        close(t);
        }
#line 675
        goto __Cont___0;
      }
    }
#line 679
    if (pid == 0) {
      {
#line 682
      outchannel = (SM_FILE_T *)((void *)0);
#line 691
      RestartRequest = (char */* volatile  */)((void *)0);
#line 692
      RestartWorkGroup = (bool volatile   )0;
#line 693
      ShutdownRequest = (char */* volatile  */)((void *)0);
#line 694
      PendingSignal = (int volatile   )0;
#line 695
      CurrentPid = getpid();
#line 696
      close_sendmail_pid();
#line 698
      sm_releasesignal(14);
#line 699
      sm_releasesignal(17);
#line 700
      sm_signal(17, (void (*)(int  ))0);
#line 701
      sm_signal(1, (void (*)(int  ))0);
#line 702
      sm_signal(15, & intsig);
#line 712
      sm_exc_newthread(& fatal_error);
      }
#line 714
      if (! control) {
        {
#line 716
        tmp___20 = anynet_ntoa(& Daemons[curdaemon].d_addr);
#line 716
        tmp___21 = macid_parse((char *)"{daemon_addr}", (char **)((void *)0));
#line 716
        macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___21, tmp___20,
                         (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                         718, SmHeapGroup);
#line 719
        tmp___22 = ntohs(Daemons[curdaemon].d_port);
#line 719
        sm_snprintf(status, (size_t )sizeof(status), "%d", (int )tmp___22);
#line 721
        tmp___23 = macid_parse((char *)"{daemon_port}", (char **)((void *)0));
#line 721
        macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___23, status,
                         (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                         722, SmHeapGroup);
        }
      }
#line 725
      idx = 0;
      {
#line 725
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 725
        if (! (idx < NDaemons)) {
#line 725
          goto while_break___13;
        }
#line 727
        if (Daemons[idx].d_socket >= 0) {
          {
#line 728
          close(Daemons[idx].d_socket);
          }
        }
#line 729
        Daemons[idx].d_socket = -1;
#line 725
        idx ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 731
      clrcontrol();
      }
#line 734
      if (control) {
        {
#line 737
        proc_list_add(CurrentPid, (char *)"console socket child", 5, 0, -1, (union bigsockaddr *)((void *)0));
        }
      } else {
        {
#line 743
        proc_list_clear();
#line 746
        sm_signal(17, & reapchild);
#line 749
        proc_list_add(CurrentPid, (char *)"daemon child", 2, 0, -1, (union bigsockaddr *)((void *)0));
#line 753
        QueueIntvl = (time_t )0;
#line 765
        tmp___24 = anynet_ntoa(& RealHostAddr);
#line 765
        sm_setproctitle(1, e, "startup with %s", tmp___24);
        }
      }
#line 769
      if (pipefd[0] != -1) {
        {
#line 782
        close(pipefd[1]);
        }
        {
#line 785
        while (1) {
          while_continue___14: /* CIL Label */ ;
          {
#line 785
          tmp___25 = read(pipefd[0], (void *)(& c), (size_t )1);
          }
#line 785
          if (tmp___25 < 0) {
            {
#line 785
            tmp___26 = __errno_location();
            }
#line 785
            if (! (*tmp___26 == 4)) {
#line 785
              goto while_break___14;
            }
          } else {
#line 785
            goto while_break___14;
          }
#line 787
          goto while_continue___14;
        }
        while_break___14: /* CIL Label */ ;
        }
        {
#line 788
        close(pipefd[0]);
        }
      }
#line 792
      if (control) {
        {
#line 794
        control_command(t, e);
#line 796
        exit(70);
        }
      }
      {
#line 800
      p = hostnamebyanyaddr(& RealHostAddr);
#line 801
      tmp___27 = strlen((char const   *)p);
      }
#line 801
      if (tmp___27 > 256U) {
#line 802
        *(p + 256) = (char )'\000';
      }
      {
#line 803
      RealHostName = newstr((char const   *)p);
      }
#line 804
      if ((int )*(RealHostName + 0) == 91) {
        {
#line 806
        tmp___30 = __h_errno_location();
        }
#line 806
        if (*tmp___30 == 2) {
#line 806
          tmp___29 = "TEMP";
        } else {
#line 806
          tmp___29 = "FAIL";
        }
        {
#line 806
        tmp___31 = macid_parse((char *)"{client_resolve}", (char **)((void *)0));
#line 806
        macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___31, (char *)tmp___29,
                         (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                         808, SmHeapGroup);
        }
      } else {
        {
#line 812
        tmp___32 = macid_parse((char *)"{client_resolve}", (char **)((void *)0));
#line 812
        macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___32, (char *)"OK",
                         (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                         813, SmHeapGroup);
        }
      }
      {
#line 815
      sm_setproctitle(1, e, "startup with %s", p);
#line 816
      markstats(e, (ADDRESS *)((void *)0), 'c');
#line 818
      inchannel = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& t)),
                             2, (void const   *)((void *)0));
      }
#line 818
      if ((unsigned long )inchannel == (unsigned long )((void *)0)) {
        {
#line 830
        syserr("cannot open SMTP server channel, fd=%d", t);
#line 832
        finis(0, 1, (int volatile   )0);
        }
      } else {
        {
#line 818
        t = dup(t);
        }
#line 818
        if (t < 0) {
          {
#line 830
          syserr("cannot open SMTP server channel, fd=%d", t);
#line 832
          finis(0, 1, (int volatile   )0);
          }
        } else {
          {
#line 818
          outchannel = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& t)),
                                  3, (void const   *)((void *)0));
          }
#line 818
          if ((unsigned long )outchannel == (unsigned long )((void *)0)) {
            {
#line 830
            syserr("cannot open SMTP server channel, fd=%d", t);
#line 832
            finis(0, 1, (int volatile   )0);
            }
          }
        }
      }
      {
#line 834
      sm_io_automode(inchannel, outchannel);
#line 836
      InChannel = inchannel;
#line 837
      OutChannel = outchannel;
#line 838
      DisConnected = 0;
#line 848
      tmp___42 = sm_io_getinfo(InChannel, 3, (void *)0);
#line 848
      tmp___43 = getsockname(tmp___42, (struct sockaddr */* __restrict  */)(& sa.sa),
                             (socklen_t */* __restrict  */)(& len___0));
      }
#line 848
      if (tmp___43 == 0) {
        {
#line 851
        p = hostnamebyanyaddr(& sa);
        }
#line 852
        if ((int )tTdvect[15] >= 9) {
          {
#line 853
          sm_dprintf((char *)"getreq: got name %s\n", p);
          }
        }
        {
#line 854
        tmp___33 = macid_parse((char *)"{if_name}", (char **)((void *)0));
#line 854
        macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___33, p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                         855, SmHeapGroup);
#line 862
        tmp___38 = isloopback(sa);
        }
#line 862
        if (tmp___38) {
          {
#line 883
          tmp___36 = macid_parse((char *)"{if_addr}", (char **)((void *)0));
#line 883
          macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___36, (char *)((void *)0),
                           (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                           885, SmHeapGroup);
#line 886
          tmp___37 = macid_parse((char *)"{if_family}", (char **)((void *)0));
#line 886
          macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___37, (char *)((void *)0),
                           (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                           888, SmHeapGroup);
          }
        } else {
          {
#line 867
          addr = anynet_ntoa(& sa);
#line 868
          sm_snprintf(family, (size_t )sizeof(family), "%d", (int )sa.sa.sa_family);
#line 871
          tmp___34 = macid_parse((char *)"{if_addr}", (char **)((void *)0));
#line 871
          macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___34, addr,
                           (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                           873, SmHeapGroup);
#line 874
          tmp___35 = macid_parse((char *)"{if_family}", (char **)((void *)0));
#line 874
          macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___35, family,
                           (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                           876, SmHeapGroup);
          }
#line 877
          if ((int )tTdvect[15] >= 7) {
            {
#line 878
            sm_dprintf((char *)"getreq: got addr %s and family %s\n", addr, family);
            }
          }
        }
      } else {
#line 893
        if ((int )tTdvect[15] >= 7) {
          {
#line 894
          sm_dprintf((char *)"getreq: getsockname failed\n");
          }
        }
        {
#line 895
        tmp___39 = macid_parse((char *)"{if_name}", (char **)((void *)0));
#line 895
        macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___39, (char *)((void *)0),
                         (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                         896, SmHeapGroup);
#line 897
        tmp___40 = macid_parse((char *)"{if_addr}", (char **)((void *)0));
#line 897
        macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___40, (char *)((void *)0),
                         (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                         898, SmHeapGroup);
#line 899
        tmp___41 = macid_parse((char *)"{if_family}", (char **)((void *)0));
#line 899
        macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___41, (char *)((void *)0),
                         (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                         900, SmHeapGroup);
        }
      }
#line 902
      goto while_break___3;
    }
#line 906
    if (control) {
      {
#line 908
      sm_snprintf(status, (size_t )sizeof(status), "control socket server child");
#line 910
      proc_list_add(pid, status, 4, 0, -1, (union bigsockaddr *)((void *)0));
      }
    } else {
      {
#line 914
      tmp___44 = anynet_ntoa(& RealHostAddr);
#line 914
      sm_snprintf(status, (size_t )sizeof(status), "SMTP server child for %s", tmp___44);
#line 917
      proc_list_add(pid, status, 1, 0, -1, & RealHostAddr);
      }
    }
    {
#line 920
    sm_releasesignal(17);
    }
#line 923
    if (pipefd[0] != -1) {
      {
#line 925
      close(pipefd[0]);
#line 926
      pipefd[0] = -1;
      }
    }
    {
#line 930
    close(t);
    }
#line 933
    if (pipefd[1] != -1) {
      {
#line 935
      close(pipefd[1]);
#line 936
      pipefd[1] = -1;
      }
    }
    __Cont___0: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 939
  if ((int )tTdvect[15] >= 2) {
    {
#line 940
    sm_dprintf((char *)"getreq: returning\n");
    }
  }
#line 944
  if ((unsigned long )Daemons[curdaemon].d_inputfilterlist != (unsigned long )((void *)0)) {
#line 946
    i = 0;
    {
#line 946
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 946
      if (i < 25) {
#line 946
        if (! ((unsigned long )Daemons[curdaemon].d_inputfilters[i] != (unsigned long )((void *)0))) {
#line 946
          goto while_break___15;
        }
      } else {
#line 946
        goto while_break___15;
      }
#line 951
      InputFilters[i] = Daemons[curdaemon].d_inputfilters[i];
#line 946
      i ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 953
    if (i < 25) {
#line 954
      InputFilters[i] = (struct milter *)((void *)0);
    }
  }
#line 957
  return (& Daemons[curdaemon].d_flags);
}
}
#line 973 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static void getrequests_checkdiskspace(ENVELOPE *e ) 
{ 
  bool logged___0 ;
  int idx ;
  time_t now ;
  bool tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 977
  logged___0 = 0;
#line 981
  now = curtime();
  }
#line 982
  if (now < NextDiskSpaceCheck) {
#line 983
    return;
  }
  {
#line 986
  tmp = enoughdiskspace(0L, (ENVELOPE *)((void *)0));
  }
#line 986
  if (tmp) {
#line 1010
    idx = 0;
    {
#line 1010
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1010
      if (! (idx < NDaemons)) {
#line 1010
        goto while_break;
      }
#line 1012
      if (! (Daemons[idx].d_flags[1UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 1UL % (8UL * sizeof(int ))))) {
#line 1013
        goto __Cont___0;
      }
#line 1016
      if (! logged___0) {
#line 1018
        if (LogLevel > 8) {
          {
#line 1019
          sm_syslog(6, "*~*", "accepting new messages (again)");
          }
        }
#line 1021
        logged___0 = 1;
      }
#line 1025
      Daemons[idx].d_flags[1UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] &= ~ (1U << 1UL % (8UL * sizeof(int )));
      __Cont___0: /* CIL Label */ 
#line 1010
      idx ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 988
    idx = 0;
    {
#line 988
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 988
      if (! (idx < NDaemons)) {
#line 988
        goto while_break___0;
      }
#line 990
      if (Daemons[idx].d_flags[1UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 1UL % (8UL * sizeof(int )))) {
#line 991
        goto __Cont;
      }
#line 994
      if (! logged___0) {
#line 996
        if (LogLevel > 8) {
          {
#line 997
          sm_syslog(6, "*~*", "rejecting new messages: min free: %ld", MinBlocksFree);
          }
        }
        {
#line 1000
        sm_setproctitle(1, e, "rejecting new messages: min free: %ld", MinBlocksFree);
#line 1003
        logged___0 = 1;
        }
      }
#line 1005
      Daemons[idx].d_flags[1UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 1UL % (8UL * sizeof(int ));
      __Cont: /* CIL Label */ 
#line 988
      idx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1030
  NextDiskSpaceCheck = now + 60L;
#line 1031
  return;
}
}
#line 1052 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static int opendaemonsocket(DAEMON_T *d , bool firsttime___0 ) 
{ 
  int on ;
  int fdflags ;
  int socksize ;
  int ntries ;
  int save_errno ;
  int *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  bool tmp___12 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 1057
  on = 1;
#line 1059
  socksize = 0;
#line 1060
  ntries = 0;
#line 1063
  if ((int )tTdvect[15] >= 2) {
    {
#line 1064
    sm_dprintf((char *)"opendaemonsocket(%s)\n", d->d_name);
    }
  }
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1068
    if (ntries > 0) {
      {
#line 1069
      sleep(5U);
      }
    }
#line 1070
    if (firsttime___0) {
#line 1070
      goto _L___0;
    } else
#line 1070
    if (d->d_socket < 0) {
      _L___0: /* CIL Label */ 
      {
#line 1098
      d->d_socket = socket((int )d->d_addr.sa.sa_family, 1, 0);
      }
#line 1100
      if (d->d_socket < 0) {
        {
#line 1102
        tmp = __errno_location();
#line 1102
        save_errno = *tmp;
#line 1103
        syserr("opendaemonsocket: daemon %s: can\'t create server SMTP socket", d->d_name);
        }
        fail: 
#line 1106
        if (d->d_flags[79UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 79UL % (8UL * sizeof(int )))) {
          {
#line 1106
          tmp___0 = transienterror(save_errno);
          }
#line 1106
          if (tmp___0) {
#line 1106
            if (ntries >= 9) {
              {
#line 1110
              syserr("opendaemonsocket: daemon %s: optional socket disabled", d->d_name);
#line 1112
              d->d_flags[2UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 2UL % (8UL * sizeof(int ));
#line 1113
              d->d_socket = -1;
              }
#line 1114
              return (-1);
            }
          } else {
            {
#line 1110
            syserr("opendaemonsocket: daemon %s: optional socket disabled", d->d_name);
#line 1112
            d->d_flags[2UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 2UL % (8UL * sizeof(int ));
#line 1113
            d->d_socket = -1;
            }
#line 1114
            return (-1);
          }
        }
        severe: 
#line 1117
        if (LogLevel > 0) {
          {
#line 1118
          sm_syslog(1, "*~*", "daemon %s: problem creating SMTP socket", d->d_name);
          }
        }
#line 1121
        d->d_socket = -1;
#line 1122
        goto __Cont;
      }
#line 1125
      if (d->d_socket >= 1024) {
        {
#line 1127
        save_errno = 22;
#line 1128
        syserr("opendaemonsocket: daemon %s: server SMTP socket (%d) too large", d->d_name,
               d->d_socket);
        }
#line 1130
        goto fail;
      }
#line 1134
      if ((int )tTdvect[15] >= 101) {
        {
#line 1135
        setsockopt(d->d_socket, 1, 1, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
        }
      }
      {
#line 1139
      setsockopt(d->d_socket, 1, 2, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
#line 1141
      setsockopt(d->d_socket, 1, 9, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
      }
#line 1145
      if (d->d_tcprcvbufsize > 0) {
        {
#line 1147
        tmp___1 = setsockopt(d->d_socket, 1, 8, (void const   *)((char *)(& d->d_tcprcvbufsize)),
                             (socklen_t )sizeof(d->d_tcprcvbufsize));
        }
#line 1147
        if (tmp___1 < 0) {
          {
#line 1151
          syserr("opendaemonsocket: daemon %s: setsockopt(SO_RCVBUF)", d->d_name);
          }
        }
      }
#line 1155
      if (d->d_tcpsndbufsize > 0) {
        {
#line 1157
        tmp___2 = setsockopt(d->d_socket, 1, 7, (void const   *)((char *)(& d->d_tcpsndbufsize)),
                             (socklen_t )sizeof(d->d_tcpsndbufsize));
        }
#line 1157
        if (tmp___2 < 0) {
          {
#line 1161
          syserr("opendaemonsocket: daemon %s: setsockopt(SO_SNDBUF)", d->d_name);
          }
        }
      }
      {
#line 1165
      fdflags = fcntl(d->d_socket, 1, 0);
      }
#line 1165
      if (fdflags == -1) {
#line 1165
        goto _L;
      } else {
        {
#line 1165
        tmp___6 = fcntl(d->d_socket, 2, fdflags | 1);
        }
#line 1165
        if (tmp___6 == -1) {
          _L: /* CIL Label */ 
          {
#line 1169
          tmp___3 = __errno_location();
#line 1169
          save_errno = *tmp___3;
#line 1170
          tmp___4 = sm_errstring(save_errno);
          }
#line 1170
          if (fdflags == -1) {
#line 1170
            tmp___5 = "get";
          } else {
#line 1170
            tmp___5 = "set";
          }
          {
#line 1170
          syserr("opendaemonsocket: daemon %s: failed to %s close-on-exec flag: %s",
                 d->d_name, tmp___5, tmp___4);
#line 1174
          close(d->d_socket);
          }
#line 1175
          goto severe;
        }
      }
      {
#line 1188
      if ((int )d->d_addr.sa.sa_family == 2) {
#line 1188
        goto case_2;
      }
#line 1205
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1189
      socksize = (int )sizeof(d->d_addr.sin);
#line 1190
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1206
      socksize = (int )sizeof(d->d_addr);
#line 1207
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1210
      tmp___8 = bind(d->d_socket, (struct sockaddr  const  *)(& d->d_addr.sa), (socklen_t )socksize);
      }
#line 1210
      if (tmp___8 < 0) {
        {
#line 1213
        tmp___7 = __errno_location();
#line 1213
        save_errno = *tmp___7;
#line 1214
        syserr("opendaemonsocket: daemon %s: cannot bind", d->d_name);
#line 1216
        close(d->d_socket);
        }
#line 1217
        goto fail;
      }
    }
#line 1220
    if (! firsttime___0) {
      {
#line 1220
      tmp___10 = listen(d->d_socket, d->d_listenqueue);
      }
#line 1220
      if (tmp___10 < 0) {
        {
#line 1223
        tmp___9 = __errno_location();
#line 1223
        save_errno = *tmp___9;
#line 1224
        syserr("opendaemonsocket: daemon %s: cannot listen", d->d_name);
#line 1226
        close(d->d_socket);
        }
#line 1227
        goto severe;
      }
    }
#line 1229
    return (socksize);
    __Cont: /* CIL Label */ 
#line 1066
    tmp___11 = ntries;
#line 1066
    ntries ++;
#line 1066
    if (tmp___11 < 10) {
      {
#line 1066
      tmp___12 = transienterror(save_errno);
      }
#line 1066
      if (! tmp___12) {
#line 1066
        goto while_break;
      }
    } else {
#line 1066
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1231
  syserr("!opendaemonsocket: daemon %s: server SMTP socket wedged: exiting", d->d_name);
  }
#line 1234
  return (-1);
}
}
#line 1247 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static unsigned short setupdaemon(union bigsockaddr *daemonaddr ) 
{ 
  unsigned short port ;
  register struct servent *sp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1257
  if ((int )daemonaddr->sa.sa_family == 0) {
    {
#line 1259
    memset((void *)daemonaddr, '\000', (size_t )sizeof(*daemonaddr));
#line 1261
    daemonaddr->sa.sa_family = (sa_family_t )2;
    }
  }
  {
#line 1268
  if ((int )daemonaddr->sa.sa_family == 2) {
#line 1268
    goto case_2;
  }
#line 1283
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1269
  if (daemonaddr->sin.sin_addr.s_addr == 0U) {
#line 1270
    daemonaddr->sin.sin_addr.s_addr = (in_addr_t )0;
  }
#line 1271
  port = daemonaddr->sin.sin_port;
#line 1272
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1285
  port = (unsigned short)0;
#line 1286
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1288
  if ((int )port == 0) {
    {
#line 1296
    sp = getservbyname("smtp", "tcp");
    }
#line 1297
    if ((unsigned long )sp == (unsigned long )((void *)0)) {
      {
#line 1299
      syserr("554 5.3.5 service \"smtp\" unknown");
#line 1300
      port = htons((uint16_t )25);
      }
    } else {
#line 1303
      port = (unsigned short )sp->s_port;
    }
  }
  {
#line 1311
  if ((int )daemonaddr->sa.sa_family == 2) {
#line 1311
    goto case_2___0;
  }
#line 1322
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
#line 1312
  daemonaddr->sin.sin_port = port;
#line 1313
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1324
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1326
  return (port);
}
}
#line 1341 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
void clrdaemon(void) 
{ 
  int i ;

  {
#line 1346
  i = 0;
  {
#line 1346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1346
    if (! (i < NDaemons)) {
#line 1346
      goto while_break;
    }
#line 1348
    if (Daemons[i].d_socket >= 0) {
      {
#line 1349
      close(Daemons[i].d_socket);
      }
    }
#line 1350
    Daemons[i].d_socket = -1;
#line 1346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1352
  return;
}
}
#line 1368 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
char *getmodifiers(char *v , unsigned int *modifiers ) 
{ 
  int l ;
  char *h ;
  char *f ;
  char *flags ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1377
  tmp = strlen((char const   *)v);
#line 1377
  l = (int )(3U * tmp + 3U);
  }
#line 1380
  if (l < 0) {
#line 1380
    goto _L;
  } else
#line 1380
  if (l > 256) {
    _L: /* CIL Label */ 
#line 1382
    if (LogLevel > 2) {
      {
#line 1383
      sm_syslog(3, "*~*", "getmodifiers too long, ignored");
      }
    }
#line 1385
    return ((char *)((void *)0));
  }
  {
#line 1387
  flags = xalloc_tagged(l, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                        1387);
#line 1388
  f = flags;
#line 1389
  memset((void *)((char *)modifiers), '\000', (size_t )32);
#line 1390
  h = v;
  }
  {
#line 1390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1390
    if (! ((int )*h != 0)) {
#line 1390
      goto while_break;
    }
#line 1392
    if (((int )*h & -128) == 0) {
      {
#line 1392
      tmp___4 = __ctype_b_loc();
      }
#line 1392
      if (! ((int const   )*(*tmp___4 + (int )*h) & 8192)) {
        {
#line 1392
        tmp___5 = __ctype_b_loc();
        }
#line 1392
        if ((int const   )*(*tmp___5 + (int )*h) & 16384) {
#line 1394
          *(modifiers + ((unsigned long )((unsigned char )*h) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL))) |= 1U << (unsigned long )((unsigned char )*h) % (8UL * sizeof(int ));
#line 1395
          if ((unsigned long )flags != (unsigned long )f) {
#line 1396
            tmp___0 = flags;
#line 1396
            flags ++;
#line 1396
            *tmp___0 = (char )' ';
          }
          {
#line 1397
          tmp___1 = flags;
#line 1397
          flags ++;
#line 1397
          *tmp___1 = *h;
#line 1398
          tmp___3 = __ctype_b_loc();
          }
#line 1398
          if ((int const   )*(*tmp___3 + (int )*h) & 256) {
#line 1399
            tmp___2 = flags;
#line 1399
            flags ++;
#line 1399
            *tmp___2 = *h;
          }
        }
      }
    }
#line 1390
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1402
  tmp___6 = flags;
#line 1402
  flags ++;
#line 1402
  *tmp___6 = (char )'\000';
#line 1403
  return (f);
}
}
#line 1416 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
bool chkdaemonmodifiers(int flag ) 
{ 
  int i ;

  {
#line 1422
  i = 0;
  {
#line 1422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1422
    if (! (i < NDaemons)) {
#line 1422
      goto while_break;
    }
#line 1423
    if (! (Daemons[i].d_flags[(unsigned long )((unsigned char )((char )flag)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )((char )flag)) % (8UL * sizeof(int ))))) {
#line 1424
      return (0);
    }
#line 1422
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1425
  return (1);
}
}
#line 1439 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static void setsockaddroptions(char *p , DAEMON_T *d ) 
{ 
  char *port ;
  char *addr ;
  register char *f ;
  register char *v ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  register struct hostent *hp ;
  unsigned short const   **tmp___7 ;
  in_addr_t tmp___8 ;
  int tmp___9 ;
  register struct servent *sp ;
  unsigned short const   **tmp___10 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1447
  port = (char *)((void *)0);
#line 1448
  addr = (char *)((void *)0);
#line 1451
  if ((int )d->d_addr.sa.sa_family == 0) {
#line 1452
    d->d_addr.sa.sa_family = (sa_family_t )2;
  }
  {
#line 1461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1461
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1461
      goto while_break;
    }
    {
#line 1466
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1466
      if (((int )*p & -128) == 0) {
        {
#line 1466
        tmp = __ctype_b_loc();
        }
#line 1466
        if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 1466
          goto while_break___0;
        }
      } else {
#line 1466
        goto while_break___0;
      }
#line 1467
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1468
    if ((int )*p == 0) {
#line 1469
      goto while_break;
    }
    {
#line 1470
    f = p;
#line 1471
    p = strchr((char const   *)p, ',');
    }
#line 1472
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1473
      tmp___0 = p;
#line 1473
      p ++;
#line 1473
      *tmp___0 = (char )'\000';
    }
    {
#line 1474
    v = strchr((char const   *)f, '=');
    }
#line 1475
    if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 1476
      goto while_continue;
    }
    {
#line 1477
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1477
      v ++;
#line 1477
      if (((int )*v & -128) == 0) {
        {
#line 1477
        tmp___1 = __ctype_b_loc();
        }
#line 1477
        if (! ((int const   )*(*tmp___1 + (int )*v) & 8192)) {
#line 1477
          goto while_break___1;
        }
      } else {
#line 1477
        goto while_break___1;
      }
#line 1478
      goto while_continue___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1479
    if (((int )*f & -128) == 0) {
      {
#line 1479
      tmp___3 = __ctype_b_loc();
      }
#line 1479
      if ((int const   )*(*tmp___3 + (int )*f) & 512) {
        {
#line 1480
        tmp___2 = toupper((int )*f);
#line 1480
        *f = (char )tmp___2;
        }
      }
    }
    {
#line 1484
    if ((int )*f == 65) {
#line 1484
      goto case_65;
    }
#line 1506
    if ((int )*f == 70) {
#line 1506
      goto case_70;
    }
#line 1542
    if ((int )*f == 73) {
#line 1542
      goto case_73;
    }
#line 1547
    if ((int )*f == 76) {
#line 1547
      goto case_76;
    }
#line 1551
    if ((int )*f == 77) {
#line 1551
      goto case_77;
    }
#line 1555
    if ((int )*f == 78) {
#line 1555
      goto case_78;
    }
#line 1559
    if ((int )*f == 80) {
#line 1559
      goto case_80;
    }
#line 1563
    if ((int )*f == 82) {
#line 1563
      goto case_82;
    }
#line 1567
    if ((int )*f == 83) {
#line 1567
      goto case_83;
    }
#line 1588
    goto switch_default;
    case_65: /* CIL Label */ 
#line 1485
    addr = v;
#line 1486
    goto switch_break;
    case_70: /* CIL Label */ 
#line 1507
    if (((int )*v & -128) == 0) {
      {
#line 1507
      tmp___6 = __ctype_b_loc();
      }
#line 1507
      if ((int const   )*(*tmp___6 + (int )*v) & 2048) {
        {
#line 1508
        tmp___4 = atoi((char const   *)v);
#line 1508
        d->d_addr.sa.sa_family = (sa_family_t )tmp___4;
        }
      } else {
#line 1507
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1517
      tmp___5 = sm_strcasecmp((char const   *)v, "inet");
      }
#line 1517
      if (tmp___5 == 0) {
#line 1518
        d->d_addr.sa.sa_family = (sa_family_t )2;
      } else {
        {
#line 1537
        syserr("554 5.3.5 Unknown address family %s in Family=option", v);
        }
      }
    }
#line 1539
    goto switch_break;
    case_73: /* CIL Label */ 
#line 1543
    d->d_inputfilterlist = v;
#line 1544
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 1548
    d->d_listenqueue = atoi((char const   *)v);
    }
#line 1549
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 1552
    d->d_mflags = getmodifiers(v, (unsigned int *)(d->d_flags));
    }
#line 1553
    goto switch_break;
    case_78: /* CIL Label */ 
#line 1556
    d->d_name = v;
#line 1557
    goto switch_break;
    case_80: /* CIL Label */ 
#line 1560
    port = v;
#line 1561
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 1564
    d->d_tcprcvbufsize = atoi((char const   *)v);
    }
#line 1565
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 1568
    d->d_tcpsndbufsize = atoi((char const   *)v);
    }
#line 1569
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1589
    syserr("554 5.3.5 PortOptions parameter \"%s\" unknown", f);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1595
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
    {
#line 1620
    if ((int )d->d_addr.sa.sa_family == 2) {
#line 1620
      goto case_2;
    }
#line 1682
    goto switch_default___0;
    case_2: /* CIL Label */ 
#line 1621
    if (! (((int )*addr & -128) == 0)) {
#line 1621
      goto _L___0;
    } else {
      {
#line 1621
      tmp___7 = __ctype_b_loc();
      }
#line 1621
      if ((int const   )*(*tmp___7 + (int )*addr) & 2048) {
        {
#line 1621
        tmp___8 = inet_addr((char const   *)addr);
#line 1621
        d->d_addr.sin.sin_addr.s_addr = tmp___8;
        }
#line 1621
        if (tmp___8 == 4294967295U) {
          _L___0: /* CIL Label */ 
          {
#line 1627
          hp = sm_gethostbyname(addr, 2);
          }
#line 1628
          if ((unsigned long )hp == (unsigned long )((void *)0)) {
            {
#line 1629
            syserr("554 5.3.0 host \"%s\" unknown", addr);
            }
          } else {
            {
#line 1633
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 1633
              if ((unsigned long )*(hp->h_addr_list) != (unsigned long )((void *)0)) {
#line 1633
                if (! (hp->h_addrtype != 2)) {
#line 1633
                  goto while_break___2;
                }
              } else {
#line 1633
                goto while_break___2;
              }
#line 1635
              (hp->h_addr_list) ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 1636
            if ((unsigned long )*(hp->h_addr_list) == (unsigned long )((void *)0)) {
              {
#line 1637
              syserr("554 5.3.0 host \"%s\" unknown", addr);
              }
            } else {
              {
#line 1640
              memmove((void *)(& d->d_addr.sin.sin_addr), (void const   *)*(hp->h_addr_list),
                      (size_t )4);
              }
            }
          }
        }
      } else {
#line 1621
        goto _L___0;
      }
    }
#line 1649
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 1683
    syserr("554 5.3.5 address= option unsupported for family %d", (int )d->d_addr.sa.sa_family);
    }
#line 1685
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1689
  if ((unsigned long )port != (unsigned long )((void *)0)) {
    {
#line 1694
    if ((int )d->d_addr.sa.sa_family == 2) {
#line 1694
      goto case_2___0;
    }
#line 1767
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 1695
    if (((int )*port & -128) == 0) {
      {
#line 1695
      tmp___10 = __ctype_b_loc();
      }
#line 1695
      if ((int const   )*(*tmp___10 + (int )*port) & 2048) {
        {
#line 1696
        tmp___9 = atoi((char const   *)port);
#line 1696
        d->d_addr.sin.sin_port = htons((unsigned short )tmp___9);
        }
      } else {
#line 1695
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 1706
      sp = getservbyname((char const   *)port, "tcp");
      }
#line 1707
      if ((unsigned long )sp == (unsigned long )((void *)0)) {
        {
#line 1708
        syserr("554 5.3.5 service \"%s\" unknown", port);
        }
      } else {
#line 1711
        d->d_addr.sin.sin_port = (in_port_t )sp->s_port;
      }
    }
#line 1714
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 1768
    syserr("554 5.3.5 Port= option unsupported for family %d", (int )d->d_addr.sa.sa_family);
    }
#line 1770
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 1773
  return;
}
}
#line 1795 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static struct dflags DaemonFlags[17]  = 
#line 1795
  {      {(char *)"AUTHREQ", 'a'}, 
        {(char *)"BINDIF", 'b'}, 
        {(char *)"CANONREQ", 'c'}, 
        {(char *)"IFNHELO", 'h'}, 
        {(char *)"FQMAIL", 'f'}, 
        {(char *)"FQRCPT", 'r'}, 
        {(char *)"SMTPS", 's'}, 
        {(char *)"UNQUALOK", 'u'}, 
        {(char *)"NOAUTH", 'A'}, 
        {(char *)"NOCANON", 'C'}, 
        {(char *)"NOETRN", 'E'}, 
        {(char *)"NOTLS", 'S'}, 
        {(char *)"ETRNONLY", 1}, 
        {(char *)"OPTIONAL", 'O'}, 
        {(char *)"DISABLE", 2}, 
        {(char *)"ISSET", 3}, 
        {(char *)((void *)0), 0}};
#line 1816 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static void printdaemonflags(DAEMON_T *d ) 
{ 
  register struct dflags *df ;
  bool first ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1821
  first = 1;
#line 1823
  df = DaemonFlags;
  {
#line 1823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1823
    if (! ((unsigned long )df->d_name != (unsigned long )((void *)0))) {
#line 1823
      goto while_break;
    }
#line 1825
    if (! (d->d_flags[(unsigned long )((unsigned char )df->d_flag) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )df->d_flag) % (8UL * sizeof(int ))))) {
#line 1826
      goto __Cont;
    }
#line 1827
    if (first) {
      {
#line 1828
      sm_dprintf((char *)"<%s", df->d_name);
      }
    } else {
      {
#line 1830
      sm_dprintf((char *)",%s", df->d_name);
      }
    }
#line 1831
    first = 0;
    __Cont: /* CIL Label */ 
#line 1823
    df ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1833
  if (! first) {
    {
#line 1834
    sm_dprintf((char *)">");
    }
  }
#line 1835
  return;
}
}
#line 1837 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
bool setdaemonoptions(char *p ) 
{ 
  char num[30] ;
  void *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1841
  if (NDaemons >= 10) {
#line 1842
    return (0);
  }
  {
#line 1843
  Daemons[NDaemons].d_socket = -1;
#line 1844
  Daemons[NDaemons].d_listenqueue = 10;
#line 1845
  memset((void *)((char *)(Daemons[NDaemons].d_flags)), '\000', (size_t )32);
#line 1846
  setsockaddroptions(p, & Daemons[NDaemons]);
  }
#line 1849
  if ((unsigned long )Daemons[NDaemons].d_inputfilterlist != (unsigned long )((void *)0)) {
    {
#line 1850
    Daemons[NDaemons].d_inputfilterlist = newstr((char const   *)Daemons[NDaemons].d_inputfilterlist);
    }
  }
#line 1853
  if ((unsigned long )Daemons[NDaemons].d_name != (unsigned long )((void *)0)) {
    {
#line 1854
    Daemons[NDaemons].d_name = newstr((char const   *)Daemons[NDaemons].d_name);
    }
  } else {
    {
#line 1859
    sm_snprintf(num, (size_t )sizeof(num), "Daemon%d", NDaemons);
#line 1860
    Daemons[NDaemons].d_name = newstr((char const   *)(num));
    }
  }
#line 1863
  if ((int )tTdvect[37] >= 1) {
    {
#line 1865
    sm_dprintf((char *)"Daemon %s flags: ", Daemons[NDaemons].d_name);
#line 1866
    printdaemonflags(& Daemons[NDaemons]);
#line 1867
    sm_dprintf((char *)"\n");
    }
  }
#line 1869
  NDaemons ++;
#line 1870
  return (1);
}
}
#line 1885 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
void initdaemon(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 1888
  if (NDaemons == 0) {
#line 1890
    Daemons[NDaemons].d_socket = -1;
#line 1891
    Daemons[NDaemons].d_listenqueue = 10;
#line 1892
    Daemons[NDaemons].d_name = (char *)"Daemon0";
#line 1893
    NDaemons = 1;
  }
#line 1895
  return;
}
}
#line 1906 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static DAEMON_T ClientSettings[33]  ;
#line 1908 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
void setclientoptions(char *p ) 
{ 
  int family ;
  DAEMON_T d ;
  char num[30] ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 1915
  memset((void *)(& d), '\000', (size_t )sizeof(d));
#line 1916
  setsockaddroptions(p, & d);
#line 1919
  family = (int )d.d_addr.sa.sa_family;
#line 1920
  ClientSettings[family] = d;
#line 1921
  ClientSettings[family].d_flags[3UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 3UL % (8UL * sizeof(int ));
  }
#line 1922
  if ((unsigned long )d.d_name != (unsigned long )((void *)0)) {
    {
#line 1923
    ClientSettings[family].d_name = newstr((char const   *)d.d_name);
    }
  } else {
    {
#line 1928
    sm_snprintf(num, (size_t )sizeof(num), "Client%d", family);
#line 1929
    ClientSettings[family].d_name = newstr((char const   *)(num));
    }
  }
#line 1931
  return;
}
}
#line 1945 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static int addr_family(char *addr ) 
{ 
  in_addr_t tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1954
  tmp = inet_addr((char const   *)addr);
  }
#line 1954
  if (tmp != 4294967295U) {
#line 1956
    if ((int )tTdvect[16] >= 9) {
      {
#line 1957
      sm_dprintf((char *)"addr_family(%s): INET\n", addr);
      }
    }
#line 1958
    return (2);
  }
#line 1979
  if ((int )tTdvect[16] >= 9) {
    {
#line 1980
    sm_dprintf((char *)"addr_family(%s): UNSPEC\n", addr);
    }
  }
#line 1981
  return (0);
}
}
#line 1994 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
bool chkclientmodifiers(int flag ) 
{ 
  int i ;
  bool flagisset ;

  {
#line 2001
  flagisset = 0;
#line 2002
  i = 0;
  {
#line 2002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2002
    if (! (i < 32)) {
#line 2002
      goto while_break;
    }
#line 2004
    if (ClientSettings[i].d_flags[3UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 3UL % (8UL * sizeof(int )))) {
#line 2006
      if (! (ClientSettings[i].d_flags[(unsigned long )((unsigned char )((char )flag)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )((char )flag)) % (8UL * sizeof(int ))))) {
#line 2007
        return (0);
      }
#line 2008
      flagisset = 1;
    }
#line 2002
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2011
  return (flagisset);
}
}
#line 2025 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
void setup_daemon_milters(void) 
{ 
  int idx ;

  {
#line 2030
  if ((int )OpMode == 115) {
#line 2033
    return;
  }
#line 2036
  idx = 0;
  {
#line 2036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2036
    if (! (idx < NDaemons)) {
#line 2036
      goto while_break;
    }
#line 2038
    if ((unsigned long )Daemons[idx].d_inputfilterlist != (unsigned long )((void *)0)) {
      {
#line 2040
      milter_config(Daemons[idx].d_inputfilterlist, Daemons[idx].d_inputfilters, 25);
      }
    }
#line 2036
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2045
  return;
}
}
#line 2067 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static sigjmp_buf CtxConnectTimeout  ;
#line 2069 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
union bigsockaddr CurHostAddr  ;
#line 2071 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
int makeconnection(char *host , unsigned int volatile   port , struct mailer_con_info *mci ,
                   ENVELOPE *e , time_t enough ) 
{ 
  register int volatile   addrno ;
  int volatile   s ;
  register struct hostent * volatile  hp ;
  union bigsockaddr addr ;
  union bigsockaddr clt_addr ;
  int save_errno ;
  int volatile   addrlen ;
  bool volatile   firstconnect ;
  SM_EVENT * volatile  ev ;
  int volatile   family ;
  int len___0 ;
  int volatile   socksize ;
  bool volatile   clt_bind ;
  BITMAP256 d_flags ;
  char *p ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  unsigned long hid ;
  struct hostent *tmp___6 ;
  int oldopts ;
  struct __res_state *tmp___7 ;
  struct __res_state *tmp___8 ;
  struct hostent *tmp___9 ;
  struct __res_state *tmp___10 ;
  in_addr_t tmp___11 ;
  int *tmp___12 ;
  size_t tmp___13 ;
  struct hostent *tmp___14 ;
  int oldopts___0 ;
  struct __res_state *tmp___15 ;
  struct __res_state *tmp___16 ;
  struct hostent *tmp___17 ;
  struct __res_state *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  int *tmp___24 ;
  int *tmp___25 ;
  int *tmp___26 ;
  register struct servent *sp ;
  struct servent *tmp___27 ;
  uint16_t tmp___28 ;
  int *tmp___29 ;
  uint16_t tmp___30 ;
  char *tmp___31 ;
  int rport ;
  int tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  int *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int on ;
  int *tmp___38 ;
  int on___0 ;
  int *tmp___39 ;
  int *tmp___40 ;
  char *tmp___41 ;
  int *tmp___42 ;
  int tmp___43 ;
  int i ;
  SM_EVENT *tmp___44 ;
  SM_EVENT *tmp___45 ;
  char *tmp___46 ;
  int *tmp___47 ;
  int *tmp___48 ;
  int tmp___49 ;
  char const   *tmp___50 ;
  char const   *tmp___51 ;
  char *tmp___52 ;
  char const   *tmp___53 ;
  int volatile   tmp___54 ;
  int volatile   tmp___55 ;
  time_t tmp___56 ;
  int *tmp___57 ;
  int *tmp___58 ;
  char const   *tmp___59 ;
  int *tmp___60 ;
  int *tmp___61 ;
  int *tmp___62 ;
  SM_FILE_T *tmp___63 ;
  int tmp___64 ;
  SM_FILE_T *tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  char *name ;
  char family___0[5] ;
  char *tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  char *tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  void *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;

  {
  {
#line 2079
  addrno = (int volatile   )0;
#line 2081
  hp = (struct hostent */* volatile  */)((struct hostent *)((void *)0));
#line 2084
  save_errno = 0;
#line 2087
  ev = (SM_EVENT */* volatile  */)((void *)0);
#line 2091
  family = (int volatile   )InetMode;
#line 2093
  socksize = (int volatile   )0;
#line 2100
  memset((void *)((char *)(d_flags)), '\000', (size_t )32);
#line 2101
  tmp___0 = macid_parse((char *)"{daemon_flags}", (char **)((void *)0));
#line 2101
  p = macvalue(tmp___0, e);
  }
#line 2101
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 2103
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2103
      if (! ((int )*p != 0)) {
#line 2103
        goto while_break;
      }
#line 2105
      if (((int )*p & -128) == 0) {
        {
#line 2105
        tmp = __ctype_b_loc();
        }
#line 2105
        if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 2106
          d_flags[(unsigned long )((unsigned char )((unsigned int )*p & 255U)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )((unsigned int )*p & 255U)) % (8UL * sizeof(int ));
        }
      } else {
#line 2106
        d_flags[(unsigned long )((unsigned char )((unsigned int )*p & 255U)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << (unsigned long )((unsigned char )((unsigned int )*p & 255U)) % (8UL * sizeof(int ));
      }
#line 2103
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2113
  clt_bind = (bool volatile   )0;
#line 2116
  if (d_flags[98UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 98UL % (8UL * sizeof(int )))) {
    {
#line 2116
    tmp___2 = macid_parse((char *)"{if_addr}", (char **)((void *)0));
#line 2116
    p = macvalue(tmp___2, e);
    }
#line 2116
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2116
      if ((int )*p != 0) {
        {
#line 2124
        memset((void *)(& clt_addr), '\000', (size_t )sizeof(clt_addr));
#line 2127
        tmp___1 = addr_family(p);
#line 2127
        clt_addr.sa.sa_family = (sa_family_t )tmp___1;
        }
        {
#line 2131
        if ((int )clt_addr.sa.sa_family == 2) {
#line 2131
          goto case_2;
        }
#line 2128
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 2132
        clt_addr.sin.sin_addr.s_addr = inet_addr((char const   *)p);
        }
#line 2133
        if (clt_addr.sin.sin_addr.s_addr != 4294967295U) {
#line 2133
          if (clt_addr.sin.sin_addr.s_addr != 2130706433U) {
#line 2136
            clt_bind = (bool volatile   )1;
#line 2137
            socksize = (int volatile   )sizeof(struct sockaddr_in );
          }
        }
#line 2139
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 2166
        if (clt_bind) {
#line 2167
          family = (int volatile   )clt_addr.sa.sa_family;
        }
      }
    }
  }
#line 2171
  if (! clt_bind) {
#line 2173
    clt_addr = ClientSettings[family].d_addr;
    {
#line 2177
    if ((int )clt_addr.sa.sa_family == 2) {
#line 2177
      goto case_2___0;
    }
#line 2204
    goto switch_default;
    case_2___0: /* CIL Label */ 
#line 2178
    if (clt_addr.sin.sin_addr.s_addr == 0U) {
#line 2179
      clt_addr.sin.sin_addr.s_addr = (in_addr_t )0;
    } else {
#line 2181
      clt_bind = (bool volatile   )1;
    }
#line 2182
    if ((int )clt_addr.sin.sin_port != 0) {
#line 2183
      clt_bind = (bool volatile   )1;
    }
#line 2184
    socksize = (int volatile   )sizeof(struct sockaddr_in );
#line 2185
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 2205
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2214
  tmp___3 = __h_errno_location();
#line 2214
  *tmp___3 = 0;
#line 2215
  tmp___4 = __errno_location();
#line 2215
  *tmp___4 = 0;
#line 2216
  memset((void *)(& CurHostAddr), '\000', (size_t )sizeof(CurHostAddr));
#line 2217
  memset((void *)(& addr), '\000', (size_t )sizeof(addr));
#line 2218
  tmp___5 = (char *)"initial connection";
#line 2218
  mci->mci_phase = tmp___5;
#line 2218
  SmtpPhase = tmp___5;
#line 2219
  CurHostName = host;
  }
#line 2221
  if ((int )*(host + 0) == 91) {
    {
#line 2223
    p = strchr((char const   *)host, ']');
    }
#line 2224
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2227
      hid = 4294967295UL;
#line 2233
      *p = (char )'\000';
#line 2238
      if (family == (int volatile   )2) {
        {
#line 2238
        tmp___11 = inet_addr((char const   *)(host + 1));
#line 2238
        hid = (unsigned long )tmp___11;
        }
#line 2238
        if (hid != 4294967295UL) {
#line 2241
          addr.sin.sin_family = (sa_family_t )2;
#line 2242
          addr.sin.sin_addr.s_addr = (in_addr_t )hid;
        } else {
#line 2238
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 2258
        tmp___6 = sm_gethostbyname(host + 1, (int )family);
#line 2258
        hp = (struct hostent */* volatile  */)tmp___6;
        }
#line 2259
        if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 2259
          if ((int )*(p + -1) == 46) {
            {
#line 2262
            tmp___7 = __res_state();
#line 2262
            oldopts = (int )tmp___7->options;
#line 2264
            tmp___8 = __res_state();
#line 2264
            tmp___8->options &= 0xfffffffffffffd7fUL;
#line 2266
            *(p + -1) = (char )'\000';
#line 2267
            tmp___9 = sm_gethostbyname(host + 1, (int )family);
#line 2267
            hp = (struct hostent */* volatile  */)tmp___9;
#line 2269
            *(p + -1) = (char )'.';
#line 2271
            tmp___10 = __res_state();
#line 2271
            tmp___10->options = (u_long )oldopts;
            }
          }
        }
#line 2274
        *p = (char )']';
#line 2275
        goto gothostent;
      }
#line 2277
      *p = (char )']';
    }
#line 2279
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 2283
      usrerrenh((char *)"5.1.2", "553 Invalid numeric domain spec \"%s\"", host);
#line 2286
      mci_setstat(mci, 68, (char *)"5.1.2", MsgBuf);
#line 2287
      tmp___12 = __errno_location();
#line 2287
      *tmp___12 = 22;
      }
#line 2288
      return (68);
    }
  } else {
    {
#line 2295
    tmp___13 = strlen((char const   *)host);
#line 2295
    p = host + (tmp___13 - 1U);
#line 2296
    tmp___14 = sm_gethostbyname(host, (int )family);
#line 2296
    hp = (struct hostent */* volatile  */)tmp___14;
    }
#line 2297
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 2297
      if ((int )*p == 46) {
        {
#line 2300
        tmp___15 = __res_state();
#line 2300
        oldopts___0 = (int )tmp___15->options;
#line 2302
        tmp___16 = __res_state();
#line 2302
        tmp___16->options &= 0xfffffffffffffd7fUL;
#line 2304
        *p = (char )'\000';
#line 2305
        tmp___17 = sm_gethostbyname(host, (int )family);
#line 2305
        hp = (struct hostent */* volatile  */)tmp___17;
#line 2306
        *p = (char )'.';
#line 2308
        tmp___18 = __res_state();
#line 2308
        tmp___18->options = (u_long )oldopts___0;
        }
      }
    }
    gothostent: 
#line 2313
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      {
#line 2334
      tmp___21 = __errno_location();
      }
#line 2334
      if (*tmp___21 == 110) {
#line 2334
        goto _L___0;
      } else {
        {
#line 2334
        tmp___22 = __h_errno_location();
        }
#line 2334
        if (*tmp___22 == 2) {
#line 2334
          goto _L___0;
        } else {
          {
#line 2334
          tmp___23 = __errno_location();
          }
#line 2334
          if (*tmp___23 == 111) {
#line 2334
            if (UseNameServer) {
              _L___0: /* CIL Label */ 
              {
#line 2338
              tmp___19 = __errno_location();
#line 2338
              save_errno = *tmp___19;
#line 2339
              mci_setstat(mci, 75, (char *)"4.4.3", (char *)((void *)0));
#line 2341
              tmp___20 = __errno_location();
#line 2341
              *tmp___20 = save_errno;
              }
#line 2342
              return (75);
            }
          }
        }
      }
      {
#line 2361
      tmp___24 = __errno_location();
#line 2361
      save_errno = *tmp___24;
#line 2362
      mci_setstat(mci, 68, (char *)"5.1.2", (char *)((void *)0));
#line 2363
      tmp___25 = __errno_location();
#line 2363
      *tmp___25 = save_errno;
      }
#line 2364
      return (68);
    }
#line 2366
    addr.sa.sa_family = (sa_family_t )hp->h_addrtype;
    {
#line 2370
    if (hp->h_addrtype == 2) {
#line 2370
      goto case_2___1;
    }
#line 2385
    goto switch_default___0;
    case_2___1: /* CIL Label */ 
    {
#line 2371
    memmove((void *)(& addr.sin.sin_addr), (void const   *)*(hp->h_addr_list + 0),
            (size_t )4);
    }
#line 2374
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 2386
    if ((unsigned long )hp->h_length > sizeof(addr.sa.sa_data)) {
      {
#line 2388
      syserr("makeconnection: long sa_data: family %d len %d", hp->h_addrtype, hp->h_length);
#line 2390
      mci_setstat(mci, 68, (char *)"5.1.2", (char *)((void *)0));
#line 2391
      tmp___26 = __errno_location();
#line 2391
      *tmp___26 = 22;
      }
#line 2392
      return (68);
    }
    {
#line 2394
    memmove((void *)(addr.sa.sa_data), (void const   *)*(hp->h_addr_list + 0), (size_t )hp->h_length);
    }
#line 2395
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 2397
    addrno = (int volatile   )1;
  }
#line 2404
  if (port == (unsigned int volatile   )0) {
    {
#line 2409
    tmp___27 = getservbyname("smtp", "tcp");
#line 2409
    sp = tmp___27;
    }
#line 2411
    if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 2413
      if (LogLevel > 2) {
        {
#line 2414
        sm_syslog(3, "*~*", "makeconnection: service \"smtp\" unknown");
        }
      }
      {
#line 2416
      tmp___28 = htons((uint16_t )25);
#line 2416
      port = (unsigned int volatile   )tmp___28;
      }
    } else {
#line 2419
      port = (unsigned int volatile   )sp->s_port;
    }
  }
  {
#line 2441
  if ((int )addr.sa.sa_family == 2) {
#line 2441
    goto case_2___2;
  }
#line 2462
  goto switch_default___1;
  case_2___2: /* CIL Label */ 
#line 2442
  addr.sin.sin_port = (in_port_t )port;
#line 2443
  addrlen = (int volatile   )sizeof(struct sockaddr_in );
#line 2444
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 2463
  syserr("Can\'t connect to address family %d", (int )addr.sa.sa_family);
#line 2464
  mci_setstat(mci, 68, (char *)"5.1.2", (char *)((void *)0));
#line 2465
  tmp___29 = __errno_location();
#line 2465
  *tmp___29 = 22;
  }
#line 2470
  return (68);
  switch_break___2: /* CIL Label */ ;
  }
#line 2489
  firstconnect = (bool volatile   )1;
  {
#line 2490
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2492
    if ((int )tTdvect[16] >= 1) {
      {
#line 2493
      tmp___30 = ntohs((uint16_t )port);
#line 2493
      tmp___31 = anynet_ntoa(& addr);
#line 2493
      sm_dprintf((char *)"makeconnection (%s [%s].%d (%d))\n", host, tmp___31, (int )tmp___30,
                 (int )addr.sa.sa_family);
      }
    }
#line 2498
    CurHostAddr = addr;
#line 2501
    if ((mci->mci_mailer)->m_flags[82UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 82UL % (8UL * sizeof(int )))) {
      {
#line 2503
      rport = 1023;
#line 2505
      tmp___32 = rresvport(& rport);
#line 2505
      s = (int volatile   )tmp___32;
      }
    } else {
      {
#line 2510
      tmp___33 = socket((int )addr.sa.sa_family, 1, 0);
#line 2510
      s = (int volatile   )tmp___33;
      }
    }
#line 2512
    if (s < (int volatile   )0) {
      {
#line 2514
      tmp___34 = __errno_location();
#line 2514
      save_errno = *tmp___34;
#line 2515
      syserr("makeconnection: cannot create socket");
#line 2519
      mci_setstat(mci, 75, (char *)"4.4.5", (char *)((void *)0));
#line 2524
      tmp___35 = __errno_location();
#line 2524
      *tmp___35 = save_errno;
      }
#line 2525
      return (75);
    }
#line 2529
    if (ClientSettings[family].d_tcpsndbufsize > 0) {
      {
#line 2531
      tmp___36 = setsockopt((int )s, 1, 7, (void const   *)((char *)(& ClientSettings[family].d_tcpsndbufsize)),
                            (socklen_t )sizeof(ClientSettings[family].d_tcpsndbufsize));
      }
#line 2531
      if (tmp___36 < 0) {
        {
#line 2534
        syserr("makeconnection: setsockopt(SO_SNDBUF)");
        }
      }
    }
#line 2538
    if (ClientSettings[family].d_tcprcvbufsize > 0) {
      {
#line 2540
      tmp___37 = setsockopt((int )s, 1, 8, (void const   *)((char *)(& ClientSettings[family].d_tcprcvbufsize)),
                            (socklen_t )sizeof(ClientSettings[family].d_tcprcvbufsize));
      }
#line 2540
      if (tmp___37 < 0) {
        {
#line 2543
        syserr("makeconnection: setsockopt(SO_RCVBUF)");
        }
      }
    }
#line 2547
    if ((int )tTdvect[16] >= 1) {
      {
#line 2548
      sm_dprintf((char *)"makeconnection: fd=%d\n", s);
      }
    }
#line 2551
    if ((int )tTdvect[16] >= 101) {
      {
#line 2553
      on = 1;
#line 2555
      setsockopt((int )s, 1, 1, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
      }
    }
#line 2558
    if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
      {
#line 2559
      sm_io_flush(e->e_xfp, -2);
      }
    }
    {
#line 2560
    tmp___38 = __errno_location();
#line 2560
    *tmp___38 = 0;
    }
#line 2562
    if (clt_bind) {
#line 2564
      on___0 = 1;
      {
#line 2569
      if ((int )clt_addr.sa.sa_family == 2) {
#line 2569
        goto case_2___3;
      }
#line 2566
      goto switch_break___3;
      case_2___3: /* CIL Label */ 
#line 2570
      if ((int )clt_addr.sin.sin_port != 0) {
        {
#line 2571
        setsockopt((int )s, 1, 2, (void const   *)((char *)(& on___0)), (socklen_t )sizeof(on___0));
        }
      }
#line 2575
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
      {
#line 2589
      tmp___43 = bind((int )s, (struct sockaddr  const  *)(& clt_addr.sa), (socklen_t )socksize);
      }
#line 2589
      if (tmp___43 < 0) {
        {
#line 2591
        tmp___39 = __errno_location();
#line 2591
        save_errno = *tmp___39;
#line 2592
        close((int )s);
#line 2593
        tmp___40 = __errno_location();
#line 2593
        *tmp___40 = save_errno;
#line 2594
        tmp___41 = anynet_ntoa(& clt_addr);
#line 2594
        syserr("makeconnection: cannot bind socket [%s]", tmp___41);
#line 2600
        tmp___42 = __errno_location();
#line 2600
        *tmp___42 = save_errno;
        }
#line 2601
        return (75);
      }
    }
    {
#line 2610
    tmp___49 = __sigsetjmp((struct __jmp_buf_tag *)(CtxConnectTimeout), 1);
    }
#line 2610
    if (tmp___49 == 0) {
#line 2614
      if (e->e_ntries <= 0) {
#line 2614
        if (TimeOuts.to_iconnect != 0L) {
          {
#line 2615
          tmp___44 = sm_seteventm((int )(TimeOuts.to_iconnect * 1000L), & connecttimeout,
                                  0);
#line 2615
          ev = (SM_EVENT */* volatile  */)tmp___44;
          }
        } else {
#line 2614
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2617
      if (TimeOuts.to_connect != 0L) {
        {
#line 2618
        tmp___45 = sm_seteventm((int )(TimeOuts.to_connect * 1000L), & connecttimeout,
                                0);
#line 2618
        ev = (SM_EVENT */* volatile  */)tmp___45;
        }
      } else {
#line 2621
        ev = (SM_EVENT */* volatile  */)((void *)0);
      }
      {
#line 2626
      if ((int )ConnectOnlyTo.sa.sa_family == 2) {
#line 2626
        goto case_2___4;
      }
#line 2623
      goto switch_break___4;
      case_2___4: /* CIL Label */ 
#line 2627
      addr.sin.sin_addr.s_addr = ConnectOnlyTo.sin.sin_addr.s_addr;
#line 2628
      goto switch_break___4;
      switch_break___4: /* CIL Label */ ;
      }
#line 2639
      if ((int )tTdvect[16] >= 1) {
        {
#line 2640
        tmp___46 = anynet_ntoa(& addr);
#line 2640
        sm_dprintf((char *)"Connecting to [%s]...\n", tmp___46);
        }
      }
      {
#line 2641
      i = connect((int )s, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                  (socklen_t )addrlen);
#line 2642
      tmp___47 = __errno_location();
#line 2642
      save_errno = *tmp___47;
      }
#line 2643
      if ((unsigned long )ev != (unsigned long )((void *)0)) {
        {
#line 2644
        sm_clrevent((SM_EVENT *)ev);
        }
      }
#line 2645
      if (i >= 0) {
#line 2646
        goto while_break___0;
      }
    } else {
      {
#line 2649
      tmp___48 = __errno_location();
#line 2649
      save_errno = *tmp___48;
      }
    }
    {
#line 2652
    close((int )s);
    }
#line 2655
    if (DialDelay > 0L) {
#line 2655
      if (firstconnect) {
#line 2655
        if ((mci->mci_mailer)->m_flags[90UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 90UL % (8UL * sizeof(int )))) {
#line 2658
          if ((int )tTdvect[16] >= 1) {
            {
#line 2659
            tmp___50 = sm_errstring(save_errno);
#line 2659
            sm_dprintf((char *)"Connect failed (%s); trying again...\n", tmp___50);
            }
          }
          {
#line 2661
          firstconnect = (bool volatile   )0;
#line 2662
          sleep((unsigned int )DialDelay);
          }
#line 2663
          goto __Cont;
        }
      }
    }
#line 2666
    if (LogLevel > 13) {
      {
#line 2667
      tmp___51 = sm_errstring(save_errno);
#line 2667
      tmp___52 = anynet_ntoa(& addr);
#line 2667
      sm_syslog(6, (char const   *)e->e_id, "makeconnection (%s [%s]) failed: %s",
                host, tmp___52, tmp___51);
      }
    }
#line 2675
    if ((unsigned long )hp != (unsigned long )((void *)0)) {
#line 2675
      if ((unsigned long )*(hp->h_addr_list + addrno) != (unsigned long )((void *)0)) {
#line 2675
        if (enough == 0L) {
#line 2675
          goto _L___2;
        } else {
          {
#line 2675
          tmp___56 = curtime();
          }
#line 2675
          if (tmp___56 < enough) {
            _L___2: /* CIL Label */ 
#line 2678
            if ((int )tTdvect[16] >= 1) {
              {
#line 2679
              tmp___53 = sm_errstring(save_errno);
#line 2679
              sm_dprintf((char *)"Connect failed (%s); trying new address....\n",
                         tmp___53);
              }
            }
            {
#line 2684
            if ((int )addr.sa.sa_family == 2) {
#line 2684
              goto case_2___5;
            }
#line 2699
            goto switch_default___2;
            case_2___5: /* CIL Label */ 
            {
#line 2685
            tmp___54 = addrno;
#line 2685
            addrno += (int volatile   )1;
#line 2685
            memmove((void *)(& addr.sin.sin_addr), (void const   *)*(hp->h_addr_list + tmp___54),
                    (size_t )4);
            }
#line 2688
            goto switch_break___5;
            switch_default___2: /* CIL Label */ 
            {
#line 2700
            tmp___55 = addrno;
#line 2700
            addrno += (int volatile   )1;
#line 2700
            memmove((void *)(addr.sa.sa_data), (void const   *)*(hp->h_addr_list + tmp___55),
                    (size_t )hp->h_length);
            }
#line 2703
            goto switch_break___5;
            switch_break___5: /* CIL Label */ ;
            }
#line 2705
            goto __Cont;
          }
        }
      }
    }
    {
#line 2707
    tmp___57 = __errno_location();
#line 2707
    *tmp___57 = save_errno;
#line 2731
    tmp___58 = __errno_location();
#line 2731
    save_errno = *tmp___58;
    }
#line 2732
    if ((int )tTdvect[16] >= 1) {
      {
#line 2733
      tmp___59 = sm_errstring(save_errno);
#line 2733
      sm_dprintf((char *)"Connect failed (%s)\n", tmp___59);
      }
    }
    {
#line 2738
    mci_setstat(mci, 75, (char *)"4.4.1", (char *)((void *)0));
#line 2743
    tmp___60 = __errno_location();
#line 2743
    *tmp___60 = save_errno;
    }
#line 2744
    return (75);
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2756
  mci->mci_out = (SM_FILE_T *)((void *)0);
#line 2757
  tmp___63 = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& s)),
                        3, (void const   *)((void *)0));
#line 2757
  mci->mci_out = tmp___63;
  }
#line 2757
  if ((unsigned long )tmp___63 == (unsigned long )((void *)0)) {
#line 2757
    goto _L___3;
  } else {
    {
#line 2757
    tmp___64 = dup((int )s);
#line 2757
    s = (int volatile   )tmp___64;
    }
#line 2757
    if (s < (int volatile   )0) {
#line 2757
      goto _L___3;
    } else {
      {
#line 2757
      tmp___65 = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& s)),
                            2, (void const   *)((void *)0));
#line 2757
      mci->mci_in = tmp___65;
      }
#line 2757
      if ((unsigned long )tmp___65 == (unsigned long )((void *)0)) {
        _L___3: /* CIL Label */ 
        {
#line 2765
        tmp___61 = __errno_location();
#line 2765
        save_errno = *tmp___61;
#line 2766
        syserr("cannot open SMTP client channel, fd=%d", s);
#line 2767
        mci_setstat(mci, 75, (char *)"4.4.5", (char *)((void *)0));
        }
#line 2768
        if ((unsigned long )mci->mci_out != (unsigned long )((void *)0)) {
          {
#line 2769
          sm_io_close(mci->mci_out, -2);
          }
        }
        {
#line 2770
        close((int )s);
#line 2771
        tmp___62 = __errno_location();
#line 2771
        *tmp___62 = save_errno;
        }
#line 2772
        return (75);
      }
    }
  }
  {
#line 2774
  sm_io_automode(mci->mci_out, mci->mci_in);
  }
#line 2777
  if ((unsigned long )ClientSettings[addr.sa.sa_family].d_mflags != (unsigned long )((void *)0)) {
    {
#line 2779
    tmp___66 = macid_parse((char *)"{client_flags}", (char **)((void *)0));
#line 2779
    macdefine_tagged(& mci->mci_macro, (ARGCLASS_T )2, tmp___66, ClientSettings[addr.sa.sa_family].d_mflags,
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                     2781, SmHeapGroup);
    }
  } else {
    {
#line 2784
    tmp___67 = macid_parse((char *)"{client_flags}", (char **)((void *)0));
#line 2784
    macdefine_tagged(& mci->mci_macro, (ARGCLASS_T )2, tmp___67, (char *)"", (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                     2785, SmHeapGroup);
    }
  }
#line 2788
  if (ClientSettings[addr.sa.sa_family].d_flags[104UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 104UL % (8UL * sizeof(int )))) {
#line 2791
    d_flags[104UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 104UL % (8UL * sizeof(int ));
  }
  {
#line 2795
  len___0 = (int )sizeof(addr);
#line 2796
  tmp___76 = getsockname((int )s, (struct sockaddr */* __restrict  */)(& addr.sa),
                         (socklen_t */* __restrict  */)(& len___0));
  }
#line 2796
  if (tmp___76 == 0) {
    {
#line 2801
    tmp___68 = anynet_ntoa(& addr);
#line 2801
    tmp___69 = macid_parse((char *)"{if_addr_out}", (char **)((void *)0));
#line 2801
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___69, tmp___68,
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                     2802, SmHeapGroup);
#line 2803
    sm_snprintf(family___0, (size_t )sizeof(family___0), "%d", (int )addr.sa.sa_family);
#line 2805
    tmp___70 = macid_parse((char *)"{if_family_out}", (char **)((void *)0));
#line 2805
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___70, family___0,
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                     2806, SmHeapGroup);
#line 2808
    name = hostnamebyanyaddr(& addr);
#line 2809
    tmp___71 = macid_parse((char *)"{if_name_out}", (char **)((void *)0));
#line 2809
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___71, name, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                     2810, SmHeapGroup);
    }
#line 2811
    if (LogLevel > 11) {
      {
#line 2814
      sm_syslog(6, (char const   *)e->e_id, "SMTP outgoing connect on %.40s", name);
      }
    }
#line 2817
    if (d_flags[104UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 104UL % (8UL * sizeof(int )))) {
#line 2819
      if ((int )*(name + 0) != 91) {
        {
#line 2819
        tmp___72 = strchr((char const   *)name, '.');
        }
#line 2819
        if ((unsigned long )tmp___72 != (unsigned long )((void *)0)) {
          {
#line 2820
          mci->mci_heloname = newstr((char const   *)name);
          }
        }
      }
    }
  } else {
    {
#line 2825
    tmp___73 = macid_parse((char *)"{if_name_out}", (char **)((void *)0));
#line 2825
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___73, (char *)((void *)0),
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                     2826, SmHeapGroup);
#line 2827
    tmp___74 = macid_parse((char *)"{if_addr_out}", (char **)((void *)0));
#line 2827
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___74, (char *)((void *)0),
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                     2828, SmHeapGroup);
#line 2829
    tmp___75 = macid_parse((char *)"{if_family_out}", (char **)((void *)0));
#line 2829
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___75, (char *)((void *)0),
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                     2830, SmHeapGroup);
    }
  }
  {
#line 2839
  mci_setstat(mci, 0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2840
  return (0);
}
}
#line 2843 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static void connecttimeout(int ignore ) 
{ 
  int *tmp ;

  {
  {
#line 2853
  tmp = __errno_location();
#line 2853
  *tmp = 110;
#line 2854
  siglongjmp((struct __jmp_buf_tag *)(CtxConnectTimeout), 1);
  }
}
}
#line 2873 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
int makeconnection_ds(char *mux_path , struct mailer_con_info *mci ) 
{ 
  int sock ;
  int rval ;
  int save_errno ;
  long sff ;
  struct sockaddr_un unix_addr ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  SM_FILE_T *tmp___9 ;
  SM_FILE_T *tmp___10 ;
  int *tmp___11 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 2880
  sff = 271110L;
#line 2884
  rval = safefile(mux_path, RunAsUid, RunAsGid, RunAsUserName, sff, 384, (struct stat *)((void *)0));
  }
#line 2887
  if (rval != 0) {
    {
#line 2889
    syserr("makeconnection_ds: unsafe domain socket %s", mux_path);
#line 2891
    mci_setstat(mci, 75, (char *)"4.3.5", (char *)((void *)0));
#line 2892
    tmp = __errno_location();
#line 2892
    *tmp = rval;
    }
#line 2893
    return (75);
  }
  {
#line 2897
  memset((void *)(& unix_addr), '\000', (size_t )sizeof(unix_addr));
#line 2898
  unix_addr.sun_family = (sa_family_t )1;
#line 2900
  tmp___1 = strlen((char const   *)mux_path);
  }
#line 2900
  if ((unsigned long )tmp___1 >= sizeof(unix_addr.sun_path)) {
    {
#line 2902
    syserr("makeconnection_ds: domain socket name %s too long", mux_path);
#line 2906
    mci_setstat(mci, 75, (char *)"5.3.5", (char *)((void *)0));
#line 2907
    tmp___0 = __errno_location();
#line 2907
    *tmp___0 = 36;
    }
#line 2908
    return (69);
  }
  {
#line 2910
  sm_strlcpy(unix_addr.sun_path, (char const   *)mux_path, (ssize_t )sizeof(unix_addr.sun_path));
#line 2914
  sock = socket(1, 1, 0);
  }
#line 2915
  if (sock == -1) {
    {
#line 2917
    tmp___2 = __errno_location();
#line 2917
    save_errno = *tmp___2;
#line 2918
    syserr("makeconnection_ds: could not create domain socket %s", mux_path);
#line 2920
    mci_setstat(mci, 75, (char *)"4.4.5", (char *)((void *)0));
#line 2921
    tmp___3 = __errno_location();
#line 2921
    *tmp___3 = save_errno;
    }
#line 2922
    return (75);
  }
  {
#line 2926
  tmp___6 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& unix_addr)),
                    (socklen_t )sizeof(unix_addr));
  }
#line 2926
  if (tmp___6 == -1) {
    {
#line 2929
    tmp___4 = __errno_location();
#line 2929
    save_errno = *tmp___4;
#line 2930
    syserr("Could not connect to socket %s", mux_path);
#line 2931
    mci_setstat(mci, 75, (char *)"4.4.1", (char *)((void *)0));
#line 2932
    close(sock);
#line 2933
    tmp___5 = __errno_location();
#line 2933
    *tmp___5 = save_errno;
    }
#line 2934
    return (75);
  }
  {
#line 2938
  mci->mci_out = (SM_FILE_T *)((void *)0);
#line 2939
  tmp___9 = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& sock)),
                       3, (void const   *)((void *)0));
#line 2939
  mci->mci_out = tmp___9;
  }
#line 2939
  if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
#line 2939
    goto _L;
  } else {
    {
#line 2939
    sock = dup(sock);
    }
#line 2939
    if (sock < 0) {
#line 2939
      goto _L;
    } else {
      {
#line 2939
      tmp___10 = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& sock)),
                            2, (void const   *)((void *)0));
#line 2939
      mci->mci_in = tmp___10;
      }
#line 2939
      if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
        {
#line 2947
        tmp___7 = __errno_location();
#line 2947
        save_errno = *tmp___7;
#line 2948
        syserr("cannot open SMTP client channel, fd=%d", sock);
#line 2949
        mci_setstat(mci, 75, (char *)"4.4.5", (char *)((void *)0));
        }
#line 2950
        if ((unsigned long )mci->mci_out != (unsigned long )((void *)0)) {
          {
#line 2951
          sm_io_close(mci->mci_out, -2);
          }
        }
        {
#line 2952
        close(sock);
#line 2953
        tmp___8 = __errno_location();
#line 2953
        *tmp___8 = save_errno;
        }
#line 2954
        return (75);
      }
    }
  }
  {
#line 2956
  sm_io_automode(mci->mci_out, mci->mci_in);
#line 2958
  mci_setstat(mci, 0, (char *)((void *)0), (char *)((void *)0));
#line 2959
  tmp___11 = __errno_location();
#line 2959
  *tmp___11 = 0;
  }
#line 2960
  return (0);
}
}
#line 2976 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
void shutdown_daemon(void) 
{ 
  int i ;
  char *reason ;
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 2982
  sm_allsignals(1);
#line 2984
  reason = (char *)ShutdownRequest;
#line 2985
  ShutdownRequest = (char */* volatile  */)((void *)0);
#line 2986
  PendingSignal = (int volatile   )0;
  }
#line 2988
  if (LogLevel > 9) {
#line 2989
    if ((unsigned long )reason == (unsigned long )((void *)0)) {
#line 2989
      tmp = "implicit call";
    } else {
#line 2989
      tmp = (char const   *)reason;
    }
    {
#line 2989
    sm_syslog(6, (char const   *)CurEnv->e_id, "stopping daemon, reason=%s", tmp);
    }
  }
  {
#line 2992
  FileName = (char *)((void *)0);
#line 2993
  closecontrolsocket(1);
#line 2998
  i = 0;
  }
  {
#line 2998
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2998
    if (! (i < NDaemons)) {
#line 2998
      goto while_break;
    }
#line 3000
    if (Daemons[i].d_socket >= 0) {
      {
#line 3002
      close(Daemons[i].d_socket);
#line 3003
      Daemons[i].d_socket = -1;
      }
    }
#line 2998
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3033
  finis(0, 1, (int volatile   )0);
  }
#line 3034
  return;
}
}
#line 3057 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
void restart_daemon(void) 
{ 
  bool drop ;
  int save_errno ;
  char *reason ;
  void (*ignore)(int  ) ;
  void (*oalrm)(int  ) ;
  void (*ousr1)(int  ) ;
  char const   *tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 3067
  sm_clear_events();
#line 3068
  sm_allsignals(1);
#line 3070
  reason = (char *)RestartRequest;
#line 3071
  RestartRequest = (char */* volatile  */)((void *)0);
#line 3072
  PendingSignal = (int volatile   )0;
  }
#line 3074
  if ((int )*(*(SaveArgv + 0) + 0) != 47) {
#line 3076
    if (LogLevel > 3) {
      {
#line 3077
      sm_syslog(6, "*~*", "could not restart: need full path");
      }
    }
    {
#line 3079
    finis(0, 1, (int volatile   )72);
    }
  }
#line 3082
  if (LogLevel > 3) {
#line 3083
    if ((unsigned long )reason == (unsigned long )((void *)0)) {
#line 3083
      tmp = "implicit call";
    } else {
#line 3083
      tmp = (char const   *)reason;
    }
    {
#line 3083
    sm_syslog(6, "*~*", "restarting %s due to %s", *(SaveArgv + 0), tmp);
    }
  }
  {
#line 3087
  closecontrolsocket(1);
#line 3089
  tmp___0 = getpid();
#line 3089
  cleanup_shm(DaemonPid == tmp___0);
#line 3093
  close_sendmail_pid();
  }
#line 3102
  if (UseMSP) {
#line 3102
    if (RunAsUid != 0U) {
#line 3102
      if (RealUid == 0U) {
#line 3102
        tmp___1 = 0;
      } else
#line 3102
      if (RealUid == RunAsUid) {
#line 3102
        tmp___1 = 0;
      } else {
#line 3102
        tmp___1 = 1;
      }
    } else {
#line 3102
      tmp___1 = 1;
    }
  } else {
#line 3102
    tmp___1 = 1;
  }
  {
#line 3102
  drop = tmp___1;
#line 3105
  tmp___4 = drop_privileges(drop);
  }
#line 3105
  if (tmp___4 != 0) {
#line 3107
    if (LogLevel > 0) {
      {
#line 3108
      tmp___2 = __errno_location();
#line 3108
      tmp___3 = sm_errstring(*tmp___2);
#line 3108
      sm_syslog(1, "*~*", "could not drop privileges: %s", tmp___3);
      }
    }
    {
#line 3111
    finis(0, 1, (int volatile   )71);
    }
  }
  {
#line 3115
  sm_close_on_exec(3, DtableSize);
  }
  {
#line 3124
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3124
    oalrm = sm_signal(14, & sm_signal_noop);
    }
#line 3124
    if ((unsigned long )oalrm == (unsigned long )((void (*)(int  ))1)) {
      {
#line 3124
      sm_signal(14, oalrm);
      }
    } else
#line 3124
    if ((unsigned long )oalrm == (unsigned long )((void (*)(int  ))0)) {
      {
#line 3124
      sm_signal(14, oalrm);
      }
    }
#line 3124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3125
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 3125
    ignore = sm_signal(17, & sm_signal_noop);
    }
#line 3125
    if ((unsigned long )ignore == (unsigned long )((void (*)(int  ))1)) {
      {
#line 3125
      sm_signal(17, ignore);
      }
    } else
#line 3125
    if ((unsigned long )ignore == (unsigned long )((void (*)(int  ))0)) {
      {
#line 3125
      sm_signal(17, ignore);
      }
    }
#line 3125
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3126
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 3126
    ignore = sm_signal(1, & sm_signal_noop);
    }
#line 3126
    if ((unsigned long )ignore == (unsigned long )((void (*)(int  ))1)) {
      {
#line 3126
      sm_signal(1, ignore);
      }
    } else
#line 3126
    if ((unsigned long )ignore == (unsigned long )((void (*)(int  ))0)) {
      {
#line 3126
      sm_signal(1, ignore);
      }
    }
#line 3126
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3127
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 3127
    ignore = sm_signal(2, & sm_signal_noop);
    }
#line 3127
    if ((unsigned long )ignore == (unsigned long )((void (*)(int  ))1)) {
      {
#line 3127
      sm_signal(2, ignore);
      }
    } else
#line 3127
    if ((unsigned long )ignore == (unsigned long )((void (*)(int  ))0)) {
      {
#line 3127
      sm_signal(2, ignore);
      }
    }
#line 3127
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 3128
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 3128
    ignore = sm_signal(13, & sm_signal_noop);
    }
#line 3128
    if ((unsigned long )ignore == (unsigned long )((void (*)(int  ))1)) {
      {
#line 3128
      sm_signal(13, ignore);
      }
    } else
#line 3128
    if ((unsigned long )ignore == (unsigned long )((void (*)(int  ))0)) {
      {
#line 3128
      sm_signal(13, ignore);
      }
    }
#line 3128
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 3129
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 3129
    ignore = sm_signal(15, & sm_signal_noop);
    }
#line 3129
    if ((unsigned long )ignore == (unsigned long )((void (*)(int  ))1)) {
      {
#line 3129
      sm_signal(15, ignore);
      }
    } else
#line 3129
    if ((unsigned long )ignore == (unsigned long )((void (*)(int  ))0)) {
      {
#line 3129
      sm_signal(15, ignore);
      }
    }
#line 3129
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 3131
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 3131
    ousr1 = sm_signal(10, & sm_signal_noop);
    }
#line 3131
    if ((unsigned long )ousr1 == (unsigned long )((void (*)(int  ))1)) {
      {
#line 3131
      sm_signal(10, ousr1);
      }
    } else
#line 3131
    if ((unsigned long )ousr1 == (unsigned long )((void (*)(int  ))0)) {
      {
#line 3131
      sm_signal(10, ousr1);
      }
    }
#line 3131
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 3135
  sm_allsignals(0);
#line 3137
  execve((char const   *)*(SaveArgv + 0), (char * const  *)SaveArgv, (char * const  *)ExternalEnviron);
#line 3138
  tmp___5 = __errno_location();
#line 3138
  save_errno = *tmp___5;
#line 3141
  sm_allsignals(1);
#line 3144
  sm_signal(14, oalrm);
#line 3148
  sm_signal(10, ousr1);
#line 3151
  tmp___6 = __errno_location();
#line 3151
  *tmp___6 = save_errno;
  }
#line 3152
  if (LogLevel > 0) {
    {
#line 3153
    tmp___7 = __errno_location();
#line 3153
    tmp___8 = sm_errstring(*tmp___7);
#line 3153
    sm_syslog(1, "*~*", "could not exec %s: %s", *(SaveArgv + 0), tmp___8);
    }
  }
  {
#line 3155
  finis(0, 1, (int volatile   )72);
  }
#line 3157
  return;
}
}
#line 3172 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
struct hostent *myhostname(char *hostbuf___1 , int size ) 
{ 
  register struct hostent *hp ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char **ha ;
  char *tmp___2 ;
  char *tmp___3 ;
  bool tmp___4 ;
  char *tmp___5 ;
  bool tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 3179
  tmp = gethostname(hostbuf___1, (size_t )size);
  }
#line 3179
  if (tmp < 0) {
    {
#line 3180
    sm_strlcpy(hostbuf___1, "localhost", size);
    }
  } else
#line 3179
  if ((int )*(hostbuf___1 + 0) == 0) {
    {
#line 3180
    sm_strlcpy(hostbuf___1, "localhost", size);
    }
  }
  {
#line 3181
  hp = sm_gethostbyname(hostbuf___1, (int )InetMode);
  }
#line 3194
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 3195
    return ((struct hostent *)((void *)0));
  }
  {
#line 3196
  tmp___0 = strchr((char const   *)hp->h_name, '.');
  }
#line 3196
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 3197
    cleanstrcpy(hostbuf___1, hp->h_name, size);
    }
  } else {
    {
#line 3196
    tmp___1 = strchr((char const   *)hostbuf___1, '.');
    }
#line 3196
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 3197
      cleanstrcpy(hostbuf___1, hp->h_name, size);
      }
    }
  }
  {
#line 3217
  tmp___3 = strchr((char const   *)hostbuf___1, '.');
  }
#line 3217
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 3221
    ha = hp->h_aliases;
    {
#line 3221
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3221
      if ((unsigned long )ha != (unsigned long )((void *)0)) {
#line 3221
        if (! ((unsigned long )*ha != (unsigned long )((void *)0))) {
#line 3221
          goto while_break;
        }
      } else {
#line 3221
        goto while_break;
      }
      {
#line 3223
      tmp___2 = strchr((char const   *)*ha, '.');
      }
#line 3223
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        {
#line 3225
        cleanstrcpy(hostbuf___1, *ha, size - 1);
#line 3226
        *(hostbuf___1 + (size - 1)) = (char )'\000';
        }
#line 3227
        goto while_break;
      }
#line 3221
      ha ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 3241
  tmp___5 = strchr((char const   *)hostbuf___1, '.');
  }
#line 3241
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
    {
#line 3241
    tmp___6 = getcanonname(hostbuf___1, size, 1, (int *)((void *)0));
    }
#line 3241
    if (! tmp___6) {
      {
#line 3244
      sm_syslog(2, "*~*", "My unqualified host name (%s) unknown; sleeping for retry",
                hostbuf___1);
#line 3247
      message("My unqualified host name (%s) unknown; sleeping for retry", hostbuf___1);
#line 3249
      sleep(60U);
#line 3250
      tmp___4 = getcanonname(hostbuf___1, size, 1, (int *)((void *)0));
      }
#line 3250
      if (! tmp___4) {
        {
#line 3252
        sm_syslog(1, "*~*", "unable to qualify my own domain name (%s) -- using short name",
                  hostbuf___1);
#line 3255
        message("WARNING: unable to qualify my own domain name (%s) -- using short name",
                hostbuf___1);
        }
      }
    }
  }
#line 3259
  return (hp);
}
}
#line 3274 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static int addrcmp(struct hostent *hp , char *ha , union bigsockaddr *sa ) 
{ 
  int tmp ;

  {
  {
#line 3287
  if ((int )sa->sa.sa_family == 2) {
#line 3287
    goto case_2;
  }
#line 3284
  goto switch_break;
  case_2: /* CIL Label */ 
#line 3288
  if (hp->h_addrtype == 2) {
    {
#line 3289
    tmp = memcmp((void const   *)ha, (void const   *)((char *)(& sa->sin.sin_addr)),
                 (size_t )4);
    }
#line 3289
    return (tmp);
  }
#line 3290
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3308
  return (-1);
}
}
#line 3325 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static sigjmp_buf CtxAuthTimeout  ;
#line 3327 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static void authtimeout(int ignore ) 
{ 
  int *tmp ;

  {
  {
#line 3337
  tmp = __errno_location();
#line 3337
  *tmp = 110;
#line 3338
  siglongjmp((struct __jmp_buf_tag *)(CtxAuthTimeout), 1);
  }
}
}
#line 3354 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static unsigned short port4  =    (unsigned short)0;
#line 3369 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static char hbuf[367]  ;
#line 3341 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
char *getauthinfo(int fd , bool *may_be_forged ) 
{ 
  unsigned short port ;
  int falen ;
  register char * volatile  p ;
  union bigsockaddr la ;
  int lalen ;
  register struct servent *sp ;
  int volatile   s ;
  int i ;
  size_t len___0 ;
  SM_EVENT *ev ;
  int nleft ;
  struct hostent *hp ;
  char *ostype ;
  char **ha ;
  char ibuf[257] ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int family ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  uint16_t tmp___7 ;
  uint16_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  ssize_t tmp___14 ;
  char *s___0 ;
  char *tmp___15 ;
  unsigned short const   **tmp___16 ;
  int tmp___17 ;
  unsigned short const   **tmp___18 ;
  char * volatile  tmp___19 ;
  unsigned short const   **tmp___20 ;
  char *tmp___21 ;
  char *charset ;
  unsigned short const   **tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  size_t tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  void *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
  {
#line 3346
  port = (unsigned short)0;
#line 3348
  p = (char */* volatile  */)((void *)0);
#line 3361
  i = 0;
#line 3366
  ostype = (char *)((void *)0);
#line 3371
  *may_be_forged = 0;
#line 3372
  falen = (int )sizeof(RealHostAddr);
#line 3373
  tmp___1 = isatty(fd);
  }
#line 3373
  if (tmp___1) {
#line 3373
    goto _L;
  } else {
    {
#line 3373
    i = getpeername(fd, (struct sockaddr */* __restrict  */)(& RealHostAddr.sa), (socklen_t */* __restrict  */)(& falen));
    }
#line 3373
    if (i < 0) {
#line 3373
      goto _L;
    } else
#line 3373
    if (falen <= 0) {
#line 3373
      goto _L;
    } else
#line 3373
    if ((int )RealHostAddr.sa.sa_family == 0) {
      _L: /* CIL Label */ 
#line 3376
      if (i < 0) {
        {
#line 3384
        tmp = __errno_location();
        }
#line 3384
        if (*tmp != 88) {
#line 3385
          return ((char *)((void *)0));
        }
        {
#line 3386
        tmp___0 = __errno_location();
#line 3386
        *tmp___0 = 0;
        }
      }
      {
#line 3388
      sm_strlcpyn(hbuf, (ssize_t )sizeof(hbuf), 2, RealUserName, "@localhost");
      }
#line 3390
      if ((int )tTdvect[9] >= 1) {
        {
#line 3391
        sm_dprintf((char *)"getauthinfo: %s\n", hbuf);
        }
      }
#line 3392
      return (hbuf);
    }
  }
#line 3395
  if ((unsigned long )RealHostName == (unsigned long )((void *)0)) {
    {
#line 3398
    tmp___2 = hostnamebyanyaddr(& RealHostAddr);
#line 3398
    RealHostName = newstr((char const   *)tmp___2);
#line 3399
    tmp___3 = strlen((char const   *)RealHostName);
    }
#line 3399
    if (tmp___3 > 256U) {
#line 3400
      *(RealHostName + 256) = (char )'\000';
    }
  }
  {
#line 3404
  tmp___5 = anynet_ntoa(& RealHostAddr);
  }
#line 3404
  if ((int )*(tmp___5 + 0) != 91) {
#line 3404
    if ((int )*(RealHostName + 0) != 91) {
      {
#line 3409
      family = (int )RealHostAddr.sa.sa_family;
#line 3430
      hp = sm_gethostbyname(RealHostName, family);
      }
#line 3431
      if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 3434
        *may_be_forged = 1;
      } else {
#line 3438
        ha = hp->h_addr_list;
        {
#line 3438
        while (1) {
          while_continue: /* CIL Label */ ;
#line 3438
          if (! ((unsigned long )*ha != (unsigned long )((void *)0))) {
#line 3438
            goto while_break;
          }
          {
#line 3440
          tmp___4 = addrcmp(hp, *ha, & RealHostAddr);
          }
#line 3440
          if (tmp___4 == 0) {
#line 3441
            goto while_break;
          }
#line 3438
          ha ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 3443
        *may_be_forged = (unsigned long )*ha == (unsigned long )((void *)0);
      }
    }
  }
#line 3451
  if (TimeOuts.to_ident == 0L) {
#line 3452
    goto noident;
  }
#line 3454
  lalen = (int )sizeof(la);
  {
#line 3458
  if ((int )RealHostAddr.sa.sa_family == 2) {
#line 3458
    goto case_2;
  }
#line 3540
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 3459
  tmp___6 = getsockname(fd, (struct sockaddr */* __restrict  */)(& la.sa), (socklen_t */* __restrict  */)(& lalen));
  }
#line 3459
  if (tmp___6 < 0) {
#line 3464
    goto noident;
  } else
#line 3459
  if (lalen <= 0) {
#line 3464
    goto noident;
  } else
#line 3459
  if ((int )la.sa.sa_family != 2) {
#line 3464
    goto noident;
  }
  {
#line 3466
  port = RealHostAddr.sin.sin_port;
#line 3469
  tmp___7 = ntohs(la.sin.sin_port);
#line 3469
  tmp___8 = ntohs(RealHostAddr.sin.sin_port);
#line 3469
  sm_snprintf(ibuf, (size_t )sizeof(ibuf), "%d,%d\r\n", (int )tmp___8, (int )tmp___7);
#line 3474
  la.sin.sin_port = (in_port_t )0;
  }
#line 3492
  if ((int )port4 == 0) {
    {
#line 3494
    sp = getservbyname("auth", "tcp");
    }
#line 3495
    if ((unsigned long )sp != (unsigned long )((void *)0)) {
#line 3496
      port4 = (unsigned short )sp->s_port;
    } else {
      {
#line 3498
      port4 = htons((uint16_t )113);
      }
    }
  }
#line 3500
  RealHostAddr.sin.sin_port = port4;
#line 3501
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3542
  goto noident;
  switch_break: /* CIL Label */ ;
  }
  {
#line 3545
  s = (int volatile   )-1;
#line 3546
  tmp___9 = __sigsetjmp((struct __jmp_buf_tag *)(CtxAuthTimeout), 1);
  }
#line 3546
  if (tmp___9 != 0) {
#line 3548
    if (s >= (int volatile   )0) {
      {
#line 3549
      close((int )s);
      }
    }
#line 3550
    goto noident;
  }
  {
#line 3554
  ev = sm_seteventm((int )(TimeOuts.to_ident * 1000L), & authtimeout, 0);
#line 3557
  tmp___10 = socket((int )la.sa.sa_family, 1, 0);
#line 3557
  s = (int volatile   )tmp___10;
  }
#line 3558
  if (s < (int volatile   )0) {
    {
#line 3560
    sm_clrevent(ev);
    }
#line 3561
    goto noident;
  }
  {
#line 3563
  tmp___11 = bind((int )s, (struct sockaddr  const  *)(& la.sa), (socklen_t )lalen);
  }
#line 3563
  if (tmp___11 < 0) {
#line 3565
    goto closeident;
  } else {
    {
#line 3563
    tmp___12 = connect((int )s, (struct sockaddr  const  *)(& RealHostAddr.sa), (socklen_t )lalen);
    }
#line 3563
    if (tmp___12 < 0) {
#line 3565
      goto closeident;
    }
  }
#line 3567
  if ((int )tTdvect[9] >= 10) {
    {
#line 3568
    sm_dprintf((char *)"getauthinfo: sent %s", ibuf);
    }
  }
  {
#line 3571
  tmp___13 = strlen((char const   *)(ibuf));
#line 3571
  tmp___14 = write((int )s, (void const   *)(ibuf), tmp___13);
  }
#line 3571
  if (tmp___14 < 0) {
#line 3572
    goto closeident;
  }
#line 3575
  p = (char */* volatile  */)(& ibuf[0]);
#line 3576
  nleft = (int )(sizeof(ibuf) - 1UL);
  {
#line 3577
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 3577
    i = read((int )s, (void *)p, (size_t )nleft);
    }
#line 3577
    if (! (i > 0)) {
#line 3577
      goto while_break___0;
    }
    {
#line 3581
    p += i;
#line 3582
    nleft -= i;
#line 3583
    *p = (char )'\000';
#line 3584
    s___0 = strchr((char const   *)(ibuf), '\n');
    }
#line 3584
    if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
#line 3586
      if ((unsigned long )p > (unsigned long )(s___0 + 1)) {
#line 3588
        p = (char */* volatile  */)(s___0 + 1);
#line 3589
        *p = (char )'\000';
      }
#line 3591
      goto while_break___0;
    }
#line 3593
    if (nleft <= 0) {
#line 3594
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3596
  close((int )s);
#line 3597
  sm_clrevent(ev);
  }
#line 3598
  if (i < 0) {
#line 3599
    goto noident;
  } else
#line 3598
  if ((unsigned long )p == (unsigned long )(& ibuf[0])) {
#line 3599
    goto noident;
  }
#line 3601
  if ((unsigned long )p >= (unsigned long )(& ibuf[2])) {
#line 3601
    p --;
#line 3601
    if ((int )*p == 10) {
#line 3601
      p --;
#line 3601
      if ((int )*p == 13) {
#line 3602
        p --;
      }
    }
  }
#line 3603
  p ++;
#line 3603
  *p = (char )'\000';
#line 3605
  if ((int )tTdvect[9] >= 3) {
    {
#line 3606
    sm_dprintf((char *)"getauthinfo:  got %s\n", ibuf);
    }
  }
  {
#line 3609
  tmp___15 = strchr((char const   *)(ibuf), ':');
#line 3609
  p = (char */* volatile  */)tmp___15;
  }
#line 3610
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3613
    goto noident;
  }
  {
#line 3615
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3615
    p ++;
#line 3615
    if (((int )*p & -128) == 0) {
      {
#line 3615
      tmp___16 = __ctype_b_loc();
      }
#line 3615
      if (! ((int const   )*(*tmp___16 + (int )*p) & 8192)) {
#line 3615
        goto while_break___1;
      }
    } else {
#line 3615
      goto while_break___1;
    }
#line 3616
    goto while_continue___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3617
  tmp___17 = sm_strncasecmp((char const   *)p, "userid", (size_t )6);
  }
#line 3617
  if (tmp___17 != 0) {
#line 3620
    goto noident;
  }
#line 3622
  p += 6;
  {
#line 3623
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3623
    if (((int )*p & -128) == 0) {
      {
#line 3623
      tmp___18 = __ctype_b_loc();
      }
#line 3623
      if (! ((int const   )*(*tmp___18 + (int )*p) & 8192)) {
#line 3623
        goto while_break___2;
      }
    } else {
#line 3623
      goto while_break___2;
    }
#line 3624
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3625
  tmp___19 = p;
#line 3625
  p ++;
#line 3625
  if ((int )*tmp___19 != 58) {
#line 3628
    goto noident;
  }
  {
#line 3632
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3632
    if (((int )*p & -128) == 0) {
      {
#line 3632
      tmp___20 = __ctype_b_loc();
      }
#line 3632
      if (! ((int const   )*(*tmp___20 + (int )*p) & 8192)) {
#line 3632
        goto while_break___3;
      }
    } else {
#line 3632
      goto while_break___3;
    }
#line 3633
    p ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 3634
  ostype = (char *)p;
#line 3635
  tmp___21 = strchr((char const   *)p, ':');
#line 3635
  p = (char */* volatile  */)tmp___21;
  }
#line 3636
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3639
    goto noident;
  } else {
    {
#line 3645
    *p = (char )'\000';
#line 3646
    charset = strchr((char const   *)ostype, ',');
    }
#line 3647
    if ((unsigned long )charset != (unsigned long )((void *)0)) {
#line 3648
      *charset = (char )'\000';
    }
  }
  {
#line 3652
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3652
    p ++;
#line 3652
    if (((int )*p & -128) == 0) {
      {
#line 3652
      tmp___22 = __ctype_b_loc();
      }
#line 3652
      if (! ((int const   )*(*tmp___22 + (int )*p) & 8192)) {
#line 3652
        goto while_break___4;
      }
    } else {
#line 3652
      goto while_break___4;
    }
#line 3653
    goto while_continue___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 3656
  tmp___23 = sm_strncasecmp((char const   *)ostype, "other", (size_t )5);
  }
#line 3656
  if (tmp___23 == 0) {
#line 3656
    if ((int )*(ostype + 5) == 32) {
      {
#line 3659
      sm_strlcpy(hbuf, "IDENT:", (ssize_t )sizeof(hbuf));
#line 3660
      cleanstrcpy(& hbuf[6], (char *)p, 100);
      }
    } else
#line 3656
    if ((int )*(ostype + 5) == 0) {
      {
#line 3659
      sm_strlcpy(hbuf, "IDENT:", (ssize_t )sizeof(hbuf));
#line 3660
      cleanstrcpy(& hbuf[6], (char *)p, 100);
      }
    } else {
      {
#line 3663
      cleanstrcpy(hbuf, (char *)p, 100);
      }
    }
  } else {
    {
#line 3663
    cleanstrcpy(hbuf, (char *)p, 100);
    }
  }
  {
#line 3664
  len___0 = strlen((char const   *)(hbuf));
  }
#line 3665
  if ((unsigned long )RealHostName == (unsigned long )((void *)0)) {
#line 3665
    tmp___24 = "localhost";
  } else {
#line 3665
    tmp___24 = (char const   *)RealHostName;
  }
  {
#line 3665
  sm_strlcpyn(& hbuf[len___0], (ssize_t )(sizeof(hbuf) - (unsigned long )len___0),
              2, "@", tmp___24);
  }
#line 3667
  goto postident;
  closeident: 
  {
#line 3670
  close((int )s);
#line 3671
  sm_clrevent(ev);
  }
  noident: 
  {
#line 3678
  if ((int )RealHostAddr.sa.sa_family == 2) {
#line 3678
    goto case_2___0;
  }
#line 3675
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 3679
  if ((int )port > 0) {
#line 3680
    RealHostAddr.sin.sin_port = port;
  }
#line 3681
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 3692
  if ((unsigned long )RealHostName == (unsigned long )((void *)0)) {
#line 3694
    if ((int )tTdvect[9] >= 1) {
      {
#line 3695
      sm_dprintf((char *)"getauthinfo: NULL\n");
      }
    }
#line 3696
    return ((char *)((void *)0));
  }
  {
#line 3698
  sm_strlcpy(hbuf, (char const   *)RealHostName, (ssize_t )sizeof(hbuf));
  }
  postident: 
#line 3806
  if ((unsigned long )RealHostName != (unsigned long )((void *)0)) {
#line 3806
    if ((int )*(RealHostName + 0) != 91) {
      {
#line 3808
      tmp___25 = strlen((char const   *)(hbuf));
#line 3808
      p = (char */* volatile  */)(& hbuf[tmp___25]);
#line 3809
      tmp___26 = anynet_ntoa(& RealHostAddr);
#line 3809
      sm_snprintf((char *)p, (size_t )(sizeof(hbuf) - (unsigned long )(p - (char */* volatile  */)(hbuf))),
                  " [%.100s]", tmp___26);
      }
    }
  }
#line 3812
  if (*may_be_forged) {
    {
#line 3814
    tmp___27 = strlen((char const   *)(hbuf));
#line 3814
    p = (char */* volatile  */)(& hbuf[tmp___27]);
#line 3815
    sm_strlcpy((char *)p, " (may be forged)", (ssize_t )(sizeof(hbuf) - (unsigned long )(p - (char */* volatile  */)(hbuf))));
#line 3816
    tmp___28 = macid_parse((char *)"{client_resolve}", (char **)((void *)0));
#line 3816
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___28, (char *)"FORGED",
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                     3817, SmHeapGroup);
    }
  }
  {
#line 3828
  if ((int )RealHostAddr.sa.sa_family == 2) {
#line 3828
    goto case_2___1;
  }
#line 3825
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 3829
  if ((int )port > 0) {
#line 3830
    RealHostAddr.sin.sin_port = port;
  }
#line 3831
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 3842
  if ((int )tTdvect[9] >= 1) {
    {
#line 3843
    sm_dprintf((char *)"getauthinfo: %s\n", hbuf);
    }
  }
#line 3844
  return (hbuf);
}
}
#line 3868 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
char *host_map_lookup(struct _map *map___0 , char *name , char **av___0 , int *statp ) 
{ 
  register struct hostent *hp ;
  struct in_addr in_addr ;
  char *cp ;
  char *ans ;
  register STAB *s ;
  time_t now ;
  time_t retrans ;
  int retry ;
  char hbuf___0[257] ;
  char const   *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  struct __res_state *tmp___5 ;
  struct __res_state *tmp___6 ;
  struct __res_state *tmp___7 ;
  struct __res_state *tmp___8 ;
  int ttl ;
  int tmp___9 ;
  bool tmp___10 ;
  struct __res_state *tmp___11 ;
  struct __res_state *tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
  {
#line 3882
  ans = (char *)((void *)0);
#line 3886
  retrans = (time_t )0;
#line 3887
  retry = 0;
#line 3896
  now = curtime();
#line 3897
  s = stab(name, 8, 1);
  }
#line 3898
  if (((int )s->s_value.sv_namecanon.nc_flags & 1) != 0) {
#line 3898
    if (s->s_value.sv_namecanon.nc_exp >= now) {
#line 3901
      if ((int )tTdvect[9] >= 1) {
#line 3902
        if ((unsigned long )s->s_value.sv_namecanon.nc_cname == (unsigned long )((void *)0)) {
#line 3902
          tmp = "NULL";
        } else {
#line 3902
          tmp = (char const   *)s->s_value.sv_namecanon.nc_cname;
        }
        {
#line 3902
        sm_dprintf((char *)"host_map_lookup(%s) => CACHE %s\n", name, tmp);
        }
      }
      {
#line 3907
      tmp___0 = __errno_location();
#line 3907
      *tmp___0 = (int )s->s_value.sv_namecanon.nc_errno;
#line 3908
      tmp___1 = __h_errno_location();
#line 3908
      *tmp___1 = (int )s->s_value.sv_namecanon.nc_herrno;
#line 3909
      *statp = (int )s->s_value.sv_namecanon.nc_stat;
      }
#line 3910
      if (*statp == 75) {
        {
#line 3912
        CurEnv->e_status = (char *)"4.4.3";
#line 3913
        tmp___2 = shortenstring((char const   *)name, (size_t )33);
#line 3913
        message("851 %s: Name server timeout", tmp___2);
        }
      }
#line 3916
      if (*statp != 0) {
#line 3917
        return ((char *)((void *)0));
      }
#line 3918
      if ((unsigned long )s->s_value.sv_namecanon.nc_cname == (unsigned long )((void *)0)) {
        {
#line 3920
        syserr("host_map_lookup(%s): bogus NULL cache entry, errno=%d, h_errno=%d",
               name, (int )s->s_value.sv_namecanon.nc_errno, (int )s->s_value.sv_namecanon.nc_herrno);
        }
#line 3924
        return ((char *)((void *)0));
      }
#line 3926
      if ((map___0->map_mflags & 16L) != 0L) {
        {
#line 3927
        tmp___3 = strlen((char const   *)name);
#line 3927
        cp = map_rewrite(map___0, (char const   *)name, tmp___3, (char **)((void *)0));
        }
      } else {
        {
#line 3929
        tmp___4 = strlen((char const   *)s->s_value.sv_namecanon.nc_cname);
#line 3929
        cp = map_rewrite(map___0, (char const   *)s->s_value.sv_namecanon.nc_cname,
                         tmp___4, av___0);
        }
      }
#line 3933
      return (cp);
    }
  }
#line 3942
  if ((int )CurEnv->e_sendmode == 100) {
#line 3942
    if ((map___0->map_mflags & 524288L) != 0L) {
#line 3945
      if ((int )tTdvect[9] >= 1) {
        {
#line 3946
        sm_dprintf((char *)"host_map_lookup(%s) => DEFERRED\n", name);
        }
      }
#line 3947
      *statp = 75;
#line 3948
      return ((char *)((void *)0));
    }
  }
#line 3958
  if ((int )tTdvect[9] >= 1) {
    {
#line 3959
    sm_dprintf((char *)"host_map_lookup(%s) => ", name);
    }
  }
#line 3961
  if (map___0->map_timeout > 0L) {
    {
#line 3963
    tmp___5 = __res_state();
#line 3963
    retrans = (time_t )tmp___5->retrans;
#line 3964
    tmp___6 = __res_state();
#line 3964
    tmp___6->retrans = (int )map___0->map_timeout;
    }
  }
#line 3966
  if (map___0->map_retry > 0) {
    {
#line 3968
    tmp___7 = __res_state();
#line 3968
    retry = tmp___7->retry;
#line 3969
    tmp___8 = __res_state();
#line 3969
    tmp___8->retry = map___0->map_retry;
    }
  }
#line 3974
  s->s_value.sv_namecanon.nc_exp = now + 3600L;
#line 3975
  if ((int )*name != 91) {
    {
#line 3979
    sm_strlcpy(hbuf___0, (char const   *)name, (ssize_t )sizeof(hbuf___0));
#line 3980
    tmp___10 = getcanonname(hbuf___0, (int )(sizeof(hbuf___0) - 1UL), ! HasWildcardMX,
                            & ttl);
    }
#line 3980
    if (tmp___10) {
#line 3982
      ans = hbuf___0;
#line 3983
      if (ttl > 0) {
#line 3984
        if (ttl < 3600) {
#line 3984
          tmp___9 = ttl;
        } else {
#line 3984
          tmp___9 = 3600;
        }
#line 3984
        s->s_value.sv_namecanon.nc_exp = now + (time_t )tmp___9;
      }
    }
  } else {
    {
#line 3990
    cp = strchr((char const   *)name, ']');
    }
#line 3990
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 3992
      if ((int )tTdvect[9] >= 1) {
        {
#line 3993
        sm_dprintf((char *)"FAILED\n");
        }
      }
#line 3994
      return ((char *)((void *)0));
    }
    {
#line 3996
    *cp = (char )'\000';
#line 3998
    hp = (struct hostent *)((void *)0);
#line 4000
    in_addr.s_addr = inet_addr((char const   *)(name + 1));
    }
#line 4000
    if (in_addr.s_addr != 4294967295U) {
      {
#line 4001
      hp = sm_gethostbyaddr((char *)(& in_addr), 4, 2);
      }
    }
#line 4010
    *cp = (char )']';
#line 4012
    if ((unsigned long )hp != (unsigned long )((void *)0)) {
      {
#line 4015
      ans = denlstring(hp->h_name, 1, 1);
      }
    }
  }
#line 4031
  if (map___0->map_timeout > 0L) {
    {
#line 4032
    tmp___11 = __res_state();
#line 4032
    tmp___11->retrans = (int )retrans;
    }
  }
#line 4033
  if (map___0->map_retry > 0) {
    {
#line 4034
    tmp___12 = __res_state();
#line 4034
    tmp___12->retry = retry;
    }
  }
#line 4037
  s->s_value.sv_namecanon.nc_flags = (short )((int )s->s_value.sv_namecanon.nc_flags | 1);
#line 4040
  if ((unsigned long )ans != (unsigned long )((void *)0)) {
#line 4042
    tmp___13 = 0;
#line 4042
    *statp = tmp___13;
#line 4042
    s->s_value.sv_namecanon.nc_stat = (short )tmp___13;
#line 4043
    if ((unsigned long )s->s_value.sv_namecanon.nc_cname != (unsigned long )((void *)0)) {
      {
#line 4044
      sm_free_tagged((void *)s->s_value.sv_namecanon.nc_cname, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c",
                     4044);
      }
    }
    {
#line 4045
    s->s_value.sv_namecanon.nc_cname = sm_strdup_x((char const   *)ans);
    }
#line 4046
    if ((map___0->map_mflags & 16L) != 0L) {
      {
#line 4047
      tmp___14 = strlen((char const   *)name);
#line 4047
      cp = map_rewrite(map___0, (char const   *)name, tmp___14, (char **)((void *)0));
      }
    } else {
      {
#line 4049
      tmp___15 = strlen((char const   *)ans);
#line 4049
      cp = map_rewrite(map___0, (char const   *)ans, tmp___15, av___0);
      }
    }
#line 4050
    if ((int )tTdvect[9] >= 1) {
      {
#line 4051
      sm_dprintf((char *)"FOUND %s\n", ans);
      }
    }
#line 4052
    return (cp);
  }
  {
#line 4057
  tmp___16 = __errno_location();
#line 4057
  s->s_value.sv_namecanon.nc_errno = (short )*tmp___16;
#line 4059
  tmp___17 = __h_errno_location();
#line 4059
  s->s_value.sv_namecanon.nc_herrno = (short )*tmp___17;
  }
#line 4060
  if ((int )tTdvect[9] >= 1) {
    {
#line 4061
    tmp___18 = __h_errno_location();
#line 4061
    sm_dprintf((char *)"FAIL (%d)\n", *tmp___18);
    }
  }
  {
#line 4062
  tmp___19 = __h_errno_location();
  }
  {
#line 4064
  if (*tmp___19 == 2) {
#line 4064
    goto case_2;
  }
#line 4075
  if (*tmp___19 == 4) {
#line 4075
    goto case_4;
  }
#line 4075
  if (*tmp___19 == 1) {
#line 4075
    goto case_4;
  }
#line 4079
  if (*tmp___19 == 3) {
#line 4079
    goto case_3;
  }
#line 4083
  goto switch_default;
  case_2: /* CIL Label */ 
#line 4065
  if (UseNameServer) {
    {
#line 4067
    CurEnv->e_status = (char *)"4.4.3";
#line 4068
    tmp___20 = shortenstring((char const   *)name, (size_t )33);
#line 4068
    message("851 %s: Name server timeout", tmp___20);
    }
  }
#line 4071
  *statp = 75;
#line 4072
  goto switch_break;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 4076
  *statp = 68;
#line 4077
  goto switch_break;
  case_3: /* CIL Label */ 
#line 4080
  *statp = 70;
#line 4081
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4084
  *statp = 69;
#line 4085
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4092
  s->s_value.sv_namecanon.nc_stat = (short )*statp;
#line 4093
  return ((char *)((void *)0));
}
}
#line 4106 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
bool host_map_init(struct _map *map___0 , char *args ) 
{ 
  register char *p ;
  unsigned short const   **tmp ;
  char *h ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;

  {
#line 4111
  p = args;
  {
#line 4113
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4115
      if (((int )*p & -128) == 0) {
        {
#line 4115
        tmp = __ctype_b_loc();
        }
#line 4115
        if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 4115
          goto while_break___0;
        }
      } else {
#line 4115
        goto while_break___0;
      }
#line 4116
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4117
    if ((int )*p != 45) {
#line 4118
      goto while_break;
    }
#line 4119
    p ++;
    {
#line 4121
    if ((int )*p == 97) {
#line 4121
      goto case_97;
    }
#line 4125
    if ((int )*p == 84) {
#line 4125
      goto case_84;
    }
#line 4129
    if ((int )*p == 109) {
#line 4129
      goto case_109;
    }
#line 4133
    if ((int )*p == 116) {
#line 4133
      goto case_116;
    }
#line 4137
    if ((int )*p == 83) {
#line 4137
      goto case_83;
    }
#line 4141
    if ((int )*p == 68) {
#line 4141
      goto case_68;
    }
#line 4145
    if ((int )*p == 100) {
#line 4145
      goto case_100;
    }
#line 4160
    if ((int )*p == 114) {
#line 4160
      goto case_114;
    }
#line 4119
    goto switch_break;
    case_97: /* CIL Label */ 
#line 4122
    p ++;
#line 4122
    map___0->map_app = p;
#line 4123
    goto switch_break;
    case_84: /* CIL Label */ 
#line 4126
    p ++;
#line 4126
    map___0->map_tapp = p;
#line 4127
    goto switch_break;
    case_109: /* CIL Label */ 
#line 4130
    map___0->map_mflags |= 16L;
#line 4131
    goto switch_break;
    case_116: /* CIL Label */ 
#line 4134
    map___0->map_mflags |= 131072L;
#line 4135
    goto switch_break;
    case_83: /* CIL Label */ 
#line 4138
    p ++;
#line 4138
    map___0->map_spacesub = *p;
#line 4139
    goto switch_break;
    case_68: /* CIL Label */ 
#line 4142
    map___0->map_mflags |= 524288L;
#line 4143
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 4149
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4149
      p ++;
#line 4149
      if (((int )*p & -128) == 0) {
        {
#line 4149
        tmp___0 = __ctype_b_loc();
        }
#line 4149
        if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 4149
          goto while_break___1;
        }
      } else {
#line 4149
        goto while_break___1;
      }
#line 4150
      goto while_continue___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 4151
    h = strchr((char const   *)p, ' ');
    }
#line 4152
    if ((unsigned long )h != (unsigned long )((void *)0)) {
#line 4153
      *h = (char )'\000';
    }
    {
#line 4154
    map___0->map_timeout = convtime(p, 's');
    }
#line 4155
    if ((unsigned long )h != (unsigned long )((void *)0)) {
#line 4156
      *h = (char )' ';
    }
#line 4158
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 4161
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4161
      p ++;
#line 4161
      if (((int )*p & -128) == 0) {
        {
#line 4161
        tmp___1 = __ctype_b_loc();
        }
#line 4161
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 4161
          goto while_break___2;
        }
      } else {
#line 4161
        goto while_break___2;
      }
#line 4162
      goto while_continue___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 4163
    map___0->map_retry = atoi((char const   *)p);
    }
#line 4164
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 4166
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4166
      if ((int )*p != 0) {
#line 4166
        if (((int )*p & -128) == 0) {
          {
#line 4166
          tmp___2 = __ctype_b_loc();
          }
#line 4166
          if ((int const   )*(*tmp___2 + (int )*p) & 8192) {
#line 4166
            goto while_break___3;
          }
        }
      } else {
#line 4166
        goto while_break___3;
      }
#line 4167
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 4168
    if ((int )*p != 0) {
#line 4169
      tmp___3 = p;
#line 4169
      p ++;
#line 4169
      *tmp___3 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4171
  if ((unsigned long )map___0->map_app != (unsigned long )((void *)0)) {
    {
#line 4172
    map___0->map_app = newstr((char const   *)map___0->map_app);
    }
  }
#line 4173
  if ((unsigned long )map___0->map_tapp != (unsigned long )((void *)0)) {
    {
#line 4174
    map___0->map_tapp = newstr((char const   *)map___0->map_tapp);
    }
  }
#line 4175
  return (1);
}
}
#line 4276 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static char buf___13[100]  ;
#line 4269 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
char *anynet_ntoa(union bigsockaddr *sap ) 
{ 
  register char *bp___3 ;
  register char *ap ;
  int l ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 4279
  if ((unsigned long )sap == (unsigned long )((void *)0)) {
#line 4280
    return ((char *)"NULLADDR");
  }
#line 4281
  if ((int )sap->sa.sa_family == 0) {
#line 4282
    return ((char *)"0");
  }
  {
#line 4287
  if ((int )sap->sa.sa_family == 1) {
#line 4287
    goto case_1;
  }
#line 4297
  if ((int )sap->sa.sa_family == 2) {
#line 4297
    goto case_2;
  }
#line 4315
  goto switch_default;
  case_1: /* CIL Label */ 
#line 4288
  if ((int )sap->sunix.sun_path[0] != 0) {
    {
#line 4289
    sm_snprintf(buf___13, (size_t )sizeof(buf___13), "[UNIX: %.64s]", sap->sunix.sun_path);
    }
  } else {
    {
#line 4292
    sm_strlcpy(buf___13, "[UNIX: localhost]", (ssize_t )sizeof(buf___13));
    }
  }
#line 4293
  return (buf___13);
  case_2: /* CIL Label */ 
  {
#line 4298
  tmp = inet_ntoa(sap->sin.sin_addr);
  }
#line 4298
  return (tmp);
  switch_default: /* CIL Label */ 
#line 4318
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 4322
  sm_snprintf(buf___13, (size_t )sizeof(buf___13), "Family %d: ", (int )sap->sa.sa_family);
#line 4323
  tmp___0 = strlen((char const   *)(buf___13));
#line 4323
  bp___3 = & buf___13[tmp___0];
#line 4324
  ap = sap->sa.sa_data;
#line 4325
  l = (int )sizeof(sap->sa.sa_data);
  }
  {
#line 4325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4325
    l --;
#line 4325
    if (! (l >= 0)) {
#line 4325
      goto while_break;
    }
    {
#line 4327
    tmp___1 = ap;
#line 4327
    ap ++;
#line 4327
    sm_snprintf(bp___3, (size_t )(sizeof(buf___13) - (unsigned long )(bp___3 - buf___13)),
                "%02x:", (int )*tmp___1 & 255);
#line 4329
    bp___3 += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4331
  bp___3 --;
#line 4331
  *bp___3 = (char )'\000';
#line 4332
  return (buf___13);
}
}
#line 4446 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
static char buf___14[203]  ;
#line 4347 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/daemon.c"
char *hostnamebyanyaddr(union bigsockaddr *sap ) 
{ 
  register struct hostent *hp ;
  int saveretry ;
  struct __res_state *tmp ;
  struct __res_state *tmp___0 ;
  struct __res_state *tmp___1 ;
  struct __res_state *tmp___2 ;
  struct __res_state *tmp___3 ;
  struct __res_state *tmp___4 ;
  char *name ;
  in_addr_t tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 4361
  tmp = __res_state();
#line 4361
  saveretry = tmp->retry;
#line 4362
  tmp___2 = __res_state();
#line 4362
  tmp___3 = __res_state();
  }
#line 4362
  if (tmp___2->retry * tmp___3->retrans > 20) {
    {
#line 4363
    tmp___0 = __res_state();
#line 4363
    tmp___1 = __res_state();
#line 4363
    tmp___0->retry = 20 / tmp___1->retrans;
    }
  }
  {
#line 4369
  if ((int )sap->sa.sa_family == 2) {
#line 4369
    goto case_2;
  }
#line 4390
  if ((int )sap->sa.sa_family == 1) {
#line 4390
    goto case_1;
  }
#line 4395
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 4370
  hp = sm_gethostbyaddr((char *)(& sap->sin.sin_addr), 4, 2);
  }
#line 4372
  goto switch_break;
  case_1: /* CIL Label */ 
#line 4391
  hp = (struct hostent *)((void *)0);
#line 4392
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 4396
  hp = sm_gethostbyaddr(sap->sa.sa_data, (int )sizeof(sap->sa.sa_data), (int )sap->sa.sa_family);
  }
#line 4398
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 4402
  tmp___4 = __res_state();
#line 4402
  tmp___4->retry = saveretry;
  }
#line 4406
  if ((unsigned long )hp != (unsigned long )((void *)0)) {
#line 4406
    if ((int )*(hp->h_name + 0) != 91) {
      {
#line 4406
      tmp___5 = inet_addr((char const   *)hp->h_name);
      }
#line 4406
      if (tmp___5 == 4294967295U) {
        {
#line 4417
        name = denlstring(hp->h_name, 1, 1);
        }
#line 4429
        return (name);
      }
    }
  }
#line 4442
  if ((int )sap->sa.sa_family == 1) {
#line 4442
    if ((int )sap->sunix.sun_path[0] == 0) {
#line 4443
      return ((char *)"localhost");
    }
  }
  {
#line 4448
  tmp___6 = anynet_ntoa(sap);
#line 4448
  sm_snprintf(buf___14, (size_t )sizeof(buf___14), "[%.200s]", tmp___6);
  }
#line 4450
  return (buf___14);
}
}
#line 41 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/convtime.c"
time_t convtime(char *p , int units ) 
{ 
  register time_t t ;
  register time_t r ;
  register char c ;
  bool pos ;
  int tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  time_t tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 48
  pos = 1;
#line 50
  r = (time_t )0;
#line 51
  tmp = sm_strcasecmp((char const   *)p, "now");
  }
#line 51
  if (tmp == 0) {
#line 52
    return ((time_t )-1);
  }
#line 53
  if ((int )*p == 45) {
#line 55
    pos = 0;
#line 56
    p ++;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! ((int )*p != 0)) {
#line 58
      goto while_break;
    }
#line 60
    t = (time_t )0;
    {
#line 61
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 61
      tmp___0 = p;
#line 61
      p ++;
#line 61
      c = *tmp___0;
#line 61
      if ((int )c != 0) {
#line 61
        if (((int )c & -128) == 0) {
          {
#line 61
          tmp___1 = __ctype_b_loc();
          }
#line 61
          if (! ((int const   )*(*tmp___1 + (int )c) & 2048)) {
#line 61
            goto while_break___0;
          }
        } else {
#line 61
          goto while_break___0;
        }
      } else {
#line 61
        goto while_break___0;
      }
#line 62
      t = t * 10L + (time_t )((int )c - 48);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 63
    if ((int )c == 0) {
#line 65
      c = (char )units;
#line 66
      p --;
    } else {
      {
#line 68
      tmp___2 = strchr("wdhms", (int )c);
      }
#line 68
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
#line 70
        usrerr("Invalid time unit `%c\'", (int )c);
#line 71
        c = (char )units;
        }
      }
    }
    {
#line 75
    if ((int )c == 119) {
#line 75
      goto case_119;
    }
#line 85
    if ((int )c == 104) {
#line 85
      goto case_104;
    }
#line 89
    if ((int )c == 109) {
#line 89
      goto case_109;
    }
#line 93
    if ((int )c == 115) {
#line 93
      goto case_115;
    }
#line 81
    goto switch_default;
    case_119: /* CIL Label */ 
#line 76
    t *= 7L;
    switch_default: /* CIL Label */ 
#line 82
    t *= 24L;
    case_104: /* CIL Label */ 
#line 86
    t *= 60L;
    case_109: /* CIL Label */ 
#line 90
    t *= 60L;
    case_115: /* CIL Label */ 
#line 94
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 96
    r += t;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  if (pos) {
#line 99
    tmp___3 = r;
  } else {
#line 99
    tmp___3 = - r;
  }
#line 99
  return (tmp___3);
}
}
#line 127 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/convtime.c"
static char buf___15[256]  ;
#line 122 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/convtime.c"
char *pintvl(time_t intvl , bool brief ) 
{ 
  register char *p ;
  int wk ;
  int dy ;
  int hr ;
  int mi ;
  int se ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 131
  if (intvl == 0L) {
#line 131
    if (! brief) {
#line 132
      return ((char *)"zero seconds");
    }
  }
#line 133
  if (intvl == -1L) {
#line 134
    return ((char *)"too long");
  }
#line 137
  se = (int )(intvl % 60L);
#line 138
  intvl /= 60L;
#line 139
  mi = (int )(intvl % 60L);
#line 140
  intvl /= 60L;
#line 141
  hr = (int )(intvl % 24L);
#line 142
  intvl /= 24L;
#line 143
  if (brief) {
#line 145
    dy = (int )intvl;
#line 146
    wk = 0;
  } else {
#line 150
    dy = (int )(intvl % 7L);
#line 151
    intvl /= 7L;
#line 152
    wk = (int )intvl;
  }
#line 156
  p = buf___15;
#line 157
  if (brief) {
#line 159
    if (dy > 0) {
      {
#line 161
      sm_snprintf(p, (size_t )(sizeof(buf___15) - (unsigned long )(p - buf___15)),
                  "%d+", dy);
#line 162
      tmp = strlen((char const   *)p);
#line 162
      p += tmp;
      }
    }
    {
#line 164
    sm_snprintf(p, (size_t )(sizeof(buf___15) - (unsigned long )(p - buf___15)), "%02d:%02d:%02d",
                hr, mi, se);
    }
#line 166
    return (buf___15);
  }
#line 170
  if (wk > 0) {
#line 172
    if (wk == 1) {
#line 172
      tmp___0 = "";
    } else {
#line 172
      tmp___0 = "s";
    }
    {
#line 172
    sm_snprintf(p, (size_t )(sizeof(buf___15) - (unsigned long )(p - buf___15)), ", %d week%s",
                wk, tmp___0);
#line 174
    tmp___1 = strlen((char const   *)p);
#line 174
    p += tmp___1;
    }
  }
#line 176
  if (dy > 0) {
#line 178
    if (dy == 1) {
#line 178
      tmp___2 = "";
    } else {
#line 178
      tmp___2 = "s";
    }
    {
#line 178
    sm_snprintf(p, (size_t )(sizeof(buf___15) - (unsigned long )(p - buf___15)), ", %d day%s",
                dy, tmp___2);
#line 180
    tmp___3 = strlen((char const   *)p);
#line 180
    p += tmp___3;
    }
  }
#line 182
  if (hr > 0) {
#line 184
    if (hr == 1) {
#line 184
      tmp___4 = "";
    } else {
#line 184
      tmp___4 = "s";
    }
    {
#line 184
    sm_snprintf(p, (size_t )(sizeof(buf___15) - (unsigned long )(p - buf___15)), ", %d hour%s",
                hr, tmp___4);
#line 186
    tmp___5 = strlen((char const   *)p);
#line 186
    p += tmp___5;
    }
  }
#line 188
  if (mi > 0) {
#line 190
    if (mi == 1) {
#line 190
      tmp___6 = "";
    } else {
#line 190
      tmp___6 = "s";
    }
    {
#line 190
    sm_snprintf(p, (size_t )(sizeof(buf___15) - (unsigned long )(p - buf___15)), ", %d minute%s",
                mi, tmp___6);
#line 192
    tmp___7 = strlen((char const   *)p);
#line 192
    p += tmp___7;
    }
  }
#line 194
  if (se > 0) {
#line 196
    if (se == 1) {
#line 196
      tmp___8 = "";
    } else {
#line 196
      tmp___8 = "s";
    }
    {
#line 196
    sm_snprintf(p, (size_t )(sizeof(buf___15) - (unsigned long )(p - buf___15)), ", %d second%s",
                se, tmp___8);
#line 198
    tmp___9 = strlen((char const   *)p);
#line 198
    p += tmp___9;
    }
  }
#line 201
  return (buf___15 + 2);
}
}
#line 418 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
#line 256 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 34 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/control.c"
static struct cmd CmdTab___0[6]  = {      {(char *)"help", 3}, 
        {(char *)"restart", 1}, 
        {(char *)"shutdown", 2}, 
        {(char *)"status", 4}, 
        {(char *)"memdump", 5}, 
        {(char *)((void *)0), 0}};
#line 49
static void controltimeout(int timeout ) ;
#line 50 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/control.c"
int ControlSocket  =    -1;
#line 65 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/control.c"
int opencontrolsocket(void) 
{ 
  int save_errno ;
  int rval ;
  long sff ;
  struct sockaddr_un controladdr ;
  int *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  uid_t u ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  __uid_t tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 71
  sff = 9027L;
#line 74
  if ((unsigned long )ControlSocketName == (unsigned long )((void *)0)) {
#line 75
    return (0);
  } else
#line 74
  if ((int )*ControlSocketName == 0) {
#line 75
    return (0);
  }
  {
#line 77
  tmp___0 = strlen((char const   *)ControlSocketName);
  }
#line 77
  if ((unsigned long )tmp___0 >= sizeof(controladdr.sun_path)) {
    {
#line 79
    tmp = __errno_location();
#line 79
    *tmp = 36;
    }
#line 80
    return (-1);
  }
  {
#line 83
  rval = safefile(ControlSocketName, RunAsUid, RunAsGid, RunAsUserName, sff, 384,
                  (struct stat *)((void *)0));
  }
#line 87
  if (rval != 0) {
    {
#line 89
    tmp___1 = __errno_location();
#line 89
    *tmp___1 = rval;
    }
#line 90
    return (-1);
  }
  {
#line 93
  ControlSocket = socket(1, 1, 0);
  }
#line 94
  if (ControlSocket < 0) {
#line 95
    return (-1);
  }
#line 96
  if (ControlSocket >= 1024) {
    {
#line 98
    clrcontrol();
#line 99
    tmp___2 = __errno_location();
#line 99
    *tmp___2 = 22;
    }
#line 100
    return (-1);
  }
  {
#line 103
  unlink((char const   *)ControlSocketName);
#line 104
  memset((void *)(& controladdr), '\000', (size_t )sizeof(controladdr));
#line 105
  controladdr.sun_family = (sa_family_t )1;
#line 106
  sm_strlcpy(controladdr.sun_path, (char const   *)ControlSocketName, (ssize_t )sizeof(controladdr.sun_path));
#line 109
  tmp___5 = bind(ControlSocket, (struct sockaddr  const  *)((struct sockaddr *)(& controladdr)),
                 (socklen_t )sizeof(controladdr));
  }
#line 109
  if (tmp___5 < 0) {
    {
#line 112
    tmp___3 = __errno_location();
#line 112
    save_errno = *tmp___3;
#line 113
    clrcontrol();
#line 114
    tmp___4 = __errno_location();
#line 114
    *tmp___4 = save_errno;
    }
#line 115
    return (-1);
  }
  {
#line 118
  tmp___11 = geteuid();
  }
#line 118
  if (tmp___11 == 0U) {
#line 120
    u = (uid_t )0;
#line 122
    if (RunAsUid != 0U) {
#line 123
      u = RunAsUid;
    } else
#line 124
    if (TrustedUid != 0U) {
#line 125
      u = TrustedUid;
    }
#line 127
    if (u != 0U) {
      {
#line 127
      tmp___10 = chown((char const   *)ControlSocketName, u, (__gid_t )-1);
      }
#line 127
      if (tmp___10 < 0) {
        {
#line 130
        tmp___6 = __errno_location();
#line 130
        save_errno = *tmp___6;
#line 131
        tmp___7 = sm_errstring(save_errno);
#line 131
        sm_syslog(1, "*~*", "ownership change on %s to uid %d failed: %s", ControlSocketName,
                  (int )u, tmp___7);
#line 135
        tmp___8 = sm_errstring(save_errno);
#line 135
        message("050 ownership change on %s to uid %d failed: %s", ControlSocketName,
                (int )u, tmp___8);
#line 138
        closecontrolsocket(1);
#line 139
        tmp___9 = __errno_location();
#line 139
        *tmp___9 = save_errno;
        }
#line 140
        return (-1);
      }
    }
  }
  {
#line 144
  tmp___14 = chmod((char const   *)ControlSocketName, (__mode_t )384);
  }
#line 144
  if (tmp___14 < 0) {
    {
#line 146
    tmp___12 = __errno_location();
#line 146
    save_errno = *tmp___12;
#line 147
    closecontrolsocket(1);
#line 148
    tmp___13 = __errno_location();
#line 148
    *tmp___13 = save_errno;
    }
#line 149
    return (-1);
  }
  {
#line 152
  tmp___17 = listen(ControlSocket, 8);
  }
#line 152
  if (tmp___17 < 0) {
    {
#line 154
    tmp___15 = __errno_location();
#line 154
    save_errno = *tmp___15;
#line 155
    closecontrolsocket(1);
#line 156
    tmp___16 = __errno_location();
#line 156
    *tmp___16 = save_errno;
    }
#line 157
    return (-1);
  }
#line 160
  return (0);
}
}
#line 175 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/control.c"
void closecontrolsocket(bool fullclose ) 
{ 
  long sff ;
  int rval ;
  int *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 180
  sff = 9027L;
#line 182
  if (ControlSocket >= 0) {
#line 186
    if (fullclose) {
      {
#line 188
      close(ControlSocket);
#line 189
      ControlSocket = -1;
      }
    }
    {
#line 192
    rval = safefile(ControlSocketName, RunAsUid, RunAsGid, RunAsUserName, sff, 384,
                    (struct stat *)((void *)0));
    }
#line 196
    if (rval != 0) {
#line 197
      return;
    }
    {
#line 199
    tmp___1 = unlink((char const   *)ControlSocketName);
    }
#line 199
    if (tmp___1 < 0) {
      {
#line 201
      tmp = __errno_location();
#line 201
      tmp___0 = sm_errstring(*tmp);
#line 201
      sm_syslog(4, "*~*", "Could not remove control socket: %s", tmp___0);
      }
#line 204
      return;
    }
  }
#line 208
  return;
}
}
#line 223 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/control.c"
void clrcontrol(void) 
{ 


  {
#line 227
  if (ControlSocket >= 0) {
    {
#line 228
    close(ControlSocket);
    }
  }
#line 229
  ControlSocket = -1;
#line 231
  return;
}
}
#line 246 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/control.c"
static sigjmp_buf CtxControlTimeout  ;
#line 249 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/control.c"
static void controltimeout(int timeout ) 
{ 
  int *tmp ;

  {
  {
#line 259
  tmp = __errno_location();
#line 259
  *tmp = 110;
#line 260
  siglongjmp((struct __jmp_buf_tag *)(CtxControlTimeout), 1);
  }
}
}
#line 263 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/control.c"
void control_command(int sock , ENVELOPE *e ) 
{ 
  int volatile   exitstat___0 ;
  SM_FILE_T *s ;
  SM_EVENT *ev ;
  SM_FILE_T *traffic ;
  SM_FILE_T *oldout ;
  char *cmd ;
  char *p ;
  struct cmd *c ;
  char cmdbuf[2048] ;
  char inp[2048] ;
  int tmp ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int qgrp ;
  long bsize ;
  long free___0 ;
  int tmp___9 ;
  int tmp___10 ;
  SM_ATOMIC_UINT_T tmp___11 ;
  bool tmp___12 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
  {
#line 268
  exitstat___0 = (int volatile   )0;
#line 269
  s = (SM_FILE_T *)((void *)0);
#line 270
  ev = (SM_EVENT *)((void *)0);
#line 279
  sm_setproctitle(0, e, "control cmd read");
  }
#line 281
  if (TimeOuts.to_control > 0L) {
    {
#line 284
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(CtxControlTimeout), 1);
    }
#line 284
    if (tmp != 0) {
#line 286
      if (LogLevel > 2) {
        {
#line 287
        sm_syslog(5, (char const   *)e->e_id, "timeout waiting for input during control command");
        }
      }
      {
#line 289
      exit(74);
      }
    }
    {
#line 291
    ev = sm_seteventm((int )(TimeOuts.to_control * 1000L), & controltimeout, (int )TimeOuts.to_control);
    }
  }
  {
#line 295
  s = sm_io_open((SM_FILE_T const   *)(& SmFtStdiofd_def), -2, (void const   *)((void *)(& sock)),
                 1, (void const   *)((void *)0));
  }
#line 297
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 299
    tmp___0 = __errno_location();
#line 299
    save_errno = *tmp___0;
#line 301
    close(sock);
#line 302
    tmp___1 = __errno_location();
#line 302
    *tmp___1 = save_errno;
#line 303
    exit(74);
    }
  }
  {
#line 305
  sm_io_setvbuf(s, -2, (char *)((void *)0), 2, (size_t )4096);
#line 308
  tmp___2 = sm_io_fgets(s, -2, inp, (int )sizeof(inp));
  }
#line 308
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 310
    sm_io_close(s, -2);
#line 311
    exit(74);
    }
  }
  {
#line 313
  sm_io_flush(s, -2);
#line 316
  fixcrlf(inp, 1);
#line 318
  sm_setproctitle(0, e, "control: %s", inp);
#line 321
  p = inp;
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (((int )*p & -128) == 0) {
      {
#line 321
      tmp___3 = __ctype_b_loc();
      }
#line 321
      if (! ((int const   )*(*tmp___3 + (int )*p) & 8192)) {
#line 321
        goto while_break;
      }
    } else {
#line 321
      goto while_break;
    }
#line 322
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 321
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  cmd = cmdbuf;
  {
#line 324
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 324
    if ((int )*p != 0) {
#line 324
      if (((int )*p & -128) == 0) {
        {
#line 324
        tmp___6 = __ctype_b_loc();
        }
#line 324
        if ((int const   )*(*tmp___6 + (int )*p) & 8192) {
#line 324
          goto while_break___0;
        } else {
#line 324
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 324
      if (! ((unsigned long )cmd < (unsigned long )(& cmdbuf[sizeof(cmdbuf) - 2UL]))) {
#line 324
        goto while_break___0;
      }
    } else {
#line 324
      goto while_break___0;
    }
#line 327
    tmp___4 = cmd;
#line 327
    cmd ++;
#line 327
    tmp___5 = p;
#line 327
    p ++;
#line 327
    *tmp___4 = *tmp___5;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  *cmd = (char )'\000';
  {
#line 331
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 331
    if (((int )*p & -128) == 0) {
      {
#line 331
      tmp___7 = __ctype_b_loc();
      }
#line 331
      if (! ((int const   )*(*tmp___7 + (int )*p) & 8192)) {
#line 331
        goto while_break___1;
      }
    } else {
#line 331
      goto while_break___1;
    }
#line 332
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 335
  c = CmdTab___0;
  {
#line 335
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 335
    if (! ((unsigned long )c->cmd_name != (unsigned long )((void *)0))) {
#line 335
      goto while_break___2;
    }
    {
#line 337
    tmp___8 = sm_strcasecmp((char const   *)c->cmd_name, (char const   *)(cmdbuf));
    }
#line 337
    if (tmp___8 == 0) {
#line 338
      goto while_break___2;
    }
#line 335
    c ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 343
  if (c->cmd_code == 3) {
#line 343
    goto case_3;
  }
#line 353
  if (c->cmd_code == 1) {
#line 353
    goto case_1;
  }
#line 358
  if (c->cmd_code == 2) {
#line 358
    goto case_2;
  }
#line 363
  if (c->cmd_code == 4) {
#line 363
    goto case_4;
  }
#line 406
  if (c->cmd_code == 5) {
#line 406
    goto case_5;
  }
#line 428
  if (c->cmd_code == 0) {
#line 428
    goto case_0;
  }
#line 341
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 344
  traffic = TrafficLogFile;
#line 345
  TrafficLogFile = (SM_FILE_T *)((void *)0);
#line 346
  oldout = OutChannel;
#line 347
  OutChannel = s;
#line 348
  help((char *)"control", e);
#line 349
  TrafficLogFile = traffic;
#line 350
  OutChannel = oldout;
  }
#line 351
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 354
  sm_io_fprintf(s, -2, "OK\r\n");
#line 355
  exitstat___0 = (int volatile   )23;
  }
#line 356
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 359
  sm_io_fprintf(s, -2, "OK\r\n");
#line 360
  exitstat___0 = (int volatile   )24;
  }
#line 361
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 364
  proc_list_probe();
#line 371
  qgrp = e->e_qgrp;
  }
#line 372
  if (! (qgrp >= 0)) {
#line 373
    qgrp = 0;
  }
  {
#line 374
  free___0 = freediskspace((Queue[qgrp])->qg_qdir, & bsize);
  }
#line 381
  if (free___0 > 0L) {
#line 382
    free___0 = (long )((double )free___0 * ((double )bsize / (double )1024));
  }
  {
#line 385
  tmp___9 = getla();
#line 385
  sm_io_fprintf(s, -2, "%d/%d/%ld/%d\r\n", CurChildren, MaxChildren, free___0, tmp___9);
#line 390
  proc_list_display(s, (char *)"");
  }
#line 391
  goto switch_break;
  case_5: /* CIL Label */ 
#line 409
  if (SmHeapCheck.debug_level >= 2U) {
#line 409
    if (SmHeapCheck.debug_level != 4294967295U) {
#line 409
      goto _L___0;
    } else {
      {
#line 409
      tmp___12 = sm_debug_loadactive(& SmHeapCheck, 2);
      }
#line 409
      if (tmp___12) {
        _L___0: /* CIL Label */ 
#line 411
        if (SmHeapCheck.debug_level == 4294967295U) {
          {
#line 411
          tmp___10 = sm_debug_loadlevel(& SmHeapCheck);
#line 411
          tmp___11 = (SM_ATOMIC_UINT_T )tmp___10;
          }
        } else {
#line 411
          tmp___11 = SmHeapCheck.debug_level;
        }
        {
#line 411
        sm_heap_report(s, (int )(tmp___11 - 1U));
        }
      } else {
        {
#line 415
        sm_io_fprintf(s, -2, "Memory dump unavailable.\r\n");
#line 417
        sm_io_fprintf(s, -2, "To fix, run sendmail with -dsm_check_heap.4\r\n");
        }
      }
    }
  } else {
    {
#line 415
    sm_io_fprintf(s, -2, "Memory dump unavailable.\r\n");
#line 417
    sm_io_fprintf(s, -2, "To fix, run sendmail with -dsm_check_heap.4\r\n");
    }
  }
#line 426
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 429
  sm_io_fprintf(s, -2, "Bad command (%s)\r\n", cmdbuf);
  }
#line 431
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 433
  sm_io_close(s, -2);
  }
#line 434
  if ((unsigned long )ev != (unsigned long )((void *)0)) {
    {
#line 435
    sm_clrevent(ev);
    }
  }
  {
#line 436
  exit((int )exitstat___0);
  }
}
}
#line 537 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
#line 540
extern  __attribute__((__nothrow__)) long sysconf(int __name )  __attribute__((__const__)) ;
#line 708
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 761
extern char *getlogin(void) ;
#line 73 "/usr/include/getopt.h"
int optind ;
#line 889 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 443 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 51 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 70
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits ) ;
#line 115 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 138
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 131 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 138
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 190 "/usr/include/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 1375 "./sendmail.h"
char *validate_connection(union bigsockaddr *sap , char *hostname , ENVELOPE *e ) ;
#line 1748
void vendor_daemon_setup(ENVELOPE *e ) ;
#line 2154
bool ConfigFileRead ;
#line 2250
int VendorCode ;
#line 2273
time_t ServiceCacheMaxAge ;
#line 2499
int getdtsize(void) ;
#line 2503
char *getvendor(int vendorcode ) ;
#line 2505
void init_md(int argc , char **argv ) ;
#line 2509
void initsetproctitle(int argc , char **argv , char **envp ) ;
#line 2510
void init_vendor_macros(ENVELOPE *e ) ;
#line 2513
void load_if_names(void) ;
#line 2546
void resetlimits(void) ;
#line 2551
void seed_random(void) ;
#line 2555
void setdefaults(ENVELOPE *e ) ;
#line 2568
void sm_closefrom(int lowest , int highest ) ;
#line 2591
char *ttypath(void) ;
#line 2608
void vendor_post_defaults(ENVELOPE *e ) ;
#line 2609
void vendor_pre_defaults(ENVELOPE *e ) ;
#line 956 "/usr/include/db.h"
extern char *db_version(int * , int * , int * ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 42 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static void setupmaps(void) ;
#line 43
static void setupmailers(void) ;
#line 44
static void setupqueues(void) ;
#line 45
static int get_num_procs_online(void) ;
#line 46
static int add_hostnames(union bigsockaddr *sa ) ;
#line 86 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
struct hdrinfo HdrInfo[36]  = 
#line 86
  {      {(char *)"resent-sender", 264UL, (char *)((void *)0)}, 
        {(char *)"resent-from", 264UL, (char *)((void *)0)}, 
        {(char *)"resent-reply-to", 264UL, (char *)((void *)0)}, 
        {(char *)"sender", 256UL, (char *)((void *)0)}, 
        {(char *)"from", 256UL, (char *)((void *)0)}, 
        {(char *)"reply-to", 256UL, (char *)((void *)0)}, 
        {(char *)"errors-to", 2304UL, (char *)((void *)0)}, 
        {(char *)"full-name", 32UL, (char *)((void *)0)}, 
        {(char *)"return-receipt-to", 1024UL, (char *)((void *)0)}, 
        {(char *)"delivery-receipt-to", 1024UL, (char *)((void *)0)}, 
        {(char *)"disposition-notification-to", 256UL, (char *)((void *)0)}, 
        {(char *)"to", 2UL, (char *)((void *)0)}, 
        {(char *)"resent-to", 10UL, (char *)((void *)0)}, 
        {(char *)"cc", 2UL, (char *)((void *)0)}, 
        {(char *)"resent-cc", 10UL, (char *)((void *)0)}, 
        {(char *)"bcc", 16386UL, (char *)((void *)0)}, 
        {(char *)"resent-bcc", 16394UL, (char *)((void *)0)}, 
        {(char *)"apparently-to", 2UL, (char *)((void *)0)}, 
        {(char *)"message-id", 0UL, (char *)((void *)0)}, 
        {(char *)"resent-message-id", 8UL, (char *)((void *)0)}, 
        {(char *)"message", 1UL, (char *)((void *)0)}, 
        {(char *)"text", 1UL, (char *)((void *)0)}, 
        {(char *)"date", 0UL, (char *)((void *)0)}, 
        {(char *)"resent-date", 8UL, (char *)((void *)0)}, 
        {(char *)"received", 192UL, (char *)((void *)0)}, 
        {(char *)"x400-received", 192UL, (char *)((void *)0)}, 
        {(char *)"via", 192UL, (char *)((void *)0)}, 
        {(char *)"mail-from", 192UL, (char *)((void *)0)}, 
        {(char *)"comments", 32832UL, (char *)((void *)0)}, 
        {(char *)"return-path", 131168UL, (char *)((void *)0)}, 
        {(char *)"content-transfer-encoding", 4096UL, (char *)((void *)0)}, 
        {(char *)"content-type", 8192UL, (char *)((void *)0)}, 
        {(char *)"content-length", 32UL, (char *)((void *)0)}, 
        {(char *)"subject", 32768UL, (char *)((void *)0)}, 
        {(char *)"x-authentication-warning", 64UL, (char *)((void *)0)}, 
        {(char *)((void *)0), 0UL, (char *)((void *)0)}};
#line 144 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
struct prival PrivacyValues[16]  = 
#line 144
  {      {(char *)"public", 0UL}, 
        {(char *)"needmailhelo", 1UL}, 
        {(char *)"needexpnhelo", 2UL}, 
        {(char *)"needvrfyhelo", 4UL}, 
        {(char *)"noexpn", 8UL}, 
        {(char *)"novrfy", 16UL}, 
        {(char *)"restrictexpand", 262144UL}, 
        {(char *)"restrictmailq", 65536UL}, 
        {(char *)"restrictqrun", 131072UL}, 
        {(char *)"noetrn", 524288UL}, 
        {(char *)"noverb", 64UL}, 
        {(char *)"authwarnings", 32UL}, 
        {(char *)"noreceipts", 2097152UL}, 
        {(char *)"nobodyreturn", 1048576UL}, 
        {(char *)"goaway", 65535UL}, 
        {(char *)((void *)0), 0UL}};
#line 171 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
struct dbsval DontBlameSendmailValues[43]  = 
#line 171
  {      {(char *)"safe", (unsigned char)0}, 
        {(char *)"assumesafechown", (unsigned char)1}, 
        {(char *)"groupwritabledirpathsafe", (unsigned char)2}, 
        {(char *)"groupwritableforwardfilesafe", (unsigned char)3}, 
        {(char *)"groupwritableincludefilesafe", (unsigned char)4}, 
        {(char *)"groupwritablealiasfile", (unsigned char)5}, 
        {(char *)"worldwritablealiasfile", (unsigned char)6}, 
        {(char *)"forwardfileinunsafedirpath", (unsigned char)7}, 
        {(char *)"includefileinunsafedirpath", (unsigned char)30}, 
        {(char *)"mapinunsafedirpath", (unsigned char)8}, 
        {(char *)"linkedaliasfileinwritabledir", (unsigned char)9}, 
        {(char *)"linkedclassfileinwritabledir", (unsigned char)10}, 
        {(char *)"linkedforwardfileinwritabledir", (unsigned char)11}, 
        {(char *)"linkedincludefileinwritabledir", (unsigned char)12}, 
        {(char *)"linkedmapinwritabledir", (unsigned char)13}, 
        {(char *)"linkedserviceswitchfileinwritabledir", (unsigned char)14}, 
        {(char *)"filedeliverytohardlink", (unsigned char)15}, 
        {(char *)"filedeliverytosymlink", (unsigned char)16}, 
        {(char *)"writemaptohardlink", (unsigned char)17}, 
        {(char *)"writemaptosymlink", (unsigned char)18}, 
        {(char *)"writestatstohardlink", (unsigned char)19}, 
        {(char *)"writestatstosymlink", (unsigned char)20}, 
        {(char *)"forwardfileingroupwritabledirpath", (unsigned char)21}, 
        {(char *)"includefileingroupwritabledirpath", (unsigned char)22}, 
        {(char *)"classfileinunsafedirpath", (unsigned char)23}, 
        {(char *)"errorheaderinunsafedirpath", (unsigned char)24}, 
        {(char *)"helpfileinunsafedirpath", (unsigned char)25}, 
        {(char *)"forwardfileinunsafedirpathsafe", (unsigned char)26}, 
        {(char *)"includefileinunsafedirpathsafe", (unsigned char)27}, 
        {(char *)"runprograminunsafedirpath", (unsigned char)28}, 
        {(char *)"runwritableprogram", (unsigned char)29}, 
        {(char *)"nonrootsafeaddr", (unsigned char)31}, 
        {(char *)"truststickybit", (unsigned char)32}, 
        {(char *)"dontwarnforwardfileinunsafedirpath", (unsigned char)33}, 
        {(char *)"insufficiententropy", (unsigned char)34}, 
        {(char *)"groupreadablesasldbfile", (unsigned char)35}, 
        {(char *)"groupwritablesasldbfile", (unsigned char)36}, 
        {(char *)"groupwritableforwardfile", (unsigned char)37}, 
        {(char *)"groupwritableincludefile", (unsigned char)38}, 
        {(char *)"worldwritableforwardfile", (unsigned char)39}, 
        {(char *)"worldwritableincludefile", (unsigned char)40}, 
        {(char *)"groupreadablekeyfile", (unsigned char)41}, 
        {(char *)((void *)0), (unsigned char)0}};
#line 238 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
int DtableSize  =    50;
#line 264 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void setdefaults(ENVELOPE *e ) 
{ 
  int i ;
  int numprocs ;
  struct passwd *pw ;
  __uid_t tmp___0 ;
  __uid_t tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 272
  numprocs = get_num_procs_online();
#line 273
  SpaceSub = (char )' ';
#line 274
  QueueLA = 8 * numprocs;
#line 275
  RefuseLA = 12 * numprocs;
#line 276
  WkRecipFact = 30000L;
#line 277
  WkClassFact = 1800L;
#line 278
  WkTimeFact = 90000L;
#line 279
  QueueFactor = WkRecipFact * 20L;
#line 280
  QueueMode = ' ';
#line 281
  tmp___0 = geteuid();
  }
#line 281
  if (RealUid != tmp___0) {
#line 281
    FileMode = 420;
  } else {
#line 281
    FileMode = 384;
  }
  {
#line 283
  tmp___2 = geteuid();
  }
#line 283
  if (RealUid != tmp___2) {
#line 283
    QueueFileMode = 420;
  } else {
#line 283
    QueueFileMode = 384;
  }
  {
#line 286
  pw = sm_getpwnam((char *)"mailnull");
  }
#line 286
  if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 286
    if (pw->pw_uid != 0U) {
      {
#line 290
      DefUid = pw->pw_uid;
#line 291
      DefGid = pw->pw_gid;
#line 292
      DefUser = newstr((char const   *)pw->pw_name);
      }
    } else {
#line 286
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 286
    pw = sm_getpwnam((char *)"sendmail");
    }
#line 286
    if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 286
      if (pw->pw_uid != 0U) {
        {
#line 290
        DefUid = pw->pw_uid;
#line 291
        DefGid = pw->pw_gid;
#line 292
        DefUser = newstr((char const   *)pw->pw_name);
        }
      } else {
#line 286
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 286
      pw = sm_getpwnam((char *)"daemon");
      }
#line 286
      if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 286
        if (pw->pw_uid != 0U) {
          {
#line 290
          DefUid = pw->pw_uid;
#line 291
          DefGid = pw->pw_gid;
#line 292
          DefUser = newstr((char const   *)pw->pw_name);
          }
        } else {
          {
#line 296
          DefUid = (uid_t )1;
#line 297
          DefGid = (gid_t )1;
#line 298
          setdefuser();
          }
        }
      } else {
        {
#line 296
        DefUid = (uid_t )1;
#line 297
        DefGid = (gid_t )1;
#line 298
        setdefuser();
        }
      }
    }
  }
#line 300
  TrustedUid = (uid_t )0;
#line 301
  if ((int )tTdvect[37] >= 4) {
#line 302
    if ((unsigned long )DefUser != (unsigned long )((void *)0)) {
#line 302
      tmp___3 = (char const   *)DefUser;
    } else {
#line 302
      tmp___3 = "<1:1>";
    }
    {
#line 302
    sm_dprintf((char *)"setdefaults: DefUser=%s, DefUid=%d, DefGid=%d\n", tmp___3,
               (int )DefUid, (int )DefGid);
    }
  }
  {
#line 305
  CheckpointInterval = 10;
#line 306
  MaxHopCount = 25;
#line 307
  set_delivery_mode('b', e);
#line 308
  e->e_errormode = (short )'p';
#line 309
  e->e_qgrp = -1;
#line 310
  e->e_qdir = -1;
#line 311
  e->e_xfqgrp = -1;
#line 312
  e->e_xfqdir = -1;
#line 313
  e->e_ctime = curtime();
#line 314
  SevenBitInput = 0;
#line 315
  MaxMciCache = 1;
#line 316
  MciCacheTimeout = (time_t )300;
#line 317
  LogLevel = 9;
#line 319
  MilterLogLevel = -1;
#line 321
  inittimeouts((char *)((void *)0), 0);
#line 322
  PrivacyFlags = 0UL;
#line 323
  MeToo = 1;
#line 324
  SendMIMEErrors = 1;
#line 325
  SuperSafe = 2;
#line 326
  memset((void *)((char *)(DontBlameSendmail)), '\000', (size_t )32);
#line 328
  MimeMode = 3;
#line 332
  i = 0;
  }
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! (i < 8)) {
#line 332
      goto while_break;
    }
#line 334
    TimeOuts.to_q_return[i] = (time_t )432000;
#line 335
    TimeOuts.to_q_warning[i] = (time_t )0;
#line 332
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 337
  ServiceSwitchFile = (char *)"/etc/mail/service.switch";
#line 338
  ServiceCacheMaxAge = (time_t )10;
#line 339
  HostsFile = (char *)"/etc/hosts";
#line 340
  PidFile = newstr("/var/run/sendmail.pid");
#line 341
  MustQuoteChars = (char *)"@,;:\\()[].\'";
#line 342
  MciInfoTimeout = (time_t )1800;
#line 343
  MaxRuleRecursion = 50;
#line 344
  MaxAliasRecursion = 10;
#line 345
  MaxMacroRecursion = 10;
#line 346
  ColonOkInAddr = 1;
#line 347
  DontLockReadFiles = 1;
#line 348
  DontProbeInterfaces = 1;
#line 349
  DoubleBounceAddr = (char *)"postmaster";
#line 350
  MaxHeadersLength = 32768;
#line 351
  MaxMimeHeaderLength = 2048;
#line 352
  MaxMimeFieldLength = MaxMimeHeaderLength / 2;
#line 353
  MaxForwardEntries = 0;
#line 354
  FastSplit = 1;
#line 355
  MaxNOOPCommands = 20;
#line 378
  InetMode = (char)2;
#line 380
  ControlSocketName = (char *)((void *)0);
#line 381
  memset((void *)(& ConnectOnlyTo), '\000', (size_t )sizeof(ConnectOnlyTo));
#line 382
  DataFileBufferSize = (size_t )4096;
#line 383
  XscriptFileBufferSize = (size_t )4096;
#line 384
  i = 0;
  }
  {
#line 384
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 384
    if (! (i < 200)) {
#line 384
      goto while_break___0;
    }
#line 385
    RuleSetNames[i] = (char *)((void *)0);
#line 384
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 387
  InputFilters[0] = (struct milter *)((void *)0);
#line 389
  RejectLogInterval = (time_t )10800;
#line 391
  RequiresDirfsync = 1;
#line 393
  ConnectionRateWindowSize = 60;
#line 394
  setupmaps();
#line 395
  setupqueues();
#line 396
  setupmailers();
#line 397
  setupheaders();
  }
#line 398
  return;
}
}
#line 409 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static char defuserbuf[40]  ;
#line 405 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void setdefuser(void) 
{ 
  struct passwd *defpwent ;
  char const   *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 411
  DefUser = defuserbuf;
#line 412
  defpwent = sm_getpwuid(DefUid);
  }
#line 413
  if ((unsigned long )defpwent == (unsigned long )((void *)0)) {
#line 413
    tmp = "nobody";
  } else
#line 413
  if ((unsigned long )defpwent->pw_name == (unsigned long )((void *)0)) {
#line 413
    tmp = "nobody";
  } else {
#line 413
    tmp = (char const   *)defpwent->pw_name;
  }
  {
#line 413
  sm_strlcpy(defuserbuf, tmp, (ssize_t )sizeof(defuserbuf));
  }
#line 417
  if ((int )tTdvect[37] >= 4) {
    {
#line 418
    sm_dprintf((char *)"setdefuser: DefUid=%d, DefUser=%s\n", (int )DefUid, DefUser);
    }
  }
#line 420
  return;
}
}
#line 429 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static void setupqueues(void) 
{ 
  char buf___16[100] ;
  void *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 434
  MaxRunnersPerQueue = 1;
#line 435
  sm_strlcpy(buf___16, "mqueue, P=/var/spool/mqueue", (ssize_t )sizeof(buf___16));
#line 436
  makequeue(buf___16, 0);
  }
#line 437
  return;
}
}
#line 442 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static void setupmailers(void) 
{ 
  char buf___16[100] ;
  void *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 447
  sm_strlcpy(buf___16, "prog, P=/bin/sh, F=lsouDq9, T=X-Unix/X-Unix/X-Unix, A=sh -c \201u",
             (ssize_t )sizeof(buf___16));
#line 449
  makemailer(buf___16);
#line 451
  sm_strlcpy(buf___16, "*file*, P=[FILE], F=lsDFMPEouq9, T=X-Unix/X-Unix/X-Unix, A=FILE \201u",
             (ssize_t )sizeof(buf___16));
#line 453
  makemailer(buf___16);
#line 455
  sm_strlcpy(buf___16, "*include*, P=/dev/null, F=su, A=INCLUDE \201u", (ssize_t )sizeof(buf___16));
#line 457
  makemailer(buf___16);
#line 458
  initerrmailers();
  }
#line 459
  return;
}
}
#line 482 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static void setupmaps(void) 
{ 
  register STAB *s ;
  int major_v ;
  int minor_v ;
  int patch_v ;
  int *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
  {
#line 491
  db_version(& major_v, & minor_v, & patch_v);
  }
#line 492
  if (major_v != 3) {
    {
#line 494
    tmp = __errno_location();
#line 494
    *tmp = 0;
#line 495
    syserr("Berkeley DB version mismatch: compiled against %d.%d.%d, run-time linked against %d.%d.%d",
           3, 2, 9, major_v, minor_v, patch_v);
    }
  } else
#line 492
  if (minor_v != 2) {
    {
#line 494
    tmp = __errno_location();
#line 494
    *tmp = 0;
#line 495
    syserr("Berkeley DB version mismatch: compiled against %d.%d.%d, run-time linked against %d.%d.%d",
           3, 2, 9, major_v, minor_v, patch_v);
    }
  }
  {
#line 501
  s = stab((char *)"hash", 5, 1);
#line 501
  s->s_value.sv_mapclass.map_cname = (char *)"hash";
#line 501
  s->s_value.sv_mapclass.map_ext = (char *)".db";
#line 501
  s->s_value.sv_mapclass.map_cflags = (short)5;
#line 501
  s->s_value.sv_mapclass.map_parse = & map_parseargs;
#line 501
  s->s_value.sv_mapclass.map_open = & hash_map_open;
#line 501
  s->s_value.sv_mapclass.map_close = & db_map_close;
#line 501
  s->s_value.sv_mapclass.map_lookup = & db_map_lookup;
#line 501
  s->s_value.sv_mapclass.map_store = & db_map_store;
#line 505
  s = stab((char *)"btree", 5, 1);
#line 505
  s->s_value.sv_mapclass.map_cname = (char *)"btree";
#line 505
  s->s_value.sv_mapclass.map_ext = (char *)".db";
#line 505
  s->s_value.sv_mapclass.map_cflags = (short)5;
#line 505
  s->s_value.sv_mapclass.map_parse = & map_parseargs;
#line 505
  s->s_value.sv_mapclass.map_open = & bt_map_open;
#line 505
  s->s_value.sv_mapclass.map_close = & db_map_close;
#line 505
  s->s_value.sv_mapclass.map_lookup = & db_map_lookup;
#line 505
  s->s_value.sv_mapclass.map_store = & db_map_store;
#line 572
  s = stab((char *)"dns", 5, 1);
#line 572
  s->s_value.sv_mapclass.map_cname = (char *)"dns";
#line 572
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 572
  s->s_value.sv_mapclass.map_cflags = (short)0;
#line 572
  s->s_value.sv_mapclass.map_parse = & dns_map_parseargs;
#line 572
  s->s_value.sv_mapclass.map_open = & dns_map_open;
#line 572
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 572
  s->s_value.sv_mapclass.map_lookup = & dns_map_lookup;
#line 572
  s->s_value.sv_mapclass.map_store = & null_map_store;
#line 581
  s = stab((char *)"bestmx", 5, 1);
#line 581
  s->s_value.sv_mapclass.map_cname = (char *)"bestmx";
#line 581
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 581
  s->s_value.sv_mapclass.map_cflags = (short)8;
#line 581
  s->s_value.sv_mapclass.map_parse = & map_parseargs;
#line 581
  s->s_value.sv_mapclass.map_open = & null_map_open;
#line 581
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 581
  s->s_value.sv_mapclass.map_lookup = & bestmx_map_lookup;
#line 581
  s->s_value.sv_mapclass.map_store = & null_map_store;
#line 586
  s = stab((char *)"host", 5, 1);
#line 586
  s->s_value.sv_mapclass.map_cname = (char *)"host";
#line 586
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 586
  s->s_value.sv_mapclass.map_cflags = (short)0;
#line 586
  s->s_value.sv_mapclass.map_parse = & host_map_init;
#line 586
  s->s_value.sv_mapclass.map_open = & null_map_open;
#line 586
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 586
  s->s_value.sv_mapclass.map_lookup = & host_map_lookup;
#line 586
  s->s_value.sv_mapclass.map_store = & null_map_store;
#line 590
  s = stab((char *)"text", 5, 1);
#line 590
  s->s_value.sv_mapclass.map_cname = (char *)"text";
#line 590
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 590
  s->s_value.sv_mapclass.map_cflags = (short)1;
#line 590
  s->s_value.sv_mapclass.map_parse = & map_parseargs;
#line 590
  s->s_value.sv_mapclass.map_open = & text_map_open;
#line 590
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 590
  s->s_value.sv_mapclass.map_lookup = & text_map_lookup;
#line 590
  s->s_value.sv_mapclass.map_store = & null_map_store;
#line 594
  s = stab((char *)"stab", 5, 1);
#line 594
  s->s_value.sv_mapclass.map_cname = (char *)"stab";
#line 594
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 594
  s->s_value.sv_mapclass.map_cflags = (short)3;
#line 594
  s->s_value.sv_mapclass.map_parse = & map_parseargs;
#line 594
  s->s_value.sv_mapclass.map_open = & stab_map_open;
#line 594
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 594
  s->s_value.sv_mapclass.map_lookup = & stab_map_lookup;
#line 594
  s->s_value.sv_mapclass.map_store = & stab_map_store;
#line 598
  s = stab((char *)"implicit", 5, 1);
#line 598
  s->s_value.sv_mapclass.map_cname = (char *)"implicit";
#line 598
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 598
  s->s_value.sv_mapclass.map_cflags = (short)7;
#line 598
  s->s_value.sv_mapclass.map_parse = & map_parseargs;
#line 598
  s->s_value.sv_mapclass.map_open = & impl_map_open;
#line 598
  s->s_value.sv_mapclass.map_close = & impl_map_close;
#line 598
  s->s_value.sv_mapclass.map_lookup = & impl_map_lookup;
#line 598
  s->s_value.sv_mapclass.map_store = & impl_map_store;
#line 603
  s = stab((char *)"user", 5, 1);
#line 603
  s->s_value.sv_mapclass.map_cname = (char *)"user";
#line 603
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 603
  s->s_value.sv_mapclass.map_cflags = (short)8;
#line 603
  s->s_value.sv_mapclass.map_parse = & map_parseargs;
#line 603
  s->s_value.sv_mapclass.map_open = & user_map_open;
#line 603
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 603
  s->s_value.sv_mapclass.map_lookup = & user_map_lookup;
#line 603
  s->s_value.sv_mapclass.map_store = & null_map_store;
#line 608
  s = stab((char *)"dequote", 5, 1);
#line 608
  s->s_value.sv_mapclass.map_cname = (char *)"dequote";
#line 608
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 608
  s->s_value.sv_mapclass.map_cflags = (short)0;
#line 608
  s->s_value.sv_mapclass.map_parse = & dequote_init;
#line 608
  s->s_value.sv_mapclass.map_open = & null_map_open;
#line 608
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 608
  s->s_value.sv_mapclass.map_lookup = & dequote_map;
#line 608
  s->s_value.sv_mapclass.map_store = & null_map_store;
#line 620
  s = stab((char *)"userdb", 5, 1);
#line 620
  s->s_value.sv_mapclass.map_cname = (char *)"userdb";
#line 620
  s->s_value.sv_mapclass.map_ext = (char *)".db";
#line 620
  s->s_value.sv_mapclass.map_cflags = (short)0;
#line 620
  s->s_value.sv_mapclass.map_parse = & map_parseargs;
#line 620
  s->s_value.sv_mapclass.map_open = & null_map_open;
#line 620
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 620
  s->s_value.sv_mapclass.map_lookup = & udb_map_lookup;
#line 620
  s->s_value.sv_mapclass.map_store = & null_map_store;
#line 626
  s = stab((char *)"program", 5, 1);
#line 626
  s->s_value.sv_mapclass.map_cname = (char *)"program";
#line 626
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 626
  s->s_value.sv_mapclass.map_cflags = (short)1;
#line 626
  s->s_value.sv_mapclass.map_parse = & map_parseargs;
#line 626
  s->s_value.sv_mapclass.map_open = & null_map_open;
#line 626
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 626
  s->s_value.sv_mapclass.map_lookup = & prog_map_lookup;
#line 626
  s->s_value.sv_mapclass.map_store = & null_map_store;
#line 631
  s = stab((char *)"sequence", 5, 1);
#line 631
  s->s_value.sv_mapclass.map_cname = (char *)"sequence";
#line 631
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 631
  s->s_value.sv_mapclass.map_cflags = (short)1;
#line 631
  s->s_value.sv_mapclass.map_parse = & seq_map_parse;
#line 631
  s->s_value.sv_mapclass.map_open = & null_map_open;
#line 631
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 631
  s->s_value.sv_mapclass.map_lookup = & seq_map_lookup;
#line 631
  s->s_value.sv_mapclass.map_store = & seq_map_store;
#line 636
  s = stab((char *)"switch", 5, 1);
#line 636
  s->s_value.sv_mapclass.map_cname = (char *)"switch";
#line 636
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 636
  s->s_value.sv_mapclass.map_cflags = (short)1;
#line 636
  s->s_value.sv_mapclass.map_parse = & map_parseargs;
#line 636
  s->s_value.sv_mapclass.map_open = & switch_map_open;
#line 636
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 636
  s->s_value.sv_mapclass.map_lookup = & seq_map_lookup;
#line 636
  s->s_value.sv_mapclass.map_store = & seq_map_store;
#line 641
  s = stab((char *)"null", 5, 1);
#line 641
  s->s_value.sv_mapclass.map_cname = (char *)"null";
#line 641
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 641
  s->s_value.sv_mapclass.map_cflags = (short)9;
#line 641
  s->s_value.sv_mapclass.map_parse = & map_parseargs;
#line 641
  s->s_value.sv_mapclass.map_open = & null_map_open;
#line 641
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 641
  s->s_value.sv_mapclass.map_lookup = & null_map_lookup;
#line 641
  s->s_value.sv_mapclass.map_store = & null_map_store;
#line 646
  s = stab((char *)"syslog", 5, 1);
#line 646
  s->s_value.sv_mapclass.map_cname = (char *)"syslog";
#line 646
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 646
  s->s_value.sv_mapclass.map_cflags = (short)0;
#line 646
  s->s_value.sv_mapclass.map_parse = & syslog_map_parseargs;
#line 646
  s->s_value.sv_mapclass.map_open = & null_map_open;
#line 646
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 646
  s->s_value.sv_mapclass.map_lookup = & syslog_map_lookup;
#line 646
  s->s_value.sv_mapclass.map_store = & null_map_store;
#line 651
  s = stab((char *)"macro", 5, 1);
#line 651
  s->s_value.sv_mapclass.map_cname = (char *)"macro";
#line 651
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 651
  s->s_value.sv_mapclass.map_cflags = (short)0;
#line 651
  s->s_value.sv_mapclass.map_parse = & dequote_init;
#line 651
  s->s_value.sv_mapclass.map_open = & null_map_open;
#line 651
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 651
  s->s_value.sv_mapclass.map_lookup = & macro_map_lookup;
#line 651
  s->s_value.sv_mapclass.map_store = & null_map_store;
#line 656
  s = stab((char *)"arith", 5, 1);
#line 656
  s->s_value.sv_mapclass.map_cname = (char *)"arith";
#line 656
  s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 656
  s->s_value.sv_mapclass.map_cflags = (short)0;
#line 656
  s->s_value.sv_mapclass.map_parse = & dequote_init;
#line 656
  s->s_value.sv_mapclass.map_open = & null_map_open;
#line 656
  s->s_value.sv_mapclass.map_close = & null_map_close;
#line 656
  s->s_value.sv_mapclass.map_lookup = & arith_map_lookup;
#line 656
  s->s_value.sv_mapclass.map_store = & null_map_store;
  }
#line 667
  if ((int )tTdvect[38] >= 2) {
    {
#line 670
    s = stab((char *)"bogus", 5, 1);
#line 670
    s->s_value.sv_mapclass.map_cname = (char *)"bogus";
#line 670
    s->s_value.sv_mapclass.map_ext = (char *)((void *)0);
#line 670
    s->s_value.sv_mapclass.map_cflags = (short)9;
#line 670
    s->s_value.sv_mapclass.map_parse = & map_parseargs;
#line 670
    s->s_value.sv_mapclass.map_open = & null_map_open;
#line 670
    s->s_value.sv_mapclass.map_close = & null_map_close;
#line 670
    s->s_value.sv_mapclass.map_lookup = & bogus_map_lookup;
#line 670
    s->s_value.sv_mapclass.map_store = & null_map_store;
    }
  }
#line 674
  return;
}
}
#line 697 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void inithostmaps(void) 
{ 
  register int i ;
  int nmaps ;
  char *maptype[12] ;
  short mapreturn[5] ;
  char buf___16[2048] ;
  STAB *tmp ;
  int tmp___0 ;
  STAB *tmp___1 ;
  STAB *tmp___2 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 763
  tmp = stab((char *)"host", 6, 0);
  }
#line 763
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 766
    sm_strlcpy(buf___16, "host host", (ssize_t )sizeof(buf___16));
    }
#line 768
    if (ConfigLevel >= 2) {
      {
#line 769
      sm_strlcat(buf___16, " -a. -D", (ssize_t )sizeof(buf___16));
      }
    }
    {
#line 771
    makemapentry(buf___16);
    }
  }
  {
#line 778
  nmaps = switch_map_find((char *)"aliases", maptype, mapreturn);
#line 779
  i = 0;
  }
  {
#line 779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 779
    if (! (i < nmaps)) {
#line 779
      goto while_break;
    }
    {
#line 781
    tmp___0 = strcmp((char const   *)maptype[i], "files");
    }
#line 781
    if (tmp___0 == 0) {
      {
#line 781
      tmp___1 = stab((char *)"aliases.files", 6, 0);
      }
#line 781
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 784
        sm_strlcpy(buf___16, "aliases.files null", (ssize_t )sizeof(buf___16));
#line 786
        makemapentry(buf___16);
        }
      }
    }
#line 779
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 825
  tmp___2 = stab((char *)"aliases", 6, 0);
  }
#line 825
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 827
    sm_strlcpy(buf___16, "aliases switch aliases", (ssize_t )sizeof(buf___16));
#line 828
    makemapentry(buf___16);
    }
  }
#line 879
  return;
}
}
#line 1022 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static time_t servicecachetime  ;
#line 922 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
int switch_map_find(char *service , char **maptype , short *mapreturn ) 
{ 
  int svcno ;
  int save_errno ;
  int *tmp ;
  STAB *st ;
  time_t now ;
  time_t tmp___0 ;
  register SM_FILE_T *fp ;
  long sff ;
  char buf___16[2048] ;
  register char *p ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
#line 928
  svcno = 0;
#line 929
  tmp = __errno_location();
#line 929
  save_errno = *tmp;
#line 1023
  tmp___0 = curtime();
#line 1023
  now = tmp___0;
#line 1025
  svcno = 0;
  }
  {
#line 1025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1025
    if (! (svcno < 5)) {
#line 1025
      goto while_break;
    }
#line 1026
    *(mapreturn + svcno) = (short)0;
#line 1025
    svcno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1028
  if (now - servicecachetime > ServiceCacheMaxAge) {
#line 1032
    sff = 24704L;
#line 1034
    if (! (DontBlameSendmail[14UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 14UL % (8UL * sizeof(int ))))) {
#line 1036
      sff |= 1024L;
    }
#line 1038
    if (ConfigFileRead) {
#line 1039
      servicecachetime = now;
    }
    {
#line 1040
    fp = safefopen(ServiceSwitchFile, 0, 0, sff);
    }
#line 1041
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
      {
#line 1045
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1045
        tmp___6 = sm_io_fgets(fp, -2, buf___16, (int )sizeof(buf___16));
        }
#line 1045
        if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 1045
          goto while_break___0;
        }
        {
#line 1050
        p = strpbrk((char const   *)(buf___16), "#\n");
        }
#line 1051
        if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1052
          *p = (char )'\000';
        }
        {
#line 1053
        p = strpbrk((char const   *)(buf___16), " \t");
        }
#line 1054
        if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1055
          tmp___1 = p;
#line 1055
          p ++;
#line 1055
          *tmp___1 = (char )'\000';
        }
#line 1056
        if ((int )buf___16[0] == 0) {
#line 1057
          goto while_continue___0;
        }
#line 1058
        if ((unsigned long )p == (unsigned long )((void *)0)) {
          {
#line 1060
          sm_syslog(3, "*~*", "Bad line on %.100s: %.100s", ServiceSwitchFile, buf___16);
          }
#line 1064
          goto while_continue___0;
        }
        {
#line 1066
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1066
          tmp___2 = __ctype_b_loc();
          }
#line 1066
          if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 1066
            goto while_break___1;
          }
#line 1067
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1068
        if ((int )*p == 0) {
#line 1069
          goto while_continue___0;
        }
        {
#line 1079
        st = stab(buf___16, 11, 1);
        }
#line 1080
        if ((unsigned long )st->s_value.sv_service[0] != (unsigned long )((void *)0)) {
          {
#line 1081
          sm_free_tagged((void *)st->s_value.sv_service[0], (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c",
                         1081);
          }
        }
        {
#line 1082
        p = newstr((char const   *)p);
#line 1083
        svcno = 0;
        }
        {
#line 1083
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1083
          if (! (svcno < 12)) {
#line 1083
            goto while_break___2;
          }
#line 1085
          if ((int )*p == 0) {
#line 1086
            goto while_break___2;
          }
          {
#line 1087
          tmp___3 = svcno;
#line 1087
          svcno ++;
#line 1087
          st->s_value.sv_service[tmp___3] = p;
#line 1088
          p = strpbrk((char const   *)p, " \t");
          }
#line 1089
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1090
            goto while_break___2;
          }
#line 1091
          tmp___4 = p;
#line 1091
          p ++;
#line 1091
          *tmp___4 = (char )'\000';
          {
#line 1092
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 1092
            tmp___5 = __ctype_b_loc();
            }
#line 1092
            if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 1092
              goto while_break___3;
            }
#line 1093
            p ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1095
        if (svcno < 12) {
#line 1096
          st->s_value.sv_service[svcno] = (char *)((void *)0);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1098
      sm_io_close(fp, -2);
      }
    }
  }
  {
#line 1103
  st = stab(service, 11, 0);
  }
#line 1104
  if ((unsigned long )st != (unsigned long )((void *)0)) {
#line 1104
    if ((unsigned long )st->s_value.sv_service[0] != (unsigned long )((void *)0)) {
#line 1107
      svcno = 0;
      {
#line 1108
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1108
        if (! (svcno < 12)) {
#line 1108
          goto while_break___4;
        }
#line 1110
        *(maptype + svcno) = st->s_value.sv_service[svcno];
#line 1111
        tmp___7 = svcno;
#line 1111
        svcno ++;
#line 1111
        if ((unsigned long )*(maptype + tmp___7) == (unsigned long )((void *)0)) {
#line 1112
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1114
      tmp___8 = __errno_location();
#line 1114
      *tmp___8 = save_errno;
#line 1115
      svcno --;
      }
#line 1115
      return (svcno);
    }
  }
#line 1124
  svcno = 0;
  {
#line 1124
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1124
    if (! (svcno < 5)) {
#line 1124
      goto while_break___5;
    }
#line 1125
    *(mapreturn + svcno) = (short)0;
#line 1124
    svcno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1126
  svcno = 0;
#line 1127
  tmp___11 = strcmp((char const   *)service, "aliases");
  }
#line 1127
  if (tmp___11 == 0) {
    {
#line 1129
    tmp___9 = svcno;
#line 1129
    svcno ++;
#line 1129
    *(maptype + tmp___9) = (char *)"files";
#line 1141
    tmp___10 = __errno_location();
#line 1141
    *tmp___10 = save_errno;
    }
#line 1142
    return (svcno);
  }
  {
#line 1144
  tmp___15 = strcmp((char const   *)service, "hosts");
  }
#line 1144
  if (tmp___15 == 0) {
    {
#line 1147
    tmp___12 = svcno;
#line 1147
    svcno ++;
#line 1147
    *(maptype + tmp___12) = (char *)"dns";
#line 1157
    tmp___13 = svcno;
#line 1157
    svcno ++;
#line 1157
    *(maptype + tmp___13) = (char *)"files";
#line 1158
    tmp___14 = __errno_location();
#line 1158
    *tmp___14 = save_errno;
    }
#line 1159
    return (svcno);
  }
  {
#line 1161
  tmp___16 = __errno_location();
#line 1161
  *tmp___16 = save_errno;
  }
#line 1162
  return (-1);
}
}
#line 1184 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static char *myname  =    (char *)((void *)0);
#line 1181 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
char *username(void) 
{ 
  register struct passwd *pw ;
  uid_t uid ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1189
  if ((unsigned long )myname == (unsigned long )((void *)0)) {
    {
#line 1191
    myname = getlogin();
    }
#line 1192
    if ((unsigned long )myname == (unsigned long )((void *)0)) {
#line 1192
      goto _L___0;
    } else
#line 1192
    if ((int )*(myname + 0) == 0) {
      _L___0: /* CIL Label */ 
      {
#line 1194
      pw = sm_getpwuid(RealUid);
      }
#line 1195
      if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 1196
        myname = pw->pw_name;
      }
    } else {
      {
#line 1200
      uid = RealUid;
#line 1202
      pw = sm_getpwnam(myname);
      }
#line 1202
      if ((unsigned long )pw == (unsigned long )((void *)0)) {
#line 1202
        goto _L;
      } else
#line 1202
      if (uid != 0U) {
#line 1202
        if (uid != pw->pw_uid) {
          _L: /* CIL Label */ 
          {
#line 1205
          pw = sm_getpwuid(uid);
          }
#line 1206
          if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 1207
            myname = pw->pw_name;
          }
        }
      }
    }
#line 1210
    if ((unsigned long )myname == (unsigned long )((void *)0)) {
      {
#line 1212
      syserr("554 5.3.0 Who are you?");
#line 1213
      myname = (char *)"postmaster";
      }
    } else
#line 1210
    if ((int )*(myname + 0) == 0) {
      {
#line 1212
      syserr("554 5.3.0 Who are you?");
#line 1213
      myname = (char *)"postmaster";
      }
    } else {
      {
#line 1215
      tmp = strpbrk((char const   *)myname, ",;:/|\"\\");
      }
#line 1215
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
        {
#line 1216
        myname = addquotes(myname, (SM_RPOOL_T *)((void *)0));
        }
      } else {
        {
#line 1218
        myname = sm_pstrdup_x((char const   *)myname);
        }
      }
    }
  }
#line 1220
  return (myname);
}
}
#line 1246 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
char *ttypath(void) 
{ 
  struct stat stbuf ;
  register char *pathn ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1255
  pathn = ttyname(2);
  }
#line 1255
  if ((unsigned long )pathn == (unsigned long )((void *)0)) {
    {
#line 1255
    pathn = ttyname(1);
    }
#line 1255
    if ((unsigned long )pathn == (unsigned long )((void *)0)) {
      {
#line 1255
      pathn = ttyname(0);
      }
#line 1255
      if ((unsigned long )pathn == (unsigned long )((void *)0)) {
        {
#line 1258
        tmp = __errno_location();
#line 1258
        *tmp = 0;
        }
#line 1259
        return ((char *)((void *)0));
      }
    }
  }
  {
#line 1263
  tmp___1 = stat((char const   */* __restrict  */)pathn, (struct stat */* __restrict  */)(& stbuf));
  }
#line 1263
  if (tmp___1 < 0) {
    {
#line 1265
    tmp___0 = __errno_location();
#line 1265
    *tmp___0 = 0;
    }
#line 1266
    return ((char *)((void *)0));
  } else
#line 1263
  if (! ((stbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) != 0U)) {
    {
#line 1265
    tmp___0 = __errno_location();
#line 1265
    *tmp___0 = 0;
    }
#line 1266
    return ((char *)((void *)0));
  }
  {
#line 1270
  tmp___2 = getlogin();
  }
#line 1270
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 1271
    return ((char *)((void *)0));
  }
#line 1274
  return (pathn);
}
}
#line 1304 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
int checkcompat(ADDRESS *to , ENVELOPE *e ) 
{ 
  char *__cil_tmp3 ;

  {
#line 1309
  if ((int )tTdvect[49] >= 1) {
    {
#line 1310
    sm_dprintf((char *)"checkcompat(to=%s, from=%s)\n", to->q_paddr, e->e_from.q_paddr);
    }
  }
#line 1327
  return (0);
}
}
#line 1344 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void init_md(int argc , char **argv ) 
{ 


  {
#line 1389
  VendorCode = 1;
#line 1391
  return;
}
}
#line 1407 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void init_vendor_macros(ENVELOPE *e ) 
{ 


  {
#line 1411
  return;
}
}
#line 1826 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
int getla(void) 
{ 
  double avenrun ;
  register int result___0 ;
  SM_FILE_T *fp ;
  int *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 1833
  fp = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)"/proc/loadavg",
                  2, (void const   *)((void *)0));
  }
#line 1835
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1837
    if ((int )tTdvect[3] >= 1) {
      {
#line 1838
      tmp = __errno_location();
#line 1838
      tmp___0 = sm_errstring(*tmp);
#line 1838
      sm_dprintf((char *)"getla: sm_io_open(%s): %s\n", "/proc/loadavg", tmp___0);
      }
    }
#line 1840
    return (-1);
  }
  {
#line 1842
  result___0 = sm_io_fscanf(fp, -2, "%lf", & avenrun);
#line 1843
  sm_io_close(fp, -2);
  }
#line 1844
  if (result___0 != 1) {
#line 1846
    if ((int )tTdvect[3] >= 1) {
      {
#line 1847
      tmp___1 = __errno_location();
#line 1847
      tmp___2 = sm_errstring(*tmp___1);
#line 1847
      sm_dprintf((char *)"getla: sm_io_fscanf() = %d: %s\n", result___0, tmp___2);
      }
    }
#line 1849
    return (-1);
  }
#line 1852
  if ((int )tTdvect[3] >= 1) {
    {
#line 1853
    sm_dprintf((char *)"getla(): %.2f\n", avenrun);
    }
  }
#line 1855
  return ((int )(avenrun + 0.5));
}
}
#line 2149 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void sm_getla(void) 
{ 
  char labuf[8] ;
  int tmp ;
  void *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 2154
  CurrentLA = getla();
#line 2155
  sm_snprintf(labuf, (size_t )sizeof(labuf), "%d", CurrentLA);
#line 2156
  tmp = macid_parse((char *)"{load_avg}", (char **)((void *)0));
#line 2156
  macdefine_tagged(& GlobalMacros, (ARGCLASS_T )1, tmp, labuf, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c",
                   2156, SmHeapGroup);
  }
#line 2157
  return;
}
}
#line 2180 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
bool shouldqueue(long pri , time_t ct ) 
{ 
  bool rval ;
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 2190
  if ((int )tTdvect[3] >= 30) {
    {
#line 2191
    sm_dprintf((char *)"shouldqueue: CurrentLA=%d, pri=%ld: ", CurrentLA, pri);
    }
  }
#line 2205
  if (CurrentLA < QueueLA) {
#line 2207
    if ((int )tTdvect[3] >= 30) {
      {
#line 2208
      sm_dprintf((char *)"false (CurrentLA < QueueLA)\n");
      }
    }
#line 2209
    return (0);
  }
#line 2219
  rval = pri > QueueFactor / (long )((CurrentLA - QueueLA) + 1);
#line 2220
  if ((int )tTdvect[3] >= 30) {
#line 2221
    if (rval) {
#line 2221
      tmp = "true";
    } else {
#line 2221
      tmp = "false";
    }
    {
#line 2221
    sm_dprintf((char *)"%s (by calculation)\n", tmp);
    }
  }
#line 2222
  return (rval);
}
}
#line 2249 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static time_t lastconn[10]  ;
#line 2250 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static int conncnt[10]  ;
#line 2251 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static time_t firstrejtime[10]  ;
#line 2252 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static time_t nextlogtime[10]  ;
#line 2335 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static time_t log_delay  =    (time_t )0;
#line 2242 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
bool refuseconnections(char *name , ENVELOPE *e , int d , bool active ) 
{ 
  int tmp ;
  int tmp___0 ;
  time_t now ;
  int tmp___1 ;
  time_t now___0 ;
  char *tmp___2 ;
  time_t now___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 2262
  if (d >= 0) {
#line 2262
    tmp = 1;
  } else {
    {
#line 2262
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c",
                2262, "SM_ASSERT(d >= 0) failed");
#line 2262
    tmp = 0;
    }
  }
#line 2263
  if (d < 10) {
#line 2263
    tmp___0 = 1;
  } else {
    {
#line 2263
    sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c",
                2263, "SM_ASSERT(d < MAXDAEMONS) failed");
#line 2263
    tmp___0 = 0;
    }
  }
#line 2264
  if (ConnRateThrottle > 0) {
    {
#line 2268
    now = curtime();
    }
#line 2269
    if (active) {
#line 2271
      if (now != lastconn[d]) {
#line 2273
        lastconn[d] = now;
#line 2274
        conncnt[d] = 1;
      } else {
#line 2276
        tmp___1 = conncnt[d];
#line 2276
        (conncnt[d]) ++;
#line 2276
        if (tmp___1 > ConnRateThrottle) {
          {
#line 2280
          sm_setproctitle(1, e, "deferring connections on daemon %s: %d per second",
                          name, ConnRateThrottle);
          }
#line 2282
          if (LogLevel > 8) {
            {
#line 2283
            sm_syslog(6, "*~*", "deferring connections on daemon %s: %d per second",
                      name, ConnRateThrottle);
            }
          }
          {
#line 2285
          sleep(1U);
          }
        }
      }
    } else
#line 2288
    if (now != lastconn[d]) {
#line 2289
      conncnt[d] = 0;
    }
  }
  {
#line 2305
  sm_getla();
  }
#line 2306
  if (RefuseLA > 0) {
#line 2306
    if (CurrentLA >= RefuseLA) {
      {
#line 2312
      sm_setproctitle(1, e, "rejecting connections on daemon %s: load average: %d",
                      name, CurrentLA);
      }
#line 2313
      if (LogLevel > 8) {
        {
#line 2314
        sm_syslog(5, "*~*", "rejecting connections on daemon %s: load average: %d",
                  name, CurrentLA);
        }
      }
      {
#line 2315
      now___0 = curtime();
      }
#line 2316
      if (firstrejtime[d] == 0L) {
#line 2318
        firstrejtime[d] = now___0;
#line 2319
        nextlogtime[d] = now___0 + RejectLogInterval;
      } else
#line 2321
      if (nextlogtime[d] < now___0) {
        {
#line 2323
        tmp___2 = pintvl(now___0 - firstrejtime[d], 1);
#line 2323
        sm_syslog(3, "*~*", "have been rejecting connections on daemon %s for %s",
                  name, tmp___2);
#line 2325
        nextlogtime[d] = now___0 + RejectLogInterval;
        }
      }
#line 2327
      return (1);
    } else {
#line 2330
      firstrejtime[d] = (time_t )0;
    }
  } else {
#line 2330
    firstrejtime[d] = (time_t )0;
  }
#line 2332
  if (DelayLA > 0) {
#line 2332
    if (CurrentLA >= DelayLA) {
      {
#line 2340
      sm_setproctitle(1, e, "delaying connections on daemon %s: load average=%d >= %d",
                      name, DelayLA);
      }
#line 2341
      if (LogLevel > 8) {
        {
#line 2341
        now___1 = curtime();
        }
#line 2341
        if (now___1 > log_delay) {
          {
#line 2343
          sm_syslog(6, "*~*", "delaying connections on daemon %s: load average=%d >= %d",
                    name, CurrentLA, DelayLA);
#line 2345
          log_delay = now___1 + 90L;
          }
        }
      }
      {
#line 2347
      sleep(1U);
      }
    }
  }
#line 2350
  if (MaxChildren > 0) {
#line 2350
    if (CurChildren >= (int volatile   )MaxChildren) {
      {
#line 2352
      proc_list_probe();
      }
#line 2353
      if (CurChildren >= (int volatile   )MaxChildren) {
        {
#line 2356
        sm_setproctitle(1, e, "rejecting connections on daemon %s: %d children, max %d",
                        name, CurChildren, MaxChildren);
        }
#line 2358
        if (LogLevel > 8) {
          {
#line 2359
          sm_syslog(6, "*~*", "rejecting connections on daemon %s: %d children, max %d",
                    name, CurChildren, MaxChildren);
          }
        }
#line 2361
        return (1);
      }
    }
  }
#line 2364
  return (0);
}
}
#line 2469 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static char **Argv  =    (char **)((void *)0);
#line 2470 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static char *LastArgv  =    (char *)((void *)0);
#line 2472
static void setproctitle(char const   *fmt  , ...) ;
#line 2483
extern char **environ ;
#line 2475 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void initsetproctitle(int argc , char **argv , char **envp ) 
{ 
  register int i ;
  int align ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp9 ;

  {
#line 2490
  if ((unsigned long )envp != (unsigned long )((void *)0)) {
#line 2492
    i = 0;
    {
#line 2492
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2492
      if (! ((unsigned long )*(envp + i) != (unsigned long )((void *)0))) {
#line 2492
        goto while_break;
      }
#line 2493
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 2492
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2494
    tmp = xalloc_tagged((int )(sizeof(char *) * (unsigned long )(i + 1)), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c",
                        2494);
#line 2494
    environ = (char **)tmp;
#line 2495
    i = 0;
    }
    {
#line 2495
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2495
      if (! ((unsigned long )*(envp + i) != (unsigned long )((void *)0))) {
#line 2495
        goto while_break___0;
      }
      {
#line 2496
      *(environ + i) = newstr((char const   *)*(envp + i));
#line 2495
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2497
    *(environ + i) = (char *)((void *)0);
  }
#line 2504
  Argv = argv;
#line 2511
  align = -1;
#line 2519
  i = 0;
  {
#line 2519
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2519
    if (! (i < argc)) {
#line 2519
      goto while_break___1;
    }
#line 2521
    if (i == 0) {
      {
#line 2522
      tmp___0 = strlen((char const   *)*(argv + i));
#line 2522
      LastArgv = *(argv + i) + tmp___0;
      }
    } else
#line 2521
    if ((unsigned long )(LastArgv + 1) == (unsigned long )*(argv + i)) {
      {
#line 2522
      tmp___0 = strlen((char const   *)*(argv + i));
#line 2522
      LastArgv = *(argv + i) + tmp___0;
      }
    }
#line 2519
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2524
  i = 0;
  {
#line 2524
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2524
    if ((unsigned long )LastArgv != (unsigned long )((void *)0)) {
#line 2524
      if ((unsigned long )envp != (unsigned long )((void *)0)) {
#line 2524
        if (! ((unsigned long )*(envp + i) != (unsigned long )((void *)0))) {
#line 2524
          goto while_break___2;
        }
      } else {
#line 2524
        goto while_break___2;
      }
    } else {
#line 2524
      goto while_break___2;
    }
#line 2526
    if ((unsigned long )(LastArgv + 1) == (unsigned long )*(envp + i)) {
      {
#line 2527
      tmp___1 = strlen((char const   *)*(envp + i));
#line 2527
      LastArgv = *(envp + i) + tmp___1;
      }
    }
#line 2524
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2529
  return;
}
}
#line 2534 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static void setproctitle(char const   *fmt  , ...) 
{ 
  register int i ;
  register char *p ;
  char buf___16[2048] ;
  va_list ap ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2559
  p = buf___16;
#line 2562
  sm_strlcpy(p, "sendmail: ", (ssize_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)));
#line 2563
  tmp = strlen((char const   *)p);
#line 2563
  p += tmp;
#line 2566
  __builtin_va_start(ap, fmt);
#line 2567
  sm_vsnprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)), fmt,
               ap);
#line 2568
  __builtin_va_end(ap);
#line 2570
  tmp___0 = strlen((char const   *)(buf___16));
#line 2570
  i = (int )tmp___0;
  }
#line 2571
  if (i < 0) {
#line 2572
    return;
  }
#line 2608
  if ((unsigned long )LastArgv == (unsigned long )((void *)0)) {
#line 2609
    return;
  }
#line 2611
  if ((long )i > (LastArgv - *(Argv + 0)) - 2L) {
#line 2613
    i = (int )((LastArgv - *(Argv + 0)) - 2L);
#line 2614
    buf___16[i] = (char )'\000';
  }
  {
#line 2616
  sm_strlcpy(*(Argv + 0), (char const   *)(buf___16), i + 1);
#line 2617
  p = *(Argv + 0) + i;
  }
  {
#line 2618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2618
    if (! ((unsigned long )p < (unsigned long )LastArgv)) {
#line 2618
      goto while_break;
    }
#line 2619
    tmp___1 = p;
#line 2619
    p ++;
#line 2619
    *tmp___1 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 2620
  *(Argv + 1) = (char *)((void *)0);
#line 2627
  return;
}
}
#line 2647 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void sm_setproctitle(bool status , ENVELOPE *e , char const   *fmt  , ...) 
{ 
  char buf___16[2048] ;
  va_list ap ;
  char prefix[2048] ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2662
  __builtin_va_start(ap, fmt);
#line 2663
  sm_vsnprintf(buf___16, (size_t )sizeof(buf___16), fmt, ap);
#line 2664
  __builtin_va_end(ap);
  }
#line 2666
  if (status) {
    {
#line 2667
    proc_list_set(CurrentPid, buf___16);
    }
  }
#line 2669
  if ((unsigned long )ProcTitlePrefix != (unsigned long )((void *)0)) {
    {
#line 2673
    expand(ProcTitlePrefix, prefix, (size_t )sizeof(prefix), e);
#line 2674
    setproctitle("%s: %s", prefix, buf___16);
    }
  } else {
    {
#line 2677
    setproctitle("%s", buf___16);
    }
  }
#line 2678
  return;
}
}
#line 2693 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
int waitfor(pid_t pid ) 
{ 
  int st ;
  pid_t i ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 2700
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2702
    tmp = __errno_location();
#line 2702
    *tmp = 0;
#line 2703
    i = sm_wait(& st);
    }
#line 2704
    if (i > 0) {
      {
#line 2705
      proc_list_drop(i, st, (int *)((void *)0));
      }
    }
#line 2700
    if (i >= 0) {
#line 2700
      goto _L;
    } else {
      {
#line 2700
      tmp___0 = __errno_location();
      }
#line 2700
      if (*tmp___0 == 4) {
        _L: /* CIL Label */ 
#line 2700
        if (! (i != pid)) {
#line 2700
          goto while_break;
        }
      } else {
#line 2700
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2707
  if (i < 0) {
#line 2708
    return (-1);
  }
#line 2709
  return (st);
}
}
#line 2721 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
pid_t sm_wait(int *status ) 
{ 
  int st ;
  pid_t i ;

  {
  {
#line 2738
  i = wait((union wait *)(& st));
#line 2746
  *status = st;
  }
#line 2748
  return (i);
}
}
#line 2769 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void reapchild(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  int st ;
  pid_t pid ;
  int status ;
  int count ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 2773
  tmp = __errno_location();
#line 2773
  save_errno = *tmp;
#line 2780
  count = 0;
  }
  {
#line 2781
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2781
    pid = waitpid(-1, & status, 1);
    }
#line 2781
    if (! (pid > 0)) {
#line 2781
      goto while_break;
    }
#line 2783
    st = status;
#line 2784
    tmp___0 = count;
#line 2784
    count ++;
#line 2784
    if (tmp___0 > 1000) {
#line 2785
      goto while_break;
    }
    {
#line 2809
    proc_list_drop(pid, st, (int *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2812
  tmp___1 = __errno_location();
#line 2812
  *tmp___1 = save_errno;
  }
#line 2813
  return;
}
}
#line 2834 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
int getdtsize(void) 
{ 
  struct rlimit rl ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2840
  tmp = getrlimit(7, & rl);
  }
#line 2840
  if (tmp >= 0) {
#line 2841
    return ((int )rl.rlim_cur);
  }
  {
#line 2845
  tmp___0 = getdtablesize();
  }
#line 2845
  return (tmp___0);
}
}
#line 3035 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
int opterr  =    1;
#line 3036 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
int optind  =    1;
#line 3037 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
int optopt  =    0;
#line 3038 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
char *optarg  =    (char *)((void *)0);
#line 3056 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static char *place  =    (char *)"";
#line 3057 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static char atend  =    (char)0;
#line 3050
 __attribute__((__nothrow__)) int getopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 3050 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
int getopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ 
  register char *oli ;
  char *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 3058
  oli = (char *)((void *)0);
#line 3060
  if (atend) {
#line 3061
    atend = (char)0;
#line 3062
    place = (char *)"";
  }
#line 3064
  if (! *place) {
#line 3065
    if (optind >= nargc) {
#line 3066
      atend = (char )((int )atend + 1);
#line 3067
      return (-1);
    } else {
#line 3065
      place = (char *)*(nargv + optind);
#line 3065
      if ((int )*place != 45) {
#line 3066
        atend = (char )((int )atend + 1);
#line 3067
        return (-1);
      } else {
#line 3065
        place ++;
#line 3065
        if (! *place) {
#line 3066
          atend = (char )((int )atend + 1);
#line 3067
          return (-1);
        }
      }
    }
#line 3069
    if ((int )*place == 45) {
#line 3070
      optind ++;
#line 3071
      atend = (char )((int )atend + 1);
#line 3072
      return (-1);
    }
  }
#line 3075
  tmp = place;
#line 3075
  place ++;
#line 3075
  optopt = (int )*tmp;
#line 3075
  if (optopt == 58) {
#line 3075
    goto _L;
  } else {
    {
#line 3075
    oli = strchr(ostr, optopt);
    }
#line 3075
    if (! oli) {
      _L: /* CIL Label */ 
#line 3076
      if (! *place) {
#line 3076
        optind ++;
      }
#line 3077
      if (opterr) {
        {
#line 3077
        sm_io_fputs(& SmIoF[2], -2, (char const   *)*nargv);
#line 3077
        sm_io_fputs(& SmIoF[2], -2, ": illegal option -- ");
#line 3077
        sm_io_putc(& SmIoF[2], -2, optopt);
#line 3077
        sm_io_putc(& SmIoF[2], -2, '\n');
        }
#line 3077
        return ('?');
      }
    }
  }
#line 3079
  if (oli) {
#line 3079
    oli ++;
#line 3079
    if ((int )*oli != 58) {
#line 3080
      optarg = (char *)((void *)0);
#line 3081
      if (! *place) {
#line 3081
        optind ++;
      }
    } else {
#line 3079
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 3084
    if (*place) {
#line 3084
      optarg = place;
    } else {
#line 3085
      optind ++;
#line 3085
      if (nargc <= optind) {
#line 3086
        place = (char *)"";
#line 3087
        if (opterr) {
          {
#line 3087
          sm_io_fputs(& SmIoF[2], -2, (char const   *)*nargv);
#line 3087
          sm_io_fputs(& SmIoF[2], -2, ": option requires an argument -- ");
#line 3087
          sm_io_putc(& SmIoF[2], -2, optopt);
#line 3087
          sm_io_putc(& SmIoF[2], -2, '\n');
          }
#line 3087
          return ('?');
        }
      } else {
#line 3089
        optarg = (char *)*(nargv + optind);
      }
    }
#line 3090
    place = (char *)"";
#line 3091
    optind ++;
  }
#line 3093
  return (optopt);
}
}
#line 3123 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static char *DefaultUserShells[5]  = {      (char *)"/bin/sh",      (char *)"/usr/bin/sh",      (char *)"/bin/csh",      (char *)"/usr/bin/csh", 
        (char *)((void *)0)};
#line 3189 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
bool usershellok(char *user , char *shell ) 
{ 
  register SM_FILE_T *shellf ;
  char buf___16[2048] ;
  bool tmp ;
  char **d ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  register char *p ;
  register char *q ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 3215
  if ((unsigned long )shell == (unsigned long )((void *)0)) {
#line 3217
    return (1);
  } else
#line 3215
  if ((int )*(shell + 0) == 0) {
#line 3217
    return (1);
  } else {
    {
#line 3215
    tmp = wordinclass(user, 't');
    }
#line 3215
    if (tmp) {
#line 3217
      return (1);
    } else
#line 3215
    if (ConfigLevel <= 1) {
#line 3217
      return (1);
    }
  }
  {
#line 3245
  shellf = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)"/etc/shells",
                      2, (void const   *)((void *)0));
  }
#line 3247
  if ((unsigned long )shellf == (unsigned long )((void *)0)) {
    {
#line 3252
    tmp___2 = __errno_location();
    }
#line 3252
    if (*tmp___2 != 2) {
#line 3252
      if (LogLevel > 3) {
        {
#line 3253
        tmp___0 = __errno_location();
#line 3253
        tmp___1 = sm_errstring(*tmp___0);
#line 3253
        sm_syslog(3, "*~*", "usershellok: cannot open %s: %s", "/etc/shells", tmp___1);
        }
      }
    }
#line 3257
    d = DefaultUserShells;
    {
#line 3257
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3257
      if (! ((unsigned long )*d != (unsigned long )((void *)0))) {
#line 3257
        goto while_break;
      }
      {
#line 3259
      tmp___3 = strcmp((char const   *)shell, (char const   *)*d);
      }
#line 3259
      if (tmp___3 == 0) {
#line 3260
        return (1);
      }
#line 3257
      d ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 3262
    return (0);
  }
  {
#line 3265
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 3265
    tmp___7 = sm_io_fgets(shellf, -2, buf___16, (int )sizeof(buf___16));
    }
#line 3265
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
#line 3265
      goto while_break___0;
    }
#line 3269
    p = buf___16;
    {
#line 3270
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3270
      if ((int )*p != 0) {
#line 3270
        if ((int )*p != 35) {
#line 3270
          if (! ((int )*p != 47)) {
#line 3270
            goto while_break___1;
          }
        } else {
#line 3270
          goto while_break___1;
        }
      } else {
#line 3270
        goto while_break___1;
      }
#line 3271
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3272
    if ((int )*p == 35) {
#line 3273
      goto while_continue___0;
    } else
#line 3272
    if ((int )*p == 0) {
#line 3273
      goto while_continue___0;
    }
#line 3274
    q = p;
    {
#line 3275
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3275
      if ((int )*p != 0) {
#line 3275
        if ((int )*p != 35) {
#line 3275
          if (((int )*p & -128) == 0) {
            {
#line 3275
            tmp___4 = __ctype_b_loc();
            }
#line 3275
            if ((int const   )*(*tmp___4 + (int )*p) & 8192) {
#line 3275
              goto while_break___2;
            }
          }
        } else {
#line 3275
          goto while_break___2;
        }
      } else {
#line 3275
        goto while_break___2;
      }
#line 3276
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3277
    *p = (char )'\000';
#line 3278
    tmp___5 = strcmp((char const   *)shell, (char const   *)q);
    }
#line 3278
    if (tmp___5 == 0) {
      {
#line 3280
      sm_io_close(shellf, -2);
      }
#line 3281
      return (1);
    } else {
      {
#line 3278
      tmp___6 = strcmp("/SENDMAIL/ANY/SHELL/", (char const   *)q);
      }
#line 3278
      if (tmp___6 == 0) {
        {
#line 3280
        sm_io_close(shellf, -2);
        }
#line 3281
        return (1);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3284
  sm_io_close(shellf, -2);
  }
#line 3285
  return (0);
}
}
#line 32 "/usr/include/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) statfs)(char const   *__file ,
                                                                                     struct statfs *__buf ) ;
#line 3335 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
long freediskspace(char *dir___0 , long *bsize ) 
{ 
  struct statfs fs ;
  int tmp ;

  {
  {
#line 3383
  tmp = statfs((char const   *)dir___0, & fs);
  }
#line 3383
  if (tmp == 0) {
#line 3389
    if ((unsigned long )bsize != (unsigned long )((void *)0)) {
#line 3390
      *bsize = (long )fs.f_bsize;
    }
#line 3391
    if (fs.f_bavail <= 0UL) {
#line 3392
      return (0L);
    } else
#line 3393
    if (fs.f_bavail > 2147483647UL) {
#line 3394
      return (2147483647L);
    } else {
#line 3396
      return ((long )fs.f_bavail);
    }
  }
#line 3398
  return (-1L);
}
}
#line 3420 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
bool enoughdiskspace(long msize , ENVELOPE *e ) 
{ 
  int i ;
  int tmp ;
  char *__cil_tmp5 ;

  {
#line 3427
  if (MinBlocksFree <= 0L) {
#line 3427
    if (msize <= 0L) {
#line 3429
      if ((int )tTdvect[4] >= 80) {
        {
#line 3430
        sm_dprintf((char *)"enoughdiskspace: no threshold\n");
        }
      }
#line 3431
      return (1);
    }
  }
  {
#line 3434
  filesys_update();
#line 3435
  i = 0;
  }
  {
#line 3435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3435
    if (! (i < NumQueue)) {
#line 3435
      goto while_break;
    }
    {
#line 3437
    tmp = pickqdir(Queue[i], msize, e);
    }
#line 3437
    if (tmp < 0) {
#line 3438
      return (0);
    }
#line 3435
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3440
  return (1);
}
}
#line 3456 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
bool transienterror(int err ) 
{ 


  {
  {
#line 3540
  if (err == 256) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 37) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 63) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 26) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 99) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 98) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 114) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 115) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 106) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 35) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 87) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 122) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 113) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 112) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 111) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 108) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 105) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 104) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 103) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 102) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 101) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 100) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 116) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 110) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 28) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 24) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 23) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 19) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 12) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 11) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 6) {
#line 3540
    goto case_256;
  }
#line 3540
  if (err == 5) {
#line 3540
    goto case_256;
  }
#line 3460
  goto switch_break;
  case_256: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 3541
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 3545
  return (0);
}
}
#line 3730 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
bool chownsafe(int fd , bool safedir ) 
{ 
  int rval ;
  int *tmp ;
  long tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 3740
  if (DontBlameSendmail[1UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 1UL % (8UL * sizeof(int )))) {
#line 3741
    return (1);
  }
  {
#line 3749
  tmp = __errno_location();
#line 3749
  *tmp = 0;
#line 3750
  tmp___0 = fpathconf(fd, 6);
#line 3750
  rval = (int )tmp___0;
  }
#line 3754
  if (safedir) {
    {
#line 3754
    tmp___1 = __errno_location();
    }
#line 3754
    if (*tmp___1 == 0) {
#line 3754
      if (rval > 0) {
#line 3754
        tmp___2 = 1;
      } else {
#line 3754
        tmp___2 = 0;
      }
    } else {
#line 3754
      tmp___2 = 0;
    }
  } else {
#line 3754
    tmp___2 = 0;
  }
#line 3754
  return (tmp___2);
}
}
#line 3779 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void resetlimits(void) 
{ 
  struct rlimit lim ;
  int *tmp ;

  {
  {
#line 3785
  lim.rlim_max = ~ 0UL;
#line 3785
  lim.rlim_cur = lim.rlim_max;
#line 3786
  setrlimit(0, (struct rlimit  const  *)(& lim));
#line 3787
  setrlimit(1, (struct rlimit  const  *)(& lim));
#line 3789
  lim.rlim_max = (rlim_t )1024;
#line 3789
  lim.rlim_cur = lim.rlim_max;
#line 3790
  setrlimit(7, (struct rlimit  const  *)(& lim));
#line 3798
  tmp = __errno_location();
#line 3798
  *tmp = 0;
  }
#line 3799
  return;
}
}
#line 3817 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
bool setvendor(char *vendor ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 3821
  tmp = sm_strcasecmp((char const   *)vendor, "Berkeley");
  }
#line 3821
  if (tmp == 0) {
#line 3823
    VendorCode = 1;
#line 3824
    return (1);
  }
#line 3852
  return (0);
}
}
#line 3864 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
char *getvendor(int vendorcode ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 3881
  if (vendorcode == 1) {
#line 3881
    goto case_1;
  }
#line 3884
  if (vendorcode == 2) {
#line 3884
    goto case_2;
  }
#line 3887
  if (vendorcode == 3) {
#line 3887
    goto case_3;
  }
#line 3890
  if (vendorcode == 4) {
#line 3890
    goto case_4;
  }
#line 3893
  if (vendorcode == 5) {
#line 3893
    goto case_5;
  }
#line 3896
  goto switch_default;
  case_1: /* CIL Label */ 
#line 3882
  return ((char *)"Berkeley");
  case_2: /* CIL Label */ 
#line 3885
  return ((char *)"Sun");
  case_3: /* CIL Label */ 
#line 3888
  return ((char *)"HP");
  case_4: /* CIL Label */ 
#line 3891
  return ((char *)"IBM");
  case_5: /* CIL Label */ 
#line 3894
  return ((char *)"Sendmail");
  switch_default: /* CIL Label */ 
#line 3897
  return ((char *)"Unknown");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3917 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void vendor_pre_defaults(ENVELOPE *e ) 
{ 


  {
#line 3937
  return;
}
}
#line 3940 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void vendor_post_defaults(ENVELOPE *e ) 
{ 


  {
#line 3954
  return;
}
}
#line 3959 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void vendor_daemon_setup(ENVELOPE *e ) 
{ 


  {
#line 3973
  return;
}
}
#line 3986 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void vendor_set_uid(uid_t uid ) 
{ 


  {
#line 4002
  return;
}
}
#line 4047 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static char reject[16384]  ;
#line 4027 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
char *validate_connection(union bigsockaddr *sap , char *hostname , ENVELOPE *e ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 4039
  if ((int )tTdvect[48] >= 3) {
    {
#line 4040
    tmp = anynet_ntoa(sap);
#line 4040
    sm_dprintf((char *)"validate_connection(%s, %s)\n", hostname, tmp);
    }
  }
  {
#line 4043
  connection_rate_check(sap, e);
#line 4044
  tmp___1 = anynet_ntoa(sap);
#line 4044
  tmp___2 = rscheck((char *)"check_relay", hostname, tmp___1, e, 5, 3, (char *)((void *)0),
                    (char *)"*~*");
  }
#line 4044
  if (tmp___2 != 0) {
#line 4050
    if ((int )tTdvect[48] >= 4) {
      {
#line 4051
      sm_dprintf((char *)"  ... validate_connection: BAD (rscheck)\n");
      }
    }
    {
#line 4053
    tmp___0 = strlen((char const   *)(MsgBuf));
    }
#line 4053
    if (tmp___0 >= 3U) {
      {
#line 4054
      sm_strlcpy(reject, (char const   *)(MsgBuf), (ssize_t )sizeof(reject));
      }
    } else {
      {
#line 4056
      sm_strlcpy(reject, "Access denied", (ssize_t )sizeof(reject));
      }
    }
#line 4058
    return (reject);
  }
#line 4085
  if ((int )tTdvect[48] >= 4) {
    {
#line 4086
    sm_dprintf((char *)"  ... validate_connection: OK\n");
    }
  }
#line 4087
  return ((char *)((void *)0));
}
}
#line 4308 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
struct hostent *sm_gethostbyname(char *name , int family ) 
{ 
  int save_errno ;
  struct hostent *h ;
  int nmaps ;
  char *maptype[12] ;
  short mapreturn[5] ;
  char hbuf___0[256] ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  struct in_addr ia ;
  size_t i ;
  char *addr ;
  char *tmp___6 ;
  int *tmp___7 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 4314
  h = (struct hostent *)((void *)0);
#line 4343
  if ((int )tTdvect[61] >= 10) {
    {
#line 4344
    sm_dprintf((char *)"sm_gethostbyname(%s, %d)... ", name, family);
    }
  }
  {
#line 4353
  h = gethostbyname((char const   *)name);
#line 4356
  tmp = __errno_location();
#line 4356
  save_errno = *tmp;
  }
#line 4357
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 4359
    if ((int )tTdvect[61] >= 10) {
      {
#line 4360
      sm_dprintf((char *)"failure\n");
      }
    }
    {
#line 4362
    nmaps = switch_map_find((char *)"hosts", (char **)(maptype), (short *)(mapreturn));
    }
    {
#line 4363
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4363
      nmaps --;
#line 4363
      if (! (nmaps >= 0)) {
#line 4363
        goto while_break;
      }
      {
#line 4365
      tmp___0 = strcmp((char const   *)maptype[nmaps], "nis");
      }
#line 4365
      if (tmp___0 == 0) {
#line 4367
        goto while_break;
      } else {
        {
#line 4365
        tmp___1 = strcmp((char const   *)maptype[nmaps], "files");
        }
#line 4365
        if (tmp___1 == 0) {
#line 4367
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 4370
    if (nmaps >= 0) {
      {
#line 4373
      tmp___3 = strlen((char const   *)name);
      }
#line 4373
      if ((unsigned long )tmp___3 > sizeof(hbuf___0) - 1UL) {
        {
#line 4375
        tmp___2 = __errno_location();
#line 4375
        *tmp___2 = save_errno;
        }
#line 4376
        return ((struct hostent *)((void *)0));
      }
      {
#line 4378
      sm_strlcpy(hbuf___0, (char const   *)name, (ssize_t )sizeof(hbuf___0));
#line 4379
      shorten_hostname(hbuf___0);
#line 4382
      tmp___5 = strcmp((char const   *)(hbuf___0), (char const   *)name);
      }
#line 4382
      if (tmp___5 != 0) {
#line 4384
        if ((int )tTdvect[61] >= 10) {
          {
#line 4385
          sm_dprintf((char *)"sm_gethostbyname(%s, %d)... ", hbuf___0, family);
          }
        }
        {
#line 4393
        h = gethostbyname((char const   *)(hbuf___0));
#line 4394
        tmp___4 = __errno_location();
#line 4394
        save_errno = *tmp___4;
        }
      }
    }
  }
#line 4400
  if ((int )tTdvect[61] >= 10) {
#line 4402
    if ((unsigned long )h == (unsigned long )((void *)0)) {
      {
#line 4403
      sm_dprintf((char *)"failure\n");
      }
    } else {
      {
#line 4406
      sm_dprintf((char *)"%s\n", h->h_name);
      }
#line 4407
      if ((int )tTdvect[61] >= 11) {
#line 4417
        if ((unsigned long )h->h_aliases != (unsigned long )((void *)0)) {
#line 4418
          i = (size_t )0;
          {
#line 4418
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 4418
            if (! ((unsigned long )*(h->h_aliases + i) != (unsigned long )((void *)0))) {
#line 4418
              goto while_break___0;
            }
            {
#line 4420
            sm_dprintf((char *)"\talias: %s\n", *(h->h_aliases + i));
#line 4418
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 4422
        i = (size_t )0;
        {
#line 4422
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 4422
          if (! ((unsigned long )*(h->h_addr_list + i) != (unsigned long )((void *)0))) {
#line 4422
            goto while_break___1;
          }
          {
#line 4432
          memmove((void *)(& ia), (void const   *)*(h->h_addr_list + i), (size_t )4);
#line 4434
          tmp___6 = inet_ntoa(ia);
#line 4434
          addr = tmp___6;
          }
#line 4436
          if ((unsigned long )addr != (unsigned long )((void *)0)) {
            {
#line 4437
            sm_dprintf((char *)"\taddr: %s\n", addr);
            }
          }
#line 4422
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 4442
  tmp___7 = __errno_location();
#line 4442
  *tmp___7 = save_errno;
  }
#line 4443
  return (h);
}
}
#line 4446 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
struct hostent *sm_gethostbyaddr(char *addr , int len___0 , int type ) 
{ 
  struct hostent *hp ;

  {
  {
#line 4490
  hp = gethostbyaddr((void const   *)addr, (__socklen_t )len___0, type);
  }
#line 4493
  return (hp);
}
}
#line 4499 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
struct passwd *sm_getpwnam(char *user ) 
{ 
  struct passwd *tmp ;

  {
  {
#line 4508
  tmp = getpwnam((char const   *)user);
  }
#line 4508
  return (tmp);
}
}
#line 4512 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
struct passwd *sm_getpwuid(uid_t uid ) 
{ 
  struct passwd *tmp ;

  {
  {
#line 4521
  tmp = getpwuid(uid);
  }
#line 4521
  return (tmp);
}
}
#line 4603 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static int add_hostnames(union bigsockaddr *sa ) 
{ 
  struct hostent *hp ;
  char **ha ;
  char hnb[64] ;
  char *tmp ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 4615
  if ((int )sa->sa.sa_family == 2) {
#line 4615
    goto case_2;
  }
#line 4630
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 4616
  hp = sm_gethostbyaddr((char *)(& sa->sin.sin_addr), (int )sizeof(sa->sin.sin_addr),
                        (int )sa->sa.sa_family);
  }
#line 4619
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4632
  if (LogLevel > 3) {
    {
#line 4633
    tmp = anynet_ntoa(sa);
#line 4633
    sm_syslog(4, "*~*", "Unsupported address family %d: %.100s", (int )sa->sa.sa_family,
              tmp);
    }
  }
#line 4636
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 4639
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    {
#line 4641
    tmp___0 = __errno_location();
#line 4641
    save_errno = *tmp___0;
    }
#line 4643
    if (LogLevel > 3) {
      {
#line 4649
      tmp___1 = __h_errno_location();
#line 4649
      tmp___2 = anynet_ntoa(sa);
#line 4649
      sm_syslog(4, "*~*", "gethostbyaddr(%.100s) failed: %d", tmp___2, *tmp___1);
      }
    }
    {
#line 4658
    tmp___3 = __errno_location();
#line 4658
    *tmp___3 = save_errno;
    }
#line 4659
    return (-1);
  }
  {
#line 4663
  tmp___6 = wordinclass(hp->h_name, 'w');
  }
#line 4663
  if (tmp___6) {
#line 4675
    if ((int )tTdvect[0] >= 43) {
      {
#line 4676
      sm_dprintf((char *)"\ta.k.a.: %s (already in $=w)\n", hp->h_name);
      }
    }
  } else {
    {
#line 4665
    setclass('w', hp->h_name);
    }
#line 4666
    if ((int )tTdvect[0] >= 4) {
      {
#line 4667
      sm_dprintf((char *)"\ta.k.a.: %s\n", hp->h_name);
      }
    }
    {
#line 4669
    tmp___4 = sm_snprintf(hnb, (size_t )sizeof(hnb), "[%s]", hp->h_name);
    }
#line 4669
    if ((unsigned long )tmp___4 < sizeof(hnb)) {
      {
#line 4669
      tmp___5 = wordinclass(hnb, 'w');
      }
#line 4669
      if (! tmp___5) {
        {
#line 4671
        setclass('w', hnb);
        }
      }
    }
  }
#line 4680
  ha = hp->h_aliases;
  {
#line 4680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4680
    if ((unsigned long )ha != (unsigned long )((void *)0)) {
#line 4680
      if (! ((unsigned long )*ha != (unsigned long )((void *)0))) {
#line 4680
        goto while_break;
      }
    } else {
#line 4680
      goto while_break;
    }
    {
#line 4682
    tmp___9 = wordinclass(*ha, 'w');
    }
#line 4682
    if (tmp___9) {
#line 4694
      if ((int )tTdvect[0] >= 43) {
        {
#line 4695
        sm_dprintf((char *)"\ta.k.a.: %s (already in $=w)\n", *ha);
        }
      }
    } else {
      {
#line 4684
      setclass('w', *ha);
      }
#line 4685
      if ((int )tTdvect[0] >= 4) {
        {
#line 4686
        sm_dprintf((char *)"\ta.k.a.: %s\n", *ha);
        }
      }
      {
#line 4687
      tmp___7 = sm_snprintf(hnb, (size_t )sizeof(hnb), "[%s]", *ha);
      }
#line 4687
      if ((unsigned long )tmp___7 < sizeof(hnb)) {
        {
#line 4687
        tmp___8 = wordinclass(hnb, 'w');
        }
#line 4687
        if (! tmp___8) {
          {
#line 4690
          setclass('w', hnb);
          }
        }
      }
    }
#line 4680
    ha ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4702
  return (0);
}
}
#line 4733 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void load_if_names(void) 
{ 
  int s ;
  int i ;
  struct ifconf ifc ;
  int numifs ;
  int *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int af ;
  struct ifreq *ifr ;
  union bigsockaddr *sa ;
  struct in_addr ia ;
  struct ifreq ifrf ;
  char ip_addr[256] ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  bool tmp___5 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 4983
  s = socket(2, 2, 0);
  }
#line 4984
  if (s == -1) {
#line 4985
    return;
  }
#line 5001
  numifs = 512;
#line 5003
  if (numifs <= 0) {
    {
#line 5005
    close(s);
    }
#line 5006
    return;
  }
  {
#line 5008
  ifc.ifc_len = (int )((unsigned long )numifs * sizeof(struct ifreq ));
#line 5009
  ifc.ifc_ifcu.ifcu_buf = xalloc_tagged(ifc.ifc_len, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c",
                                        5009);
#line 5010
  tmp___1 = ioctl(s, 35090UL, (char *)(& ifc));
  }
#line 5010
  if (tmp___1 < 0) {
#line 5012
    if ((int )tTdvect[0] >= 4) {
      {
#line 5013
      tmp = __errno_location();
#line 5013
      tmp___0 = sm_errstring(*tmp);
#line 5013
      sm_dprintf((char *)"SIOCGIFCONF failed: %s\n", tmp___0);
      }
    }
    {
#line 5015
    close(s);
    }
#line 5016
    return;
  }
#line 5020
  if ((int )tTdvect[0] >= 40) {
    {
#line 5021
    sm_dprintf((char *)"scanning for interface specific names, ifc_len=%d\n", ifc.ifc_len);
    }
  }
#line 5024
  i = 0;
  {
#line 5024
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5024
    if (i < ifc.ifc_len) {
#line 5024
      if (! (i >= 0)) {
#line 5024
        goto while_break;
      }
    } else {
#line 5024
      goto while_break;
    }
#line 5027
    ifr = (struct ifreq *)(ifc.ifc_ifcu.ifcu_buf + i);
#line 5028
    sa = (union bigsockaddr *)(& ifr->ifr_ifru.ifru_addr);
#line 5047
    if ((unsigned long )(ifc.ifc_len - i) < sizeof(*ifr)) {
#line 5048
      goto while_break;
    }
#line 5055
    i = (int )((unsigned long )i + sizeof(*ifr));
#line 5057
    if ((int )tTdvect[0] >= 20) {
      {
#line 5058
      tmp___2 = anynet_ntoa(sa);
#line 5058
      sm_dprintf((char *)"%s\n", tmp___2);
      }
    }
#line 5060
    af = (int )ifr->ifr_ifru.ifru_addr.sa_family;
#line 5061
    if (af != 2) {
#line 5066
      goto __Cont;
    }
    {
#line 5069
    memset((void *)(& ifrf), '\000', (size_t )sizeof(struct ifreq ));
#line 5070
    sm_strlcpy(ifrf.ifr_ifrn.ifrn_name, (char const   *)(ifr->ifr_ifrn.ifrn_name),
               (ssize_t )sizeof(ifrf.ifr_ifrn.ifrn_name));
#line 5072
    ioctl(s, 35091UL, (char *)(& ifrf));
    }
#line 5073
    if ((int )tTdvect[0] >= 41) {
      {
#line 5074
      sm_dprintf((char *)"\tflags: %lx\n", (unsigned long )ifrf.ifr_ifru.ifru_flags);
      }
    }
#line 5081
    if (! (((int )ifrf.ifr_ifru.ifru_flags & 1) != 0)) {
#line 5082
      goto __Cont;
    }
#line 5084
    ip_addr[0] = (char )'\000';
    {
#line 5089
    if (af == 2) {
#line 5089
      goto case_2;
    }
#line 5087
    goto switch_break;
    case_2: /* CIL Label */ 
#line 5090
    ia = sa->sin.sin_addr;
#line 5091
    if (ia.s_addr == 0U) {
      {
#line 5094
      tmp___3 = inet_ntoa(ia);
#line 5094
      message("WARNING: interface %s is UP with %s address", ifr->ifr_ifrn.ifrn_name,
              tmp___3);
      }
#line 5096
      goto __Cont;
    } else
#line 5091
    if (ia.s_addr == 4294967295U) {
      {
#line 5094
      tmp___3 = inet_ntoa(ia);
#line 5094
      message("WARNING: interface %s is UP with %s address", ifr->ifr_ifrn.ifrn_name,
              tmp___3);
      }
#line 5096
      goto __Cont;
    }
    {
#line 5100
    tmp___4 = inet_ntoa(ia);
#line 5100
    sm_snprintf(ip_addr, (size_t )sizeof(ip_addr), "[%.*s]", (int )sizeof(ip_addr) - 3,
                tmp___4);
    }
#line 5103
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 5143
    if ((int )ip_addr[0] == 0) {
#line 5144
      goto __Cont;
    }
    {
#line 5146
    tmp___5 = wordinclass(ip_addr, 'w');
    }
#line 5146
    if (! tmp___5) {
      {
#line 5148
      setclass('w', ip_addr);
      }
#line 5149
      if ((int )tTdvect[0] >= 4) {
        {
#line 5150
        sm_dprintf((char *)"\ta.k.a.: %s\n", ip_addr);
        }
      }
    }
#line 5154
    if (DontProbeInterfaces == 2) {
#line 5154
      if (((int )ifrf.ifr_ifru.ifru_flags & 8) != 0) {
#line 5156
        goto __Cont;
      }
    }
    {
#line 5158
    add_hostnames(sa);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5160
  sm_free_tagged((void *)ifc.ifc_ifcu.ifcu_buf, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c",
                 5160);
#line 5161
  close(s);
  }
#line 5165
  return;
}
}
#line 5178 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
bool isloopback(union bigsockaddr sa ) 
{ 
  uint32_t tmp ;

  {
  {
#line 5187
  tmp = ntohl(sa.sin.sin_addr.s_addr);
  }
#line 5187
  if ((tmp & 4278190080U) >> 24 == 127U) {
#line 5189
    return (1);
  }
#line 5191
  return (0);
}
}
#line 5203 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
static int get_num_procs_online(void) 
{ 
  int nproc ;
  long tmp ;

  {
  {
#line 5206
  nproc = 0;
#line 5220
  tmp = sysconf(84);
#line 5220
  nproc = (int )tmp;
  }
#line 5232
  if (nproc <= 0) {
#line 5233
    nproc = 1;
  }
#line 5234
  return (nproc);
}
}
#line 5247 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void sm_closefrom(int lowest , int highest ) 
{ 
  int i ;

  {
#line 5256
  i = lowest;
  {
#line 5256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5256
    if (! (i < highest)) {
#line 5256
      goto while_break;
    }
    {
#line 5257
    close(i);
#line 5256
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5259
  return;
}
}
#line 5294 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void sm_close_on_exec(int highest , int lowest ) 
{ 
  int i ;
  int j ;

  {
#line 5303
  i = lowest;
  {
#line 5303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5303
    if (! (i < highest)) {
#line 5303
      goto while_break;
    }
    {
#line 5305
    j = fcntl(i, 1, 0);
    }
#line 5305
    if (j != -1) {
      {
#line 5306
      fcntl(i, 2, j | 1);
      }
    }
#line 5303
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5309
  return;
}
}
#line 5320 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void seed_random(void) 
{ 
  long seed___0 ;
  struct timeval t ;
  int tmp ;

  {
  {
#line 5329
  seed___0 = (long )CurrentPid;
#line 5330
  tmp = gettimeofday((struct timeval */* __restrict  */)(& t), (__timezone_ptr_t )((void *)0));
  }
#line 5330
  if (tmp >= 0) {
#line 5331
    seed___0 += t.tv_sec + t.tv_usec;
  }
  {
#line 5334
  srandom((unsigned int )seed___0);
  }
#line 5339
  return;
}
}
#line 5373
int SyslogPrefixLen ;
#line 5354 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
void sm_syslog(int level , char const   *id , char const   *fmt  , ...) 
{ 
  char *buf___16 ;
  size_t bufsize ;
  char *begin ;
  char *end ;
  int save_errno ;
  int seq ;
  int idlen ;
  char buf0[2048] ;
  char *newstring ;
  va_list ap ;
  int *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int n ;
  int tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;
  char save ;
  int tmp___7 ;
  size_t tmp___8 ;
  int *tmp___9 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
#line 5369
  seq = 1;
#line 5376
  tmp = __errno_location();
#line 5376
  save_errno = *tmp;
  }
#line 5377
  if ((unsigned long )id == (unsigned long )((void *)0)) {
    {
#line 5379
    id = "NOQUEUE";
#line 5380
    tmp___0 = strlen(id);
#line 5380
    idlen = (int )(tmp___0 + (size_t )SyslogPrefixLen);
    }
  } else {
    {
#line 5382
    tmp___2 = strcmp(id, "*~*");
    }
#line 5382
    if (tmp___2 == 0) {
#line 5384
      id = "";
#line 5385
      idlen = SyslogPrefixLen;
    } else {
      {
#line 5388
      tmp___1 = strlen(id);
#line 5388
      idlen = (int )(tmp___1 + (size_t )SyslogPrefixLen);
      }
    }
  }
#line 5390
  buf___16 = buf0;
#line 5391
  bufsize = (size_t )sizeof(buf0);
  {
#line 5393
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5398
    __builtin_va_start(ap, fmt);
#line 5399
    n = sm_vsnprintf(buf___16, bufsize, fmt, ap);
#line 5400
    __builtin_va_end(ap);
    }
#line 5401
    if (n > 0) {
#line 5401
      tmp___3 = 1;
    } else {
      {
#line 5401
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c",
                  5401, "SM_ASSERT(n > 0) failed");
#line 5401
      tmp___3 = 0;
      }
    }
#line 5402
    if ((size_t )n < bufsize) {
#line 5403
      goto while_break;
    }
#line 5406
    bufsize = (size_t )(n + 1);
#line 5407
    if ((unsigned long )buf___16 != (unsigned long )(buf0)) {
      {
#line 5409
      sm_free_tagged((void *)buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c",
                     5409);
#line 5410
      buf___16 = (char *)((void *)0);
      }
    }
    {
#line 5412
    tmp___4 = sm_malloc_tagged_x(bufsize, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c",
                                 5412, SmHeapGroup);
#line 5412
    buf___16 = (char *)tmp___4;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5416
  newstring = str2prt(buf___16);
#line 5417
  tmp___6 = strlen((char const   *)newstring);
  }
#line 5417
  if ((tmp___6 + (size_t )idlen) + 1U < 1024U) {
#line 5420
    if ((int const   )*id == 0) {
      {
#line 5421
      syslog(level, "%s", newstring);
      }
    } else {
      {
#line 5423
      syslog(level, "%s: %s", id, newstring);
      }
    }
#line 5433
    if ((unsigned long )buf___16 != (unsigned long )(buf0)) {
      {
#line 5434
      sm_free_tagged((void *)buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c",
                     5434);
      }
    }
    {
#line 5435
    tmp___5 = __errno_location();
#line 5435
    *tmp___5 = save_errno;
    }
#line 5436
    return;
  }
#line 5446
  begin = newstring;
#line 5447
  idlen += 5;
  {
#line 5448
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5448
    if ((int )*begin != 0) {
      {
#line 5448
      tmp___8 = strlen((char const   *)begin);
      }
#line 5448
      if (! (tmp___8 + (size_t )idlen > 1024U)) {
#line 5448
        goto while_break___0;
      }
    } else {
#line 5448
      goto while_break___0;
    }
#line 5453
    if (seq >= 999) {
#line 5456
      goto while_break___0;
    }
#line 5458
    end = ((begin + 1024) - idlen) - 7;
    {
#line 5459
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5459
      if (! ((unsigned long )end > (unsigned long )begin)) {
#line 5459
        goto while_break___1;
      }
#line 5462
      if ((int )*end == 44) {
#line 5464
        end ++;
#line 5465
        goto while_break___1;
      } else
#line 5462
      if ((int )*end == 32) {
#line 5464
        end ++;
#line 5465
        goto while_break___1;
      }
#line 5467
      end --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5470
    if ((unsigned long )end == (unsigned long )begin) {
#line 5471
      end = ((begin + 1024) - idlen) - 7;
    }
    {
#line 5472
    save = *end;
#line 5473
    *end = (char)0;
#line 5475
    tmp___7 = seq;
#line 5475
    seq ++;
#line 5475
    syslog(level, "%s[%d]: %s ...", id, tmp___7, begin);
#line 5480
    *end = save;
#line 5481
    begin = end;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5483
  if (seq >= 999) {
    {
#line 5485
    syslog(level, "%s[%d]: log terminated, too many parts", id, seq);
    }
  } else
#line 5491
  if ((int )*begin != 0) {
    {
#line 5493
    syslog(level, "%s[%d]: %s", id, seq, begin);
    }
  }
#line 5498
  if ((unsigned long )buf___16 != (unsigned long )(buf0)) {
    {
#line 5499
    sm_free_tagged((void *)buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c",
                   5499);
    }
  }
  {
#line 5500
  tmp___9 = __errno_location();
#line 5500
  *tmp___9 = save_errno;
  }
#line 5501
  return;
}
}
#line 5687 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
char *CompileOptions[15]  = 
#line 5687
  {      (char *)"DNSMAP",      (char *)"LOG",      (char *)"MATCHGECOS",      (char *)"MILTER", 
        (char *)"MIME7TO8",      (char *)"MIME8TO7",      (char *)"NAMED_BIND",      (char *)"NETINET", 
        (char *)"NETUNIX",      (char *)"NEWDB",      (char *)"PIPELINING",      (char *)"SCANF", 
        (char *)"USERDB",      (char *)"XDEBUG",      (char *)((void *)0)};
#line 5838 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
char *OsCompileOptions[23]  = 
#line 5838
  {      (char *)"HASFCHOWN",      (char *)"HASFCHMOD",      (char *)"HASGETDTABLESIZE",      (char *)"HASINITGROUPS", 
        (char *)"HASLSTAT",      (char *)"HASNICE",      (char *)"HASRANDOM",      (char *)"HASRRESVPORT", 
        (char *)"HASSETREGID",      (char *)"HASSETREUID",      (char *)"HASSETRLIMIT",      (char *)"HASSETSID", 
        (char *)"HASSETVBUF",      (char *)"HASURANDOMDEV",      (char *)"HASSTRERROR",      (char *)"HASUNAME", 
        (char *)"HASUNSETENV",      (char *)"HASWAITPID",      (char *)"IDENTPROTO",      (char *)"REQUIRES_DIR_FSYNC", 
        (char *)"USE_DOUBLE_FORK",      (char *)"USE_SIGLONGJMP",      (char *)((void *)0)};
#line 6051 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/conf.c"
char *FFRCompileOptions[1]  = {      (char *)((void *)0)};
#line 18 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c"
static void eatfrom(char * volatile  fm , ENVELOPE *e ) ;
#line 19
static void collect_doheader(ENVELOPE *e ) ;
#line 20
static SM_FILE_T *collect_dfopen(ENVELOPE *e ) ;
#line 21
static SM_FILE_T *collect_eoh(ENVELOPE *e , int numhdrs , int hdrslen ) ;
#line 46 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c"
static SM_FILE_T *collect_eoh(ENVELOPE *e , int numhdrs , int hdrslen ) 
{ 
  char hnum[16] ;
  char hsize[16] ;
  SM_FILE_T *tmp ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 56
  sm_snprintf(hnum, (size_t )sizeof(hnum), "%d", numhdrs);
#line 57
  sm_snprintf(hsize, (size_t )sizeof(hsize), "%d", hdrslen);
  }
#line 58
  if ((int )tTdvect[30] >= 10) {
    {
#line 59
    sm_dprintf((char *)"collect: rscheck(\"check_eoh\", \"%s $| %s\")\n", hnum, hsize);
    }
  }
  {
#line 61
  rscheck((char *)"check_eoh", hnum, hsize, e, 6, 3, (char *)((void *)0), e->e_id);
#line 69
  collect_doheader(e);
#line 70
  tmp = collect_dfopen(e);
  }
#line 70
  return (tmp);
}
}
#line 91 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c"
static void collect_doheader(ENVELOPE *e ) 
{ 
  ADDRESS *q ;
  char *tmp ;
  register ADDRESS *q___0 ;
  char *hdr ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 100
  eatheader(e, 1, 0);
  }
#line 102
  if (GrabTo) {
#line 102
    if ((unsigned long )e->e_sendqueue == (unsigned long )((void *)0)) {
      {
#line 103
      usrerr("No recipient addresses found in header");
      }
    }
  }
#line 109
  if (RrtImpliesDsn) {
    {
#line 109
    tmp = hvalue((char *)"return-receipt-to", e->e_header);
    }
#line 109
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 113
      q = e->e_sendqueue;
      {
#line 113
      while (1) {
        while_continue: /* CIL Label */ ;
#line 113
        if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 113
          goto while_break;
        }
#line 114
        if (! ((q->q_flags & 512UL) != 0UL)) {
#line 115
          q->q_flags |= 576UL;
        }
#line 113
        q = q->q_next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 122
  tmp___1 = hvalue((char *)"to", e->e_header);
  }
#line 122
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 127
    e->e_flags |= 64UL;
  } else {
    {
#line 122
    tmp___2 = hvalue((char *)"cc", e->e_header);
    }
#line 122
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 127
      e->e_flags |= 64UL;
    } else {
      {
#line 122
      tmp___3 = hvalue((char *)"apparently-to", e->e_header);
      }
#line 122
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 127
        e->e_flags |= 64UL;
      } else {
        {
#line 129
        tmp___0 = hvalue((char *)"bcc", e->e_header);
        }
#line 129
        if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 133
          hdr = (char *)((void *)0);
          {
#line 138
          if (NoRecipientAction == 2) {
#line 138
            goto case_2;
          }
#line 142
          if (NoRecipientAction == 1) {
#line 142
            goto case_1;
          }
#line 146
          if (NoRecipientAction == 3) {
#line 146
            goto case_3;
          }
#line 150
          if (NoRecipientAction == 4) {
#line 150
            goto case_4;
          }
#line 136
          goto switch_break;
          case_2: /* CIL Label */ 
#line 139
          hdr = (char *)"Apparently-To";
#line 140
          goto switch_break;
          case_1: /* CIL Label */ 
#line 143
          hdr = (char *)"To";
#line 144
          goto switch_break;
          case_3: /* CIL Label */ 
          {
#line 147
          addheader((char *)"Bcc", (char *)" ", 0, e);
          }
#line 148
          goto switch_break;
          case_4: /* CIL Label */ 
          {
#line 151
          addheader((char *)"To", (char *)"undisclosed-recipients:;", 0, e);
          }
#line 152
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 155
          if ((unsigned long )hdr != (unsigned long )((void *)0)) {
#line 157
            q___0 = e->e_sendqueue;
            {
#line 157
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 157
              if (! ((unsigned long )q___0 != (unsigned long )((void *)0))) {
#line 157
                goto while_break___0;
              }
#line 159
              if ((unsigned long )q___0->q_alias != (unsigned long )((void *)0)) {
#line 160
                goto __Cont;
              }
#line 161
              if ((int )tTdvect[30] >= 3) {
                {
#line 162
                sm_dprintf((char *)"Adding %s: %s\n", hdr, q___0->q_paddr);
                }
              }
              {
#line 164
              addheader(hdr, q___0->q_paddr, 0, e);
              }
              __Cont: /* CIL Label */ 
#line 157
              q___0 = q___0->q_next;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 168
  return;
}
}
#line 193 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c"
static SM_FILE_T *collect_dfopen(ENVELOPE *e ) 
{ 
  mode_t oldumask ;
  int dfd ;
  struct stat stbuf ;
  SM_FILE_T *df ;
  char *dfname ;
  bool tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;

  {
  {
#line 197
  oldumask = (mode_t )0;
#line 203
  tmp = setnewqueue(e);
  }
#line 203
  if (! tmp) {
#line 204
    return ((SM_FILE_T *)((void *)0));
  }
  {
#line 206
  dfname = queuename(e, 'd');
  }
#line 207
  if ((QueueFileMode & (128 >> 3)) != 0) {
    {
#line 208
    oldumask = umask((__mode_t )2);
    }
  }
  {
#line 209
  df = bfopen(dfname, (mode_t )QueueFileMode, DataFileBufferSize, 8192L);
  }
#line 211
  if ((QueueFileMode & (128 >> 3)) != 0) {
    {
#line 212
    umask(oldumask);
    }
  }
#line 213
  if ((unsigned long )df == (unsigned long )((void *)0)) {
    {
#line 215
    syserr("@Cannot create %s", dfname);
#line 216
    e->e_flags |= 4UL;
#line 217
    flush_errors(1);
#line 218
    finis(0, 1, (int volatile   )ExitStat);
    }
  }
  {
#line 221
  dfd = sm_io_getinfo(df, 3, (void *)0);
  }
#line 222
  if (dfd < 0) {
#line 223
    e->e_dfino = (ino_t )-1;
  } else {
    {
#line 222
    tmp___0 = fstat(dfd, & stbuf);
    }
#line 222
    if (tmp___0 < 0) {
#line 223
      e->e_dfino = (ino_t )-1;
    } else {
#line 226
      e->e_dfdev = stbuf.st_dev;
#line 227
      e->e_dfino = stbuf.st_ino;
    }
  }
#line 229
  e->e_flags |= 2097152UL;
#line 230
  return (df);
}
}
#line 278 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c"
void collect(SM_FILE_T *fp , bool smtpmode , HDR **hdrp , ENVELOPE *e , bool rsetsize ) 
{ 
  register SM_FILE_T *df ;
  bool ignrdot ;
  int dbto ;
  register char *bp___3 ;
  int c ;
  bool inputerr ;
  bool headeronly ;
  char *buf___16 ;
  int buflen___1 ;
  int istate ;
  int mstate ;
  int hdrslen ;
  int numhdrs ;
  int afd ;
  unsigned char *pbp ;
  unsigned char peekbuf[8] ;
  char bufbuf[2048] ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  unsigned char *tmp___8 ;
  int tmp___9 ;
  char *obuf ;
  char const   *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  bool tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned long tmp___23 ;
  char *tmp___24 ;
  char const   *errmsg ;
  int *tmp___25 ;
  int tmp___26 ;
  int save_errno ;
  int *tmp___27 ;
  char *dfile ;
  struct stat st ;
  int dfd ;
  int tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  int tmp___35 ;
  char *host ;
  char *problem ;
  ADDRESS *q ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  char *dfname ;
  char *tmp___40 ;
  SM_FILE_T *tmp___41 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;

  {
#line 304
  df = (SM_FILE_T *)((void *)0);
#line 305
  if (smtpmode) {
#line 305
    ignrdot = 0;
  } else {
#line 305
    ignrdot = IgnrDot;
  }
#line 308
  if (smtpmode) {
#line 308
    dbto = (int )TimeOuts.to_datablock * 1000;
  } else {
#line 308
    dbto = -1;
  }
  {
#line 310
  sm_io_setinfo(fp, 7, (void *)(& dbto));
#line 311
  c = -1;
#line 312
  inputerr = 0;
#line 313
  headeronly = (unsigned long )hdrp != (unsigned long )((void *)0);
#line 314
  hdrslen = 0;
#line 315
  numhdrs = 0;
#line 316
  HasEightBits = 0;
#line 317
  bp___3 = bufbuf;
#line 317
  buf___16 = bp___3;
#line 318
  buflen___1 = (int )sizeof(bufbuf);
#line 319
  pbp = peekbuf;
#line 320
  istate = 1;
  }
#line 321
  if (SaveFrom) {
#line 321
    mstate = 1;
  } else {
#line 321
    mstate = 0;
  }
#line 327
  if (smtpmode) {
    {
#line 328
    message("354 Enter mail, end with \".\" on a line by itself");
    }
  }
#line 331
  if ((int )tTdvect[83] >= 101) {
    {
#line 332
    sleep(319U);
    }
  }
#line 334
  if ((int )tTdvect[30] >= 2) {
    {
#line 335
    sm_dprintf((char *)"collect\n");
    }
  }
#line 346
  if (rsetsize) {
#line 347
    e->e_msgsize = 0L;
  }
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if ((int )tTdvect[30] >= 35) {
      {
#line 351
      sm_dprintf((char *)"top, istate=%d, mstate=%d\n", istate, mstate);
      }
    }
    {
#line 353
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 355
      if ((unsigned long )pbp > (unsigned long )(peekbuf)) {
#line 356
        pbp --;
#line 356
        c = (int )*pbp;
      } else {
        {
#line 359
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 359
          if (! ((fp->f_flags & 128L) != 0L)) {
#line 359
            if (! (! ((fp->f_flags & 256L) != 0L))) {
#line 359
              goto while_break___1;
            }
          } else {
#line 359
            goto while_break___1;
          }
          {
#line 361
          tmp = __errno_location();
#line 361
          *tmp = 0;
#line 362
          c = sm_io_getc(fp, -2);
          }
#line 363
          if (c == -1) {
            {
#line 363
            tmp___0 = __errno_location();
            }
#line 363
            if (*tmp___0 == 4) {
#line 366
              fp->f_flags &= -385L;
#line 367
              goto while_continue___1;
            }
          }
#line 371
          if (c == -1) {
            {
#line 371
            tmp___2 = __errno_location();
            }
#line 371
            if (*tmp___2 == 11) {
#line 371
              if (smtpmode) {
                {
#line 382
                e->e_message = (char *)((void *)0);
#line 383
                tmp___1 = __errno_location();
#line 383
                *tmp___1 = 0;
#line 384
                inputerr = 1;
                }
#line 385
                goto readabort;
              }
            }
          }
#line 387
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 389
        if ((unsigned long )TrafficLogFile != (unsigned long )((void *)0)) {
#line 389
          if (! headeronly) {
#line 391
            if (istate == 1) {
              {
#line 392
              sm_io_fprintf(TrafficLogFile, -2, "%05d <<< ", CurrentPid);
              }
            }
#line 396
            if (c == -1) {
              {
#line 397
              sm_io_fprintf(TrafficLogFile, -2, "[EOF]\n");
              }
            } else {
              {
#line 401
              sm_io_putc(TrafficLogFile, -2, c);
              }
            }
          }
        }
#line 405
        if (c == -1) {
#line 406
          goto readerr;
        }
#line 407
        if (SevenBitInput) {
#line 408
          c &= 127;
        } else {
#line 410
          HasEightBits |= (c & 128) != 0;
        }
      }
#line 412
      if ((int )tTdvect[30] >= 94) {
        {
#line 413
        sm_dprintf((char *)"istate=%d, c=%c (0x%x)\n", istate, (int )((char )c), c);
        }
      }
      {
#line 417
      if (istate == 1) {
#line 417
        goto case_1;
      }
#line 425
      if (istate == 2) {
#line 425
        goto case_2;
      }
#line 449
      if (istate == 3) {
#line 449
        goto case_3;
      }
#line 472
      if (istate == 4) {
#line 472
        goto case_4;
      }
#line 415
      goto switch_break;
      case_1: /* CIL Label */ 
#line 418
      if (c == 46) {
#line 420
        istate = 2;
#line 421
        goto __Cont;
      }
#line 423
      goto switch_break;
      case_2: /* CIL Label */ 
#line 426
      if (c == 10) {
#line 426
        if (! ignrdot) {
#line 426
          if (! ((e->e_flags & 262144UL) != 0UL)) {
#line 428
            goto readerr;
          } else {
#line 426
            goto _L___2;
          }
        } else {
#line 426
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 429
      if (c == 13) {
#line 429
        if (! ((e->e_flags & 524288UL) != 0UL)) {
#line 432
          istate = 3;
#line 433
          goto __Cont;
        } else {
#line 429
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 435
      if (ignrdot) {
#line 435
        goto _L;
      } else
#line 435
      if (c != 46) {
#line 435
        if ((int )OpMode != 115) {
#line 435
          if ((int )OpMode != 100) {
#line 435
            if ((int )OpMode != 97) {
              _L: /* CIL Label */ 
#line 442
              if ((unsigned long )pbp < (unsigned long )(peekbuf + sizeof(peekbuf))) {
#line 442
                tmp___3 = 1;
              } else {
                {
#line 442
                sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c",
                            443, "SM_ASSERT(pbp < peekbuf + sizeof(peekbuf)) failed");
#line 442
                tmp___3 = 0;
                }
              }
#line 444
              tmp___4 = pbp;
#line 444
              pbp ++;
#line 444
              *tmp___4 = (unsigned char )c;
#line 445
              c = '.';
            }
          }
        }
      }
#line 447
      goto switch_break;
      case_3: /* CIL Label */ 
#line 450
      if (c == 10) {
#line 450
        if (! ignrdot) {
#line 451
          goto readerr;
        } else {
#line 450
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 455
        if ((unsigned long )pbp < (unsigned long )(peekbuf + sizeof(peekbuf))) {
#line 455
          tmp___5 = 1;
        } else {
          {
#line 455
          sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c",
                      456, "SM_ASSERT(pbp < peekbuf + sizeof(peekbuf)) failed");
#line 455
          tmp___5 = 0;
          }
        }
#line 457
        tmp___6 = pbp;
#line 457
        pbp ++;
#line 457
        *tmp___6 = (unsigned char )c;
#line 458
        if ((int )OpMode != 115) {
#line 458
          if ((int )OpMode != 100) {
#line 458
            if ((int )OpMode != 97) {
#line 462
              if ((unsigned long )pbp < (unsigned long )(peekbuf + sizeof(peekbuf))) {
#line 462
                tmp___7 = 1;
              } else {
                {
#line 462
                sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c",
                            463, "SM_ASSERT(pbp < peekbuf + sizeof(peekbuf)) failed");
#line 462
                tmp___7 = 0;
                }
              }
#line 464
              tmp___8 = pbp;
#line 464
              pbp ++;
#line 464
              *tmp___8 = (unsigned char )'\r';
#line 465
              c = '.';
            } else {
#line 468
              c = '\r';
            }
          } else {
#line 468
            c = '\r';
          }
        } else {
#line 468
          c = '\r';
        }
      }
#line 470
      goto switch_break;
      case_4: /* CIL Label */ 
#line 473
      if (c == 10) {
#line 474
        istate = 1;
      } else {
        {
#line 477
        sm_io_ungetc(fp, -2, c);
#line 479
        c = '\r';
#line 480
        istate = 0;
        }
      }
#line 482
      goto bufferchar;
      switch_break: /* CIL Label */ ;
      }
#line 485
      if (c == 13) {
#line 485
        if (! ((e->e_flags & 524288UL) != 0UL)) {
#line 487
          istate = 4;
#line 488
          goto __Cont;
        } else {
#line 485
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 490
      if (c == 10) {
#line 490
        if (! ((e->e_flags & 262144UL) != 0UL)) {
#line 492
          istate = 1;
        } else {
#line 494
          istate = 0;
        }
      } else {
#line 494
        istate = 0;
      }
      bufferchar: 
#line 497
      if (! headeronly) {
#line 500
        if (e->e_msgsize >= 0L) {
#line 502
          (e->e_msgsize) ++;
#line 503
          if (MaxMessageSize > 0L) {
#line 503
            if (! ((e->e_flags & 33554432UL) != 0UL)) {
#line 503
              if (e->e_msgsize > MaxMessageSize) {
#line 506
                e->e_flags |= 33554432UL;
              }
            }
          }
        }
      }
      {
#line 511
      if (mstate == 2) {
#line 511
        goto case_2___0;
      }
#line 519
      if (mstate == 3) {
#line 519
        goto case_3___0;
      }
#line 509
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 513
      if (! ((e->e_flags & 33554432UL) != 0UL)) {
        {
#line 514
        sm_io_putc(df, -2, c);
        }
      }
      case_3___0: /* CIL Label */ 
#line 520
      goto __Cont;
      switch_break___0: /* CIL Label */ ;
      }
#line 523
      if (mstate == 0) {
#line 523
        tmp___9 = 1;
      } else
#line 523
      if (mstate == 1) {
#line 523
        tmp___9 = 1;
      } else {
        {
#line 523
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c",
                    523, "SM_ASSERT(mstate == MS_UFROM || mstate == MS_HEADER) failed");
#line 523
        tmp___9 = 0;
        }
      }
#line 526
      if ((unsigned long )bp___3 >= (unsigned long )(buf___16 + (buflen___1 - 2))) {
#line 531
        obuf = buf___16;
#line 532
        if (buflen___1 < 1024) {
#line 533
          buflen___1 *= 2;
        } else {
#line 535
          buflen___1 += 1024;
        }
#line 536
        if (buflen___1 <= 0) {
#line 538
          if ((unsigned long )CurHostName == (unsigned long )((void *)0)) {
#line 538
            tmp___10 = "local";
          } else {
#line 538
            tmp___10 = (char const   *)CurHostName;
          }
          {
#line 538
          sm_syslog(5, (char const   *)e->e_id, "header overflow from %s during message collect",
                    tmp___10);
#line 541
          tmp___11 = __errno_location();
#line 541
          *tmp___11 = 0;
#line 542
          e->e_flags |= 8UL;
#line 543
          e->e_status = (char *)"5.6.0";
#line 544
          usrerrenh(e->e_status, "552 Headers too large");
          }
#line 546
          goto discard;
        }
        {
#line 548
        buf___16 = xalloc_tagged(buflen___1, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c",
                                 548);
#line 549
        memmove((void *)buf___16, (void const   *)obuf, (size_t )(bp___3 - obuf));
#line 550
        bp___3 = buf___16 + (bp___3 - obuf);
        }
#line 551
        if ((unsigned long )obuf != (unsigned long )(bufbuf)) {
          {
#line 552
          sm_free_tagged((void *)obuf, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c",
                         552);
          }
        }
      }
#line 565
      if (c >= 128) {
#line 565
        if (! (c <= 159)) {
#line 565
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 573
      if (c != 0) {
#line 575
        tmp___12 = bp___3;
#line 575
        bp___3 ++;
#line 575
        *tmp___12 = (char )c;
#line 576
        hdrslen ++;
#line 577
        if (! headeronly) {
#line 577
          if (MaxHeadersLength > 0) {
#line 577
            if (hdrslen > MaxHeadersLength) {
#line 581
              if ((unsigned long )CurHostName == (unsigned long )((void *)0)) {
#line 581
                tmp___13 = "local";
              } else {
#line 581
                tmp___13 = (char const   *)CurHostName;
              }
              {
#line 581
              sm_syslog(5, (char const   *)e->e_id, "headers too large (%d max) from %s during message collect",
                        MaxHeadersLength, tmp___13);
#line 585
              tmp___14 = __errno_location();
#line 585
              *tmp___14 = 0;
#line 586
              e->e_flags |= 8UL;
#line 587
              e->e_status = (char *)"5.6.0";
#line 588
              usrerrenh(e->e_status, "552 Headers too large (%d max)", MaxHeadersLength);
              }
              discard: 
#line 592
              mstate = 3;
            }
          }
        }
      }
#line 595
      if (istate == 1) {
#line 596
        goto while_break___0;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 598
    *bp___3 = (char )'\000';
    nextstate: 
#line 601
    if ((int )tTdvect[30] >= 35) {
      {
#line 602
      sm_dprintf((char *)"nextstate, istate=%d, mstate=%d, line = \"%s\"\n", istate,
                 mstate, buf___16);
      }
    }
    {
#line 606
    if (mstate == 0) {
#line 606
      goto case_0;
    }
#line 618
    if (mstate == 1) {
#line 618
      goto case_1___0;
    }
#line 678
    if (mstate == 2) {
#line 678
      goto case_2___1;
    }
#line 604
    goto switch_break___1;
    case_0: /* CIL Label */ 
    {
#line 607
    mstate = 1;
#line 609
    tmp___15 = strncmp((char const   *)buf___16, "From ", (size_t )5);
    }
#line 609
    if (tmp___15 == 0) {
      {
#line 611
      bp___3 = buf___16;
#line 612
      eatfrom((char */* volatile  */)buf___16, e);
      }
#line 613
      goto __Cont___0;
    }
    case_1___0: /* CIL Label */ 
    {
#line 619
    tmp___16 = isheader(buf___16);
    }
#line 619
    if (! tmp___16) {
#line 621
      mstate = 2;
#line 622
      goto nextstate;
    }
    {
#line 626
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 628
      fp->f_flags &= -385L;
#line 629
      tmp___17 = __errno_location();
#line 629
      *tmp___17 = 0;
#line 630
      c = sm_io_getc(fp, -2);
      }
#line 633
      if (c == -1) {
        {
#line 633
        tmp___19 = __errno_location();
        }
#line 633
        if (*tmp___19 == 11) {
#line 633
          if (smtpmode) {
            {
#line 644
            e->e_message = (char *)((void *)0);
#line 645
            tmp___18 = __errno_location();
#line 645
            *tmp___18 = 0;
#line 646
            inputerr = 1;
            }
#line 647
            goto readabort;
          }
        }
      }
#line 626
      if (c == -1) {
        {
#line 626
        tmp___20 = __errno_location();
        }
#line 626
        if (! (*tmp___20 == 4)) {
#line 626
          goto while_break___2;
        }
      } else {
#line 626
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 650
    if (c != -1) {
      {
#line 651
      sm_io_ungetc(fp, -2, c);
      }
    }
#line 652
    if (c == 32) {
#line 655
      goto __Cont___0;
    } else
#line 652
    if (c == 9) {
#line 655
      goto __Cont___0;
    }
#line 658
    if ((unsigned long )bp___3 > (unsigned long )buf___16) {
#line 658
      tmp___21 = 1;
    } else {
      {
#line 658
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c",
                  658, "SM_ASSERT(bp > buf) failed");
#line 658
      tmp___21 = 0;
      }
    }
#line 661
    if ((int )*(bp___3 - 1) != 10) {
#line 661
      tmp___22 = 1;
    } else
#line 661
    if ((unsigned long )bp___3 > (unsigned long )(buf___16 + 1)) {
#line 661
      tmp___22 = 1;
    } else {
      {
#line 661
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c",
                  661, "SM_ASSERT(*(bp - 1) != \'\\n\' || bp > buf + 1) failed");
#line 661
      tmp___22 = 0;
      }
    }
#line 664
    bp___3 --;
#line 664
    if ((int )*bp___3 != 10) {
#line 665
      bp___3 ++;
    } else {
#line 664
      bp___3 --;
#line 664
      if ((int )*bp___3 != 13) {
#line 665
        bp___3 ++;
      }
    }
    {
#line 666
    *bp___3 = (char )'\000';
#line 668
    tmp___23 = chompheader(buf___16, 6, hdrp, e);
    }
#line 668
    if ((tmp___23 & 1UL) != 0UL) {
#line 672
      mstate = 2;
#line 673
      goto nextstate;
    }
#line 675
    numhdrs ++;
#line 676
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
#line 679
    if ((int )tTdvect[30] >= 1) {
      {
#line 680
      sm_dprintf((char *)"EOH\n");
      }
    }
#line 682
    if (headeronly) {
#line 683
      goto readerr;
    }
    {
#line 685
    df = collect_eoh(e, numhdrs, hdrslen);
    }
#line 686
    if ((unsigned long )df == (unsigned long )((void *)0)) {
#line 687
      e->e_flags |= 33554432UL;
    }
#line 689
    bp___3 = buf___16;
#line 692
    if (! ((e->e_flags & 524288UL) != 0UL)) {
#line 692
      if ((int )*(bp___3 + 0) == 13) {
#line 692
        if ((int )*(bp___3 + 1) == 10) {
#line 697
          goto switch_break___1;
        } else {
#line 692
          goto _L___7;
        }
      } else {
#line 692
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 692
    if (! ((e->e_flags & 262144UL) != 0UL)) {
#line 692
      if ((int )*(bp___3 + 0) == 10) {
#line 697
        goto switch_break___1;
      }
    }
#line 701
    if (! ((e->e_flags & 33554432UL) != 0UL)) {
      {
#line 703
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 703
        if (! ((int )*bp___3 != 0)) {
#line 703
          goto while_break___3;
        }
        {
#line 704
        tmp___24 = bp___3;
#line 704
        bp___3 ++;
#line 704
        sm_io_putc(df, -2, (int )*tmp___24);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 707
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 709
    bp___3 = buf___16;
    __Cont___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  readerr: 
#line 713
  if ((fp->f_flags & 128L) != 0L) {
#line 713
    if (smtpmode) {
#line 713
      goto _L___8;
    } else {
#line 713
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 713
  if ((fp->f_flags & 256L) != 0L) {
    _L___8: /* CIL Label */ 
#line 717
    if ((fp->f_flags & 128L) != 0L) {
#line 718
      errmsg = "unexpected close";
    } else {
      {
#line 720
      tmp___25 = __errno_location();
#line 720
      errmsg = sm_errstring(*tmp___25);
      }
    }
#line 721
    if ((int )tTdvect[30] >= 1) {
      {
#line 722
      sm_dprintf((char *)"collect: premature EOM: %s\n", errmsg);
      }
    }
#line 723
    if (LogLevel > 1) {
      {
#line 724
      sm_syslog(4, (char const   *)e->e_id, "collect: premature EOM: %s", errmsg);
      }
    }
#line 726
    inputerr = 1;
  }
#line 729
  if (headeronly) {
#line 730
    return;
  }
#line 732
  if (mstate != 2) {
#line 735
    if ((unsigned long )df == (unsigned long )((void *)0)) {
#line 735
      tmp___26 = 1;
    } else {
      {
#line 735
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c",
                  735, "SM_ASSERT(df == NULL) failed");
#line 735
      tmp___26 = 0;
      }
    }
    {
#line 736
    df = collect_eoh(e, numhdrs, hdrslen);
    }
  }
#line 739
  if (! ((unsigned long )df == (unsigned long )((void *)0))) {
    {
#line 744
    tmp___35 = sm_io_flush(df, -2);
    }
#line 744
    if (tmp___35 != 0) {
      {
#line 746
      dferror((SM_FILE_T */* volatile  */)df, (char *)"sm_io_flush||sm_io_error",
              e);
#line 747
      flush_errors(1);
#line 748
      finis(1, 1, (int volatile   )ExitStat);
      }
    } else
#line 744
    if ((df->f_flags & 256L) != 0L) {
      {
#line 746
      dferror((SM_FILE_T */* volatile  */)df, (char *)"sm_io_flush||sm_io_error",
              e);
#line 747
      flush_errors(1);
#line 748
      finis(1, 1, (int volatile   )ExitStat);
      }
    } else
#line 751
    if (! (SuperSafe == 0)) {
#line 751
      if (! (SuperSafe == 1)) {
#line 751
        if (SuperSafe == 3) {
#line 751
          if (! smtpmode) {
#line 751
            goto _L___11;
          }
        } else {
          _L___11: /* CIL Label */ 
          {
#line 759
          tmp___33 = sm_io_setinfo(df, 1001, (void *)0);
          }
#line 759
          if (tmp___33 < 0) {
            {
#line 759
            tmp___34 = __errno_location();
            }
#line 759
            if (*tmp___34 != 22) {
              {
#line 761
              tmp___27 = __errno_location();
#line 761
              save_errno = *tmp___27;
              }
#line 763
              if (save_errno == 17) {
                {
#line 769
                dfile = queuename(e, 'd');
#line 770
                tmp___28 = stat((char const   */* __restrict  */)dfile, (struct stat */* __restrict  */)(& st));
                }
#line 770
                if (tmp___28 < 0) {
#line 771
                  st.st_size = (__off_t )-1;
                }
                {
#line 772
                tmp___29 = __errno_location();
#line 772
                *tmp___29 = 17;
#line 773
                syserr("@collect: bfcommit(%s): already on disk, size=%ld", dfile,
                       st.st_size);
#line 775
                dfd = sm_io_getinfo(df, 3, (void *)0);
                }
#line 776
                if (dfd >= 0) {
                  {
#line 777
                  dumpfd(dfd, 1, 1);
                  }
                }
              }
              {
#line 779
              tmp___30 = __errno_location();
#line 779
              *tmp___30 = save_errno;
#line 780
              dferror((SM_FILE_T */* volatile  */)df, (char *)"bfcommit", e);
#line 781
              flush_errors(1);
#line 782
              finis(save_errno != 17, 1, (int volatile   )ExitStat);
              }
            } else {
#line 759
              goto _L___10;
            }
          } else {
            _L___10: /* CIL Label */ 
            {
#line 784
            afd = sm_io_getinfo(df, 3, (void *)0);
            }
#line 784
            if (afd < 0) {
              {
#line 786
              dferror((SM_FILE_T */* volatile  */)df, (char *)"sm_io_getinfo", e);
#line 787
              flush_errors(1);
#line 788
              finis(1, 1, (int volatile   )ExitStat);
              }
            } else {
              {
#line 791
              tmp___32 = fsync(afd);
              }
#line 791
              if (tmp___32 < 0) {
                {
#line 793
                dferror((SM_FILE_T */* volatile  */)df, (char *)"fsync", e);
#line 794
                flush_errors(1);
#line 795
                finis(1, 1, (int volatile   )ExitStat);
                }
              } else {
                {
#line 798
                tmp___31 = sm_io_close(df, -2);
                }
#line 798
                if (tmp___31 < 0) {
                  {
#line 800
                  dferror((SM_FILE_T */* volatile  */)df, (char *)"sm_io_close", e);
#line 801
                  flush_errors(1);
#line 802
                  finis(1, 1, (int volatile   )ExitStat);
                  }
                } else {
                  {
#line 808
                  df = (SM_FILE_T *)((void *)0);
#line 811
                  upd_qs(e, 0, 1, (char *)"collect");
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  readabort: 
#line 816
  if (inputerr) {
#line 816
    if ((int )OpMode == 115) {
#line 816
      goto _L___12;
    } else
#line 816
    if ((int )OpMode == 100) {
      _L___12: /* CIL Label */ 
#line 822
      host = RealHostName;
#line 823
      if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 824
        host = (char *)"localhost";
      }
#line 826
      if ((fp->f_flags & 128L) != 0L) {
#line 827
        problem = (char *)"unexpected close";
      } else
#line 828
      if ((fp->f_flags & 256L) != 0L) {
#line 829
        problem = (char *)"I/O error";
      } else {
#line 831
        problem = (char *)"read timeout";
      }
#line 832
      if (LogLevel > 0) {
#line 832
        if ((fp->f_flags & 128L) != 0L) {
          {
#line 833
          tmp___36 = shortenstring((char const   *)e->e_from.q_paddr, (size_t )203);
#line 833
          sm_syslog(5, (char const   *)e->e_id, "collect: %s on connection from %.100s, sender=%s",
                    problem, host, tmp___36);
          }
        }
      }
#line 837
      if ((fp->f_flags & 128L) != 0L) {
        {
#line 838
        tmp___37 = shortenstring((char const   *)e->e_from.q_paddr, (size_t )203);
#line 838
        usrerr("421 4.4.1 collect: %s on connection from %s, from=%s", problem, host,
               tmp___37);
        }
      } else {
        {
#line 842
        tmp___38 = shortenstring((char const   *)e->e_from.q_paddr, (size_t )203);
#line 842
        syserr("421 4.4.1 collect: %s on connection from %s, from=%s", problem, host,
               tmp___38);
        }
      }
      {
#line 845
      flush_errors(1);
#line 848
      e->e_to = (char *)((void *)0);
#line 849
      e->e_flags &= 0xffffffffffffffdfUL;
#line 850
      e->e_flags |= 8UL;
#line 853
      q = e->e_sendqueue;
      }
      {
#line 853
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 853
        if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 853
          goto while_break___4;
        }
#line 855
        if ((int )q->q_state >= 6) {
#line 856
          goto __Cont___1;
        }
#line 857
        q->q_state = (short)15;
        __Cont___1: /* CIL Label */ 
#line 853
        q = q->q_next;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 860
      finis(1, 1, (int volatile   )ExitStat);
      }
    }
  }
#line 865
  if ((e->e_flags & 32768UL) != 0UL) {
#line 865
    if (LogLevel > 4) {
      {
#line 867
      logsender(e, e->e_msgid);
#line 868
      e->e_flags &= 0xffffffffffff7fffUL;
      }
    }
  }
#line 872
  if ((e->e_flags & 33554432UL) != 0UL) {
#line 874
    e->e_flags |= 12UL;
#line 875
    if (! ((e->e_flags & 32UL) != 0UL)) {
      {
#line 877
      e->e_status = (char *)"5.2.3";
#line 878
      usrerrenh(e->e_status, "552 Message exceeds maximum fixed size (%ld)", MaxMessageSize);
      }
#line 881
      if (LogLevel > 6) {
        {
#line 882
        sm_syslog(5, (char const   *)e->e_id, "message size (%ld) exceeds maximum (%ld)",
                  e->e_msgsize, MaxMessageSize);
        }
      }
    }
  }
#line 889
  if (HasEightBits) {
#line 891
    e->e_flags |= 131072UL;
#line 892
    if (! ((MimeMode & 6) != 0)) {
#line 892
      if (! ((e->e_flags & 4194304UL) != 0UL)) {
        {
#line 895
        e->e_status = (char *)"5.6.1";
#line 896
        usrerrenh(e->e_status, "554 Eight bit data not allowed");
        }
      }
    }
  } else
#line 902
  if ((unsigned long )e->e_bodytype != (unsigned long )((void *)0)) {
    {
#line 902
    tmp___39 = sm_strcasecmp((char const   *)e->e_bodytype, "8BITMIME");
    }
#line 902
    if (tmp___39 == 0) {
#line 904
      e->e_bodytype = (char *)"7BIT";
    }
  }
#line 907
  if (SuperSafe == 2) {
#line 907
    if (! ((e->e_flags & 32UL) != 0UL)) {
      {
#line 909
      tmp___40 = queuename(e, 'd');
#line 909
      dfname = tmp___40;
#line 910
      tmp___41 = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)dfname,
                            2, (void const   *)((void *)0));
#line 910
      e->e_dfp = tmp___41;
      }
#line 910
      if ((unsigned long )tmp___41 == (unsigned long )((void *)0)) {
        {
#line 914
        syserr("@Cannot reopen %s", dfname);
#line 915
        finis(1, 1, (int volatile   )ExitStat);
        }
      }
    } else {
#line 920
      e->e_dfp = df;
    }
  } else {
#line 920
    e->e_dfp = df;
  }
#line 923
  if ((int )OpMode != 118) {
    {
#line 931
    e->e_msgpriority = (e->e_msgsize - (long )e->e_class * WkClassFact) + (long )e->e_nrcpts * WkRecipFact;
#line 934
    markstats(e, (ADDRESS *)((void *)0), 'n');
    }
  }
#line 936
  return;
}
}
#line 959 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c"
void dferror(SM_FILE_T * volatile  df , char *msg , ENVELOPE *e ) 
{ 
  char *dfname ;
  struct stat st ;
  long avail ;
  long bsize ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  __gid_t tmp___2 ;
  __uid_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  SM_FILE_T *tmp___7 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 967
  dfname = queuename(e, 'd');
  }
#line 968
  if (ExitStat == 0) {
#line 968
    ExitStat = 74;
  } else
#line 968
  if (ExitStat == 75) {
#line 968
    ExitStat = 74;
  }
  {
#line 969
  tmp___4 = __errno_location();
  }
#line 969
  if (*tmp___4 == 28) {
    {
#line 979
    e->e_flags |= 4UL;
#line 981
    tmp = sm_io_getinfo((SM_FILE_T *)df, 3, (void *)0);
#line 981
    tmp___0 = fstat(tmp, & st);
    }
#line 981
    if (tmp___0 < 0) {
#line 988
      st.st_size = (__off_t )0;
    }
    {
#line 989
    sm_io_reopen((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)dfname,
                 3, (void const   *)((void *)0), (SM_FILE_T *)df);
    }
#line 991
    if (st.st_size <= 0L) {
      {
#line 992
      sm_io_fprintf((SM_FILE_T *)df, -2, "\n*** Mail could not be accepted");
      }
    } else {
      {
#line 995
      sm_io_fprintf((SM_FILE_T *)df, -2, "\n*** Mail of at least %llu bytes could not be accepted\n",
                    (ULONGLONG_T )st.st_size);
      }
    }
    {
#line 998
    sm_io_fprintf((SM_FILE_T *)df, -2, "*** at %s due to lack of disk space for temp file.\n",
                  MyHostName);
#line 1001
    tmp___1 = qid_printqueue(e->e_qgrp, e->e_qdir);
#line 1001
    avail = freediskspace(tmp___1, & bsize);
    }
#line 1003
    if (avail > 0L) {
#line 1005
      if (bsize > 1024L) {
#line 1006
        avail *= bsize / 1024L;
      } else
#line 1007
      if (bsize < 1024L) {
#line 1008
        avail /= 1024L / bsize;
      }
      {
#line 1009
      sm_io_fprintf((SM_FILE_T *)df, -2, "*** Currently, %ld kilobytes are available for mail temp files.\n",
                    avail);
      }
    }
    {
#line 1018
    syserr("421 4.3.1 Out of disk space for temp file");
    }
  } else {
    {
#line 1022
    tmp___2 = getegid();
#line 1022
    tmp___3 = geteuid();
#line 1022
    syserr("421 4.3.0 collect: Cannot write %s (%s, uid=%d, gid=%d)", dfname, msg,
           (int )tmp___3, (int )tmp___2);
    }
  }
  {
#line 1024
  tmp___7 = sm_io_reopen((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)"/dev/null",
                         3, (void const   *)((void *)0), (SM_FILE_T *)df);
  }
#line 1024
  if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
    {
#line 1026
    tmp___5 = __errno_location();
#line 1026
    tmp___6 = sm_errstring(*tmp___5);
#line 1026
    sm_syslog(3, (char const   *)e->e_id, "dferror: sm_io_reopen(\"/dev/null\") failed: %s",
              tmp___6);
    }
  }
#line 1029
  return;
}
}
#line 1050 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c"
static char *DowList[8]  = 
#line 1050
  {      (char *)"Sun",      (char *)"Mon",      (char *)"Tue",      (char *)"Wed", 
        (char *)"Thu",      (char *)"Fri",      (char *)"Sat",      (char *)((void *)0)};
#line 1055 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c"
static char *MonthList[13]  = 
#line 1055
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec", 
        (char *)((void *)0)};
#line 1062 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c"
static void eatfrom(char * volatile  fm , ENVELOPE *e ) 
{ 
  register char *p ;
  register char **dt ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *q ;
  char buf___16[25] ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1070
  if ((int )tTdvect[30] >= 2) {
    {
#line 1071
    sm_dprintf((char *)"eatfrom(%s)\n", fm);
    }
  }
#line 1074
  p = (char *)fm;
  {
#line 1075
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1075
    if (! ((int )*p != 0)) {
#line 1075
      goto while_break;
    }
    {
#line 1078
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1078
      if ((int )*p != 0) {
#line 1078
        if (! ((int )*p != 32)) {
#line 1078
          goto while_break___0;
        }
      } else {
#line 1078
        goto while_break___0;
      }
#line 1079
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1080
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1080
      if (! ((int )*p == 32)) {
#line 1080
        goto while_break___1;
      }
#line 1081
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1082
    tmp = strlen((char const   *)p);
    }
#line 1082
    if (tmp < 17U) {
#line 1085
      return;
    }
#line 1087
    if (((int )*p & -128) == 0) {
      {
#line 1087
      tmp___0 = __ctype_b_loc();
      }
#line 1087
      if ((int const   )*(*tmp___0 + (int )*p) & 256) {
#line 1087
        if ((int )*(p + 3) != 32) {
#line 1089
          goto while_continue;
        } else
#line 1087
        if ((int )*(p + 13) != 58) {
#line 1089
          goto while_continue;
        } else
#line 1087
        if ((int )*(p + 16) != 58) {
#line 1089
          goto while_continue;
        }
      } else {
#line 1089
        goto while_continue;
      }
    } else {
#line 1089
      goto while_continue;
    }
#line 1092
    dt = DowList;
    {
#line 1092
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1092
      if (! ((unsigned long )*dt != (unsigned long )((void *)0))) {
#line 1092
        goto while_break___2;
      }
      {
#line 1093
      tmp___1 = strncmp((char const   *)*dt, (char const   *)p, (size_t )3);
      }
#line 1093
      if (tmp___1 == 0) {
#line 1094
        goto while_break___2;
      }
#line 1092
      dt ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1095
    if ((unsigned long )*dt == (unsigned long )((void *)0)) {
#line 1096
      goto while_continue;
    }
#line 1098
    dt = MonthList;
    {
#line 1098
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1098
      if (! ((unsigned long )*dt != (unsigned long )((void *)0))) {
#line 1098
        goto while_break___3;
      }
      {
#line 1100
      tmp___2 = strncmp((char const   *)*dt, (char const   *)(p + 4), (size_t )3);
      }
#line 1100
      if (tmp___2 == 0) {
#line 1101
        goto while_break___3;
      }
#line 1098
      dt ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1103
    if ((unsigned long )*dt != (unsigned long )((void *)0)) {
#line 1104
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1107
  if ((int )*p != 0) {
    {
#line 1112
    sm_strlcpy(buf___16, (char const   *)p, (ssize_t )sizeof(buf___16));
#line 1113
    q = arpadate(buf___16);
#line 1114
    macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, 'a', q, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/collect.c",
                     1114, SmHeapGroup);
    }
  }
#line 1116
  return;
}
}
#line 37 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
static ssize_t sm_bfread(SM_FILE_T *fp , char *buf___16 , size_t nbytes ) ;
#line 38
static ssize_t sm_bfwrite(SM_FILE_T *fp , char const   *buf___16 , size_t nbytes ) ;
#line 39
static off_t sm_bfseek(SM_FILE_T *fp , off_t offset , int whence ) ;
#line 40
static int sm_bfclose(SM_FILE_T *fp ) ;
#line 41
static int sm_bfcommit(SM_FILE_T *fp ) ;
#line 42
static int sm_bftruncate(SM_FILE_T *fp ) ;
#line 44
static int sm_bfopen(SM_FILE_T *fp , void const   *info , int flags , void const   *rpool ) ;
#line 45
static int sm_bfsetinfo(SM_FILE_T *fp , int what , void *valp ) ;
#line 46
static int sm_bfgetinfo(SM_FILE_T *fp , int what , void *valp ) ;
#line 97 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
static int sm_bfopen(SM_FILE_T *fp , void const   *info , int flags , void const   *rpool ) 
{ 
  char *filename ;
  mode_t fmode ;
  size_t bsize ;
  long sflags ;
  struct bf *bfp ;
  int l ;
  struct stat st ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 112
  filename = ((struct bf_info *)info)->bi_filename;
#line 113
  fmode = ((struct bf_info *)info)->bi_fmode;
#line 114
  bsize = ((struct bf_info *)info)->bi_bsize;
#line 115
  sflags = ((struct bf_info *)info)->bi_flags;
#line 118
  if ((int )*filename == 0) {
    {
#line 121
    tmp = __errno_location();
#line 121
    *tmp = 2;
    }
#line 122
    return (-1);
  }
  {
#line 124
  tmp___1 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
  }
#line 124
  if (tmp___1 == 0) {
    {
#line 127
    tmp___0 = __errno_location();
#line 127
    *tmp___0 = 17;
    }
#line 128
    return (-1);
  }
  {
#line 132
  tmp___2 = sm_malloc_tagged((size_t )sizeof(struct bf ), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c",
                             132, SmHeapGroup);
#line 132
  bfp = (struct bf *)tmp___2;
  }
#line 133
  if ((unsigned long )bfp == (unsigned long )((void *)0)) {
    {
#line 135
    tmp___3 = __errno_location();
#line 135
    *tmp___3 = 12;
    }
#line 136
    return (-1);
  }
#line 141
  if (bsize > 0U) {
    {
#line 143
    tmp___4 = sm_malloc_tagged(bsize, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c",
                               143, SmHeapGroup);
#line 143
    bfp->bf_buf = (char *)tmp___4;
    }
#line 144
    if ((unsigned long )bfp->bf_buf == (unsigned long )((void *)0)) {
      {
#line 146
      bfp->bf_bufsize = 0;
#line 147
      sm_free_tagged((void *)bfp, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c",
                     147);
#line 148
      tmp___5 = __errno_location();
#line 148
      *tmp___5 = 12;
      }
#line 149
      return (-1);
    }
  } else {
#line 153
    bfp->bf_buf = (char *)((void *)0);
  }
  {
#line 156
  bfp->bf_committed = 0;
#line 157
  bfp->bf_ondisk = 0;
#line 158
  bfp->bf_flags = sflags;
#line 159
  bfp->bf_bufsize = (int )bsize;
#line 160
  bfp->bf_buffilled = 0;
#line 161
  tmp___6 = strlen((char const   *)filename);
#line 161
  l = (int )(tmp___6 + 1U);
#line 162
  tmp___7 = sm_malloc_tagged((size_t )l, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c",
                             162, SmHeapGroup);
#line 162
  bfp->bf_filename = (char *)tmp___7;
  }
#line 163
  if ((unsigned long )bfp->bf_filename == (unsigned long )((void *)0)) {
#line 165
    if ((unsigned long )bfp->bf_buf != (unsigned long )((void *)0)) {
      {
#line 166
      sm_free_tagged((void *)bfp->bf_buf, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c",
                     166);
      }
    }
    {
#line 167
    sm_free_tagged((void *)bfp, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c",
                   167);
#line 168
    tmp___8 = __errno_location();
#line 168
    *tmp___8 = 12;
    }
#line 169
    return (-1);
  }
  {
#line 171
  sm_strlcpy(bfp->bf_filename, (char const   *)filename, l);
#line 172
  bfp->bf_filemode = fmode;
#line 173
  bfp->bf_offset = (off_t )0;
#line 174
  bfp->bf_size = 0;
#line 175
  bfp->bf_disk_fd = -1;
#line 176
  fp->f_cookie = (void *)bfp;
  }
#line 178
  if ((int )tTdvect[58] >= 8) {
    {
#line 179
    sm_dprintf((char *)"sm_bfopen(%s)\n", filename);
    }
  }
#line 181
  return (0);
}
}
#line 215 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
SM_FILE_T *bfopen(char *filename , mode_t fmode , size_t bsize , long flags ) 
{ 
  mode_t omask ;
  SM_FILE_T vector ;
  struct bf_info info ;
  SM_FILE_T *tmp ;
  char *__cil_tmp9 ;

  {
  {
#line 227
  vector.sm_magic = SmFileMagic;
#line 227
  vector.f_p = (unsigned char *)0;
#line 227
  vector.f_r = 0;
#line 227
  vector.f_w = 0;
#line 227
  vector.f_flags = 0L;
#line 227
  vector.f_file = (short)-1;
#line 227
  vector.f_bf.smb_base = (unsigned char *)0;
#line 227
  vector.f_bf.smb_size = 0;
#line 227
  vector.f_lbfsize = 0;
#line 227
  vector.f_cookie = (void *)0;
#line 227
  vector.f_ival = 0;
#line 227
  vector.f_close = & sm_bfclose;
#line 227
  vector.f_read = & sm_bfread;
#line 227
  vector.f_seek = & sm_bfseek;
#line 227
  vector.f_write = & sm_bfwrite;
#line 227
  vector.f_open = & sm_bfopen;
#line 227
  vector.f_setinfo = & sm_bfsetinfo;
#line 227
  vector.f_getinfo = & sm_bfgetinfo;
#line 227
  vector.f_timeout = -1;
#line 227
  vector.f_timeoutstate = 0;
#line 227
  vector.f_type = (char *)"SendmailBufferedFile";
#line 227
  vector.f_flushfp = (struct sm_file *)0;
#line 227
  vector.f_modefp = (struct sm_file *)0;
#line 227
  vector.f_ub.smb_base = (unsigned char *)0;
#line 227
  vector.f_ub.smb_size = 0;
#line 227
  vector.f_up = (unsigned char *)0;
#line 227
  vector.f_ur = 0;
#line 227
  vector.f_ubuf[0] = (unsigned char)0;
#line 227
  vector.f_ubuf[1] = (unsigned char)0;
#line 227
  vector.f_ubuf[2] = (unsigned char)0;
#line 227
  vector.f_nbuf[0] = (unsigned char)0;
#line 227
  vector.f_blksize = 0;
#line 227
  vector.f_lseekoff = 0L;
#line 227
  vector.f_dup_cnt = 0;
#line 238
  omask = umask((__mode_t )0);
#line 239
  fmode &= ~ omask;
#line 240
  umask(omask);
#line 245
  info.bi_filename = filename;
#line 246
  info.bi_fmode = fmode;
#line 247
  info.bi_bsize = bsize;
#line 248
  info.bi_flags = flags;
#line 250
  tmp = sm_io_open((SM_FILE_T const   *)(& vector), -2, (void const   *)(& info),
                   1, (void const   *)((void *)0));
  }
#line 250
  return (tmp);
}
}
#line 262 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
static int sm_bfgetinfo(SM_FILE_T *fp , int what , void *valp ) 
{ 
  struct bf *bfp ;

  {
#line 270
  bfp = (struct bf *)fp->f_cookie;
  {
#line 273
  if (what == 3) {
#line 273
    goto case_3;
  }
#line 275
  if (what == 8) {
#line 275
    goto case_8;
  }
#line 277
  goto switch_default;
  case_3: /* CIL Label */ 
#line 274
  return (bfp->bf_disk_fd);
  case_8: /* CIL Label */ 
#line 276
  return (bfp->bf_size);
  switch_default: /* CIL Label */ 
#line 278
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 298 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
static int sm_bfclose(SM_FILE_T *fp ) 
{ 
  struct bf *bfp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 305
  bfp = (struct bf *)fp->f_cookie;
#line 308
  if (bfp->bf_ondisk) {
#line 308
    if (! bfp->bf_committed) {
      {
#line 309
      unlink((char const   *)bfp->bf_filename);
      }
    }
  }
  {
#line 310
  sm_free_tagged((void *)bfp->bf_filename, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c",
                 310);
  }
#line 312
  if (bfp->bf_disk_fd != -1) {
    {
#line 313
    close(bfp->bf_disk_fd);
    }
  }
#line 316
  if (bfp->bf_bufsize > 0) {
    {
#line 317
    sm_free_tagged((void *)bfp->bf_buf, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c",
                   317);
    }
  }
  {
#line 320
  sm_free_tagged((void *)bfp, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c",
                 320);
  }
#line 321
  return (0);
}
}
#line 340 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
static ssize_t sm_bfread(SM_FILE_T *fp , char *buf___16 , size_t nbytes ) 
{ 
  struct bf *bfp ;
  ssize_t count ;
  int retval ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  __off_t tmp___3 ;
  char *__cil_tmp12 ;

  {
#line 347
  count = 0;
#line 351
  bfp = (struct bf *)fp->f_cookie;
#line 353
  if (bfp->bf_offset < (off_t )bfp->bf_buffilled) {
#line 356
    count = (ssize_t )nbytes;
#line 357
    if (bfp->bf_offset + (off_t )count > (off_t )bfp->bf_buffilled) {
#line 358
      count = (ssize_t )((off_t )bfp->bf_buffilled - bfp->bf_offset);
    }
    {
#line 360
    memcpy((void */* __restrict  */)buf___16, (void const   */* __restrict  */)(bfp->bf_buf + bfp->bf_offset),
           (size_t )count);
    }
  }
#line 363
  if (bfp->bf_offset + (off_t )nbytes > (off_t )bfp->bf_buffilled) {
#line 366
    if (! bfp->bf_ondisk) {
#line 369
      if ((int )tTdvect[58] >= 8) {
        {
#line 370
        sm_dprintf((char *)"sm_bfread(%s): to disk\n", bfp->bf_filename);
        }
      }
#line 372
      goto finished;
    }
#line 376
    if (bfp->bf_disk_fd < 0) {
      {
#line 378
      tmp = __errno_location();
#line 378
      *tmp = 5;
      }
#line 379
      return (-1);
    }
    {
#line 382
    tmp___3 = lseek(bfp->bf_disk_fd, bfp->bf_offset + (off_t )count, 0);
    }
#line 382
    if (tmp___3 < 0L) {
      {
#line 385
      tmp___1 = __errno_location();
      }
#line 385
      if (*tmp___1 == 22) {
        {
#line 393
        tmp___0 = __errno_location();
#line 393
        *tmp___0 = 5;
        }
      } else {
        {
#line 385
        tmp___2 = __errno_location();
        }
#line 385
        if (*tmp___2 == 29) {
          {
#line 393
          tmp___0 = __errno_location();
#line 393
          *tmp___0 = 5;
          }
        }
      }
#line 395
      return (-1);
    }
    {
#line 398
    while (1) {
      while_continue: /* CIL Label */ ;
#line 398
      if (! ((size_t )count < nbytes)) {
#line 398
        goto while_break;
      }
      {
#line 400
      retval = read(bfp->bf_disk_fd, (void *)(buf___16 + count), nbytes - (size_t )count);
      }
#line 403
      if (retval < 0) {
#line 406
        return (-1);
      } else
#line 408
      if (retval == 0) {
#line 409
        goto finished;
      } else {
#line 411
        count += retval;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  finished: 
#line 416
  bfp->bf_offset += (off_t )count;
#line 417
  return (count);
}
}
#line 436 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
static off_t sm_bfseek(SM_FILE_T *fp , off_t offset , int whence ) 
{ 
  struct bf *bfp ;
  int *tmp ;

  {
#line 446
  bfp = (struct bf *)fp->f_cookie;
  {
#line 450
  if (whence == 0) {
#line 450
    goto case_0;
  }
#line 454
  if (whence == 1) {
#line 454
    goto case_1;
  }
#line 458
  if (whence == 2) {
#line 458
    goto case_2;
  }
#line 462
  goto switch_default;
  case_0: /* CIL Label */ 
#line 451
  bfp->bf_offset = offset;
#line 452
  goto switch_break;
  case_1: /* CIL Label */ 
#line 455
  bfp->bf_offset += offset;
#line 456
  goto switch_break;
  case_2: /* CIL Label */ 
#line 459
  bfp->bf_offset = (off_t )bfp->bf_size + offset;
#line 460
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 463
  tmp = __errno_location();
#line 463
  *tmp = 22;
  }
#line 464
  return ((off_t )-1);
  switch_break: /* CIL Label */ ;
  }
#line 466
  return (bfp->bf_offset);
}
}
#line 485 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
static ssize_t sm_bfwrite(SM_FILE_T *fp , char const   *buf___16 , size_t nbytes ) 
{ 
  struct bf *bfp ;
  ssize_t count ;
  int retval ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  __off_t tmp___2 ;
  mode_t omask ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  __off_t tmp___10 ;

  {
#line 492
  count = 0;
#line 496
  bfp = (struct bf *)fp->f_cookie;
#line 499
  if (bfp->bf_committed) {
    {
#line 501
    tmp___2 = lseek(bfp->bf_disk_fd, bfp->bf_offset, 0);
    }
#line 501
    if (tmp___2 < 0L) {
      {
#line 503
      tmp___0 = __errno_location();
      }
#line 503
      if (*tmp___0 == 22) {
        {
#line 511
        tmp = __errno_location();
#line 511
        *tmp = 5;
        }
      } else {
        {
#line 503
        tmp___1 = __errno_location();
        }
#line 503
        if (*tmp___1 == 29) {
          {
#line 511
          tmp = __errno_location();
#line 511
          *tmp = 5;
          }
        }
      }
#line 513
      return (-1);
    }
    {
#line 516
    count = write(bfp->bf_disk_fd, (void const   *)buf___16, nbytes);
    }
#line 517
    if (count < 0) {
#line 520
      return (-1);
    }
#line 522
    goto finished;
  }
#line 525
  if (bfp->bf_offset < (off_t )bfp->bf_bufsize) {
#line 528
    count = (ssize_t )nbytes;
#line 529
    if (bfp->bf_offset + (off_t )count > (off_t )bfp->bf_bufsize) {
#line 530
      count = (ssize_t )((off_t )bfp->bf_bufsize - bfp->bf_offset);
    }
    {
#line 532
    memcpy((void */* __restrict  */)(bfp->bf_buf + bfp->bf_offset), (void const   */* __restrict  */)buf___16,
           (size_t )count);
    }
#line 533
    if (bfp->bf_offset + (off_t )count > (off_t )bfp->bf_buffilled) {
#line 534
      bfp->bf_buffilled = (int )(bfp->bf_offset + (off_t )count);
    }
  }
#line 537
  if (bfp->bf_offset + (off_t )nbytes > (off_t )bfp->bf_bufsize) {
#line 540
    if (! bfp->bf_ondisk) {
      {
#line 545
      omask = umask((__mode_t )0);
#line 546
      retval = safeopen(bfp->bf_filename, 578, (int )bfp->bf_filemode, bfp->bf_flags);
#line 549
      umask(omask);
      }
#line 552
      if (retval < 0) {
        {
#line 563
        tmp___4 = __errno_location();
        }
#line 563
        if (! (*tmp___4 == 28)) {
          {
#line 563
          tmp___5 = __errno_location();
          }
#line 563
          if (! (*tmp___5 == 122)) {
            {
#line 568
            tmp___3 = __errno_location();
#line 568
            *tmp___3 = 5;
            }
          }
        }
#line 570
        return (-1);
      }
#line 572
      bfp->bf_disk_fd = retval;
#line 573
      bfp->bf_ondisk = 1;
    }
#line 577
    if (bfp->bf_ondisk) {
#line 577
      if (bfp->bf_disk_fd < 0) {
        {
#line 579
        tmp___6 = __errno_location();
#line 579
        *tmp___6 = 5;
        }
#line 580
        return (-1);
      }
    }
    {
#line 583
    tmp___10 = lseek(bfp->bf_disk_fd, bfp->bf_offset + (off_t )count, 0);
    }
#line 583
    if (tmp___10 < 0L) {
      {
#line 586
      tmp___8 = __errno_location();
      }
#line 586
      if (*tmp___8 == 22) {
        {
#line 594
        tmp___7 = __errno_location();
#line 594
        *tmp___7 = 5;
        }
      } else {
        {
#line 586
        tmp___9 = __errno_location();
        }
#line 586
        if (*tmp___9 == 29) {
          {
#line 594
          tmp___7 = __errno_location();
#line 594
          *tmp___7 = 5;
          }
        }
      }
#line 596
      return (-1);
    }
    {
#line 599
    while (1) {
      while_continue: /* CIL Label */ ;
#line 599
      if (! ((size_t )count < nbytes)) {
#line 599
        goto while_break;
      }
      {
#line 601
      retval = write(bfp->bf_disk_fd, (void const   *)(buf___16 + count), nbytes - (size_t )count);
      }
#line 603
      if (retval < 0) {
#line 606
        return (-1);
      } else {
#line 609
        count += retval;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  finished: 
#line 614
  bfp->bf_offset += (off_t )count;
#line 615
  if (bfp->bf_offset > (off_t )bfp->bf_size) {
#line 616
    bfp->bf_size = (int )bfp->bf_offset;
  }
#line 617
  return (count);
}
}
#line 639 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
int bfrewind(SM_FILE_T *fp ) 
{ 
  int tmp ;

  {
  {
#line 643
  sm_io_flush(fp, -2);
#line 644
  fp->f_flags &= -385L;
#line 645
  tmp = sm_io_seek(fp, -2, 0L, 0);
  }
#line 645
  return (tmp);
}
}
#line 668 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
static int sm_bfcommit(SM_FILE_T *fp ) 
{ 
  struct bf *bfp ;
  int retval ;
  int byteswritten ;
  int save_errno ;
  mode_t omask ;
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  __off_t tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 677
  bfp = (struct bf *)fp->f_cookie;
#line 680
  if (bfp->bf_committed) {
#line 681
    return (0);
  }
#line 684
  if (! bfp->bf_ondisk) {
#line 690
    if ((int )tTdvect[58] >= 8) {
      {
#line 692
      sm_dprintf((char *)"bfcommit(%s): to disk\n", bfp->bf_filename);
      }
#line 693
      if ((int )tTdvect[58] >= 32) {
        {
#line 694
        sm_dprintf((char *)"bfcommit(): filemode %o flags %ld\n", bfp->bf_filemode,
                   bfp->bf_flags);
        }
      }
    }
    {
#line 698
    tmp___0 = stat((char const   */* __restrict  */)bfp->bf_filename, (struct stat */* __restrict  */)(& st));
    }
#line 698
    if (tmp___0 == 0) {
      {
#line 700
      tmp = __errno_location();
#line 700
      *tmp = 17;
      }
#line 701
      return (-1);
    }
    {
#line 705
    omask = umask((__mode_t )0);
#line 706
    retval = safeopen(bfp->bf_filename, 194, (int )bfp->bf_filemode, bfp->bf_flags);
#line 709
    tmp___1 = __errno_location();
#line 709
    save_errno = *tmp___1;
#line 710
    umask(omask);
    }
#line 713
    if (retval < 0) {
      {
#line 716
      tmp___2 = __errno_location();
#line 716
      *tmp___2 = save_errno;
      }
#line 717
      return (-1);
    }
#line 720
    bfp->bf_disk_fd = retval;
#line 721
    bfp->bf_ondisk = 1;
  }
#line 725
  if (bfp->bf_buffilled > 0) {
    {
#line 727
    byteswritten = 0;
#line 729
    tmp___3 = lseek(bfp->bf_disk_fd, (__off_t )0, 0);
    }
#line 729
    if (tmp___3 < 0L) {
#line 732
      return (-1);
    }
    {
#line 735
    while (1) {
      while_continue: /* CIL Label */ ;
#line 735
      if (! (byteswritten < bfp->bf_buffilled)) {
#line 735
        goto while_break;
      }
      {
#line 737
      retval = write(bfp->bf_disk_fd, (void const   *)(bfp->bf_buf + byteswritten),
                     (size_t )(bfp->bf_buffilled - byteswritten));
      }
#line 740
      if (retval < 0) {
#line 743
        return (-1);
      } else {
#line 746
        byteswritten += retval;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  bfp->bf_committed = 1;
#line 752
  bfp->bf_buffilled = 0;
#line 753
  if (bfp->bf_bufsize > 0) {
    {
#line 756
    bfp->bf_bufsize = 0;
#line 757
    sm_free_tagged((void *)bfp->bf_buf, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c",
                   757);
    }
  }
#line 759
  return (0);
}
}
#line 780 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
static int sm_bftruncate(SM_FILE_T *fp ) 
{ 
  struct bf *bfp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 786
  tmp = bfrewind(fp);
  }
#line 786
  if (tmp < 0) {
#line 787
    return (-1);
  }
#line 790
  bfp = (struct bf *)fp->f_cookie;
#line 791
  bfp->bf_buffilled = 0;
#line 792
  bfp->bf_size = 0;
#line 795
  if (bfp->bf_bufsize > 0) {
    {
#line 796
    memset((void *)bfp->bf_buf, '\000', (size_t )bfp->bf_bufsize);
    }
  }
#line 797
  if (bfp->bf_ondisk) {
    {
#line 804
    tmp___0 = ftruncate(bfp->bf_disk_fd, (__off_t )0);
    }
#line 804
    return (tmp___0);
  }
#line 807
  return (0);
}
}
#line 820 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c"
static int sm_bfsetinfo(SM_FILE_T *fp , int what , void *valp ) 
{ 
  struct bf *bfp ;
  int bsize ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp11 ;

  {
#line 830
  bfp = (struct bf *)fp->f_cookie;
  {
#line 833
  if (what == 1000) {
#line 833
    goto case_1000;
  }
#line 851
  if (what == 1001) {
#line 851
    goto case_1001;
  }
#line 853
  if (what == 1002) {
#line 853
    goto case_1002;
  }
#line 855
  if (what == 1003) {
#line 855
    goto case_1003;
  }
#line 857
  goto switch_default;
  case_1000: /* CIL Label */ 
#line 834
  bsize = *((int *)valp);
#line 835
  bfp->bf_bufsize = bsize;
#line 838
  if (bsize > 0) {
    {
#line 840
    tmp = sm_malloc_tagged((size_t )bsize, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/bf.c",
                           840, SmHeapGroup);
#line 840
    bfp->bf_buf = (char *)tmp;
    }
#line 841
    if ((unsigned long )bfp->bf_buf == (unsigned long )((void *)0)) {
      {
#line 843
      bfp->bf_bufsize = 0;
#line 844
      tmp___0 = __errno_location();
#line 844
      *tmp___0 = 12;
      }
#line 845
      return (-1);
    }
  } else {
#line 849
    bfp->bf_buf = (char *)((void *)0);
  }
#line 850
  return (0);
  case_1001: /* CIL Label */ 
  {
#line 852
  tmp___1 = sm_bfcommit(fp);
  }
#line 852
  return (tmp___1);
  case_1002: /* CIL Label */ 
  {
#line 854
  tmp___2 = sm_bftruncate(fp);
  }
#line 854
  return (tmp___2);
  case_1003: /* CIL Label */ 
#line 856
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 858
  tmp___3 = __errno_location();
#line 858
  *tmp___3 = 22;
  }
#line 859
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 233 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 67 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/arpadate.c"
static char b[93]  ;
#line 55 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/arpadate.c"
char *arpadate(char *ud ) 
{ 
  register char *p ;
  register char *q ;
  register int off ;
  register int i ;
  register struct tm *lt ;
  time_t t ;
  struct tm gmt ;
  char *tz ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  struct tm *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;

  {
  {
#line 76
  t = curtime();
  }
#line 77
  if ((unsigned long )ud == (unsigned long )((void *)0)) {
    {
#line 78
    ud = ctime((time_t const   *)(& t));
    }
  }
#line 84
  q = b;
#line 86
  p = ud + 0;
#line 87
  tmp = q;
#line 87
  q ++;
#line 87
  tmp___0 = p;
#line 87
  p ++;
#line 87
  *tmp = *tmp___0;
#line 88
  tmp___1 = q;
#line 88
  q ++;
#line 88
  tmp___2 = p;
#line 88
  p ++;
#line 88
  *tmp___1 = *tmp___2;
#line 89
  tmp___3 = q;
#line 89
  q ++;
#line 89
  tmp___4 = p;
#line 89
  p ++;
#line 89
  *tmp___3 = *tmp___4;
#line 90
  tmp___5 = q;
#line 90
  q ++;
#line 90
  *tmp___5 = (char )',';
#line 91
  tmp___6 = q;
#line 91
  q ++;
#line 91
  *tmp___6 = (char )' ';
#line 93
  p = ud + 8;
#line 94
  if ((int )*p == 32) {
#line 95
    p ++;
  } else {
#line 97
    tmp___7 = q;
#line 97
    q ++;
#line 97
    tmp___8 = p;
#line 97
    p ++;
#line 97
    *tmp___7 = *tmp___8;
  }
#line 98
  tmp___9 = q;
#line 98
  q ++;
#line 98
  tmp___10 = p;
#line 98
  p ++;
#line 98
  *tmp___9 = *tmp___10;
#line 99
  tmp___11 = q;
#line 99
  q ++;
#line 99
  *tmp___11 = (char )' ';
#line 101
  p = ud + 4;
#line 102
  tmp___12 = q;
#line 102
  q ++;
#line 102
  tmp___13 = p;
#line 102
  p ++;
#line 102
  *tmp___12 = *tmp___13;
#line 103
  tmp___14 = q;
#line 103
  q ++;
#line 103
  tmp___15 = p;
#line 103
  p ++;
#line 103
  *tmp___14 = *tmp___15;
#line 104
  tmp___16 = q;
#line 104
  q ++;
#line 104
  tmp___17 = p;
#line 104
  p ++;
#line 104
  *tmp___16 = *tmp___17;
#line 105
  tmp___18 = q;
#line 105
  q ++;
#line 105
  *tmp___18 = (char )' ';
#line 107
  p = ud + 20;
#line 108
  tmp___19 = q;
#line 108
  q ++;
#line 108
  tmp___20 = p;
#line 108
  p ++;
#line 108
  *tmp___19 = *tmp___20;
#line 109
  tmp___21 = q;
#line 109
  q ++;
#line 109
  tmp___22 = p;
#line 109
  p ++;
#line 109
  *tmp___21 = *tmp___22;
#line 110
  tmp___23 = q;
#line 110
  q ++;
#line 110
  tmp___24 = p;
#line 110
  p ++;
#line 110
  *tmp___23 = *tmp___24;
#line 111
  tmp___25 = q;
#line 111
  q ++;
#line 111
  tmp___26 = p;
#line 111
  p ++;
#line 111
  *tmp___25 = *tmp___26;
#line 112
  tmp___27 = q;
#line 112
  q ++;
#line 112
  *tmp___27 = (char )' ';
#line 114
  p = ud + 11;
#line 115
  i = 8;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (i > 0)) {
#line 115
      goto while_break;
    }
#line 116
    tmp___28 = q;
#line 116
    q ++;
#line 116
    tmp___29 = p;
#line 116
    p ++;
#line 116
    *tmp___28 = *tmp___29;
#line 115
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  tmp___30 = gmtime((time_t const   *)(& t));
#line 125
  gmt = *tmp___30;
#line 126
  lt = localtime((time_t const   *)(& t));
#line 128
  off = ((lt->tm_hour - gmt.tm_hour) * 60 + lt->tm_min) - gmt.tm_min;
  }
#line 131
  if (lt->tm_year < gmt.tm_year) {
#line 132
    off -= 1440;
  } else
#line 133
  if (lt->tm_year > gmt.tm_year) {
#line 134
    off += 1440;
  } else
#line 135
  if (lt->tm_yday < gmt.tm_yday) {
#line 136
    off -= 1440;
  } else
#line 137
  if (lt->tm_yday > gmt.tm_yday) {
#line 138
    off += 1440;
  }
#line 140
  tmp___31 = q;
#line 140
  q ++;
#line 140
  *tmp___31 = (char )' ';
#line 141
  if (off == 0) {
#line 143
    tmp___32 = q;
#line 143
    q ++;
#line 143
    *tmp___32 = (char )'G';
#line 144
    tmp___33 = q;
#line 144
    q ++;
#line 144
    *tmp___33 = (char )'M';
#line 145
    tmp___34 = q;
#line 145
    q ++;
#line 145
    *tmp___34 = (char )'T';
  } else {
#line 149
    tz = (char *)((void *)0);
#line 175
    if (off < 0) {
#line 177
      off = - off;
#line 178
      tmp___35 = q;
#line 178
      q ++;
#line 178
      *tmp___35 = (char )'-';
    } else {
#line 181
      tmp___36 = q;
#line 181
      q ++;
#line 181
      *tmp___36 = (char )'+';
    }
#line 183
    if (off >= 1440) {
#line 184
      off = 1439;
    }
#line 186
    tmp___37 = q;
#line 186
    q ++;
#line 186
    *tmp___37 = (char )(off / 600 + 48);
#line 187
    tmp___38 = q;
#line 187
    q ++;
#line 187
    *tmp___38 = (char )((off / 60) % 10 + 48);
#line 188
    off %= 60;
#line 189
    tmp___39 = q;
#line 189
    q ++;
#line 189
    *tmp___39 = (char )(off / 10 + 48);
#line 190
    tmp___40 = q;
#line 190
    q ++;
#line 190
    *tmp___40 = (char )(off % 10 + 48);
#line 191
    if ((unsigned long )tz != (unsigned long )((void *)0)) {
#line 191
      if ((int )*tz != 0) {
#line 193
        tmp___41 = q;
#line 193
        q ++;
#line 193
        *tmp___41 = (char )' ';
#line 194
        tmp___42 = q;
#line 194
        q ++;
#line 194
        *tmp___42 = (char )'(';
        {
#line 195
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 195
          if ((int )*tz != 0) {
#line 195
            if (! ((unsigned long )q < (unsigned long )(& b[sizeof(b) - 3UL]))) {
#line 195
              goto while_break___0;
            }
          } else {
#line 195
            goto while_break___0;
          }
#line 196
          tmp___43 = q;
#line 196
          q ++;
#line 196
          tmp___44 = tz;
#line 196
          tz ++;
#line 196
          *tmp___43 = *tmp___44;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 197
        tmp___45 = q;
#line 197
        q ++;
#line 197
        *tmp___45 = (char )')';
      }
    }
  }
#line 200
  *q = (char )'\000';
#line 202
  return (b);
}
}
#line 2172 "./sendmail.h"
bool NoAlias ;
#line 21 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c"
static struct _map *AliasFileMap  =    (struct _map *)((void *)0);
#line 22 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c"
static int NAliasFileMaps  ;
#line 24
static char *aliaslookup(char *name , int *pstat , char *av___0 ) ;
#line 51 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c"
void alias(ADDRESS *a , ADDRESS **sendq , int aliaslevel , ENVELOPE *e ) 
{ 
  register char *p ;
  char *owner ;
  int status ;
  char obuf[263] ;
  char *tmp ;
  char *tmp___0 ;
  SM_FILE_T *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 60
  status = 0;
#line 63
  if ((int )tTdvect[27] >= 1) {
    {
#line 64
    sm_dprintf((char *)"alias(%s)\n", a->q_user);
    }
  }
#line 67
  if (! ((int )a->q_state == 0)) {
#line 68
    return;
  }
#line 70
  if (NoAlias) {
#line 71
    return;
  }
  {
#line 73
  e->e_to = a->q_paddr;
#line 105
  p = aliaslookup(a->q_user, & status, a->q_host);
  }
#line 106
  if (status == 75) {
#line 106
    goto _L;
  } else
#line 106
  if (status == 69) {
    _L: /* CIL Label */ 
#line 108
    a->q_state = (short)3;
#line 109
    if ((unsigned long )e->e_message == (unsigned long )((void *)0)) {
#line 110
      e->e_message = (char *)"alias database unavailable";
    }
#line 113
    if ((unsigned long )a->q_message == (unsigned long )((void *)0)) {
#line 114
      a->q_message = (char *)"alias database unavailable";
    }
#line 115
    return;
  }
#line 117
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 118
    return;
  }
#line 125
  if ((int )tTdvect[27] >= 1) {
    {
#line 126
    sm_dprintf((char *)"%s (%s, %s) aliased to %s\n", a->q_paddr, a->q_host, a->q_user,
               p);
    }
  }
#line 128
  if ((e->e_flags & 512UL) != 0UL) {
#line 130
    a->q_state = (short)5;
#line 131
    return;
  }
  {
#line 133
  tmp = shortenstring((char const   *)p, (size_t )203);
#line 133
  message("aliased to %s", tmp);
  }
#line 134
  if (LogLevel > 10) {
    {
#line 135
    tmp___0 = shortenstring((char const   *)p, (size_t )203);
#line 135
    sm_syslog(6, (char const   *)e->e_id, "alias %.100s => %s", a->q_paddr, tmp___0);
    }
  }
#line 138
  a->q_flags &= 0xfffffffffffffff7UL;
#line 139
  if ((int )tTdvect[27] >= 5) {
    {
#line 141
    sm_dprintf((char *)"alias: QS_EXPANDED ");
#line 142
    tmp___1 = sm_debug_file();
#line 142
    printaddr(tmp___1, a, 0);
    }
  }
  {
#line 144
  a->q_state = (short)7;
#line 152
  a->q_uid = DefUid;
#line 153
  a->q_gid = (gid_t )0;
#line 154
  a->q_fullname = (char *)((void *)0);
#line 155
  a->q_flags |= 16385UL;
#line 157
  sendtolist(p, a, sendq, aliaslevel + 1, e);
  }
#line 159
  if ((a->q_flags & 8UL) != 0UL) {
#line 159
    if ((int )a->q_state == 7) {
#line 160
      a->q_state = (short)0;
    }
  }
  {
#line 166
  tmp___2 = strncmp((char const   *)a->q_user, "owner-", (size_t )6);
  }
#line 166
  if (tmp___2 == 0) {
    {
#line 168
    sm_strlcpy(obuf, "owner-owner", (ssize_t )sizeof(obuf));
    }
  } else {
    {
#line 166
    tmp___3 = strlen((char const   *)a->q_user);
    }
#line 166
    if ((unsigned long )tmp___3 > sizeof(obuf) - 7UL) {
      {
#line 168
      sm_strlcpy(obuf, "owner-owner", (ssize_t )sizeof(obuf));
      }
    } else {
      {
#line 170
      sm_strlcpyn(obuf, (ssize_t )sizeof(obuf), 2, "owner-", a->q_user);
      }
    }
  }
  {
#line 171
  owner = aliaslookup(obuf, & status, a->q_host);
  }
#line 172
  if ((unsigned long )owner == (unsigned long )((void *)0)) {
#line 173
    return;
  }
  {
#line 176
  tmp___4 = strpbrk((char const   *)owner, ",:/|\"");
  }
#line 176
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 177
    owner = obuf;
  }
  {
#line 178
  a->q_owner = sm_rpool_strdup_x(e->e_rpool, (char const   *)owner);
  }
#line 181
  if ((unsigned long )e->e_xfp != (unsigned long )((void *)0)) {
    {
#line 182
    sm_io_fprintf(e->e_xfp, -2, "Message delivered to mailing list %s\n", a->q_paddr);
    }
  }
#line 185
  e->e_flags |= 16UL;
#line 186
  a->q_flags |= 6144UL;
#line 187
  return;
}
}
#line 213 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c"
static struct _map *map  =    (struct _map *)((void *)0);
#line 207 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c"
static char *aliaslookup(char *name , int *pstat , char *av___0 ) 
{ 
  STAB *s ;
  STAB *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 219
  if ((unsigned long )map == (unsigned long )((void *)0)) {
    {
#line 221
    tmp = stab((char *)"aliases", 6, 0);
#line 221
    s = tmp;
    }
#line 223
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 224
      return ((char *)((void *)0));
    }
#line 225
    map = & s->s_value.sv_map;
  }
#line 227
  if (! ((map->map_mflags & 32L) != 0L)) {
    {
#line 227
    tmp___0 = openmap(map);
    }
#line 227
    if (! tmp___0) {
#line 227
      return ((char *)((void *)0));
    }
  }
  {
#line 230
  tmp___1 = sm_strcasecmp((char const   *)name, "postmaster");
  }
#line 230
  if (tmp___1 == 0) {
#line 231
    name = (char *)"postmaster";
  }
  {
#line 244
  tmp___2 = (*((map->map_class)->map_lookup))(map, name, (char **)((void *)0), pstat);
  }
#line 244
  return (tmp___2);
}
}
#line 259 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c"
void setalias(char *spec ) 
{ 
  register char *p ;
  register struct _map *map___0 ;
  char *class ;
  STAB *s ;
  char buf___16[50] ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  bool quoted ;
  char *tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 268
  if ((int )tTdvect[27] >= 8) {
    {
#line 269
    sm_dprintf((char *)"setalias(%s)\n", spec);
    }
  }
#line 271
  p = spec;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 271
      goto while_break;
    }
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 275
      if (((int )*p & -128) == 0) {
        {
#line 275
        tmp = __ctype_b_loc();
        }
#line 275
        if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 275
          goto while_break___0;
        }
      } else {
#line 275
        goto while_break___0;
      }
#line 276
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 277
    if ((int )*p == 0) {
#line 278
      goto while_break;
    }
#line 279
    spec = p;
#line 281
    if (NAliasFileMaps >= 12) {
      {
#line 283
      syserr("Too many alias databases defined, %d max", 12);
      }
#line 285
      return;
    }
#line 287
    if ((unsigned long )AliasFileMap == (unsigned long )((void *)0)) {
      {
#line 289
      sm_strlcpy(buf___16, "aliases.files sequence", (ssize_t )sizeof(buf___16));
#line 291
      AliasFileMap = makemapentry(buf___16);
      }
#line 292
      if ((unsigned long )AliasFileMap == (unsigned long )((void *)0)) {
        {
#line 294
        syserr("setalias: cannot create aliases.files map");
        }
#line 295
        return;
      }
    }
    {
#line 298
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "Alias%d", NAliasFileMaps);
#line 299
    s = stab(buf___16, 6, 1);
#line 300
    map___0 = & s->s_value.sv_map;
#line 301
    memset((void *)map___0, '\000', (size_t )sizeof(*map___0));
#line 302
    map___0->map_mname = s->s_name;
#line 303
    p = strpbrk((char const   *)p, " ,/:");
    }
#line 304
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 304
      if ((int )*p == 58) {
#line 307
        tmp___0 = p;
#line 307
        p ++;
#line 307
        *tmp___0 = (char )'\000';
#line 308
        class = spec;
#line 309
        spec = p;
      } else {
#line 313
        class = (char *)"implicit";
#line 314
        map___0->map_mflags = 2L;
      }
    } else {
#line 313
      class = (char *)"implicit";
#line 314
      map___0->map_mflags = 2L;
    }
#line 318
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 320
      quoted = 0;
      {
#line 322
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 322
        if (! ((int )*p != 0)) {
#line 322
          goto while_break___1;
        }
#line 330
        if ((int )*p == 34) {
#line 331
          quoted = ! quoted;
        } else
#line 332
        if ((int )*p == 44) {
#line 332
          if (! quoted) {
#line 333
            goto while_break___1;
          }
        }
#line 322
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 337
      if ((int )*p == 0) {
#line 338
        p = (char *)((void *)0);
      }
    }
#line 340
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 341
      tmp___1 = p;
#line 341
      p ++;
#line 341
      *tmp___1 = (char )'\000';
    }
#line 343
    if ((int )tTdvect[27] >= 20) {
      {
#line 344
      sm_dprintf((char *)"  map %s:%s %s\n", class, s->s_name, spec);
      }
    }
    {
#line 347
    s = stab(class, 5, 0);
    }
#line 348
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
#line 350
      syserr("setalias: unknown alias class %s", class);
      }
    } else
#line 352
    if (! (((int )s->s_value.sv_mapclass.map_cflags & 1) != 0)) {
      {
#line 354
      syserr("setalias: map class %s can\'t handle aliases", class);
      }
    } else {
      {
#line 359
      map___0->map_class = & s->s_value.sv_mapclass;
#line 360
      map___0->map_mflags |= 128L;
#line 361
      tmp___3 = (*((map___0->map_class)->map_parse))(map___0, spec);
      }
#line 361
      if (tmp___3) {
#line 363
        map___0->map_mflags |= 1L;
#line 364
        tmp___2 = NAliasFileMaps;
#line 364
        NAliasFileMaps ++;
#line 364
        AliasFileMap->map_stack[tmp___2] = map___0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return;
}
}
#line 387 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c"
bool aliaswait(struct _map *map___0 , char *ext , bool isopen ) 
{ 
  bool attimeout ;
  time_t mtime ;
  struct stat stb ;
  char buf___16[4096] ;
  int st ;
  unsigned int sleeptime ;
  unsigned int loopcount ;
  time_t toolong ;
  time_t tmp ;
  time_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 393
  attimeout = 0;
#line 398
  if ((int )tTdvect[27] >= 3) {
    {
#line 399
    sm_dprintf((char *)"aliaswait(%s:%s)\n", (map___0->map_class)->map_cname, map___0->map_file);
    }
  }
#line 401
  if ((map___0->map_mflags & 2048L) != 0L) {
#line 402
    return (isopen);
  }
#line 403
  map___0->map_mflags |= 2048L;
#line 405
  if (SafeAlias > 0L) {
    {
#line 408
    sleeptime = 2U;
#line 409
    loopcount = 0U;
#line 410
    tmp = curtime();
#line 410
    toolong = tmp + SafeAlias;
    }
    {
#line 412
    while (1) {
      while_continue: /* CIL Label */ ;
#line 412
      if (isopen) {
        {
#line 412
        tmp___1 = (*((map___0->map_class)->map_lookup))(map___0, (char *)"@", (char **)((void *)0),
                                                        & st);
        }
#line 412
        if (! ((unsigned long )tmp___1 == (unsigned long )((void *)0))) {
#line 412
          goto while_break;
        }
      } else {
#line 412
        goto while_break;
      }
      {
#line 415
      tmp___0 = curtime();
      }
#line 415
      if (tmp___0 > toolong) {
#line 418
        attimeout = 1;
#line 419
        goto while_break;
      }
#line 427
      if ((int )tTdvect[27] >= 2) {
        {
#line 429
        loopcount ++;
#line 430
        sm_dprintf((char *)"aliaswait: sleeping for %u seconds (loopcount = %u)\n",
                   sleeptime, loopcount);
        }
      }
      {
#line 434
      map___0->map_mflags |= 16777216L;
#line 435
      (*((map___0->map_class)->map_close))(map___0);
#line 436
      map___0->map_mflags &= -16777313L;
#line 437
      sleep(sleeptime);
#line 438
      sleeptime *= 2U;
      }
#line 439
      if (sleeptime > 60U) {
#line 440
        sleeptime = 60U;
      }
      {
#line 441
      isopen = (*((map___0->map_class)->map_open))(map___0, 0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 446
  if (! (((int )(map___0->map_class)->map_cflags & 4) != 0)) {
#line 448
    if ((int )tTdvect[27] >= 3) {
      {
#line 449
      sm_dprintf((char *)"aliaswait: not rebuildable\n");
      }
    }
#line 450
    map___0->map_mflags &= -2049L;
#line 451
    return (isopen);
  }
  {
#line 453
  tmp___2 = stat((char const   */* __restrict  */)map___0->map_file, (struct stat */* __restrict  */)(& stb));
  }
#line 453
  if (tmp___2 < 0) {
#line 455
    if ((int )tTdvect[27] >= 3) {
      {
#line 456
      sm_dprintf((char *)"aliaswait: no source file\n");
      }
    }
#line 457
    map___0->map_mflags &= -2049L;
#line 458
    return (isopen);
  }
#line 460
  mtime = stb.st_mtim.tv_sec;
#line 461
  if ((unsigned long )ext == (unsigned long )((void *)0)) {
#line 461
    tmp___5 = "";
  } else {
#line 461
    tmp___5 = (char const   *)ext;
  }
  {
#line 461
  tmp___6 = sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, map___0->map_file,
                        tmp___5);
  }
#line 461
  if ((unsigned long )tmp___6 >= sizeof(buf___16)) {
#line 464
    if (LogLevel > 3) {
#line 465
      if ((unsigned long )ext == (unsigned long )((void *)0)) {
#line 465
        tmp___3 = "";
      } else {
#line 465
        tmp___3 = (char const   *)ext;
      }
      {
#line 465
      sm_syslog(6, "*~*", "alias database %s%s name too long", map___0->map_file,
                tmp___3);
      }
    }
#line 468
    if ((unsigned long )ext == (unsigned long )((void *)0)) {
#line 468
      tmp___4 = "";
    } else {
#line 468
      tmp___4 = (char const   *)ext;
    }
    {
#line 468
    message("alias database %s%s name too long", map___0->map_file, tmp___4);
    }
  }
  {
#line 472
  tmp___7 = stat((char const   */* __restrict  */)(buf___16), (struct stat */* __restrict  */)(& stb));
  }
#line 472
  if (tmp___7 < 0) {
#line 472
    goto _L;
  } else
#line 472
  if (stb.st_mtim.tv_sec < mtime) {
#line 472
    goto _L;
  } else
#line 472
  if (attimeout) {
    _L: /* CIL Label */ 
#line 474
    if (LogLevel > 3) {
      {
#line 475
      sm_syslog(6, "*~*", "alias database %s out of date", buf___16);
      }
    }
    {
#line 477
    message("Warning: alias database %s out of date", buf___16);
    }
  }
#line 479
  map___0->map_mflags &= -2049L;
#line 480
  return (isopen);
}
}
#line 497 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c"
bool rebuildaliases(struct _map *map___0 , bool automatic ) 
{ 
  SM_FILE_T *af ;
  bool nolock ;
  bool success ;
  long sff ;
  void (*oldsigint)(int  ) ;
  void (*oldsigquit)(int  ) ;
  void (*oldsigtstp)(int  ) ;
  struct stat stb ;
  int saveerr ;
  int *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  bool tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  int *tmp___15 ;
  char const   *tmp___16 ;
  bool tmp___17 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 503
  nolock = 0;
#line 504
  success = 0;
#line 505
  sff = 24704L;
#line 511
  if (! (((int )(map___0->map_class)->map_cflags & 4) != 0)) {
#line 512
    return (0);
  }
#line 514
  if (! (DontBlameSendmail[9UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 9UL % (8UL * sizeof(int ))))) {
#line 515
    sff |= 1024L;
  }
#line 516
  if (! (DontBlameSendmail[5UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 5UL % (8UL * sizeof(int ))))) {
#line 517
    sff |= 2048L;
  }
#line 518
  if (! (DontBlameSendmail[6UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 6UL % (8UL * sizeof(int ))))) {
#line 519
    sff |= 4096L;
  }
  {
#line 522
  af = safefopen(map___0->map_file, 2, 0, sff);
  }
#line 522
  if ((unsigned long )af == (unsigned long )((void *)0)) {
    {
#line 526
    tmp___3 = __errno_location();
    }
#line 526
    if (*tmp___3 != 13) {
      {
#line 526
      tmp___4 = __errno_location();
      }
#line 526
      if (*tmp___4 != 30) {
#line 526
        goto _L;
      } else {
#line 526
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 526
    if (automatic) {
#line 526
      goto _L;
    } else {
      {
#line 526
      af = safefopen(map___0->map_file, 0, 0, sff);
      }
#line 526
      if ((unsigned long )af == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
        {
#line 529
        tmp = __errno_location();
#line 529
        saveerr = *tmp;
        }
#line 531
        if ((int )tTdvect[27] >= 1) {
          {
#line 532
          tmp___0 = sm_errstring(saveerr);
#line 532
          sm_dprintf((char *)"Can\'t open %s: %s\n", map___0->map_file, tmp___0);
          }
        }
#line 534
        if (! automatic) {
#line 534
          if (! ((map___0->map_mflags & 4L) != 0L)) {
            {
#line 535
            tmp___1 = sm_errstring(saveerr);
#line 535
            message("newaliases: cannot open %s: %s", map___0->map_file, tmp___1);
            }
          }
        }
        {
#line 537
        tmp___2 = __errno_location();
#line 537
        *tmp___2 = 0;
        }
#line 538
        return (0);
      }
    }
#line 540
    nolock = 1;
#line 541
    if ((int )tTdvect[27] >= 1) {
      {
#line 544
      tmp___5 = __errno_location();
#line 544
      tmp___6 = sm_errstring(*tmp___5);
#line 544
      message("warning: cannot lock %s: %s", map___0->map_file, tmp___6);
      }
    } else {
      {
#line 541
      tmp___7 = sm_io_getinfo(af, 3, (void *)0);
#line 541
      tmp___8 = fstat(tmp___7, & stb);
      }
#line 541
      if (tmp___8 < 0) {
        {
#line 544
        tmp___5 = __errno_location();
#line 544
        tmp___6 = sm_errstring(*tmp___5);
#line 544
        message("warning: cannot lock %s: %s", map___0->map_file, tmp___6);
        }
      } else
#line 541
      if ((stb.st_mode & (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3))) != 0U) {
        {
#line 544
        tmp___5 = __errno_location();
#line 544
        tmp___6 = sm_errstring(*tmp___5);
#line 544
        message("warning: cannot lock %s: %s", map___0->map_file, tmp___6);
        }
      }
    }
  }
#line 549
  if (! nolock) {
    {
#line 549
    tmp___11 = sm_io_getinfo(af, 3, (void *)0);
#line 549
    tmp___12 = lockfile(tmp___11, map___0->map_file, (char *)((void *)0), 6);
    }
#line 549
    if (! tmp___12) {
      {
#line 554
      message("Alias file %s is locked (maybe being rebuilt)", map___0->map_file);
      }
#line 556
      if ((int )OpMode != 105) {
        {
#line 559
        tmp___9 = sm_io_getinfo(af, 3, (void *)0);
#line 559
        lockfile(tmp___9, map___0->map_file, (char *)((void *)0), 2);
        }
      }
      {
#line 562
      sm_io_close(af, -2);
#line 563
      tmp___10 = __errno_location();
#line 563
      *tmp___10 = 0;
      }
#line 564
      return (0);
    }
  }
  {
#line 567
  oldsigint = sm_signal(2, (void (*)(int  ))1);
#line 568
  oldsigquit = sm_signal(3, (void (*)(int  ))1);
#line 570
  oldsigtstp = sm_signal(20, (void (*)(int  ))1);
#line 573
  tmp___17 = (*((map___0->map_class)->map_open))(map___0, 2);
  }
#line 573
  if (tmp___17) {
#line 575
    if (LogLevel > 7) {
      {
#line 577
      tmp___13 = username();
      }
#line 577
      if (automatic) {
#line 577
        tmp___14 = "auto";
      } else {
#line 577
        tmp___14 = "";
      }
      {
#line 577
      sm_syslog(5, "*~*", "alias database %s %srebuilt by %s", map___0->map_file,
                tmp___14, tmp___13);
      }
    }
    {
#line 582
    map___0->map_mflags |= 96L;
#line 583
    map___0->map_pid = CurrentPid;
#line 584
    readaliases(map___0, af, ! automatic, 1);
#line 585
    success = 1;
    }
  } else {
#line 589
    if ((int )tTdvect[27] >= 1) {
      {
#line 590
      tmp___15 = __errno_location();
#line 590
      tmp___16 = sm_errstring(*tmp___15);
#line 590
      sm_dprintf((char *)"Can\'t create database for %s: %s\n", map___0->map_file,
                 tmp___16);
      }
    }
#line 592
    if (! automatic) {
      {
#line 593
      syserr("Cannot create database for alias file %s", map___0->map_file);
      }
    }
  }
  {
#line 598
  sm_io_close(af, -2);
  }
#line 601
  if ((map___0->map_mflags & 32L) != 0L) {
    {
#line 603
    map___0->map_mflags |= 16777216L;
#line 604
    (*((map___0->map_class)->map_close))(map___0);
#line 605
    map___0->map_mflags &= -16777313L;
    }
  }
  {
#line 609
  sm_signal(2, oldsigint);
#line 610
  sm_signal(3, oldsigquit);
#line 612
  sm_signal(20, oldsigtstp);
  }
#line 614
  return (success);
}
}
#line 637 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c"
void readaliases(struct _map *map___0 , SM_FILE_T *af , bool announcestats , bool logstats ) 
{ 
  register char *p ;
  char *rhs ;
  bool skipping ;
  long naliases ;
  long bytes ;
  long longest ;
  ADDRESS al ;
  ADDRESS bl___0 ;
  char line[8192] ;
  int lhssize ;
  int rhssize ;
  int c ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ADDRESS *tmp___2 ;
  unsigned short const   **tmp___3 ;
  register char *nlp ;
  size_t tmp___4 ;
  char *delimptr ;
  unsigned short const   **tmp___5 ;
  ADDRESS *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  unsigned short const   **tmp___12 ;
  char *tmp___13 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
#line 655
  FileName = map___0->map_file;
#line 656
  LineNumber = 0;
#line 657
  longest = 0L;
#line 657
  bytes = longest;
#line 657
  naliases = bytes;
#line 658
  skipping = 0;
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 659
    tmp___13 = sm_io_fgets(af, -2, line, (int )sizeof(line));
    }
#line 659
    if (! ((unsigned long )tmp___13 != (unsigned long )((void *)0))) {
#line 659
      goto while_break;
    }
    {
#line 664
    LineNumber ++;
#line 665
    p = strchr((char const   *)(line), '\n');
    }
    {
#line 668
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 668
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 668
        if ((unsigned long )p > (unsigned long )(line)) {
#line 668
          if (! ((int )*(p + -1) == 92)) {
#line 668
            goto while_break___0;
          }
        } else {
#line 668
          goto while_break___0;
        }
      } else {
#line 668
        goto while_break___0;
      }
      {
#line 670
      p --;
#line 671
      tmp = sm_io_fgets(af, -2, p, (int )(sizeof(line) - (unsigned long )(p - line)));
      }
#line 671
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 673
        goto while_break___0;
      }
      {
#line 674
      LineNumber ++;
#line 675
      p = strchr((char const   *)p, '\n');
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 677
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 678
      *p = (char )'\000';
    } else
#line 679
    if (! ((af->f_flags & 128L) != 0L)) {
      {
#line 681
      tmp___0 = __errno_location();
#line 681
      *tmp___0 = 0;
#line 682
      syserr("554 5.3.0 alias line too long");
      }
      {
#line 685
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 685
        c = sm_io_getc(af, -2);
        }
#line 685
        if (c != -1) {
#line 685
          if (! (c != 10)) {
#line 685
            goto while_break___1;
          }
        } else {
#line 685
          goto while_break___1;
        }
#line 687
        goto while_continue___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 690
      skipping = 1;
#line 691
      goto while_continue;
    }
    {
#line 696
    if ((int )line[0] == 0) {
#line 696
      goto case_0;
    }
#line 696
    if ((int )line[0] == 35) {
#line 696
      goto case_0;
    }
#line 701
    if ((int )line[0] == 9) {
#line 701
      goto case_9;
    }
#line 701
    if ((int )line[0] == 32) {
#line 701
      goto case_9;
    }
#line 693
    goto switch_break;
    case_0: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 697
    skipping = 0;
#line 698
    goto while_continue;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 702
    if (! skipping) {
      {
#line 703
      syserr("554 5.3.5 Non-continuation line starts with space");
      }
    }
#line 704
    skipping = 1;
#line 705
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
#line 707
    skipping = 0;
#line 718
    p = line;
    {
#line 718
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 718
      if ((int )*p != 0) {
#line 718
        if ((int )*p != 58) {
#line 718
          if (! ((int )*p != 10)) {
#line 718
            goto while_break___2;
          }
        } else {
#line 718
          goto while_break___2;
        }
      } else {
#line 718
        goto while_break___2;
      }
#line 719
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 718
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 720
    tmp___1 = p;
#line 720
    p ++;
#line 720
    if ((int )*tmp___1 != 58) {
      {
#line 722
      syserr("554 5.3.5 missing colon");
      }
#line 723
      goto while_continue;
    }
    {
#line 725
    tmp___2 = parseaddr(line, & al, 48, ':', (char **)((void *)0), CurEnv, 1);
    }
#line 725
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
#line 728
      syserr("554 5.3.5 %.40s... illegal alias name", line);
      }
#line 729
      goto while_continue;
    }
    {
#line 738
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 738
      if (((int )*p & -128) == 0) {
        {
#line 738
        tmp___3 = __ctype_b_loc();
        }
#line 738
        if (! ((int const   )*(*tmp___3 + (int )*p) & 8192)) {
#line 738
          goto while_break___3;
        }
      } else {
#line 738
        goto while_break___3;
      }
#line 739
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 740
    rhs = p;
    {
#line 741
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 745
      tmp___4 = strlen((char const   *)p);
#line 745
      nlp = p + tmp___4;
      }
#line 746
      if ((unsigned long )nlp > (unsigned long )p) {
#line 746
        if ((int )*(nlp + -1) == 10) {
#line 747
          nlp --;
#line 747
          *nlp = (char )'\000';
        }
      }
#line 749
      if (CheckAliases) {
        {
#line 752
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 752
          if (! ((int )*p != 0)) {
#line 752
            goto while_break___5;
          }
          {
#line 756
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 756
            if (((int )*p & -128) == 0) {
              {
#line 756
              tmp___5 = __ctype_b_loc();
              }
#line 756
              if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 756
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 756
            if (! ((int )*p == 44)) {
#line 756
              goto while_break___6;
            }
#line 758
            p ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 759
          if ((int )*p == 0) {
#line 760
            goto while_break___5;
          }
          {
#line 761
          tmp___6 = parseaddr(p, & bl___0, 0, ',', & delimptr, CurEnv, 1);
          }
#line 761
          if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
            {
#line 764
            usrerr("553 5.3.5 %s... bad address", p);
            }
          }
#line 765
          p = delimptr;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
#line 770
        p = nlp;
      }
      {
#line 774
      c = sm_io_getc(af, -2);
      }
#line 775
      if (! ((af->f_flags & 128L) != 0L)) {
        {
#line 776
        sm_io_ungetc(af, -2, c);
        }
      }
#line 777
      if (c != 32) {
#line 777
        if (c != 9) {
#line 778
          goto while_break___4;
        }
      }
      {
#line 781
      tmp___7 = sm_io_fgets(af, -2, p, (int )(sizeof(line) - (unsigned long )(p - line)));
      }
#line 781
      if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
#line 783
        goto while_break___4;
      }
      {
#line 784
      LineNumber ++;
#line 787
      tmp___8 = strchr((char const   *)p, '\n');
      }
#line 787
      if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 787
        if (! ((af->f_flags & 128L) != 0L)) {
          {
#line 789
          usrerr("554 5.3.5 alias too long");
          }
          {
#line 790
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 790
            c = sm_io_getc(af, -2);
            }
#line 790
            if (c != -1) {
#line 790
              if (! (c != 10)) {
#line 790
                goto while_break___7;
              }
            } else {
#line 790
              goto while_break___7;
            }
#line 792
            goto while_continue___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 793
          skipping = 1;
#line 794
          goto while_break___4;
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 798
    if (skipping) {
#line 799
      goto while_continue;
    }
#line 801
    if (! ((al.q_mailer)->m_flags[65UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 65UL % (8UL * sizeof(int ))))) {
      {
#line 803
      syserr("554 5.3.5 %s... cannot alias non-local names", al.q_paddr);
      }
#line 805
      goto while_continue;
    }
    {
#line 814
    tmp___9 = sm_strcasecmp((char const   *)al.q_user, "postmaster");
    }
#line 814
    if (tmp___9 == 0) {
      {
#line 815
      makelower(al.q_user);
      }
    }
    {
#line 817
    tmp___10 = strlen((char const   *)al.q_user);
#line 817
    lhssize = (int )tmp___10;
#line 818
    tmp___11 = strlen((char const   *)rhs);
#line 818
    rhssize = (int )tmp___11;
    }
#line 819
    if (rhssize > 0) {
#line 822
      p = rhs;
      {
#line 823
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 823
        if (((int )*p & -128) == 0) {
          {
#line 823
          tmp___12 = __ctype_b_loc();
          }
#line 823
          if (! ((int const   )*(*tmp___12 + (int )*p) & 8192)) {
#line 823
            goto while_break___8;
          }
        } else {
#line 823
          goto while_break___8;
        }
#line 824
        p ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 826
    if (rhssize == 0) {
      {
#line 828
      syserr("554 5.3.5 %.40s... missing value for alias", line);
      }
    } else
#line 826
    if ((int )*p == 0) {
      {
#line 828
      syserr("554 5.3.5 %.40s... missing value for alias", line);
      }
    } else {
      {
#line 834
      (*((map___0->map_class)->map_store))(map___0, al.q_user, rhs);
#line 837
      naliases ++;
#line 838
      bytes += (long )(lhssize + rhssize);
      }
#line 839
      if ((long )rhssize > longest) {
#line 840
        longest = (long )rhssize;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 857
  CurEnv->e_to = (char *)((void *)0);
#line 858
  FileName = (char *)((void *)0);
#line 859
  if (Verbose) {
    {
#line 860
    message("%s: %ld aliases, longest %ld bytes, %ld bytes total", map___0->map_file,
            naliases, longest, bytes);
    }
  } else
#line 859
  if (announcestats) {
    {
#line 860
    message("%s: %ld aliases, longest %ld bytes, %ld bytes total", map___0->map_file,
            naliases, longest, bytes);
    }
  }
#line 862
  if (LogLevel > 7) {
#line 862
    if (logstats) {
      {
#line 863
      sm_syslog(6, "*~*", "%s: %ld aliases, longest %ld bytes, %ld bytes total", map___0->map_file,
                naliases, longest, bytes);
      }
    }
  }
#line 866
  return;
}
}
#line 889 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c"
void forward(ADDRESS *user , ADDRESS **sendq , int aliaslevel , ENVELOPE *e ) 
{ 
  char *pp ;
  char *ep ;
  bool got_transient ;
  int err ;
  char buf___16[4096] ;
  struct stat st ;
  char *tmp ;
  char *curhost ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  bool tmp___6 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 900
  if ((int )tTdvect[27] >= 1) {
    {
#line 901
    sm_dprintf((char *)"forward(%s)\n", user->q_paddr);
    }
  }
#line 903
  if (! ((user->q_mailer)->m_flags[119UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 119UL % (8UL * sizeof(int ))))) {
#line 905
    return;
  } else
#line 903
  if (! ((int )user->q_state == 0)) {
#line 905
    return;
  }
#line 906
  if ((unsigned long )ForwardPath != (unsigned long )((void *)0)) {
#line 906
    if ((int )*ForwardPath == 0) {
#line 907
      return;
    }
  }
#line 908
  if ((unsigned long )user->q_home == (unsigned long )((void *)0)) {
    {
#line 910
    syserr("554 5.3.0 forward: no home");
#line 911
    user->q_home = (char *)"/no/such/directory";
    }
  }
  {
#line 915
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'z', user->q_home, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c",
                   915, SmHeapGroup);
#line 916
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'u', user->q_user, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c",
                   916, SmHeapGroup);
#line 917
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )2, 'h', user->q_host, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/alias.c",
                   917, SmHeapGroup);
  }
#line 918
  if ((unsigned long )ForwardPath == (unsigned long )((void *)0)) {
    {
#line 919
    ForwardPath = newstr("\201z/.forward");
    }
  }
#line 921
  got_transient = 0;
#line 922
  pp = ForwardPath;
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    if (! ((unsigned long )pp != (unsigned long )((void *)0))) {
#line 922
      goto while_break;
    }
    {
#line 928
    ep = strchr((char const   *)pp, ':');
    }
#line 929
    if ((unsigned long )ep != (unsigned long )((void *)0)) {
#line 930
      *ep = (char )'\000';
    }
    {
#line 931
    expand(pp, buf___16, (size_t )sizeof(buf___16), e);
    }
#line 932
    if ((unsigned long )ep != (unsigned long )((void *)0)) {
#line 933
      tmp = ep;
#line 933
      ep ++;
#line 933
      *tmp = (char )':';
    }
#line 934
    if ((int )buf___16[0] == 0) {
#line 935
      goto __Cont;
    }
#line 936
    if ((int )tTdvect[27] >= 3) {
      {
#line 937
      sm_dprintf((char *)"forward: trying %s\n", buf___16);
      }
    }
    {
#line 939
    err = include(buf___16, 1, user, sendq, aliaslevel, e);
    }
#line 940
    if (err == 0) {
#line 941
      goto while_break;
    } else {
      {
#line 942
      tmp___6 = transienterror(err);
      }
#line 942
      if (tmp___6) {
#line 945
        got_transient = 1;
#line 946
        if ((int )tTdvect[27] >= 2) {
          {
#line 947
          sm_dprintf((char *)"forward: transient error on %s\n", buf___16);
          }
        }
#line 949
        if (LogLevel > 2) {
          {
#line 951
          curhost = CurHostName;
#line 953
          CurHostName = (char *)((void *)0);
#line 954
          tmp___0 = sm_errstring(err);
#line 954
          sm_syslog(3, (char const   *)e->e_id, "forward %s: transient error: %s",
                    buf___16, tmp___0);
#line 957
          CurHostName = curhost;
          }
        }
      } else {
        {
#line 965
        if (err == 2) {
#line 965
          goto case_2;
        }
#line 969
        if (err == 262) {
#line 969
          goto case_262;
        }
#line 969
        if (err == 261) {
#line 969
          goto case_262;
        }
#line 990
        goto switch_default;
        case_2: /* CIL Label */ 
#line 966
        goto switch_break;
        case_262: /* CIL Label */ 
        case_261: /* CIL Label */ 
        {
#line 971
        tmp___1 = stat((char const   */* __restrict  */)(buf___16), (struct stat */* __restrict  */)(& st));
        }
#line 971
        if (tmp___1 < 0) {
          {
#line 971
          tmp___2 = __errno_location();
          }
#line 971
          if (*tmp___2 == 2) {
#line 973
            if (DontBlameSendmail[33UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 33UL % (8UL * sizeof(int )))) {
#line 975
              goto switch_break;
            }
          }
        }
        switch_default: /* CIL Label */ 
#line 991
        if (RunAsUid == 0U) {
#line 991
          tmp___4 = 2;
        } else {
#line 991
          tmp___4 = 10;
        }
#line 991
        if (LogLevel > tmp___4) {
          {
#line 992
          tmp___3 = sm_errstring(err);
#line 992
          sm_syslog(4, (char const   *)e->e_id, "forward %s: %s", buf___16, tmp___3);
          }
        }
#line 995
        if (Verbose) {
          {
#line 996
          tmp___5 = sm_errstring(err);
#line 996
          message("forward: %s: %s", buf___16, tmp___5);
          }
        }
#line 998
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 922
    pp = ep;
  }
  while_break: /* CIL Label */ ;
  }
#line 1002
  if ((unsigned long )pp == (unsigned long )((void *)0)) {
#line 1002
    if (got_transient) {
      {
#line 1010
      message("transient .forward open error: message queued");
#line 1011
      user->q_state = (short)3;
      }
#line 1012
      return;
    }
  }
#line 1014
  return;
}
}
#line 632 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
#line 665
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 665 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) putenv)(char *__string ) ;
#line 675
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 283 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 82 "/usr/include/sys/utsname.h"
extern  __attribute__((__nothrow__)) int uname(struct utsname *__name ) ;
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 471 "./sendmail.h"
MAILER *FileMailer  ;
#line 472 "./sendmail.h"
MAILER *InclMailer  ;
#line 473 "./sendmail.h"
MAILER *LocalMailer  ;
#line 474 "./sendmail.h"
MAILER *ProgMailer  ;
#line 475 "./sendmail.h"
MAILER *Mailer[26]  ;
#line 632 "./sendmail.h"
MACROS_T GlobalMacros  ;
#line 746 "./sendmail.h"
int MaxMciCache  ;
#line 747 "./sendmail.h"
time_t MciCacheTimeout  ;
#line 748 "./sendmail.h"
time_t MciInfoTimeout  ;
#line 960 "./sendmail.h"
ENVELOPE BlankEnvelope  ;
#line 1001 "./sendmail.h"
int NumPriorities  ;
#line 1002 "./sendmail.h"
struct priority Priorities[25]  ;
#line 1623 "./sendmail.h"
unsigned long PrivacyFlags  ;
#line 1717 "./sendmail.h"
struct milter *InputFilters[25]  ;
#line 1718 "./sendmail.h"
char *InputFilterList  ;
#line 1719 "./sendmail.h"
int MilterLogLevel  ;
#line 1939 "./sendmail.h"
int volatile   CurRunners  ;
#line 1940 "./sendmail.h"
int MaxQueueRun  ;
#line 1941 "./sendmail.h"
int MaxQueueChildren  ;
#line 1942 "./sendmail.h"
int MaxRunnersPerQueue  ;
#line 1943 "./sendmail.h"
int NiceQueueRun  ;
#line 1944 "./sendmail.h"
int NumQueue  ;
#line 1945 "./sendmail.h"
int QueueFileMode  ;
#line 1946 "./sendmail.h"
int QueueMode  ;
#line 1947 "./sendmail.h"
int QueueSortOrder  ;
#line 1948 "./sendmail.h"
time_t MinQueueAge  ;
#line 1949 "./sendmail.h"
time_t QueueIntvl  ;
#line 1950 "./sendmail.h"
char *QueueDir  ;
#line 1951 "./sendmail.h"
QUEUE_CHAR *QueueLimitId  ;
#line 1952 "./sendmail.h"
QUEUE_CHAR *QueueLimitQuarantine  ;
#line 1953 "./sendmail.h"
QUEUE_CHAR *QueueLimitRecipient  ;
#line 1954 "./sendmail.h"
QUEUE_CHAR *QueueLimitSender  ;
#line 1955 "./sendmail.h"
QUEUEGRP *Queue[51]  ;
#line 1992 "./sendmail.h"
struct __anonstruct_TimeOuts_64 TimeOuts  ;
#line 2147 "./sendmail.h"
bool AllowBogusHELO  ;
#line 2148 "./sendmail.h"
bool CheckAliases  ;
#line 2152 "./sendmail.h"
bool ColonOkInAddr  ;
#line 2154 "./sendmail.h"
bool ConfigFileRead  ;
#line 2156 "./sendmail.h"
bool DisConnected  ;
#line 2157 "./sendmail.h"
bool DontExpandCnames  ;
#line 2158 "./sendmail.h"
bool DontInitGroups  ;
#line 2159 "./sendmail.h"
bool DontLockReadFiles  ;
#line 2160 "./sendmail.h"
bool DontPruneRoutes  ;
#line 2161 "./sendmail.h"
bool ForkQueueRuns  ;
#line 2162 "./sendmail.h"
bool FromFlag  ;
#line 2163 "./sendmail.h"
bool GrabTo  ;
#line 2164 "./sendmail.h"
bool HasEightBits  ;
#line 2165 "./sendmail.h"
bool HasWildcardMX  ;
#line 2166 "./sendmail.h"
bool HoldErrs  ;
#line 2167 "./sendmail.h"
bool IgnoreHostStatus  ;
#line 2168 "./sendmail.h"
bool IgnrDot  ;
#line 2169 "./sendmail.h"
bool LogUsrErrs  ;
#line 2170 "./sendmail.h"
bool MatchGecos  ;
#line 2171 "./sendmail.h"
bool MeToo  ;
#line 2172 "./sendmail.h"
bool NoAlias  ;
#line 2173 "./sendmail.h"
bool NoConnect  ;
#line 2174 "./sendmail.h"
bool OnlyOneError  ;
#line 2175 "./sendmail.h"
bool QuickAbort  ;
#line 2177 "./sendmail.h"
bool RequiresDirfsync  ;
#line 2179 "./sendmail.h"
bool volatile   RestartWorkGroup  ;
#line 2180 "./sendmail.h"
bool RrtImpliesDsn  ;
#line 2181 "./sendmail.h"
bool SaveFrom  ;
#line 2182 "./sendmail.h"
bool SendMIMEErrors  ;
#line 2183 "./sendmail.h"
bool SevenBitInput  ;
#line 2184 "./sendmail.h"
bool SingleLineFromHeader  ;
#line 2185 "./sendmail.h"
bool SingleThreadDelivery  ;
#line 2189 "./sendmail.h"
bool volatile   StopRequest  ;
#line 2190 "./sendmail.h"
bool SuprErrs  ;
#line 2191 "./sendmail.h"
bool TryNullMXList  ;
#line 2192 "./sendmail.h"
bool UseMSP  ;
#line 2193 "./sendmail.h"
bool WorkAroundBrokenAAAA  ;
#line 2194 "./sendmail.h"
bool UseErrorsTo  ;
#line 2195 "./sendmail.h"
bool UseNameServer  ;
#line 2196 "./sendmail.h"
char InetMode  ;
#line 2197 "./sendmail.h"
char OpMode  ;
#line 2198 "./sendmail.h"
char SpaceSub  ;
#line 2199 "./sendmail.h"
int BadRcptThrottle  ;
#line 2200 "./sendmail.h"
int CheckpointInterval  ;
#line 2201 "./sendmail.h"
int ConfigLevel  ;
#line 2202 "./sendmail.h"
int ConnRateThrottle  ;
#line 2203 "./sendmail.h"
int volatile   CurChildren  ;
#line 2204 "./sendmail.h"
int CurrentLA  ;
#line 2205 "./sendmail.h"
int DefaultNotify  ;
#line 2206 "./sendmail.h"
int DelayLA  ;
#line 2207 "./sendmail.h"
int DontProbeInterfaces  ;
#line 2208 "./sendmail.h"
int Errors  ;
#line 2209 "./sendmail.h"
int ExitStat  ;
#line 2210 "./sendmail.h"
int FastSplit  ;
#line 2211 "./sendmail.h"
int FileMode  ;
#line 2212 "./sendmail.h"
int LineNumber  ;
#line 2213 "./sendmail.h"
int LogLevel  ;
#line 2214 "./sendmail.h"
int MaxAliasRecursion  ;
#line 2215 "./sendmail.h"
int MaxChildren  ;
#line 2216 "./sendmail.h"
int MaxForwardEntries  ;
#line 2217 "./sendmail.h"
int MaxHeadersLength  ;
#line 2218 "./sendmail.h"
int MaxHopCount  ;
#line 2219 "./sendmail.h"
int MaxMacroRecursion  ;
#line 2220 "./sendmail.h"
int MaxMimeFieldLength  ;
#line 2221 "./sendmail.h"
int MaxMimeHeaderLength  ;
#line 2222 "./sendmail.h"
int MaxNOOPCommands  ;
#line 2224 "./sendmail.h"
int MaxRcptPerMsg  ;
#line 2225 "./sendmail.h"
int MaxRuleRecursion  ;
#line 2230 "./sendmail.h"
int MimeMode  ;
#line 2231 "./sendmail.h"
int NoRecipientAction  ;
#line 2234 "./sendmail.h"
int Numfilesys  ;
#line 2235 "./sendmail.h"
int *PNumFileSys  ;
#line 2241 "./sendmail.h"
int QueueLA  ;
#line 2242 "./sendmail.h"
int RefuseLA  ;
#line 2243 "./sendmail.h"
time_t RejectLogInterval  ;
#line 2249 "./sendmail.h"
int SuperSafe  ;
#line 2250 "./sendmail.h"
int VendorCode  ;
#line 2251 "./sendmail.h"
int Verbose  ;
#line 2252 "./sendmail.h"
gid_t DefGid  ;
#line 2253 "./sendmail.h"
gid_t RealGid  ;
#line 2254 "./sendmail.h"
gid_t RunAsGid  ;
#line 2255 "./sendmail.h"
gid_t EffGid  ;
#line 2257 "./sendmail.h"
key_t ShmKey  ;
#line 2262 "./sendmail.h"
pid_t CurrentPid  ;
#line 2263 "./sendmail.h"
pid_t DaemonPid  ;
#line 2264 "./sendmail.h"
pid_t PidFilePid  ;
#line 2265 "./sendmail.h"
uid_t DefUid  ;
#line 2266 "./sendmail.h"
uid_t RealUid  ;
#line 2267 "./sendmail.h"
uid_t RunAsUid  ;
#line 2268 "./sendmail.h"
uid_t TrustedUid  ;
#line 2269 "./sendmail.h"
size_t DataFileBufferSize  ;
#line 2270 "./sendmail.h"
time_t DeliverByMin  ;
#line 2271 "./sendmail.h"
time_t DialDelay  ;
#line 2272 "./sendmail.h"
time_t SafeAlias  ;
#line 2273 "./sendmail.h"
time_t ServiceCacheMaxAge  ;
#line 2274 "./sendmail.h"
size_t XscriptFileBufferSize  ;
#line 2275 "./sendmail.h"
mode_t OldUmask  ;
#line 2276 "./sendmail.h"
long MaxMessageSize  ;
#line 2277 "./sendmail.h"
long MinBlocksFree  ;
#line 2278 "./sendmail.h"
long QueueFactor  ;
#line 2279 "./sendmail.h"
long WkClassFact  ;
#line 2280 "./sendmail.h"
long WkRecipFact  ;
#line 2281 "./sendmail.h"
long WkTimeFact  ;
#line 2282 "./sendmail.h"
char *ControlSocketName  ;
#line 2283 "./sendmail.h"
char *CurHostName  ;
#line 2284 "./sendmail.h"
char *DeadLetterDrop  ;
#line 2285 "./sendmail.h"
char *DefUser  ;
#line 2286 "./sendmail.h"
char *DefaultCharSet  ;
#line 2287 "./sendmail.h"
char *DoubleBounceAddr  ;
#line 2288 "./sendmail.h"
char *ErrMsgFile  ;
#line 2289 "./sendmail.h"
char *FallbackMX  ;
#line 2290 "./sendmail.h"
char *FallbackSmartHost  ;
#line 2291 "./sendmail.h"
char *FileName  ;
#line 2292 "./sendmail.h"
char *ForwardPath  ;
#line 2296 "./sendmail.h"
char *HelpFile  ;
#line 2297 "./sendmail.h"
char *HostStatDir  ;
#line 2298 "./sendmail.h"
char *HostsFile  ;
#line 2300 "./sendmail.h"
char *MustQuoteChars  ;
#line 2301 "./sendmail.h"
char *MyHostName  ;
#line 2302 "./sendmail.h"
char *OperatorChars  ;
#line 2303 "./sendmail.h"
char *PidFile  ;
#line 2304 "./sendmail.h"
char *PostMasterCopy  ;
#line 2305 "./sendmail.h"
char *ProcTitlePrefix  ;
#line 2306 "./sendmail.h"
char *RealHostName  ;
#line 2307 "./sendmail.h"
char *RealUserName  ;
#line 2308 "./sendmail.h"
char * volatile  RestartRequest  ;
#line 2309 "./sendmail.h"
char *RunAsUserName  ;
#line 2310 "./sendmail.h"
char *SafeFileEnv  ;
#line 2311 "./sendmail.h"
char *ServiceSwitchFile  ;
#line 2312 "./sendmail.h"
char * volatile  ShutdownRequest  ;
#line 2313 "./sendmail.h"
char *SmtpGreeting  ;
#line 2314 "./sendmail.h"
char *SmtpPhase  ;
#line 2315 "./sendmail.h"
char SmtpError[2048]  ;
#line 2316 "./sendmail.h"
char *StatFile  ;
#line 2317 "./sendmail.h"
char *TimeZoneSpec  ;
#line 2318 "./sendmail.h"
char *UdbSpec  ;
#line 2319 "./sendmail.h"
char *UnixFromLine  ;
#line 2320 "./sendmail.h"
char **ExternalEnviron  ;
#line 2321 "./sendmail.h"
char **SaveArgv  ;
#line 2322 "./sendmail.h"
BITMAP256 DontBlameSendmail  ;
#line 2323 "./sendmail.h"
SM_FILE_T *InChannel  ;
#line 2324 "./sendmail.h"
SM_FILE_T *OutChannel  ;
#line 2325 "./sendmail.h"
SM_FILE_T *TrafficLogFile  ;
#line 2329 "./sendmail.h"
ENVELOPE *CurEnv  ;
#line 2330 "./sendmail.h"
char *RuleSetNames[200]  ;
#line 2331 "./sendmail.h"
char *UserEnviron[101]  ;
#line 2332 "./sendmail.h"
struct rewrite *RewriteRules[200]  ;
#line 2333 "./sendmail.h"
struct termescape TermEscape  ;
#line 2334 "./sendmail.h"
union bigsockaddr ConnectOnlyTo  ;
#line 2335 "./sendmail.h"
union bigsockaddr RealHostAddr  ;
#line 2339 "./sendmail.h"
int ConnectionRateWindowSize  ;
#line 38 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static SM_DEBUG_T DebugNoPRestart  =    {SmDebugMagic, (SM_ATOMIC_UINT_T )-1, (char *)"no_persistent_restart", (char *)"@(#)$Debug: no_persistent_restart - don\'t restart, log only $",
    (SM_DEBUG_T *)((void *)0)};
#line 42
static void dump_class(STAB *s , int id ) ;
#line 43
static void obsolete(char **argv ) ;
#line 44
static void testmodeline(char *line , ENVELOPE *e ) ;
#line 45
static char *getextenv(char const   *envar ) ;
#line 46
static void sm_printoptions(char **options ) ;
#line 47
static void intindebug(int sig ) ;
#line 48
static void sighup(int sig ) ;
#line 49
static void sigpipe(int sig ) ;
#line 50
static void sigterm(int sig ) ;
#line 52
static void sigusr1(int sig ) ;
#line 92 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
char *FullName  ;
#line 94 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static ENVELOPE MainEnvelope  ;
#line 95 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
ADDRESS NullAddress  = 
#line 95
     {(char *)"", (char *)"", (char *)((void *)0), (char *)"", (struct mailer *)0, 0UL,
    0U, 0U, (char *)0, (char *)0, (struct address *)0, (struct address *)0, (char *)0,
    (struct address *)0, (struct address *)0, (char *)0, (char *)0, (char *)0, (char *)0,
    0L, (char *)0, (short)0, (char *)0, 0, 0, (char *)0};
#line 97 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
char *CommandLineArgs  ;
#line 98 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
bool Warn_Q_option  =    0;
#line 99 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static int MissingFds  =    0;
#line 100 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
char *Mbdb  =    (char *)"pw";
#line 103 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
gid_t InitialGidSet[65536]  ;
#line 117 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
unsigned int SubmitMode  ;
#line 118 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
int SyslogPrefixLen  ;
#line 186
int main(int argc , char **argv , char **envp ) ;
#line 186 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static time_t starttime  =    (time_t )0;
#line 190 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static char rnamebuf[256]  ;
#line 148 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
int main(int argc , char **argv , char **envp ) 
{ 
  register char *p ;
  char **av___0 ;
  char *ep ;
  char *from ;
  STAB *st ;
  register int i ;
  int j ;
  int dp ;
  int fill_errno ;
  int qgrp ;
  bool safecf ;
  BITMAP256 *p_flags ;
  bool warn_C_flag ;
  bool auth ;
  char warn_f_flag ;
  bool run_in_foreground ;
  bool queuerun ;
  bool debug ;
  struct passwd *pw ;
  struct hostent *hp ;
  char *nullserver ;
  char *authinfo ;
  char *sysloglabel ;
  char *conffile ;
  char *queuegroup ;
  char *quarantining ;
  bool extraprivs ;
  bool forged ;
  bool negate ;
  bool queuepersistent ;
  bool foregroundqueue ;
  bool save_val ;
  int cftype ;
  SM_FILE_T *smdebug ;
  struct stat traf_st ;
  char buf___16[2048] ;
  char jbuf[64] ;
  char *emptyenviron[1] ;
  QUEUE_CHAR *new ;
  ENVELOPE *e ;
  __uid_t tmp ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __gid_t tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  SM_FILE_T *tmp___20 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  unsigned short const   **tmp___25 ;
  __uid_t tmp___26 ;
  __uid_t tmp___27 ;
  __gid_t tmp___28 ;
  __gid_t tmp___29 ;
  __uid_t tmp___30 ;
  __uid_t tmp___31 ;
  char **tmp___32 ;
  size_t tmp___33 ;
  char *tmp___34 ;
  int h ;
  int tmp___35 ;
  char *tmp___36 ;
  char **tmp___37 ;
  size_t tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tz ;
  int tzlen ;
  size_t tmp___41 ;
  struct __res_state *tmp___42 ;
  struct __res_state *tmp___43 ;
  struct __res_state *tmp___44 ;
  struct __res_state *tmp___45 ;
  struct __res_state *tmp___46 ;
  struct __res_state *tmp___47 ;
  struct __res_state *tmp___48 ;
  struct __res_state *tmp___49 ;
  struct __res_state *tmp___50 ;
  struct __res_state *tmp___51 ;
  int *tmp___52 ;
  struct utsname utsname ;
  int *tmp___53 ;
  char const   *tmp___54 ;
  int tmp___55 ;
  struct in_addr ia ;
  char ipbuf[103] ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  int tmp___59 ;
  long tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  char *tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  char *tmp___67 ;
  size_t tmp___68 ;
  void *tmp___69 ;
  size_t tmp___70 ;
  void *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  bool tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  char *tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char mbuf___0[2048] ;
  char const   *tmp___89 ;
  uid_t new_uid ;
  __uid_t tmp___90 ;
  __uid_t tmp___91 ;
  __uid_t tmp___92 ;
  int tmp___93 ;
  __uid_t tmp___94 ;
  __uid_t tmp___95 ;
  __uid_t tmp___96 ;
  sigfunc_t tmp___97 ;
  char *tmp___98 ;
  __uid_t tmp___99 ;
  __uid_t tmp___100 ;
  struct __res_state *tmp___101 ;
  struct __res_state *tmp___102 ;
  char pidpath[4096] ;
  char *tmp___103 ;
  char *tmp___104 ;
  SM_FILE_T *tmp___105 ;
  char *tmp___106 ;
  SM_FILE_T *tmp___107 ;
  char *tmp___108 ;
  SM_FILE_T *tmp___109 ;
  char *tmp___110 ;
  SM_FILE_T *tmp___111 ;
  bool tmp___112 ;
  bool tmp___113 ;
  char *action ;
  bool tmp___114 ;
  sigfunc_t tmp___115 ;
  __uid_t tmp___116 ;
  sigfunc_t tmp___117 ;
  char *full ;
  char *tmp___118 ;
  char *tmp___119 ;
  bool tmp___120 ;
  char *_newval ;
  char *tmp___121 ;
  char *_newval___0 ;
  char *tmp___122 ;
  char *tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int *tmp___137 ;
  char const   *tmp___138 ;
  bool tmp___139 ;
  struct stat stbuf ;
  int tmp___140 ;
  int j___0 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  SM_FILE_T *tmp___144 ;
  SM_RPOOL_T *tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  SM_EXC_HANDLER_T _h ;
  char *tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  bool tmp___153 ;
  SM_EXC_T *exc  __attribute__((__unused__)) ;
  int tmp___154 ;
  pid_t pid ;
  int rwgflags ;
  int status ;
  pid_t ret ;
  int *tmp___155 ;
  int *tmp___156 ;
  int *tmp___157 ;
  union __anonunion___u_65___1 __u ;
  char dtype[200] ;
  char *tmp___158 ;
  char const   *tmp___159 ;
  int tmp___160 ;
  char *tmp___161 ;
  int tmp___162 ;
  int status___0 ;
  pid_t ret___0 ;
  int group ;
  int *tmp___163 ;
  int *tmp___164 ;
  int *tmp___165 ;
  union __anonunion___u_66___1 __u___0 ;
  union __anonunion___u_67___1 __u___1 ;
  union __anonunion___u_68___1 __u___2 ;
  union __anonunion___u_69___0 __u___3 ;
  union __anonunion___u_70___0 __u___4 ;
  bool tmp___166 ;
  char qtype[200] ;
  char *tmp___167 ;
  bool tmp___168 ;
  int tmp___169 ;
  SM_RPOOL_T *tmp___170 ;
  char pbuf[20] ;
  char ipbuf___0[103] ;
  char *tmp___171 ;
  int tmp___172 ;
  int tmp___173 ;
  int tmp___174 ;
  char *tmp___175 ;
  int tmp___176 ;
  int tmp___177 ;
  int tmp___178 ;
  char *tmp___179 ;
  char *tmp___180 ;
  SM_RPOOL_T *tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  bool tmp___184 ;
  int tmp___185 ;
  char *fv ;
  size_t tmp___186 ;
  char *tmp___187 ;
  size_t tmp___188 ;
  void *tmp___189 ;
  char *tmp___190 ;
  char *tmp___191 ;
  char *tmp___192 ;
  char *tmp___193 ;
  int savederrors ;
  unsigned long savedflags ;
  int tmp___194 ;
  int tmp___195 ;
  int *tmp___196 ;
  bool tmp___197 ;
  ENVELOPE *next ;
  SM_FILE_T *tmp___198 ;
  struct __res_state *tmp___199 ;
  struct __res_state *tmp___200 ;
  int tmp___201 ;
  void *__cil_tmp285 ;
  void *__cil_tmp286 ;
  void *__cil_tmp287 ;
  void *__cil_tmp288 ;
  void *__cil_tmp289 ;
  void *__cil_tmp290 ;
  void *__cil_tmp291 ;
  void *__cil_tmp292 ;
  void *__cil_tmp293 ;
  void *__cil_tmp294 ;
  char *__cil_tmp295 ;
  char *__cil_tmp296 ;
  char *__cil_tmp297 ;
  char *__cil_tmp298 ;
  char *__cil_tmp299 ;
  char *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;
  char *__cil_tmp345 ;
  char *__cil_tmp346 ;
  char *__cil_tmp347 ;
  char *__cil_tmp348 ;
  char *__cil_tmp349 ;
  char *__cil_tmp350 ;
  char *__cil_tmp351 ;
  char *__cil_tmp352 ;
  char *__cil_tmp353 ;
  char *__cil_tmp354 ;
  char *__cil_tmp355 ;
  char *__cil_tmp356 ;
  char *__cil_tmp357 ;
  char *__cil_tmp358 ;
  char *__cil_tmp359 ;
  char *__cil_tmp360 ;
  char *__cil_tmp361 ;
  char *__cil_tmp362 ;
  char *__cil_tmp363 ;
  char *__cil_tmp364 ;
  char *__cil_tmp365 ;
  char *__cil_tmp366 ;
  char *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;
  char *__cil_tmp370 ;
  char *__cil_tmp371 ;
  char *__cil_tmp372 ;
  char *__cil_tmp373 ;
  char *__cil_tmp374 ;
  char *__cil_tmp375 ;
  char *__cil_tmp376 ;
  char *__cil_tmp377 ;
  char *__cil_tmp378 ;
  char *__cil_tmp379 ;
  char *__cil_tmp380 ;
  char *__cil_tmp381 ;
  char *__cil_tmp382 ;
  char *__cil_tmp383 ;
  char *__cil_tmp384 ;
  char *__cil_tmp385 ;
  char *__cil_tmp386 ;
  char *__cil_tmp387 ;
  char *__cil_tmp388 ;
  char *__cil_tmp389 ;
  char *__cil_tmp390 ;
  char *__cil_tmp391 ;
  char *__cil_tmp392 ;
  char *__cil_tmp393 ;
  char *__cil_tmp394 ;
  char *__cil_tmp395 ;
  char *__cil_tmp396 ;
  char *__cil_tmp397 ;
  char *__cil_tmp398 ;
  char *__cil_tmp399 ;
  char *__cil_tmp400 ;
  char *__cil_tmp401 ;
  char *__cil_tmp402 ;
  char *__cil_tmp403 ;
  char *__cil_tmp404 ;
  char *__cil_tmp405 ;
  char *__cil_tmp406 ;
  char *__cil_tmp407 ;
  char *__cil_tmp408 ;
  char *__cil_tmp409 ;
  char *__cil_tmp410 ;
  char *__cil_tmp411 ;
  char *__cil_tmp412 ;
  char *__cil_tmp413 ;
  char *__cil_tmp414 ;
  char *__cil_tmp415 ;
  char *__cil_tmp416 ;
  char *__cil_tmp417 ;
  char *__cil_tmp418 ;
  char *__cil_tmp419 ;
  char *__cil_tmp420 ;
  char *__cil_tmp421 ;
  char *__cil_tmp422 ;
  char *__cil_tmp423 ;
  char *__cil_tmp424 ;
  char *__cil_tmp425 ;
  char *__cil_tmp426 ;
  char *__cil_tmp427 ;
  char *__cil_tmp428 ;
  char *__cil_tmp429 ;
  char *__cil_tmp430 ;
  char *__cil_tmp431 ;
  char *__cil_tmp432 ;
  char *__cil_tmp433 ;
  char *__cil_tmp434 ;
  char *__cil_tmp435 ;
  char *__cil_tmp436 ;
  char *__cil_tmp437 ;
  char *__cil_tmp438 ;
  char *__cil_tmp439 ;
  char *__cil_tmp440 ;
  char *__cil_tmp441 ;
  char *__cil_tmp442 ;
  char *__cil_tmp443 ;
  char *__cil_tmp444 ;
  char *__cil_tmp445 ;
  char *__cil_tmp446 ;
  char *__cil_tmp447 ;
  char *__cil_tmp448 ;
  char *__cil_tmp449 ;
  char *__cil_tmp450 ;
  char *__cil_tmp451 ;
  char *__cil_tmp452 ;
  char *__cil_tmp453 ;
  char *__cil_tmp454 ;
  char *__cil_tmp455 ;
  char *__cil_tmp456 ;
  char *__cil_tmp457 ;
  char *__cil_tmp458 ;
  char *__cil_tmp459 ;
  char *__cil_tmp460 ;
  char *__cil_tmp461 ;
  char *__cil_tmp462 ;
  char *__cil_tmp463 ;
  char *__cil_tmp464 ;
  char *__cil_tmp465 ;
  char *__cil_tmp466 ;
  char *__cil_tmp467 ;
  char *__cil_tmp468 ;
  char *__cil_tmp469 ;
  char *__cil_tmp470 ;
  char *__cil_tmp471 ;
  char *__cil_tmp472 ;
  char *__cil_tmp473 ;
  char *__cil_tmp474 ;
  char *__cil_tmp475 ;
  char *__cil_tmp476 ;
  char *__cil_tmp477 ;
  char *__cil_tmp478 ;
  char *__cil_tmp479 ;
  char *__cil_tmp480 ;
  char *__cil_tmp481 ;
  char *__cil_tmp482 ;
  char *__cil_tmp483 ;
  char *__cil_tmp484 ;
  char *__cil_tmp485 ;
  char *__cil_tmp486 ;
  char *__cil_tmp487 ;
  char *__cil_tmp488 ;
  char *__cil_tmp489 ;
  char *__cil_tmp490 ;
  char *__cil_tmp491 ;
  char *__cil_tmp492 ;
  char *__cil_tmp493 ;
  char *__cil_tmp494 ;
  char *__cil_tmp495 ;
  char *__cil_tmp496 ;
  char *__cil_tmp497 ;
  char *__cil_tmp498 ;
  char *__cil_tmp499 ;
  char *__cil_tmp500 ;
  char *__cil_tmp501 ;
  char *__cil_tmp502 ;
  char *__cil_tmp503 ;
  char *__cil_tmp504 ;
  char *__cil_tmp505 ;
  char *__cil_tmp506 ;
  char *__cil_tmp507 ;
  char *__cil_tmp508 ;
  char *__cil_tmp509 ;
  char *__cil_tmp510 ;
  char *__cil_tmp511 ;
  char *__cil_tmp512 ;
  char *__cil_tmp513 ;
  char *__cil_tmp514 ;
  char *__cil_tmp515 ;
  char *__cil_tmp516 ;
  char *__cil_tmp517 ;
  char *__cil_tmp518 ;
  char *__cil_tmp519 ;
  char *__cil_tmp520 ;
  char *__cil_tmp521 ;
  char *__cil_tmp522 ;
  char *__cil_tmp523 ;
  char *__cil_tmp524 ;
  char *__cil_tmp525 ;
  char *__cil_tmp526 ;
  char *__cil_tmp527 ;
  char *__cil_tmp528 ;
  char *__cil_tmp529 ;
  char *__cil_tmp530 ;
  char *__cil_tmp531 ;
  char *__cil_tmp532 ;
  char *__cil_tmp533 ;
  char *__cil_tmp534 ;
  char *__cil_tmp535 ;
  char *__cil_tmp536 ;
  char *__cil_tmp537 ;
  char *__cil_tmp538 ;
  char *__cil_tmp539 ;
  char *__cil_tmp540 ;
  char *__cil_tmp541 ;
  char *__cil_tmp542 ;
  char *__cil_tmp543 ;
  char *__cil_tmp544 ;
  char *__cil_tmp545 ;
  char *__cil_tmp546 ;
  char *__cil_tmp547 ;
  char *__cil_tmp548 ;
  char *__cil_tmp549 ;
  char *__cil_tmp550 ;
  char *__cil_tmp551 ;
  char *__cil_tmp552 ;
  char *__cil_tmp553 ;
  char *__cil_tmp554 ;
  char *__cil_tmp555 ;
  char *__cil_tmp556 ;
  char *__cil_tmp557 ;
  char *__cil_tmp558 ;
  char *__cil_tmp559 ;
  char *__cil_tmp560 ;
  char *__cil_tmp561 ;
  char *__cil_tmp562 ;
  char *__cil_tmp563 ;
  char *__cil_tmp564 ;
  char *__cil_tmp565 ;
  char *__cil_tmp566 ;
  char *__cil_tmp567 ;
  char *__cil_tmp568 ;
  char *__cil_tmp569 ;
  char *__cil_tmp570 ;
  char *__cil_tmp571 ;
  char *__cil_tmp572 ;
  char *__cil_tmp573 ;
  char *__cil_tmp574 ;
  char *__cil_tmp575 ;
  char *__cil_tmp576 ;
  char *__cil_tmp577 ;
  char *__cil_tmp578 ;
  char *__cil_tmp579 ;
  char *__cil_tmp580 ;
  char *__cil_tmp581 ;
  char *__cil_tmp582 ;
  char *__cil_tmp583 ;
  char *__cil_tmp584 ;
  char *__cil_tmp585 ;
  char *__cil_tmp586 ;
  char *__cil_tmp587 ;
  char *__cil_tmp588 ;
  char *__cil_tmp589 ;
  char *__cil_tmp590 ;
  char *__cil_tmp591 ;
  char *__cil_tmp592 ;
  char *__cil_tmp593 ;
  char *__cil_tmp594 ;
  char *__cil_tmp595 ;
  char *__cil_tmp596 ;
  char *__cil_tmp597 ;
  char *__cil_tmp598 ;
  char *__cil_tmp599 ;
  char *__cil_tmp600 ;
  char *__cil_tmp601 ;
  char *__cil_tmp602 ;
  char *__cil_tmp603 ;
  char *__cil_tmp604 ;
  char *__cil_tmp605 ;
  char *__cil_tmp606 ;
  char *__cil_tmp607 ;
  char *__cil_tmp608 ;
  char *__cil_tmp609 ;
  char *__cil_tmp610 ;
  char *__cil_tmp611 ;
  char *__cil_tmp612 ;
  char *__cil_tmp613 ;
  char *__cil_tmp614 ;
  char *__cil_tmp615 ;
  char *__cil_tmp616 ;
  char *__cil_tmp617 ;
  char *__cil_tmp618 ;
  char *__cil_tmp619 ;

  {
  {
#line 163
  qgrp = -1;
#line 164
  safecf = 1;
#line 165
  p_flags = (BITMAP256 *)((void *)0);
#line 166
  warn_C_flag = 0;
#line 167
  auth = 1;
#line 168
  warn_f_flag = (char )'\000';
#line 169
  run_in_foreground = 0;
#line 170
  queuerun = 0;
#line 170
  debug = 0;
#line 173
  nullserver = (char *)((void *)0);
#line 174
  authinfo = (char *)((void *)0);
#line 175
  sysloglabel = (char *)((void *)0);
#line 176
  conffile = (char *)((void *)0);
#line 177
  queuegroup = (char *)((void *)0);
#line 178
  quarantining = (char *)((void *)0);
#line 181
  queuepersistent = 0;
#line 182
  foregroundqueue = 0;
#line 214
  sm_exc_newthread(& fatal_error);
#line 217
  InChannel = & SmIoF[0];
#line 218
  OutChannel = & SmIoF[1];
  }
#line 226
  if (starttime != 0L) {
    {
#line 228
    syserr("main: reentered!");
#line 229
    abort();
    }
  }
  {
#line 231
  starttime = curtime();
#line 234
  TermEscape.te_rv_off = (char *)"";
#line 234
  TermEscape.te_rv_on = TermEscape.te_rv_off;
#line 236
  RealUid = getuid();
#line 237
  RealGid = getgid();
  }
#line 240
  if (RealUid != 0U) {
    {
#line 240
    tmp = geteuid();
#line 240
    tmp___0 = getuid();
    }
#line 240
    if (tmp != tmp___0) {
#line 240
      tmp___3 = 1;
    } else {
      {
#line 240
      tmp___1 = getegid();
#line 240
      tmp___2 = getgid();
      }
#line 240
      if (tmp___1 != tmp___2) {
#line 240
        tmp___3 = 1;
      } else {
#line 240
        tmp___3 = 0;
      }
    }
  } else {
#line 240
    tmp___3 = 0;
  }
  {
#line 240
  extraprivs = tmp___3;
#line 243
  CurrentPid = getpid();
#line 246
  cftype = 0;
#line 249
  DtableSize = getdtsize();
  }
#line 250
  if (DtableSize > 256) {
#line 251
    DtableSize = 256;
  }
  {
#line 259
  tmp___4 = __errno_location();
#line 259
  fill_errno = 0;
#line 259
  *tmp___4 = fill_errno;
#line 260
  fill_fd(0, (char *)((void *)0));
#line 261
  tmp___6 = __errno_location();
  }
#line 261
  if (*tmp___6 != 0) {
    {
#line 262
    tmp___5 = __errno_location();
#line 262
    fill_errno = *tmp___5;
    }
  }
  {
#line 263
  fill_fd(1, (char *)((void *)0));
#line 264
  tmp___8 = __errno_location();
  }
#line 264
  if (*tmp___8 != 0) {
    {
#line 265
    tmp___7 = __errno_location();
#line 265
    fill_errno = *tmp___7;
    }
  }
  {
#line 266
  fill_fd(2, (char *)((void *)0));
#line 267
  tmp___10 = __errno_location();
  }
#line 267
  if (*tmp___10 != 0) {
    {
#line 268
    tmp___9 = __errno_location();
#line 268
    fill_errno = *tmp___9;
    }
  }
  {
#line 270
  sm_closefrom(3, DtableSize);
#line 271
  tmp___11 = __errno_location();
#line 271
  *tmp___11 = 0;
#line 272
  smdebug = (SM_FILE_T *)((void *)0);
#line 279
  openlog("sendmail", 1, 2 << 3);
#line 291
  seed_random();
#line 294
  init_md(argc, argv);
#line 297
  SyslogPrefixLen = 42;
#line 300
  Errors = 0;
#line 301
  ExitStat = 0;
#line 303
  SubmitMode = 0U;
#line 305
  checkfd012((char *)"after openlog");
#line 308
  tTsetup(tTdvect, (unsigned int )sizeof(tTdvect), (char *)"0-99.1,*_trace_*.1");
#line 312
  i = getgroups(65536, InitialGidSet);
  }
#line 313
  if (i <= 0) {
#line 315
    InitialGidSet[0] = (gid_t )-1;
#line 316
    i = 0;
  }
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! (i < 65536)) {
#line 318
      goto while_break;
    }
#line 319
    tmp___12 = i;
#line 319
    i ++;
#line 319
    InitialGidSet[tmp___12] = InitialGidSet[0];
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  dp = drop_privileges(0);
  }
#line 324
  if (ExitStat == 0) {
#line 324
    ExitStat = dp;
  } else
#line 324
  if (ExitStat == 75) {
#line 324
    ExitStat = dp;
  }
#line 328
  if (! extraprivs) {
    {
#line 331
    sm_signal(10, & sigusr1);
    }
  } else {
    {
#line 336
    sm_signal(10, (void (*)(int  ))1);
    }
  }
  {
#line 341
  initsetproctitle(argc, argv, envp);
#line 344
  obsolete(argv);
#line 352
  OpMode = (char )'m';
#line 353
  av___0 = argv;
#line 354
  p = strrchr((char const   *)*av___0, '/');
#line 355
  tmp___13 = p;
#line 355
  p ++;
  }
#line 355
  if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
#line 356
    p = *av___0;
  }
  {
#line 357
  tmp___18 = strcmp((char const   *)p, "newaliases");
  }
#line 357
  if (tmp___18 == 0) {
#line 358
    OpMode = (char )'i';
  } else {
    {
#line 359
    tmp___17 = strcmp((char const   *)p, "mailq");
    }
#line 359
    if (tmp___17 == 0) {
#line 360
      OpMode = (char )'p';
    } else {
      {
#line 361
      tmp___16 = strcmp((char const   *)p, "smtpd");
      }
#line 361
      if (tmp___16 == 0) {
#line 362
        OpMode = (char )'d';
      } else {
        {
#line 363
        tmp___15 = strcmp((char const   *)p, "hoststat");
        }
#line 363
        if (tmp___15 == 0) {
#line 364
          OpMode = (char )'h';
        } else {
          {
#line 365
          tmp___14 = strcmp((char const   *)p, "purgestat");
          }
#line 365
          if (tmp___14 == 0) {
#line 366
            OpMode = (char )'H';
          }
        }
      }
    }
  }
#line 379
  opterr = 0;
  {
#line 380
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 380
    j = getopt(argc, (char * const  *)argv, "A:B:b:C:cD:d:e:F:f:Gh:IiL:M:mN:nO:o:p:Q:q:R:r:sTtV:vX:");
    }
#line 380
    if (! (j != -1)) {
#line 380
      goto while_break___0;
    }
    {
#line 384
    if (j == 98) {
#line 384
      goto case_98;
    }
#line 416
    if (j == 68) {
#line 416
      goto case_68___0;
    }
#line 437
    if (j == 100) {
#line 437
      goto case_100___0;
    }
#line 445
    if (j == 71) {
#line 445
      goto case_71;
    }
#line 449
    if (j == 76) {
#line 449
      goto case_76;
    }
#line 465
    if (j == 113) {
#line 465
      goto case_113;
    }
#line 465
    if (j == 81) {
#line 465
      goto case_113;
    }
#line 382
    goto switch_break;
    case_98: /* CIL Label */ 
#line 385
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
#line 385
      j = ' ';
    } else {
#line 385
      j = (int )*optarg;
    }
    {
#line 399
    if (j == 97) {
#line 399
      goto case_97;
    }
#line 399
    if (j == 72) {
#line 399
      goto case_97;
    }
#line 399
    if (j == 104) {
#line 399
      goto case_97;
    }
#line 399
    if (j == 80) {
#line 399
      goto case_97;
    }
#line 399
    if (j == 112) {
#line 399
      goto case_97;
    }
#line 399
    if (j == 116) {
#line 399
      goto case_97;
    }
#line 399
    if (j == 118) {
#line 399
      goto case_97;
    }
#line 399
    if (j == 109) {
#line 399
      goto case_97;
    }
#line 399
    if (j == 105) {
#line 399
      goto case_97;
    }
#line 399
    if (j == 115) {
#line 399
      goto case_97;
    }
#line 399
    if (j == 68) {
#line 399
      goto case_97;
    }
#line 399
    if (j == 100) {
#line 399
      goto case_97;
    }
#line 403
    if (j == 122) {
#line 403
      goto case_122;
    }
#line 408
    goto switch_default;
    case_97: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 400
    OpMode = (char )j;
#line 401
    goto switch_break___0;
    case_122: /* CIL Label */ 
    {
#line 404
    sm_io_fprintf(& SmIoF[1], -2, "Frozen configurations unsupported\n");
    }
#line 406
    return (64);
    switch_default: /* CIL Label */ 
    {
#line 409
    sm_io_fprintf(& SmIoF[1], -2, "Invalid operation mode %c\n", j);
    }
#line 412
    return (64);
    switch_break___0: /* CIL Label */ ;
    }
#line 414
    goto switch_break;
    case_68___0: /* CIL Label */ 
#line 417
    if (debug) {
      {
#line 419
      tmp___19 = __errno_location();
#line 419
      *tmp___19 = 0;
#line 420
      syserr("-D file must be before -d");
#line 421
      ExitStat = 64;
      }
#line 422
      goto switch_break;
    }
    {
#line 424
    dp = drop_privileges(1);
    }
#line 425
    if (ExitStat == 0) {
#line 425
      ExitStat = dp;
    } else
#line 425
    if (ExitStat == 75) {
#line 425
      ExitStat = dp;
    }
    {
#line 426
    smdebug = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)optarg,
                         4, (void const   *)((void *)0));
    }
#line 428
    if ((unsigned long )smdebug == (unsigned long )((void *)0)) {
      {
#line 430
      syserr("cannot open %s", optarg);
#line 431
      ExitStat = 73;
      }
#line 432
      goto switch_break;
    }
    {
#line 434
    sm_debug_setfile(smdebug);
    }
#line 435
    goto switch_break;
    case_100___0: /* CIL Label */ 
    {
#line 438
    debug = 1;
#line 439
    tTflag(optarg);
#line 440
    tmp___20 = sm_debug_file();
#line 440
    sm_io_setvbuf(tmp___20, -2, (char *)((void *)0), 2, (size_t )4096);
    }
#line 443
    goto switch_break;
    case_71: /* CIL Label */ 
#line 446
    SubmitMode = 1U;
#line 447
    goto switch_break;
    case_76: /* CIL Label */ 
#line 450
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
      {
#line 452
      sm_io_fprintf(& SmIoF[1], -2, "option requires an argument -- \'%c\'", (int )((char )j));
      }
#line 455
      return (64);
    }
    {
#line 457
    tmp___24 = strlen((char const   *)optarg);
    }
#line 457
    if (tmp___24 < 32U) {
      {
#line 457
      tmp___22 = strlen((char const   *)optarg);
#line 457
      tmp___23 = tmp___22;
      }
    } else {
#line 457
      tmp___23 = (size_t )32;
    }
    {
#line 457
    j = (int )(tmp___23 + 1U);
#line 458
    sysloglabel = xalloc_tagged(j, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                                458);
#line 459
    sm_strlcpy(sysloglabel, (char const   *)optarg, j);
#line 460
    SyslogPrefixLen = 34 + j;
    }
#line 462
    goto switch_break;
    case_113: /* CIL Label */ 
    case_81: /* CIL Label */ 
#line 467
    queuerun = 1;
#line 468
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 471
  opterr = 1;
#line 474
  if (extraprivs) {
#line 474
    if (queuerun) {
#line 474
      if (debug) {
        {
#line 476
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Can not use -d with -q.  Disabling debugging.\n");
#line 478
        sm_debug_close();
#line 479
        sm_debug_setfile((SM_FILE_T *)((void *)0));
#line 480
        memset((void *)(tTdvect), '\000', (size_t )sizeof(tTdvect));
        }
      }
    }
  }
#line 484
  if ((unsigned long )sysloglabel != (unsigned long )((void *)0)) {
#line 487
    p = sysloglabel;
    {
#line 487
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 487
      if (! ((int )*p != 0)) {
#line 487
        goto while_break___1;
      }
#line 489
      if (! (((int )*p & -128) == 0)) {
#line 490
        *p = (char )'*';
      } else {
        {
#line 489
        tmp___25 = __ctype_b_loc();
        }
#line 489
        if ((int const   )*(*tmp___25 + (int )*p) & 16384) {
#line 489
          if ((int )*p == 37) {
#line 490
            *p = (char )'*';
          }
        } else {
#line 490
          *p = (char )'*';
        }
      }
#line 487
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 492
    closelog();
#line 494
    openlog((char const   *)sysloglabel, 1, 2 << 3);
    }
  }
  {
#line 502
  BlankEnvelope.e_puthdr = & putheader;
#line 503
  BlankEnvelope.e_putbody = & putbody;
#line 504
  BlankEnvelope.e_xfp = (SM_FILE_T *)((void *)0);
#line 505
  BlankEnvelope.e_from = NullAddress;
#line 506
  CurEnv = & BlankEnvelope;
#line 507
  MainEnvelope.e_from = NullAddress;
#line 514
  setdefaults(& BlankEnvelope);
#line 515
  initmacros(& BlankEnvelope);
#line 518
  set_op_mode((int )OpMode);
#line 520
  pw = sm_getpwuid(RealUid);
  }
#line 521
  if ((unsigned long )pw != (unsigned long )((void *)0)) {
    {
#line 522
    sm_strlcpy(rnamebuf, (char const   *)pw->pw_name, (ssize_t )sizeof(rnamebuf));
    }
  } else {
    {
#line 524
    sm_snprintf(rnamebuf, (size_t )sizeof(rnamebuf), "Unknown UID %d", (int )RealUid);
    }
  }
#line 527
  RealUserName = rnamebuf;
#line 529
  if ((int )tTdvect[0] >= 101) {
    {
#line 531
    sm_dprintf((char *)"Version %s\n", Version);
#line 532
    finis(0, 1, (int volatile   )0);
    }
  }
#line 541
  if (RealUid != 0U) {
    {
#line 541
    tmp___27 = geteuid();
    }
#line 541
    if (tmp___27 == RealUid) {
#line 543
      if ((int )tTdvect[47] >= 1) {
        {
#line 544
        sm_dprintf((char *)"Non-set-user-ID binary: RunAsUid = RealUid = %d\n", (int )RealUid);
        }
      }
#line 546
      RunAsUid = RealUid;
    } else {
#line 541
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 548
    tmp___26 = geteuid();
    }
#line 548
    if (tmp___26 != 0U) {
      {
#line 549
      RunAsUid = geteuid();
      }
    }
  }
  {
#line 551
  EffGid = getegid();
  }
#line 552
  if (RealUid != 0U) {
#line 552
    if (EffGid == RealGid) {
#line 553
      RunAsGid = RealGid;
    }
  }
#line 555
  if ((int )tTdvect[47] >= 5) {
    {
#line 557
    tmp___28 = getgid();
#line 557
    tmp___29 = getegid();
#line 557
    tmp___30 = getuid();
#line 557
    tmp___31 = geteuid();
#line 557
    sm_dprintf((char *)"main: e/ruid = %d/%d e/rgid = %d/%d\n", (int )tmp___31, (int )tmp___30,
               (int )tmp___29, (int )tmp___28);
#line 560
    sm_dprintf((char *)"main: RunAsUser = %d:%d\n", (int )RunAsUid, (int )RunAsGid);
    }
  }
#line 565
  j = 0;
#line 566
  av___0 = argv;
  {
#line 566
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 566
    if (! ((unsigned long )*av___0 != (unsigned long )((void *)0))) {
#line 566
      goto while_break___2;
    }
    {
#line 567
    tmp___32 = av___0;
#line 567
    av___0 ++;
#line 567
    tmp___33 = strlen((char const   *)*tmp___32);
#line 567
    j = (int )((size_t )j + (tmp___33 + 1U));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 568
  tmp___34 = xalloc_tagged((int )(sizeof(char *) * (unsigned long )(argc + 1)), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                           568);
#line 568
  SaveArgv = (char **)tmp___34;
#line 569
  CommandLineArgs = xalloc_tagged(j, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                                  569);
#line 570
  p = CommandLineArgs;
#line 571
  av___0 = argv;
#line 571
  i = 0;
  }
  {
#line 571
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 571
    if (! ((unsigned long )*av___0 != (unsigned long )((void *)0))) {
#line 571
      goto while_break___3;
    }
    {
#line 575
    tmp___35 = i;
#line 575
    i ++;
#line 575
    *(SaveArgv + tmp___35) = newstr((char const   *)*av___0);
    }
#line 576
    if ((unsigned long )av___0 != (unsigned long )argv) {
#line 577
      tmp___36 = p;
#line 577
      p ++;
#line 577
      *tmp___36 = (char )' ';
    }
    {
#line 578
    tmp___37 = av___0;
#line 578
    av___0 ++;
#line 578
    sm_strlcpy(p, (char const   *)*tmp___37, j);
#line 579
    tmp___38 = strlen((char const   *)p);
#line 579
    h = (int )tmp___38;
#line 580
    p += h;
#line 581
    j -= h + 1;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 583
  *(SaveArgv + i) = (char *)((void *)0);
#line 585
  if ((int )tTdvect[0] >= 1) {
    {
#line 589
    sm_dprintf((char *)"Version %s\n Compiled with:", Version);
#line 590
    sm_printoptions(CompileOptions);
    }
  }
#line 592
  if ((int )tTdvect[0] >= 10) {
    {
#line 596
    sm_dprintf((char *)"    OS Defines:");
#line 597
    sm_printoptions(OsCompileOptions);
#line 599
    sm_dprintf((char *)"Kernel symbols:\t%s\n", "/boot/vmlinux");
#line 602
    tmp___39 = getcfname((int )OpMode, (int )SubmitMode, 2, conffile);
#line 602
    sm_dprintf((char *)"     Conf file:\t%s (default for MSP)\n", tmp___39);
#line 605
    tmp___40 = getcfname((int )OpMode, (int )SubmitMode, 1, conffile);
#line 605
    sm_dprintf((char *)"     Conf file:\t%s (default for MTA)\n", tmp___40);
#line 608
    sm_dprintf((char *)"      Pid file:\t%s (default)\n", PidFile);
    }
  }
#line 611
  if ((int )tTdvect[0] >= 12) {
    {
#line 615
    sm_dprintf((char *)" libsm Defines:");
#line 616
    sm_printoptions(SmCompileOptions);
    }
  }
#line 619
  if ((int )tTdvect[0] >= 13) {
    {
#line 623
    sm_dprintf((char *)"   FFR Defines:");
#line 624
    sm_printoptions(FFRCompileOptions);
    }
  }
  {
#line 628
  ExternalEnviron = environ;
#line 629
  emptyenviron[0] = (char *)((void *)0);
#line 630
  environ = emptyenviron;
#line 637
  p = getextenv("TZ");
  }
#line 637
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 643
    tmp___41 = strlen((char const   *)p);
#line 643
    tzlen = (int )(tmp___41 + 4U);
#line 644
    tz = xalloc_tagged(tzlen, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                       644);
#line 645
    sm_strlcpyn(tz, tzlen, 2, "TZ=", p);
#line 648
    putenv(tz);
    }
  }
  {
#line 652
  sm_setuserenv("AGENT", "sendmail");
#line 654
  sm_signal(13, (void (*)(int  ))1);
#line 655
  OldUmask = umask((__mode_t )18);
#line 656
  FullName = getextenv("NAME");
  }
#line 657
  if ((unsigned long )FullName != (unsigned long )((void *)0)) {
    {
#line 658
    FullName = newstr((char const   *)FullName);
    }
  }
  {
#line 665
  tmp___42 = __res_state();
  }
#line 665
  if (! ((tmp___42->options & 1UL) != 0UL)) {
    {
#line 666
    __res_init();
    }
  }
#line 667
  if ((int )tTdvect[8] >= 8) {
    {
#line 668
    tmp___43 = __res_state();
#line 668
    tmp___43->options |= 2UL;
    }
  } else {
    {
#line 670
    tmp___44 = __res_state();
#line 670
    tmp___44->options &= 0xfffffffffffffffdUL;
    }
  }
  {
#line 672
  tmp___45 = __res_state();
#line 672
  tmp___45->options |= 4096UL;
#line 674
  tmp___46 = __res_state();
#line 674
  TimeOuts.res_retry[2] = tmp___46->retry;
#line 675
  tmp___47 = __res_state();
#line 675
  TimeOuts.res_retry[0] = tmp___47->retry;
#line 676
  tmp___48 = __res_state();
#line 676
  TimeOuts.res_retry[1] = tmp___48->retry;
#line 677
  tmp___49 = __res_state();
#line 677
  TimeOuts.res_retrans[2] = (time_t )tmp___49->retrans;
#line 678
  tmp___50 = __res_state();
#line 678
  TimeOuts.res_retrans[0] = (time_t )tmp___50->retrans;
#line 679
  tmp___51 = __res_state();
#line 679
  TimeOuts.res_retrans[1] = (time_t )tmp___51->retrans;
#line 682
  tmp___52 = __errno_location();
#line 682
  *tmp___52 = 0;
#line 683
  from = (char *)((void *)0);
#line 686
  init_vendor_macros(& BlankEnvelope);
#line 689
  macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, 'v', Version, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                   689, SmHeapGroup);
#line 692
  hp = myhostname(jbuf, (int )sizeof(jbuf));
  }
#line 693
  if ((int )jbuf[0] != 0) {
#line 697
    if ((int )tTdvect[0] >= 4) {
      {
#line 698
      sm_dprintf((char *)"Canonical name: %s\n", jbuf);
      }
    }
    {
#line 699
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, 'w', jbuf, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     699, SmHeapGroup);
#line 700
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, 'j', jbuf, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     700, SmHeapGroup);
#line 701
    setclass('w', jbuf);
#line 703
    p = strchr((char const   *)(jbuf), '.');
    }
#line 704
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 704
      if ((int )*(p + 1) != 0) {
        {
#line 705
        macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, 'm', p + 1, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                         705, SmHeapGroup);
        }
      }
    }
    {
#line 707
    tmp___55 = uname(& utsname);
    }
#line 707
    if (tmp___55 >= 0) {
#line 708
      p = utsname.nodename;
    } else {
#line 711
      if ((int )tTdvect[0] >= 22) {
        {
#line 712
        tmp___53 = __errno_location();
#line 712
        tmp___54 = sm_errstring(*tmp___53);
#line 712
        sm_dprintf((char *)"uname failed (%s)\n", tmp___54);
        }
      }
      {
#line 714
      makelower(jbuf);
#line 715
      p = jbuf;
      }
    }
#line 717
    if ((int )tTdvect[0] >= 4) {
      {
#line 718
      sm_dprintf((char *)" UUCP nodename: %s\n", p);
      }
    }
    {
#line 719
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, 'k', p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     719, SmHeapGroup);
#line 720
    setclass('k', p);
#line 721
    setclass('w', p);
    }
  }
#line 723
  if ((unsigned long )hp != (unsigned long )((void *)0)) {
#line 725
    av___0 = hp->h_aliases;
    {
#line 725
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 725
      if ((unsigned long )av___0 != (unsigned long )((void *)0)) {
#line 725
        if (! ((unsigned long )*av___0 != (unsigned long )((void *)0))) {
#line 725
          goto while_break___4;
        }
      } else {
#line 725
        goto while_break___4;
      }
#line 727
      if ((int )tTdvect[0] >= 4) {
        {
#line 728
        sm_dprintf((char *)"\ta.k.a.: %s\n", *av___0);
        }
      }
      {
#line 729
      setclass('w', *av___0);
#line 725
      av___0 ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 732
    i = 0;
    {
#line 732
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 732
      if (i >= 0) {
#line 732
        if (! ((unsigned long )*(hp->h_addr_list + i) != (unsigned long )((void *)0))) {
#line 732
          goto while_break___5;
        }
      } else {
#line 732
        goto while_break___5;
      }
#line 744
      ipbuf[0] = (char )'\000';
      {
#line 748
      if (hp->h_addrtype == 2) {
#line 748
        goto case_2;
      }
#line 745
      goto switch_break___1;
      case_2: /* CIL Label */ 
#line 749
      if (hp->h_length != 4) {
#line 750
        goto switch_break___1;
      }
      {
#line 752
      memmove((void *)(& ia), (void const   *)*(hp->h_addr_list + i), (size_t )4);
#line 753
      tmp___56 = inet_ntoa(ia);
#line 753
      sm_snprintf(ipbuf, (size_t )sizeof(ipbuf), "[%.100s]", tmp___56);
      }
#line 755
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 771
      if ((int )ipbuf[0] == 0) {
#line 772
        goto while_break___5;
      }
#line 774
      if ((int )tTdvect[0] >= 4) {
        {
#line 775
        sm_dprintf((char *)"\ta.k.a.: %s\n", ipbuf);
        }
      }
      {
#line 776
      setclass('w', ipbuf);
#line 732
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 786
  tmp___57 = arpadate((char *)((void *)0));
#line 786
  macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, 'b', tmp___57, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                   786, SmHeapGroup);
#line 789
  sm_getla();
#line 791
  QueueLimitRecipient = (QUEUE_CHAR *)((void *)0);
#line 792
  QueueLimitSender = (QUEUE_CHAR *)((void *)0);
#line 793
  QueueLimitId = (QUEUE_CHAR *)((void *)0);
#line 794
  QueueLimitQuarantine = (QUEUE_CHAR *)((void *)0);
#line 800
  optind = 1;
  }
  {
#line 801
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 801
    j = getopt(argc, (char * const  *)argv, "A:B:b:C:cD:d:e:F:f:Gh:IiL:M:mN:nO:o:p:Q:q:R:r:sTtV:vX:");
    }
#line 801
    if (! (j != -1)) {
#line 801
      goto while_break___6;
    }
    {
#line 805
    if (j == 98) {
#line 805
      goto case_98___0;
    }
#line 809
    if (j == 65) {
#line 809
      goto case_65;
    }
#line 814
    if (j == 66) {
#line 814
      goto case_66;
    }
#line 819
    if (j == 67) {
#line 819
      goto case_67;
    }
#line 829
    if (j == 100) {
#line 829
      goto case_100___1;
    }
#line 829
    if (j == 68) {
#line 829
      goto case_100___1;
    }
#line 834
    if (j == 114) {
#line 834
      goto case_114;
    }
#line 834
    if (j == 102) {
#line 834
      goto case_114;
    }
#line 850
    if (j == 70) {
#line 850
      goto case_70;
    }
#line 855
    if (j == 71) {
#line 855
      goto case_71___0;
    }
#line 860
    if (j == 104) {
#line 860
      goto case_104___0;
    }
#line 875
    if (j == 76) {
#line 875
      goto case_76___0;
    }
#line 879
    if (j == 110) {
#line 879
      goto case_110;
    }
#line 884
    if (j == 78) {
#line 884
      goto case_78;
    }
#line 910
    if (j == 111) {
#line 910
      goto case_111;
    }
#line 915
    if (j == 79) {
#line 915
      goto case_79;
    }
#line 919
    if (j == 112) {
#line 919
      goto case_112___0;
    }
#line 944
    if (j == 81) {
#line 944
      goto case_81___0;
    }
#line 962
    if (j == 113) {
#line 962
      goto case_113___0;
    }
#line 1075
    if (j == 82) {
#line 1075
      goto case_82___0;
    }
#line 1095
    if (j == 116) {
#line 1095
      goto case_116___0;
    }
#line 1100
    if (j == 86) {
#line 1100
      goto case_86;
    }
#line 1115
    if (j == 88) {
#line 1115
      goto case_88;
    }
#line 1144
    if (j == 118) {
#line 1144
      goto case_118___0;
    }
#line 1144
    if (j == 84) {
#line 1144
      goto case_118___0;
    }
#line 1144
    if (j == 109) {
#line 1144
      goto case_118___0;
    }
#line 1144
    if (j == 105) {
#line 1144
      goto case_118___0;
    }
#line 1144
    if (j == 99) {
#line 1144
      goto case_118___0;
    }
#line 1149
    if (j == 77) {
#line 1149
      goto case_77;
    }
#line 1149
    if (j == 101) {
#line 1149
      goto case_77;
    }
#line 1153
    if (j == 115) {
#line 1153
      goto case_115___0;
    }
#line 1174
    goto switch_default___1;
    case_98___0: /* CIL Label */ 
#line 807
    goto switch_break___2;
    case_65: /* CIL Label */ 
#line 810
    if ((int )*(optarg + 0) == 99) {
#line 810
      cftype = 2;
    } else {
#line 810
      cftype = 1;
    }
#line 812
    goto switch_break___2;
    case_66: /* CIL Label */ 
#line 815
    if (extraprivs) {
#line 815
      if ((int )OpMode != 109) {
#line 815
        if ((int )OpMode != 115) {
#line 815
          if ((int )OpMode != 97) {
#line 815
            if ((int )OpMode != 118) {
#line 815
              if ((int )OpMode != 116) {
                {
#line 815
                sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option (not in submission mode)\n",
                              j);
                }
#line 815
                goto switch_break___2;
              }
            }
          }
        }
      }
    }
#line 815
    if (extraprivs) {
#line 815
      if (queuerun) {
        {
#line 815
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option with -q\n",
                      j);
        }
#line 815
        goto switch_break___2;
      }
    }
    {
#line 816
    BlankEnvelope.e_bodytype = newstr((char const   *)optarg);
    }
#line 817
    goto switch_break___2;
    case_67: /* CIL Label */ 
#line 820
    if (RealUid != 0U) {
#line 821
      warn_C_flag = 1;
    }
    {
#line 822
    conffile = newstr((char const   *)optarg);
#line 823
    dp = drop_privileges(1);
    }
#line 824
    if (ExitStat == 0) {
#line 824
      ExitStat = dp;
    } else
#line 824
    if (ExitStat == 75) {
#line 824
      ExitStat = dp;
    }
#line 825
    safecf = 0;
#line 826
    goto switch_break___2;
    case_100___1: /* CIL Label */ 
    case_68___1: /* CIL Label */ 
#line 831
    goto switch_break___2;
    case_114: /* CIL Label */ 
    case_102: /* CIL Label */ 
#line 835
    if (extraprivs) {
#line 835
      if ((int )OpMode != 109) {
#line 835
        if ((int )OpMode != 115) {
#line 835
          if ((int )OpMode != 97) {
#line 835
            if ((int )OpMode != 118) {
#line 835
              if ((int )OpMode != 116) {
                {
#line 835
                sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option (not in submission mode)\n",
                              j);
                }
#line 835
                goto switch_break___2;
              }
            }
          }
        }
      }
    }
#line 835
    if (extraprivs) {
#line 835
      if (queuerun) {
        {
#line 835
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option with -q\n",
                      j);
        }
#line 835
        goto switch_break___2;
      }
    }
#line 836
    if ((unsigned long )from != (unsigned long )((void *)0)) {
      {
#line 838
      usrerr("More than one \"from\" person");
#line 839
      ExitStat = 64;
      }
#line 840
      goto switch_break___2;
    }
#line 842
    if ((int )*(optarg + 0) == 0) {
      {
#line 843
      from = newstr("<>");
      }
    } else {
      {
#line 845
      tmp___58 = denlstring(optarg, 1, 1);
#line 845
      from = newstr((char const   *)tmp___58);
      }
    }
    {
#line 846
    tmp___59 = strcmp((char const   *)RealUserName, (char const   *)from);
    }
#line 846
    if (tmp___59 != 0) {
#line 847
      warn_f_flag = (char )j;
    }
#line 848
    goto switch_break___2;
    case_70: /* CIL Label */ 
#line 851
    if (extraprivs) {
#line 851
      if ((int )OpMode != 109) {
#line 851
        if ((int )OpMode != 115) {
#line 851
          if ((int )OpMode != 97) {
#line 851
            if ((int )OpMode != 118) {
#line 851
              if ((int )OpMode != 116) {
                {
#line 851
                sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option (not in submission mode)\n",
                              j);
                }
#line 851
                goto switch_break___2;
              }
            }
          }
        }
      }
    }
#line 851
    if (extraprivs) {
#line 851
      if (queuerun) {
        {
#line 851
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option with -q\n",
                      j);
        }
#line 851
        goto switch_break___2;
      }
    }
    {
#line 852
    FullName = newstr((char const   *)optarg);
    }
#line 853
    goto switch_break___2;
    case_71___0: /* CIL Label */ 
#line 857
    if (extraprivs) {
#line 857
      if ((int )OpMode != 109) {
#line 857
        if ((int )OpMode != 115) {
#line 857
          if ((int )OpMode != 97) {
#line 857
            if ((int )OpMode != 118) {
#line 857
              if ((int )OpMode != 116) {
                {
#line 857
                sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option (not in submission mode)\n",
                              j);
                }
#line 857
                goto switch_break___2;
              }
            }
          }
        }
      }
    }
#line 857
    if (extraprivs) {
#line 857
      if (queuerun) {
        {
#line 857
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option with -q\n",
                      j);
        }
#line 857
        goto switch_break___2;
      }
    }
#line 858
    goto switch_break___2;
    case_104___0: /* CIL Label */ 
#line 861
    if (extraprivs) {
#line 861
      if ((int )OpMode != 109) {
#line 861
        if ((int )OpMode != 115) {
#line 861
          if ((int )OpMode != 97) {
#line 861
            if ((int )OpMode != 118) {
#line 861
              if ((int )OpMode != 116) {
                {
#line 861
                sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option (not in submission mode)\n",
                              j);
                }
#line 861
                goto switch_break___2;
              }
            }
          }
        }
      }
    }
#line 861
    if (extraprivs) {
#line 861
      if (queuerun) {
        {
#line 861
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option with -q\n",
                      j);
        }
#line 861
        goto switch_break___2;
      }
    }
    {
#line 862
    tmp___60 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& ep),
                      10);
#line 862
    BlankEnvelope.e_hopcount = (short )tmp___60;
#line 864
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%d", (int )BlankEnvelope.e_hopcount);
#line 866
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, 'c', buf___16, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     866, SmHeapGroup);
    }
#line 868
    if (*ep) {
      {
#line 870
      usrerr("Bad hop count (%s)", optarg);
#line 871
      ExitStat = 64;
      }
    }
#line 873
    goto switch_break___2;
    case_76___0: /* CIL Label */ 
#line 877
    goto switch_break___2;
    case_110: /* CIL Label */ 
#line 880
    if (extraprivs) {
#line 880
      if ((int )OpMode != 109) {
#line 880
        if ((int )OpMode != 115) {
#line 880
          if ((int )OpMode != 97) {
#line 880
            if ((int )OpMode != 118) {
#line 880
              if ((int )OpMode != 116) {
                {
#line 880
                sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option (not in submission mode)\n",
                              j);
                }
#line 880
                goto switch_break___2;
              }
            }
          }
        }
      }
    }
#line 880
    if (extraprivs) {
#line 880
      if (queuerun) {
        {
#line 880
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option with -q\n",
                      j);
        }
#line 880
        goto switch_break___2;
      }
    }
#line 881
    NoAlias = 1;
#line 882
    goto switch_break___2;
    case_78: /* CIL Label */ 
#line 885
    if (extraprivs) {
#line 885
      if ((int )OpMode != 109) {
#line 885
        if ((int )OpMode != 115) {
#line 885
          if ((int )OpMode != 97) {
#line 885
            if ((int )OpMode != 118) {
#line 885
              if ((int )OpMode != 116) {
                {
#line 885
                sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option (not in submission mode)\n",
                              j);
                }
#line 885
                goto switch_break___2;
              }
            }
          }
        }
      }
    }
#line 885
    if (extraprivs) {
#line 885
      if (queuerun) {
        {
#line 885
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option with -q\n",
                      j);
        }
#line 885
        goto switch_break___2;
      }
    }
    {
#line 886
    DefaultNotify |= 512;
#line 887
    tmp___61 = macid_parse((char *)"{dsn_notify}", (char **)((void *)0));
#line 887
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___61, optarg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     888, SmHeapGroup);
#line 889
    tmp___62 = sm_strcasecmp((char const   *)optarg, "never");
    }
#line 889
    if (tmp___62 == 0) {
#line 890
      goto switch_break___2;
    }
#line 891
    p = optarg;
    {
#line 891
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 891
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 891
        goto while_break___7;
      }
      {
#line 893
      p = strchr((char const   *)p, ',');
      }
#line 894
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 895
        tmp___63 = p;
#line 895
        p ++;
#line 895
        *tmp___63 = (char )'\000';
      }
      {
#line 896
      tmp___66 = sm_strcasecmp((char const   *)optarg, "success");
      }
#line 896
      if (tmp___66 == 0) {
#line 897
        DefaultNotify |= 64;
      } else {
        {
#line 898
        tmp___65 = sm_strcasecmp((char const   *)optarg, "failure");
        }
#line 898
        if (tmp___65 == 0) {
#line 899
          DefaultNotify |= 128;
        } else {
          {
#line 900
          tmp___64 = sm_strcasecmp((char const   *)optarg, "delay");
          }
#line 900
          if (tmp___64 == 0) {
#line 901
            DefaultNotify |= 256;
          } else {
            {
#line 904
            usrerr("Invalid -N argument");
#line 905
            ExitStat = 64;
            }
          }
        }
      }
#line 891
      optarg = p;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 908
    goto switch_break___2;
    case_111: /* CIL Label */ 
    {
#line 911
    setoption((int )*optarg, optarg + 1, 0, 1, & BlankEnvelope);
    }
#line 913
    goto switch_break___2;
    case_79: /* CIL Label */ 
    {
#line 916
    setoption(' ', optarg, 0, 1, & BlankEnvelope);
    }
#line 917
    goto switch_break___2;
    case_112___0: /* CIL Label */ 
#line 920
    if (extraprivs) {
#line 920
      if ((int )OpMode != 109) {
#line 920
        if ((int )OpMode != 115) {
#line 920
          if ((int )OpMode != 97) {
#line 920
            if ((int )OpMode != 118) {
#line 920
              if ((int )OpMode != 116) {
                {
#line 920
                sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option (not in submission mode)\n",
                              j);
                }
#line 920
                goto switch_break___2;
              }
            }
          }
        }
      }
    }
#line 920
    if (extraprivs) {
#line 920
      if (queuerun) {
        {
#line 920
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option with -q\n",
                      j);
        }
#line 920
        goto switch_break___2;
      }
    }
    {
#line 921
    p = strchr((char const   *)optarg, ':');
    }
#line 922
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 924
      tmp___67 = p;
#line 924
      p ++;
#line 924
      *tmp___67 = (char )'\000';
#line 925
      if ((int )*p != 0) {
        {
#line 927
        tmp___68 = strlen((char const   *)p);
#line 927
        i = (int )(tmp___68 + 1U);
#line 928
        tmp___69 = sm_malloc_tagged_x((size_t )i, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                                      928, SmHeapGroup);
#line 928
        ep = (char *)tmp___69;
#line 929
        cleanstrcpy(ep, p, i);
#line 930
        macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )0, 's', ep, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                         931, SmHeapGroup);
        }
      }
    }
#line 934
    if ((int )*optarg != 0) {
      {
#line 936
      tmp___70 = strlen((char const   *)optarg);
#line 936
      i = (int )(tmp___70 + 1U);
#line 937
      tmp___71 = sm_malloc_tagged_x((size_t )i, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                                    937, SmHeapGroup);
#line 937
      ep = (char *)tmp___71;
#line 938
      cleanstrcpy(ep, optarg, i);
#line 939
      macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )0, 'r', ep, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                       940, SmHeapGroup);
      }
    }
#line 942
    goto switch_break___2;
    case_81___0: /* CIL Label */ 
#line 946
    if ((int )OpMode != 109) {
#line 946
      if ((int )OpMode != 113) {
        {
#line 949
        usrerr("Can not use -Q with -b%c", (int )OpMode);
#line 950
        ExitStat = 64;
        }
#line 951
        goto switch_break___2;
      }
    }
#line 954
    if ((int )OpMode == 109) {
      {
#line 955
      set_op_mode('q');
      }
    }
    {
#line 957
    FullName = (char *)((void *)0);
#line 959
    quarantining = newstr((char const   *)optarg);
    }
#line 960
    goto switch_break___2;
    case_113___0: /* CIL Label */ 
#line 964
    if ((int )OpMode != 109) {
#line 964
      if ((int )OpMode != 100) {
#line 964
        if ((int )OpMode != 68) {
#line 964
          if ((int )OpMode != 112) {
#line 964
            if ((int )OpMode != 80) {
#line 964
              if ((int )OpMode != 113) {
                {
#line 971
                usrerr("Can not use -q with -b%c", (int )OpMode);
#line 972
                ExitStat = 64;
                }
#line 973
                goto switch_break___2;
              }
            }
          }
        }
      }
    }
#line 977
    if ((int )OpMode == 109) {
      {
#line 978
      set_op_mode('q');
      }
    }
#line 980
    FullName = (char *)((void *)0);
#line 981
    negate = (int )*(optarg + 0) == 33;
#line 982
    if (negate) {
#line 985
      optarg ++;
    }
    {
#line 990
    if ((int )*(optarg + 0) == 71) {
#line 990
      goto case_71___1;
    }
#line 1006
    if ((int )*(optarg + 0) == 73) {
#line 1006
      goto case_73;
    }
#line 1014
    if ((int )*(optarg + 0) == 82) {
#line 1014
      goto case_82;
    }
#line 1022
    if ((int )*(optarg + 0) == 83) {
#line 1022
      goto case_83;
    }
#line 1030
    if ((int )*(optarg + 0) == 102) {
#line 1030
      goto case_102___0;
    }
#line 1034
    if ((int )*(optarg + 0) == 81) {
#line 1034
      goto case_81___1;
    }
#line 1046
    if ((int )*(optarg + 0) == 76) {
#line 1046
      goto case_76___1;
    }
#line 1050
    if ((int )*(optarg + 0) == 112) {
#line 1050
      goto case_112___1;
    }
#line 1059
    goto switch_default___0;
    case_71___1: /* CIL Label */ 
#line 991
    if (negate) {
      {
#line 993
      usrerr("Can not use -q!G");
#line 994
      ExitStat = 64;
      }
#line 995
      goto switch_break___3;
    }
#line 997
    if ((unsigned long )queuegroup != (unsigned long )((void *)0)) {
      {
#line 999
      usrerr("Can not use multiple -qG options");
#line 1000
      ExitStat = 64;
      }
#line 1001
      goto switch_break___3;
    }
    {
#line 1003
    queuegroup = newstr((char const   *)(optarg + 1));
    }
#line 1004
    goto switch_break___3;
    case_73: /* CIL Label */ 
    {
#line 1007
    tmp___72 = xalloc_tagged((int )sizeof(*new), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                             1007);
#line 1007
    new = (QUEUE_CHAR *)tmp___72;
#line 1008
    new->queue_match = newstr((char const   *)(optarg + 1));
#line 1009
    new->queue_negate = negate;
#line 1010
    new->queue_next = QueueLimitId;
#line 1011
    QueueLimitId = new;
    }
#line 1012
    goto switch_break___3;
    case_82: /* CIL Label */ 
    {
#line 1015
    tmp___73 = xalloc_tagged((int )sizeof(*new), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                             1015);
#line 1015
    new = (QUEUE_CHAR *)tmp___73;
#line 1016
    new->queue_match = newstr((char const   *)(optarg + 1));
#line 1017
    new->queue_negate = negate;
#line 1018
    new->queue_next = QueueLimitRecipient;
#line 1019
    QueueLimitRecipient = new;
    }
#line 1020
    goto switch_break___3;
    case_83: /* CIL Label */ 
    {
#line 1023
    tmp___74 = xalloc_tagged((int )sizeof(*new), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                             1023);
#line 1023
    new = (QUEUE_CHAR *)tmp___74;
#line 1024
    new->queue_match = newstr((char const   *)(optarg + 1));
#line 1025
    new->queue_negate = negate;
#line 1026
    new->queue_next = QueueLimitSender;
#line 1027
    QueueLimitSender = new;
    }
#line 1028
    goto switch_break___3;
    case_102___0: /* CIL Label */ 
#line 1031
    foregroundqueue = 1;
#line 1032
    goto switch_break___3;
    case_81___1: /* CIL Label */ 
#line 1035
    if ((int )*(optarg + 1) != 0) {
      {
#line 1037
      tmp___75 = xalloc_tagged((int )sizeof(*new), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                               1037);
#line 1037
      new = (QUEUE_CHAR *)tmp___75;
#line 1038
      new->queue_match = newstr((char const   *)(optarg + 1));
#line 1039
      new->queue_negate = negate;
#line 1040
      new->queue_next = QueueLimitQuarantine;
#line 1041
      QueueLimitQuarantine = new;
      }
    }
#line 1043
    QueueMode = 'Q';
#line 1044
    goto switch_break___3;
    case_76___1: /* CIL Label */ 
#line 1047
    QueueMode = 'L';
#line 1048
    goto switch_break___3;
    case_112___1: /* CIL Label */ 
#line 1051
    queuepersistent = 1;
#line 1052
    if (QueueIntvl == 0L) {
#line 1053
      QueueIntvl = (time_t )1;
    }
#line 1054
    if ((int )*(optarg + 1) == 0) {
#line 1055
      goto switch_break___3;
    }
#line 1056
    optarg ++;
    switch_default___0: /* CIL Label */ 
    {
#line 1060
    i = Errors;
#line 1061
    QueueIntvl = convtime(optarg, 'm');
    }
#line 1062
    if (QueueIntvl < 0L) {
      {
#line 1064
      usrerr("Invalid -q value");
#line 1065
      ExitStat = 64;
      }
    }
#line 1069
    if (i < Errors) {
#line 1070
      ExitStat = 64;
    }
#line 1071
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 1073
    goto switch_break___2;
    case_82___0: /* CIL Label */ 
#line 1076
    if (extraprivs) {
#line 1076
      if ((int )OpMode != 109) {
#line 1076
        if ((int )OpMode != 115) {
#line 1076
          if ((int )OpMode != 97) {
#line 1076
            if ((int )OpMode != 118) {
#line 1076
              if ((int )OpMode != 116) {
                {
#line 1076
                sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option (not in submission mode)\n",
                              j);
                }
#line 1076
                goto switch_break___2;
              }
            }
          }
        }
      }
    }
#line 1076
    if (extraprivs) {
#line 1076
      if (queuerun) {
        {
#line 1076
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option with -q\n",
                      j);
        }
#line 1076
        goto switch_break___2;
      }
    }
#line 1077
    if ((BlankEnvelope.e_flags & 1048576UL) != 0UL) {
      {
#line 1079
      usrerr("Duplicate -R flag");
#line 1080
      ExitStat = 64;
      }
#line 1081
      goto switch_break___2;
    }
    {
#line 1083
    BlankEnvelope.e_flags |= 1048576UL;
#line 1084
    tmp___77 = sm_strcasecmp((char const   *)optarg, "hdrs");
    }
#line 1084
    if (tmp___77 == 0) {
#line 1085
      BlankEnvelope.e_flags |= 4UL;
    } else {
      {
#line 1086
      tmp___76 = sm_strcasecmp((char const   *)optarg, "full");
      }
#line 1086
      if (tmp___76 != 0) {
        {
#line 1088
        usrerr("Invalid -R value");
#line 1089
        ExitStat = 64;
        }
      }
    }
    {
#line 1091
    tmp___78 = macid_parse((char *)"{dsn_ret}", (char **)((void *)0));
#line 1091
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___78, optarg, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     1092, SmHeapGroup);
    }
#line 1093
    goto switch_break___2;
    case_116___0: /* CIL Label */ 
#line 1096
    if (extraprivs) {
#line 1096
      if ((int )OpMode != 109) {
#line 1096
        if ((int )OpMode != 115) {
#line 1096
          if ((int )OpMode != 97) {
#line 1096
            if ((int )OpMode != 118) {
#line 1096
              if ((int )OpMode != 116) {
                {
#line 1096
                sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option (not in submission mode)\n",
                              j);
                }
#line 1096
                goto switch_break___2;
              }
            }
          }
        }
      }
    }
#line 1096
    if (extraprivs) {
#line 1096
      if (queuerun) {
        {
#line 1096
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option with -q\n",
                      j);
        }
#line 1096
        goto switch_break___2;
      }
    }
#line 1097
    GrabTo = 1;
#line 1098
    goto switch_break___2;
    case_86: /* CIL Label */ 
#line 1101
    if (extraprivs) {
#line 1101
      if ((int )OpMode != 109) {
#line 1101
        if ((int )OpMode != 115) {
#line 1101
          if ((int )OpMode != 97) {
#line 1101
            if ((int )OpMode != 118) {
#line 1101
              if ((int )OpMode != 116) {
                {
#line 1101
                sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option (not in submission mode)\n",
                              j);
                }
#line 1101
                goto switch_break___2;
              }
            }
          }
        }
      }
    }
#line 1101
    if (extraprivs) {
#line 1101
      if (queuerun) {
        {
#line 1101
        sm_io_fprintf(& SmIoF[1], -2, "WARNING: Ignoring submission mode -%c option with -q\n",
                      j);
        }
#line 1101
        goto switch_break___2;
      }
    }
    {
#line 1102
    tmp___80 = xtextok(optarg);
    }
#line 1102
    if (tmp___80) {
      {
#line 1109
      BlankEnvelope.e_envid = newstr((char const   *)optarg);
#line 1110
      tmp___79 = macid_parse((char *)"{dsn_envid}", (char **)((void *)0));
#line 1110
      macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___79, optarg,
                       (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                       1111, SmHeapGroup);
      }
    } else {
      {
#line 1104
      usrerr("Invalid syntax in -V flag");
#line 1105
      ExitStat = 64;
      }
    }
#line 1113
    goto switch_break___2;
    case_88: /* CIL Label */ 
    {
#line 1116
    dp = drop_privileges(1);
    }
#line 1117
    if (ExitStat == 0) {
#line 1117
      ExitStat = dp;
    } else
#line 1117
    if (ExitStat == 75) {
#line 1117
      ExitStat = dp;
    }
    {
#line 1118
    tmp___81 = stat((char const   */* __restrict  */)optarg, (struct stat */* __restrict  */)(& traf_st));
    }
#line 1118
    if (tmp___81 == 0) {
#line 1118
      if ((traf_st.st_mode & 61440U) == 4096U) {
        {
#line 1120
        TrafficLogFile = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)optarg,
                                    3, (void const   *)((void *)0));
        }
      } else {
        {
#line 1125
        TrafficLogFile = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)optarg,
                                    4, (void const   *)((void *)0));
        }
      }
    } else {
      {
#line 1125
      TrafficLogFile = sm_io_open((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)optarg,
                                  4, (void const   *)((void *)0));
      }
    }
#line 1129
    if ((unsigned long )TrafficLogFile == (unsigned long )((void *)0)) {
      {
#line 1131
      syserr("cannot open %s", optarg);
#line 1132
      ExitStat = 73;
      }
#line 1133
      goto switch_break___2;
    }
    {
#line 1135
    sm_io_setvbuf(TrafficLogFile, -2, (char *)((void *)0), 1, (size_t )0);
    }
#line 1137
    goto switch_break___2;
    case_118___0: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_109___0: /* CIL Label */ 
    case_105___0: /* CIL Label */ 
    case_99: /* CIL Label */ 
    {
#line 1145
    setoption(j, (char *)"T", 0, 1, & BlankEnvelope);
    }
#line 1146
    goto switch_break___2;
    case_77: /* CIL Label */ 
    case_101: /* CIL Label */ 
    {
#line 1150
    setoption(j, optarg, 0, 1, & BlankEnvelope);
    }
#line 1151
    goto switch_break___2;
    case_115___0: /* CIL Label */ 
    {
#line 1154
    setoption('f', (char *)"T", 0, 1, & BlankEnvelope);
    }
#line 1155
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 1175
    finis(1, 1, (int volatile   )64);
    }
#line 1177
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1182
  if (ExitStat != 0) {
#line 1182
    if ((int )OpMode != 116) {
      {
#line 1185
      finis(0, 1, (int volatile   )ExitStat);
      }
    } else {
#line 1182
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1182
  if (ExitStat == 71) {
    {
#line 1185
    finis(0, 1, (int volatile   )ExitStat);
    }
  }
#line 1189
  if ((SubmitMode & 1U) != 0U) {
    {
#line 1192
    tmp___83 = macid_parse((char *)"{daemon_flags}", (char **)((void *)0));
#line 1192
    tmp___84 = macvalue(tmp___83, & BlankEnvelope);
    }
#line 1192
    if ((unsigned long )tmp___84 == (unsigned long )((void *)0)) {
      {
#line 1193
      tmp___82 = macid_parse((char *)"{daemon_flags}", (char **)((void *)0));
#line 1193
      macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___82, (char *)"CC f",
                       (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                       1194, SmHeapGroup);
      }
    }
  } else
#line 1196
  if ((int )OpMode == 109) {
#line 1196
    goto _L___1;
  } else
#line 1196
  if ((int )OpMode == 115) {
    _L___1: /* CIL Label */ 
    {
#line 1198
    SubmitMode = 2U;
#line 1201
    tmp___86 = macid_parse((char *)"{daemon_flags}", (char **)((void *)0));
#line 1201
    tmp___87 = macvalue(tmp___86, & BlankEnvelope);
    }
#line 1201
    if ((unsigned long )tmp___87 == (unsigned long )((void *)0)) {
      {
#line 1202
      tmp___85 = macid_parse((char *)"{daemon_flags}", (char **)((void *)0));
#line 1202
      macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___85, (char *)"c u",
                       (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                       1203, SmHeapGroup);
      }
    }
  }
  {
#line 1213
  checkfd012((char *)"before readcf");
#line 1215
  vendor_pre_defaults(& BlankEnvelope);
#line 1217
  tmp___88 = getcfname((int )OpMode, (int )SubmitMode, cftype, conffile);
#line 1217
  readcf(tmp___88, safecf, & BlankEnvelope);
#line 1220
  ConfigFileRead = 1;
#line 1222
  vendor_post_defaults(& BlankEnvelope);
  }
#line 1225
  if (MissingFds != 0) {
#line 1225
    if (LogLevel > 8) {
#line 1229
      mbuf___0[0] = (char )'\000';
#line 1230
      if ((MissingFds & 1) != 0) {
        {
#line 1231
        sm_strlcat(mbuf___0, ", stdin", (ssize_t )sizeof(mbuf___0));
        }
      }
#line 1232
      if ((MissingFds & (1 << 1)) != 0) {
        {
#line 1233
        sm_strlcat(mbuf___0, ", stdout", (ssize_t )sizeof(mbuf___0));
        }
      }
#line 1234
      if ((MissingFds & (1 << 2)) != 0) {
        {
#line 1235
        sm_strlcat(mbuf___0, ", stderr", (ssize_t )sizeof(mbuf___0));
        }
      }
      {
#line 1238
      tmp___89 = sm_errstring(fill_errno);
#line 1238
      sm_syslog(4, "*~*", "File descriptors missing on startup: %s; %s", & mbuf___0[2],
                tmp___89);
      }
    }
  }
#line 1244
  if (RealUid != 0U) {
    {
#line 1244
    tmp___96 = geteuid();
    }
#line 1244
    if (RealUid != tmp___96) {
      {
#line 1246
      tmp___90 = geteuid();
#line 1246
      new_uid = tmp___90;
      }
#line 1256
      if (new_uid == 0U) {
#line 1257
        new_uid = DefUid;
      }
#line 1258
      if ((int )tTdvect[47] >= 5) {
        {
#line 1259
        sm_dprintf((char *)"Changing real uid to %d\n", (int )new_uid);
        }
      }
      {
#line 1260
      tmp___92 = geteuid();
#line 1260
      tmp___93 = setreuid(new_uid, tmp___92);
      }
#line 1260
      if (tmp___93 < 0) {
        {
#line 1262
        tmp___91 = geteuid();
#line 1262
        syserr("main: setreuid(%d, %d) failed", (int )new_uid, (int )tmp___91);
#line 1264
        finis(0, 1, (int volatile   )71);
        }
      }
#line 1267
      if ((int )tTdvect[47] >= 10) {
        {
#line 1268
        tmp___94 = getuid();
#line 1268
        tmp___95 = geteuid();
#line 1268
        sm_dprintf((char *)"Now running as e/ruid %d:%d\n", (int )tmp___95, (int )tmp___94);
        }
      }
    }
  }
#line 1291
  if ((unsigned long )FallbackMX != (unsigned long )((void *)0)) {
    {
#line 1292
    getfallbackmxrr(FallbackMX);
    }
  }
#line 1295
  if (SuperSafe == 1) {
#line 1295
    if ((int )CurEnv->e_sendmode != 105) {
      {
#line 1297
      sm_io_fprintf(& SmIoF[1], -2, "WARNING: SuperSafe=interactive should only be used with\n         DeliveryMode=interactive\n");
      }
    }
  }
#line 1301
  if (UseMSP) {
#line 1301
    if ((int )OpMode == 100) {
      {
#line 1303
      usrerr("Mail submission program cannot be used as daemon");
#line 1304
      finis(0, 1, (int volatile   )64);
      }
    } else
#line 1301
    if ((int )OpMode == 68) {
      {
#line 1303
      usrerr("Mail submission program cannot be used as daemon");
#line 1304
      finis(0, 1, (int volatile   )64);
      }
    }
  }
#line 1307
  if ((int )OpMode == 109) {
    {
#line 1310
    makeworkgroups();
    }
  } else
#line 1307
  if ((int )OpMode == 115) {
    {
#line 1310
    makeworkgroups();
    }
  } else
#line 1307
  if ((int )OpMode == 113) {
    {
#line 1310
    makeworkgroups();
    }
  } else
#line 1307
  if ((int )OpMode == 97) {
    {
#line 1310
    makeworkgroups();
    }
  } else
#line 1307
  if ((int )OpMode == 100) {
    {
#line 1310
    makeworkgroups();
    }
  } else
#line 1307
  if ((int )OpMode == 68) {
    {
#line 1310
    makeworkgroups();
    }
  }
  {
#line 1313
  tmp___97 = sm_signal(2, (void (*)(int  ))1);
  }
#line 1313
  if ((unsigned long )tmp___97 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 1314
    sm_signal(2, & intsig);
    }
  }
  {
#line 1315
  sm_signal(15, & intsig);
  }
#line 1318
  if ((unsigned long )TimeZoneSpec == (unsigned long )((void *)0)) {
    {
#line 1319
    unsetenv("TZ");
    }
  } else
#line 1320
  if ((int )*(TimeZoneSpec + 0) != 0) {
    {
#line 1321
    sm_setuserenv("TZ", (char const   *)TimeZoneSpec);
    }
  } else {
    {
#line 1323
    sm_setuserenv("TZ", (char const   *)((void *)0));
    }
  }
  {
#line 1324
  tzset();
#line 1327
  i = sm_mbdb_initialize(Mbdb);
  }
#line 1328
  if (i != 0) {
    {
#line 1330
    tmp___98 = sm_strexit(i);
#line 1330
    usrerr("Can\'t initialize mailbox database \"%s\": %s", Mbdb, tmp___98);
#line 1332
    ExitStat = i;
    }
  }
  {
#line 1336
  resetlimits();
  }
#line 1338
  if ((int )OpMode == 116) {
    {
#line 1341
    dp = drop_privileges(1);
    }
#line 1342
    if (dp != 0) {
      {
#line 1344
      finis(0, 1, (int volatile   )dp);
      }
    }
  } else
#line 1348
  if ((int )OpMode != 100) {
#line 1348
    if ((int )OpMode != 68) {
      {
#line 1351
      dp = drop_privileges(0);
      }
#line 1352
      if (ExitStat == 0) {
#line 1352
        ExitStat = dp;
      } else
#line 1352
      if (ExitStat == 75) {
#line 1352
        ExitStat = dp;
      }
#line 1353
      if (dp == 0) {
#line 1353
        if (UseMSP) {
          {
#line 1353
          tmp___99 = geteuid();
          }
#line 1353
          if (tmp___99 == 0U) {
            {
#line 1355
            usrerr("Mail submission program must have RunAsUser set to non root user");
#line 1356
            finis(0, 1, (int volatile   )78);
            }
          } else {
            {
#line 1353
            tmp___100 = getuid();
            }
#line 1353
            if (tmp___100 == 0U) {
              {
#line 1355
              usrerr("Mail submission program must have RunAsUser set to non root user");
#line 1356
              finis(0, 1, (int volatile   )78);
              }
            }
          }
        }
      }
    }
  }
  {
#line 1362
  tmp___101 = __res_state();
#line 1362
  tmp___101->retry = TimeOuts.res_retry[2];
#line 1363
  tmp___102 = __res_state();
#line 1363
  tmp___102->retrans = (int )TimeOuts.res_retrans[2];
#line 1370
  authinfo = getauthinfo(0, & forged);
#line 1371
  macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, '_', authinfo, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                   1371, SmHeapGroup);
  }
#line 1374
  if ((int )BlankEnvelope.e_errormode != 112) {
#line 1375
    HoldErrs = 1;
  }
  {
#line 1378
  expand((char *)"\201m", jbuf, (size_t )sizeof(jbuf), & BlankEnvelope);
  }
#line 1379
  if ((int )jbuf[0] != 0) {
    {
#line 1380
    setclass('m', jbuf);
    }
  }
#line 1383
  if (DontProbeInterfaces != 0) {
    {
#line 1384
    load_if_names();
    }
  }
#line 1386
  if ((int )tTdvect[0] >= 10) {
    {
#line 1391
    tmp___103 = getcfname((int )OpMode, (int )SubmitMode, cftype, conffile);
#line 1391
    sm_dprintf((char *)"     Conf file:\t%s (selected)\n", tmp___103);
#line 1393
    expand(PidFile, pidpath, (size_t )sizeof(pidpath), & BlankEnvelope);
#line 1394
    sm_dprintf((char *)"      Pid file:\t%s (selected)\n", pidpath);
    }
  }
#line 1397
  if ((int )tTdvect[0] >= 1) {
    {
#line 1399
    sm_dprintf((char *)"\n============ SYSTEM IDENTITY (after readcf) ============");
#line 1400
    sm_dprintf((char *)"\n      (short domain name) $w = ");
#line 1401
    tmp___104 = macvalue('w', & BlankEnvelope);
#line 1401
    tmp___105 = sm_debug_file();
#line 1401
    xputs(tmp___105, (char const   *)tmp___104);
#line 1402
    sm_dprintf((char *)"\n  (canonical domain name) $j = ");
#line 1403
    tmp___106 = macvalue('j', & BlankEnvelope);
#line 1403
    tmp___107 = sm_debug_file();
#line 1403
    xputs(tmp___107, (char const   *)tmp___106);
#line 1404
    sm_dprintf((char *)"\n         (subdomain name) $m = ");
#line 1405
    tmp___108 = macvalue('m', & BlankEnvelope);
#line 1405
    tmp___109 = sm_debug_file();
#line 1405
    xputs(tmp___109, (char const   *)tmp___108);
#line 1406
    sm_dprintf((char *)"\n              (node name) $k = ");
#line 1407
    tmp___110 = macvalue('k', & BlankEnvelope);
#line 1407
    tmp___111 = sm_debug_file();
#line 1407
    xputs(tmp___111, (char const   *)tmp___110);
#line 1408
    sm_dprintf((char *)"\n========================================================\n\n");
    }
  }
#line 1417
  if (warn_C_flag) {
    {
#line 1418
    auth_warning(& BlankEnvelope, "Processed by %s with -C %s", RealUserName, conffile);
    }
  }
#line 1420
  if (Warn_Q_option) {
    {
#line 1420
    tmp___112 = wordinclass(RealUserName, 't');
    }
#line 1420
    if (! tmp___112) {
      {
#line 1421
      auth_warning(& BlankEnvelope, "Processed from queue %s", QueueDir);
      }
    }
  }
#line 1423
  if ((unsigned long )sysloglabel != (unsigned long )((void *)0)) {
    {
#line 1423
    tmp___113 = wordinclass(RealUserName, 't');
    }
#line 1423
    if (! tmp___113) {
#line 1423
      if (RealUid != 0U) {
#line 1423
        if (RealUid != TrustedUid) {
#line 1423
          if (LogLevel > 1) {
            {
#line 1425
            sm_syslog(4, "*~*", "user %d changed syslog label", (int )RealUid);
            }
          }
        }
      }
    }
  }
  {
#line 1429
  i = check_bodytype(BlankEnvelope.e_bodytype);
  }
#line 1430
  if (i == -1) {
    {
#line 1432
    usrerr("Illegal body type %s", BlankEnvelope.e_bodytype);
#line 1433
    BlankEnvelope.e_bodytype = (char *)((void *)0);
    }
  } else
#line 1435
  if (i != 0) {
#line 1436
    SevenBitInput = i == 1;
  }
#line 1439
  if (DefaultNotify == 0) {
#line 1440
    DefaultNotify = 384;
  }
#line 1443
  if (ConfigLevel > 10) {
    {
#line 1445
    syserr("Warning: .cf version level (%d) exceeds sendmail version %s functionality (%d)",
           ConfigLevel, Version, 10);
    }
  }
#line 1450
  if ((unsigned long )HostStatDir != (unsigned long )((void *)0)) {
#line 1450
    if (MaxMciCache == 0) {
      {
#line 1452
      HostStatDir = (char *)((void *)0);
#line 1453
      sm_io_fprintf(& SmIoF[1], -2, "Warning: HostStatusDirectory disabled with ConnectionCacheSize = 0\n");
      }
    }
  }
#line 1458
  if (SingleThreadDelivery) {
#line 1458
    if ((unsigned long )HostStatDir == (unsigned long )((void *)0)) {
      {
#line 1460
      SingleThreadDelivery = 0;
#line 1461
      sm_io_fprintf(& SmIoF[1], -2, "Warning: HostStatusDirectory required for SingleThreadDelivery\n");
      }
    }
  }
#line 1476
  if (RealUid != 0U) {
#line 1476
    if (RealUid != TrustedUid) {
#line 1479
      action = (char *)((void *)0);
      {
#line 1483
      if ((int )OpMode == 113) {
#line 1483
        goto case_113___1;
      }
#line 1498
      if ((int )OpMode == 72) {
#line 1498
        goto case_72___0;
      }
#line 1504
      if ((int )OpMode == 68) {
#line 1504
        goto case_68___2;
      }
#line 1504
      if ((int )OpMode == 100) {
#line 1504
        goto case_68___2;
      }
#line 1522
      if ((int )OpMode == 118) {
#line 1522
        goto case_118___1;
      }
#line 1559
      if ((int )OpMode == 104) {
#line 1559
        goto case_104___1;
      }
#line 1559
      if ((int )OpMode == 122) {
#line 1559
        goto case_104___1;
      }
#line 1559
      if ((int )OpMode == 80) {
#line 1559
        goto case_104___1;
      }
#line 1559
      if ((int )OpMode == 112) {
#line 1559
        goto case_104___1;
      }
#line 1559
      if ((int )OpMode == 116) {
#line 1559
        goto case_104___1;
      }
#line 1563
      if ((int )OpMode == 105) {
#line 1563
        goto case_105___1;
      }
#line 1588
      goto switch_default___2;
      case_113___1: /* CIL Label */ 
#line 1484
      if ((unsigned long )quarantining != (unsigned long )((void *)0)) {
#line 1485
        action = (char *)"quarantine jobs";
      } else
#line 1489
      if (QueueIntvl == 0L) {
#line 1490
        goto switch_break___4;
      }
#line 1494
      if ((unsigned long )action == (unsigned long )((void *)0)) {
#line 1495
        action = (char *)"start a queue runner daemon";
      }
      case_72___0: /* CIL Label */ 
#line 1499
      if ((unsigned long )action == (unsigned long )((void *)0)) {
#line 1500
        action = (char *)"purge host status";
      }
      case_68___2: /* CIL Label */ 
      case_100___2: /* CIL Label */ 
#line 1505
      if ((unsigned long )action == (unsigned long )((void *)0)) {
#line 1506
        action = (char *)"run daemon";
      }
#line 1508
      if ((int )tTdvect[65] >= 1) {
        {
#line 1509
        sm_dprintf((char *)"Deny user %d attempt to %s\n", (int )RealUid, action);
        }
      }
#line 1512
      if (LogLevel > 1) {
        {
#line 1513
        sm_syslog(1, "*~*", "user %d attempted to %s", (int )RealUid, action);
        }
      }
      {
#line 1516
      HoldErrs = 0;
#line 1517
      usrerr("Permission denied (real uid not trusted)");
#line 1518
      finis(0, 1, (int volatile   )64);
      }
#line 1520
      goto switch_break___4;
      case_118___1: /* CIL Label */ 
#line 1523
      if ((PrivacyFlags & 262144UL) != 0UL) {
#line 1532
        if ((int )tTdvect[65] >= 1) {
          {
#line 1533
          sm_dprintf((char *)"Drop privs for user %d attempt to expand (RestrictExpand)\n",
                     (int )RealUid);
          }
        }
        {
#line 1536
        dp = drop_privileges(1);
        }
#line 1539
        if ((int )tTdvect[65] >= 1) {
          {
#line 1540
          sm_dprintf((char *)"Faking DontBlameSendmail=NonRootSafeAddr\n");
          }
        }
#line 1541
        DontBlameSendmail[31UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 31UL % (8UL * sizeof(int ));
#line 1543
        if (dp != 0) {
#line 1545
          if ((int )tTdvect[65] >= 1) {
            {
#line 1546
            sm_dprintf((char *)"Failed to drop privs for user %d attempt to expand, exiting\n",
                       (int )RealUid);
            }
          }
          {
#line 1548
          CurEnv->e_id = (char *)((void *)0);
#line 1549
          finis(1, 1, (int volatile   )dp);
          }
        }
      }
#line 1553
      goto switch_break___4;
      case_104___1: /* CIL Label */ 
      case_122___0: /* CIL Label */ 
      case_80___0: /* CIL Label */ 
      case_112___2: /* CIL Label */ 
      case_116___1: /* CIL Label */ 
#line 1561
      goto switch_break___4;
      case_105___1: /* CIL Label */ 
      {
#line 1564
      tmp___114 = wordinclass(RealUserName, 't');
      }
#line 1564
      if (! tmp___114) {
#line 1566
        if ((int )tTdvect[65] >= 1) {
          {
#line 1567
          sm_dprintf((char *)"Deny user %d attempt to rebuild the alias map\n", (int )RealUid);
          }
        }
#line 1569
        if (LogLevel > 1) {
          {
#line 1570
          sm_syslog(1, "*~*", "user %d attempted to rebuild the alias map", (int )RealUid);
          }
        }
        {
#line 1573
        HoldErrs = 0;
#line 1574
        usrerr("Permission denied (real uid not trusted)");
#line 1575
        finis(0, 1, (int volatile   )64);
        }
      }
#line 1578
      if (UseMSP) {
        {
#line 1580
        HoldErrs = 0;
#line 1581
        usrerr("User %d cannot rebuild aliases in mail submission program", (int )RealUid);
#line 1583
        finis(0, 1, (int volatile   )64);
        }
      }
      switch_default___2: /* CIL Label */ 
#line 1589
      if ((PrivacyFlags & 262144UL) != 0UL) {
#line 1589
        if (Verbose != 0) {
#line 1599
          if ((int )tTdvect[65] >= 1) {
            {
#line 1600
            sm_dprintf((char *)"Dropping verbosity for user %d (RestrictExpand)\n",
                       (int )RealUid);
            }
          }
#line 1602
          Verbose = 0;
        }
      }
#line 1604
      goto switch_break___4;
      switch_break___4: /* CIL Label */ ;
      }
    }
  }
#line 1608
  if (MeToo) {
#line 1609
    BlankEnvelope.e_flags |= 16384UL;
  }
  {
#line 1613
  if ((int )OpMode == 116) {
#line 1613
    goto case_116___2;
  }
#line 1622
  if ((int )OpMode == 118) {
#line 1622
    goto case_118___2;
  }
#line 1633
  if ((int )OpMode == 68) {
#line 1633
    goto case_68___3;
  }
#line 1638
  if ((int )OpMode == 100) {
#line 1638
    goto case_100___3;
  }
#line 1651
  if ((int )OpMode == 105) {
#line 1651
    goto case_105___2;
  }
#line 1657
  goto switch_default___3;
  case_116___2: /* CIL Label */ 
#line 1615
  HostStatDir = (char *)((void *)0);
#line 1616
  if (Verbose == 0) {
#line 1617
    Verbose = 2;
  }
#line 1618
  BlankEnvelope.e_errormode = (short )'p';
#line 1619
  HoldErrs = 0;
#line 1620
  goto switch_break___5;
  case_118___2: /* CIL Label */ 
  {
#line 1623
  BlankEnvelope.e_errormode = (short )'p';
#line 1624
  HoldErrs = 0;
#line 1626
  tmp___115 = sm_signal(1, (void (*)(int  ))1);
  }
#line 1626
  if ((unsigned long )tmp___115 == (unsigned long )((void (*)(int  ))0)) {
    {
#line 1627
    sm_signal(1, & intsig);
    }
  }
  {
#line 1628
  tmp___116 = geteuid();
  }
#line 1628
  if (tmp___116 != 0U) {
    {
#line 1629
    sm_io_fprintf(& SmIoF[1], -2, "Notice: -bv may give misleading output for non-privileged user\n");
    }
  }
#line 1631
  goto switch_break___5;
  case_68___3: /* CIL Label */ 
  {
#line 1634
  run_in_foreground = 1;
#line 1635
  set_op_mode('d');
  }
  case_100___3: /* CIL Label */ 
  {
#line 1639
  vendor_daemon_setup(& BlankEnvelope);
#line 1642
  FullName = (char *)((void *)0);
#line 1643
  GrabTo = 0;
  }
#line 1646
  if ((unsigned long )*(SaveArgv + 0) == (unsigned long )((void *)0)) {
    {
#line 1647
    sm_syslog(4, "*~*", "daemon invoked without full pathname; kill -1 won\'t work");
    }
  } else
#line 1646
  if ((int )*(*(SaveArgv + 0) + 0) != 47) {
    {
#line 1647
    sm_syslog(4, "*~*", "daemon invoked without full pathname; kill -1 won\'t work");
    }
  }
#line 1649
  goto switch_break___5;
  case_105___2: /* CIL Label */ 
#line 1652
  Verbose = 2;
#line 1653
  BlankEnvelope.e_errormode = (short )'p';
#line 1654
  HoldErrs = 0;
  switch_default___3: /* CIL Label */ 
  {
#line 1659
  tmp___117 = sm_signal(1, (void (*)(int  ))1);
  }
#line 1659
  if ((unsigned long )tmp___117 == (unsigned long )((void (*)(int  ))0)) {
    {
#line 1660
    sm_signal(1, & intsig);
    }
  }
#line 1661
  goto switch_break___5;
  switch_break___5: /* CIL Label */ ;
  }
#line 1665
  if ((unsigned long )FullName != (unsigned long )((void *)0)) {
    {
#line 1667
    full = (char *)((void *)0);
#line 1670
    tmp___119 = strchr((char const   *)FullName, '\n');
    }
#line 1670
    if ((unsigned long )tmp___119 != (unsigned long )((void *)0)) {
      {
#line 1672
      tmp___118 = denlstring(FullName, 1, 1);
#line 1672
      full = newstr((char const   *)tmp___118);
#line 1673
      FullName = full;
      }
    }
    {
#line 1677
    tmp___120 = rfc822_string(FullName);
    }
#line 1677
    if (! tmp___120) {
      {
#line 1685
      FullName = addquotes(FullName, (SM_RPOOL_T *)((void *)0));
      }
#line 1686
      if ((unsigned long )full != (unsigned long )((void *)0)) {
        {
#line 1687
        sm_free_tagged((void *)full, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                       1687);
        }
      }
    }
  }
#line 1692
  if (Verbose) {
    {
#line 1695
    setoption('c', (char *)"F", 1, 0, & BlankEnvelope);
#line 1698
    setoption('d', (char *)"", 1, 0, & BlankEnvelope);
    }
  }
#line 1711
  if (ConfigLevel < 10) {
    {
#line 1713
    message("Warning: .cf file is out of date: sendmail %s supports version %d, .cf file is version %d",
            Version, 10, ConfigLevel);
    }
  }
#line 1717
  if (ConfigLevel < 3) {
#line 1718
    UseErrorsTo = 1;
  }
#line 1721
  if ((unsigned long )SmtpGreeting == (unsigned long )((void *)0)) {
#line 1723
    if (ConfigLevel < 7) {
      {
#line 1723
      p = macvalue('e', & BlankEnvelope);
      }
#line 1723
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 1725
        SmtpGreeting = newstr((char const   *)p);
        }
      } else {
#line 1727
        SmtpGreeting = (char *)"\201j Sendmail \201v ready at \201b";
      }
    } else {
#line 1727
      SmtpGreeting = (char *)"\201j Sendmail \201v ready at \201b";
    }
  }
#line 1729
  if ((unsigned long )UnixFromLine == (unsigned long )((void *)0)) {
#line 1731
    if (ConfigLevel < 7) {
      {
#line 1731
      p = macvalue('l', & BlankEnvelope);
      }
#line 1731
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 1733
        UnixFromLine = newstr((char const   *)p);
        }
      } else {
#line 1735
        UnixFromLine = (char *)"From \201g  \201d";
      }
    } else {
#line 1735
      UnixFromLine = (char *)"From \201g  \201d";
    }
  }
  {
#line 1737
  SmtpError[0] = (char )'\000';
#line 1740
  expand((char *)"\201j", jbuf, (size_t )sizeof(jbuf), & BlankEnvelope);
  }
#line 1741
  if ((int )jbuf[0] == 0) {
    {
#line 1742
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 1742
      tmp___121 = sm_pstrdup_x("localhost");
#line 1742
      _newval = tmp___121;
      }
#line 1742
      if ((unsigned long )MyHostName != (unsigned long )((void *)0)) {
        {
#line 1742
        sm_free_tagged((void *)MyHostName, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                       1742);
        }
      }
#line 1742
      MyHostName = _newval;
#line 1742
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  } else {
    {
#line 1744
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 1744
      tmp___122 = sm_pstrdup_x((char const   *)(jbuf));
#line 1744
      _newval___0 = tmp___122;
      }
#line 1744
      if ((unsigned long )MyHostName != (unsigned long )((void *)0)) {
        {
#line 1744
        sm_free_tagged((void *)MyHostName, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                       1744);
        }
      }
#line 1744
      MyHostName = _newval___0;
#line 1744
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  {
#line 1745
  tmp___123 = strchr((char const   *)MyHostName, '.');
  }
#line 1745
  if ((unsigned long )tmp___123 == (unsigned long )((void *)0)) {
    {
#line 1746
    message("WARNING: local host name (%s) is not qualified; see cf/README: WHO AM I?",
            MyHostName);
    }
  }
  {
#line 1750
  setclass('w', MyHostName);
#line 1753
  st = stab((char *)"mqueue", 15, 0);
  }
#line 1754
  if ((unsigned long )st == (unsigned long )((void *)0)) {
    {
#line 1755
    syserr("No default queue (mqueue) defined");
    }
  } else {
    {
#line 1757
    set_def_queueval(st->s_value.sv_queue, 1);
    }
  }
  {
#line 1760
  st = stab((char *)"local", 3, 0);
  }
#line 1761
  if ((unsigned long )st != (unsigned long )((void *)0)) {
#line 1762
    LocalMailer = st->s_value.sv_mailer;
  } else
#line 1763
  if ((int )OpMode != 116) {
    {
#line 1764
    syserr("No local mailer defined");
    }
  } else
#line 1763
  if (! warn_C_flag) {
    {
#line 1764
    syserr("No local mailer defined");
    }
  }
  {
#line 1766
  st = stab((char *)"prog", 3, 0);
  }
#line 1767
  if ((unsigned long )st == (unsigned long )((void *)0)) {
    {
#line 1768
    syserr("No prog mailer defined");
    }
  } else {
#line 1771
    ProgMailer = st->s_value.sv_mailer;
#line 1772
    ProgMailer->m_flags[109UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] &= ~ (1U << 109UL % (8UL * sizeof(int )));
  }
  {
#line 1775
  st = stab((char *)"*file*", 3, 0);
  }
#line 1776
  if ((unsigned long )st == (unsigned long )((void *)0)) {
    {
#line 1777
    syserr("No *file* mailer defined");
    }
  } else {
#line 1780
    FileMailer = st->s_value.sv_mailer;
#line 1781
    FileMailer->m_flags[109UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] &= ~ (1U << 109UL % (8UL * sizeof(int )));
  }
  {
#line 1784
  st = stab((char *)"*include*", 3, 0);
  }
#line 1785
  if ((unsigned long )st == (unsigned long )((void *)0)) {
    {
#line 1786
    syserr("No *include* mailer defined");
    }
  } else {
#line 1788
    InclMailer = st->s_value.sv_mailer;
  }
#line 1790
  if (ConfigLevel < 6) {
#line 1793
    if ((unsigned long )LocalMailer != (unsigned long )((void *)0)) {
#line 1795
      LocalMailer->m_flags[65UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 65UL % (8UL * sizeof(int ));
#line 1796
      LocalMailer->m_flags[119UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 119UL % (8UL * sizeof(int ));
#line 1797
      LocalMailer->m_flags[53UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 53UL % (8UL * sizeof(int ));
#line 1798
      LocalMailer->m_flags[58UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 58UL % (8UL * sizeof(int ));
#line 1799
      LocalMailer->m_flags[124UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 124UL % (8UL * sizeof(int ));
#line 1800
      LocalMailer->m_flags[47UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 47UL % (8UL * sizeof(int ));
#line 1801
      LocalMailer->m_flags[64UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 64UL % (8UL * sizeof(int ));
    }
#line 1803
    if ((unsigned long )ProgMailer != (unsigned long )((void *)0)) {
#line 1804
      ProgMailer->m_flags[111UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 111UL % (8UL * sizeof(int ));
    }
#line 1805
    if ((unsigned long )FileMailer != (unsigned long )((void *)0)) {
#line 1806
      FileMailer->m_flags[111UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 111UL % (8UL * sizeof(int ));
    }
  }
#line 1808
  if (ConfigLevel < 7) {
#line 1810
    if ((unsigned long )LocalMailer != (unsigned long )((void *)0)) {
#line 1811
      LocalMailer->m_flags[113UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 113UL % (8UL * sizeof(int ));
    }
#line 1812
    if ((unsigned long )ProgMailer != (unsigned long )((void *)0)) {
#line 1813
      ProgMailer->m_flags[113UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 113UL % (8UL * sizeof(int ));
    }
#line 1814
    if ((unsigned long )FileMailer != (unsigned long )((void *)0)) {
#line 1815
      FileMailer->m_flags[113UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] |= 1U << 113UL % (8UL * sizeof(int ));
    }
  }
  {
#line 1819
  setclass('n', (char *)"multipart/signed");
#line 1822
  setclass('s', (char *)"rfc822");
#line 1825
  setclass('e', (char *)"7bit");
#line 1826
  setclass('e', (char *)"8bit");
#line 1827
  setclass('e', (char *)"binary");
#line 1838
  tmp___124 = macid_parse((char *)"{checkMIMEFieldHeaders}", (char **)((void *)0));
#line 1838
  setclass(tmp___124, (char *)"content-disposition");
#line 1839
  tmp___125 = macid_parse((char *)"{checkMIMEFieldHeaders}", (char **)((void *)0));
#line 1839
  setclass(tmp___125, (char *)"content-type");
#line 1842
  tmp___126 = macid_parse((char *)"{checkMIMETextHeaders}", (char **)((void *)0));
#line 1842
  setclass(tmp___126, (char *)"content-description");
#line 1845
  tmp___127 = macid_parse((char *)"{checkMIMEHeaders}", (char **)((void *)0));
#line 1845
  setclass(tmp___127, (char *)"content-disposition");
#line 1846
  tmp___128 = macid_parse((char *)"{checkMIMEHeaders}", (char **)((void *)0));
#line 1846
  setclass(tmp___128, (char *)"content-id");
#line 1847
  tmp___129 = macid_parse((char *)"{checkMIMEHeaders}", (char **)((void *)0));
#line 1847
  setclass(tmp___129, (char *)"content-transfer-encoding");
#line 1848
  tmp___130 = macid_parse((char *)"{checkMIMEHeaders}", (char **)((void *)0));
#line 1848
  setclass(tmp___130, (char *)"content-type");
#line 1849
  tmp___131 = macid_parse((char *)"{checkMIMEHeaders}", (char **)((void *)0));
#line 1849
  setclass(tmp___131, (char *)"mime-version");
#line 1852
  tmp___132 = macid_parse((char *)"{persistentMacros}", (char **)((void *)0));
#line 1852
  setclass(tmp___132, (char *)"r");
#line 1853
  tmp___133 = macid_parse((char *)"{persistentMacros}", (char **)((void *)0));
#line 1853
  setclass(tmp___133, (char *)"s");
#line 1854
  tmp___134 = macid_parse((char *)"{persistentMacros}", (char **)((void *)0));
#line 1854
  setclass(tmp___134, (char *)"_");
#line 1855
  tmp___135 = macid_parse((char *)"{persistentMacros}", (char **)((void *)0));
#line 1855
  setclass(tmp___135, (char *)"{if_addr}");
#line 1856
  tmp___136 = macid_parse((char *)"{persistentMacros}", (char **)((void *)0));
#line 1856
  setclass(tmp___136, (char *)"{daemon_flags}");
  }
#line 1859
  if ((unsigned long )QueueDir == (unsigned long )((void *)0)) {
#line 1859
    goto _L___2;
  } else
#line 1859
  if ((int )*QueueDir == 0) {
    _L___2: /* CIL Label */ 
#line 1861
    if ((int )OpMode != 116) {
      {
#line 1863
      syserr("QueueDirectory (Q) option must be set");
#line 1864
      ExitStat = 78;
      }
    }
  } else
#line 1869
  if ((int )OpMode != 116) {
    {
#line 1870
    setup_queues((int )OpMode == 100);
    }
  }
#line 1874
  if ((unsigned long )HostStatDir != (unsigned long )((void *)0)) {
    {
#line 1874
    tmp___139 = path_is_dir(HostStatDir, 0);
    }
#line 1874
    if (! tmp___139) {
      {
#line 1877
      tmp___137 = __errno_location();
#line 1877
      tmp___138 = sm_errstring(*tmp___137);
#line 1877
      sm_io_fprintf(& SmIoF[1], -2, "Warning: Cannot use HostStatusDirectory = %s: %s\n",
                    HostStatDir, tmp___138);
#line 1880
      HostStatDir = (char *)((void *)0);
      }
    }
  }
#line 1883
  if ((int )OpMode == 113) {
#line 1883
    if (RealUid != 0U) {
#line 1883
      if ((PrivacyFlags & 131072UL) != 0UL) {
        {
#line 1889
        tmp___140 = stat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& stbuf));
        }
#line 1889
        if (tmp___140 < 0) {
          {
#line 1890
          syserr("main: cannot stat %s", QueueDir);
          }
        }
#line 1891
        if (stbuf.st_uid != RealUid) {
          {
#line 1894
          HoldErrs = 0;
#line 1895
          usrerr("You do not have permission to process the queue");
#line 1896
          finis(0, 1, (int volatile   )77);
          }
        }
      }
    }
  }
#line 1903
  if ((int )OpMode == 100) {
    {
#line 1905
    milter_config(InputFilterList, InputFilters, 25);
#line 1906
    setup_daemon_milters();
    }
  } else
#line 1903
  if ((int )OpMode == 115) {
    {
#line 1905
    milter_config(InputFilterList, InputFilters, 25);
#line 1906
    setup_daemon_milters();
    }
  }
#line 1911
  if ((unsigned long )queuegroup != (unsigned long )((void *)0)) {
    {
#line 1913
    qgrp = name2qid(queuegroup);
    }
#line 1914
    if (qgrp == -1) {
      {
#line 1916
      HoldErrs = 0;
#line 1917
      usrerr("Queue group %s unknown", queuegroup);
#line 1918
      finis(0, 1, (int volatile   )ExitStat);
      }
    }
  }
#line 1924
  if (ExitStat != 0) {
#line 1924
    if ((int )OpMode != 116) {
      {
#line 1926
      finis(0, 1, (int volatile   )ExitStat);
      }
    }
  }
  {
#line 1936
  checkfd012((char *)"before main() initmaps");
  }
  {
#line 1945
  if ((int )OpMode == 112) {
#line 1945
    goto case_112___3;
  }
#line 1969
  if ((int )OpMode == 80) {
#line 1969
    goto case_80___1;
  }
#line 1978
  if ((int )OpMode == 113) {
#line 1978
    goto case_113___2;
  }
#line 1996
  if ((int )OpMode == 104) {
#line 1996
    goto case_104___2;
  }
#line 2003
  if ((int )OpMode == 72) {
#line 2003
    goto case_72___1;
  }
#line 2009
  if ((int )OpMode == 105) {
#line 2009
    goto case_105___3;
  }
#line 2017
  if ((int )OpMode == 100) {
#line 2017
    goto case_100___4;
  }
#line 2017
  if ((int )OpMode == 115) {
#line 2017
    goto case_100___4;
  }
#line 1943
  goto switch_break___6;
  case_112___3: /* CIL Label */ 
  {
#line 1947
  HoldErrs = 0;
#line 1948
  dropenvelope(& BlankEnvelope, 1, 0);
#line 1949
  sm_signal(13, & sigpipe);
  }
#line 1950
  if (qgrp != -1) {
#line 1955
    j___0 = 0;
    {
#line 1955
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1955
      if (! (j___0 < (Queue[qgrp])->qg_numqueues)) {
#line 1955
        goto while_break___10;
      }
#line 1957
      if (StopRequest) {
        {
#line 1958
        stop_sendmail();
        }
      }
      {
#line 1959
      print_single_queue(qgrp, j___0);
#line 1955
      j___0 ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 1961
    finis(0, 1, (int volatile   )0);
    }
  }
  {
#line 1964
  printqueue();
#line 1965
  finis(0, 1, (int volatile   )0);
  }
#line 1967
  goto switch_break___6;
  case_80___1: /* CIL Label */ 
  {
#line 1971
  dropenvelope(& BlankEnvelope, 1, 0);
#line 1972
  sm_signal(13, & sigpipe);
#line 1973
  printnqe(& SmIoF[1], (char *)((void *)0));
#line 1974
  finis(0, 1, (int volatile   )0);
  }
#line 1976
  goto switch_break___6;
  case_113___2: /* CIL Label */ 
#line 1980
  if ((unsigned long )quarantining == (unsigned long )((void *)0)) {
#line 1981
    goto switch_break___6;
  }
#line 1983
  if (QueueMode != 81) {
#line 1983
    if (QueueMode != 32) {
      {
#line 1986
      HoldErrs = 0;
#line 1987
      usrerr("Can not use -Q with -q%c", QueueMode);
#line 1988
      ExitStat = 64;
#line 1989
      finis(0, 1, (int volatile   )ExitStat);
      }
    }
  }
  {
#line 1992
  quarantine_queue(quarantining, qgrp);
#line 1993
  finis(0, 1, (int volatile   )0);
  }
#line 1994
  goto switch_break___6;
  case_104___2: /* CIL Label */ 
  {
#line 1997
  sm_signal(13, & sigpipe);
#line 1998
  mci_traverse_persistent((int (*)())(& mci_print_persistent), (char *)((void *)0));
#line 1999
  finis(0, 1, (int volatile   )0);
  }
#line 2001
  goto switch_break___6;
  case_72___1: /* CIL Label */ 
  {
#line 2004
  mci_traverse_persistent((int (*)())(& mci_purge_persistent), (char *)((void *)0));
#line 2005
  finis(0, 1, (int volatile   )0);
  }
#line 2007
  goto switch_break___6;
  case_105___3: /* CIL Label */ 
  {
#line 2011
  initmaps();
#line 2012
  finis(0, 1, (int volatile   )ExitStat);
  }
#line 2014
  goto switch_break___6;
  case_100___4: /* CIL Label */ 
  case_115___1: /* CIL Label */ 
  {
#line 2019
  DefaultNotify = 384;
#line 2020
  tmp___141 = macid_parse((char *)"{dsn_notify}", (char **)((void *)0));
#line 2020
  macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___141, (char *)((void *)0),
                   (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                   2021, SmHeapGroup);
#line 2022
  BlankEnvelope.e_envid = (char *)((void *)0);
#line 2023
  tmp___142 = macid_parse((char *)"{dsn_envid}", (char **)((void *)0));
#line 2023
  macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___142, (char *)((void *)0),
                   (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                   2024, SmHeapGroup);
#line 2025
  BlankEnvelope.e_flags &= 0xffffffffffeffffbUL;
#line 2026
  tmp___143 = macid_parse((char *)"{dsn_ret}", (char **)((void *)0));
#line 2026
  macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___143, (char *)((void *)0),
                   (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                   2027, SmHeapGroup);
  }
#line 2030
  goto switch_break___6;
  switch_break___6: /* CIL Label */ ;
  }
#line 2033
  if ((int )tTdvect[0] >= 15) {
#line 2036
    if ((int )tTdvect[0] >= 90) {
      {
#line 2037
      printrules();
      }
    }
#line 2038
    i = 0;
    {
#line 2038
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 2038
      if (! (i < 25)) {
#line 2038
        goto while_break___11;
      }
#line 2040
      if ((unsigned long )Mailer[i] != (unsigned long )((void *)0)) {
        {
#line 2041
        tmp___144 = sm_debug_file();
#line 2041
        printmailer(tmp___144, Mailer[i]);
        }
      }
#line 2038
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  {
#line 2049
  tmp___145 = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 2049
  CurEnv = newenvelope(& MainEnvelope, & BlankEnvelope, tmp___145);
#line 2051
  MainEnvelope.e_flags = BlankEnvelope.e_flags;
  }
#line 2057
  if ((int )OpMode == 116) {
    {
#line 2059
    tmp___146 = sm_io_getinfo(& SmIoF[0], 3, (void *)0);
#line 2059
    tmp___147 = isatty(tmp___146);
    }
#line 2059
    if (tmp___147) {
#line 2060
      Verbose = 2;
    }
#line 2062
    if (Verbose) {
      {
#line 2064
      sm_io_fprintf(& SmIoF[1], -2, "ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)\n");
#line 2066
      sm_io_fprintf(& SmIoF[1], -2, "Enter <ruleset> <address>\n");
      }
    }
    {
#line 2069
    tmp___148 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 2069
    macdefine_tagged(& MainEnvelope.e_macro, (ARGCLASS_T )2, tmp___148, (char *)"e r",
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     2070, SmHeapGroup);
    }
    {
#line 2071
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 2073
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 2073
        _h.eh_value = (SM_EXC_T *)((void *)0);
#line 2073
        _h.eh_parent = SmExcHandler;
#line 2073
        _h.eh_state = 2;
#line 2073
        SmExcHandler = & _h;
#line 2073
        tmp___150 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
        }
#line 2073
        if (tmp___150 == 0) {
          {
#line 2075
          sm_signal(2, & intindebug);
#line 2076
          sm_releasesignal(2);
          }
#line 2077
          if (Verbose == 2) {
            {
#line 2078
            sm_io_fprintf(& SmIoF[1], -2, "> ");
            }
          }
          {
#line 2081
          sm_io_flush(& SmIoF[1], -2);
#line 2082
          tmp___149 = sm_io_fgets(& SmIoF[0], -2, buf___16, (int )sizeof(buf___16));
          }
#line 2082
          if ((unsigned long )tmp___149 == (unsigned long )((void *)0)) {
            {
#line 2084
            testmodeline((char *)"/quit", & MainEnvelope);
            }
          }
          {
#line 2085
          p = strchr((char const   *)(buf___16), '\n');
          }
#line 2086
          if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2087
            *p = (char )'\000';
          }
#line 2088
          if (Verbose < 2) {
            {
#line 2089
            sm_io_fprintf(& SmIoF[1], -2, "> %s\n", buf___16);
            }
          }
          {
#line 2092
          testmodeline(buf___16, & MainEnvelope);
          }
        }
#line 2094
        if (_h.eh_state == 1) {
#line 2094
          goto while_break___13;
        }
#line 2094
        if (_h.eh_state == 2) {
#line 2094
          if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 2094
            tmp___151 = 1;
          } else {
            {
#line 2094
            sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                        2094, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2094
            tmp___151 = 0;
            }
          }
#line 2094
          SmExcHandler = _h.eh_parent;
        }
        {
#line 2094
        tmp___153 = sm_exc_match(_h.eh_value, "[!F]*");
        }
#line 2094
        if (tmp___153) {
#line 2094
          _h.eh_state = 1;
        } else {
#line 2094
          _h.eh_state = 0;
        }
#line 2094
        if (_h.eh_state == 1) {
          {
#line 2094
          exc = _h.eh_value;
#line 2103
          sm_io_fprintf(& SmIoF[1], -2, "\n");
#line 2105
          sm_exc_print(exc, & SmIoF[1]);
          }
        }
#line 2073
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 2107
      if (_h.eh_state == 2) {
#line 2107
        if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 2107
          tmp___154 = 1;
        } else {
          {
#line 2107
          sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                      2107, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2107
          tmp___154 = 0;
          }
        }
#line 2107
        SmExcHandler = _h.eh_parent;
#line 2107
        if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
          {
#line 2107
          sm_exc_raise_x(_h.eh_value);
          }
        }
      } else
#line 2107
      if (_h.eh_state == 0) {
#line 2107
        if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
          {
#line 2107
          sm_exc_raise_x(_h.eh_value);
          }
        }
      } else {
        {
#line 2107
        sm_exc_free(_h.eh_value);
        }
      }
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 2146
  if ((int )OpMode == 113) {
#line 2146
    if (QueueIntvl == 0L) {
#line 2148
      pid = -1;
#line 2164
      if (Verbose) {
#line 2164
        goto _L___3;
      } else
#line 2164
      if (foregroundqueue) {
#line 2164
        goto _L___3;
      } else {
        {
#line 2164
        pid = fork();
        }
#line 2164
        if (pid <= 0) {
          _L___3: /* CIL Label */ 
#line 2173
          if (pid == 0) {
            {
#line 2176
            RestartRequest = (char */* volatile  */)((void *)0);
#line 2177
            ShutdownRequest = (char */* volatile  */)((void *)0);
#line 2178
            PendingSignal = (int volatile   )0;
#line 2181
            disconnect(2, CurEnv);
            }
          }
          {
#line 2184
          CurrentPid = getpid();
          }
#line 2185
          if (qgrp != -1) {
#line 2187
            rwgflags = 0;
#line 2195
            i = 0;
            {
#line 2195
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 2195
              if (i < NumQueue) {
#line 2195
                if (! ((unsigned long )Queue[i] != (unsigned long )((void *)0))) {
#line 2195
                  goto while_break___14;
                }
              } else {
#line 2195
                goto while_break___14;
              }
#line 2197
              (Queue[i])->qg_nextrun = (time_t )-1;
#line 2195
              i ++;
            }
            while_break___14: /* CIL Label */ ;
            }
#line 2198
            (Queue[qgrp])->qg_nextrun = (time_t )0;
#line 2199
            if (Verbose) {
#line 2200
              rwgflags |= 2;
            }
#line 2201
            if (queuepersistent) {
#line 2202
              rwgflags |= 4;
            }
            {
#line 2203
            rwgflags |= 8;
#line 2204
            run_work_group((Queue[qgrp])->qg_wgrp, rwgflags);
            }
          } else {
            {
#line 2208
            runqueue(0, Verbose, queuepersistent, 1);
            }
          }
          {
#line 2212
          sm_setproctitle(1, CurEnv, "Queue control");
#line 2213
          sm_signal(17, (void (*)(int  ))0);
          }
          {
#line 2214
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 2214
            if (! (CurChildren > (int volatile   )0)) {
#line 2214
              goto while_break___15;
            }
            {
#line 2219
            tmp___155 = __errno_location();
#line 2219
            *tmp___155 = 0;
            }
            {
#line 2220
            while (1) {
              while_continue___16: /* CIL Label */ ;
              {
#line 2220
              ret = sm_wait(& status);
              }
#line 2220
              if (! (ret <= 0)) {
#line 2220
                goto while_break___16;
              }
              {
#line 2222
              tmp___156 = __errno_location();
              }
#line 2222
              if (*tmp___156 == 10) {
#line 2232
                CurChildren = (int volatile   )0;
#line 2233
                goto while_break___16;
              }
#line 2235
              goto while_continue___16;
            }
            while_break___16: /* CIL Label */ ;
            }
            {
#line 2239
            tmp___157 = __errno_location();
            }
#line 2239
            if (*tmp___157 == 10) {
              {
#line 2241
              sm_syslog(3, "*~*", "queue control process: lost all children: wait returned ECHILD");
              }
#line 2243
              goto while_break___15;
            }
#line 2247
            __u.__in = status;
#line 2247
            if ((__u.__i & 255) == 127) {
#line 2248
              goto while_continue___15;
            }
            {
#line 2250
            proc_list_drop(ret, status, (int *)((void *)0));
            }
          }
          while_break___15: /* CIL Label */ ;
          }
        }
      }
      {
#line 2253
      finis(1, 1, (int volatile   )ExitStat);
      }
    }
  }
#line 2268
  if ((int )OpMode == 115) {
    {
#line 2270
    proc_list_add(CurrentPid, (char *)"Sendmail SMTP Agent", 1, 0, -1, (union bigsockaddr *)((void *)0));
#line 2274
    sm_signal(17, & reapchild);
    }
  }
#line 2286
  if ((int )OpMode == 100) {
#line 2286
    goto _L___4;
  } else
#line 2286
  if (QueueIntvl > 0L) {
    _L___4: /* CIL Label */ 
#line 2290
    if (! run_in_foreground) {
#line 2290
      if (! ((int )tTdvect[99] >= 100)) {
        {
#line 2293
        i = fork();
        }
#line 2294
        if (i < 0) {
          {
#line 2295
          syserr("daemon: cannot fork");
          }
        }
#line 2296
        if (i != 0) {
          {
#line 2298
          finis(0, 1, (int volatile   )0);
          }
        }
        {
#line 2308
        RestartRequest = (char */* volatile  */)((void *)0);
#line 2309
        RestartWorkGroup = (bool volatile   )0;
#line 2310
        ShutdownRequest = (char */* volatile  */)((void *)0);
#line 2311
        PendingSignal = (int volatile   )0;
#line 2312
        CurrentPid = getpid();
#line 2314
        sm_exc_newthread(& fatal_error);
#line 2317
        disconnect(2, & MainEnvelope);
        }
      }
    }
#line 2320
    dtype[0] = (char )'\000';
#line 2321
    if ((int )OpMode == 100) {
      {
#line 2323
      sm_strlcat(dtype, "+SMTP", (ssize_t )sizeof(dtype));
#line 2324
      DaemonPid = CurrentPid;
      }
    }
#line 2326
    if (QueueIntvl > 0L) {
      {
#line 2328
      tmp___158 = pintvl(QueueIntvl, 1);
      }
#line 2328
      if (queuepersistent) {
#line 2328
        tmp___159 = "+persistent-queueing@";
      } else {
#line 2328
        tmp___159 = "+queueing@";
      }
      {
#line 2328
      sm_strlcat2(dtype, tmp___159, (char const   *)tmp___158, (ssize_t )sizeof(dtype));
      }
    }
#line 2335
    if ((int )tTdvect[0] >= 1) {
      {
#line 2336
      sm_strlcat(dtype, "+debugging", (ssize_t )sizeof(dtype));
      }
    }
    {
#line 2338
    sm_syslog(6, "*~*", "starting daemon (%s): %s", Version, dtype + 1);
#line 2345
    tmp___160 = macid_parse((char *)"{daemon_info}", (char **)((void *)0));
#line 2345
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___160, dtype + 1,
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     2346, SmHeapGroup);
#line 2349
    tmp___161 = pintvl(QueueIntvl, 1);
#line 2349
    tmp___162 = macid_parse((char *)"{queue_interval}", (char **)((void *)0));
#line 2349
    macdefine_tagged(& MainEnvelope.e_macro, (ARGCLASS_T )1, tmp___162, tmp___161,
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     2350, SmHeapGroup);
#line 2353
    sm_signal(1, & sighup);
#line 2354
    sm_releasesignal(1);
#line 2355
    sm_signal(15, & sigterm);
    }
#line 2357
    if (QueueIntvl > 0L) {
      {
#line 2359
      runqueue(1, 0, queuepersistent, 1);
      }
#line 2368
      if ((int )OpMode != 100) {
#line 2368
        if (queuepersistent) {
          {
#line 2375
          log_sendmail_pid(& MainEnvelope);
#line 2378
          sm_setproctitle(1, CurEnv, "Queue control");
#line 2379
          sm_signal(17, (void (*)(int  ))0);
          }
          {
#line 2380
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 2380
            if (! (CurChildren > (int volatile   )0)) {
#line 2380
              goto while_break___17;
            }
            {
#line 2386
            while (1) {
              while_continue___18: /* CIL Label */ ;
#line 2386
              if ((unsigned long )ShutdownRequest != (unsigned long )((void *)0)) {
                {
#line 2386
                shutdown_daemon();
                }
              } else
#line 2386
              if ((unsigned long )RestartRequest != (unsigned long )((void *)0)) {
                {
#line 2386
                restart_daemon();
                }
              } else
#line 2386
              if (RestartWorkGroup) {
                {
#line 2386
                restart_marked_work_groups();
                }
              }
#line 2386
              goto while_break___18;
            }
            while_break___18: /* CIL Label */ ;
            }
            {
#line 2387
            tmp___163 = __errno_location();
#line 2387
            *tmp___163 = 0;
            }
            {
#line 2388
            while (1) {
              while_continue___19: /* CIL Label */ ;
              {
#line 2388
              ret___0 = sm_wait(& status___0);
              }
#line 2388
              if (! (ret___0 <= 0)) {
#line 2388
                goto while_break___19;
              }
              {
#line 2397
              tmp___164 = __errno_location();
              }
#line 2397
              if (*tmp___164 == 10) {
#line 2399
                CurChildren = (int volatile   )0;
#line 2400
                goto while_break___19;
              }
#line 2402
              goto while_continue___19;
            }
            while_break___19: /* CIL Label */ ;
            }
            {
#line 2406
            tmp___165 = __errno_location();
            }
#line 2406
            if (*tmp___165 == 10) {
              {
#line 2408
              sm_syslog(3, "*~*", "persistent queue runner control process: lost all children: wait returned ECHILD");
              }
#line 2410
              goto while_break___17;
            }
#line 2413
            __u___0.__in = status___0;
#line 2413
            if ((__u___0.__i & 255) == 127) {
#line 2414
              goto while_continue___17;
            }
            {
#line 2417
            proc_list_drop(ret___0, status___0, & group);
#line 2419
            __u___4.__in = status___0;
            }
#line 2419
            if ((int )((signed char )((__u___4.__i & 127) + 1)) >> 1 > 0) {
#line 2421
              __u___2.__in = status___0;
#line 2421
              if (__u___2.__i & 128) {
                {
#line 2425
                __u___1.__in = status___0;
#line 2425
                sm_syslog(3, "*~*", "persistent queue runner=%d core dumped, signal=%d",
                          group, __u___1.__i & 127);
#line 2428
                mark_work_group_restart(group, -1);
                }
#line 2430
                goto while_continue___17;
              }
              {
#line 2435
              __u___3.__in = status___0;
#line 2435
              sm_syslog(3, "*~*", "persistent queue runner=%d died, signal=%d", group,
                        __u___3.__i & 127);
              }
            }
#line 2444
            if (DebugNoPRestart.debug_level >= 1U) {
#line 2444
              if (DebugNoPRestart.debug_level != 4294967295U) {
                {
#line 2447
                sm_syslog(7, "*~*", "persistent queue runner=%d, exited", group);
#line 2450
                mark_work_group_restart(group, -1);
                }
              } else {
                {
#line 2444
                tmp___166 = sm_debug_loadactive(& DebugNoPRestart, 1);
                }
#line 2444
                if (tmp___166) {
                  {
#line 2447
                  sm_syslog(7, "*~*", "persistent queue runner=%d, exited", group);
#line 2450
                  mark_work_group_restart(group, -1);
                  }
                }
              }
            }
          }
          while_break___17: /* CIL Label */ ;
          }
          {
#line 2454
          finis(1, 1, (int volatile   )ExitStat);
          }
        }
      }
#line 2458
      if ((int )OpMode != 100) {
        {
#line 2467
        log_sendmail_pid(& MainEnvelope);
#line 2470
        qtype[0] = (char )'\000';
#line 2471
        tmp___167 = pintvl(QueueIntvl, 1);
#line 2471
        sm_strlcpyn(qtype, (ssize_t )sizeof(qtype), 4, "Queue runner@", tmp___167,
                    " for ", QueueDir);
#line 2476
        sm_setproctitle(1, CurEnv, (char const   *)(qtype));
        }
        {
#line 2477
        while (1) {
          while_continue___20: /* CIL Label */ ;
          {
#line 2479
          pause();
          }
          {
#line 2481
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 2481
            if ((unsigned long )ShutdownRequest != (unsigned long )((void *)0)) {
              {
#line 2481
              shutdown_daemon();
              }
            } else
#line 2481
            if ((unsigned long )RestartRequest != (unsigned long )((void *)0)) {
              {
#line 2481
              restart_daemon();
              }
            } else
#line 2481
            if (RestartWorkGroup) {
              {
#line 2481
              restart_marked_work_groups();
              }
            }
#line 2481
            goto while_break___21;
          }
          while_break___21: /* CIL Label */ ;
          }
          {
#line 2483
          tmp___168 = doqueuerun();
          }
#line 2483
          if (tmp___168) {
            {
#line 2484
            runqueue(1, 0, 0, 0);
            }
          }
        }
        while_break___20: /* CIL Label */ ;
        }
      }
    }
    {
#line 2489
    dropenvelope(& MainEnvelope, 1, 0);
    }
    nextreq: 
    {
#line 2497
    p_flags = getrequests(& MainEnvelope);
#line 2500
    drop_privileges(0);
#line 2507
    tmp___169 = sm_io_getinfo(InChannel, 3, (void *)0);
#line 2507
    authinfo = getauthinfo(tmp___169, & forged);
#line 2509
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, '_', authinfo, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     2509, SmHeapGroup);
#line 2512
    sm_rpool_free(MainEnvelope.e_rpool);
#line 2513
    tmp___170 = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 2513
    newenvelope(& MainEnvelope, & MainEnvelope, tmp___170);
    }
  }
#line 2517
  if (LogLevel > 9) {
    {
#line 2520
    sm_syslog(6, (char const   *)((void *)0), "connect from %s", authinfo);
    }
  }
#line 2528
  if ((int )OpMode == 115) {
#line 2528
    goto _L___5;
  } else
#line 2528
  if ((int )OpMode == 100) {
    _L___5: /* CIL Label */ 
#line 2536
    if (forged) {
      {
#line 2540
      tmp___171 = anynet_ntoa(& RealHostAddr);
#line 2540
      sm_snprintf(ipbuf___0, (size_t )sizeof(ipbuf___0), "[%.100s]", tmp___171);
#line 2542
      tmp___172 = macid_parse((char *)"{client_name}", (char **)((void *)0));
#line 2542
      macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___172, ipbuf___0,
                       (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                       2543, SmHeapGroup);
      }
    } else {
      {
#line 2546
      tmp___173 = macid_parse((char *)"{client_name}", (char **)((void *)0));
#line 2546
      macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___173, RealHostName,
                       (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                       2547, SmHeapGroup);
      }
    }
    {
#line 2548
    tmp___174 = macid_parse((char *)"{client_ptr}", (char **)((void *)0));
#line 2548
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )2, tmp___174, RealHostName,
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     2549, SmHeapGroup);
#line 2550
    tmp___175 = anynet_ntoa(& RealHostAddr);
#line 2550
    tmp___176 = macid_parse((char *)"{client_addr}", (char **)((void *)0));
#line 2550
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___176, tmp___175,
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     2551, SmHeapGroup);
#line 2552
    sm_getla();
    }
    {
#line 2557
    if ((int )RealHostAddr.sa.sa_family == 2) {
#line 2557
      goto case_2___0;
    }
#line 2568
    goto switch_default___4;
    case_2___0: /* CIL Label */ 
    {
#line 2558
    sm_snprintf(pbuf, (size_t )sizeof(pbuf), "%d", (int )RealHostAddr.sin.sin_port);
    }
#line 2560
    goto switch_break___7;
    switch_default___4: /* CIL Label */ 
    {
#line 2569
    sm_snprintf(pbuf, (size_t )sizeof(pbuf), "0");
    }
#line 2570
    goto switch_break___7;
    switch_break___7: /* CIL Label */ ;
    }
    {
#line 2572
    tmp___177 = macid_parse((char *)"{client_port}", (char **)((void *)0));
#line 2572
    macdefine_tagged(& BlankEnvelope.e_macro, (ARGCLASS_T )1, tmp___177, pbuf, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     2573, SmHeapGroup);
    }
#line 2575
    if ((int )OpMode == 100) {
      {
#line 2578
      HoldErrs = 1;
#line 2579
      tmp___178 = macid_parse((char *)"{client_name}", (char **)((void *)0));
#line 2579
      tmp___179 = macvalue(tmp___178, & MainEnvelope);
#line 2579
      nullserver = validate_connection(& RealHostAddr, tmp___179, & MainEnvelope);
#line 2583
      HoldErrs = 0;
      }
    } else
#line 2585
    if ((unsigned long )p_flags == (unsigned long )((void *)0)) {
      {
#line 2587
      tmp___180 = xalloc_tagged((int )sizeof(*p_flags), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                                2587);
#line 2587
      p_flags = (BITMAP256 *)tmp___180;
#line 2588
      memset((void *)((char *)p_flags), '\000', (size_t )32);
      }
    }
    {
#line 2597
    smtp((char */* volatile  */)nullserver, (unsigned int *)(*p_flags), (ENVELOPE */* volatile  */)(& MainEnvelope));
    }
#line 2599
    if ((int )tTdvect[93] >= 100) {
#line 2603
      if ((int )OpMode == 100) {
#line 2604
        goto nextreq;
      }
    }
  }
  {
#line 2608
  sm_rpool_free(MainEnvelope.e_rpool);
#line 2609
  tmp___181 = sm_rpool_new_x((SM_RPOOL_T *)((void *)0));
#line 2609
  clearenvelope(& MainEnvelope, 0, tmp___181);
  }
#line 2610
  if ((int )OpMode == 118) {
    {
#line 2612
    set_delivery_mode('v', & MainEnvelope);
#line 2613
    PostMasterCopy = (char *)((void *)0);
    }
  } else {
#line 2618
    MainEnvelope.e_flags |= 36864UL;
  }
  {
#line 2625
  initsys(& MainEnvelope);
#line 2626
  tmp___182 = macid_parse((char *)"{ntries}", (char **)((void *)0));
#line 2626
  macdefine_tagged(& MainEnvelope.e_macro, (ARGCLASS_T )2, tmp___182, (char *)"0",
                   (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                   2626, SmHeapGroup);
#line 2627
  tmp___183 = macid_parse((char *)"{nrcpts}", (char **)((void *)0));
#line 2627
  macdefine_tagged(& MainEnvelope.e_macro, (ARGCLASS_T )2, tmp___183, (char *)"0",
                   (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                   2627, SmHeapGroup);
#line 2628
  setsender(from, & MainEnvelope, (char **)((void *)0), '\000', 0);
  }
#line 2629
  if ((int )warn_f_flag != 0) {
    {
#line 2629
    tmp___184 = wordinclass(RealUserName, 't');
    }
#line 2629
    if (! tmp___184) {
#line 2629
      if (! ((MainEnvelope.e_from.q_mailer)->m_flags[108UL / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << 108UL % (8UL * sizeof(int ))))) {
        {
#line 2633
        auth_warning(& MainEnvelope, "%s set sender to %s using -%c", RealUserName,
                     from, (int )warn_f_flag);
        }
      } else {
        {
#line 2629
        tmp___185 = strcmp((char const   *)MainEnvelope.e_from.q_user, (char const   *)RealUserName);
        }
#line 2629
        if (tmp___185 != 0) {
          {
#line 2633
          auth_warning(& MainEnvelope, "%s set sender to %s using -%c", RealUserName,
                       from, (int )warn_f_flag);
          }
        }
      }
    }
  }
#line 2639
  if (auth) {
    {
#line 2644
    fv = macvalue('f', & MainEnvelope);
    }
#line 2645
    if ((unsigned long )fv == (unsigned long )((void *)0)) {
#line 2646
      MainEnvelope.e_auth_param = (char *)((void *)0);
    } else
#line 2645
    if ((int )*fv == 0) {
#line 2646
      MainEnvelope.e_auth_param = (char *)((void *)0);
    } else {
      {
#line 2649
      tmp___191 = strchr((char const   *)fv, '@');
      }
#line 2649
      if ((unsigned long )tmp___191 == (unsigned long )((void *)0)) {
        {
#line 2651
        tmp___186 = strlen((char const   *)fv);
#line 2651
        tmp___187 = macvalue('j', & MainEnvelope);
#line 2651
        tmp___188 = strlen((char const   *)tmp___187);
#line 2651
        i = (int )((tmp___186 + tmp___188) + 2U);
#line 2653
        tmp___189 = sm_malloc_tagged_x((size_t )i, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                                       2653, SmHeapGroup);
#line 2653
        p = (char *)tmp___189;
#line 2654
        tmp___190 = macvalue('j', & MainEnvelope);
#line 2654
        sm_strlcpyn(p, i, 3, fv, "@", tmp___190);
        }
      } else {
        {
#line 2659
        p = sm_strdup_x((char const   *)fv);
        }
      }
      {
#line 2660
      tmp___192 = xtextify(p, (char *)"=");
#line 2660
      MainEnvelope.e_auth_param = sm_rpool_strdup_x(MainEnvelope.e_rpool, (char const   *)tmp___192);
#line 2662
      sm_free_tagged((void *)p, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     2662);
      }
    }
  }
  {
#line 2665
  tmp___193 = macvalue('s', & MainEnvelope);
  }
#line 2665
  if ((unsigned long )tmp___193 == (unsigned long )((void *)0)) {
    {
#line 2666
    macdefine_tagged(& MainEnvelope.e_macro, (ARGCLASS_T )2, 's', RealHostName, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     2666, SmHeapGroup);
    }
  }
#line 2668
  av___0 = argv + optind;
#line 2669
  if ((unsigned long )*av___0 == (unsigned long )((void *)0)) {
#line 2669
    if (! GrabTo) {
      {
#line 2671
      MainEnvelope.e_to = (char *)((void *)0);
#line 2672
      MainEnvelope.e_flags |= 4096UL;
#line 2673
      HoldErrs = 0;
#line 2674
      SuperSafe = 0;
#line 2675
      usrerr("Recipient names must be specified");
      }
#line 2678
      if ((int )OpMode != 118) {
        {
#line 2679
        collect(InChannel, 0, (HDR **)((void *)0), & MainEnvelope, 1);
        }
      }
      {
#line 2680
      finis(1, 1, (int volatile   )64);
      }
    }
  }
  {
#line 2688
  save_val = LogUsrErrs;
#line 2689
  LogUsrErrs = 1;
#line 2690
  sendtoargv(av___0, & MainEnvelope);
#line 2691
  LogUsrErrs = save_val;
  }
#line 2694
  if (Errors > 0) {
#line 2694
    if (ExitStat == 0) {
#line 2695
      ExitStat = 64;
    }
  }
#line 2716
  MainEnvelope.e_to = (char *)((void *)0);
#line 2717
  if ((int )OpMode != 118) {
#line 2717
    goto _L___6;
  } else
#line 2717
  if (GrabTo) {
    _L___6: /* CIL Label */ 
    {
#line 2733
    savederrors = Errors;
#line 2734
    savedflags = MainEnvelope.e_flags & 32UL;
#line 2735
    MainEnvelope.e_flags |= 4096UL;
#line 2736
    MainEnvelope.e_flags &= 0xffffffffffffffdfUL;
#line 2737
    Errors = 0;
#line 2738
    buffer_errors();
#line 2739
    collect(InChannel, 0, (HDR **)((void *)0), & MainEnvelope, 1);
    }
#line 2742
    if (Errors > 0) {
      giveup: 
#line 2745
      if (! GrabTo) {
        {
#line 2748
        logundelrcpts(& MainEnvelope, MainEnvelope.e_message, 8, 0);
        }
      }
      {
#line 2752
      flush_errors(1);
#line 2753
      finis(1, 1, (int volatile   )ExitStat);
      }
#line 2755
      return (-1);
    }
#line 2759
    if ((MainEnvelope.e_flags & 8UL) != 0UL) {
#line 2761
      if (ExitStat != 0) {
#line 2761
        tmp___194 = ExitStat;
      } else {
#line 2761
        tmp___194 = 65;
      }
      {
#line 2761
      finis(1, 1, (int volatile   )tmp___194);
      }
#line 2764
      return (-1);
    }
    {
#line 2768
    sm_snprintf(buf___16, (size_t )sizeof(buf___16), "%ld", MainEnvelope.e_msgsize);
#line 2770
    tmp___195 = macid_parse((char *)"{msg_size}", (char **)((void *)0));
#line 2770
    macdefine_tagged(& MainEnvelope.e_macro, (ARGCLASS_T )1, tmp___195, buf___16,
                     (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                     2771, SmHeapGroup);
#line 2773
    Errors = savederrors;
#line 2774
    MainEnvelope.e_flags |= savedflags;
    }
  }
  {
#line 2776
  tmp___196 = __errno_location();
#line 2776
  *tmp___196 = 0;
  }
#line 2778
  if ((int )tTdvect[1] >= 1) {
    {
#line 2779
    sm_dprintf((char *)"From person = \"%s\"\n", MainEnvelope.e_from.q_paddr);
    }
  }
#line 2783
  if ((unsigned long )MainEnvelope.e_quarmsg != (unsigned long )((void *)0)) {
    {
#line 2784
    markstats(& MainEnvelope, (ADDRESS *)((void *)0), 'q');
    }
  }
#line 2791
  if (Errors == 0) {
    {
#line 2793
    tmp___197 = split_by_recipient(& MainEnvelope);
    }
#line 2793
    if (! tmp___197) {
#line 2793
      if ((MainEnvelope.e_flags & 32UL) != 0UL) {
#line 2795
        goto giveup;
      }
    }
  }
#line 2799
  if (FastSplit > 0) {
#line 2799
    i = 0;
  } else {
#line 2799
    i = -1;
  }
#line 2800
  e = & MainEnvelope;
  {
#line 2800
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 2800
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 2800
      goto while_break___22;
    }
#line 2804
    e->e_from.q_state = (short)8;
#line 2805
    if ((int )tTdvect[1] >= 5) {
      {
#line 2807
      sm_dprintf((char *)"main[%d]: QS_SENDER ", i);
#line 2808
      tmp___198 = sm_debug_file();
#line 2808
      printaddr(tmp___198, & e->e_from, 0);
      }
    }
    {
#line 2810
    e->e_to = (char *)((void *)0);
#line 2811
    sm_getla();
#line 2812
    GrabTo = 0;
#line 2814
    tmp___199 = __res_state();
#line 2814
    tmp___199->retry = TimeOuts.res_retry[0];
#line 2815
    tmp___200 = __res_state();
#line 2815
    tmp___200->retrans = (int )TimeOuts.res_retrans[0];
#line 2817
    next = e->e_sibling;
#line 2818
    e->e_sibling = (ENVELOPE *)((void *)0);
    }
#line 2821
    if (i >= FastSplit) {
#line 2821
      tmp___201 = 'q';
    } else {
#line 2821
      tmp___201 = '\000';
    }
    {
#line 2821
    sendall(e, tmp___201);
#line 2822
    e->e_sibling = next;
#line 2800
    e = e->e_sibling;
#line 2800
    i ++;
    }
  }
  while_break___22: /* CIL Label */ ;
  }
  {
#line 2830
  finis(1, 1, (int volatile   )ExitStat);
  }
#line 2832
  return (ExitStat);
}
}
#line 2847 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
void stop_sendmail(void) 
{ 


  {
  {
#line 2851
  endpwent();
#line 2852
  setuid(RealUid);
#line 2853
  exit(0);
  }
}
}
#line 2870 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
void finis(bool drop , bool cleanup , int volatile   exitstat___0 ) 
{ 
  char pidpath[4096] ;
  char const   *tmp ;
  SM_EXC_HANDLER_T _h ;
  int tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  __pid_t tmp___3 ;
  __pid_t tmp___4 ;
  int tmp___5 ;
  SM_ATOMIC_UINT_T tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 2879
  sm_clear_events();
#line 2880
  sm_releasesignal(14);
  }
#line 2882
  if ((int )tTdvect[2] >= 1) {
#line 2884
    if ((unsigned long )CurEnv->e_id == (unsigned long )((void *)0)) {
#line 2884
      tmp = "NOQUEUE";
    } else {
#line 2884
      tmp = (char const   *)CurEnv->e_id;
    }
    {
#line 2884
    sm_dprintf((char *)"\n====finis: stat %d e_id=%s e_flags=", exitstat___0, tmp);
#line 2887
    printenvflags(CurEnv);
    }
  }
#line 2889
  if ((int )tTdvect[2] >= 9) {
    {
#line 2890
    printopenfds(0);
    }
  }
  {
#line 2892
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2892
    _h.eh_value = (SM_EXC_T *)((void *)0);
#line 2892
    _h.eh_parent = SmExcHandler;
#line 2892
    _h.eh_state = 2;
#line 2892
    SmExcHandler = & _h;
#line 2892
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 2892
    if (tmp___1 == 0) {
#line 2898
      CurEnv->e_to = (char *)((void *)0);
#line 2899
      if (drop) {
#line 2901
        if ((unsigned long )CurEnv->e_id != (unsigned long )((void *)0)) {
          {
#line 2903
          dropenvelope(CurEnv, 1, 0);
#line 2904
          sm_rpool_free(CurEnv->e_rpool);
#line 2905
          CurEnv->e_rpool = (SM_RPOOL_T *)((void *)0);
          }
        } else {
          {
#line 2908
          poststats(StatFile);
          }
        }
      }
      {
#line 2912
      mci_flush(1, (struct mailer_con_info *)((void *)0));
#line 2915
      closemaps(0);
#line 2919
      _udbx_close();
      }
#line 2931
      if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 2931
        tmp___0 = 1;
      } else {
        {
#line 2931
        sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                    2931, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2931
        tmp___0 = 0;
        }
      }
    }
    {
#line 2931
    tmp___9 = __sigsetjmp((struct __jmp_buf_tag *)(_h.eh_context), 0);
    }
#line 2931
    if (tmp___9 == 0) {
#line 2936
      if (LogLevel > 78) {
        {
#line 2937
        sm_syslog(7, (char const   *)CurEnv->e_id, "finis, pid=%d", CurrentPid);
        }
      }
#line 2939
      if (exitstat___0 == (int volatile   )75) {
#line 2941
        exitstat___0 = (int volatile   )0;
      } else
#line 2939
      if ((int )CurEnv->e_errormode == 101) {
#line 2941
        exitstat___0 = (int volatile   )0;
      }
      {
#line 2944
      cleanup_queues();
#line 2946
      tmp___2 = getpid();
#line 2946
      cleanup_shm(DaemonPid == tmp___2);
#line 2950
      close_sendmail_pid();
#line 2952
      tmp___3 = getpid();
      }
#line 2952
      if (DaemonPid == tmp___3) {
        {
#line 2955
        expand(PidFile, pidpath, (size_t )sizeof(pidpath), CurEnv);
#line 2956
        unlink((char const   *)(pidpath));
        }
      } else {
        {
#line 2952
        tmp___4 = getpid();
        }
#line 2952
        if (PidFilePid == tmp___4) {
          {
#line 2955
          expand(PidFile, pidpath, (size_t )sizeof(pidpath), CurEnv);
#line 2956
          unlink((char const   *)(pidpath));
          }
        }
      }
      {
#line 2960
      endpwent();
#line 2961
      sm_mbdb_terminate();
#line 2965
      setuid(RealUid);
      }
#line 2968
      if (SmHeapCheck.debug_level >= 2U) {
#line 2968
        if (SmHeapCheck.debug_level != 4294967295U) {
#line 2968
          goto _L;
        } else {
          {
#line 2968
          tmp___7 = sm_debug_loadactive(& SmHeapCheck, 2);
          }
#line 2968
          if (tmp___7) {
            _L: /* CIL Label */ 
#line 2969
            if (SmHeapCheck.debug_level == 4294967295U) {
              {
#line 2969
              tmp___5 = sm_debug_loadlevel(& SmHeapCheck);
#line 2969
              tmp___6 = (SM_ATOMIC_UINT_T )tmp___5;
              }
            } else {
#line 2969
              tmp___6 = SmHeapCheck.debug_level;
            }
            {
#line 2969
            sm_heap_report(& SmIoF[1], (int )(tmp___6 - 1U));
            }
          }
        }
      }
#line 2972
      if (SmXtrapReport.debug_level >= 1U) {
#line 2972
        if (SmXtrapReport.debug_level != 4294967295U) {
          {
#line 2973
          sm_dprintf((char *)"xtrap count = %d\n", SmXtrapCount);
          }
        } else {
          {
#line 2972
          tmp___8 = sm_debug_loadactive(& SmXtrapReport, 1);
          }
#line 2972
          if (tmp___8) {
            {
#line 2973
            sm_dprintf((char *)"xtrap count = %d\n", SmXtrapCount);
            }
          }
        }
      }
#line 2974
      if (cleanup) {
        {
#line 2975
        exit((int )exitstat___0);
        }
      } else {
        {
#line 2977
        _exit((int )exitstat___0);
        }
      }
    }
#line 2892
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2978
  if (_h.eh_state == 2) {
#line 2978
    if ((unsigned long )SmExcHandler == (unsigned long )(& _h)) {
#line 2978
      tmp___10 = 1;
    } else {
      {
#line 2978
      sm_abort_at("/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                  2978, "SM_ASSERT(SmExcHandler == &_h) failed");
#line 2978
      tmp___10 = 0;
      }
    }
#line 2978
    SmExcHandler = _h.eh_parent;
#line 2978
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 2978
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else
#line 2978
  if (_h.eh_state == 0) {
#line 2978
    if ((unsigned long )_h.eh_value != (unsigned long )((void *)0)) {
      {
#line 2978
      sm_exc_raise_x(_h.eh_value);
      }
    }
  } else {
    {
#line 2978
    sm_exc_free(_h.eh_value);
    }
  }
#line 2979
  return;
}
}
#line 2998 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static struct sm_exc_type  const  EtypeInterrupt  =    {SmExcTypeMagic, "S:mta.interrupt", "", & sm_etype_printf, "interrupt"};
#line 3008 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static void intindebug(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 3012
  tmp = __errno_location();
#line 3012
  save_errno = *tmp;
#line 3015
  tmp___0 = __errno_location();
#line 3015
  *tmp___0 = save_errno;
  }
  {
#line 3016
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3016
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 3016
      if (sig != 0) {
        {
#line 3016
        pend_signal(sig);
        }
#line 3016
        return;
      }
    }
#line 3016
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3017
  tmp___1 = __errno_location();
#line 3017
  *tmp___1 = save_errno;
#line 3018
  sm_exc_raisenew_x(& EtypeInterrupt);
#line 3019
  tmp___2 = __errno_location();
#line 3019
  *tmp___2 = save_errno;
  }
#line 3020
  return;
}
}
#line 3041 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static void sigterm(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 3045
  tmp = __errno_location();
#line 3045
  save_errno = *tmp;
#line 3048
  ShutdownRequest = (char */* volatile  */)"signal";
#line 3049
  tmp___0 = __errno_location();
#line 3049
  *tmp___0 = save_errno;
  }
#line 3050
  return;
}
}
#line 3071 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static void sighup(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 3075
  tmp = __errno_location();
#line 3075
  save_errno = *tmp;
#line 3078
  RestartRequest = (char */* volatile  */)"signal";
#line 3079
  tmp___0 = __errno_location();
#line 3079
  *tmp___0 = save_errno;
  }
#line 3080
  return;
}
}
#line 3101 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static void sigpipe(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 3105
  tmp = __errno_location();
#line 3105
  save_errno = *tmp;
#line 3108
  StopRequest = (bool volatile   )1;
#line 3109
  tmp___0 = __errno_location();
#line 3109
  *tmp___0 = save_errno;
  }
#line 3110
  return;
}
}
#line 3135 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
void intsig(int sig ) 
{ 
  bool drop ;
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;
  register ADDRESS *q ;
  char *__cil_tmp7 ;

  {
  {
#line 3139
  drop = 0;
#line 3140
  tmp = __errno_location();
#line 3140
  save_errno = *tmp;
#line 3143
  tmp___0 = __errno_location();
#line 3143
  *tmp___0 = save_errno;
  }
  {
#line 3144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3144
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 3144
      if (sig != 0) {
        {
#line 3144
        pend_signal(sig);
        }
#line 3144
        return;
      }
    }
#line 3144
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3145
  sm_allsignals(1);
  }
#line 3147
  if (sig != 0) {
#line 3147
    if (LogLevel > 79) {
      {
#line 3148
      sm_syslog(7, (char const   *)CurEnv->e_id, "interrupt");
      }
    }
  }
#line 3149
  FileName = (char *)((void *)0);
#line 3152
  if ((unsigned long )CurEnv->e_id != (unsigned long )((void *)0)) {
#line 3152
    if ((int )OpMode == 115) {
#line 3152
      goto _L___0;
    } else
#line 3152
    if ((int )OpMode == 109) {
#line 3152
      goto _L___0;
    } else
#line 3152
    if ((int )OpMode == 97) {
      _L___0: /* CIL Label */ 
#line 3160
      CurEnv->e_to = (char *)((void *)0);
#line 3161
      CurEnv->e_flags &= 0xffffffffffffffdfUL;
#line 3162
      CurEnv->e_flags |= 8UL;
#line 3169
      q = CurEnv->e_sendqueue;
      {
#line 3169
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3169
        if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 3169
          goto while_break___0;
        }
#line 3170
        q->q_state = (short)6;
#line 3169
        q = q->q_next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3172
      drop = 1;
    } else {
#line 3152
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3174
  if ((int )OpMode != 116) {
    {
#line 3176
    unlockqueue(CurEnv);
    }
  }
  {
#line 3179
  finis(drop, 0, (int volatile   )0);
  }
#line 3181
  return;
}
}
#line 3202 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
void disconnect(int droplev , ENVELOPE *e ) 
{ 
  int fd ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  SM_FILE_T *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 3209
  if ((int )tTdvect[52] >= 1) {
    {
#line 3210
    tmp = sm_io_getinfo(OutChannel, 3, (void *)0);
#line 3210
    tmp___0 = sm_io_getinfo(InChannel, 3, (void *)0);
#line 3210
    sm_dprintf((char *)"disconnect: In %d Out %d, e=%p\n", tmp___0, tmp, e);
    }
  }
#line 3213
  if ((int )tTdvect[52] >= 100) {
    {
#line 3215
    sm_dprintf((char *)"don\'t\n");
    }
#line 3216
    return;
  }
#line 3218
  if (LogLevel > 93) {
    {
#line 3219
    sm_syslog(7, (char const   *)e->e_id, "disconnect level %d", droplev);
    }
  }
  {
#line 3224
  sm_signal(2, (void (*)(int  ))1);
#line 3225
  sm_signal(3, (void (*)(int  ))1);
#line 3228
  HoldErrs = 1;
#line 3229
  CurEnv->e_errormode = (short )'m';
#line 3230
  Verbose = 0;
#line 3231
  DisConnected = 1;
  }
#line 3234
  if ((unsigned long )InChannel != (unsigned long )(& SmIoF[0])) {
    {
#line 3236
    sm_io_close(InChannel, -2);
#line 3237
    InChannel = & SmIoF[0];
    }
  }
  {
#line 3239
  tmp___3 = sm_io_reopen((SM_FILE_T const   *)(& SmFtStdio_def), -2, (void const   *)"/dev/null",
                         2, (void const   *)((void *)0), & SmIoF[0]);
  }
#line 3239
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 3241
    tmp___1 = __errno_location();
#line 3241
    tmp___2 = sm_errstring(*tmp___1);
#line 3241
    sm_syslog(3, (char const   *)e->e_id, "disconnect: sm_io_reopen(\"%s\") failed: %s",
              "/dev/null", tmp___2);
    }
  }
#line 3252
  if ((unsigned long )OutChannel != (unsigned long )(& SmIoF[1])) {
    {
#line 3252
    tmp___4 = sm_io_getinfo(OutChannel, 3, (void *)0);
#line 3252
    tmp___5 = sm_io_getinfo(& SmIoF[1], 3, (void *)0);
    }
#line 3252
    if (tmp___4 != tmp___5) {
      {
#line 3256
      sm_io_close(OutChannel, -2);
#line 3257
      OutChannel = & SmIoF[1];
      }
    }
  }
#line 3274
  if (droplev > 0) {
    {
#line 3276
    fd = open("/dev/null", 1, 438);
    }
#line 3277
    if (fd == -1) {
      {
#line 3278
      tmp___6 = __errno_location();
#line 3278
      tmp___7 = sm_errstring(*tmp___6);
#line 3278
      sm_syslog(3, (char const   *)e->e_id, "disconnect: open(\"%s\") failed: %s",
                "/dev/null", tmp___7);
      }
    }
    {
#line 3281
    sm_io_flush(& SmIoF[1], -2);
#line 3282
    dup2(fd, 1);
#line 3283
    dup2(fd, 2);
#line 3284
    close(fd);
    }
  }
#line 3288
  if (droplev > 1) {
    {
#line 3290
    setsid();
#line 3291
    tmp___8 = __errno_location();
#line 3291
    *tmp___8 = 0;
    }
  }
  {
#line 3295
  checkfd012((char *)"disconnect");
  }
#line 3298
  if (LogLevel > 71) {
    {
#line 3299
    sm_syslog(7, (char const   *)e->e_id, "in background, pid=%d", CurrentPid);
    }
  }
  {
#line 3302
  tmp___9 = __errno_location();
#line 3302
  *tmp___9 = 0;
  }
#line 3303
  return;
}
}
#line 3305 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static void obsolete(char **argv ) 
{ 
  register char *ap ;
  register char *op ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 3312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3312
    argv ++;
#line 3312
    ap = *argv;
#line 3312
    if (! ((unsigned long )ap != (unsigned long )((void *)0))) {
#line 3312
      goto while_break;
    }
#line 3315
    if ((int )*(ap + 0) != 45) {
#line 3316
      return;
    } else
#line 3315
    if ((int )*(ap + 1) == 45) {
#line 3316
      return;
    }
#line 3319
    if ((int )*(ap + 1) == 81) {
#line 3319
      if ((int )*(ap + 2) == 46) {
        {
#line 3323
        sm_io_fprintf(& SmIoF[1], -2, "Can not use -Q.\n");
#line 3325
        exit(64);
        }
      } else {
#line 3319
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3319
    if ((int )*(ap + 1) == 81) {
#line 3319
      if ((unsigned long )*(argv + 1) != (unsigned long )((void *)0)) {
#line 3319
        if ((int )*(*(argv + 1) + 0) == 46) {
#line 3319
          if ((int )*(*(argv + 1) + 1) == 0) {
            {
#line 3323
            sm_io_fprintf(& SmIoF[1], -2, "Can not use -Q.\n");
#line 3325
            exit(64);
            }
          }
        }
      }
    }
    {
#line 3329
    op = strchr("A:B:b:C:cD:d:e:F:f:Gh:IiL:M:mN:nO:o:p:Q:q:R:r:sTtV:vX:", (int )*(ap + 1));
    }
#line 3330
    if ((unsigned long )op != (unsigned long )((void *)0)) {
#line 3330
      op ++;
#line 3330
      if ((int )*op == 58) {
#line 3330
        if ((int )*(ap + 2) == 0) {
#line 3330
          if ((int )*(ap + 1) != 100) {
#line 3330
            if ((unsigned long )*(argv + 1) != (unsigned long )((void *)0)) {
#line 3330
              if ((int )*(*(argv + 1) + 0) != 45) {
#line 3337
                argv ++;
#line 3338
                goto while_continue;
              }
            }
          }
        }
      }
    }
#line 3343
    if ((int )*(ap + 1) == 67) {
#line 3343
      if ((int )*(ap + 2) == 0) {
        {
#line 3345
        *argv = xalloc_tagged((int )(sizeof("sendmail.cf") + 2UL), (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                              3345);
#line 3346
        sm_strlcpyn(*(argv + 0), (ssize_t )(sizeof("sendmail.cf") + 2UL), 2, "-C",
                    "sendmail.cf");
        }
      }
    }
#line 3351
    if ((int )*(ap + 1) == 113) {
#line 3351
      if ((int )*(ap + 2) == 0) {
#line 3352
        *argv = (char *)"-q0";
      }
    }
#line 3355
    if ((int )*(ap + 1) == 81) {
#line 3355
      if ((int )*(ap + 2) == 0) {
#line 3356
        *argv = (char *)"-Q.";
      }
    }
#line 3359
    if ((int )*(ap + 1) == 100) {
#line 3359
      if ((int )*(ap + 2) == 0) {
#line 3360
        *argv = (char *)"-d0-99.1";
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3372
  return;
}
}
#line 3401 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static char hostbuf___0[48]  ;
#line 3385 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
void auth_warning(ENVELOPE *e , char const   *msg  , ...) 
{ 
  char buf___16[2048] ;
  va_list ap ;
  register char *p ;
  struct hostent *hp ;
  size_t tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 3398
  if ((PrivacyFlags & 32UL) != 0UL) {
#line 3403
    if ((int )hostbuf___0[0] == 0) {
      {
#line 3407
      hp = myhostname(hostbuf___0, (int )sizeof(hostbuf___0));
      }
    }
    {
#line 3417
    sm_strlcpyn(buf___16, (ssize_t )sizeof(buf___16), 2, hostbuf___0, ": ");
#line 3418
    tmp = strlen((char const   *)(buf___16));
#line 3418
    p = & buf___16[tmp];
#line 3419
    __builtin_va_start(ap, msg);
#line 3420
    sm_vsnprintf(p, (size_t )(sizeof(buf___16) - (unsigned long )(p - buf___16)),
                 msg, ap);
#line 3421
    __builtin_va_end(ap);
#line 3422
    addheader((char *)"X-Authentication-Warning", buf___16, 0, e);
    }
#line 3423
    if (LogLevel > 3) {
      {
#line 3424
      sm_syslog(6, (char const   *)e->e_id, "Authentication-Warning: %.400s", buf___16);
      }
    }
  }
#line 3428
  return;
}
}
#line 3439 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static char *getextenv(char const   *envar ) 
{ 
  char **envp ;
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 3446
  tmp = strlen(envar);
#line 3446
  l = (int )tmp;
#line 3447
  envp = ExternalEnviron;
  }
  {
#line 3447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3447
    if ((unsigned long )envp != (unsigned long )((void *)0)) {
#line 3447
      if (! ((unsigned long )*envp != (unsigned long )((void *)0))) {
#line 3447
        goto while_break;
      }
    } else {
#line 3447
      goto while_break;
    }
    {
#line 3449
    tmp___0 = strncmp((char const   *)*envp, envar, (size_t )l);
    }
#line 3449
    if (tmp___0 == 0) {
#line 3449
      if ((int )*(*envp + l) == 61) {
#line 3450
        return (*envp + (l + 1));
      }
    }
#line 3447
    envp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3452
  return ((char *)((void *)0));
}
}
#line 3468 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
void sm_setuserenv(char const   *envar , char const   *value ) 
{ 
  int i ;
  int l ;
  char **evp ;
  char *p ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char **tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 3474
  evp = UserEnviron;
#line 3477
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 3479
    tmp = getextenv(envar);
#line 3479
    value = (char const   *)tmp;
    }
#line 3480
    if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 3481
      return;
    }
  }
  {
#line 3485
  tmp___0 = strlen(envar);
#line 3485
  i = (int )(tmp___0 + 1U);
#line 3486
  tmp___1 = strlen(value);
#line 3486
  l = (int )((tmp___1 + (size_t )i) + 1U);
#line 3487
  tmp___2 = xalloc_tagged(l, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                          3487);
#line 3487
  p = tmp___2;
#line 3488
  sm_strlcpyn(p, l, 3, envar, "=", value);
  }
  {
#line 3490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3490
    if ((unsigned long )*evp != (unsigned long )((void *)0)) {
      {
#line 3490
      tmp___3 = strncmp((char const   *)*evp, (char const   *)p, (size_t )i);
      }
#line 3490
      if (! (tmp___3 != 0)) {
#line 3490
        goto while_break;
      }
    } else {
#line 3490
      goto while_break;
    }
#line 3491
    evp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3492
  if ((unsigned long )*evp != (unsigned long )((void *)0)) {
#line 3494
    tmp___4 = evp;
#line 3494
    evp ++;
#line 3494
    *tmp___4 = p;
  } else
#line 3496
  if ((unsigned long )evp < (unsigned long )(& UserEnviron[100])) {
#line 3498
    tmp___5 = evp;
#line 3498
    evp ++;
#line 3498
    *tmp___5 = p;
#line 3499
    *evp = (char *)((void *)0);
  }
  {
#line 3503
  tmp___6 = putenv(p);
  }
#line 3503
  if (tmp___6 < 0) {
    {
#line 3504
    syserr("sm_setuserenv: putenv(%s) failed", p);
    }
  }
#line 3505
  return;
}
}
#line 3512 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
void dumpstate(char *when ) 
{ 
  register char *j ;
  char *tmp ;
  int rs ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  int status ;
  register char **pvp ;
  char *pv[1001] ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 3516
  tmp = macvalue('j', CurEnv);
#line 3516
  j = tmp;
  }
#line 3520
  if ((unsigned long )j == (unsigned long )((void *)0)) {
#line 3520
    tmp___0 = "<NULL>";
  } else {
#line 3520
    tmp___0 = (char const   *)j;
  }
  {
#line 3520
  sm_syslog(7, (char const   *)CurEnv->e_id, "--- dumping state on %s: $j = %s ---",
            when, tmp___0);
  }
#line 3524
  if ((unsigned long )j != (unsigned long )((void *)0)) {
    {
#line 3526
    tmp___1 = wordinclass(j, 'w');
    }
#line 3526
    if (! tmp___1) {
      {
#line 3527
      sm_syslog(7, (char const   *)CurEnv->e_id, "*** $j not in $=w ***");
      }
    }
  }
  {
#line 3530
  sm_syslog(7, (char const   *)CurEnv->e_id, "CurChildren = %d", CurChildren);
#line 3531
  sm_syslog(7, (char const   *)CurEnv->e_id, "NextMacroId = %d (Max %d)", NextMacroId,
            255);
#line 3533
  sm_syslog(7, (char const   *)CurEnv->e_id, "--- open file descriptors: ---");
#line 3534
  printopenfds(1);
#line 3535
  sm_syslog(7, (char const   *)CurEnv->e_id, "--- connection cache: ---");
#line 3536
  mci_dump_all(& SmIoF[1], 1);
#line 3537
  rs = strtorwset((char *)"debug_dumpstate", (char **)((void *)0), 0);
  }
#line 3538
  if (rs > 0) {
    {
#line 3544
    pv[0] = (char *)((void *)0);
#line 3545
    status = rewrite(pv, rs, 0, CurEnv, 1000);
#line 3546
    sm_syslog(7, (char const   *)CurEnv->e_id, "--- ruleset debug_dumpstate returns stat %d, pv: ---",
              status);
#line 3549
    pvp = pv;
    }
    {
#line 3549
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3549
      if (! ((unsigned long )*pvp != (unsigned long )((void *)0))) {
#line 3549
        goto while_break;
      }
      {
#line 3550
      sm_syslog(7, (char const   *)CurEnv->e_id, "%s", *pvp);
#line 3549
      pvp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 3552
  sm_syslog(7, (char const   *)CurEnv->e_id, "--- end of state dump ---");
  }
#line 3553
  return;
}
}
#line 3573 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static void sigusr1(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 3577
  tmp = __errno_location();
#line 3577
  save_errno = *tmp;
#line 3583
  tmp___0 = __errno_location();
#line 3583
  *tmp___0 = save_errno;
  }
  {
#line 3584
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3584
    if (InCriticalSection > (unsigned int volatile   )0) {
#line 3584
      if (sig != 0) {
        {
#line 3584
        pend_signal(sig);
        }
#line 3584
        return;
      }
    }
#line 3584
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3585
  dumpstate((char *)"user signal");
#line 3587
  dumpstab();
#line 3589
  tmp___1 = __errno_location();
#line 3589
  *tmp___1 = save_errno;
  }
#line 3590
  return;
}
}
#line 3606 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
int drop_privileges(bool to_real_uid ) 
{ 
  int rval ;
  gid_t emptygidset[1] ;
  __gid_t tmp ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __uid_t tmp___2 ;
  __gid_t tmp___3 ;
  int tmp___4 ;
  __uid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  __gid_t tmp___8 ;
  int *tmp___9 ;
  __gid_t tmp___10 ;
  __gid_t tmp___11 ;
  uid_t euid ;
  int tmp___12 ;
  int tmp___13 ;
  __uid_t tmp___14 ;
  int tmp___15 ;
  __uid_t tmp___16 ;
  __uid_t tmp___17 ;
  __uid_t tmp___18 ;
  __uid_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  __uid_t tmp___24 ;
  __uid_t tmp___25 ;
  __gid_t tmp___26 ;
  __gid_t tmp___27 ;
  __uid_t tmp___28 ;
  __uid_t tmp___29 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 3610
  rval = 0;
#line 3613
  if ((int )tTdvect[47] >= 1) {
    {
#line 3614
    tmp = getegid();
#line 3614
    tmp___0 = geteuid();
#line 3614
    tmp___1 = getgid();
#line 3614
    tmp___2 = getuid();
#line 3614
    sm_dprintf((char *)"drop_privileges(%d): Real[UG]id=%d:%d, get[ug]id=%d:%d, gete[ug]id=%d:%d, RunAs[UG]id=%d:%d\n",
               to_real_uid, (int )RealUid, (int )RealGid, (int )tmp___2, (int )tmp___1,
               (int )tmp___0, (int )tmp, (int )RunAsUid, (int )RunAsGid);
    }
  }
#line 3621
  if (to_real_uid) {
#line 3623
    RunAsUserName = RealUserName;
#line 3624
    RunAsUid = RealUid;
#line 3625
    RunAsGid = RealGid;
#line 3626
    EffGid = RunAsGid;
  }
  {
#line 3630
  endpwent();
#line 3631
  sm_mbdb_terminate();
  }
#line 3634
  if (to_real_uid) {
#line 3634
    emptygidset[0] = RunAsGid;
  } else
#line 3634
  if (RunAsGid != 0U) {
#line 3634
    emptygidset[0] = RunAsGid;
  } else {
    {
#line 3634
    tmp___3 = getegid();
#line 3634
    emptygidset[0] = tmp___3;
    }
  }
  {
#line 3645
  tmp___4 = setgroups((size_t )1, (__gid_t const   *)(emptygidset));
  }
#line 3645
  if (tmp___4 == -1) {
    {
#line 3645
    tmp___5 = geteuid();
    }
#line 3645
    if (tmp___5 == 0U) {
      {
#line 3647
      syserr("drop_privileges: setgroups(1, %d) failed", (int )emptygidset[0]);
#line 3649
      rval = 71;
      }
    }
  }
#line 3653
  if (to_real_uid) {
    {
#line 3672
    tmp___6 = setregid(RunAsGid, RunAsGid);
    }
#line 3672
    if (tmp___6 < 0) {
      {
#line 3674
      syserr("drop_privileges: setregid(%d, %d) failed", (int )RunAsGid, (int )RunAsGid);
#line 3676
      rval = 71;
      }
    }
  }
#line 3690
  if (rval == 0) {
#line 3690
    if (to_real_uid) {
#line 3690
      goto _L;
    } else
#line 3690
    if (RunAsGid != 0U) {
      _L: /* CIL Label */ 
      {
#line 3692
      tmp___7 = setgid(RunAsGid);
      }
#line 3692
      if (tmp___7 < 0) {
#line 3692
        if (! UseMSP) {
          {
#line 3694
          syserr("drop_privileges: setgid(%d) failed", (int )RunAsGid);
#line 3696
          rval = 71;
          }
        } else {
          {
#line 3692
          tmp___8 = getegid();
          }
#line 3692
          if (tmp___8 != RunAsGid) {
            {
#line 3694
            syserr("drop_privileges: setgid(%d) failed", (int )RunAsGid);
#line 3696
            rval = 71;
            }
          }
        }
      }
      {
#line 3698
      tmp___9 = __errno_location();
#line 3698
      *tmp___9 = 0;
      }
#line 3699
      if (rval == 0) {
        {
#line 3699
        tmp___11 = getegid();
        }
#line 3699
        if (tmp___11 != RunAsGid) {
          {
#line 3701
          tmp___10 = getegid();
#line 3701
          syserr("drop_privileges: Unable to set effective gid=%d to RunAsGid=%d",
                 (int )tmp___10, (int )RunAsGid);
#line 3703
          rval = 71;
          }
        }
      }
    }
  }
#line 3708
  if (to_real_uid) {
#line 3708
    goto _L___3;
  } else
#line 3708
  if (RunAsUid != 0U) {
    _L___3: /* CIL Label */ 
    {
#line 3719
    tmp___15 = setuid(RunAsUid);
    }
#line 3719
    if (tmp___15 < 0) {
#line 3719
      goto _L___1;
    } else {
      {
#line 3719
      tmp___16 = geteuid();
      }
#line 3719
      if (tmp___16 != RunAsUid) {
#line 3719
        goto _L___1;
      } else {
        {
#line 3719
        tmp___17 = getuid();
        }
#line 3719
        if (tmp___17 != RunAsUid) {
#line 3719
          if (to_real_uid) {
#line 3719
            goto _L___1;
          } else {
            {
#line 3719
            tmp___18 = geteuid();
            }
#line 3719
            if (tmp___18 == 0U) {
#line 3719
              goto _L___1;
            } else {
              {
#line 3719
              tmp___19 = getuid();
              }
#line 3719
              if (tmp___19 == 0U) {
                _L___1: /* CIL Label */ 
                {
#line 3731
                tmp___14 = geteuid();
                }
#line 3731
                if (tmp___14 == RunAsUid) {
                  {
#line 3733
                  tmp___12 = setreuid(RunAsUid, (__uid_t )-1);
                  }
#line 3733
                  if (tmp___12 < 0) {
                    {
#line 3735
                    syserr("drop_privileges: setreuid(%d, -1) failed", (int )RunAsUid);
#line 3737
                    rval = 71;
                    }
                  }
                  {
#line 3739
                  tmp___13 = setuid(RunAsUid);
                  }
#line 3739
                  if (tmp___13 < 0) {
                    {
#line 3741
                    syserr("drop_privileges: second setuid(%d) attempt failed", (int )RunAsUid);
#line 3743
                    rval = 71;
                    }
                  }
                } else {
                  {
#line 3749
                  syserr("drop_privileges: setuid(%d) failed", (int )RunAsUid);
#line 3751
                  rval = 71;
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 3754
    euid = geteuid();
    }
#line 3755
    if (RunAsUid != 0U) {
      {
#line 3755
      tmp___21 = setuid((__uid_t )0);
      }
#line 3755
      if (tmp___21 == 0) {
        {
#line 3764
        syserr("drop_privileges: setuid(0) succeeded (when it should not)");
#line 3765
        rval = 71;
        }
      } else {
#line 3755
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 3767
    if (RunAsUid != euid) {
      {
#line 3767
      tmp___20 = setuid(euid);
      }
#line 3767
      if (tmp___20 == 0) {
        {
#line 3775
        syserr("drop_privileges: Unable to drop non-root set-user-ID privileges");
#line 3776
        rval = 71;
        }
      }
    }
  }
#line 3780
  if (to_real_uid) {
#line 3780
    goto _L___4;
  } else
#line 3780
  if (RunAsGid != 0U) {
    _L___4: /* CIL Label */ 
#line 3780
    if (rval == 0) {
#line 3780
      if (RunAsGid != EffGid) {
        {
#line 3780
        tmp___24 = getuid();
        }
#line 3780
        if (tmp___24 != 0U) {
          {
#line 3780
          tmp___25 = geteuid();
          }
#line 3780
          if (tmp___25 != 0U) {
            {
#line 3784
            tmp___22 = __errno_location();
#line 3784
            *tmp___22 = 0;
#line 3785
            tmp___23 = setgid(EffGid);
            }
#line 3785
            if (tmp___23 == 0) {
              {
#line 3787
              syserr("drop_privileges: setgid(%d) succeeded (when it should not)",
                     (int )EffGid);
#line 3789
              rval = 71;
              }
            }
          }
        }
      }
    }
  }
#line 3793
  if ((int )tTdvect[47] >= 5) {
    {
#line 3795
    tmp___26 = getgid();
#line 3795
    tmp___27 = getegid();
#line 3795
    tmp___28 = getuid();
#line 3795
    tmp___29 = geteuid();
#line 3795
    sm_dprintf((char *)"drop_privileges: e/ruid = %d/%d e/rgid = %d/%d\n", (int )tmp___29,
               (int )tmp___28, (int )tmp___27, (int )tmp___26);
#line 3798
    sm_dprintf((char *)"drop_privileges: RunAsUser = %d:%d\n", (int )RunAsUid, (int )RunAsGid);
    }
#line 3800
    if ((int )tTdvect[47] >= 10) {
      {
#line 3801
      sm_dprintf((char *)"drop_privileges: rval = %d\n", rval);
      }
    }
  }
#line 3803
  return (rval);
}
}
#line 3823 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
void fill_fd(int fd , char *where ) 
{ 
  int i ;
  struct stat stbuf ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 3831
  tmp = fstat(fd, & stbuf);
  }
#line 3831
  if (tmp >= 0) {
#line 3832
    return;
  } else {
    {
#line 3831
    tmp___0 = __errno_location();
    }
#line 3831
    if (*tmp___0 != 9) {
#line 3832
      return;
    }
  }
#line 3834
  if ((unsigned long )where != (unsigned long )((void *)0)) {
    {
#line 3835
    syserr("fill_fd: %s: fd %d not open", where, fd);
    }
  } else {
#line 3837
    MissingFds |= 1 << fd;
  }
#line 3838
  if (fd == 0) {
#line 3838
    tmp___1 = 0;
  } else {
#line 3838
    tmp___1 = 1;
  }
  {
#line 3838
  i = open("/dev/null", tmp___1, 438);
  }
#line 3839
  if (i < 0) {
#line 3841
    if ((unsigned long )where == (unsigned long )((void *)0)) {
#line 3841
      tmp___2 = "startup";
    } else {
#line 3841
      tmp___2 = (char const   *)where;
    }
    {
#line 3841
    syserr("!fill_fd: %s: cannot open %s", tmp___2, "/dev/null");
    }
  }
#line 3844
  if (fd != i) {
    {
#line 3846
    dup2(i, fd);
#line 3847
    close(i);
    }
  }
#line 3849
  return;
}
}
#line 3860 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static void sm_printoptions(char **options ) 
{ 
  int ll ;
  char **av___0 ;
  size_t tmp ;
  char **tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 3867
  av___0 = options;
#line 3868
  ll = 7;
  {
#line 3869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3869
    if (! ((unsigned long )*av___0 != (unsigned long )((void *)0))) {
#line 3869
      goto while_break;
    }
    {
#line 3871
    tmp = strlen((char const   *)*av___0);
    }
#line 3871
    if ((size_t )ll + tmp > 63U) {
      {
#line 3873
      sm_dprintf((char *)"\n");
#line 3874
      ll = 0;
      }
    }
#line 3876
    if (ll == 0) {
      {
#line 3877
      sm_dprintf((char *)"\t\t");
      }
    } else {
      {
#line 3879
      sm_dprintf((char *)" ");
      }
    }
    {
#line 3880
    sm_dprintf((char *)"%s", *av___0);
#line 3881
    tmp___0 = av___0;
#line 3881
    av___0 ++;
#line 3881
    tmp___1 = strlen((char const   *)*tmp___0);
#line 3881
    ll = (int )((size_t )ll + (tmp___1 + 1U));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3883
  sm_dprintf((char *)"\n");
  }
#line 3884
  return;
}
}
#line 3914 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static int tryflags  =    0;
#line 3900 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static void testmodeline(char *line , ENVELOPE *e ) 
{ 
  register char *p ;
  char *q ;
  char *delimptr ;
  int mid ;
  int i ;
  int rs ;
  STAB *map___0 ;
  char **s ;
  struct rewrite *rw ;
  ADDRESS a ;
  char exbuf[2048] ;
  register char *wd ;
  char delim ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char **tmp___1 ;
  char **tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int nmx ;
  int rcode ;
  char *mxhosts[101] ;
  char host[64] ;
  size_t tmp___8 ;
  int rcode___0 ;
  char *av___0[2] ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  bool tmp___11 ;
  MAILER *m ;
  STAB *st ;
  int rcode___1 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  ADDRESS *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  unsigned short const   **tmp___27 ;
  unsigned short const   **tmp___28 ;
  bool tmp___29 ;
  register char **pvp ;
  char pvpbuf[1256] ;
  unsigned char *tmp___30 ;
  int status ;
  char *tmp___31 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;

  {
  {
#line 3919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3919
    if (! ((int )*line == 32)) {
#line 3919
      goto while_break;
    }
#line 3920
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3925
  if ((int )*(line + 0) == 0) {
#line 3925
    goto case_0;
  }
#line 3925
  if ((int )*(line + 0) == 35) {
#line 3925
    goto case_0;
  }
#line 3928
  if ((int )*(line + 0) == 63) {
#line 3928
    goto case_63;
  }
#line 3932
  if ((int )*(line + 0) == 46) {
#line 3932
    goto case_46;
  }
#line 3983
  if ((int )*(line + 0) == 61) {
#line 3983
    goto case_61;
  }
#line 4044
  if ((int )*(line + 0) == 45) {
#line 4044
    goto case_45;
  }
#line 4063
  if ((int )*(line + 0) == 36) {
#line 4063
    goto case_36;
  }
#line 4086
  if ((int )*(line + 0) == 47) {
#line 4086
    goto case_47;
  }
#line 3922
  goto switch_break;
  case_0: /* CIL Label */ 
  case_35: /* CIL Label */ 
#line 3926
  return;
  case_63: /* CIL Label */ 
  {
#line 3929
  help((char *)"-bt", e);
  }
#line 3930
  return;
  case_46: /* CIL Label */ 
  {
#line 3935
  if ((int )*(line + 1) == 68) {
#line 3935
    goto case_68;
  }
#line 3943
  if ((int )*(line + 1) == 67) {
#line 3943
    goto case_67;
  }
#line 3971
  if ((int )*(line + 1) == 0) {
#line 3971
    goto case_0___0;
  }
#line 3976
  goto switch_default;
  case_68: /* CIL Label */ 
  {
#line 3936
  mid = macid_parse(line + 2, & delimptr);
  }
#line 3937
  if (mid == 0) {
#line 3938
    return;
  }
  {
#line 3939
  translate_dollars(delimptr);
#line 3940
  macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, mid, delimptr, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                   3940, SmHeapGroup);
  }
#line 3941
  goto switch_break___0;
  case_67: /* CIL Label */ 
#line 3944
  if ((int )*(line + 2) == 0) {
#line 3945
    return;
  }
  {
#line 3947
  mid = macid_parse(line + 2, & delimptr);
  }
#line 3948
  if (mid == 0) {
#line 3949
    return;
  }
  {
#line 3950
  translate_dollars(delimptr);
#line 3951
  expand(delimptr, exbuf, (size_t )sizeof(exbuf), e);
#line 3952
  p = exbuf;
  }
  {
#line 3953
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3953
    if (! ((int )*p != 0)) {
#line 3953
      goto while_break___0;
    }
    {
#line 3958
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3958
      if ((int )*p != 0) {
#line 3958
        if (((int )*p & -128) == 0) {
          {
#line 3958
          tmp = __ctype_b_loc();
          }
#line 3958
          if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 3958
            goto while_break___1;
          }
        } else {
#line 3958
          goto while_break___1;
        }
      } else {
#line 3958
        goto while_break___1;
      }
#line 3959
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3960
    wd = p;
    {
#line 3961
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3961
      if ((int )*p != 0) {
#line 3961
        if (((int )*p & -128) == 0) {
          {
#line 3961
          tmp___0 = __ctype_b_loc();
          }
#line 3961
          if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
#line 3961
            goto while_break___2;
          }
        }
      } else {
#line 3961
        goto while_break___2;
      }
#line 3962
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3963
    delim = *p;
#line 3964
    *p = (char )'\000';
#line 3965
    if ((int )*(wd + 0) != 0) {
      {
#line 3966
      setclass(mid, wd);
      }
    }
#line 3967
    *p = delim;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3969
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 3972
  sm_io_fprintf(& SmIoF[1], -2, "Usage: .[DC]macro value(s)\n");
  }
#line 3974
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 3977
  sm_io_fprintf(& SmIoF[1], -2, "Unknown \".\" command %s\n", line);
  }
#line 3979
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 3981
  return;
  case_61: /* CIL Label */ 
  {
#line 3986
  if ((int )*(line + 1) == 83) {
#line 3986
    goto case_83;
  }
#line 4024
  if ((int )*(line + 1) == 77) {
#line 4024
    goto case_77;
  }
#line 4032
  if ((int )*(line + 1) == 0) {
#line 4032
    goto case_0___1;
  }
#line 4037
  goto switch_default___0;
  case_83: /* CIL Label */ 
  {
#line 3987
  rs = strtorwset(line + 2, (char **)((void *)0), 0);
  }
#line 3988
  if (rs < 0) {
    {
#line 3990
    sm_io_fprintf(& SmIoF[1], -2, "Undefined ruleset %s\n", line + 2);
    }
#line 3992
    return;
  }
#line 3994
  rw = RewriteRules[rs];
#line 3995
  if ((unsigned long )rw == (unsigned long )((void *)0)) {
#line 3996
    return;
  }
  {
#line 3997
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 3999
    sm_io_putc(& SmIoF[1], -2, 'R');
#line 4001
    s = rw->r_lhs;
    }
    {
#line 4002
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 4002
      if (! ((unsigned long )*s != (unsigned long )((void *)0))) {
#line 4002
        goto while_break___4;
      }
      {
#line 4004
      tmp___1 = s;
#line 4004
      s ++;
#line 4004
      xputs(& SmIoF[1], (char const   *)*tmp___1);
#line 4005
      sm_io_putc(& SmIoF[1], -2, ' ');
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 4008
    sm_io_putc(& SmIoF[1], -2, '\t');
#line 4010
    sm_io_putc(& SmIoF[1], -2, '\t');
#line 4012
    s = rw->r_rhs;
    }
    {
#line 4013
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 4013
      if (! ((unsigned long )*s != (unsigned long )((void *)0))) {
#line 4013
        goto while_break___5;
      }
      {
#line 4015
      tmp___2 = s;
#line 4015
      s ++;
#line 4015
      xputs(& SmIoF[1], (char const   *)*tmp___2);
#line 4016
      sm_io_putc(& SmIoF[1], -2, ' ');
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 4019
    sm_io_putc(& SmIoF[1], -2, '\n');
#line 3997
    rw = rw->r_next;
    }
#line 3997
    if (! ((unsigned long )rw != (unsigned long )((void *)0))) {
#line 3997
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 4022
  goto switch_break___1;
  case_77: /* CIL Label */ 
#line 4025
  i = 0;
  {
#line 4025
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 4025
    if (! (i < 25)) {
#line 4025
      goto while_break___6;
    }
#line 4027
    if ((unsigned long )Mailer[i] != (unsigned long )((void *)0)) {
      {
#line 4028
      printmailer(& SmIoF[1], Mailer[i]);
      }
    }
#line 4025
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 4030
  goto switch_break___1;
  case_0___1: /* CIL Label */ 
  {
#line 4033
  sm_io_fprintf(& SmIoF[1], -2, "Usage: =Sruleset or =M\n");
  }
#line 4035
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 4038
  sm_io_fprintf(& SmIoF[1], -2, "Unknown \"=\" command %s\n", line);
  }
#line 4040
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 4042
  return;
  case_45: /* CIL Label */ 
  {
#line 4047
  if ((int )*(line + 1) == 100) {
#line 4047
    goto case_100;
  }
#line 4051
  if ((int )*(line + 1) == 0) {
#line 4051
    goto case_0___2;
  }
#line 4056
  goto switch_default___1;
  case_100: /* CIL Label */ 
  {
#line 4048
  tTflag(line + 2);
  }
#line 4049
  goto switch_break___2;
  case_0___2: /* CIL Label */ 
  {
#line 4052
  sm_io_fprintf(& SmIoF[1], -2, "Usage: -d{debug arguments}\n");
  }
#line 4054
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 4057
  sm_io_fprintf(& SmIoF[1], -2, "Unknown \"-\" command %s\n", line);
  }
#line 4059
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 4061
  return;
  case_36: /* CIL Label */ 
#line 4064
  if ((int )*(line + 1) == 61) {
    {
#line 4066
    mid = macid_parse(line + 2, (char **)((void *)0));
    }
#line 4067
    if (mid != 0) {
      {
#line 4068
      stabapply(& dump_class, mid);
      }
    }
#line 4069
    return;
  }
  {
#line 4071
  mid = macid_parse(line + 1, (char **)((void *)0));
  }
#line 4072
  if (mid == 0) {
#line 4073
    return;
  }
  {
#line 4074
  p = macvalue(mid, e);
  }
#line 4075
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 4076
    sm_io_fprintf(& SmIoF[1], -2, "Undefined\n");
    }
  } else {
    {
#line 4080
    xputs(& SmIoF[1], (char const   *)p);
#line 4081
    sm_io_fprintf(& SmIoF[1], -2, "\n");
    }
  }
#line 4084
  return;
  case_47: /* CIL Label */ 
  {
#line 4087
  tmp___3 = strlen((char const   *)line);
#line 4087
  p = line + tmp___3;
  }
  {
#line 4088
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 4088
    p --;
#line 4088
    if ((unsigned long )p >= (unsigned long )line) {
#line 4088
      if (((int )*p & -128) == 0) {
        {
#line 4088
        tmp___4 = __ctype_b_loc();
        }
#line 4088
        if (! ((int const   )*(*tmp___4 + (int )*p) & 8192)) {
#line 4088
          goto while_break___7;
        }
      } else {
#line 4088
        goto while_break___7;
      }
    } else {
#line 4088
      goto while_break___7;
    }
#line 4089
    *p = (char )'\000';
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 4090
  p = strpbrk((char const   *)line, " \t");
  }
#line 4091
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 4093
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 4093
      if (((int )*p & -128) == 0) {
        {
#line 4093
        tmp___6 = __ctype_b_loc();
        }
#line 4093
        if (! ((int const   )*(*tmp___6 + (int )*p) & 8192)) {
#line 4093
          goto while_break___8;
        }
      } else {
#line 4093
        goto while_break___8;
      }
#line 4094
      tmp___5 = p;
#line 4094
      p ++;
#line 4094
      *tmp___5 = (char )'\000';
    }
    while_break___8: /* CIL Label */ ;
    }
  } else {
#line 4097
    p = (char *)"";
  }
#line 4098
  if ((int )*(line + 1) == 0) {
    {
#line 4100
    sm_io_fprintf(& SmIoF[1], -2, "Usage: /[canon|map|mx|parse|try|tryflags]\n");
    }
#line 4102
    return;
  }
  {
#line 4104
  tmp___7 = sm_strcasecmp((char const   *)(line + 1), "quit");
  }
#line 4104
  if (tmp___7 == 0) {
    {
#line 4106
    CurEnv->e_id = (char *)((void *)0);
#line 4107
    finis(1, 1, (int volatile   )ExitStat);
    }
  }
  {
#line 4110
  tmp___26 = sm_strcasecmp((char const   *)(line + 1), "mx");
  }
#line 4110
  if (tmp___26 == 0) {
#line 4118
    if ((int )*p == 0) {
      {
#line 4120
      sm_io_fprintf(& SmIoF[1], -2, "Usage: /mx address\n");
      }
#line 4122
      return;
    }
    {
#line 4124
    nmx = getmxrr(p, mxhosts, (unsigned short *)((void *)0), 0, & rcode, 1, (int *)((void *)0));
#line 4126
    sm_io_fprintf(& SmIoF[1], -2, "getmxrr(%s) returns %d value(s):\n", p, nmx);
#line 4129
    i = 0;
    }
    {
#line 4129
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 4129
      if (! (i < nmx)) {
#line 4129
        goto while_break___9;
      }
      {
#line 4130
      sm_io_fprintf(& SmIoF[1], -2, "\t%s\n", mxhosts[i]);
#line 4129
      i ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
  } else {
    {
#line 4137
    tmp___25 = sm_strcasecmp((char const   *)(line + 1), "canon");
    }
#line 4137
    if (tmp___25 == 0) {
#line 4141
      if ((int )*p == 0) {
        {
#line 4143
        sm_io_fprintf(& SmIoF[1], -2, "Usage: /canon address\n");
        }
#line 4145
        return;
      } else {
        {
#line 4147
        tmp___8 = sm_strlcpy(host, (char const   *)p, (ssize_t )sizeof(host));
        }
#line 4147
        if ((unsigned long )tmp___8 >= sizeof(host)) {
          {
#line 4149
          sm_io_fprintf(& SmIoF[1], -2, "Name too long\n");
          }
#line 4151
          return;
        }
      }
      {
#line 4153
      getcanonname(host, (int )sizeof(host), ! HasWildcardMX, (int *)((void *)0));
#line 4155
      sm_io_fprintf(& SmIoF[1], -2, "getcanonname(%s) returns %s\n", p, host);
      }
    } else {
      {
#line 4159
      tmp___24 = sm_strcasecmp((char const   *)(line + 1), "map");
      }
#line 4159
      if (tmp___24 == 0) {
#line 4161
        rcode___0 = 0;
#line 4164
        if ((int )*p == 0) {
          {
#line 4166
          sm_io_fprintf(& SmIoF[1], -2, "Usage: /map mapname key\n");
          }
#line 4168
          return;
        }
#line 4170
        q = p;
        {
#line 4170
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 4170
          if ((int )*q != 0) {
#line 4170
            if (((int )*q & -128) == 0) {
              {
#line 4170
              tmp___9 = __ctype_b_loc();
              }
#line 4170
              if ((int const   )*(*tmp___9 + (int )*q) & 8192) {
#line 4170
                goto while_break___10;
              }
            }
          } else {
#line 4170
            goto while_break___10;
          }
#line 4171
          goto __Cont;
          __Cont: /* CIL Label */ 
#line 4170
          q ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 4172
        if ((int )*q == 0) {
          {
#line 4174
          sm_io_fprintf(& SmIoF[1], -2, "No key specified\n");
          }
#line 4176
          return;
        }
        {
#line 4178
        tmp___10 = q;
#line 4178
        q ++;
#line 4178
        *tmp___10 = (char )'\000';
#line 4179
        map___0 = stab(p, 6, 0);
        }
#line 4180
        if ((unsigned long )map___0 == (unsigned long )((void *)0)) {
          {
#line 4182
          sm_io_fprintf(& SmIoF[1], -2, "Map named \"%s\" not found\n", p);
          }
#line 4184
          return;
        }
#line 4186
        if (! ((map___0->s_value.sv_map.map_mflags & 32L) != 0L)) {
          {
#line 4186
          tmp___11 = openmap(& map___0->s_value.sv_map);
          }
#line 4186
          if (! tmp___11) {
            {
#line 4189
            sm_io_fprintf(& SmIoF[1], -2, "Map named \"%s\" not open\n", p);
            }
#line 4191
            return;
          }
        }
        {
#line 4193
        sm_io_fprintf(& SmIoF[1], -2, "map_lookup: %s (%s) ", p, q);
#line 4195
        av___0[0] = q;
#line 4196
        av___0[1] = (char *)((void *)0);
#line 4197
        p = (*((map___0->s_value.sv_map.map_class)->map_lookup))(& map___0->s_value.sv_map,
                                                                 q, av___0, & rcode___0);
        }
#line 4199
        if ((unsigned long )p == (unsigned long )((void *)0)) {
          {
#line 4200
          sm_io_fprintf(& SmIoF[1], -2, "no match (%d)\n", rcode___0);
          }
        } else {
          {
#line 4204
          sm_io_fprintf(& SmIoF[1], -2, "returns %s (%d)\n", p, rcode___0);
          }
        }
      } else {
        {
#line 4208
        tmp___23 = sm_strcasecmp((char const   *)(line + 1), "try");
        }
#line 4208
        if (tmp___23 == 0) {
          {
#line 4212
          rcode___1 = 0;
#line 4214
          q = strpbrk((char const   *)p, " \t");
          }
#line 4215
          if ((unsigned long )q != (unsigned long )((void *)0)) {
            {
#line 4217
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 4217
              if (((int )*q & -128) == 0) {
                {
#line 4217
                tmp___13 = __ctype_b_loc();
                }
#line 4217
                if (! ((int const   )*(*tmp___13 + (int )*q) & 8192)) {
#line 4217
                  goto while_break___11;
                }
              } else {
#line 4217
                goto while_break___11;
              }
#line 4218
              tmp___12 = q;
#line 4218
              q ++;
#line 4218
              *tmp___12 = (char )'\000';
            }
            while_break___11: /* CIL Label */ ;
            }
          }
#line 4220
          if ((unsigned long )q == (unsigned long )((void *)0)) {
            {
#line 4222
            sm_io_fprintf(& SmIoF[1], -2, "Usage: /try mailer address\n");
            }
#line 4224
            return;
          } else
#line 4220
          if ((int )*q == 0) {
            {
#line 4222
            sm_io_fprintf(& SmIoF[1], -2, "Usage: /try mailer address\n");
            }
#line 4224
            return;
          }
          {
#line 4226
          st = stab(p, 3, 0);
          }
#line 4227
          if ((unsigned long )st == (unsigned long )((void *)0)) {
            {
#line 4229
            sm_io_fprintf(& SmIoF[1], -2, "Unknown mailer %s\n", p);
            }
#line 4231
            return;
          }
#line 4233
          m = st->s_value.sv_mailer;
#line 4234
          if ((tryflags & 1) != 0) {
#line 4234
            tmp___14 = "sender";
          } else {
#line 4234
            tmp___14 = "recipient";
          }
#line 4234
          if ((tryflags & 2) != 0) {
#line 4234
            tmp___15 = "header";
          } else {
#line 4234
            tmp___15 = "envelope";
          }
          {
#line 4234
          sm_io_fprintf(& SmIoF[1], -2, "Trying %s %s address %s for mailer %s\n",
                        tmp___15, tmp___14, q, p);
#line 4240
          p = remotename(q, m, tryflags, & rcode___1, CurEnv);
          }
#line 4241
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 4241
            tmp___16 = "<NULL>";
          } else {
#line 4241
            tmp___16 = (char const   *)p;
          }
          {
#line 4241
          sm_io_fprintf(& SmIoF[1], -2, "Rcode = %d, addr = %s\n", rcode___1, tmp___16);
#line 4244
          e->e_to = (char *)((void *)0);
          }
        } else {
          {
#line 4246
          tmp___22 = sm_strcasecmp((char const   *)(line + 1), "tryflags");
          }
#line 4246
          if (tmp___22 == 0) {
#line 4248
            if ((int )*p == 0) {
              {
#line 4250
              sm_io_fprintf(& SmIoF[1], -2, "Usage: /tryflags [Hh|Ee][Ss|Rr]\n");
              }
#line 4252
              return;
            }
            {
#line 4254
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 4254
              if (! ((int )*p != 0)) {
#line 4254
                goto while_break___12;
              }
              {
#line 4259
              if ((int )*p == 104) {
#line 4259
                goto case_104;
              }
#line 4259
              if ((int )*p == 72) {
#line 4259
                goto case_104;
              }
#line 4264
              if ((int )*p == 101) {
#line 4264
                goto case_101;
              }
#line 4264
              if ((int )*p == 69) {
#line 4264
                goto case_101;
              }
#line 4269
              if ((int )*p == 115) {
#line 4269
                goto case_115;
              }
#line 4269
              if ((int )*p == 83) {
#line 4269
                goto case_115;
              }
#line 4274
              if ((int )*p == 114) {
#line 4274
                goto case_114;
              }
#line 4274
              if ((int )*p == 82) {
#line 4274
                goto case_114;
              }
#line 4256
              goto switch_break___3;
              case_104: /* CIL Label */ 
              case_72: /* CIL Label */ 
#line 4260
              tryflags |= 2;
#line 4261
              goto switch_break___3;
              case_101: /* CIL Label */ 
              case_69: /* CIL Label */ 
#line 4265
              tryflags &= -3;
#line 4266
              goto switch_break___3;
              case_115: /* CIL Label */ 
              case_83___0: /* CIL Label */ 
#line 4270
              tryflags |= 1;
#line 4271
              goto switch_break___3;
              case_114: /* CIL Label */ 
              case_82: /* CIL Label */ 
#line 4275
              tryflags &= -2;
#line 4276
              goto switch_break___3;
              switch_break___3: /* CIL Label */ ;
              }
#line 4254
              p ++;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 4279
            if ((tryflags & 2) != 0) {
#line 4279
              exbuf[0] = (char )'h';
            } else {
#line 4279
              exbuf[0] = (char )'e';
            }
#line 4280
            exbuf[1] = (char )' ';
#line 4281
            if ((tryflags & 1) != 0) {
#line 4281
              exbuf[2] = (char )'s';
            } else {
#line 4281
              exbuf[2] = (char )'r';
            }
            {
#line 4282
            exbuf[3] = (char )'\000';
#line 4283
            tmp___17 = macid_parse((char *)"{addr_type}", (char **)((void *)0));
#line 4283
            macdefine_tagged(& e->e_macro, (ARGCLASS_T )1, tmp___17, exbuf, (char *)"/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c",
                             4284, SmHeapGroup);
            }
          } else {
            {
#line 4286
            tmp___21 = sm_strcasecmp((char const   *)(line + 1), "parse");
            }
#line 4286
            if (tmp___21 == 0) {
#line 4288
              if ((int )*p == 0) {
                {
#line 4290
                sm_io_fprintf(& SmIoF[1], -2, "Usage: /parse address\n");
                }
#line 4292
                return;
              }
              {
#line 4294
              q = crackaddr(p, e);
#line 4295
              sm_io_fprintf(& SmIoF[1], -2, "Cracked address = ");
#line 4297
              xputs(& SmIoF[1], (char const   *)q);
              }
#line 4298
              if ((tryflags & 1) != 0) {
#line 4298
                tmp___18 = "sender";
              } else {
#line 4298
                tmp___18 = "recipient";
              }
#line 4298
              if ((tryflags & 2) != 0) {
#line 4298
                tmp___19 = "header";
              } else {
#line 4298
                tmp___19 = "envelope";
              }
              {
#line 4298
              sm_io_fprintf(& SmIoF[1], -2, "\nParsing %s %s address\n", tmp___19,
                            tmp___18);
#line 4304
              tmp___20 = parseaddr(p, & a, tryflags, '\000', (char **)((void *)0),
                                   e, 1);
              }
#line 4304
              if ((unsigned long )tmp___20 == (unsigned long )((void *)0)) {
                {
#line 4306
                sm_io_fprintf(& SmIoF[1], -2, "Cannot parse\n");
                }
              } else
#line 4308
              if ((unsigned long )a.q_host != (unsigned long )((void *)0)) {
#line 4308
                if ((int )*(a.q_host + 0) != 0) {
                  {
#line 4309
                  sm_io_fprintf(& SmIoF[1], -2, "mailer %s, host %s, user %s\n", (a.q_mailer)->m_name,
                                a.q_host, a.q_user);
                  }
                } else {
                  {
#line 4315
                  sm_io_fprintf(& SmIoF[1], -2, "mailer %s, user %s\n", (a.q_mailer)->m_name,
                                a.q_user);
                  }
                }
              } else {
                {
#line 4315
                sm_io_fprintf(& SmIoF[1], -2, "mailer %s, user %s\n", (a.q_mailer)->m_name,
                              a.q_user);
                }
              }
#line 4319
              e->e_to = (char *)((void *)0);
            } else {
              {
#line 4323
              sm_io_fprintf(& SmIoF[1], -2, "Unknown \"/\" command %s\n", line);
              }
            }
          }
        }
      }
    }
  }
#line 4327
  return;
  switch_break: /* CIL Label */ ;
  }
#line 4330
  p = line;
  {
#line 4330
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 4330
    if (((int )*p & -128) == 0) {
      {
#line 4330
      tmp___27 = __ctype_b_loc();
      }
#line 4330
      if (! ((int const   )*(*tmp___27 + (int )*p) & 8192)) {
#line 4330
        goto while_break___13;
      }
    } else {
#line 4330
      goto while_break___13;
    }
#line 4331
    goto __Cont___0;
    __Cont___0: /* CIL Label */ 
#line 4330
    p ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 4332
  q = p;
  {
#line 4333
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 4333
    if ((int )*p != 0) {
#line 4333
      if (((int )*p & -128) == 0) {
        {
#line 4333
        tmp___28 = __ctype_b_loc();
        }
#line 4333
        if ((int const   )*(*tmp___28 + (int )*p) & 8192) {
#line 4333
          goto while_break___14;
        }
      }
    } else {
#line 4333
      goto while_break___14;
    }
#line 4334
    p ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 4335
  if ((int )*p == 0) {
    {
#line 4337
    sm_io_fprintf(& SmIoF[1], -2, "No address!\n");
    }
#line 4339
    return;
  }
  {
#line 4341
  *p = (char )'\000';
#line 4342
  tmp___29 = invalidaddr(p + 1, (char *)((void *)0), 1);
  }
#line 4342
  if (tmp___29) {
#line 4343
    return;
  }
  {
#line 4344
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 4349
    if (ConfigLevel >= 9) {
#line 4349
      tmp___30 = TokTypeNoC;
    } else {
#line 4349
      tmp___30 = (unsigned char *)((void *)0);
    }
    {
#line 4349
    p ++;
#line 4349
    pvp = prescan(p, ',', pvpbuf, (int )sizeof(pvpbuf), & delimptr, tmp___30, 0);
    }
#line 4351
    if ((unsigned long )pvp == (unsigned long )((void *)0)) {
#line 4352
      goto __Cont___1;
    }
#line 4353
    p = q;
    {
#line 4354
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 4354
      if (! ((int )*p != 0)) {
#line 4354
        goto while_break___16;
      }
      {
#line 4358
      rs = strtorwset(p, (char **)((void *)0), 0);
      }
#line 4359
      if (rs < 0) {
        {
#line 4361
        sm_io_fprintf(& SmIoF[1], -2, "Undefined ruleset %s\n", p);
        }
#line 4364
        goto while_break___16;
      }
      {
#line 4366
      status = rewrite(pvp, rs, 0, e, 1000);
      }
#line 4367
      if (status != 0) {
        {
#line 4368
        sm_io_fprintf(& SmIoF[1], -2, "== Ruleset %s (%d) status %d\n", p, rs, status);
        }
      }
      {
#line 4371
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 4371
        if ((int )*p != 0) {
#line 4371
          tmp___31 = p;
#line 4371
          p ++;
#line 4371
          if (! ((int )*tmp___31 != 44)) {
#line 4371
            goto while_break___17;
          }
        } else {
#line 4371
          goto while_break___17;
        }
#line 4372
        goto while_continue___17;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    __Cont___1: /* CIL Label */ 
#line 4344
    p = delimptr;
#line 4344
    if (! ((int )*p != 0)) {
#line 4344
      goto while_break___15;
    }
  }
  while_break___15: /* CIL Label */ ;
  }
#line 4375
  return;
}
}
#line 4377 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
static void dump_class(STAB *s , int id ) 
{ 
  char *__cil_tmp3 ;

  {
#line 4382
  if ((int )s->s_symtype != 1) {
#line 4383
    return;
  }
#line 4384
  if (s->s_value.sv_class[(unsigned long )((unsigned char )((unsigned int )id & 255U)) / (8UL * sizeof(int )) & (32UL / sizeof(int ) - 1UL)] & (1U << (unsigned long )((unsigned char )((unsigned int )id & 255U)) % (8UL * sizeof(int )))) {
    {
#line 4385
    sm_io_fprintf(& SmIoF[1], -2, "%s\n", s->s_name);
    }
  }
#line 4387
  return;
}
}
#line 4397 "/home/pronto/abs/test-suite/sendmail-8.13.6/obj.Linux.2.6.15.i686/sendmail/main.c"
struct sm_exc_type  const  EtypeQuickAbort  =    {SmExcTypeMagic, "E:mta.quickabort", "i", & sm_etype_printf, "quick abort %0"};
