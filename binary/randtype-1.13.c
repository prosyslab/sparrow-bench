/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 250 "/usr/include/unistd.h"
typedef __off64_t off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_17 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_17 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_18 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_18 fd_set;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_33 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_35 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_36 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_37 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_38 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_31 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_32 _kill ;
   struct __anonstruct__timer_33 _timer ;
   struct __anonstruct__rt_34 _rt ;
   struct __anonstruct__sigchld_35 _sigchld ;
   struct __anonstruct__sigfault_36 _sigfault ;
   struct __anonstruct__sigpoll_37 _sigpoll ;
   struct __anonstruct__sigsys_38 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_30 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_31 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_30 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_50 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_50 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 1224 "/usr/include/zlib.h"
struct gzFile_s;
#line 1224 "/usr/include/zlib.h"
typedef struct gzFile_s *gzFile;
#line 1670 "/usr/include/zlib.h"
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off64_t pos ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
struct replaces {
   char *find ;
   char *replace ;
   struct replaces *next ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
typedef struct replaces REPLACE;
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 359
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 139 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) raise)(int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 218
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigdelset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 1264 "/usr/include/zlib.h"
extern gzFile gzdopen(int fd , char const   *mode ) ;
#line 1372
extern char *gzgets(gzFile file , char *buf , int len ) ;
#line 1511
extern int gzclose(gzFile file ) ;
#line 1725
extern gzFile gzopen(char const   * , char const   * ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
REPLACE *replace  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
float tms  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
float cms  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
int err  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
unsigned int tmult  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
unsigned int cmult  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
unsigned int dolines  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
unsigned int mistakes  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
unsigned int dir  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
char nowait[137]  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
char wait[137]  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.h"
char dumpstr[64]  ;
#line 54
static void usage(char const   *me ) ;
#line 55
static int randtype(char *str ) ;
#line 56
static int splitter(char const   *filename , int kill___0 ) ;
#line 57
static char chk_special(char const   *str , char const   c ) ;
#line 58
static int time_split(char const   *str , float *ms , unsigned int *mult ) ;
#line 59
static void randsleep(float ms , unsigned int mult ) ;
#line 60
static void catch_signal(int signal___0 ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static void cleanup(void) 
{ 
  REPLACE *cur ;
  REPLACE *next ;

  {
#line 37
  if (replace) {
#line 38
    cur = replace;
    {
#line 38
    while (1) {
      while_continue: /* CIL Label */ ;
#line 38
      if (! cur) {
#line 38
        goto while_break;
      }
      {
#line 39
      next = cur->next;
#line 40
      free((void *)cur->find);
#line 41
      free((void *)cur->replace);
#line 42
      free((void *)cur);
#line 38
      cur = next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 46
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static void catch_signal(int signal___0 ) 
{ 


  {
  {
#line 53
  if (signal___0 == 14) {
#line 53
    goto case_14;
  }
#line 56
  if (signal___0 == 15) {
#line 56
    goto case_15;
  }
#line 58
  if (signal___0 == 2) {
#line 58
    goto case_2;
  }
#line 60
  goto switch_default;
  case_14: /* CIL Label */ 
  {
#line 54
  raise(15);
  }
#line 55
  goto switch_break;
  case_15: /* CIL Label */ 
#line 57
  goto switch_break;
  case_2: /* CIL Label */ 
#line 59
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 61
  raise(15);
  }
#line 62
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 65
  cleanup();
#line 66
  exit(signal___0);
  }
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static void usage(char const   *me ) 
{ 


  {
  {
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-hvl] [-d ,|.<string> [-k]] [-n <string>] [-t <ms,mult>]\n\t\t  [-w <string> [-c ms,mult]] [-r s1,s2[:...]] [-m <int>]\n\t\t  [-q <int>] [file ...]\n\n",
          me);
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -t ms,mult\tSpecify randomness where `ms\' is the maximum microseconds\n\t\tbetween characters and `mult\' is the multiplier of `ms\'.\n\t\tDefault is %i,%i.\n",
          18, 20000);
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -d string\tA string beginning with either \',\' (left) or \'.\' (right) which\n\t\tis output immediately.\n");
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -k\t\tKill the dump string (-d) when printing the line.\n");
#line 87
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -r s1,s2\tReplace s1 with s2. Separate more than one with \':\'.\n");
#line 90
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -n chars\tPrint these characters immediately.\n");
#line 92
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -w chars\tThe opposite of the -n option, these characters are delayed by\n\t\tthe time specified by the -c option.\n");
#line 96
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -c ms,mult\tFor use with the -w option, this option has the same value\n\t\tformat as the -t option or the same default.\n");
#line 100
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -l\t\tThe -t option will apply to outputting lines rather than\n\t\tcharacters, all options other than -q are ignored.\n");
#line 104
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -m int\tGenerate mistakes on output with a frequency of <int>. The\n\t\tfrequency is the comparison of a random alphanumeric character\n\t\tand the next character.\n");
#line 107
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -q int\tTerminate program after specified amount of seconds.\n");
#line 109
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -h\t\tYour looking at it.\n");
#line 110
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v\t\tShow version information.\n");
#line 112
  exit(-1);
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static char chk_special(char const   *str , char const   c ) 
{ 
  register char i ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    tmp___0 = str;
#line 120
    str ++;
#line 120
    i = (char )*tmp___0;
#line 120
    if (! i) {
#line 120
      goto while_break;
    }
#line 121
    if ((int )i == 92) {
#line 121
      if (*str) {
#line 122
        tmp = str;
#line 122
        str ++;
#line 122
        i = (char )*tmp;
        {
#line 123
        if ((int )i == 97) {
#line 123
          goto case_97;
        }
#line 126
        if ((int )i == 98) {
#line 126
          goto case_98;
        }
#line 129
        if ((int )i == 102) {
#line 129
          goto case_102;
        }
#line 132
        if ((int )i == 110) {
#line 132
          goto case_110;
        }
#line 135
        if ((int )i == 114) {
#line 135
          goto case_114;
        }
#line 138
        if ((int )i == 116) {
#line 138
          goto case_116;
        }
#line 141
        if ((int )i == 118) {
#line 141
          goto case_118;
        }
#line 144
        if ((int )i == 92) {
#line 144
          goto case_92;
        }
#line 147
        goto switch_default;
        case_97: /* CIL Label */ 
#line 124
        i = (char )'\a';
#line 125
        goto switch_break;
        case_98: /* CIL Label */ 
#line 127
        i = (char )'\b';
#line 128
        goto switch_break;
        case_102: /* CIL Label */ 
#line 130
        i = (char )'\f';
#line 131
        goto switch_break;
        case_110: /* CIL Label */ 
#line 133
        i = (char )'\n';
#line 134
        goto switch_break;
        case_114: /* CIL Label */ 
#line 136
        i = (char )'\r';
#line 137
        goto switch_break;
        case_116: /* CIL Label */ 
#line 139
        i = (char )'\t';
#line 140
        goto switch_break;
        case_118: /* CIL Label */ 
#line 142
        i = (char)11;
#line 143
        goto switch_break;
        case_92: /* CIL Label */ 
#line 145
        i = (char )'\\';
#line 146
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 148
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 152
    if ((int )i == (int )c) {
#line 153
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return (i);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static struct timeval tv  ;
#line 159 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static void randsleep(float ms , unsigned int mult ) 
{ 
  long i ;
  long tmp ;

  {
  {
#line 165
  tmp = random();
#line 165
  i = (long )((unsigned int )(1 + (int )((double )(ms * (float )tmp) / ((double )2147483647 + 1.0))) * mult);
  }
#line 171
  if (i > 999999L) {
#line 172
    tv.tv_sec = i / 1000000L;
#line 173
    tv.tv_usec = i % 1000000L;
  } else {
#line 176
    tv.tv_usec = i;
  }
  {
#line 179
  select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
         (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 181
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static void randchar(int c ) 
{ 
  int i ;
  long tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 190
    tmp = random();
#line 190
    i = (1 + (int )((94.0 * (double )tmp) / ((double )2147483647 + 1.0))) + 32;
#line 188
    tmp___0 = __ctype_b_loc();
    }
#line 188
    if ((int const   )*(*tmp___0 + i) & 1024) {
#line 188
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  tmp___4 = __ctype_b_loc();
  }
#line 196
  if ((int const   )*(*tmp___4 + c) & 512) {
    {
#line 196
    tmp___2 = tolower(i);
#line 196
    tmp___3 = tmp___2;
    }
  } else {
#line 196
    tmp___3 = i;
  }
  {
#line 196
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c",
          tmp___3);
#line 197
  randsleep(tms * (float )2, tmult);
#line 198
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\b \b");
#line 199
  randsleep(tms * (float )2, tmult);
  }
#line 201
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static int randint(float max ) 
{ 
  long tmp ;

  {
  {
#line 207
  tmp = random();
  }
#line 207
  return (1 + (int )((double )(max * (float )tmp) / ((double )2147483647 + 1.0)));
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static int randtype(char *str ) 
{ 
  int n ;
  int p ;
  register unsigned int i ;
  register char c ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 215
  n = 0;
#line 216
  i = 0U;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    tmp___2 = str;
#line 219
    str ++;
#line 219
    i = (unsigned int )*tmp___2;
#line 219
    if (! i) {
#line 219
      goto while_break;
    }
#line 220
    p = 0;
    {
#line 220
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 220
      if (! ((unsigned int )p < mistakes)) {
#line 220
        goto while_break___0;
      }
      {
#line 221
      tmp = __ctype_b_loc();
      }
#line 221
      if (! ((int const   )*(*tmp + (int )i) & 1024)) {
#line 222
        goto while_break___0;
      }
      {
#line 224
      tmp___0 = strlen((char const   *)str);
#line 224
      tmp___1 = randint((float )tmp___0);
      }
#line 224
      if (tmp___1 == n) {
        {
#line 225
        randchar((int )i);
        }
#line 226
        goto while_break___0;
      }
#line 220
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 230
    n ++;
#line 231
    c = chk_special((char const   *)(nowait), (char const   )i);
    }
#line 233
    if (i == (unsigned int )c) {
      {
#line 234
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c",
              i);
      }
#line 235
      goto while_continue;
    }
    {
#line 238
    c = chk_special((char const   *)(wait), (char const   )i);
    }
#line 240
    if (i == (unsigned int )c) {
      {
#line 241
      randsleep(cms, cmult);
#line 242
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c",
              i);
      }
#line 243
      goto while_continue;
    }
    {
#line 246
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c",
            i);
#line 247
    randsleep(tms, tmult);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  return (0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static int time_split(char const   *str , float *ms , unsigned int *mult ) 
{ 
  register int n ;
  register int i ;
  char *s ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;

  {
  {
#line 259
  tmp = strdup(str);
#line 262
  n = 0;
  }
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! (n <= 1)) {
#line 262
      goto while_break;
    }
#line 263
    if (n == 0) {
      {
#line 264
      s = strtok((char */* __restrict  */)tmp, (char const   */* __restrict  */)",");
      }
    } else {
      {
#line 266
      s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
      }
    }
#line 268
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 269
      return (1);
    }
#line 271
    i = 0;
    {
#line 271
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 271
      tmp___1 = strlen((char const   *)s);
      }
#line 271
      if (! ((size_t )i < tmp___1)) {
#line 271
        goto while_break___0;
      }
      {
#line 272
      tmp___0 = __ctype_b_loc();
      }
#line 272
      if (((int const   )*(*tmp___0 + (int )*(s + i)) & 2048) == 0) {
#line 273
        return (1);
      }
#line 271
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 276
    if (n == 0) {
      {
#line 277
      tmp___2 = atof((char const   *)s);
#line 277
      *ms = (float )tmp___2;
      }
    } else {
      {
#line 279
      tmp___3 = atoi((char const   *)s);
#line 279
      *mult = (unsigned int )tmp___3;
      }
    }
#line 262
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  free((void *)tmp);
  }
#line 283
  return (0);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static char *strrep(char *str , char *find , char *repl ) 
{ 
  char *p0 ;
  char *p1 ;
  char *p2 ;
  size_t find_len ;
  size_t tmp ;
  size_t repl_len ;
  size_t tmp___0 ;
  size_t dist ;
  size_t diff ;
  size_t tmp___1 ;

  {
  {
#line 292
  tmp = strlen((char const   *)find);
#line 292
  find_len = tmp;
#line 293
  tmp___0 = strlen((char const   *)repl);
#line 293
  repl_len = tmp___0;
#line 294
  dist = (size_t )0;
#line 294
  diff = repl_len - find_len;
  }
#line 296
  if (! find_len) {
#line 297
    return (str);
  } else {
    {
#line 296
    p0 = strstr((char const   *)str, (char const   *)find);
    }
#line 296
    if ((unsigned long )p0 == (unsigned long )((void *)0)) {
#line 297
      return (str);
    }
  }
#line 299
  if (diff > 0UL) {
#line 300
    p1 = p0 + 1;
    {
#line 300
    while (1) {
      while_continue: /* CIL Label */ ;
#line 300
      if (! ((unsigned long )p1 != (unsigned long )((void *)0))) {
#line 300
        goto while_break;
      }
      {
#line 301
      dist += diff;
#line 300
      p1 ++;
#line 300
      p1 = strstr((char const   *)p1, (char const   *)find);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 303
    tmp___1 = strlen((char const   *)str);
#line 303
    memmove((void *)(p0 + dist), (void const   *)p0, (tmp___1 - (size_t )(p0 - str)) + 1UL);
    }
  }
#line 306
  if (diff > 0UL) {
#line 306
    p1 = (p0 + dist) + find_len;
  } else {
#line 306
    p1 = p0 + find_len;
  }
  {
#line 307
  p2 = strstr((char const   *)p1, (char const   *)find);
  }
  {
#line 309
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 309
    if (! p2) {
#line 309
      goto while_break___0;
    }
    {
#line 310
    memcpy((void */* __restrict  */)p0, (void const   */* __restrict  */)repl, repl_len);
#line 311
    p0 += repl_len;
#line 312
    memmove((void *)p0, (void const   *)p1, (size_t )(p2 - p1));
#line 313
    p0 += p2 - p1;
#line 314
    p1 = p2 + find_len;
#line 315
    p2 = strstr((char const   *)p1, (char const   *)find);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  memcpy((void */* __restrict  */)p0, (void const   */* __restrict  */)repl, repl_len);
  }
#line 320
  if (diff < 0UL) {
    {
#line 321
    p0 += repl_len;
#line 322
    p2 = strchr((char const   *)p1, '\000');
#line 323
    memmove((void *)p0, (void const   *)p1, (size_t )((p2 - p1) + 1L));
    }
  }
#line 326
  return (str);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static int splitter(char const   *filename , int kill___0 ) 
{ 
  gzFile *fp ;
  char *s ;
  char *src ;
  char *tmp ;
  register unsigned int i ;
  int *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  gzFile tmp___5 ;
  int *tmp___6 ;
  gzFile tmp___7 ;
  REPLACE *rnode ;
  char *p ;
  char *x ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int *tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;

  {
  {
#line 334
  fp = (gzFile *)((void *)0);
#line 341
  tmp___1 = malloc((size_t )2048);
#line 341
  s = (char *)tmp___1;
  }
#line 341
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 342
    perror("malloc(LINE_MAX)");
#line 343
    tmp___0 = __errno_location();
    }
#line 343
    return (*tmp___0);
  }
  {
#line 346
  tmp___3 = calloc((size_t )0, (size_t )1);
#line 346
  src = (char *)tmp___3;
  }
#line 346
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 347
    perror("calloc()");
#line 348
    tmp___2 = __errno_location();
    }
#line 348
    return (*tmp___2);
  }
#line 351
  if ((int const   )*(filename + 0) == 45) {
#line 351
    if ((int const   )*(filename + 1) == 0) {
      {
#line 353
      tmp___5 = gzdopen(0, "rb");
#line 353
      fp = (gzFile *)tmp___5;
      }
#line 353
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
        {
#line 354
        perror(filename);
#line 355
        tmp___4 = __errno_location();
        }
#line 355
        return (*tmp___4);
      }
    } else {
#line 351
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 363
    tmp___7 = gzopen(filename, "rb");
#line 363
    fp = (gzFile *)tmp___7;
    }
#line 363
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 367
      perror(filename);
#line 368
      tmp___6 = __errno_location();
      }
#line 368
      return (*tmp___6);
    }
  }
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 373
    s = gzgets((gzFile )fp, s, 2048);
    }
#line 373
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 373
      goto while_break;
    }
#line 380
    if (replace) {
#line 381
      rnode = replace;
      {
#line 383
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 383
        if (! ((unsigned long )rnode->next != (unsigned long )((void *)0))) {
#line 383
          goto while_break___0;
        }
        {
#line 386
        x = strrep(s, rnode->find, rnode->replace);
#line 387
        strncpy((char */* __restrict  */)s, (char const   */* __restrict  */)x, (size_t )2047);
#line 388
        rnode = rnode->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 392
    if (dolines) {
      {
#line 393
      randsleep(tms, tmult);
#line 394
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
              s);
      }
#line 395
      goto while_continue;
    }
#line 398
    if (dumpstr[0]) {
#line 399
      if (dir == 44U) {
        {
#line 400
        tmp = strstr((char const   *)s, (char const   *)(dumpstr));
        }
#line 400
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 401
          i = 0U;
          {
#line 401
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 401
            tmp___8 = strlen((char const   *)s);
#line 401
            tmp___9 = strlen((char const   *)tmp);
            }
#line 401
            if (! ((size_t )i < tmp___8 - tmp___9)) {
#line 401
              goto while_break___1;
            }
            {
#line 402
            fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c",
                    (int )*(s + i));
#line 401
            i ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 404
          tmp___11 = calloc((size_t )1, (size_t )2048);
#line 404
          s = (char *)tmp___11;
          }
#line 404
          if ((unsigned long )s == (unsigned long )((void *)0)) {
            {
#line 405
            perror("calloc");
#line 406
            tmp___10 = __errno_location();
            }
#line 406
            return (*tmp___10);
          }
#line 409
          if (kill___0) {
            {
#line 410
            tmp___12 = strlen((char const   *)(dumpstr));
#line 410
            i = (unsigned int )tmp___12;
            }
            {
#line 410
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 410
              tmp___13 = strlen((char const   *)tmp);
              }
#line 410
              if (! ((size_t )i < tmp___13)) {
#line 410
                goto while_break___2;
              }
              {
#line 411
              sprintf((char */* __restrict  */)src, (char const   */* __restrict  */)"%c",
                      (int )*(tmp + i));
#line 412
              strncat((char */* __restrict  */)s, (char const   */* __restrict  */)src,
                      (size_t )2047);
#line 410
              i ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          } else {
            {
#line 416
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 416
              tmp___14 = tmp;
#line 416
              tmp ++;
#line 416
              i = (unsigned int )*tmp___14;
#line 416
              if (! i) {
#line 416
                goto while_break___3;
              }
              {
#line 417
              sprintf((char */* __restrict  */)src, (char const   */* __restrict  */)"%c",
                      i);
#line 418
              strncat((char */* __restrict  */)s, (char const   */* __restrict  */)src,
                      (size_t )2047);
              }
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        }
      } else {
        {
#line 424
        p = strdup((char const   *)s);
#line 426
        tmp = strtok((char */* __restrict  */)s, (char const   */* __restrict  */)(dumpstr));
        }
#line 426
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
          {
#line 427
          randtype(tmp);
          }
#line 429
          if (kill___0) {
            {
#line 430
            tmp___15 = strlen((char const   *)tmp);
#line 430
            tmp___16 = strlen((char const   *)(dumpstr));
#line 430
            i = (unsigned int )(tmp___15 + tmp___16);
            }
          } else {
            {
#line 432
            tmp___17 = strlen((char const   *)tmp);
#line 432
            i = (unsigned int )tmp___17;
            }
          }
#line 434
          i = i;
          {
#line 434
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 434
            tmp___18 = strlen((char const   *)p);
            }
#line 434
            if (! ((size_t )i < tmp___18)) {
#line 434
              goto while_break___4;
            }
            {
#line 435
            fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c",
                    (int )*(p + i));
#line 434
            i ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
        }
        {
#line 439
        free((void *)p);
        }
      }
    }
#line 443
    if (dir != 46U) {
      {
#line 444
      randtype(s);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 448
  gzclose((gzFile )fp);
  }
#line 453
  if (! dolines) {
    {
#line 454
    free((void *)src);
    }
  }
  {
#line 456
  free((void *)s);
  }
#line 458
  return (0);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static int parse_replace(char const   *str ) 
{ 
  REPLACE *rnode ;
  char *tmp ;
  char *s ;
  char *ss ;
  int *tmp___0 ;
  void *tmp___1 ;
  char *find ;
  char *repl ;
  int i ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;
  struct replaces *tmp___11 ;
  void *tmp___12 ;

  {
  {
#line 466
  tmp___1 = malloc(sizeof(REPLACE ));
#line 466
  replace = (REPLACE *)tmp___1;
  }
#line 466
  if ((unsigned long )replace == (unsigned long )((void *)0)) {
    {
#line 467
    perror("malloc");
#line 468
    tmp___0 = __errno_location();
#line 468
    exit(*tmp___0);
    }
  }
  {
#line 471
  rnode = replace;
#line 472
  tmp = strdup(str);
  }
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 474
    s = strtok_r((char */* __restrict  */)tmp, (char const   */* __restrict  */)":",
                 (char **/* __restrict  */)(& ss));
    }
#line 474
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 474
      goto while_break;
    }
    {
#line 478
    find = strtok((char */* __restrict  */)s, (char const   */* __restrict  */)",");
    }
#line 478
    if ((unsigned long )find == (unsigned long )((void *)0)) {
#line 479
      return (1);
    }
    {
#line 481
    tmp___2 = strlen((char const   *)find);
#line 481
    i = (int )(tmp___2 + 1UL);
#line 483
    tmp___5 = malloc((size_t )i);
#line 483
    tmp___4 = (char *)tmp___5;
#line 483
    rnode->find = tmp___4;
    }
#line 483
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
      {
#line 484
      perror("malloc");
#line 485
      tmp___3 = __errno_location();
#line 485
      exit(*tmp___3);
      }
    }
    {
#line 488
    snprintf((char */* __restrict  */)rnode->find, (size_t )i, (char const   */* __restrict  */)"%s",
             find);
#line 490
    repl = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
    }
#line 490
    if ((unsigned long )repl == (unsigned long )((void *)0)) {
#line 491
      return (1);
    }
    {
#line 493
    tmp___6 = strlen((char const   *)repl);
#line 493
    i = (int )(tmp___6 + 1UL);
#line 495
    tmp___9 = malloc((size_t )i);
#line 495
    tmp___8 = (char *)tmp___9;
#line 495
    rnode->replace = tmp___8;
    }
#line 495
    if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
      {
#line 496
      perror("malloc");
#line 497
      tmp___7 = __errno_location();
#line 497
      exit(*tmp___7);
      }
    }
    {
#line 500
    snprintf((char */* __restrict  */)rnode->replace, (size_t )i, (char const   */* __restrict  */)"%s",
             repl);
#line 502
    tmp___12 = malloc(sizeof(REPLACE ));
#line 502
    tmp___11 = (REPLACE *)tmp___12;
#line 502
    rnode->next = tmp___11;
    }
#line 502
    if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
      {
#line 503
      perror("malloc");
#line 504
      tmp___10 = __errno_location();
#line 504
      exit(*tmp___10);
      }
    }
#line 507
    rnode = rnode->next;
#line 508
    tmp = ss;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 511
  rnode->next = (struct replaces *)((void *)0);
#line 513
  tmp = (char *)((void *)0);
#line 514
  free((void *)tmp);
  }
#line 516
  return (0);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static unsigned int i  ;
#line 521 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static unsigned int opt  ;
#line 521 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static unsigned int kill___0  ;
#line 521 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
static unsigned int quit  ;
#line 519 "/home/june/repo/benchmarks/collector/temp/randtype-1.13/randtype.c"
int main(int argc , char **argv ) 
{ 
  char *time ;
  char *chartime ;
  char *replacestr ;
  char progname[255] ;
  char tmp[255] ;
  struct sigaction my_sigaction ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned int tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  __pid_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 522
  time = (char *)((void *)0);
#line 522
  chartime = (char *)((void *)0);
#line 522
  replacestr = (char *)((void *)0);
#line 526
  bzero((void *)(& my_sigaction), sizeof(my_sigaction));
#line 527
  bzero((void *)(progname), sizeof(progname));
#line 528
  snprintf((char */* __restrict  */)(progname), sizeof(progname), (char const   */* __restrict  */)"%s",
           *(argv + 0));
#line 531
  cms = (float )18;
#line 531
  tms = cms;
#line 532
  cmult = 20000U;
#line 532
  tmult = cmult;
#line 533
  wait[0] = (char )'\000';
#line 533
  nowait[0] = wait[0];
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 535
    tmp___9 = getopt(argc, (char * const  *)argv, "m:vhr:q:t:n:w:d:c:kl");
#line 535
    opt = (unsigned int )tmp___9;
    }
#line 535
    if (! (opt != 4294967295U)) {
#line 535
      goto while_break;
    }
#line 536
    tmp[0] = (char)0;
    {
#line 539
    if (opt == 0U) {
#line 539
      goto case_0;
    }
#line 541
    if (opt == 109U) {
#line 541
      goto case_109;
    }
#line 551
    if (opt == 110U) {
#line 551
      goto case_110;
    }
#line 554
    if (opt == 119U) {
#line 554
      goto case_119;
    }
#line 557
    if (opt == 116U) {
#line 557
      goto case_116;
    }
#line 560
    if (opt == 114U) {
#line 560
      goto case_114;
    }
#line 563
    if (opt == 100U) {
#line 563
      goto case_100;
    }
#line 575
    if (opt == 99U) {
#line 575
      goto case_99;
    }
#line 578
    if (opt == 107U) {
#line 578
      goto case_107;
    }
#line 581
    if (opt == 108U) {
#line 581
      goto case_108;
    }
#line 584
    if (opt == 113U) {
#line 584
      goto case_113;
    }
#line 594
    if (opt == 118U) {
#line 594
      goto case_118;
    }
#line 598
    goto switch_default;
    case_0: /* CIL Label */ 
#line 540
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 542
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp), (char const   */* __restrict  */)"%s",
             optarg);
#line 544
    i = 0U;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 544
      tmp___1 = strlen((char const   *)(tmp));
      }
#line 544
      if (! ((size_t )i < tmp___1)) {
#line 544
        goto while_break___0;
      }
      {
#line 545
      tmp___0 = __ctype_b_loc();
      }
#line 545
      if (((int const   )*(*tmp___0 + (int )tmp[i]) & 2048) == 0) {
        {
#line 546
        usage((char const   *)(progname));
        }
      }
#line 544
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 549
    tmp___2 = atoi((char const   *)(tmp));
#line 549
    mistakes = (unsigned int )tmp___2;
    }
#line 550
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 552
    snprintf((char */* __restrict  */)(nowait), sizeof(nowait), (char const   */* __restrict  */)"%s",
             optarg);
    }
#line 553
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 555
    snprintf((char */* __restrict  */)(wait), sizeof(wait), (char const   */* __restrict  */)"%s",
             optarg);
    }
#line 556
    goto switch_break;
    case_116: /* CIL Label */ 
#line 558
    time = optarg;
#line 559
    goto switch_break;
    case_114: /* CIL Label */ 
#line 561
    replacestr = optarg;
#line 562
    goto switch_break;
    case_100: /* CIL Label */ 
#line 564
    if ((int )*(optarg + 0) != 44) {
#line 564
      if ((int )*(optarg + 0) != 46) {
        {
#line 565
        usage((char const   *)(progname));
        }
      } else {
#line 564
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 564
      tmp___3 = strlen((char const   *)optarg);
      }
#line 564
      if (tmp___3 < 2UL) {
        {
#line 565
        usage((char const   *)(progname));
        }
      }
    }
#line 567
    dir = (unsigned int )*(optarg + 0);
    {
#line 569
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 569
      tmp___5 = optarg;
#line 569
      optarg ++;
#line 569
      if (! *tmp___5) {
#line 569
        goto while_break___1;
      }
#line 570
      tmp___4 = i;
#line 570
      i ++;
#line 570
      tmp[tmp___4] = *optarg;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 572
    tmp[i] = (char)0;
#line 573
    snprintf((char */* __restrict  */)(dumpstr), sizeof(dumpstr), (char const   */* __restrict  */)"%s",
             tmp);
    }
#line 574
    goto switch_break;
    case_99: /* CIL Label */ 
#line 576
    chartime = optarg;
#line 577
    goto switch_break;
    case_107: /* CIL Label */ 
#line 579
    kill___0 = 1U;
#line 580
    goto switch_break;
    case_108: /* CIL Label */ 
#line 582
    dolines = 1U;
#line 583
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 585
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp), (char const   */* __restrict  */)"%s",
             optarg);
#line 587
    i = 0U;
    }
    {
#line 587
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 587
      tmp___7 = strlen((char const   *)(tmp));
      }
#line 587
      if (! ((size_t )i < tmp___7)) {
#line 587
        goto while_break___2;
      }
      {
#line 588
      tmp___6 = __ctype_b_loc();
      }
#line 588
      if (((int const   )*(*tmp___6 + (int )tmp[i]) & 2048) == 0) {
        {
#line 589
        usage((char const   *)(progname));
        }
      }
#line 587
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 592
    tmp___8 = atoi((char const   *)(tmp));
#line 592
    quit = (unsigned int )tmp___8;
    }
#line 593
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 595
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n%s\n",
            "randtype 1.13", "Copyright (C) 1999-2001 bjk <bjk@arbornet.org>");
#line 596
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 599
    usage((char const   *)(progname));
    }
#line 600
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  if (replacestr) {
    {
#line 605
    tmp___10 = parse_replace((char const   *)replacestr);
    }
#line 605
    if (tmp___10 != 0) {
      {
#line 606
      usage((char const   *)(progname));
      }
    }
  }
#line 608
  if (time) {
    {
#line 609
    tmp___11 = time_split((char const   *)time, & tms, & tmult);
    }
#line 609
    if (tmp___11 != 0) {
      {
#line 610
      usage((char const   *)(progname));
      }
    }
  }
#line 612
  if (! dolines) {
#line 613
    if ((unsigned long )chartime != (unsigned long )((void *)0)) {
#line 613
      if ((int )wait[0] != 0) {
        {
#line 614
        tmp___12 = time_split((char const   *)chartime, & cms, & cmult);
        }
#line 614
        if (tmp___12 != 0) {
          {
#line 615
          usage((char const   *)(progname));
          }
        }
      }
    }
    {
#line 620
    setvbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)0, 2, (size_t )8192);
    }
  }
  {
#line 624
  sigemptyset(& my_sigaction.sa_mask);
#line 625
  sigfillset(& my_sigaction.sa_mask);
#line 626
  my_sigaction.__sigaction_handler.sa_handler = & catch_signal;
#line 630
  sigdelset(& my_sigaction.sa_mask, 15);
#line 631
  sigdelset(& my_sigaction.sa_mask, 14);
#line 632
  sigdelset(& my_sigaction.sa_mask, 2);
#line 633
  sigdelset(& my_sigaction.sa_mask, 20);
#line 635
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& my_sigaction.sa_mask), (sigset_t */* __restrict  */)((void *)0));
#line 637
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& my_sigaction), (struct sigaction */* __restrict  */)((void *)0));
#line 638
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& my_sigaction), (struct sigaction */* __restrict  */)((void *)0));
#line 639
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& my_sigaction), (struct sigaction */* __restrict  */)((void *)0));
#line 642
  tmp___13 = getpid();
#line 642
  srandom((unsigned int )tmp___13);
#line 648
  alarm(quit);
  }
#line 651
  if (argc == optind) {
    {
#line 652
    tmp___14 = splitter("-", (int )kill___0);
#line 652
    err |= tmp___14;
    }
  } else {
#line 654
    i = (unsigned int )optind;
    {
#line 654
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 654
      if (! (i < (unsigned int )argc)) {
#line 654
        goto while_break___3;
      }
      {
#line 655
      tmp___15 = splitter((char const   *)*(argv + i), (int )kill___0);
#line 655
      err |= tmp___15;
#line 654
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 659
  cleanup();
#line 660
  exit(err);
  }
}
}
