/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 476 "../include/libast/types.h"
typedef long spif_int64_t;
#line 508 "../include/libast/types.h"
typedef signed char spif_char_t;
#line 580 "../include/libast/types.h"
typedef spif_char_t *spif_charptr_t;
#line 598 "../include/libast/types.h"
typedef void *spif_ptr_t;
#line 618 "../include/libast/types.h"
typedef spif_charptr_t spif_classname_t;
#line 821
enum __anonenum_spif_cmp_t_186 {
    SPIF_CMP_LESS = -1,
    SPIF_CMP_EQUAL = 0,
    SPIF_CMP_GREATER = 1
} ;
#line 821 "../include/libast/types.h"
typedef enum __anonenum_spif_cmp_t_186 spif_cmp_t;
#line 937
enum __anonenum_spif_bool_t_187 {
    false = 0,
    False = 0,
    FALSE = 0,
    true = 1,
    True = 1,
    TRUE = 1
} ;
#line 937 "../include/libast/types.h"
typedef enum __anonenum_spif_bool_t_187 spif_bool_t;
#line 708 "../include/libast/obj.h"
struct spif_class_t_struct;
#line 708 "../include/libast/obj.h"
typedef struct spif_class_t_struct spif_const_class_t;
#line 708 "../include/libast/obj.h"
typedef spif_const_class_t *spif_class_t;
#line 708 "../include/libast/obj.h"
struct spif_class_t_struct {
   spif_classname_t classname ;
   void *(*noo)() ;
   void *(*init)() ;
   void *(*done)() ;
   void *(*del)() ;
   void *(*show)() ;
   void *(*comp)() ;
   void *(*dup)() ;
   void *(*type)() ;
};
#line 740
struct spif_obj_t_struct;
#line 740 "../include/libast/obj.h"
typedef struct spif_obj_t_struct spif_const_obj_t;
#line 740 "../include/libast/obj.h"
typedef spif_const_obj_t *spif_obj_t;
#line 740 "../include/libast/obj.h"
struct spif_obj_t_struct {
   spif_class_t cls ;
};
#line 86 "../include/libast/str.h"
typedef spif_int64_t spif_stridx_t;
#line 88
struct spif_str_t_struct;
#line 88 "../include/libast/str.h"
typedef struct spif_str_t_struct spif_const_str_t;
#line 88 "../include/libast/str.h"
typedef spif_const_str_t *spif_str_t;
#line 88 "../include/libast/str.h"
struct spif_str_t_struct {
   spif_const_obj_t parent ;
   spif_charptr_t s ;
   spif_stridx_t size ;
   spif_stridx_t len ;
};
#line 72 "../include/libast/list_if.h"
typedef spif_obj_t spif_list_t;
#line 75
struct spif_listclass_t_struct;
#line 75 "../include/libast/list_if.h"
typedef struct spif_listclass_t_struct spif_const_listclass_t;
#line 75 "../include/libast/list_if.h"
typedef spif_const_listclass_t *spif_listclass_t;
#line 75 "../include/libast/list_if.h"
struct spif_listclass_t_struct {
   spif_const_class_t parent ;
   void *(*append)() ;
   void *(*contains)() ;
   void *(*count)() ;
   void *(*find)() ;
   void *(*get)() ;
   void *(*index)() ;
   void *(*insert)() ;
   void *(*insert_at)() ;
   void *(*iterator)() ;
   void *(*prepend)() ;
   void *(*remove)() ;
   void *(*remove_at)() ;
   void *(*reverse)() ;
   void *(*to_array)() ;
};
#line 51 "../include/libast/tok.h"
struct spif_tok_t_struct;
#line 51 "../include/libast/tok.h"
typedef struct spif_tok_t_struct spif_const_tok_t;
#line 51 "../include/libast/tok.h"
typedef spif_const_tok_t *spif_tok_t;
#line 51 "../include/libast/tok.h"
struct spif_tok_t_struct {
   spif_const_obj_t parent ;
   spif_str_t src ;
   spif_char_t quote ;
   spif_char_t dquote ;
   spif_char_t escape ;
   spif_str_t sep ;
   spif_list_t tokens ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 720 "../include/libast/types.h"
typedef struct protoent spif_const_protoinfo_t;
#line 720 "../include/libast/types.h"
typedef spif_const_protoinfo_t *spif_protoinfo_t;
#line 730 "../include/libast/types.h"
typedef struct servent spif_const_servinfo_t;
#line 730 "../include/libast/types.h"
typedef spif_const_servinfo_t *spif_servinfo_t;
#line 47 "../include/libast/url.h"
struct spif_url_t_struct;
#line 47 "../include/libast/url.h"
typedef struct spif_url_t_struct spif_const_url_t;
#line 47 "../include/libast/url.h"
typedef spif_const_url_t *spif_url_t;
#line 47 "../include/libast/url.h"
struct spif_url_t_struct {
   spif_const_str_t parent ;
   spif_str_t proto ;
   spif_str_t user ;
   spif_str_t passwd ;
   spif_str_t host ;
   spif_str_t port ;
   spif_str_t path ;
   spif_str_t query ;
};
#line 458 "../include/libast/types.h"
typedef int spif_int32_t;
#line 215 "../include/libast/objpair.h"
struct spif_objpair_t_struct;
#line 215 "../include/libast/objpair.h"
typedef struct spif_objpair_t_struct spif_const_objpair_t;
#line 215 "../include/libast/objpair.h"
typedef spif_const_objpair_t *spif_objpair_t;
#line 215 "../include/libast/objpair.h"
struct spif_objpair_t_struct {
   spif_const_obj_t parent ;
   spif_obj_t key ;
   spif_obj_t value ;
};
#line 73 "../include/libast/list_if.h"
typedef spif_int32_t spif_listidx_t;
#line 60 "../include/libast/iterator_if.h"
typedef spif_obj_t spif_iterator_t;
#line 62
struct spif_iteratorclass_t_struct;
#line 62 "../include/libast/iterator_if.h"
typedef struct spif_iteratorclass_t_struct spif_const_iteratorclass_t;
#line 62 "../include/libast/iterator_if.h"
typedef spif_const_iteratorclass_t *spif_iteratorclass_t;
#line 62 "../include/libast/iterator_if.h"
struct spif_iteratorclass_t_struct {
   spif_const_class_t parent ;
   void *(*has_next)() ;
   void *(*next)() ;
};
#line 68 "../include/libast/map_if.h"
typedef spif_obj_t spif_map_t;
#line 70
struct spif_mapclass_t_struct;
#line 70 "../include/libast/map_if.h"
typedef struct spif_mapclass_t_struct spif_const_mapclass_t;
#line 70 "../include/libast/map_if.h"
typedef spif_const_mapclass_t *spif_mapclass_t;
#line 70 "../include/libast/map_if.h"
struct spif_mapclass_t_struct {
   spif_const_class_t parent ;
   void *(*count)() ;
   void *(*get)() ;
   void *(*get_keys)() ;
   void *(*get_pairs)() ;
   void *(*get_values)() ;
   void *(*has_key)() ;
   void *(*has_value)() ;
   void *(*iterator)() ;
   void *(*remove)() ;
   void *(*set)() ;
};
#line 65 "../include/libast/vector_if.h"
typedef spif_obj_t spif_vector_t;
#line 67
struct spif_vectorclass_t_struct;
#line 67 "../include/libast/vector_if.h"
typedef struct spif_vectorclass_t_struct spif_const_vectorclass_t;
#line 67 "../include/libast/vector_if.h"
typedef spif_const_vectorclass_t *spif_vectorclass_t;
#line 67 "../include/libast/vector_if.h"
struct spif_vectorclass_t_struct {
   spif_const_class_t parent ;
   void *(*contains)() ;
   void *(*count)() ;
   void *(*find)() ;
   void *(*insert)() ;
   void *(*iterator)() ;
   void *(*remove)() ;
   void *(*to_array)() ;
};
#line 34 "../include/libast/dlinked_list.h"
struct spif_dlinked_list_item_t_struct;
#line 34 "../include/libast/dlinked_list.h"
typedef struct spif_dlinked_list_item_t_struct spif_const_dlinked_list_item_t;
#line 34 "../include/libast/dlinked_list.h"
typedef spif_const_dlinked_list_item_t *spif_dlinked_list_item_t;
#line 34 "../include/libast/dlinked_list.h"
struct spif_dlinked_list_item_t_struct {
   spif_obj_t data ;
   spif_dlinked_list_item_t prev ;
   spif_dlinked_list_item_t next ;
};
#line 40
struct spif_dlinked_list_t_struct;
#line 40 "../include/libast/dlinked_list.h"
typedef struct spif_dlinked_list_t_struct spif_const_dlinked_list_t;
#line 40 "../include/libast/dlinked_list.h"
typedef spif_const_dlinked_list_t *spif_dlinked_list_t;
#line 40 "../include/libast/dlinked_list.h"
struct spif_dlinked_list_t_struct {
   spif_const_obj_t parent ;
   spif_listidx_t len ;
   spif_dlinked_list_item_t head ;
   spif_dlinked_list_item_t tail ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
struct spif_dlinked_list_iterator_t_struct;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
typedef struct spif_dlinked_list_iterator_t_struct spif_const_dlinked_list_iterator_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
typedef spif_const_dlinked_list_iterator_t *spif_dlinked_list_iterator_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
struct spif_dlinked_list_iterator_t_struct {
   spif_const_obj_t parent ;
   spif_dlinked_list_t subject ;
   spif_dlinked_list_item_t current ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 431 "../include/libast/types.h"
typedef unsigned char spif_uint8_t;
#line 535 "../include/libast/types.h"
typedef long spif_long_t;
#line 571 "../include/libast/types.h"
typedef unsigned long spif_ulong_t;
#line 589 "../include/libast/types.h"
typedef spif_uint8_t *spif_byteptr_t;
#line 78 "../include/libast/mbuff.h"
typedef spif_int64_t spif_memidx_t;
#line 80
struct spif_mbuff_t_struct;
#line 80 "../include/libast/mbuff.h"
typedef struct spif_mbuff_t_struct spif_const_mbuff_t;
#line 80 "../include/libast/mbuff.h"
typedef spif_const_mbuff_t *spif_mbuff_t;
#line 80 "../include/libast/mbuff.h"
struct spif_mbuff_t_struct {
   spif_const_obj_t parent ;
   spif_byteptr_t buff ;
   spif_memidx_t size ;
   spif_memidx_t len ;
};
#line 87
struct spif_mbuffclass_t_struct;
#line 87 "../include/libast/mbuff.h"
typedef struct spif_mbuffclass_t_struct spif_const_mbuffclass_t;
#line 87 "../include/libast/mbuff.h"
typedef spif_const_mbuffclass_t *spif_mbuffclass_t;
#line 87 "../include/libast/mbuff.h"
struct spif_mbuffclass_t_struct {
   spif_const_class_t parent ;
   void *(*new_from_ptr)() ;
   void *(*new_from_buff)() ;
   void *(*new_from_fp)() ;
   void *(*new_from_fd)() ;
   void *(*init_from_ptr)() ;
   void *(*init_from_buff)() ;
   void *(*init_from_fp)() ;
   void *(*init_from_fd)() ;
   void *(*append)() ;
   void *(*append_from_ptr)() ;
   void *(*clear)() ;
   void *(*cmp)() ;
   void *(*cmp_with_ptr)() ;
   void *(*find)() ;
   void *(*find_from_ptr)() ;
   void *(*index)() ;
   void *(*ncmp)() ;
   void *(*ncmp_with_ptr)() ;
   void *(*prepend)() ;
   void *(*prepend_from_ptr)() ;
   void *(*reverse)() ;
   void *(*rindex)() ;
   void *(*splice)() ;
   void *(*splice_from_ptr)() ;
   void *(*subbuff)() ;
   void *(*subbuff_to_ptr)() ;
   void *(*trim)() ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 449 "../include/libast/types.h"
typedef unsigned short spif_uint16_t;
#line 467 "../include/libast/types.h"
typedef unsigned int spif_uint32_t;
#line 2493 "../include/libast.h"
struct spifopt_t_struct {
   spif_char_t short_opt ;
   spif_charptr_t long_opt ;
   spif_charptr_t desc ;
   spif_uint16_t flags ;
   void *value ;
   spif_uint32_t mask ;
};
#line 2493 "../include/libast.h"
typedef struct spifopt_t_struct spifopt_t;
#line 2552 "../include/libast.h"
struct spifopt_settings_t_struct {
   spifopt_t *opt_list ;
   spif_uint16_t num_opts ;
   spif_uint8_t flags ;
   spif_uint8_t bad_opts ;
   spif_uint8_t allow_bad ;
   spif_uint8_t indent ;
   void (*help_handler)() ;
};
#line 2552 "../include/libast.h"
typedef struct spifopt_settings_t_struct spifopt_settings_t;
#line 33 "../include/libast/array.h"
struct spif_array_t_struct;
#line 33 "../include/libast/array.h"
typedef struct spif_array_t_struct spif_const_array_t;
#line 33 "../include/libast/array.h"
typedef spif_const_array_t *spif_array_t;
#line 33 "../include/libast/array.h"
struct spif_array_t_struct {
   spif_const_obj_t parent ;
   spif_listidx_t len ;
   spif_obj_t *items ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
struct spif_array_iterator_t_struct;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
typedef struct spif_array_iterator_t_struct spif_const_array_iterator_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
typedef spif_const_array_iterator_t *spif_array_iterator_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
struct spif_array_iterator_t_struct {
   spif_const_obj_t parent ;
   spif_array_t subject ;
   spif_listidx_t current_index ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 544 "../include/libast/types.h"
typedef unsigned char spif_uchar_t;
#line 95 "../include/libast/str.h"
struct spif_strclass_t_struct;
#line 95 "../include/libast/str.h"
typedef struct spif_strclass_t_struct spif_const_strclass_t;
#line 95 "../include/libast/str.h"
typedef spif_const_strclass_t *spif_strclass_t;
#line 95 "../include/libast/str.h"
struct spif_strclass_t_struct {
   spif_const_class_t parent ;
   void *(*new_from_ptr)() ;
   void *(*new_from_buff)() ;
   void *(*new_from_fp)() ;
   void *(*new_from_fd)() ;
   void *(*new_from_num)() ;
   void *(*init_from_ptr)() ;
   void *(*init_from_buff)() ;
   void *(*init_from_fp)() ;
   void *(*init_from_fd)() ;
   void *(*init_from_num)() ;
   void *(*append)() ;
   void *(*append_char)() ;
   void *(*append_from_ptr)() ;
   void *(*casecmp)() ;
   void *(*casecmp_with_ptr)() ;
   void *(*clear)() ;
   void *(*cmp)() ;
   void *(*cmp_with_ptr)() ;
   void *(*downcase)() ;
   void *(*find)() ;
   void *(*find_from_ptr)() ;
   void *(*index)() ;
   void *(*ncasecmp)() ;
   void *(*ncasecmp_with_ptr)() ;
   void *(*ncmp)() ;
   void *(*ncmp_with_ptr)() ;
   void *(*prepend)() ;
   void *(*prepend_char)() ;
   void *(*prepend_from_ptr)() ;
   void *(*reverse)() ;
   void *(*rindex)() ;
   void *(*splice)() ;
   void *(*splice_from_ptr)() ;
   void *(*substr)() ;
   void *(*substr_to_ptr)() ;
   void *(*to_float)() ;
   void *(*to_num)() ;
   void *(*trim)() ;
   void *(*upcase)() ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_185 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_185 regmatch_t;
#line 45 "../include/libast/regexp.h"
struct spif_regexp_t_struct;
#line 45 "../include/libast/regexp.h"
typedef struct spif_regexp_t_struct spif_const_regexp_t;
#line 45 "../include/libast/regexp.h"
typedef spif_const_regexp_t *spif_regexp_t;
#line 45 "../include/libast/regexp.h"
struct spif_regexp_t_struct {
   spif_const_str_t parent ;
   spif_ptr_t data ;
   int flags ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 1590 "../include/libast.h"
struct file_state_struct {
   FILE *fp ;
   spif_charptr_t path ;
   spif_charptr_t outfile ;
   spif_uint32_t line ;
   spif_uint8_t flags ;
};
#line 1590 "../include/libast.h"
typedef struct file_state_struct fstate_t;
#line 303 "../include/libast_internal.h"
struct ctx_t_struct {
   spif_charptr_t name ;
   spif_ptr_t (*handler)(spif_charptr_t  , spif_ptr_t  ) ;
};
#line 303 "../include/libast_internal.h"
typedef struct ctx_t_struct ctx_t;
#line 336 "../include/libast_internal.h"
struct ctx_state_t_struct {
   unsigned char ctx_id ;
   void *state ;
};
#line 336 "../include/libast_internal.h"
typedef struct ctx_state_t_struct ctx_state_t;
#line 362 "../include/libast_internal.h"
struct spifconf_func_t_struct {
   spif_charptr_t name ;
   spif_charptr_t (*ptr)(spif_charptr_t  ) ;
};
#line 362 "../include/libast_internal.h"
typedef struct spifconf_func_t_struct spifconf_func_t;
#line 389 "../include/libast_internal.h"
struct spifconf_var_t_struct {
   spif_charptr_t var ;
   spif_charptr_t value ;
   struct spifconf_var_t_struct *next ;
};
#line 389 "../include/libast_internal.h"
typedef struct spifconf_var_t_struct spifconf_var_t;
#line 422 "../include/libast/types.h"
typedef signed char spif_int8_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_un;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 668 "../include/libast/types.h"
typedef struct sockaddr spif_const_sockaddr_t;
#line 668 "../include/libast/types.h"
typedef spif_const_sockaddr_t *spif_sockaddr_t;
#line 679 "../include/libast/types.h"
typedef struct sockaddr_in spif_const_ipsockaddr_t;
#line 679 "../include/libast/types.h"
typedef spif_const_ipsockaddr_t *spif_ipsockaddr_t;
#line 690 "../include/libast/types.h"
typedef struct sockaddr_un spif_const_unixsockaddr_t;
#line 690 "../include/libast/types.h"
typedef spif_const_unixsockaddr_t *spif_unixsockaddr_t;
#line 710 "../include/libast/types.h"
typedef struct hostent spif_const_hostinfo_t;
#line 710 "../include/libast/types.h"
typedef spif_const_hostinfo_t *spif_hostinfo_t;
#line 740 "../include/libast/types.h"
typedef int spif_sockfd_t;
#line 750 "../include/libast/types.h"
typedef int spif_sockfamily_t;
#line 760 "../include/libast/types.h"
typedef int spif_socktype_t;
#line 770 "../include/libast/types.h"
typedef int spif_sockproto_t;
#line 780 "../include/libast/types.h"
typedef spif_uint16_t spif_sockport_t;
#line 790 "../include/libast/types.h"
typedef socklen_t spif_sockaddr_len_t;
#line 71 "../include/libast/socket.h"
struct spif_socket_t_struct;
#line 71 "../include/libast/socket.h"
typedef struct spif_socket_t_struct spif_const_socket_t;
#line 71 "../include/libast/socket.h"
typedef spif_const_socket_t *spif_socket_t;
#line 71 "../include/libast/socket.h"
struct spif_socket_t_struct {
   spif_const_obj_t parent ;
   spif_sockfd_t fd ;
   spif_sockfamily_t fam ;
   spif_socktype_t type ;
   spif_sockproto_t proto ;
   spif_sockaddr_t addr ;
   spif_sockaddr_len_t len ;
   spif_uint32_t flags ;
   spif_url_t local_url ;
   spif_url_t remote_url ;
};
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_77 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_77 XGCValues;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 267
struct _XDisplay;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 88 "../include/libast_internal.h"
struct ptr_t_struct {
   void *ptr ;
   size_t size ;
   spif_char_t file[21] ;
   spif_uint32_t line ;
};
#line 88 "../include/libast_internal.h"
typedef struct ptr_t_struct ptr_t;
#line 108 "../include/libast_internal.h"
struct memrec_t_struct {
   size_t cnt ;
   ptr_t *ptrs ;
};
#line 108 "../include/libast_internal.h"
typedef struct memrec_t_struct memrec_t;
#line 38 "../include/libast/linked_list.h"
struct spif_linked_list_item_t_struct;
#line 38 "../include/libast/linked_list.h"
typedef struct spif_linked_list_item_t_struct spif_const_linked_list_item_t;
#line 38 "../include/libast/linked_list.h"
typedef spif_const_linked_list_item_t *spif_linked_list_item_t;
#line 38 "../include/libast/linked_list.h"
struct spif_linked_list_item_t_struct {
   spif_obj_t data ;
   spif_linked_list_item_t next ;
};
#line 43
struct spif_linked_list_t_struct;
#line 43 "../include/libast/linked_list.h"
typedef struct spif_linked_list_t_struct spif_const_linked_list_t;
#line 43 "../include/libast/linked_list.h"
typedef spif_const_linked_list_t *spif_linked_list_t;
#line 43 "../include/libast/linked_list.h"
struct spif_linked_list_t_struct {
   spif_const_obj_t parent ;
   spif_listidx_t len ;
   spif_linked_list_item_t head ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
struct spif_linked_list_iterator_t_struct;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
typedef struct spif_linked_list_iterator_t_struct spif_const_linked_list_iterator_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
typedef spif_const_linked_list_iterator_t *spif_linked_list_iterator_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
struct spif_linked_list_iterator_t_struct {
   spif_const_obj_t parent ;
   spif_linked_list_t subject ;
   spif_linked_list_item_t current ;
};
#line 2689 "../include/libast.h"
unsigned int libast_debug_level ;
#line 52 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/debug.c"
unsigned int libast_debug_level  =    0U;
#line 62 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/debug.c"
unsigned long libast_debug_flags  =    0UL;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 142 "../include/libast/str.h"
spif_str_t spif_str_new_from_ptr(spif_charptr_t old ) ;
#line 143
spif_str_t spif_str_new_from_buff(spif_charptr_t buff , spif_stridx_t size ) ;
#line 144
spif_str_t spif_str_new_from_fp(FILE *fp ) ;
#line 145
spif_str_t spif_str_new_from_fd(int fd ) ;
#line 147
spif_bool_t spif_str_del(spif_str_t self ) ;
#line 155
spif_str_t spif_str_show(spif_str_t self , spif_charptr_t name___0 , spif_str_t buff ,
                         size_t indent ) ;
#line 157
spif_str_t spif_str_dup(spif_str_t self ) ;
#line 161
spif_bool_t spif_str_append_char(spif_str_t self , spif_char_t c ) ;
#line 162
spif_bool_t spif_str_append_from_ptr(spif_str_t self , spif_charptr_t other ) ;
#line 165
spif_bool_t spif_str_clear(spif_str_t self , spif_char_t c ) ;
#line 166
spif_cmp_t spif_str_cmp(spif_str_t self , spif_str_t other ) ;
#line 187
spif_bool_t spif_str_trim(spif_str_t self ) ;
#line 190
spif_stridx_t spif_str_get_len(spif_str_t self ) ;
#line 753 "../include/libast/obj.h"
spif_bool_t spif_obj_init(spif_obj_t self ) ;
#line 756
spif_bool_t spif_obj_set_class(spif_obj_t self , spif_class_t cls ) ;
#line 61 "../include/libast/tok.h"
spif_class_t spif_tok_class ;
#line 62
spif_tok_t spif_tok_new(void) ;
#line 63
spif_tok_t spif_tok_new_from_ptr(spif_charptr_t old ) ;
#line 64
spif_tok_t spif_tok_new_from_fp(FILE *fp ) ;
#line 65
spif_tok_t spif_tok_new_from_fd(int fd ) ;
#line 66
spif_bool_t spif_tok_del(spif_tok_t self ) ;
#line 67
spif_bool_t spif_tok_init(spif_tok_t self ) ;
#line 68
spif_bool_t spif_tok_init_from_ptr(spif_tok_t self , spif_charptr_t old ) ;
#line 69
spif_bool_t spif_tok_init_from_fp(spif_tok_t self , FILE *fp ) ;
#line 70
spif_bool_t spif_tok_init_from_fd(spif_tok_t self , int fd ) ;
#line 71
spif_bool_t spif_tok_done(spif_tok_t self ) ;
#line 72
spif_bool_t spif_tok_eval(spif_tok_t self ) ;
#line 73
spif_str_t spif_tok_show(spif_tok_t self , spif_charptr_t name___0 , spif_str_t buff ,
                         size_t indent ) ;
#line 74
spif_cmp_t spif_tok_comp(spif_tok_t self , spif_tok_t other ) ;
#line 75
spif_tok_t spif_tok_dup(spif_tok_t self ) ;
#line 76
spif_classname_t spif_tok_type(spif_tok_t self ) ;
#line 77
spif_str_t spif_tok_get_src(spif_tok_t self ) ;
#line 77
spif_bool_t spif_tok_set_src(spif_tok_t self , spif_str_t new_src ) ;
#line 78
spif_char_t spif_tok_get_quote(spif_tok_t self ) ;
#line 78
spif_bool_t spif_tok_set_quote(spif_tok_t self , spif_char_t new_quote ) ;
#line 79
spif_char_t spif_tok_get_dquote(spif_tok_t self ) ;
#line 79
spif_bool_t spif_tok_set_dquote(spif_tok_t self , spif_char_t new_dquote ) ;
#line 80
spif_char_t spif_tok_get_escape(spif_tok_t self ) ;
#line 80
spif_bool_t spif_tok_set_escape(spif_tok_t self , spif_char_t new_escape ) ;
#line 81
spif_str_t spif_tok_get_sep(spif_tok_t self ) ;
#line 81
spif_bool_t spif_tok_set_sep(spif_tok_t self , spif_str_t new_sep ) ;
#line 82
spif_list_t spif_tok_get_tokens(spif_tok_t self ) ;
#line 82
spif_bool_t spif_tok_set_tokens(spif_tok_t self , spif_list_t new_tokens ) ;
#line 47 "../include/libast/dlinked_list.h"
spif_listclass_t spif_dlinked_list_listclass ;
#line 2683 "../include/libast.h"
int libast_dprintf(char const   *format  , ...) ;
#line 2685
void libast_print_warning(char const   *fmt  , ...) ;
#line 2686
void libast_fatal_error(char const   *fmt  , ...) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
static spif_const_class_t t_class  = 
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
     {(spif_charptr_t )"!spif_tok_t!", (void *(*)())(& spif_tok_new), (void *(*)())(& spif_tok_init),
    (void *(*)())(& spif_tok_done), (void *(*)())(& spif_tok_del), (void *(*)())(& spif_tok_show),
    (void *(*)())(& spif_tok_comp), (void *(*)())(& spif_tok_dup), (void *(*)())(& spif_tok_type)};
#line 44 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_class_t spif_tok_class  =    & t_class;
#line 47 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_tok_t spif_tok_new(void) 
{ 
  spif_tok_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 52
  tmp = malloc(sizeof(spif_const_tok_t ));
#line 52
  self = (spif_tok_t )tmp;
#line 53
  tmp___0 = spif_tok_init(self);
  }
#line 53
  if (! tmp___0) {
    {
#line 54
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 54
      free((void *)self);
#line 54
      self = (spif_tok_t )((void *)0);
      }
#line 54
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 55
    self = (spif_tok_t )((void *)0);
  }
#line 57
  return (self);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_tok_t spif_tok_new_from_ptr(spif_charptr_t old ) 
{ 
  spif_tok_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 65
  tmp = malloc(sizeof(spif_const_tok_t ));
#line 65
  self = (spif_tok_t )tmp;
#line 66
  tmp___0 = spif_tok_init_from_ptr(self, old);
  }
#line 66
  if (! tmp___0) {
    {
#line 67
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 67
      free((void *)self);
#line 67
      self = (spif_tok_t )((void *)0);
      }
#line 67
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 68
    self = (spif_tok_t )((void *)0);
  }
#line 70
  return (self);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_tok_t spif_tok_new_from_fp(FILE *fp ) 
{ 
  spif_tok_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 78
  tmp = malloc(sizeof(spif_const_tok_t ));
#line 78
  self = (spif_tok_t )tmp;
#line 79
  tmp___0 = spif_tok_init_from_fp(self, fp);
  }
#line 79
  if (! tmp___0) {
    {
#line 80
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 80
      free((void *)self);
#line 80
      self = (spif_tok_t )((void *)0);
      }
#line 80
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 81
    self = (spif_tok_t )((void *)0);
  }
#line 83
  return (self);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_tok_t spif_tok_new_from_fd(int fd ) 
{ 
  spif_tok_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 91
  tmp = malloc(sizeof(spif_const_tok_t ));
#line 91
  self = (spif_tok_t )tmp;
#line 92
  tmp___0 = spif_tok_init_from_fd(self, fd);
  }
#line 92
  if (! tmp___0) {
    {
#line 93
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 93
      free((void *)self);
#line 93
      self = (spif_tok_t )((void *)0);
      }
#line 93
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 94
    self = (spif_tok_t )((void *)0);
  }
#line 96
  return (self);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_del(spif_tok_t self ) 
{ 
  spif_bool_t t ;

  {
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (! ((unsigned long )self == (unsigned long )((spif_tok_t )((void *)0))))) {
#line 104
      if (libast_debug_level >= 1U) {
        {
#line 104
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                           104, "!SPIF_TOK_ISNULL(self)");
        }
      } else {
        {
#line 104
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                             104, "!SPIF_TOK_ISNULL(self)");
        }
      }
#line 104
      return ((spif_bool_t )0);
    }
#line 104
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  t = spif_tok_done(self);
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 106
    free((void *)self);
#line 106
    self = (spif_tok_t )((void *)0);
    }
#line 106
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  return (t);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_init(spif_tok_t self ) 
{ 
  spif_bool_t tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (! ((unsigned long )self == (unsigned long )((spif_tok_t )((void *)0))))) {
#line 113
      if (libast_debug_level >= 1U) {
        {
#line 113
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                           113, "!SPIF_TOK_ISNULL(self)");
        }
      } else {
        {
#line 113
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                             113, "!SPIF_TOK_ISNULL(self)");
        }
      }
#line 113
      return ((spif_bool_t )0);
    }
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  tmp___0 = spif_obj_init((spif_obj_t )self);
  }
#line 114
  if (tmp___0) {
    {
#line 116
    tmp = spif_obj_set_class((spif_obj_t )self, spif_tok_class);
    }
#line 116
    if (! tmp) {
#line 117
      return ((spif_bool_t )0);
    }
  } else {
#line 115
    return ((spif_bool_t )0);
  }
#line 119
  self->src = (spif_str_t )((void *)0);
#line 120
  self->quote = (spif_char_t )'\'';
#line 121
  self->dquote = (spif_char_t )'\"';
#line 122
  self->escape = (spif_char_t )'\\';
#line 123
  self->tokens = (spif_list_t )((void *)0);
#line 124
  self->sep = (spif_str_t )((void *)0);
#line 125
  return ((spif_bool_t )1);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_init_from_ptr(spif_tok_t self , spif_charptr_t old ) 
{ 
  spif_bool_t tmp ;
  spif_bool_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (! ((unsigned long )self == (unsigned long )((spif_tok_t )((void *)0))))) {
#line 131
      if (libast_debug_level >= 1U) {
        {
#line 131
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_init_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                           131, "!SPIF_TOK_ISNULL(self)");
        }
      } else {
        {
#line 131
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_init_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                             131, "!SPIF_TOK_ISNULL(self)");
        }
      }
#line 131
      return ((spif_bool_t )0);
    }
#line 131
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  tmp___0 = spif_obj_init((spif_obj_t )self);
  }
#line 132
  if (tmp___0) {
    {
#line 134
    tmp = spif_obj_set_class((spif_obj_t )self, spif_tok_class);
    }
#line 134
    if (! tmp) {
#line 135
      return ((spif_bool_t )0);
    }
  } else {
#line 133
    return ((spif_bool_t )0);
  }
  {
#line 137
  self->src = spif_str_new_from_ptr(old);
#line 138
  self->quote = (spif_char_t )'\'';
#line 139
  self->dquote = (spif_char_t )'\"';
#line 140
  self->escape = (spif_char_t )'\\';
#line 141
  self->tokens = (spif_list_t )((void *)0);
#line 142
  self->sep = (spif_str_t )((void *)0);
  }
#line 143
  if ((unsigned long )((spif_obj_t )self->src) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 143
    tmp___1 = 0;
  } else {
#line 143
    tmp___1 = 1;
  }
#line 143
  return ((spif_bool_t )tmp___1);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_init_from_fp(spif_tok_t self , FILE *fp ) 
{ 
  spif_bool_t tmp ;
  spif_bool_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (! ((unsigned long )self == (unsigned long )((spif_tok_t )((void *)0))))) {
#line 149
      if (libast_debug_level >= 1U) {
        {
#line 149
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_init_from_fp",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                           149, "!SPIF_TOK_ISNULL(self)");
        }
      } else {
        {
#line 149
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_init_from_fp",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                             149, "!SPIF_TOK_ISNULL(self)");
        }
      }
#line 149
      return ((spif_bool_t )0);
    }
#line 149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  tmp___0 = spif_obj_init((spif_obj_t )self);
  }
#line 150
  if (tmp___0) {
    {
#line 152
    tmp = spif_obj_set_class((spif_obj_t )self, spif_tok_class);
    }
#line 152
    if (! tmp) {
#line 153
      return ((spif_bool_t )0);
    }
  } else {
#line 151
    return ((spif_bool_t )0);
  }
  {
#line 155
  self->src = spif_str_new_from_fp(fp);
#line 156
  self->quote = (spif_char_t )'\'';
#line 157
  self->dquote = (spif_char_t )'\"';
#line 158
  self->escape = (spif_char_t )'\\';
#line 159
  self->tokens = (spif_list_t )((void *)0);
#line 160
  self->sep = (spif_str_t )((void *)0);
  }
#line 161
  if ((unsigned long )((spif_obj_t )self->src) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 161
    tmp___1 = 0;
  } else {
#line 161
    tmp___1 = 1;
  }
#line 161
  return ((spif_bool_t )tmp___1);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_init_from_fd(spif_tok_t self , int fd ) 
{ 
  spif_bool_t tmp ;
  spif_bool_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (! ((unsigned long )self == (unsigned long )((spif_tok_t )((void *)0))))) {
#line 167
      if (libast_debug_level >= 1U) {
        {
#line 167
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_init_from_fd",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                           167, "!SPIF_TOK_ISNULL(self)");
        }
      } else {
        {
#line 167
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_init_from_fd",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                             167, "!SPIF_TOK_ISNULL(self)");
        }
      }
#line 167
      return ((spif_bool_t )0);
    }
#line 167
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  tmp___0 = spif_obj_init((spif_obj_t )self);
  }
#line 168
  if (tmp___0) {
    {
#line 170
    tmp = spif_obj_set_class((spif_obj_t )self, spif_tok_class);
    }
#line 170
    if (! tmp) {
#line 171
      return ((spif_bool_t )0);
    }
  } else {
#line 169
    return ((spif_bool_t )0);
  }
  {
#line 173
  self->src = spif_str_new_from_fd(fd);
#line 174
  self->quote = (spif_char_t )'\'';
#line 175
  self->dquote = (spif_char_t )'\"';
#line 176
  self->escape = (spif_char_t )'\\';
#line 177
  self->tokens = (spif_list_t )((void *)0);
#line 178
  self->sep = (spif_str_t )((void *)0);
  }
#line 179
  if ((unsigned long )((spif_obj_t )self->src) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 179
    tmp___1 = 0;
  } else {
#line 179
    tmp___1 = 1;
  }
#line 179
  return ((spif_bool_t )tmp___1);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_done(spif_tok_t self ) 
{ 


  {
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (! ((unsigned long )self == (unsigned long )((spif_tok_t )((void *)0))))) {
#line 185
      if (libast_debug_level >= 1U) {
        {
#line 185
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                           185, "!SPIF_TOK_ISNULL(self)");
        }
      } else {
        {
#line 185
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                             185, "!SPIF_TOK_ISNULL(self)");
        }
      }
#line 185
      return ((spif_bool_t )0);
    }
#line 185
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  if (! ((unsigned long )self->tokens == (unsigned long )((spif_list_t )((void *)0)))) {
    {
#line 187
    (*(((self->tokens)->cls)->del))(self->tokens);
#line 188
    self->tokens = (spif_list_t )((void *)0);
    }
  }
#line 190
  if (! ((unsigned long )((spif_obj_t )self->src) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 191
    spif_str_del(self->src);
#line 192
    self->src = (spif_str_t )((void *)0);
    }
  }
#line 194
  if (! ((unsigned long )((spif_obj_t )self->sep) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 195
    spif_str_del(self->sep);
#line 196
    self->sep = (spif_str_t )((void *)0);
    }
  }
#line 198
  self->quote = (spif_char_t )'\'';
#line 199
  self->dquote = (spif_char_t )'\"';
#line 200
  self->escape = (spif_char_t )'\\';
#line 201
  return ((spif_bool_t )1);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_str_t spif_tok_show(spif_tok_t self , spif_charptr_t name___0 , spif_str_t buff ,
                         size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  char *tmp___0 ;

  {
#line 209
  if ((unsigned long )self == (unsigned long )((spif_tok_t )((void *)0))) {
    {
#line 210
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 210
      memset((void *)(tmp), ' ', indent);
      }
#line 210
      if ((char *)name___0) {
#line 210
        tmp___0 = (char *)name___0;
      } else {
#line 210
        tmp___0 = (char *)"<name null>";
      }
      {
#line 210
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_tok_t) %s:  { ((spif_tok_t) NULL) }\n",
               tmp___0);
      }
#line 210
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 210
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 210
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 210
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 211
    return (buff);
  }
  {
#line 214
  memset((void *)(tmp), ' ', indent);
#line 215
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_tok_t) %s:  %10p {\n", name___0,
           (spif_ptr_t )self);
  }
#line 218
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 219
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 221
    spif_str_append_from_ptr(buff, tmp);
    }
  }
  {
#line 223
  buff = spif_str_show(self->src, (spif_charptr_t )"src", buff, indent + 2UL);
#line 224
  buff = spif_str_show(self->sep, (spif_charptr_t )"sep", buff, indent + 2UL);
#line 226
  indent += 2UL;
#line 227
  memset((void *)(tmp), ' ', indent);
#line 228
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_char_t) quote:  \'%c\' (0x%02x)\n",
           (int )((char )self->quote), (unsigned int )self->quote);
#line 230
  spif_str_append_from_ptr(buff, tmp);
#line 231
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_char_t) dquote:  \'%c\' (0x%02x)\n",
           (int )((char )self->dquote), (unsigned int )self->dquote);
#line 233
  spif_str_append_from_ptr(buff, tmp);
#line 234
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_char_t) escape:  \'%c\' (0x%02x)\n",
           (int )((char )self->escape), (unsigned int )self->escape);
#line 236
  spif_str_append_from_ptr(buff, tmp);
#line 238
  (*(((self->tokens)->cls)->show))(self->tokens, "self->tokens", buff, indent);
#line 239
  indent -= 2UL;
#line 241
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"}\n");
#line 242
  spif_str_append_from_ptr(buff, tmp);
  }
#line 243
  return (buff);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_cmp_t spif_tok_comp(spif_tok_t self , spif_tok_t other ) 
{ 
  spif_cmp_t tmp ;

  {
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 249
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 249
        return ((spif_cmp_t )0);
      } else {
#line 249
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 249
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 249
      return ((spif_cmp_t )-1);
    } else
#line 249
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 249
      return ((spif_cmp_t )1);
    }
#line 249
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 250
    if ((unsigned long )((spif_obj_t )self->src) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 250
      if ((unsigned long )((spif_obj_t )other->src) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 250
        return ((spif_cmp_t )0);
      } else {
#line 250
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 250
    if ((unsigned long )((spif_obj_t )self->src) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 250
      return ((spif_cmp_t )-1);
    } else
#line 250
    if ((unsigned long )((spif_obj_t )other->src) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 250
      return ((spif_cmp_t )1);
    }
#line 250
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 251
  tmp = spif_str_cmp(self->src, other->src);
  }
#line 251
  return (tmp);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_tok_t spif_tok_dup(spif_tok_t self ) 
{ 
  spif_tok_t tmp ;
  void *tmp___0 ;

  {
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (! ((unsigned long )self == (unsigned long )((spif_tok_t )((void *)0))))) {
#line 259
      if (libast_debug_level >= 1U) {
        {
#line 259
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                           259, "!SPIF_TOK_ISNULL(self)");
        }
      } else {
        {
#line 259
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                             259, "!SPIF_TOK_ISNULL(self)");
        }
      }
#line 259
      return ((spif_tok_t )((void *)0));
    }
#line 259
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 260
  tmp = spif_tok_new();
#line 261
  tmp->src = spif_str_dup(self->src);
#line 262
  tmp->quote = self->quote;
#line 263
  tmp->dquote = self->dquote;
#line 264
  tmp->escape = self->escape;
#line 265
  tmp___0 = (*(((self->tokens)->cls)->dup))(self->tokens);
#line 265
  tmp->tokens = (spif_obj_t )tmp___0;
#line 266
  tmp->sep = spif_str_dup(self->sep);
  }
#line 268
  return (tmp);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_classname_t spif_tok_type(spif_tok_t self ) 
{ 


  {
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (! ((unsigned long )self == (unsigned long )((spif_tok_t )((void *)0))))) {
#line 274
      if (libast_debug_level >= 1U) {
        {
#line 274
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                           274, "!SPIF_TOK_ISNULL(self)");
        }
      } else {
        {
#line 274
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                             274, "!SPIF_TOK_ISNULL(self)");
        }
      }
#line 274
      return ((spif_classname_t )((void *)0));
    }
#line 274
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_eval(spif_tok_t self ) 
{ 
  char const   *pstr ;
  char const   *delim ;
  spif_str_t tmp ;
  char quote ;
  size_t len ;
  time_t tmp___0 ;
  spif_charptr_t tmp___1 ;
  spif_stridx_t tmp___2 ;
  spif_charptr_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  int tmp___14 ;
  spif_stridx_t tmp___15 ;
  char *tmp___16 ;
  unsigned short const   **tmp___17 ;
  int tmp___18 ;

  {
#line 284
  delim = (char const   *)((void *)0);
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (! ((unsigned long )self == (unsigned long )((spif_tok_t )((void *)0))))) {
#line 289
      if (libast_debug_level >= 1U) {
        {
#line 289
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_eval",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                           289, "!SPIF_TOK_ISNULL(self)");
        }
      } else {
        {
#line 289
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_tok_eval",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                             289, "!SPIF_TOK_ISNULL(self)");
        }
      }
#line 289
      return ((spif_bool_t )0);
    }
#line 289
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 290
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 290
    if (! (! ((unsigned long )((spif_obj_t )self->src) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 290
      if (libast_debug_level >= 1U) {
        {
#line 290
        tmp___0 = time((time_t *)((void *)0));
#line 290
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c",
                290, "spif_tok_eval");
#line 290
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_STR_ISNULL(self->src)");
        }
      }
#line 290
      return ((spif_bool_t )0);
    }
#line 290
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 292
  if ((unsigned long )((spif_obj_t )self->src) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 292
    tmp___1 = (spif_charptr_t )"";
  } else {
#line 292
    tmp___1 = (self->src)->s;
  }
  {
#line 292
  pstr = (char const   *)((spif_charptr_t const   )tmp___1);
#line 293
  tmp___2 = spif_str_get_len(self->src);
#line 293
  len = (size_t )tmp___2;
  }
#line 295
  if (! ((unsigned long )((spif_obj_t )self->sep) == (unsigned long )((spif_obj_t )((void *)0)))) {
#line 296
    if ((unsigned long )((spif_obj_t )self->sep) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 296
      tmp___3 = (spif_charptr_t )"";
    } else {
#line 296
      tmp___3 = (self->sep)->s;
    }
#line 296
    delim = (char const   *)((spif_charptr_t const   )tmp___3);
  }
#line 299
  if (! ((unsigned long )self->tokens == (unsigned long )((spif_list_t )((void *)0)))) {
    {
#line 300
    (*(((self->tokens)->cls)->del))(self->tokens);
    }
  }
  {
#line 302
  tmp___4 = (*(((spif_class_t )spif_dlinked_list_listclass)->noo))();
#line 302
  self->tokens = (spif_list_t )tmp___4;
  }
  {
#line 305
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 305
    if (*pstr) {
#line 305
      if ((unsigned long )delim != (unsigned long )((void *)0)) {
        {
#line 305
        tmp___5 = strchr(delim, (int )*pstr);
#line 305
        tmp___7 = (unsigned long )tmp___5 != (unsigned long )((void *)0);
        }
      } else {
        {
#line 305
        tmp___6 = __ctype_b_loc();
#line 305
        tmp___7 = (int )((int const   )*(*tmp___6 + (int )*pstr) & 8192);
        }
      }
#line 305
      if (! tmp___7) {
#line 305
        goto while_break___1;
      }
    } else {
#line 305
      goto while_break___1;
    }
#line 305
    pstr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 309
  quote = (char)0;
  {
#line 309
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 309
    if (! *pstr) {
#line 309
      goto while_break___2;
    }
    {
#line 310
    tmp = spif_str_new_from_buff((spif_charptr_t )"", (spif_stridx_t )len);
#line 311
    spif_str_clear(tmp, (spif_char_t )0);
    }
    {
#line 314
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 314
      if (*pstr) {
#line 314
        if (! quote) {
#line 314
          if ((unsigned long )delim != (unsigned long )((void *)0)) {
            {
#line 314
            tmp___12 = strchr(delim, (int )*pstr);
#line 314
            tmp___14 = (unsigned long )tmp___12 != (unsigned long )((void *)0);
            }
          } else {
            {
#line 314
            tmp___13 = __ctype_b_loc();
#line 314
            tmp___14 = (int )((int const   )*(*tmp___13 + (int )*pstr) & 8192);
            }
          }
#line 314
          if (tmp___14) {
#line 314
            goto while_break___3;
          }
        }
      } else {
#line 314
        goto while_break___3;
      }
#line 315
      if ((int const   )*pstr == (int const   )self->dquote) {
#line 315
        goto _L;
      } else
#line 315
      if ((int const   )*pstr == (int const   )self->quote) {
        _L: /* CIL Label */ 
#line 317
        if (quote) {
#line 318
          if ((int )quote == (int )*pstr) {
#line 319
            quote = (char)0;
          } else {
            {
#line 322
            spif_str_append_char(tmp, (spif_char_t )*pstr);
            }
          }
        } else {
#line 325
          quote = (char )*pstr;
        }
#line 327
        pstr ++;
      } else {
#line 330
        if ((int const   )*pstr == (int const   )self->escape) {
#line 330
          if ((unsigned long )delim != (unsigned long )((void *)0)) {
            {
#line 330
            tmp___8 = strchr(delim, (int )*(pstr + 1));
#line 330
            tmp___10 = (unsigned long )tmp___8 != (unsigned long )((void *)0);
            }
          } else {
            {
#line 330
            tmp___9 = __ctype_b_loc();
#line 330
            tmp___10 = (int )((int const   )*(*tmp___9 + (int )*(pstr + 1)) & 8192);
            }
          }
#line 330
          if (tmp___10) {
#line 333
            pstr ++;
          } else
#line 330
          if (quote) {
#line 330
            if ((int )quote == (int )*(pstr + 1)) {
#line 333
              pstr ++;
            }
          }
        }
        {
#line 335
        tmp___11 = pstr;
#line 335
        pstr ++;
#line 335
        spif_str_append_char(tmp, (spif_char_t )*tmp___11);
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 340
    spif_str_trim(tmp);
#line 341
    tmp___15 = spif_str_get_len(tmp);
#line 341
    len -= (size_t )tmp___15;
#line 344
    (*(((spif_listclass_t )(self->tokens)->cls)->append))(self->tokens, tmp);
    }
    {
#line 347
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 347
      if (*pstr) {
#line 347
        if ((unsigned long )delim != (unsigned long )((void *)0)) {
          {
#line 347
          tmp___16 = strchr(delim, (int )*pstr);
#line 347
          tmp___18 = (unsigned long )tmp___16 != (unsigned long )((void *)0);
          }
        } else {
          {
#line 347
          tmp___17 = __ctype_b_loc();
#line 347
          tmp___18 = (int )((int const   )*(*tmp___17 + (int )*pstr) & 8192);
          }
        }
#line 347
        if (! tmp___18) {
#line 347
          goto while_break___4;
        }
      } else {
#line 347
        goto while_break___4;
      }
#line 347
      pstr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 349
  return ((spif_bool_t )1);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_str_t spif_tok_get_src(spif_tok_t self ) 
{ 


  {
#line 352
  return (self->src);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_set_src(spif_tok_t self , spif_str_t new_src ) 
{ 


  {
#line 352
  if (! ((unsigned long )((spif_obj_t )self->src) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 352
    (*((((spif_obj_t )self->src)->cls)->del))(self->src);
    }
  }
#line 352
  self->src = new_src;
#line 352
  return ((spif_bool_t )1);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_char_t spif_tok_get_quote(spif_tok_t self ) 
{ 


  {
#line 353
  return (self->quote);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_set_quote(spif_tok_t self , spif_char_t new_quote ) 
{ 


  {
#line 353
  self->quote = new_quote;
#line 353
  return ((spif_bool_t )1);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_char_t spif_tok_get_dquote(spif_tok_t self ) 
{ 


  {
#line 354
  return (self->dquote);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_set_dquote(spif_tok_t self , spif_char_t new_dquote ) 
{ 


  {
#line 354
  self->dquote = new_dquote;
#line 354
  return ((spif_bool_t )1);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_char_t spif_tok_get_escape(spif_tok_t self ) 
{ 


  {
#line 355
  return (self->escape);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_set_escape(spif_tok_t self , spif_char_t new_escape ) 
{ 


  {
#line 355
  self->escape = new_escape;
#line 355
  return ((spif_bool_t )1);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_str_t spif_tok_get_sep(spif_tok_t self ) 
{ 


  {
#line 356
  return (self->sep);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_set_sep(spif_tok_t self , spif_str_t new_sep ) 
{ 


  {
#line 356
  if (! ((unsigned long )((spif_obj_t )self->sep) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 356
    (*((((spif_obj_t )self->sep)->cls)->del))(self->sep);
    }
  }
#line 356
  self->sep = new_sep;
#line 356
  return ((spif_bool_t )1);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_list_t spif_tok_get_tokens(spif_tok_t self ) 
{ 


  {
#line 357
  return (self->tokens);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/tok.c"
spif_bool_t spif_tok_set_tokens(spif_tok_t self , spif_list_t new_tokens ) 
{ 


  {
#line 357
  if (! ((unsigned long )self->tokens == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 357
    (*(((self->tokens)->cls)->del))(self->tokens);
    }
  }
#line 357
  self->tokens = new_tokens;
#line 357
  return ((spif_bool_t )1);
}
}
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 290 "/usr/include/netdb.h"
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 357
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 148 "../include/libast/str.h"
spif_bool_t spif_str_init(spif_str_t self ) ;
#line 149
spif_bool_t spif_str_init_from_ptr(spif_str_t self , spif_charptr_t old ) ;
#line 154
spif_bool_t spif_str_done(spif_str_t self ) ;
#line 156
spif_cmp_t spif_str_comp(spif_str_t self , spif_str_t other ) ;
#line 160
spif_bool_t spif_str_append(spif_str_t self , spif_str_t other ) ;
#line 58 "../include/libast/url.h"
spif_class_t spif_url_class ;
#line 59
spif_url_t spif_url_new(void) ;
#line 60
spif_url_t spif_url_new_from_str(spif_str_t other ) ;
#line 61
spif_url_t spif_url_new_from_ptr(spif_charptr_t other ) ;
#line 62
spif_bool_t spif_url_del(spif_url_t self ) ;
#line 63
spif_bool_t spif_url_init(spif_url_t self ) ;
#line 64
spif_bool_t spif_url_init_from_str(spif_url_t self , spif_str_t other ) ;
#line 65
spif_bool_t spif_url_init_from_ptr(spif_url_t self , spif_charptr_t other ) ;
#line 66
spif_bool_t spif_url_done(spif_url_t self ) ;
#line 67
spif_str_t spif_url_show(spif_url_t self , spif_charptr_t name___0 , spif_str_t buff ,
                         size_t indent ) ;
#line 68
spif_cmp_t spif_url_comp(spif_url_t self , spif_url_t other ) ;
#line 69
spif_url_t spif_url_dup(spif_url_t self ) ;
#line 70
spif_classname_t spif_url_type(spif_url_t self ) ;
#line 71
spif_str_t spif_url_get_proto(spif_url_t self ) ;
#line 71
spif_bool_t spif_url_set_proto(spif_url_t self , spif_str_t new_proto ) ;
#line 72
spif_str_t spif_url_get_user(spif_url_t self ) ;
#line 72
spif_bool_t spif_url_set_user(spif_url_t self , spif_str_t new_user ) ;
#line 73
spif_str_t spif_url_get_passwd(spif_url_t self ) ;
#line 73
spif_bool_t spif_url_set_passwd(spif_url_t self , spif_str_t new_passwd ) ;
#line 74
spif_str_t spif_url_get_host(spif_url_t self ) ;
#line 74
spif_bool_t spif_url_set_host(spif_url_t self , spif_str_t new_host ) ;
#line 75
spif_str_t spif_url_get_port(spif_url_t self ) ;
#line 75
spif_bool_t spif_url_set_port(spif_url_t self , spif_str_t new_port ) ;
#line 76
spif_str_t spif_url_get_path(spif_url_t self ) ;
#line 76
spif_bool_t spif_url_set_path(spif_url_t self , spif_str_t new_path ) ;
#line 77
spif_str_t spif_url_get_query(spif_url_t self ) ;
#line 77
spif_bool_t spif_url_set_query(spif_url_t self , spif_str_t new_query ) ;
#line 78
spif_bool_t spif_url_unparse(spif_url_t self ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
static spif_const_class_t u_class  = 
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
     {(spif_charptr_t )"!spif_url_t!", (void *(*)())(& spif_url_new), (void *(*)())(& spif_url_init),
    (void *(*)())(& spif_url_done), (void *(*)())(& spif_url_del), (void *(*)())(& spif_url_show),
    (void *(*)())(& spif_url_comp), (void *(*)())(& spif_url_dup), (void *(*)())(& spif_url_type)};
#line 44 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_class_t spif_url_class  =    & u_class;
#line 47
static spif_bool_t spif_url_parse(spif_url_t self ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_url_t spif_url_new(void) 
{ 
  spif_url_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 54
  tmp = malloc(sizeof(spif_const_url_t ));
#line 54
  self = (spif_url_t )tmp;
#line 55
  tmp___0 = spif_url_init(self);
  }
#line 55
  if (! tmp___0) {
    {
#line 56
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 56
      free((void *)self);
#line 56
      self = (spif_url_t )((void *)0);
      }
#line 56
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 57
    self = (spif_url_t )((void *)0);
  }
#line 59
  return (self);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_url_t spif_url_new_from_str(spif_str_t other ) 
{ 
  spif_url_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 67
  tmp = malloc(sizeof(spif_const_url_t ));
#line 67
  self = (spif_url_t )tmp;
#line 68
  tmp___0 = spif_url_init_from_str(self, other);
  }
#line 68
  if (! tmp___0) {
    {
#line 69
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 69
      free((void *)self);
#line 69
      self = (spif_url_t )((void *)0);
      }
#line 69
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 70
    self = (spif_url_t )((void *)0);
  }
#line 72
  return (self);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_url_t spif_url_new_from_ptr(spif_charptr_t other ) 
{ 
  spif_url_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 80
  tmp = malloc(sizeof(spif_const_url_t ));
#line 80
  self = (spif_url_t )tmp;
#line 81
  tmp___0 = spif_url_init_from_ptr(self, other);
  }
#line 81
  if (! tmp___0) {
    {
#line 82
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 82
      free((void *)self);
#line 82
      self = (spif_url_t )((void *)0);
      }
#line 82
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 83
    self = (spif_url_t )((void *)0);
  }
#line 85
  return (self);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_init(spif_url_t self ) 
{ 
  spif_bool_t tmp ;

  {
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 91
      if (libast_debug_level >= 1U) {
        {
#line 91
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                           91, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 91
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                             91, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 91
      return ((spif_bool_t )0);
    }
#line 91
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  tmp = spif_str_init((spif_str_t )self);
  }
#line 92
  if (! tmp) {
#line 93
    return ((spif_bool_t )0);
  }
  {
#line 95
  spif_obj_set_class((spif_obj_t )self, spif_url_class);
#line 96
  self->proto = (spif_str_t )((void *)0);
#line 97
  self->user = (spif_str_t )((void *)0);
#line 98
  self->passwd = (spif_str_t )((void *)0);
#line 99
  self->host = (spif_str_t )((void *)0);
#line 100
  self->port = (spif_str_t )((void *)0);
#line 101
  self->path = (spif_str_t )((void *)0);
#line 102
  self->query = (spif_str_t )((void *)0);
  }
#line 103
  return ((spif_bool_t )1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_init_from_str(spif_url_t self , spif_str_t other ) 
{ 
  spif_charptr_t tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 109
      if (libast_debug_level >= 1U) {
        {
#line 109
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_init_from_str",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                           109, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 109
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_init_from_str",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                             109, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 109
      return ((spif_bool_t )0);
    }
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 110
    tmp = (spif_charptr_t )"";
  } else {
#line 110
    tmp = other->s;
  }
  {
#line 110
  tmp___0 = spif_str_init_from_ptr((spif_str_t )self, (spif_charptr_t )((spif_charptr_t const   )tmp));
  }
#line 110
  if (! tmp___0) {
#line 111
    return ((spif_bool_t )0);
  }
  {
#line 113
  spif_obj_set_class((spif_obj_t )self, spif_url_class);
#line 114
  self->proto = (spif_str_t )((void *)0);
#line 115
  self->user = (spif_str_t )((void *)0);
#line 116
  self->passwd = (spif_str_t )((void *)0);
#line 117
  self->host = (spif_str_t )((void *)0);
#line 118
  self->port = (spif_str_t )((void *)0);
#line 119
  self->path = (spif_str_t )((void *)0);
#line 120
  self->query = (spif_str_t )((void *)0);
#line 121
  spif_url_parse(self);
  }
#line 122
  return ((spif_bool_t )1);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_init_from_ptr(spif_url_t self , spif_charptr_t other ) 
{ 
  spif_bool_t tmp ;

  {
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 128
      if (libast_debug_level >= 1U) {
        {
#line 128
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_init_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                           128, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 128
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_init_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                             128, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 128
      return ((spif_bool_t )0);
    }
#line 128
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 129
  tmp = spif_str_init_from_ptr((spif_str_t )self, other);
  }
#line 129
  if (! tmp) {
#line 130
    return ((spif_bool_t )0);
  }
  {
#line 132
  spif_obj_set_class((spif_obj_t )self, spif_url_class);
#line 133
  self->proto = (spif_str_t )((void *)0);
#line 134
  self->user = (spif_str_t )((void *)0);
#line 135
  self->passwd = (spif_str_t )((void *)0);
#line 136
  self->host = (spif_str_t )((void *)0);
#line 137
  self->port = (spif_str_t )((void *)0);
#line 138
  self->path = (spif_str_t )((void *)0);
#line 139
  self->query = (spif_str_t )((void *)0);
#line 140
  spif_url_parse(self);
  }
#line 141
  return ((spif_bool_t )1);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_done(spif_url_t self ) 
{ 


  {
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 147
      if (libast_debug_level >= 1U) {
        {
#line 147
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                           147, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 147
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                             147, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 147
      return ((spif_bool_t )0);
    }
#line 147
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  if (! ((unsigned long )((spif_obj_t )self->proto) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 149
    spif_str_del(self->proto);
#line 150
    self->proto = (spif_str_t )((void *)0);
    }
  }
#line 152
  if (! ((unsigned long )((spif_obj_t )self->user) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 153
    spif_str_del(self->user);
#line 154
    self->user = (spif_str_t )((void *)0);
    }
  }
#line 156
  if (! ((unsigned long )((spif_obj_t )self->passwd) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 157
    spif_str_del(self->passwd);
#line 158
    self->passwd = (spif_str_t )((void *)0);
    }
  }
#line 160
  if (! ((unsigned long )((spif_obj_t )self->host) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 161
    spif_str_del(self->host);
#line 162
    self->host = (spif_str_t )((void *)0);
    }
  }
#line 164
  if (! ((unsigned long )((spif_obj_t )self->port) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 165
    spif_str_del(self->port);
#line 166
    self->port = (spif_str_t )((void *)0);
    }
  }
#line 168
  if (! ((unsigned long )((spif_obj_t )self->path) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 169
    spif_str_del(self->path);
#line 170
    self->path = (spif_str_t )((void *)0);
    }
  }
#line 172
  if (! ((unsigned long )((spif_obj_t )self->query) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 173
    spif_str_del(self->query);
#line 174
    self->query = (spif_str_t )((void *)0);
    }
  }
  {
#line 176
  spif_str_done((spif_str_t )self);
  }
#line 177
  return ((spif_bool_t )1);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_del(spif_url_t self ) 
{ 


  {
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 183
      if (libast_debug_level >= 1U) {
        {
#line 183
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                           183, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 183
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                             183, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 183
      return ((spif_bool_t )0);
    }
#line 183
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  spif_url_done(self);
  }
  {
#line 185
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 185
    free((void *)self);
#line 185
    self = (spif_url_t )((void *)0);
    }
#line 185
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 186
  return ((spif_bool_t )1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_str_t spif_url_show(spif_url_t self , spif_charptr_t name___0 , spif_str_t buff ,
                         size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  char *tmp___0 ;

  {
#line 194
  if ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))) {
    {
#line 195
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 195
      memset((void *)(tmp), ' ', indent);
      }
#line 195
      if ((char *)name___0) {
#line 195
        tmp___0 = (char *)name___0;
      } else {
#line 195
        tmp___0 = (char *)"<name null>";
      }
      {
#line 195
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_url_t) %s:  { ((spif_url_t) NULL) }\n",
               tmp___0);
      }
#line 195
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 195
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 195
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 195
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 196
    return (buff);
  }
  {
#line 199
  memset((void *)(tmp), ' ', indent);
#line 200
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_url_t) %s:  %10p {\n", name___0,
           (spif_ptr_t )self);
  }
#line 203
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 204
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 206
    spif_str_append_from_ptr(buff, tmp);
    }
  }
  {
#line 209
  buff = spif_str_show(self->proto, (spif_charptr_t )"proto", buff, indent + 2UL);
#line 210
  buff = spif_str_show(self->user, (spif_charptr_t )"user", buff, indent + 2UL);
#line 211
  buff = spif_str_show(self->passwd, (spif_charptr_t )"passwd", buff, indent + 2UL);
#line 212
  buff = spif_str_show(self->host, (spif_charptr_t )"host", buff, indent + 2UL);
#line 213
  buff = spif_str_show(self->port, (spif_charptr_t )"port", buff, indent + 2UL);
#line 214
  buff = spif_str_show(self->path, (spif_charptr_t )"path", buff, indent + 2UL);
#line 215
  buff = spif_str_show(self->query, (spif_charptr_t )"query", buff, indent + 2UL);
#line 217
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"}\n");
#line 218
  spif_str_append_from_ptr(buff, tmp);
  }
#line 219
  return (buff);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_cmp_t spif_url_comp(spif_url_t self , spif_url_t other ) 
{ 
  spif_cmp_t tmp ;

  {
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 225
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 225
        return ((spif_cmp_t )0);
      } else {
#line 225
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 225
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 225
      return ((spif_cmp_t )-1);
    } else
#line 225
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 225
      return ((spif_cmp_t )1);
    }
#line 225
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 226
  tmp = spif_str_comp((spif_str_t )self, (spif_str_t )other);
  }
#line 226
  return (tmp);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_url_t spif_url_dup(spif_url_t self ) 
{ 
  spif_url_t tmp ;

  {
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 234
      if (libast_debug_level >= 1U) {
        {
#line 234
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                           234, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 234
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                             234, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 234
      return ((spif_url_t )((void *)0));
    }
#line 234
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 235
  tmp = spif_url_new_from_str((spif_str_t )self);
  }
#line 236
  return (tmp);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_classname_t spif_url_type(spif_url_t self ) 
{ 


  {
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 242
      if (libast_debug_level >= 1U) {
        {
#line 242
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                           242, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 242
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                             242, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 242
      return ((spif_classname_t )((void *)0));
    }
#line 242
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_str_t spif_url_get_proto(spif_url_t self ) 
{ 


  {
#line 246
  return (self->proto);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_set_proto(spif_url_t self , spif_str_t new_proto ) 
{ 


  {
#line 246
  if (! ((unsigned long )((spif_obj_t )self->proto) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 246
    (*((((spif_obj_t )self->proto)->cls)->del))(self->proto);
    }
  }
#line 246
  self->proto = new_proto;
#line 246
  return ((spif_bool_t )1);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_str_t spif_url_get_user(spif_url_t self ) 
{ 


  {
#line 247
  return (self->user);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_set_user(spif_url_t self , spif_str_t new_user ) 
{ 


  {
#line 247
  if (! ((unsigned long )((spif_obj_t )self->user) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 247
    (*((((spif_obj_t )self->user)->cls)->del))(self->user);
    }
  }
#line 247
  self->user = new_user;
#line 247
  return ((spif_bool_t )1);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_str_t spif_url_get_passwd(spif_url_t self ) 
{ 


  {
#line 248
  return (self->passwd);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_set_passwd(spif_url_t self , spif_str_t new_passwd ) 
{ 


  {
#line 248
  if (! ((unsigned long )((spif_obj_t )self->passwd) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 248
    (*((((spif_obj_t )self->passwd)->cls)->del))(self->passwd);
    }
  }
#line 248
  self->passwd = new_passwd;
#line 248
  return ((spif_bool_t )1);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_str_t spif_url_get_host(spif_url_t self ) 
{ 


  {
#line 249
  return (self->host);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_set_host(spif_url_t self , spif_str_t new_host ) 
{ 


  {
#line 249
  if (! ((unsigned long )((spif_obj_t )self->host) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 249
    (*((((spif_obj_t )self->host)->cls)->del))(self->host);
    }
  }
#line 249
  self->host = new_host;
#line 249
  return ((spif_bool_t )1);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_str_t spif_url_get_port(spif_url_t self ) 
{ 


  {
#line 250
  return (self->port);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_set_port(spif_url_t self , spif_str_t new_port ) 
{ 


  {
#line 250
  if (! ((unsigned long )((spif_obj_t )self->port) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 250
    (*((((spif_obj_t )self->port)->cls)->del))(self->port);
    }
  }
#line 250
  self->port = new_port;
#line 250
  return ((spif_bool_t )1);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_str_t spif_url_get_path(spif_url_t self ) 
{ 


  {
#line 251
  return (self->path);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_set_path(spif_url_t self , spif_str_t new_path ) 
{ 


  {
#line 251
  if (! ((unsigned long )((spif_obj_t )self->path) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 251
    (*((((spif_obj_t )self->path)->cls)->del))(self->path);
    }
  }
#line 251
  self->path = new_path;
#line 251
  return ((spif_bool_t )1);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_str_t spif_url_get_query(spif_url_t self ) 
{ 


  {
#line 252
  return (self->query);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_set_query(spif_url_t self , spif_str_t new_query ) 
{ 


  {
#line 252
  if (! ((unsigned long )((spif_obj_t )self->query) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 252
    (*((((spif_obj_t )self->query)->cls)->del))(self->query);
    }
  }
#line 252
  self->query = new_query;
#line 252
  return ((spif_bool_t )1);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
static spif_bool_t spif_url_parse(spif_url_t self ) 
{ 
  spif_charptr_t s ;
  spif_charptr_t tmp ;
  spif_charptr_t pstr ;
  spif_charptr_t pend ;
  spif_charptr_t ptmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  spif_charptr_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  spif_charptr_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  spif_protoinfo_t proto ;
  spif_servinfo_t serv ;
  spif_charptr_t tmp___10 ;
  spif_charptr_t tmp___11 ;
  spif_charptr_t tmp___12 ;
  time_t tmp___13 ;
  spif_char_t buff[32] ;
  uint16_t tmp___14 ;

  {
#line 257
  if ((unsigned long )((spif_obj_t )((spif_str_t )self)) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 257
    tmp = (spif_charptr_t )"";
  } else {
#line 257
    tmp = ((spif_str_t )self)->s;
  }
#line 257
  s = (spif_charptr_t )((spif_charptr_t const   )tmp);
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 260
      if (libast_debug_level >= 1U) {
        {
#line 260
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_parse",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                           260, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 260
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_parse",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                             260, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 260
      return ((spif_bool_t )0);
    }
#line 260
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  pstr = s;
#line 264
  tmp___0 = strchr((char const   *)((char *)s), ':');
#line 264
  pend = (spif_charptr_t )tmp___0;
  }
#line 265
  if ((unsigned long )pend != (unsigned long )((void *)0)) {
    {
#line 266
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 266
      if (! ((unsigned long )pstr < (unsigned long )pend)) {
#line 266
        goto while_break___0;
      }
      {
#line 267
      tmp___1 = __ctype_b_loc();
      }
#line 267
      if (! ((int const   )*(*tmp___1 + (int )*pstr) & 8)) {
#line 268
        goto while_break___0;
      }
#line 266
      pstr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 271
    if ((unsigned long )pstr == (unsigned long )pend) {
      {
#line 273
      self->proto = spif_str_new_from_buff(s, pend - s);
#line 274
      pstr ++;
      }
    } else {
#line 277
      pstr = s;
    }
  }
#line 281
  if ((int )*pstr == 47) {
#line 281
    if ((int )*(pstr + 1) == 47) {
#line 282
      pstr += 2;
    }
  }
  {
#line 286
  tmp___2 = strchr((char const   *)((char *)pstr), '/');
#line 286
  pend = (spif_charptr_t )tmp___2;
  }
#line 287
  if ((unsigned long )pend != (unsigned long )((void *)0)) {
    {
#line 288
    tmp___4 = strchr((char const   *)((char *)pend), '?');
#line 288
    tmp___3 = (spif_charptr_t )tmp___4;
    }
#line 290
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
      {
#line 291
      self->query = spif_str_new_from_ptr(tmp___3 + 1);
#line 292
      self->path = spif_str_new_from_buff(pend, tmp___3 - pend);
      }
    } else {
      {
#line 294
      self->path = spif_str_new_from_ptr(pend);
      }
    }
  } else {
    {
#line 296
    tmp___5 = strchr((char const   *)((char *)pstr), '?');
#line 296
    pend = (spif_charptr_t )tmp___5;
    }
#line 296
    if ((unsigned long )pend != (unsigned long )((void *)0)) {
      {
#line 297
      self->query = spif_str_new_from_ptr(pend + 1);
      }
    } else {
#line 299
      pend = pstr;
      {
#line 299
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 299
        if (! *pend) {
#line 299
          goto while_break___1;
        }
#line 299
        pend ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  {
#line 304
  tmp___6 = strchr((char const   *)((char *)pstr), '@');
#line 304
  ptmp = (spif_charptr_t )tmp___6;
  }
#line 305
  if ((unsigned long )ptmp != (unsigned long )((void *)0)) {
#line 305
    if ((unsigned long )ptmp < (unsigned long )pend) {
      {
#line 306
      tmp___8 = strchr((char const   *)((char *)pstr), ':');
#line 306
      tmp___7 = (spif_charptr_t )tmp___8;
      }
#line 308
      if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 308
        if ((unsigned long )tmp___7 < (unsigned long )ptmp) {
          {
#line 310
          self->user = spif_str_new_from_buff(pstr, tmp___7 - pstr);
#line 311
          self->passwd = spif_str_new_from_buff(tmp___7 + 1, (ptmp - tmp___7) - 1L);
          }
        } else {
          {
#line 313
          self->user = spif_str_new_from_buff(pstr, ptmp - pstr);
          }
        }
      } else {
        {
#line 313
        self->user = spif_str_new_from_buff(pstr, ptmp - pstr);
        }
      }
#line 315
      pstr = ptmp + 1;
    }
  }
  {
#line 319
  tmp___9 = strchr((char const   *)((char *)pstr), ':');
#line 319
  ptmp = (spif_charptr_t )tmp___9;
  }
#line 320
  if ((unsigned long )ptmp != (unsigned long )((void *)0)) {
#line 320
    if ((unsigned long )ptmp < (unsigned long )pend) {
      {
#line 321
      self->host = spif_str_new_from_buff(pstr, ptmp - pstr);
#line 322
      self->port = spif_str_new_from_buff(ptmp + 1, (pend - ptmp) - 1L);
      }
    } else {
#line 320
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 323
  if ((unsigned long )pstr != (unsigned long )pend) {
    {
#line 324
    self->host = spif_str_new_from_buff(pstr, pend - pstr);
    }
  }
#line 328
  if ((unsigned long )((spif_obj_t )self->port) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 328
    if (! ((unsigned long )((spif_obj_t )self->proto) == (unsigned long )((spif_obj_t )((void *)0)))) {
#line 332
      if ((unsigned long )((spif_obj_t )self->proto) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 332
        tmp___10 = (spif_charptr_t )"";
      } else {
#line 332
        tmp___10 = (self->proto)->s;
      }
      {
#line 332
      proto = getprotobyname((char const   *)((char *)((spif_charptr_t const   )tmp___10)));
      }
#line 333
      if ((unsigned long )proto == (unsigned long )((void *)0)) {
#line 335
        if ((unsigned long )((spif_obj_t )self->proto) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 335
          tmp___11 = (spif_charptr_t )"";
        } else {
#line 335
          tmp___11 = (self->proto)->s;
        }
        {
#line 335
        serv = getservbyname((char const   *)((char *)((spif_charptr_t const   )tmp___11)),
                             "tcp");
        }
#line 336
        if ((unsigned long )serv == (unsigned long )((void *)0)) {
#line 337
          if ((unsigned long )((spif_obj_t )self->proto) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 337
            tmp___12 = (spif_charptr_t )"";
          } else {
#line 337
            tmp___12 = (self->proto)->s;
          }
          {
#line 337
          serv = getservbyname((char const   *)((char *)((spif_charptr_t const   )tmp___12)),
                               "udp");
          }
        }
#line 339
        if ((unsigned long )serv != (unsigned long )((void *)0)) {
          {
#line 340
          proto = getprotobyname((char const   *)serv->s_proto);
          }
          {
#line 341
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 341
            if (! ((unsigned long )proto != (unsigned long )((void *)0))) {
#line 341
              if (libast_debug_level >= 1U) {
                {
#line 341
                tmp___13 = time((time_t *)((void *)0));
#line 341
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                        (unsigned long )tmp___13, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                        341, "spif_url_parse");
#line 341
                libast_dprintf("REQUIRE failed:  %s\n", "proto != NULL");
                }
              }
#line 341
              return ((spif_bool_t )0);
            }
#line 341
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 344
      if ((unsigned long )proto != (unsigned long )((void *)0)) {
        {
#line 347
        tmp___14 = ntohs((uint16_t )serv->s_port);
#line 347
        snprintf((char */* __restrict  */)((char *)(buff)), sizeof(buff), (char const   */* __restrict  */)"%d",
                 (int )tmp___14);
#line 348
        self->port = spif_str_new_from_ptr(buff);
        }
      }
    }
  }
#line 352
  return ((spif_bool_t )1);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c"
spif_bool_t spif_url_unparse(spif_url_t self ) 
{ 


  {
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 358
      if (libast_debug_level >= 1U) {
        {
#line 358
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_unparse",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                           358, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 358
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_unparse",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/url.c",
                             358, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 358
      return ((spif_bool_t )0);
    }
#line 358
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 359
  spif_str_done((spif_str_t )self);
#line 360
  spif_str_init_from_ptr((spif_str_t )self, (spif_charptr_t )"");
  }
#line 363
  if (! ((unsigned long )((spif_obj_t )self->proto) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 364
    spif_str_append((spif_str_t )self, self->proto);
#line 365
    spif_str_append_char((spif_str_t )self, (spif_char_t )':');
    }
  }
#line 369
  if (! ((unsigned long )((spif_obj_t )self->port) == (unsigned long )((spif_obj_t )((void *)0)))) {
#line 369
    if ((unsigned long )((spif_obj_t )self->host) == (unsigned long )((spif_obj_t )((void *)0))) {
      {
#line 370
      self->host = spif_str_new_from_ptr((spif_charptr_t )"localhost");
      }
    }
  }
#line 374
  if (! ((unsigned long )((spif_obj_t )self->host) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 375
    spif_str_append_from_ptr((spif_str_t )self, (spif_charptr_t )"//");
    }
  }
#line 378
  if (! ((unsigned long )((spif_obj_t )self->user) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 379
    spif_str_append((spif_str_t )self, self->user);
    }
#line 380
    if (! ((unsigned long )((spif_obj_t )self->passwd) == (unsigned long )((spif_obj_t )((void *)0)))) {
      {
#line 381
      spif_str_append_char((spif_str_t )self, (spif_char_t )':');
#line 382
      spif_str_append((spif_str_t )self, self->passwd);
      }
    }
    {
#line 384
    spif_str_append_char((spif_str_t )self, (spif_char_t )'@');
    }
  }
#line 387
  if (! ((unsigned long )((spif_obj_t )self->host) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 388
    spif_str_append((spif_str_t )self, self->host);
    }
#line 389
    if (! ((unsigned long )((spif_obj_t )self->port) == (unsigned long )((spif_obj_t )((void *)0)))) {
      {
#line 390
      spif_str_append_char((spif_str_t )self, (spif_char_t )':');
#line 391
      spif_str_append((spif_str_t )self, self->port);
      }
    }
  }
#line 395
  if (! ((unsigned long )((spif_obj_t )self->path) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 396
    spif_str_append((spif_str_t )self, self->path);
    }
  }
#line 399
  if (! ((unsigned long )((spif_obj_t )self->query) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 400
    spif_str_append_char((spif_str_t )self, (spif_char_t )'?');
#line 401
    spif_str_append((spif_str_t )self, self->query);
    }
  }
#line 403
  return ((spif_bool_t )1);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 758 "../include/libast/obj.h"
spif_cmp_t spif_obj_comp(spif_obj_t self , spif_obj_t other ) ;
#line 222 "../include/libast/objpair.h"
spif_class_t spif_objpair_class ;
#line 226
spif_objpair_t spif_objpair_new_from_both(spif_obj_t key , spif_obj_t value ) ;
#line 238
spif_bool_t spif_objpair_set_value(spif_objpair_t self , spif_obj_t new_value ) ;
#line 49 "../include/libast/linked_list.h"
spif_listclass_t spif_linked_list_listclass ;
#line 48 "../include/libast/dlinked_list.h"
spif_vectorclass_t spif_dlinked_list_vectorclass ;
#line 49
spif_mapclass_t spif_dlinked_list_mapclass ;
#line 40 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_dlinked_list_item_t spif_dlinked_list_item_new(void) ;
#line 41
static spif_bool_t spif_dlinked_list_item_init(spif_dlinked_list_item_t self ) ;
#line 42
static spif_bool_t spif_dlinked_list_item_done(spif_dlinked_list_item_t self ) ;
#line 43
static spif_bool_t spif_dlinked_list_item_del(spif_dlinked_list_item_t self ) ;
#line 44
static spif_str_t spif_dlinked_list_item_show(spif_dlinked_list_item_t self , spif_charptr_t name___0 ,
                                              spif_str_t buff , size_t indent ) ;
#line 45
static spif_cmp_t spif_dlinked_list_item_comp(spif_dlinked_list_item_t self , spif_dlinked_list_item_t other ) ;
#line 46
static spif_dlinked_list_item_t spif_dlinked_list_item_dup(spif_dlinked_list_item_t self ) ;
#line 47
static spif_classname_t spif_dlinked_list_item_type(spif_dlinked_list_item_t self ) ;
#line 48
spif_obj_t spif_dlinked_list_item_get_data(spif_dlinked_list_item_t self ) ;
#line 48
spif_bool_t spif_dlinked_list_item_set_data(spif_dlinked_list_item_t self , spif_obj_t new_data ) ;
#line 49
spif_dlinked_list_item_t spif_dlinked_list_item_get_prev(spif_dlinked_list_item_t self ) ;
#line 49
spif_bool_t spif_dlinked_list_item_set_prev(spif_dlinked_list_item_t self , spif_dlinked_list_item_t new_prev ) ;
#line 50
spif_dlinked_list_item_t spif_dlinked_list_item_get_next(spif_dlinked_list_item_t self ) ;
#line 50
spif_bool_t spif_dlinked_list_item_set_next(spif_dlinked_list_item_t self , spif_dlinked_list_item_t new_next ) ;
#line 52
static spif_dlinked_list_t spif_dlinked_list_new(void) ;
#line 53
static spif_dlinked_list_t spif_dlinked_list_vector_new(void) ;
#line 54
static spif_dlinked_list_t spif_dlinked_list_map_new(void) ;
#line 55
static spif_bool_t spif_dlinked_list_init(spif_dlinked_list_t self ) ;
#line 56
static spif_bool_t spif_dlinked_list_vector_init(spif_dlinked_list_t self ) ;
#line 57
static spif_bool_t spif_dlinked_list_map_init(spif_dlinked_list_t self ) ;
#line 58
static spif_bool_t spif_dlinked_list_done(spif_dlinked_list_t self ) ;
#line 59
static spif_bool_t spif_dlinked_list_del(spif_dlinked_list_t self ) ;
#line 60
static spif_str_t spif_dlinked_list_show(spif_dlinked_list_t self , spif_charptr_t name___0 ,
                                         spif_str_t buff , size_t indent ) ;
#line 61
static spif_cmp_t spif_dlinked_list_comp(spif_dlinked_list_t self , spif_dlinked_list_t other ) ;
#line 62
static spif_dlinked_list_t spif_dlinked_list_dup(spif_dlinked_list_t self ) ;
#line 63
static spif_dlinked_list_t spif_dlinked_list_vector_dup(spif_dlinked_list_t self ) ;
#line 64
static spif_dlinked_list_t spif_dlinked_list_map_dup(spif_dlinked_list_t self ) ;
#line 65
static spif_classname_t spif_dlinked_list_type(spif_dlinked_list_t self ) ;
#line 66
static spif_bool_t spif_dlinked_list_append(spif_dlinked_list_t self , spif_obj_t obj ) ;
#line 67
static spif_bool_t spif_dlinked_list_contains(spif_dlinked_list_t self , spif_obj_t obj ) ;
#line 68
static spif_bool_t spif_dlinked_list_vector_contains(spif_dlinked_list_t self , spif_obj_t obj ) ;
#line 69
static spif_listidx_t spif_dlinked_list_count(spif_dlinked_list_t self ) ;
#line 70
static spif_obj_t spif_dlinked_list_find(spif_dlinked_list_t self , spif_obj_t obj ) ;
#line 71
static spif_obj_t spif_dlinked_list_vector_find(spif_dlinked_list_t self , spif_obj_t obj ) ;
#line 72
static spif_obj_t spif_dlinked_list_get(spif_dlinked_list_t self , spif_listidx_t idx ) ;
#line 73
static spif_obj_t spif_dlinked_list_map_get(spif_dlinked_list_t self , spif_obj_t key ) ;
#line 74
static spif_list_t spif_dlinked_list_get_keys(spif_dlinked_list_t self , spif_list_t key_list ) ;
#line 75
static spif_list_t spif_dlinked_list_get_pairs(spif_dlinked_list_t self , spif_list_t pair_list ) ;
#line 76
static spif_list_t spif_dlinked_list_get_values(spif_dlinked_list_t self , spif_list_t value_list ) ;
#line 77
static spif_bool_t spif_dlinked_list_has_key(spif_dlinked_list_t self , spif_obj_t key ) ;
#line 78
static spif_bool_t spif_dlinked_list_has_value(spif_dlinked_list_t self , spif_obj_t value ) ;
#line 79
static spif_listidx_t spif_dlinked_list_index(spif_dlinked_list_t self , spif_obj_t obj ) ;
#line 80
static spif_bool_t spif_dlinked_list_insert(spif_dlinked_list_t self , spif_obj_t obj ) ;
#line 81
static spif_bool_t spif_dlinked_list_insert_at(spif_dlinked_list_t self , spif_obj_t obj ,
                                               spif_listidx_t idx ) ;
#line 82
static spif_iterator_t spif_dlinked_list_iterator(spif_dlinked_list_t self ) ;
#line 83
static spif_bool_t spif_dlinked_list_prepend(spif_dlinked_list_t self , spif_obj_t obj ) ;
#line 84
static spif_obj_t spif_dlinked_list_remove(spif_dlinked_list_t self , spif_obj_t item ) ;
#line 85
static spif_obj_t spif_dlinked_list_map_remove(spif_dlinked_list_t self , spif_obj_t item ) ;
#line 86
static spif_obj_t spif_dlinked_list_remove_at(spif_dlinked_list_t self , spif_listidx_t idx ) ;
#line 87
static spif_bool_t spif_dlinked_list_reverse(spif_dlinked_list_t self ) ;
#line 88
static spif_bool_t spif_dlinked_list_set(spif_dlinked_list_t self , spif_obj_t key ,
                                         spif_obj_t value ) ;
#line 89
static spif_obj_t *spif_dlinked_list_to_array(spif_dlinked_list_t self ) ;
#line 90
spif_listidx_t spif_dlinked_list_get_len(spif_dlinked_list_t self ) ;
#line 90
spif_bool_t spif_dlinked_list_set_len(spif_dlinked_list_t self , spif_listidx_t new_len ) ;
#line 91
spif_dlinked_list_item_t spif_dlinked_list_get_head(spif_dlinked_list_t self ) ;
#line 91
spif_bool_t spif_dlinked_list_set_head(spif_dlinked_list_t self , spif_dlinked_list_item_t new_head ) ;
#line 92
spif_dlinked_list_item_t spif_dlinked_list_get_tail(spif_dlinked_list_t self ) ;
#line 92
spif_bool_t spif_dlinked_list_set_tail(spif_dlinked_list_t self , spif_dlinked_list_item_t new_tail ) ;
#line 94
static spif_dlinked_list_iterator_t spif_dlinked_list_iterator_new(spif_dlinked_list_t subject ) ;
#line 95
static spif_bool_t spif_dlinked_list_iterator_init(spif_dlinked_list_iterator_t self ,
                                                   spif_dlinked_list_t subject ) ;
#line 96
static spif_bool_t spif_dlinked_list_iterator_done(spif_dlinked_list_iterator_t self ) ;
#line 97
static spif_bool_t spif_dlinked_list_iterator_del(spif_dlinked_list_iterator_t self ) ;
#line 98
static spif_str_t spif_dlinked_list_iterator_show(spif_dlinked_list_iterator_t self ,
                                                  spif_charptr_t name___0 , spif_str_t buff ,
                                                  size_t indent ) ;
#line 99
static spif_cmp_t spif_dlinked_list_iterator_comp(spif_dlinked_list_iterator_t self ,
                                                  spif_dlinked_list_iterator_t other ) ;
#line 100
static spif_dlinked_list_iterator_t spif_dlinked_list_iterator_dup(spif_dlinked_list_iterator_t self ) ;
#line 101
static spif_classname_t spif_dlinked_list_iterator_type(spif_dlinked_list_iterator_t self ) ;
#line 102
static spif_bool_t spif_dlinked_list_iterator_has_next(spif_dlinked_list_iterator_t self ) ;
#line 103
static spif_obj_t spif_dlinked_list_iterator_next(spif_dlinked_list_iterator_t self ) ;
#line 104
spif_dlinked_list_t spif_dlinked_list_iterator_get_subject(spif_dlinked_list_iterator_t self ) ;
#line 104
spif_bool_t spif_dlinked_list_iterator_set_subject(spif_dlinked_list_iterator_t self ,
                                                   spif_dlinked_list_t new_subject ) ;
#line 105
spif_dlinked_list_item_t spif_dlinked_list_iterator_get_current(spif_dlinked_list_iterator_t self ) ;
#line 105
spif_bool_t spif_dlinked_list_iterator_set_current(spif_dlinked_list_iterator_t self ,
                                                   spif_dlinked_list_item_t new_current ) ;
#line 108 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_const_class_t dli_class  = 
#line 108
     {(spif_charptr_t )"!spif_dlinked_list_item_t!", (void *(*)())(& spif_dlinked_list_item_new),
    (void *(*)())(& spif_dlinked_list_item_init), (void *(*)())(& spif_dlinked_list_item_done),
    (void *(*)())(& spif_dlinked_list_item_del), (void *(*)())(& spif_dlinked_list_item_show),
    (void *(*)())(& spif_dlinked_list_item_comp), (void *(*)())(& spif_dlinked_list_item_dup),
    (void *(*)())(& spif_dlinked_list_item_type)};
#line 119 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_class_t spif_dlinked_list_item_class  =    & dli_class;
#line 121 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_const_listclass_t dl_class  = 
#line 121
     {{(spif_charptr_t )"!spif_dlinked_list_t!", (void *(*)())(& spif_dlinked_list_new),
     (void *(*)())(& spif_dlinked_list_init), (void *(*)())(& spif_dlinked_list_done),
     (void *(*)())(& spif_dlinked_list_del), (void *(*)())(& spif_dlinked_list_show),
     (void *(*)())(& spif_dlinked_list_comp), (void *(*)())(& spif_dlinked_list_dup),
     (void *(*)())(& spif_dlinked_list_type)}, (void *(*)())(& spif_dlinked_list_append),
    (void *(*)())(& spif_dlinked_list_contains), (void *(*)())(& spif_dlinked_list_count),
    (void *(*)())(& spif_dlinked_list_find), (void *(*)())(& spif_dlinked_list_get),
    (void *(*)())(& spif_dlinked_list_index), (void *(*)())(& spif_dlinked_list_insert),
    (void *(*)())(& spif_dlinked_list_insert_at), (void *(*)())(& spif_dlinked_list_iterator),
    (void *(*)())(& spif_dlinked_list_prepend), (void *(*)())(& spif_dlinked_list_remove),
    (void *(*)())(& spif_dlinked_list_remove_at), (void *(*)())(& spif_dlinked_list_reverse),
    (void *(*)())(& spif_dlinked_list_to_array)};
#line 148 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_listclass_t spif_dlinked_list_listclass  =    & dl_class;
#line 150 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_const_vectorclass_t dlv_class  = 
#line 150
     {{(spif_charptr_t )"!spif_dlinked_list_t!", (void *(*)())(& spif_dlinked_list_vector_new),
     (void *(*)())(& spif_dlinked_list_vector_init), (void *(*)())(& spif_dlinked_list_done),
     (void *(*)())(& spif_dlinked_list_del), (void *(*)())(& spif_dlinked_list_show),
     (void *(*)())(& spif_dlinked_list_comp), (void *(*)())(& spif_dlinked_list_vector_dup),
     (void *(*)())(& spif_dlinked_list_type)}, (void *(*)())(& spif_dlinked_list_vector_contains),
    (void *(*)())(& spif_dlinked_list_count), (void *(*)())(& spif_dlinked_list_vector_find),
    (void *(*)())(& spif_dlinked_list_insert), (void *(*)())(& spif_dlinked_list_iterator),
    (void *(*)())(& spif_dlinked_list_remove), (void *(*)())(& spif_dlinked_list_to_array)};
#line 170 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_vectorclass_t spif_dlinked_list_vectorclass  =    & dlv_class;
#line 172 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_const_mapclass_t dllm_class  = 
#line 172
     {{(spif_charptr_t )"!spif_dlinked_list_t!", (void *(*)())(& spif_dlinked_list_map_new),
     (void *(*)())(& spif_dlinked_list_map_init), (void *(*)())(& spif_dlinked_list_done),
     (void *(*)())(& spif_dlinked_list_del), (void *(*)())(& spif_dlinked_list_show),
     (void *(*)())(& spif_dlinked_list_comp), (void *(*)())(& spif_dlinked_list_map_dup),
     (void *(*)())(& spif_dlinked_list_type)}, (void *(*)())(& spif_dlinked_list_count),
    (void *(*)())(& spif_dlinked_list_map_get), (void *(*)())(& spif_dlinked_list_get_keys),
    (void *(*)())(& spif_dlinked_list_get_pairs), (void *(*)())(& spif_dlinked_list_get_values),
    (void *(*)())(& spif_dlinked_list_has_key), (void *(*)())(& spif_dlinked_list_has_value),
    (void *(*)())(& spif_dlinked_list_iterator), (void *(*)())(& spif_dlinked_list_map_remove),
    (void *(*)())(& spif_dlinked_list_set)};
#line 195 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_mapclass_t spif_dlinked_list_mapclass  =    & dllm_class;
#line 197 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_const_iteratorclass_t dlli_class  =    {{(spif_charptr_t )"!spif_dlinked_list_t!", (void *(*)())(& spif_dlinked_list_iterator_new),
     (void *(*)())(& spif_dlinked_list_iterator_init), (void *(*)())(& spif_dlinked_list_iterator_done),
     (void *(*)())(& spif_dlinked_list_iterator_del), (void *(*)())(& spif_dlinked_list_iterator_show),
     (void *(*)())(& spif_dlinked_list_iterator_comp), (void *(*)())(& spif_dlinked_list_iterator_dup),
     (void *(*)())(& spif_dlinked_list_iterator_type)}, (void *(*)())(& spif_dlinked_list_iterator_has_next),
    (void *(*)())(& spif_dlinked_list_iterator_next)};
#line 212 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_iteratorclass_t spif_dlinked_list_iteratorclass  =    & dlli_class;
#line 215 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_dlinked_list_item_t spif_dlinked_list_item_new(void) 
{ 
  spif_dlinked_list_item_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 220
  tmp = malloc(sizeof(spif_const_dlinked_list_item_t ));
#line 220
  self = (spif_dlinked_list_item_t )tmp;
#line 221
  tmp___0 = spif_dlinked_list_item_init(self);
  }
#line 221
  if (! tmp___0) {
    {
#line 222
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 222
      free((void *)self);
#line 222
      self = (spif_dlinked_list_item_t )((void *)0);
      }
#line 222
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 223
    self = (spif_dlinked_list_item_t )((void *)0);
  }
#line 225
  return (self);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_item_init(spif_dlinked_list_item_t self ) 
{ 


  {
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! (! ((unsigned long )self == (unsigned long )((spif_dlinked_list_item_t )((void *)0))))) {
#line 231
      if (libast_debug_level >= 1U) {
        {
#line 231
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_item_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           231, "!SPIF_DLINKED_LIST_ITEM_ISNULL(self)");
        }
      } else {
        {
#line 231
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_item_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             231, "!SPIF_DLINKED_LIST_ITEM_ISNULL(self)");
        }
      }
#line 231
      return ((spif_bool_t )0);
    }
#line 231
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  self->data = (spif_obj_t )((void *)0);
#line 233
  self->prev = (spif_dlinked_list_item_t )((void *)0);
#line 234
  self->next = (spif_dlinked_list_item_t )((void *)0);
#line 235
  return ((spif_bool_t )1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_item_done(spif_dlinked_list_item_t self ) 
{ 


  {
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! (! ((unsigned long )self == (unsigned long )((spif_dlinked_list_item_t )((void *)0))))) {
#line 241
      if (libast_debug_level >= 1U) {
        {
#line 241
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_item_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           241, "!SPIF_DLINKED_LIST_ITEM_ISNULL(self)");
        }
      } else {
        {
#line 241
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_item_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             241, "!SPIF_DLINKED_LIST_ITEM_ISNULL(self)");
        }
      }
#line 241
      return ((spif_bool_t )0);
    }
#line 241
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  if ((unsigned long )self->data != (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 243
    (*(((self->data)->cls)->del))(self->data);
    }
  }
#line 245
  self->data = (spif_obj_t )((void *)0);
#line 246
  self->prev = (spif_dlinked_list_item_t )((void *)0);
#line 247
  self->next = (spif_dlinked_list_item_t )((void *)0);
#line 248
  return ((spif_bool_t )1);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_item_del(spif_dlinked_list_item_t self ) 
{ 


  {
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (! ((unsigned long )self == (unsigned long )((spif_dlinked_list_item_t )((void *)0))))) {
#line 254
      if (libast_debug_level >= 1U) {
        {
#line 254
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_item_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           254, "!SPIF_DLINKED_LIST_ITEM_ISNULL(self)");
        }
      } else {
        {
#line 254
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_item_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             254, "!SPIF_DLINKED_LIST_ITEM_ISNULL(self)");
        }
      }
#line 254
      return ((spif_bool_t )0);
    }
#line 254
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  spif_dlinked_list_item_done(self);
  }
  {
#line 256
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 256
    free((void *)self);
#line 256
    self = (spif_dlinked_list_item_t )((void *)0);
    }
#line 256
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 257
  return ((spif_bool_t )1);
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_str_t spif_dlinked_list_item_show(spif_dlinked_list_item_t self , spif_charptr_t name___0 ,
                                              spif_str_t buff , size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 265
  if ((unsigned long )self == (unsigned long )((spif_dlinked_list_item_t )((void *)0))) {
    {
#line 266
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 266
      memset((void *)(tmp), ' ', indent);
      }
#line 266
      if ((char *)name___0) {
#line 266
        tmp___0 = (char *)name___0;
      } else {
#line 266
        tmp___0 = (char *)"<name null>";
      }
      {
#line 266
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_dlinked_list_item_t) %s:  { ((spif_dlinked_list_item_t) NULL) }\n",
               tmp___0);
      }
#line 266
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 266
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 266
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 266
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 267
    return (buff);
  }
  {
#line 270
  memset((void *)(tmp), ' ', indent);
#line 271
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_dlinked_list_item_t) %s (%9p <- %9p -> %9p):  ",
           name___0, (spif_ptr_t )self->prev, (spif_ptr_t )self, (spif_ptr_t )self->next);
  }
#line 275
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 276
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 278
    spif_str_append_from_ptr(buff, tmp);
    }
  }
#line 280
  if ((unsigned long )((spif_dlinked_list_item_t )self->data) == (unsigned long )((spif_dlinked_list_item_t )((void *)0))) {
    {
#line 281
    spif_str_append_from_ptr(buff, (spif_charptr_t )"{ ((spif_obj_t) NULL) }");
    }
  } else {
    {
#line 283
    tmp___1 = (*(((self->data)->cls)->show))(self->data, "self->data", buff, 0);
#line 283
    buff = (spif_str_t )tmp___1;
    }
  }
#line 285
  return (buff);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_cmp_t spif_dlinked_list_item_comp(spif_dlinked_list_item_t self , spif_dlinked_list_item_t other ) 
{ 
  void *tmp ;

  {
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 291
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 291
        return ((spif_cmp_t )0);
      } else {
#line 291
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 291
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 291
      return ((spif_cmp_t )-1);
    } else
#line 291
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 291
      return ((spif_cmp_t )1);
    }
#line 291
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 292
  tmp = (*(((self->data)->cls)->comp))(self->data, other->data);
  }
#line 292
  return ((spif_cmp_t )tmp);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_dlinked_list_item_t spif_dlinked_list_item_dup(spif_dlinked_list_item_t self ) 
{ 
  spif_dlinked_list_item_t tmp ;
  void *tmp___0 ;

  {
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (! ((unsigned long )self == (unsigned long )((spif_dlinked_list_item_t )((void *)0))))) {
#line 300
      if (libast_debug_level >= 1U) {
        {
#line 300
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_item_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           300, "!SPIF_DLINKED_LIST_ITEM_ISNULL(self)");
        }
      } else {
        {
#line 300
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_item_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             300, "!SPIF_DLINKED_LIST_ITEM_ISNULL(self)");
        }
      }
#line 300
      return ((spif_dlinked_list_item_t )((void *)0));
    }
#line 300
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 301
  tmp = spif_dlinked_list_item_new();
#line 302
  tmp___0 = (*(((self->data)->cls)->dup))(self->data);
#line 302
  tmp->data = (spif_obj_t )tmp___0;
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_classname_t spif_dlinked_list_item_type(spif_dlinked_list_item_t self ) 
{ 


  {
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (! ((unsigned long )self == (unsigned long )((spif_dlinked_list_item_t )((void *)0))))) {
#line 309
      if (libast_debug_level >= 1U) {
        {
#line 309
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_item_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           309, "!SPIF_DLINKED_LIST_ITEM_ISNULL(self)");
        }
      } else {
        {
#line 309
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_item_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             309, "!SPIF_DLINKED_LIST_ITEM_ISNULL(self)");
        }
      }
#line 309
      return ((spif_classname_t )((void *)0));
    }
#line 309
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return (spif_dlinked_list_item_class->classname);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_obj_t spif_dlinked_list_item_get_data(spif_dlinked_list_item_t self ) 
{ 


  {
#line 313
  return (self->data);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_bool_t spif_dlinked_list_item_set_data(spif_dlinked_list_item_t self , spif_obj_t new_data ) 
{ 


  {
#line 313
  if (! ((unsigned long )self->data == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 313
    (*(((self->data)->cls)->del))(self->data);
    }
  }
#line 313
  self->data = new_data;
#line 313
  return ((spif_bool_t )1);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_dlinked_list_item_t spif_dlinked_list_item_get_prev(spif_dlinked_list_item_t self ) 
{ 


  {
#line 314
  return (self->prev);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_bool_t spif_dlinked_list_item_set_prev(spif_dlinked_list_item_t self , spif_dlinked_list_item_t new_prev ) 
{ 


  {
#line 314
  self->prev = new_prev;
#line 314
  return ((spif_bool_t )1);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_dlinked_list_item_t spif_dlinked_list_item_get_next(spif_dlinked_list_item_t self ) 
{ 


  {
#line 315
  return (self->next);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_bool_t spif_dlinked_list_item_set_next(spif_dlinked_list_item_t self , spif_dlinked_list_item_t new_next ) 
{ 


  {
#line 315
  self->next = new_next;
#line 315
  return ((spif_bool_t )1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_dlinked_list_t spif_dlinked_list_new(void) 
{ 
  spif_dlinked_list_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 323
  tmp = malloc(sizeof(spif_const_dlinked_list_t ));
#line 323
  self = (spif_dlinked_list_t )tmp;
#line 324
  tmp___0 = spif_dlinked_list_init(self);
  }
#line 324
  if (! tmp___0) {
    {
#line 325
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 325
      free((void *)self);
#line 325
      self = (spif_dlinked_list_t )((void *)0);
      }
#line 325
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 326
    self = (spif_dlinked_list_t )((void *)0);
  }
#line 328
  return (self);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_dlinked_list_t spif_dlinked_list_vector_new(void) 
{ 
  spif_dlinked_list_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 336
  tmp = malloc(sizeof(spif_const_dlinked_list_t ));
#line 336
  self = (spif_dlinked_list_t )tmp;
#line 337
  tmp___0 = spif_dlinked_list_vector_init(self);
  }
#line 337
  if (! tmp___0) {
    {
#line 338
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 338
      free((void *)self);
#line 338
      self = (spif_dlinked_list_t )((void *)0);
      }
#line 338
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 339
    self = (spif_dlinked_list_t )((void *)0);
  }
#line 341
  return (self);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_dlinked_list_t spif_dlinked_list_map_new(void) 
{ 
  spif_dlinked_list_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 349
  tmp = malloc(sizeof(spif_const_dlinked_list_t ));
#line 349
  self = (spif_dlinked_list_t )tmp;
#line 350
  tmp___0 = spif_dlinked_list_map_init(self);
  }
#line 350
  if (! tmp___0) {
    {
#line 351
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 351
      free((void *)self);
#line 351
      self = (spif_dlinked_list_t )((void *)0);
      }
#line 351
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 352
    self = (spif_dlinked_list_t )((void *)0);
  }
#line 354
  return (self);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_init(spif_dlinked_list_t self ) 
{ 


  {
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 360
      if (libast_debug_level >= 1U) {
        {
#line 360
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           360, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 360
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             360, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 360
      return ((spif_bool_t )0);
    }
#line 360
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 362
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_dlinked_list_listclass);
#line 363
  self->len = 0;
#line 364
  self->head = (spif_dlinked_list_item_t )((void *)0);
#line 365
  self->tail = (spif_dlinked_list_item_t )((void *)0);
  }
#line 366
  return ((spif_bool_t )1);
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_vector_init(spif_dlinked_list_t self ) 
{ 


  {
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 372
      if (libast_debug_level >= 1U) {
        {
#line 372
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_vector_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           372, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 372
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_vector_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             372, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 372
      return ((spif_bool_t )0);
    }
#line 372
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_dlinked_list_vectorclass);
#line 375
  self->len = 0;
#line 376
  self->head = (spif_dlinked_list_item_t )((void *)0);
#line 377
  self->tail = (spif_dlinked_list_item_t )((void *)0);
  }
#line 378
  return ((spif_bool_t )1);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_map_init(spif_dlinked_list_t self ) 
{ 


  {
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (! (! ((unsigned long )((spif_map_t )self) == (unsigned long )((spif_map_t )((void *)0))))) {
#line 384
      if (libast_debug_level >= 1U) {
        {
#line 384
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_map_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           384, "!SPIF_MAP_ISNULL(self)");
        }
      } else {
        {
#line 384
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_map_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             384, "!SPIF_MAP_ISNULL(self)");
        }
      }
#line 384
      return ((spif_bool_t )0);
    }
#line 384
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 386
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_dlinked_list_mapclass);
#line 387
  self->len = 0;
#line 388
  self->head = (spif_dlinked_list_item_t )((void *)0);
#line 389
  self->tail = (spif_dlinked_list_item_t )((void *)0);
  }
#line 390
  return ((spif_bool_t )1);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_done(spif_dlinked_list_t self ) 
{ 
  spif_dlinked_list_item_t current ;
  spif_dlinked_list_item_t tmp ;

  {
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 398
      if (libast_debug_level >= 1U) {
        {
#line 398
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           398, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 398
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             398, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 398
      return ((spif_bool_t )0);
    }
#line 398
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  if (self->len) {
#line 400
    current = self->head;
    {
#line 400
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 400
      if (! current) {
#line 400
        goto while_break___0;
      }
      {
#line 403
      tmp = current;
#line 404
      current = current->next;
#line 405
      spif_dlinked_list_item_del(tmp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 407
    self->len = 0;
#line 408
    self->head = (spif_dlinked_list_item_t )((void *)0);
#line 409
    self->tail = (spif_dlinked_list_item_t )((void *)0);
  }
#line 411
  return ((spif_bool_t )1);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_del(spif_dlinked_list_t self ) 
{ 


  {
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 417
      if (libast_debug_level >= 1U) {
        {
#line 417
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           417, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 417
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             417, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 417
      return ((spif_bool_t )0);
    }
#line 417
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 418
  spif_dlinked_list_done(self);
  }
  {
#line 419
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 419
    free((void *)self);
#line 419
    self = (spif_dlinked_list_t )((void *)0);
    }
#line 419
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return ((spif_bool_t )1);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_str_t spif_dlinked_list_show(spif_dlinked_list_t self , spif_charptr_t name___0 ,
                                         spif_str_t buff , size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  spif_dlinked_list_item_t current ;
  spif_listidx_t i ;
  char *tmp___0 ;

  {
#line 430
  if ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))) {
    {
#line 431
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 431
      memset((void *)(tmp), ' ', indent);
      }
#line 431
      if ((char *)name___0) {
#line 431
        tmp___0 = (char *)name___0;
      } else {
#line 431
        tmp___0 = (char *)"<name null>";
      }
      {
#line 431
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_dlinked_list_t) %s:  { ((spif_dlinked_list_t) NULL) }\n",
               tmp___0);
      }
#line 431
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 431
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 431
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 431
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 432
    return (buff);
  }
  {
#line 435
  memset((void *)(tmp), ' ', indent);
#line 436
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_dlinked_list_t) %s:  %10p {\n",
           name___0, (spif_ptr_t )self);
  }
#line 438
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 439
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 441
    spif_str_append_from_ptr(buff, tmp);
    }
  }
#line 444
  if ((unsigned long )self->head == (unsigned long )((spif_dlinked_list_item_t )((void *)0))) {
    {
#line 445
    spif_str_append_from_ptr(buff, (spif_charptr_t )"{ ((spif_obj_t) NULL) }");
    }
  } else {
#line 447
    current = self->head;
#line 447
    i = 0;
    {
#line 447
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 447
      if (! current) {
#line 447
        goto while_break___0;
      }
      {
#line 448
      sprintf((char */* __restrict  */)((char *)(tmp)), (char const   */* __restrict  */)"item %d",
              i);
#line 449
      buff = spif_dlinked_list_item_show(current, tmp, buff, indent + 2UL);
#line 447
      current = current->next;
#line 447
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 453
  memset((void *)(tmp), ' ', indent);
#line 454
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"}\n");
#line 455
  spif_str_append_from_ptr(buff, tmp);
  }
#line 456
  return (buff);
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_cmp_t spif_dlinked_list_comp(spif_dlinked_list_t self , spif_dlinked_list_t other ) 
{ 
  spif_cmp_t tmp ;

  {
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 462
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 462
        return ((spif_cmp_t )0);
      } else {
#line 462
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 462
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 462
      return ((spif_cmp_t )-1);
    } else
#line 462
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 462
      return ((spif_cmp_t )1);
    }
#line 462
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 463
  tmp = spif_obj_comp((spif_obj_t )self, (spif_obj_t )other);
  }
#line 463
  return (tmp);
}
}
#line 466 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_dlinked_list_t spif_dlinked_list_dup(spif_dlinked_list_t self ) 
{ 
  spif_dlinked_list_t tmp ;
  spif_dlinked_list_item_t src ;
  spif_dlinked_list_item_t dest ;
  spif_dlinked_list_item_t prev ;

  {
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 472
      if (libast_debug_level >= 1U) {
        {
#line 472
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           472, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 472
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             472, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 472
      return ((spif_dlinked_list_t )((void *)0));
    }
#line 472
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 473
  tmp = spif_dlinked_list_new();
#line 474
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self, sizeof(spif_const_dlinked_list_t ));
#line 475
  tmp->head = spif_dlinked_list_item_dup(self->head);
#line 476
  src = self->head;
#line 476
  dest = tmp->head;
#line 476
  prev = (spif_dlinked_list_item_t )((void *)0);
  }
  {
#line 476
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 476
    if (! src->next) {
#line 476
      goto while_break___0;
    }
    {
#line 479
    dest->next = spif_dlinked_list_item_dup(src->next);
#line 480
    dest->prev = prev;
#line 476
    src = src->next;
#line 476
    prev = dest;
#line 476
    dest = dest->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 482
  dest->next = (spif_dlinked_list_item_t )((void *)0);
#line 483
  tmp->tail = prev;
#line 484
  return (tmp);
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_dlinked_list_t spif_dlinked_list_vector_dup(spif_dlinked_list_t self ) 
{ 
  spif_dlinked_list_t tmp ;
  spif_dlinked_list_item_t src ;
  spif_dlinked_list_item_t dest ;
  spif_dlinked_list_item_t prev ;

  {
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 493
      if (libast_debug_level >= 1U) {
        {
#line 493
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_vector_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           493, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 493
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_vector_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             493, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 493
      return ((spif_dlinked_list_t )((void *)0));
    }
#line 493
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 494
  tmp = spif_dlinked_list_vector_new();
#line 495
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self, sizeof(spif_const_dlinked_list_t ));
#line 496
  tmp->head = spif_dlinked_list_item_dup(self->head);
#line 497
  src = self->head;
#line 497
  dest = tmp->head;
#line 497
  prev = (spif_dlinked_list_item_t )((void *)0);
  }
  {
#line 497
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 497
    if (! src->next) {
#line 497
      goto while_break___0;
    }
    {
#line 500
    dest->next = spif_dlinked_list_item_dup(src->next);
#line 501
    dest->prev = prev;
#line 497
    src = src->next;
#line 497
    prev = dest;
#line 497
    dest = dest->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 503
  dest->next = (spif_dlinked_list_item_t )((void *)0);
#line 504
  tmp->tail = prev;
#line 505
  return (tmp);
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_dlinked_list_t spif_dlinked_list_map_dup(spif_dlinked_list_t self ) 
{ 
  spif_dlinked_list_t tmp ;
  spif_dlinked_list_item_t src ;
  spif_dlinked_list_item_t dest ;
  spif_dlinked_list_item_t prev ;

  {
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (! (! ((unsigned long )((spif_map_t )self) == (unsigned long )((spif_map_t )((void *)0))))) {
#line 514
      if (libast_debug_level >= 1U) {
        {
#line 514
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_map_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           514, "!SPIF_MAP_ISNULL(self)");
        }
      } else {
        {
#line 514
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_map_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             514, "!SPIF_MAP_ISNULL(self)");
        }
      }
#line 514
      return ((spif_dlinked_list_t )((void *)0));
    }
#line 514
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 515
  tmp = spif_dlinked_list_map_new();
#line 516
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self, sizeof(spif_const_dlinked_list_t ));
#line 517
  tmp->head = spif_dlinked_list_item_dup(self->head);
#line 518
  src = self->head;
#line 518
  dest = tmp->head;
#line 518
  prev = (spif_dlinked_list_item_t )((void *)0);
  }
  {
#line 518
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 518
    if (! src->next) {
#line 518
      goto while_break___0;
    }
    {
#line 521
    dest->next = spif_dlinked_list_item_dup(src->next);
#line 522
    dest->prev = prev;
#line 518
    src = src->next;
#line 518
    prev = dest;
#line 518
    dest = dest->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 524
  dest->next = (spif_dlinked_list_item_t )((void *)0);
#line 525
  tmp->tail = prev;
#line 526
  return (tmp);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_classname_t spif_dlinked_list_type(spif_dlinked_list_t self ) 
{ 


  {
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 532
      if (libast_debug_level >= 1U) {
        {
#line 532
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           532, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 532
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             532, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 532
      return ((spif_classname_t )((void *)0));
    }
#line 532
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_append(spif_dlinked_list_t self , spif_obj_t obj ) 
{ 
  spif_dlinked_list_item_t item ;
  spif_dlinked_list_item_t tmp ;

  {
  {
#line 541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 541
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 541
      if (libast_debug_level >= 1U) {
        {
#line 541
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_append",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           541, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 541
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_append",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             541, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 541
      return ((spif_bool_t )0);
    }
#line 541
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 543
  item = spif_dlinked_list_item_new();
#line 544
  spif_dlinked_list_item_set_data(item, obj);
  }
#line 547
  if (self->tail) {
#line 548
    item->prev = self->tail;
#line 549
    (item->prev)->next = item;
#line 550
    self->tail = item;
  } else {
#line 552
    tmp = item;
#line 552
    self->head = tmp;
#line 552
    self->tail = tmp;
#line 553
    item->prev = (spif_dlinked_list_item_t )((void *)0);
  }
#line 555
  item->next = (spif_dlinked_list_item_t )((void *)0);
#line 556
  (self->len) ++;
#line 557
  return ((spif_bool_t )1);
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_contains(spif_dlinked_list_t self , spif_obj_t obj ) 
{ 
  int tmp___0 ;
  spif_obj_t tmp___1 ;

  {
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 563
      if (libast_debug_level >= 1U) {
        {
#line 563
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_contains",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           563, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 563
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_contains",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             563, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 563
      return ((spif_bool_t )0);
    }
#line 563
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 564
  tmp___1 = spif_dlinked_list_find(self, obj);
  }
#line 564
  if ((unsigned long )tmp___1 == (unsigned long )((spif_list_t )((void *)0))) {
#line 564
    tmp___0 = 0;
  } else {
#line 564
    tmp___0 = 1;
  }
#line 564
  return ((spif_bool_t )tmp___0);
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_vector_contains(spif_dlinked_list_t self , spif_obj_t obj ) 
{ 
  int tmp___0 ;
  spif_obj_t tmp___1 ;

  {
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 570
      if (libast_debug_level >= 1U) {
        {
#line 570
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_vector_contains",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           570, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 570
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_vector_contains",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             570, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 570
      return ((spif_bool_t )0);
    }
#line 570
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 571
  tmp___1 = spif_dlinked_list_vector_find(self, obj);
  }
#line 571
  if ((unsigned long )tmp___1 == (unsigned long )((spif_list_t )((void *)0))) {
#line 571
    tmp___0 = 0;
  } else {
#line 571
    tmp___0 = 1;
  }
#line 571
  return ((spif_bool_t )tmp___0);
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_listidx_t spif_dlinked_list_count(spif_dlinked_list_t self ) 
{ 


  {
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 577
      if (libast_debug_level >= 1U) {
        {
#line 577
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_count",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           577, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 577
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_count",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             577, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 577
      return (0);
    }
#line 577
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  return (self->len);
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_obj_t spif_dlinked_list_find(spif_dlinked_list_t self , spif_obj_t obj ) 
{ 
  spif_dlinked_list_item_t current ;
  time_t tmp ;
  void *tmp___0 ;

  {
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 586
      if (libast_debug_level >= 1U) {
        {
#line 586
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_find",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           586, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 586
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_find",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             586, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 586
      return ((spif_obj_t )((void *)0));
    }
#line 586
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 587
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 587
    if (! (! ((unsigned long )obj == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 587
      if (libast_debug_level >= 1U) {
        {
#line 587
        tmp = time((time_t *)((void *)0));
#line 587
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                587, "spif_dlinked_list_find");
#line 587
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(obj)");
        }
      }
#line 587
      return ((spif_obj_t )((void *)0));
    }
#line 587
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 588
  current = self->head;
  {
#line 588
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 588
    if (! current) {
#line 588
      goto while_break___1;
    }
    {
#line 589
    tmp___0 = (*((obj->cls)->comp))(obj, current->data);
    }
#line 589
    if ((int )((spif_cmp_t )tmp___0) == 0) {
#line 590
      return (current->data);
    }
#line 588
    current = current->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 593
  return ((spif_obj_t )((void *)0));
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_obj_t spif_dlinked_list_vector_find(spif_dlinked_list_t self , spif_obj_t obj ) 
{ 
  spif_dlinked_list_item_t current ;
  time_t tmp ;
  spif_cmp_t c ;
  void *tmp___0 ;

  {
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 601
      if (libast_debug_level >= 1U) {
        {
#line 601
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_vector_find",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           601, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 601
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_vector_find",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             601, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 601
      return ((spif_obj_t )((void *)0));
    }
#line 601
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 602
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 602
    if (! (! ((unsigned long )obj == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 602
      if (libast_debug_level >= 1U) {
        {
#line 602
        tmp = time((time_t *)((void *)0));
#line 602
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                602, "spif_dlinked_list_vector_find");
#line 602
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(obj)");
        }
      }
#line 602
      return ((spif_obj_t )((void *)0));
    }
#line 602
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 603
  current = self->head;
  {
#line 603
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 603
    if (! current) {
#line 603
      goto while_break___1;
    }
    {
#line 606
    tmp___0 = (*((obj->cls)->comp))(obj, current->data);
#line 606
    c = (spif_cmp_t )tmp___0;
    }
#line 607
    if ((int )c == 0) {
#line 608
      return (current->data);
    } else
#line 609
    if ((int )c == -1) {
#line 610
      goto while_break___1;
    }
#line 603
    current = current->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 613
  return ((spif_obj_t )((void *)0));
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_obj_t spif_dlinked_list_get(spif_dlinked_list_t self , spif_listidx_t idx ) 
{ 
  spif_listidx_t i ;
  spif_dlinked_list_item_t current ;
  time_t tmp ;
  time_t tmp___0 ;
  spif_obj_t tmp___1 ;
  spif_obj_t tmp___2 ;

  {
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
#line 622
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 622
      if (libast_debug_level >= 1U) {
        {
#line 622
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_get",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           622, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 622
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_get",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             622, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 622
      return ((spif_obj_t )((void *)0));
    }
#line 622
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 623
  if (idx < 0) {
#line 625
    idx += self->len;
  }
  {
#line 627
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 627
    if (! (idx >= 0)) {
#line 627
      if (libast_debug_level >= 1U) {
        {
#line 627
        tmp = time((time_t *)((void *)0));
#line 627
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                627, "spif_dlinked_list_get");
#line 627
        libast_dprintf("REQUIRE failed:  %s\n", "idx >= 0");
        }
      }
#line 627
      return ((spif_obj_t )((void *)0));
    }
#line 627
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 628
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 628
    if (! (idx < self->len)) {
#line 628
      if (libast_debug_level >= 1U) {
        {
#line 628
        tmp___0 = time((time_t *)((void *)0));
#line 628
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                628, "spif_dlinked_list_get");
#line 628
        libast_dprintf("REQUIRE failed:  %s\n", "idx < self->len");
        }
      }
#line 628
      return ((spif_obj_t )((void *)0));
    }
#line 628
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 630
  if (idx > self->len / 2) {
#line 631
    current = self->tail;
#line 631
    i = self->len - 1;
    {
#line 631
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 631
      if (current) {
#line 631
        if (! (i > idx)) {
#line 631
          goto while_break___2;
        }
      } else {
#line 631
        goto while_break___2;
      }
#line 631
      i --;
#line 631
      current = current->prev;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 632
    if (current) {
#line 632
      tmp___1 = current->data;
    } else {
#line 632
      tmp___1 = (spif_obj_t )((void *)0);
    }
#line 632
    return (tmp___1);
  } else {
#line 634
    current = self->head;
#line 634
    i = 0;
    {
#line 634
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 634
      if (current) {
#line 634
        if (! (i < idx)) {
#line 634
          goto while_break___3;
        }
      } else {
#line 634
        goto while_break___3;
      }
#line 634
      i ++;
#line 634
      current = current->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 635
    if (current) {
#line 635
      tmp___2 = current->data;
    } else {
#line 635
      tmp___2 = (spif_obj_t )((void *)0);
    }
#line 635
    return (tmp___2);
  }
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_obj_t spif_dlinked_list_map_get(spif_dlinked_list_t self , spif_obj_t key ) 
{ 
  spif_dlinked_list_item_t current ;
  time_t tmp ;
  spif_cmp_t c ;
  void *tmp___0 ;

  {
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 644
      if (libast_debug_level >= 1U) {
        {
#line 644
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_map_get",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           644, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 644
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_map_get",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             644, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 644
      return ((spif_obj_t )((void *)0));
    }
#line 644
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 645
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 645
    if (! (! ((unsigned long )key == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 645
      if (libast_debug_level >= 1U) {
        {
#line 645
        tmp = time((time_t *)((void *)0));
#line 645
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                645, "spif_dlinked_list_map_get");
#line 645
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(key)");
        }
      }
#line 645
      return ((spif_obj_t )((void *)0));
    }
#line 645
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 646
  current = self->head;
  {
#line 646
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 646
    if (! current) {
#line 646
      goto while_break___1;
    }
    {
#line 650
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 650
      if (! (! ((unsigned long )current->data == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 650
        if (libast_debug_level >= 1U) {
          {
#line 650
          libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_map_get",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             650, "!SPIF_OBJ_ISNULL(current->data)");
          }
        } else {
          {
#line 650
          libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_map_get",
                               "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                               650, "!SPIF_OBJ_ISNULL(current->data)");
          }
        }
#line 650
        return ((spif_obj_t )((void *)0));
      }
#line 650
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 651
    tmp___0 = (*(((current->data)->cls)->comp))(current->data, key);
#line 651
    c = (spif_cmp_t )tmp___0;
    }
#line 652
    if ((int )c == 0) {
#line 653
      return (((spif_objpair_t )current->data)->value);
    } else
#line 654
    if ((int )c == 1) {
#line 655
      goto while_break___1;
    }
#line 646
    current = current->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 658
  return ((spif_obj_t )((void *)0));
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_list_t spif_dlinked_list_get_keys(spif_dlinked_list_t self , spif_list_t key_list ) 
{ 
  spif_dlinked_list_item_t current ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 666
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 666
      if (libast_debug_level >= 1U) {
        {
#line 666
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_get_keys",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           666, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 666
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_get_keys",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             666, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 666
      return ((spif_list_t )((void *)0));
    }
#line 666
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 667
  if ((unsigned long )key_list == (unsigned long )((spif_list_t )((void *)0))) {
    {
#line 668
    tmp = (*(((spif_class_t )spif_linked_list_listclass)->noo))();
#line 668
    key_list = (spif_list_t )tmp;
    }
  }
#line 670
  current = self->head;
  {
#line 670
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 670
    if (! current) {
#line 670
      goto while_break___0;
    }
    {
#line 672
    tmp___0 = (*(((((spif_objpair_t )current->data)->key)->cls)->dup))(((spif_objpair_t )current->data)->key);
#line 672
    (*(((spif_listclass_t )key_list->cls)->append))(key_list, (spif_obj_t )tmp___0);
#line 670
    current = current->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 674
  return (key_list);
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_list_t spif_dlinked_list_get_pairs(spif_dlinked_list_t self , spif_list_t pair_list ) 
{ 
  spif_dlinked_list_item_t current ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 682
      if (libast_debug_level >= 1U) {
        {
#line 682
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_get_pairs",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           682, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 682
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_get_pairs",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             682, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 682
      return ((spif_list_t )((void *)0));
    }
#line 682
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  if ((unsigned long )pair_list == (unsigned long )((spif_list_t )((void *)0))) {
    {
#line 684
    tmp = (*(((spif_class_t )spif_linked_list_listclass)->noo))();
#line 684
    pair_list = (spif_list_t )tmp;
    }
  }
#line 686
  current = self->head;
  {
#line 686
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 686
    if (! current) {
#line 686
      goto while_break___0;
    }
    {
#line 688
    tmp___0 = (*((((spif_obj_t )((spif_objpair_t )current->data))->cls)->dup))((spif_objpair_t )current->data);
#line 688
    (*(((spif_listclass_t )pair_list->cls)->append))(pair_list, (spif_obj_t )tmp___0);
#line 686
    current = current->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 690
  return (pair_list);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_list_t spif_dlinked_list_get_values(spif_dlinked_list_t self , spif_list_t value_list ) 
{ 
  spif_dlinked_list_item_t current ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 698
      if (libast_debug_level >= 1U) {
        {
#line 698
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_get_values",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           698, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 698
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_get_values",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             698, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 698
      return ((spif_list_t )((void *)0));
    }
#line 698
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 699
  if ((unsigned long )value_list == (unsigned long )((spif_list_t )((void *)0))) {
    {
#line 700
    tmp = (*(((spif_class_t )spif_linked_list_listclass)->noo))();
#line 700
    value_list = (spif_list_t )tmp;
    }
  }
#line 702
  current = self->head;
  {
#line 702
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 702
    if (! current) {
#line 702
      goto while_break___0;
    }
    {
#line 704
    tmp___0 = (*(((((spif_objpair_t )current->data)->value)->cls)->dup))(((spif_objpair_t )current->data)->value);
#line 704
    (*(((spif_listclass_t )value_list->cls)->append))(value_list, (spif_obj_t )tmp___0);
#line 702
    current = current->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 706
  return (value_list);
}
}
#line 709 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_has_key(spif_dlinked_list_t self , spif_obj_t key ) 
{ 
  int tmp___0 ;
  spif_obj_t tmp___1 ;

  {
  {
#line 712
  tmp___1 = spif_dlinked_list_map_get(self, key);
  }
#line 712
  if ((unsigned long )tmp___1 == (unsigned long )((spif_obj_t )((void *)0))) {
#line 712
    tmp___0 = 0;
  } else {
#line 712
    tmp___0 = 1;
  }
#line 712
  return ((spif_bool_t )tmp___0);
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_has_value(spif_dlinked_list_t self , spif_obj_t value ) 
{ 
  spif_dlinked_list_item_t current ;
  spif_objpair_t pair ;
  void *tmp ;

  {
  {
#line 720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 720
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 720
      if (libast_debug_level >= 1U) {
        {
#line 720
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_has_value",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           720, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 720
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_has_value",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             720, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 720
      return ((spif_bool_t )0);
    }
#line 720
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 722
  current = self->head;
  {
#line 722
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 722
    if (! current) {
#line 722
      goto while_break___0;
    }
#line 726
    pair = (spif_objpair_t )current->data;
#line 727
    if ((unsigned long )value == (unsigned long )((spif_obj_t )((void *)0))) {
#line 727
      if ((unsigned long )pair->value == (unsigned long )((spif_obj_t )((void *)0))) {
#line 728
        return ((spif_bool_t )1);
      } else {
#line 727
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 729
      tmp = (*(((pair->value)->cls)->comp))(pair->value, value);
      }
#line 729
      if ((int )((spif_cmp_t )tmp) == 0) {
#line 730
        return ((spif_bool_t )1);
      }
    }
#line 722
    current = current->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 733
  return ((spif_bool_t )0);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_listidx_t spif_dlinked_list_index(spif_dlinked_list_t self , spif_obj_t obj ) 
{ 
  spif_listidx_t i ;
  spif_dlinked_list_item_t current ;
  void *tmp ;
  spif_listidx_t tmp___0 ;

  {
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 742
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 742
      if (libast_debug_level >= 1U) {
        {
#line 742
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_index",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           742, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 742
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_index",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             742, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 742
      return (-1);
    }
#line 742
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 743
  current = self->head;
#line 743
  i = 0;
  {
#line 743
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 743
    if (current) {
      {
#line 743
      tmp = (*((obj->cls)->comp))(obj, current->data);
      }
#line 743
      if ((int )((spif_cmp_t )tmp) == 0) {
#line 743
        goto while_break___0;
      }
    } else {
#line 743
      goto while_break___0;
    }
#line 743
    i ++;
#line 743
    current = current->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 744
  if (current) {
#line 744
    tmp___0 = i;
  } else {
#line 744
    tmp___0 = -1;
  }
#line 744
  return (tmp___0);
}
}
#line 747 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_insert(spif_dlinked_list_t self , spif_obj_t obj ) 
{ 
  spif_dlinked_list_item_t item ;
  spif_dlinked_list_item_t current ;
  spif_dlinked_list_item_t tmp ;
  spif_cmp_t tmp___0 ;
  spif_cmp_t tmp___1 ;
  spif_cmp_t tmp___2 ;

  {
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 752
      if (libast_debug_level >= 1U) {
        {
#line 752
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_insert",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           752, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 752
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_insert",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             752, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 752
      return ((spif_bool_t )0);
    }
#line 752
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 753
  item = spif_dlinked_list_item_new();
#line 754
  spif_dlinked_list_item_set_data(item, obj);
  }
#line 756
  if ((unsigned long )self->head == (unsigned long )((spif_dlinked_list_item_t )((void *)0))) {
#line 757
    tmp = item;
#line 757
    self->tail = tmp;
#line 757
    self->head = tmp;
  } else {
    {
#line 758
    tmp___2 = spif_dlinked_list_item_comp(item, self->head);
    }
#line 758
    if ((int )tmp___2 == -1) {
#line 759
      item->next = self->head;
#line 760
      (self->head)->prev = item;
#line 761
      self->head = item;
    } else {
      {
#line 762
      tmp___1 = spif_dlinked_list_item_comp(item, self->tail);
      }
#line 762
      if ((int )tmp___1 == 1) {
#line 763
        item->prev = self->tail;
#line 764
        (self->tail)->next = item;
#line 765
        self->tail = item;
      } else {
#line 767
        current = self->head;
        {
#line 767
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 767
          if (current->next) {
            {
#line 767
            tmp___0 = spif_dlinked_list_item_comp(item, current->next);
            }
#line 767
            if (! ((int )tmp___0 == 1)) {
#line 767
              goto while_break___0;
            }
          } else {
#line 767
            goto while_break___0;
          }
#line 767
          current = current->next;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 770
        item->next = current->next;
#line 771
        item->prev = current;
#line 772
        (current->next)->prev = item;
#line 773
        current->next = item;
      }
    }
  }
#line 775
  (self->len) ++;
#line 776
  return ((spif_bool_t )1);
}
}
#line 779 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_insert_at(spif_dlinked_list_t self , spif_obj_t obj ,
                                               spif_listidx_t idx ) 
{ 
  spif_listidx_t i ;
  spif_dlinked_list_item_t item ;
  spif_dlinked_list_item_t current ;
  time_t tmp ;
  spif_bool_t tmp___0 ;
  spif_bool_t tmp___1 ;
  spif_bool_t tmp___2 ;

  {
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 785
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 785
      if (libast_debug_level >= 1U) {
        {
#line 785
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_insert_at",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           785, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 785
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_insert_at",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             785, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 785
      return ((spif_bool_t )0);
    }
#line 785
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 786
  if (idx < 0) {
#line 788
    idx += self->len;
  }
  {
#line 790
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 790
    if (! (idx + 1 > 0)) {
#line 790
      if (libast_debug_level >= 1U) {
        {
#line 790
        tmp = time((time_t *)((void *)0));
#line 790
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                790, "spif_dlinked_list_insert_at");
#line 790
        libast_dprintf("REQUIRE failed:  %s\n", "(idx + 1) > 0");
        }
      }
#line 790
      return ((spif_bool_t )0);
    }
#line 790
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 792
  if (idx == 0) {
    {
#line 793
    tmp___0 = spif_dlinked_list_prepend(self, obj);
    }
#line 793
    return (tmp___0);
  } else
#line 792
  if ((unsigned long )self->head == (unsigned long )((spif_dlinked_list_item_t )((void *)0))) {
    {
#line 793
    tmp___0 = spif_dlinked_list_prepend(self, obj);
    }
#line 793
    return (tmp___0);
  } else
#line 794
  if (idx == self->len - 1) {
    {
#line 795
    tmp___1 = spif_dlinked_list_append(self, obj);
    }
#line 795
    return (tmp___1);
  } else
#line 794
  if ((unsigned long )self->tail == (unsigned long )((spif_dlinked_list_item_t )((void *)0))) {
    {
#line 795
    tmp___1 = spif_dlinked_list_append(self, obj);
    }
#line 795
    return (tmp___1);
  } else
#line 796
  if (idx > self->len) {
#line 797
    i = self->len;
    {
#line 797
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 797
      if (! (i < idx)) {
#line 797
        goto while_break___1;
      }
      {
#line 798
      spif_dlinked_list_append(self, (spif_obj_t )((void *)0));
#line 797
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 800
    tmp___2 = spif_dlinked_list_append(self, obj);
    }
#line 800
    return (tmp___2);
  } else
#line 801
  if (idx > self->len / 2) {
#line 802
    current = self->tail;
#line 802
    i = self->len - 1;
    {
#line 802
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 802
      if (current->prev) {
#line 802
        if (! (i > idx)) {
#line 802
          goto while_break___2;
        }
      } else {
#line 802
        goto while_break___2;
      }
#line 802
      i --;
#line 802
      current = current->prev;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 803
    if (i != idx) {
#line 804
      return ((spif_bool_t )0);
    }
  } else {
#line 807
    current = self->head;
#line 807
    i = 1;
    {
#line 807
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 807
      if (current->next) {
#line 807
        if (! (i < idx)) {
#line 807
          goto while_break___3;
        }
      } else {
#line 807
        goto while_break___3;
      }
#line 807
      i ++;
#line 807
      current = current->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 808
    if (i != idx) {
#line 809
      return ((spif_bool_t )0);
    }
  }
  {
#line 812
  item = spif_dlinked_list_item_new();
#line 813
  spif_dlinked_list_item_set_data(item, obj);
#line 815
  item->next = current->next;
#line 816
  item->prev = current;
#line 817
  (current->next)->prev = item;
#line 818
  current->next = item;
#line 819
  (self->len) ++;
  }
#line 820
  return ((spif_bool_t )1);
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_iterator_t spif_dlinked_list_iterator(spif_dlinked_list_t self ) 
{ 
  spif_dlinked_list_iterator_t tmp ;

  {
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 826
      if (libast_debug_level >= 1U) {
        {
#line 826
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           826, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 826
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             826, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 826
      return ((spif_iterator_t )((void *)0));
    }
#line 826
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 827
  tmp = spif_dlinked_list_iterator_new(self);
  }
#line 827
  return ((spif_iterator_t )tmp);
}
}
#line 830 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_prepend(spif_dlinked_list_t self , spif_obj_t obj ) 
{ 
  spif_dlinked_list_item_t item ;
  spif_dlinked_list_item_t current ;
  spif_dlinked_list_item_t tmp ;

  {
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 835
      if (libast_debug_level >= 1U) {
        {
#line 835
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_prepend",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           835, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 835
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_prepend",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             835, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 835
      return ((spif_bool_t )0);
    }
#line 835
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 837
  item = spif_dlinked_list_item_new();
#line 838
  spif_dlinked_list_item_set_data(item, obj);
  }
#line 841
  if (self->head) {
#line 842
    current = self->head;
#line 843
    self->head = item;
#line 844
    current->prev = item;
#line 845
    item->next = current;
  } else {
#line 847
    tmp = item;
#line 847
    self->tail = tmp;
#line 847
    self->head = tmp;
  }
#line 849
  (self->len) ++;
#line 850
  return ((spif_bool_t )1);
}
}
#line 853 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_obj_t spif_dlinked_list_remove(spif_dlinked_list_t self , spif_obj_t item ) 
{ 
  spif_dlinked_list_item_t current ;
  spif_dlinked_list_item_t tmp ;
  void *tmp___0 ;

  {
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 858
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 858
      if (libast_debug_level >= 1U) {
        {
#line 858
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_remove",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           858, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 858
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_remove",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             858, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 858
      return ((spif_obj_t )((void *)0));
    }
#line 858
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 859
  if ((unsigned long )self->head == (unsigned long )((spif_dlinked_list_item_t )((void *)0))) {
#line 860
    return ((spif_obj_t )((void *)0));
  }
#line 863
  current = self->head;
  {
#line 863
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 863
    if (current) {
      {
#line 863
      tmp___0 = (*((item->cls)->comp))(item, current->data);
      }
#line 863
      if ((int )((spif_cmp_t )tmp___0) == 0) {
#line 863
        goto while_break___0;
      }
    } else {
#line 863
      goto while_break___0;
    }
#line 863
    current = current->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 864
  if ((unsigned long )current == (unsigned long )((spif_dlinked_list_item_t )((void *)0))) {
#line 865
    return ((spif_obj_t )((void *)0));
  }
#line 867
  tmp = current;
#line 868
  if (! ((unsigned long )tmp->prev == (unsigned long )((spif_dlinked_list_item_t )((void *)0)))) {
#line 869
    (tmp->prev)->next = tmp->next;
  }
#line 871
  if (! ((unsigned long )tmp->next == (unsigned long )((spif_dlinked_list_item_t )((void *)0)))) {
#line 872
    (tmp->next)->prev = tmp->prev;
  }
#line 874
  if ((unsigned long )tmp == (unsigned long )self->head) {
#line 875
    self->head = tmp->next;
  }
#line 877
  if ((unsigned long )tmp == (unsigned long )self->tail) {
#line 878
    self->tail = tmp->prev;
  }
  {
#line 880
  item = tmp->data;
#line 881
  tmp->data = (spif_obj_t )((void *)0);
#line 882
  spif_dlinked_list_item_del(tmp);
#line 884
  (self->len) --;
  }
#line 885
  return (item);
}
}
#line 888 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_obj_t spif_dlinked_list_map_remove(spif_dlinked_list_t self , spif_obj_t item ) 
{ 
  spif_dlinked_list_item_t current ;
  spif_dlinked_list_item_t tmp ;
  time_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 893
  while (1) {
    while_continue: /* CIL Label */ ;
#line 893
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 893
      if (libast_debug_level >= 1U) {
        {
#line 893
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_map_remove",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           893, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 893
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_map_remove",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             893, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 893
      return ((spif_obj_t )((void *)0));
    }
#line 893
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 894
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 894
    if (! (! ((unsigned long )item == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 894
      if (libast_debug_level >= 1U) {
        {
#line 894
        tmp___0 = time((time_t *)((void *)0));
#line 894
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                894, "spif_dlinked_list_map_remove");
#line 894
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(item)");
        }
      }
#line 894
      return ((spif_obj_t )((void *)0));
    }
#line 894
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 895
  if ((unsigned long )self->head == (unsigned long )((spif_dlinked_list_item_t )((void *)0))) {
#line 896
    return ((spif_obj_t )((void *)0));
  } else {
    {
#line 897
    tmp___2 = (*((((self->head)->data)->cls)->comp))((self->head)->data, item);
    }
#line 897
    if ((int )((spif_cmp_t )tmp___2) == 0) {
#line 898
      tmp = self->head;
#line 899
      self->head = (self->head)->next;
    } else {
#line 901
      current = self->head;
      {
#line 901
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 901
        if (current->next) {
          {
#line 901
          tmp___1 = (*((((current->next)->data)->cls)->comp))((current->next)->data,
                                                              item);
          }
#line 901
          if ((int )((spif_cmp_t )tmp___1) == 0) {
#line 901
            goto while_break___1;
          }
        } else {
#line 901
          goto while_break___1;
        }
#line 901
        current = current->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 902
      if (current->next) {
#line 903
        tmp = current->next;
#line 904
        current->next = (current->next)->next;
      } else {
#line 906
        return ((spif_obj_t )((void *)0));
      }
    }
  }
  {
#line 909
  item = tmp->data;
#line 910
  tmp->data = (spif_obj_t )((void *)0);
#line 911
  spif_dlinked_list_item_del(tmp);
#line 913
  (self->len) --;
  }
#line 914
  return (item);
}
}
#line 917 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_obj_t spif_dlinked_list_remove_at(spif_dlinked_list_t self , spif_listidx_t idx ) 
{ 
  spif_listidx_t i ;
  spif_dlinked_list_item_t current ;
  spif_obj_t tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 924
      if (libast_debug_level >= 1U) {
        {
#line 924
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_remove_at",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           924, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 924
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_remove_at",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             924, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 924
      return ((spif_obj_t )((void *)0));
    }
#line 924
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 925
  if ((unsigned long )self->head == (unsigned long )((spif_dlinked_list_item_t )((void *)0))) {
#line 926
    return ((spif_obj_t )((void *)0));
  }
#line 929
  if (idx < 0) {
#line 931
    idx += self->len;
  }
  {
#line 933
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 933
    if (! (idx >= 0)) {
#line 933
      if (libast_debug_level >= 1U) {
        {
#line 933
        tmp___0 = time((time_t *)((void *)0));
#line 933
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                933, "spif_dlinked_list_remove_at");
#line 933
        libast_dprintf("REQUIRE failed:  %s\n", "idx >= 0");
        }
      }
#line 933
      return ((spif_obj_t )((void *)0));
    }
#line 933
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 934
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 934
    if (! (idx < self->len)) {
#line 934
      if (libast_debug_level >= 1U) {
        {
#line 934
        tmp___1 = time((time_t *)((void *)0));
#line 934
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                934, "spif_dlinked_list_remove_at");
#line 934
        libast_dprintf("REQUIRE failed:  %s\n", "idx < self->len");
        }
      }
#line 934
      return ((spif_obj_t )((void *)0));
    }
#line 934
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 936
  if (idx > self->len / 2) {
#line 937
    current = self->tail;
#line 937
    i = self->len - 1;
    {
#line 937
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 937
      if (current) {
#line 937
        if (! (i > idx)) {
#line 937
          goto while_break___2;
        }
      } else {
#line 937
        goto while_break___2;
      }
#line 937
      i --;
#line 937
      current = current->prev;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 939
    current = self->head;
#line 939
    i = 0;
    {
#line 939
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 939
      if (current) {
#line 939
        if (! (i < idx)) {
#line 939
          goto while_break___3;
        }
      } else {
#line 939
        goto while_break___3;
      }
#line 939
      i ++;
#line 939
      current = current->next;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 942
  if ((unsigned long )current == (unsigned long )((spif_dlinked_list_item_t )((void *)0))) {
#line 943
    return ((spif_obj_t )((void *)0));
  }
#line 945
  if (! ((unsigned long )current->prev == (unsigned long )((spif_dlinked_list_item_t )((void *)0)))) {
#line 946
    (current->prev)->next = current->next;
  }
#line 948
  if (! ((unsigned long )current->next == (unsigned long )((spif_dlinked_list_item_t )((void *)0)))) {
#line 949
    (current->next)->prev = current->prev;
  }
#line 951
  if ((unsigned long )current == (unsigned long )self->head) {
#line 952
    self->head = current->next;
  }
#line 954
  if ((unsigned long )current == (unsigned long )self->tail) {
#line 955
    self->tail = current->prev;
  }
  {
#line 958
  tmp = spif_dlinked_list_item_get_data(current);
#line 959
  current->data = (spif_obj_t )((void *)0);
#line 960
  spif_dlinked_list_item_del(current);
#line 962
  (self->len) --;
  }
#line 963
  return (tmp);
}
}
#line 966 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_reverse(spif_dlinked_list_t self ) 
{ 
  spif_dlinked_list_item_t current ;
  spif_dlinked_list_item_t tmp ;
  spif_dlinked_list_item_t __tmp ;

  {
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 971
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 971
      if (libast_debug_level >= 1U) {
        {
#line 971
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_reverse",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           971, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 971
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_reverse",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             971, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 971
      return ((spif_bool_t )0);
    }
#line 971
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 972
  current = self->head;
  {
#line 972
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 972
    if (! current) {
#line 972
      goto while_break___0;
    }
#line 973
    tmp = current;
#line 974
    current = current->next;
#line 975
    __tmp = tmp->prev;
#line 975
    tmp->prev = tmp->next;
#line 975
    tmp->next = __tmp;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 977
  self->head = tmp;
#line 978
  return ((spif_bool_t )1);
}
}
#line 981 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_set(spif_dlinked_list_t self , spif_obj_t key ,
                                         spif_obj_t value ) 
{ 
  spif_dlinked_list_item_t current ;
  time_t tmp ;
  void *tmp___0 ;
  spif_objpair_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 986
  while (1) {
    while_continue: /* CIL Label */ ;
#line 986
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 986
      if (libast_debug_level >= 1U) {
        {
#line 986
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_set",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           986, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 986
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_set",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             986, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 986
      return ((spif_bool_t )0);
    }
#line 986
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 987
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 987
    if (! (! ((unsigned long )key == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 987
      if (libast_debug_level >= 1U) {
        {
#line 987
        tmp = time((time_t *)((void *)0));
#line 987
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                987, "spif_dlinked_list_set");
#line 987
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(key)");
        }
      }
#line 987
      return ((spif_bool_t )0);
    }
#line 987
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 989
  if (! ((unsigned long )key == (unsigned long )((spif_obj_t )((void *)0)))) {
#line 989
    if ((unsigned long )key->cls == (unsigned long )spif_objpair_class) {
#line 989
      if ((unsigned long )value == (unsigned long )((spif_obj_t )((void *)0))) {
#line 990
        value = ((spif_objpair_t )key)->value;
#line 991
        key = ((spif_objpair_t )key)->key;
      }
    }
  }
#line 993
  current = self->head;
  {
#line 993
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 993
    if (! current) {
#line 993
      goto while_break___1;
    }
    {
#line 994
    tmp___0 = (*(((current->data)->cls)->comp))(current->data, key);
    }
#line 994
    if ((int )((spif_cmp_t )tmp___0) == 0) {
#line 995
      goto while_break___1;
    }
#line 993
    current = current->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 999
  if ((unsigned long )current == (unsigned long )((spif_dlinked_list_item_t )((void *)0))) {
    {
#line 1000
    tmp___1 = spif_objpair_new_from_both(key, value);
#line 1000
    spif_dlinked_list_insert(self, (spif_obj_t )tmp___1);
    }
#line 1001
    return ((spif_bool_t )0);
  } else {
    {
#line 1003
    tmp___2 = (*((value->cls)->dup))(value);
#line 1003
    spif_objpair_set_value((spif_objpair_t )current->data, (spif_obj_t )tmp___2);
    }
#line 1004
    return ((spif_bool_t )1);
  }
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_obj_t *spif_dlinked_list_to_array(spif_dlinked_list_t self ) 
{ 
  spif_obj_t *tmp ;
  spif_dlinked_list_item_t current ;
  spif_listidx_t i ;
  void *tmp___0 ;
  spif_obj_t tmp___1 ;

  {
  {
#line 1015
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1015
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 1015
      if (libast_debug_level >= 1U) {
        {
#line 1015
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_to_array",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           1015, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 1015
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_to_array",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             1015, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 1015
      return ((spif_obj_t *)((void *)0));
    }
#line 1015
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1016
  tmp___0 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 1016
  tmp = (spif_obj_t *)tmp___0;
#line 1017
  i = 0;
#line 1017
  current = self->head;
  }
  {
#line 1017
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1017
    if (! (i < self->len)) {
#line 1017
      goto while_break___0;
    }
    {
#line 1018
    tmp___1 = spif_dlinked_list_item_get_data(current);
#line 1018
    *(tmp + i) = tmp___1;
#line 1017
    current = current->next;
#line 1017
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1020
  return (tmp);
}
}
#line 1023 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_listidx_t spif_dlinked_list_get_len(spif_dlinked_list_t self ) 
{ 


  {
#line 1023
  return (self->len);
}
}
#line 1023 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_bool_t spif_dlinked_list_set_len(spif_dlinked_list_t self , spif_listidx_t new_len ) 
{ 


  {
#line 1023
  self->len = new_len;
#line 1023
  return ((spif_bool_t )1);
}
}
#line 1024 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_dlinked_list_item_t spif_dlinked_list_get_head(spif_dlinked_list_t self ) 
{ 


  {
#line 1024
  return (self->head);
}
}
#line 1024 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_bool_t spif_dlinked_list_set_head(spif_dlinked_list_t self , spif_dlinked_list_item_t new_head ) 
{ 


  {
#line 1024
  self->head = new_head;
#line 1024
  return ((spif_bool_t )1);
}
}
#line 1025 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_dlinked_list_item_t spif_dlinked_list_get_tail(spif_dlinked_list_t self ) 
{ 


  {
#line 1025
  return (self->tail);
}
}
#line 1025 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_bool_t spif_dlinked_list_set_tail(spif_dlinked_list_t self , spif_dlinked_list_item_t new_tail ) 
{ 


  {
#line 1025
  self->tail = new_tail;
#line 1025
  return ((spif_bool_t )1);
}
}
#line 1028 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_dlinked_list_iterator_t spif_dlinked_list_iterator_new(spif_dlinked_list_t subject ) 
{ 
  spif_dlinked_list_iterator_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 1033
  tmp = malloc(sizeof(spif_const_dlinked_list_iterator_t ));
#line 1033
  self = (spif_dlinked_list_iterator_t )tmp;
#line 1034
  tmp___0 = spif_dlinked_list_iterator_init(self, subject);
  }
#line 1034
  if (! tmp___0) {
    {
#line 1035
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1035
      free((void *)self);
#line 1035
      self = (spif_dlinked_list_iterator_t )((void *)0);
      }
#line 1035
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1036
    self = (spif_dlinked_list_iterator_t )((void *)0);
  }
#line 1038
  return (self);
}
}
#line 1041 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_iterator_init(spif_dlinked_list_iterator_t self ,
                                                   spif_dlinked_list_t subject ) 
{ 


  {
  {
#line 1044
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1044
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1044
      if (libast_debug_level >= 1U) {
        {
#line 1044
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           1044, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1044
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             1044, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1044
      return ((spif_bool_t )0);
    }
#line 1044
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1046
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_dlinked_list_iteratorclass);
#line 1047
  self->subject = subject;
  }
#line 1048
  if ((unsigned long )((spif_list_t )self->subject) == (unsigned long )((spif_list_t )((void *)0))) {
#line 1049
    self->current = (spif_dlinked_list_item_t )((void *)0);
  } else {
#line 1051
    self->current = (self->subject)->head;
  }
#line 1053
  return ((spif_bool_t )1);
}
}
#line 1056 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_iterator_done(spif_dlinked_list_iterator_t self ) 
{ 


  {
  {
#line 1059
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1059
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1059
      if (libast_debug_level >= 1U) {
        {
#line 1059
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           1059, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1059
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             1059, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1059
      return ((spif_bool_t )0);
    }
#line 1059
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1060
  self->subject = (spif_dlinked_list_t )((void *)0);
#line 1061
  self->current = (spif_dlinked_list_item_t )((void *)0);
#line 1062
  return ((spif_bool_t )1);
}
}
#line 1065 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_iterator_del(spif_dlinked_list_iterator_t self ) 
{ 


  {
  {
#line 1068
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1068
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1068
      if (libast_debug_level >= 1U) {
        {
#line 1068
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           1068, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1068
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             1068, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1068
      return ((spif_bool_t )0);
    }
#line 1068
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1069
  spif_dlinked_list_iterator_done(self);
  }
  {
#line 1070
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1070
    free((void *)self);
#line 1070
    self = (spif_dlinked_list_iterator_t )((void *)0);
    }
#line 1070
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1071
  return ((spif_bool_t )1);
}
}
#line 1074 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_str_t spif_dlinked_list_iterator_show(spif_dlinked_list_iterator_t self ,
                                                  spif_charptr_t name___0 , spif_str_t buff ,
                                                  size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  char *tmp___0 ;

  {
#line 1079
  if ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))) {
    {
#line 1080
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1080
      memset((void *)(tmp), ' ', indent);
      }
#line 1080
      if ((char *)name___0) {
#line 1080
        tmp___0 = (char *)name___0;
      } else {
#line 1080
        tmp___0 = (char *)"<name null>";
      }
      {
#line 1080
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_iterator_t) %s:  { ((spif_iterator_t) NULL) }\n",
               tmp___0);
      }
#line 1080
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 1080
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 1080
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 1080
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1081
    return (buff);
  }
  {
#line 1084
  memset((void *)(tmp), ' ', indent);
#line 1085
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_dlinked_list_iterator_t) %s:  %10p {\n",
           name___0, (spif_ptr_t )self);
  }
#line 1088
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 1089
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 1091
    spif_str_append_from_ptr(buff, tmp);
    }
  }
  {
#line 1094
  buff = spif_dlinked_list_show(self->subject, (spif_charptr_t )"subject", buff, indent + 2UL);
#line 1096
  buff = spif_dlinked_list_item_show(self->current, (spif_charptr_t )"current", buff,
                                     indent + 2UL);
#line 1099
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"}\n");
#line 1100
  spif_str_append_from_ptr(buff, tmp);
  }
#line 1101
  return (buff);
}
}
#line 1104 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_cmp_t spif_dlinked_list_iterator_comp(spif_dlinked_list_iterator_t self ,
                                                  spif_dlinked_list_iterator_t other ) 
{ 
  spif_cmp_t tmp ;

  {
  {
#line 1107
  tmp = spif_dlinked_list_comp(self->subject, other->subject);
  }
#line 1107
  return (tmp);
}
}
#line 1110 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_dlinked_list_iterator_t spif_dlinked_list_iterator_dup(spif_dlinked_list_iterator_t self ) 
{ 
  spif_dlinked_list_iterator_t tmp ;

  {
  {
#line 1115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1115
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1115
      if (libast_debug_level >= 1U) {
        {
#line 1115
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           1115, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1115
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             1115, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1115
      return ((spif_dlinked_list_iterator_t )((void *)0));
    }
#line 1115
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1116
  tmp = spif_dlinked_list_iterator_new(self->subject);
#line 1117
  tmp->current = self->current;
  }
#line 1118
  return (tmp);
}
}
#line 1121 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_classname_t spif_dlinked_list_iterator_type(spif_dlinked_list_iterator_t self ) 
{ 


  {
  {
#line 1124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1124
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1124
      if (libast_debug_level >= 1U) {
        {
#line 1124
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           1124, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1124
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             1124, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1124
      return ((spif_classname_t )((void *)0));
    }
#line 1124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1125
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 1128 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_bool_t spif_dlinked_list_iterator_has_next(spif_dlinked_list_iterator_t self ) 
{ 
  spif_dlinked_list_t subject ;
  time_t tmp ;

  {
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1133
      if (libast_debug_level >= 1U) {
        {
#line 1133
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_has_next",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           1133, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1133
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_has_next",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             1133, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1133
      return ((spif_bool_t )0);
    }
#line 1133
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1134
  subject = self->subject;
  {
#line 1135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1135
    if (! (! ((unsigned long )((spif_list_t )subject) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 1135
      if (libast_debug_level >= 1U) {
        {
#line 1135
        tmp = time((time_t *)((void *)0));
#line 1135
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                1135, "spif_dlinked_list_iterator_has_next");
#line 1135
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_LIST_ISNULL(subject)");
        }
      }
#line 1135
      return ((spif_bool_t )0);
    }
#line 1135
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1136
  if (self->current) {
#line 1137
    return ((spif_bool_t )1);
  } else {
#line 1139
    return ((spif_bool_t )0);
  }
}
}
#line 1143 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
static spif_obj_t spif_dlinked_list_iterator_next(spif_dlinked_list_iterator_t self ) 
{ 
  spif_obj_t tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 1148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1148
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1148
      if (libast_debug_level >= 1U) {
        {
#line 1148
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_next",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                           1148, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1148
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_dlinked_list_iterator_next",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                             1148, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1148
      return ((spif_obj_t )((void *)0));
    }
#line 1148
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1149
    if (! (! ((unsigned long )((spif_list_t )self->subject) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 1149
      if (libast_debug_level >= 1U) {
        {
#line 1149
        tmp___0 = time((time_t *)((void *)0));
#line 1149
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                1149, "spif_dlinked_list_iterator_next");
#line 1149
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_LIST_ISNULL(self->subject)");
        }
      }
#line 1149
      return ((spif_obj_t )((void *)0));
    }
#line 1149
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1150
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1150
    if (! (! ((unsigned long )self->current == (unsigned long )((spif_dlinked_list_item_t )((void *)0))))) {
#line 1150
      if (libast_debug_level >= 1U) {
        {
#line 1150
        tmp___1 = time((time_t *)((void *)0));
#line 1150
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c",
                1150, "spif_dlinked_list_iterator_next");
#line 1150
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_DLINKED_LIST_ITEM_ISNULL(self->current)");
        }
      }
#line 1150
      return ((spif_obj_t )((void *)0));
    }
#line 1150
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1151
  tmp = (self->current)->data;
#line 1152
  self->current = (self->current)->next;
#line 1153
  return (tmp);
}
}
#line 1156 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_dlinked_list_t spif_dlinked_list_iterator_get_subject(spif_dlinked_list_iterator_t self ) 
{ 


  {
#line 1156
  return (self->subject);
}
}
#line 1156 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_bool_t spif_dlinked_list_iterator_set_subject(spif_dlinked_list_iterator_t self ,
                                                   spif_dlinked_list_t new_subject ) 
{ 


  {
#line 1156
  if (! ((unsigned long )((spif_obj_t )self->subject) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 1156
    (*((((spif_obj_t )self->subject)->cls)->del))(self->subject);
    }
  }
#line 1156
  self->subject = new_subject;
#line 1156
  return ((spif_bool_t )1);
}
}
#line 1157 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_dlinked_list_item_t spif_dlinked_list_iterator_get_current(spif_dlinked_list_iterator_t self ) 
{ 


  {
#line 1157
  return (self->current);
}
}
#line 1157 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/dlinked_list.c"
spif_bool_t spif_dlinked_list_iterator_set_current(spif_dlinked_list_iterator_t self ,
                                                   spif_dlinked_list_item_t new_current ) 
{ 


  {
#line 1157
  self->current = new_current;
#line 1157
  return ((spif_bool_t )1);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 382
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,3), __leaf__)) memmem)(void const   *__haystack ,
                                                                                                 size_t __haystacklen ,
                                                                                                 void const   *__needle ,
                                                                                                 size_t __needlelen )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 119 "../include/libast/mbuff.h"
spif_class_t spif_mbuff_class ;
#line 120
spif_mbuffclass_t spif_mbuff_mbuffclass ;
#line 121
spif_mbuff_t spif_mbuff_new(void) ;
#line 122
spif_mbuff_t spif_mbuff_new_from_ptr(spif_byteptr_t old , spif_memidx_t len ) ;
#line 123
spif_mbuff_t spif_mbuff_new_from_buff(spif_byteptr_t buff , spif_memidx_t len , spif_memidx_t size ) ;
#line 124
spif_mbuff_t spif_mbuff_new_from_fp(FILE *fp ) ;
#line 125
spif_mbuff_t spif_mbuff_new_from_fd(int fd ) ;
#line 126
spif_bool_t spif_mbuff_del(spif_mbuff_t self ) ;
#line 127
spif_bool_t spif_mbuff_init(spif_mbuff_t self ) ;
#line 128
spif_bool_t spif_mbuff_init_from_ptr(spif_mbuff_t self , spif_byteptr_t old , spif_memidx_t len ) ;
#line 129
spif_bool_t spif_mbuff_init_from_buff(spif_mbuff_t self , spif_byteptr_t buff , spif_memidx_t len ,
                                      spif_memidx_t size ) ;
#line 130
spif_bool_t spif_mbuff_init_from_fp(spif_mbuff_t self , FILE *fp ) ;
#line 131
spif_bool_t spif_mbuff_init_from_fd(spif_mbuff_t self , int fd ) ;
#line 132
spif_bool_t spif_mbuff_done(spif_mbuff_t self ) ;
#line 133
spif_str_t spif_mbuff_show(spif_mbuff_t self , spif_byteptr_t name___0 , spif_str_t buff ,
                           size_t indent ) ;
#line 134
spif_cmp_t spif_mbuff_comp(spif_mbuff_t self , spif_mbuff_t other ) ;
#line 135
spif_mbuff_t spif_mbuff_dup(spif_mbuff_t self ) ;
#line 136
spif_classname_t spif_mbuff_type(spif_mbuff_t self ) ;
#line 138
spif_bool_t spif_mbuff_append(spif_mbuff_t self , spif_mbuff_t other ) ;
#line 139
spif_bool_t spif_mbuff_append_from_ptr(spif_mbuff_t self , spif_byteptr_t other ,
                                       spif_memidx_t len ) ;
#line 140
spif_bool_t spif_mbuff_clear(spif_mbuff_t self , spif_uint8_t c ) ;
#line 141
spif_cmp_t spif_mbuff_cmp(spif_mbuff_t self , spif_mbuff_t other ) ;
#line 142
spif_cmp_t spif_mbuff_cmp_with_ptr(spif_mbuff_t self , spif_byteptr_t other , spif_memidx_t len ) ;
#line 143
spif_memidx_t spif_mbuff_find(spif_mbuff_t self , spif_mbuff_t other ) ;
#line 144
spif_memidx_t spif_mbuff_find_from_ptr(spif_mbuff_t self , spif_byteptr_t other ,
                                       spif_memidx_t len ) ;
#line 145
spif_memidx_t spif_mbuff_index(spif_mbuff_t self , spif_uint8_t c ) ;
#line 146
spif_cmp_t spif_mbuff_ncmp(spif_mbuff_t self , spif_mbuff_t other , spif_memidx_t cnt ) ;
#line 147
spif_cmp_t spif_mbuff_ncmp_with_ptr(spif_mbuff_t self , spif_byteptr_t other , spif_memidx_t cnt ) ;
#line 148
spif_bool_t spif_mbuff_prepend(spif_mbuff_t self , spif_mbuff_t other ) ;
#line 149
spif_bool_t spif_mbuff_prepend_from_ptr(spif_mbuff_t self , spif_byteptr_t other ,
                                        spif_memidx_t len ) ;
#line 150
spif_bool_t spif_mbuff_reverse(spif_mbuff_t self ) ;
#line 151
spif_memidx_t spif_mbuff_rindex(spif_mbuff_t self , spif_uint8_t c ) ;
#line 152
spif_bool_t spif_mbuff_splice(spif_mbuff_t self , spif_memidx_t idx , spif_memidx_t cnt ,
                              spif_mbuff_t other ) ;
#line 153
spif_bool_t spif_mbuff_splice_from_ptr(spif_mbuff_t self , spif_memidx_t idx , spif_memidx_t cnt ,
                                       spif_byteptr_t other , spif_memidx_t len ) ;
#line 154
spif_mbuff_t spif_mbuff_subbuff(spif_mbuff_t self , spif_memidx_t idx , spif_memidx_t cnt ) ;
#line 155
spif_byteptr_t spif_mbuff_subbuff_to_ptr(spif_mbuff_t self , spif_memidx_t idx , spif_memidx_t cnt ) ;
#line 156
spif_bool_t spif_mbuff_trim(spif_mbuff_t self ) ;
#line 157
spif_memidx_t spif_mbuff_get_size(spif_mbuff_t self ) ;
#line 157
spif_bool_t spif_mbuff_set_size(spif_mbuff_t self , spif_memidx_t new_size ) ;
#line 158
spif_memidx_t spif_mbuff_get_len(spif_mbuff_t self ) ;
#line 158
spif_bool_t spif_mbuff_set_len(spif_mbuff_t self , spif_memidx_t new_len ) ;
#line 2739 "../include/libast.h"
spif_charptr_t spiftool_safe_str(spif_charptr_t str , unsigned short len ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
static spif_const_mbuffclass_t mb_class  = 
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
     {{(spif_charptr_t )"!spif_mbuff_t!", (void *(*)())(& spif_mbuff_new), (void *(*)())(& spif_mbuff_init),
     (void *(*)())(& spif_mbuff_done), (void *(*)())(& spif_mbuff_del), (void *(*)())(& spif_mbuff_show),
     (void *(*)())(& spif_mbuff_comp), (void *(*)())(& spif_mbuff_dup), (void *(*)())(& spif_mbuff_type)},
    (void *(*)())(& spif_mbuff_new_from_ptr), (void *(*)())(& spif_mbuff_new_from_buff),
    (void *(*)())(& spif_mbuff_new_from_fp), (void *(*)())(& spif_mbuff_new_from_fd),
    (void *(*)())(& spif_mbuff_init_from_ptr), (void *(*)())(& spif_mbuff_init_from_buff),
    (void *(*)())(& spif_mbuff_init_from_fp), (void *(*)())(& spif_mbuff_init_from_fd),
    (void *(*)())(& spif_mbuff_append), (void *(*)())(& spif_mbuff_append_from_ptr),
    (void *(*)())(& spif_mbuff_clear), (void *(*)())(& spif_mbuff_cmp), (void *(*)())(& spif_mbuff_cmp_with_ptr),
    (void *(*)())(& spif_mbuff_find), (void *(*)())(& spif_mbuff_find_from_ptr), (void *(*)())(& spif_mbuff_index),
    (void *(*)())(& spif_mbuff_ncmp), (void *(*)())(& spif_mbuff_ncmp_with_ptr), (void *(*)())(& spif_mbuff_prepend),
    (void *(*)())(& spif_mbuff_prepend_from_ptr), (void *(*)())(& spif_mbuff_reverse),
    (void *(*)())(& spif_mbuff_rindex), (void *(*)())(& spif_mbuff_splice), (void *(*)())(& spif_mbuff_splice_from_ptr),
    (void *(*)())(& spif_mbuff_subbuff), (void *(*)())(& spif_mbuff_subbuff_to_ptr),
    (void *(*)())(& spif_mbuff_trim)};
#line 73 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_class_t spif_mbuff_class  =    (spif_class_t )(& mb_class);
#line 74 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_mbuffclass_t spif_mbuff_mbuffclass  =    & mb_class;
#line 77 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_mbuff_t spif_mbuff_new(void) 
{ 
  spif_mbuff_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 82
  tmp = malloc(sizeof(spif_const_mbuff_t ));
#line 82
  self = (spif_mbuff_t )tmp;
#line 83
  tmp___0 = spif_mbuff_init(self);
  }
#line 83
  if (! tmp___0) {
    {
#line 84
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 84
      free((void *)self);
#line 84
      self = (spif_mbuff_t )((void *)0);
      }
#line 84
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 85
    self = (spif_mbuff_t )((void *)0);
  }
#line 87
  return (self);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_mbuff_t spif_mbuff_new_from_ptr(spif_byteptr_t old , spif_memidx_t len ) 
{ 
  spif_mbuff_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 95
  tmp = malloc(sizeof(spif_const_mbuff_t ));
#line 95
  self = (spif_mbuff_t )tmp;
#line 96
  tmp___0 = spif_mbuff_init_from_ptr(self, old, len);
  }
#line 96
  if (! tmp___0) {
    {
#line 97
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 97
      free((void *)self);
#line 97
      self = (spif_mbuff_t )((void *)0);
      }
#line 97
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 98
    self = (spif_mbuff_t )((void *)0);
  }
#line 100
  return (self);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_mbuff_t spif_mbuff_new_from_buff(spif_byteptr_t buff , spif_memidx_t len , spif_memidx_t size ) 
{ 
  spif_mbuff_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 108
  tmp = malloc(sizeof(spif_const_mbuff_t ));
#line 108
  self = (spif_mbuff_t )tmp;
#line 109
  tmp___0 = spif_mbuff_init_from_buff(self, buff, len, size);
  }
#line 109
  if (! tmp___0) {
    {
#line 110
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 110
      free((void *)self);
#line 110
      self = (spif_mbuff_t )((void *)0);
      }
#line 110
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 111
    self = (spif_mbuff_t )((void *)0);
  }
#line 113
  return (self);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_mbuff_t spif_mbuff_new_from_fp(FILE *fp ) 
{ 
  spif_mbuff_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 121
  tmp = malloc(sizeof(spif_const_mbuff_t ));
#line 121
  self = (spif_mbuff_t )tmp;
#line 122
  tmp___0 = spif_mbuff_init_from_fp(self, fp);
  }
#line 122
  if (! tmp___0) {
    {
#line 123
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 123
      free((void *)self);
#line 123
      self = (spif_mbuff_t )((void *)0);
      }
#line 123
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 124
    self = (spif_mbuff_t )((void *)0);
  }
#line 126
  return (self);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_mbuff_t spif_mbuff_new_from_fd(int fd ) 
{ 
  spif_mbuff_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 134
  tmp = malloc(sizeof(spif_const_mbuff_t ));
#line 134
  self = (spif_mbuff_t )tmp;
#line 135
  tmp___0 = spif_mbuff_init_from_fd(self, fd);
  }
#line 135
  if (! tmp___0) {
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 136
      free((void *)self);
#line 136
      self = (spif_mbuff_t )((void *)0);
      }
#line 136
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 137
    self = (spif_mbuff_t )((void *)0);
  }
#line 139
  return (self);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_init(spif_mbuff_t self ) 
{ 


  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 145
      if (libast_debug_level >= 1U) {
        {
#line 145
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           145, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 145
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             145, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 145
      return ((spif_bool_t )0);
    }
#line 145
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_mbuff_mbuffclass);
#line 148
  self->buff = (spif_byteptr_t )((void *)0);
#line 149
  self->len = (spif_memidx_t )0;
#line 150
  self->size = (spif_memidx_t )0;
  }
#line 151
  return ((spif_bool_t )1);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_init_from_ptr(spif_mbuff_t self , spif_byteptr_t old , spif_memidx_t len ) 
{ 
  time_t tmp ;
  spif_bool_t tmp___0 ;
  spif_memidx_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 157
      if (libast_debug_level >= 1U) {
        {
#line 157
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           157, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 157
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             157, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 157
      return ((spif_bool_t )0);
    }
#line 157
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 158
    if (! ((unsigned long )old != (unsigned long )((spif_byteptr_t )((void *)0)))) {
#line 158
      if (libast_debug_level >= 1U) {
        {
#line 158
        tmp = time((time_t *)((void *)0));
#line 158
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                158, "spif_mbuff_init_from_ptr");
#line 158
        libast_dprintf("REQUIRE failed:  %s\n", "(old != SPIF_NULL_TYPE(byteptr))");
        }
      }
      {
#line 158
      tmp___0 = spif_mbuff_init(self);
      }
#line 158
      return (tmp___0);
    }
#line 158
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 160
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_mbuff_mbuffclass);
#line 161
  tmp___1 = len;
#line 161
  self->size = tmp___1;
#line 161
  self->len = tmp___1;
#line 162
  tmp___2 = malloc((size_t )self->size);
#line 162
  self->buff = (spif_byteptr_t )tmp___2;
#line 163
  memcpy((void */* __restrict  */)self->buff, (void const   */* __restrict  */)old,
         (size_t )self->len);
  }
#line 164
  return ((spif_bool_t )1);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_init_from_buff(spif_mbuff_t self , spif_byteptr_t buff , spif_memidx_t len ,
                                      spif_memidx_t size ) 
{ 
  spif_memidx_t aa ;
  spif_memidx_t bb ;
  spif_memidx_t tmp ;
  void *tmp___0 ;

  {
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 170
      if (libast_debug_level >= 1U) {
        {
#line 170
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init_from_buff",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           170, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 170
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init_from_buff",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             170, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 170
      return ((spif_bool_t )0);
    }
#line 170
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 172
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_mbuff_mbuffclass);
  }
#line 173
  if ((unsigned long )buff != (unsigned long )((spif_byteptr_t )((void *)0))) {
#line 174
    self->len = len;
  } else {
#line 176
    self->len = (spif_memidx_t )0;
  }
#line 178
  aa = size;
#line 178
  bb = self->len;
#line 178
  if (aa > bb) {
#line 178
    tmp = aa;
  } else {
#line 178
    tmp = bb;
  }
  {
#line 178
  self->size = tmp;
#line 179
  tmp___0 = malloc((size_t )self->size);
#line 179
  self->buff = (spif_byteptr_t )tmp___0;
  }
#line 180
  if ((unsigned long )buff != (unsigned long )((spif_byteptr_t )((void *)0))) {
    {
#line 181
    memcpy((void */* __restrict  */)self->buff, (void const   */* __restrict  */)buff,
           (size_t )self->len);
    }
  }
#line 183
  return ((spif_bool_t )1);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_init_from_fp(spif_mbuff_t self , FILE *fp ) 
{ 
  spif_byteptr_t p ;
  long file_pos ;
  spif_memidx_t file_size ;
  int o ;
  spif_memidx_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 193
      if (libast_debug_level >= 1U) {
        {
#line 193
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init_from_fp",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           193, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 193
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init_from_fp",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             193, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 193
      return ((spif_bool_t )0);
    }
#line 193
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 194
    if (! ((unsigned long )fp != (unsigned long )((FILE *)((void *)0)))) {
#line 194
      if (libast_debug_level >= 1U) {
        {
#line 194
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init_from_fp",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           194, "(fp != SPIF_NULL_TYPE_C(FILE *))");
        }
      } else {
        {
#line 194
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init_from_fp",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             194, "(fp != SPIF_NULL_TYPE_C(FILE *))");
        }
      }
#line 194
      return ((spif_bool_t )0);
    }
#line 194
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 196
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_mbuff_mbuffclass);
#line 198
  file_pos = ftell(fp);
#line 199
  fseek(fp, 0L, 2);
#line 200
  file_size = ftell(fp);
#line 201
  fseek(fp, file_pos, 0);
#line 202
  o = 0;
  }
#line 202
  if (file_size < (spif_memidx_t )o) {
#line 202
    file_size = (spif_memidx_t )o;
  }
#line 203
  if (file_size == 0L) {
    {
#line 204
    spif_mbuff_init(self);
    }
#line 205
    return ((spif_bool_t )0);
  }
  {
#line 207
  tmp = file_size;
#line 207
  self->size = tmp;
#line 207
  self->len = tmp;
#line 208
  tmp___0 = malloc((size_t )self->size);
#line 208
  self->buff = (spif_byteptr_t )tmp___0;
#line 210
  tmp___1 = fread((void */* __restrict  */)p, (size_t )file_size, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 210
  if (tmp___1 < 1UL) {
    {
#line 211
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 211
      free((void *)self->buff);
#line 211
      self->buff = (spif_byteptr_t )((void *)0);
      }
#line 211
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 212
    return ((spif_bool_t )0);
  }
#line 214
  return ((spif_bool_t )1);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_init_from_fd(spif_mbuff_t self , int fd ) 
{ 
  spif_byteptr_t p ;
  off_t file_pos ;
  spif_memidx_t file_size ;
  __off_t tmp ;
  int o ;
  spif_memidx_t tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 224
      if (libast_debug_level >= 1U) {
        {
#line 224
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init_from_fd",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           224, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 224
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init_from_fd",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             224, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 224
      return ((spif_bool_t )0);
    }
#line 224
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 225
    if (! (fd >= 0)) {
#line 225
      if (libast_debug_level >= 1U) {
        {
#line 225
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init_from_fd",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           225, "(fd >= 0)");
        }
      } else {
        {
#line 225
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_init_from_fd",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             225, "(fd >= 0)");
        }
      }
#line 225
      return ((spif_bool_t )0);
    }
#line 225
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 227
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_mbuff_mbuffclass);
#line 229
  file_pos = lseek(fd, (off_t )0, 1);
#line 230
  tmp = lseek(fd, (off_t )0, 2);
#line 230
  file_size = tmp;
#line 231
  lseek(fd, file_pos, 0);
#line 232
  o = 0;
  }
#line 232
  if (file_size < (spif_memidx_t )o) {
#line 232
    file_size = (spif_memidx_t )o;
  }
#line 233
  if (file_size == 0L) {
    {
#line 234
    spif_mbuff_init(self);
    }
#line 235
    return ((spif_bool_t )0);
  }
  {
#line 237
  tmp___0 = file_size;
#line 237
  self->size = tmp___0;
#line 237
  self->len = tmp___0;
#line 238
  tmp___1 = malloc((size_t )self->size);
#line 238
  self->buff = (spif_byteptr_t )tmp___1;
#line 240
  tmp___2 = read(fd, (void *)p, (size_t )file_size);
  }
#line 240
  if (tmp___2 < 1L) {
    {
#line 241
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 241
      free((void *)self->buff);
#line 241
      self->buff = (spif_byteptr_t )((void *)0);
      }
#line 241
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 242
    return ((spif_bool_t )0);
  }
#line 244
  return ((spif_bool_t )1);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_done(spif_mbuff_t self ) 
{ 


  {
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 250
      if (libast_debug_level >= 1U) {
        {
#line 250
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           250, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 250
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             250, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 250
      return ((spif_bool_t )0);
    }
#line 250
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  if (self->size) {
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 252
      free((void *)self->buff);
#line 252
      self->buff = (spif_byteptr_t )((void *)0);
      }
#line 252
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 253
    self->len = (spif_memidx_t )0;
#line 254
    self->size = (spif_memidx_t )0;
#line 255
    self->buff = (spif_byteptr_t )((void *)0);
  }
#line 257
  return ((spif_bool_t )1);
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_del(spif_mbuff_t self ) 
{ 


  {
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 263
      if (libast_debug_level >= 1U) {
        {
#line 263
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           263, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 263
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             263, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 263
      return ((spif_bool_t )0);
    }
#line 263
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  spif_mbuff_done(self);
  }
  {
#line 265
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 265
    free((void *)self);
#line 265
    self = (spif_mbuff_t )((void *)0);
    }
#line 265
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 266
  return ((spif_bool_t )1);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_str_t spif_mbuff_show(spif_mbuff_t self , spif_byteptr_t name___0 , spif_str_t buff ,
                           size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  spif_memidx_t j ;
  char *tmp___0 ;
  spif_memidx_t k ;
  spif_memidx_t l ;
  spif_memidx_t len ;
  size_t tmp___1 ;
  spif_charptr_t tmp___2 ;

  {
#line 275
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 276
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 276
      memset((void *)(tmp), ' ', indent);
      }
#line 276
      if ((char *)name___0) {
#line 276
        tmp___0 = (char *)name___0;
      } else {
#line 276
        tmp___0 = (char *)"<name null>";
      }
      {
#line 276
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_mbuff_t) %s:  { ((spif_mbuff_t) NULL) }\n",
               tmp___0);
      }
#line 276
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 276
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 276
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 276
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 277
    return (buff);
  }
  {
#line 280
  memset((void *)(tmp), ' ', indent);
#line 281
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_mbuff_t) %s:  %10p (length %lu, size %lu) {\n",
           name___0, (spif_ptr_t )self, (spif_ulong_t )self->len, (spif_ulong_t )self->size);
  }
#line 284
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 285
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 287
    spif_str_append_from_ptr(buff, tmp);
    }
  }
  {
#line 290
  memset((void *)(tmp), ' ', indent + 2UL);
#line 291
  j = (spif_memidx_t )0;
  }
  {
#line 291
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 291
    if (! (j < self->len)) {
#line 291
      goto while_break___0;
    }
    {
#line 294
    snprintf((char */* __restrict  */)(((char *)(tmp) + indent) + 2), (sizeof(tmp) - indent) - 2UL,
             (char const   */* __restrict  */)"%0lx    ", j);
#line 295
    tmp___1 = strlen((char const   *)((char *)(tmp)));
#line 295
    len = (spif_memidx_t )tmp___1;
    }
#line 296
    if ((unsigned long )(len + 36L) < sizeof(tmp)) {
#line 297
      if (self->len - j < 8L) {
#line 297
        l = self->len - j;
      } else {
#line 297
        l = (spif_memidx_t )8;
      }
#line 298
      k = (spif_memidx_t )0;
      {
#line 298
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 298
        if (! (k < l)) {
#line 298
          goto while_break___1;
        }
        {
#line 299
        sprintf((char */* __restrict  */)((char *)(tmp) + len), (char const   */* __restrict  */)"%02x ",
                (int )*(self->buff + (j + k)));
#line 298
        k ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 301
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 301
        if (! (k < 8L)) {
#line 301
          goto while_break___2;
        }
        {
#line 302
        strcat((char */* __restrict  */)((char *)(tmp) + len), (char const   */* __restrict  */)"   ");
#line 301
        k ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 304
      tmp___2 = spiftool_safe_str((spif_charptr_t )(self->buff + j), (unsigned short )l);
#line 304
      sprintf((char */* __restrict  */)((char *)(tmp) + len), (char const   */* __restrict  */)"%-8s\n",
              tmp___2);
      }
    }
    {
#line 306
    spif_str_append_from_ptr(buff, tmp);
#line 291
    j += 8L;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 309
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"}\n");
#line 310
  spif_str_append_from_ptr(buff, tmp);
  }
#line 311
  return (buff);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_cmp_t spif_mbuff_comp(spif_mbuff_t self , spif_mbuff_t other ) 
{ 
  spif_cmp_t tmp ;

  {
  {
#line 317
  tmp = spif_mbuff_cmp(self, other);
  }
#line 317
  return (tmp);
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_mbuff_t spif_mbuff_dup(spif_mbuff_t self ) 
{ 
  spif_mbuff_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 325
      if (libast_debug_level >= 1U) {
        {
#line 325
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           325, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 325
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             325, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 325
      return ((spif_mbuff_t )((void *)0));
    }
#line 325
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 326
  tmp___0 = malloc(sizeof(spif_const_mbuff_t ));
#line 326
  tmp = (spif_mbuff_t )tmp___0;
#line 327
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self, sizeof(spif_const_mbuff_t ));
#line 328
  tmp___1 = malloc((size_t )self->size);
#line 328
  tmp->buff = (spif_byteptr_t )tmp___1;
#line 329
  memcpy((void */* __restrict  */)tmp->buff, (void const   */* __restrict  */)self->buff,
         (size_t )self->size);
#line 330
  tmp->len = self->len;
#line 331
  tmp->size = self->size;
  }
#line 332
  return (tmp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_classname_t spif_mbuff_type(spif_mbuff_t self ) 
{ 


  {
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 338
      if (libast_debug_level >= 1U) {
        {
#line 338
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           338, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 338
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             338, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 338
      return ((spif_classname_t )"{ ((spif_classname_t) NULL) }");
    }
#line 338
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_append(spif_mbuff_t self , spif_mbuff_t other ) 
{ 
  time_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  spif_byteptr_t tmp___5 ;

  {
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 345
      if (libast_debug_level >= 1U) {
        {
#line 345
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_append",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           345, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 345
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_append",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             345, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 345
      return ((spif_bool_t )0);
    }
#line 345
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 346
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 346
    if (! (! ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 346
      if (libast_debug_level >= 1U) {
        {
#line 346
        tmp = time((time_t *)((void *)0));
#line 346
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                346, "spif_mbuff_append");
#line 346
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_MBUFF_ISNULL(other)");
        }
      }
#line 346
      return ((spif_bool_t )0);
    }
#line 346
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 347
  if (other->size) {
#line 347
    if (other->len) {
#line 348
      self->size += other->size;
#line 349
      if (self->size) {
#line 349
        if (self->buff) {
          {
#line 349
          tmp___0 = realloc((void *)self->buff, (size_t )self->size);
#line 349
          tmp___2 = tmp___0;
          }
        } else {
          {
#line 349
          tmp___1 = malloc((size_t )self->size);
#line 349
          tmp___2 = tmp___1;
          }
        }
#line 349
        tmp___4 = tmp___2;
      } else {
#line 349
        if (self->buff) {
          {
#line 349
          free((void *)self->buff);
#line 349
          tmp___3 = (void *)0;
          }
        } else {
#line 349
          tmp___3 = (void *)0;
        }
#line 349
        tmp___4 = tmp___3;
      }
#line 349
      self->buff = (spif_byteptr_t )tmp___4;
#line 350
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 350
        tmp___5 = (spif_byteptr_t )"";
      } else {
#line 350
        tmp___5 = other->buff;
      }
      {
#line 350
      memcpy((void */* __restrict  */)(self->buff + self->len), (void const   */* __restrict  */)((spif_byteptr_t const   )tmp___5),
             (size_t )other->len);
#line 351
      self->len += other->len;
      }
    }
  }
#line 353
  return ((spif_bool_t )1);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_append_from_ptr(spif_mbuff_t self , spif_byteptr_t other ,
                                       spif_memidx_t len ) 
{ 
  time_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 359
      if (libast_debug_level >= 1U) {
        {
#line 359
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_append_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           359, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 359
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_append_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             359, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 359
      return ((spif_bool_t )0);
    }
#line 359
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (! ((unsigned long )other != (unsigned long )((spif_byteptr_t )((void *)0)))) {
#line 360
      if (libast_debug_level >= 1U) {
        {
#line 360
        tmp = time((time_t *)((void *)0));
#line 360
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                360, "spif_mbuff_append_from_ptr");
#line 360
        libast_dprintf("REQUIRE failed:  %s\n", "(other != SPIF_NULL_TYPE(byteptr))");
        }
      }
#line 360
      return ((spif_bool_t )0);
    }
#line 360
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 361
  if (len) {
#line 362
    self->size += len;
#line 363
    if (self->size) {
#line 363
      if (self->buff) {
        {
#line 363
        tmp___0 = realloc((void *)self->buff, (size_t )self->size);
#line 363
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 363
        tmp___1 = malloc((size_t )self->size);
#line 363
        tmp___2 = tmp___1;
        }
      }
#line 363
      tmp___4 = tmp___2;
    } else {
#line 363
      if (self->buff) {
        {
#line 363
        free((void *)self->buff);
#line 363
        tmp___3 = (void *)0;
        }
      } else {
#line 363
        tmp___3 = (void *)0;
      }
#line 363
      tmp___4 = tmp___3;
    }
    {
#line 363
    self->buff = (spif_byteptr_t )tmp___4;
#line 364
    memcpy((void */* __restrict  */)(self->buff + self->len), (void const   */* __restrict  */)other,
           (size_t )len);
#line 365
    self->len += len;
    }
  }
#line 367
  return ((spif_bool_t )1);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_clear(spif_mbuff_t self , spif_uint8_t c ) 
{ 


  {
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 373
      if (libast_debug_level >= 1U) {
        {
#line 373
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_clear",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           373, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 373
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_clear",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             373, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 373
      return ((spif_bool_t )0);
    }
#line 373
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  memset((void *)self->buff, (int )c, (size_t )self->len);
  }
#line 375
  return ((spif_bool_t )1);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_cmp_t spif_mbuff_cmp(spif_mbuff_t self , spif_mbuff_t other ) 
{ 
  int c ;
  spif_memidx_t aa ;
  spif_memidx_t bb ;
  spif_memidx_t tmp ;
  spif_byteptr_t tmp___0 ;
  spif_byteptr_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 383
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 383
        return ((spif_cmp_t )0);
      } else {
#line 383
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 383
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 383
      return ((spif_cmp_t )-1);
    } else
#line 383
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 383
      return ((spif_cmp_t )1);
    }
#line 383
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  aa = self->len;
#line 384
  bb = other->len;
#line 384
  if (aa < bb) {
#line 384
    tmp = aa;
  } else {
#line 384
    tmp = bb;
  }
#line 384
  if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 384
    tmp___0 = (spif_byteptr_t )"";
  } else {
#line 384
    tmp___0 = other->buff;
  }
#line 384
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 384
    tmp___1 = (spif_byteptr_t )"";
  } else {
#line 384
    tmp___1 = self->buff;
  }
  {
#line 384
  c = memcmp((void const   *)((spif_byteptr_t const   )tmp___1), (void const   *)((spif_byteptr_t const   )tmp___0),
             (size_t )tmp);
  }
#line 385
  if (c < 0) {
#line 385
    tmp___3 = -1;
  } else {
#line 385
    if (c > 0) {
#line 385
      tmp___2 = 1;
    } else {
#line 385
      tmp___2 = 0;
    }
#line 385
    tmp___3 = tmp___2;
  }
#line 385
  return ((spif_cmp_t )tmp___3);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_cmp_t spif_mbuff_cmp_with_ptr(spif_mbuff_t self , spif_byteptr_t other , spif_memidx_t len ) 
{ 
  int c ;
  spif_byteptr_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 393
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 393
        return ((spif_cmp_t )0);
      } else {
#line 393
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 393
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 393
      return ((spif_cmp_t )-1);
    } else
#line 393
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 393
      return ((spif_cmp_t )1);
    }
#line 393
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 394
    tmp = (spif_byteptr_t )"";
  } else {
#line 394
    tmp = self->buff;
  }
  {
#line 394
  c = memcmp((void const   *)((spif_byteptr_t const   )tmp), (void const   *)other,
             (size_t )len);
  }
#line 395
  if (c < 0) {
#line 395
    tmp___1 = -1;
  } else {
#line 395
    if (c > 0) {
#line 395
      tmp___0 = 1;
    } else {
#line 395
      tmp___0 = 0;
    }
#line 395
    tmp___1 = tmp___0;
  }
#line 395
  return ((spif_cmp_t )tmp___1);
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_memidx_t spif_mbuff_find(spif_mbuff_t self , spif_mbuff_t other ) 
{ 
  spif_byteptr_t tmp ;
  time_t tmp___0 ;
  spif_byteptr_t tmp___1 ;
  spif_byteptr_t tmp___2 ;
  void *tmp___3 ;
  spif_byteptr_t tmp___4 ;

  {
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 403
      if (libast_debug_level >= 1U) {
        {
#line 403
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_find",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           403, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 403
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_find",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             403, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 403
      return ((spif_memidx_t )-1);
    }
#line 403
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 404
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 404
    if (! (! ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 404
      if (libast_debug_level >= 1U) {
        {
#line 404
        tmp___0 = time((time_t *)((void *)0));
#line 404
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                404, "spif_mbuff_find");
#line 404
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_MBUFF_ISNULL(other)");
        }
      }
#line 404
      return ((spif_memidx_t )-1);
    }
#line 404
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 405
  if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 405
    tmp___1 = (spif_byteptr_t )"";
  } else {
#line 405
    tmp___1 = other->buff;
  }
#line 405
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 405
    tmp___2 = (spif_byteptr_t )"";
  } else {
#line 405
    tmp___2 = self->buff;
  }
  {
#line 405
  tmp___3 = memmem((void const   *)((spif_byteptr_t const   )tmp___2), (size_t )self->len,
                   (void const   *)((spif_byteptr_t const   )tmp___1), (size_t )other->len);
#line 405
  tmp = (spif_byteptr_t )tmp___3;
  }
#line 406
  if (tmp) {
#line 407
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 407
      tmp___4 = (spif_byteptr_t )"";
    } else {
#line 407
      tmp___4 = self->buff;
    }
#line 407
    return ((spif_long_t )tmp - (spif_long_t )((spif_byteptr_t const   )tmp___4));
  } else {
#line 409
    return (self->len);
  }
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_memidx_t spif_mbuff_find_from_ptr(spif_mbuff_t self , spif_byteptr_t other ,
                                       spif_memidx_t len ) 
{ 
  spif_byteptr_t tmp ;
  time_t tmp___0 ;
  spif_byteptr_t tmp___1 ;
  void *tmp___2 ;
  spif_byteptr_t tmp___3 ;

  {
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 418
      if (libast_debug_level >= 1U) {
        {
#line 418
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_find_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           418, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 418
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_find_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             418, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 418
      return ((spif_memidx_t )-1);
    }
#line 418
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 419
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 419
    if (! ((unsigned long )other != (unsigned long )((spif_byteptr_t )((void *)0)))) {
#line 419
      if (libast_debug_level >= 1U) {
        {
#line 419
        tmp___0 = time((time_t *)((void *)0));
#line 419
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                419, "spif_mbuff_find_from_ptr");
#line 419
        libast_dprintf("REQUIRE failed:  %s\n", "(other != SPIF_NULL_TYPE(byteptr))");
        }
      }
#line 419
      return ((spif_memidx_t )-1);
    }
#line 419
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 420
    tmp___1 = (spif_byteptr_t )"";
  } else {
#line 420
    tmp___1 = self->buff;
  }
  {
#line 420
  tmp___2 = memmem((void const   *)((spif_byteptr_t const   )tmp___1), (size_t )self->len,
                   (void const   *)other, (size_t )len);
#line 420
  tmp = (spif_byteptr_t )tmp___2;
  }
#line 421
  if (tmp) {
#line 422
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 422
      tmp___3 = (spif_byteptr_t )"";
    } else {
#line 422
      tmp___3 = self->buff;
    }
#line 422
    return ((spif_long_t )tmp - (spif_long_t )((spif_byteptr_t const   )tmp___3));
  } else {
#line 424
    return (self->len);
  }
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_memidx_t spif_mbuff_index(spif_mbuff_t self , spif_uint8_t c ) 
{ 
  spif_byteptr_t tmp ;
  spif_memidx_t i ;

  {
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 434
      if (libast_debug_level >= 1U) {
        {
#line 434
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_index",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           434, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 434
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_index",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             434, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 434
      return ((spif_memidx_t )-1);
    }
#line 434
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  tmp = self->buff;
#line 435
  i = (spif_memidx_t )0;
  {
#line 435
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 435
    if ((int )*tmp & ~ ((int )c)) {
#line 435
      if (! (i < self->len)) {
#line 435
        goto while_break___0;
      }
    } else {
#line 435
      goto while_break___0;
    }
#line 435
    i ++;
#line 435
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 436
  return ((spif_long_t )tmp - (spif_long_t )self->buff);
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_cmp_t spif_mbuff_ncmp(spif_mbuff_t self , spif_mbuff_t other , spif_memidx_t cnt ) 
{ 
  int c ;
  spif_memidx_t aa ;
  spif_memidx_t bb ;
  spif_memidx_t tmp ;
  spif_byteptr_t tmp___0 ;
  spif_byteptr_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 444
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 444
        return ((spif_cmp_t )0);
      } else {
#line 444
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 444
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 444
      return ((spif_cmp_t )-1);
    } else
#line 444
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 444
      return ((spif_cmp_t )1);
    }
#line 444
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  if (cnt > self->len) {
#line 445
    goto _L___0;
  } else
#line 445
  if (cnt > other->len) {
    _L___0: /* CIL Label */ 
#line 446
    aa = self->len;
#line 446
    bb = other->len;
#line 446
    if (aa < bb) {
#line 446
      tmp = aa;
    } else {
#line 446
      tmp = bb;
    }
#line 446
    cnt = tmp;
  }
#line 448
  if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 448
    tmp___0 = (spif_byteptr_t )"";
  } else {
#line 448
    tmp___0 = other->buff;
  }
#line 448
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 448
    tmp___1 = (spif_byteptr_t )"";
  } else {
#line 448
    tmp___1 = self->buff;
  }
  {
#line 448
  c = memcmp((void const   *)((spif_byteptr_t const   )tmp___1), (void const   *)((spif_byteptr_t const   )tmp___0),
             (size_t )cnt);
  }
#line 449
  if (c < 0) {
#line 449
    tmp___3 = -1;
  } else {
#line 449
    if (c > 0) {
#line 449
      tmp___2 = 1;
    } else {
#line 449
      tmp___2 = 0;
    }
#line 449
    tmp___3 = tmp___2;
  }
#line 449
  return ((spif_cmp_t )tmp___3);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_cmp_t spif_mbuff_ncmp_with_ptr(spif_mbuff_t self , spif_byteptr_t other , spif_memidx_t cnt ) 
{ 
  spif_cmp_t tmp ;

  {
  {
#line 455
  tmp = spif_mbuff_cmp_with_ptr(self, other, cnt);
  }
#line 455
  return (tmp);
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_prepend(spif_mbuff_t self , spif_mbuff_t other ) 
{ 
  time_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  spif_byteptr_t tmp___5 ;

  {
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 461
      if (libast_debug_level >= 1U) {
        {
#line 461
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_prepend",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           461, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 461
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_prepend",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             461, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 461
      return ((spif_bool_t )0);
    }
#line 461
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 462
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 462
    if (! (! ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 462
      if (libast_debug_level >= 1U) {
        {
#line 462
        tmp = time((time_t *)((void *)0));
#line 462
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                462, "spif_mbuff_prepend");
#line 462
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_MBUFF_ISNULL(other)");
        }
      }
#line 462
      return ((spif_bool_t )0);
    }
#line 462
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 463
  if (other->size) {
#line 463
    if (other->len) {
#line 464
      self->size += other->size;
#line 465
      if (self->size) {
#line 465
        if (self->buff) {
          {
#line 465
          tmp___0 = realloc((void *)self->buff, (size_t )self->size);
#line 465
          tmp___2 = tmp___0;
          }
        } else {
          {
#line 465
          tmp___1 = malloc((size_t )self->size);
#line 465
          tmp___2 = tmp___1;
          }
        }
#line 465
        tmp___4 = tmp___2;
      } else {
#line 465
        if (self->buff) {
          {
#line 465
          free((void *)self->buff);
#line 465
          tmp___3 = (void *)0;
          }
        } else {
#line 465
          tmp___3 = (void *)0;
        }
#line 465
        tmp___4 = tmp___3;
      }
      {
#line 465
      self->buff = (spif_byteptr_t )tmp___4;
#line 466
      memmove((void *)(self->buff + other->len), (void const   *)self->buff, (size_t )self->len);
      }
#line 467
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 467
        tmp___5 = (spif_byteptr_t )"";
      } else {
#line 467
        tmp___5 = other->buff;
      }
      {
#line 467
      memcpy((void */* __restrict  */)self->buff, (void const   */* __restrict  */)((spif_byteptr_t const   )tmp___5),
             (size_t )other->len);
#line 468
      self->len += other->len;
      }
    }
  }
#line 470
  return ((spif_bool_t )1);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_prepend_from_ptr(spif_mbuff_t self , spif_byteptr_t other ,
                                        spif_memidx_t len ) 
{ 
  time_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 476
      if (libast_debug_level >= 1U) {
        {
#line 476
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_prepend_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           476, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 476
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_prepend_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             476, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 476
      return ((spif_bool_t )0);
    }
#line 476
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 477
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 477
    if (! ((unsigned long )other != (unsigned long )((spif_byteptr_t )((void *)0)))) {
#line 477
      if (libast_debug_level >= 1U) {
        {
#line 477
        tmp = time((time_t *)((void *)0));
#line 477
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                477, "spif_mbuff_prepend_from_ptr");
#line 477
        libast_dprintf("REQUIRE failed:  %s\n", "(other != SPIF_NULL_TYPE(byteptr))");
        }
      }
#line 477
      return ((spif_bool_t )0);
    }
#line 477
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 478
  if (len) {
#line 479
    self->size += len;
#line 480
    if (self->size) {
#line 480
      if (self->buff) {
        {
#line 480
        tmp___0 = realloc((void *)self->buff, (size_t )self->size);
#line 480
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 480
        tmp___1 = malloc((size_t )self->size);
#line 480
        tmp___2 = tmp___1;
        }
      }
#line 480
      tmp___4 = tmp___2;
    } else {
#line 480
      if (self->buff) {
        {
#line 480
        free((void *)self->buff);
#line 480
        tmp___3 = (void *)0;
        }
      } else {
#line 480
        tmp___3 = (void *)0;
      }
#line 480
      tmp___4 = tmp___3;
    }
    {
#line 480
    self->buff = (spif_byteptr_t )tmp___4;
#line 481
    memmove((void *)(self->buff + len), (void const   *)self->buff, (size_t )self->len);
#line 482
    memcpy((void */* __restrict  */)self->buff, (void const   */* __restrict  */)other,
           (size_t )len);
#line 483
    self->len += len;
    }
  }
#line 485
  return ((spif_bool_t )1);
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_reverse(spif_mbuff_t self ) 
{ 
  spif_byteptr_t tmp ;
  int i ;
  int j ;
  time_t tmp___0 ;
  spif_uint8_t __tmp ;

  {
#line 491
  tmp = self->buff;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 494
      if (libast_debug_level >= 1U) {
        {
#line 494
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_reverse",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           494, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 494
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_reverse",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             494, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 494
      return ((spif_bool_t )0);
    }
#line 494
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 495
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 495
    if (! ((unsigned long )self->buff != (unsigned long )((spif_byteptr_t )((void *)0)))) {
#line 495
      if (libast_debug_level >= 1U) {
        {
#line 495
        tmp___0 = time((time_t *)((void *)0));
#line 495
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                495, "spif_mbuff_reverse");
#line 495
        libast_dprintf("REQUIRE failed:  %s\n", "self->buff != SPIF_NULL_TYPE(byteptr)");
        }
      }
#line 495
      return ((spif_bool_t )0);
    }
#line 495
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 497
  j = 0;
#line 497
  i = (int )(self->len - 1L);
  {
#line 497
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 497
    if (! (i > j)) {
#line 497
      goto while_break___1;
    }
#line 498
    __tmp = *(tmp + j);
#line 498
    *(tmp + j) = *(tmp + i);
#line 498
    *(tmp + i) = __tmp;
#line 497
    i --;
#line 497
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 500
  return ((spif_bool_t )1);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_memidx_t spif_mbuff_rindex(spif_mbuff_t self , spif_uint8_t c ) 
{ 
  spif_byteptr_t tmp ;
  spif_memidx_t i ;

  {
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 509
      if (libast_debug_level >= 1U) {
        {
#line 509
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_rindex",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           509, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 509
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_rindex",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             509, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 509
      return ((spif_memidx_t )-1);
    }
#line 509
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  tmp = self->buff + self->len;
#line 510
  i = (spif_memidx_t )0;
  {
#line 510
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 510
    if ((int )*tmp & ~ ((int )c)) {
#line 510
      if (! (i < self->len)) {
#line 510
        goto while_break___0;
      }
    } else {
#line 510
      goto while_break___0;
    }
#line 510
    i ++;
#line 510
    tmp --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 512
  if ((unsigned long )tmp == (unsigned long )self->buff) {
#line 512
    if ((int )*tmp != (int )c) {
#line 513
      return (self->len);
    } else {
#line 515
      return ((spif_long_t )tmp - (spif_long_t )self->buff);
    }
  } else {
#line 515
    return ((spif_long_t )tmp - (spif_long_t )self->buff);
  }
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_splice(spif_mbuff_t self , spif_memidx_t idx , spif_memidx_t cnt ,
                              spif_mbuff_t other ) 
{ 
  spif_byteptr_t tmp ;
  spif_byteptr_t ptmp ;
  spif_memidx_t newsize ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  time_t tmp___3 ;
  spif_memidx_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 525
      if (libast_debug_level >= 1U) {
        {
#line 525
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_splice",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           525, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 525
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_splice",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             525, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 525
      return ((spif_bool_t )0);
    }
#line 525
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  if (idx < 0L) {
#line 527
    idx = self->len + idx;
  }
  {
#line 529
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 529
    if (! (idx >= 0L)) {
#line 529
      if (libast_debug_level >= 1U) {
        {
#line 529
        tmp___0 = time((time_t *)((void *)0));
#line 529
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                529, "spif_mbuff_splice");
#line 529
        libast_dprintf("REQUIRE failed:  %s\n", "idx >= 0");
        }
      }
#line 529
      return ((spif_bool_t )0);
    }
#line 529
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 530
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 530
    if (! (idx < self->len)) {
#line 530
      if (libast_debug_level >= 1U) {
        {
#line 530
        tmp___1 = time((time_t *)((void *)0));
#line 530
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                530, "spif_mbuff_splice");
#line 530
        libast_dprintf("REQUIRE failed:  %s\n", "idx < self->len");
        }
      }
#line 530
      return ((spif_bool_t )0);
    }
#line 530
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 531
  if (cnt < 0L) {
#line 532
    cnt = (idx + self->len) + cnt;
  }
  {
#line 534
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 534
    if (! (cnt >= 0L)) {
#line 534
      if (libast_debug_level >= 1U) {
        {
#line 534
        tmp___2 = time((time_t *)((void *)0));
#line 534
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___2, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                534, "spif_mbuff_splice");
#line 534
        libast_dprintf("REQUIRE failed:  %s\n", "cnt >= 0");
        }
      }
#line 534
      return ((spif_bool_t )0);
    }
#line 534
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 535
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 535
    if (! (cnt <= self->len - idx)) {
#line 535
      if (libast_debug_level >= 1U) {
        {
#line 535
        tmp___3 = time((time_t *)((void *)0));
#line 535
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___3, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                535, "spif_mbuff_splice");
#line 535
        libast_dprintf("REQUIRE failed:  %s\n", "cnt <= (self->len - idx)");
        }
      }
#line 535
      return ((spif_bool_t )0);
    }
#line 535
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 537
  if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 537
    tmp___4 = (spif_memidx_t )0;
  } else {
#line 537
    tmp___4 = other->len;
  }
  {
#line 537
  newsize = ((self->len + tmp___4) - cnt) + 1L;
#line 538
  tmp___5 = malloc((size_t )newsize);
#line 538
  tmp = (spif_byteptr_t )tmp___5;
#line 538
  ptmp = tmp;
  }
#line 539
  if (idx > 0L) {
    {
#line 540
    memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self->buff,
           (size_t )idx);
#line 541
    ptmp += idx;
    }
  }
#line 543
  if (! ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 544
    memcpy((void */* __restrict  */)ptmp, (void const   */* __restrict  */)other->buff,
           (size_t )other->len);
#line 545
    ptmp += other->len;
    }
  }
  {
#line 547
  memcpy((void */* __restrict  */)ptmp, (void const   */* __restrict  */)((self->buff + idx) + cnt),
         (size_t )(((self->len - idx) - cnt) + 1L));
  }
#line 548
  if (self->size < newsize) {
#line 549
    if (newsize) {
#line 549
      if (self->buff) {
        {
#line 549
        tmp___6 = realloc((void *)self->buff, (size_t )newsize);
#line 549
        tmp___8 = tmp___6;
        }
      } else {
        {
#line 549
        tmp___7 = malloc((size_t )newsize);
#line 549
        tmp___8 = tmp___7;
        }
      }
#line 549
      tmp___10 = tmp___8;
    } else {
#line 549
      if (self->buff) {
        {
#line 549
        free((void *)self->buff);
#line 549
        tmp___9 = (void *)0;
        }
      } else {
#line 549
        tmp___9 = (void *)0;
      }
#line 549
      tmp___10 = tmp___9;
    }
#line 549
    self->buff = (spif_byteptr_t )tmp___10;
#line 550
    self->size = newsize;
  }
  {
#line 552
  self->len = newsize;
#line 553
  memcpy((void */* __restrict  */)self->buff, (void const   */* __restrict  */)tmp,
         (size_t )newsize);
  }
  {
#line 554
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 554
    free((void *)tmp);
#line 554
    tmp = (spif_byteptr_t )((void *)0);
    }
#line 554
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 555
  return ((spif_bool_t )1);
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_splice_from_ptr(spif_mbuff_t self , spif_memidx_t idx , spif_memidx_t cnt ,
                                       spif_byteptr_t other , spif_memidx_t len ) 
{ 
  spif_byteptr_t tmp ;
  spif_byteptr_t ptmp ;
  spif_memidx_t newsize ;
  int tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  time_t tmp___3 ;
  time_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 564
      if (libast_debug_level >= 1U) {
        {
#line 564
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_splice_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           564, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 564
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_splice_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             564, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 564
      return ((spif_bool_t )0);
    }
#line 564
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 565
  if ((unsigned long )((spif_ptr_t )other) == (unsigned long )((void *)0)) {
#line 565
    tmp___0 = 1;
  } else {
#line 565
    tmp___0 = 0;
  }
#line 565
  if (tmp___0) {
#line 566
    len = (spif_memidx_t )0;
  }
#line 568
  if (idx < 0L) {
#line 569
    idx = self->len + idx;
  }
  {
#line 571
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 571
    if (! (idx >= 0L)) {
#line 571
      if (libast_debug_level >= 1U) {
        {
#line 571
        tmp___1 = time((time_t *)((void *)0));
#line 571
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                571, "spif_mbuff_splice_from_ptr");
#line 571
        libast_dprintf("REQUIRE failed:  %s\n", "idx >= 0");
        }
      }
#line 571
      return ((spif_bool_t )0);
    }
#line 571
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 572
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 572
    if (! (idx < self->len)) {
#line 572
      if (libast_debug_level >= 1U) {
        {
#line 572
        tmp___2 = time((time_t *)((void *)0));
#line 572
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___2, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                572, "spif_mbuff_splice_from_ptr");
#line 572
        libast_dprintf("REQUIRE failed:  %s\n", "idx < self->len");
        }
      }
#line 572
      return ((spif_bool_t )0);
    }
#line 572
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 573
  if (cnt < 0L) {
#line 574
    cnt = (idx + self->len) + cnt;
  }
  {
#line 576
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 576
    if (! (cnt >= 0L)) {
#line 576
      if (libast_debug_level >= 1U) {
        {
#line 576
        tmp___3 = time((time_t *)((void *)0));
#line 576
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___3, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                576, "spif_mbuff_splice_from_ptr");
#line 576
        libast_dprintf("REQUIRE failed:  %s\n", "cnt >= 0");
        }
      }
#line 576
      return ((spif_bool_t )0);
    }
#line 576
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 577
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 577
    if (! (cnt <= self->len - idx)) {
#line 577
      if (libast_debug_level >= 1U) {
        {
#line 577
        tmp___4 = time((time_t *)((void *)0));
#line 577
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___4, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                577, "spif_mbuff_splice_from_ptr");
#line 577
        libast_dprintf("REQUIRE failed:  %s\n", "cnt <= (self->len - idx)");
        }
      }
#line 577
      return ((spif_bool_t )0);
    }
#line 577
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 579
  newsize = (self->len + len) - cnt;
#line 580
  tmp___5 = malloc((size_t )newsize);
#line 580
  tmp = (spif_byteptr_t )tmp___5;
#line 580
  ptmp = tmp;
  }
#line 581
  if (idx > 0L) {
    {
#line 582
    memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self->buff,
           (size_t )idx);
#line 583
    ptmp += idx;
    }
  }
#line 585
  if (len) {
    {
#line 586
    memcpy((void */* __restrict  */)ptmp, (void const   */* __restrict  */)other,
           (size_t )len);
#line 587
    ptmp += len;
    }
  }
  {
#line 589
  memcpy((void */* __restrict  */)ptmp, (void const   */* __restrict  */)((self->buff + idx) + cnt),
         (size_t )((self->len - idx) - cnt));
  }
#line 590
  if (self->size < newsize) {
#line 591
    if (newsize) {
#line 591
      if (self->buff) {
        {
#line 591
        tmp___6 = realloc((void *)self->buff, (size_t )newsize);
#line 591
        tmp___8 = tmp___6;
        }
      } else {
        {
#line 591
        tmp___7 = malloc((size_t )newsize);
#line 591
        tmp___8 = tmp___7;
        }
      }
#line 591
      tmp___10 = tmp___8;
    } else {
#line 591
      if (self->buff) {
        {
#line 591
        free((void *)self->buff);
#line 591
        tmp___9 = (void *)0;
        }
      } else {
#line 591
        tmp___9 = (void *)0;
      }
#line 591
      tmp___10 = tmp___9;
    }
#line 591
    self->buff = (spif_byteptr_t )tmp___10;
#line 592
    self->size = newsize;
  }
  {
#line 594
  self->len = newsize;
#line 595
  memcpy((void */* __restrict  */)self->buff, (void const   */* __restrict  */)tmp,
         (size_t )newsize);
  }
  {
#line 596
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 596
    free((void *)tmp);
#line 596
    tmp = (spif_byteptr_t )((void *)0);
    }
#line 596
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 597
  return ((spif_bool_t )1);
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_mbuff_t spif_mbuff_subbuff(spif_mbuff_t self , spif_memidx_t idx , spif_memidx_t cnt ) 
{ 
  time_t tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  spif_memidx_t o ;
  spif_mbuff_t tmp___2 ;

  {
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 603
      if (libast_debug_level >= 1U) {
        {
#line 603
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_subbuff",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           603, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 603
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_subbuff",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             603, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 603
      return ((spif_mbuff_t )((void *)0));
    }
#line 603
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  if (idx < 0L) {
#line 605
    idx = self->len + idx;
  }
  {
#line 607
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 607
    if (! (idx >= 0L)) {
#line 607
      if (libast_debug_level >= 1U) {
        {
#line 607
        tmp = time((time_t *)((void *)0));
#line 607
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                607, "spif_mbuff_subbuff");
#line 607
        libast_dprintf("REQUIRE failed:  %s\n", "idx >= 0");
        }
      }
#line 607
      return ((spif_mbuff_t )((void *)0));
    }
#line 607
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 608
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 608
    if (! (idx < self->len)) {
#line 608
      if (libast_debug_level >= 1U) {
        {
#line 608
        tmp___0 = time((time_t *)((void *)0));
#line 608
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                608, "spif_mbuff_subbuff");
#line 608
        libast_dprintf("REQUIRE failed:  %s\n", "idx < self->len");
        }
      }
#line 608
      return ((spif_mbuff_t )((void *)0));
    }
#line 608
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 609
  if (cnt <= 0L) {
#line 610
    cnt = (self->len - idx) + cnt;
  }
  {
#line 612
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 612
    if (! (cnt >= 0L)) {
#line 612
      if (libast_debug_level >= 1U) {
        {
#line 612
        tmp___1 = time((time_t *)((void *)0));
#line 612
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                612, "spif_mbuff_subbuff");
#line 612
        libast_dprintf("REQUIRE failed:  %s\n", "cnt >= 0");
        }
      }
#line 612
      return ((spif_mbuff_t )((void *)0));
    }
#line 612
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 613
  o = self->len - idx;
#line 613
  if (cnt > o) {
#line 613
    cnt = o;
  }
  {
#line 614
  tmp___2 = spif_mbuff_new_from_buff(self->buff + idx, cnt, cnt);
  }
#line 614
  return (tmp___2);
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_byteptr_t spif_mbuff_subbuff_to_ptr(spif_mbuff_t self , spif_memidx_t idx , spif_memidx_t cnt ) 
{ 
  spif_byteptr_t newmbuff ;
  time_t tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  spif_memidx_t o ;
  void *tmp___2 ;
  spif_byteptr_t tmp___3 ;

  {
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
#line 622
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 622
      if (libast_debug_level >= 1U) {
        {
#line 622
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_subbuff_to_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           622, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 622
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_subbuff_to_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             622, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 622
      return ((spif_byteptr_t )((void *)0));
    }
#line 622
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 623
  if (idx < 0L) {
#line 624
    idx = self->len + idx;
  }
  {
#line 626
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 626
    if (! (idx >= 0L)) {
#line 626
      if (libast_debug_level >= 1U) {
        {
#line 626
        tmp = time((time_t *)((void *)0));
#line 626
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                626, "spif_mbuff_subbuff_to_ptr");
#line 626
        libast_dprintf("REQUIRE failed:  %s\n", "idx >= 0");
        }
      }
#line 626
      return ((spif_byteptr_t )((void *)0));
    }
#line 626
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 627
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 627
    if (! (idx < self->len)) {
#line 627
      if (libast_debug_level >= 1U) {
        {
#line 627
        tmp___0 = time((time_t *)((void *)0));
#line 627
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                627, "spif_mbuff_subbuff_to_ptr");
#line 627
        libast_dprintf("REQUIRE failed:  %s\n", "idx < self->len");
        }
      }
#line 627
      return ((spif_byteptr_t )((void *)0));
    }
#line 627
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 628
  if (cnt <= 0L) {
#line 629
    cnt = (self->len - idx) + cnt;
  }
  {
#line 631
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 631
    if (! (cnt >= 0L)) {
#line 631
      if (libast_debug_level >= 1U) {
        {
#line 631
        tmp___1 = time((time_t *)((void *)0));
#line 631
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                631, "spif_mbuff_subbuff_to_ptr");
#line 631
        libast_dprintf("REQUIRE failed:  %s\n", "cnt >= 0");
        }
      }
#line 631
      return ((spif_byteptr_t )((void *)0));
    }
#line 631
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 632
  o = self->len - idx;
#line 632
  if (cnt > o) {
#line 632
    cnt = o;
  }
  {
#line 634
  tmp___2 = malloc((size_t )(cnt + 1L));
#line 634
  newmbuff = (spif_byteptr_t )tmp___2;
  }
#line 635
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 635
    tmp___3 = (spif_byteptr_t )"";
  } else {
#line 635
    tmp___3 = self->buff;
  }
  {
#line 635
  memcpy((void */* __restrict  */)newmbuff, (void const   */* __restrict  */)((spif_byteptr_t const   )tmp___3 + idx),
         (size_t )cnt);
#line 636
  *(newmbuff + cnt) = (spif_uint8_t )0;
  }
#line 637
  return (newmbuff);
}
}
#line 640 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_trim(spif_mbuff_t self ) 
{ 
  spif_byteptr_t start ;
  spif_byteptr_t end ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  spif_bool_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 645
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 645
      if (libast_debug_level >= 1U) {
        {
#line 645
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_trim",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                           645, "!SPIF_MBUFF_ISNULL(self)");
        }
      } else {
        {
#line 645
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_mbuff_trim",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c",
                             645, "!SPIF_MBUFF_ISNULL(self)");
        }
      }
#line 645
      return ((spif_bool_t )0);
    }
#line 645
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 646
  start = self->buff;
#line 647
  end = (self->buff + self->len) - 1;
  {
#line 648
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 648
    tmp = __ctype_b_loc();
    }
#line 648
    if ((int const   )*(*tmp + (int )*start) & 8192) {
#line 648
      if (! ((unsigned long )start < (unsigned long )end)) {
#line 648
        goto while_break___0;
      }
    } else {
#line 648
      goto while_break___0;
    }
#line 648
    start ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 649
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 649
    tmp___0 = __ctype_b_loc();
    }
#line 649
    if ((int const   )*(*tmp___0 + (int )*end) & 8192) {
#line 649
      if (! ((unsigned long )start < (unsigned long )end)) {
#line 649
        goto while_break___1;
      }
    } else {
#line 649
      goto while_break___1;
    }
#line 649
    end --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 650
  if ((unsigned long )start > (unsigned long )end) {
    {
#line 651
    tmp___1 = spif_mbuff_done(self);
    }
#line 651
    return (tmp___1);
  }
  {
#line 653
  end ++;
#line 653
  *end = (spif_uint8_t )0;
#line 654
  self->len = end - start;
#line 655
  self->size = self->len + 1L;
#line 656
  memmove((void *)self->buff, (void const   *)start, (size_t )self->size);
  }
#line 657
  if (self->size) {
#line 657
    if (self->buff) {
      {
#line 657
      tmp___2 = realloc((void *)self->buff, (size_t )self->size);
#line 657
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 657
      tmp___3 = malloc((size_t )self->size);
#line 657
      tmp___4 = tmp___3;
      }
    }
#line 657
    tmp___6 = tmp___4;
  } else {
#line 657
    if (self->buff) {
      {
#line 657
      free((void *)self->buff);
#line 657
      tmp___5 = (void *)0;
      }
    } else {
#line 657
      tmp___5 = (void *)0;
    }
#line 657
    tmp___6 = tmp___5;
  }
#line 657
  self->buff = (spif_byteptr_t )tmp___6;
#line 658
  return ((spif_bool_t )1);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_memidx_t spif_mbuff_get_size(spif_mbuff_t self ) 
{ 


  {
#line 661
  return (self->size);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_set_size(spif_mbuff_t self , spif_memidx_t new_size ) 
{ 


  {
#line 661
  self->size = new_size;
#line 661
  return ((spif_bool_t )1);
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_memidx_t spif_mbuff_get_len(spif_mbuff_t self ) 
{ 


  {
#line 662
  return (self->len);
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mbuff.c"
spif_bool_t spif_mbuff_set_len(spif_mbuff_t self , spif_memidx_t new_len ) 
{ 


  {
#line 662
  self->len = new_len;
#line 662
  return ((spif_bool_t )1);
}
}
#line 750 "../include/libast/obj.h"
spif_class_t spif_obj_class ;
#line 751
spif_obj_t spif_obj_new(void) ;
#line 752
spif_bool_t spif_obj_del(spif_obj_t self ) ;
#line 754
spif_bool_t spif_obj_done(spif_obj_t self ) ;
#line 755
spif_class_t spif_obj_get_class(spif_obj_t self ) ;
#line 757
spif_str_t spif_obj_show(spif_obj_t self , spif_charptr_t name___0 , spif_str_t buff ,
                         size_t indent ) ;
#line 759
spif_obj_t spif_obj_dup(spif_obj_t self ) ;
#line 760
spif_classname_t spif_obj_type(spif_obj_t self ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
static spif_const_class_t o_class  = 
#line 61 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
     {(spif_charptr_t )"!spif_obj_t!", (void *(*)())(& spif_obj_new), (void *(*)())(& spif_obj_init),
    (void *(*)())(& spif_obj_done), (void *(*)())(& spif_obj_del), (void *(*)())(& spif_obj_show),
    (void *(*)())(& spif_obj_comp), (void *(*)())(& spif_obj_dup), (void *(*)())(& spif_obj_type)};
#line 83 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
spif_class_t spif_obj_class  =    & o_class;
#line 116 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
spif_obj_t spif_obj_new(void) 
{ 
  spif_obj_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 121
  tmp = malloc(sizeof(spif_const_obj_t ));
#line 121
  self = (spif_obj_t )tmp;
#line 122
  tmp___0 = spif_obj_init(self);
  }
#line 122
  if (! tmp___0) {
    {
#line 123
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 123
      free((void *)self);
#line 123
      self = (spif_obj_t )((void *)0);
      }
#line 123
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 124
    self = (spif_obj_t )((void *)0);
  }
#line 126
  return (self);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
spif_bool_t spif_obj_del(spif_obj_t self ) 
{ 
  spif_bool_t t ;

  {
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (! ((unsigned long )self == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 147
      if (libast_debug_level >= 1U) {
        {
#line 147
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                           147, "!SPIF_OBJ_ISNULL(self)");
        }
      } else {
        {
#line 147
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                             147, "!SPIF_OBJ_ISNULL(self)");
        }
      }
#line 147
      return ((spif_bool_t )0);
    }
#line 147
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  t = spif_obj_done(self);
  }
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 150
    free((void *)self);
#line 150
    self = (spif_obj_t )((void *)0);
    }
#line 150
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 151
  return (t);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
spif_bool_t spif_obj_init(spif_obj_t self ) 
{ 


  {
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (! ((unsigned long )self == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 179
      if (libast_debug_level >= 1U) {
        {
#line 179
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                           179, "!SPIF_OBJ_ISNULL(self)");
        }
      } else {
        {
#line 179
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                             179, "!SPIF_OBJ_ISNULL(self)");
        }
      }
#line 179
      return ((spif_bool_t )0);
    }
#line 179
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  spif_obj_set_class(self, spif_obj_class);
  }
#line 181
  return ((spif_bool_t )1);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
spif_bool_t spif_obj_done(spif_obj_t self ) 
{ 


  {
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (! ((unsigned long )self == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 199
      if (libast_debug_level >= 1U) {
        {
#line 199
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                           199, "!SPIF_OBJ_ISNULL(self)");
        }
      } else {
        {
#line 199
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                             199, "!SPIF_OBJ_ISNULL(self)");
        }
      }
#line 199
      return ((spif_bool_t )0);
    }
#line 199
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((spif_bool_t )1);
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
spif_str_t spif_obj_show(spif_obj_t self , spif_charptr_t name___0 , spif_str_t buff ,
                         size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  char *tmp___0 ;

  {
#line 246
  if ((unsigned long )self == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 247
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 247
      memset((void *)(tmp), ' ', indent);
      }
#line 247
      if ((char *)name___0) {
#line 247
        tmp___0 = (char *)name___0;
      } else {
#line 247
        tmp___0 = (char *)"<name null>";
      }
      {
#line 247
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_obj_t) %s:  { ((spif_obj_t) NULL) }\n",
               tmp___0);
      }
#line 247
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 247
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 247
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 247
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 248
    return (buff);
  }
  {
#line 251
  memset((void *)(tmp), ' ', indent);
#line 252
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_obj_t) %s:  %10p \"%s\"\n", name___0,
           (spif_ptr_t )self, (spif_classname_t )self->cls);
  }
#line 255
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 256
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 258
    spif_str_append_from_ptr(buff, tmp);
    }
  }
#line 260
  return (buff);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
spif_cmp_t spif_obj_comp(spif_obj_t self , spif_obj_t other ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if ((unsigned long )self == (unsigned long )((spif_obj_t )((void *)0))) {
#line 285
      if ((unsigned long )other == (unsigned long )((spif_obj_t )((void *)0))) {
#line 285
        return ((spif_cmp_t )0);
      } else {
#line 285
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 285
    if ((unsigned long )self == (unsigned long )((spif_obj_t )((void *)0))) {
#line 285
      return ((spif_cmp_t )-1);
    } else
#line 285
    if ((unsigned long )other == (unsigned long )((spif_obj_t )((void *)0))) {
#line 285
      return ((spif_cmp_t )1);
    }
#line 285
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  if ((int )((spif_ulong_t )self - (spif_ulong_t )other) < 0) {
#line 286
    tmp___0 = -1;
  } else {
#line 286
    if ((int )((spif_ulong_t )self - (spif_ulong_t )other) > 0) {
#line 286
      tmp = 1;
    } else {
#line 286
      tmp = 0;
    }
#line 286
    tmp___0 = tmp;
  }
#line 286
  return ((spif_cmp_t )tmp___0);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
spif_obj_t spif_obj_dup(spif_obj_t self ) 
{ 
  spif_obj_t tmp ;

  {
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (! ((unsigned long )self == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 314
      if (libast_debug_level >= 1U) {
        {
#line 314
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                           314, "!SPIF_OBJ_ISNULL(self)");
        }
      } else {
        {
#line 314
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                             314, "!SPIF_OBJ_ISNULL(self)");
        }
      }
#line 314
      return ((spif_obj_t )((void *)0));
    }
#line 314
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 315
  tmp = spif_obj_new();
#line 316
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self, sizeof(spif_const_obj_t ));
  }
#line 317
  return (tmp);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
spif_classname_t spif_obj_type(spif_obj_t self ) 
{ 


  {
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (! ((unsigned long )self == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 337
      if (libast_debug_level >= 1U) {
        {
#line 337
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                           337, "!SPIF_OBJ_ISNULL(self)");
        }
      } else {
        {
#line 337
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                             337, "!SPIF_OBJ_ISNULL(self)");
        }
      }
#line 337
      return ((spif_classname_t )((void *)0));
    }
#line 337
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  return ((spif_classname_t )self->cls);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
spif_class_t spif_obj_get_class(spif_obj_t self ) 
{ 


  {
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (! ((unsigned long )self == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 364
      if (libast_debug_level >= 1U) {
        {
#line 364
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_get_class",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                           364, "!SPIF_OBJ_ISNULL(self)");
        }
      } else {
        {
#line 364
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_get_class",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                             364, "!SPIF_OBJ_ISNULL(self)");
        }
      }
#line 364
      return ((spif_class_t )((void *)0));
    }
#line 364
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  return (self->cls);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c"
spif_bool_t spif_obj_set_class(spif_obj_t self , spif_class_t cls ) 
{ 


  {
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! (! ((unsigned long )self == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 392
      if (libast_debug_level >= 1U) {
        {
#line 392
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_set_class",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                           392, "!SPIF_OBJ_ISNULL(self)");
        }
      } else {
        {
#line 392
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_obj_set_class",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/obj.c",
                             392, "!SPIF_OBJ_ISNULL(self)");
        }
      }
#line 392
      return ((spif_bool_t )0);
    }
#line 392
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  self->cls = cls;
#line 394
  return ((spif_bool_t )1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 2681 "../include/libast.h"
void libast_set_program_name(char const   *progname ) ;
#line 2682
void libast_set_program_version(char const   *progversion ) ;
#line 2684
void libast_print_error(char const   *fmt  , ...) ;
#line 60 "../include/libast_internal.h"
spif_charptr_t libast_program_name ;
#line 60
spif_charptr_t libast_program_version ;
#line 52 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c"
spif_charptr_t libast_program_name  =    (spif_charptr_t )"libast";
#line 61 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c"
spif_charptr_t libast_program_version  =    (spif_charptr_t )"0.7";
#line 74 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c"
void libast_set_program_name(char const   *progname ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 77
  if (libast_program_name) {
    {
#line 78
    tmp = strcmp((char const   *)((char *)libast_program_name), progname);
    }
#line 78
    if (! tmp) {
#line 79
      return;
    }
    {
#line 81
    tmp___0 = strcmp((char const   *)((char *)libast_program_name), "libast");
    }
#line 81
    if (tmp___0) {
      {
#line 82
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 82
        free((void *)libast_program_name);
#line 82
        libast_program_name = (spif_charptr_t )((void *)0);
        }
#line 82
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 85
  if (progname) {
    {
#line 86
    tmp___1 = strdup((char const   *)((char *)progname));
#line 86
    libast_program_name = (spif_charptr_t )tmp___1;
    }
  } else {
#line 88
    libast_program_name = (spif_charptr_t )"libast";
  }
#line 90
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c"
void libast_set_program_version(char const   *progversion ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 106
  if (libast_program_version) {
    {
#line 107
    tmp = strcmp((char const   *)((char *)libast_program_version), progversion);
    }
#line 107
    if (! tmp) {
#line 108
      return;
    }
    {
#line 110
    tmp___0 = strcmp((char const   *)((char *)libast_program_version), "0.7");
    }
#line 110
    if (tmp___0) {
      {
#line 111
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 111
        free((void *)libast_program_version);
#line 111
        libast_program_version = (spif_charptr_t )((void *)0);
        }
#line 111
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 114
  if (progversion) {
    {
#line 115
    tmp___1 = strdup((char const   *)((char *)progversion));
#line 115
    libast_program_version = (spif_charptr_t )tmp___1;
    }
  } else {
#line 117
    libast_program_version = (spif_charptr_t )"0.7";
  }
#line 119
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c"
int libast_dprintf(char const   *format  , ...) 
{ 
  va_list args ;
  int n ;
  int tmp ;
  time_t tmp___0 ;

  {
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if ((unsigned long )((spif_ptr_t )format) == (unsigned long )((void *)0)) {
#line 142
      tmp = 1;
    } else {
#line 142
      tmp = 0;
    }
#line 142
    if (tmp) {
#line 142
      if (libast_debug_level >= 1U) {
        {
#line 142
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "libast_dprintf",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c",
                           142, "!SPIF_PTR_ISNULL(format)");
        }
      } else {
        {
#line 142
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "libast_dprintf",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c",
                             142, "!SPIF_PTR_ISNULL(format)");
        }
      }
#line 142
      return (-1);
    }
#line 142
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 143
    if (! ((unsigned long )libast_program_name != (unsigned long )((void *)0))) {
#line 143
      if (libast_debug_level >= 1U) {
        {
#line 143
        tmp___0 = time((time_t *)((void *)0));
#line 143
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c",
                143, "libast_dprintf");
#line 143
        libast_dprintf("REQUIRE failed:  %s\n", "libast_program_name != NULL");
        }
      }
#line 143
      return (0);
    }
#line 143
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 144
  __builtin_va_start(args, format);
#line 145
  n = vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
               args);
#line 146
  __builtin_va_end(args);
#line 147
  fflush(stderr);
  }
#line 148
  return (n);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c"
void libast_print_error(char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;
  int tmp ;
  time_t tmp___0 ;

  {
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if ((unsigned long )((spif_ptr_t )fmt) == (unsigned long )((void *)0)) {
#line 170
      tmp = 1;
    } else {
#line 170
      tmp = 0;
    }
#line 170
    if (tmp) {
#line 170
      if (libast_debug_level >= 1U) {
        {
#line 170
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "libast_print_error",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c",
                           170, "!SPIF_PTR_ISNULL(fmt)");
        }
      } else {
        {
#line 170
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "libast_print_error",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c",
                             170, "!SPIF_PTR_ISNULL(fmt)");
        }
#line 170
        return;
      }
    }
#line 170
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! ((unsigned long )libast_program_name != (unsigned long )((void *)0))) {
#line 171
      if (libast_debug_level >= 1U) {
        {
#line 171
        tmp___0 = time((time_t *)((void *)0));
#line 171
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c",
                171, "libast_print_error");
#line 171
        libast_dprintf("REQUIRE failed:  %s\n", "libast_program_name != NULL");
        }
      }
#line 171
      return;
    }
#line 171
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 172
  __builtin_va_start(arg_ptr, fmt);
#line 173
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:  Error:  ",
          libast_program_name);
#line 174
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           arg_ptr);
#line 175
  __builtin_va_end(arg_ptr);
  }
#line 176
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c"
void libast_print_warning(char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;
  int tmp ;
  time_t tmp___0 ;

  {
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if ((unsigned long )((spif_ptr_t )fmt) == (unsigned long )((void *)0)) {
#line 197
      tmp = 1;
    } else {
#line 197
      tmp = 0;
    }
#line 197
    if (tmp) {
#line 197
      if (libast_debug_level >= 1U) {
        {
#line 197
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "libast_print_warning",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c",
                           197, "!SPIF_PTR_ISNULL(fmt)");
        }
      } else {
        {
#line 197
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "libast_print_warning",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c",
                             197, "!SPIF_PTR_ISNULL(fmt)");
        }
#line 197
        return;
      }
    }
#line 197
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )libast_program_name != (unsigned long )((void *)0))) {
#line 198
      if (libast_debug_level >= 1U) {
        {
#line 198
        tmp___0 = time((time_t *)((void *)0));
#line 198
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c",
                198, "libast_print_warning");
#line 198
        libast_dprintf("REQUIRE failed:  %s\n", "libast_program_name != NULL");
        }
      }
#line 198
      return;
    }
#line 198
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 199
  __builtin_va_start(arg_ptr, fmt);
#line 200
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:  Warning:  ",
          libast_program_name);
#line 201
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           arg_ptr);
#line 202
  __builtin_va_end(arg_ptr);
  }
#line 203
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c"
void libast_fatal_error(char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;
  int tmp ;

  {
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if ((unsigned long )((spif_ptr_t )fmt) == (unsigned long )((void *)0)) {
#line 224
      tmp = 1;
    } else {
#line 224
      tmp = 0;
    }
#line 224
    if (tmp) {
#line 224
      if (libast_debug_level >= 1U) {
        {
#line 224
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "libast_fatal_error",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c",
                           224, "!SPIF_PTR_ISNULL(fmt)");
        }
      } else {
        {
#line 224
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "libast_fatal_error",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/msgs.c",
                             224, "!SPIF_PTR_ISNULL(fmt)");
        }
#line 224
        return;
      }
    }
#line 224
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  if ((unsigned long )libast_program_name != (unsigned long )((void *)0)) {
    {
#line 226
    __builtin_va_start(arg_ptr, fmt);
#line 227
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:  FATAL:  ",
            libast_program_name);
#line 228
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             arg_ptr);
#line 229
    __builtin_va_end(arg_ptr);
    }
  }
  {
#line 231
  exit(-1);
  }
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 1659 "../include/libast.h"
char const   *true_vals[4] ;
#line 1659
char const   *false_vals[4] ;
#line 2598
spifopt_settings_t spifopt_settings ;
#line 2733
spif_charptr_t spiftool_get_word(unsigned long index___0 , spif_charptr_t const   str ) ;
#line 2734
spif_charptr_t spiftool_get_pword(unsigned long index___0 , spif_charptr_t const   str ) ;
#line 2735
unsigned long spiftool_num_words(spif_charptr_t const   str ) ;
#line 2798
void spifopt_parse(int argc , char **argv ) ;
#line 2799
void spifopt_usage(void) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
spifopt_settings_t spifopt_settings  =    {(spifopt_t *)((void *)0), (spif_uint16_t )0, (spif_uint8_t )0, (spif_uint8_t )0,
    (spif_uint8_t )0, (spif_uint8_t )0, (void (*)())((void *)0)};
#line 93 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
static spif_charptr_t get_option_type_string(spif_uint16_t type ) 
{ 


  {
  {
#line 97
  if ((int )type == 1) {
#line 97
    goto case_1;
  }
#line 98
  if ((int )type == (int )(1UL << 5)) {
#line 98
    goto case_exp;
  }
#line 99
  if ((int )type == (int )(1UL << 7)) {
#line 99
    goto case_exp___0;
  }
#line 100
  goto switch_default;
  case_1: /* CIL Label */ 
#line 97
  return ((spif_charptr_t )"(bool)");
#line 97
  goto switch_break;
  case_exp: /* CIL Label */ 
#line 98
  return ((spif_charptr_t )"(int)");
#line 98
  goto switch_break;
  case_exp___0: /* CIL Label */ 
#line 99
  return ((spif_charptr_t )"(strs)");
#line 99
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 100
  return ((spif_charptr_t )"(str)");
  switch_break: /* CIL Label */ ;
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (libast_debug_level >= 1U) {
      {
#line 102
      libast_fatal_error("ASSERT failed in %s() at %s:%d:  This code should not be reached.\n",
                         "get_option_type_string", "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                         102);
      }
    } else {
      {
#line 102
      libast_print_warning("ASSERT failed in %s() at %s:%d:  This code should not be reached.\n",
                           "get_option_type_string", "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                           102);
      }
    }
#line 102
    return ((spif_charptr_t )((void *)0));
#line 102
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return ((spif_char_t *)0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
void spifopt_usage(void) 
{ 
  spif_uint16_t i ;
  spif_uint16_t col ;
  spif_uint16_t l_long ;
  spif_uint16_t l_desc ;
  size_t o ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t o___0 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  spif_charptr_t tmp___12 ;

  {
#line 119
  l_long = (spif_uint16_t )0;
#line 119
  l_desc = (spif_uint16_t )0;
#line 122
  i = (spif_uint16_t )0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! ((int )i < (int )spifopt_settings.num_opts)) {
#line 122
      goto while_break;
    }
#line 123
    if ((int )i < (int )spifopt_settings.num_opts) {
#line 123
      tmp___0 = (int )i;
    } else {
#line 123
      tmp___0 = 0;
    }
    {
#line 123
    tmp___1 = strlen((char const   *)(spifopt_settings.opt_list + tmp___0)->long_opt);
#line 123
    o = tmp___1;
    }
#line 123
    if ((size_t )l_long < o) {
#line 123
      l_long = (spif_uint16_t )o;
    }
#line 124
    if ((int )i < (int )spifopt_settings.num_opts) {
#line 124
      tmp___3 = (int )i;
    } else {
#line 124
      tmp___3 = 0;
    }
    {
#line 124
    tmp___4 = strlen((char const   *)(spifopt_settings.opt_list + tmp___3)->desc);
#line 124
    o___0 = tmp___4;
    }
#line 124
    if ((size_t )l_desc < o___0) {
#line 124
      l_desc = (spif_uint16_t )o___0;
    }
#line 122
    i = (spif_uint16_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  l_long = (spif_uint16_t )((int )l_long + 2);
#line 127
  l_desc = (spif_uint16_t )((int )l_desc + 7);
#line 129
  printf((char const   */* __restrict  */)"%s %s\n", libast_program_name, libast_program_version);
#line 130
  printf((char const   */* __restrict  */)"Usage:\n\n");
#line 131
  printf((char const   */* __restrict  */)"POSIX ");
#line 133
  col = (spif_uint16_t )0;
  }
  {
#line 133
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 133
    if (! ((int )col < ((int )l_long - 3) / 2)) {
#line 133
      goto while_break___0;
    }
    {
#line 133
    printf((char const   */* __restrict  */)" ");
#line 133
    col = (spif_uint16_t )((int )col + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 134
  printf((char const   */* __restrict  */)"GNU");
#line 135
  col = (spif_uint16_t )0;
  }
  {
#line 135
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 135
    if (! ((int )col < ((int )l_long - 3) / 2)) {
#line 135
      goto while_break___1;
    }
    {
#line 135
    printf((char const   */* __restrict  */)" ");
#line 135
    col = (spif_uint16_t )((int )col + 1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 136
  if (! ((int )l_long % 2)) {
    {
#line 137
    printf((char const   */* __restrict  */)" ");
    }
  }
  {
#line 139
  printf((char const   */* __restrict  */)"  ");
#line 141
  col = (spif_uint16_t )0;
  }
  {
#line 141
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 141
    if (! ((int )col < ((int )l_desc - 11) / 2)) {
#line 141
      goto while_break___2;
    }
    {
#line 141
    printf((char const   */* __restrict  */)" ");
#line 141
    col = (spif_uint16_t )((int )col + 1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 142
  printf((char const   */* __restrict  */)"Description");
#line 143
  col = (spif_uint16_t )0;
  }
  {
#line 143
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 143
    if (! ((int )col < ((int )l_desc - 11) / 2)) {
#line 143
      goto while_break___3;
    }
    {
#line 143
    printf((char const   */* __restrict  */)" ");
#line 143
    col = (spif_uint16_t )((int )col + 1);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 144
  if (! ((int )l_desc % 2)) {
    {
#line 145
    printf((char const   */* __restrict  */)" ");
    }
  }
  {
#line 148
  printf((char const   */* __restrict  */)"\n");
#line 149
  printf((char const   */* __restrict  */)"----- ");
#line 151
  col = (spif_uint16_t )0;
  }
  {
#line 151
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 151
    if (! ((int )col < (int )l_long)) {
#line 151
      goto while_break___4;
    }
    {
#line 151
    printf((char const   */* __restrict  */)"-");
#line 151
    col = (spif_uint16_t )((int )col + 1);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 152
  printf((char const   */* __restrict  */)"  ");
#line 153
  col = (spif_uint16_t )0;
  }
  {
#line 153
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 153
    if (! ((int )col < (int )l_desc)) {
#line 153
      goto while_break___5;
    }
    {
#line 153
    printf((char const   */* __restrict  */)"-");
#line 153
    col = (spif_uint16_t )((int )col + 1);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 154
  printf((char const   */* __restrict  */)"\n");
#line 156
  i = (spif_uint16_t )0;
#line 156
  l_long = (spif_uint16_t )((int )l_long - 2);
  }
  {
#line 156
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 156
    if (! ((int )i < (int )spifopt_settings.num_opts)) {
#line 156
      goto while_break___6;
    }
#line 157
    if ((int )i < (int )spifopt_settings.num_opts) {
#line 157
      tmp___6 = (int )i;
    } else {
#line 157
      tmp___6 = 0;
    }
#line 157
    if ((spifopt_settings.opt_list + tmp___6)->short_opt) {
#line 158
      if ((int )i < (int )spifopt_settings.num_opts) {
#line 158
        tmp___5 = (int )i;
      } else {
#line 158
        tmp___5 = 0;
      }
      {
#line 158
      printf((char const   */* __restrict  */)" -%c   ", (int )(spifopt_settings.opt_list + tmp___5)->short_opt);
      }
    } else {
      {
#line 160
      printf((char const   */* __restrict  */)"      ");
      }
    }
#line 162
    if ((int )i < (int )spifopt_settings.num_opts) {
#line 162
      tmp___7 = (int )i;
    } else {
#line 162
      tmp___7 = 0;
    }
    {
#line 162
    printf((char const   */* __restrict  */)"--%s", (spifopt_settings.opt_list + tmp___7)->long_opt);
    }
#line 163
    if ((int )i < (int )spifopt_settings.num_opts) {
#line 163
      tmp___8 = (int )i;
    } else {
#line 163
      tmp___8 = 0;
    }
    {
#line 163
    tmp___9 = strlen((char const   *)((char *)(spifopt_settings.opt_list + tmp___8)->long_opt));
#line 163
    col = (spif_uint16_t )tmp___9;
    }
    {
#line 163
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 163
      if (! ((int )col < (int )l_long)) {
#line 163
        goto while_break___7;
      }
      {
#line 164
      printf((char const   */* __restrict  */)" ");
#line 163
      col = (spif_uint16_t )((int )col + 1);
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 166
    if ((int )i < (int )spifopt_settings.num_opts) {
#line 166
      tmp___10 = (int )i;
    } else {
#line 166
      tmp___10 = 0;
    }
#line 166
    if ((int )i < (int )spifopt_settings.num_opts) {
#line 166
      tmp___11 = (int )i;
    } else {
#line 166
      tmp___11 = 0;
    }
    {
#line 166
    tmp___12 = get_option_type_string((spif_uint16_t )((int )(spifopt_settings.opt_list + tmp___11)->flags & 2047));
#line 166
    printf((char const   */* __restrict  */)"  %-6s %s\n", tmp___12, (spifopt_settings.opt_list + tmp___10)->desc);
#line 156
    i = (spif_uint16_t )((int )i + 1);
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 168
  exit(1);
  }
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
static spif_int32_t find_long_option(spif_charptr_t opt ) 
{ 
  spif_int32_t j ;
  time_t tmp ;
  char *tmp___0 ;
  size_t l ;
  spif_int32_t tmp___1 ;
  time_t tmp___2 ;
  spif_int32_t tmp___3 ;
  spif_int32_t tmp___4 ;
  int tmp___5 ;
  void (*tmp___6)() ;

  {
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (libast_debug_level >= 1U) {
      {
#line 188
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 188
        tmp = time((time_t *)((void *)0));
#line 188
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                188, "find_long_option");
        }
#line 188
        if ((char *)opt) {
#line 188
          tmp___0 = (char *)opt;
        } else {
#line 188
          tmp___0 = (char *)"<opt null>";
        }
        {
#line 188
        libast_dprintf("opt == \"%s\"\n", tmp___0);
        }
#line 188
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 188
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  j = 0;
  {
#line 190
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 190
    if (! (j < (spif_int32_t )spifopt_settings.num_opts)) {
#line 190
      goto while_break___1;
    }
#line 193
    if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 193
      tmp___1 = j;
    } else {
#line 193
      tmp___1 = 0;
    }
    {
#line 193
    l = strlen((char const   *)((char *)(spifopt_settings.opt_list + tmp___1)->long_opt));
    }
#line 195
    if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 195
      tmp___4 = j;
    } else {
#line 195
      tmp___4 = 0;
    }
    {
#line 195
    tmp___5 = strncasecmp((char const   *)((char *)(spifopt_settings.opt_list + tmp___4)->long_opt),
                          (char const   *)((char *)opt), l);
    }
#line 195
    if (! tmp___5) {
#line 195
      if ((int )*(opt + l) == 61) {
#line 195
        goto _L;
      } else
#line 195
      if (! *(opt + l)) {
        _L: /* CIL Label */ 
        {
#line 198
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 198
          if (libast_debug_level >= 1U) {
            {
#line 198
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 198
              tmp___2 = time((time_t *)((void *)0));
#line 198
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___2, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                      198, "find_long_option");
              }
#line 198
              if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 198
                tmp___3 = j;
              } else {
#line 198
                tmp___3 = 0;
              }
              {
#line 198
              libast_dprintf("Match found at %d:  %s == %s\n", j, (spifopt_settings.opt_list + tmp___3)->long_opt,
                             opt);
              }
#line 198
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 198
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 199
        return (j);
      }
    }
#line 190
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 204
  libast_print_error("Unrecognized long option --%s\n", opt);
  }
  {
#line 205
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 205
    spifopt_settings.bad_opts = (spif_uint8_t )((int )spifopt_settings.bad_opts + 1);
#line 205
    if ((int )spifopt_settings.bad_opts > (int )spifopt_settings.allow_bad) {
      {
#line 205
      libast_print_error("Error threshold exceeded, giving up.\n");
      }
#line 205
      if (spifopt_settings.help_handler) {
#line 205
        tmp___6 = spifopt_settings.help_handler;
      } else {
#line 205
        tmp___6 = & spifopt_usage;
      }
      {
#line 205
      (*tmp___6)();
      }
    } else {
      {
#line 205
      libast_print_error("Attempting to continue, but strange things may happen.\n");
      }
    }
#line 205
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 206
  return (-1);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
static spif_int32_t find_short_option(char opt ) 
{ 
  spif_int32_t j ;
  time_t tmp ;
  time_t tmp___0 ;
  spif_int32_t tmp___1 ;
  spif_int32_t tmp___2 ;
  void (*tmp___3)() ;

  {
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (libast_debug_level >= 1U) {
      {
#line 226
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 226
        tmp = time((time_t *)((void *)0));
#line 226
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                226, "find_short_option");
#line 226
        libast_dprintf("opt == \"%c\"\n", (int )opt);
        }
#line 226
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 226
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  j = 0;
  {
#line 227
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 227
    if (! (j < (spif_int32_t )spifopt_settings.num_opts)) {
#line 227
      goto while_break___1;
    }
#line 228
    if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 228
      tmp___2 = j;
    } else {
#line 228
      tmp___2 = 0;
    }
#line 228
    if ((int )(spifopt_settings.opt_list + tmp___2)->short_opt == (int )opt) {
      {
#line 229
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 229
        if (libast_debug_level >= 1U) {
          {
#line 229
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 229
            tmp___0 = time((time_t *)((void *)0));
#line 229
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                    (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                    229, "find_short_option");
            }
#line 229
            if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 229
              tmp___1 = j;
            } else {
#line 229
              tmp___1 = 0;
            }
            {
#line 229
            libast_dprintf("Match found at %d:  %c == %c\n", j, (int )(spifopt_settings.opt_list + tmp___1)->short_opt,
                           (int )opt);
            }
#line 229
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 229
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 230
      return (j);
    }
#line 227
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 233
  libast_print_error("unrecognized option -%c\n", (int )opt);
  }
  {
#line 234
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 234
    spifopt_settings.bad_opts = (spif_uint8_t )((int )spifopt_settings.bad_opts + 1);
#line 234
    if ((int )spifopt_settings.bad_opts > (int )spifopt_settings.allow_bad) {
      {
#line 234
      libast_print_error("Error threshold exceeded, giving up.\n");
      }
#line 234
      if (spifopt_settings.help_handler) {
#line 234
        tmp___3 = spifopt_settings.help_handler;
      } else {
#line 234
        tmp___3 = & spifopt_usage;
      }
      {
#line 234
      (*tmp___3)();
      }
    } else {
      {
#line 234
      libast_print_error("Attempting to continue, but strange things may happen.\n");
      }
    }
#line 234
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 235
  return (-1);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
static spif_charptr_t find_value_long(spif_charptr_t arg , spif_charptr_t next_arg ,
                                      spif_charptr_t hasequal ) 
{ 
  spif_charptr_t val_ptr ;
  char *tmp ;
  time_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 260
  tmp = strchr((char const   *)((char *)arg), '=');
#line 260
  val_ptr = (spif_charptr_t )tmp;
  }
#line 260
  if ((unsigned long )val_ptr != (unsigned long )((void *)0)) {
#line 261
    val_ptr ++;
#line 262
    *hasequal = (spif_char_t )1;
  } else {
#line 264
    if (next_arg) {
#line 265
      val_ptr = next_arg;
    }
#line 267
    *hasequal = (spif_char_t )0;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (libast_debug_level >= 1U) {
      {
#line 269
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 269
        tmp___0 = time((time_t *)((void *)0));
#line 269
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                269, "find_value_long");
        }
#line 269
        if ((char *)val_ptr) {
#line 269
          tmp___1 = (char *)val_ptr;
        } else {
#line 269
          tmp___1 = (char *)"<val_ptr null>";
        }
        {
#line 269
        libast_dprintf("hasequal == %d  val_ptr == %10.8p \"%s\"\n", (int )*hasequal,
                       val_ptr, tmp___1);
        }
#line 269
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 269
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  return (val_ptr);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
static spif_charptr_t find_value_short(spif_charptr_t arg , spif_charptr_t next_arg ) 
{ 
  spif_charptr_t val_ptr ;
  time_t tmp ;
  char *tmp___0 ;

  {
#line 290
  val_ptr = (spif_charptr_t )((void *)0);
#line 292
  if (*(arg + 1)) {
#line 293
    val_ptr = arg + 1;
  } else
#line 294
  if ((unsigned long )next_arg != (unsigned long )((void *)0)) {
#line 295
    val_ptr = next_arg;
  }
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (libast_debug_level >= 1U) {
      {
#line 297
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 297
        tmp = time((time_t *)((void *)0));
#line 297
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                297, "find_value_short");
        }
#line 297
        if ((char *)val_ptr) {
#line 297
          tmp___0 = (char *)val_ptr;
        } else {
#line 297
          tmp___0 = (char *)"<val_ptr null>";
        }
        {
#line 297
        libast_dprintf("val_ptr == %10.8p \"%s\"\n", val_ptr, tmp___0);
        }
#line 297
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 297
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return (val_ptr);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
static spif_bool_t is_boolean_value(spif_charptr_t val_ptr ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 316
  if (! val_ptr) {
#line 317
    return ((spif_bool_t )0);
  } else
#line 316
  if (! *val_ptr) {
#line 317
    return ((spif_bool_t )0);
  }
  {
#line 319
  tmp___8 = strcasecmp((char const   *)((char *)val_ptr), true_vals[0]);
  }
#line 319
  if (tmp___8) {
    {
#line 319
    tmp___9 = strcasecmp((char const   *)((char *)val_ptr), true_vals[1]);
    }
#line 319
    if (tmp___9) {
      {
#line 319
      tmp___10 = strcasecmp((char const   *)((char *)val_ptr), true_vals[2]);
      }
#line 319
      if (tmp___10) {
        {
#line 319
        tmp___11 = strcasecmp((char const   *)((char *)val_ptr), true_vals[3]);
        }
#line 319
        if (tmp___11) {
          {
#line 319
          tmp___12 = strcasecmp((char const   *)((char *)val_ptr), false_vals[0]);
          }
#line 319
          if (tmp___12) {
            {
#line 319
            tmp___13 = strcasecmp((char const   *)((char *)val_ptr), false_vals[1]);
            }
#line 319
            if (tmp___13) {
              {
#line 319
              tmp___14 = strcasecmp((char const   *)((char *)val_ptr), false_vals[2]);
              }
#line 319
              if (tmp___14) {
                {
#line 319
                tmp___15 = strcasecmp((char const   *)((char *)val_ptr), false_vals[3]);
                }
#line 319
                if (tmp___15) {
#line 319
                  tmp___7 = 0;
                } else {
#line 319
                  tmp___7 = 1;
                }
              } else {
#line 319
                tmp___7 = 1;
              }
            } else {
#line 319
              tmp___7 = 1;
            }
          } else {
#line 319
            tmp___7 = 1;
          }
        } else {
#line 319
          tmp___7 = 1;
        }
      } else {
#line 319
        tmp___7 = 1;
      }
    } else {
#line 319
      tmp___7 = 1;
    }
  } else {
#line 319
    tmp___7 = 1;
  }
#line 319
  return ((spif_bool_t )tmp___7);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
static spif_bool_t is_valid_option(spif_charptr_t opt ) 
{ 
  time_t tmp ;
  spif_int32_t tmp___0 ;
  spif_int32_t tmp___1 ;

  {
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! ((unsigned long )opt != (unsigned long )((void *)0))) {
#line 338
      if (libast_debug_level >= 1U) {
        {
#line 338
        tmp = time((time_t *)((void *)0));
#line 338
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                338, "is_valid_option");
#line 338
        libast_dprintf("REQUIRE failed:  %s\n", "opt != NULL");
        }
      }
#line 338
      return ((spif_bool_t )0);
    }
#line 338
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  if ((int )*opt != 45) {
#line 341
    return ((spif_bool_t )0);
  }
#line 343
  opt ++;
#line 344
  if ((int )*opt == 45) {
    {
#line 345
    opt ++;
#line 346
    tmp___0 = find_long_option(opt);
    }
#line 346
    if (tmp___0 >= 0) {
#line 347
      return ((spif_bool_t )1);
    }
  } else {
    {
#line 350
    tmp___1 = find_short_option((char )*opt);
    }
#line 350
    if (tmp___1 >= 0) {
#line 351
      return ((spif_bool_t )1);
    }
  }
#line 354
  return ((spif_bool_t )0);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
static spif_bool_t handle_boolean(spif_int32_t n , spif_charptr_t val_ptr , unsigned char islong ) 
{ 
  time_t tmp ;
  time_t tmp___0 ;
  spif_int32_t tmp___1 ;
  spif_int32_t tmp___2 ;
  spif_int32_t tmp___3 ;
  spif_int32_t tmp___4 ;
  time_t tmp___5 ;
  spif_int32_t tmp___6 ;
  spif_int32_t tmp___7 ;
  spif_int32_t tmp___8 ;
  spif_int32_t tmp___9 ;
  time_t tmp___10 ;
  spif_int32_t tmp___11 ;
  spif_int32_t tmp___12 ;
  spif_int32_t tmp___13 ;
  spif_int32_t tmp___14 ;
  spif_int32_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  time_t tmp___24 ;
  spif_int32_t tmp___25 ;
  time_t tmp___26 ;
  spif_int32_t tmp___27 ;
  spif_int32_t tmp___28 ;
  spif_int32_t tmp___29 ;
  spif_int32_t tmp___30 ;
  spif_int32_t tmp___31 ;

  {
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (libast_debug_level >= 1U) {
      {
#line 377
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 377
        tmp = time((time_t *)((void *)0));
#line 377
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                377, "handle_boolean");
#line 377
        libast_dprintf("Boolean option detected\n");
        }
#line 377
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 377
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  if (val_ptr) {
#line 378
    if (islong) {
      {
#line 380
      tmp___20 = strcasecmp((char const   *)((char *)val_ptr), true_vals[0]);
      }
#line 380
      if (tmp___20) {
        {
#line 380
        tmp___21 = strcasecmp((char const   *)((char *)val_ptr), true_vals[1]);
        }
#line 380
        if (tmp___21) {
          {
#line 380
          tmp___22 = strcasecmp((char const   *)((char *)val_ptr), true_vals[2]);
          }
#line 380
          if (tmp___22) {
            {
#line 380
            tmp___23 = strcasecmp((char const   *)((char *)val_ptr), true_vals[3]);
            }
#line 380
            if (tmp___23) {
              {
#line 385
              tmp___16 = strcasecmp((char const   *)((char *)val_ptr), false_vals[0]);
              }
#line 385
              if (tmp___16) {
                {
#line 385
                tmp___17 = strcasecmp((char const   *)((char *)val_ptr), false_vals[1]);
                }
#line 385
                if (tmp___17) {
                  {
#line 385
                  tmp___18 = strcasecmp((char const   *)((char *)val_ptr), false_vals[2]);
                  }
#line 385
                  if (tmp___18) {
                    {
#line 385
                    tmp___19 = strcasecmp((char const   *)((char *)val_ptr), false_vals[3]);
                    }
#line 385
                    if (tmp___19) {
#line 391
                      if ((unsigned long )spifopt_settings.flags & 1UL) {
#line 391
                        if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 391
                          tmp___14 = n;
                        } else {
#line 391
                          tmp___14 = 0;
                        }
#line 391
                        if ((unsigned long )(spifopt_settings.opt_list + tmp___14)->flags & (1UL << 11)) {
#line 391
                          goto _L___3;
                        } else {
#line 391
                          goto _L___4;
                        }
                      } else
                      _L___4: /* CIL Label */ 
#line 391
                      if (! ((unsigned long )spifopt_settings.flags & 1UL)) {
#line 391
                        if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 391
                          tmp___15 = n;
                        } else {
#line 391
                          tmp___15 = 0;
                        }
#line 391
                        if (! ((unsigned long )(spifopt_settings.opt_list + tmp___15)->flags & (1UL << 11))) {
                          _L___3: /* CIL Label */ 
                          {
#line 392
                          while (1) {
                            while_continue___1: /* CIL Label */ ;
#line 392
                            if (libast_debug_level >= 1U) {
                              {
#line 392
                              while (1) {
                                while_continue___2: /* CIL Label */ ;
                                {
#line 392
                                tmp___10 = time((time_t *)((void *)0));
#line 392
                                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                                        (unsigned long )tmp___10, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                                        392, "handle_boolean");
                                }
#line 392
                                if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 392
                                  tmp___11 = n;
                                } else {
#line 392
                                  tmp___11 = 0;
                                }
                                {
#line 392
                                libast_dprintf("Forcing option --%s to TRUE\n", (spifopt_settings.opt_list + tmp___11)->long_opt);
                                }
#line 392
                                goto while_break___2;
                              }
                              while_break___2: /* CIL Label */ ;
                              }
                            }
#line 392
                            goto while_break___1;
                          }
                          while_break___1: /* CIL Label */ ;
                          }
#line 393
                          if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 393
                            tmp___12 = n;
                          } else {
#line 393
                            tmp___12 = 0;
                          }
#line 393
                          if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 393
                            tmp___13 = n;
                          } else {
#line 393
                            tmp___13 = 0;
                          }
#line 393
                          *((unsigned long *)(spifopt_settings.opt_list + tmp___12)->value) |= (unsigned long )(spifopt_settings.opt_list + tmp___13)->mask;
                        }
                      }
#line 395
                      return ((spif_bool_t )0);
                    } else
                    _L___5: /* CIL Label */ 
#line 386
                    if ((unsigned long )spifopt_settings.flags & 1UL) {
#line 386
                      if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 386
                        tmp___8 = n;
                      } else {
#line 386
                        tmp___8 = 0;
                      }
#line 386
                      if ((unsigned long )(spifopt_settings.opt_list + tmp___8)->flags & (1UL << 11)) {
#line 386
                        goto _L___1;
                      } else {
#line 386
                        goto _L___2;
                      }
                    } else
                    _L___2: /* CIL Label */ 
#line 386
                    if (! ((unsigned long )spifopt_settings.flags & 1UL)) {
#line 386
                      if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 386
                        tmp___9 = n;
                      } else {
#line 386
                        tmp___9 = 0;
                      }
#line 386
                      if (! ((unsigned long )(spifopt_settings.opt_list + tmp___9)->flags & (1UL << 11))) {
                        _L___1: /* CIL Label */ 
                        {
#line 387
                        while (1) {
                          while_continue___3: /* CIL Label */ ;
#line 387
                          if (libast_debug_level >= 1U) {
                            {
#line 387
                            while (1) {
                              while_continue___4: /* CIL Label */ ;
                              {
#line 387
                              tmp___5 = time((time_t *)((void *)0));
#line 387
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                                      (unsigned long )tmp___5, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                                      387, "handle_boolean");
#line 387
                              libast_dprintf("\"%s\" == FALSE\n", val_ptr);
                              }
#line 387
                              goto while_break___4;
                            }
                            while_break___4: /* CIL Label */ ;
                            }
                          }
#line 387
                          goto while_break___3;
                        }
                        while_break___3: /* CIL Label */ ;
                        }
#line 388
                        if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 388
                          tmp___6 = n;
                        } else {
#line 388
                          tmp___6 = 0;
                        }
#line 388
                        if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 388
                          tmp___7 = n;
                        } else {
#line 388
                          tmp___7 = 0;
                        }
#line 388
                        *((unsigned long *)(spifopt_settings.opt_list + tmp___6)->value) &= (unsigned long )(~ (spifopt_settings.opt_list + tmp___7)->mask);
                      }
                    }
                  } else {
#line 385
                    goto _L___5;
                  }
                } else {
#line 385
                  goto _L___5;
                }
              } else {
#line 385
                goto _L___5;
              }
            } else
            _L___6: /* CIL Label */ 
#line 381
            if ((unsigned long )spifopt_settings.flags & 1UL) {
#line 381
              if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 381
                tmp___3 = n;
              } else {
#line 381
                tmp___3 = 0;
              }
#line 381
              if ((unsigned long )(spifopt_settings.opt_list + tmp___3)->flags & (1UL << 11)) {
#line 381
                goto _L;
              } else {
#line 381
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 381
            if (! ((unsigned long )spifopt_settings.flags & 1UL)) {
#line 381
              if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 381
                tmp___4 = n;
              } else {
#line 381
                tmp___4 = 0;
              }
#line 381
              if (! ((unsigned long )(spifopt_settings.opt_list + tmp___4)->flags & (1UL << 11))) {
                _L: /* CIL Label */ 
                {
#line 382
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 382
                  if (libast_debug_level >= 1U) {
                    {
#line 382
                    while (1) {
                      while_continue___6: /* CIL Label */ ;
                      {
#line 382
                      tmp___0 = time((time_t *)((void *)0));
#line 382
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                              (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                              382, "handle_boolean");
#line 382
                      libast_dprintf("\"%s\" == TRUE\n", val_ptr);
                      }
#line 382
                      goto while_break___6;
                    }
                    while_break___6: /* CIL Label */ ;
                    }
                  }
#line 382
                  goto while_break___5;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 383
                if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 383
                  tmp___1 = n;
                } else {
#line 383
                  tmp___1 = 0;
                }
#line 383
                if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 383
                  tmp___2 = n;
                } else {
#line 383
                  tmp___2 = 0;
                }
#line 383
                *((unsigned long *)(spifopt_settings.opt_list + tmp___1)->value) |= (unsigned long )(spifopt_settings.opt_list + tmp___2)->mask;
              }
            }
          } else {
#line 380
            goto _L___6;
          }
        } else {
#line 380
          goto _L___6;
        }
      } else {
#line 380
        goto _L___6;
      }
    } else {
#line 378
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 398
  if ((unsigned long )spifopt_settings.flags & 1UL) {
#line 398
    if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 398
      tmp___30 = n;
    } else {
#line 398
      tmp___30 = 0;
    }
#line 398
    if ((unsigned long )(spifopt_settings.opt_list + tmp___30)->flags & (1UL << 11)) {
#line 398
      goto _L___7;
    } else {
#line 398
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 398
  if (! ((unsigned long )spifopt_settings.flags & 1UL)) {
#line 398
    if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 398
      tmp___31 = n;
    } else {
#line 398
      tmp___31 = 0;
    }
#line 398
    if (! ((unsigned long )(spifopt_settings.opt_list + tmp___31)->flags & (1UL << 11))) {
      _L___7: /* CIL Label */ 
#line 400
      if (islong) {
        {
#line 401
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 401
          if (libast_debug_level >= 1U) {
            {
#line 401
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 401
              tmp___24 = time((time_t *)((void *)0));
#line 401
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___24, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                      401, "handle_boolean");
              }
#line 401
              if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 401
                tmp___25 = n;
              } else {
#line 401
                tmp___25 = 0;
              }
              {
#line 401
              libast_dprintf("Forcing option --%s to TRUE\n", (spifopt_settings.opt_list + tmp___25)->long_opt);
              }
#line 401
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
#line 401
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
#line 403
        val_ptr = (spif_charptr_t )((void *)0);
        {
#line 404
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 404
          if (libast_debug_level >= 1U) {
            {
#line 404
            while (1) {
              while_continue___10: /* CIL Label */ ;
              {
#line 404
              tmp___26 = time((time_t *)((void *)0));
#line 404
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___26, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                      404, "handle_boolean");
              }
#line 404
              if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 404
                tmp___27 = n;
              } else {
#line 404
                tmp___27 = 0;
              }
              {
#line 404
              libast_dprintf("Forcing option -%c to TRUE\n", (int )(spifopt_settings.opt_list + tmp___27)->short_opt);
              }
#line 404
              goto while_break___10;
            }
            while_break___10: /* CIL Label */ ;
            }
          }
#line 404
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
#line 406
      if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 406
        tmp___28 = n;
      } else {
#line 406
        tmp___28 = 0;
      }
#line 406
      if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 406
        tmp___29 = n;
      } else {
#line 406
        tmp___29 = 0;
      }
#line 406
      *((unsigned long *)(spifopt_settings.opt_list + tmp___28)->value) |= (unsigned long )(spifopt_settings.opt_list + tmp___29)->mask;
    }
  }
#line 409
  return ((spif_bool_t )1);
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
static void handle_integer(spif_int32_t n , spif_charptr_t val_ptr ) 
{ 
  time_t tmp ;
  spif_int32_t tmp___0 ;
  long tmp___1 ;

  {
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (libast_debug_level >= 1U) {
      {
#line 429
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 429
        tmp = time((time_t *)((void *)0));
#line 429
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                429, "handle_integer");
#line 429
        libast_dprintf("Integer option detected\n");
        }
#line 429
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 429
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 430
    tmp___0 = n;
  } else {
#line 430
    tmp___0 = 0;
  }
  {
#line 430
  tmp___1 = strtol((char const   */* __restrict  */)((char *)val_ptr), (char **/* __restrict  */)((char **)((void *)0)),
                   0);
#line 430
  *((int *)(spifopt_settings.opt_list + tmp___0)->value) = (int )tmp___1;
  }
#line 431
  return;
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
static void handle_string(spif_int32_t n , spif_charptr_t val_ptr ) 
{ 
  time_t tmp ;
  spif_int32_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (libast_debug_level >= 1U) {
      {
#line 450
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 450
        tmp = time((time_t *)((void *)0));
#line 450
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                450, "handle_string");
#line 450
        libast_dprintf("String option detected\n");
        }
#line 450
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 450
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 451
    tmp___0 = n;
  } else {
#line 451
    tmp___0 = 0;
  }
  {
#line 451
  tmp___1 = strdup((char const   *)((char *)val_ptr));
#line 451
  *((char const   **)(spifopt_settings.opt_list + tmp___0)->value) = (char const   *)tmp___1;
  }
#line 452
  return;
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
static void handle_arglist(spif_int32_t n , spif_charptr_t val_ptr , unsigned char hasequal ,
                           spif_int32_t i , int argc , char **argv ) 
{ 
  spif_charptr_t *tmp ;
  register unsigned short k ;
  time_t tmp___0 ;
  unsigned long tmp___1 ;
  void *tmp___2 ;
  time_t tmp___3 ;
  spif_int32_t tmp___4 ;
  unsigned short len ;
  void *tmp___5 ;
  char *tmp___6 ;
  time_t tmp___7 ;
  spif_int32_t tmp___8 ;

  {
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (libast_debug_level >= 1U) {
      {
#line 480
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 480
        tmp___0 = time((time_t *)((void *)0));
#line 480
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                480, "handle_arglist");
#line 480
        libast_dprintf("Argument list option detected\n");
        }
#line 480
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 480
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  if (hasequal) {
    {
#line 483
    tmp___1 = spiftool_num_words((spif_charptr_t const   )val_ptr);
#line 483
    tmp___2 = malloc(sizeof(spif_charptr_t ) * (tmp___1 + 1UL));
#line 483
    tmp = (spif_charptr_t *)tmp___2;
#line 485
    k = (unsigned short)0;
    }
    {
#line 485
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 485
      if (! val_ptr) {
#line 485
        goto while_break___1;
      }
      {
#line 486
      *(tmp + k) = spiftool_get_word(1UL, (spif_charptr_t const   )val_ptr);
#line 487
      val_ptr = spiftool_get_pword(2UL, (spif_charptr_t const   )val_ptr);
      }
      {
#line 488
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 488
        if (libast_debug_level >= 1U) {
          {
#line 488
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 488
            tmp___3 = time((time_t *)((void *)0));
#line 488
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                    (unsigned long )tmp___3, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                    488, "handle_arglist");
#line 488
            libast_dprintf("tmp[%d] == %s\n", (int )k, *(tmp + k));
            }
#line 488
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 488
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 485
      k = (unsigned short )((int )k + 1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 490
    *(tmp + k) = (spif_charptr_t )((void *)0);
#line 491
    if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 491
      tmp___4 = n;
    } else {
#line 491
      tmp___4 = 0;
    }
#line 491
    *((spif_charptr_t **)(spifopt_settings.opt_list + tmp___4)->value) = tmp;
  } else {
    {
#line 493
    len = (unsigned short )(argc - i);
#line 496
    tmp___5 = malloc(sizeof(spif_charptr_t ) * (unsigned long )((argc - i) + 1));
#line 496
    tmp = (spif_charptr_t *)tmp___5;
#line 498
    k = (unsigned short)0;
    }
    {
#line 498
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 498
      if (! ((int )k < (int )len)) {
#line 498
        goto while_break___4;
      }
      {
#line 499
      tmp___6 = strdup((char const   *)*(argv + ((int )k + i)));
#line 499
      *(tmp + k) = (spif_charptr_t )tmp___6;
      }
      {
#line 500
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 500
        if (libast_debug_level >= 1U) {
          {
#line 500
          while (1) {
            while_continue___6: /* CIL Label */ ;
            {
#line 500
            tmp___7 = time((time_t *)((void *)0));
#line 500
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                    (unsigned long )tmp___7, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                    500, "handle_arglist");
#line 500
            libast_dprintf("tmp[%d] == %s\n", (int )k, *(tmp + k));
            }
#line 500
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 500
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 501
      *(argv + ((int )k + i)) = (char *)((void *)0);
#line 498
      k = (unsigned short )((int )k + 1);
    }
    while_break___4: /* CIL Label */ ;
    }
#line 503
    *(tmp + k) = (spif_charptr_t )((void *)0);
#line 504
    if (n < (spif_int32_t )spifopt_settings.num_opts) {
#line 504
      tmp___8 = n;
    } else {
#line 504
      tmp___8 = 0;
    }
#line 504
    *((spif_charptr_t **)(spifopt_settings.opt_list + tmp___8)->value) = tmp;
  }
#line 506
  return;
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c"
void spifopt_parse(int argc , char **argv ) 
{ 
  spif_int32_t i ;
  spif_int32_t j ;
  spif_charptr_t opt ;
  time_t tmp ;
  time_t tmp___0 ;
  spif_charptr_t val_ptr ;
  spif_char_t islong ;
  spif_char_t hasequal ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  int tmp___3 ;
  time_t tmp___4 ;
  time_t tmp___5 ;
  time_t tmp___6 ;
  time_t tmp___7 ;
  spif_int32_t tmp___8 ;
  spif_bool_t tmp___9 ;
  spif_int32_t tmp___10 ;
  spif_bool_t tmp___11 ;
  size_t tmp___12 ;
  spif_str_t warn ;
  spif_int32_t tmp___13 ;
  spif_int32_t tmp___14 ;
  spif_int32_t tmp___15 ;
  spif_charptr_t tmp___16 ;
  spif_int32_t tmp___17 ;
  char const   *tmp___21 ;
  spif_int32_t tmp___22 ;
  char const   *tmp___23 ;
  spif_int32_t tmp___24 ;
  char const   *tmp___25 ;
  spif_int32_t tmp___26 ;
  spif_int32_t tmp___27 ;
  char const   *tmp___31 ;
  spif_int32_t tmp___32 ;
  char const   *tmp___33 ;
  spif_int32_t tmp___34 ;
  char const   *tmp___35 ;
  spif_int32_t tmp___36 ;
  spif_int32_t tmp___37 ;
  void (*tmp___38)() ;
  time_t tmp___39 ;
  time_t tmp___40 ;
  time_t tmp___41 ;
  time_t tmp___42 ;
  spif_int32_t tmp___43 ;
  time_t tmp___44 ;
  time_t tmp___45 ;
  time_t tmp___46 ;
  time_t tmp___47 ;
  spif_int32_t tmp___48 ;
  spif_int32_t tmp___49 ;
  spif_int32_t tmp___50 ;
  spif_bool_t tmp___51 ;
  spif_int32_t tmp___52 ;
  spif_int32_t tmp___53 ;
  spif_int32_t tmp___54 ;
  spif_int32_t tmp___55 ;
  spif_int32_t tmp___56 ;
  spif_int32_t tmp___57 ;
  time_t tmp___58 ;
  spif_int32_t tmp___59 ;
  spif_int32_t tmp___60 ;
  spif_int32_t tmp___61 ;
  spif_int32_t tmp___62 ;
  spif_int32_t tmp___63 ;
  spif_int32_t tmp___64 ;
  spif_int32_t tmp___65 ;
  spif_int32_t tmp___66 ;
  time_t tmp___67 ;
  time_t tmp___68 ;
  time_t tmp___69 ;
  time_t tmp___70 ;

  {
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (! (argc > 1)) {
#line 527
      if (libast_debug_level >= 1U) {
        {
#line 527
        tmp = time((time_t *)((void *)0));
#line 527
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                527, "spifopt_parse");
#line 527
        libast_dprintf("REQUIRE failed:  %s\n", "argc > 1");
        }
      }
#line 527
      return;
    }
#line 527
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 528
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 528
    if (! ((unsigned long )argv != (unsigned long )((void *)0))) {
#line 528
      if (libast_debug_level >= 1U) {
        {
#line 528
        tmp___0 = time((time_t *)((void *)0));
#line 528
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                528, "spifopt_parse");
#line 528
        libast_dprintf("REQUIRE failed:  %s\n", "argv != NULL");
        }
      }
#line 528
      return;
    }
#line 528
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 531
  i = 1;
#line 531
  opt = (spif_charptr_t )*(argv + 1);
  {
#line 531
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 531
    if (! (i < argc)) {
#line 531
      goto while_break___1;
    }
#line 532
    val_ptr = (spif_charptr_t )((void *)0);
#line 533
    islong = (spif_char_t )0;
#line 533
    hasequal = (spif_char_t )0;
    {
#line 535
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 535
      if (libast_debug_level >= 1U) {
        {
#line 535
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 535
          tmp___1 = time((time_t *)((void *)0));
#line 535
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                  535, "spifopt_parse");
#line 535
          libast_dprintf("argv[%d] == \"%s\", opt == \"%s\"\n", i, *(argv + i), opt);
          }
#line 535
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 535
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 537
    if ((unsigned long )((spif_ptr_t )opt) == (unsigned long )((void *)0)) {
#line 537
      tmp___3 = 1;
    } else {
#line 537
      tmp___3 = 0;
    }
#line 537
    if (tmp___3) {
#line 539
      goto while_break___1;
    } else
#line 540
    if ((unsigned long )opt == (unsigned long )((spif_charptr_t )*(argv + i))) {
#line 542
      if ((int )*opt != 45) {
        {
#line 543
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 543
          if (libast_debug_level >= 1U) {
            {
#line 543
            while (1) {
              while_continue___5: /* CIL Label */ ;
              {
#line 543
              tmp___2 = time((time_t *)((void *)0));
#line 543
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___2, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                      543, "spifopt_parse");
#line 543
              libast_dprintf("NEXT_ARG()\n");
              }
#line 543
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
#line 543
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 543
        i ++;
#line 543
        opt = (spif_charptr_t )*(argv + i);
#line 543
        goto __Cont;
      } else {
#line 545
        opt ++;
      }
    }
#line 550
    if ((int )*opt == 45) {
#line 551
      islong = (spif_char_t )1;
#line 553
      opt ++;
      {
#line 554
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 554
        if (libast_debug_level >= 1U) {
          {
#line 554
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 554
            tmp___4 = time((time_t *)((void *)0));
#line 554
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                    (unsigned long )tmp___4, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                    554, "spifopt_parse");
#line 554
            libast_dprintf("Long option detected\n");
            }
#line 554
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
#line 554
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 555
      j = find_long_option(opt);
      }
#line 555
      if (j == -1) {
        {
#line 556
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 556
          if (libast_debug_level >= 1U) {
            {
#line 556
            while (1) {
              while_continue___9: /* CIL Label */ ;
              {
#line 556
              tmp___5 = time((time_t *)((void *)0));
#line 556
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___5, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                      556, "spifopt_parse");
#line 556
              libast_dprintf("NEXT_ARG()\n");
              }
#line 556
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
#line 556
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 556
        i ++;
#line 556
        opt = (spif_charptr_t )*(argv + i);
#line 556
        goto __Cont;
      }
    } else {
      {
#line 559
      j = find_short_option((char )*opt);
      }
#line 559
      if (j == -1) {
        {
#line 560
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 560
          if (libast_debug_level >= 1U) {
            {
#line 560
            while (1) {
              while_continue___11: /* CIL Label */ ;
              {
#line 560
              tmp___6 = time((time_t *)((void *)0));
#line 560
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___6, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                      560, "spifopt_parse");
#line 560
              libast_dprintf("NEXT_LETTER(%s)\n", opt);
              }
#line 560
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
          }
#line 560
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 560
        if (*(opt + 1)) {
#line 560
          opt ++;
        } else {
          {
#line 560
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 560
            if (libast_debug_level >= 1U) {
              {
#line 560
              while (1) {
                while_continue___13: /* CIL Label */ ;
                {
#line 560
                tmp___7 = time((time_t *)((void *)0));
#line 560
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                        (unsigned long )tmp___7, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                        560, "spifopt_parse");
#line 560
                libast_dprintf("NEXT_ARG()\n");
                }
#line 560
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
            }
#line 560
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 560
          i ++;
#line 560
          opt = (spif_charptr_t )*(argv + i);
#line 560
          goto __Cont;
        }
#line 560
        goto __Cont;
      }
    }
#line 563
    if (! ((unsigned long )spifopt_settings.flags & 1UL)) {
#line 564
      *(argv + i) = (char *)((void *)0);
    }
#line 568
    if (islong) {
      {
#line 569
      val_ptr = find_value_long(opt, (spif_charptr_t )*(argv + (i + 1)), & hasequal);
      }
    } else {
      {
#line 571
      val_ptr = find_value_short(opt, (spif_charptr_t )*(argv + (i + 1)));
      }
    }
#line 575
    if (val_ptr) {
#line 576
      if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 576
        tmp___10 = j;
      } else {
#line 576
        tmp___10 = 0;
      }
#line 576
      if ((unsigned long )(spifopt_settings.opt_list + tmp___10)->flags & 1UL) {
        {
#line 576
        tmp___11 = is_boolean_value(val_ptr);
        }
#line 576
        if (tmp___11) {
#line 576
          goto _L;
        } else {
#line 577
          val_ptr = (spif_charptr_t )((void *)0);
        }
      } else {
        _L: /* CIL Label */ 
#line 578
        if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 578
          tmp___8 = j;
        } else {
#line 578
          tmp___8 = 0;
        }
#line 578
        if ((unsigned long )(spifopt_settings.opt_list + tmp___8)->flags & (1UL << 10)) {
          {
#line 578
          tmp___9 = is_valid_option(val_ptr);
          }
#line 578
          if (tmp___9) {
#line 579
            val_ptr = (spif_charptr_t )((void *)0);
          }
        }
      }
    }
#line 582
    if (val_ptr) {
#line 583
      if ((unsigned long )val_ptr == (unsigned long )((spif_charptr_t )*(argv + (i + 1)))) {
        {
#line 584
        i ++;
#line 585
        tmp___12 = strlen((char const   *)((char *)opt));
#line 585
        opt += tmp___12;
        }
      }
    }
#line 590
    if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 590
      tmp___17 = j;
    } else {
#line 590
      tmp___17 = 0;
    }
#line 590
    if ((unsigned long )(spifopt_settings.opt_list + tmp___17)->flags & (1UL << 12)) {
      {
#line 593
      warn = spif_str_new_from_buff((spif_charptr_t )"The ", (spif_stridx_t )128);
      }
#line 594
      if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 594
        tmp___14 = j;
      } else {
#line 594
        tmp___14 = 0;
      }
#line 594
      if ((spifopt_settings.opt_list + tmp___14)->short_opt) {
        {
#line 595
        spif_str_append_char(warn, (spif_char_t )'-');
        }
#line 596
        if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 596
          tmp___13 = j;
        } else {
#line 596
          tmp___13 = 0;
        }
        {
#line 596
        spif_str_append_char(warn, (spifopt_settings.opt_list + tmp___13)->short_opt);
#line 597
        spif_str_append_from_ptr(warn, (spif_charptr_t )" / --");
        }
      } else {
        {
#line 599
        spif_str_append_from_ptr(warn, (spif_charptr_t )"--");
        }
      }
#line 601
      if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 601
        tmp___15 = j;
      } else {
#line 601
        tmp___15 = 0;
      }
      {
#line 601
      spif_str_append_from_ptr(warn, (spifopt_settings.opt_list + tmp___15)->long_opt);
#line 602
      spif_str_append_from_ptr(warn, (spif_charptr_t )" option is deprecated and should not be used.\n");
      }
#line 603
      if ((unsigned long )((spif_obj_t )warn) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 603
        tmp___16 = (spif_charptr_t )"";
      } else {
#line 603
        tmp___16 = warn->s;
      }
      {
#line 603
      libast_print_warning((char const   *)((char *)((spif_charptr_t const   )tmp___16)));
#line 604
      spif_str_del(warn);
      }
    }
#line 608
    if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 608
      tmp___50 = j;
    } else {
#line 608
      tmp___50 = 0;
    }
#line 608
    if ((int )(spifopt_settings.opt_list + tmp___50)->flags & 992) {
#line 609
      if ((unsigned long )val_ptr == (unsigned long )((void *)0)) {
#line 610
        if (islong) {
#line 611
          if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 611
            tmp___26 = j;
          } else {
#line 611
            tmp___26 = 0;
          }
#line 611
          if ((unsigned long )(spifopt_settings.opt_list + tmp___26)->flags & (1UL << 5)) {
#line 611
            tmp___25 = "n integer";
          } else {
#line 611
            if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 611
              tmp___24 = j;
            } else {
#line 611
              tmp___24 = 0;
            }
#line 611
            if ((unsigned long )(spifopt_settings.opt_list + tmp___24)->flags & (1UL << 6)) {
#line 611
              tmp___23 = " string";
            } else {
#line 611
              if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 611
                tmp___22 = j;
              } else {
#line 611
                tmp___22 = 0;
              }
#line 611
              if ((unsigned long )(spifopt_settings.opt_list + tmp___22)->flags & (1UL << 7)) {
#line 611
                tmp___21 = "n argument list";
              } else {
#line 611
                tmp___21 = "";
              }
#line 611
              tmp___23 = tmp___21;
            }
#line 611
            tmp___25 = tmp___23;
          }
#line 611
          if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 611
            tmp___27 = j;
          } else {
#line 611
            tmp___27 = 0;
          }
          {
#line 611
          libast_print_error("long option --%s requires a%s value\n", (spifopt_settings.opt_list + tmp___27)->long_opt,
                             tmp___25);
          }
        } else {
#line 620
          if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 620
            tmp___36 = j;
          } else {
#line 620
            tmp___36 = 0;
          }
#line 620
          if ((unsigned long )(spifopt_settings.opt_list + tmp___36)->flags & (1UL << 5)) {
#line 620
            tmp___35 = "n integer";
          } else {
#line 620
            if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 620
              tmp___34 = j;
            } else {
#line 620
              tmp___34 = 0;
            }
#line 620
            if ((unsigned long )(spifopt_settings.opt_list + tmp___34)->flags & (1UL << 6)) {
#line 620
              tmp___33 = " string";
            } else {
#line 620
              if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 620
                tmp___32 = j;
              } else {
#line 620
                tmp___32 = 0;
              }
#line 620
              if ((unsigned long )(spifopt_settings.opt_list + tmp___32)->flags & (1UL << 7)) {
#line 620
                tmp___31 = "n argument list";
              } else {
#line 620
                tmp___31 = "";
              }
#line 620
              tmp___33 = tmp___31;
            }
#line 620
            tmp___35 = tmp___33;
          }
#line 620
          if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 620
            tmp___37 = j;
          } else {
#line 620
            tmp___37 = 0;
          }
          {
#line 620
          libast_print_error("option -%c requires a%s value\n", (int )(spifopt_settings.opt_list + tmp___37)->short_opt,
                             tmp___35);
          }
        }
        {
#line 629
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 629
          spifopt_settings.bad_opts = (spif_uint8_t )((int )spifopt_settings.bad_opts + 1);
#line 629
          if ((int )spifopt_settings.bad_opts > (int )spifopt_settings.allow_bad) {
            {
#line 629
            libast_print_error("Error threshold exceeded, giving up.\n");
            }
#line 629
            if (spifopt_settings.help_handler) {
#line 629
              tmp___38 = spifopt_settings.help_handler;
            } else {
#line 629
              tmp___38 = & spifopt_usage;
            }
            {
#line 629
            (*tmp___38)();
            }
          } else {
            {
#line 629
            libast_print_error("Attempting to continue, but strange things may happen.\n");
            }
          }
#line 629
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 630
        goto __Cont;
      }
#line 633
      if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 633
        tmp___43 = j;
      } else {
#line 633
        tmp___43 = 0;
      }
#line 633
      if ((unsigned long )(spifopt_settings.opt_list + tmp___43)->value == (unsigned long )((void *)0)) {
        {
#line 634
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 634
          if (libast_debug_level >= 1U) {
            {
#line 634
            while (1) {
              while_continue___16: /* CIL Label */ ;
              {
#line 634
              tmp___39 = time((time_t *)((void *)0));
#line 634
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___39, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                      634, "spifopt_parse");
#line 634
              libast_dprintf("NEXT_LOOP()\n");
              }
#line 634
              goto while_break___16;
            }
            while_break___16: /* CIL Label */ ;
            }
          }
#line 634
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 634
        if (islong) {
#line 634
          goto _L___0;
        } else
#line 634
        if (val_ptr) {
          _L___0: /* CIL Label */ 
          {
#line 634
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 634
            if (libast_debug_level >= 1U) {
              {
#line 634
              while (1) {
                while_continue___18: /* CIL Label */ ;
                {
#line 634
                tmp___40 = time((time_t *)((void *)0));
#line 634
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                        (unsigned long )tmp___40, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                        634, "spifopt_parse");
#line 634
                libast_dprintf("NEXT_ARG()\n");
                }
#line 634
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
            }
#line 634
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
#line 634
          i ++;
#line 634
          opt = (spif_charptr_t )*(argv + i);
#line 634
          goto __Cont;
        } else {
          {
#line 634
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 634
            if (libast_debug_level >= 1U) {
              {
#line 634
              while (1) {
                while_continue___20: /* CIL Label */ ;
                {
#line 634
                tmp___41 = time((time_t *)((void *)0));
#line 634
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                        (unsigned long )tmp___41, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                        634, "spifopt_parse");
#line 634
                libast_dprintf("NEXT_LETTER(%s)\n", opt);
                }
#line 634
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
#line 634
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 634
          if (*(opt + 1)) {
#line 634
            opt ++;
          } else {
            {
#line 634
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 634
              if (libast_debug_level >= 1U) {
                {
#line 634
                while (1) {
                  while_continue___22: /* CIL Label */ ;
                  {
#line 634
                  tmp___42 = time((time_t *)((void *)0));
#line 634
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                          (unsigned long )tmp___42, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                          634, "spifopt_parse");
#line 634
                  libast_dprintf("NEXT_ARG()\n");
                  }
#line 634
                  goto while_break___22;
                }
                while_break___22: /* CIL Label */ ;
                }
              }
#line 634
              goto while_break___21;
            }
            while_break___21: /* CIL Label */ ;
            }
#line 634
            i ++;
#line 634
            opt = (spif_charptr_t )*(argv + i);
#line 634
            goto __Cont;
          }
#line 634
          goto __Cont;
        }
      }
    } else {
#line 636
      if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 636
        tmp___48 = j;
      } else {
#line 636
        tmp___48 = 0;
      }
#line 636
      if ((unsigned long )(spifopt_settings.opt_list + tmp___48)->flags & (1UL << 10)) {
#line 636
        if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 636
          tmp___49 = j;
        } else {
#line 636
          tmp___49 = 0;
        }
#line 636
        if ((unsigned long )(spifopt_settings.opt_list + tmp___49)->value == (unsigned long )((void *)0)) {
          {
#line 638
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 638
            if (libast_debug_level >= 1U) {
              {
#line 638
              while (1) {
                while_continue___24: /* CIL Label */ ;
                {
#line 638
                tmp___44 = time((time_t *)((void *)0));
#line 638
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                        (unsigned long )tmp___44, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                        638, "spifopt_parse");
#line 638
                libast_dprintf("NEXT_LOOP()\n");
                }
#line 638
                goto while_break___24;
              }
              while_break___24: /* CIL Label */ ;
              }
            }
#line 638
            goto while_break___23;
          }
          while_break___23: /* CIL Label */ ;
          }
#line 638
          if (islong) {
#line 638
            goto _L___1;
          } else
#line 638
          if (val_ptr) {
            _L___1: /* CIL Label */ 
            {
#line 638
            while (1) {
              while_continue___25: /* CIL Label */ ;
#line 638
              if (libast_debug_level >= 1U) {
                {
#line 638
                while (1) {
                  while_continue___26: /* CIL Label */ ;
                  {
#line 638
                  tmp___45 = time((time_t *)((void *)0));
#line 638
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                          (unsigned long )tmp___45, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                          638, "spifopt_parse");
#line 638
                  libast_dprintf("NEXT_ARG()\n");
                  }
#line 638
                  goto while_break___26;
                }
                while_break___26: /* CIL Label */ ;
                }
              }
#line 638
              goto while_break___25;
            }
            while_break___25: /* CIL Label */ ;
            }
#line 638
            i ++;
#line 638
            opt = (spif_charptr_t )*(argv + i);
#line 638
            goto __Cont;
          } else {
            {
#line 638
            while (1) {
              while_continue___27: /* CIL Label */ ;
#line 638
              if (libast_debug_level >= 1U) {
                {
#line 638
                while (1) {
                  while_continue___28: /* CIL Label */ ;
                  {
#line 638
                  tmp___46 = time((time_t *)((void *)0));
#line 638
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                          (unsigned long )tmp___46, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                          638, "spifopt_parse");
#line 638
                  libast_dprintf("NEXT_LETTER(%s)\n", opt);
                  }
#line 638
                  goto while_break___28;
                }
                while_break___28: /* CIL Label */ ;
                }
              }
#line 638
              goto while_break___27;
            }
            while_break___27: /* CIL Label */ ;
            }
#line 638
            if (*(opt + 1)) {
#line 638
              opt ++;
            } else {
              {
#line 638
              while (1) {
                while_continue___29: /* CIL Label */ ;
#line 638
                if (libast_debug_level >= 1U) {
                  {
#line 638
                  while (1) {
                    while_continue___30: /* CIL Label */ ;
                    {
#line 638
                    tmp___47 = time((time_t *)((void *)0));
#line 638
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                            (unsigned long )tmp___47, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                            638, "spifopt_parse");
#line 638
                    libast_dprintf("NEXT_ARG()\n");
                    }
#line 638
                    goto while_break___30;
                  }
                  while_break___30: /* CIL Label */ ;
                  }
                }
#line 638
                goto while_break___29;
              }
              while_break___29: /* CIL Label */ ;
              }
#line 638
              i ++;
#line 638
              opt = (spif_charptr_t )*(argv + i);
#line 638
              goto __Cont;
            }
#line 638
            goto __Cont;
          }
        }
      }
    }
#line 641
    if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 641
      tmp___66 = j;
    } else {
#line 641
      tmp___66 = 0;
    }
#line 641
    if ((unsigned long )(spifopt_settings.opt_list + tmp___66)->flags & 1UL) {
      {
#line 642
      tmp___51 = handle_boolean(j, val_ptr, (unsigned char )islong);
      }
#line 642
      if (! tmp___51) {
#line 643
        i --;
      }
    } else {
#line 645
      if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 645
        tmp___65 = j;
      } else {
#line 645
        tmp___65 = 0;
      }
#line 645
      if ((unsigned long )(spifopt_settings.opt_list + tmp___65)->flags & (1UL << 6)) {
#line 646
        if ((unsigned long )spifopt_settings.flags & 1UL) {
#line 646
          if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 646
            tmp___52 = j;
          } else {
#line 646
            tmp___52 = 0;
          }
#line 646
          if ((unsigned long )(spifopt_settings.opt_list + tmp___52)->flags & (1UL << 11)) {
            {
#line 647
            handle_string(j, val_ptr);
            }
          } else {
#line 646
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 646
        if (! ((unsigned long )spifopt_settings.flags & 1UL)) {
#line 646
          if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 646
            tmp___53 = j;
          } else {
#line 646
            tmp___53 = 0;
          }
#line 646
          if (! ((unsigned long )(spifopt_settings.opt_list + tmp___53)->flags & (1UL << 11))) {
            {
#line 647
            handle_string(j, val_ptr);
            }
          }
        }
      } else {
#line 649
        if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 649
          tmp___64 = j;
        } else {
#line 649
          tmp___64 = 0;
        }
#line 649
        if ((unsigned long )(spifopt_settings.opt_list + tmp___64)->flags & (1UL << 5)) {
#line 650
          if ((unsigned long )spifopt_settings.flags & 1UL) {
#line 650
            if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 650
              tmp___54 = j;
            } else {
#line 650
              tmp___54 = 0;
            }
#line 650
            if ((unsigned long )(spifopt_settings.opt_list + tmp___54)->flags & (1UL << 11)) {
              {
#line 651
              handle_integer(j, val_ptr);
              }
            } else {
#line 650
              goto _L___3;
            }
          } else
          _L___3: /* CIL Label */ 
#line 650
          if (! ((unsigned long )spifopt_settings.flags & 1UL)) {
#line 650
            if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 650
              tmp___55 = j;
            } else {
#line 650
              tmp___55 = 0;
            }
#line 650
            if (! ((unsigned long )(spifopt_settings.opt_list + tmp___55)->flags & (1UL << 11))) {
              {
#line 651
              handle_integer(j, val_ptr);
              }
            }
          }
        } else {
#line 653
          if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 653
            tmp___63 = j;
          } else {
#line 653
            tmp___63 = 0;
          }
#line 653
          if ((unsigned long )(spifopt_settings.opt_list + tmp___63)->flags & (1UL << 7)) {
#line 654
            if ((unsigned long )spifopt_settings.flags & 1UL) {
#line 654
              if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 654
                tmp___56 = j;
              } else {
#line 654
                tmp___56 = 0;
              }
#line 654
              if ((unsigned long )(spifopt_settings.opt_list + tmp___56)->flags & (1UL << 11)) {
                {
#line 655
                handle_arglist(j, val_ptr, (unsigned char )hasequal, i, argc, argv);
                }
              } else {
#line 654
                goto _L___4;
              }
            } else
            _L___4: /* CIL Label */ 
#line 654
            if (! ((unsigned long )spifopt_settings.flags & 1UL)) {
#line 654
              if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 654
                tmp___57 = j;
              } else {
#line 654
                tmp___57 = 0;
              }
#line 654
              if (! ((unsigned long )(spifopt_settings.opt_list + tmp___57)->flags & (1UL << 11))) {
                {
#line 655
                handle_arglist(j, val_ptr, (unsigned char )hasequal, i, argc, argv);
                }
              }
            }
#line 657
            if (! hasequal) {
#line 658
              goto while_break___1;
            }
          } else {
#line 660
            if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 660
              tmp___62 = j;
            } else {
#line 660
              tmp___62 = 0;
            }
#line 660
            if ((unsigned long )(spifopt_settings.opt_list + tmp___62)->flags & (1UL << 10)) {
#line 661
              if ((unsigned long )spifopt_settings.flags & 1UL) {
#line 661
                if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 661
                  tmp___60 = j;
                } else {
#line 661
                  tmp___60 = 0;
                }
#line 661
                if ((unsigned long )(spifopt_settings.opt_list + tmp___60)->flags & (1UL << 11)) {
#line 661
                  goto _L___5;
                } else {
#line 661
                  goto _L___6;
                }
              } else
              _L___6: /* CIL Label */ 
#line 661
              if (! ((unsigned long )spifopt_settings.flags & 1UL)) {
#line 661
                if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 661
                  tmp___61 = j;
                } else {
#line 661
                  tmp___61 = 0;
                }
#line 661
                if (! ((unsigned long )(spifopt_settings.opt_list + tmp___61)->flags & (1UL << 11))) {
                  _L___5: /* CIL Label */ 
                  {
#line 662
                  while (1) {
                    while_continue___31: /* CIL Label */ ;
#line 662
                    if (libast_debug_level >= 1U) {
                      {
#line 662
                      while (1) {
                        while_continue___32: /* CIL Label */ ;
                        {
#line 662
                        tmp___58 = time((time_t *)((void *)0));
#line 662
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                                (unsigned long )tmp___58, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                                662, "spifopt_parse");
#line 662
                        libast_dprintf("Abstract option detected\n");
                        }
#line 662
                        goto while_break___32;
                      }
                      while_break___32: /* CIL Label */ ;
                      }
                    }
#line 662
                    goto while_break___31;
                  }
                  while_break___31: /* CIL Label */ ;
                  }
#line 663
                  if (j < (spif_int32_t )spifopt_settings.num_opts) {
#line 663
                    tmp___59 = j;
                  } else {
#line 663
                    tmp___59 = 0;
                  }
                  {
#line 663
                  (*((void (*)(spif_charptr_t  ))(spifopt_settings.opt_list + tmp___59)->value))(val_ptr);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 666
    if (! ((unsigned long )spifopt_settings.flags & 1UL)) {
#line 667
      *(argv + i) = (char *)((void *)0);
    }
    {
#line 669
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 669
      if (libast_debug_level >= 1U) {
        {
#line 669
        while (1) {
          while_continue___34: /* CIL Label */ ;
          {
#line 669
          tmp___67 = time((time_t *)((void *)0));
#line 669
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___67, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                  669, "spifopt_parse");
#line 669
          libast_dprintf("NEXT_LOOP()\n");
          }
#line 669
          goto while_break___34;
        }
        while_break___34: /* CIL Label */ ;
        }
      }
#line 669
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
#line 669
    if (islong) {
#line 669
      goto _L___7;
    } else
#line 669
    if (val_ptr) {
      _L___7: /* CIL Label */ 
      {
#line 669
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 669
        if (libast_debug_level >= 1U) {
          {
#line 669
          while (1) {
            while_continue___36: /* CIL Label */ ;
            {
#line 669
            tmp___68 = time((time_t *)((void *)0));
#line 669
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                    (unsigned long )tmp___68, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                    669, "spifopt_parse");
#line 669
            libast_dprintf("NEXT_ARG()\n");
            }
#line 669
            goto while_break___36;
          }
          while_break___36: /* CIL Label */ ;
          }
        }
#line 669
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
#line 669
      i ++;
#line 669
      opt = (spif_charptr_t )*(argv + i);
#line 669
      goto __Cont;
    } else {
      {
#line 669
      while (1) {
        while_continue___37: /* CIL Label */ ;
#line 669
        if (libast_debug_level >= 1U) {
          {
#line 669
          while (1) {
            while_continue___38: /* CIL Label */ ;
            {
#line 669
            tmp___69 = time((time_t *)((void *)0));
#line 669
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                    (unsigned long )tmp___69, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                    669, "spifopt_parse");
#line 669
            libast_dprintf("NEXT_LETTER(%s)\n", opt);
            }
#line 669
            goto while_break___38;
          }
          while_break___38: /* CIL Label */ ;
          }
        }
#line 669
        goto while_break___37;
      }
      while_break___37: /* CIL Label */ ;
      }
#line 669
      if (*(opt + 1)) {
#line 669
        opt ++;
      } else {
        {
#line 669
        while (1) {
          while_continue___39: /* CIL Label */ ;
#line 669
          if (libast_debug_level >= 1U) {
            {
#line 669
            while (1) {
              while_continue___40: /* CIL Label */ ;
              {
#line 669
              tmp___70 = time((time_t *)((void *)0));
#line 669
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___70, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/options.c",
                      669, "spifopt_parse");
#line 669
              libast_dprintf("NEXT_ARG()\n");
              }
#line 669
              goto while_break___40;
            }
            while_break___40: /* CIL Label */ ;
            }
          }
#line 669
          goto while_break___39;
        }
        while_break___39: /* CIL Label */ ;
        }
#line 669
        i ++;
#line 669
        opt = (spif_charptr_t )*(argv + i);
#line 669
        goto __Cont;
      }
#line 669
      goto __Cont;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 672
  if ((unsigned long )spifopt_settings.flags & 1UL) {
#line 673
    spifopt_settings.flags = (spif_uint8_t )((unsigned long )spifopt_settings.flags & 0xfffffffffffffffeUL);
  } else {
#line 675
    i = 1;
#line 675
    j = 1;
    {
#line 675
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 675
      if (! (i < argc)) {
#line 675
        goto while_break___41;
      }
#line 676
      if (*(argv + i)) {
#line 677
        *(argv + j) = *(argv + i);
#line 678
        j ++;
      }
#line 675
      i ++;
    }
    while_break___41: /* CIL Label */ ;
    }
#line 681
    if (j > 1) {
#line 682
      *(argv + j) = (char *)((void *)0);
    }
  }
#line 685
  return;
}
}
#line 39 "../include/libast/array.h"
spif_listclass_t spif_array_listclass ;
#line 40
spif_vectorclass_t spif_array_vectorclass ;
#line 41
spif_mapclass_t spif_array_mapclass ;
#line 40 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_array_t spif_array_list_new(void) ;
#line 41
static spif_array_t spif_array_vector_new(void) ;
#line 42
static spif_array_t spif_array_map_new(void) ;
#line 43
static spif_bool_t spif_array_list_init(spif_array_t self ) ;
#line 44
static spif_bool_t spif_array_vector_init(spif_array_t self ) ;
#line 45
static spif_bool_t spif_array_map_init(spif_array_t self ) ;
#line 46
static spif_bool_t spif_array_done(spif_array_t self ) ;
#line 47
static spif_bool_t spif_array_del(spif_array_t self ) ;
#line 48
static spif_str_t spif_array_show(spif_array_t self , spif_charptr_t name___0 , spif_str_t buff ,
                                  size_t indent ) ;
#line 49
static spif_cmp_t spif_array_comp(spif_array_t self , spif_array_t other ) ;
#line 50
static spif_array_t spif_array_list_dup(spif_array_t self ) ;
#line 51
static spif_array_t spif_array_vector_dup(spif_array_t self ) ;
#line 52
static spif_array_t spif_array_map_dup(spif_array_t self ) ;
#line 53
static spif_classname_t spif_array_type(spif_array_t self ) ;
#line 54
static spif_bool_t spif_array_append(spif_array_t self , spif_obj_t obj ) ;
#line 55
static spif_bool_t spif_array_list_contains(spif_array_t self , spif_obj_t obj ) ;
#line 56
static spif_bool_t spif_array_vector_contains(spif_array_t self , spif_obj_t obj ) ;
#line 57
static spif_listidx_t spif_array_count(spif_array_t self ) ;
#line 58
static spif_obj_t spif_array_list_find(spif_array_t self , spif_obj_t obj ) ;
#line 59
static spif_obj_t spif_array_vector_find(spif_array_t self , spif_obj_t obj ) ;
#line 60
static spif_obj_t spif_array_get(spif_array_t self , spif_listidx_t idx ) ;
#line 61
static spif_obj_t spif_array_map_get(spif_array_t self , spif_obj_t key ) ;
#line 62
static spif_list_t spif_array_get_keys(spif_array_t self , spif_list_t key_list ) ;
#line 63
static spif_list_t spif_array_get_pairs(spif_array_t self , spif_list_t pair_list ) ;
#line 64
static spif_list_t spif_array_get_values(spif_array_t self , spif_list_t value_list ) ;
#line 65
static spif_bool_t spif_array_has_key(spif_array_t self , spif_obj_t key ) ;
#line 66
static spif_bool_t spif_array_has_value(spif_array_t self , spif_obj_t value ) ;
#line 67
static spif_listidx_t spif_array_index(spif_array_t self , spif_obj_t obj ) ;
#line 68
static spif_bool_t spif_array_insert(spif_array_t self , spif_obj_t obj ) ;
#line 69
static spif_bool_t spif_array_insert_at(spif_array_t self , spif_obj_t obj , spif_listidx_t idx ) ;
#line 70
static spif_iterator_t spif_array_iterator(spif_array_t self ) ;
#line 71
static spif_bool_t spif_array_prepend(spif_array_t self , spif_obj_t obj ) ;
#line 72
static spif_obj_t spif_array_remove(spif_array_t self , spif_obj_t item ) ;
#line 73
static spif_obj_t spif_array_remove_at(spif_array_t self , spif_listidx_t idx ) ;
#line 74
static spif_obj_t spif_array_map_remove(spif_array_t self , spif_obj_t item ) ;
#line 75
static spif_bool_t spif_array_reverse(spif_array_t self ) ;
#line 76
static spif_bool_t spif_array_set(spif_array_t self , spif_obj_t key , spif_obj_t value ) ;
#line 77
static spif_obj_t *spif_array_to_array(spif_array_t self ) ;
#line 78
static spif_array_iterator_t spif_array_iterator_new(spif_array_t subject ) ;
#line 79
static spif_bool_t spif_array_iterator_init(spif_array_iterator_t self , spif_array_t subject ) ;
#line 80
static spif_bool_t spif_array_iterator_done(spif_array_iterator_t self ) ;
#line 81
static spif_bool_t spif_array_iterator_del(spif_array_iterator_t self ) ;
#line 82
static spif_str_t spif_array_iterator_show(spif_array_iterator_t self , spif_charptr_t name___0 ,
                                           spif_str_t buff , size_t indent ) ;
#line 83
static spif_cmp_t spif_array_iterator_comp(spif_array_iterator_t self , spif_array_iterator_t other ) ;
#line 84
static spif_array_iterator_t spif_array_iterator_dup(spif_array_iterator_t self ) ;
#line 85
static spif_classname_t spif_array_iterator_type(spif_array_iterator_t self ) ;
#line 86
static spif_bool_t spif_array_iterator_has_next(spif_array_iterator_t self ) ;
#line 87
static spif_obj_t spif_array_iterator_next(spif_array_iterator_t self ) ;
#line 90 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_const_listclass_t a_class  = 
#line 90
     {{(spif_charptr_t )"!spif_array_t!", (void *(*)())(& spif_array_list_new), (void *(*)())(& spif_array_list_init),
     (void *(*)())(& spif_array_done), (void *(*)())(& spif_array_del), (void *(*)())(& spif_array_show),
     (void *(*)())(& spif_array_comp), (void *(*)())(& spif_array_list_dup), (void *(*)())(& spif_array_type)},
    (void *(*)())(& spif_array_append), (void *(*)())(& spif_array_list_contains),
    (void *(*)())(& spif_array_count), (void *(*)())(& spif_array_list_find), (void *(*)())(& spif_array_get),
    (void *(*)())(& spif_array_index), (void *(*)())(& spif_array_insert), (void *(*)())(& spif_array_insert_at),
    (void *(*)())(& spif_array_iterator), (void *(*)())(& spif_array_prepend), (void *(*)())(& spif_array_remove),
    (void *(*)())(& spif_array_remove_at), (void *(*)())(& spif_array_reverse), (void *(*)())(& spif_array_to_array)};
#line 117 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
spif_listclass_t spif_array_listclass  =    & a_class;
#line 119 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_const_vectorclass_t av_class  = 
#line 119
     {{(spif_charptr_t )"!spif_array_t!", (void *(*)())(& spif_array_vector_new), (void *(*)())(& spif_array_vector_init),
     (void *(*)())(& spif_array_done), (void *(*)())(& spif_array_del), (void *(*)())(& spif_array_show),
     (void *(*)())(& spif_array_comp), (void *(*)())(& spif_array_vector_dup), (void *(*)())(& spif_array_type)},
    (void *(*)())(& spif_array_vector_contains), (void *(*)())(& spif_array_count),
    (void *(*)())(& spif_array_vector_find), (void *(*)())(& spif_array_insert), (void *(*)())(& spif_array_iterator),
    (void *(*)())(& spif_array_remove), (void *(*)())(& spif_array_to_array)};
#line 139 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
spif_vectorclass_t spif_array_vectorclass  =    & av_class;
#line 141 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_const_mapclass_t am_class  = 
#line 141
     {{(spif_charptr_t )"!spif_array_t!", (void *(*)())(& spif_array_map_new), (void *(*)())(& spif_array_map_init),
     (void *(*)())(& spif_array_done), (void *(*)())(& spif_array_del), (void *(*)())(& spif_array_show),
     (void *(*)())(& spif_array_comp), (void *(*)())(& spif_array_map_dup), (void *(*)())(& spif_array_type)},
    (void *(*)())(& spif_array_count), (void *(*)())(& spif_array_map_get), (void *(*)())(& spif_array_get_keys),
    (void *(*)())(& spif_array_get_pairs), (void *(*)())(& spif_array_get_values),
    (void *(*)())(& spif_array_has_key), (void *(*)())(& spif_array_has_value), (void *(*)())(& spif_array_iterator),
    (void *(*)())(& spif_array_map_remove), (void *(*)())(& spif_array_set)};
#line 164 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
spif_mapclass_t spif_array_mapclass  =    & am_class;
#line 166 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_const_iteratorclass_t ai_class  =    {{(spif_charptr_t )"!spif_array_t!", (void *(*)())(& spif_array_iterator_new),
     (void *(*)())(& spif_array_iterator_init), (void *(*)())(& spif_array_iterator_done),
     (void *(*)())(& spif_array_iterator_del), (void *(*)())(& spif_array_iterator_show),
     (void *(*)())(& spif_array_iterator_comp), (void *(*)())(& spif_array_iterator_dup),
     (void *(*)())(& spif_array_iterator_type)}, (void *(*)())(& spif_array_iterator_has_next),
    (void *(*)())(& spif_array_iterator_next)};
#line 181 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
spif_iteratorclass_t spif_array_iteratorclass  =    & ai_class;
#line 184 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_array_t spif_array_list_new(void) 
{ 
  spif_array_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 189
  tmp = malloc(sizeof(spif_const_array_t ));
#line 189
  self = (spif_array_t )tmp;
#line 190
  tmp___0 = spif_array_list_init(self);
  }
#line 190
  if (! tmp___0) {
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 191
      free((void *)self);
#line 191
      self = (spif_array_t )((void *)0);
      }
#line 191
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 192
    self = (spif_array_t )((void *)0);
  }
#line 194
  return (self);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_list_init(spif_array_t self ) 
{ 
  spif_bool_t tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 200
      if (libast_debug_level >= 1U) {
        {
#line 200
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_list_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           200, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 200
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_list_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             200, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 200
      return ((spif_bool_t )0);
    }
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp___0 = spif_obj_init((spif_obj_t )self);
  }
#line 201
  if (tmp___0) {
    {
#line 203
    tmp = spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_array_listclass);
    }
#line 203
    if (! tmp) {
#line 204
      return ((spif_bool_t )0);
    }
  } else {
#line 202
    return ((spif_bool_t )0);
  }
#line 206
  self->len = 0;
#line 207
  self->items = (spif_obj_t *)((void *)0);
#line 208
  return ((spif_bool_t )1);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_array_t spif_array_vector_new(void) 
{ 
  spif_array_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 216
  tmp = malloc(sizeof(spif_const_array_t ));
#line 216
  self = (spif_array_t )tmp;
#line 217
  tmp___0 = spif_array_vector_init(self);
  }
#line 217
  if (! tmp___0) {
    {
#line 218
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 218
      free((void *)self);
#line 218
      self = (spif_array_t )((void *)0);
      }
#line 218
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 219
    self = (spif_array_t )((void *)0);
  }
#line 221
  return (self);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_array_t spif_array_map_new(void) 
{ 
  spif_array_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 229
  tmp = malloc(sizeof(spif_const_array_t ));
#line 229
  self = (spif_array_t )tmp;
#line 230
  tmp___0 = spif_array_map_init(self);
  }
#line 230
  if (! tmp___0) {
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 231
      free((void *)self);
#line 231
      self = (spif_array_t )((void *)0);
      }
#line 231
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 232
    self = (spif_array_t )((void *)0);
  }
#line 234
  return (self);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_vector_init(spif_array_t self ) 
{ 
  spif_bool_t tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 240
      if (libast_debug_level >= 1U) {
        {
#line 240
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_vector_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           240, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 240
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_vector_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             240, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 240
      return ((spif_bool_t )0);
    }
#line 240
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 241
  tmp___0 = spif_obj_init((spif_obj_t )self);
  }
#line 241
  if (tmp___0) {
    {
#line 243
    tmp = spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_array_vectorclass);
    }
#line 243
    if (! tmp) {
#line 244
      return ((spif_bool_t )0);
    }
  } else {
#line 242
    return ((spif_bool_t )0);
  }
#line 246
  self->len = 0;
#line 247
  self->items = (spif_obj_t *)((void *)0);
#line 248
  return ((spif_bool_t )1);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_map_init(spif_array_t self ) 
{ 
  spif_bool_t tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 254
      if (libast_debug_level >= 1U) {
        {
#line 254
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_map_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           254, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 254
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_map_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             254, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 254
      return ((spif_bool_t )0);
    }
#line 254
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  tmp___0 = spif_obj_init((spif_obj_t )self);
  }
#line 255
  if (tmp___0) {
    {
#line 257
    tmp = spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_array_mapclass);
    }
#line 257
    if (! tmp) {
#line 258
      return ((spif_bool_t )0);
    }
  } else {
#line 256
    return ((spif_bool_t )0);
  }
#line 260
  self->len = 0;
#line 261
  self->items = (spif_obj_t *)((void *)0);
#line 262
  return ((spif_bool_t )1);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_done(spif_array_t self ) 
{ 
  spif_listidx_t i ;

  {
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 270
      if (libast_debug_level >= 1U) {
        {
#line 270
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           270, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 270
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             270, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 270
      return ((spif_bool_t )0);
    }
#line 270
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  i = 0;
  {
#line 271
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 271
    if (! (i < self->len)) {
#line 271
      goto while_break___0;
    }
#line 272
    if (! ((unsigned long )*(self->items + i) == (unsigned long )((spif_obj_t )((void *)0)))) {
      {
#line 273
      (*(((*(self->items + i))->cls)->del))(*(self->items + i));
      }
    }
#line 271
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 276
  self->len = 0;
  {
#line 277
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 277
    free((void *)self->items);
#line 277
    self->items = (spif_obj_t *)((void *)0);
    }
#line 277
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 278
  return ((spif_bool_t )1);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_del(spif_array_t self ) 
{ 
  spif_bool_t t ;

  {
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 286
      if (libast_debug_level >= 1U) {
        {
#line 286
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           286, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 286
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             286, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 286
      return ((spif_bool_t )0);
    }
#line 286
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 287
  t = spif_array_done(self);
  }
  {
#line 288
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 288
    free((void *)self);
#line 288
    self = (spif_array_t )((void *)0);
    }
#line 288
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 289
  return (t);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_str_t spif_array_show(spif_array_t self , spif_charptr_t name___0 , spif_str_t buff ,
                                  size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  spif_listidx_t i ;
  char *tmp___0 ;
  spif_obj_t o ;
  char tmp2[4096] ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
#line 298
  if ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))) {
    {
#line 299
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 299
      memset((void *)(tmp), ' ', indent);
      }
#line 299
      if ((char *)name___0) {
#line 299
        tmp___0 = (char *)name___0;
      } else {
#line 299
        tmp___0 = (char *)"<name null>";
      }
      {
#line 299
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_array_t) %s:  { ((spif_array_t) NULL) }\n",
               tmp___0);
      }
#line 299
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 299
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 299
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 299
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 300
    return (buff);
  }
  {
#line 303
  memset((void *)(tmp), ' ', indent);
#line 304
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_array_t) %s:  %10p {\n", name___0,
           (spif_ptr_t )self);
  }
#line 306
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 307
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 309
    spif_str_append_from_ptr(buff, tmp);
    }
  }
#line 312
  if ((unsigned long )((spif_array_t )self->items) == (unsigned long )((spif_array_t )((void *)0))) {
    {
#line 313
    spif_str_append_from_ptr(buff, (spif_charptr_t )"{ ((spif_obj_t *) NULL) }");
    }
  } else {
#line 315
    i = 0;
    {
#line 315
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 315
      if (! (i < self->len)) {
#line 315
        goto while_break___0;
      }
      {
#line 316
      o = *(self->items + i);
#line 317
      sprintf((char */* __restrict  */)((char *)(tmp)), (char const   */* __restrict  */)"item %d",
              i);
      }
#line 318
      if ((unsigned long )o == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 321
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 321
          memset((void *)(tmp2), ' ', indent + 2UL);
          }
#line 321
          if ((char *)(tmp)) {
#line 321
            tmp___1 = (char *)(tmp);
          } else {
#line 321
            tmp___1 = (char *)"<tmp null>";
          }
          {
#line 321
          snprintf((char */* __restrict  */)(tmp2 + (indent + 2UL)), sizeof(tmp2) - (indent + 2UL),
                   (char const   */* __restrict  */)"(spif_obj_t) %s:  { ((spif_obj_t) NULL) }\n",
                   tmp___1);
          }
#line 321
          if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
            {
#line 321
            buff = spif_str_new_from_ptr((spif_charptr_t )(tmp2));
            }
          } else {
            {
#line 321
            spif_str_append_from_ptr(buff, (spif_charptr_t )(tmp2));
            }
          }
#line 321
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 323
        tmp___2 = (*((o->cls)->show))(o, tmp, buff, indent + 2UL);
#line 323
        buff = (spif_str_t )tmp___2;
        }
      }
#line 315
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 328
  memset((void *)(tmp), ' ', indent);
#line 329
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"}\n");
#line 330
  spif_str_append_from_ptr(buff, tmp);
  }
#line 331
  return (buff);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_cmp_t spif_array_comp(spif_array_t self , spif_array_t other ) 
{ 
  spif_listidx_t i ;
  spif_cmp_t c ;
  void *tmp ;

  {
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 339
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 339
        return ((spif_cmp_t )0);
      } else {
#line 339
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 339
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 339
      return ((spif_cmp_t )-1);
    } else
#line 339
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 339
      return ((spif_cmp_t )1);
    }
#line 339
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  i = 0;
  {
#line 340
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 340
    if (! (i < self->len)) {
#line 340
      goto while_break___0;
    }
#line 343
    if ((unsigned long )*(self->items + i) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 343
      if ((unsigned long )*(other->items + i) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 344
        goto __Cont;
      } else {
#line 343
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 345
    if ((unsigned long )*(self->items + i) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 346
      return ((spif_cmp_t )-1);
    } else
#line 347
    if ((unsigned long )*(other->items + i) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 348
      return ((spif_cmp_t )1);
    }
    {
#line 350
    tmp = (*(((*(self->items + i))->cls)->comp))(*(self->items + i), *(other->items + i));
#line 350
    c = (spif_cmp_t )tmp;
    }
#line 351
    if (! ((int )c == 0)) {
#line 352
      return (c);
    }
    __Cont: /* CIL Label */ 
#line 340
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 355
  return ((spif_cmp_t )0);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_array_t spif_array_list_dup(spif_array_t self ) 
{ 
  spif_array_t tmp ;
  spif_listidx_t i ;
  time_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 364
      if (libast_debug_level >= 1U) {
        {
#line 364
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_list_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           364, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 364
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_list_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             364, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 364
      return ((spif_array_t )((void *)0));
    }
#line 364
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  tmp = spif_array_list_new();
  }
  {
#line 367
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 367
    if (! (! ((unsigned long )tmp == (unsigned long )((spif_array_t )((void *)0))))) {
#line 367
      if (libast_debug_level >= 1U) {
        {
#line 367
        tmp___0 = time((time_t *)((void *)0));
#line 367
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                367, "spif_array_list_dup");
#line 367
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_ARRAY_ISNULL(tmp)");
        }
      }
#line 367
      return ((spif_array_t )((void *)0));
    }
#line 367
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 368
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self, sizeof(spif_const_array_t ));
#line 369
  tmp___1 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 369
  tmp->items = (spif_obj_t *)tmp___1;
#line 370
  i = 0;
  }
  {
#line 370
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 370
    if (! (i < self->len)) {
#line 370
      goto while_break___1;
    }
    {
#line 371
    tmp___2 = (*(((*(self->items + i))->cls)->dup))(*(self->items + i));
#line 371
    *(tmp->items + i) = (spif_obj_t )tmp___2;
#line 370
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 373
  return (tmp);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_array_t spif_array_vector_dup(spif_array_t self ) 
{ 
  spif_array_t tmp ;
  spif_listidx_t i ;
  time_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 382
      if (libast_debug_level >= 1U) {
        {
#line 382
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_vector_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           382, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 382
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_vector_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             382, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 382
      return ((spif_array_t )((void *)0));
    }
#line 382
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 384
  tmp = spif_array_vector_new();
  }
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 385
    if (! (! ((unsigned long )tmp == (unsigned long )((spif_array_t )((void *)0))))) {
#line 385
      if (libast_debug_level >= 1U) {
        {
#line 385
        tmp___0 = time((time_t *)((void *)0));
#line 385
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                385, "spif_array_vector_dup");
#line 385
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_ARRAY_ISNULL(tmp)");
        }
      }
#line 385
      return ((spif_array_t )((void *)0));
    }
#line 385
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 386
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self, sizeof(spif_const_array_t ));
#line 387
  tmp___1 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 387
  tmp->items = (spif_obj_t *)tmp___1;
#line 388
  i = 0;
  }
  {
#line 388
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 388
    if (! (i < self->len)) {
#line 388
      goto while_break___1;
    }
    {
#line 389
    tmp___2 = (*(((*(self->items + i))->cls)->dup))(*(self->items + i));
#line 389
    *(tmp->items + i) = (spif_obj_t )tmp___2;
#line 388
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 391
  return (tmp);
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_array_t spif_array_map_dup(spif_array_t self ) 
{ 
  spif_array_t tmp ;
  spif_listidx_t i ;
  time_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 400
      if (libast_debug_level >= 1U) {
        {
#line 400
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_map_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           400, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 400
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_map_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             400, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 400
      return ((spif_array_t )((void *)0));
    }
#line 400
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 402
  tmp = spif_array_map_new();
  }
  {
#line 403
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 403
    if (! (! ((unsigned long )tmp == (unsigned long )((spif_array_t )((void *)0))))) {
#line 403
      if (libast_debug_level >= 1U) {
        {
#line 403
        tmp___0 = time((time_t *)((void *)0));
#line 403
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                403, "spif_array_map_dup");
#line 403
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_ARRAY_ISNULL(tmp)");
        }
      }
#line 403
      return ((spif_array_t )((void *)0));
    }
#line 403
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 404
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self, sizeof(spif_const_array_t ));
#line 405
  tmp___1 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 405
  tmp->items = (spif_obj_t *)tmp___1;
#line 406
  i = 0;
  }
  {
#line 406
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 406
    if (! (i < self->len)) {
#line 406
      goto while_break___1;
    }
    {
#line 407
    tmp___2 = (*(((*(self->items + i))->cls)->dup))(*(self->items + i));
#line 407
    *(tmp->items + i) = (spif_obj_t )tmp___2;
#line 406
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 409
  return (tmp);
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_classname_t spif_array_type(spif_array_t self ) 
{ 


  {
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 415
      if (libast_debug_level >= 1U) {
        {
#line 415
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           415, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 415
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             415, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 415
      return ((spif_classname_t )((void *)0));
    }
#line 415
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_append(spif_array_t self , spif_obj_t obj ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 422
      if (libast_debug_level >= 1U) {
        {
#line 422
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_append",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           422, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 422
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_append",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             422, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 422
      return ((spif_bool_t )0);
    }
#line 422
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 423
  (self->len) ++;
#line 424
  if (self->items) {
#line 425
    if (sizeof(spif_const_obj_t ) * (unsigned long )self->len) {
#line 425
      if (self->items) {
        {
#line 425
        tmp = realloc((void *)self->items, sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 425
        tmp___1 = tmp;
        }
      } else {
        {
#line 425
        tmp___0 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 425
        tmp___1 = tmp___0;
        }
      }
#line 425
      tmp___3 = tmp___1;
    } else {
#line 425
      if (self->items) {
        {
#line 425
        free((void *)self->items);
#line 425
        tmp___2 = (void *)0;
        }
      } else {
#line 425
        tmp___2 = (void *)0;
      }
#line 425
      tmp___3 = tmp___2;
    }
#line 425
    self->items = (spif_obj_t *)tmp___3;
  } else {
    {
#line 427
    tmp___4 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 427
    self->items = (spif_obj_t *)tmp___4;
    }
  }
#line 429
  *(self->items + (self->len - 1)) = obj;
#line 430
  return ((spif_bool_t )1);
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_list_contains(spif_array_t self , spif_obj_t obj ) 
{ 
  int tmp___0 ;
  spif_obj_t tmp___1 ;

  {
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 436
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 436
      if (libast_debug_level >= 1U) {
        {
#line 436
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_list_contains",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           436, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 436
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_list_contains",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             436, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 436
      return ((spif_bool_t )0);
    }
#line 436
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 437
  tmp___1 = spif_array_list_find(self, obj);
  }
#line 437
  if ((unsigned long )tmp___1 == (unsigned long )((spif_list_t )((void *)0))) {
#line 437
    tmp___0 = 0;
  } else {
#line 437
    tmp___0 = 1;
  }
#line 437
  return ((spif_bool_t )tmp___0);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_vector_contains(spif_array_t self , spif_obj_t obj ) 
{ 
  int tmp___0 ;
  spif_obj_t tmp___1 ;

  {
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 443
      if (libast_debug_level >= 1U) {
        {
#line 443
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_vector_contains",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           443, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 443
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_vector_contains",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             443, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 443
      return ((spif_bool_t )0);
    }
#line 443
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  tmp___1 = spif_array_vector_find(self, obj);
  }
#line 444
  if ((unsigned long )tmp___1 == (unsigned long )((spif_vector_t )((void *)0))) {
#line 444
    tmp___0 = 0;
  } else {
#line 444
    tmp___0 = 1;
  }
#line 444
  return ((spif_bool_t )tmp___0);
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_listidx_t spif_array_count(spif_array_t self ) 
{ 


  {
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 450
      if (libast_debug_level >= 1U) {
        {
#line 450
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_count",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           450, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 450
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_count",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             450, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 450
      return ((spif_listidx_t )((void *)0));
    }
#line 450
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  return (self->len);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_obj_t spif_array_list_find(spif_array_t self , spif_obj_t obj ) 
{ 
  spif_listidx_t i ;
  time_t tmp ;
  void *tmp___0 ;

  {
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 459
      if (libast_debug_level >= 1U) {
        {
#line 459
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_list_find",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           459, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 459
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_list_find",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             459, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 459
      return ((spif_obj_t )((void *)0));
    }
#line 459
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 460
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 460
    if (! (! ((unsigned long )obj == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 460
      if (libast_debug_level >= 1U) {
        {
#line 460
        tmp = time((time_t *)((void *)0));
#line 460
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                460, "spif_array_list_find");
#line 460
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(obj)");
        }
      }
#line 460
      return ((spif_obj_t )((void *)0));
    }
#line 460
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 461
  i = 0;
  {
#line 461
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 461
    if (! (i < self->len)) {
#line 461
      goto while_break___1;
    }
#line 462
    if ((unsigned long )*(self->items + i) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 463
      goto __Cont;
    }
    {
#line 465
    tmp___0 = (*(((*(self->items + i))->cls)->comp))(*(self->items + i), obj);
    }
#line 465
    if ((int )((spif_cmp_t )tmp___0) == 0) {
#line 466
      return (*(self->items + i));
    }
    __Cont: /* CIL Label */ 
#line 461
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 469
  return ((spif_obj_t )((void *)0));
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_obj_t spif_array_vector_find(spif_array_t self , spif_obj_t obj ) 
{ 
  spif_listidx_t start ;
  spif_listidx_t end ;
  spif_listidx_t mid ;
  spif_cmp_t diff ;
  time_t tmp ;
  time_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 478
      if (libast_debug_level >= 1U) {
        {
#line 478
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_vector_find",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           478, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 478
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_vector_find",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             478, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 478
      return ((spif_obj_t )((void *)0));
    }
#line 478
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 479
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 479
    if (! (! ((unsigned long )obj == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 479
      if (libast_debug_level >= 1U) {
        {
#line 479
        tmp = time((time_t *)((void *)0));
#line 479
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                479, "spif_array_vector_find");
#line 479
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(obj)");
        }
      }
#line 479
      return ((spif_obj_t )((void *)0));
    }
#line 479
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 480
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 480
    if (! (self->len > 0)) {
#line 480
      if (libast_debug_level >= 1U) {
        {
#line 480
        tmp___0 = time((time_t *)((void *)0));
#line 480
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                480, "spif_array_vector_find");
#line 480
        libast_dprintf("REQUIRE failed:  %s\n", "self->len > 0");
        }
      }
#line 480
      return ((spif_obj_t )((void *)0));
    }
#line 480
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 482
  start = 0;
#line 482
  end = self->len - 1;
  {
#line 482
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 482
    if (! (start <= end)) {
#line 482
      goto while_break___2;
    }
    {
#line 483
    mid = (end - start) / 2 + start;
#line 484
    tmp___1 = (*(((*(self->items + mid))->cls)->comp))(*(self->items + mid), obj);
#line 484
    diff = (spif_cmp_t )tmp___1;
    }
#line 485
    if ((int )diff == 0) {
#line 486
      return (*(self->items + mid));
    } else
#line 487
    if ((int )diff == -1) {
#line 488
      start = mid + 1;
    } else {
#line 490
      end = mid - 1;
#line 491
      if (end == -1) {
#line 492
        goto while_break___2;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 496
  return ((spif_obj_t )((void *)0));
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_obj_t spif_array_get(spif_array_t self , spif_listidx_t idx ) 
{ 
  spif_obj_t tmp ;

  {
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 502
      if (libast_debug_level >= 1U) {
        {
#line 502
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_get",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           502, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 502
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_get",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             502, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 502
      return ((spif_obj_t )((void *)0));
    }
#line 502
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  if (idx < 0) {
#line 504
    idx += self->len;
  }
#line 506
  if (idx >= 0) {
#line 506
    if (idx < self->len) {
#line 506
      tmp = *(self->items + idx);
    } else {
#line 506
      tmp = (spif_obj_t )((void *)0);
    }
  } else {
#line 506
    tmp = (spif_obj_t )((void *)0);
  }
#line 506
  return (tmp);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_obj_t spif_array_map_get(spif_array_t self , spif_obj_t key ) 
{ 
  spif_listidx_t start ;
  spif_listidx_t end ;
  spif_listidx_t mid ;
  spif_cmp_t diff ;
  time_t tmp ;
  time_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 515
      if (libast_debug_level >= 1U) {
        {
#line 515
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_map_get",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           515, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 515
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_map_get",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             515, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 515
      return ((spif_obj_t )((void *)0));
    }
#line 515
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 516
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 516
    if (! (! ((unsigned long )key == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 516
      if (libast_debug_level >= 1U) {
        {
#line 516
        tmp = time((time_t *)((void *)0));
#line 516
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                516, "spif_array_map_get");
#line 516
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(key)");
        }
      }
#line 516
      return ((spif_obj_t )((void *)0));
    }
#line 516
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 517
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 517
    if (! (self->len > 0)) {
#line 517
      if (libast_debug_level >= 1U) {
        {
#line 517
        tmp___0 = time((time_t *)((void *)0));
#line 517
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                517, "spif_array_map_get");
#line 517
        libast_dprintf("REQUIRE failed:  %s\n", "self->len > 0");
        }
      }
#line 517
      return ((spif_obj_t )((void *)0));
    }
#line 517
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 519
  start = 0;
#line 519
  end = self->len - 1;
  {
#line 519
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 519
    if (! (start <= end)) {
#line 519
      goto while_break___2;
    }
    {
#line 520
    mid = (end - start) / 2 + start;
#line 521
    tmp___1 = (*(((*(self->items + mid))->cls)->comp))(*(self->items + mid), key);
#line 521
    diff = (spif_cmp_t )tmp___1;
    }
#line 522
    if ((int )diff == 0) {
#line 523
      return (((spif_objpair_t )*(self->items + mid))->value);
    } else
#line 524
    if ((int )diff == -1) {
#line 525
      start = mid + 1;
    } else {
#line 527
      end = mid - 1;
#line 528
      if (end == -1) {
#line 529
        goto while_break___2;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 533
  return ((spif_obj_t )((void *)0));
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_list_t spif_array_get_keys(spif_array_t self , spif_list_t key_list ) 
{ 
  spif_listidx_t i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 541
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 541
      if (libast_debug_level >= 1U) {
        {
#line 541
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_get_keys",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           541, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 541
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_get_keys",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             541, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 541
      return ((spif_list_t )((void *)0));
    }
#line 541
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  if ((unsigned long )key_list == (unsigned long )((spif_list_t )((void *)0))) {
    {
#line 543
    tmp = (*(((spif_class_t )spif_array_listclass)->noo))();
#line 543
    key_list = (spif_list_t )tmp;
    }
  }
#line 546
  i = 0;
  {
#line 546
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 546
    if (! (i < self->len)) {
#line 546
      goto while_break___0;
    }
    {
#line 547
    tmp___0 = (*(((((spif_objpair_t )*(self->items + i))->key)->cls)->dup))(((spif_objpair_t )*(self->items + i))->key);
#line 547
    (*(((spif_listclass_t )key_list->cls)->append))(key_list, (spif_obj_t )tmp___0);
#line 546
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 549
  return (key_list);
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_list_t spif_array_get_pairs(spif_array_t self , spif_list_t pair_list ) 
{ 
  spif_listidx_t i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 557
      if (libast_debug_level >= 1U) {
        {
#line 557
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_get_pairs",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           557, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 557
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_get_pairs",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             557, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 557
      return ((spif_list_t )((void *)0));
    }
#line 557
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 558
  if ((unsigned long )pair_list == (unsigned long )((spif_list_t )((void *)0))) {
    {
#line 559
    tmp = (*(((spif_class_t )spif_array_listclass)->noo))();
#line 559
    pair_list = (spif_list_t )tmp;
    }
  }
#line 562
  i = 0;
  {
#line 562
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 562
    if (! (i < self->len)) {
#line 562
      goto while_break___0;
    }
    {
#line 563
    tmp___0 = (*((((spif_obj_t )((spif_objpair_t )*(self->items + i)))->cls)->dup))((spif_objpair_t )*(self->items + i));
#line 563
    (*(((spif_listclass_t )pair_list->cls)->append))(pair_list, (spif_obj_t )tmp___0);
#line 562
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 565
  return (pair_list);
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_list_t spif_array_get_values(spif_array_t self , spif_list_t value_list ) 
{ 
  spif_listidx_t i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 573
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 573
      if (libast_debug_level >= 1U) {
        {
#line 573
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_get_values",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           573, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 573
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_get_values",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             573, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 573
      return ((spif_list_t )((void *)0));
    }
#line 573
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  if ((unsigned long )value_list == (unsigned long )((spif_list_t )((void *)0))) {
    {
#line 575
    tmp = (*(((spif_class_t )spif_array_listclass)->noo))();
#line 575
    value_list = (spif_list_t )tmp;
    }
  }
#line 578
  i = 0;
  {
#line 578
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 578
    if (! (i < self->len)) {
#line 578
      goto while_break___0;
    }
    {
#line 579
    tmp___0 = (*(((((spif_objpair_t )*(self->items + i))->value)->cls)->dup))(((spif_objpair_t )*(self->items + i))->value);
#line 579
    (*(((spif_listclass_t )value_list->cls)->append))(value_list, (spif_obj_t )tmp___0);
#line 578
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 581
  return (value_list);
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_has_key(spif_array_t self , spif_obj_t key ) 
{ 
  int tmp___0 ;
  spif_obj_t tmp___1 ;

  {
  {
#line 587
  tmp___1 = spif_array_map_get(self, key);
  }
#line 587
  if ((unsigned long )tmp___1 == (unsigned long )((spif_obj_t )((void *)0))) {
#line 587
    tmp___0 = 0;
  } else {
#line 587
    tmp___0 = 1;
  }
#line 587
  return ((spif_bool_t )tmp___0);
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_has_value(spif_array_t self , spif_obj_t value ) 
{ 
  spif_listidx_t i ;
  spif_objpair_t pair ;
  void *tmp ;

  {
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 595
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 595
      if (libast_debug_level >= 1U) {
        {
#line 595
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_has_value",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           595, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 595
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_has_value",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             595, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 595
      return ((spif_bool_t )0);
    }
#line 595
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 597
  i = 0;
  {
#line 597
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 597
    if (! (i < self->len)) {
#line 597
      goto while_break___0;
    }
#line 600
    pair = (spif_objpair_t )*(self->items + i);
#line 601
    if ((unsigned long )value == (unsigned long )((spif_obj_t )((void *)0))) {
#line 601
      if ((unsigned long )pair->value == (unsigned long )((spif_obj_t )((void *)0))) {
#line 602
        return ((spif_bool_t )1);
      } else {
#line 601
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 603
      tmp = (*(((pair->value)->cls)->comp))(pair->value, value);
      }
#line 603
      if ((int )((spif_cmp_t )tmp) == 0) {
#line 604
        return ((spif_bool_t )1);
      }
    }
#line 597
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 607
  return ((spif_bool_t )0);
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_listidx_t spif_array_index(spif_array_t self , spif_obj_t obj ) 
{ 
  spif_listidx_t i ;
  void *tmp ;

  {
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 615
      if (libast_debug_level >= 1U) {
        {
#line 615
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_index",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           615, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 615
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_index",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             615, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 615
      return (-1);
    }
#line 615
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  i = 0;
  {
#line 616
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 616
    if (! (i < self->len)) {
#line 616
      goto while_break___0;
    }
#line 617
    if ((unsigned long )*(self->items + i) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 618
      if ((unsigned long )obj == (unsigned long )((spif_obj_t )((void *)0))) {
#line 619
        return (i);
      }
#line 621
      goto __Cont;
    }
    {
#line 623
    tmp = (*(((*(self->items + i))->cls)->comp))(*(self->items + i), obj);
    }
#line 623
    if ((int )((spif_cmp_t )tmp) == 0) {
#line 624
      return (i);
    }
    __Cont: /* CIL Label */ 
#line 616
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 627
  return (-1);
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_insert(spif_array_t self , spif_obj_t obj ) 
{ 
  spif_listidx_t i ;
  spif_listidx_t left ;
  time_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 635
      if (libast_debug_level >= 1U) {
        {
#line 635
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_insert",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           635, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 635
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_insert",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             635, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 635
      return ((spif_bool_t )0);
    }
#line 635
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 636
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 636
    if (! (! ((unsigned long )obj == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 636
      if (libast_debug_level >= 1U) {
        {
#line 636
        tmp = time((time_t *)((void *)0));
#line 636
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                636, "spif_array_insert");
#line 636
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(obj)");
        }
      }
#line 636
      return ((spif_bool_t )0);
    }
#line 636
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 637
  if (self->items) {
#line 638
    if (sizeof(spif_const_obj_t ) * (unsigned long )(self->len + 1)) {
#line 638
      if (self->items) {
        {
#line 638
        tmp___0 = realloc((void *)self->items, sizeof(spif_const_obj_t ) * (unsigned long )(self->len + 1));
#line 638
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 638
        tmp___1 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )(self->len + 1));
#line 638
        tmp___2 = tmp___1;
        }
      }
#line 638
      tmp___4 = tmp___2;
    } else {
#line 638
      if (self->items) {
        {
#line 638
        free((void *)self->items);
#line 638
        tmp___3 = (void *)0;
        }
      } else {
#line 638
        tmp___3 = (void *)0;
      }
#line 638
      tmp___4 = tmp___3;
    }
#line 638
    self->items = (spif_obj_t *)tmp___4;
  } else {
    {
#line 640
    tmp___5 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )(self->len + 1));
#line 640
    self->items = (spif_obj_t *)tmp___5;
    }
  }
#line 643
  i = 0;
  {
#line 643
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 643
    if (i < self->len) {
      {
#line 643
      tmp___6 = (*((obj->cls)->comp))(obj, *(self->items + i));
      }
#line 643
      if (! ((int )((spif_cmp_t )tmp___6) == 1)) {
#line 643
        goto while_break___1;
      }
    } else {
#line 643
      goto while_break___1;
    }
#line 643
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 644
  left = self->len - i;
#line 645
  if (left) {
    {
#line 646
    memmove((void *)((self->items + i) + 1), (void const   *)(self->items + i), sizeof(spif_const_obj_t ) * (unsigned long )left);
    }
  }
#line 648
  *(self->items + i) = obj;
#line 649
  (self->len) ++;
#line 650
  return ((spif_bool_t )1);
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_insert_at(spif_array_t self , spif_obj_t obj , spif_listidx_t idx ) 
{ 
  spif_listidx_t left ;
  time_t tmp ;
  time_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *end ;
  long l ;
  long *l_dest ;
  char *c_dest ;
  char *tmp___7 ;
  long *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 658
      if (libast_debug_level >= 1U) {
        {
#line 658
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_insert_at",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           658, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 658
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_insert_at",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             658, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 658
      return ((spif_bool_t )0);
    }
#line 658
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 659
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 659
    if (! (! ((unsigned long )obj == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 659
      if (libast_debug_level >= 1U) {
        {
#line 659
        tmp = time((time_t *)((void *)0));
#line 659
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                659, "spif_array_insert_at");
#line 659
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(obj)");
        }
      }
#line 659
      return ((spif_bool_t )0);
    }
#line 659
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 660
  if (idx < 0) {
#line 662
    idx += self->len;
  }
  {
#line 664
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 664
    if (! (idx + 1 >= 0)) {
#line 664
      if (libast_debug_level >= 1U) {
        {
#line 664
        tmp___0 = time((time_t *)((void *)0));
#line 664
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                664, "spif_array_insert_at");
#line 664
        libast_dprintf("REQUIRE failed:  %s\n", "(idx + 1) >= 0");
        }
      }
#line 664
      return ((spif_bool_t )0);
    }
#line 664
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 666
  if (idx > self->len) {
#line 668
    left = - (idx - self->len);
#line 669
    self->len = idx;
  } else {
#line 671
    left = self->len - idx;
  }
#line 674
  if (self->items) {
#line 675
    if (sizeof(spif_const_obj_t ) * (unsigned long )(self->len + 1)) {
#line 675
      if (self->items) {
        {
#line 675
        tmp___1 = realloc((void *)self->items, sizeof(spif_const_obj_t ) * (unsigned long )(self->len + 1));
#line 675
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 675
        tmp___2 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )(self->len + 1));
#line 675
        tmp___3 = tmp___2;
        }
      }
#line 675
      tmp___5 = tmp___3;
    } else {
#line 675
      if (self->items) {
        {
#line 675
        free((void *)self->items);
#line 675
        tmp___4 = (void *)0;
        }
      } else {
#line 675
        tmp___4 = (void *)0;
      }
#line 675
      tmp___5 = tmp___4;
    }
#line 675
    self->items = (spif_obj_t *)tmp___5;
  } else {
    {
#line 677
    tmp___6 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )(self->len + 1));
#line 677
    self->items = (spif_obj_t *)tmp___6;
    }
  }
#line 680
  if (left > 0) {
    {
#line 682
    memmove((void *)((self->items + idx) + 1), (void const   *)(self->items + idx),
            sizeof(spif_const_obj_t ) * (unsigned long )left);
    }
  } else
#line 683
  if (left < 0) {
#line 685
    left = - left;
    {
#line 686
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 686
      end = (char *)(self->items + (idx - left)) + sizeof(spif_const_obj_t ) * (unsigned long )left;
#line 686
      l_dest = (long *)(self->items + (idx - left));
#line 686
      if (! (self->items + (idx - left))) {
#line 686
        goto while_break___2;
      }
#line 686
      if (sizeof(spif_const_obj_t ) * (unsigned long )left >= 4UL * sizeof(long )) {
#line 686
        l = 0L;
#line 686
        l |= l << 16;
#line 686
        l |= l << 32;
#line 686
        if ((unsigned long )l_dest & (sizeof(long ) - 1UL)) {
#line 686
          c_dest = (char *)l_dest;
          {
#line 686
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 686
            if (! ((unsigned long )c_dest & (sizeof(long ) - 1UL))) {
#line 686
              goto while_break___3;
            }
#line 686
            tmp___7 = c_dest;
#line 686
            c_dest ++;
#line 686
            *tmp___7 = (char)0;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 686
          l_dest = (long *)c_dest;
        }
        {
#line 686
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 686
          if (! ((unsigned long )(end - (char *)l_dest) >= sizeof(long ))) {
#line 686
            goto while_break___4;
          }
#line 686
          tmp___8 = l_dest;
#line 686
          l_dest ++;
#line 686
          *tmp___8 = l;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 686
      if ((unsigned long )((char *)l_dest) < (unsigned long )end) {
#line 686
        c_dest = (char *)l_dest;
#line 686
        tmp___9 = c_dest;
#line 686
        c_dest ++;
#line 686
        *tmp___9 = (char)0;
        {
#line 686
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 686
          if (! ((unsigned long )c_dest < (unsigned long )end)) {
#line 686
            goto while_break___5;
          }
#line 686
          tmp___10 = c_dest;
#line 686
          c_dest ++;
#line 686
          *tmp___10 = (char)0;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 686
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 688
  *(self->items + idx) = obj;
#line 689
  (self->len) ++;
#line 690
  return ((spif_bool_t )1);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_iterator_t spif_array_iterator(spif_array_t self ) 
{ 
  spif_array_iterator_t tmp ;

  {
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 696
      if (libast_debug_level >= 1U) {
        {
#line 696
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           696, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 696
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             696, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 696
      return ((spif_iterator_t )((void *)0));
    }
#line 696
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 697
  tmp = spif_array_iterator_new(self);
  }
#line 697
  return ((spif_iterator_t )tmp);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_prepend(spif_array_t self , spif_obj_t obj ) 
{ 
  time_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 703
      if (libast_debug_level >= 1U) {
        {
#line 703
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_prepend",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           703, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 703
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_prepend",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             703, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 703
      return ((spif_bool_t )0);
    }
#line 703
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 704
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 704
    if (! (! ((unsigned long )obj == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 704
      if (libast_debug_level >= 1U) {
        {
#line 704
        tmp = time((time_t *)((void *)0));
#line 704
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                704, "spif_array_prepend");
#line 704
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(obj)");
        }
      }
#line 704
      return ((spif_bool_t )0);
    }
#line 704
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 705
  if (self->items) {
#line 706
    if (sizeof(spif_const_obj_t ) * (unsigned long )(self->len + 1)) {
#line 706
      if (self->items) {
        {
#line 706
        tmp___0 = realloc((void *)self->items, sizeof(spif_const_obj_t ) * (unsigned long )(self->len + 1));
#line 706
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 706
        tmp___1 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )(self->len + 1));
#line 706
        tmp___2 = tmp___1;
        }
      }
#line 706
      tmp___4 = tmp___2;
    } else {
#line 706
      if (self->items) {
        {
#line 706
        free((void *)self->items);
#line 706
        tmp___3 = (void *)0;
        }
      } else {
#line 706
        tmp___3 = (void *)0;
      }
#line 706
      tmp___4 = tmp___3;
    }
#line 706
    self->items = (spif_obj_t *)tmp___4;
  } else {
    {
#line 708
    tmp___5 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )(self->len + 1));
#line 708
    self->items = (spif_obj_t *)tmp___5;
    }
  }
  {
#line 711
  memmove((void *)(self->items + 1), (void const   *)self->items, sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 712
  *(self->items + 0) = obj;
#line 713
  (self->len) ++;
  }
#line 714
  return ((spif_bool_t )1);
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_obj_t spif_array_remove(spif_array_t self , spif_obj_t item ) 
{ 
  spif_obj_t tmp ;
  spif_listidx_t i ;
  spif_listidx_t left ;
  time_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 723
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 723
      if (libast_debug_level >= 1U) {
        {
#line 723
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_remove",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           723, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 723
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_remove",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             723, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 723
      return ((spif_obj_t )((void *)0));
    }
#line 723
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 724
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 724
    if (! (! ((unsigned long )item == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 724
      if (libast_debug_level >= 1U) {
        {
#line 724
        tmp___0 = time((time_t *)((void *)0));
#line 724
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                724, "spif_array_remove");
#line 724
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(item)");
        }
      }
#line 724
      return ((spif_obj_t )((void *)0));
    }
#line 724
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 725
  i = 0;
  {
#line 725
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 725
    if (i < self->len) {
      {
#line 725
      tmp___1 = (*((item->cls)->comp))(item, *(self->items + i));
      }
#line 725
      if ((int )((spif_cmp_t )tmp___1) == 0) {
#line 725
        goto while_break___1;
      }
    } else {
#line 725
      goto while_break___1;
    }
#line 725
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 726
  if (i == self->len) {
#line 727
    return ((spif_obj_t )((void *)0));
  }
  {
#line 730
  left = (self->len - i) - 1;
#line 731
  tmp = *(self->items + i);
#line 732
  memmove((void *)(self->items + i), (void const   *)((self->items + i) + 1), sizeof(spif_const_obj_t ) * (unsigned long )left);
#line 733
  (self->len) --;
  }
#line 733
  if (sizeof(spif_const_obj_t ) * (unsigned long )self->len) {
#line 733
    if (self->items) {
      {
#line 733
      (self->len) --;
#line 733
      tmp___2 = realloc((void *)self->items, sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 733
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 733
      (self->len) --;
#line 733
      tmp___3 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 733
      tmp___4 = tmp___3;
      }
    }
#line 733
    tmp___6 = tmp___4;
  } else {
#line 733
    if (self->items) {
      {
#line 733
      free((void *)self->items);
#line 733
      tmp___5 = (void *)0;
      }
    } else {
#line 733
      tmp___5 = (void *)0;
    }
#line 733
    tmp___6 = tmp___5;
  }
#line 733
  self->items = (spif_obj_t *)tmp___6;
#line 735
  return (tmp);
}
}
#line 738 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_obj_t spif_array_map_remove(spif_array_t self , spif_obj_t item ) 
{ 
  spif_obj_t tmp ;
  spif_listidx_t i ;
  spif_listidx_t left ;
  time_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 744
      if (libast_debug_level >= 1U) {
        {
#line 744
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_map_remove",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           744, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 744
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_map_remove",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             744, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 744
      return ((spif_obj_t )((void *)0));
    }
#line 744
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 745
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 745
    if (! (! ((unsigned long )item == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 745
      if (libast_debug_level >= 1U) {
        {
#line 745
        tmp___0 = time((time_t *)((void *)0));
#line 745
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                745, "spif_array_map_remove");
#line 745
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(item)");
        }
      }
#line 745
      return ((spif_obj_t )((void *)0));
    }
#line 745
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 746
  i = 0;
  {
#line 746
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 746
    if (i < self->len) {
      {
#line 746
      tmp___1 = (*(((*(self->items + i))->cls)->comp))(*(self->items + i), item);
      }
#line 746
      if ((int )((spif_cmp_t )tmp___1) == 0) {
#line 746
        goto while_break___1;
      }
    } else {
#line 746
      goto while_break___1;
    }
#line 746
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 747
  if (i == self->len) {
#line 748
    return ((spif_obj_t )((void *)0));
  }
  {
#line 751
  left = (self->len - i) - 1;
#line 752
  tmp = *(self->items + i);
#line 753
  memmove((void *)(self->items + i), (void const   *)((self->items + i) + 1), sizeof(spif_const_obj_t ) * (unsigned long )left);
#line 754
  (self->len) --;
  }
#line 754
  if (sizeof(spif_const_obj_t ) * (unsigned long )self->len) {
#line 754
    if (self->items) {
      {
#line 754
      (self->len) --;
#line 754
      tmp___2 = realloc((void *)self->items, sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 754
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 754
      (self->len) --;
#line 754
      tmp___3 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 754
      tmp___4 = tmp___3;
      }
    }
#line 754
    tmp___6 = tmp___4;
  } else {
#line 754
    if (self->items) {
      {
#line 754
      free((void *)self->items);
#line 754
      tmp___5 = (void *)0;
      }
    } else {
#line 754
      tmp___5 = (void *)0;
    }
#line 754
    tmp___6 = tmp___5;
  }
#line 754
  self->items = (spif_obj_t *)tmp___6;
#line 756
  return (tmp);
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_obj_t spif_array_remove_at(spif_array_t self , spif_listidx_t idx ) 
{ 
  spif_obj_t tmp ;
  spif_listidx_t left ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 765
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 765
      if (libast_debug_level >= 1U) {
        {
#line 765
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_remove_at",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           765, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 765
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_remove_at",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             765, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 765
      return ((spif_obj_t )((void *)0));
    }
#line 765
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 766
  if (idx < 0) {
#line 768
    idx += self->len;
  }
#line 770
  if (idx < 0) {
#line 771
    return ((spif_obj_t )((void *)0));
  } else
#line 770
  if (idx >= self->len) {
#line 771
    return ((spif_obj_t )((void *)0));
  }
  {
#line 774
  left = (self->len - idx) - 1;
#line 775
  tmp = *(self->items + idx);
#line 776
  memmove((void *)(self->items + idx), (void const   *)((self->items + idx) + 1),
          sizeof(spif_const_obj_t ) * (unsigned long )left);
#line 777
  (self->len) --;
  }
#line 777
  if (sizeof(spif_const_obj_t ) * (unsigned long )self->len) {
#line 777
    if (self->items) {
      {
#line 777
      (self->len) --;
#line 777
      tmp___0 = realloc((void *)self->items, sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 777
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 777
      (self->len) --;
#line 777
      tmp___1 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 777
      tmp___2 = tmp___1;
      }
    }
#line 777
    tmp___4 = tmp___2;
  } else {
#line 777
    if (self->items) {
      {
#line 777
      free((void *)self->items);
#line 777
      tmp___3 = (void *)0;
      }
    } else {
#line 777
      tmp___3 = (void *)0;
    }
#line 777
    tmp___4 = tmp___3;
  }
#line 777
  self->items = (spif_obj_t *)tmp___4;
#line 779
  return (tmp);
}
}
#line 782 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_reverse(spif_array_t self ) 
{ 
  spif_listidx_t i ;
  spif_listidx_t j ;
  spif_obj_t __tmp ;

  {
  {
#line 787
  while (1) {
    while_continue: /* CIL Label */ ;
#line 787
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 787
      if (libast_debug_level >= 1U) {
        {
#line 787
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_reverse",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           787, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 787
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_reverse",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             787, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 787
      return ((spif_bool_t )0);
    }
#line 787
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 788
  i = 0;
#line 788
  j = self->len - 1;
  {
#line 788
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 788
    if (! (i < j)) {
#line 788
      goto while_break___0;
    }
#line 789
    __tmp = *(self->items + i);
#line 789
    *(self->items + i) = *(self->items + j);
#line 789
    *(self->items + j) = __tmp;
#line 788
    i ++;
#line 788
    j --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 791
  return ((spif_bool_t )1);
}
}
#line 794 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_set(spif_array_t self , spif_obj_t key , spif_obj_t value ) 
{ 
  spif_listidx_t i ;
  time_t tmp ;
  void *tmp___0 ;
  spif_objpair_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 799
  while (1) {
    while_continue: /* CIL Label */ ;
#line 799
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 799
      if (libast_debug_level >= 1U) {
        {
#line 799
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_set",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           799, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 799
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_set",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             799, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 799
      return ((spif_bool_t )0);
    }
#line 799
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 800
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 800
    if (! (! ((unsigned long )key == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 800
      if (libast_debug_level >= 1U) {
        {
#line 800
        tmp = time((time_t *)((void *)0));
#line 800
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                800, "spif_array_set");
#line 800
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(key)");
        }
      }
#line 800
      return ((spif_bool_t )0);
    }
#line 800
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 802
  if (! ((unsigned long )key == (unsigned long )((spif_obj_t )((void *)0)))) {
#line 802
    if ((unsigned long )key->cls == (unsigned long )spif_objpair_class) {
#line 802
      if ((unsigned long )value == (unsigned long )((spif_obj_t )((void *)0))) {
#line 803
        value = ((spif_objpair_t )key)->value;
#line 804
        key = ((spif_objpair_t )key)->key;
      }
    }
  }
#line 807
  i = 0;
  {
#line 807
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 807
    if (i < self->len) {
      {
#line 807
      tmp___0 = (*(((*(self->items + i))->cls)->comp))(*(self->items + i), key);
      }
#line 807
      if ((int )((spif_cmp_t )tmp___0) == 0) {
#line 807
        goto while_break___1;
      }
    } else {
#line 807
      goto while_break___1;
    }
#line 807
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 808
  if (i == self->len) {
    {
#line 809
    tmp___1 = spif_objpair_new_from_both(key, value);
#line 809
    spif_array_insert(self, (spif_obj_t )tmp___1);
    }
#line 810
    return ((spif_bool_t )0);
  } else {
    {
#line 812
    tmp___2 = (*((value->cls)->dup))(value);
#line 812
    spif_objpair_set_value((spif_objpair_t )*(self->items + i), (spif_obj_t )tmp___2);
    }
#line 813
    return ((spif_bool_t )1);
  }
}
}
#line 817 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_obj_t *spif_array_to_array(spif_array_t self ) 
{ 
  spif_obj_t *tmp ;
  spif_listidx_t i ;
  void *tmp___0 ;

  {
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 823
    if (! (! ((unsigned long )self == (unsigned long )((spif_array_t )((void *)0))))) {
#line 823
      if (libast_debug_level >= 1U) {
        {
#line 823
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_to_array",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           823, "!SPIF_ARRAY_ISNULL(self)");
        }
      } else {
        {
#line 823
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_to_array",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             823, "!SPIF_ARRAY_ISNULL(self)");
        }
      }
#line 823
      return ((spif_obj_t *)((void *)0));
    }
#line 823
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 824
  tmp___0 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 824
  tmp = (spif_obj_t *)tmp___0;
#line 825
  i = 0;
  }
  {
#line 825
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 825
    if (! (i < self->len)) {
#line 825
      goto while_break___0;
    }
#line 826
    *(tmp + i) = *(self->items + i);
#line 825
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 828
  return (tmp);
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_array_iterator_t spif_array_iterator_new(spif_array_t subject ) 
{ 
  spif_array_iterator_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 836
  tmp = malloc(sizeof(spif_const_array_iterator_t ));
#line 836
  self = (spif_array_iterator_t )tmp;
#line 837
  tmp___0 = spif_array_iterator_init(self, subject);
  }
#line 837
  if (! tmp___0) {
    {
#line 838
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 838
      free((void *)self);
#line 838
      self = (spif_array_iterator_t )((void *)0);
      }
#line 838
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 839
    self = (spif_array_iterator_t )((void *)0);
  }
#line 841
  return (self);
}
}
#line 844 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_iterator_init(spif_array_iterator_t self , spif_array_t subject ) 
{ 
  spif_bool_t tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 847
  while (1) {
    while_continue: /* CIL Label */ ;
#line 847
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 847
      if (libast_debug_level >= 1U) {
        {
#line 847
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           847, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 847
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             847, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 847
      return ((spif_bool_t )0);
    }
#line 847
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 848
  tmp___0 = spif_obj_init((spif_obj_t )self);
  }
#line 848
  if (tmp___0) {
    {
#line 850
    tmp = spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_array_iteratorclass);
    }
#line 850
    if (! tmp) {
#line 851
      return ((spif_bool_t )0);
    }
  } else {
#line 849
    return ((spif_bool_t )0);
  }
#line 853
  self->subject = subject;
#line 854
  self->current_index = 0;
#line 855
  return ((spif_bool_t )1);
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_iterator_done(spif_array_iterator_t self ) 
{ 


  {
  {
#line 861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 861
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 861
      if (libast_debug_level >= 1U) {
        {
#line 861
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           861, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 861
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             861, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 861
      return ((spif_bool_t )0);
    }
#line 861
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 862
  self->subject = (spif_array_t )((void *)0);
#line 863
  self->current_index = 0;
#line 864
  return ((spif_bool_t )1);
}
}
#line 867 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_iterator_del(spif_array_iterator_t self ) 
{ 
  spif_bool_t t ;

  {
  {
#line 872
  while (1) {
    while_continue: /* CIL Label */ ;
#line 872
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 872
      if (libast_debug_level >= 1U) {
        {
#line 872
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           872, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 872
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             872, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 872
      return ((spif_bool_t )0);
    }
#line 872
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  t = spif_array_iterator_done(self);
  }
  {
#line 874
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 874
    free((void *)self);
#line 874
    self = (spif_array_iterator_t )((void *)0);
    }
#line 874
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 875
  return (t);
}
}
#line 878 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_str_t spif_array_iterator_show(spif_array_iterator_t self , spif_charptr_t name___0 ,
                                           spif_str_t buff , size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  char *tmp___0 ;

  {
#line 883
  if ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))) {
    {
#line 884
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 884
      memset((void *)(tmp), ' ', indent);
      }
#line 884
      if ((char *)name___0) {
#line 884
        tmp___0 = (char *)name___0;
      } else {
#line 884
        tmp___0 = (char *)"<name null>";
      }
      {
#line 884
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_iterator_t) %s:  { ((spif_iterator_t) NULL) }\n",
               tmp___0);
      }
#line 884
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 884
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 884
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 884
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 885
    return (buff);
  }
  {
#line 888
  memset((void *)(tmp), ' ', indent);
#line 889
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_array_iterator_t) %s:  %10p {\n",
           name___0, (spif_ptr_t )self);
  }
#line 891
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 892
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 894
    spif_str_append_from_ptr(buff, tmp);
    }
  }
  {
#line 897
  buff = spif_array_show(self->subject, (spif_charptr_t )"subject", buff, indent + 2UL);
#line 899
  memset((void *)(tmp), ' ', indent + 2UL);
#line 900
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"  (spif_listidx_t) current_index:  %lu\n",
           (unsigned long )self->current_index);
#line 903
  spif_str_append_from_ptr(buff, tmp);
#line 905
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"}\n");
#line 906
  spif_str_append_from_ptr(buff, tmp);
  }
#line 907
  return (buff);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_cmp_t spif_array_iterator_comp(spif_array_iterator_t self , spif_array_iterator_t other ) 
{ 
  spif_cmp_t c ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;
#line 915
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 915
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 915
        return ((spif_cmp_t )0);
      } else {
#line 915
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 915
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 915
      return ((spif_cmp_t )-1);
    } else
#line 915
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 915
      return ((spif_cmp_t )1);
    }
#line 915
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 917
  c = spif_array_comp(self->subject, other->subject);
  }
#line 918
  if ((int )c == 0) {
#line 919
    if (self->current_index - other->current_index < 0) {
#line 919
      tmp___0 = -1;
    } else {
#line 919
      if (self->current_index - other->current_index > 0) {
#line 919
        tmp = 1;
      } else {
#line 919
        tmp = 0;
      }
#line 919
      tmp___0 = tmp;
    }
#line 919
    return ((spif_cmp_t )tmp___0);
  } else {
#line 921
    return (c);
  }
}
}
#line 925 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_array_iterator_t spif_array_iterator_dup(spif_array_iterator_t self ) 
{ 
  spif_array_iterator_t tmp ;

  {
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 930
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 930
      if (libast_debug_level >= 1U) {
        {
#line 930
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           930, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 930
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             930, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 930
      return ((spif_array_iterator_t )((void *)0));
    }
#line 930
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 931
  tmp = spif_array_iterator_new(self->subject);
#line 932
  tmp->current_index = self->current_index;
  }
#line 933
  return (tmp);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_classname_t spif_array_iterator_type(spif_array_iterator_t self ) 
{ 


  {
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;
#line 939
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 939
      if (libast_debug_level >= 1U) {
        {
#line 939
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           939, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 939
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             939, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 939
      return ((spif_classname_t )((void *)0));
    }
#line 939
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 940
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 943 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_bool_t spif_array_iterator_has_next(spif_array_iterator_t self ) 
{ 
  spif_array_t subject ;
  time_t tmp ;

  {
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 948
      if (libast_debug_level >= 1U) {
        {
#line 948
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_has_next",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           948, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 948
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_has_next",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             948, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 948
      return ((spif_bool_t )0);
    }
#line 948
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 949
  subject = self->subject;
  {
#line 950
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 950
    if (! (! ((unsigned long )((spif_list_t )subject) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 950
      if (libast_debug_level >= 1U) {
        {
#line 950
        tmp = time((time_t *)((void *)0));
#line 950
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                950, "spif_array_iterator_has_next");
#line 950
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_LIST_ISNULL(subject)");
        }
      }
#line 950
      return ((spif_bool_t )0);
    }
#line 950
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 951
  if (self->current_index >= subject->len) {
#line 952
    return ((spif_bool_t )0);
  } else {
#line 954
    return ((spif_bool_t )1);
  }
}
}
#line 958 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c"
static spif_obj_t spif_array_iterator_next(spif_array_iterator_t self ) 
{ 
  spif_obj_t tmp ;
  time_t tmp___0 ;

  {
  {
#line 963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 963
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 963
      if (libast_debug_level >= 1U) {
        {
#line 963
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_next",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                           963, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 963
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_array_iterator_next",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                             963, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 963
      return ((spif_obj_t )((void *)0));
    }
#line 963
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 964
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 964
    if (! (! ((unsigned long )((spif_list_t )self->subject) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 964
      if (libast_debug_level >= 1U) {
        {
#line 964
        tmp___0 = time((time_t *)((void *)0));
#line 964
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/array.c",
                964, "spif_array_iterator_next");
#line 964
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_LIST_ISNULL(self->subject)");
        }
      }
#line 964
      return ((spif_obj_t )((void *)0));
    }
#line 964
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 965
  tmp = spif_array_get(self->subject, self->current_index);
#line 966
  (self->current_index) ++;
  }
#line 967
  return (tmp);
}
}
#line 2773 "../include/libast.h"
spif_uint32_t spifhash_jenkins(spif_uint8_t *key , spif_uint32_t length , spif_uint32_t seed ) ;
#line 2774
spif_uint32_t spifhash_jenkins32(spif_uint8_t *key , spif_uint32_t length , spif_uint32_t seed ) ;
#line 2778
spif_uint32_t spifhash_jenkinsLE(spif_uint8_t *key , spif_uint32_t length , spif_uint32_t seed ) ;
#line 2780
spif_uint32_t spifhash_rotating(spif_uint8_t *key , spif_uint32_t len , spif_uint32_t seed ) ;
#line 2781
spif_uint32_t spifhash_one_at_a_time(spif_uint8_t *key , spif_uint32_t len , spif_uint32_t seed ) ;
#line 2782
spif_uint32_t spifhash_fnv(spif_uint8_t *key , spif_uint32_t len , spif_uint32_t seed ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/builtin_hashes.c"
spif_uint32_t spifhash_jenkins(spif_uint8_t *key , spif_uint32_t length , spif_uint32_t seed ) 
{ 
  register spif_uint32_t a ;
  register spif_uint32_t b ;
  register spif_uint32_t c ;
  register spif_uint32_t len ;

  {
#line 63
  len = length;
#line 64
  b = 4146181709U;
#line 64
  a = b;
#line 65
  c = seed;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! (len >= 12U)) {
#line 69
      goto while_break;
    }
#line 70
    a += (((spif_uint32_t )*(key + 0) + ((spif_uint32_t )*(key + 1) << 8)) + ((spif_uint32_t )*(key + 2) << 16)) + ((spif_uint32_t )*(key + 3) << 24);
#line 71
    b += (((spif_uint32_t )*(key + 4) + ((spif_uint32_t )*(key + 5) << 8)) + ((spif_uint32_t )*(key + 6) << 16)) + ((spif_uint32_t )*(key + 7) << 24);
#line 72
    c += (((spif_uint32_t )*(key + 8) + ((spif_uint32_t )*(key + 9) << 8)) + ((spif_uint32_t )*(key + 10) << 16)) + ((spif_uint32_t )*(key + 11) << 24);
#line 73
    a -= b;
#line 73
    a -= c;
#line 73
    a ^= c >> 13;
#line 73
    b -= c;
#line 73
    b -= a;
#line 73
    b ^= a << 8;
#line 73
    c -= a;
#line 73
    c -= b;
#line 73
    c ^= b >> 13;
#line 73
    a -= b;
#line 73
    a -= c;
#line 73
    a ^= c >> 12;
#line 73
    b -= c;
#line 73
    b -= a;
#line 73
    b ^= a << 16;
#line 73
    c -= a;
#line 73
    c -= b;
#line 73
    c ^= b >> 5;
#line 73
    a -= b;
#line 73
    a -= c;
#line 73
    a ^= c >> 3;
#line 73
    b -= c;
#line 73
    b -= a;
#line 73
    b ^= a << 10;
#line 73
    c -= a;
#line 73
    c -= b;
#line 73
    c ^= b >> 15;
#line 74
    key += 12;
#line 75
    len -= 12U;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  c += length;
  {
#line 82
  if (len == 11U) {
#line 82
    goto case_11;
  }
#line 83
  if (len == 10U) {
#line 83
    goto case_10;
  }
#line 84
  if (len == 9U) {
#line 84
    goto case_9;
  }
#line 85
  if (len == 8U) {
#line 85
    goto case_8;
  }
#line 86
  if (len == 7U) {
#line 86
    goto case_7;
  }
#line 87
  if (len == 6U) {
#line 87
    goto case_6;
  }
#line 88
  if (len == 5U) {
#line 88
    goto case_5;
  }
#line 89
  if (len == 4U) {
#line 89
    goto case_4;
  }
#line 90
  if (len == 3U) {
#line 90
    goto case_3;
  }
#line 91
  if (len == 2U) {
#line 91
    goto case_2;
  }
#line 92
  if (len == 1U) {
#line 92
    goto case_1;
  }
#line 81
  goto switch_break;
  case_11: /* CIL Label */ 
#line 82
  c += (spif_uint32_t )*(key + 10) << 24;
  case_10: /* CIL Label */ 
#line 83
  c += (spif_uint32_t )*(key + 9) << 16;
  case_9: /* CIL Label */ 
#line 84
  c += (spif_uint32_t )*(key + 8) << 8;
  case_8: /* CIL Label */ 
#line 85
  b += (spif_uint32_t )*(key + 7) << 24;
  case_7: /* CIL Label */ 
#line 86
  b += (spif_uint32_t )*(key + 6) << 16;
  case_6: /* CIL Label */ 
#line 87
  b += (spif_uint32_t )*(key + 5) << 8;
  case_5: /* CIL Label */ 
#line 88
  b += (spif_uint32_t )*(key + 4);
  case_4: /* CIL Label */ 
#line 89
  a += (spif_uint32_t )*(key + 3) << 24;
  case_3: /* CIL Label */ 
#line 90
  a += (spif_uint32_t )*(key + 2) << 16;
  case_2: /* CIL Label */ 
#line 91
  a += (spif_uint32_t )*(key + 1) << 8;
  case_1: /* CIL Label */ 
#line 92
  a += (spif_uint32_t )*(key + 0);
  switch_break: /* CIL Label */ ;
  }
#line 95
  a -= b;
#line 95
  a -= c;
#line 95
  a ^= c >> 13;
#line 95
  b -= c;
#line 95
  b -= a;
#line 95
  b ^= a << 8;
#line 95
  c -= a;
#line 95
  c -= b;
#line 95
  c ^= b >> 13;
#line 95
  a -= b;
#line 95
  a -= c;
#line 95
  a ^= c >> 12;
#line 95
  b -= c;
#line 95
  b -= a;
#line 95
  b ^= a << 16;
#line 95
  c -= a;
#line 95
  c -= b;
#line 95
  c ^= b >> 5;
#line 95
  a -= b;
#line 95
  a -= c;
#line 95
  a ^= c >> 3;
#line 95
  b -= c;
#line 95
  b -= a;
#line 95
  b ^= a << 10;
#line 95
  c -= a;
#line 95
  c -= b;
#line 95
  c ^= b >> 15;
#line 97
  return (c);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/builtin_hashes.c"
spif_uint32_t spifhash_jenkins32(spif_uint8_t *key , spif_uint32_t length , spif_uint32_t seed ) 
{ 
  register spif_uint32_t a ;
  register spif_uint32_t b ;
  register spif_uint32_t c ;
  register spif_uint32_t len ;
  register spif_uint32_t *key_dword ;

  {
#line 122
  key_dword = (spif_uint32_t *)key;
#line 124
  len = length;
#line 125
  b = 4146181709U;
#line 125
  a = b;
#line 126
  c = seed;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (len >= 3U)) {
#line 130
      goto while_break;
    }
#line 131
    a += *(key_dword + 0);
#line 132
    b += *(key_dword + 1);
#line 133
    c += *(key_dword + 2);
#line 134
    a -= b;
#line 134
    a -= c;
#line 134
    a ^= c >> 13;
#line 134
    b -= c;
#line 134
    b -= a;
#line 134
    b ^= a << 8;
#line 134
    c -= a;
#line 134
    c -= b;
#line 134
    c ^= b >> 13;
#line 134
    a -= b;
#line 134
    a -= c;
#line 134
    a ^= c >> 12;
#line 134
    b -= c;
#line 134
    b -= a;
#line 134
    b ^= a << 16;
#line 134
    c -= a;
#line 134
    c -= b;
#line 134
    c ^= b >> 5;
#line 134
    a -= b;
#line 134
    a -= c;
#line 134
    a ^= c >> 3;
#line 134
    b -= c;
#line 134
    b -= a;
#line 134
    b ^= a << 10;
#line 134
    c -= a;
#line 134
    c -= b;
#line 134
    c ^= b >> 15;
#line 135
    key_dword += 3;
#line 136
    len -= 3U;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  c += length;
  {
#line 143
  if (len == 2U) {
#line 143
    goto case_2;
  }
#line 144
  if (len == 1U) {
#line 144
    goto case_1;
  }
#line 142
  goto switch_break;
  case_2: /* CIL Label */ 
#line 143
  b += *(key_dword + 1);
  case_1: /* CIL Label */ 
#line 144
  a += *(key_dword + 0);
  switch_break: /* CIL Label */ ;
  }
#line 147
  a -= b;
#line 147
  a -= c;
#line 147
  a ^= c >> 13;
#line 147
  b -= c;
#line 147
  b -= a;
#line 147
  b ^= a << 8;
#line 147
  c -= a;
#line 147
  c -= b;
#line 147
  c ^= b >> 13;
#line 147
  a -= b;
#line 147
  a -= c;
#line 147
  a ^= c >> 12;
#line 147
  b -= c;
#line 147
  b -= a;
#line 147
  b ^= a << 16;
#line 147
  c -= a;
#line 147
  c -= b;
#line 147
  c ^= b >> 5;
#line 147
  a -= b;
#line 147
  a -= c;
#line 147
  a ^= c >> 3;
#line 147
  b -= c;
#line 147
  b -= a;
#line 147
  b ^= a << 10;
#line 147
  c -= a;
#line 147
  c -= b;
#line 147
  c ^= b >> 15;
#line 149
  return (c);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/builtin_hashes.c"
spif_uint32_t spifhash_jenkinsLE(spif_uint8_t *key , spif_uint32_t length , spif_uint32_t seed ) 
{ 
  register spif_uint32_t a ;
  register spif_uint32_t b ;
  register spif_uint32_t c ;
  register spif_uint32_t len ;

  {
#line 175
  len = length;
#line 176
  b = 4146181709U;
#line 176
  a = b;
#line 177
  c = seed;
#line 181
  if ((spif_uint32_t )key & 3U) {
    {
#line 183
    while (1) {
      while_continue: /* CIL Label */ ;
#line 183
      if (! (len >= 12U)) {
#line 183
        goto while_break;
      }
#line 184
      a += (((spif_uint32_t )*(key + 0) + ((spif_uint32_t )*(key + 1) << 8)) + ((spif_uint32_t )*(key + 2) << 16)) + ((spif_uint32_t )*(key + 3) << 24);
#line 185
      b += (((spif_uint32_t )*(key + 4) + ((spif_uint32_t )*(key + 5) << 8)) + ((spif_uint32_t )*(key + 6) << 16)) + ((spif_uint32_t )*(key + 7) << 24);
#line 186
      c += (((spif_uint32_t )*(key + 8) + ((spif_uint32_t )*(key + 9) << 8)) + ((spif_uint32_t )*(key + 10) << 16)) + ((spif_uint32_t )*(key + 11) << 24);
#line 187
      a -= b;
#line 187
      a -= c;
#line 187
      a ^= c >> 13;
#line 187
      b -= c;
#line 187
      b -= a;
#line 187
      b ^= a << 8;
#line 187
      c -= a;
#line 187
      c -= b;
#line 187
      c ^= b >> 13;
#line 187
      a -= b;
#line 187
      a -= c;
#line 187
      a ^= c >> 12;
#line 187
      b -= c;
#line 187
      b -= a;
#line 187
      b ^= a << 16;
#line 187
      c -= a;
#line 187
      c -= b;
#line 187
      c ^= b >> 5;
#line 187
      a -= b;
#line 187
      a -= c;
#line 187
      a ^= c >> 3;
#line 187
      b -= c;
#line 187
      b -= a;
#line 187
      b ^= a << 10;
#line 187
      c -= a;
#line 187
      c -= b;
#line 187
      c ^= b >> 15;
#line 188
      key += 12;
#line 189
      len -= 12U;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 193
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 193
      if (! (len >= 12U)) {
#line 193
        goto while_break___0;
      }
#line 196
      a += *((spif_uint32_t *)key);
#line 197
      b += *((spif_uint32_t *)(key + 4));
#line 198
      c += *((spif_uint32_t *)(key + 8));
#line 199
      a -= b;
#line 199
      a -= c;
#line 199
      a ^= c >> 13;
#line 199
      b -= c;
#line 199
      b -= a;
#line 199
      b ^= a << 8;
#line 199
      c -= a;
#line 199
      c -= b;
#line 199
      c ^= b >> 13;
#line 199
      a -= b;
#line 199
      a -= c;
#line 199
      a ^= c >> 12;
#line 199
      b -= c;
#line 199
      b -= a;
#line 199
      b ^= a << 16;
#line 199
      c -= a;
#line 199
      c -= b;
#line 199
      c ^= b >> 5;
#line 199
      a -= b;
#line 199
      a -= c;
#line 199
      a ^= c >> 3;
#line 199
      b -= c;
#line 199
      b -= a;
#line 199
      b ^= a << 10;
#line 199
      c -= a;
#line 199
      c -= b;
#line 199
      c ^= b >> 15;
#line 200
      key += 12;
#line 201
      len -= 12U;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 207
  c += length;
  {
#line 209
  if (len == 11U) {
#line 209
    goto case_11;
  }
#line 211
  if (len == 10U) {
#line 211
    goto case_10;
  }
#line 213
  if (len == 9U) {
#line 213
    goto case_9;
  }
#line 215
  if (len == 8U) {
#line 215
    goto case_8;
  }
#line 217
  if (len == 7U) {
#line 217
    goto case_7;
  }
#line 219
  if (len == 6U) {
#line 219
    goto case_6;
  }
#line 221
  if (len == 5U) {
#line 221
    goto case_5;
  }
#line 223
  if (len == 4U) {
#line 223
    goto case_4;
  }
#line 225
  if (len == 3U) {
#line 225
    goto case_3;
  }
#line 227
  if (len == 2U) {
#line 227
    goto case_2;
  }
#line 229
  if (len == 1U) {
#line 229
    goto case_1;
  }
#line 208
  goto switch_break;
  case_11: /* CIL Label */ 
#line 210
  c += (spif_uint32_t )*(key + 10) << 24;
  case_10: /* CIL Label */ 
#line 212
  c += (spif_uint32_t )*(key + 9) << 16;
  case_9: /* CIL Label */ 
#line 214
  c += (spif_uint32_t )*(key + 8) << 8;
  case_8: /* CIL Label */ 
#line 216
  b += (spif_uint32_t )*(key + 7) << 24;
  case_7: /* CIL Label */ 
#line 218
  b += (spif_uint32_t )*(key + 6) << 16;
  case_6: /* CIL Label */ 
#line 220
  b += (spif_uint32_t )*(key + 5) << 8;
  case_5: /* CIL Label */ 
#line 222
  b += (spif_uint32_t )*(key + 4);
  case_4: /* CIL Label */ 
#line 224
  a += (spif_uint32_t )*(key + 3) << 24;
  case_3: /* CIL Label */ 
#line 226
  a += (spif_uint32_t )*(key + 2) << 16;
  case_2: /* CIL Label */ 
#line 228
  a += (spif_uint32_t )*(key + 1) << 8;
  case_1: /* CIL Label */ 
#line 230
  a += (spif_uint32_t )*(key + 0);
  switch_break: /* CIL Label */ ;
  }
#line 233
  a -= b;
#line 233
  a -= c;
#line 233
  a ^= c >> 13;
#line 233
  b -= c;
#line 233
  b -= a;
#line 233
  b ^= a << 8;
#line 233
  c -= a;
#line 233
  c -= b;
#line 233
  c ^= b >> 13;
#line 233
  a -= b;
#line 233
  a -= c;
#line 233
  a ^= c >> 12;
#line 233
  b -= c;
#line 233
  b -= a;
#line 233
  b ^= a << 16;
#line 233
  c -= a;
#line 233
  c -= b;
#line 233
  c ^= b >> 5;
#line 233
  a -= b;
#line 233
  a -= c;
#line 233
  a ^= c >> 3;
#line 233
  b -= c;
#line 233
  b -= a;
#line 233
  b ^= a << 10;
#line 233
  c -= a;
#line 233
  c -= b;
#line 233
  c ^= b >> 15;
#line 235
  return (c);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/builtin_hashes.c"
spif_uint32_t spifhash_rotating(spif_uint8_t *key , spif_uint32_t len , spif_uint32_t seed ) 
{ 
  spif_uint32_t hash ;
  spif_uint32_t i ;

  {
#line 263
  if (! seed) {
#line 264
    seed = 4146181709U;
  }
#line 266
  hash = seed;
#line 266
  i = (spif_uint32_t )0;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! (i < len)) {
#line 266
      goto while_break;
    }
#line 267
    hash = ((hash << 4) ^ (hash >> 28)) ^ (unsigned int )*(key + i);
#line 266
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return ((hash ^ (hash >> 10)) ^ (hash >> 20));
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/builtin_hashes.c"
spif_uint32_t spifhash_one_at_a_time(spif_uint8_t *key , spif_uint32_t len , spif_uint32_t seed ) 
{ 
  spif_uint32_t hash ;
  spif_uint32_t i ;

  {
#line 291
  if (! seed) {
#line 292
    seed = 4146181709U;
  }
#line 294
  hash = seed;
#line 294
  i = (spif_uint32_t )0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < len)) {
#line 294
      goto while_break;
    }
#line 295
    hash += (spif_uint32_t )*(key + i);
#line 296
    hash += hash << 10;
#line 297
    hash ^= hash >> 6;
#line 294
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  hash += hash << 3;
#line 300
  hash ^= hash >> 11;
#line 301
  hash += hash << 15;
#line 302
  return (hash);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/builtin_hashes.c"
spif_uint32_t spifhash_fnv(spif_uint8_t *key , spif_uint32_t len , spif_uint32_t seed ) 
{ 
  spif_uint8_t *key_end ;
  spif_uint32_t hash ;

  {
#line 321
  key_end = key + len;
#line 324
  if (! seed) {
#line 325
    seed = 2166136261U;
  }
#line 327
  hash = seed;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! ((unsigned long )key < (unsigned long )key_end)) {
#line 327
      goto while_break;
    }
#line 328
    hash ^= (spif_uint32_t )*key;
#line 331
    hash += ((((hash << 1) + (hash << 4)) + (hash << 7)) + (hash << 8)) + (hash << 24);
#line 327
    key ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  return (hash);
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 297 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 2720 "../include/libast.h"
int spiftool_temp_file(spif_charptr_t ftemplate , size_t len ) ;
#line 2723
spif_bool_t spiftool_safe_strncpy(spif_charptr_t dest , spif_charptr_t const   src ,
                                  spif_int32_t size ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/file.c"
int spiftool_temp_file(spif_charptr_t ftemplate , size_t len ) 
{ 
  spif_char_t buff[256] ;
  int fd ;
  mode_t m ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if ((unsigned long )((spif_ptr_t )ftemplate) == (unsigned long )((void *)0)) {
#line 70
      tmp = 1;
    } else {
#line 70
      tmp = 0;
    }
#line 70
    if (tmp) {
#line 70
      if (libast_debug_level >= 1U) {
        {
#line 70
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_temp_file",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/file.c",
                           70, "!SPIF_PTR_ISNULL(ftemplate)");
        }
      } else {
        {
#line 70
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_temp_file",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/file.c",
                             70, "!SPIF_PTR_ISNULL(ftemplate)");
        }
      }
#line 70
      return (-1);
    }
#line 70
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 71
    if (! (len > 0UL)) {
#line 71
      if (libast_debug_level >= 1U) {
        {
#line 71
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_temp_file",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/file.c",
                           71, "len > 0");
        }
      } else {
        {
#line 71
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_temp_file",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/file.c",
                             71, "len > 0");
        }
      }
#line 71
      return (-1);
    }
#line 71
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 72
  tmp___3 = getenv("TMPDIR");
  }
#line 72
  if (tmp___3) {
    {
#line 73
    tmp___0 = getenv("TMPDIR");
#line 73
    snprintf((char */* __restrict  */)((char *)(buff)), sizeof(buff), (char const   */* __restrict  */)"%s/%sXXXXXX",
             tmp___0, ftemplate);
    }
  } else {
    {
#line 75
    tmp___2 = getenv("TMP");
    }
#line 75
    if (tmp___2) {
      {
#line 76
      tmp___1 = getenv("TMP");
#line 76
      snprintf((char */* __restrict  */)((char *)(buff)), sizeof(buff), (char const   */* __restrict  */)"%s/%sXXXXXX",
               tmp___1, ftemplate);
      }
    } else {
      {
#line 79
      snprintf((char */* __restrict  */)((char *)(buff)), sizeof(buff), (char const   */* __restrict  */)"/tmp/%sXXXXXX",
               ftemplate);
      }
    }
  }
  {
#line 82
  m = umask((__mode_t )63);
#line 83
  fd = mkstemp((char *)(buff));
#line 84
  umask(m);
  }
#line 85
  if (fd < 0) {
#line 86
    return (-1);
  } else {
    {
#line 85
    tmp___4 = fchmod(fd, (__mode_t )384);
    }
#line 85
    if (tmp___4) {
#line 86
      return (-1);
    }
  }
#line 89
  if (len) {
    {
#line 90
    spiftool_safe_strncpy(ftemplate, (spif_charptr_t const   )(buff), (spif_int32_t )len);
    }
  }
#line 92
  return (fd);
}
}
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 406
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                                                 size_t __maxlen )  __attribute__((__pure__)) ;
#line 489
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 517
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 139 "../include/libast/str.h"
spif_class_t spif_str_class ;
#line 140
spif_strclass_t spif_str_strclass ;
#line 141
spif_str_t spif_str_new(void) ;
#line 146
spif_str_t spif_str_new_from_num(long num ) ;
#line 150
spif_bool_t spif_str_init_from_buff(spif_str_t self , spif_charptr_t buff , spif_stridx_t size ) ;
#line 151
spif_bool_t spif_str_init_from_fp(spif_str_t self , FILE *fp ) ;
#line 152
spif_bool_t spif_str_init_from_fd(spif_str_t self , int fd ) ;
#line 153
spif_bool_t spif_str_init_from_num(spif_str_t self , long num ) ;
#line 158
spif_classname_t spif_str_type(spif_str_t self ) ;
#line 163
spif_cmp_t spif_str_casecmp(spif_str_t self , spif_str_t other ) ;
#line 164
spif_cmp_t spif_str_casecmp_with_ptr(spif_str_t self , spif_charptr_t other ) ;
#line 167
spif_cmp_t spif_str_cmp_with_ptr(spif_str_t self , spif_charptr_t other ) ;
#line 168
spif_bool_t spif_str_downcase(spif_str_t self ) ;
#line 169
spif_stridx_t spif_str_find(spif_str_t self , spif_str_t other ) ;
#line 170
spif_stridx_t spif_str_find_from_ptr(spif_str_t self , spif_charptr_t other ) ;
#line 171
spif_stridx_t spif_str_index(spif_str_t self , spif_char_t c ) ;
#line 172
spif_cmp_t spif_str_ncasecmp(spif_str_t self , spif_str_t other , spif_stridx_t cnt ) ;
#line 173
spif_cmp_t spif_str_ncasecmp_with_ptr(spif_str_t self , spif_charptr_t other , spif_stridx_t cnt ) ;
#line 174
spif_cmp_t spif_str_ncmp(spif_str_t self , spif_str_t other , spif_stridx_t cnt ) ;
#line 175
spif_cmp_t spif_str_ncmp_with_ptr(spif_str_t self , spif_charptr_t other , spif_stridx_t cnt ) ;
#line 176
spif_bool_t spif_str_prepend(spif_str_t self , spif_str_t other ) ;
#line 177
spif_bool_t spif_str_prepend_char(spif_str_t self , spif_char_t c ) ;
#line 178
spif_bool_t spif_str_prepend_from_ptr(spif_str_t self , spif_charptr_t other ) ;
#line 179
spif_bool_t spif_str_reverse(spif_str_t self ) ;
#line 180
spif_stridx_t spif_str_rindex(spif_str_t self , spif_char_t c ) ;
#line 181
spif_bool_t spif_str_splice(spif_str_t self , spif_stridx_t idx , spif_stridx_t cnt ,
                            spif_str_t other ) ;
#line 182
spif_bool_t spif_str_splice_from_ptr(spif_str_t self , spif_stridx_t idx , spif_stridx_t cnt ,
                                     spif_charptr_t other ) ;
#line 183
spif_str_t spif_str_substr(spif_str_t self , spif_stridx_t idx , spif_stridx_t cnt ) ;
#line 184
spif_charptr_t spif_str_substr_to_ptr(spif_str_t self , spif_stridx_t idx , spif_stridx_t cnt ) ;
#line 185
double spif_str_to_float(spif_str_t self ) ;
#line 186
size_t spif_str_to_num(spif_str_t self , int base ) ;
#line 188
spif_bool_t spif_str_upcase(spif_str_t self ) ;
#line 189
spif_stridx_t spif_str_get_size(spif_str_t self ) ;
#line 189
spif_bool_t spif_str_set_size(spif_str_t self , spif_stridx_t new_size ) ;
#line 190
spif_bool_t spif_str_set_len(spif_str_t self , spif_stridx_t new_len ) ;
#line 2766 "../include/libast.h"
char *strrev(char *str ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
static spif_const_strclass_t s_class  = 
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
     {{(spif_charptr_t )"!spif_str_t!", (void *(*)())(& spif_str_new), (void *(*)())(& spif_str_init),
     (void *(*)())(& spif_str_done), (void *(*)())(& spif_str_del), (void *(*)())(& spif_str_show),
     (void *(*)())(& spif_str_comp), (void *(*)())(& spif_str_dup), (void *(*)())(& spif_str_type)},
    (void *(*)())(& spif_str_new_from_ptr), (void *(*)())(& spif_str_new_from_buff),
    (void *(*)())(& spif_str_new_from_fp), (void *(*)())(& spif_str_new_from_fd),
    (void *(*)())(& spif_str_new_from_num), (void *(*)())(& spif_str_init_from_ptr),
    (void *(*)())(& spif_str_init_from_buff), (void *(*)())(& spif_str_init_from_fp),
    (void *(*)())(& spif_str_init_from_fd), (void *(*)())(& spif_str_init_from_num),
    (void *(*)())(& spif_str_append), (void *(*)())(& spif_str_append_char), (void *(*)())(& spif_str_append_from_ptr),
    (void *(*)())(& spif_str_casecmp), (void *(*)())(& spif_str_casecmp_with_ptr),
    (void *(*)())(& spif_str_clear), (void *(*)())(& spif_str_cmp), (void *(*)())(& spif_str_cmp_with_ptr),
    (void *(*)())(& spif_str_downcase), (void *(*)())(& spif_str_find), (void *(*)())(& spif_str_find_from_ptr),
    (void *(*)())(& spif_str_index), (void *(*)())(& spif_str_ncasecmp), (void *(*)())(& spif_str_ncasecmp_with_ptr),
    (void *(*)())(& spif_str_ncmp), (void *(*)())(& spif_str_ncmp_with_ptr), (void *(*)())(& spif_str_prepend),
    (void *(*)())(& spif_str_prepend_char), (void *(*)())(& spif_str_prepend_from_ptr),
    (void *(*)())(& spif_str_reverse), (void *(*)())(& spif_str_rindex), (void *(*)())(& spif_str_splice),
    (void *(*)())(& spif_str_splice_from_ptr), (void *(*)())(& spif_str_substr), (void *(*)())(& spif_str_substr_to_ptr),
    (void *(*)())(& spif_str_to_float), (void *(*)())(& spif_str_to_num), (void *(*)())(& spif_str_trim),
    (void *(*)())(& spif_str_upcase)};
#line 85 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_class_t spif_str_class  =    (spif_class_t )(& s_class);
#line 86 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_strclass_t spif_str_strclass  =    & s_class;
#line 89 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
unsigned long const   buff_inc  =    (size_t const   )4096;
#line 91 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_str_t spif_str_new(void) 
{ 
  spif_str_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 96
  tmp = malloc(sizeof(spif_const_str_t ));
#line 96
  self = (spif_str_t )tmp;
#line 97
  tmp___0 = spif_str_init(self);
  }
#line 97
  if (! tmp___0) {
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 98
      free((void *)self);
#line 98
      self = (spif_str_t )((void *)0);
      }
#line 98
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 99
    self = (spif_str_t )((void *)0);
  }
#line 101
  return (self);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_str_t spif_str_new_from_ptr(spif_charptr_t old ) 
{ 
  spif_str_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 109
  tmp = malloc(sizeof(spif_const_str_t ));
#line 109
  self = (spif_str_t )tmp;
#line 110
  tmp___0 = spif_str_init_from_ptr(self, old);
  }
#line 110
  if (! tmp___0) {
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 111
      free((void *)self);
#line 111
      self = (spif_str_t )((void *)0);
      }
#line 111
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 112
    self = (spif_str_t )((void *)0);
  }
#line 114
  return (self);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_str_t spif_str_new_from_buff(spif_charptr_t buff , spif_stridx_t size ) 
{ 
  spif_str_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 122
  tmp = malloc(sizeof(spif_const_str_t ));
#line 122
  self = (spif_str_t )tmp;
#line 123
  tmp___0 = spif_str_init_from_buff(self, buff, size);
  }
#line 123
  if (! tmp___0) {
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 124
      free((void *)self);
#line 124
      self = (spif_str_t )((void *)0);
      }
#line 124
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 125
    self = (spif_str_t )((void *)0);
  }
#line 127
  return (self);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_str_t spif_str_new_from_fp(FILE *fp ) 
{ 
  spif_str_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 135
  tmp = malloc(sizeof(spif_const_str_t ));
#line 135
  self = (spif_str_t )tmp;
#line 136
  tmp___0 = spif_str_init_from_fp(self, fp);
  }
#line 136
  if (! tmp___0) {
    {
#line 137
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 137
      free((void *)self);
#line 137
      self = (spif_str_t )((void *)0);
      }
#line 137
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 138
    self = (spif_str_t )((void *)0);
  }
#line 140
  return (self);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_str_t spif_str_new_from_fd(int fd ) 
{ 
  spif_str_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 148
  tmp = malloc(sizeof(spif_const_str_t ));
#line 148
  self = (spif_str_t )tmp;
#line 149
  tmp___0 = spif_str_init_from_fd(self, fd);
  }
#line 149
  if (! tmp___0) {
    {
#line 150
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 150
      free((void *)self);
#line 150
      self = (spif_str_t )((void *)0);
      }
#line 150
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 151
    self = (spif_str_t )((void *)0);
  }
#line 153
  return (self);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_str_t spif_str_new_from_num(long num ) 
{ 
  spif_str_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 161
  tmp = malloc(sizeof(spif_const_str_t ));
#line 161
  self = (spif_str_t )tmp;
#line 162
  tmp___0 = spif_str_init_from_num(self, num);
  }
#line 162
  if (! tmp___0) {
    {
#line 163
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 163
      free((void *)self);
#line 163
      self = (spif_str_t )((void *)0);
      }
#line 163
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 164
    self = (spif_str_t )((void *)0);
  }
#line 166
  return (self);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_init(spif_str_t self ) 
{ 


  {
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 172
      if (libast_debug_level >= 1U) {
        {
#line 172
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           172, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 172
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             172, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 172
      return ((spif_bool_t )0);
    }
#line 172
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_str_strclass);
#line 175
  self->s = (spif_charptr_t )((void *)0);
#line 176
  self->len = (spif_stridx_t )0;
#line 177
  self->size = (spif_stridx_t )0;
  }
#line 178
  return ((spif_bool_t )1);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_init_from_ptr(spif_str_t self , spif_charptr_t old ) 
{ 
  time_t tmp ;
  spif_bool_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 184
      if (libast_debug_level >= 1U) {
        {
#line 184
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           184, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 184
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             184, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 184
      return ((spif_bool_t )0);
    }
#line 184
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 185
    if (! ((unsigned long )old != (unsigned long )((spif_charptr_t )((void *)0)))) {
#line 185
      if (libast_debug_level >= 1U) {
        {
#line 185
        tmp = time((time_t *)((void *)0));
#line 185
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                185, "spif_str_init_from_ptr");
#line 185
        libast_dprintf("REQUIRE failed:  %s\n", "(old != SPIF_NULL_TYPE(charptr))");
        }
      }
      {
#line 185
      tmp___0 = spif_str_init(self);
      }
#line 185
      return (tmp___0);
    }
#line 185
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 187
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_str_strclass);
#line 188
  tmp___1 = strlen((char const   *)old);
#line 188
  self->len = (spif_stridx_t )tmp___1;
#line 189
  self->size = self->len + 1L;
#line 190
  tmp___2 = malloc((size_t )self->size);
#line 190
  self->s = (spif_charptr_t )tmp___2;
#line 191
  memcpy((void */* __restrict  */)self->s, (void const   */* __restrict  */)old, (size_t )self->size);
  }
#line 192
  return ((spif_bool_t )1);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_init_from_buff(spif_str_t self , spif_charptr_t buff , spif_stridx_t size ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 198
      if (libast_debug_level >= 1U) {
        {
#line 198
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_buff",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           198, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 198
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_buff",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             198, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 198
      return ((spif_bool_t )0);
    }
#line 198
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 200
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_str_strclass);
#line 201
  self->size = size;
  }
#line 202
  if ((unsigned long )buff != (unsigned long )((spif_charptr_t )((void *)0))) {
    {
#line 203
    tmp = strnlen((char const   *)buff, (size_t )size);
#line 203
    self->len = (spif_stridx_t )tmp;
    }
  } else {
#line 205
    self->len = (spif_stridx_t )0;
  }
#line 207
  if (self->size == self->len) {
#line 208
    (self->size) ++;
  }
  {
#line 210
  tmp___0 = malloc((size_t )self->size);
#line 210
  self->s = (spif_charptr_t )tmp___0;
  }
#line 211
  if ((unsigned long )buff != (unsigned long )((spif_charptr_t )((void *)0))) {
    {
#line 212
    memcpy((void */* __restrict  */)self->s, (void const   */* __restrict  */)buff,
           (size_t )self->len);
    }
  }
#line 214
  *(self->s + self->len) = (spif_char_t )0;
#line 215
  return ((spif_bool_t )1);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_init_from_fp(spif_str_t self , FILE *fp ) 
{ 
  spif_charptr_t p ;
  spif_charptr_t end ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;

  {
#line 221
  end = (spif_charptr_t )((void *)0);
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 223
      if (libast_debug_level >= 1U) {
        {
#line 223
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_fp",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           223, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 223
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_fp",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             223, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 223
      return ((spif_bool_t )0);
    }
#line 223
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 224
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 224
    if (! ((unsigned long )fp != (unsigned long )((FILE *)((void *)0)))) {
#line 224
      if (libast_debug_level >= 1U) {
        {
#line 224
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_fp",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           224, "(fp != SPIF_NULL_TYPE_C(FILE *))");
        }
      } else {
        {
#line 224
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_fp",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             224, "(fp != SPIF_NULL_TYPE_C(FILE *))");
        }
      }
#line 224
      return ((spif_bool_t )0);
    }
#line 224
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 226
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_str_strclass);
#line 227
  self->size = (spif_stridx_t )buff_inc;
#line 228
  self->len = (spif_stridx_t )0;
#line 229
  tmp = malloc((size_t )self->size);
#line 229
  self->s = (spif_charptr_t )tmp;
#line 231
  p = self->s;
  }
  {
#line 231
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 231
    tmp___6 = fgets((char */* __restrict  */)((char *)p), (int )buff_inc, (FILE */* __restrict  */)fp);
    }
#line 231
    if (! tmp___6) {
#line 231
      goto while_break___1;
    }
    {
#line 232
    tmp___5 = strchr((char const   *)p, '\n');
#line 232
    end = (spif_charptr_t )tmp___5;
    }
#line 232
    if ((unsigned long )end == (unsigned long )((void *)0)) {
#line 234
      self->size = (spif_stridx_t )((unsigned long const   )self->size + buff_inc);
#line 235
      if (self->size) {
#line 235
        if (self->s) {
          {
#line 235
          tmp___0 = realloc((void *)self->s, (size_t )self->size);
#line 235
          tmp___2 = tmp___0;
          }
        } else {
          {
#line 235
          tmp___1 = malloc((size_t )self->size);
#line 235
          tmp___2 = tmp___1;
          }
        }
#line 235
        tmp___4 = tmp___2;
      } else {
#line 235
        if (self->s) {
          {
#line 235
          free((void *)self->s);
#line 235
          tmp___3 = (void *)0;
          }
        } else {
#line 235
          tmp___3 = (void *)0;
        }
#line 235
        tmp___4 = tmp___3;
      }
#line 235
      self->s = (spif_charptr_t )tmp___4;
    } else {
#line 237
      *end = (spif_char_t )0;
#line 238
      goto while_break___1;
    }
#line 231
    p += buff_inc;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 241
  if (end) {
#line 241
    tmp___8 = end - self->s;
  } else {
    {
#line 241
    tmp___7 = strlen((char const   *)self->s);
#line 241
    tmp___8 = (long )((int )tmp___7);
    }
  }
#line 241
  self->len = tmp___8;
#line 244
  self->size = self->len + 1L;
#line 245
  if (self->size) {
#line 245
    if (self->s) {
      {
#line 245
      tmp___9 = realloc((void *)self->s, (size_t )self->size);
#line 245
      tmp___11 = tmp___9;
      }
    } else {
      {
#line 245
      tmp___10 = malloc((size_t )self->size);
#line 245
      tmp___11 = tmp___10;
      }
    }
#line 245
    tmp___13 = tmp___11;
  } else {
#line 245
    if (self->s) {
      {
#line 245
      free((void *)self->s);
#line 245
      tmp___12 = (void *)0;
      }
    } else {
#line 245
      tmp___12 = (void *)0;
    }
#line 245
    tmp___13 = tmp___12;
  }
#line 245
  self->s = (spif_charptr_t )tmp___13;
#line 246
  return ((spif_bool_t )1);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_init_from_fd(spif_str_t self , int fd ) 
{ 
  int n ;
  spif_charptr_t p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  ssize_t tmp___5 ;
  int *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 255
      if (libast_debug_level >= 1U) {
        {
#line 255
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_fd",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           255, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 255
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_fd",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             255, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 255
      return ((spif_bool_t )0);
    }
#line 255
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 256
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 256
    if (! (fd >= 0)) {
#line 256
      if (libast_debug_level >= 1U) {
        {
#line 256
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_fd",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           256, "(fd >= 0)");
        }
      } else {
        {
#line 256
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_fd",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             256, "(fd >= 0)");
        }
      }
#line 256
      return ((spif_bool_t )0);
    }
#line 256
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 258
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_str_strclass);
#line 259
  self->size = (spif_stridx_t )buff_inc;
#line 260
  self->len = (spif_stridx_t )0;
#line 261
  tmp = malloc((size_t )self->size);
#line 261
  self->s = (spif_charptr_t )tmp;
#line 263
  p = self->s;
  }
  {
#line 263
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 263
    tmp___5 = read(fd, (void *)p, (size_t )buff_inc);
#line 263
    n = (int )tmp___5;
    }
#line 263
    if (! (n > 0)) {
      {
#line 263
      tmp___6 = __errno_location();
      }
#line 263
      if (! (*tmp___6 == 4)) {
#line 263
        goto while_break___1;
      }
    }
#line 264
    self->size += (spif_stridx_t )n;
#line 265
    if (self->size) {
#line 265
      if (self->s) {
        {
#line 265
        tmp___0 = realloc((void *)self->s, (size_t )self->size);
#line 265
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 265
        tmp___1 = malloc((size_t )self->size);
#line 265
        tmp___2 = tmp___1;
        }
      }
#line 265
      tmp___4 = tmp___2;
    } else {
#line 265
      if (self->s) {
        {
#line 265
        free((void *)self->s);
#line 265
        tmp___3 = (void *)0;
        }
      } else {
#line 265
        tmp___3 = (void *)0;
      }
#line 265
      tmp___4 = tmp___3;
    }
#line 265
    self->s = (spif_charptr_t )tmp___4;
#line 266
    p += n;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 268
  self->len = (spif_stridx_t )((unsigned long const   )self->size - buff_inc);
#line 269
  self->size = self->len + 1L;
#line 270
  if (self->size) {
#line 270
    if (self->s) {
      {
#line 270
      tmp___7 = realloc((void *)self->s, (size_t )self->size);
#line 270
      tmp___9 = tmp___7;
      }
    } else {
      {
#line 270
      tmp___8 = malloc((size_t )self->size);
#line 270
      tmp___9 = tmp___8;
      }
    }
#line 270
    tmp___11 = tmp___9;
  } else {
#line 270
    if (self->s) {
      {
#line 270
      free((void *)self->s);
#line 270
      tmp___10 = (void *)0;
      }
    } else {
#line 270
      tmp___10 = (void *)0;
    }
#line 270
    tmp___11 = tmp___10;
  }
#line 270
  self->s = (spif_charptr_t )tmp___11;
#line 271
  *(self->s + self->len) = (spif_char_t )0;
#line 272
  return ((spif_bool_t )1);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_init_from_num(spif_str_t self , long num ) 
{ 
  spif_char_t buff[28] ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 280
      if (libast_debug_level >= 1U) {
        {
#line 280
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_num",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           280, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 280
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_init_from_num",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             280, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 280
      return ((spif_bool_t )0);
    }
#line 280
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_str_strclass);
#line 284
  snprintf((char */* __restrict  */)((char *)(buff)), sizeof(buff), (char const   */* __restrict  */)"%ld",
           num);
#line 285
  tmp = strlen((char const   *)((char *)(buff)));
#line 285
  self->len = (spif_stridx_t )tmp;
#line 286
  self->size = self->len + 1L;
#line 287
  tmp___0 = malloc((size_t )self->size);
#line 287
  self->s = (spif_charptr_t )tmp___0;
#line 288
  strcpy((char */* __restrict  */)((char *)self->s), (char const   */* __restrict  */)((char *)(buff)));
  }
#line 290
  return ((spif_bool_t )1);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_done(spif_str_t self ) 
{ 


  {
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 296
      if (libast_debug_level >= 1U) {
        {
#line 296
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           296, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 296
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             296, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 296
      return ((spif_bool_t )0);
    }
#line 296
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  if (self->size) {
    {
#line 298
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 298
      free((void *)self->s);
#line 298
      self->s = (spif_charptr_t )((void *)0);
      }
#line 298
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 299
    self->len = (spif_stridx_t )0;
#line 300
    self->size = (spif_stridx_t )0;
#line 301
    self->s = (spif_charptr_t )((void *)0);
  }
#line 303
  return ((spif_bool_t )1);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_del(spif_str_t self ) 
{ 


  {
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 309
      if (libast_debug_level >= 1U) {
        {
#line 309
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           309, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 309
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             309, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 309
      return ((spif_bool_t )0);
    }
#line 309
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 310
  spif_str_done(self);
  }
  {
#line 311
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 311
    free((void *)self);
#line 311
    self = (spif_str_t )((void *)0);
    }
#line 311
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 312
  return ((spif_bool_t )1);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_str_t spif_str_show(spif_str_t self , spif_charptr_t name___0 , spif_str_t buff ,
                         size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  char *tmp___0 ;

  {
#line 320
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 321
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 321
      memset((void *)(tmp), ' ', indent);
      }
#line 321
      if ((char *)name___0) {
#line 321
        tmp___0 = (char *)name___0;
      } else {
#line 321
        tmp___0 = (char *)"<name null>";
      }
      {
#line 321
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_str_t) %s:  { ((spif_str_t) NULL) }\n",
               tmp___0);
      }
#line 321
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 321
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 321
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 321
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 322
    return (buff);
  }
  {
#line 325
  memset((void *)(tmp), ' ', indent);
#line 326
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_str_t) %s:  %10p { \"", name___0,
           (spif_ptr_t )self);
  }
#line 329
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 330
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 332
    spif_str_append_from_ptr(buff, tmp);
    }
  }
  {
#line 335
  spif_str_append(buff, self);
#line 337
  snprintf((char */* __restrict  */)((char *)(tmp)), sizeof(tmp), (char const   */* __restrict  */)"\", len %lu, size %lu }\n",
           (unsigned long )self->len, (unsigned long )self->size);
#line 339
  spif_str_append_from_ptr(buff, tmp);
  }
#line 340
  return (buff);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_cmp_t spif_str_comp(spif_str_t self , spif_str_t other ) 
{ 
  spif_cmp_t tmp ;

  {
  {
#line 346
  tmp = spif_str_cmp(self, other);
  }
#line 346
  return (tmp);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_str_t spif_str_dup(spif_str_t self ) 
{ 
  spif_str_t tmp ;
  void *tmp___0 ;
  spif_charptr_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 354
      if (libast_debug_level >= 1U) {
        {
#line 354
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           354, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 354
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             354, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 354
      return ((spif_str_t )((void *)0));
    }
#line 354
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 355
  tmp___0 = malloc(sizeof(spif_const_str_t ));
#line 355
  tmp = (spif_str_t )tmp___0;
#line 356
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self, sizeof(spif_const_str_t ));
  }
#line 357
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 357
    tmp___1 = (spif_charptr_t )"";
  } else {
#line 357
    tmp___1 = self->s;
  }
  {
#line 357
  tmp___2 = strdup((char const   *)((char *)((char const   *)((spif_charptr_t const   )tmp___1))));
#line 357
  tmp->s = (spif_charptr_t )tmp___2;
#line 358
  tmp->len = self->len;
#line 359
  tmp->size = self->size;
  }
#line 360
  return (tmp);
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_classname_t spif_str_type(spif_str_t self ) 
{ 


  {
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 366
      if (libast_debug_level >= 1U) {
        {
#line 366
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           366, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 366
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             366, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 366
      return ((spif_classname_t )"{ ((spif_classname_t) NULL) }");
    }
#line 366
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_append(spif_str_t self , spif_str_t other ) 
{ 
  time_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  spif_charptr_t tmp___5 ;

  {
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 373
      if (libast_debug_level >= 1U) {
        {
#line 373
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_append",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           373, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 373
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_append",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             373, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 373
      return ((spif_bool_t )0);
    }
#line 373
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 374
    if (! (! ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 374
      if (libast_debug_level >= 1U) {
        {
#line 374
        tmp = time((time_t *)((void *)0));
#line 374
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                374, "spif_str_append");
#line 374
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_STR_ISNULL(other)");
        }
      }
#line 374
      return ((spif_bool_t )0);
    }
#line 374
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 375
  if (other->size) {
#line 375
    if (other->len) {
#line 376
      self->size += other->size - 1L;
#line 377
      if (self->size) {
#line 377
        if (self->s) {
          {
#line 377
          tmp___0 = realloc((void *)self->s, (size_t )self->size);
#line 377
          tmp___2 = tmp___0;
          }
        } else {
          {
#line 377
          tmp___1 = malloc((size_t )self->size);
#line 377
          tmp___2 = tmp___1;
          }
        }
#line 377
        tmp___4 = tmp___2;
      } else {
#line 377
        if (self->s) {
          {
#line 377
          free((void *)self->s);
#line 377
          tmp___3 = (void *)0;
          }
        } else {
#line 377
          tmp___3 = (void *)0;
        }
#line 377
        tmp___4 = tmp___3;
      }
#line 377
      self->s = (spif_charptr_t )tmp___4;
#line 378
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 378
        tmp___5 = (spif_charptr_t )"";
      } else {
#line 378
        tmp___5 = other->s;
      }
      {
#line 378
      memcpy((void */* __restrict  */)(self->s + self->len), (void const   */* __restrict  */)((spif_charptr_t const   )tmp___5),
             (size_t )(other->len + 1L));
#line 379
      self->len += other->len;
      }
    }
  }
#line 381
  return ((spif_bool_t )1);
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_append_char(spif_str_t self , spif_char_t c ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 387
      if (libast_debug_level >= 1U) {
        {
#line 387
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_append_char",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           387, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 387
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_append_char",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             387, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 387
      return ((spif_bool_t )0);
    }
#line 387
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  (self->len) ++;
#line 389
  if (self->size <= self->len) {
#line 390
    (self->size) ++;
#line 391
    if (self->size) {
#line 391
      if (self->s) {
        {
#line 391
        tmp = realloc((void *)self->s, (size_t )self->size);
#line 391
        tmp___1 = tmp;
        }
      } else {
        {
#line 391
        tmp___0 = malloc((size_t )self->size);
#line 391
        tmp___1 = tmp___0;
        }
      }
#line 391
      tmp___3 = tmp___1;
    } else {
#line 391
      if (self->s) {
        {
#line 391
        free((void *)self->s);
#line 391
        tmp___2 = (void *)0;
        }
      } else {
#line 391
        tmp___2 = (void *)0;
      }
#line 391
      tmp___3 = tmp___2;
    }
#line 391
    self->s = (spif_charptr_t )tmp___3;
  }
#line 393
  *(self->s + (self->len - 1L)) = c;
#line 394
  *(self->s + self->len) = (spif_char_t )0;
#line 395
  return ((spif_bool_t )1);
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_append_from_ptr(spif_str_t self , spif_charptr_t other ) 
{ 
  spif_stridx_t len ;
  time_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 403
      if (libast_debug_level >= 1U) {
        {
#line 403
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_append_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           403, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 403
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_append_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             403, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 403
      return ((spif_bool_t )0);
    }
#line 403
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 404
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 404
    if (! ((unsigned long )other != (unsigned long )((spif_charptr_t )((void *)0)))) {
#line 404
      if (libast_debug_level >= 1U) {
        {
#line 404
        tmp = time((time_t *)((void *)0));
#line 404
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                404, "spif_str_append_from_ptr");
#line 404
        libast_dprintf("REQUIRE failed:  %s\n", "(other != SPIF_NULL_TYPE(charptr))");
        }
      }
#line 404
      return ((spif_bool_t )0);
    }
#line 404
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 405
  tmp___0 = strlen((char const   *)other);
#line 405
  len = (spif_stridx_t )tmp___0;
  }
#line 406
  if (len) {
#line 407
    self->size += len;
#line 408
    if (self->size) {
#line 408
      if (self->s) {
        {
#line 408
        tmp___1 = realloc((void *)self->s, (size_t )self->size);
#line 408
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 408
        tmp___2 = malloc((size_t )self->size);
#line 408
        tmp___3 = tmp___2;
        }
      }
#line 408
      tmp___5 = tmp___3;
    } else {
#line 408
      if (self->s) {
        {
#line 408
        free((void *)self->s);
#line 408
        tmp___4 = (void *)0;
        }
      } else {
#line 408
        tmp___4 = (void *)0;
      }
#line 408
      tmp___5 = tmp___4;
    }
    {
#line 408
    self->s = (spif_charptr_t )tmp___5;
#line 409
    memcpy((void */* __restrict  */)(self->s + self->len), (void const   */* __restrict  */)other,
           (size_t )(len + 1L));
#line 410
    self->len += len;
    }
  }
#line 412
  return ((spif_bool_t )1);
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_cmp_t spif_str_casecmp(spif_str_t self , spif_str_t other ) 
{ 
  int c ;
  spif_charptr_t tmp ;
  spif_charptr_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 420
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 420
        return ((spif_cmp_t )0);
      } else {
#line 420
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 420
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 420
      return ((spif_cmp_t )-1);
    } else
#line 420
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 420
      return ((spif_cmp_t )1);
    }
#line 420
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 421
  if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 421
    tmp = (spif_charptr_t )"";
  } else {
#line 421
    tmp = other->s;
  }
#line 421
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 421
    tmp___0 = (spif_charptr_t )"";
  } else {
#line 421
    tmp___0 = self->s;
  }
  {
#line 421
  c = strcasecmp((char const   *)((char *)((spif_charptr_t const   )tmp___0)), (char const   *)((char *)((spif_charptr_t const   )tmp)));
  }
#line 422
  if (c < 0) {
#line 422
    tmp___2 = -1;
  } else {
#line 422
    if (c > 0) {
#line 422
      tmp___1 = 1;
    } else {
#line 422
      tmp___1 = 0;
    }
#line 422
    tmp___2 = tmp___1;
  }
#line 422
  return ((spif_cmp_t )tmp___2);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_cmp_t spif_str_casecmp_with_ptr(spif_str_t self , spif_charptr_t other ) 
{ 
  int c ;
  spif_charptr_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 430
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 430
        return ((spif_cmp_t )0);
      } else {
#line 430
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 430
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 430
      return ((spif_cmp_t )-1);
    } else
#line 430
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 430
      return ((spif_cmp_t )1);
    }
#line 430
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 431
    tmp = (spif_charptr_t )"";
  } else {
#line 431
    tmp = self->s;
  }
  {
#line 431
  c = strcasecmp((char const   *)((char *)((spif_charptr_t const   )tmp)), (char const   *)((char *)other));
  }
#line 432
  if (c < 0) {
#line 432
    tmp___1 = -1;
  } else {
#line 432
    if (c > 0) {
#line 432
      tmp___0 = 1;
    } else {
#line 432
      tmp___0 = 0;
    }
#line 432
    tmp___1 = tmp___0;
  }
#line 432
  return ((spif_cmp_t )tmp___1);
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_clear(spif_str_t self , spif_char_t c ) 
{ 


  {
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 438
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 438
      if (libast_debug_level >= 1U) {
        {
#line 438
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_clear",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           438, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 438
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_clear",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             438, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 438
      return ((spif_bool_t )0);
    }
#line 438
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 439
  memset((void *)self->s, (int )c, (size_t )self->size);
#line 440
  *(self->s + self->len) = (spif_char_t )0;
  }
#line 441
  return ((spif_bool_t )1);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_cmp_t spif_str_cmp(spif_str_t self , spif_str_t other ) 
{ 
  int c ;
  spif_charptr_t tmp ;
  spif_charptr_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 449
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 449
        return ((spif_cmp_t )0);
      } else {
#line 449
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 449
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 449
      return ((spif_cmp_t )-1);
    } else
#line 449
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 449
      return ((spif_cmp_t )1);
    }
#line 449
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 450
    tmp = (spif_charptr_t )"";
  } else {
#line 450
    tmp = other->s;
  }
#line 450
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 450
    tmp___0 = (spif_charptr_t )"";
  } else {
#line 450
    tmp___0 = self->s;
  }
  {
#line 450
  c = strcmp((char const   *)((char *)((spif_charptr_t const   )tmp___0)), (char const   *)((char *)((spif_charptr_t const   )tmp)));
  }
#line 451
  if (c < 0) {
#line 451
    tmp___2 = -1;
  } else {
#line 451
    if (c > 0) {
#line 451
      tmp___1 = 1;
    } else {
#line 451
      tmp___1 = 0;
    }
#line 451
    tmp___2 = tmp___1;
  }
#line 451
  return ((spif_cmp_t )tmp___2);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_cmp_t spif_str_cmp_with_ptr(spif_str_t self , spif_charptr_t other ) 
{ 
  int c ;
  spif_charptr_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 459
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 459
        return ((spif_cmp_t )0);
      } else {
#line 459
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 459
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 459
      return ((spif_cmp_t )-1);
    } else
#line 459
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 459
      return ((spif_cmp_t )1);
    }
#line 459
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 460
    tmp = (spif_charptr_t )"";
  } else {
#line 460
    tmp = self->s;
  }
  {
#line 460
  c = strcmp((char const   *)((char *)((spif_charptr_t const   )tmp)), (char const   *)((char *)other));
  }
#line 461
  if (c < 0) {
#line 461
    tmp___1 = -1;
  } else {
#line 461
    if (c > 0) {
#line 461
      tmp___0 = 1;
    } else {
#line 461
      tmp___0 = 0;
    }
#line 461
    tmp___1 = tmp___0;
  }
#line 461
  return ((spif_cmp_t )tmp___1);
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_downcase(spif_str_t self ) 
{ 
  spif_charptr_t tmp ;
  int tmp___0 ;

  {
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 469
      if (libast_debug_level >= 1U) {
        {
#line 469
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_downcase",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           469, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 469
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_downcase",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             469, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 469
      return ((spif_bool_t )0);
    }
#line 469
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  tmp = self->s;
  {
#line 470
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 470
    if (! *tmp) {
#line 470
      goto while_break___0;
    }
    {
#line 471
    tmp___0 = tolower((int )*tmp);
#line 471
    *tmp = (spif_char_t )tmp___0;
#line 470
    tmp ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 473
  return ((spif_bool_t )1);
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_stridx_t spif_str_find(spif_str_t self , spif_str_t other ) 
{ 
  char *tmp ;
  time_t tmp___0 ;
  spif_charptr_t tmp___1 ;
  spif_charptr_t tmp___2 ;
  spif_charptr_t tmp___3 ;

  {
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 481
      if (libast_debug_level >= 1U) {
        {
#line 481
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_find",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           481, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 481
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_find",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             481, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 481
      return ((spif_stridx_t )-1);
    }
#line 481
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 482
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 482
    if (! (! ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 482
      if (libast_debug_level >= 1U) {
        {
#line 482
        tmp___0 = time((time_t *)((void *)0));
#line 482
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                482, "spif_str_find");
#line 482
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_STR_ISNULL(other)");
        }
      }
#line 482
      return ((spif_stridx_t )-1);
    }
#line 482
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 483
  if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 483
    tmp___1 = (spif_charptr_t )"";
  } else {
#line 483
    tmp___1 = other->s;
  }
#line 483
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 483
    tmp___2 = (spif_charptr_t )"";
  } else {
#line 483
    tmp___2 = self->s;
  }
  {
#line 483
  tmp = strstr((char const   *)((spif_charptr_t const   )tmp___2), (char const   *)((spif_charptr_t const   )tmp___1));
  }
#line 485
  if (tmp) {
#line 486
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 486
      tmp___3 = (spif_charptr_t )"";
    } else {
#line 486
      tmp___3 = self->s;
    }
#line 486
    return ((spif_long_t )tmp - (spif_long_t )((spif_charptr_t const   )tmp___3));
  } else {
#line 488
    return (self->len);
  }
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_stridx_t spif_str_find_from_ptr(spif_str_t self , spif_charptr_t other ) 
{ 
  char *tmp ;
  time_t tmp___0 ;
  spif_charptr_t tmp___1 ;
  spif_charptr_t tmp___2 ;

  {
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 497
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 497
      if (libast_debug_level >= 1U) {
        {
#line 497
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_find_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           497, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 497
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_find_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             497, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 497
      return ((spif_stridx_t )-1);
    }
#line 497
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 498
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 498
    if (! ((unsigned long )other != (unsigned long )((spif_charptr_t )((void *)0)))) {
#line 498
      if (libast_debug_level >= 1U) {
        {
#line 498
        tmp___0 = time((time_t *)((void *)0));
#line 498
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                498, "spif_str_find_from_ptr");
#line 498
        libast_dprintf("REQUIRE failed:  %s\n", "(other != SPIF_NULL_TYPE(charptr))");
        }
      }
#line 498
      return ((spif_stridx_t )-1);
    }
#line 498
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 499
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 499
    tmp___1 = (spif_charptr_t )"";
  } else {
#line 499
    tmp___1 = self->s;
  }
  {
#line 499
  tmp = strstr((char const   *)((spif_charptr_t const   )tmp___1), (char const   *)other);
  }
#line 501
  if (tmp) {
#line 502
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 502
      tmp___2 = (spif_charptr_t )"";
    } else {
#line 502
      tmp___2 = self->s;
    }
#line 502
    return ((spif_long_t )tmp - (spif_long_t )((spif_charptr_t const   )tmp___2));
  } else {
#line 504
    return (self->len);
  }
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_stridx_t spif_str_index(spif_str_t self , spif_char_t c ) 
{ 
  char *tmp ;
  spif_charptr_t tmp___0 ;
  spif_charptr_t tmp___1 ;

  {
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 513
      if (libast_debug_level >= 1U) {
        {
#line 513
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_index",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           513, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 513
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_index",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             513, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 513
      return ((spif_stridx_t )-1);
    }
#line 513
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 514
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 514
    tmp___0 = (spif_charptr_t )"";
  } else {
#line 514
    tmp___0 = self->s;
  }
  {
#line 514
  tmp = index((char const   *)((spif_charptr_t const   )tmp___0), (int )c);
  }
#line 515
  if (tmp) {
#line 516
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 516
      tmp___1 = (spif_charptr_t )"";
    } else {
#line 516
      tmp___1 = self->s;
    }
#line 516
    return ((spif_long_t )tmp - (spif_long_t )((spif_charptr_t const   )tmp___1));
  } else {
#line 518
    return (self->len);
  }
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_cmp_t spif_str_ncasecmp(spif_str_t self , spif_str_t other , spif_stridx_t cnt ) 
{ 
  int c ;
  spif_charptr_t tmp ;
  spif_charptr_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 527
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 527
        return ((spif_cmp_t )0);
      } else {
#line 527
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 527
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 527
      return ((spif_cmp_t )-1);
    } else
#line 527
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 527
      return ((spif_cmp_t )1);
    }
#line 527
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 528
    tmp = (spif_charptr_t )"";
  } else {
#line 528
    tmp = other->s;
  }
#line 528
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 528
    tmp___0 = (spif_charptr_t )"";
  } else {
#line 528
    tmp___0 = self->s;
  }
  {
#line 528
  c = strncasecmp((char const   *)((char *)((spif_charptr_t const   )tmp___0)), (char const   *)((char *)((spif_charptr_t const   )tmp)),
                  (size_t )cnt);
  }
#line 529
  if (c < 0) {
#line 529
    tmp___2 = -1;
  } else {
#line 529
    if (c > 0) {
#line 529
      tmp___1 = 1;
    } else {
#line 529
      tmp___1 = 0;
    }
#line 529
    tmp___2 = tmp___1;
  }
#line 529
  return ((spif_cmp_t )tmp___2);
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_cmp_t spif_str_ncasecmp_with_ptr(spif_str_t self , spif_charptr_t other , spif_stridx_t cnt ) 
{ 
  int c ;
  spif_charptr_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 537
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 537
        return ((spif_cmp_t )0);
      } else {
#line 537
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 537
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 537
      return ((spif_cmp_t )-1);
    } else
#line 537
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 537
      return ((spif_cmp_t )1);
    }
#line 537
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 538
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 538
    tmp = (spif_charptr_t )"";
  } else {
#line 538
    tmp = self->s;
  }
  {
#line 538
  c = strncasecmp((char const   *)((char *)((spif_charptr_t const   )tmp)), (char const   *)((char *)other),
                  (size_t )cnt);
  }
#line 539
  if (c < 0) {
#line 539
    tmp___1 = -1;
  } else {
#line 539
    if (c > 0) {
#line 539
      tmp___0 = 1;
    } else {
#line 539
      tmp___0 = 0;
    }
#line 539
    tmp___1 = tmp___0;
  }
#line 539
  return ((spif_cmp_t )tmp___1);
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_cmp_t spif_str_ncmp(spif_str_t self , spif_str_t other , spif_stridx_t cnt ) 
{ 
  int c ;
  spif_charptr_t tmp ;
  spif_charptr_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 547
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 547
        return ((spif_cmp_t )0);
      } else {
#line 547
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 547
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 547
      return ((spif_cmp_t )-1);
    } else
#line 547
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 547
      return ((spif_cmp_t )1);
    }
#line 547
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 548
  if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 548
    tmp = (spif_charptr_t )"";
  } else {
#line 548
    tmp = other->s;
  }
#line 548
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 548
    tmp___0 = (spif_charptr_t )"";
  } else {
#line 548
    tmp___0 = self->s;
  }
  {
#line 548
  c = strncmp((char const   *)((char *)((spif_charptr_t const   )tmp___0)), (char const   *)((char *)((spif_charptr_t const   )tmp)),
              (size_t )cnt);
  }
#line 549
  if (c < 0) {
#line 549
    tmp___2 = -1;
  } else {
#line 549
    if (c > 0) {
#line 549
      tmp___1 = 1;
    } else {
#line 549
      tmp___1 = 0;
    }
#line 549
    tmp___2 = tmp___1;
  }
#line 549
  return ((spif_cmp_t )tmp___2);
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_cmp_t spif_str_ncmp_with_ptr(spif_str_t self , spif_charptr_t other , spif_stridx_t cnt ) 
{ 
  int c ;
  spif_charptr_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 557
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 557
        return ((spif_cmp_t )0);
      } else {
#line 557
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 557
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 557
      return ((spif_cmp_t )-1);
    } else
#line 557
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 557
      return ((spif_cmp_t )1);
    }
#line 557
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 558
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 558
    tmp = (spif_charptr_t )"";
  } else {
#line 558
    tmp = self->s;
  }
  {
#line 558
  c = strncmp((char const   *)((char *)((spif_charptr_t const   )tmp)), (char const   *)((char *)other),
              (size_t )cnt);
  }
#line 559
  if (c < 0) {
#line 559
    tmp___1 = -1;
  } else {
#line 559
    if (c > 0) {
#line 559
      tmp___0 = 1;
    } else {
#line 559
      tmp___0 = 0;
    }
#line 559
    tmp___1 = tmp___0;
  }
#line 559
  return ((spif_cmp_t )tmp___1);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_prepend(spif_str_t self , spif_str_t other ) 
{ 
  time_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  spif_charptr_t tmp___5 ;

  {
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 565
      if (libast_debug_level >= 1U) {
        {
#line 565
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_prepend",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           565, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 565
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_prepend",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             565, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 565
      return ((spif_bool_t )0);
    }
#line 565
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 566
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 566
    if (! (! ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 566
      if (libast_debug_level >= 1U) {
        {
#line 566
        tmp = time((time_t *)((void *)0));
#line 566
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                566, "spif_str_prepend");
#line 566
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_STR_ISNULL(other)");
        }
      }
#line 566
      return ((spif_bool_t )0);
    }
#line 566
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 567
  if (other->size) {
#line 567
    if (other->len) {
#line 568
      self->size += other->size - 1L;
#line 569
      if (self->size) {
#line 569
        if (self->s) {
          {
#line 569
          tmp___0 = realloc((void *)self->s, (size_t )self->size);
#line 569
          tmp___2 = tmp___0;
          }
        } else {
          {
#line 569
          tmp___1 = malloc((size_t )self->size);
#line 569
          tmp___2 = tmp___1;
          }
        }
#line 569
        tmp___4 = tmp___2;
      } else {
#line 569
        if (self->s) {
          {
#line 569
          free((void *)self->s);
#line 569
          tmp___3 = (void *)0;
          }
        } else {
#line 569
          tmp___3 = (void *)0;
        }
#line 569
        tmp___4 = tmp___3;
      }
      {
#line 569
      self->s = (spif_charptr_t )tmp___4;
#line 570
      memmove((void *)(self->s + other->len), (void const   *)self->s, (size_t )(self->len + 1L));
      }
#line 571
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 571
        tmp___5 = (spif_charptr_t )"";
      } else {
#line 571
        tmp___5 = other->s;
      }
      {
#line 571
      memcpy((void */* __restrict  */)self->s, (void const   */* __restrict  */)((spif_charptr_t const   )tmp___5),
             (size_t )other->len);
#line 572
      self->len += other->len;
      }
    }
  }
#line 574
  return ((spif_bool_t )1);
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_prepend_char(spif_str_t self , spif_char_t c ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 580
      if (libast_debug_level >= 1U) {
        {
#line 580
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_prepend_char",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           580, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 580
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_prepend_char",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             580, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 580
      return ((spif_bool_t )0);
    }
#line 580
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 581
  (self->len) ++;
#line 582
  if (self->size <= self->len) {
#line 583
    (self->size) ++;
#line 584
    if (self->size) {
#line 584
      if (self->s) {
        {
#line 584
        tmp = realloc((void *)self->s, (size_t )self->size);
#line 584
        tmp___1 = tmp;
        }
      } else {
        {
#line 584
        tmp___0 = malloc((size_t )self->size);
#line 584
        tmp___1 = tmp___0;
        }
      }
#line 584
      tmp___3 = tmp___1;
    } else {
#line 584
      if (self->s) {
        {
#line 584
        free((void *)self->s);
#line 584
        tmp___2 = (void *)0;
        }
      } else {
#line 584
        tmp___2 = (void *)0;
      }
#line 584
      tmp___3 = tmp___2;
    }
#line 584
    self->s = (spif_charptr_t )tmp___3;
  }
  {
#line 586
  memmove((void *)(self->s + 1), (void const   *)self->s, (size_t )(self->len + 1L));
#line 587
  *(self->s + 0) = (spif_char_t )((spif_uchar_t )c);
  }
#line 588
  return ((spif_bool_t )1);
}
}
#line 591 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_prepend_from_ptr(spif_str_t self , spif_charptr_t other ) 
{ 
  spif_stridx_t len ;
  time_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
#line 596
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 596
      if (libast_debug_level >= 1U) {
        {
#line 596
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_prepend_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           596, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 596
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_prepend_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             596, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 596
      return ((spif_bool_t )0);
    }
#line 596
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 597
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 597
    if (! ((unsigned long )other != (unsigned long )((spif_charptr_t )((void *)0)))) {
#line 597
      if (libast_debug_level >= 1U) {
        {
#line 597
        tmp = time((time_t *)((void *)0));
#line 597
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                597, "spif_str_prepend_from_ptr");
#line 597
        libast_dprintf("REQUIRE failed:  %s\n", "(other != SPIF_NULL_TYPE(charptr))");
        }
      }
#line 597
      return ((spif_bool_t )0);
    }
#line 597
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 598
  tmp___0 = strlen((char const   *)other);
#line 598
  len = (spif_stridx_t )tmp___0;
  }
#line 599
  if (len) {
#line 600
    self->size += len;
#line 601
    if (self->size) {
#line 601
      if (self->s) {
        {
#line 601
        tmp___1 = realloc((void *)self->s, (size_t )self->size);
#line 601
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 601
        tmp___2 = malloc((size_t )self->size);
#line 601
        tmp___3 = tmp___2;
        }
      }
#line 601
      tmp___5 = tmp___3;
    } else {
#line 601
      if (self->s) {
        {
#line 601
        free((void *)self->s);
#line 601
        tmp___4 = (void *)0;
        }
      } else {
#line 601
        tmp___4 = (void *)0;
      }
#line 601
      tmp___5 = tmp___4;
    }
    {
#line 601
    self->s = (spif_charptr_t )tmp___5;
#line 602
    memmove((void *)(self->s + len), (void const   *)self->s, (size_t )(self->len + 1L));
#line 603
    memcpy((void */* __restrict  */)self->s, (void const   */* __restrict  */)other,
           (size_t )len);
#line 604
    self->len += len;
    }
  }
#line 606
  return ((spif_bool_t )1);
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_reverse(spif_str_t self ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 612
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 612
      if (libast_debug_level >= 1U) {
        {
#line 612
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_reverse",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           612, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 612
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_reverse",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             612, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 612
      return ((spif_bool_t )0);
    }
#line 612
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  tmp___1 = strrev((char *)self->s);
  }
#line 613
  if (tmp___1) {
#line 613
    tmp___0 = 1;
  } else {
#line 613
    tmp___0 = 0;
  }
#line 613
  return ((spif_bool_t )tmp___0);
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_stridx_t spif_str_rindex(spif_str_t self , spif_char_t c ) 
{ 
  char *tmp ;
  spif_charptr_t tmp___0 ;
  spif_charptr_t tmp___1 ;

  {
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 621
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 621
      if (libast_debug_level >= 1U) {
        {
#line 621
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_rindex",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           621, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 621
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_rindex",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             621, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 621
      return ((spif_stridx_t )-1);
    }
#line 621
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 622
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 622
    tmp___0 = (spif_charptr_t )"";
  } else {
#line 622
    tmp___0 = self->s;
  }
  {
#line 622
  tmp = rindex((char const   *)((spif_charptr_t const   )tmp___0), (int )c);
  }
#line 623
  if (tmp) {
#line 624
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 624
      tmp___1 = (spif_charptr_t )"";
    } else {
#line 624
      tmp___1 = self->s;
    }
#line 624
    return ((spif_long_t )tmp - (spif_long_t )((spif_charptr_t const   )tmp___1));
  } else {
#line 626
    return (self->len);
  }
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_splice(spif_str_t self , spif_stridx_t idx , spif_stridx_t cnt ,
                            spif_str_t other ) 
{ 
  spif_charptr_t tmp ;
  spif_charptr_t ptmp ;
  spif_stridx_t newsize ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  time_t tmp___3 ;
  spif_stridx_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 636
      if (libast_debug_level >= 1U) {
        {
#line 636
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_splice",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           636, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 636
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_splice",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             636, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 636
      return ((spif_bool_t )0);
    }
#line 636
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  if (idx < 0L) {
#line 638
    idx = self->len + idx;
  }
  {
#line 640
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 640
    if (! (idx >= 0L)) {
#line 640
      if (libast_debug_level >= 1U) {
        {
#line 640
        tmp___0 = time((time_t *)((void *)0));
#line 640
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                640, "spif_str_splice");
#line 640
        libast_dprintf("REQUIRE failed:  %s\n", "idx >= 0");
        }
      }
#line 640
      return ((spif_bool_t )0);
    }
#line 640
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 641
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 641
    if (! (idx < self->len)) {
#line 641
      if (libast_debug_level >= 1U) {
        {
#line 641
        tmp___1 = time((time_t *)((void *)0));
#line 641
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                641, "spif_str_splice");
#line 641
        libast_dprintf("REQUIRE failed:  %s\n", "idx < self->len");
        }
      }
#line 641
      return ((spif_bool_t )0);
    }
#line 641
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 642
  if (cnt < 0L) {
#line 643
    cnt = (idx + self->len) + cnt;
  }
  {
#line 645
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 645
    if (! (cnt >= 0L)) {
#line 645
      if (libast_debug_level >= 1U) {
        {
#line 645
        tmp___2 = time((time_t *)((void *)0));
#line 645
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___2, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                645, "spif_str_splice");
#line 645
        libast_dprintf("REQUIRE failed:  %s\n", "cnt >= 0");
        }
      }
#line 645
      return ((spif_bool_t )0);
    }
#line 645
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 646
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 646
    if (! (cnt <= self->len - idx)) {
#line 646
      if (libast_debug_level >= 1U) {
        {
#line 646
        tmp___3 = time((time_t *)((void *)0));
#line 646
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___3, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                646, "spif_str_splice");
#line 646
        libast_dprintf("REQUIRE failed:  %s\n", "cnt <= (self->len - idx)");
        }
      }
#line 646
      return ((spif_bool_t )0);
    }
#line 646
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 648
  if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 648
    tmp___4 = (spif_stridx_t )0;
  } else {
#line 648
    tmp___4 = other->len;
  }
  {
#line 648
  newsize = ((self->len + tmp___4) - cnt) + 1L;
#line 649
  tmp___5 = malloc((size_t )newsize);
#line 649
  tmp = (spif_charptr_t )tmp___5;
#line 649
  ptmp = tmp;
  }
#line 650
  if (idx > 0L) {
    {
#line 651
    memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self->s,
           (size_t )idx);
#line 652
    ptmp += idx;
    }
  }
#line 654
  if (! ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 655
    memcpy((void */* __restrict  */)ptmp, (void const   */* __restrict  */)other->s,
           (size_t )other->len);
#line 656
    ptmp += other->len;
    }
  }
  {
#line 658
  memcpy((void */* __restrict  */)ptmp, (void const   */* __restrict  */)((self->s + idx) + cnt),
         (size_t )(((self->len - idx) - cnt) + 1L));
  }
#line 659
  if (self->size < newsize) {
#line 660
    if (newsize) {
#line 660
      if (self->s) {
        {
#line 660
        tmp___6 = realloc((void *)self->s, (size_t )newsize);
#line 660
        tmp___8 = tmp___6;
        }
      } else {
        {
#line 660
        tmp___7 = malloc((size_t )newsize);
#line 660
        tmp___8 = tmp___7;
        }
      }
#line 660
      tmp___10 = tmp___8;
    } else {
#line 660
      if (self->s) {
        {
#line 660
        free((void *)self->s);
#line 660
        tmp___9 = (void *)0;
        }
      } else {
#line 660
        tmp___9 = (void *)0;
      }
#line 660
      tmp___10 = tmp___9;
    }
#line 660
    self->s = (spif_charptr_t )tmp___10;
#line 661
    self->size = newsize;
  }
  {
#line 663
  self->len = newsize - 1L;
#line 664
  memcpy((void */* __restrict  */)self->s, (void const   */* __restrict  */)tmp, (size_t )newsize);
  }
  {
#line 665
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 665
    free((void *)tmp);
#line 665
    tmp = (spif_charptr_t )((void *)0);
    }
#line 665
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 666
  return ((spif_bool_t )1);
}
}
#line 669 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_splice_from_ptr(spif_str_t self , spif_stridx_t idx , spif_stridx_t cnt ,
                                     spif_charptr_t other ) 
{ 
  spif_charptr_t tmp ;
  spif_charptr_t ptmp ;
  spif_stridx_t len ;
  spif_stridx_t newsize ;
  size_t tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  time_t tmp___3 ;
  time_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 675
      if (libast_debug_level >= 1U) {
        {
#line 675
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_splice_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           675, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 675
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_splice_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             675, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 675
      return ((spif_bool_t )0);
    }
#line 675
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 676
  if (other) {
    {
#line 676
    tmp___0 = strlen((char const   *)other);
#line 676
    len = (spif_stridx_t )tmp___0;
    }
  } else {
#line 676
    len = (spif_stridx_t )0;
  }
#line 677
  if (idx < 0L) {
#line 678
    idx = self->len + idx;
  }
  {
#line 680
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 680
    if (! (idx >= 0L)) {
#line 680
      if (libast_debug_level >= 1U) {
        {
#line 680
        tmp___1 = time((time_t *)((void *)0));
#line 680
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                680, "spif_str_splice_from_ptr");
#line 680
        libast_dprintf("REQUIRE failed:  %s\n", "idx >= 0");
        }
      }
#line 680
      return ((spif_bool_t )0);
    }
#line 680
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 681
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 681
    if (! (idx < self->len)) {
#line 681
      if (libast_debug_level >= 1U) {
        {
#line 681
        tmp___2 = time((time_t *)((void *)0));
#line 681
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___2, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                681, "spif_str_splice_from_ptr");
#line 681
        libast_dprintf("REQUIRE failed:  %s\n", "idx < self->len");
        }
      }
#line 681
      return ((spif_bool_t )0);
    }
#line 681
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 682
  if (cnt < 0L) {
#line 683
    cnt = (idx + self->len) + cnt;
  }
  {
#line 685
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 685
    if (! (cnt >= 0L)) {
#line 685
      if (libast_debug_level >= 1U) {
        {
#line 685
        tmp___3 = time((time_t *)((void *)0));
#line 685
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___3, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                685, "spif_str_splice_from_ptr");
#line 685
        libast_dprintf("REQUIRE failed:  %s\n", "cnt >= 0");
        }
      }
#line 685
      return ((spif_bool_t )0);
    }
#line 685
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 686
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 686
    if (! (cnt <= self->len - idx)) {
#line 686
      if (libast_debug_level >= 1U) {
        {
#line 686
        tmp___4 = time((time_t *)((void *)0));
#line 686
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___4, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                686, "spif_str_splice_from_ptr");
#line 686
        libast_dprintf("REQUIRE failed:  %s\n", "cnt <= (self->len - idx)");
        }
      }
#line 686
      return ((spif_bool_t )0);
    }
#line 686
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 688
  newsize = ((self->len + len) - cnt) + 1L;
#line 689
  tmp___5 = malloc((size_t )newsize);
#line 689
  tmp = (spif_charptr_t )tmp___5;
#line 689
  ptmp = tmp;
  }
#line 690
  if (idx > 0L) {
    {
#line 691
    memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self->s,
           (size_t )idx);
#line 692
    ptmp += idx;
    }
  }
#line 694
  if (len) {
    {
#line 695
    memcpy((void */* __restrict  */)ptmp, (void const   */* __restrict  */)other,
           (size_t )len);
#line 696
    ptmp += len;
    }
  }
  {
#line 698
  memcpy((void */* __restrict  */)ptmp, (void const   */* __restrict  */)((self->s + idx) + cnt),
         (size_t )(((self->len - idx) - cnt) + 1L));
  }
#line 699
  if (self->size < newsize) {
#line 700
    if (newsize) {
#line 700
      if (self->s) {
        {
#line 700
        tmp___6 = realloc((void *)self->s, (size_t )newsize);
#line 700
        tmp___8 = tmp___6;
        }
      } else {
        {
#line 700
        tmp___7 = malloc((size_t )newsize);
#line 700
        tmp___8 = tmp___7;
        }
      }
#line 700
      tmp___10 = tmp___8;
    } else {
#line 700
      if (self->s) {
        {
#line 700
        free((void *)self->s);
#line 700
        tmp___9 = (void *)0;
        }
      } else {
#line 700
        tmp___9 = (void *)0;
      }
#line 700
      tmp___10 = tmp___9;
    }
#line 700
    self->s = (spif_charptr_t )tmp___10;
#line 701
    self->size = newsize;
  }
  {
#line 703
  self->len = newsize - 1L;
#line 704
  memcpy((void */* __restrict  */)self->s, (void const   */* __restrict  */)tmp, (size_t )newsize);
  }
  {
#line 705
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 705
    free((void *)tmp);
#line 705
    tmp = (spif_charptr_t )((void *)0);
    }
#line 705
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 706
  return ((spif_bool_t )1);
}
}
#line 709 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_str_t spif_str_substr(spif_str_t self , spif_stridx_t idx , spif_stridx_t cnt ) 
{ 
  time_t tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  spif_stridx_t o ;
  spif_charptr_t tmp___2 ;
  spif_str_t tmp___3 ;

  {
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 712
      if (libast_debug_level >= 1U) {
        {
#line 712
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_substr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           712, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 712
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_substr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             712, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 712
      return ((spif_str_t )((void *)0));
    }
#line 712
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 713
  if (idx < 0L) {
#line 714
    idx = self->len + idx;
  }
  {
#line 716
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 716
    if (! (idx >= 0L)) {
#line 716
      if (libast_debug_level >= 1U) {
        {
#line 716
        tmp = time((time_t *)((void *)0));
#line 716
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                716, "spif_str_substr");
#line 716
        libast_dprintf("REQUIRE failed:  %s\n", "idx >= 0");
        }
      }
#line 716
      return ((spif_str_t )((void *)0));
    }
#line 716
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 717
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 717
    if (! (idx < self->len)) {
#line 717
      if (libast_debug_level >= 1U) {
        {
#line 717
        tmp___0 = time((time_t *)((void *)0));
#line 717
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                717, "spif_str_substr");
#line 717
        libast_dprintf("REQUIRE failed:  %s\n", "idx < self->len");
        }
      }
#line 717
      return ((spif_str_t )((void *)0));
    }
#line 717
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 718
  if (cnt <= 0L) {
#line 719
    cnt = (self->len - idx) + cnt;
  }
  {
#line 721
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 721
    if (! (cnt >= 0L)) {
#line 721
      if (libast_debug_level >= 1U) {
        {
#line 721
        tmp___1 = time((time_t *)((void *)0));
#line 721
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                721, "spif_str_substr");
#line 721
        libast_dprintf("REQUIRE failed:  %s\n", "cnt >= 0");
        }
      }
#line 721
      return ((spif_str_t )((void *)0));
    }
#line 721
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 722
  o = self->len - idx;
#line 722
  if (cnt > o) {
#line 722
    cnt = o;
  }
#line 723
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 723
    tmp___2 = (spif_charptr_t )"";
  } else {
#line 723
    tmp___2 = self->s;
  }
  {
#line 723
  tmp___3 = spif_str_new_from_buff((spif_charptr_t )((spif_charptr_t const   )tmp___2 + idx),
                                   cnt);
  }
#line 723
  return (tmp___3);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_charptr_t spif_str_substr_to_ptr(spif_str_t self , spif_stridx_t idx , spif_stridx_t cnt ) 
{ 
  spif_charptr_t newstr ;
  time_t tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  spif_stridx_t o ;
  void *tmp___2 ;
  spif_charptr_t tmp___3 ;

  {
  {
#line 731
  while (1) {
    while_continue: /* CIL Label */ ;
#line 731
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 731
      if (libast_debug_level >= 1U) {
        {
#line 731
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_substr_to_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           731, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 731
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_substr_to_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             731, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 731
      return ((spif_charptr_t )((void *)0));
    }
#line 731
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 732
  if (idx < 0L) {
#line 733
    idx = self->len + idx;
  }
  {
#line 735
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 735
    if (! (idx >= 0L)) {
#line 735
      if (libast_debug_level >= 1U) {
        {
#line 735
        tmp = time((time_t *)((void *)0));
#line 735
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                735, "spif_str_substr_to_ptr");
#line 735
        libast_dprintf("REQUIRE failed:  %s\n", "idx >= 0");
        }
      }
#line 735
      return ((spif_charptr_t )((void *)0));
    }
#line 735
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 736
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 736
    if (! (idx < self->len)) {
#line 736
      if (libast_debug_level >= 1U) {
        {
#line 736
        tmp___0 = time((time_t *)((void *)0));
#line 736
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                736, "spif_str_substr_to_ptr");
#line 736
        libast_dprintf("REQUIRE failed:  %s\n", "idx < self->len");
        }
      }
#line 736
      return ((spif_charptr_t )((void *)0));
    }
#line 736
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 737
  if (cnt <= 0L) {
#line 738
    cnt = (self->len - idx) + cnt;
  }
  {
#line 740
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 740
    if (! (cnt >= 0L)) {
#line 740
      if (libast_debug_level >= 1U) {
        {
#line 740
        tmp___1 = time((time_t *)((void *)0));
#line 740
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                740, "spif_str_substr_to_ptr");
#line 740
        libast_dprintf("REQUIRE failed:  %s\n", "cnt >= 0");
        }
      }
#line 740
      return ((spif_charptr_t )((void *)0));
    }
#line 740
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 741
  o = self->len - idx;
#line 741
  if (cnt > o) {
#line 741
    cnt = o;
  }
  {
#line 743
  tmp___2 = malloc((size_t )(cnt + 1L));
#line 743
  newstr = (spif_charptr_t )tmp___2;
  }
#line 744
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 744
    tmp___3 = (spif_charptr_t )"";
  } else {
#line 744
    tmp___3 = self->s;
  }
  {
#line 744
  memcpy((void */* __restrict  */)newstr, (void const   */* __restrict  */)((spif_charptr_t const   )tmp___3 + idx),
         (size_t )cnt);
#line 745
  *(newstr + cnt) = (spif_char_t )0;
  }
#line 746
  return (newstr);
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
double spif_str_to_float(spif_str_t self ) 
{ 
  float tmp ;
  spif_charptr_t tmp___0 ;
  double tmp___1 ;

  {
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 752
      if (libast_debug_level >= 1U) {
        {
#line 752
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_to_float",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           752, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 752
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_to_float",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             752, "!SPIF_STR_ISNULL(self)");
        }
      }
      {
#line 752
      tmp = __builtin_nanf("");
      }
#line 752
      return ((double )tmp);
    }
#line 752
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 753
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 753
    tmp___0 = (spif_charptr_t )"";
  } else {
#line 753
    tmp___0 = self->s;
  }
  {
#line 753
  tmp___1 = strtod((char const   */* __restrict  */)((char const   *)((spif_charptr_t const   )tmp___0)),
                   (char **/* __restrict  */)((char **)((void *)0)));
  }
#line 753
  return (tmp___1);
}
}
#line 756 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
size_t spif_str_to_num(spif_str_t self , int base ) 
{ 
  spif_charptr_t tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 759
  while (1) {
    while_continue: /* CIL Label */ ;
#line 759
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 759
      if (libast_debug_level >= 1U) {
        {
#line 759
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_to_num",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           759, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 759
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_to_num",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             759, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 759
      return ((size_t )-1);
    }
#line 759
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 760
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 760
    tmp = (spif_charptr_t )"";
  } else {
#line 760
    tmp = self->s;
  }
  {
#line 760
  tmp___0 = strtoul((char const   */* __restrict  */)((char const   *)((spif_charptr_t const   )tmp)),
                    (char **/* __restrict  */)((char **)((void *)0)), base);
  }
#line 760
  return (tmp___0);
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_trim(spif_str_t self ) 
{ 
  spif_charptr_t start ;
  spif_charptr_t end ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  spif_bool_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 768
      if (libast_debug_level >= 1U) {
        {
#line 768
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_trim",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           768, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 768
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_trim",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             768, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 768
      return ((spif_bool_t )0);
    }
#line 768
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 769
  start = self->s;
#line 770
  end = (self->s + self->len) - 1;
  {
#line 771
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 771
    tmp = __ctype_b_loc();
    }
#line 771
    if ((int const   )*(*tmp + (int )((spif_uchar_t )*start)) & 8192) {
#line 771
      if (! ((unsigned long )start < (unsigned long )end)) {
#line 771
        goto while_break___0;
      }
    } else {
#line 771
      goto while_break___0;
    }
#line 771
    start ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 772
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 772
    tmp___0 = __ctype_b_loc();
    }
#line 772
    if ((int const   )*(*tmp___0 + (int )((spif_uchar_t )*end)) & 8192) {
#line 772
      if (! ((unsigned long )start < (unsigned long )end)) {
#line 772
        goto while_break___1;
      }
    } else {
#line 772
      goto while_break___1;
    }
#line 772
    end --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 773
  if ((unsigned long )start > (unsigned long )end) {
    {
#line 774
    tmp___1 = spif_str_done(self);
    }
#line 774
    return (tmp___1);
  }
  {
#line 776
  end ++;
#line 776
  *end = (spif_char_t )0;
#line 777
  self->len = end - start;
#line 778
  self->size = self->len + 1L;
#line 779
  memmove((void *)self->s, (void const   *)start, (size_t )self->size);
  }
#line 780
  if (self->size) {
#line 780
    if (self->s) {
      {
#line 780
      tmp___2 = realloc((void *)self->s, (size_t )self->size);
#line 780
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 780
      tmp___3 = malloc((size_t )self->size);
#line 780
      tmp___4 = tmp___3;
      }
    }
#line 780
    tmp___6 = tmp___4;
  } else {
#line 780
    if (self->s) {
      {
#line 780
      free((void *)self->s);
#line 780
      tmp___5 = (void *)0;
      }
    } else {
#line 780
      tmp___5 = (void *)0;
    }
#line 780
    tmp___6 = tmp___5;
  }
#line 780
  self->s = (spif_charptr_t )tmp___6;
#line 781
  return ((spif_bool_t )1);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_upcase(spif_str_t self ) 
{ 
  spif_charptr_t tmp ;
  int tmp___0 ;

  {
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 789
      if (libast_debug_level >= 1U) {
        {
#line 789
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_upcase",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                           789, "!SPIF_STR_ISNULL(self)");
        }
      } else {
        {
#line 789
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_str_upcase",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c",
                             789, "!SPIF_STR_ISNULL(self)");
        }
      }
#line 789
      return ((spif_bool_t )0);
    }
#line 789
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  tmp = self->s;
  {
#line 790
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 790
    if (! *tmp) {
#line 790
      goto while_break___0;
    }
    {
#line 791
    tmp___0 = toupper((int )*tmp);
#line 791
    *tmp = (spif_char_t )tmp___0;
#line 790
    tmp ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 793
  return ((spif_bool_t )1);
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_stridx_t spif_str_get_size(spif_str_t self ) 
{ 


  {
#line 796
  return (self->size);
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_set_size(spif_str_t self , spif_stridx_t new_size ) 
{ 


  {
#line 796
  self->size = new_size;
#line 796
  return ((spif_bool_t )1);
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_stridx_t spif_str_get_len(spif_str_t self ) 
{ 


  {
#line 797
  return (self->len);
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/str.c"
spif_bool_t spif_str_set_len(spif_str_t self , spif_stridx_t new_len ) 
{ 


  {
#line 797
  self->len = new_len;
#line 797
  return ((spif_bool_t )1);
}
}
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 51 "../include/libast/regexp.h"
spif_class_t spif_regexp_class ;
#line 52
spif_regexp_t spif_regexp_new(void) ;
#line 53
spif_regexp_t spif_regexp_new_from_str(spif_str_t other ) ;
#line 54
spif_regexp_t spif_regexp_new_from_ptr(spif_charptr_t other ) ;
#line 55
spif_bool_t spif_regexp_del(spif_regexp_t self ) ;
#line 56
spif_bool_t spif_regexp_init(spif_regexp_t self ) ;
#line 57
spif_bool_t spif_regexp_init_from_str(spif_regexp_t self , spif_str_t other ) ;
#line 58
spif_bool_t spif_regexp_init_from_ptr(spif_regexp_t self , spif_charptr_t other ) ;
#line 59
spif_bool_t spif_regexp_done(spif_regexp_t self ) ;
#line 60
spif_regexp_t spif_regexp_dup(spif_regexp_t self ) ;
#line 61
spif_cmp_t spif_regexp_comp(spif_regexp_t self , spif_regexp_t other ) ;
#line 62
spif_str_t spif_regexp_show(spif_regexp_t self , spif_charptr_t name___0 , spif_str_t buff ,
                            size_t indent ) ;
#line 63
spif_classname_t spif_regexp_type(spif_regexp_t self ) ;
#line 64
spif_bool_t spif_regexp_compile(spif_regexp_t self ) ;
#line 65
spif_bool_t spif_regexp_matches_str(spif_regexp_t self , spif_str_t subject ) ;
#line 66
spif_bool_t spif_regexp_matches_ptr(spif_regexp_t self , spif_charptr_t subject ) ;
#line 67
int spif_regexp_get_flags(spif_regexp_t self ) ;
#line 68
spif_bool_t spif_regexp_set_flags(spif_regexp_t self , spif_charptr_t flagstr ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
static spif_const_class_t r_class  = 
#line 33 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
     {(spif_charptr_t )"!spif_regexp_t!", (void *(*)())(& spif_regexp_new), (void *(*)())(& spif_regexp_init),
    (void *(*)())(& spif_regexp_done), (void *(*)())(& spif_regexp_del), (void *(*)())(& spif_regexp_show),
    (void *(*)())(& spif_regexp_comp), (void *(*)())(& spif_regexp_dup), (void *(*)())(& spif_regexp_type)};
#line 44 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_class_t spif_regexp_class  =    & r_class;
#line 47 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_regexp_t spif_regexp_new(void) 
{ 
  spif_regexp_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 52
  tmp = malloc(sizeof(spif_const_regexp_t ));
#line 52
  self = (spif_regexp_t )tmp;
#line 53
  tmp___0 = spif_regexp_init(self);
  }
#line 53
  if (! tmp___0) {
    {
#line 54
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 54
      free((void *)self);
#line 54
      self = (spif_regexp_t )((void *)0);
      }
#line 54
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 55
    self = (spif_regexp_t )((void *)0);
  }
#line 57
  return (self);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_regexp_t spif_regexp_new_from_str(spif_str_t other ) 
{ 
  spif_regexp_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 65
  tmp = malloc(sizeof(spif_const_regexp_t ));
#line 65
  self = (spif_regexp_t )tmp;
#line 66
  tmp___0 = spif_regexp_init_from_str(self, other);
  }
#line 66
  if (! tmp___0) {
    {
#line 67
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 67
      free((void *)self);
#line 67
      self = (spif_regexp_t )((void *)0);
      }
#line 67
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 68
    self = (spif_regexp_t )((void *)0);
  }
#line 70
  return (self);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_regexp_t spif_regexp_new_from_ptr(spif_charptr_t other ) 
{ 
  spif_regexp_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 78
  tmp = malloc(sizeof(spif_const_regexp_t ));
#line 78
  self = (spif_regexp_t )tmp;
#line 79
  tmp___0 = spif_regexp_init_from_ptr(self, other);
  }
#line 79
  if (! tmp___0) {
    {
#line 80
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 80
      free((void *)self);
#line 80
      self = (spif_regexp_t )((void *)0);
      }
#line 80
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 81
    self = (spif_regexp_t )((void *)0);
  }
#line 83
  return (self);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_bool_t spif_regexp_init(spif_regexp_t self ) 
{ 
  spif_bool_t tmp ;

  {
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 89
      if (libast_debug_level >= 1U) {
        {
#line 89
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           89, "!SPIF_REGEXP_ISNULL(self)");
        }
      } else {
        {
#line 89
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                             89, "!SPIF_REGEXP_ISNULL(self)");
        }
      }
#line 89
      return ((spif_bool_t )0);
    }
#line 89
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  tmp = spif_str_init((spif_str_t )self);
  }
#line 90
  if (! tmp) {
#line 91
    return ((spif_bool_t )0);
  }
  {
#line 93
  spif_obj_set_class((spif_obj_t )self, spif_regexp_class);
#line 94
  self->data = (void *)0;
#line 95
  spif_regexp_set_flags(self, (spif_charptr_t )((void *)0));
  }
#line 96
  return ((spif_bool_t )1);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_bool_t spif_regexp_init_from_str(spif_regexp_t self , spif_str_t other ) 
{ 
  spif_charptr_t tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 102
      if (libast_debug_level >= 1U) {
        {
#line 102
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_init_from_str",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           102, "!SPIF_REGEXP_ISNULL(self)");
        }
      } else {
        {
#line 102
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_init_from_str",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                             102, "!SPIF_REGEXP_ISNULL(self)");
        }
      }
#line 102
      return ((spif_bool_t )0);
    }
#line 102
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 103
    tmp = (spif_charptr_t )"";
  } else {
#line 103
    tmp = other->s;
  }
  {
#line 103
  tmp___0 = spif_str_init_from_ptr((spif_str_t )self, (spif_charptr_t )((spif_charptr_t const   )tmp));
  }
#line 103
  if (! tmp___0) {
#line 104
    return ((spif_bool_t )0);
  }
  {
#line 106
  spif_obj_set_class((spif_obj_t )self, spif_regexp_class);
#line 107
  self->data = (void *)0;
#line 108
  spif_regexp_set_flags(self, (spif_charptr_t )"");
  }
#line 109
  return ((spif_bool_t )1);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_bool_t spif_regexp_init_from_ptr(spif_regexp_t self , spif_charptr_t other ) 
{ 
  spif_bool_t tmp ;

  {
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 115
      if (libast_debug_level >= 1U) {
        {
#line 115
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_init_from_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           115, "!SPIF_REGEXP_ISNULL(self)");
        }
      } else {
        {
#line 115
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_init_from_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                             115, "!SPIF_REGEXP_ISNULL(self)");
        }
      }
#line 115
      return ((spif_bool_t )0);
    }
#line 115
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  tmp = spif_str_init_from_ptr((spif_str_t )self, other);
  }
#line 116
  if (! tmp) {
#line 117
    return ((spif_bool_t )0);
  }
  {
#line 119
  spif_obj_set_class((spif_obj_t )self, spif_regexp_class);
#line 120
  self->data = (void *)0;
#line 121
  spif_regexp_set_flags(self, (spif_charptr_t )"");
  }
#line 122
  return ((spif_bool_t )1);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_bool_t spif_regexp_done(spif_regexp_t self ) 
{ 


  {
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 128
      if (libast_debug_level >= 1U) {
        {
#line 128
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           128, "!SPIF_REGEXP_ISNULL(self)");
        }
      } else {
        {
#line 128
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                             128, "!SPIF_REGEXP_ISNULL(self)");
        }
      }
#line 128
      return ((spif_bool_t )0);
    }
#line 128
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 129
  spif_str_done((spif_str_t )self);
  }
#line 130
  if ((unsigned long )self->data != (unsigned long )((void *)0)) {
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 131
      free(self->data);
#line 131
      self->data = (void *)0;
      }
#line 131
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 133
  self->flags = 0;
#line 134
  return ((spif_bool_t )1);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_bool_t spif_regexp_del(spif_regexp_t self ) 
{ 


  {
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 140
      if (libast_debug_level >= 1U) {
        {
#line 140
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           140, "!SPIF_REGEXP_ISNULL(self)");
        }
      } else {
        {
#line 140
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                             140, "!SPIF_REGEXP_ISNULL(self)");
        }
      }
#line 140
      return ((spif_bool_t )0);
    }
#line 140
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  spif_regexp_done(self);
  }
  {
#line 142
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 142
    free((void *)self);
#line 142
    self = (spif_regexp_t )((void *)0);
    }
#line 142
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 143
  return ((spif_bool_t )1);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_str_t spif_regexp_show(spif_regexp_t self , spif_charptr_t name___0 , spif_str_t buff ,
                            size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  char *tmp___0 ;

  {
#line 151
  if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 152
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 152
      memset((void *)(tmp), ' ', indent);
      }
#line 152
      if ((char *)name___0) {
#line 152
        tmp___0 = (char *)name___0;
      } else {
#line 152
        tmp___0 = (char *)"<name null>";
      }
      {
#line 152
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_regexp_t) %s:  { ((spif_regexp_t) NULL) }\n",
               tmp___0);
      }
#line 152
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 152
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 152
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 152
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 153
    return (buff);
  }
  {
#line 156
  memset((void *)(tmp), ' ', indent);
#line 157
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_regexp_t) %s:  %10p {\n", name___0,
           (spif_ptr_t )self);
  }
#line 160
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 161
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 163
    spif_str_append_from_ptr(buff, tmp);
    }
  }
  {
#line 166
  snprintf((char */* __restrict  */)((char *)(tmp)), sizeof(tmp), (char const   */* __restrict  */)"}\n");
#line 167
  spif_str_append_from_ptr(buff, tmp);
  }
#line 168
  return (buff);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_cmp_t spif_regexp_comp(spif_regexp_t self , spif_regexp_t other ) 
{ 
  spif_cmp_t tmp ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 174
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 174
        return ((spif_cmp_t )0);
      } else {
#line 174
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 174
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 174
      return ((spif_cmp_t )-1);
    } else
#line 174
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 174
      return ((spif_cmp_t )1);
    }
#line 174
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 175
  tmp = spif_str_comp((spif_str_t )self, (spif_str_t )other);
  }
#line 175
  return (tmp);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_regexp_t spif_regexp_dup(spif_regexp_t self ) 
{ 
  spif_regexp_t tmp ;

  {
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 183
      if (libast_debug_level >= 1U) {
        {
#line 183
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           183, "!SPIF_REGEXP_ISNULL(self)");
        }
      } else {
        {
#line 183
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                             183, "!SPIF_REGEXP_ISNULL(self)");
        }
      }
#line 183
      return ((spif_regexp_t )((void *)0));
    }
#line 183
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  tmp = spif_regexp_new_from_str((spif_str_t )self);
#line 186
  tmp->flags = self->flags;
#line 187
  spif_regexp_compile(tmp);
  }
#line 188
  return (tmp);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_classname_t spif_regexp_type(spif_regexp_t self ) 
{ 


  {
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 194
      if (libast_debug_level >= 1U) {
        {
#line 194
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           194, "!SPIF_REGEXP_ISNULL(self)");
        }
      } else {
        {
#line 194
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                             194, "!SPIF_REGEXP_ISNULL(self)");
        }
      }
#line 194
      return ((spif_classname_t )((void *)0));
    }
#line 194
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_bool_t spif_regexp_compile(spif_regexp_t self ) 
{ 
  char buff[256] ;
  int errcode ;
  void *tmp ;
  spif_charptr_t tmp___0 ;
  spif_charptr_t tmp___1 ;

  {
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 201
      if (libast_debug_level >= 1U) {
        {
#line 201
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_compile",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           201, "!SPIF_REGEXP_ISNULL(self)");
        }
      } else {
        {
#line 201
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_compile",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                             201, "!SPIF_REGEXP_ISNULL(self)");
        }
      }
#line 201
      return ((spif_bool_t )0);
    }
#line 201
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  if ((unsigned long )self->data != (unsigned long )((void *)0)) {
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 203
      free(self->data);
#line 203
      self->data = (void *)0;
      }
#line 203
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 224
  tmp = malloc(sizeof(regex_t ));
#line 224
  self->data = tmp;
  }
#line 225
  if ((unsigned long )((spif_obj_t )((spif_str_t )self)) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 225
    tmp___1 = (spif_charptr_t )"";
  } else {
#line 225
    tmp___1 = ((spif_str_t )self)->s;
  }
  {
#line 225
  errcode = regcomp((regex_t */* __restrict  */)((regex_t *)self->data), (char const   */* __restrict  */)((spif_charptr_t const   )tmp___1),
                    self->flags & 65535);
  }
#line 225
  if (errcode != 0) {
    {
#line 226
    regerror(errcode, (regex_t const   */* __restrict  */)((regex_t *)self->data),
             (char */* __restrict  */)(buff), sizeof(buff));
    }
#line 227
    if ((unsigned long )((spif_obj_t )((spif_str_t )self)) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 227
      tmp___0 = (spif_charptr_t )"";
    } else {
#line 227
      tmp___0 = ((spif_str_t )self)->s;
    }
    {
#line 227
    libast_print_error("POSIX regexp compilation of \"%s\" failed -- %s\n", (spif_charptr_t const   )tmp___0,
                       buff);
    }
    {
#line 228
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 228
      free(self->data);
#line 228
      self->data = (void *)0;
      }
#line 228
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 229
    return ((spif_bool_t )0);
  }
#line 231
  return ((spif_bool_t )1);
  {
#line 236
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 236
    if (libast_debug_level >= 1U) {
      {
#line 236
      libast_fatal_error("ASSERT failed in %s() at %s:%d:  This code should not be reached.\n",
                         "spif_regexp_compile", "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                         236);
      }
    } else {
      {
#line 236
      libast_print_warning("ASSERT failed in %s() at %s:%d:  This code should not be reached.\n",
                           "spif_regexp_compile", "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           236);
      }
    }
#line 236
    return ((spif_bool_t )0);
#line 236
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_bool_t spif_regexp_matches_str(spif_regexp_t self , spif_str_t subject ) 
{ 
  time_t tmp ;
  int rc ;
  char errbuf[256] ;
  spif_charptr_t tmp___0 ;
  spif_charptr_t tmp___1 ;

  {
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 242
      if (libast_debug_level >= 1U) {
        {
#line 242
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_matches_str",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           242, "!SPIF_REGEXP_ISNULL(self)");
        }
      } else {
        {
#line 242
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_matches_str",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                             242, "!SPIF_REGEXP_ISNULL(self)");
        }
      }
#line 242
      return ((spif_bool_t )0);
    }
#line 242
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 243
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 243
    if (! (! ((unsigned long )((spif_obj_t )subject) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 243
      if (libast_debug_level >= 1U) {
        {
#line 243
        tmp = time((time_t *)((void *)0));
#line 243
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                243, "spif_regexp_matches_str");
#line 243
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_STR_ISNULL(subject)");
        }
      }
#line 243
      return ((spif_bool_t )0);
    }
#line 243
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 264
  if ((unsigned long )((spif_obj_t )subject) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 264
    tmp___0 = (spif_charptr_t )"";
  } else {
#line 264
    tmp___0 = subject->s;
  }
  {
#line 264
  rc = regexec((regex_t const   */* __restrict  */)((regex_t *)self->data), (char const   */* __restrict  */)((spif_charptr_t const   )tmp___0),
               (size_t )0, (regmatch_t */* __restrict  */)((regmatch_t *)((void *)0)),
               (self->flags >> 8) & 65535);
  }
#line 266
  if (rc == 0) {
#line 267
    return ((spif_bool_t )1);
  } else
#line 268
  if (rc == 1) {
#line 269
    return ((spif_bool_t )0);
  } else {
    {
#line 271
    regerror(rc, (regex_t const   */* __restrict  */)((regex_t *)self->data), (char */* __restrict  */)(errbuf),
             sizeof(errbuf));
    }
#line 272
    if ((unsigned long )((spif_obj_t )subject) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 272
      tmp___1 = (spif_charptr_t )"";
    } else {
#line 272
      tmp___1 = subject->s;
    }
    {
#line 272
    libast_print_error("POSIX regexp matching error on \"%s\" -- %s\n", (spif_charptr_t const   )tmp___1,
                       errbuf);
    }
#line 273
    return ((spif_bool_t )0);
  }
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_bool_t spif_regexp_matches_ptr(spif_regexp_t self , spif_charptr_t subject ) 
{ 
  time_t tmp ;
  int tmp___0 ;
  int rc ;
  char errbuf[256] ;

  {
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 293
      if (libast_debug_level >= 1U) {
        {
#line 293
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_matches_ptr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           293, "!SPIF_REGEXP_ISNULL(self)");
        }
      } else {
        {
#line 293
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_matches_ptr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                             293, "!SPIF_REGEXP_ISNULL(self)");
        }
      }
#line 293
      return ((spif_bool_t )0);
    }
#line 293
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 294
    if ((unsigned long )((spif_ptr_t )subject) == (unsigned long )((void *)0)) {
#line 294
      tmp___0 = 1;
    } else {
#line 294
      tmp___0 = 0;
    }
#line 294
    if (tmp___0) {
#line 294
      if (libast_debug_level >= 1U) {
        {
#line 294
        tmp = time((time_t *)((void *)0));
#line 294
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                294, "spif_regexp_matches_ptr");
#line 294
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_PTR_ISNULL(subject)");
        }
      }
#line 294
      return ((spif_bool_t )0);
    }
#line 294
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 315
  rc = regexec((regex_t const   */* __restrict  */)((regex_t *)self->data), (char const   */* __restrict  */)subject,
               (size_t )0, (regmatch_t */* __restrict  */)((regmatch_t *)((void *)0)),
               (self->flags >> 8) & 65535);
  }
#line 317
  if (rc == 0) {
#line 318
    return ((spif_bool_t )1);
  } else
#line 319
  if (rc == 1) {
#line 320
    return ((spif_bool_t )0);
  } else {
    {
#line 322
    regerror(rc, (regex_t const   */* __restrict  */)((regex_t *)self->data), (char */* __restrict  */)(errbuf),
             sizeof(errbuf));
#line 323
    libast_print_error("POSIX regexp matching error on \"%s\" -- %s\n", subject, errbuf);
    }
#line 324
    return ((spif_bool_t )0);
  }
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
int spif_regexp_get_flags(spif_regexp_t self ) 
{ 


  {
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 344
      if (libast_debug_level >= 1U) {
        {
#line 344
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_get_flags",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           344, "!SPIF_REGEXP_ISNULL(self)");
        }
      } else {
        {
#line 344
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_get_flags",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                             344, "!SPIF_REGEXP_ISNULL(self)");
        }
      }
#line 344
      return (0);
    }
#line 344
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  return (self->flags);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c"
spif_bool_t spif_regexp_set_flags(spif_regexp_t self , spif_charptr_t flagstr ) 
{ 
  spif_charptr_t p ;
  time_t tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! (! ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 353
      if (libast_debug_level >= 1U) {
        {
#line 353
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_set_flags",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                           353, "!SPIF_REGEXP_ISNULL(self)");
        }
      } else {
        {
#line 353
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_regexp_set_flags",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                             353, "!SPIF_REGEXP_ISNULL(self)");
        }
      }
#line 353
      return ((spif_bool_t )0);
    }
#line 353
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  self->flags = 1 | ((1 << 1) << 1);
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (! ((unsigned long )flagstr != (unsigned long )((spif_charptr_t )((void *)0)))) {
#line 360
      if (libast_debug_level >= 1U) {
        {
#line 360
        tmp = time((time_t *)((void *)0));
#line 360
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/regexp.c",
                360, "spif_regexp_set_flags");
#line 360
        libast_dprintf("REQUIRE failed:  %s\n", "flagstr != SPIF_NULL_TYPE(charptr)");
        }
      }
#line 360
      return ((spif_bool_t )0);
    }
#line 360
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 361
  p = flagstr;
  {
#line 361
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 361
    if (! *p) {
#line 361
      goto while_break___1;
    }
    {
#line 374
    if ((int )*p == 98) {
#line 374
      goto case_98;
    }
#line 375
    if ((int )*p == 105) {
#line 375
      goto case_105;
    }
#line 376
    if ((int )*p == 110) {
#line 376
      goto case_110;
    }
#line 377
    if ((int )*p == 115) {
#line 377
      goto case_115;
    }
#line 378
    if ((int )*p == 94) {
#line 378
      goto case_94;
    }
#line 379
    if ((int )*p == 36) {
#line 379
      goto case_36;
    }
#line 381
    goto switch_default;
    case_98: /* CIL Label */ 
#line 374
    self->flags &= -2;
#line 374
    goto switch_break;
    case_105: /* CIL Label */ 
#line 375
    self->flags |= 1 << 1;
#line 375
    goto switch_break;
    case_110: /* CIL Label */ 
#line 376
    self->flags |= ((1 << 1) << 1) << 1;
#line 376
    goto switch_break;
    case_115: /* CIL Label */ 
#line 377
    self->flags &= ~ ((1 << 1) << 1);
#line 377
    goto switch_break;
    case_94: /* CIL Label */ 
#line 378
    self->flags |= 1 << 8;
#line 378
    goto switch_break;
    case_36: /* CIL Label */ 
#line 379
    self->flags |= (1 << 1) << 8;
#line 379
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 382
    libast_print_warning("Unrecognized regexp flag character \'%c\'\n", (int )*p);
    }
#line 383
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 361
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 386
  tmp___0 = spif_regexp_compile(self);
  }
#line 386
  return (tmp___0);
}
}
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 717
extern int system(char const   *__command ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 1657 "../include/libast.h"
fstate_t *fstate ;
#line 1658
unsigned char fstate_idx ;
#line 2736
spif_charptr_t spiftool_chomp(spif_charptr_t s ) ;
#line 2740
spif_charptr_t spiftool_condense_whitespace(spif_charptr_t s ) ;
#line 2742
spif_cmp_t spiftool_version_compare(spif_charptr_t v1 , spif_charptr_t v2 ) ;
#line 2785
void spifconf_init_subsystem(void) ;
#line 2786
unsigned char spifconf_register_context(spif_charptr_t name___0 , spif_ptr_t (*handler)(spif_charptr_t  ,
                                                                                        spif_ptr_t  ) ) ;
#line 2787
unsigned char spifconf_register_fstate(FILE *fp , spif_charptr_t path , spif_charptr_t outfile ,
                                       unsigned long line , unsigned char flags ) ;
#line 2788
unsigned char spifconf_register_builtin(char *name___0 , spif_charptr_t (*ptr)(spif_charptr_t  ) ) ;
#line 2789
unsigned char spifconf_register_context_state(unsigned char ctx_id ) ;
#line 2790
void spifconf_free_subsystem(void) ;
#line 2791
spif_charptr_t spifconf_shell_expand(spif_charptr_t s ) ;
#line 2792
spif_charptr_t spifconf_find_file(spif_charptr_t const   file , spif_charptr_t const   dir ,
                                  spif_charptr_t const   pathlist ) ;
#line 2793
FILE *spifconf_open_file(spif_charptr_t name___0 ) ;
#line 2794
void spifconf_parse_line(FILE *fp , spif_charptr_t buff ) ;
#line 2795
spif_charptr_t spifconf_parse(spif_charptr_t conf_name , spif_charptr_t const   dir ,
                              spif_charptr_t const   path ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spifconf_var_t *spifconf_new_var(void) ;
#line 43
static void spifconf_free_var(spifconf_var_t *v ) ;
#line 44
static spif_charptr_t spifconf_get_var(spif_charptr_t const   var ) ;
#line 45
static void spifconf_put_var(spif_charptr_t var , spif_charptr_t val ) ;
#line 46
static spif_charptr_t builtin_random(spif_charptr_t param ) ;
#line 47
static spif_charptr_t builtin_exec(spif_charptr_t param ) ;
#line 48
static spif_charptr_t builtin_get(spif_charptr_t param ) ;
#line 49
static spif_charptr_t builtin_put(spif_charptr_t param ) ;
#line 50
static spif_charptr_t builtin_dirscan(spif_charptr_t param ) ;
#line 51
static spif_charptr_t builtin_version(spif_charptr_t param ) ;
#line 52
static spif_charptr_t builtin_appname(spif_charptr_t param ) ;
#line 53
static void *parse_null(spif_charptr_t buff , void *state ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static ctx_t *context  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static ctx_state_t *ctx_state  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spifconf_func_t *builtins  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static unsigned char ctx_cnt  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static unsigned char ctx_idx  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static unsigned char ctx_state_idx  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static unsigned char ctx_state_cnt  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static unsigned char fstate_cnt  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static unsigned char builtin_cnt  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static unsigned char builtin_idx  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spifconf_var_t *spifconf_vars  =    (spifconf_var_t *)((void *)0);
#line 61 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
char const   *true_vals[4]  = {      "1",      "on",      "true",      "yes"};
#line 62 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
char const   *false_vals[4]  = {      "0",      "off",      "false",      "no"};
#line 64 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
fstate_t *fstate  =    (fstate_t *)((void *)0);
#line 65 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
unsigned char fstate_idx  =    (unsigned char)0;
#line 70 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
void spifconf_init_subsystem(void) 
{ 
  void *tmp ;
  char *end ;
  long l ;
  long *l_dest ;
  char *c_dest ;
  char *tmp___0 ;
  long *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *end___0 ;
  long l___0 ;
  long *l_dest___0 ;
  char *c_dest___0 ;
  char *tmp___6 ;
  long *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  char *end___1 ;
  long l___1 ;
  long *l_dest___1 ;
  char *c_dest___1 ;
  char *tmp___11 ;
  long *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  void *tmp___15 ;
  char *end___2 ;
  long l___2 ;
  long *l_dest___2 ;
  char *c_dest___2 ;
  char *tmp___16 ;
  long *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
  {
#line 74
  ctx_cnt = (unsigned char)20;
#line 75
  ctx_idx = (unsigned char)0;
#line 76
  tmp = malloc(sizeof(ctx_t ) * (unsigned long )ctx_cnt);
#line 76
  context = (ctx_t *)tmp;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    end = (char *)context + sizeof(ctx_t ) * (unsigned long )ctx_cnt;
#line 77
    l_dest = (long *)context;
#line 77
    if (! context) {
#line 77
      goto while_break;
    }
#line 77
    if (sizeof(ctx_t ) * (unsigned long )ctx_cnt >= 4UL * sizeof(long )) {
#line 77
      l = 0L;
#line 77
      l |= l << 16;
#line 77
      l |= l << 32;
#line 77
      if ((unsigned long )l_dest & (sizeof(long ) - 1UL)) {
#line 77
        c_dest = (char *)l_dest;
        {
#line 77
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 77
          if (! ((unsigned long )c_dest & (sizeof(long ) - 1UL))) {
#line 77
            goto while_break___0;
          }
#line 77
          tmp___0 = c_dest;
#line 77
          c_dest ++;
#line 77
          *tmp___0 = (char)0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 77
        l_dest = (long *)c_dest;
      }
      {
#line 77
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 77
        if (! ((unsigned long )(end - (char *)l_dest) >= sizeof(long ))) {
#line 77
          goto while_break___1;
        }
#line 77
        tmp___1 = l_dest;
#line 77
        l_dest ++;
#line 77
        *tmp___1 = l;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 77
    if ((unsigned long )((char *)l_dest) < (unsigned long )end) {
#line 77
      c_dest = (char *)l_dest;
#line 77
      tmp___2 = c_dest;
#line 77
      c_dest ++;
#line 77
      *tmp___2 = (char)0;
      {
#line 77
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 77
        if (! ((unsigned long )c_dest < (unsigned long )end)) {
#line 77
          goto while_break___2;
        }
#line 77
        tmp___3 = c_dest;
#line 77
        c_dest ++;
#line 77
        *tmp___3 = (char)0;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 77
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  tmp___4 = strdup((char const   *)((char *)"null"));
#line 78
  (context + 0)->name = (spif_charptr_t )tmp___4;
#line 79
  (context + 0)->handler = & parse_null;
#line 82
  ctx_state_cnt = (unsigned char)20;
#line 83
  ctx_state_idx = (unsigned char)0;
#line 84
  tmp___5 = malloc(sizeof(ctx_state_t ) * (unsigned long )ctx_state_cnt);
#line 84
  ctx_state = (ctx_state_t *)tmp___5;
  }
  {
#line 85
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 85
    end___0 = (char *)ctx_state + sizeof(ctx_state_t ) * (unsigned long )ctx_state_cnt;
#line 85
    l_dest___0 = (long *)ctx_state;
#line 85
    if (! ctx_state) {
#line 85
      goto while_break___3;
    }
#line 85
    if (sizeof(ctx_state_t ) * (unsigned long )ctx_state_cnt >= 4UL * sizeof(long )) {
#line 85
      l___0 = 0L;
#line 85
      l___0 |= l___0 << 16;
#line 85
      l___0 |= l___0 << 32;
#line 85
      if ((unsigned long )l_dest___0 & (sizeof(long ) - 1UL)) {
#line 85
        c_dest___0 = (char *)l_dest___0;
        {
#line 85
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 85
          if (! ((unsigned long )c_dest___0 & (sizeof(long ) - 1UL))) {
#line 85
            goto while_break___4;
          }
#line 85
          tmp___6 = c_dest___0;
#line 85
          c_dest___0 ++;
#line 85
          *tmp___6 = (char)0;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 85
        l_dest___0 = (long *)c_dest___0;
      }
      {
#line 85
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 85
        if (! ((unsigned long )(end___0 - (char *)l_dest___0) >= sizeof(long ))) {
#line 85
          goto while_break___5;
        }
#line 85
        tmp___7 = l_dest___0;
#line 85
        l_dest___0 ++;
#line 85
        *tmp___7 = l___0;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 85
    if ((unsigned long )((char *)l_dest___0) < (unsigned long )end___0) {
#line 85
      c_dest___0 = (char *)l_dest___0;
#line 85
      tmp___8 = c_dest___0;
#line 85
      c_dest___0 ++;
#line 85
      *tmp___8 = (char)0;
      {
#line 85
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 85
        if (! ((unsigned long )c_dest___0 < (unsigned long )end___0)) {
#line 85
          goto while_break___6;
        }
#line 85
        tmp___9 = c_dest___0;
#line 85
        c_dest___0 ++;
#line 85
        *tmp___9 = (char)0;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 85
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 88
  fstate_cnt = (unsigned char)10;
#line 89
  fstate_idx = (unsigned char)0;
#line 90
  tmp___10 = malloc(sizeof(fstate_t ) * (unsigned long )fstate_cnt);
#line 90
  fstate = (fstate_t *)tmp___10;
  }
  {
#line 91
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 91
    end___1 = (char *)fstate + sizeof(fstate_t ) * (unsigned long )fstate_cnt;
#line 91
    l_dest___1 = (long *)fstate;
#line 91
    if (! fstate) {
#line 91
      goto while_break___7;
    }
#line 91
    if (sizeof(fstate_t ) * (unsigned long )fstate_cnt >= 4UL * sizeof(long )) {
#line 91
      l___1 = 0L;
#line 91
      l___1 |= l___1 << 16;
#line 91
      l___1 |= l___1 << 32;
#line 91
      if ((unsigned long )l_dest___1 & (sizeof(long ) - 1UL)) {
#line 91
        c_dest___1 = (char *)l_dest___1;
        {
#line 91
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 91
          if (! ((unsigned long )c_dest___1 & (sizeof(long ) - 1UL))) {
#line 91
            goto while_break___8;
          }
#line 91
          tmp___11 = c_dest___1;
#line 91
          c_dest___1 ++;
#line 91
          *tmp___11 = (char)0;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 91
        l_dest___1 = (long *)c_dest___1;
      }
      {
#line 91
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 91
        if (! ((unsigned long )(end___1 - (char *)l_dest___1) >= sizeof(long ))) {
#line 91
          goto while_break___9;
        }
#line 91
        tmp___12 = l_dest___1;
#line 91
        l_dest___1 ++;
#line 91
        *tmp___12 = l___1;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 91
    if ((unsigned long )((char *)l_dest___1) < (unsigned long )end___1) {
#line 91
      c_dest___1 = (char *)l_dest___1;
#line 91
      tmp___13 = c_dest___1;
#line 91
      c_dest___1 ++;
#line 91
      *tmp___13 = (char)0;
      {
#line 91
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 91
        if (! ((unsigned long )c_dest___1 < (unsigned long )end___1)) {
#line 91
          goto while_break___10;
        }
#line 91
        tmp___14 = c_dest___1;
#line 91
        c_dest___1 ++;
#line 91
        *tmp___14 = (char)0;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 91
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 94
  builtin_cnt = (unsigned char)10;
#line 95
  builtin_idx = (unsigned char)0;
#line 96
  tmp___15 = malloc(sizeof(spifconf_func_t ) * (unsigned long )builtin_cnt);
#line 96
  builtins = (spifconf_func_t *)tmp___15;
  }
  {
#line 97
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 97
    end___2 = (char *)builtins + sizeof(spifconf_func_t ) * (unsigned long )builtin_cnt;
#line 97
    l_dest___2 = (long *)builtins;
#line 97
    if (! builtins) {
#line 97
      goto while_break___11;
    }
#line 97
    if (sizeof(spifconf_func_t ) * (unsigned long )builtin_cnt >= 4UL * sizeof(long )) {
#line 97
      l___2 = 0L;
#line 97
      l___2 |= l___2 << 16;
#line 97
      l___2 |= l___2 << 32;
#line 97
      if ((unsigned long )l_dest___2 & (sizeof(long ) - 1UL)) {
#line 97
        c_dest___2 = (char *)l_dest___2;
        {
#line 97
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 97
          if (! ((unsigned long )c_dest___2 & (sizeof(long ) - 1UL))) {
#line 97
            goto while_break___12;
          }
#line 97
          tmp___16 = c_dest___2;
#line 97
          c_dest___2 ++;
#line 97
          *tmp___16 = (char)0;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 97
        l_dest___2 = (long *)c_dest___2;
      }
      {
#line 97
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 97
        if (! ((unsigned long )(end___2 - (char *)l_dest___2) >= sizeof(long ))) {
#line 97
          goto while_break___13;
        }
#line 97
        tmp___17 = l_dest___2;
#line 97
        l_dest___2 ++;
#line 97
        *tmp___17 = l___2;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 97
    if ((unsigned long )((char *)l_dest___2) < (unsigned long )end___2) {
#line 97
      c_dest___2 = (char *)l_dest___2;
#line 97
      tmp___18 = c_dest___2;
#line 97
      c_dest___2 ++;
#line 97
      *tmp___18 = (char)0;
      {
#line 97
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 97
        if (! ((unsigned long )c_dest___2 < (unsigned long )end___2)) {
#line 97
          goto while_break___14;
        }
#line 97
        tmp___19 = c_dest___2;
#line 97
        c_dest___2 ++;
#line 97
        *tmp___19 = (char)0;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 97
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 100
  spifconf_register_builtin((char *)"appname", & builtin_appname);
#line 101
  spifconf_register_builtin((char *)"version", & builtin_version);
#line 102
  spifconf_register_builtin((char *)"exec", & builtin_exec);
#line 103
  spifconf_register_builtin((char *)"random", & builtin_random);
#line 104
  spifconf_register_builtin((char *)"get", & builtin_get);
#line 105
  spifconf_register_builtin((char *)"put", & builtin_put);
#line 106
  spifconf_register_builtin((char *)"dirscan", & builtin_dirscan);
  }
#line 107
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
unsigned char spifconf_register_context(spif_charptr_t name___0 , spif_ptr_t (*handler)(spif_charptr_t  ,
                                                                                        spif_ptr_t  ) ) 
{ 
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  time_t tmp___8 ;

  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if ((unsigned long )((spif_ptr_t )name___0) == (unsigned long )((void *)0)) {
#line 113
      tmp = 1;
    } else {
#line 113
      tmp = 0;
    }
#line 113
    if (tmp) {
#line 113
      if (libast_debug_level >= 1U) {
        {
#line 113
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_register_context",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           113, "!SPIF_PTR_ISNULL(name)");
        }
      } else {
        {
#line 113
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_register_context",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             113, "!SPIF_PTR_ISNULL(name)");
        }
      }
#line 113
      return ((unsigned char)255);
    }
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 114
    if ((unsigned long )((spif_ptr_t )handler) == (unsigned long )((void *)0)) {
#line 114
      tmp___0 = 1;
    } else {
#line 114
      tmp___0 = 0;
    }
#line 114
    if (tmp___0) {
#line 114
      if (libast_debug_level >= 1U) {
        {
#line 114
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_register_context",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           114, "!SPIF_PTR_ISNULL(handler)");
        }
      } else {
        {
#line 114
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_register_context",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             114, "!SPIF_PTR_ISNULL(handler)");
        }
      }
#line 114
      return ((unsigned char)255);
    }
#line 114
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 116
  tmp___6 = strcasecmp((char const   *)((char *)name___0), "null");
  }
#line 116
  if (tmp___6) {
#line 117
    ctx_idx = (unsigned char )((int )ctx_idx + 1);
#line 117
    if ((int )ctx_idx == (int )ctx_cnt) {
#line 118
      ctx_cnt = (unsigned char )((int )ctx_cnt * 2);
#line 119
      if (sizeof(ctx_t ) * (unsigned long )ctx_cnt) {
#line 119
        if (context) {
          {
#line 119
          tmp___1 = realloc((void *)context, sizeof(ctx_t ) * (unsigned long )ctx_cnt);
#line 119
          tmp___3 = tmp___1;
          }
        } else {
          {
#line 119
          tmp___2 = malloc(sizeof(ctx_t ) * (unsigned long )ctx_cnt);
#line 119
          tmp___3 = tmp___2;
          }
        }
#line 119
        tmp___5 = tmp___3;
      } else {
#line 119
        if (context) {
          {
#line 119
          free((void *)context);
#line 119
          tmp___4 = (void *)0;
          }
        } else {
#line 119
          tmp___4 = (void *)0;
        }
#line 119
        tmp___5 = tmp___4;
      }
#line 119
      context = (ctx_t *)tmp___5;
    }
  } else {
    {
#line 122
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 122
      free((void *)(context + 0)->name);
#line 122
      (context + 0)->name = (spif_charptr_t )((void *)0);
      }
#line 122
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 124
  tmp___7 = strdup((char const   *)((char *)name___0));
#line 124
  (context + ctx_idx)->name = (spif_charptr_t )tmp___7;
#line 125
  (context + ctx_idx)->handler = handler;
  }
  {
#line 126
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 126
    if (libast_debug_level >= 3U) {
      {
#line 126
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 126
        tmp___8 = time((time_t *)((void *)0));
#line 126
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___8, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                126, "spifconf_register_context");
#line 126
        libast_dprintf("Added context \"%s\" with ID %d and handler 0x%08x\n", (context + ctx_idx)->name,
                       (int )ctx_idx, (context + ctx_idx)->handler);
        }
#line 126
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 126
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 127
  return (ctx_idx);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
unsigned char spifconf_register_fstate(FILE *fp , spif_charptr_t path , spif_charptr_t outfile ,
                                       unsigned long line , unsigned char flags ) 
{ 
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if ((unsigned long )((spif_ptr_t )fp) == (unsigned long )((void *)0)) {
#line 134
      tmp = 1;
    } else {
#line 134
      tmp = 0;
    }
#line 134
    if (tmp) {
#line 134
      if (libast_debug_level >= 1U) {
        {
#line 134
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_register_fstate",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           134, "!SPIF_PTR_ISNULL(fp)");
        }
      } else {
        {
#line 134
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_register_fstate",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             134, "!SPIF_PTR_ISNULL(fp)");
        }
      }
#line 134
      return ((unsigned char)255);
    }
#line 134
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if ((unsigned long )((spif_ptr_t )path) == (unsigned long )((void *)0)) {
#line 135
      tmp___0 = 1;
    } else {
#line 135
      tmp___0 = 0;
    }
#line 135
    if (tmp___0) {
#line 135
      if (libast_debug_level >= 1U) {
        {
#line 135
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_register_fstate",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           135, "!SPIF_PTR_ISNULL(path)");
        }
      } else {
        {
#line 135
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_register_fstate",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             135, "!SPIF_PTR_ISNULL(path)");
        }
      }
#line 135
      return ((unsigned char)255);
    }
#line 135
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 137
  fstate_idx = (unsigned char )((int )fstate_idx + 1);
#line 137
  if ((int )fstate_idx == (int )fstate_cnt) {
#line 138
    fstate_cnt = (unsigned char )((int )fstate_cnt * 2);
#line 139
    if (sizeof(fstate_t ) * (unsigned long )fstate_cnt) {
#line 139
      if (fstate) {
        {
#line 139
        tmp___1 = realloc((void *)fstate, sizeof(fstate_t ) * (unsigned long )fstate_cnt);
#line 139
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 139
        tmp___2 = malloc(sizeof(fstate_t ) * (unsigned long )fstate_cnt);
#line 139
        tmp___3 = tmp___2;
        }
      }
#line 139
      tmp___5 = tmp___3;
    } else {
#line 139
      if (fstate) {
        {
#line 139
        free((void *)fstate);
#line 139
        tmp___4 = (void *)0;
        }
      } else {
#line 139
        tmp___4 = (void *)0;
      }
#line 139
      tmp___5 = tmp___4;
    }
#line 139
    fstate = (fstate_t *)tmp___5;
  }
#line 141
  (fstate + fstate_idx)->fp = fp;
#line 142
  (fstate + fstate_idx)->path = path;
#line 143
  (fstate + fstate_idx)->outfile = outfile;
#line 144
  (fstate + fstate_idx)->line = (spif_uint32_t )line;
#line 145
  (fstate + fstate_idx)->flags = flags;
#line 146
  return (fstate_idx);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
unsigned char spifconf_register_builtin(char *name___0 , spif_charptr_t (*ptr)(spif_charptr_t  ) ) 
{ 
  int tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if ((unsigned long )((spif_ptr_t )name___0) == (unsigned long )((void *)0)) {
#line 153
      tmp = 1;
    } else {
#line 153
      tmp = 0;
    }
#line 153
    if (tmp) {
#line 153
      if (libast_debug_level >= 1U) {
        {
#line 153
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_register_builtin",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           153, "!SPIF_PTR_ISNULL(name)");
        }
      } else {
        {
#line 153
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_register_builtin",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             153, "!SPIF_PTR_ISNULL(name)");
        }
      }
#line 153
      return ((unsigned char)255);
    }
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  tmp___0 = strdup((char const   *)name___0);
#line 155
  (builtins + builtin_idx)->name = (spif_charptr_t )tmp___0;
#line 156
  (builtins + builtin_idx)->ptr = ptr;
#line 157
  builtin_idx = (unsigned char )((int )builtin_idx + 1);
  }
#line 157
  if ((int )builtin_idx == (int )builtin_cnt) {
#line 158
    builtin_cnt = (unsigned char )((int )builtin_cnt * 2);
#line 159
    if (sizeof(spifconf_func_t ) * (unsigned long )builtin_cnt) {
#line 159
      if (builtins) {
        {
#line 159
        tmp___1 = realloc((void *)builtins, sizeof(spifconf_func_t ) * (unsigned long )builtin_cnt);
#line 159
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 159
        tmp___2 = malloc(sizeof(spifconf_func_t ) * (unsigned long )builtin_cnt);
#line 159
        tmp___3 = tmp___2;
        }
      }
#line 159
      tmp___5 = tmp___3;
    } else {
#line 159
      if (builtins) {
        {
#line 159
        free((void *)builtins);
#line 159
        tmp___4 = (void *)0;
        }
      } else {
#line 159
        tmp___4 = (void *)0;
      }
#line 159
      tmp___5 = tmp___4;
    }
#line 159
    builtins = (spifconf_func_t *)tmp___5;
  }
#line 161
  return ((unsigned char )((int )builtin_idx - 1));
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
unsigned char spifconf_register_context_state(unsigned char ctx_id ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 168
  ctx_state_idx = (unsigned char )((int )ctx_state_idx + 1);
#line 168
  if ((int )ctx_state_idx == (int )ctx_state_cnt) {
#line 169
    ctx_state_cnt = (unsigned char )((int )ctx_state_cnt * 2);
#line 170
    if (sizeof(ctx_state_t ) * (unsigned long )ctx_state_cnt) {
#line 170
      if (ctx_state) {
        {
#line 170
        tmp = realloc((void *)ctx_state, sizeof(ctx_state_t ) * (unsigned long )ctx_state_cnt);
#line 170
        tmp___1 = tmp;
        }
      } else {
        {
#line 170
        tmp___0 = malloc(sizeof(ctx_state_t ) * (unsigned long )ctx_state_cnt);
#line 170
        tmp___1 = tmp___0;
        }
      }
#line 170
      tmp___3 = tmp___1;
    } else {
#line 170
      if (ctx_state) {
        {
#line 170
        free((void *)ctx_state);
#line 170
        tmp___2 = (void *)0;
        }
      } else {
#line 170
        tmp___2 = (void *)0;
      }
#line 170
      tmp___3 = tmp___2;
    }
#line 170
    ctx_state = (ctx_state_t *)tmp___3;
  }
#line 172
  (ctx_state + ctx_state_idx)->ctx_id = ctx_id;
#line 173
  (ctx_state + ctx_state_idx)->state = (void *)0;
#line 174
  return (ctx_state_idx);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
void spifconf_free_subsystem(void) 
{ 
  spifconf_var_t *v ;
  spifconf_var_t *tmp ;
  unsigned long i ;

  {
#line 183
  v = spifconf_vars;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! v) {
#line 183
      goto while_break;
    }
    {
#line 184
    tmp = v;
#line 185
    v = v->next;
#line 186
    spifconf_free_var(tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  i = 0UL;
  {
#line 188
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 188
    if (! (i < (unsigned long )builtin_idx)) {
#line 188
      goto while_break___0;
    }
    {
#line 189
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 189
      free((void *)(builtins + i)->name);
#line 189
      (builtins + i)->name = (spif_charptr_t )((void *)0);
      }
#line 189
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 188
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 191
  i = 0UL;
  {
#line 191
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 191
    if (! (i <= (unsigned long )ctx_idx)) {
#line 191
      goto while_break___2;
    }
    {
#line 192
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 192
      free((void *)(context + i)->name);
#line 192
      (context + i)->name = (spif_charptr_t )((void *)0);
      }
#line 192
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 191
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 194
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 194
    free((void *)ctx_state);
#line 194
    ctx_state = (ctx_state_t *)((void *)0);
    }
#line 194
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 195
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 195
    free((void *)builtins);
#line 195
    builtins = (spifconf_func_t *)((void *)0);
    }
#line 195
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 196
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 196
    free((void *)fstate);
#line 196
    fstate = (fstate_t *)((void *)0);
    }
#line 196
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 197
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 197
    free((void *)context);
#line 197
    context = (ctx_t *)((void *)0);
    }
#line 197
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 198
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spifconf_var_t *spifconf_new_var(void) 
{ 
  spifconf_var_t *v ;
  void *tmp ;
  char *end ;
  long l ;
  long *l_dest ;
  char *c_dest ;
  char *tmp___0 ;
  long *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 205
  tmp = malloc(sizeof(spifconf_var_t ));
#line 205
  v = (spifconf_var_t *)tmp;
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    end = (char *)v + sizeof(spifconf_var_t );
#line 206
    l_dest = (long *)v;
#line 206
    if (! v) {
#line 206
      goto while_break;
    }
#line 206
    if (sizeof(spifconf_var_t ) >= 4UL * sizeof(long )) {
#line 206
      l = 0L;
#line 206
      l |= l << 16;
#line 206
      l |= l << 32;
#line 206
      if ((unsigned long )l_dest & (sizeof(long ) - 1UL)) {
#line 206
        c_dest = (char *)l_dest;
        {
#line 206
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 206
          if (! ((unsigned long )c_dest & (sizeof(long ) - 1UL))) {
#line 206
            goto while_break___0;
          }
#line 206
          tmp___0 = c_dest;
#line 206
          c_dest ++;
#line 206
          *tmp___0 = (char)0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 206
        l_dest = (long *)c_dest;
      }
      {
#line 206
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 206
        if (! ((unsigned long )(end - (char *)l_dest) >= sizeof(long ))) {
#line 206
          goto while_break___1;
        }
#line 206
        tmp___1 = l_dest;
#line 206
        l_dest ++;
#line 206
        *tmp___1 = l;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 206
    if ((unsigned long )((char *)l_dest) < (unsigned long )end) {
#line 206
      c_dest = (char *)l_dest;
#line 206
      tmp___2 = c_dest;
#line 206
      c_dest ++;
#line 206
      *tmp___2 = (char)0;
      {
#line 206
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 206
        if (! ((unsigned long )c_dest < (unsigned long )end)) {
#line 206
          goto while_break___2;
        }
#line 206
        tmp___3 = c_dest;
#line 206
        c_dest ++;
#line 206
        *tmp___3 = (char)0;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 206
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return (v);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static void spifconf_free_var(spifconf_var_t *v ) 
{ 
  int tmp ;

  {
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if ((unsigned long )((spif_ptr_t )v) == (unsigned long )((void *)0)) {
#line 213
      tmp = 1;
    } else {
#line 213
      tmp = 0;
    }
#line 213
    if (tmp) {
#line 213
      if (libast_debug_level >= 1U) {
        {
#line 213
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_free_var",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           213, "!SPIF_PTR_ISNULL(v)");
        }
      } else {
        {
#line 213
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_free_var",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             213, "!SPIF_PTR_ISNULL(v)");
        }
#line 213
        return;
      }
    }
#line 213
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  if (v->var) {
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 215
      free((void *)v->var);
#line 215
      v->var = (spif_charptr_t )((void *)0);
      }
#line 215
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 217
  if (v->value) {
    {
#line 218
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 218
      free((void *)v->value);
#line 218
      v->value = (spif_charptr_t )((void *)0);
      }
#line 218
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 220
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 220
    free((void *)v);
#line 220
    v = (spifconf_var_t *)((void *)0);
    }
#line 220
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spif_charptr_t spifconf_get_var(spif_charptr_t const   var ) 
{ 
  spifconf_var_t *v ;
  int tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  int tmp___2 ;
  time_t tmp___3 ;

  {
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if ((unsigned long )((spif_ptr_t )var) == (unsigned long )((void *)0)) {
#line 228
      tmp = 1;
    } else {
#line 228
      tmp = 0;
    }
#line 228
    if (tmp) {
#line 228
      if (libast_debug_level >= 1U) {
        {
#line 228
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_get_var",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           228, "!SPIF_PTR_ISNULL(var)");
        }
      } else {
        {
#line 228
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_get_var",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             228, "!SPIF_PTR_ISNULL(var)");
        }
      }
#line 228
      return ((spif_charptr_t )((void *)0));
    }
#line 228
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 229
    if (libast_debug_level >= 3U) {
      {
#line 229
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 229
        tmp___0 = time((time_t *)((void *)0));
#line 229
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                229, "spifconf_get_var");
#line 229
        libast_dprintf("var == \"%s\"\n", var);
        }
#line 229
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 229
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 230
  v = spifconf_vars;
  {
#line 230
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 230
    if (! v) {
#line 230
      goto while_break___2;
    }
    {
#line 231
    tmp___2 = strcmp((char const   *)((char *)v->var), (char const   *)((char *)var));
    }
#line 231
    if (! tmp___2) {
      {
#line 232
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 232
        if (libast_debug_level >= 3U) {
          {
#line 232
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 232
            tmp___1 = time((time_t *)((void *)0));
#line 232
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                    (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                    232, "spifconf_get_var");
#line 232
            libast_dprintf("Found it at %10p:  \"%s\" == \"%s\"\n", v, v->var, v->value);
            }
#line 232
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 232
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 233
      return (v->value);
    }
#line 230
    v = v->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 236
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 236
    if (libast_debug_level >= 3U) {
      {
#line 236
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 236
        tmp___3 = time((time_t *)((void *)0));
#line 236
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___3, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                236, "spifconf_get_var");
#line 236
        libast_dprintf("Not found.\n");
        }
#line 236
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 236
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 237
  return ((spif_charptr_t )((void *)0));
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static void spifconf_put_var(spif_charptr_t var , spif_charptr_t val ) 
{ 
  spifconf_var_t *v ;
  spifconf_var_t *loc ;
  spifconf_var_t *tmp ;
  time_t tmp___0 ;
  int n ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  time_t tmp___3 ;
  time_t tmp___4 ;
  time_t tmp___5 ;
  spif_charptr_t tmp___6 ;
  spif_charptr_t tmp___7 ;

  {
#line 243
  loc = (spifconf_var_t *)((void *)0);
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )var != (unsigned long )((void *)0))) {
#line 245
      if (libast_debug_level >= 1U) {
        {
#line 245
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_put_var",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           245, "var != NULL");
        }
      } else {
        {
#line 245
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_put_var",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             245, "var != NULL");
        }
#line 245
        return;
      }
    }
#line 245
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 246
    if (libast_debug_level >= 3U) {
      {
#line 246
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 246
        tmp___0 = time((time_t *)((void *)0));
#line 246
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                246, "spifconf_put_var");
#line 246
        libast_dprintf("var == \"%s\", val == \"%s\"\n", var, val);
        }
#line 246
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 246
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 248
  v = spifconf_vars;
  {
#line 248
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 248
    if (! v) {
#line 248
      goto while_break___2;
    }
    {
#line 251
    n = strcmp((char const   *)((char *)var), (char const   *)((char *)v->var));
    }
    {
#line 252
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 252
      if (libast_debug_level >= 3U) {
        {
#line 252
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 252
          tmp___1 = time((time_t *)((void *)0));
#line 252
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                  252, "spifconf_put_var");
#line 252
          libast_dprintf("Comparing at %10p:  \"%s\" -> \"%s\", n == %d\n", v, v->var,
                         v->value, n);
          }
#line 252
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 252
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 253
    if (n == 0) {
      {
#line 254
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 254
        free((void *)v->value);
#line 254
        v->value = (spif_charptr_t )((void *)0);
        }
#line 254
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 255
      if (val) {
#line 256
        v->value = val;
        {
#line 257
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 257
          if (libast_debug_level >= 3U) {
            {
#line 257
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 257
              tmp___2 = time((time_t *)((void *)0));
#line 257
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___2, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                      257, "spifconf_put_var");
#line 257
              libast_dprintf("Variable already defined.  Replacing its value with \"%s\"\n",
                             v->value);
              }
#line 257
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
#line 257
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
        {
#line 259
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 259
          if (libast_debug_level >= 3U) {
            {
#line 259
            while (1) {
              while_continue___9: /* CIL Label */ ;
              {
#line 259
              tmp___3 = time((time_t *)((void *)0));
#line 259
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___3, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                      259, "spifconf_put_var");
#line 259
              libast_dprintf("Variable already defined.  Deleting it.\n");
              }
#line 259
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
#line 259
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 260
        if (loc) {
#line 261
          loc->next = v->next;
        } else {
#line 263
          spifconf_vars = v->next;
        }
        {
#line 265
        spifconf_free_var(v);
        }
      }
#line 267
      return;
    } else
#line 268
    if (n < 0) {
#line 269
      goto while_break___2;
    }
#line 248
    loc = v;
#line 248
    v = v->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 272
  if (! val) {
    {
#line 273
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 273
      if (libast_debug_level >= 3U) {
        {
#line 273
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 273
          tmp___4 = time((time_t *)((void *)0));
#line 273
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___4, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                  273, "spifconf_put_var");
#line 273
          libast_dprintf("Empty value given for non-existant variable \"%s\".  Aborting.\n",
                         var);
          }
#line 273
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 273
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 274
    return;
  }
  {
#line 276
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 276
    if (libast_debug_level >= 3U) {
      {
#line 276
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 276
        tmp___5 = time((time_t *)((void *)0));
#line 276
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___5, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                278, "spifconf_put_var");
        }
#line 276
        if (v) {
#line 276
          tmp___6 = v->var;
        } else {
#line 276
          tmp___6 = (spif_charptr_t )"-end-";
        }
#line 276
        if (loc) {
#line 276
          tmp___7 = loc->var;
        } else {
#line 276
          tmp___7 = (spif_charptr_t )"-beginning-";
        }
        {
#line 276
        libast_dprintf("Inserting new var/val pair between \"%s\" and \"%s\"\n", tmp___7,
                       tmp___6);
        }
#line 276
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 276
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 279
  tmp = spifconf_new_var();
  }
#line 280
  if ((unsigned long )loc == (unsigned long )((void *)0)) {
#line 281
    tmp->next = spifconf_vars;
#line 282
    spifconf_vars = tmp;
  } else {
#line 284
    tmp->next = loc->next;
#line 285
    loc->next = tmp;
  }
#line 287
  tmp->var = var;
#line 288
  tmp->value = val;
#line 289
  return;
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static unsigned int rseed  =    0U;
#line 291 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spif_charptr_t builtin_random(spif_charptr_t param ) 
{ 
  unsigned long n ;
  unsigned long index___0 ;
  time_t tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  time_t tmp___2 ;
  int tmp___3 ;
  spif_charptr_t tmp___4 ;

  {
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if ((unsigned long )((spif_ptr_t )param) == (unsigned long )((void *)0)) {
#line 297
      tmp___0 = 1;
    } else {
#line 297
      tmp___0 = 0;
    }
#line 297
    if (tmp___0) {
#line 297
      if (libast_debug_level >= 1U) {
        {
#line 297
        tmp = time((time_t *)((void *)0));
#line 297
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                297, "builtin_random");
#line 297
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_PTR_ISNULL(param)");
        }
      }
#line 297
      return ((spif_charptr_t )((void *)0));
    }
#line 297
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  if (rseed == 0U) {
    {
#line 301
    tmp___1 = getpid();
#line 301
    tmp___2 = time((time_t *)((void *)0));
#line 301
    rseed = (unsigned int )(((time_t )tmp___1 * tmp___2) % 4294967295L);
#line 302
    srand(rseed);
    }
  }
  {
#line 304
  n = spiftool_num_words((spif_charptr_t const   )param);
#line 305
  tmp___3 = rand();
#line 305
  index___0 = (unsigned long )((int )((double )((float )n * (float )tmp___3) / ((double )2147483647 + 1.0)) + 1);
#line 308
  tmp___4 = spiftool_get_word(index___0, (spif_charptr_t const   )param);
  }
#line 308
  return (tmp___4);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spif_charptr_t builtin_exec(spif_charptr_t param ) 
{ 
  spif_uint32_t fsize ;
  spif_uint32_t maxlen ;
  spif_charptr_t Command ;
  spif_charptr_t Output ;
  spif_char_t OutFile[256] ;
  FILE *fp ;
  int fd ;
  time_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  long tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;

  {
#line 315
  Output = (spif_charptr_t )((void *)0);
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if ((unsigned long )((spif_ptr_t )param) == (unsigned long )((void *)0)) {
#line 320
      tmp___0 = 1;
    } else {
#line 320
      tmp___0 = 0;
    }
#line 320
    if (tmp___0) {
#line 320
      if (libast_debug_level >= 1U) {
        {
#line 320
        tmp = time((time_t *)((void *)0));
#line 320
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                320, "builtin_exec");
#line 320
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_PTR_ISNULL(param)");
        }
      }
#line 320
      return ((spif_charptr_t )((void *)0));
    }
#line 320
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  tmp___1 = malloc((size_t )20480);
#line 323
  Command = (spif_charptr_t )tmp___1;
#line 324
  strcpy((char */* __restrict  */)((char *)(OutFile)), (char const   */* __restrict  */)"Eterm-exec-");
#line 325
  fd = spiftool_temp_file(OutFile, sizeof(OutFile));
  }
#line 326
  if (fd < 0) {
    {
#line 327
    tmp___2 = __errno_location();
#line 327
    tmp___3 = strerror(*tmp___2);
#line 327
    libast_print_error("Unable to create unique temporary file for \"%s\" -- %s\n",
                       param, tmp___3);
    }
#line 328
    return ((spif_charptr_t )((void *)0));
  } else {
    {
#line 326
    tmp___4 = fchmod(fd, (__mode_t )((384 | (256 >> 3)) | ((256 >> 3) >> 3)));
    }
#line 326
    if (tmp___4) {
      {
#line 327
      tmp___2 = __errno_location();
#line 327
      tmp___3 = strerror(*tmp___2);
#line 327
      libast_print_error("Unable to create unique temporary file for \"%s\" -- %s\n",
                         param, tmp___3);
      }
#line 328
      return ((spif_charptr_t )((void *)0));
    }
  }
  {
#line 331
  tmp___5 = strlen((char const   *)((char *)param));
#line 331
  tmp___6 = strlen((char const   *)((char *)(OutFile)));
#line 331
  maxlen = (spif_uint32_t )((tmp___5 + tmp___6) + 8UL);
  }
#line 332
  if (maxlen > 20480U) {
    {
#line 333
    libast_print_error("Parse error in file %s, line %lu:  Cannot execute command, line too long\n",
                       (fstate + fstate_idx)->path, (fstate + fstate_idx)->line);
    }
#line 335
    return ((spif_charptr_t )((void *)0));
  }
  {
#line 337
  strcpy((char */* __restrict  */)((char *)Command), (char const   */* __restrict  */)((char *)param));
#line 338
  strcat((char */* __restrict  */)((char *)Command), (char const   */* __restrict  */)" >");
#line 339
  strcat((char */* __restrict  */)((char *)Command), (char const   */* __restrict  */)((char *)(OutFile)));
#line 340
  system((char const   *)((char *)Command));
#line 341
  fp = fdopen(fd, "rb");
  }
#line 341
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 342
    fseek(fp, 0L, 2);
#line 343
    tmp___7 = ftell(fp);
#line 343
    fsize = (spif_uint32_t )tmp___7;
#line 344
    rewind(fp);
    }
#line 345
    if (fsize) {
      {
#line 346
      tmp___8 = malloc((size_t )(fsize + 1U));
#line 346
      Output = (spif_charptr_t )tmp___8;
#line 347
      fread((void */* __restrict  */)Output, (size_t )fsize, (size_t )1, (FILE */* __restrict  */)fp);
#line 348
      *(Output + fsize) = (spif_char_t )0;
#line 349
      fclose(fp);
#line 350
      remove((char const   *)((char *)(OutFile)));
#line 351
      Output = spiftool_condense_whitespace(Output);
      }
    } else {
      {
#line 353
      libast_print_warning("Command at line %lu of file %s returned no output.\n",
                           (fstate + fstate_idx)->line, (fstate + fstate_idx)->path);
      }
    }
  } else {
#line 357
    if ((char *)(OutFile)) {
#line 357
      tmp___9 = (char *)(OutFile);
    } else {
#line 357
      tmp___9 = (char *)"<OutFile null>";
    }
    {
#line 357
    libast_print_warning("Output file %s could not be created.  (line %lu of file %s)\n",
                         tmp___9, (fstate + fstate_idx)->line, (fstate + fstate_idx)->path);
    }
  }
  {
#line 359
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 359
    free((void *)Command);
#line 359
    Command = (spif_charptr_t )((void *)0);
    }
#line 359
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 361
  return (Output);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spif_charptr_t builtin_get(spif_charptr_t param ) 
{ 
  spif_charptr_t s ;
  spif_charptr_t f ;
  spif_charptr_t v ;
  unsigned short n ;
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 370
  if (! param) {
    {
#line 371
    libast_print_error("Parse error in file %s, line %lu:  Invalid syntax for %get().  Syntax is:  %get(variable)\n",
                       (fstate + fstate_idx)->path, (fstate + fstate_idx)->line);
    }
#line 373
    return ((spif_charptr_t )((void *)0));
  } else {
    {
#line 370
    tmp = spiftool_num_words((spif_charptr_t const   )param);
#line 370
    n = (unsigned short )tmp;
    }
#line 370
    if ((int )n > 2) {
      {
#line 371
      libast_print_error("Parse error in file %s, line %lu:  Invalid syntax for %get().  Syntax is:  %get(variable)\n",
                         (fstate + fstate_idx)->path, (fstate + fstate_idx)->line);
      }
#line 373
      return ((spif_charptr_t )((void *)0));
    }
  }
  {
#line 377
  s = spiftool_get_word(1UL, (spif_charptr_t const   )param);
  }
#line 378
  if ((int )n == 2) {
    {
#line 379
    f = spiftool_get_word(2UL, (spif_charptr_t const   )param);
    }
  } else {
#line 381
    f = (spif_charptr_t )((void *)0);
  }
  {
#line 383
  v = spifconf_get_var((spif_charptr_t const   )s);
  }
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 384
    free((void *)s);
#line 384
    s = (spif_charptr_t )((void *)0);
    }
#line 384
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (v) {
#line 386
    if (f) {
      {
#line 387
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 387
        free((void *)f);
#line 387
        f = (spif_charptr_t )((void *)0);
        }
#line 387
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 389
    tmp___0 = strdup((char const   *)((char *)v));
    }
#line 389
    return ((spif_charptr_t )tmp___0);
  } else
#line 390
  if (f) {
#line 391
    return (f);
  } else {
#line 393
    return ((spif_charptr_t )((void *)0));
  }
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spif_charptr_t builtin_put(spif_charptr_t param ) 
{ 
  spif_charptr_t var ;
  spif_charptr_t val ;
  unsigned long tmp ;

  {
#line 402
  if (! param) {
    {
#line 403
    libast_print_error("Parse error in file %s, line %lu:  Invalid syntax for %put().  Syntax is:  %put(variable value)\n",
                       (fstate + fstate_idx)->path, (fstate + fstate_idx)->line);
    }
#line 405
    return ((spif_charptr_t )((void *)0));
  } else {
    {
#line 402
    tmp = spiftool_num_words((spif_charptr_t const   )param);
    }
#line 402
    if (tmp != 2UL) {
      {
#line 403
      libast_print_error("Parse error in file %s, line %lu:  Invalid syntax for %put().  Syntax is:  %put(variable value)\n",
                         (fstate + fstate_idx)->path, (fstate + fstate_idx)->line);
      }
#line 405
      return ((spif_charptr_t )((void *)0));
    }
  }
  {
#line 409
  var = spiftool_get_word(1UL, (spif_charptr_t const   )param);
#line 410
  val = spiftool_get_word(2UL, (spif_charptr_t const   )param);
#line 411
  spifconf_put_var(var, val);
  }
#line 412
  return ((spif_charptr_t )((void *)0));
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spif_charptr_t builtin_dirscan(spif_charptr_t param ) 
{ 
  int i ;
  unsigned long n ;
  DIR *dirp ;
  struct dirent *dp ;
  struct stat filestat ;
  spif_charptr_t dir ;
  spif_charptr_t buff ;
  unsigned long tmp ;
  void *tmp___0 ;
  spif_char_t fullname[4096] ;
  unsigned long len ;
  int tmp___1 ;

  {
#line 425
  if (! param) {
    {
#line 426
    libast_print_error("Parse error in file %s, line %lu:  Invalid syntax for %dirscan().  Syntax is:  %dirscan(directory)\n",
                       (fstate + fstate_idx)->path, (fstate + fstate_idx)->line);
    }
#line 428
    return ((spif_charptr_t )((void *)0));
  } else {
    {
#line 425
    tmp = spiftool_num_words((spif_charptr_t const   )param);
    }
#line 425
    if (tmp != 1UL) {
      {
#line 426
      libast_print_error("Parse error in file %s, line %lu:  Invalid syntax for %dirscan().  Syntax is:  %dirscan(directory)\n",
                         (fstate + fstate_idx)->path, (fstate + fstate_idx)->line);
      }
#line 428
      return ((spif_charptr_t )((void *)0));
    }
  }
  {
#line 431
  dir = spiftool_get_word(1UL, (spif_charptr_t const   )param);
#line 432
  dirp = opendir((char const   *)((char *)dir));
  }
#line 433
  if (! dirp) {
#line 434
    return ((spif_charptr_t )((void *)0));
  }
  {
#line 436
  tmp___0 = malloc((size_t )20480);
#line 436
  buff = (spif_charptr_t )tmp___0;
#line 437
  *buff = (spif_char_t )0;
#line 438
  n = 20480UL;
#line 440
  i = 0;
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 440
    dp = readdir(dirp);
    }
#line 440
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 440
      goto while_break;
    }
    {
#line 443
    snprintf((char */* __restrict  */)((char *)(fullname)), sizeof(fullname), (char const   */* __restrict  */)"%s/%s",
             dir, dp->d_name);
#line 444
    tmp___1 = stat((char const   */* __restrict  */)((char *)(fullname)), (struct stat */* __restrict  */)(& filestat));
    }
#line 444
    if (! tmp___1) {
#line 447
      if ((filestat.st_mode & 61440U) == 32768U) {
        {
#line 450
        len = strlen((char const   *)(dp->d_name));
        }
#line 451
        if (len < n) {
          {
#line 452
          strcat((char */* __restrict  */)((char *)buff), (char const   */* __restrict  */)(dp->d_name));
#line 453
          strcat((char */* __restrict  */)((char *)buff), (char const   */* __restrict  */)" ");
#line 454
          n -= len + 1UL;
          }
        }
      }
    }
#line 458
    if (n < 2UL) {
#line 459
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 462
  closedir(dirp);
  }
#line 463
  return (buff);
}
}
#line 466 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spif_charptr_t builtin_version(spif_charptr_t param ) 
{ 
  char *tmp ;

  {
  {
#line 472
  tmp = strdup((char const   *)((char *)libast_program_version));
  }
#line 472
  return ((spif_charptr_t )tmp);
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spif_charptr_t builtin_appname(spif_charptr_t param ) 
{ 
  char buff[256] ;
  char *tmp ;

  {
  {
#line 483
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s-%s",
           libast_program_name, libast_program_version);
#line 484
  tmp = strdup((char const   *)(buff));
  }
#line 484
  return ((spif_charptr_t )tmp);
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
spif_charptr_t spifconf_shell_expand(spif_charptr_t s ) 
{ 
  register spif_charptr_t tmp ;
  register spif_charptr_t pbuff ;
  register spif_charptr_t tmp1 ;
  register spif_uint32_t j ;
  register spif_uint32_t k ;
  register spif_uint32_t l ;
  spif_char_t newbuff[20480] ;
  spif_uint8_t in_single ;
  spif_uint8_t in_double ;
  spif_uint32_t cnt1 ;
  spif_uint32_t cnt2 ;
  spif_uint32_t max ;
  spif_charptr_t Command ;
  spif_charptr_t Output ;
  spif_charptr_t EnvVar ;
  time_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  spif_uint32_t aa ;
  spif_uint32_t bb ;
  spif_uint32_t tmp___3 ;
  time_t tmp___4 ;
  int tmp___5 ;
  spif_uint32_t tmp___6 ;
  spif_charptr_t tmp___7 ;
  time_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  time_t tmp___11 ;
  void *tmp___12 ;
  spif_charptr_t tmp___13 ;
  size_t tmp___14 ;
  spif_uint32_t aa___0 ;
  spif_uint32_t bb___0 ;
  spif_uint32_t tmp___15 ;
  time_t tmp___16 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  spif_uint32_t aa___1 ;
  spif_uint32_t bb___1 ;
  spif_uint32_t tmp___19 ;
  time_t tmp___20 ;
  void *tmp___21 ;
  unsigned short const   **tmp___22 ;
  char *tmp___23 ;
  size_t tmp___24 ;
  spif_uint32_t aa___2 ;
  spif_uint32_t bb___2 ;
  spif_uint32_t tmp___25 ;
  time_t tmp___26 ;
  time_t tmp___27 ;

  {
#line 493
  pbuff = s;
#line 494
  l = (spif_uint32_t )0;
#line 496
  in_single = (spif_uint8_t )0;
#line 496
  in_double = (spif_uint8_t )0;
#line 497
  cnt1 = (spif_uint32_t )0;
#line 497
  cnt2 = (spif_uint32_t )0;
#line 498
  max = (spif_uint32_t )20479;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 501
      if (libast_debug_level >= 1U) {
        {
#line 501
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_shell_expand",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           501, "s != NULL");
        }
      } else {
        {
#line 501
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_shell_expand",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             501, "s != NULL");
        }
      }
#line 501
      return ((spif_charptr_t )((void *)0));
    }
#line 501
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 507
  j = (spif_uint32_t )0;
  {
#line 507
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 507
    if (*pbuff) {
#line 507
      if (! (j < max)) {
#line 507
        goto while_break___0;
      }
    } else {
#line 507
      goto while_break___0;
    }
    {
#line 509
    if ((int )*pbuff == 126) {
#line 509
      goto case_126;
    }
#line 521
    if ((int )*pbuff == 92) {
#line 521
      goto case_92;
    }
#line 558
    if ((int )*pbuff == 37) {
#line 558
      goto case_37;
    }
#line 615
    if ((int )*pbuff == 96) {
#line 615
      goto case_96;
    }
#line 650
    if ((int )*pbuff == 36) {
#line 650
      goto case_36;
    }
#line 681
    if ((int )*pbuff == 34) {
#line 681
      goto case_34;
    }
#line 693
    if ((int )*pbuff == 39) {
#line 693
      goto case_39;
    }
#line 703
    goto switch_default___2;
    case_126: /* CIL Label */ 
    {
#line 510
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 510
      if (libast_debug_level >= 3U) {
        {
#line 510
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 510
          tmp___0 = time((time_t *)((void *)0));
#line 510
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                  510, "spifconf_shell_expand");
#line 510
          libast_dprintf("Tilde detected.\n");
          }
#line 510
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 510
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 511
    tmp___1 = getenv("HOME");
#line 511
    EnvVar = (spif_charptr_t )tmp___1;
    }
#line 512
    if (! in_single) {
#line 512
      if (! in_double) {
#line 512
        if (EnvVar) {
#line 512
          if (*EnvVar) {
            {
#line 513
            spiftool_safe_strncpy(newbuff + j, (spif_charptr_t const   )EnvVar, (spif_int32_t )(max - j));
#line 514
            tmp___2 = strlen((char const   *)((char *)EnvVar));
#line 514
            cnt1 = (spif_uint32_t )(tmp___2 - 1UL);
#line 515
            cnt2 = (max - j) - 1U;
#line 516
            aa = cnt1;
#line 516
            bb = cnt2;
            }
#line 516
            if (aa < bb) {
#line 516
              tmp___3 = aa;
            } else {
#line 516
              tmp___3 = bb;
            }
#line 516
            j += tmp___3;
          } else {
#line 518
            newbuff[j] = *pbuff;
          }
        } else {
#line 518
          newbuff[j] = *pbuff;
        }
      } else {
#line 518
        newbuff[j] = *pbuff;
      }
    } else {
#line 518
      newbuff[j] = *pbuff;
    }
#line 520
    goto switch_break;
    case_92: /* CIL Label */ 
    {
#line 522
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 522
      if (libast_debug_level >= 3U) {
        {
#line 522
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 522
          tmp___4 = time((time_t *)((void *)0));
#line 522
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___4, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                  522, "spifconf_shell_expand");
#line 522
          libast_dprintf("Escape sequence detected.\n");
          }
#line 522
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 522
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 523
    if (! in_single) {
#line 523
      goto _L;
    } else
#line 523
    if (in_single) {
#line 523
      if ((int )*(pbuff + 1) == 39) {
        _L: /* CIL Label */ 
        {
#line 524
        pbuff ++;
#line 524
        tmp___5 = tolower((int )*pbuff);
        }
        {
#line 525
        if (tmp___5 == 110) {
#line 525
          goto case_110;
        }
#line 528
        if (tmp___5 == 114) {
#line 528
          goto case_114;
        }
#line 531
        if (tmp___5 == 116) {
#line 531
          goto case_116;
        }
#line 534
        if (tmp___5 == 98) {
#line 534
          goto case_98;
        }
#line 537
        if (tmp___5 == 102) {
#line 537
          goto case_102;
        }
#line 540
        if (tmp___5 == 97) {
#line 540
          goto case_97;
        }
#line 543
        if (tmp___5 == 118) {
#line 543
          goto case_118;
        }
#line 546
        if (tmp___5 == 101) {
#line 546
          goto case_101;
        }
#line 549
        goto switch_default;
        case_110: /* CIL Label */ 
#line 526
        newbuff[j] = (spif_char_t )'\n';
#line 527
        goto switch_break___0;
        case_114: /* CIL Label */ 
#line 529
        newbuff[j] = (spif_char_t )'\r';
#line 530
        goto switch_break___0;
        case_116: /* CIL Label */ 
#line 532
        newbuff[j] = (spif_char_t )'\t';
#line 533
        goto switch_break___0;
        case_98: /* CIL Label */ 
#line 535
        newbuff[j] = (spif_char_t )'\b';
#line 536
        goto switch_break___0;
        case_102: /* CIL Label */ 
#line 538
        newbuff[j] = (spif_char_t )'\f';
#line 539
        goto switch_break___0;
        case_97: /* CIL Label */ 
#line 541
        newbuff[j] = (spif_char_t )'\a';
#line 542
        goto switch_break___0;
        case_118: /* CIL Label */ 
#line 544
        newbuff[j] = (spif_char_t )'\v';
#line 545
        goto switch_break___0;
        case_101: /* CIL Label */ 
#line 547
        newbuff[j] = (spif_char_t )'\033';
#line 548
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 550
        newbuff[j] = *pbuff;
#line 551
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      } else {
#line 523
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 554
      tmp___6 = j;
#line 554
      j ++;
#line 554
      tmp___7 = pbuff;
#line 554
      pbuff ++;
#line 554
      newbuff[tmp___6] = *tmp___7;
#line 555
      newbuff[j] = *pbuff;
    }
#line 557
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 559
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 559
      if (libast_debug_level >= 3U) {
        {
#line 559
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 559
          tmp___8 = time((time_t *)((void *)0));
#line 559
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___8, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                  559, "spifconf_shell_expand");
#line 559
          libast_dprintf("%% detected.\n");
          }
#line 559
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 559
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 560
    k = (spif_uint32_t )0;
#line 560
    pbuff ++;
    {
#line 560
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 560
      if (! ((unsigned long )(builtins + k)->name != (unsigned long )((void *)0))) {
#line 560
        goto while_break___7;
      }
      {
#line 562
      tmp___9 = strlen((char const   *)((char *)(builtins + k)->name));
#line 562
      l = (spif_uint32_t )tmp___9;
#line 563
      tmp___10 = strncasecmp((char const   *)((char *)(builtins + k)->name), (char const   *)((char *)pbuff),
                             (size_t )l);
      }
#line 563
      if (! tmp___10) {
#line 563
        if ((int )*(pbuff + l) == 40) {
#line 567
          goto while_break___7;
        } else
#line 563
        if ((int )*(pbuff + l) == 32) {
#line 563
          if ((int )*(pbuff + (l + 1U)) == 41) {
#line 567
            goto while_break___7;
          }
        }
      }
#line 560
      k ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 570
    if ((unsigned long )(builtins + k)->name == (unsigned long )((void *)0)) {
#line 571
      newbuff[j] = *pbuff;
    } else {
      {
#line 573
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 573
        if (libast_debug_level >= 3U) {
          {
#line 573
          while (1) {
            while_continue___9: /* CIL Label */ ;
            {
#line 573
            tmp___11 = time((time_t *)((void *)0));
#line 573
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                    (unsigned long )tmp___11, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                    573, "spifconf_shell_expand");
#line 573
            libast_dprintf("Call to built-in function %s detected.\n", (builtins + k)->name);
            }
#line 573
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
#line 573
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 574
      tmp___12 = malloc((size_t )20480);
#line 574
      Command = (spif_charptr_t )tmp___12;
#line 575
      pbuff += l;
      }
#line 576
      if ((int )*pbuff != 40) {
#line 577
        pbuff ++;
      }
#line 578
      tmp1 = Command;
#line 578
      pbuff ++;
#line 578
      l = (spif_uint32_t )1;
      {
#line 578
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 578
        if (l) {
#line 578
          if (! *pbuff) {
#line 578
            goto while_break___10;
          }
        } else {
#line 578
          goto while_break___10;
        }
        {
#line 580
        if ((int )*pbuff == 40) {
#line 580
          goto case_40;
        }
#line 584
        if ((int )*pbuff == 41) {
#line 584
          goto case_41;
        }
#line 586
        goto switch_default___0;
        case_40: /* CIL Label */ 
#line 581
        l ++;
#line 582
        *tmp1 = *pbuff;
#line 583
        goto switch_break___1;
        case_41: /* CIL Label */ 
#line 585
        l --;
        switch_default___0: /* CIL Label */ 
#line 587
        *tmp1 = *pbuff;
#line 588
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 578
        pbuff ++;
#line 578
        tmp1 ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 591
      tmp1 --;
#line 591
      *tmp1 = (spif_char_t )0;
#line 592
      if (l) {
        {
#line 593
        libast_print_error("parse error in file %s, line %lu:  Mismatched parentheses\n",
                           (fstate + fstate_idx)->path, (fstate + fstate_idx)->line);
        }
#line 594
        return ((spif_charptr_t )((void *)0));
      }
      {
#line 596
      Command = spifconf_shell_expand(Command);
#line 597
      tmp___13 = (*((builtins + k)->ptr))(Command);
#line 597
      Output = tmp___13;
      }
      {
#line 598
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 598
        free((void *)Command);
#line 598
        Command = (spif_charptr_t )((void *)0);
        }
#line 598
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 599
      if (Output) {
#line 600
        if (*Output) {
          {
#line 601
          spiftool_safe_strncpy(newbuff + j, (spif_charptr_t const   )Output, (spif_int32_t )(max - j));
#line 602
          tmp___14 = strlen((char const   *)((char *)Output));
#line 602
          l = (spif_uint32_t )(tmp___14 - 1UL);
#line 603
          cnt2 = (max - j) - 1U;
#line 604
          aa___0 = l;
#line 604
          bb___0 = cnt2;
          }
#line 604
          if (aa___0 < bb___0) {
#line 604
            tmp___15 = aa___0;
          } else {
#line 604
            tmp___15 = bb___0;
          }
#line 604
          j += tmp___15;
        } else {
#line 606
          j --;
        }
        {
#line 608
        while (1) {
          while_continue___12: /* CIL Label */ ;
          {
#line 608
          free((void *)Output);
#line 608
          Output = (spif_charptr_t )((void *)0);
          }
#line 608
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
      } else {
#line 610
        j --;
      }
#line 612
      pbuff --;
    }
#line 614
    goto switch_break;
    case_96: /* CIL Label */ 
    {
#line 617
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 617
      if (libast_debug_level >= 3U) {
        {
#line 617
        while (1) {
          while_continue___14: /* CIL Label */ ;
          {
#line 617
          tmp___16 = time((time_t *)((void *)0));
#line 617
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___16, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                  617, "spifconf_shell_expand");
#line 617
          libast_dprintf("Backquotes detected.  Evaluating expression.\n");
          }
#line 617
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
#line 617
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 618
    if (! in_single) {
      {
#line 619
      tmp___17 = malloc((size_t )20480);
#line 619
      Command = (spif_charptr_t )tmp___17;
#line 620
      l = (spif_uint32_t )0;
#line 621
      pbuff ++;
      }
      {
#line 621
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 621
        if (*pbuff) {
#line 621
          if ((int )*pbuff != 96) {
#line 621
            if (! (l < max)) {
#line 621
              goto while_break___15;
            }
          } else {
#line 621
            goto while_break___15;
          }
        } else {
#line 621
          goto while_break___15;
        }
#line 622
        *(Command + l) = *pbuff;
#line 621
        pbuff ++;
#line 621
        l ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 624
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 624
        if (! (l < 20480U)) {
#line 624
          if (libast_debug_level >= 1U) {
            {
#line 624
            libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_shell_expand",
                               "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                               624, "l < CONFIG_BUFF");
            }
          } else {
            {
#line 624
            libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_shell_expand",
                                 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                                 624, "l < CONFIG_BUFF");
            }
          }
#line 624
          return ((spif_charptr_t )((void *)0));
        }
#line 624
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 625
      *(Command + l) = (spif_char_t )0;
#line 626
      Command = spifconf_shell_expand(Command);
#line 627
      Output = builtin_exec(Command);
      }
      {
#line 628
      while (1) {
        while_continue___17: /* CIL Label */ ;
        {
#line 628
        free((void *)Command);
#line 628
        Command = (spif_charptr_t )((void *)0);
        }
#line 628
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 629
      if (Output) {
#line 630
        if (*Output) {
          {
#line 631
          spiftool_safe_strncpy(newbuff + j, (spif_charptr_t const   )Output, (spif_int32_t )(max - j));
#line 632
          tmp___18 = strlen((char const   *)((char *)Output));
#line 632
          l = (spif_uint32_t )(tmp___18 - 1UL);
#line 633
          cnt2 = (max - j) - 1U;
#line 634
          aa___1 = l;
#line 634
          bb___1 = cnt2;
          }
#line 634
          if (aa___1 < bb___1) {
#line 634
            tmp___19 = aa___1;
          } else {
#line 634
            tmp___19 = bb___1;
          }
#line 634
          j += tmp___19;
        } else {
#line 636
          j --;
        }
        {
#line 638
        while (1) {
          while_continue___18: /* CIL Label */ ;
          {
#line 638
          free((void *)Output);
#line 638
          Output = (spif_charptr_t )((void *)0);
          }
#line 638
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      } else {
#line 640
        j --;
      }
    } else {
#line 643
      newbuff[j] = *pbuff;
    }
#line 649
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 651
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 651
      if (libast_debug_level >= 3U) {
        {
#line 651
        while (1) {
          while_continue___20: /* CIL Label */ ;
          {
#line 651
          tmp___20 = time((time_t *)((void *)0));
#line 651
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___20, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                  651, "spifconf_shell_expand");
#line 651
          libast_dprintf("Environment variable detected.  Evaluating.\n");
          }
#line 651
          goto while_break___20;
        }
        while_break___20: /* CIL Label */ ;
        }
      }
#line 651
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 652
    if (! in_single) {
      {
#line 653
      tmp___21 = malloc((size_t )128);
#line 653
      EnvVar = (spif_charptr_t )tmp___21;
#line 654
      pbuff ++;
      }
      {
#line 655
      if ((int )*pbuff == 123) {
#line 655
        goto case_123;
      }
#line 659
      if ((int )*pbuff == 40) {
#line 659
        goto case_40___0;
      }
#line 663
      goto switch_default___1;
      case_123: /* CIL Label */ 
#line 656
      pbuff ++;
#line 656
      k = (spif_uint32_t )0;
      {
#line 656
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 656
        if ((int )*pbuff != 125) {
#line 656
          if (! (k < 127U)) {
#line 656
            goto while_break___21;
          }
        } else {
#line 656
          goto while_break___21;
        }
#line 657
        *(EnvVar + k) = *pbuff;
#line 656
        k ++;
#line 656
        pbuff ++;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 658
      goto switch_break___2;
      case_40___0: /* CIL Label */ 
#line 660
      pbuff ++;
#line 660
      k = (spif_uint32_t )0;
      {
#line 660
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 660
        if ((int )*pbuff != 41) {
#line 660
          if (! (k < 127U)) {
#line 660
            goto while_break___22;
          }
        } else {
#line 660
          goto while_break___22;
        }
#line 661
        *(EnvVar + k) = *pbuff;
#line 660
        k ++;
#line 660
        pbuff ++;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 662
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
#line 664
      k = (spif_uint32_t )0;
      {
#line 664
      while (1) {
        while_continue___23: /* CIL Label */ ;
        {
#line 664
        tmp___22 = __ctype_b_loc();
        }
#line 664
        if ((int const   )*(*tmp___22 + (int )*pbuff) & 8) {
#line 664
          goto _L___1;
        } else
#line 664
        if ((int )*pbuff == 95) {
          _L___1: /* CIL Label */ 
#line 664
          if (! (k < 127U)) {
#line 664
            goto while_break___23;
          }
        } else {
#line 664
          goto while_break___23;
        }
#line 665
        *(EnvVar + k) = *pbuff;
#line 664
        k ++;
#line 664
        pbuff ++;
      }
      while_break___23: /* CIL Label */ ;
      }
#line 666
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
      {
#line 668
      *(EnvVar + k) = (spif_char_t )0;
#line 669
      tmp___23 = getenv((char const   *)((char *)EnvVar));
#line 669
      tmp = (spif_charptr_t )tmp___23;
      }
#line 670
      if (tmp) {
#line 670
        if (*tmp) {
          {
#line 671
          spiftool_safe_strncpy(newbuff, (spif_charptr_t const   )tmp, (spif_int32_t )(max - j));
#line 672
          tmp___24 = strlen((char const   *)((char *)tmp));
#line 672
          cnt1 = (spif_uint32_t )(tmp___24 - 1UL);
#line 673
          cnt2 = (max - j) - 1U;
#line 674
          aa___2 = cnt1;
#line 674
          bb___2 = cnt2;
          }
#line 674
          if (aa___2 < bb___2) {
#line 674
            tmp___25 = aa___2;
          } else {
#line 674
            tmp___25 = bb___2;
          }
#line 674
          j += tmp___25;
        }
      }
#line 676
      pbuff --;
    } else {
#line 678
      newbuff[j] = *pbuff;
    }
#line 680
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 682
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 682
      if (libast_debug_level >= 3U) {
        {
#line 682
        while (1) {
          while_continue___25: /* CIL Label */ ;
          {
#line 682
          tmp___26 = time((time_t *)((void *)0));
#line 682
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___26, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                  682, "spifconf_shell_expand");
#line 682
          libast_dprintf("Double quotes detected.\n");
          }
#line 682
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
      }
#line 682
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
#line 683
    if (! in_single) {
#line 684
      if (in_double) {
#line 685
        in_double = (spif_uint8_t )0;
      } else {
#line 687
        in_double = (spif_uint8_t )1;
      }
    }
#line 690
    newbuff[j] = *pbuff;
#line 691
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 694
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 694
      if (libast_debug_level >= 3U) {
        {
#line 694
        while (1) {
          while_continue___27: /* CIL Label */ ;
          {
#line 694
          tmp___27 = time((time_t *)((void *)0));
#line 694
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___27, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                  694, "spifconf_shell_expand");
#line 694
          libast_dprintf("Single quotes detected.\n");
          }
#line 694
          goto while_break___27;
        }
        while_break___27: /* CIL Label */ ;
        }
      }
#line 694
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 695
    if (in_single) {
#line 696
      in_single = (spif_uint8_t )0;
    } else {
#line 698
      in_single = (spif_uint8_t )1;
    }
#line 700
    newbuff[j] = *pbuff;
#line 701
    goto switch_break;
    switch_default___2: /* CIL Label */ 
#line 704
    newbuff[j] = *pbuff;
    switch_break: /* CIL Label */ ;
    }
#line 507
    pbuff ++;
#line 507
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 707
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 707
    if (! (j < 20480U)) {
#line 707
      if (libast_debug_level >= 1U) {
        {
#line 707
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_shell_expand",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           707, "j < CONFIG_BUFF");
        }
      } else {
        {
#line 707
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_shell_expand",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             707, "j < CONFIG_BUFF");
        }
      }
#line 707
      return ((spif_charptr_t )((void *)0));
    }
#line 707
    goto while_break___28;
  }
  while_break___28: /* CIL Label */ ;
  }
  {
#line 708
  newbuff[j] = (spif_char_t )0;
#line 715
  strcpy((char */* __restrict  */)((char *)s), (char const   */* __restrict  */)((char *)(newbuff)));
  }
#line 719
  return (s);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spif_char_t name[4096]  ;
#line 727 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static spif_char_t full_path[4096]  ;
#line 724 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
spif_charptr_t spifconf_find_file(spif_charptr_t const   file , spif_charptr_t const   dir ,
                                  spif_charptr_t const   pathlist ) 
{ 
  spif_charptr_t path ;
  spif_charptr_t p ;
  spif_int32_t len ;
  spif_int32_t maxpathlen ;
  struct stat fst ;
  time_t tmp ;
  time_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  time_t tmp___6 ;
  size_t tmp___7 ;
  time_t tmp___8 ;
  time_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  time_t tmp___12 ;
  short n ;
  spif_charptr_t tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  short tmp___16 ;
  time_t tmp___17 ;
  time_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  time_t tmp___21 ;

  {
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 732
    if (! ((unsigned long )file != (unsigned long )((void *)0))) {
#line 732
      if (libast_debug_level >= 1U) {
        {
#line 732
        tmp = time((time_t *)((void *)0));
#line 732
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                732, "spifconf_find_file");
#line 732
        libast_dprintf("REQUIRE failed:  %s\n", "file != NULL");
        }
      }
#line 732
      return ((spif_charptr_t )((void *)0));
    }
#line 732
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  getcwd((char *)(name), (size_t )4096);
  }
  {
#line 735
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 735
    if (libast_debug_level >= 3U) {
      {
#line 735
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 735
        tmp___0 = time((time_t *)((void *)0));
#line 735
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                736, "spifconf_find_file");
        }
#line 735
        if ((char *)pathlist) {
#line 735
          tmp___1 = (char *)pathlist;
        } else {
#line 735
          tmp___1 = (char *)"<pathlist null>";
        }
#line 735
        if ((char *)dir) {
#line 735
          tmp___2 = (char *)dir;
        } else {
#line 735
          tmp___2 = (char *)"<dir null>";
        }
        {
#line 735
        libast_dprintf("spifconf_find_file(\"%s\", \"%s\", \"%s\") called from directory \"%s\".\n",
                       file, tmp___2, tmp___1, name);
        }
#line 735
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 735
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 739
  tmp___3 = strlen((char const   *)((char *)file));
  }
#line 739
  if (dir) {
    {
#line 739
    tmp___4 = strlen((char const   *)((char *)dir));
#line 739
    tmp___5 = tmp___4;
    }
  } else {
#line 739
    tmp___5 = (size_t )0;
  }
#line 739
  len = (spif_int32_t )((tmp___3 + tmp___5) + 2UL);
#line 740
  if (len > (spif_int32_t )sizeof(name)) {
#line 740
    goto _L;
  } else
#line 740
  if (len <= 0) {
    _L: /* CIL Label */ 
    {
#line 741
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 741
      if (libast_debug_level >= 3U) {
        {
#line 741
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 741
          tmp___6 = time((time_t *)((void *)0));
#line 741
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___6, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                  741, "spifconf_find_file");
#line 741
          libast_dprintf("Too big.  I lose. :(\n");
          }
#line 741
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 741
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 742
    return ((spif_charptr_t )((void *)0));
  }
#line 745
  if (dir) {
    {
#line 746
    strcpy((char */* __restrict  */)((char *)(name)), (char const   */* __restrict  */)((char *)dir));
#line 747
    strcat((char */* __restrict  */)((char *)(name)), (char const   */* __restrict  */)"/");
#line 748
    strcat((char */* __restrict  */)((char *)(name)), (char const   */* __restrict  */)((char *)file));
    }
  } else {
    {
#line 750
    strcpy((char */* __restrict  */)((char *)(name)), (char const   */* __restrict  */)((char *)file));
    }
  }
  {
#line 752
  tmp___7 = strlen((char const   *)((char *)(name)));
#line 752
  len = (spif_int32_t )tmp___7;
  }
  {
#line 753
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 753
    if (libast_debug_level >= 3U) {
      {
#line 753
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 753
        tmp___8 = time((time_t *)((void *)0));
#line 753
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___8, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                753, "spifconf_find_file");
#line 753
        libast_dprintf("Checking for file \"%s\"\n", name);
        }
#line 753
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 753
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 754
  tmp___10 = access((char const   *)((char *)(name)), 4);
  }
#line 754
  if (! tmp___10) {
    {
#line 754
    tmp___11 = stat((char const   */* __restrict  */)((char *)(name)), (struct stat */* __restrict  */)(& fst));
    }
#line 754
    if (! tmp___11) {
#line 754
      if (! ((fst.st_mode & 61440U) == 16384U)) {
        {
#line 757
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 757
          if (libast_debug_level >= 3U) {
            {
#line 757
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 757
              tmp___9 = time((time_t *)((void *)0));
#line 757
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___9, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                      757, "spifconf_find_file");
#line 757
              libast_dprintf("Found \"%s\"\n", name);
              }
#line 757
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
#line 757
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 758
        return (name);
      }
    }
  }
#line 763
  maxpathlen = (spif_int32_t )((sizeof(name) - (unsigned long )len) - 2UL);
#line 763
  if (maxpathlen <= 0) {
    {
#line 764
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 764
      if (libast_debug_level >= 3U) {
        {
#line 764
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 764
          tmp___12 = time((time_t *)((void *)0));
#line 764
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___12, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                  764, "spifconf_find_file");
#line 764
          libast_dprintf("Too big.  I lose. :(\n");
          }
#line 764
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
#line 764
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 765
    return ((spif_charptr_t )((void *)0));
  }
#line 768
  path = (spif_charptr_t )pathlist;
  {
#line 768
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 768
    if ((unsigned long )path != (unsigned long )((void *)0)) {
#line 768
      if (! ((int )*path != 0)) {
#line 768
        goto while_break___10;
      }
    } else {
#line 768
      goto while_break___10;
    }
    {
#line 772
    tmp___15 = strchr((char const   *)((char *)path), ':');
#line 772
    p = (spif_charptr_t )tmp___15;
    }
#line 772
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 773
      tmp___13 = p;
#line 773
      p ++;
#line 773
      n = (short )(tmp___13 - path);
    } else {
      {
#line 775
      tmp___14 = strlen((char const   *)((char *)path));
#line 775
      n = (short )tmp___14;
      }
    }
#line 779
    if ((int )n > 0) {
#line 779
      if ((int )n <= maxpathlen) {
        {
#line 781
        memcpy((void */* __restrict  */)(full_path), (void const   */* __restrict  */)path,
               (size_t )n);
        }
#line 782
        if ((int )full_path[(int )n - 1] != 47) {
#line 783
          tmp___16 = n;
#line 783
          n = (short )((int )n + 1);
#line 783
          full_path[tmp___16] = (spif_char_t )'/';
        }
        {
#line 785
        full_path[n] = (spif_char_t )'\000';
#line 786
        strcat((char */* __restrict  */)((char *)(full_path)), (char const   */* __restrict  */)((char *)(name)));
        }
        {
#line 788
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 788
          if (libast_debug_level >= 3U) {
            {
#line 788
            while (1) {
              while_continue___12: /* CIL Label */ ;
              {
#line 788
              tmp___17 = time((time_t *)((void *)0));
#line 788
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___17, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                      788, "spifconf_find_file");
#line 788
              libast_dprintf("Checking for file \"%s\"\n", full_path);
              }
#line 788
              goto while_break___12;
            }
            while_break___12: /* CIL Label */ ;
            }
          }
#line 788
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 789
        tmp___19 = access((char const   *)((char *)(full_path)), 4);
        }
#line 789
        if (! tmp___19) {
          {
#line 789
          tmp___20 = stat((char const   */* __restrict  */)((char *)(full_path)),
                          (struct stat */* __restrict  */)(& fst));
          }
#line 789
          if (! tmp___20) {
#line 789
            if (! ((fst.st_mode & 61440U) == 16384U)) {
              {
#line 792
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 792
                if (libast_debug_level >= 3U) {
                  {
#line 792
                  while (1) {
                    while_continue___14: /* CIL Label */ ;
                    {
#line 792
                    tmp___18 = time((time_t *)((void *)0));
#line 792
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                            (unsigned long )tmp___18, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                            792, "spifconf_find_file");
#line 792
                    libast_dprintf("Found \"%s\"\n", full_path);
                    }
#line 792
                    goto while_break___14;
                  }
                  while_break___14: /* CIL Label */ ;
                  }
                }
#line 792
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
#line 793
              return (full_path);
            }
          }
        }
      }
    }
#line 768
    path = p;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 797
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 797
    if (libast_debug_level >= 3U) {
      {
#line 797
      while (1) {
        while_continue___16: /* CIL Label */ ;
        {
#line 797
        tmp___21 = time((time_t *)((void *)0));
#line 797
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___21, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                797, "spifconf_find_file");
#line 797
        libast_dprintf("spifconf_find_file():  File \"%s\" not found in path.\n",
                       name);
        }
#line 797
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
#line 797
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 798
  return ((spif_charptr_t )((void *)0));
}
}
#line 801 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
FILE *spifconf_open_file(spif_charptr_t name___0 ) 
{ 
  FILE *fp ;
  spif_cmp_t ver ;
  spif_str_t ver_str ;
  spif_char_t buff[256] ;
  spif_char_t test[30] ;
  spif_charptr_t begin_ptr ;
  spif_charptr_t end_ptr ;
  spif_stridx_t testlen ;
  size_t tmp ;
  time_t tmp___0 ;
  spif_cmp_t tmp___1 ;
  spif_charptr_t tmp___2 ;
  spif_stridx_t tmp___3 ;
  spif_charptr_t tmp___4 ;
  spif_stridx_t tmp___5 ;
  time_t tmp___6 ;
  int aa ;
  int bb ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 811
    if (! ((unsigned long )name___0 != (unsigned long )((void *)0))) {
#line 811
      if (libast_debug_level >= 1U) {
        {
#line 811
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_open_file",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           811, "name != NULL");
        }
      } else {
        {
#line 811
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_open_file",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             811, "name != NULL");
        }
      }
#line 811
      return ((FILE *)((void *)0));
    }
#line 811
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  snprintf((char */* __restrict  */)((char *)(test)), sizeof(test), (char const   */* __restrict  */)"<%s-",
           libast_program_name);
#line 814
  tmp = strlen((char const   *)((char *)(test)));
#line 814
  testlen = (spif_stridx_t )tmp;
#line 818
  fp = fopen((char const   */* __restrict  */)((char *)name___0), (char const   */* __restrict  */)"rt");
  }
  {
#line 819
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 819
    if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
#line 819
      if (libast_debug_level >= 1U) {
        {
#line 819
        tmp___0 = time((time_t *)((void *)0));
#line 819
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                819, "spifconf_open_file");
#line 819
        libast_dprintf("REQUIRE failed:  %s\n", "fp != NULL");
        }
      }
#line 819
      return ((FILE *)((void *)0));
    }
#line 819
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 820
  fgets((char */* __restrict  */)((char *)(buff)), 256, (FILE */* __restrict  */)fp);
#line 821
  ver_str = spif_str_new_from_ptr(buff);
#line 824
  tmp___1 = spif_str_ncasecmp_with_ptr(ver_str, test, testlen);
  }
#line 824
  if (tmp___1) {
    {
#line 825
    libast_print_warning("%s exists but does not contain the proper magic string (<%s-%s>)\n",
                         name___0, libast_program_name, libast_program_version);
#line 827
    fclose(fp);
#line 828
    spif_str_del(ver_str);
    }
#line 829
    return ((FILE *)((void *)0));
  }
#line 833
  if ((unsigned long )((spif_obj_t )ver_str) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 833
    tmp___2 = (spif_charptr_t )"";
  } else {
#line 833
    tmp___2 = ver_str->s;
  }
  {
#line 833
  tmp___3 = spif_str_index(ver_str, (spif_char_t )'-');
#line 833
  begin_ptr = (spif_charptr_t )(((spif_charptr_t const   )tmp___2 + tmp___3) + 1);
  }
#line 834
  if ((unsigned long )((spif_obj_t )ver_str) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 834
    tmp___4 = (spif_charptr_t )"";
  } else {
#line 834
    tmp___4 = ver_str->s;
  }
  {
#line 834
  tmp___5 = spif_str_index(ver_str, (spif_char_t )'>');
#line 834
  end_ptr = (spif_charptr_t )((spif_charptr_t const   )tmp___4 + tmp___5);
  }
  {
#line 835
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 835
    if (libast_debug_level >= 3U) {
      {
#line 835
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 835
        tmp___6 = time((time_t *)((void *)0));
#line 835
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___6, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                836, "spifconf_open_file");
#line 835
        libast_dprintf("Begin pointer is %10p (%s), end pointer is %10p (%s), length is %d, buffer size is %d\n",
                       begin_ptr, begin_ptr, end_ptr, end_ptr, (int )(end_ptr - begin_ptr),
                       sizeof(buff));
        }
#line 835
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 835
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 837
  if ((unsigned long )((spif_ptr_t )end_ptr) == (unsigned long )((void *)0)) {
#line 837
    tmp___8 = 1;
  } else {
#line 837
    tmp___8 = 0;
  }
#line 837
  if (tmp___8) {
    {
#line 838
    spiftool_safe_strncpy(buff, (spif_charptr_t const   )begin_ptr, (spif_int32_t )sizeof(buff));
    }
  } else {
#line 840
    aa = (int )sizeof(buff);
#line 840
    bb = (int )((end_ptr - begin_ptr) + 1L);
#line 840
    if (aa < bb) {
#line 840
      tmp___7 = aa;
    } else {
#line 840
      tmp___7 = bb;
    }
    {
#line 840
    testlen = (spif_stridx_t )tmp___7;
#line 841
    spiftool_safe_strncpy(buff, (spif_charptr_t const   )begin_ptr, (spif_int32_t )testlen);
    }
  }
  {
#line 843
  ver = spiftool_version_compare(buff, libast_program_version);
  }
#line 844
  if ((int )ver == 1) {
    {
#line 845
    libast_print_warning("Config file is designed for a newer version of %s\n", libast_program_name);
    }
  }
  {
#line 848
  spif_str_del(ver_str);
  }
#line 849
  return (fp);
}
}
#line 853 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
void spifconf_parse_line(FILE *fp , spif_charptr_t buff ) 
{ 
  register unsigned long i ;
  unsigned char id ;
  void *state ;
  spif_charptr_t name___0 ;
  int tmp ;
  int tmp___0 ;
  time_t tmp___1 ;
  spif_charptr_t path ;
  FILE *fp___0 ;
  int *tmp___2 ;
  char *tmp___3 ;
  spif_char_t cmd[4096] ;
  spif_char_t fname[4096] ;
  spif_charptr_t outfile ;
  int fd ;
  FILE *fp___1 ;
  char *tmp___4 ;
  spif_charptr_t tmp___5 ;
  spif_charptr_t tmp___6 ;
  int tmp___7 ;
  spif_charptr_t tmp___8 ;
  int tmp___9 ;
  spif_charptr_t name___1 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 856
  i = 0UL;
#line 858
  state = (void *)0;
  {
#line 860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 860
    if (! ((unsigned long )buff != (unsigned long )((void *)0))) {
#line 860
      if (libast_debug_level >= 1U) {
        {
#line 860
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_parse_line",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           860, "buff != NULL");
        }
      } else {
        {
#line 860
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifconf_parse_line",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             860, "buff != NULL");
        }
#line 860
        return;
      }
    }
#line 860
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 862
  if (! *buff) {
#line 862
    goto _L;
  } else
#line 862
  if ((int )*buff == 10) {
#line 862
    goto _L;
  } else
#line 862
  if ((int )*buff == 35) {
#line 862
    goto _L;
  } else
#line 862
  if ((int )*buff == 60) {
    _L: /* CIL Label */ 
    {
#line 863
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 863
      if (! fp) {
#line 863
        fstate_idx = (unsigned char )((int )fstate_idx - 1);
        {
#line 863
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 863
          if (ctx_state_idx) {
            {
#line 863
            state = (*((context + id)->handler))((spif_charptr_t )"\002", (ctx_state + ctx_state_idx)->state);
#line 863
            (ctx_state + ctx_state_idx)->state = (void *)0;
#line 863
            ctx_state_idx = (unsigned char )((int )ctx_state_idx - 1);
#line 863
            id = (ctx_state + ctx_state_idx)->ctx_id;
#line 863
            (ctx_state + ctx_state_idx)->state = state;
            }
            {
#line 863
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 863
              (fstate + fstate_idx)->flags = (spif_uint8_t )((int )(fstate + fstate_idx)->flags & -2);
#line 863
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
#line 863
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 863
      return;
#line 863
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 865
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 866
    spifconf_register_fstate((FILE *)((void *)0), (spif_charptr_t )"<argv>", (spif_charptr_t )((void *)0),
                             0UL, (unsigned char)0);
    }
    {
#line 867
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 867
      name___0 = spiftool_get_word(1UL, (spif_charptr_t const   )buff);
      }
      {
#line 867
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 867
        i = 0UL;
        {
#line 867
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 867
          if (! (i <= (unsigned long )ctx_idx)) {
#line 867
            goto while_break___5;
          }
          {
#line 867
          tmp = strcasecmp((char const   *)((char *)name___0), (char const   *)((char *)(context + i)->name));
          }
#line 867
          if (! tmp) {
#line 867
            id = (unsigned char )i;
#line 867
            goto while_break___5;
          }
#line 867
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 867
        if (i > (unsigned long )ctx_idx) {
          {
#line 867
          libast_print_error("Parsing file %s, line %lu:  No such context \"%s\"\n",
                             (fstate + fstate_idx)->path, (fstate + fstate_idx)->line,
                             name___0);
#line 867
          id = (unsigned char)0;
          }
        }
#line 867
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 867
      spifconf_register_context_state(id);
      }
#line 867
      if (ctx_state_idx) {
#line 867
        tmp___0 = (int )ctx_state_idx - 1;
      } else {
#line 867
        tmp___0 = 0;
      }
      {
#line 867
      state = (*((context + id)->handler))((spif_charptr_t )"\001", (ctx_state + tmp___0)->state);
#line 867
      (ctx_state + ctx_state_idx)->state = state;
      }
      {
#line 867
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 867
        free((void *)name___0);
#line 867
        name___0 = (spif_charptr_t )((void *)0);
        }
#line 867
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 867
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 868
    buff = spiftool_get_pword(2UL, (spif_charptr_t const   )buff);
    }
#line 869
    if (! buff) {
      {
#line 870
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 870
        if (! fp) {
#line 870
          fstate_idx = (unsigned char )((int )fstate_idx - 1);
          {
#line 870
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 870
            if (ctx_state_idx) {
              {
#line 870
              state = (*((context + id)->handler))((spif_charptr_t )"\002", (ctx_state + ctx_state_idx)->state);
#line 870
              (ctx_state + ctx_state_idx)->state = (void *)0;
#line 870
              ctx_state_idx = (unsigned char )((int )ctx_state_idx - 1);
#line 870
              id = (ctx_state + ctx_state_idx)->ctx_id;
#line 870
              (ctx_state + ctx_state_idx)->state = state;
              }
              {
#line 870
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 870
                (fstate + fstate_idx)->flags = (spif_uint8_t )((int )(fstate + fstate_idx)->flags & -2);
#line 870
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
            }
#line 870
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
#line 870
        return;
#line 870
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  {
#line 873
  id = (ctx_state + ctx_state_idx)->ctx_id;
#line 874
  spiftool_chomp(buff);
  }
  {
#line 875
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 875
    if (libast_debug_level >= 3U) {
      {
#line 875
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 875
        tmp___1 = time((time_t *)((void *)0));
#line 875
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                875, "spifconf_parse_line");
#line 875
        libast_dprintf("Parsing line #%lu of file %s\n", (fstate + fstate_idx)->line,
                       (fstate + fstate_idx)->path);
        }
#line 875
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
#line 875
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 878
  if ((int )*buff == 0) {
#line 878
    goto case_0;
  }
#line 878
  if ((int )*buff == 35) {
#line 878
    goto case_0;
  }
#line 880
  if ((int )*buff == 37) {
#line 880
    goto case_37;
  }
#line 922
  if ((int )*buff == 98) {
#line 922
    goto case_98;
  }
#line 931
  if ((int )*buff == 101) {
#line 931
    goto case_101;
  }
#line 937
  goto switch_default;
  case_0: /* CIL Label */ 
  case_35: /* CIL Label */ 
  {
#line 879
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 879
    if (! fp) {
#line 879
      fstate_idx = (unsigned char )((int )fstate_idx - 1);
      {
#line 879
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 879
        if (ctx_state_idx) {
          {
#line 879
          state = (*((context + id)->handler))((spif_charptr_t )"\002", (ctx_state + ctx_state_idx)->state);
#line 879
          (ctx_state + ctx_state_idx)->state = (void *)0;
#line 879
          ctx_state_idx = (unsigned char )((int )ctx_state_idx - 1);
#line 879
          id = (ctx_state + ctx_state_idx)->ctx_id;
#line 879
          (ctx_state + ctx_state_idx)->state = state;
          }
          {
#line 879
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 879
            (fstate + fstate_idx)->flags = (spif_uint8_t )((int )(fstate + fstate_idx)->flags & -2);
#line 879
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
#line 879
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 879
    return;
#line 879
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  case_37: /* CIL Label */ 
  {
#line 881
  tmp___8 = spiftool_get_pword(1UL, (spif_charptr_t const   )(buff + 1));
#line 881
  tmp___9 = strncasecmp((char const   *)((char *)tmp___8), "include ", sizeof("include ") - 1UL);
  }
#line 881
  if (tmp___9) {
    {
#line 893
    tmp___6 = spiftool_get_pword(1UL, (spif_charptr_t const   )(buff + 1));
#line 893
    tmp___7 = strncasecmp((char const   *)((char *)tmp___6), "preproc ", sizeof("preproc ") - 1UL);
    }
#line 893
    if (tmp___7) {
#line 916
      if ((int )(fstate + fstate_idx)->flags & 1) {
        {
#line 917
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 917
          if (! fp) {
#line 917
            fstate_idx = (unsigned char )((int )fstate_idx - 1);
            {
#line 917
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 917
              if (ctx_state_idx) {
                {
#line 917
                state = (*((context + id)->handler))((spif_charptr_t )"\002", (ctx_state + ctx_state_idx)->state);
#line 917
                (ctx_state + ctx_state_idx)->state = (void *)0;
#line 917
                ctx_state_idx = (unsigned char )((int )ctx_state_idx - 1);
#line 917
                id = (ctx_state + ctx_state_idx)->ctx_id;
#line 917
                (ctx_state + ctx_state_idx)->state = state;
                }
                {
#line 917
                while (1) {
                  while_continue___17: /* CIL Label */ ;
#line 917
                  (fstate + fstate_idx)->flags = (spif_uint8_t )((int )(fstate + fstate_idx)->flags & -2);
#line 917
                  goto while_break___17;
                }
                while_break___17: /* CIL Label */ ;
                }
              }
#line 917
              goto while_break___16;
            }
            while_break___16: /* CIL Label */ ;
            }
          }
#line 917
          return;
#line 917
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
      {
#line 919
      spifconf_shell_expand(buff);
      }
    } else {
#line 899
      if ((int )(fstate + fstate_idx)->flags & 2) {
        {
#line 900
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 900
          if (! fp___1) {
#line 900
            fstate_idx = (unsigned char )((int )fstate_idx - 1);
            {
#line 900
            while (1) {
              while_continue___19: /* CIL Label */ ;
#line 900
              if (ctx_state_idx) {
                {
#line 900
                state = (*((context + id)->handler))((spif_charptr_t )"\002", (ctx_state + ctx_state_idx)->state);
#line 900
                (ctx_state + ctx_state_idx)->state = (void *)0;
#line 900
                ctx_state_idx = (unsigned char )((int )ctx_state_idx - 1);
#line 900
                id = (ctx_state + ctx_state_idx)->ctx_id;
#line 900
                (ctx_state + ctx_state_idx)->state = state;
                }
                {
#line 900
                while (1) {
                  while_continue___20: /* CIL Label */ ;
#line 900
                  (fstate + fstate_idx)->flags = (spif_uint8_t )((int )(fstate + fstate_idx)->flags & -2);
#line 900
                  goto while_break___20;
                }
                while_break___20: /* CIL Label */ ;
                }
              }
#line 900
              goto while_break___19;
            }
            while_break___19: /* CIL Label */ ;
            }
          }
#line 900
          return;
#line 900
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
      {
#line 902
      strcpy((char */* __restrict  */)((char *)(fname)), (char const   */* __restrict  */)"Eterm-preproc-");
#line 903
      fd = spiftool_temp_file(fname, (size_t )4096);
#line 904
      tmp___4 = strdup((char const   *)((char *)(fname)));
#line 904
      outfile = (spif_charptr_t )tmp___4;
#line 905
      tmp___5 = spiftool_get_pword(2UL, (spif_charptr_t const   )buff);
#line 905
      snprintf((char */* __restrict  */)((char *)(cmd)), (size_t )4096, (char const   */* __restrict  */)"%s < %s > %s",
               tmp___5, (fstate + fstate_idx)->path, fname);
#line 907
      system((char const   *)((char *)(cmd)));
#line 908
      fp___1 = fdopen(fd, "rt");
      }
#line 909
      if ((unsigned long )fp___1 != (unsigned long )((void *)0)) {
        {
#line 910
        fclose((fstate + fstate_idx)->fp);
#line 911
        (fstate + fstate_idx)->fp = fp___1;
        }
        {
#line 912
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 912
          (fstate + fstate_idx)->flags = (spif_uint8_t )((int )(fstate + fstate_idx)->flags | 2);
#line 912
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 913
        (fstate + fstate_idx)->outfile = outfile;
      }
    }
  } else {
    {
#line 885
    spifconf_shell_expand(buff);
#line 886
    path = spiftool_get_word(2UL, (spif_charptr_t const   )(buff + 1));
#line 887
    fp___0 = spifconf_open_file(path);
    }
#line 887
    if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
      {
#line 888
      tmp___2 = __errno_location();
#line 888
      tmp___3 = strerror(*tmp___2);
#line 888
      libast_print_error("Parsing file %s, line %lu:  Unable to locate %%included config file %s (%s), continuing\n",
                         (fstate + fstate_idx)->path, (fstate + fstate_idx)->line,
                         path, tmp___3);
      }
    } else {
      {
#line 891
      spifconf_register_fstate(fp___0, path, (spif_charptr_t )((void *)0), 1UL, (unsigned char)0);
      }
    }
  }
#line 921
  goto switch_break;
  case_98: /* CIL Label */ 
#line 923
  if ((int )(fstate + fstate_idx)->flags & 1) {
    {
#line 924
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 924
      if (! fp) {
#line 924
        fstate_idx = (unsigned char )((int )fstate_idx - 1);
        {
#line 924
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 924
          if (ctx_state_idx) {
            {
#line 924
            state = (*((context + id)->handler))((spif_charptr_t )"\002", (ctx_state + ctx_state_idx)->state);
#line 924
            (ctx_state + ctx_state_idx)->state = (void *)0;
#line 924
            ctx_state_idx = (unsigned char )((int )ctx_state_idx - 1);
#line 924
            id = (ctx_state + ctx_state_idx)->ctx_id;
#line 924
            (ctx_state + ctx_state_idx)->state = state;
            }
            {
#line 924
            while (1) {
              while_continue___24: /* CIL Label */ ;
#line 924
              (fstate + fstate_idx)->flags = (spif_uint8_t )((int )(fstate + fstate_idx)->flags & -2);
#line 924
              goto while_break___24;
            }
            while_break___24: /* CIL Label */ ;
            }
          }
#line 924
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
#line 924
      return;
#line 924
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
  }
  {
#line 926
  tmp___12 = strncasecmp((char const   *)((char *)buff), "begin ", sizeof("begin ") - 1UL);
  }
#line 926
  if (! tmp___12) {
    {
#line 927
    while (1) {
      while_continue___25: /* CIL Label */ ;
      {
#line 927
      name___1 = spiftool_get_word(2UL, (spif_charptr_t const   )buff);
      }
      {
#line 927
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 927
        i = 0UL;
        {
#line 927
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 927
          if (! (i <= (unsigned long )ctx_idx)) {
#line 927
            goto while_break___27;
          }
          {
#line 927
          tmp___10 = strcasecmp((char const   *)((char *)name___1), (char const   *)((char *)(context + i)->name));
          }
#line 927
          if (! tmp___10) {
#line 927
            id = (unsigned char )i;
#line 927
            goto while_break___27;
          }
#line 927
          i ++;
        }
        while_break___27: /* CIL Label */ ;
        }
#line 927
        if (i > (unsigned long )ctx_idx) {
          {
#line 927
          libast_print_error("Parsing file %s, line %lu:  No such context \"%s\"\n",
                             (fstate + fstate_idx)->path, (fstate + fstate_idx)->line,
                             name___1);
#line 927
          id = (unsigned char)0;
          }
        }
#line 927
        goto while_break___26;
      }
      while_break___26: /* CIL Label */ ;
      }
      {
#line 927
      spifconf_register_context_state(id);
      }
#line 927
      if (ctx_state_idx) {
#line 927
        tmp___11 = (int )ctx_state_idx - 1;
      } else {
#line 927
        tmp___11 = 0;
      }
      {
#line 927
      state = (*((context + id)->handler))((spif_charptr_t )"\001", (ctx_state + tmp___11)->state);
#line 927
      (ctx_state + ctx_state_idx)->state = state;
      }
      {
#line 927
      while (1) {
        while_continue___28: /* CIL Label */ ;
        {
#line 927
        free((void *)name___1);
#line 927
        name___1 = (spif_charptr_t )((void *)0);
        }
#line 927
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
#line 927
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
#line 928
    goto switch_break;
  }
  case_101: /* CIL Label */ 
  {
#line 932
  tmp___13 = strncasecmp((char const   *)((char *)buff), "end ", sizeof("end ") - 1UL);
  }
#line 932
  if (tmp___13) {
    {
#line 932
    tmp___14 = strcasecmp((char const   *)((char *)buff), "end");
    }
#line 932
    if (! tmp___14) {
      _L___0: /* CIL Label */ 
      {
#line 933
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 933
        if (ctx_state_idx) {
          {
#line 933
          state = (*((context + id)->handler))((spif_charptr_t )"\002", (ctx_state + ctx_state_idx)->state);
#line 933
          (ctx_state + ctx_state_idx)->state = (void *)0;
#line 933
          ctx_state_idx = (unsigned char )((int )ctx_state_idx - 1);
#line 933
          id = (ctx_state + ctx_state_idx)->ctx_id;
#line 933
          (ctx_state + ctx_state_idx)->state = state;
          }
          {
#line 933
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 933
            (fstate + fstate_idx)->flags = (spif_uint8_t )((int )(fstate + fstate_idx)->flags & -2);
#line 933
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
        }
#line 933
        goto while_break___29;
      }
      while_break___29: /* CIL Label */ ;
      }
#line 934
      goto switch_break;
    }
  } else {
#line 932
    goto _L___0;
  }
  switch_default: /* CIL Label */ 
#line 938
  if ((int )(fstate + fstate_idx)->flags & 1) {
    {
#line 939
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 939
      if (! fp) {
#line 939
        fstate_idx = (unsigned char )((int )fstate_idx - 1);
        {
#line 939
        while (1) {
          while_continue___32: /* CIL Label */ ;
#line 939
          if (ctx_state_idx) {
            {
#line 939
            state = (*((context + id)->handler))((spif_charptr_t )"\002", (ctx_state + ctx_state_idx)->state);
#line 939
            (ctx_state + ctx_state_idx)->state = (void *)0;
#line 939
            ctx_state_idx = (unsigned char )((int )ctx_state_idx - 1);
#line 939
            id = (ctx_state + ctx_state_idx)->ctx_id;
#line 939
            (ctx_state + ctx_state_idx)->state = state;
            }
            {
#line 939
            while (1) {
              while_continue___33: /* CIL Label */ ;
#line 939
              (fstate + fstate_idx)->flags = (spif_uint8_t )((int )(fstate + fstate_idx)->flags & -2);
#line 939
              goto while_break___33;
            }
            while_break___33: /* CIL Label */ ;
            }
          }
#line 939
          goto while_break___32;
        }
        while_break___32: /* CIL Label */ ;
        }
      }
#line 939
      return;
#line 939
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
  }
  {
#line 941
  spifconf_shell_expand(buff);
#line 942
  (ctx_state + ctx_state_idx)->state = (*((context + id)->handler))(buff, (ctx_state + ctx_state_idx)->state);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 944
  while (1) {
    while_continue___34: /* CIL Label */ ;
#line 944
    if (! fp) {
#line 944
      fstate_idx = (unsigned char )((int )fstate_idx - 1);
      {
#line 944
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 944
        if (ctx_state_idx) {
          {
#line 944
          state = (*((context + id)->handler))((spif_charptr_t )"\002", (ctx_state + ctx_state_idx)->state);
#line 944
          (ctx_state + ctx_state_idx)->state = (void *)0;
#line 944
          ctx_state_idx = (unsigned char )((int )ctx_state_idx - 1);
#line 944
          id = (ctx_state + ctx_state_idx)->ctx_id;
#line 944
          (ctx_state + ctx_state_idx)->state = state;
          }
          {
#line 944
          while (1) {
            while_continue___36: /* CIL Label */ ;
#line 944
            (fstate + fstate_idx)->flags = (spif_uint8_t )((int )(fstate + fstate_idx)->flags & -2);
#line 944
            goto while_break___36;
          }
          while_break___36: /* CIL Label */ ;
          }
        }
#line 944
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
    }
#line 944
    return;
#line 944
    goto while_break___34;
  }
  while_break___34: /* CIL Label */ ;
  }
#line 945
  return;
}
}
#line 949 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
spif_charptr_t spifconf_parse(spif_charptr_t conf_name , spif_charptr_t const   dir ,
                              spif_charptr_t const   path ) 
{ 
  FILE *fp ;
  spif_charptr_t name___0 ;
  spif_charptr_t p ;
  spif_char_t buff[20480] ;
  spif_char_t orig_dir[4096] ;
  time_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  time_t tmp___5 ;
  char *tmp___6 ;

  {
#line 953
  name___0 = (spif_charptr_t )((void *)0);
#line 953
  p = (spif_charptr_t )".";
  {
#line 956
  while (1) {
    while_continue: /* CIL Label */ ;
#line 956
    if (! ((unsigned long )conf_name != (unsigned long )((void *)0))) {
#line 956
      if (libast_debug_level >= 1U) {
        {
#line 956
        tmp = time((time_t *)((void *)0));
#line 956
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                956, "spifconf_parse");
#line 956
        libast_dprintf("REQUIRE failed:  %s\n", "conf_name != NULL");
        }
      }
#line 956
      return ((spif_charptr_t )0);
    }
#line 956
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 958
  orig_dir[0] = (spif_char_t )0;
#line 959
  if (path) {
    {
#line 960
    name___0 = spifconf_find_file((spif_charptr_t const   )conf_name, dir, path);
    }
#line 960
    if ((unsigned long )name___0 != (unsigned long )((void *)0)) {
      {
#line 961
      tmp___0 = strrchr((char const   *)((char *)name___0), '/');
#line 961
      p = (spif_charptr_t )tmp___0;
      }
#line 961
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 962
        getcwd((char *)(orig_dir), (size_t )4096);
#line 963
        *p = (spif_char_t )0;
#line 964
        p = name___0;
#line 965
        chdir((char const   *)((char *)name___0));
        }
      } else {
#line 967
        p = (spif_charptr_t )".";
      }
    } else {
#line 970
      return ((spif_charptr_t )((void *)0));
    }
  }
  {
#line 973
  fp = spifconf_open_file(conf_name);
  }
#line 973
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 974
    return ((spif_charptr_t )((void *)0));
  }
  {
#line 977
  spifconf_register_fstate(fp, conf_name, (spif_charptr_t )((void *)0), 1UL, (unsigned char)0);
  }
  {
#line 979
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 979
    if (! ((int )fstate_idx > 0)) {
#line 979
      goto while_break___0;
    }
    {
#line 980
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 980
      tmp___4 = fgets((char */* __restrict  */)((char *)(buff)), 20480, (FILE */* __restrict  */)(fstate + fstate_idx)->fp);
      }
#line 980
      if (! tmp___4) {
#line 980
        goto while_break___1;
      }
      {
#line 981
      ((fstate + fstate_idx)->line) ++;
#line 982
      tmp___3 = strchr((char const   *)((char *)(buff)), '\n');
      }
#line 982
      if (! tmp___3) {
        {
#line 983
        libast_print_error("Parse error in file %s, line %lu:  line too long\n", (fstate + fstate_idx)->path,
                           (fstate + fstate_idx)->line);
        }
        {
#line 985
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 985
          tmp___1 = fgets((char */* __restrict  */)((char *)(buff)), 20480, (FILE */* __restrict  */)(fstate + fstate_idx)->fp);
          }
#line 985
          if (tmp___1) {
            {
#line 985
            tmp___2 = strrchr((char const   *)((char *)(buff)), '\n');
            }
#line 985
            if (tmp___2) {
#line 985
              goto while_break___2;
            }
          } else {
#line 985
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 987
        goto __Cont;
      }
      {
#line 989
      spifconf_parse_line(fp, buff);
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 991
    fclose((fstate + fstate_idx)->fp);
    }
#line 992
    if ((int )(fstate + fstate_idx)->flags & 2) {
      {
#line 993
      remove((char const   *)((char *)(fstate + fstate_idx)->outfile));
      }
      {
#line 994
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 994
        free((void *)(fstate + fstate_idx)->outfile);
#line 994
        (fstate + fstate_idx)->outfile = (spif_charptr_t )((void *)0);
        }
#line 994
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 996
    fstate_idx = (unsigned char )((int )fstate_idx - 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 998
  if (orig_dir[0]) {
    {
#line 999
    chdir((char const   *)((char *)(orig_dir)));
    }
  }
  {
#line 1001
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1001
    if (libast_debug_level >= 3U) {
      {
#line 1001
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 1001
        tmp___5 = time((time_t *)((void *)0));
#line 1001
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___5, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                1001, "spifconf_parse");
#line 1001
        libast_dprintf("Returning \"%s\"\n", p);
        }
#line 1001
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1001
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1002
  tmp___6 = strdup((char const   *)((char *)p));
  }
#line 1002
  return ((spif_charptr_t )tmp___6);
}
}
#line 1005 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c"
static void *parse_null(spif_charptr_t buff , void *state ) 
{ 
  int tmp ;

  {
  {
#line 1008
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1008
    if ((unsigned long )((spif_ptr_t )buff) == (unsigned long )((void *)0)) {
#line 1008
      tmp = 1;
    } else {
#line 1008
      tmp = 0;
    }
#line 1008
    if (tmp) {
#line 1008
      if (libast_debug_level >= 1U) {
        {
#line 1008
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "parse_null",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                           1008, "!SPIF_PTR_ISNULL(buff)");
        }
      } else {
        {
#line 1008
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "parse_null",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/conf.c",
                             1008, "!SPIF_PTR_ISNULL(buff)");
        }
      }
#line 1008
      return ((void *)0);
    }
#line 1008
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1009
  if ((int )*buff == 1) {
#line 1010
    return ((void *)0);
  } else
#line 1011
  if ((int )*buff == 2) {
#line 1012
    return ((void *)0);
  } else {
    {
#line 1014
    libast_print_error("Parse error in file %s, line %lu:  Not allowed in \"null\" context:  \"%s\"\n",
                       (fstate + fstate_idx)->path, (fstate + fstate_idx)->line, buff);
    }
#line 1016
    return (state);
  }
}
}
#line 2724 "../include/libast.h"
spif_bool_t spiftool_safe_strncat(spif_charptr_t dest , spif_charptr_t const   src ,
                                  spif_int32_t size ) ;
#line 2725
spif_charptr_t spiftool_substr(spif_charptr_t const   str , spif_int32_t idx , spif_int32_t cnt ) ;
#line 2727
spif_bool_t spiftool_regexp_match(spif_charptr_t const   str , spif_charptr_t const   pattern ) ;
#line 2728
spif_bool_t spiftool_regexp_match_r(spif_charptr_t const   str , spif_charptr_t const   pattern ,
                                    regex_t **rexp___0 ) ;
#line 2730
spif_charptr_t *spiftool_split(spif_charptr_t const   delim , spif_charptr_t const   str ) ;
#line 2731
spif_charptr_t *spiftool_split_regexp(spif_charptr_t const   regexp , spif_charptr_t const   str ) ;
#line 2732
spif_charptr_t spiftool_join(spif_charptr_t sep , spif_charptr_t *slist ) ;
#line 2737
spif_charptr_t spiftool_downcase_str(spif_charptr_t str ) ;
#line 2738
spif_charptr_t spiftool_upcase_str(spif_charptr_t str ) ;
#line 2741
void spiftool_hex_dump(void *buff , size_t count ) ;
#line 2760
char *strcasechr(char const   *haystack , char const   needle ) ;
#line 2763
char *strcasepbrk(char const   *haystack , char const   *needle ) ;
#line 121 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
char *strcasechr(char const   *haystack , char const   needle ) 
{ 
  register char const   *t ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )haystack != (unsigned long )((void *)0))) {
#line 126
      if (libast_debug_level >= 1U) {
        {
#line 126
        tmp = time((time_t *)((void *)0));
#line 126
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                126, "strcasechr");
#line 126
        libast_dprintf("REQUIRE failed:  %s\n", "haystack != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 126
      return ((char *)((void *)0));
    }
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  t = haystack;
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 127
    if (t) {
#line 127
      if (! *t) {
#line 127
        goto while_break___0;
      }
    } else {
#line 127
      goto while_break___0;
    }
    {
#line 128
    tmp___0 = tolower((int )*t);
#line 128
    tmp___1 = tolower((int )needle);
    }
#line 128
    if (tmp___0 == tmp___1) {
#line 129
      return ((char *)t);
    }
#line 127
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 132
  return ((char *)((void *)0));
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
char *strcasepbrk(char const   *haystack , char const   *needle ) 
{ 
  register char const   *t ;
  time_t tmp ;
  time_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! ((unsigned long )needle != (unsigned long )((void *)0))) {
#line 142
      if (libast_debug_level >= 1U) {
        {
#line 142
        tmp = time((time_t *)((void *)0));
#line 142
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                142, "strcasepbrk");
#line 142
        libast_dprintf("REQUIRE failed:  %s\n", "needle != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 142
      return ((char *)((void *)0));
    }
#line 142
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 143
    if (! ((unsigned long )haystack != (unsigned long )((void *)0))) {
#line 143
      if (libast_debug_level >= 1U) {
        {
#line 143
        tmp___0 = time((time_t *)((void *)0));
#line 143
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                143, "strcasepbrk");
#line 143
        libast_dprintf("REQUIRE failed:  %s\n", "haystack != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 143
      return ((char *)((void *)0));
    }
#line 143
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 144
  t = haystack;
  {
#line 144
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 144
    if (t) {
#line 144
      if (! *t) {
#line 144
        goto while_break___1;
      }
    } else {
#line 144
      goto while_break___1;
    }
    {
#line 145
    tmp___1 = strcasechr(needle, *t);
    }
#line 145
    if (tmp___1) {
#line 146
      return ((char *)t);
    }
#line 144
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 149
  return ((char *)((void *)0));
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
char *strrev(char *str ) 
{ 
  register int i ;
  register int j ;
  time_t tmp ;
  size_t tmp___0 ;
  char __tmp ;

  {
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 159
      if (libast_debug_level >= 1U) {
        {
#line 159
        tmp = time((time_t *)((void *)0));
#line 159
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                159, "strrev");
#line 159
        libast_dprintf("REQUIRE failed:  %s\n", "str != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 159
      return ((char *)((void *)0));
    }
#line 159
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  tmp___0 = strlen((char const   *)str);
#line 160
  i = (int )tmp___0;
#line 161
  j = 0;
#line 161
  i --;
  }
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (! (i > j)) {
#line 161
      goto while_break___0;
    }
#line 162
    __tmp = *(str + j);
#line 162
    *(str + j) = *(str + i);
#line 162
    *(str + i) = __tmp;
#line 161
    i --;
#line 161
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 164
  return (str);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_bool_t spiftool_safe_strncpy(spif_charptr_t dest , spif_charptr_t const   src ,
                                  spif_int32_t size ) 
{ 
  spif_char_t c ;
  spif_charptr_t s ;
  spif_charptr_t pbuff ;
  spif_charptr_t max_pbuff ;
  int tmp ;
  time_t tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  int tmp___3 ;

  {
#line 205
  s = (spif_charptr_t )src;
#line 205
  pbuff = dest;
#line 206
  max_pbuff = (dest + size) - 1;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if ((unsigned long )((spif_ptr_t )dest) == (unsigned long )((void *)0)) {
#line 208
      tmp = 1;
    } else {
#line 208
      tmp = 0;
    }
#line 208
    if (tmp) {
#line 208
      if (libast_debug_level >= 1U) {
        {
#line 208
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_safe_strncpy",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           208, "!SPIF_PTR_ISNULL(dest)");
        }
      } else {
        {
#line 208
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_safe_strncpy",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             208, "!SPIF_PTR_ISNULL(dest)");
        }
      }
#line 208
      return ((spif_bool_t )0);
    }
#line 208
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 209
    if ((unsigned long )((spif_ptr_t )src) == (unsigned long )((void *)0)) {
#line 209
      tmp___1 = 1;
    } else {
#line 209
      tmp___1 = 0;
    }
#line 209
    if (tmp___1) {
#line 209
      if (libast_debug_level >= 1U) {
        {
#line 209
        tmp___0 = time((time_t *)((void *)0));
#line 209
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                209, "spiftool_safe_strncpy");
#line 209
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_PTR_ISNULL(src)");
        }
      }
#line 209
      return ((spif_bool_t )0);
    }
#line 209
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 210
    if (! (size > 0)) {
#line 210
      if (libast_debug_level >= 1U) {
        {
#line 210
        tmp___2 = time((time_t *)((void *)0));
#line 210
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___2, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                210, "spiftool_safe_strncpy");
#line 210
        libast_dprintf("REQUIRE failed:  %s\n", "size > 0");
        }
      }
#line 210
      return ((spif_bool_t )0);
    }
#line 210
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 212
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 212
    c = *s;
#line 212
    if (c) {
#line 212
      if (! ((unsigned long )pbuff < (unsigned long )max_pbuff)) {
#line 212
        goto while_break___2;
      }
    } else {
#line 212
      goto while_break___2;
    }
#line 213
    *pbuff = c;
#line 212
    s ++;
#line 212
    pbuff ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 215
  *pbuff = (spif_char_t )0;
#line 216
  if ((int )c == 0) {
#line 216
    tmp___3 = 1;
  } else {
#line 216
    tmp___3 = 0;
  }
#line 216
  return ((spif_bool_t )tmp___3);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_bool_t spiftool_safe_strncat(spif_charptr_t dest , spif_charptr_t const   src ,
                                  spif_int32_t size ) 
{ 
  spif_int32_t len ;
  int tmp ;
  time_t tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  size_t tmp___3 ;
  spif_bool_t tmp___4 ;

  {
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if ((unsigned long )((spif_ptr_t )dest) == (unsigned long )((void *)0)) {
#line 227
      tmp = 1;
    } else {
#line 227
      tmp = 0;
    }
#line 227
    if (tmp) {
#line 227
      if (libast_debug_level >= 1U) {
        {
#line 227
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_safe_strncat",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           227, "!SPIF_PTR_ISNULL(dest)");
        }
      } else {
        {
#line 227
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_safe_strncat",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             227, "!SPIF_PTR_ISNULL(dest)");
        }
      }
#line 227
      return ((spif_bool_t )0);
    }
#line 227
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 228
    if ((unsigned long )((spif_ptr_t )src) == (unsigned long )((void *)0)) {
#line 228
      tmp___1 = 1;
    } else {
#line 228
      tmp___1 = 0;
    }
#line 228
    if (tmp___1) {
#line 228
      if (libast_debug_level >= 1U) {
        {
#line 228
        tmp___0 = time((time_t *)((void *)0));
#line 228
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                228, "spiftool_safe_strncat");
#line 228
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_PTR_ISNULL(src)");
        }
      }
#line 228
      return ((spif_bool_t )0);
    }
#line 228
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 229
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 229
    if (! (size > 0)) {
#line 229
      if (libast_debug_level >= 1U) {
        {
#line 229
        tmp___2 = time((time_t *)((void *)0));
#line 229
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___2, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                229, "spiftool_safe_strncat");
#line 229
        libast_dprintf("REQUIRE failed:  %s\n", "size > 0");
        }
      }
#line 229
      return ((spif_bool_t )0);
    }
#line 229
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 231
  tmp___3 = strnlen((char const   *)((char *)dest), (size_t )size);
#line 231
  len = (spif_int32_t )tmp___3;
  }
#line 232
  if (len >= size) {
#line 233
    return ((spif_bool_t )0);
  } else {
    {
#line 235
    tmp___4 = spiftool_safe_strncpy(dest + len, src, size - len);
    }
#line 235
    return (tmp___4);
  }
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_charptr_t spiftool_substr(spif_charptr_t const   str , spif_int32_t idx , spif_int32_t cnt ) 
{ 
  spif_charptr_t newstr ;
  spif_uint32_t start_pos ;
  spif_uint32_t char_count ;
  spif_uint32_t len ;
  time_t tmp ;
  size_t tmp___0 ;
  time_t tmp___1 ;
  spif_uint32_t o ;
  void *tmp___2 ;

  {
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )str != (unsigned long )((spif_charptr_t )((void *)0)))) {
#line 249
      if (libast_debug_level >= 1U) {
        {
#line 249
        tmp = time((time_t *)((void *)0));
#line 249
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                249, "spiftool_substr");
#line 249
        libast_dprintf("REQUIRE failed:  %s\n", "str != SPIF_NULL_TYPE(charptr)");
        }
      }
#line 249
      return ((spif_charptr_t )((void *)0));
    }
#line 249
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  tmp___0 = strlen((char const   *)((char *)str));
#line 251
  len = (spif_uint32_t )tmp___0;
  }
#line 253
  if (idx < 0) {
#line 254
    start_pos = len + (spif_uint32_t )idx;
  } else {
#line 256
    start_pos = (spif_uint32_t )idx;
  }
  {
#line 258
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 258
    if (! (start_pos < len)) {
#line 258
      if (libast_debug_level >= 1U) {
        {
#line 258
        tmp___1 = time((time_t *)((void *)0));
#line 258
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                258, "spiftool_substr");
#line 258
        libast_dprintf("REQUIRE failed:  %s\n", "start_pos < len");
        }
      }
#line 258
      return ((spif_charptr_t )((void *)0));
    }
#line 258
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 260
  if (cnt <= 0) {
#line 261
    char_count = (len - start_pos) + (spif_uint32_t )cnt;
  } else {
#line 263
    char_count = (spif_uint32_t )cnt;
  }
#line 265
  o = len - start_pos;
#line 265
  if (char_count > o) {
#line 265
    char_count = o;
  }
  {
#line 267
  tmp___2 = malloc((size_t )(char_count + 1U));
#line 267
  newstr = (spif_charptr_t )tmp___2;
#line 268
  memcpy((void */* __restrict  */)newstr, (void const   */* __restrict  */)(str + start_pos),
         (size_t )char_count);
#line 269
  *(newstr + char_count) = (spif_char_t )0;
  }
#line 270
  return (newstr);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
static regex_t *rexp  =    (regex_t *)((void *)0);
#line 277 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_bool_t spiftool_regexp_match(spif_charptr_t const   str , spif_charptr_t const   pattern ) 
{ 
  register int result ;
  char errbuf[256] ;
  void *tmp ;
  int tmp___0 ;

  {
#line 284
  if (! str) {
    {
#line 286
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 286
      free((void *)rexp);
#line 286
      rexp = (regex_t *)((void *)0);
      }
#line 286
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 287
    return ((spif_bool_t )0);
  } else
#line 288
  if (! rexp) {
    {
#line 290
    tmp = malloc(sizeof(regex_t ));
#line 290
    rexp = (regex_t *)tmp;
    }
  }
#line 293
  if (pattern) {
    {
#line 295
    result = regcomp((regex_t */* __restrict  */)rexp, (char const   */* __restrict  */)pattern,
                     1);
    }
#line 295
    if (result != 0) {
      {
#line 296
      regerror(result, (regex_t const   */* __restrict  */)rexp, (char */* __restrict  */)(errbuf),
               (size_t )256);
#line 297
      libast_print_error("Unable to compile regexp %s -- %s.\n", pattern, errbuf);
      }
#line 298
      return ((spif_bool_t )0);
    }
  }
  {
#line 303
  result = regexec((regex_t const   */* __restrict  */)rexp, (char const   */* __restrict  */)str,
                   (size_t )0, (regmatch_t */* __restrict  */)((regmatch_t *)((void *)0)),
                   0);
  }
#line 303
  if (result != 0) {
#line 303
    if (result != 1) {
      {
#line 305
      regerror(result, (regex_t const   */* __restrict  */)rexp, (char */* __restrict  */)(errbuf),
               (size_t )256);
#line 306
      libast_print_error("Error testing input string %s -- %s.\n", str, errbuf);
      }
#line 307
      return ((spif_bool_t )0);
    }
  }
#line 309
  if (result == 1) {
#line 309
    tmp___0 = 0;
  } else {
#line 309
    tmp___0 = 1;
  }
#line 309
  return ((spif_bool_t )tmp___0);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_bool_t spiftool_regexp_match_r(spif_charptr_t const   str , spif_charptr_t const   pattern ,
                                    regex_t **rexp___0 ) 
{ 
  register int result ;
  char errbuf[256] ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! ((unsigned long )rexp___0 != (unsigned long )((void *)0))) {
#line 321
      if (libast_debug_level >= 1U) {
        {
#line 321
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_regexp_match_r",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           321, "rexp != NULL");
        }
      } else {
        {
#line 321
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_regexp_match_r",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             321, "rexp != NULL");
        }
      }
#line 321
      return ((spif_bool_t )0);
    }
#line 321
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if ((unsigned long )*rexp___0 == (unsigned long )((void *)0)) {
    {
#line 323
    tmp = malloc(sizeof(regex_t ));
#line 323
    *rexp___0 = (regex_t *)tmp;
    }
  }
#line 326
  if (pattern) {
    {
#line 327
    result = regcomp((regex_t */* __restrict  */)*rexp___0, (char const   */* __restrict  */)pattern,
                     1);
    }
#line 327
    if (result != 0) {
      {
#line 328
      regerror(result, (regex_t const   */* __restrict  */)*rexp___0, (char */* __restrict  */)(errbuf),
               (size_t )256);
#line 329
      libast_print_error("Unable to compile regexp %s -- %s.\n", pattern, errbuf);
      }
      {
#line 330
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 330
        free((void *)*rexp___0);
#line 330
        *rexp___0 = (regex_t *)((void *)0);
        }
#line 330
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 331
      return ((spif_bool_t )0);
    }
  }
  {
#line 335
  result = regexec((regex_t const   */* __restrict  */)*rexp___0, (char const   */* __restrict  */)str,
                   (size_t )0, (regmatch_t */* __restrict  */)((regmatch_t *)((void *)0)),
                   0);
  }
#line 335
  if (result != 0) {
#line 335
    if (result != 1) {
      {
#line 337
      regerror(result, (regex_t const   */* __restrict  */)*rexp___0, (char */* __restrict  */)(errbuf),
               (size_t )256);
#line 338
      libast_print_error("Error testing input string %s -- %s.\n", str, errbuf);
      }
#line 339
      return ((spif_bool_t )0);
    }
  }
#line 341
  if (result == 1) {
#line 341
    tmp___0 = 0;
  } else {
#line 341
    tmp___0 = 1;
  }
#line 341
  return ((spif_bool_t )tmp___0);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_charptr_t *spiftool_split(spif_charptr_t const   delim , spif_charptr_t const   str ) 
{ 
  spif_charptr_t *slist ;
  register spif_charptr_t pstr ;
  register spif_charptr_t pdest ;
  char quote ;
  unsigned short cnt ;
  unsigned long len ;
  time_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  spif_charptr_t tmp___16 ;
  void *tmp___17 ;
  spif_charptr_t tmp___18 ;
  spif_charptr_t tmp___19 ;
  char *tmp___20 ;
  unsigned short const   **tmp___21 ;
  int tmp___22 ;
  spif_charptr_t tmp___23 ;
  spif_charptr_t tmp___24 ;
  char *tmp___25 ;
  unsigned short const   **tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  char *tmp___34 ;
  unsigned short const   **tmp___35 ;
  int tmp___36 ;

  {
#line 354
  quote = (char)0;
#line 355
  cnt = (unsigned short)0;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 358
      if (libast_debug_level >= 1U) {
        {
#line 358
        tmp = time((time_t *)((void *)0));
#line 358
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                358, "spiftool_split");
#line 358
        libast_dprintf("REQUIRE failed:  %s\n", "str != NULL");
        }
      }
#line 358
      return ((spif_charptr_t *)((void *)0));
    }
#line 358
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  tmp___2 = malloc(sizeof(spif_charptr_t ));
#line 360
  slist = (spif_charptr_t *)tmp___2;
  }
#line 360
  if ((unsigned long )slist == (unsigned long )((void *)0)) {
    {
#line 361
    tmp___0 = __errno_location();
#line 361
    tmp___1 = strerror(*tmp___0);
#line 361
    libast_print_error("split():  Unable to allocate memory -- %s\n", tmp___1);
    }
#line 362
    return ((spif_charptr_t *)((void *)0));
  }
#line 366
  pstr = (spif_charptr_t )str;
  {
#line 366
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 366
    if (*pstr) {
#line 366
      if ((unsigned long )delim != (unsigned long )((void *)0)) {
        {
#line 366
        tmp___3 = strchr((char const   *)((char *)delim), (int )*pstr);
#line 366
        tmp___5 = (unsigned long )tmp___3 != (unsigned long )((void *)0);
        }
      } else {
        {
#line 366
        tmp___4 = __ctype_b_loc();
#line 366
        tmp___5 = (int )((int const   )*(*tmp___4 + (int )*pstr) & 8192);
        }
      }
#line 366
      if (! tmp___5) {
#line 366
        goto while_break___0;
      }
    } else {
#line 366
      goto while_break___0;
    }
#line 366
    pstr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 370
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 370
    if (! *pstr) {
#line 370
      goto while_break___1;
    }
#line 373
    if (sizeof(spif_charptr_t ) * (unsigned long )((int )cnt + 2)) {
#line 373
      if (slist) {
        {
#line 373
        tmp___8 = realloc((void *)slist, sizeof(spif_charptr_t ) * (unsigned long )((int )cnt + 2));
#line 373
        tmp___10 = tmp___8;
        }
      } else {
        {
#line 373
        tmp___9 = malloc(sizeof(spif_charptr_t ) * (unsigned long )((int )cnt + 2));
#line 373
        tmp___10 = tmp___9;
        }
      }
#line 373
      tmp___12 = tmp___10;
    } else {
#line 373
      if (slist) {
        {
#line 373
        free((void *)slist);
#line 373
        tmp___11 = (void *)0;
        }
      } else {
#line 373
        tmp___11 = (void *)0;
      }
#line 373
      tmp___12 = tmp___11;
    }
#line 373
    slist = (spif_charptr_t *)tmp___12;
#line 373
    if ((unsigned long )slist == (unsigned long )((void *)0)) {
      {
#line 374
      tmp___6 = __errno_location();
#line 374
      tmp___7 = strerror(*tmp___6);
#line 374
      libast_print_error("split():  Unable to allocate memory -- %s\n", tmp___7);
      }
#line 375
      return ((spif_charptr_t *)((void *)0));
    }
    {
#line 380
    tmp___13 = strlen((char const   *)((char *)pstr));
#line 380
    len = tmp___13 + 1UL;
#line 381
    tmp___17 = malloc(len);
#line 381
    tmp___16 = (spif_charptr_t )tmp___17;
#line 381
    *(slist + cnt) = tmp___16;
    }
#line 381
    if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
      {
#line 382
      tmp___14 = __errno_location();
#line 382
      tmp___15 = strerror(*tmp___14);
#line 382
      libast_print_error("split():  Unable to allocate memory -- %s.\n", tmp___15);
      }
#line 383
      return ((spif_charptr_t *)((void *)0));
    }
#line 385
    pdest = *(slist + cnt);
    {
#line 388
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 388
      if (*pstr) {
#line 388
        if (! quote) {
#line 388
          if ((unsigned long )delim != (unsigned long )((void *)0)) {
            {
#line 388
            tmp___25 = strchr((char const   *)((char *)delim), (int )*pstr);
#line 388
            tmp___27 = (unsigned long )tmp___25 != (unsigned long )((void *)0);
            }
          } else {
            {
#line 388
            tmp___26 = __ctype_b_loc();
#line 388
            tmp___27 = (int )((int const   )*(*tmp___26 + (int )*pstr) & 8192);
            }
          }
#line 388
          if (tmp___27) {
#line 388
            goto while_break___2;
          }
        }
      } else {
#line 388
        goto while_break___2;
      }
#line 389
      if ((int )*pstr == 34) {
#line 389
        goto _L;
      } else
#line 389
      if ((int )*pstr == 39) {
        _L: /* CIL Label */ 
#line 391
        if (quote) {
#line 392
          if ((int )quote == (int )*pstr) {
#line 393
            quote = (char)0;
          } else {
#line 396
            tmp___18 = pdest;
#line 396
            pdest ++;
#line 396
            tmp___19 = pstr;
#line 396
            pstr ++;
#line 396
            *tmp___18 = *tmp___19;
          }
        } else {
#line 399
          quote = (char )*pstr;
        }
#line 401
        pstr ++;
      } else {
#line 404
        if ((int )*pstr == 92) {
#line 404
          if ((unsigned long )delim != (unsigned long )((void *)0)) {
            {
#line 404
            tmp___20 = strchr((char const   *)((char *)delim), (int )*(pstr + 1));
#line 404
            tmp___22 = (unsigned long )tmp___20 != (unsigned long )((void *)0);
            }
          } else {
            {
#line 404
            tmp___21 = __ctype_b_loc();
#line 404
            tmp___22 = (int )((int const   )*(*tmp___21 + (int )*(pstr + 1)) & 8192);
            }
          }
#line 404
          if (tmp___22) {
#line 407
            pstr ++;
          } else
#line 404
          if (quote) {
#line 404
            if ((int )quote == (int )*(pstr + 1)) {
#line 407
              pstr ++;
            }
          }
        }
#line 409
        tmp___23 = pdest;
#line 409
        pdest ++;
#line 409
        tmp___24 = pstr;
#line 409
        pstr ++;
#line 409
        *tmp___23 = *tmp___24;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 413
    *pdest = (spif_char_t )0;
#line 416
    tmp___28 = strlen((char const   *)((char *)*(slist + cnt)));
#line 416
    len = tmp___28 + 1UL;
    }
#line 417
    if (len) {
#line 417
      if (*(slist + cnt)) {
        {
#line 417
        tmp___29 = realloc((void *)*(slist + cnt), len);
#line 417
        tmp___31 = tmp___29;
        }
      } else {
        {
#line 417
        tmp___30 = malloc(len);
#line 417
        tmp___31 = tmp___30;
        }
      }
#line 417
      tmp___33 = tmp___31;
    } else {
#line 417
      if (*(slist + cnt)) {
        {
#line 417
        free((void *)*(slist + cnt));
#line 417
        tmp___32 = (void *)0;
        }
      } else {
#line 417
        tmp___32 = (void *)0;
      }
#line 417
      tmp___33 = tmp___32;
    }
#line 417
    *(slist + cnt) = (spif_charptr_t )tmp___33;
    {
#line 420
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 420
      if (*pstr) {
#line 420
        if ((unsigned long )delim != (unsigned long )((void *)0)) {
          {
#line 420
          tmp___34 = strchr((char const   *)((char *)delim), (int )*pstr);
#line 420
          tmp___36 = (unsigned long )tmp___34 != (unsigned long )((void *)0);
          }
        } else {
          {
#line 420
          tmp___35 = __ctype_b_loc();
#line 420
          tmp___36 = (int )((int const   )*(*tmp___35 + (int )*pstr) & 8192);
          }
        }
#line 420
        if (! tmp___36) {
#line 420
          goto while_break___3;
        }
      } else {
#line 420
        goto while_break___3;
      }
#line 420
      pstr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 370
    cnt = (unsigned short )((int )cnt + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 422
  if ((int )cnt == 0) {
    {
#line 423
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 423
      free((void *)slist);
#line 423
      slist = (spif_charptr_t *)((void *)0);
      }
#line 423
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 424
    return ((spif_charptr_t *)((void *)0));
  } else {
#line 427
    *(slist + cnt) = (spif_charptr_t )0;
#line 428
    return (slist);
  }
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_charptr_t *spiftool_split_regexp(spif_charptr_t const   regexp , spif_charptr_t const   str ) 
{ 


  {
#line 437
  return ((spif_charptr_t *)((void *)0));
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_charptr_t spiftool_join(spif_charptr_t sep , spif_charptr_t *slist ) 
{ 
  register unsigned long i ;
  size_t len ;
  size_t slen ;
  spif_charptr_t new_str ;
  time_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! ((unsigned long )slist != (unsigned long )((void *)0))) {
#line 447
      if (libast_debug_level >= 1U) {
        {
#line 447
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_join",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           447, "slist != SPIF_NULL_TYPE(ptr)");
        }
      } else {
        {
#line 447
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_join",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             447, "slist != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 447
      return ((spif_charptr_t )((void *)0));
    }
#line 447
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 448
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 448
    if (! ((unsigned long )*slist != (unsigned long )((void *)0))) {
#line 448
      if (libast_debug_level >= 1U) {
        {
#line 448
        tmp = time((time_t *)((void *)0));
#line 448
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                448, "spiftool_join");
#line 448
        libast_dprintf("REQUIRE failed:  %s\n", "*slist != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 448
      return ((spif_charptr_t )((void *)0));
    }
#line 448
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 449
  if ((unsigned long )sep == (unsigned long )((void *)0)) {
#line 450
    sep = (spif_charptr_t )"";
  }
  {
#line 452
  slen = strlen((char const   *)((char *)sep));
#line 453
  len = (size_t )0;
#line 453
  i = len;
  }
  {
#line 453
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 453
    if (! *(slist + i)) {
#line 453
      goto while_break___1;
    }
    {
#line 454
    tmp___0 = strlen((char const   *)((char *)*(slist + i)));
#line 454
    len += tmp___0;
#line 453
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 456
  len += slen * (i - 1UL);
#line 457
  tmp___1 = malloc(len);
#line 457
  new_str = (spif_charptr_t )tmp___1;
#line 458
  strcpy((char */* __restrict  */)((char *)new_str), (char const   */* __restrict  */)((char *)*(slist + 0)));
#line 459
  i = 1UL;
  }
  {
#line 459
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 459
    if (! *(slist + i)) {
#line 459
      goto while_break___2;
    }
#line 460
    if (slen) {
      {
#line 461
      strcat((char */* __restrict  */)((char *)new_str), (char const   */* __restrict  */)((char *)sep));
      }
    }
    {
#line 463
    strcat((char */* __restrict  */)((char *)new_str), (char const   */* __restrict  */)((char *)*(slist + i)));
#line 459
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 465
  return (new_str);
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_charptr_t spiftool_get_word(unsigned long index___0 , spif_charptr_t const   str ) 
{ 
  spif_charptr_t tmpstr ;
  char delim ;
  register unsigned long i ;
  register unsigned long j ;
  register unsigned long k ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  size_t tmp___16 ;

  {
#line 476
  delim = (char)0;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 479
      if (libast_debug_level >= 1U) {
        {
#line 479
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_get_word",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           479, "str != SPIF_NULL_TYPE(ptr)");
        }
      } else {
        {
#line 479
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_get_word",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             479, "str != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 479
      return ((spif_charptr_t )((void *)0));
    }
#line 479
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 480
  tmp = strlen((char const   *)((char *)str));
#line 480
  k = tmp + 1UL;
#line 481
  tmp___2 = malloc(k);
#line 481
  tmpstr = (spif_charptr_t )tmp___2;
  }
#line 481
  if ((unsigned long )tmpstr == (unsigned long )((void *)0)) {
    {
#line 482
    tmp___0 = __errno_location();
#line 482
    tmp___1 = strerror(*tmp___0);
#line 482
    libast_print_error("get_word(%lu, %s):  Unable to allocate memory -- %s.\n", index___0,
                       str, tmp___1);
    }
#line 483
    return ((spif_charptr_t )((void *)0));
  }
#line 485
  *tmpstr = (spif_char_t )0;
#line 486
  i = 0UL;
#line 486
  j = 0UL;
  {
#line 486
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 486
    if (j < index___0) {
#line 486
      if (! *(str + i)) {
#line 486
        goto while_break___0;
      }
    } else {
#line 486
      goto while_break___0;
    }
    {
#line 487
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 487
      tmp___3 = __ctype_b_loc();
      }
#line 487
      if (! ((int const   )*(*tmp___3 + (int )*(str + i)) & 8192)) {
#line 487
        goto while_break___1;
      }
#line 487
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 489
    if ((int )*(str + i) == 34) {
#line 489
      goto case_34;
    }
#line 493
    if ((int )*(str + i) == 39) {
#line 493
      goto case_39;
    }
#line 497
    goto switch_default;
    case_34: /* CIL Label */ 
#line 490
    delim = (char )'\"';
#line 491
    i ++;
#line 492
    goto switch_break;
    case_39: /* CIL Label */ 
#line 494
    delim = (char )'\'';
#line 495
    i ++;
#line 496
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 498
    delim = (char)0;
    switch_break: /* CIL Label */ ;
    }
#line 500
    k = 0UL;
    {
#line 500
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 500
      if (*(str + i)) {
#line 500
        if (delim) {
#line 500
          tmp___7 = (int )*(str + i) == (int )delim;
        } else {
          {
#line 500
          tmp___6 = __ctype_b_loc();
#line 500
          tmp___7 = (int )((int const   )*(*tmp___6 + (int )*(str + i)) & 8192);
          }
        }
#line 500
        if (tmp___7) {
#line 500
          goto while_break___2;
        }
      } else {
#line 500
        goto while_break___2;
      }
#line 501
      if ((int )*(str + i) == 92) {
#line 502
        if ((int )*(str + (i + 1UL)) == 39) {
#line 503
          i ++;
        } else
#line 502
        if ((int )*(str + (i + 1UL)) == 34) {
#line 503
          i ++;
        }
      }
#line 506
      tmp___4 = k;
#line 506
      k ++;
#line 506
      tmp___5 = i;
#line 506
      i ++;
#line 506
      *(tmpstr + tmp___4) = *(str + tmp___5);
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 510
    if ((int )*(str + i) == 39) {
#line 510
      goto case_39___0;
    }
#line 510
    if ((int )*(str + i) == 34) {
#line 510
      goto case_39___0;
    }
#line 508
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
    case_34___0: /* CIL Label */ 
#line 511
    i ++;
#line 512
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 514
    *(tmpstr + k) = (spif_char_t )0;
#line 486
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 517
  if (j != index___0) {
    {
#line 518
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 518
      free((void *)tmpstr);
#line 518
      tmpstr = (spif_charptr_t )((void *)0);
      }
#line 518
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 520
    return ((spif_charptr_t )((void *)0));
  } else {
    {
#line 522
    tmp___16 = strlen((char const   *)((char *)tmpstr));
    }
#line 522
    if (tmp___16 + 1UL) {
#line 522
      if (tmpstr) {
        {
#line 522
        tmp___9 = strlen((char const   *)((char *)tmpstr));
#line 522
        tmp___10 = realloc((void *)tmpstr, tmp___9 + 1UL);
#line 522
        tmp___13 = tmp___10;
        }
      } else {
        {
#line 522
        tmp___11 = strlen((char const   *)((char *)tmpstr));
#line 522
        tmp___12 = malloc(tmp___11 + 1UL);
#line 522
        tmp___13 = tmp___12;
        }
      }
#line 522
      tmp___15 = tmp___13;
    } else {
#line 522
      if (tmpstr) {
        {
#line 522
        free((void *)tmpstr);
#line 522
        tmp___14 = (void *)0;
        }
      } else {
#line 522
        tmp___14 = (void *)0;
      }
#line 522
      tmp___15 = tmp___14;
    }
#line 522
    tmpstr = (spif_charptr_t )tmp___15;
#line 524
    return (tmpstr);
  }
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_charptr_t spiftool_get_pword(unsigned long index___0 , spif_charptr_t const   str ) 
{ 
  register spif_charptr_t tmpstr ;
  register unsigned long j ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 532
  tmpstr = (spif_charptr_t )str;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 535
      if (libast_debug_level >= 1U) {
        {
#line 535
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_get_pword",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           535, "str != SPIF_NULL_TYPE(ptr)");
        }
      } else {
        {
#line 535
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_get_pword",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             535, "str != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 535
      return ((spif_charptr_t )((void *)0));
    }
#line 535
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 536
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 536
    tmp = __ctype_b_loc();
    }
#line 536
    if ((int const   )*(*tmp + (int )*tmpstr) & 8192) {
#line 536
      if (! *tmpstr) {
#line 536
        goto while_break___0;
      }
    } else {
#line 536
      goto while_break___0;
    }
#line 536
    tmpstr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 537
  j = 1UL;
  {
#line 537
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 537
    if (j < index___0) {
#line 537
      if (! *tmpstr) {
#line 537
        goto while_break___1;
      }
    } else {
#line 537
      goto while_break___1;
    }
    {
#line 538
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 538
      tmp___0 = __ctype_b_loc();
      }
#line 538
      if ((int const   )*(*tmp___0 + (int )*tmpstr) & 8192) {
#line 538
        goto while_break___2;
      } else
#line 538
      if (! *tmpstr) {
#line 538
        goto while_break___2;
      }
#line 538
      tmpstr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 539
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 539
      tmp___1 = __ctype_b_loc();
      }
#line 539
      if ((int const   )*(*tmp___1 + (int )*tmpstr) & 8192) {
#line 539
        if (! *tmpstr) {
#line 539
          goto while_break___3;
        }
      } else {
#line 539
        goto while_break___3;
      }
#line 539
      tmpstr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 537
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 542
  if ((int )*tmpstr == 34) {
#line 543
    tmpstr ++;
  } else
#line 542
  if ((int )*tmpstr == 39) {
#line 543
    tmpstr ++;
  }
#line 545
  if ((int )*tmpstr == 0) {
#line 547
    return ((spif_charptr_t )((void *)0));
  } else {
#line 550
    return (tmpstr);
  }
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
unsigned long spiftool_num_words(spif_charptr_t const   str ) 
{ 
  register unsigned long cnt ;
  char delim ;
  register unsigned long i ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 558
  cnt = 0UL;
#line 559
  delim = (char)0;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 562
      if (libast_debug_level >= 1U) {
        {
#line 562
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_num_words",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           562, "str != SPIF_NULL_TYPE(ptr)");
        }
      } else {
        {
#line 562
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_num_words",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             562, "str != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 562
      return (0xffffffffffffffffUL);
    }
#line 562
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 563
  i = 0UL;
  {
#line 563
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 563
    if (*(str + i)) {
#line 563
      if (delim) {
#line 563
        tmp___0 = (int )*(str + i) == (int )delim;
      } else {
        {
#line 563
        tmp = __ctype_b_loc();
#line 563
        tmp___0 = (int )((int const   )*(*tmp + (int )*(str + i)) & 8192);
        }
      }
#line 563
      if (! tmp___0) {
#line 563
        goto while_break___0;
      }
    } else {
#line 563
      goto while_break___0;
    }
#line 563
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 564
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 564
    if (! *(str + i)) {
#line 564
      goto while_break___1;
    }
    {
#line 566
    if ((int )*(str + i) == 34) {
#line 566
      goto case_34;
    }
#line 570
    if ((int )*(str + i) == 39) {
#line 570
      goto case_39;
    }
#line 574
    goto switch_default;
    case_34: /* CIL Label */ 
#line 567
    delim = (char )'\"';
#line 568
    i ++;
#line 569
    goto switch_break;
    case_39: /* CIL Label */ 
#line 571
    delim = (char )'\'';
#line 572
    i ++;
#line 573
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 575
    delim = (char)0;
    switch_break: /* CIL Label */ ;
    }
    {
#line 577
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 577
      if (*(str + i)) {
#line 577
        if (delim) {
#line 577
          tmp___2 = (int )*(str + i) == (int )delim;
        } else {
          {
#line 577
          tmp___1 = __ctype_b_loc();
#line 577
          tmp___2 = (int )((int const   )*(*tmp___1 + (int )*(str + i)) & 8192);
          }
        }
#line 577
        if (tmp___2) {
#line 577
          goto while_break___2;
        }
      } else {
#line 577
        goto while_break___2;
      }
#line 577
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 580
    if ((int )*(str + i) == 39) {
#line 580
      goto case_39___0;
    }
#line 580
    if ((int )*(str + i) == 34) {
#line 580
      goto case_39___0;
    }
#line 578
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
    case_34___0: /* CIL Label */ 
#line 581
    i ++;
#line 582
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 584
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 584
      if (*(str + i)) {
        {
#line 584
        tmp___3 = __ctype_b_loc();
        }
#line 584
        if (! ((int const   )*(*tmp___3 + (int )*(str + i)) & 8192)) {
#line 584
          goto while_break___3;
        }
      } else {
#line 584
        goto while_break___3;
      }
#line 584
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 564
    cnt ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 588
  return (cnt);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_charptr_t spiftool_chomp(spif_charptr_t s ) 
{ 
  register spif_charptr_t front ;
  register spif_charptr_t back ;
  time_t tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 597
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 597
      if (libast_debug_level >= 1U) {
        {
#line 597
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_chomp",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           597, "s != NULL");
        }
      } else {
        {
#line 597
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_chomp",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             597, "s != NULL");
        }
      }
#line 597
      return ((spif_charptr_t )((void *)0));
    }
#line 597
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 598
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 598
    if (! *s) {
#line 598
      if (libast_debug_level >= 1U) {
        {
#line 598
        tmp = time((time_t *)((void *)0));
#line 598
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                598, "spiftool_chomp");
#line 598
        libast_dprintf("REQUIRE failed:  %s\n", "*s");
        }
      }
#line 598
      return (s);
    }
#line 598
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 600
  front = s;
  {
#line 600
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 600
    if (*front) {
      {
#line 600
      tmp___0 = __ctype_b_loc();
      }
#line 600
      if (! ((int const   )*(*tmp___0 + (int )*front) & 8192)) {
#line 600
        goto while_break___1;
      }
    } else {
#line 600
      goto while_break___1;
    }
#line 600
    front ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 601
  tmp___1 = strlen((char const   *)((char *)s));
#line 601
  back = (s + tmp___1) - 1;
  }
  {
#line 601
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 601
    if (*back) {
      {
#line 601
      tmp___2 = __ctype_b_loc();
      }
#line 601
      if ((int const   )*(*tmp___2 + (int )*back) & 8192) {
#line 601
        if (! ((unsigned long )back > (unsigned long )front)) {
#line 601
          goto while_break___2;
        }
      } else {
#line 601
        goto while_break___2;
      }
    } else {
#line 601
      goto while_break___2;
    }
#line 601
    back --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 603
  back ++;
#line 603
  *back = (spif_char_t )0;
#line 604
  if ((unsigned long )front != (unsigned long )s) {
    {
#line 605
    memmove((void *)s, (void const   *)front, (size_t )((back - front) + 1L));
    }
  }
#line 607
  return (s);
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_charptr_t spiftool_downcase_str(spif_charptr_t str ) 
{ 
  register spif_charptr_t tmp ;
  int tmp___0 ;

  {
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 615
      if (libast_debug_level >= 1U) {
        {
#line 615
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_downcase_str",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           615, "str != SPIF_NULL_TYPE(ptr)");
        }
      } else {
        {
#line 615
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_downcase_str",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             615, "str != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 615
      return ((spif_charptr_t )((void *)0));
    }
#line 615
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  tmp = str;
  {
#line 616
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 616
    if (! *tmp) {
#line 616
      goto while_break___0;
    }
    {
#line 617
    tmp___0 = tolower((int )*tmp);
#line 617
    *tmp = (spif_char_t )tmp___0;
#line 616
    tmp ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 620
  return (str);
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_charptr_t spiftool_upcase_str(spif_charptr_t str ) 
{ 
  register spif_charptr_t tmp ;
  int tmp___0 ;

  {
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;
#line 628
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 628
      if (libast_debug_level >= 1U) {
        {
#line 628
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_upcase_str",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           628, "str != SPIF_NULL_TYPE(ptr)");
        }
      } else {
        {
#line 628
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_upcase_str",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             628, "str != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 628
      return ((spif_charptr_t )((void *)0));
    }
#line 628
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  tmp = str;
  {
#line 629
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 629
    if (! *tmp) {
#line 629
      goto while_break___0;
    }
    {
#line 630
    tmp___0 = toupper((int )*tmp);
#line 630
    *tmp = (spif_char_t )tmp___0;
#line 629
    tmp ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 633
  return (str);
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_charptr_t spiftool_condense_whitespace(spif_charptr_t s ) 
{ 
  register unsigned char gotspc ;
  register spif_charptr_t pbuff ;
  register spif_charptr_t pbuff2 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;

  {
#line 640
  gotspc = (unsigned char)0;
#line 641
  pbuff = s;
#line 641
  pbuff2 = s;
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 643
      if (libast_debug_level >= 1U) {
        {
#line 643
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_condense_whitespace",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           643, "s != SPIF_NULL_TYPE(ptr)");
        }
      } else {
        {
#line 643
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_condense_whitespace",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             643, "s != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 643
      return ((spif_charptr_t )((void *)0));
    }
#line 643
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 645
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 645
    if (! *pbuff2) {
#line 645
      goto while_break___0;
    }
    {
#line 646
    tmp = __ctype_b_loc();
    }
#line 646
    if ((int const   )*(*tmp + (int )*pbuff2) & 8192) {
#line 647
      if (! gotspc) {
#line 648
        *pbuff = (spif_char_t )' ';
#line 649
        gotspc = (unsigned char)1;
#line 650
        pbuff ++;
      }
    } else {
#line 653
      *pbuff = *pbuff2;
#line 654
      gotspc = (unsigned char)0;
#line 655
      pbuff ++;
    }
#line 645
    pbuff2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 658
  if ((unsigned long )pbuff >= (unsigned long )s) {
    {
#line 658
    tmp___0 = __ctype_b_loc();
    }
#line 658
    if ((int const   )*(*tmp___0 + (int )*(pbuff - 1)) & 8192) {
#line 659
      pbuff --;
    }
  }
  {
#line 660
  *pbuff = (spif_char_t )0;
#line 662
  tmp___9 = strlen((char const   *)((char *)s));
  }
#line 662
  if (tmp___9 + 1UL) {
#line 662
    if (s) {
      {
#line 662
      tmp___2 = strlen((char const   *)((char *)s));
#line 662
      tmp___3 = realloc((void *)s, tmp___2 + 1UL);
#line 662
      tmp___6 = tmp___3;
      }
    } else {
      {
#line 662
      tmp___4 = strlen((char const   *)((char *)s));
#line 662
      tmp___5 = malloc(tmp___4 + 1UL);
#line 662
      tmp___6 = tmp___5;
      }
    }
#line 662
    tmp___8 = tmp___6;
  } else {
#line 662
    if (s) {
      {
#line 662
      free((void *)s);
#line 662
      tmp___7 = (void *)0;
      }
    } else {
#line 662
      tmp___7 = (void *)0;
    }
#line 662
    tmp___8 = tmp___7;
  }
#line 662
  return ((spif_charptr_t )tmp___8);
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_charptr_t spiftool_safe_str(spif_charptr_t str , unsigned short len ) 
{ 
  register unsigned short i ;
  unsigned short const   **tmp ;

  {
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 670
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 670
      if (libast_debug_level >= 1U) {
        {
#line 670
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_safe_str",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           670, "str != SPIF_NULL_TYPE(ptr)");
        }
      } else {
        {
#line 670
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_safe_str",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             670, "str != SPIF_NULL_TYPE(ptr)");
        }
      }
#line 670
      return ((spif_charptr_t )((void *)0));
    }
#line 670
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 671
  i = (unsigned short)0;
  {
#line 671
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 671
    if (! ((int )i < (int )len)) {
#line 671
      goto while_break___0;
    }
    {
#line 672
    tmp = __ctype_b_loc();
    }
#line 672
    if ((int const   )*(*tmp + (int )*(str + i)) & 2) {
#line 673
      *(str + i) = (spif_char_t )'.';
    }
#line 671
    i = (unsigned short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 677
  return (str);
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
void spiftool_hex_dump(void *buff , size_t count ) 
{ 
  register unsigned long j ;
  register unsigned long k ;
  register unsigned long l ;
  register spif_charptr_t ptr ;
  spif_char_t buffr[9] ;
  spif_charptr_t tmp ;

  {
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 687
    if (! ((unsigned long )buff != (unsigned long )((void *)0))) {
#line 687
      if (libast_debug_level >= 1U) {
        {
#line 687
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_hex_dump",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                           687, "buff != SPIF_NULL_TYPE(ptr)");
        }
      } else {
        {
#line 687
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spiftool_hex_dump",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                             687, "buff != SPIF_NULL_TYPE(ptr)");
        }
#line 687
        return;
      }
    }
#line 687
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 688
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Address  |  Size  | Offset  | 00 01 02 03 04 05 06 07 |  ASCII  \n");
#line 689
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-----------+--------+---------+-------------------------+---------\n");
#line 690
  ptr = (spif_charptr_t )buff;
#line 690
  j = 0UL;
  }
  {
#line 690
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 690
    if (! (j < count)) {
#line 690
      goto while_break___0;
    }
    {
#line 691
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %10p | %06lu | %07x | ",
            buff, count, (unsigned int )j);
    }
#line 692
    if (count - j < 8UL) {
#line 692
      l = count - j;
    } else {
#line 692
      l = 8UL;
    }
    {
#line 693
    memcpy((void */* __restrict  */)(buffr), (void const   */* __restrict  */)(ptr + j),
           l);
#line 694
    memset((void *)(buffr + l), 0, 9UL - l);
#line 695
    k = 0UL;
    }
    {
#line 695
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 695
      if (! (k < l)) {
#line 695
        goto while_break___1;
      }
      {
#line 696
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
              (int )buffr[k]);
#line 695
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 698
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 698
      if (! (k < 8UL)) {
#line 698
        goto while_break___2;
      }
      {
#line 699
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   ");
#line 698
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 701
    tmp = spiftool_safe_str(buffr, (unsigned short )l);
#line 701
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| %-8s\n",
            tmp);
#line 690
    j += 8UL;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 703
  return;
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c"
spif_cmp_t spiftool_version_compare(spif_charptr_t v1 , spif_charptr_t v2 ) 
{ 
  spif_char_t buff1[128] ;
  spif_char_t buff2[128] ;
  time_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  time_t tmp___6 ;
  spif_charptr_t p1 ;
  spif_charptr_t p2 ;
  spif_int8_t ival1 ;
  spif_int8_t ival2 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  spif_char_t tmp___9 ;
  time_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  time_t tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int c ;
  time_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  spif_charptr_t p1___0 ;
  spif_charptr_t p2___0 ;
  spif_int32_t ival1___0 ;
  spif_int32_t ival2___0 ;
  spif_cmp_t c___0 ;
  unsigned short const   **tmp___31 ;
  unsigned short const   **tmp___32 ;
  spif_char_t tmp___33 ;
  long tmp___34 ;
  long tmp___35 ;
  time_t tmp___36 ;
  int tmp___37 ;
  time_t tmp___38 ;
  spif_charptr_t p1___1 ;
  spif_charptr_t p2___1 ;
  spif_cmp_t c___1 ;
  unsigned short const   **tmp___39 ;
  unsigned short const   **tmp___40 ;
  spif_char_t tmp___41 ;
  time_t tmp___42 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  time_t tmp___48 ;
  time_t tmp___49 ;
  time_t tmp___50 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  unsigned short const   **tmp___63 ;
  unsigned short const   **tmp___64 ;
  unsigned short const   **tmp___65 ;
  unsigned short const   **tmp___66 ;
  unsigned short const   **tmp___67 ;
  unsigned short const   **tmp___68 ;
  time_t tmp___69 ;
  time_t tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  time_t tmp___75 ;
  time_t tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  time_t tmp___81 ;

  {
  {
#line 713
  while (1) {
    while_continue: /* CIL Label */ ;
#line 713
    if (libast_debug_level >= 3U) {
      {
#line 713
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 713
        tmp = time((time_t *)((void *)0));
#line 713
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                713, "spiftool_version_compare");
        }
#line 713
        if ((char *)v2) {
#line 713
          tmp___0 = (char *)v2;
        } else {
#line 713
          tmp___0 = (char *)"<v2 null>";
        }
#line 713
        if ((char *)v1) {
#line 713
          tmp___1 = (char *)v1;
        } else {
#line 713
          tmp___1 = (char *)"<v1 null>";
        }
        {
#line 713
        libast_dprintf("Comparing version strings \"%s\" and \"%s\"\n", tmp___1, tmp___0);
        }
#line 713
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 713
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 714
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 714
    if ((unsigned long )((spif_ptr_t )v1) == (unsigned long )((void *)0)) {
#line 714
      tmp___4 = 1;
    } else {
#line 714
      tmp___4 = 0;
    }
#line 714
    if (tmp___4) {
#line 714
      if ((unsigned long )((spif_ptr_t )v2) == (unsigned long )((void *)0)) {
#line 714
        tmp___5 = 1;
      } else {
#line 714
        tmp___5 = 0;
      }
#line 714
      if (tmp___5) {
#line 714
        return ((spif_cmp_t )0);
      } else {
#line 714
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 714
      if ((unsigned long )((spif_ptr_t )v1) == (unsigned long )((void *)0)) {
#line 714
        tmp___3 = 1;
      } else {
#line 714
        tmp___3 = 0;
      }
#line 714
      if (tmp___3) {
#line 714
        return ((spif_cmp_t )-1);
      } else {
#line 714
        if ((unsigned long )((spif_ptr_t )v2) == (unsigned long )((void *)0)) {
#line 714
          tmp___2 = 1;
        } else {
#line 714
          tmp___2 = 0;
        }
#line 714
        if (tmp___2) {
#line 714
          return ((spif_cmp_t )1);
        }
      }
    }
#line 714
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 716
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 716
    if (*v1) {
#line 716
      if (! *v2) {
#line 716
        goto while_break___2;
      }
    } else {
#line 716
      goto while_break___2;
    }
    {
#line 717
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 717
      if (libast_debug_level >= 3U) {
        {
#line 717
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 717
          tmp___6 = time((time_t *)((void *)0));
#line 717
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___6, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                  717, "spiftool_version_compare");
#line 717
          libast_dprintf(" -> Looking at \"%s\" and \"%s\"\n", v1, v2);
          }
#line 717
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 717
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 718
    tmp___67 = __ctype_b_loc();
    }
#line 718
    if ((int const   )*(*tmp___67 + (int )*v1) & 1024) {
      {
#line 718
      tmp___68 = __ctype_b_loc();
      }
#line 718
      if ((int const   )*(*tmp___68 + (int )*v2) & 1024) {
#line 719
        p1 = buff1;
#line 719
        p2 = buff2;
#line 720
        ival1 = (spif_int8_t )6;
#line 720
        ival2 = (spif_int8_t )6;
        {
#line 723
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 723
          if (*v1) {
            {
#line 723
            tmp___7 = __ctype_b_loc();
            }
#line 723
            if (! ((int const   )*(*tmp___7 + (int )*v1) & 1024)) {
#line 723
              goto while_break___5;
            }
          } else {
#line 723
            goto while_break___5;
          }
#line 723
          *p1 = *v1;
#line 723
          v1 ++;
#line 723
          p1 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 724
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 724
          if (*v2) {
            {
#line 724
            tmp___8 = __ctype_b_loc();
            }
#line 724
            if (! ((int const   )*(*tmp___8 + (int )*v2) & 1024)) {
#line 724
              goto while_break___6;
            }
          } else {
#line 724
            goto while_break___6;
          }
#line 724
          *p2 = *v2;
#line 724
          v2 ++;
#line 724
          p2 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 725
        tmp___9 = (spif_char_t )0;
#line 725
        *p2 = tmp___9;
#line 725
        *p1 = tmp___9;
#line 728
        spiftool_downcase_str(buff1);
#line 729
        spiftool_downcase_str(buff2);
        }
        {
#line 730
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 730
          if (libast_debug_level >= 3U) {
            {
#line 730
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 730
              tmp___10 = time((time_t *)((void *)0));
#line 730
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___10, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                      730, "spiftool_version_compare");
#line 730
              libast_dprintf("     -> Comparing as words \"%s\" vs. \"%s\"\n", buff1,
                             buff2);
              }
#line 730
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
#line 730
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 733
        tmp___15 = strcmp((char const   *)((char *)(buff1)), "snap");
        }
#line 733
        if (tmp___15) {
          {
#line 735
          tmp___14 = strcmp((char const   *)((char *)(buff1)), "pre");
          }
#line 735
          if (tmp___14) {
            {
#line 737
            tmp___13 = strcmp((char const   *)((char *)(buff1)), "alpha");
            }
#line 737
            if (tmp___13) {
              {
#line 739
              tmp___12 = strcmp((char const   *)((char *)(buff1)), "beta");
              }
#line 739
              if (tmp___12) {
                {
#line 741
                tmp___11 = strcmp((char const   *)((char *)(buff1)), "rc");
                }
#line 741
                if (! tmp___11) {
#line 742
                  ival1 = (spif_int8_t )5;
                }
              } else {
#line 740
                ival1 = (spif_int8_t )4;
              }
            } else {
#line 738
              ival1 = (spif_int8_t )3;
            }
          } else {
#line 736
            ival1 = (spif_int8_t )2;
          }
        } else {
#line 734
          ival1 = (spif_int8_t )1;
        }
        {
#line 744
        tmp___20 = strcmp((char const   *)((char *)(buff2)), "snap");
        }
#line 744
        if (tmp___20) {
          {
#line 746
          tmp___19 = strcmp((char const   *)((char *)(buff2)), "pre");
          }
#line 746
          if (tmp___19) {
            {
#line 748
            tmp___18 = strcmp((char const   *)((char *)(buff2)), "alpha");
            }
#line 748
            if (tmp___18) {
              {
#line 750
              tmp___17 = strcmp((char const   *)((char *)(buff2)), "beta");
              }
#line 750
              if (tmp___17) {
                {
#line 752
                tmp___16 = strcmp((char const   *)((char *)(buff2)), "rc");
                }
#line 752
                if (! tmp___16) {
#line 753
                  ival2 = (spif_int8_t )5;
                }
              } else {
#line 751
                ival2 = (spif_int8_t )4;
              }
            } else {
#line 749
              ival2 = (spif_int8_t )3;
            }
          } else {
#line 747
            ival2 = (spif_int8_t )2;
          }
        } else {
#line 745
          ival2 = (spif_int8_t )1;
        }
#line 755
        if ((int )ival1 != (int )ival2) {
          {
#line 757
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 757
            if (libast_debug_level >= 3U) {
              {
#line 757
              while (1) {
                while_continue___10: /* CIL Label */ ;
                {
#line 757
                tmp___21 = time((time_t *)((void *)0));
#line 757
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                        (unsigned long )tmp___21, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                        757, "spiftool_version_compare");
                }
#line 757
                if ((int )ival1 - (int )ival2 < 0) {
#line 757
                  tmp___23 = -1;
                } else {
#line 757
                  if ((int )ival1 - (int )ival2 > 0) {
#line 757
                    tmp___22 = 1;
                  } else {
#line 757
                    tmp___22 = 0;
                  }
#line 757
                  tmp___23 = tmp___22;
                }
                {
#line 757
                libast_dprintf("     -> %d\n", tmp___23);
                }
#line 757
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
#line 757
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 758
          if ((int )ival1 - (int )ival2 < 0) {
#line 758
            tmp___25 = -1;
          } else {
#line 758
            if ((int )ival1 - (int )ival2 > 0) {
#line 758
              tmp___24 = 1;
            } else {
#line 758
              tmp___24 = 0;
            }
#line 758
            tmp___25 = tmp___24;
          }
#line 758
          return ((spif_cmp_t )tmp___25);
        } else
#line 759
        if ((int )ival1 == 6) {
          {
#line 763
          c = strcmp((char const   *)((char *)(buff1)), (char const   *)((char *)(buff2)));
          }
#line 763
          if (c != 0) {
            {
#line 764
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 764
              if (libast_debug_level >= 3U) {
                {
#line 764
                while (1) {
                  while_continue___12: /* CIL Label */ ;
                  {
#line 764
                  tmp___26 = time((time_t *)((void *)0));
#line 764
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                          (unsigned long )tmp___26, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                          764, "spiftool_version_compare");
                  }
#line 764
                  if (c < 0) {
#line 764
                    tmp___28 = -1;
                  } else {
#line 764
                    if (c > 0) {
#line 764
                      tmp___27 = 1;
                    } else {
#line 764
                      tmp___27 = 0;
                    }
#line 764
                    tmp___28 = tmp___27;
                  }
                  {
#line 764
                  libast_dprintf("     -> %d\n", tmp___28);
                  }
#line 764
                  goto while_break___12;
                }
                while_break___12: /* CIL Label */ ;
                }
              }
#line 764
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 765
            if (c < 0) {
#line 765
              tmp___30 = -1;
            } else {
#line 765
              if (c > 0) {
#line 765
                tmp___29 = 1;
              } else {
#line 765
                tmp___29 = 0;
              }
#line 765
              tmp___30 = tmp___29;
            }
#line 765
            return ((spif_cmp_t )tmp___30);
          }
        }
      } else {
#line 718
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 768
      tmp___65 = __ctype_b_loc();
      }
#line 768
      if ((int const   )*(*tmp___65 + (int )*v1) & 2048) {
        {
#line 768
        tmp___66 = __ctype_b_loc();
        }
#line 768
        if ((int const   )*(*tmp___66 + (int )*v2) & 2048) {
#line 769
          p1___0 = buff1;
#line 769
          p2___0 = buff2;
          {
#line 774
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 774
            if (*v1) {
              {
#line 774
              tmp___31 = __ctype_b_loc();
              }
#line 774
              if (! ((int const   )*(*tmp___31 + (int )*v1) & 2048)) {
#line 774
                goto while_break___13;
              }
            } else {
#line 774
              goto while_break___13;
            }
#line 774
            *p1___0 = *v1;
#line 774
            v1 ++;
#line 774
            p1___0 ++;
          }
          while_break___13: /* CIL Label */ ;
          }
          {
#line 775
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 775
            if (*v2) {
              {
#line 775
              tmp___32 = __ctype_b_loc();
              }
#line 775
              if (! ((int const   )*(*tmp___32 + (int )*v2) & 2048)) {
#line 775
                goto while_break___14;
              }
            } else {
#line 775
              goto while_break___14;
            }
#line 775
            *p2___0 = *v2;
#line 775
            v2 ++;
#line 775
            p2___0 ++;
          }
          while_break___14: /* CIL Label */ ;
          }
          {
#line 776
          tmp___33 = (spif_char_t )0;
#line 776
          *p2___0 = tmp___33;
#line 776
          *p1___0 = tmp___33;
#line 779
          tmp___34 = strtol((char const   */* __restrict  */)((char *)(buff1)), (char **/* __restrict  */)((char **)((void *)0)),
                            10);
#line 779
          ival1___0 = (spif_int32_t )tmp___34;
#line 780
          tmp___35 = strtol((char const   */* __restrict  */)((char *)(buff2)), (char **/* __restrict  */)((char **)((void *)0)),
                            10);
#line 780
          ival2___0 = (spif_int32_t )tmp___35;
          }
          {
#line 781
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 781
            if (libast_debug_level >= 3U) {
              {
#line 781
              while (1) {
                while_continue___16: /* CIL Label */ ;
                {
#line 781
                tmp___36 = time((time_t *)((void *)0));
#line 781
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                        (unsigned long )tmp___36, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                        781, "spiftool_version_compare");
#line 781
                libast_dprintf("     -> Comparing as integers %d vs. %d\n", ival1___0,
                               ival2___0);
                }
#line 781
                goto while_break___16;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
#line 781
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 784
          if (ival1___0 - ival2___0 < 0) {
#line 784
            c___0 = (spif_cmp_t )-1;
          } else {
#line 784
            if (ival1___0 - ival2___0 > 0) {
#line 784
              tmp___37 = 1;
            } else {
#line 784
              tmp___37 = 0;
            }
#line 784
            c___0 = (spif_cmp_t )tmp___37;
          }
#line 785
          if (! ((int )c___0 == 0)) {
            {
#line 786
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 786
              if (libast_debug_level >= 3U) {
                {
#line 786
                while (1) {
                  while_continue___18: /* CIL Label */ ;
                  {
#line 786
                  tmp___38 = time((time_t *)((void *)0));
#line 786
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                          (unsigned long )tmp___38, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                          786, "spiftool_version_compare");
#line 786
                  libast_dprintf("     -> %d\n", (int )c___0);
                  }
#line 786
                  goto while_break___18;
                }
                while_break___18: /* CIL Label */ ;
                }
              }
#line 786
              goto while_break___17;
            }
            while_break___17: /* CIL Label */ ;
            }
#line 787
            return (c___0);
          }
        } else {
#line 768
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 789
        tmp___63 = __ctype_b_loc();
        }
#line 789
        if ((int const   )*(*tmp___63 + (int )*v1) & 8) {
          _L___0: /* CIL Label */ 
          {
#line 805
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 805
            if (libast_debug_level >= 3U) {
              {
#line 805
              while (1) {
                while_continue___20: /* CIL Label */ ;
                {
#line 805
                tmp___49 = time((time_t *)((void *)0));
#line 805
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                        (unsigned long )tmp___49, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                        805, "spiftool_version_compare");
#line 805
                libast_dprintf("     -> Comparing as alphanumeric strings \"%s\" vs. \"%s\"\n",
                               buff1, buff2);
                }
#line 805
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
#line 805
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
          {
#line 806
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 806
            if (libast_debug_level >= 3U) {
              {
#line 806
              while (1) {
                while_continue___22: /* CIL Label */ ;
                {
#line 806
                tmp___50 = time((time_t *)((void *)0));
#line 806
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                        (unsigned long )tmp___50, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                        806, "spiftool_version_compare");
#line 806
                tmp___56 = strcasecmp((char const   *)((char *)(buff1)), (char const   *)((char *)(buff2)));
                }
#line 806
                if (tmp___56 < 0) {
#line 806
                  tmp___55 = -1;
                } else {
                  {
#line 806
                  tmp___54 = strcasecmp((char const   *)((char *)(buff1)), (char const   *)((char *)(buff2)));
                  }
#line 806
                  if (tmp___54 > 0) {
#line 806
                    tmp___53 = 1;
                  } else {
#line 806
                    tmp___53 = 0;
                  }
#line 806
                  tmp___55 = tmp___53;
                }
                {
#line 806
                libast_dprintf("     -> %d\n", tmp___55);
                }
#line 806
                goto while_break___22;
              }
              while_break___22: /* CIL Label */ ;
              }
            }
#line 806
            goto while_break___21;
          }
          while_break___21: /* CIL Label */ ;
          }
          {
#line 807
          tmp___62 = strcasecmp((char const   *)((char *)(buff1)), (char const   *)((char *)(buff2)));
          }
#line 807
          if (tmp___62 < 0) {
#line 807
            tmp___61 = -1;
          } else {
            {
#line 807
            tmp___60 = strcasecmp((char const   *)((char *)(buff1)), (char const   *)((char *)(buff2)));
            }
#line 807
            if (tmp___60 > 0) {
#line 807
              tmp___59 = 1;
            } else {
#line 807
              tmp___59 = 0;
            }
#line 807
            tmp___61 = tmp___59;
          }
#line 807
          return ((spif_cmp_t )tmp___61);
        } else {
          {
#line 789
          tmp___64 = __ctype_b_loc();
          }
#line 789
          if ((int const   )*(*tmp___64 + (int )*v2) & 8) {
#line 789
            goto _L___0;
          } else {
#line 790
            p1___1 = buff1;
#line 790
            p2___1 = buff2;
            {
#line 794
            while (1) {
              while_continue___23: /* CIL Label */ ;
#line 794
              if (*v1) {
                {
#line 794
                tmp___39 = __ctype_b_loc();
                }
#line 794
                if ((int const   )*(*tmp___39 + (int )*v1) & 8) {
#line 794
                  goto while_break___23;
                }
              } else {
#line 794
                goto while_break___23;
              }
#line 794
              *p1___1 = *v1;
#line 794
              v1 ++;
#line 794
              p1___1 ++;
            }
            while_break___23: /* CIL Label */ ;
            }
            {
#line 795
            while (1) {
              while_continue___24: /* CIL Label */ ;
#line 795
              if (*v2) {
                {
#line 795
                tmp___40 = __ctype_b_loc();
                }
#line 795
                if ((int const   )*(*tmp___40 + (int )*v2) & 8) {
#line 795
                  goto while_break___24;
                }
              } else {
#line 795
                goto while_break___24;
              }
#line 795
              *p2___1 = *v2;
#line 795
              v2 ++;
#line 795
              p2___1 ++;
            }
            while_break___24: /* CIL Label */ ;
            }
#line 796
            tmp___41 = (spif_char_t )0;
#line 796
            *p2___1 = tmp___41;
#line 796
            *p1___1 = tmp___41;
            {
#line 798
            while (1) {
              while_continue___25: /* CIL Label */ ;
#line 798
              if (libast_debug_level >= 3U) {
                {
#line 798
                while (1) {
                  while_continue___26: /* CIL Label */ ;
                  {
#line 798
                  tmp___42 = time((time_t *)((void *)0));
#line 798
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                          (unsigned long )tmp___42, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                          798, "spiftool_version_compare");
#line 798
                  libast_dprintf("     -> Comparing as non-alphanumeric strings \"%s\" vs. \"%s\"\n",
                                 buff1, buff2);
                  }
#line 798
                  goto while_break___26;
                }
                while_break___26: /* CIL Label */ ;
                }
              }
#line 798
              goto while_break___25;
            }
            while_break___25: /* CIL Label */ ;
            }
            {
#line 799
            tmp___47 = strcasecmp((char const   *)((char *)(buff1)), (char const   *)((char *)(buff2)));
            }
#line 799
            if (tmp___47 < 0) {
#line 799
              c___1 = (spif_cmp_t )-1;
            } else {
              {
#line 799
              tmp___46 = strcasecmp((char const   *)((char *)(buff1)), (char const   *)((char *)(buff2)));
              }
#line 799
              if (tmp___46 > 0) {
#line 799
                tmp___45 = 1;
              } else {
#line 799
                tmp___45 = 0;
              }
#line 799
              c___1 = (spif_cmp_t )tmp___45;
            }
#line 800
            if (! ((int )c___1 == 0)) {
              {
#line 801
              while (1) {
                while_continue___27: /* CIL Label */ ;
#line 801
                if (libast_debug_level >= 3U) {
                  {
#line 801
                  while (1) {
                    while_continue___28: /* CIL Label */ ;
                    {
#line 801
                    tmp___48 = time((time_t *)((void *)0));
#line 801
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                            (unsigned long )tmp___48, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                            801, "spiftool_version_compare");
#line 801
                    libast_dprintf("     -> %d\n", (int )c___1);
                    }
#line 801
                    goto while_break___28;
                  }
                  while_break___28: /* CIL Label */ ;
                  }
                }
#line 801
                goto while_break___27;
              }
              while_break___27: /* CIL Label */ ;
              }
#line 802
              return (c___1);
            }
          }
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 812
  if (*v1) {
    {
#line 813
    tmp___71 = strncasecmp((char const   *)((char *)v1), "snap", sizeof("snap") - 1UL);
    }
#line 813
    if (tmp___71) {
      {
#line 813
      tmp___72 = strncasecmp((char const   *)((char *)v1), "pre", sizeof("pre") - 1UL);
      }
#line 813
      if (tmp___72) {
        {
#line 813
        tmp___73 = strncasecmp((char const   *)((char *)v1), "alpha", sizeof("alpha") - 1UL);
        }
#line 813
        if (tmp___73) {
          {
#line 813
          tmp___74 = strncasecmp((char const   *)((char *)v1), "beta", sizeof("beta") - 1UL);
          }
#line 813
          if (tmp___74) {
            {
#line 818
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 818
              if (libast_debug_level >= 3U) {
                {
#line 818
                while (1) {
                  while_continue___30: /* CIL Label */ ;
                  {
#line 818
                  tmp___70 = time((time_t *)((void *)0));
#line 818
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                          (unsigned long )tmp___70, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                          818, "spiftool_version_compare");
#line 818
                  libast_dprintf("     -> >\n");
                  }
#line 818
                  goto while_break___30;
                }
                while_break___30: /* CIL Label */ ;
                }
              }
#line 818
              goto while_break___29;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 819
            return ((spif_cmp_t )1);
          } else {
            _L___3: /* CIL Label */ 
            {
#line 815
            while (1) {
              while_continue___31: /* CIL Label */ ;
#line 815
              if (libast_debug_level >= 3U) {
                {
#line 815
                while (1) {
                  while_continue___32: /* CIL Label */ ;
                  {
#line 815
                  tmp___69 = time((time_t *)((void *)0));
#line 815
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                          (unsigned long )tmp___69, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                          815, "spiftool_version_compare");
#line 815
                  libast_dprintf("     -> <\n");
                  }
#line 815
                  goto while_break___32;
                }
                while_break___32: /* CIL Label */ ;
                }
              }
#line 815
              goto while_break___31;
            }
            while_break___31: /* CIL Label */ ;
            }
#line 816
            return ((spif_cmp_t )-1);
          }
        } else {
#line 813
          goto _L___3;
        }
      } else {
#line 813
        goto _L___3;
      }
    } else {
#line 813
      goto _L___3;
    }
  } else
#line 821
  if (*v2) {
    {
#line 822
    tmp___77 = strncasecmp((char const   *)((char *)v2), "snap", sizeof("snap") - 1UL);
    }
#line 822
    if (tmp___77) {
      {
#line 822
      tmp___78 = strncasecmp((char const   *)((char *)v2), "pre", sizeof("pre") - 1UL);
      }
#line 822
      if (tmp___78) {
        {
#line 822
        tmp___79 = strncasecmp((char const   *)((char *)v2), "alpha", sizeof("alpha") - 1UL);
        }
#line 822
        if (tmp___79) {
          {
#line 822
          tmp___80 = strncasecmp((char const   *)((char *)v2), "beta", sizeof("beta") - 1UL);
          }
#line 822
          if (tmp___80) {
            {
#line 827
            while (1) {
              while_continue___33: /* CIL Label */ ;
#line 827
              if (libast_debug_level >= 3U) {
                {
#line 827
                while (1) {
                  while_continue___34: /* CIL Label */ ;
                  {
#line 827
                  tmp___76 = time((time_t *)((void *)0));
#line 827
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                          (unsigned long )tmp___76, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                          827, "spiftool_version_compare");
#line 827
                  libast_dprintf("     -> <\n");
                  }
#line 827
                  goto while_break___34;
                }
                while_break___34: /* CIL Label */ ;
                }
              }
#line 827
              goto while_break___33;
            }
            while_break___33: /* CIL Label */ ;
            }
#line 828
            return ((spif_cmp_t )-1);
          } else {
            _L___4: /* CIL Label */ 
            {
#line 824
            while (1) {
              while_continue___35: /* CIL Label */ ;
#line 824
              if (libast_debug_level >= 3U) {
                {
#line 824
                while (1) {
                  while_continue___36: /* CIL Label */ ;
                  {
#line 824
                  tmp___75 = time((time_t *)((void *)0));
#line 824
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                          (unsigned long )tmp___75, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                          824, "spiftool_version_compare");
#line 824
                  libast_dprintf("     -> >\n");
                  }
#line 824
                  goto while_break___36;
                }
                while_break___36: /* CIL Label */ ;
                }
              }
#line 824
              goto while_break___35;
            }
            while_break___35: /* CIL Label */ ;
            }
#line 825
            return ((spif_cmp_t )1);
          }
        } else {
#line 822
          goto _L___4;
        }
      } else {
#line 822
        goto _L___4;
      }
    } else {
#line 822
      goto _L___4;
    }
  }
  {
#line 831
  while (1) {
    while_continue___37: /* CIL Label */ ;
#line 831
    if (libast_debug_level >= 3U) {
      {
#line 831
      while (1) {
        while_continue___38: /* CIL Label */ ;
        {
#line 831
        tmp___81 = time((time_t *)((void *)0));
#line 831
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___81, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/strings.c",
                831, "spiftool_version_compare");
#line 831
        libast_dprintf("     -> ==\n");
        }
#line 831
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
    }
#line 831
    goto while_break___37;
  }
  while_break___37: /* CIL Label */ ;
  }
#line 832
  return ((spif_cmp_t )0);
}
}
#line 223 "../include/libast/objpair.h"
spif_objpair_t spif_objpair_new(void) ;
#line 224
spif_objpair_t spif_objpair_new_from_key(spif_obj_t key ) ;
#line 225
spif_objpair_t spif_objpair_new_from_value(spif_obj_t value ) ;
#line 227
spif_bool_t spif_objpair_del(spif_objpair_t self ) ;
#line 228
spif_bool_t spif_objpair_init(spif_objpair_t self ) ;
#line 229
spif_bool_t spif_objpair_init_from_key(spif_objpair_t self , spif_obj_t key ) ;
#line 230
spif_bool_t spif_objpair_init_from_value(spif_objpair_t self , spif_obj_t value ) ;
#line 231
spif_bool_t spif_objpair_init_from_both(spif_objpair_t self , spif_obj_t key , spif_obj_t value ) ;
#line 232
spif_bool_t spif_objpair_done(spif_objpair_t self ) ;
#line 233
spif_str_t spif_objpair_show(spif_objpair_t self , spif_charptr_t name___0 , spif_str_t buff ,
                             size_t indent ) ;
#line 234
spif_cmp_t spif_objpair_comp(spif_objpair_t self , spif_obj_t other ) ;
#line 235
spif_objpair_t spif_objpair_dup(spif_objpair_t self ) ;
#line 236
spif_classname_t spif_objpair_type(spif_objpair_t self ) ;
#line 237
spif_obj_t spif_objpair_get_key(spif_objpair_t self ) ;
#line 237
spif_bool_t spif_objpair_set_key(spif_objpair_t self , spif_obj_t new_key ) ;
#line 238
spif_obj_t spif_objpair_get_value(spif_objpair_t self ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
static spif_const_class_t o_class___0  = 
#line 61 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
     {(spif_charptr_t )"!spif_objpair_t!", (void *(*)())(& spif_objpair_new), (void *(*)())(& spif_objpair_init),
    (void *(*)())(& spif_objpair_done), (void *(*)())(& spif_objpair_del), (void *(*)())(& spif_objpair_show),
    (void *(*)())(& spif_objpair_comp), (void *(*)())(& spif_objpair_dup), (void *(*)())(& spif_objpair_type)};
#line 83 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_class_t spif_objpair_class  =    & o_class___0;
#line 116 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_objpair_t spif_objpair_new(void) 
{ 
  spif_objpair_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 121
  tmp = malloc(sizeof(spif_const_objpair_t ));
#line 121
  self = (spif_objpair_t )tmp;
#line 122
  tmp___0 = spif_objpair_init(self);
  }
#line 122
  if (! tmp___0) {
    {
#line 123
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 123
      free((void *)self);
#line 123
      self = (spif_objpair_t )((void *)0);
      }
#line 123
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 124
    self = (spif_objpair_t )((void *)0);
  }
#line 126
  return (self);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_objpair_t spif_objpair_new_from_key(spif_obj_t key ) 
{ 
  spif_objpair_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 145
  tmp = malloc(sizeof(spif_const_objpair_t ));
#line 145
  self = (spif_objpair_t )tmp;
#line 146
  tmp___0 = spif_objpair_init_from_key(self, key);
  }
#line 146
  if (! tmp___0) {
    {
#line 147
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 147
      free((void *)self);
#line 147
      self = (spif_objpair_t )((void *)0);
      }
#line 147
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 148
    self = (spif_objpair_t )((void *)0);
  }
#line 150
  return (self);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_objpair_t spif_objpair_new_from_value(spif_obj_t value ) 
{ 
  spif_objpair_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 169
  tmp = malloc(sizeof(spif_const_objpair_t ));
#line 169
  self = (spif_objpair_t )tmp;
#line 170
  tmp___0 = spif_objpair_init_from_value(self, value);
  }
#line 170
  if (! tmp___0) {
    {
#line 171
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 171
      free((void *)self);
#line 171
      self = (spif_objpair_t )((void *)0);
      }
#line 171
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 172
    self = (spif_objpair_t )((void *)0);
  }
#line 174
  return (self);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_objpair_t spif_objpair_new_from_both(spif_obj_t key , spif_obj_t value ) 
{ 
  spif_objpair_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 195
  tmp = malloc(sizeof(spif_const_objpair_t ));
#line 195
  self = (spif_objpair_t )tmp;
#line 196
  tmp___0 = spif_objpair_init_from_both(self, key, value);
  }
#line 196
  if (! tmp___0) {
    {
#line 197
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 197
      free((void *)self);
#line 197
      self = (spif_objpair_t )((void *)0);
      }
#line 197
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 198
    self = (spif_objpair_t )((void *)0);
  }
#line 200
  return (self);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_bool_t spif_objpair_init(spif_objpair_t self ) 
{ 


  {
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (! ((unsigned long )self == (unsigned long )((spif_objpair_t )((void *)0))))) {
#line 218
      if (libast_debug_level >= 1U) {
        {
#line 218
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                           218, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      } else {
        {
#line 218
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                             218, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      }
#line 218
      return ((spif_bool_t )0);
    }
#line 218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 219
  spif_obj_set_class((spif_obj_t )self, spif_objpair_class);
  }
#line 220
  return ((spif_bool_t )1);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_bool_t spif_objpair_init_from_key(spif_objpair_t self , spif_obj_t key ) 
{ 
  void *tmp ;

  {
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (! ((unsigned long )self == (unsigned long )((spif_objpair_t )((void *)0))))) {
#line 240
      if (libast_debug_level >= 1U) {
        {
#line 240
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_key",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                           240, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      } else {
        {
#line 240
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_key",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                             240, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      }
#line 240
      return ((spif_bool_t )0);
    }
#line 240
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 241
    if (! (! ((unsigned long )key == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 241
      if (libast_debug_level >= 1U) {
        {
#line 241
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_key",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                           241, "!SPIF_OBJ_ISNULL(key)");
        }
      } else {
        {
#line 241
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_key",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                             241, "!SPIF_OBJ_ISNULL(key)");
        }
      }
#line 241
      return ((spif_bool_t )0);
    }
#line 241
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 242
  spif_obj_set_class((spif_obj_t )self, spif_objpair_class);
#line 243
  tmp = (*((key->cls)->dup))(key);
#line 243
  self->key = (spif_obj_t )tmp;
#line 244
  self->value = (spif_obj_t )((void *)0);
  }
#line 245
  return ((spif_bool_t )1);
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_bool_t spif_objpair_init_from_value(spif_objpair_t self , spif_obj_t value ) 
{ 
  void *tmp ;

  {
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (! ((unsigned long )self == (unsigned long )((spif_objpair_t )((void *)0))))) {
#line 265
      if (libast_debug_level >= 1U) {
        {
#line 265
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_value",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                           265, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      } else {
        {
#line 265
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_value",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                             265, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      }
#line 265
      return ((spif_bool_t )0);
    }
#line 265
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 266
    if (! (! ((unsigned long )value == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 266
      if (libast_debug_level >= 1U) {
        {
#line 266
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_value",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                           266, "!SPIF_OBJ_ISNULL(value)");
        }
      } else {
        {
#line 266
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_value",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                             266, "!SPIF_OBJ_ISNULL(value)");
        }
      }
#line 266
      return ((spif_bool_t )0);
    }
#line 266
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 267
  spif_obj_set_class((spif_obj_t )self, spif_objpair_class);
#line 268
  self->key = (spif_obj_t )((void *)0);
#line 269
  tmp = (*((value->cls)->dup))(value);
#line 269
  self->value = (spif_obj_t )tmp;
  }
#line 270
  return ((spif_bool_t )1);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_bool_t spif_objpair_init_from_both(spif_objpair_t self , spif_obj_t key , spif_obj_t value ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! (! ((unsigned long )self == (unsigned long )((spif_objpair_t )((void *)0))))) {
#line 292
      if (libast_debug_level >= 1U) {
        {
#line 292
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_both",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                           292, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      } else {
        {
#line 292
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_both",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                             292, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      }
#line 292
      return ((spif_bool_t )0);
    }
#line 292
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 293
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 293
    if (! (! ((unsigned long )key == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 293
      if (libast_debug_level >= 1U) {
        {
#line 293
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_both",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                           293, "!SPIF_OBJ_ISNULL(key)");
        }
      } else {
        {
#line 293
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_both",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                             293, "!SPIF_OBJ_ISNULL(key)");
        }
      }
#line 293
      return ((spif_bool_t )0);
    }
#line 293
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 294
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 294
    if (! (! ((unsigned long )value == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 294
      if (libast_debug_level >= 1U) {
        {
#line 294
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_both",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                           294, "!SPIF_OBJ_ISNULL(value)");
        }
      } else {
        {
#line 294
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_init_from_both",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                             294, "!SPIF_OBJ_ISNULL(value)");
        }
      }
#line 294
      return ((spif_bool_t )0);
    }
#line 294
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 295
  spif_obj_set_class((spif_obj_t )self, spif_objpair_class);
#line 296
  tmp = (*((key->cls)->dup))(key);
#line 296
  self->key = (spif_obj_t )tmp;
#line 297
  tmp___0 = (*((value->cls)->dup))(value);
#line 297
  self->value = (spif_obj_t )tmp___0;
  }
#line 298
  return ((spif_bool_t )1);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_bool_t spif_objpair_done(spif_objpair_t self ) 
{ 


  {
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (! ((unsigned long )self == (unsigned long )((spif_objpair_t )((void *)0))))) {
#line 316
      if (libast_debug_level >= 1U) {
        {
#line 316
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                           316, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      } else {
        {
#line 316
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                             316, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      }
#line 316
      return ((spif_bool_t )0);
    }
#line 316
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  if (! ((unsigned long )self->key == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 318
    (*(((self->key)->cls)->del))(self->key);
    }
  }
#line 320
  self->key = (spif_obj_t )((void *)0);
#line 321
  if (! ((unsigned long )self->value == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 322
    (*(((self->value)->cls)->del))(self->value);
    }
  }
#line 324
  self->value = (spif_obj_t )((void *)0);
#line 326
  return ((spif_bool_t )1);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_bool_t spif_objpair_del(spif_objpair_t self ) 
{ 


  {
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (! ((unsigned long )self == (unsigned long )((spif_objpair_t )((void *)0))))) {
#line 345
      if (libast_debug_level >= 1U) {
        {
#line 345
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                           345, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      } else {
        {
#line 345
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                             345, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      }
#line 345
      return ((spif_bool_t )0);
    }
#line 345
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 346
  spif_objpair_done(self);
  }
  {
#line 347
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 347
    free((void *)self);
#line 347
    self = (spif_objpair_t )((void *)0);
    }
#line 347
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 348
  return ((spif_bool_t )1);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_str_t spif_objpair_show(spif_objpair_t self , spif_charptr_t name___0 , spif_str_t buff ,
                             size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  char *tmp___0 ;

  {
#line 372
  if ((unsigned long )self == (unsigned long )((spif_objpair_t )((void *)0))) {
    {
#line 373
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 373
      memset((void *)(tmp), ' ', indent);
      }
#line 373
      if ((char *)name___0) {
#line 373
        tmp___0 = (char *)name___0;
      } else {
#line 373
        tmp___0 = (char *)"<name null>";
      }
      {
#line 373
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_objpair_t) %s:  { ((spif_objpair_t) NULL) }\n",
               tmp___0);
      }
#line 373
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 373
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 373
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 373
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 374
    return (buff);
  }
  {
#line 377
  memset((void *)(tmp), ' ', indent);
#line 378
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_objpair_t) %s:  %10p \"%s\"\n",
           name___0, (spif_ptr_t )self, (spif_classname_t )((spif_obj_t )self)->cls);
  }
#line 381
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 382
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 384
    spif_str_append_from_ptr(buff, tmp);
    }
  }
#line 386
  return (buff);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_cmp_t spif_objpair_comp(spif_objpair_t self , spif_obj_t other ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 405
      if ((unsigned long )other == (unsigned long )((spif_obj_t )((void *)0))) {
#line 405
        return ((spif_cmp_t )0);
      } else {
#line 405
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 405
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 405
      return ((spif_cmp_t )-1);
    } else
#line 405
    if ((unsigned long )other == (unsigned long )((spif_obj_t )((void *)0))) {
#line 405
      return ((spif_cmp_t )1);
    }
#line 405
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  if (! ((unsigned long )other == (unsigned long )((spif_obj_t )((void *)0)))) {
#line 406
    if ((unsigned long )other->cls == (unsigned long )spif_objpair_class) {
      {
#line 407
      tmp = (*(((self->key)->cls)->comp))(self->key, ((spif_objpair_t )other)->key);
      }
#line 407
      return ((spif_cmp_t )tmp);
    } else {
      {
#line 409
      tmp___0 = (*(((self->key)->cls)->comp))(self->key, other);
      }
#line 409
      return ((spif_cmp_t )tmp___0);
    }
  } else {
    {
#line 409
    tmp___0 = (*(((self->key)->cls)->comp))(self->key, other);
    }
#line 409
    return ((spif_cmp_t )tmp___0);
  }
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_objpair_t spif_objpair_dup(spif_objpair_t self ) 
{ 
  spif_objpair_t tmp ;

  {
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (! ((unsigned long )self == (unsigned long )((spif_objpair_t )((void *)0))))) {
#line 429
      if (libast_debug_level >= 1U) {
        {
#line 429
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                           429, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      } else {
        {
#line 429
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                             429, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      }
#line 429
      return ((spif_objpair_t )((void *)0));
    }
#line 429
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 430
  tmp = spif_objpair_new_from_both(self->key, self->value);
  }
#line 430
  return (tmp);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_classname_t spif_objpair_type(spif_objpair_t self ) 
{ 


  {
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    if (! (! ((unsigned long )self == (unsigned long )((spif_objpair_t )((void *)0))))) {
#line 448
      if (libast_debug_level >= 1U) {
        {
#line 448
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                           448, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      } else {
        {
#line 448
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_objpair_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c",
                             448, "!SPIF_OBJPAIR_ISNULL(self)");
        }
      }
#line 448
      return ((spif_classname_t )((void *)0));
    }
#line 448
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_obj_t spif_objpair_get_key(spif_objpair_t self ) 
{ 


  {
#line 452
  return (self->key);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_bool_t spif_objpair_set_key(spif_objpair_t self , spif_obj_t new_key ) 
{ 


  {
#line 452
  if (! ((unsigned long )self->key == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 452
    (*(((self->key)->cls)->del))(self->key);
    }
  }
#line 452
  self->key = new_key;
#line 452
  return ((spif_bool_t )1);
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_obj_t spif_objpair_get_value(spif_objpair_t self ) 
{ 


  {
#line 453
  return (self->value);
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/objpair.c"
spif_bool_t spif_objpair_set_value(spif_objpair_t self , spif_obj_t new_value ) 
{ 


  {
#line 453
  if (! ((unsigned long )self->value == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 453
    (*(((self->value)->cls)->del))(self->value);
    }
  }
#line 453
  self->value = new_value;
#line 453
  return ((spif_bool_t )1);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __h_errno_location)(void)  __attribute__((__const__)) ;
#line 95
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) hstrerror)(int __err_num ) ;
#line 137
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 83 "../include/libast/socket.h"
spif_class_t spif_socket_class ;
#line 84
spif_socket_t spif_socket_new(void) ;
#line 85
spif_socket_t spif_socket_new_from_urls(spif_url_t surl , spif_url_t durl ) ;
#line 86
spif_bool_t spif_socket_del(spif_socket_t self ) ;
#line 87
spif_bool_t spif_socket_init(spif_socket_t self ) ;
#line 88
spif_bool_t spif_socket_init_from_urls(spif_socket_t self , spif_url_t surl , spif_url_t durl ) ;
#line 89
spif_bool_t spif_socket_done(spif_socket_t self ) ;
#line 90
spif_str_t spif_socket_show(spif_socket_t self , spif_charptr_t name___0 , spif_str_t buff ,
                            size_t indent ) ;
#line 91
spif_cmp_t spif_socket_comp(spif_socket_t self , spif_socket_t other ) ;
#line 92
spif_socket_t spif_socket_dup(spif_socket_t self ) ;
#line 93
spif_classname_t spif_socket_type(spif_socket_t self ) ;
#line 94
spif_bool_t spif_socket_open(spif_socket_t self ) ;
#line 95
spif_bool_t spif_socket_close(spif_socket_t self ) ;
#line 96
spif_bool_t spif_socket_check_io(spif_socket_t self ) ;
#line 97
spif_socket_t spif_socket_accept(spif_socket_t self ) ;
#line 98
spif_bool_t spif_socket_send(spif_socket_t self , spif_str_t data ) ;
#line 99
spif_str_t spif_socket_recv(spif_socket_t self ) ;
#line 100
spif_bool_t spif_socket_set_nbio(spif_socket_t self ) ;
#line 101
spif_bool_t spif_socket_clear_nbio(spif_socket_t self ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
static spif_url_t spif_url_new_from_ipaddr(spif_ipsockaddr_t ipaddr ) ;
#line 33
static spif_bool_t spif_url_init_from_ipaddr(spif_url_t self , spif_ipsockaddr_t ipaddr ) ;
#line 34
static spif_url_t spif_url_new_from_unixaddr(spif_unixsockaddr_t unixaddr ) ;
#line 35
static spif_bool_t spif_url_init_from_unixaddr(spif_url_t self , spif_unixsockaddr_t unixaddr ) ;
#line 36
static spif_ipsockaddr_t spif_url_get_ipaddr(spif_url_t self ) ;
#line 37
static spif_unixsockaddr_t spif_url_get_unixaddr(spif_url_t self ) ;
#line 38
static spif_sockport_t spif_url_get_portnum(spif_url_t self ) ;
#line 39
static spif_bool_t spif_socket_get_proto(spif_socket_t self ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
static spif_const_class_t s_class___0  = 
#line 42
     {(spif_charptr_t )"!spif_socket_t!", (void *(*)())(& spif_socket_new), (void *(*)())(& spif_socket_init),
    (void *(*)())(& spif_socket_done), (void *(*)())(& spif_socket_del), (void *(*)())(& spif_socket_show),
    (void *(*)())(& spif_socket_comp), (void *(*)())(& spif_socket_dup), (void *(*)())(& spif_socket_type)};
#line 53 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_class_t spif_socket_class  =    & s_class___0;
#line 56 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_socket_t spif_socket_new(void) 
{ 
  spif_socket_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 61
  tmp = malloc(sizeof(spif_const_socket_t ));
#line 61
  self = (spif_socket_t )tmp;
#line 62
  tmp___0 = spif_socket_init(self);
  }
#line 62
  if (! tmp___0) {
    {
#line 63
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 63
      free((void *)self);
#line 63
      self = (spif_socket_t )((void *)0);
      }
#line 63
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 64
    self = (spif_socket_t )((void *)0);
  }
#line 66
  return (self);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_socket_t spif_socket_new_from_urls(spif_url_t surl , spif_url_t durl ) 
{ 
  spif_socket_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 74
  tmp = malloc(sizeof(spif_const_socket_t ));
#line 74
  self = (spif_socket_t )tmp;
#line 75
  tmp___0 = spif_socket_init_from_urls(self, surl, durl);
  }
#line 75
  if (! tmp___0) {
    {
#line 76
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 76
      free((void *)self);
#line 76
      self = (spif_socket_t )((void *)0);
      }
#line 76
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 77
    self = (spif_socket_t )((void *)0);
  }
#line 79
  return (self);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_bool_t spif_socket_init(spif_socket_t self ) 
{ 


  {
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 85
      if (libast_debug_level >= 1U) {
        {
#line 85
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           85, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 85
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             85, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 85
      return ((spif_bool_t )0);
    }
#line 85
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  spif_obj_set_class((spif_obj_t )self, spif_socket_class);
#line 88
  self->fd = -1;
#line 89
  self->fam = 2;
#line 90
  self->type = 1;
#line 91
  self->proto = 0;
#line 92
  self->addr = (spif_sockaddr_t )((void *)0);
#line 93
  self->len = (spif_sockaddr_len_t )0;
#line 94
  self->flags = (spif_uint32_t )0;
#line 95
  self->local_url = (spif_url_t )((void *)0);
#line 96
  self->remote_url = (spif_url_t )((void *)0);
  }
#line 97
  return ((spif_bool_t )1);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_bool_t spif_socket_init_from_urls(spif_socket_t self , spif_url_t surl , spif_url_t durl ) 
{ 


  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 103
      if (libast_debug_level >= 1U) {
        {
#line 103
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_init_from_urls",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           103, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 103
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_init_from_urls",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             103, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 103
      return ((spif_bool_t )0);
    }
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  spif_obj_set_class((spif_obj_t )self, spif_socket_class);
#line 106
  self->fd = -1;
#line 107
  self->fam = 2;
#line 108
  self->type = 1;
#line 109
  self->proto = 0;
#line 110
  self->addr = (spif_sockaddr_t )((void *)0);
#line 111
  self->len = (spif_sockaddr_len_t )0;
#line 112
  self->flags = (spif_uint32_t )0;
  }
#line 113
  if (! ((unsigned long )surl == (unsigned long )((spif_url_t )((void *)0)))) {
    {
#line 114
    self->local_url = spif_url_dup(surl);
    }
  } else {
#line 116
    self->local_url = (spif_url_t )((void *)0);
  }
#line 118
  if (! ((unsigned long )durl == (unsigned long )((spif_url_t )((void *)0)))) {
    {
#line 119
    self->remote_url = spif_url_dup(durl);
    }
  } else {
#line 121
    self->remote_url = (spif_url_t )((void *)0);
  }
#line 123
  return ((spif_bool_t )1);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_bool_t spif_socket_done(spif_socket_t self ) 
{ 


  {
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 129
      if (libast_debug_level >= 1U) {
        {
#line 129
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           129, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 129
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             129, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 129
      return ((spif_bool_t )0);
    }
#line 129
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  if (self->fd >= 0) {
    {
#line 131
    spif_socket_close(self);
    }
  }
#line 133
  self->fam = 2;
#line 134
  self->type = 1;
#line 135
  self->proto = 0;
#line 136
  if ((unsigned long )self->addr != (unsigned long )((spif_sockaddr_t )((void *)0))) {
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 137
      free((void *)self->addr);
#line 137
      self->addr = (spif_sockaddr_t )((void *)0);
      }
#line 137
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 138
    self->addr = (spif_sockaddr_t )((void *)0);
  }
#line 140
  self->len = (spif_sockaddr_len_t )0;
#line 141
  self->flags = (spif_uint32_t )0;
#line 142
  if (! ((unsigned long )self->local_url == (unsigned long )((spif_url_t )((void *)0)))) {
    {
#line 143
    spif_url_del(self->local_url);
#line 144
    self->local_url = (spif_url_t )((void *)0);
    }
  }
#line 146
  if (! ((unsigned long )self->remote_url == (unsigned long )((spif_url_t )((void *)0)))) {
    {
#line 147
    spif_url_del(self->remote_url);
#line 148
    self->remote_url = (spif_url_t )((void *)0);
    }
  }
#line 150
  return ((spif_bool_t )1);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_bool_t spif_socket_del(spif_socket_t self ) 
{ 


  {
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 156
      if (libast_debug_level >= 1U) {
        {
#line 156
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           156, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 156
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             156, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 156
      return ((spif_bool_t )0);
    }
#line 156
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  spif_socket_done(self);
  }
  {
#line 158
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 158
    free((void *)self);
#line 158
    self = (spif_socket_t )((void *)0);
    }
#line 158
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 159
  return ((spif_bool_t )1);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_str_t spif_socket_show(spif_socket_t self , spif_charptr_t name___0 , spif_str_t buff ,
                            size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  char *tmp___0 ;

  {
#line 167
  if ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))) {
    {
#line 168
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      memset((void *)(tmp), ' ', indent);
      }
#line 168
      if ((char *)name___0) {
#line 168
        tmp___0 = (char *)name___0;
      } else {
#line 168
        tmp___0 = (char *)"<name null>";
      }
      {
#line 168
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_socket_t) %s:  { ((spif_socket_t) NULL) }\n",
               tmp___0);
      }
#line 168
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 168
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 168
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 168
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 169
    return (buff);
  }
  {
#line 172
  memset((void *)(tmp), ' ', indent);
#line 173
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_socket_t) %s:  %10p {\n", name___0,
           (spif_ptr_t )self);
  }
#line 176
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 177
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 179
    spif_str_append_from_ptr(buff, tmp);
    }
  }
  {
#line 182
  indent += 2UL;
#line 183
  memset((void *)(tmp), ' ', indent);
#line 184
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_sockfd_t) fd:  %d\n", self->fd);
#line 185
  spif_str_append_from_ptr(buff, tmp);
#line 187
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_sockfamily_t) fam:  %d\n", self->fam);
#line 188
  spif_str_append_from_ptr(buff, tmp);
#line 190
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_socktype_t) type:  %d\n", self->type);
#line 191
  spif_str_append_from_ptr(buff, tmp);
#line 193
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_sockproto_t) proto:  %d\n", self->proto);
#line 194
  spif_str_append_from_ptr(buff, tmp);
#line 196
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_sockaddr_t) addr:  %10p\n", (spif_ptr_t )self->addr);
#line 197
  spif_str_append_from_ptr(buff, tmp);
#line 199
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_sockaddr_len_t) len:  %lu\n", (unsigned long )self->len);
#line 200
  spif_str_append_from_ptr(buff, tmp);
#line 202
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_uint32_t) flags:  0x%08x\n", self->flags);
#line 203
  spif_str_append_from_ptr(buff, tmp);
#line 205
  spif_url_show(self->local_url, (spif_charptr_t )"local_url", buff, indent);
#line 206
  spif_url_show(self->remote_url, (spif_charptr_t )"remote_url", buff, indent);
#line 208
  indent -= 2UL;
#line 209
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"}\n");
#line 210
  spif_str_append_from_ptr(buff, tmp);
  }
#line 212
  return (buff);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_cmp_t spif_socket_comp(spif_socket_t self , spif_socket_t other ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 218
  if (self->fd - other->fd < 0) {
#line 218
    tmp___0 = -1;
  } else {
#line 218
    if (self->fd - other->fd > 0) {
#line 218
      tmp = 1;
    } else {
#line 218
      tmp = 0;
    }
#line 218
    tmp___0 = tmp;
  }
#line 218
  return ((spif_cmp_t )tmp___0);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_socket_t spif_socket_dup(spif_socket_t self ) 
{ 
  spif_socket_t tmp ;
  void *tmp___0 ;

  {
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 226
      if (libast_debug_level >= 1U) {
        {
#line 226
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           226, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 226
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             226, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 226
      return ((spif_socket_t )((void *)0));
    }
#line 226
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 227
  tmp = spif_socket_new();
  }
#line 228
  if (self->fd >= 0) {
    {
#line 229
    tmp->fd = dup(self->fd);
    }
  }
#line 231
  tmp->fam = self->fam;
#line 232
  tmp->type = self->type;
#line 233
  tmp->proto = self->proto;
#line 234
  tmp->len = self->len;
#line 235
  if ((unsigned long )self->addr != (unsigned long )((spif_sockaddr_t )((void *)0))) {
    {
#line 236
    tmp___0 = malloc((size_t )tmp->len);
#line 236
    tmp->addr = (spif_sockaddr_t )tmp___0;
#line 237
    memcpy((void */* __restrict  */)tmp->addr, (void const   */* __restrict  */)self->addr,
           (size_t )tmp->len);
    }
  }
#line 239
  tmp->flags = self->flags;
#line 240
  if (! ((unsigned long )self->local_url == (unsigned long )((spif_url_t )((void *)0)))) {
    {
#line 241
    tmp->local_url = spif_url_dup(self->local_url);
    }
  }
#line 243
  if (! ((unsigned long )self->remote_url == (unsigned long )((spif_url_t )((void *)0)))) {
    {
#line 244
    tmp->remote_url = spif_url_dup(self->remote_url);
    }
  }
#line 246
  return (tmp);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_classname_t spif_socket_type(spif_socket_t self ) 
{ 


  {
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 252
      if (libast_debug_level >= 1U) {
        {
#line 252
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           252, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 252
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             252, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 252
      return ((spif_classname_t )((void *)0));
    }
#line 252
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_bool_t spif_socket_open(spif_socket_t self ) 
{ 
  spif_ipsockaddr_t tmp ;
  spif_unixsockaddr_t tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  spif_ipsockaddr_t addr ;
  time_t tmp___6 ;
  uint16_t tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  spif_charptr_t tmp___10 ;
  int tmp___11 ;
  spif_unixsockaddr_t addr___0 ;
  int *tmp___12 ;
  char *tmp___13 ;
  spif_charptr_t tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  spif_charptr_t tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  spif_charptr_t tmp___22 ;
  int tmp___23 ;

  {
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 259
      if (libast_debug_level >= 1U) {
        {
#line 259
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_open",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           259, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 259
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_open",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             259, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 259
      return ((spif_bool_t )0);
    }
#line 259
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  if (! self->addr) {
    {
#line 263
    spif_socket_get_proto(self);
    }
#line 266
    if ((unsigned long )self->flags & 1UL) {
#line 267
      self->fam = 2;
#line 268
      if (! ((unsigned long )self->remote_url == (unsigned long )((spif_url_t )((void *)0)))) {
        {
#line 269
        tmp = spif_url_get_ipaddr(self->remote_url);
#line 269
        self->addr = (spif_sockaddr_t )tmp;
        }
      } else {
#line 271
        self->addr = (spif_sockaddr_t )((void *)0);
      }
#line 273
      if ((unsigned long )self->addr == (unsigned long )((spif_sockaddr_t )((void *)0))) {
#line 274
        self->len = (spif_sockaddr_len_t )0;
      } else {
#line 276
        self->len = (spif_sockaddr_len_t )sizeof(spif_const_ipsockaddr_t );
      }
    } else
#line 278
    if ((unsigned long )self->flags & (1UL << 1)) {
#line 279
      self->fam = 1;
#line 280
      if (! ((unsigned long )self->remote_url == (unsigned long )((spif_url_t )((void *)0)))) {
        {
#line 281
        tmp___0 = spif_url_get_unixaddr(self->remote_url);
#line 281
        self->addr = (spif_sockaddr_t )tmp___0;
        }
      } else {
#line 283
        self->addr = (spif_sockaddr_t )((void *)0);
      }
#line 285
      if ((unsigned long )self->addr == (unsigned long )((spif_sockaddr_t )((void *)0))) {
#line 286
        self->len = (spif_sockaddr_len_t )0;
      } else {
#line 288
        self->len = (spif_sockaddr_len_t )sizeof(spif_const_unixsockaddr_t );
      }
    } else {
      {
#line 291
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 291
        if (libast_debug_level >= 2U) {
          {
#line 291
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 291
            tmp___1 = time((time_t *)((void *)0));
#line 291
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                    (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                    291, "spif_socket_open");
#line 291
            libast_dprintf("Unknown socket family 0x%08x!\n", self->flags & 15U);
            }
#line 291
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 291
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 292
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 292
        if (libast_debug_level >= 1U) {
          {
#line 292
          libast_fatal_error("ASSERT failed in %s() at %s:%d:  This code should not be reached.\n",
                             "spif_socket_open", "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             292);
          }
        } else {
          {
#line 292
          libast_print_warning("ASSERT failed in %s() at %s:%d:  This code should not be reached.\n",
                               "spif_socket_open", "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                               292);
          }
        }
#line 292
        return ((spif_bool_t )0);
#line 292
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 297
  if (self->fd < 0) {
#line 298
    if ((unsigned long )self->flags & (1UL << 4)) {
#line 299
      self->type = 1;
    } else
#line 300
    if ((unsigned long )self->flags & (1UL << 5)) {
#line 301
      self->type = 2;
    } else
#line 302
    if ((unsigned long )self->flags & (1UL << 6)) {
#line 303
      self->type = 3;
    } else {
      {
#line 305
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 305
        if (libast_debug_level >= 2U) {
          {
#line 305
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 305
            tmp___2 = time((time_t *)((void *)0));
#line 305
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                    (unsigned long )tmp___2, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                    305, "spif_socket_open");
#line 305
            libast_dprintf("Unknown socket type 0x%08x!\n", self->flags & (unsigned int )(15 << 4));
            }
#line 305
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 305
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 306
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 306
        if (libast_debug_level >= 1U) {
          {
#line 306
          libast_fatal_error("ASSERT failed in %s() at %s:%d:  This code should not be reached.\n",
                             "spif_socket_open", "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             306);
          }
        } else {
          {
#line 306
          libast_print_warning("ASSERT failed in %s() at %s:%d:  This code should not be reached.\n",
                               "spif_socket_open", "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                               306);
          }
        }
#line 306
        return ((spif_bool_t )0);
#line 306
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 309
    tmp___3 = socket(self->fam, self->type, self->proto);
#line 309
    self->fd = tmp___3;
    }
#line 310
    if (self->fd < 0) {
      {
#line 311
      tmp___4 = __errno_location();
#line 311
      tmp___5 = strerror(*tmp___4);
#line 311
      libast_print_error("Unable to create socket(%d, %d, %d) -- %s\n", self->fam,
                         self->type, self->proto, tmp___5);
      }
#line 313
      return ((spif_bool_t )0);
    }
#line 317
    if (! ((unsigned long )self->local_url == (unsigned long )((spif_url_t )((void *)0)))) {
#line 318
      if ((unsigned long )self->flags & 1UL) {
        {
#line 321
        addr = spif_url_get_ipaddr(self->local_url);
        }
        {
#line 323
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 323
          if (libast_debug_level >= 2U) {
            {
#line 323
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 323
              tmp___6 = time((time_t *)((void *)0));
#line 323
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                      (unsigned long )tmp___6, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                      323, "spif_socket_open");
#line 323
              tmp___7 = ntohs(addr->sin_port);
#line 323
              libast_dprintf("Binding to port %d\n", (int )tmp___7);
              }
#line 323
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
#line 323
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 324
        tmp___11 = bind(self->fd, (struct sockaddr  const  */* __restrict  */)((spif_sockaddr_t )addr),
                        (socklen_t )sizeof(spif_const_ipsockaddr_t ));
        }
#line 324
        if (tmp___11) {
          {
#line 325
          tmp___8 = __errno_location();
#line 325
          tmp___9 = strerror(*tmp___8);
          }
#line 325
          if ((unsigned long )((spif_obj_t )self->local_url) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 325
            tmp___10 = (spif_charptr_t )"";
          } else {
#line 325
            tmp___10 = ((spif_str_t )self->local_url)->s;
          }
          {
#line 325
          libast_print_error("Unable to bind socket %d to %s -- %s\n", self->fd, (spif_charptr_t const   )tmp___10,
                             tmp___9);
          }
          {
#line 327
          while (1) {
            while_continue___8: /* CIL Label */ ;
            {
#line 327
            free((void *)addr);
#line 327
            addr = (spif_ipsockaddr_t )((void *)0);
            }
#line 327
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 328
          return ((spif_bool_t )0);
        }
        {
#line 330
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 330
          free((void *)addr);
#line 330
          addr = (spif_ipsockaddr_t )((void *)0);
          }
#line 330
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      } else
#line 331
      if ((unsigned long )self->flags & (1UL << 1)) {
        {
#line 334
        addr___0 = spif_url_get_unixaddr(self->local_url);
#line 336
        tmp___15 = bind(self->fd, (struct sockaddr  const  */* __restrict  */)((spif_sockaddr_t )addr___0),
                        (socklen_t )sizeof(spif_const_unixsockaddr_t ));
        }
#line 336
        if (tmp___15) {
          {
#line 337
          tmp___12 = __errno_location();
#line 337
          tmp___13 = strerror(*tmp___12);
          }
#line 337
          if ((unsigned long )((spif_obj_t )self->local_url) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 337
            tmp___14 = (spif_charptr_t )"";
          } else {
#line 337
            tmp___14 = ((spif_str_t )self->local_url)->s;
          }
          {
#line 337
          libast_print_error("Unable to bind socket %d to %s -- %s\n", self->fd, (spif_charptr_t const   )tmp___14,
                             tmp___13);
          }
          {
#line 339
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 339
            free((void *)addr___0);
#line 339
            addr___0 = (spif_unixsockaddr_t )((void *)0);
            }
#line 339
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 340
          return ((spif_bool_t )0);
        }
        {
#line 342
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 342
          free((void *)addr___0);
#line 342
          addr___0 = (spif_unixsockaddr_t )((void *)0);
          }
#line 342
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
    }
    {
#line 345
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 345
      self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 9));
#line 345
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 349
  if (! ((unsigned long )self->remote_url == (unsigned long )((spif_url_t )((void *)0)))) {
    {
#line 350
    spif_socket_clear_nbio(self);
#line 351
    tmp___19 = connect(self->fd, (struct sockaddr  const  */* __restrict  */)self->addr,
                       self->len);
    }
#line 351
    if (tmp___19 < 0) {
      {
#line 352
      tmp___16 = __errno_location();
#line 352
      tmp___17 = strerror(*tmp___16);
      }
#line 352
      if ((unsigned long )((spif_obj_t )self->remote_url) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 352
        tmp___18 = (spif_charptr_t )"";
      } else {
#line 352
        tmp___18 = ((spif_str_t )self->remote_url)->s;
      }
      {
#line 352
      libast_print_error("Unable to connect socket %d to %s -- %s\n", self->fd, (spif_charptr_t const   )tmp___18,
                         tmp___17);
      }
#line 354
      return ((spif_bool_t )0);
    }
    {
#line 356
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 356
      self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 10));
#line 356
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
  } else
#line 357
  if (! ((unsigned long )self->local_url == (unsigned long )((spif_url_t )((void *)0)))) {
    {
#line 358
    tmp___23 = listen(self->fd, 5);
    }
#line 358
    if (tmp___23 < 0) {
      {
#line 359
      tmp___20 = __errno_location();
#line 359
      tmp___21 = strerror(*tmp___20);
      }
#line 359
      if ((unsigned long )((spif_obj_t )self->local_url) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 359
        tmp___22 = (spif_charptr_t )"";
      } else {
#line 359
        tmp___22 = ((spif_str_t )self->local_url)->s;
      }
      {
#line 359
      libast_print_error("Unable to listen at %s on socket %d -- %s\n", (spif_charptr_t const   )tmp___22,
                         self->fd, tmp___21);
      }
#line 361
      return ((spif_bool_t )0);
    }
    {
#line 363
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 363
      self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 8));
#line 363
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
  }
#line 366
  return ((spif_bool_t )1);
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_bool_t spif_socket_close(spif_socket_t self ) 
{ 
  int ret ;
  time_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 374
      if (libast_debug_level >= 1U) {
        {
#line 374
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_close",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           374, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 374
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_close",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             374, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 374
      return ((spif_bool_t )0);
    }
#line 374
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 375
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 375
    if (! (self->fd >= 0)) {
#line 375
      if (libast_debug_level >= 1U) {
        {
#line 375
        tmp = time((time_t *)((void *)0));
#line 375
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                375, "spif_socket_close");
#line 375
        libast_dprintf("REQUIRE failed:  %s\n", "self->fd >= 0");
        }
      }
#line 375
      return ((spif_bool_t )0);
    }
#line 375
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 376
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 376
    self->flags &= (unsigned int )(~ (255 << 8));
#line 376
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 377
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 378
    ret = close(self->fd);
    }
#line 377
    if (ret < 0) {
      {
#line 377
      tmp___0 = __errno_location();
      }
#line 377
      if (! (*tmp___0 == 4)) {
#line 377
        goto while_break___2;
      }
    } else {
#line 377
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 380
  if (ret < 0) {
    {
#line 381
    tmp___1 = __errno_location();
#line 381
    tmp___2 = strerror(*tmp___1);
#line 381
    libast_print_error("Unable to close socket %d -- %s\n", self->fd, tmp___2);
#line 382
    self->fd = -1;
    }
#line 383
    return ((spif_bool_t )0);
  }
#line 385
  self->fd = -1;
#line 386
  return ((spif_bool_t )1);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
static struct timeval tv  =    {(__time_t )0, (__suseconds_t )0};
#line 389 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_bool_t spif_socket_check_io(spif_socket_t self ) 
{ 
  fd_set read_fds ;
  fd_set write_fds ;
  time_t tmp ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 395
      if (libast_debug_level >= 1U) {
        {
#line 395
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_check_io",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           395, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 395
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_check_io",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             395, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 395
      return ((spif_bool_t )0);
    }
#line 395
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! (self->fd >= 0)) {
#line 396
      if (libast_debug_level >= 1U) {
        {
#line 396
        tmp = time((time_t *)((void *)0));
#line 396
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                396, "spif_socket_check_io");
#line 396
        libast_dprintf("REQUIRE failed:  %s\n", "self->fd >= 0");
        }
      }
#line 396
      return ((spif_bool_t )0);
    }
#line 396
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 398
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 398
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& read_fds.fds_bits[0]): "memory");
#line 398
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 399
  read_fds.fds_bits[self->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << self->fd % (8 * (int )sizeof(__fd_mask ));
  {
#line 400
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 400
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& write_fds.fds_bits[0]): "memory");
#line 400
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 401
  write_fds.fds_bits[self->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << self->fd % (8 * (int )sizeof(__fd_mask ));
#line 402
  tmp___2 = select(self->fd + 1, (fd_set */* __restrict  */)(& read_fds), (fd_set */* __restrict  */)(& write_fds),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 402
  if (tmp___2 < 0) {
    {
#line 403
    tmp___0 = __errno_location();
#line 403
    tmp___1 = strerror(*tmp___0);
#line 403
    libast_print_error("Unable to select() on %d -- %s\n", self->fd, tmp___1);
    }
#line 404
    return ((spif_bool_t )0);
  }
#line 407
  if ((read_fds.fds_bits[self->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << self->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 408
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 408
      self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 11));
#line 408
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
    {
#line 410
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 410
      self->flags = (spif_uint32_t )((unsigned long )self->flags & ~ (1UL << 11));
#line 410
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 412
  if ((write_fds.fds_bits[self->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << self->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 413
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 413
      self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 12));
#line 413
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
    {
#line 415
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 415
      self->flags = (spif_uint32_t )((unsigned long )self->flags & ~ (1UL << 12));
#line 415
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 417
  return ((spif_bool_t )1);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_socket_t spif_socket_accept(spif_socket_t self ) 
{ 
  spif_sockaddr_t addr ;
  spif_sockaddr_len_t len ;
  int newfd ;
  spif_socket_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 428
      if (libast_debug_level >= 1U) {
        {
#line 428
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_accept",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           428, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 428
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_accept",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             428, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 428
      return ((spif_socket_t )((void *)0));
    }
#line 428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 430
  tmp___0 = malloc(sizeof(spif_const_sockaddr_t ));
#line 430
  addr = (spif_sockaddr_t )tmp___0;
#line 431
  len = (spif_sockaddr_len_t )sizeof(spif_const_sockaddr_t );
  }
  {
#line 432
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 433
    newfd = accept(self->fd, (struct sockaddr */* __restrict  */)addr, (socklen_t */* __restrict  */)(& len));
    }
#line 432
    if (newfd < 0) {
      {
#line 432
      tmp___1 = __errno_location();
      }
#line 432
      if (! (*tmp___1 == 11)) {
        {
#line 432
        tmp___2 = __errno_location();
        }
#line 432
        if (! (*tmp___2 == 11)) {
#line 432
          goto while_break___0;
        }
      }
    } else {
#line 432
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 436
  if (newfd < 0) {
    {
#line 437
    tmp___3 = __errno_location();
#line 437
    tmp___4 = strerror(*tmp___3);
#line 437
    libast_print_error("Unable to accept() connection on %d -- %s\n", self->fd, tmp___4);
    }
#line 438
    return ((spif_socket_t )((void *)0));
  }
  {
#line 442
  tmp = spif_socket_dup(self);
#line 443
  tmp->fd = newfd;
  }
  {
#line 444
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 444
    tmp->flags = (spif_uint32_t )((unsigned long )tmp->flags & ~ (((1UL << 8) | (1UL << 11)) | (1UL << 12)));
#line 444
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 445
  if ((unsigned long )self->flags & 1UL) {
    {
#line 446
    tmp->remote_url = spif_url_new_from_ipaddr((spif_ipsockaddr_t )addr);
    }
  } else
#line 447
  if ((unsigned long )self->flags & (1UL << 1)) {
    {
#line 448
    tmp->remote_url = spif_url_new_from_unixaddr((spif_unixsockaddr_t )addr);
    }
  }
  {
#line 450
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 450
    free((void *)addr);
#line 450
    addr = (spif_sockaddr_t )((void *)0);
    }
#line 450
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 451
  if ((unsigned long )self->flags & (1UL << 13)) {
    {
#line 452
    spif_socket_set_nbio(tmp);
    }
  }
#line 454
  return (tmp);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_bool_t spif_socket_send(spif_socket_t self , spif_str_t data ) 
{ 
  size_t len ;
  int num_written ;
  struct timeval tv___0 ;
  time_t tmp ;
  spif_stridx_t tmp___0 ;
  time_t tmp___1 ;
  spif_charptr_t tmp___2 ;
  ssize_t tmp___3 ;
  spif_charptr_t tmp___4 ;
  ssize_t tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  time_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  spif_bool_t b ;
  spif_str_t tmp_buf ;
  spif_charptr_t s ;
  long left ;
  spif_charptr_t tmp___12 ;

  {
#line 462
  tv___0.tv_sec = (__time_t )0;
#line 462
  tv___0.tv_usec = (__suseconds_t )0;
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 464
      if (libast_debug_level >= 1U) {
        {
#line 464
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_send",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           464, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 464
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_send",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             464, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 464
      return ((spif_bool_t )0);
    }
#line 464
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 465
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 465
    if (! (! ((unsigned long )((spif_obj_t )data) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 465
      if (libast_debug_level >= 1U) {
        {
#line 465
        tmp = time((time_t *)((void *)0));
#line 465
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                465, "spif_socket_send");
#line 465
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_STR_ISNULL(data)");
        }
      }
#line 465
      return ((spif_bool_t )0);
    }
#line 465
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 467
  tmp___0 = spif_str_get_len(data);
#line 467
  len = (size_t )tmp___0;
  }
  {
#line 468
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 468
    if (! (len > 0UL)) {
#line 468
      if (libast_debug_level >= 1U) {
        {
#line 468
        tmp___1 = time((time_t *)((void *)0));
#line 468
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                468, "spif_socket_send");
#line 468
        libast_dprintf("REQUIRE failed:  %s\n", "len > 0");
        }
      }
#line 468
      return ((spif_bool_t )0);
    }
#line 468
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 470
  if ((unsigned long )((spif_obj_t )data) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 470
    tmp___2 = (spif_charptr_t )"";
  } else {
#line 470
    tmp___2 = data->s;
  }
  {
#line 470
  tmp___3 = write(self->fd, (void const   *)((spif_charptr_t const   )tmp___2), len);
#line 470
  num_written = (int )tmp___3;
  }
  {
#line 471
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 471
    if (num_written < 0) {
      {
#line 471
      tmp___6 = __errno_location();
      }
#line 471
      if (! (*tmp___6 == 11)) {
        {
#line 471
        tmp___7 = __errno_location();
        }
#line 471
        if (! (*tmp___7 == 4)) {
#line 471
          goto while_break___2;
        }
      }
    } else {
#line 471
      goto while_break___2;
    }
#line 472
    tv___0.tv_usec += 10000L;
#line 473
    if (tv___0.tv_usec == 1000000L) {
#line 474
      tv___0.tv_usec = (__suseconds_t )0;
#line 475
      (tv___0.tv_sec) ++;
    }
    {
#line 477
    select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv___0));
    }
#line 478
    if ((unsigned long )((spif_obj_t )data) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 478
      tmp___4 = (spif_charptr_t )"";
    } else {
#line 478
      tmp___4 = data->s;
    }
    {
#line 478
    tmp___5 = write(self->fd, (void const   *)((spif_charptr_t const   )tmp___4),
                    len);
#line 478
    num_written = (int )tmp___5;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 480
  if (num_written < 0) {
    {
#line 481
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 481
      if (libast_debug_level >= 2U) {
        {
#line 481
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 481
          tmp___8 = time((time_t *)((void *)0));
#line 481
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                  (unsigned long )tmp___8, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                  481, "spif_socket_send");
#line 481
          tmp___9 = __errno_location();
#line 481
          tmp___10 = strerror(*tmp___9);
#line 481
          libast_dprintf("Unable to write to socket %d -- %s\n", self->fd, tmp___10);
          }
#line 481
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 481
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 482
    tmp___11 = __errno_location();
    }
    {
#line 483
    if (*tmp___11 == 27) {
#line 483
      goto case_27;
    }
#line 501
    if (*tmp___11 == 32) {
#line 501
      goto case_32;
    }
#line 501
    if (*tmp___11 == 5) {
#line 501
      goto case_32;
    }
#line 506
    goto switch_default;
    case_27: /* CIL Label */ 
#line 490
    left = (long )len;
#line 490
    if ((unsigned long )((spif_obj_t )data) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 490
      tmp___12 = (spif_charptr_t )"";
    } else {
#line 490
      tmp___12 = data->s;
    }
#line 490
    s = (spif_charptr_t )((spif_charptr_t const   )tmp___12);
    {
#line 490
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 490
      if (! (left > 0L)) {
#line 490
        goto while_break___5;
      }
      {
#line 491
      tmp_buf = spif_str_new_from_buff(s, (spif_stridx_t )1024);
#line 492
      b = spif_socket_send(self, tmp_buf);
      }
#line 493
      if ((unsigned int )b == 0U) {
        {
#line 494
        spif_str_del(tmp_buf);
        }
#line 495
        return (b);
      }
#line 490
      s += 1024;
#line 490
      left -= 1024L;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 499
    goto switch_break;
    case_32: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 502
    close(self->fd);
    }
    switch_default: /* CIL Label */ 
#line 507
    self->fd = -1;
    {
#line 508
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 508
      self->flags &= (unsigned int )(~ (255 << 8));
#line 508
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 509
    return ((spif_bool_t )0);
#line 510
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 513
  return ((spif_bool_t )1);
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_str_t spif_socket_recv(spif_socket_t self ) 
{ 
  spif_str_t new_str ;

  {
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
#line 521
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 521
      if (libast_debug_level >= 1U) {
        {
#line 521
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_recv",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           521, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 521
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_recv",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             521, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 521
      return ((spif_str_t )((void *)0));
    }
#line 521
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 522
  new_str = spif_str_new_from_fd(self->fd);
  }
#line 523
  return (new_str);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_bool_t spif_socket_set_nbio(spif_socket_t self ) 
{ 
  int flags ;
  time_t tmp ;
  int tmp___0 ;

  {
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 531
      if (libast_debug_level >= 1U) {
        {
#line 531
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_set_nbio",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           531, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 531
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_set_nbio",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             531, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 531
      return ((spif_bool_t )0);
    }
#line 531
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 532
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 532
    if (! (self->fd >= 0)) {
#line 532
      if (libast_debug_level >= 1U) {
        {
#line 532
        tmp = time((time_t *)((void *)0));
#line 532
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                532, "spif_socket_set_nbio");
#line 532
        libast_dprintf("REQUIRE failed:  %s\n", "self->fd >= 0");
        }
      }
#line 532
      return ((spif_bool_t )0);
    }
#line 532
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 536
  flags = fcntl(self->fd, 3, 0);
  }
#line 537
  if (flags < 0) {
#line 538
    flags = 2048;
  } else {
#line 540
    flags |= 2048;
  }
  {
#line 542
  tmp___0 = fcntl(self->fd, 4, flags);
  }
#line 542
  if (tmp___0 != 0) {
#line 543
    return ((spif_bool_t )0);
  } else {
    {
#line 545
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 545
      self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 13));
#line 545
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 546
    return ((spif_bool_t )1);
  }
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
spif_bool_t spif_socket_clear_nbio(spif_socket_t self ) 
{ 
  int flags ;
  time_t tmp ;
  int tmp___0 ;

  {
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    if (! (! ((unsigned long )self == (unsigned long )((spif_socket_t )((void *)0))))) {
#line 577
      if (libast_debug_level >= 1U) {
        {
#line 577
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_clear_nbio",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           577, "!SPIF_SOCKET_ISNULL(self)");
        }
      } else {
        {
#line 577
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_clear_nbio",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             577, "!SPIF_SOCKET_ISNULL(self)");
        }
      }
#line 577
      return ((spif_bool_t )0);
    }
#line 577
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 578
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 578
    if (! (self->fd >= 0)) {
#line 578
      if (libast_debug_level >= 1U) {
        {
#line 578
        tmp = time((time_t *)((void *)0));
#line 578
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                578, "spif_socket_clear_nbio");
#line 578
        libast_dprintf("REQUIRE failed:  %s\n", "self->fd >= 0");
        }
      }
#line 578
      return ((spif_bool_t )0);
    }
#line 578
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  flags = fcntl(self->fd, 3, 0);
  }
#line 583
  if (flags < 0) {
#line 584
    flags = 0;
  } else {
#line 586
    flags &= -2049;
  }
  {
#line 588
  tmp___0 = fcntl(self->fd, 4, flags);
  }
#line 588
  if (tmp___0 != 0) {
#line 589
    return ((spif_bool_t )0);
  } else {
    {
#line 591
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 591
      self->flags = (spif_uint32_t )((unsigned long )self->flags & ~ (1UL << 13));
#line 591
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 592
    return ((spif_bool_t )1);
  }
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
static spif_url_t spif_url_new_from_ipaddr(spif_ipsockaddr_t ipaddr ) 
{ 
  spif_url_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 625
  tmp = malloc(sizeof(spif_const_url_t ));
#line 625
  self = (spif_url_t )tmp;
#line 626
  tmp___0 = spif_url_init_from_ipaddr(self, ipaddr);
  }
#line 626
  if (! tmp___0) {
    {
#line 627
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 627
      free((void *)self);
#line 627
      self = (spif_url_t )((void *)0);
      }
#line 627
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 628
    self = (spif_url_t )((void *)0);
  }
#line 630
  return (self);
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
static spif_bool_t spif_url_init_from_ipaddr(spif_url_t self , spif_ipsockaddr_t ipaddr ) 
{ 
  spif_uint8_t tries ;
  spif_hostinfo_t hinfo ;
  int *tmp ;
  int *tmp___0 ;
  spif_charptr_t buff ;
  char *tmp___1 ;
  uint16_t tmp___2 ;

  {
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 639
      if (libast_debug_level >= 1U) {
        {
#line 639
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_init_from_ipaddr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           639, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 639
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_init_from_ipaddr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             639, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 639
      return ((spif_bool_t )0);
    }
#line 639
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  spif_str_init((spif_str_t )self);
#line 641
  spif_obj_set_class((spif_obj_t )self, spif_url_class);
#line 642
  self->proto = (spif_str_t )((void *)0);
#line 643
  self->user = (spif_str_t )((void *)0);
#line 644
  self->passwd = (spif_str_t )((void *)0);
#line 645
  self->path = (spif_str_t )((void *)0);
#line 646
  self->query = (spif_str_t )((void *)0);
#line 649
  tmp = __h_errno_location();
#line 649
  *tmp = 0;
#line 650
  tries = (spif_uint8_t )0;
  }
  {
#line 651
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 652
    tries = (spif_uint8_t )((int )tries + 1);
#line 653
    hinfo = gethostbyaddr((void const   *)((char const   *)(& ipaddr->sin_addr)),
                          (__socklen_t )sizeof(ipaddr->sin_addr), 2);
    }
#line 651
    if ((int )tries <= 3) {
#line 651
      if ((unsigned long )hinfo == (unsigned long )((void *)0)) {
        {
#line 651
        tmp___0 = __h_errno_location();
        }
#line 651
        if (! (*tmp___0 == 2)) {
#line 651
          goto while_break___0;
        }
      } else {
#line 651
        goto while_break___0;
      }
    } else {
#line 651
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 655
  if ((unsigned long )hinfo == (unsigned long )((void *)0)) {
    {
#line 658
    tmp___1 = inet_ntoa(ipaddr->sin_addr);
#line 658
    buff = (spif_charptr_t )tmp___1;
#line 659
    self->host = spif_str_new_from_ptr(buff);
    }
  } else
#line 655
  if ((unsigned long )hinfo->h_name == (unsigned long )((void *)0)) {
    {
#line 658
    tmp___1 = inet_ntoa(ipaddr->sin_addr);
#line 658
    buff = (spif_charptr_t )tmp___1;
#line 659
    self->host = spif_str_new_from_ptr(buff);
    }
  } else {
    {
#line 661
    self->host = spif_str_new_from_ptr((spif_charptr_t )hinfo->h_name);
    }
  }
  {
#line 664
  tmp___2 = ntohs(ipaddr->sin_port);
#line 664
  self->port = spif_str_new_from_num((long )tmp___2);
  }
#line 665
  return ((spif_bool_t )1);
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
static spif_url_t spif_url_new_from_unixaddr(spif_unixsockaddr_t unixaddr ) 
{ 
  spif_url_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 673
  tmp = malloc(sizeof(spif_const_url_t ));
#line 673
  self = (spif_url_t )tmp;
#line 674
  tmp___0 = spif_url_init_from_unixaddr(self, unixaddr);
  }
#line 674
  if (! tmp___0) {
    {
#line 675
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 675
      free((void *)self);
#line 675
      self = (spif_url_t )((void *)0);
      }
#line 675
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 676
    self = (spif_url_t )((void *)0);
  }
#line 678
  return (self);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
static spif_bool_t spif_url_init_from_unixaddr(spif_url_t self , spif_unixsockaddr_t unixaddr ) 
{ 


  {
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 684
      if (libast_debug_level >= 1U) {
        {
#line 684
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_init_from_unixaddr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           684, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 684
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_init_from_unixaddr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             684, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 684
      return ((spif_bool_t )0);
    }
#line 684
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 685
  spif_str_init((spif_str_t )self);
#line 686
  spif_obj_set_class((spif_obj_t )self, spif_url_class);
#line 687
  self->proto = (spif_str_t )((void *)0);
#line 688
  self->user = (spif_str_t )((void *)0);
#line 689
  self->passwd = (spif_str_t )((void *)0);
#line 690
  self->host = (spif_str_t )((void *)0);
#line 691
  self->port = (spif_str_t )((void *)0);
#line 692
  self->query = (spif_str_t )((void *)0);
  }
#line 694
  if ((unsigned long )(unixaddr->sun_path) != (unsigned long )((void *)0)) {
    {
#line 695
    self->path = spif_str_new_from_ptr((spif_charptr_t )(unixaddr->sun_path));
    }
  } else {
#line 697
    self->path = (spif_str_t )((void *)0);
  }
#line 699
  return ((spif_bool_t )1);
}
}
#line 702 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
static spif_ipsockaddr_t spif_url_get_ipaddr(spif_url_t self ) 
{ 
  spif_uint8_t tries ;
  spif_hostinfo_t hinfo ;
  spif_ipsockaddr_t addr ;
  spif_str_t hostname ;
  spif_str_t tmp ;
  time_t tmp___0 ;
  int *tmp___1 ;
  spif_charptr_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  spif_charptr_t tmp___6 ;
  void *tmp___7 ;
  spif_sockport_t tmp___8 ;
  time_t tmp___9 ;
  spif_charptr_t tmp___10 ;
  uint16_t tmp___11 ;
  uint32_t tmp___12 ;

  {
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 710
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 710
      if (libast_debug_level >= 1U) {
        {
#line 710
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_get_ipaddr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           710, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 710
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_get_ipaddr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             710, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 710
      return ((spif_ipsockaddr_t )((void *)0));
    }
#line 710
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 713
  tmp = spif_url_get_host(self);
#line 713
  hostname = tmp;
  }
  {
#line 714
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 714
    if (! (! ((unsigned long )((spif_obj_t )hostname) == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 714
      if (libast_debug_level >= 1U) {
        {
#line 714
        tmp___0 = time((time_t *)((void *)0));
#line 714
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                714, "spif_url_get_ipaddr");
#line 714
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_STR_ISNULL(hostname)");
        }
      }
#line 714
      return ((spif_ipsockaddr_t )((void *)0));
    }
#line 714
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 717
  tmp___1 = __h_errno_location();
#line 717
  *tmp___1 = 0;
#line 718
  tries = (spif_uint8_t )0;
  }
  {
#line 719
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 720
    tries = (spif_uint8_t )((int )tries + 1);
#line 721
    if ((unsigned long )((spif_obj_t )hostname) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 721
      tmp___2 = (spif_charptr_t )"";
    } else {
#line 721
      tmp___2 = hostname->s;
    }
    {
#line 721
    hinfo = gethostbyname((char const   *)((char *)((spif_charptr_t const   )tmp___2)));
    }
#line 719
    if ((int )tries <= 3) {
#line 719
      if ((unsigned long )hinfo == (unsigned long )((void *)0)) {
        {
#line 719
        tmp___3 = __h_errno_location();
        }
#line 719
        if (! (*tmp___3 == 2)) {
#line 719
          goto while_break___1;
        }
      } else {
#line 719
        goto while_break___1;
      }
    } else {
#line 719
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 723
  if ((unsigned long )hinfo == (unsigned long )((void *)0)) {
    {
#line 724
    tmp___4 = __h_errno_location();
#line 724
    tmp___5 = hstrerror(*tmp___4);
    }
#line 724
    if ((unsigned long )((spif_obj_t )hostname) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 724
      tmp___6 = (spif_charptr_t )"";
    } else {
#line 724
      tmp___6 = hostname->s;
    }
    {
#line 724
    libast_print_error("Unable to resolve hostname \"%s\" -- %s\n", (spif_charptr_t const   )tmp___6,
                       tmp___5);
    }
#line 725
    return ((spif_ipsockaddr_t )((void *)0));
  }
#line 728
  if ((unsigned long )hinfo->h_addr_list == (unsigned long )((void *)0)) {
    {
#line 729
    libast_print_error("Invalid address list returned by gethostbyname()\n");
    }
#line 730
    return ((spif_ipsockaddr_t )((void *)0));
  }
  {
#line 734
  tmp___7 = malloc(sizeof(spif_const_ipsockaddr_t ));
#line 734
  addr = (spif_ipsockaddr_t )tmp___7;
#line 735
  addr->sin_family = (sa_family_t )2;
#line 736
  tmp___8 = spif_url_get_portnum(self);
#line 736
  addr->sin_port = htons(tmp___8);
#line 737
  memcpy((void */* __restrict  */)(& addr->sin_addr), (void const   */* __restrict  */)((void *)*(hinfo->h_addr_list + 0)),
         sizeof(addr->sin_addr));
  }
  {
#line 738
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 738
    if (libast_debug_level >= 2U) {
      {
#line 738
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 738
        tmp___9 = time((time_t *)((void *)0));
#line 738
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___9, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                739, "spif_url_get_ipaddr");
        }
#line 738
        if ((unsigned long )((spif_obj_t )hostname) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 738
          tmp___10 = (spif_charptr_t )"";
        } else {
#line 738
          tmp___10 = hostname->s;
        }
        {
#line 738
        tmp___11 = ntohs(addr->sin_port);
#line 738
        tmp___12 = ntohl((uint32_t )*((int *)(& addr->sin_addr)));
#line 738
        libast_dprintf("Got address 0x%08x and port %d for name \"%s\"\n", (long )tmp___12,
                       (int )tmp___11, (spif_charptr_t const   )tmp___10);
        }
#line 738
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 738
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 740
  return (addr);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
static spif_unixsockaddr_t spif_url_get_unixaddr(spif_url_t self ) 
{ 
  spif_unixsockaddr_t addr ;
  void *tmp ;
  spif_str_t tmp___1 ;
  spif_charptr_t tmp___2 ;
  spif_str_t tmp___3 ;

  {
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
#line 748
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 748
      if (libast_debug_level >= 1U) {
        {
#line 748
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_get_unixaddr",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           748, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 748
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_get_unixaddr",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             748, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 748
      return ((spif_unixsockaddr_t )((void *)0));
    }
#line 748
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 751
  tmp = malloc(sizeof(spif_const_unixsockaddr_t ));
#line 751
  addr = (spif_unixsockaddr_t )tmp;
#line 752
  addr->sun_family = (sa_family_t )1;
#line 753
  addr->sun_path[0] = (char)0;
#line 754
  tmp___3 = spif_url_get_path(self);
  }
#line 754
  if ((unsigned long )((spif_obj_t )tmp___3) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 754
    tmp___2 = (spif_charptr_t )"";
  } else {
    {
#line 754
    tmp___1 = spif_url_get_path(self);
#line 754
    tmp___2 = tmp___1->s;
    }
  }
  {
#line 754
  strncat((char */* __restrict  */)(addr->sun_path), (char const   */* __restrict  */)((char *)((spif_charptr_t const   )tmp___2)),
          sizeof(addr->sun_path) - 1UL);
  }
#line 755
  return (addr);
}
}
#line 758 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
static spif_sockport_t spif_url_get_portnum(spif_url_t self ) 
{ 
  spif_str_t port_str ;
  size_t tmp ;

  {
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (! (! ((unsigned long )self == (unsigned long )((spif_url_t )((void *)0))))) {
#line 763
      if (libast_debug_level >= 1U) {
        {
#line 763
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_get_portnum",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           763, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 763
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_url_get_portnum",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             763, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 763
      return ((spif_sockport_t )((void *)0));
    }
#line 763
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 766
  port_str = spif_url_get_port(self);
  }
#line 767
  if (! ((unsigned long )((spif_obj_t )port_str) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 768
    tmp = spif_str_to_num(port_str, 10);
    }
#line 768
    return ((spif_sockport_t )tmp);
  }
#line 771
  return ((spif_sockport_t )0);
}
}
#line 774 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c"
static spif_bool_t spif_socket_get_proto(spif_socket_t self ) 
{ 
  spif_url_t url ;
  spif_protoinfo_t proto ;
  spif_str_t proto_str ;
  spif_servinfo_t serv ;
  time_t tmp ;
  spif_str_t target ;
  spif_charptr_t tmp___0 ;
  spif_charptr_t tmp___1 ;
  spif_charptr_t tmp___2 ;
  time_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  spif_cmp_t tmp___6 ;
  spif_cmp_t tmp___7 ;

  {
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;
#line 782
    if (! (! ((unsigned long )((spif_url_t )self) == (unsigned long )((spif_url_t )((void *)0))))) {
#line 782
      if (libast_debug_level >= 1U) {
        {
#line 782
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_get_proto",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                           782, "!SPIF_URL_ISNULL(self)");
        }
      } else {
        {
#line 782
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_socket_get_proto",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                             782, "!SPIF_URL_ISNULL(self)");
        }
      }
#line 782
      return ((spif_bool_t )0);
    }
#line 782
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 785
  if ((unsigned long )self->remote_url == (unsigned long )((spif_url_t )((void *)0))) {
#line 785
    url = self->local_url;
  } else {
#line 785
    url = self->remote_url;
  }
  {
#line 786
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 786
    if (! (! ((unsigned long )url == (unsigned long )((spif_url_t )((void *)0))))) {
#line 786
      if (libast_debug_level >= 1U) {
        {
#line 786
        tmp = time((time_t *)((void *)0));
#line 786
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                786, "spif_socket_get_proto");
#line 786
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_URL_ISNULL(url)");
        }
      }
#line 786
      return ((spif_bool_t )0);
    }
#line 786
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 788
  proto_str = spif_url_get_proto(url);
  }
#line 789
  if (! ((unsigned long )((spif_obj_t )proto_str) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 790
    tmp___7 = spif_str_cmp_with_ptr(proto_str, (spif_charptr_t )"raw");
    }
#line 790
    if ((int )tmp___7 == 0) {
      {
#line 794
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 794
        self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 6));
#line 794
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 797
      target = spif_url_get_host(url);
      }
#line 798
      if ((unsigned long )((spif_obj_t )target) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 799
        target = spif_url_get_path(url);
        }
#line 800
        if (! ((unsigned long )((spif_obj_t )target) == (unsigned long )((spif_obj_t )((void *)0)))) {
          {
#line 801
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 801
            self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 1));
#line 801
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 804
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 804
          self->flags = (spif_uint32_t )((unsigned long )self->flags | 1UL);
#line 804
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 806
      tmp___6 = spif_str_cmp_with_ptr(proto_str, (spif_charptr_t )"unix");
      }
#line 806
      if ((int )tmp___6 == 0) {
        {
#line 808
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 808
          self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 1));
#line 808
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 809
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 809
          self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 4));
#line 809
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
#line 812
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 812
          self->flags = (spif_uint32_t )((unsigned long )self->flags | 1UL);
#line 812
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 813
        if ((unsigned long )((spif_obj_t )proto_str) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 813
          tmp___0 = (spif_charptr_t )"";
        } else {
#line 813
          tmp___0 = proto_str->s;
        }
        {
#line 813
        proto = getprotobyname((char const   *)((char *)((spif_charptr_t const   )tmp___0)));
        }
#line 814
        if ((unsigned long )proto == (unsigned long )((void *)0)) {
#line 816
          if ((unsigned long )((spif_obj_t )proto_str) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 816
            tmp___1 = (spif_charptr_t )"";
          } else {
#line 816
            tmp___1 = proto_str->s;
          }
          {
#line 816
          serv = getservbyname((char const   *)((char *)((spif_charptr_t const   )tmp___1)),
                               "tcp");
          }
#line 817
          if ((unsigned long )serv == (unsigned long )((void *)0)) {
#line 818
            if ((unsigned long )((spif_obj_t )proto_str) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 818
              tmp___2 = (spif_charptr_t )"";
            } else {
#line 818
              tmp___2 = proto_str->s;
            }
            {
#line 818
            serv = getservbyname((char const   *)((char *)((spif_charptr_t const   )tmp___2)),
                                 "udp");
            }
          }
#line 820
          if ((unsigned long )serv != (unsigned long )((void *)0)) {
            {
#line 822
            proto = getprotobyname((char const   *)serv->s_proto);
            }
            {
#line 823
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 823
              if (! ((unsigned long )proto != (unsigned long )((void *)0))) {
#line 823
                if (libast_debug_level >= 1U) {
                  {
#line 823
                  tmp___3 = time((time_t *)((void *)0));
#line 823
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                          (unsigned long )tmp___3, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/socket.c",
                          823, "spif_socket_get_proto");
#line 823
                  libast_dprintf("REQUIRE failed:  %s\n", "proto != NULL");
                  }
                }
#line 823
                return ((spif_bool_t )0);
              }
#line 823
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
        }
#line 826
        if ((unsigned long )proto != (unsigned long )((void *)0)) {
          {
#line 828
          self->proto = proto->p_proto;
#line 829
          tmp___5 = strcmp((char const   *)proto->p_name, "tcp");
          }
#line 829
          if (tmp___5) {
            {
#line 831
            tmp___4 = strcmp((char const   *)proto->p_name, "udp");
            }
#line 831
            if (! tmp___4) {
              {
#line 832
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 832
                self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 5));
#line 832
                goto while_break___8;
              }
              while_break___8: /* CIL Label */ ;
              }
            }
          } else {
            {
#line 830
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 830
              self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 4));
#line 830
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
        }
      }
    }
  } else {
    {
#line 838
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 838
      self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 1));
#line 838
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 839
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 839
      self->flags = (spif_uint32_t )((unsigned long )self->flags | (1UL << 4));
#line 839
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
#line 841
  return ((spif_bool_t )1);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 1596 "/usr/include/X11/Xlib.h"
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1609
extern Pixmap XCreatePixmap(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int  ) ;
#line 2573
extern int XFreeGC(Display * , GC  ) ;
#line 2582
extern int XFreePixmap(Display * , Pixmap  ) ;
#line 2692 "../include/libast.h"
void spifmem_init(void) ;
#line 2693
void *spifmem_malloc(spif_charptr_t const   filename , unsigned long line , size_t size ) ;
#line 2694
void *spifmem_realloc(spif_charptr_t const   var , spif_charptr_t const   filename ,
                      unsigned long line , void *ptr , size_t size ) ;
#line 2695
void *spifmem_calloc(spif_charptr_t const   filename , unsigned long line , size_t count ,
                     size_t size ) ;
#line 2696
void spifmem_free(spif_charptr_t const   var , spif_charptr_t const   filename , unsigned long line ,
                  void *ptr ) ;
#line 2697
spif_charptr_t spifmem_strdup(spif_charptr_t const   var , spif_charptr_t const   filename ,
                              unsigned long line , spif_charptr_t const   str ) ;
#line 2699
void spifmem_dump_mem_tables(void) ;
#line 2701
Pixmap spifmem_x_create_pixmap(spif_charptr_t const   filename , unsigned long line ,
                               Display *d , Drawable win , unsigned int w , unsigned int h ,
                               unsigned int depth ) ;
#line 2703
void spifmem_x_free_pixmap(spif_charptr_t const   var , spif_charptr_t const   filename ,
                           unsigned long line , Display *d , Pixmap p ) ;
#line 2711
void spifmem_dump_pixmap_tables(void) ;
#line 2712
GC spifmem_x_create_gc(spif_charptr_t const   filename , unsigned long line , Display *d ,
                       Drawable win , unsigned long mask , XGCValues *gcv ) ;
#line 2714
void spifmem_x_free_gc(spif_charptr_t const   var , spif_charptr_t const   filename ,
                       unsigned long line , Display *d , GC gc ) ;
#line 2715
void spifmem_dump_gc_tables(void) ;
#line 2717
void spiftool_free_array(void *list , size_t count ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
static void memrec_add_var(memrec_t *memrec , spif_charptr_t const   filename , unsigned long line ,
                           void *ptr , size_t size ) ;
#line 44
static ptr_t *memrec_find_var(memrec_t *memrec , void const   *ptr ) ;
#line 45
static void memrec_rem_var(memrec_t *memrec , spif_charptr_t const   var , spif_charptr_t const   filename ,
                           unsigned long line , void const   *ptr ) ;
#line 46
static void memrec_chg_var(memrec_t *memrec , spif_charptr_t const   var , spif_charptr_t const   filename ,
                           unsigned long line , void const   *oldp , void *newp ,
                           size_t size ) ;
#line 47
static void memrec_dump_pointers(memrec_t *memrec ) ;
#line 48
static void memrec_dump_resources(memrec_t *memrec ) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
static memrec_t malloc_rec  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
static memrec_t pixmap_rec  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
static memrec_t gc_rec  ;
#line 117 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
void spifmem_init(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 121
  tmp = malloc(sizeof(ptr_t ));
#line 121
  malloc_rec.ptrs = (ptr_t *)tmp;
#line 122
  tmp___0 = malloc(sizeof(ptr_t ));
#line 122
  pixmap_rec.ptrs = (ptr_t *)tmp___0;
#line 123
  tmp___1 = malloc(sizeof(ptr_t ));
#line 123
  gc_rec.ptrs = (ptr_t *)tmp___1;
  }
#line 124
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
static void memrec_add_var(memrec_t *memrec , spif_charptr_t const   filename , unsigned long line ,
                           void *ptr , size_t size ) 
{ 
  register ptr_t *p ;
  ptr_t *tmp ;
  void *tmp___0 ;

  {
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! ((unsigned long )memrec != (unsigned long )((void *)0))) {
#line 149
      if (libast_debug_level >= 1U) {
        {
#line 149
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "memrec_add_var",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                           149, "memrec != NULL");
        }
      } else {
        {
#line 149
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "memrec_add_var",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             149, "memrec != NULL");
        }
#line 149
        return;
      }
    }
#line 149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  (memrec->cnt) ++;
#line 151
  tmp___0 = realloc((void *)memrec->ptrs, sizeof(ptr_t ) * memrec->cnt);
#line 151
  tmp = (ptr_t *)tmp___0;
#line 151
  memrec->ptrs = tmp;
#line 154
  p = (memrec->ptrs + memrec->cnt) - 1;
#line 157
  p->ptr = ptr;
#line 158
  p->size = size;
#line 159
  spiftool_safe_strncpy(p->file, filename, 20);
#line 160
  p->file[20] = (spif_char_t )0;
#line 161
  p->line = (spif_uint32_t )line;
  }
#line 162
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
static ptr_t *memrec_find_var(memrec_t *memrec , void const   *ptr ) 
{ 
  register ptr_t *p ;
  register unsigned long i ;
  time_t tmp ;

  {
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! ((unsigned long )memrec != (unsigned long )((void *)0))) {
#line 184
      if (libast_debug_level >= 1U) {
        {
#line 184
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "memrec_find_var",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                           184, "memrec != NULL");
        }
      } else {
        {
#line 184
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "memrec_find_var",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             184, "memrec != NULL");
        }
      }
#line 184
      return ((ptr_t *)((void *)0));
    }
#line 184
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 185
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 185
      if (libast_debug_level >= 1U) {
        {
#line 185
        tmp = time((time_t *)((void *)0));
#line 185
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                185, "memrec_find_var");
#line 185
        libast_dprintf("REQUIRE failed:  %s\n", "ptr != NULL");
        }
      }
#line 185
      return ((ptr_t *)((void *)0));
    }
#line 185
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 187
  i = 0UL;
#line 187
  p = memrec->ptrs;
  {
#line 187
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 187
    if (! (i < memrec->cnt)) {
#line 187
      goto while_break___1;
    }
#line 188
    if ((unsigned long )p->ptr == (unsigned long )ptr) {
#line 190
      return (p);
    }
#line 187
    i ++;
#line 187
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 193
  return ((ptr_t *)((void *)0));
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
static void memrec_rem_var(memrec_t *memrec , spif_charptr_t const   var , spif_charptr_t const   filename ,
                           unsigned long line , void const   *ptr ) 
{ 
  register ptr_t *p ;
  void *tmp ;

  {
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! ((unsigned long )memrec != (unsigned long )((void *)0))) {
#line 218
      if (libast_debug_level >= 1U) {
        {
#line 218
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "memrec_rem_var",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                           218, "memrec != NULL");
        }
      } else {
        {
#line 218
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "memrec_rem_var",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             218, "memrec != NULL");
        }
#line 218
        return;
      }
    }
#line 218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  p = memrec_find_var(memrec, ptr);
  }
#line 223
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 226
    return;
  }
#line 229
  (memrec->cnt) --;
#line 229
  if (memrec->cnt > 0UL) {
    {
#line 230
    memmove((void *)p, (void const   *)(p + 1), sizeof(ptr_t ) * (memrec->cnt - (size_t )(p - memrec->ptrs)));
#line 231
    tmp = realloc((void *)memrec->ptrs, sizeof(ptr_t ) * memrec->cnt);
#line 231
    memrec->ptrs = (ptr_t *)tmp;
    }
  }
#line 233
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
static void memrec_chg_var(memrec_t *memrec , spif_charptr_t const   var , spif_charptr_t const   filename ,
                           unsigned long line , void const   *oldp , void *newp ,
                           size_t size ) 
{ 
  register ptr_t *p ;

  {
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! ((unsigned long )memrec != (unsigned long )((void *)0))) {
#line 259
      if (libast_debug_level >= 1U) {
        {
#line 259
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "memrec_chg_var",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                           259, "memrec != NULL");
        }
      } else {
        {
#line 259
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "memrec_chg_var",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             259, "memrec != NULL");
        }
#line 259
        return;
      }
    }
#line 259
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 262
  p = memrec_find_var(memrec, oldp);
  }
#line 262
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 265
    return;
  }
  {
#line 268
  p->ptr = newp;
#line 269
  p->size = size;
#line 270
  spiftool_safe_strncpy(p->file, filename, 20);
#line 271
  p->line = (spif_uint32_t )line;
  }
#line 272
  return;
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
static void memrec_dump_pointers(memrec_t *memrec ) 
{ 
  register ptr_t *p ;
  unsigned long i ;
  unsigned long j ;
  unsigned long k ;
  unsigned long l ;
  unsigned long total ;
  unsigned long len ;
  spif_char_t buff[9] ;
  spif_charptr_t tmp ;
  char *tmp___0 ;
  spif_charptr_t tmp___1 ;

  {
#line 291
  total = 0UL;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! ((unsigned long )memrec != (unsigned long )((void *)0))) {
#line 295
      if (libast_debug_level >= 1U) {
        {
#line 295
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "memrec_dump_pointers",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                           295, "memrec != NULL");
        }
      } else {
        {
#line 295
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "memrec_dump_pointers",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             295, "memrec != NULL");
        }
#line 295
        return;
      }
    }
#line 295
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 296
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PTR:  %lu pointers stored.\n",
          memrec->cnt);
#line 297
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PTR:   Pointer |       Filename       |  Line  |  Address |  Size  | Offset  | 00 01 02 03 04 05 06 07 |  ASCII  \n");
#line 299
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PTR:  ---------+----------------------+--------+----------+--------+---------+-------------------------+---------\n");
#line 301
  fflush(stderr);
#line 302
  len = sizeof(ptr_t ) * memrec->cnt;
#line 303
  memset((void *)(buff), 0, sizeof(buff));
#line 306
  p = memrec->ptrs;
#line 306
  j = 0UL;
  }
  {
#line 306
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 306
    if (! (j < len)) {
#line 306
      goto while_break___0;
    }
    {
#line 307
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PTR:   %07lu | %20s | %6lu | %10p | %06lu | %07x | ",
            0UL, "", 0UL, (spif_ptr_t )memrec->ptrs, sizeof(ptr_t ) * memrec->cnt,
            (unsigned int )j);
    }
#line 312
    if (len - j < 8UL) {
#line 312
      l = len - j;
    } else {
#line 312
      l = 8UL;
    }
    {
#line 314
    memcpy((void */* __restrict  */)(buff), (void const   */* __restrict  */)((spif_charptr_t )p + j),
           l);
#line 315
    buff[l] = (spif_char_t )0;
#line 316
    k = 0UL;
    }
    {
#line 316
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 316
      if (! (k < l)) {
#line 316
        goto while_break___1;
      }
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
              (int )buff[k]);
#line 316
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 320
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 320
      if (! (k < 8UL)) {
#line 320
        goto while_break___2;
      }
      {
#line 321
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   ");
#line 320
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 324
    tmp = spiftool_safe_str(buff, (unsigned short )l);
#line 324
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| %-8s\n",
            tmp);
#line 326
    fflush(stderr);
#line 306
    j += 8UL;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  i = 0UL;
  {
#line 330
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 330
    if (! (i < memrec->cnt)) {
#line 330
      goto while_break___3;
    }
#line 332
    total += p->size;
#line 333
    j = 0UL;
    {
#line 333
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 333
      if (! (j < p->size)) {
#line 333
        goto while_break___4;
      }
#line 334
      if ((char *)(p->file)) {
#line 334
        tmp___0 = (char *)(p->file);
      } else {
#line 334
        tmp___0 = (char *)"<p->file null>";
      }
      {
#line 334
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PTR:   %07lu | %20s | %6lu | %10p | %06lu | %07x | ",
              i + 1UL, tmp___0, (unsigned long )p->line, p->ptr, p->size, (unsigned int )j);
      }
#line 338
      if (p->size - j < 8UL) {
#line 338
        l = p->size - j;
      } else {
#line 338
        l = 8UL;
      }
      {
#line 340
      memcpy((void */* __restrict  */)(buff), (void const   */* __restrict  */)((spif_charptr_t )p->ptr + j),
             l);
#line 341
      buff[l] = (spif_char_t )0;
#line 342
      k = 0UL;
      }
      {
#line 342
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 342
        if (! (k < l)) {
#line 342
          goto while_break___5;
        }
        {
#line 343
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
                (int )buff[k]);
#line 342
        k ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 346
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 346
        if (! (k < 8UL)) {
#line 346
          goto while_break___6;
        }
        {
#line 347
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   ");
#line 346
        k ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 350
      tmp___1 = spiftool_safe_str(buff, (unsigned short )l);
#line 350
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| %-8s\n",
              tmp___1);
#line 352
      fflush(stderr);
#line 333
      j += 8UL;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 330
    p ++;
#line 330
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 355
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PTR:  Total allocated memory: %10lu bytes\n",
          total);
#line 356
  fflush(stderr);
  }
#line 357
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
static void memrec_dump_resources(memrec_t *memrec ) 
{ 
  register ptr_t *p ;
  unsigned long i ;
  unsigned long total ;
  unsigned long len ;
  char *tmp ;

  {
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! ((unsigned long )memrec != (unsigned long )((void *)0))) {
#line 378
      if (libast_debug_level >= 1U) {
        {
#line 378
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "memrec_dump_resources",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                           378, "memrec != NULL");
        }
      } else {
        {
#line 378
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "memrec_dump_resources",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             378, "memrec != NULL");
        }
#line 378
        return;
      }
    }
#line 378
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 379
  len = memrec->cnt;
#line 380
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RES:  %lu resources stored.\n",
          memrec->cnt);
#line 382
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RES:   Index | Resource ID |       Filename       |  Line  |  Size  \n");
#line 383
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RES:  -------+-------------+----------------------+--------+--------\n");
#line 384
  fflush(stderr);
#line 386
  p = memrec->ptrs;
#line 386
  i = 0UL;
#line 386
  total = 0UL;
  }
  {
#line 386
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 386
    if (! (i < len)) {
#line 386
      goto while_break___0;
    }
#line 387
    total += p->size;
#line 388
    if ((char *)(p->file)) {
#line 388
      tmp = (char *)(p->file);
    } else {
#line 388
      tmp = (char *)"<p->file null>";
    }
    {
#line 388
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RES:   %5lu |  0x%08lx | %20s | %6lu | %6lu\n",
            i, (unsigned long )p->ptr, tmp, (unsigned long )p->line, p->size);
#line 393
    fflush(stderr);
#line 386
    i ++;
#line 386
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 395
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RES:  Total size: %lu bytes\n",
          total);
#line 396
  fflush(stderr);
  }
#line 397
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
void *spifmem_malloc(spif_charptr_t const   filename , unsigned long line , size_t size ) 
{ 
  void *temp ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 433
  tmp = malloc(size);
#line 433
  temp = tmp;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 434
      tmp___0 = 1;
    } else {
#line 434
      tmp___0 = 0;
    }
#line 434
    if (tmp___0) {
#line 434
      if (libast_debug_level >= 1U) {
        {
#line 434
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_malloc",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                           434, "!SPIF_PTR_ISNULL(temp)");
        }
      } else {
        {
#line 434
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_malloc",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             434, "!SPIF_PTR_ISNULL(temp)");
        }
      }
#line 434
      return ((void *)0);
    }
#line 434
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  if (libast_debug_level >= 5U) {
#line 436
    if ((char *)filename) {
#line 436
      tmp___1 = (char *)filename;
    } else {
#line 436
      tmp___1 = (char *)"<filename null>";
    }
    {
#line 436
    memrec_add_var(& malloc_rec, (spif_charptr_t const   )((spif_charptr_t )tmp___1),
                   line, temp, size);
    }
  }
#line 438
  return (temp);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
void *spifmem_realloc(spif_charptr_t const   var , spif_charptr_t const   filename ,
                      unsigned long line , void *ptr , size_t size ) 
{ 
  void *temp ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 474
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 475
    tmp = spifmem_malloc(filename, line, size);
#line 475
    temp = tmp;
    }
  } else
#line 476
  if (size == 0UL) {
    {
#line 477
    spifmem_free(var, filename, line, ptr);
#line 478
    temp = (void *)0;
    }
  } else {
    {
#line 480
    tmp___0 = realloc(ptr, size);
#line 480
    temp = tmp___0;
    }
    {
#line 481
    while (1) {
      while_continue: /* CIL Label */ ;
#line 481
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 481
        tmp___1 = 1;
      } else {
#line 481
        tmp___1 = 0;
      }
#line 481
      if (tmp___1) {
#line 481
        if (libast_debug_level >= 1U) {
          {
#line 481
          libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_realloc",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             481, "!SPIF_PTR_ISNULL(temp)");
          }
        } else {
          {
#line 481
          libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_realloc",
                               "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                               481, "!SPIF_PTR_ISNULL(temp)");
          }
        }
#line 481
        return ((void *)0);
      }
#line 481
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 482
    if (libast_debug_level >= 5U) {
#line 483
      if ((char *)filename) {
#line 483
        tmp___2 = (char *)filename;
      } else {
#line 483
        tmp___2 = (char *)"<filename null>";
      }
      {
#line 483
      memrec_chg_var(& malloc_rec, var, (spif_charptr_t const   )((spif_charptr_t )tmp___2),
                     line, (void const   *)ptr, temp, size);
      }
    }
  }
#line 486
  return (temp);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
void *spifmem_calloc(spif_charptr_t const   filename , unsigned long line , size_t count ,
                     size_t size ) 
{ 
  void *temp ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 522
  tmp = calloc(count, size);
#line 522
  temp = tmp;
  }
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 523
      tmp___0 = 1;
    } else {
#line 523
      tmp___0 = 0;
    }
#line 523
    if (tmp___0) {
#line 523
      if (libast_debug_level >= 1U) {
        {
#line 523
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_calloc",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                           523, "!SPIF_PTR_ISNULL(temp)");
        }
      } else {
        {
#line 523
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_calloc",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             523, "!SPIF_PTR_ISNULL(temp)");
        }
      }
#line 523
      return ((void *)0);
    }
#line 523
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 524
  if (libast_debug_level >= 5U) {
#line 525
    if ((char *)filename) {
#line 525
      tmp___1 = (char *)filename;
    } else {
#line 525
      tmp___1 = (char *)"<filename null>";
    }
    {
#line 525
    memrec_add_var(& malloc_rec, (spif_charptr_t const   )((spif_charptr_t )tmp___1),
                   line, temp, size * count);
    }
  }
#line 527
  return (temp);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
void spifmem_free(spif_charptr_t const   var , spif_charptr_t const   filename , unsigned long line ,
                  void *ptr ) 
{ 
  char *tmp ;

  {
#line 557
  if (ptr) {
#line 558
    if (libast_debug_level >= 5U) {
#line 559
      if ((char *)filename) {
#line 559
        tmp = (char *)filename;
      } else {
#line 559
        tmp = (char *)"<filename null>";
      }
      {
#line 559
      memrec_rem_var(& malloc_rec, var, (spif_charptr_t const   )((spif_charptr_t )tmp),
                     line, (void const   *)ptr);
      }
    }
    {
#line 561
    free(ptr);
    }
  }
#line 565
  return;
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
spif_charptr_t spifmem_strdup(spif_charptr_t const   var , spif_charptr_t const   filename ,
                              unsigned long line , spif_charptr_t const   str ) 
{ 
  register spif_charptr_t newstr ;
  register size_t len ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    if ((unsigned long )((spif_ptr_t )str) == (unsigned long )((void *)0)) {
#line 590
      tmp = 1;
    } else {
#line 590
      tmp = 0;
    }
#line 590
    if (tmp) {
#line 590
      if (libast_debug_level >= 1U) {
        {
#line 590
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_strdup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                           590, "!SPIF_PTR_ISNULL(str)");
        }
      } else {
        {
#line 590
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_strdup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             590, "!SPIF_PTR_ISNULL(str)");
        }
      }
#line 590
      return ((spif_charptr_t )((void *)0));
    }
#line 590
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 594
  tmp___0 = strlen((char const   *)((char *)str));
#line 594
  len = tmp___0 + 1UL;
  }
#line 595
  if ((char *)filename) {
#line 595
    tmp___1 = (char *)filename;
  } else {
#line 595
    tmp___1 = (char *)"<filename null>";
  }
  {
#line 595
  tmp___2 = spifmem_malloc((spif_charptr_t const   )((spif_charptr_t )tmp___1), line,
                           len);
#line 595
  newstr = (spif_charptr_t )tmp___2;
  }
  {
#line 596
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 596
    if ((unsigned long )((spif_ptr_t )newstr) == (unsigned long )((void *)0)) {
#line 596
      tmp___3 = 1;
    } else {
#line 596
      tmp___3 = 0;
    }
#line 596
    if (tmp___3) {
#line 596
      if (libast_debug_level >= 1U) {
        {
#line 596
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_strdup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                           596, "!SPIF_PTR_ISNULL(newstr)");
        }
      } else {
        {
#line 596
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_strdup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             596, "!SPIF_PTR_ISNULL(newstr)");
        }
      }
#line 596
      return ((spif_charptr_t )((void *)0));
    }
#line 596
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 597
  strcpy((char */* __restrict  */)((char *)newstr), (char const   */* __restrict  */)((char *)str));
  }
#line 598
  return (newstr);
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
void spifmem_dump_mem_tables(void) 
{ 


  {
  {
#line 613
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dumping memory allocation table:\n");
#line 614
  memrec_dump_pointers(& malloc_rec);
  }
#line 615
  return;
}
}
#line 642 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
Pixmap spifmem_x_create_pixmap(spif_charptr_t const   filename , unsigned long line ,
                               Display *d , Drawable win , unsigned int w , unsigned int h ,
                               unsigned int depth ) 
{ 
  Pixmap p ;
  char *tmp ;

  {
  {
#line 648
  p = XCreatePixmap(d, win, w, h, depth);
  }
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (p != 0UL)) {
#line 650
      if (libast_debug_level >= 1U) {
        {
#line 650
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_x_create_pixmap",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                           650, "p != None");
        }
      } else {
        {
#line 650
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_x_create_pixmap",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             650, "p != None");
        }
      }
#line 650
      return ((Pixmap )0L);
    }
#line 650
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  if (libast_debug_level >= 5U) {
#line 652
    if ((char *)filename) {
#line 652
      tmp = (char *)filename;
    } else {
#line 652
      tmp = (char *)"<filename null>";
    }
    {
#line 652
    memrec_add_var(& pixmap_rec, (spif_charptr_t const   )((spif_charptr_t )tmp),
                   line, (void *)p, (size_t )((w * h) * (depth / 8U)));
    }
  }
#line 654
  return (p);
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
void spifmem_x_free_pixmap(spif_charptr_t const   var , spif_charptr_t const   filename ,
                           unsigned long line , Display *d , Pixmap p ) 
{ 
  char *tmp ;

  {
#line 678
  if (p) {
#line 679
    if (libast_debug_level >= 5U) {
#line 680
      if ((char *)filename) {
#line 680
        tmp = (char *)filename;
      } else {
#line 680
        tmp = (char *)"<filename null>";
      }
      {
#line 680
      memrec_rem_var(& pixmap_rec, var, (spif_charptr_t const   )((spif_charptr_t )tmp),
                     line, (void const   *)((void *)p));
      }
    }
    {
#line 682
    XFreePixmap(d, p);
    }
  }
#line 686
  return;
}
}
#line 764 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
void spifmem_dump_pixmap_tables(void) 
{ 


  {
  {
#line 767
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dumping X11 Pixmap allocation table:\n");
#line 768
  memrec_dump_resources(& pixmap_rec);
  }
#line 769
  return;
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
GC spifmem_x_create_gc(spif_charptr_t const   filename , unsigned long line , Display *d ,
                       Drawable win , unsigned long mask , XGCValues *gcv ) 
{ 
  GC gc ;
  char *tmp ;

  {
  {
#line 802
  gc = XCreateGC(d, win, mask, gcv);
  }
  {
#line 803
  while (1) {
    while_continue: /* CIL Label */ ;
#line 803
    if (! ((unsigned long )gc != (unsigned long )((GC )0))) {
#line 803
      if (libast_debug_level >= 1U) {
        {
#line 803
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_x_create_gc",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                           803, "gc != None");
        }
      } else {
        {
#line 803
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spifmem_x_create_gc",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                             803, "gc != None");
        }
      }
#line 803
      return ((GC )0L);
    }
#line 803
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 804
  if (libast_debug_level >= 5U) {
#line 805
    if ((char *)filename) {
#line 805
      tmp = (char *)filename;
    } else {
#line 805
      tmp = (char *)"<filename null>";
    }
    {
#line 805
    memrec_add_var(& gc_rec, (spif_charptr_t const   )((spif_charptr_t )tmp), line,
                   (void *)gc, sizeof(XGCValues ));
    }
  }
#line 807
  return (gc);
}
}
#line 827 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
void spifmem_x_free_gc(spif_charptr_t const   var , spif_charptr_t const   filename ,
                       unsigned long line , Display *d , GC gc ) 
{ 
  char *tmp ;

  {
#line 831
  if (gc) {
#line 832
    if (libast_debug_level >= 5U) {
#line 833
      if ((char *)filename) {
#line 833
        tmp = (char *)filename;
      } else {
#line 833
        tmp = (char *)"<filename null>";
      }
      {
#line 833
      memrec_rem_var(& gc_rec, var, (spif_charptr_t const   )((spif_charptr_t )tmp),
                     line, (void const   *)((void *)gc));
      }
    }
    {
#line 835
    XFreeGC(d, gc);
    }
  }
#line 839
  return;
}
}
#line 850 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
void spifmem_dump_gc_tables(void) 
{ 


  {
  {
#line 853
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dumping X11 GC allocation table:\n");
#line 854
  memrec_dump_resources(& gc_rec);
  }
#line 855
  return;
}
}
#line 875 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c"
void spiftool_free_array(void *list , size_t count ) 
{ 
  register size_t i ;
  void **l ;
  time_t tmp ;

  {
#line 879
  l = (void **)list;
  {
#line 881
  while (1) {
    while_continue: /* CIL Label */ ;
#line 881
    if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 881
      if (libast_debug_level >= 1U) {
        {
#line 881
        tmp = time((time_t *)((void *)0));
#line 881
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/mem.c",
                881, "spiftool_free_array");
#line 881
        libast_dprintf("REQUIRE failed:  %s\n", "list != NULL");
        }
      }
#line 881
      return;
    }
#line 881
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  if (count == 0UL) {
#line 884
    count = (size_t )-1;
  }
#line 886
  i = (size_t )0;
  {
#line 886
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 886
    if (i < count) {
#line 886
      if (! *(l + i)) {
#line 886
        goto while_break___0;
      }
    } else {
#line 886
      goto while_break___0;
    }
    {
#line 887
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 887
      free(*(l + i));
#line 887
      *(l + i) = (void *)0;
      }
#line 887
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 886
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 889
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 889
    free(list);
#line 889
    list = (void *)0;
    }
#line 889
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 890
  return;
}
}
#line 50 "../include/libast/linked_list.h"
spif_vectorclass_t spif_linked_list_vectorclass ;
#line 51
spif_mapclass_t spif_linked_list_mapclass ;
#line 40 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_linked_list_item_t spif_linked_list_item_new(void) ;
#line 41
static spif_bool_t spif_linked_list_item_init(spif_linked_list_item_t self ) ;
#line 42
static spif_bool_t spif_linked_list_item_done(spif_linked_list_item_t self ) ;
#line 43
static spif_bool_t spif_linked_list_item_del(spif_linked_list_item_t self ) ;
#line 44
static spif_str_t spif_linked_list_item_show(spif_linked_list_item_t self , spif_charptr_t name___0 ,
                                             spif_str_t buff , size_t indent ) ;
#line 45
static spif_cmp_t spif_linked_list_item_comp(spif_linked_list_item_t self , spif_linked_list_item_t other ) ;
#line 46
static spif_linked_list_item_t spif_linked_list_item_dup(spif_linked_list_item_t self ) ;
#line 47
static spif_classname_t spif_linked_list_item_type(spif_linked_list_item_t self ) ;
#line 48
spif_obj_t spif_linked_list_item_get_data(spif_linked_list_item_t self ) ;
#line 48
spif_bool_t spif_linked_list_item_set_data(spif_linked_list_item_t self , spif_obj_t new_data ) ;
#line 49
spif_linked_list_item_t spif_linked_list_item_get_next(spif_linked_list_item_t self ) ;
#line 49
spif_bool_t spif_linked_list_item_set_next(spif_linked_list_item_t self , spif_linked_list_item_t new_next ) ;
#line 51
static spif_linked_list_t spif_linked_list_new(void) ;
#line 52
static spif_linked_list_t spif_linked_list_vector_new(void) ;
#line 53
static spif_linked_list_t spif_linked_list_map_new(void) ;
#line 54
static spif_bool_t spif_linked_list_init(spif_linked_list_t self ) ;
#line 55
static spif_bool_t spif_linked_list_vector_init(spif_linked_list_t self ) ;
#line 56
static spif_bool_t spif_linked_list_map_init(spif_linked_list_t self ) ;
#line 57
static spif_bool_t spif_linked_list_done(spif_linked_list_t self ) ;
#line 58
static spif_bool_t spif_linked_list_del(spif_linked_list_t self ) ;
#line 59
static spif_str_t spif_linked_list_show(spif_linked_list_t self , spif_charptr_t name___0 ,
                                        spif_str_t buff , size_t indent ) ;
#line 60
static spif_cmp_t spif_linked_list_comp(spif_linked_list_t self , spif_linked_list_t other ) ;
#line 61
static spif_linked_list_t spif_linked_list_dup(spif_linked_list_t self ) ;
#line 62
static spif_linked_list_t spif_linked_list_vector_dup(spif_linked_list_t self ) ;
#line 63
static spif_linked_list_t spif_linked_list_map_dup(spif_linked_list_t self ) ;
#line 64
static spif_classname_t spif_linked_list_type(spif_linked_list_t self ) ;
#line 65
static spif_bool_t spif_linked_list_append(spif_linked_list_t self , spif_obj_t obj ) ;
#line 66
static spif_bool_t spif_linked_list_contains(spif_linked_list_t self , spif_obj_t obj ) ;
#line 67
static spif_bool_t spif_linked_list_vector_contains(spif_linked_list_t self , spif_obj_t obj ) ;
#line 68
static spif_listidx_t spif_linked_list_count(spif_linked_list_t self ) ;
#line 69
static spif_obj_t spif_linked_list_find(spif_linked_list_t self , spif_obj_t obj ) ;
#line 70
static spif_obj_t spif_linked_list_vector_find(spif_linked_list_t self , spif_obj_t obj ) ;
#line 71
static spif_obj_t spif_linked_list_get(spif_linked_list_t self , spif_listidx_t idx ) ;
#line 72
static spif_obj_t spif_linked_list_map_get(spif_linked_list_t self , spif_obj_t key ) ;
#line 73
static spif_list_t spif_linked_list_get_keys(spif_linked_list_t self , spif_list_t key_list ) ;
#line 74
static spif_list_t spif_linked_list_get_pairs(spif_linked_list_t self , spif_list_t pair_list ) ;
#line 75
static spif_list_t spif_linked_list_get_values(spif_linked_list_t self , spif_list_t value_list ) ;
#line 76
static spif_bool_t spif_linked_list_has_key(spif_linked_list_t self , spif_obj_t key ) ;
#line 77
static spif_bool_t spif_linked_list_has_value(spif_linked_list_t self , spif_obj_t value ) ;
#line 78
static spif_listidx_t spif_linked_list_index(spif_linked_list_t self , spif_obj_t obj ) ;
#line 79
static spif_bool_t spif_linked_list_insert(spif_linked_list_t self , spif_obj_t obj ) ;
#line 80
static spif_bool_t spif_linked_list_insert_at(spif_linked_list_t self , spif_obj_t obj ,
                                              spif_listidx_t idx ) ;
#line 81
static spif_iterator_t spif_linked_list_iterator(spif_linked_list_t self ) ;
#line 82
static spif_bool_t spif_linked_list_prepend(spif_linked_list_t self , spif_obj_t obj ) ;
#line 83
static spif_obj_t spif_linked_list_remove(spif_linked_list_t self , spif_obj_t item ) ;
#line 84
static spif_obj_t spif_linked_list_map_remove(spif_linked_list_t self , spif_obj_t item ) ;
#line 85
static spif_obj_t spif_linked_list_remove_at(spif_linked_list_t self , spif_listidx_t idx ) ;
#line 86
static spif_bool_t spif_linked_list_reverse(spif_linked_list_t self ) ;
#line 87
static spif_bool_t spif_linked_list_set(spif_linked_list_t self , spif_obj_t key ,
                                        spif_obj_t value ) ;
#line 88
static spif_obj_t *spif_linked_list_to_array(spif_linked_list_t self ) ;
#line 89
spif_listidx_t spif_linked_list_get_len(spif_linked_list_t self ) ;
#line 89
spif_bool_t spif_linked_list_set_len(spif_linked_list_t self , spif_listidx_t new_len ) ;
#line 90
spif_linked_list_item_t spif_linked_list_get_head(spif_linked_list_t self ) ;
#line 90
spif_bool_t spif_linked_list_set_head(spif_linked_list_t self , spif_linked_list_item_t new_head ) ;
#line 92
static spif_linked_list_iterator_t spif_linked_list_iterator_new(spif_linked_list_t subject ) ;
#line 93
static spif_bool_t spif_linked_list_iterator_init(spif_linked_list_iterator_t self ,
                                                  spif_linked_list_t subject ) ;
#line 94
static spif_bool_t spif_linked_list_iterator_done(spif_linked_list_iterator_t self ) ;
#line 95
static spif_bool_t spif_linked_list_iterator_del(spif_linked_list_iterator_t self ) ;
#line 96
static spif_str_t spif_linked_list_iterator_show(spif_linked_list_iterator_t self ,
                                                 spif_charptr_t name___0 , spif_str_t buff ,
                                                 size_t indent ) ;
#line 97
static spif_cmp_t spif_linked_list_iterator_comp(spif_linked_list_iterator_t self ,
                                                 spif_linked_list_iterator_t other ) ;
#line 98
static spif_linked_list_iterator_t spif_linked_list_iterator_dup(spif_linked_list_iterator_t self ) ;
#line 99
static spif_classname_t spif_linked_list_iterator_type(spif_linked_list_iterator_t self ) ;
#line 100
static spif_bool_t spif_linked_list_iterator_has_next(spif_linked_list_iterator_t self ) ;
#line 101
static spif_obj_t spif_linked_list_iterator_next(spif_linked_list_iterator_t self ) ;
#line 102
spif_linked_list_t spif_linked_list_iterator_get_subject(spif_linked_list_iterator_t self ) ;
#line 102
spif_bool_t spif_linked_list_iterator_set_subject(spif_linked_list_iterator_t self ,
                                                  spif_linked_list_t new_subject ) ;
#line 103
spif_linked_list_item_t spif_linked_list_iterator_get_current(spif_linked_list_iterator_t self ) ;
#line 103
spif_bool_t spif_linked_list_iterator_set_current(spif_linked_list_iterator_t self ,
                                                  spif_linked_list_item_t new_current ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_const_class_t lli_class  = 
#line 106
     {(spif_charptr_t )"!spif_linked_list_item_t!", (void *(*)())(& spif_linked_list_item_new),
    (void *(*)())(& spif_linked_list_item_init), (void *(*)())(& spif_linked_list_item_done),
    (void *(*)())(& spif_linked_list_item_del), (void *(*)())(& spif_linked_list_item_show),
    (void *(*)())(& spif_linked_list_item_comp), (void *(*)())(& spif_linked_list_item_dup),
    (void *(*)())(& spif_linked_list_item_type)};
#line 117 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_class_t spif_linked_list_item_class  =    & lli_class;
#line 119 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_const_listclass_t ll_class  = 
#line 119
     {{(spif_charptr_t )"!spif_linked_list_t!", (void *(*)())(& spif_linked_list_new),
     (void *(*)())(& spif_linked_list_init), (void *(*)())(& spif_linked_list_done),
     (void *(*)())(& spif_linked_list_del), (void *(*)())(& spif_linked_list_show),
     (void *(*)())(& spif_linked_list_comp), (void *(*)())(& spif_linked_list_dup),
     (void *(*)())(& spif_linked_list_type)}, (void *(*)())(& spif_linked_list_append),
    (void *(*)())(& spif_linked_list_contains), (void *(*)())(& spif_linked_list_count),
    (void *(*)())(& spif_linked_list_find), (void *(*)())(& spif_linked_list_get),
    (void *(*)())(& spif_linked_list_index), (void *(*)())(& spif_linked_list_insert),
    (void *(*)())(& spif_linked_list_insert_at), (void *(*)())(& spif_linked_list_iterator),
    (void *(*)())(& spif_linked_list_prepend), (void *(*)())(& spif_linked_list_remove),
    (void *(*)())(& spif_linked_list_remove_at), (void *(*)())(& spif_linked_list_reverse),
    (void *(*)())(& spif_linked_list_to_array)};
#line 146 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_listclass_t spif_linked_list_listclass  =    & ll_class;
#line 148 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_const_vectorclass_t llv_class  = 
#line 148
     {{(spif_charptr_t )"!spif_linked_list_t!", (void *(*)())(& spif_linked_list_vector_new),
     (void *(*)())(& spif_linked_list_vector_init), (void *(*)())(& spif_linked_list_done),
     (void *(*)())(& spif_linked_list_del), (void *(*)())(& spif_linked_list_show),
     (void *(*)())(& spif_linked_list_comp), (void *(*)())(& spif_linked_list_vector_dup),
     (void *(*)())(& spif_linked_list_type)}, (void *(*)())(& spif_linked_list_vector_contains),
    (void *(*)())(& spif_linked_list_count), (void *(*)())(& spif_linked_list_vector_find),
    (void *(*)())(& spif_linked_list_insert), (void *(*)())(& spif_linked_list_iterator),
    (void *(*)())(& spif_linked_list_remove), (void *(*)())(& spif_linked_list_to_array)};
#line 168 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_vectorclass_t spif_linked_list_vectorclass  =    & llv_class;
#line 170 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_const_mapclass_t llm_class  = 
#line 170
     {{(spif_charptr_t )"!spif_linked_list_t!", (void *(*)())(& spif_linked_list_map_new),
     (void *(*)())(& spif_linked_list_map_init), (void *(*)())(& spif_linked_list_done),
     (void *(*)())(& spif_linked_list_del), (void *(*)())(& spif_linked_list_show),
     (void *(*)())(& spif_linked_list_comp), (void *(*)())(& spif_linked_list_map_dup),
     (void *(*)())(& spif_linked_list_type)}, (void *(*)())(& spif_linked_list_count),
    (void *(*)())(& spif_linked_list_map_get), (void *(*)())(& spif_linked_list_get_keys),
    (void *(*)())(& spif_linked_list_get_pairs), (void *(*)())(& spif_linked_list_get_values),
    (void *(*)())(& spif_linked_list_has_key), (void *(*)())(& spif_linked_list_has_value),
    (void *(*)())(& spif_linked_list_iterator), (void *(*)())(& spif_linked_list_map_remove),
    (void *(*)())(& spif_linked_list_set)};
#line 193 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_mapclass_t spif_linked_list_mapclass  =    & llm_class;
#line 195 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_const_iteratorclass_t li_class  =    {{(spif_charptr_t )"!spif_linked_list_t!", (void *(*)())(& spif_linked_list_iterator_new),
     (void *(*)())(& spif_linked_list_iterator_init), (void *(*)())(& spif_linked_list_iterator_done),
     (void *(*)())(& spif_linked_list_iterator_del), (void *(*)())(& spif_linked_list_iterator_show),
     (void *(*)())(& spif_linked_list_iterator_comp), (void *(*)())(& spif_linked_list_iterator_dup),
     (void *(*)())(& spif_linked_list_iterator_type)}, (void *(*)())(& spif_linked_list_iterator_has_next),
    (void *(*)())(& spif_linked_list_iterator_next)};
#line 210 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_iteratorclass_t spif_linked_list_iteratorclass  =    & li_class;
#line 213 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_linked_list_item_t spif_linked_list_item_new(void) 
{ 
  spif_linked_list_item_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 218
  tmp = malloc(sizeof(spif_const_linked_list_item_t ));
#line 218
  self = (spif_linked_list_item_t )tmp;
#line 219
  tmp___0 = spif_linked_list_item_init(self);
  }
#line 219
  if (! tmp___0) {
    {
#line 220
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 220
      free((void *)self);
#line 220
      self = (spif_linked_list_item_t )((void *)0);
      }
#line 220
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 221
    self = (spif_linked_list_item_t )((void *)0);
  }
#line 223
  return (self);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_item_init(spif_linked_list_item_t self ) 
{ 


  {
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (! ((unsigned long )self == (unsigned long )((spif_linked_list_item_t )((void *)0))))) {
#line 229
      if (libast_debug_level >= 1U) {
        {
#line 229
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_item_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           229, "!SPIF_LINKED_LIST_ITEM_ISNULL(self)");
        }
      } else {
        {
#line 229
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_item_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             229, "!SPIF_LINKED_LIST_ITEM_ISNULL(self)");
        }
      }
#line 229
      return ((spif_bool_t )0);
    }
#line 229
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  self->data = (spif_obj_t )((void *)0);
#line 231
  self->next = (spif_linked_list_item_t )((void *)0);
#line 232
  return ((spif_bool_t )1);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_item_done(spif_linked_list_item_t self ) 
{ 


  {
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (! ((unsigned long )self == (unsigned long )((spif_linked_list_item_t )((void *)0))))) {
#line 238
      if (libast_debug_level >= 1U) {
        {
#line 238
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_item_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           238, "!SPIF_LINKED_LIST_ITEM_ISNULL(self)");
        }
      } else {
        {
#line 238
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_item_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             238, "!SPIF_LINKED_LIST_ITEM_ISNULL(self)");
        }
      }
#line 238
      return ((spif_bool_t )0);
    }
#line 238
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  if ((unsigned long )self->data != (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 240
    (*(((self->data)->cls)->del))(self->data);
    }
  }
#line 242
  self->data = (spif_obj_t )((void *)0);
#line 243
  self->next = (spif_linked_list_item_t )((void *)0);
#line 244
  return ((spif_bool_t )1);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_item_del(spif_linked_list_item_t self ) 
{ 


  {
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (! ((unsigned long )self == (unsigned long )((spif_linked_list_item_t )((void *)0))))) {
#line 250
      if (libast_debug_level >= 1U) {
        {
#line 250
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_item_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           250, "!SPIF_LINKED_LIST_ITEM_ISNULL(self)");
        }
      } else {
        {
#line 250
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_item_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             250, "!SPIF_LINKED_LIST_ITEM_ISNULL(self)");
        }
      }
#line 250
      return ((spif_bool_t )0);
    }
#line 250
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  spif_linked_list_item_done(self);
  }
  {
#line 252
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 252
    free((void *)self);
#line 252
    self = (spif_linked_list_item_t )((void *)0);
    }
#line 252
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 253
  return ((spif_bool_t )1);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_str_t spif_linked_list_item_show(spif_linked_list_item_t self , spif_charptr_t name___0 ,
                                             spif_str_t buff , size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 261
  if ((unsigned long )self == (unsigned long )((spif_linked_list_item_t )((void *)0))) {
    {
#line 262
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 262
      memset((void *)(tmp), ' ', indent);
      }
#line 262
      if ((char *)name___0) {
#line 262
        tmp___0 = (char *)name___0;
      } else {
#line 262
        tmp___0 = (char *)"<name null>";
      }
      {
#line 262
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_linked_list_item_t) %s:  { ((spif_linked_list_item_t) NULL) }\n",
               tmp___0);
      }
#line 262
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 262
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 262
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 262
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 263
    return (buff);
  }
  {
#line 266
  memset((void *)(tmp), ' ', indent);
#line 267
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_linked_list_item_t) %s (%9p -> %9p):  ",
           name___0, (spif_ptr_t )self, (spif_ptr_t )self->next);
  }
#line 270
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 271
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 273
    spif_str_append_from_ptr(buff, tmp);
    }
  }
#line 275
  if ((unsigned long )((spif_linked_list_item_t )self->data) == (unsigned long )((spif_linked_list_item_t )((void *)0))) {
    {
#line 276
    spif_str_append_from_ptr(buff, (spif_charptr_t )"{ ((spif_obj_t) NULL) }\n");
    }
  } else {
    {
#line 278
    tmp___1 = (*(((self->data)->cls)->show))(self->data, "self->data", buff, 0);
#line 278
    buff = (spif_str_t )tmp___1;
    }
  }
#line 280
  return (buff);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_cmp_t spif_linked_list_item_comp(spif_linked_list_item_t self , spif_linked_list_item_t other ) 
{ 
  void *tmp ;

  {
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 286
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 286
        return ((spif_cmp_t )0);
      } else {
#line 286
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 286
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 286
      return ((spif_cmp_t )-1);
    } else
#line 286
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 286
      return ((spif_cmp_t )1);
    }
#line 286
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 287
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 287
    if ((unsigned long )self->data == (unsigned long )((spif_obj_t )((void *)0))) {
#line 287
      if ((unsigned long )other->data == (unsigned long )((spif_obj_t )((void *)0))) {
#line 287
        return ((spif_cmp_t )0);
      } else {
#line 287
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 287
    if ((unsigned long )self->data == (unsigned long )((spif_obj_t )((void *)0))) {
#line 287
      return ((spif_cmp_t )-1);
    } else
#line 287
    if ((unsigned long )other->data == (unsigned long )((spif_obj_t )((void *)0))) {
#line 287
      return ((spif_cmp_t )1);
    }
#line 287
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 288
  tmp = (*(((self->data)->cls)->comp))(self->data, other->data);
  }
#line 288
  return ((spif_cmp_t )tmp);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_linked_list_item_t spif_linked_list_item_dup(spif_linked_list_item_t self ) 
{ 
  spif_linked_list_item_t tmp ;
  void *tmp___0 ;

  {
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (! ((unsigned long )self == (unsigned long )((spif_linked_list_item_t )((void *)0))))) {
#line 296
      if (libast_debug_level >= 1U) {
        {
#line 296
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_item_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           296, "!SPIF_LINKED_LIST_ITEM_ISNULL(self)");
        }
      } else {
        {
#line 296
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_item_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             296, "!SPIF_LINKED_LIST_ITEM_ISNULL(self)");
        }
      }
#line 296
      return ((spif_linked_list_item_t )0);
    }
#line 296
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 297
  tmp = spif_linked_list_item_new();
  }
#line 298
  if (! ((unsigned long )self->data == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 299
    tmp___0 = (*(((self->data)->cls)->dup))(self->data);
#line 299
    tmp->data = (spif_obj_t )tmp___0;
    }
  }
#line 301
  return (tmp);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_classname_t spif_linked_list_item_type(spif_linked_list_item_t self ) 
{ 


  {
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! (! ((unsigned long )self == (unsigned long )((spif_linked_list_item_t )((void *)0))))) {
#line 307
      if (libast_debug_level >= 1U) {
        {
#line 307
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_item_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           307, "!SPIF_LINKED_LIST_ITEM_ISNULL(self)");
        }
      } else {
        {
#line 307
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_item_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             307, "!SPIF_LINKED_LIST_ITEM_ISNULL(self)");
        }
      }
#line 307
      return ((spif_classname_t )((void *)0));
    }
#line 307
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_obj_t spif_linked_list_item_get_data(spif_linked_list_item_t self ) 
{ 


  {
#line 311
  return (self->data);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_bool_t spif_linked_list_item_set_data(spif_linked_list_item_t self , spif_obj_t new_data ) 
{ 


  {
#line 311
  if (! ((unsigned long )self->data == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 311
    (*(((self->data)->cls)->del))(self->data);
    }
  }
#line 311
  self->data = new_data;
#line 311
  return ((spif_bool_t )1);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_linked_list_item_t spif_linked_list_item_get_next(spif_linked_list_item_t self ) 
{ 


  {
#line 312
  return (self->next);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_bool_t spif_linked_list_item_set_next(spif_linked_list_item_t self , spif_linked_list_item_t new_next ) 
{ 


  {
#line 312
  self->next = new_next;
#line 312
  return ((spif_bool_t )1);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_linked_list_t spif_linked_list_new(void) 
{ 
  spif_linked_list_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 320
  tmp = malloc(sizeof(spif_const_linked_list_t ));
#line 320
  self = (spif_linked_list_t )tmp;
#line 321
  tmp___0 = spif_linked_list_init(self);
  }
#line 321
  if (! tmp___0) {
    {
#line 322
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 322
      free((void *)self);
#line 322
      self = (spif_linked_list_t )((void *)0);
      }
#line 322
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 323
    self = (spif_linked_list_t )((void *)0);
  }
#line 325
  return (self);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_linked_list_t spif_linked_list_vector_new(void) 
{ 
  spif_linked_list_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 333
  tmp = malloc(sizeof(spif_const_linked_list_t ));
#line 333
  self = (spif_linked_list_t )tmp;
#line 334
  tmp___0 = spif_linked_list_vector_init(self);
  }
#line 334
  if (! tmp___0) {
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 335
      free((void *)self);
#line 335
      self = (spif_linked_list_t )((void *)0);
      }
#line 335
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 336
    self = (spif_linked_list_t )((void *)0);
  }
#line 338
  return (self);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_linked_list_t spif_linked_list_map_new(void) 
{ 
  spif_linked_list_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 346
  tmp = malloc(sizeof(spif_const_linked_list_t ));
#line 346
  self = (spif_linked_list_t )tmp;
#line 347
  tmp___0 = spif_linked_list_map_init(self);
  }
#line 347
  if (! tmp___0) {
    {
#line 348
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 348
      free((void *)self);
#line 348
      self = (spif_linked_list_t )((void *)0);
      }
#line 348
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 349
    self = (spif_linked_list_t )((void *)0);
  }
#line 351
  return (self);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_init(spif_linked_list_t self ) 
{ 
  spif_bool_t t ;

  {
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 359
      if (libast_debug_level >= 1U) {
        {
#line 359
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           359, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 359
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             359, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 359
      return ((spif_bool_t )0);
    }
#line 359
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  t = spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_linked_list_listclass);
#line 362
  self->len = 0;
#line 363
  self->head = (spif_linked_list_item_t )((void *)0);
  }
#line 364
  return (t);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_vector_init(spif_linked_list_t self ) 
{ 
  spif_bool_t t ;

  {
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 372
      if (libast_debug_level >= 1U) {
        {
#line 372
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_vector_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           372, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 372
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_vector_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             372, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 372
      return ((spif_bool_t )0);
    }
#line 372
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  t = spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_linked_list_vectorclass);
#line 375
  self->len = 0;
#line 376
  self->head = (spif_linked_list_item_t )((void *)0);
  }
#line 377
  return (t);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_map_init(spif_linked_list_t self ) 
{ 
  spif_bool_t t ;

  {
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 385
      if (libast_debug_level >= 1U) {
        {
#line 385
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_map_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           385, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 385
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_map_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             385, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 385
      return ((spif_bool_t )0);
    }
#line 385
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 387
  t = spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_linked_list_mapclass);
#line 388
  self->len = 0;
#line 389
  self->head = (spif_linked_list_item_t )((void *)0);
  }
#line 390
  return (t);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_done(spif_linked_list_t self ) 
{ 
  spif_linked_list_item_t current ;
  spif_linked_list_item_t tmp ;

  {
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 398
      if (libast_debug_level >= 1U) {
        {
#line 398
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           398, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 398
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             398, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 398
      return ((spif_bool_t )0);
    }
#line 398
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  if (self->len) {
#line 400
    current = self->head;
    {
#line 400
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 400
      if (! current) {
#line 400
        goto while_break___0;
      }
      {
#line 403
      tmp = current;
#line 404
      current = current->next;
#line 405
      spif_linked_list_item_del(tmp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 407
    self->len = 0;
#line 408
    self->head = (spif_linked_list_item_t )((void *)0);
  }
#line 410
  return ((spif_bool_t )1);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_del(spif_linked_list_t self ) 
{ 


  {
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 416
      if (libast_debug_level >= 1U) {
        {
#line 416
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           416, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 416
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             416, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 416
      return ((spif_bool_t )0);
    }
#line 416
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 417
  spif_linked_list_done(self);
  }
  {
#line 418
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 418
    free((void *)self);
#line 418
    self = (spif_linked_list_t )((void *)0);
    }
#line 418
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 419
  return ((spif_bool_t )1);
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_str_t spif_linked_list_show(spif_linked_list_t self , spif_charptr_t name___0 ,
                                        spif_str_t buff , size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  spif_linked_list_item_t current ;
  spif_listidx_t i ;
  char *tmp___0 ;

  {
#line 429
  if ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))) {
    {
#line 430
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 430
      memset((void *)(tmp), ' ', indent);
      }
#line 430
      if ((char *)name___0) {
#line 430
        tmp___0 = (char *)name___0;
      } else {
#line 430
        tmp___0 = (char *)"<name null>";
      }
      {
#line 430
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_linked_list_t) %s:  { ((spif_linked_list_t) NULL) }\n",
               tmp___0);
      }
#line 430
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 430
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 430
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 430
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 431
    return (buff);
  }
  {
#line 434
  memset((void *)(tmp), ' ', indent);
#line 435
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_linked_list_t) %s:  %10p {\n",
           name___0, (spif_ptr_t )self);
  }
#line 437
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 438
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 440
    spif_str_append_from_ptr(buff, tmp);
    }
  }
  {
#line 443
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"  len:  %lu\n", (unsigned long )self->len);
#line 445
  spif_str_append_from_ptr(buff, tmp);
  }
#line 447
  if ((unsigned long )self->head == (unsigned long )((spif_linked_list_item_t )((void *)0))) {
    {
#line 448
    spif_str_append_from_ptr(buff, (spif_charptr_t )"{ ((spif_obj_t) NULL) }\n");
    }
  } else {
#line 450
    current = self->head;
#line 450
    i = 0;
    {
#line 450
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 450
      if (! current) {
#line 450
        goto while_break___0;
      }
      {
#line 451
      sprintf((char */* __restrict  */)((char *)(tmp)), (char const   */* __restrict  */)"item %d",
              i);
#line 452
      buff = spif_linked_list_item_show(current, tmp, buff, indent + 2UL);
#line 450
      current = current->next;
#line 450
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 456
  memset((void *)(tmp), ' ', indent);
#line 457
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"}\n");
#line 458
  spif_str_append_from_ptr(buff, tmp);
  }
#line 459
  return (buff);
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_cmp_t spif_linked_list_comp(spif_linked_list_t self , spif_linked_list_t other ) 
{ 
  void *tmp ;

  {
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 465
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 465
        return ((spif_cmp_t )0);
      } else {
#line 465
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 465
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 465
      return ((spif_cmp_t )-1);
    } else
#line 465
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 465
      return ((spif_cmp_t )1);
    }
#line 465
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 467
  tmp = (*((((spif_obj_t )self)->cls)->comp))((spif_obj_t )self, (spif_obj_t )other);
  }
#line 467
  return ((spif_cmp_t )tmp);
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_linked_list_t spif_linked_list_dup(spif_linked_list_t self ) 
{ 
  spif_linked_list_t tmp ;
  spif_linked_list_item_t src ;
  spif_linked_list_item_t dest ;

  {
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 476
      if (libast_debug_level >= 1U) {
        {
#line 476
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           476, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 476
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             476, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 476
      return ((spif_linked_list_t )((void *)0));
    }
#line 476
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 477
  tmp = spif_linked_list_new();
#line 478
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self, sizeof(spif_const_linked_list_t ));
#line 479
  tmp->head = spif_linked_list_item_dup(self->head);
#line 480
  src = self->head;
#line 480
  dest = tmp->head;
  }
  {
#line 480
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 480
    if (! src->next) {
#line 480
      goto while_break___0;
    }
    {
#line 481
    dest->next = spif_linked_list_item_dup(src->next);
#line 480
    src = src->next;
#line 480
    dest = dest->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 483
  dest->next = (spif_linked_list_item_t )((void *)0);
#line 484
  return (tmp);
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_linked_list_t spif_linked_list_vector_dup(spif_linked_list_t self ) 
{ 
  spif_linked_list_t tmp ;
  spif_linked_list_item_t src ;
  spif_linked_list_item_t dest ;

  {
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 493
      if (libast_debug_level >= 1U) {
        {
#line 493
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_vector_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           493, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 493
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_vector_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             493, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 493
      return ((spif_linked_list_t )((void *)0));
    }
#line 493
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 494
  tmp = spif_linked_list_vector_new();
#line 495
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self, sizeof(spif_const_linked_list_t ));
#line 496
  tmp->head = spif_linked_list_item_dup(self->head);
#line 497
  src = self->head;
#line 497
  dest = tmp->head;
  }
  {
#line 497
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 497
    if (! src->next) {
#line 497
      goto while_break___0;
    }
    {
#line 498
    dest->next = spif_linked_list_item_dup(src->next);
#line 497
    src = src->next;
#line 497
    dest = dest->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 500
  dest->next = (spif_linked_list_item_t )((void *)0);
#line 501
  return (tmp);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_linked_list_t spif_linked_list_map_dup(spif_linked_list_t self ) 
{ 
  spif_linked_list_t tmp ;
  spif_linked_list_item_t src ;
  spif_linked_list_item_t dest ;

  {
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 510
      if (libast_debug_level >= 1U) {
        {
#line 510
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_map_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           510, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 510
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_map_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             510, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 510
      return ((spif_linked_list_t )((void *)0));
    }
#line 510
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 511
  tmp = spif_linked_list_map_new();
#line 512
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)self, sizeof(spif_const_linked_list_t ));
#line 513
  tmp->head = spif_linked_list_item_dup(self->head);
#line 514
  src = self->head;
#line 514
  dest = tmp->head;
  }
  {
#line 514
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 514
    if (! src->next) {
#line 514
      goto while_break___0;
    }
    {
#line 515
    dest->next = spif_linked_list_item_dup(src->next);
#line 514
    src = src->next;
#line 514
    dest = dest->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 517
  dest->next = (spif_linked_list_item_t )((void *)0);
#line 518
  return (tmp);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_classname_t spif_linked_list_type(spif_linked_list_t self ) 
{ 


  {
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 524
      if (libast_debug_level >= 1U) {
        {
#line 524
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           524, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 524
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             524, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 524
      return ((spif_classname_t )((void *)0));
    }
#line 524
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 525
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_append(spif_linked_list_t self , spif_obj_t obj ) 
{ 
  spif_linked_list_item_t item ;
  spif_linked_list_item_t current ;

  {
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 533
      if (libast_debug_level >= 1U) {
        {
#line 533
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_append",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           533, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 533
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_append",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             533, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 533
      return ((spif_bool_t )0);
    }
#line 533
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 535
  item = spif_linked_list_item_new();
#line 536
  spif_linked_list_item_set_data(item, obj);
  }
#line 539
  if (self->head) {
#line 540
    current = self->head;
    {
#line 540
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 540
      if (! current->next) {
#line 540
        goto while_break___0;
      }
#line 540
      current = current->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 541
    current->next = item;
  } else {
#line 543
    self->head = item;
  }
#line 546
  (self->len) ++;
#line 547
  return ((spif_bool_t )1);
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_contains(spif_linked_list_t self , spif_obj_t obj ) 
{ 
  int tmp___0 ;
  spif_obj_t tmp___1 ;

  {
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 553
      if (libast_debug_level >= 1U) {
        {
#line 553
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_contains",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           553, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 553
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_contains",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             553, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 553
      return ((spif_bool_t )0);
    }
#line 553
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 554
  tmp___1 = spif_linked_list_find(self, obj);
  }
#line 554
  if ((unsigned long )tmp___1 == (unsigned long )((spif_obj_t )((void *)0))) {
#line 554
    tmp___0 = 0;
  } else {
#line 554
    tmp___0 = 1;
  }
#line 554
  return ((spif_bool_t )tmp___0);
}
}
#line 557 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_vector_contains(spif_linked_list_t self , spif_obj_t obj ) 
{ 
  int tmp___0 ;
  spif_obj_t tmp___1 ;

  {
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 560
      if (libast_debug_level >= 1U) {
        {
#line 560
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_vector_contains",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           560, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 560
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_vector_contains",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             560, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 560
      return ((spif_bool_t )0);
    }
#line 560
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 561
  tmp___1 = spif_linked_list_vector_find(self, obj);
  }
#line 561
  if ((unsigned long )tmp___1 == (unsigned long )((spif_obj_t )((void *)0))) {
#line 561
    tmp___0 = 0;
  } else {
#line 561
    tmp___0 = 1;
  }
#line 561
  return ((spif_bool_t )tmp___0);
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_listidx_t spif_linked_list_count(spif_linked_list_t self ) 
{ 


  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 567
      if (libast_debug_level >= 1U) {
        {
#line 567
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_count",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           567, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 567
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_count",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             567, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 567
      return ((spif_listidx_t )((void *)0));
    }
#line 567
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  return (self->len);
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_obj_t spif_linked_list_find(spif_linked_list_t self , spif_obj_t obj ) 
{ 
  spif_linked_list_item_t current ;
  time_t tmp ;
  void *tmp___0 ;

  {
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 576
      if (libast_debug_level >= 1U) {
        {
#line 576
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_find",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           576, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 576
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_find",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             576, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 576
      return ((spif_obj_t )((void *)0));
    }
#line 576
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 577
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 577
    if (! (! ((unsigned long )obj == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 577
      if (libast_debug_level >= 1U) {
        {
#line 577
        tmp = time((time_t *)((void *)0));
#line 577
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                577, "spif_linked_list_find");
#line 577
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(obj)");
        }
      }
#line 577
      return ((spif_obj_t )((void *)0));
    }
#line 577
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 578
  current = self->head;
  {
#line 578
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 578
    if (! current) {
#line 578
      goto while_break___1;
    }
    {
#line 580
    tmp___0 = (*((obj->cls)->comp))(obj, current->data);
    }
#line 580
    if ((int )((spif_cmp_t )tmp___0) == 0) {
#line 581
      return (current->data);
    }
#line 578
    current = current->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 584
  return ((spif_obj_t )((void *)0));
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_obj_t spif_linked_list_vector_find(spif_linked_list_t self , spif_obj_t obj ) 
{ 
  spif_linked_list_item_t current ;
  time_t tmp ;
  spif_cmp_t c ;
  void *tmp___0 ;

  {
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 592
      if (libast_debug_level >= 1U) {
        {
#line 592
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_vector_find",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           592, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 592
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_vector_find",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             592, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 592
      return ((spif_obj_t )((void *)0));
    }
#line 592
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 593
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 593
    if (! (! ((unsigned long )obj == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 593
      if (libast_debug_level >= 1U) {
        {
#line 593
        tmp = time((time_t *)((void *)0));
#line 593
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                593, "spif_linked_list_vector_find");
#line 593
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(obj)");
        }
      }
#line 593
      return ((spif_obj_t )((void *)0));
    }
#line 593
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 594
  current = self->head;
  {
#line 594
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 594
    if (! current) {
#line 594
      goto while_break___1;
    }
    {
#line 598
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 598
      if (! (! ((unsigned long )current->data == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 598
        if (libast_debug_level >= 1U) {
          {
#line 598
          libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_vector_find",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             598, "!SPIF_OBJ_ISNULL(current->data)");
          }
        } else {
          {
#line 598
          libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_vector_find",
                               "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                               598, "!SPIF_OBJ_ISNULL(current->data)");
          }
        }
#line 598
        return ((spif_obj_t )((void *)0));
      }
#line 598
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 599
    tmp___0 = (*(((current->data)->cls)->comp))(current->data, obj);
#line 599
    c = (spif_cmp_t )tmp___0;
    }
#line 600
    if ((int )c == 0) {
#line 601
      return (current->data);
    } else
#line 602
    if ((int )c == 1) {
#line 603
      goto while_break___1;
    }
#line 594
    current = current->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 606
  return ((spif_obj_t )((void *)0));
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_obj_t spif_linked_list_get(spif_linked_list_t self , spif_listidx_t idx ) 
{ 
  spif_listidx_t i ;
  spif_linked_list_item_t current ;
  time_t tmp ;
  time_t tmp___0 ;
  spif_obj_t tmp___1 ;

  {
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 615
      if (libast_debug_level >= 1U) {
        {
#line 615
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_get",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           615, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 615
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_get",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             615, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 615
      return ((spif_obj_t )((void *)0));
    }
#line 615
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  if (idx < 0) {
#line 618
    idx += self->len;
  }
  {
#line 620
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 620
    if (! (idx >= 0)) {
#line 620
      if (libast_debug_level >= 1U) {
        {
#line 620
        tmp = time((time_t *)((void *)0));
#line 620
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                620, "spif_linked_list_get");
#line 620
        libast_dprintf("REQUIRE failed:  %s\n", "idx >= 0");
        }
      }
#line 620
      return ((spif_obj_t )((void *)0));
    }
#line 620
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 621
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 621
    if (! (idx < self->len)) {
#line 621
      if (libast_debug_level >= 1U) {
        {
#line 621
        tmp___0 = time((time_t *)((void *)0));
#line 621
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                621, "spif_linked_list_get");
#line 621
        libast_dprintf("REQUIRE failed:  %s\n", "idx < self->len");
        }
      }
#line 621
      return ((spif_obj_t )((void *)0));
    }
#line 621
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 622
  current = self->head;
#line 622
  i = 0;
  {
#line 622
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 622
    if (current) {
#line 622
      if (! (i < idx)) {
#line 622
        goto while_break___2;
      }
    } else {
#line 622
      goto while_break___2;
    }
#line 622
    i ++;
#line 622
    current = current->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 623
  if (current) {
#line 623
    tmp___1 = current->data;
  } else {
#line 623
    tmp___1 = (spif_obj_t )((void *)0);
  }
#line 623
  return (tmp___1);
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_obj_t spif_linked_list_map_get(spif_linked_list_t self , spif_obj_t key ) 
{ 
  spif_linked_list_item_t current ;
  time_t tmp ;
  spif_cmp_t c ;
  void *tmp___0 ;

  {
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 631
      if (libast_debug_level >= 1U) {
        {
#line 631
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_map_get",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           631, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 631
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_map_get",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             631, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 631
      return ((spif_obj_t )((void *)0));
    }
#line 631
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 632
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 632
    if (! (! ((unsigned long )key == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 632
      if (libast_debug_level >= 1U) {
        {
#line 632
        tmp = time((time_t *)((void *)0));
#line 632
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                632, "spif_linked_list_map_get");
#line 632
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(key)");
        }
      }
#line 632
      return ((spif_obj_t )((void *)0));
    }
#line 632
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 633
  current = self->head;
  {
#line 633
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 633
    if (! current) {
#line 633
      goto while_break___1;
    }
    {
#line 637
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 637
      if (! (! ((unsigned long )current->data == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 637
        if (libast_debug_level >= 1U) {
          {
#line 637
          libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_map_get",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             637, "!SPIF_OBJ_ISNULL(current->data)");
          }
        } else {
          {
#line 637
          libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_map_get",
                               "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                               637, "!SPIF_OBJ_ISNULL(current->data)");
          }
        }
#line 637
        return ((spif_obj_t )((void *)0));
      }
#line 637
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 638
    tmp___0 = (*(((current->data)->cls)->comp))(current->data, key);
#line 638
    c = (spif_cmp_t )tmp___0;
    }
#line 639
    if ((int )c == 0) {
#line 640
      return (((spif_objpair_t )current->data)->value);
    } else
#line 641
    if ((int )c == 1) {
#line 642
      goto while_break___1;
    }
#line 633
    current = current->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 645
  return ((spif_obj_t )((void *)0));
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_list_t spif_linked_list_get_keys(spif_linked_list_t self , spif_list_t key_list ) 
{ 
  spif_linked_list_item_t current ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 653
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 653
      if (libast_debug_level >= 1U) {
        {
#line 653
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_get_keys",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           653, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 653
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_get_keys",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             653, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 653
      return ((spif_list_t )((void *)0));
    }
#line 653
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 654
  if ((unsigned long )key_list == (unsigned long )((spif_list_t )((void *)0))) {
    {
#line 655
    tmp = (*(((spif_class_t )spif_linked_list_listclass)->noo))();
#line 655
    key_list = (spif_list_t )tmp;
    }
  }
#line 657
  current = self->head;
  {
#line 657
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 657
    if (! current) {
#line 657
      goto while_break___0;
    }
    {
#line 659
    tmp___0 = (*(((((spif_objpair_t )current->data)->key)->cls)->dup))(((spif_objpair_t )current->data)->key);
#line 659
    (*(((spif_listclass_t )key_list->cls)->append))(key_list, (spif_obj_t )tmp___0);
#line 657
    current = current->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 661
  return (key_list);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_list_t spif_linked_list_get_pairs(spif_linked_list_t self , spif_list_t pair_list ) 
{ 
  spif_linked_list_item_t current ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
#line 669
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 669
      if (libast_debug_level >= 1U) {
        {
#line 669
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_get_pairs",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           669, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 669
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_get_pairs",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             669, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 669
      return ((spif_list_t )((void *)0));
    }
#line 669
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 670
  if ((unsigned long )pair_list == (unsigned long )((spif_list_t )((void *)0))) {
    {
#line 671
    tmp = (*(((spif_class_t )spif_linked_list_listclass)->noo))();
#line 671
    pair_list = (spif_list_t )tmp;
    }
  }
#line 673
  current = self->head;
  {
#line 673
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 673
    if (! current) {
#line 673
      goto while_break___0;
    }
    {
#line 675
    tmp___0 = (*((((spif_obj_t )((spif_objpair_t )current->data))->cls)->dup))((spif_objpair_t )current->data);
#line 675
    (*(((spif_listclass_t )pair_list->cls)->append))(pair_list, (spif_obj_t )tmp___0);
#line 673
    current = current->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 677
  return (pair_list);
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_list_t spif_linked_list_get_values(spif_linked_list_t self , spif_list_t value_list ) 
{ 
  spif_linked_list_item_t current ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 685
      if (libast_debug_level >= 1U) {
        {
#line 685
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_get_values",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           685, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 685
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_get_values",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             685, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 685
      return ((spif_list_t )((void *)0));
    }
#line 685
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if ((unsigned long )value_list == (unsigned long )((spif_list_t )((void *)0))) {
    {
#line 687
    tmp = (*(((spif_class_t )spif_linked_list_listclass)->noo))();
#line 687
    value_list = (spif_list_t )tmp;
    }
  }
#line 689
  current = self->head;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (! current) {
#line 689
      goto while_break___0;
    }
    {
#line 691
    tmp___0 = (*(((((spif_objpair_t )current->data)->value)->cls)->dup))(((spif_objpair_t )current->data)->value);
#line 691
    (*(((spif_listclass_t )value_list->cls)->append))(value_list, (spif_obj_t )tmp___0);
#line 689
    current = current->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 693
  return (value_list);
}
}
#line 696 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_has_key(spif_linked_list_t self , spif_obj_t key ) 
{ 
  int tmp___0 ;
  spif_obj_t tmp___1 ;

  {
  {
#line 699
  tmp___1 = spif_linked_list_map_get(self, key);
  }
#line 699
  if ((unsigned long )tmp___1 == (unsigned long )((spif_obj_t )((void *)0))) {
#line 699
    tmp___0 = 0;
  } else {
#line 699
    tmp___0 = 1;
  }
#line 699
  return ((spif_bool_t )tmp___0);
}
}
#line 702 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_has_value(spif_linked_list_t self , spif_obj_t value ) 
{ 
  spif_linked_list_item_t current ;
  spif_objpair_t pair ;
  void *tmp ;

  {
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! (! ((unsigned long )((spif_vector_t )self) == (unsigned long )((spif_vector_t )((void *)0))))) {
#line 707
      if (libast_debug_level >= 1U) {
        {
#line 707
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_has_value",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           707, "!SPIF_VECTOR_ISNULL(self)");
        }
      } else {
        {
#line 707
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_has_value",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             707, "!SPIF_VECTOR_ISNULL(self)");
        }
      }
#line 707
      return ((spif_bool_t )0);
    }
#line 707
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  current = self->head;
  {
#line 709
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 709
    if (! current) {
#line 709
      goto while_break___0;
    }
#line 713
    pair = (spif_objpair_t )current->data;
#line 714
    if ((unsigned long )value == (unsigned long )((spif_obj_t )((void *)0))) {
#line 714
      if ((unsigned long )pair->value == (unsigned long )((spif_obj_t )((void *)0))) {
#line 715
        return ((spif_bool_t )1);
      } else {
#line 714
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 716
      tmp = (*(((pair->value)->cls)->comp))(pair->value, value);
      }
#line 716
      if ((int )((spif_cmp_t )tmp) == 0) {
#line 717
        return ((spif_bool_t )1);
      }
    }
#line 709
    current = current->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 720
  return ((spif_bool_t )0);
}
}
#line 723 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_listidx_t spif_linked_list_index(spif_linked_list_t self , spif_obj_t obj ) 
{ 
  spif_listidx_t i ;
  spif_linked_list_item_t current ;
  void *tmp ;
  spif_listidx_t tmp___0 ;

  {
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 729
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 729
      if (libast_debug_level >= 1U) {
        {
#line 729
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_index",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           729, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 729
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_index",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             729, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 729
      return (-1);
    }
#line 729
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 730
  current = self->head;
#line 730
  i = 0;
  {
#line 730
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 730
    if (current) {
      {
#line 730
      tmp = (*((obj->cls)->comp))(obj, current->data);
      }
#line 730
      if ((int )((spif_cmp_t )tmp) == 0) {
#line 730
        goto while_break___0;
      }
    } else {
#line 730
      goto while_break___0;
    }
#line 730
    i ++;
#line 730
    current = current->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 731
  if (current) {
#line 731
    tmp___0 = i;
  } else {
#line 731
    tmp___0 = -1;
  }
#line 731
  return (tmp___0);
}
}
#line 734 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_insert(spif_linked_list_t self , spif_obj_t obj ) 
{ 
  spif_linked_list_item_t item ;
  spif_linked_list_item_t current ;
  spif_cmp_t tmp ;
  spif_cmp_t tmp___0 ;

  {
  {
#line 739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 739
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 739
      if (libast_debug_level >= 1U) {
        {
#line 739
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_insert",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           739, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 739
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_insert",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             739, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 739
      return ((spif_bool_t )0);
    }
#line 739
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 740
  item = spif_linked_list_item_new();
#line 741
  spif_linked_list_item_set_data(item, obj);
  }
#line 743
  if ((unsigned long )self->head == (unsigned long )((spif_linked_list_item_t )((void *)0))) {
#line 744
    self->head = item;
  } else {
    {
#line 745
    tmp___0 = spif_linked_list_item_comp(item, self->head);
    }
#line 745
    if ((int )tmp___0 == -1) {
#line 746
      item->next = self->head;
#line 747
      self->head = item;
    } else {
#line 749
      current = self->head;
      {
#line 749
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 749
        if (current->next) {
          {
#line 749
          tmp = spif_linked_list_item_comp(item, current->next);
          }
#line 749
          if (! ((int )tmp == 1)) {
#line 749
            goto while_break___0;
          }
        } else {
#line 749
          goto while_break___0;
        }
#line 749
        current = current->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 752
      item->next = current->next;
#line 753
      current->next = item;
    }
  }
#line 755
  (self->len) ++;
#line 756
  return ((spif_bool_t )1);
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_insert_at(spif_linked_list_t self , spif_obj_t obj ,
                                              spif_listidx_t idx ) 
{ 
  spif_listidx_t i ;
  spif_linked_list_item_t item ;
  spif_linked_list_item_t current ;
  time_t tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 765
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 765
      if (libast_debug_level >= 1U) {
        {
#line 765
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_insert_at",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           765, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 765
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_insert_at",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             765, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 765
      return ((spif_bool_t )0);
    }
#line 765
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 766
  if (idx < 0) {
#line 768
    idx += self->len;
  }
  {
#line 770
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 770
    if (! (idx + 1 >= 0)) {
#line 770
      if (libast_debug_level >= 1U) {
        {
#line 770
        tmp = time((time_t *)((void *)0));
#line 770
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                770, "spif_linked_list_insert_at");
#line 770
        libast_dprintf("REQUIRE failed:  %s\n", "(idx + 1) >= 0");
        }
      }
#line 770
      return ((spif_bool_t )0);
    }
#line 770
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 772
  if (idx == 0) {
    {
#line 773
    tmp___0 = spif_linked_list_prepend(self, obj);
    }
#line 773
    return (tmp___0);
  } else
#line 772
  if ((unsigned long )self->head == (unsigned long )((spif_linked_list_item_t )((void *)0))) {
    {
#line 773
    tmp___0 = spif_linked_list_prepend(self, obj);
    }
#line 773
    return (tmp___0);
  }
#line 775
  current = self->head;
#line 775
  i = 1;
  {
#line 775
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 775
    if (current->next) {
#line 775
      if (! (i < idx)) {
#line 775
        goto while_break___1;
      }
    } else {
#line 775
      goto while_break___1;
    }
#line 775
    i ++;
#line 775
    current = current->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 776
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 776
    if (! (i < idx)) {
#line 776
      goto while_break___2;
    }
    {
#line 777
    current->next = spif_linked_list_item_new();
#line 778
    (self->len) ++;
#line 776
    i ++;
#line 776
    current = current->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 781
  item = spif_linked_list_item_new();
#line 782
  spif_linked_list_item_set_data(item, obj);
#line 784
  item->next = current->next;
#line 785
  current->next = item;
#line 786
  (self->len) ++;
  }
#line 787
  return ((spif_bool_t )1);
}
}
#line 790 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_iterator_t spif_linked_list_iterator(spif_linked_list_t self ) 
{ 
  spif_linked_list_iterator_t tmp ;

  {
  {
#line 793
  tmp = spif_linked_list_iterator_new(self);
  }
#line 793
  return ((spif_iterator_t )tmp);
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_prepend(spif_linked_list_t self , spif_obj_t obj ) 
{ 
  spif_linked_list_item_t item ;
  spif_linked_list_item_t current ;

  {
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 801
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 801
      if (libast_debug_level >= 1U) {
        {
#line 801
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_prepend",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           801, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 801
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_prepend",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             801, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 801
      return ((spif_bool_t )0);
    }
#line 801
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 803
  item = spif_linked_list_item_new();
#line 804
  spif_linked_list_item_set_data(item, obj);
#line 807
  current = self->head;
#line 808
  self->head = item;
#line 809
  item->next = current;
#line 811
  (self->len) ++;
  }
#line 812
  return ((spif_bool_t )1);
}
}
#line 815 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_obj_t spif_linked_list_remove(spif_linked_list_t self , spif_obj_t item ) 
{ 
  spif_linked_list_item_t current ;
  spif_linked_list_item_t tmp ;
  time_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 820
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 820
      if (libast_debug_level >= 1U) {
        {
#line 820
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_remove",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           820, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 820
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_remove",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             820, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 820
      return ((spif_obj_t )((void *)0));
    }
#line 820
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 821
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 821
    if (! (! ((unsigned long )item == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 821
      if (libast_debug_level >= 1U) {
        {
#line 821
        tmp___0 = time((time_t *)((void *)0));
#line 821
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                821, "spif_linked_list_remove");
#line 821
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(item)");
        }
      }
#line 821
      return ((spif_obj_t )((void *)0));
    }
#line 821
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 822
  if ((unsigned long )self->head == (unsigned long )((spif_linked_list_item_t )((void *)0))) {
#line 823
    return ((spif_obj_t )((void *)0));
  } else {
    {
#line 824
    tmp___2 = (*((item->cls)->comp))(item, (self->head)->data);
    }
#line 824
    if ((int )((spif_cmp_t )tmp___2) == 0) {
#line 825
      tmp = self->head;
#line 826
      self->head = (self->head)->next;
    } else {
#line 828
      current = self->head;
      {
#line 828
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 828
        if (current->next) {
          {
#line 828
          tmp___1 = (*((item->cls)->comp))(item, (current->next)->data);
          }
#line 828
          if ((int )((spif_cmp_t )tmp___1) == 0) {
#line 828
            goto while_break___1;
          }
        } else {
#line 828
          goto while_break___1;
        }
#line 828
        current = current->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 829
      if (current->next) {
#line 830
        tmp = current->next;
#line 831
        current->next = (current->next)->next;
      } else {
#line 833
        return ((spif_obj_t )((void *)0));
      }
    }
  }
  {
#line 836
  item = tmp->data;
#line 837
  tmp->data = (spif_obj_t )((void *)0);
#line 838
  spif_linked_list_item_del(tmp);
#line 840
  (self->len) --;
  }
#line 841
  return (item);
}
}
#line 844 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_obj_t spif_linked_list_map_remove(spif_linked_list_t self , spif_obj_t item ) 
{ 
  spif_linked_list_item_t current ;
  spif_linked_list_item_t tmp ;
  time_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 849
      if (libast_debug_level >= 1U) {
        {
#line 849
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_map_remove",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           849, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 849
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_map_remove",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             849, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 849
      return ((spif_obj_t )((void *)0));
    }
#line 849
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 850
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 850
    if (! (! ((unsigned long )item == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 850
      if (libast_debug_level >= 1U) {
        {
#line 850
        tmp___0 = time((time_t *)((void *)0));
#line 850
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                850, "spif_linked_list_map_remove");
#line 850
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(item)");
        }
      }
#line 850
      return ((spif_obj_t )((void *)0));
    }
#line 850
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 851
  if ((unsigned long )self->head == (unsigned long )((spif_linked_list_item_t )((void *)0))) {
#line 852
    return ((spif_obj_t )((void *)0));
  } else {
    {
#line 853
    tmp___2 = (*((((self->head)->data)->cls)->comp))((self->head)->data, item);
    }
#line 853
    if ((int )((spif_cmp_t )tmp___2) == 0) {
#line 854
      tmp = self->head;
#line 855
      self->head = (self->head)->next;
    } else {
#line 857
      current = self->head;
      {
#line 857
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 857
        if (current->next) {
          {
#line 857
          tmp___1 = (*((((current->next)->data)->cls)->comp))((current->next)->data,
                                                              item);
          }
#line 857
          if ((int )((spif_cmp_t )tmp___1) == 0) {
#line 857
            goto while_break___1;
          }
        } else {
#line 857
          goto while_break___1;
        }
#line 857
        current = current->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 858
      if (current->next) {
#line 859
        tmp = current->next;
#line 860
        current->next = (current->next)->next;
      } else {
#line 862
        return ((spif_obj_t )((void *)0));
      }
    }
  }
  {
#line 865
  item = tmp->data;
#line 866
  tmp->data = (spif_obj_t )((void *)0);
#line 867
  spif_linked_list_item_del(tmp);
#line 869
  (self->len) --;
  }
#line 870
  return (item);
}
}
#line 873 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_obj_t spif_linked_list_remove_at(spif_linked_list_t self , spif_listidx_t idx ) 
{ 
  spif_listidx_t i ;
  spif_linked_list_item_t item ;
  spif_linked_list_item_t current ;
  spif_obj_t tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 880
  while (1) {
    while_continue: /* CIL Label */ ;
#line 880
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 880
      if (libast_debug_level >= 1U) {
        {
#line 880
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_remove_at",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           880, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 880
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_remove_at",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             880, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 880
      return ((spif_obj_t )((void *)0));
    }
#line 880
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 881
  if (idx < 0) {
#line 883
    idx += self->len;
  }
  {
#line 885
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 885
    if (! (idx >= 0)) {
#line 885
      if (libast_debug_level >= 1U) {
        {
#line 885
        tmp___0 = time((time_t *)((void *)0));
#line 885
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                885, "spif_linked_list_remove_at");
#line 885
        libast_dprintf("REQUIRE failed:  %s\n", "idx >= 0");
        }
      }
#line 885
      return ((spif_obj_t )((void *)0));
    }
#line 885
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 886
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 886
    if (! (idx < self->len)) {
#line 886
      if (libast_debug_level >= 1U) {
        {
#line 886
        tmp___1 = time((time_t *)((void *)0));
#line 886
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                886, "spif_linked_list_remove_at");
#line 886
        libast_dprintf("REQUIRE failed:  %s\n", "idx < self->len");
        }
      }
#line 886
      return ((spif_obj_t )((void *)0));
    }
#line 886
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 888
  if ((unsigned long )self->head == (unsigned long )((spif_linked_list_item_t )((void *)0))) {
#line 889
    return ((spif_obj_t )((void *)0));
  } else
#line 890
  if (idx == 0) {
#line 891
    item = self->head;
#line 892
    self->head = item->next;
  } else {
#line 894
    current = self->head;
#line 894
    i = 1;
    {
#line 894
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 894
      if (current->next) {
#line 894
        if (! (i < idx)) {
#line 894
          goto while_break___2;
        }
      } else {
#line 894
        goto while_break___2;
      }
#line 894
      i ++;
#line 894
      current = current->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 895
    if (i != idx) {
#line 896
      return ((spif_obj_t )((void *)0));
    }
#line 898
    item = current->next;
#line 899
    current->next = item->next;
  }
  {
#line 901
  (self->len) --;
#line 902
  tmp = spif_linked_list_item_get_data(item);
#line 903
  item->data = (spif_obj_t )((void *)0);
#line 904
  spif_linked_list_item_del(item);
  }
#line 905
  return (tmp);
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_reverse(spif_linked_list_t self ) 
{ 
  spif_linked_list_item_t current ;
  spif_linked_list_item_t tmp ;
  spif_linked_list_item_t previous ;

  {
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
#line 913
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 913
      if (libast_debug_level >= 1U) {
        {
#line 913
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_reverse",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           913, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 913
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_reverse",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             913, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 913
      return ((spif_bool_t )0);
    }
#line 913
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 914
  previous = (spif_linked_list_item_t )((void *)0);
#line 914
  current = self->head;
  {
#line 914
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 914
    if (! current) {
#line 914
      goto while_break___0;
    }
#line 915
    tmp = current;
#line 916
    current = current->next;
#line 917
    tmp->next = previous;
#line 914
    previous = tmp;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 919
  self->head = tmp;
#line 920
  return ((spif_bool_t )1);
}
}
#line 923 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_set(spif_linked_list_t self , spif_obj_t key ,
                                        spif_obj_t value ) 
{ 
  spif_linked_list_item_t current ;
  time_t tmp ;
  void *tmp___0 ;
  spif_objpair_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 928
  while (1) {
    while_continue: /* CIL Label */ ;
#line 928
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 928
      if (libast_debug_level >= 1U) {
        {
#line 928
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_set",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           928, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 928
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_set",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             928, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 928
      return ((spif_bool_t )0);
    }
#line 928
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 929
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 929
    if (! (! ((unsigned long )key == (unsigned long )((spif_obj_t )((void *)0))))) {
#line 929
      if (libast_debug_level >= 1U) {
        {
#line 929
        tmp = time((time_t *)((void *)0));
#line 929
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                929, "spif_linked_list_set");
#line 929
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_OBJ_ISNULL(key)");
        }
      }
#line 929
      return ((spif_bool_t )0);
    }
#line 929
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 931
  if (! ((unsigned long )key == (unsigned long )((spif_obj_t )((void *)0)))) {
#line 931
    if ((unsigned long )key->cls == (unsigned long )spif_objpair_class) {
#line 931
      if ((unsigned long )value == (unsigned long )((spif_obj_t )((void *)0))) {
#line 932
        value = ((spif_objpair_t )key)->value;
#line 933
        key = ((spif_objpair_t )key)->key;
      }
    }
  }
#line 935
  current = self->head;
  {
#line 935
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 935
    if (! current) {
#line 935
      goto while_break___1;
    }
    {
#line 936
    tmp___0 = (*(((current->data)->cls)->comp))(current->data, key);
    }
#line 936
    if ((int )((spif_cmp_t )tmp___0) == 0) {
#line 937
      goto while_break___1;
    }
#line 935
    current = current->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 941
  if ((unsigned long )current == (unsigned long )((spif_linked_list_item_t )((void *)0))) {
    {
#line 942
    tmp___1 = spif_objpair_new_from_both(key, value);
#line 942
    spif_linked_list_insert(self, (spif_obj_t )tmp___1);
    }
#line 943
    return ((spif_bool_t )0);
  } else {
    {
#line 945
    tmp___2 = (*((value->cls)->dup))(value);
#line 945
    spif_objpair_set_value((spif_objpair_t )current->data, (spif_obj_t )tmp___2);
    }
#line 946
    return ((spif_bool_t )1);
  }
}
}
#line 950 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_obj_t *spif_linked_list_to_array(spif_linked_list_t self ) 
{ 
  spif_obj_t *tmp ;
  spif_linked_list_item_t current ;
  spif_listidx_t i ;
  void *tmp___0 ;
  spif_obj_t tmp___1 ;

  {
  {
#line 957
  while (1) {
    while_continue: /* CIL Label */ ;
#line 957
    if (! (! ((unsigned long )((spif_list_t )self) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 957
      if (libast_debug_level >= 1U) {
        {
#line 957
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_to_array",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           957, "!SPIF_LIST_ISNULL(self)");
        }
      } else {
        {
#line 957
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_to_array",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             957, "!SPIF_LIST_ISNULL(self)");
        }
      }
#line 957
      return ((spif_obj_t *)((void *)0));
    }
#line 957
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 958
  tmp___0 = malloc(sizeof(spif_const_obj_t ) * (unsigned long )self->len);
#line 958
  tmp = (spif_obj_t *)tmp___0;
#line 959
  i = 0;
#line 959
  current = self->head;
  }
  {
#line 959
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 959
    if (! (i < self->len)) {
#line 959
      goto while_break___0;
    }
    {
#line 960
    tmp___1 = spif_linked_list_item_get_data(current);
#line 960
    *(tmp + i) = tmp___1;
#line 959
    current = current->next;
#line 959
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 962
  return (tmp);
}
}
#line 965 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_listidx_t spif_linked_list_get_len(spif_linked_list_t self ) 
{ 


  {
#line 965
  return (self->len);
}
}
#line 965 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_bool_t spif_linked_list_set_len(spif_linked_list_t self , spif_listidx_t new_len ) 
{ 


  {
#line 965
  self->len = new_len;
#line 965
  return ((spif_bool_t )1);
}
}
#line 966 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_linked_list_item_t spif_linked_list_get_head(spif_linked_list_t self ) 
{ 


  {
#line 966
  return (self->head);
}
}
#line 966 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_bool_t spif_linked_list_set_head(spif_linked_list_t self , spif_linked_list_item_t new_head ) 
{ 


  {
#line 966
  self->head = new_head;
#line 966
  return ((spif_bool_t )1);
}
}
#line 969 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_linked_list_iterator_t spif_linked_list_iterator_new(spif_linked_list_t subject ) 
{ 
  spif_linked_list_iterator_t self ;
  void *tmp ;
  spif_bool_t tmp___0 ;

  {
  {
#line 974
  tmp = malloc(sizeof(spif_const_linked_list_iterator_t ));
#line 974
  self = (spif_linked_list_iterator_t )tmp;
#line 975
  tmp___0 = spif_linked_list_iterator_init(self, subject);
  }
#line 975
  if (! tmp___0) {
    {
#line 976
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 976
      free((void *)self);
#line 976
      self = (spif_linked_list_iterator_t )((void *)0);
      }
#line 976
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 977
    self = (spif_linked_list_iterator_t )((void *)0);
  }
#line 979
  return (self);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_iterator_init(spif_linked_list_iterator_t self ,
                                                  spif_linked_list_t subject ) 
{ 


  {
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;
#line 985
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 985
      if (libast_debug_level >= 1U) {
        {
#line 985
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_init",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           985, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 985
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_init",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             985, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 985
      return ((spif_bool_t )0);
    }
#line 985
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 987
  spif_obj_set_class((spif_obj_t )self, (spif_class_t )spif_linked_list_iteratorclass);
#line 988
  self->subject = subject;
  }
#line 989
  if ((unsigned long )((spif_list_t )self->subject) == (unsigned long )((spif_list_t )((void *)0))) {
#line 990
    self->current = (spif_linked_list_item_t )((void *)0);
  } else {
#line 992
    self->current = (self->subject)->head;
  }
#line 994
  return ((spif_bool_t )1);
}
}
#line 997 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_iterator_done(spif_linked_list_iterator_t self ) 
{ 


  {
  {
#line 1000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1000
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1000
      if (libast_debug_level >= 1U) {
        {
#line 1000
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_done",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           1000, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1000
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_done",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             1000, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1000
      return ((spif_bool_t )0);
    }
#line 1000
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1002
  self->subject = (spif_linked_list_t )((void *)0);
#line 1003
  self->current = (spif_linked_list_item_t )((void *)0);
#line 1004
  return ((spif_bool_t )1);
}
}
#line 1007 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_iterator_del(spif_linked_list_iterator_t self ) 
{ 


  {
  {
#line 1010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1010
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1010
      if (libast_debug_level >= 1U) {
        {
#line 1010
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_del",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           1010, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1010
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_del",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             1010, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1010
      return ((spif_bool_t )0);
    }
#line 1010
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1011
  spif_linked_list_iterator_done(self);
  }
  {
#line 1012
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1012
    free((void *)self);
#line 1012
    self = (spif_linked_list_iterator_t )((void *)0);
    }
#line 1012
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1013
  return ((spif_bool_t )1);
}
}
#line 1016 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_str_t spif_linked_list_iterator_show(spif_linked_list_iterator_t self ,
                                                 spif_charptr_t name___0 , spif_str_t buff ,
                                                 size_t indent ) 
{ 
  spif_char_t tmp[4096] ;
  char *tmp___0 ;

  {
#line 1021
  if ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))) {
    {
#line 1022
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1022
      memset((void *)(tmp), ' ', indent);
      }
#line 1022
      if ((char *)name___0) {
#line 1022
        tmp___0 = (char *)name___0;
      } else {
#line 1022
        tmp___0 = (char *)"<name null>";
      }
      {
#line 1022
      snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
               (char const   */* __restrict  */)"(spif_iterator_t) %s:  { ((spif_iterator_t) NULL) }\n",
               tmp___0);
      }
#line 1022
      if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
        {
#line 1022
        buff = spif_str_new_from_ptr(tmp);
        }
      } else {
        {
#line 1022
        spif_str_append_from_ptr(buff, tmp);
        }
      }
#line 1022
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1023
    return (buff);
  }
  {
#line 1026
  memset((void *)(tmp), ' ', indent);
#line 1027
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"(spif_linked_list_iterator_t) %s:  %10p {\n",
           name___0, (spif_ptr_t )self);
  }
#line 1030
  if ((unsigned long )((spif_obj_t )buff) == (unsigned long )((spif_obj_t )((void *)0))) {
    {
#line 1031
    buff = spif_str_new_from_ptr(tmp);
    }
  } else {
    {
#line 1033
    spif_str_append_from_ptr(buff, tmp);
    }
  }
  {
#line 1036
  buff = spif_linked_list_show(self->subject, (spif_charptr_t )"subject", buff, indent + 2UL);
#line 1037
  buff = spif_linked_list_item_show(self->current, (spif_charptr_t )"current", buff,
                                    indent + 2UL);
#line 1039
  snprintf((char */* __restrict  */)((char *)(tmp) + indent), sizeof(tmp) - indent,
           (char const   */* __restrict  */)"}\n");
#line 1040
  spif_str_append_from_ptr(buff, tmp);
  }
#line 1041
  return (buff);
}
}
#line 1044 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_cmp_t spif_linked_list_iterator_comp(spif_linked_list_iterator_t self ,
                                                 spif_linked_list_iterator_t other ) 
{ 
  spif_cmp_t tmp ;

  {
  {
#line 1047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1047
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 1047
      if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 1047
        return ((spif_cmp_t )0);
      } else {
#line 1047
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1047
    if ((unsigned long )((spif_obj_t )self) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 1047
      return ((spif_cmp_t )-1);
    } else
#line 1047
    if ((unsigned long )((spif_obj_t )other) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 1047
      return ((spif_cmp_t )1);
    }
#line 1047
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1048
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1048
    if ((unsigned long )((spif_obj_t )self->subject) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 1048
      if ((unsigned long )((spif_obj_t )other->subject) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 1048
        return ((spif_cmp_t )0);
      } else {
#line 1048
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1048
    if ((unsigned long )((spif_obj_t )self->subject) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 1048
      return ((spif_cmp_t )-1);
    } else
#line 1048
    if ((unsigned long )((spif_obj_t )other->subject) == (unsigned long )((spif_obj_t )((void *)0))) {
#line 1048
      return ((spif_cmp_t )1);
    }
#line 1048
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1049
  tmp = spif_linked_list_comp(self->subject, other->subject);
  }
#line 1049
  return (tmp);
}
}
#line 1052 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_linked_list_iterator_t spif_linked_list_iterator_dup(spif_linked_list_iterator_t self ) 
{ 
  spif_linked_list_iterator_t tmp ;

  {
  {
#line 1057
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1057
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1057
      if (libast_debug_level >= 1U) {
        {
#line 1057
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_dup",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           1057, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1057
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_dup",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             1057, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1057
      return ((spif_linked_list_iterator_t )((void *)0));
    }
#line 1057
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1058
  tmp = spif_linked_list_iterator_new(self->subject);
#line 1059
  tmp->current = self->current;
  }
#line 1060
  return (tmp);
}
}
#line 1063 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_classname_t spif_linked_list_iterator_type(spif_linked_list_iterator_t self ) 
{ 


  {
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1066
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1066
      if (libast_debug_level >= 1U) {
        {
#line 1066
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_type",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           1066, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1066
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_type",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             1066, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1066
      return ((spif_classname_t )((void *)0));
    }
#line 1066
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1067
  return ((spif_classname_t )((spif_obj_t )self)->cls);
}
}
#line 1070 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_bool_t spif_linked_list_iterator_has_next(spif_linked_list_iterator_t self ) 
{ 
  spif_linked_list_t subject ;
  time_t tmp ;

  {
  {
#line 1075
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1075
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1075
      if (libast_debug_level >= 1U) {
        {
#line 1075
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_has_next",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           1075, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1075
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_has_next",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             1075, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1075
      return ((spif_bool_t )0);
    }
#line 1075
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1076
  subject = self->subject;
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1077
    if (! (! ((unsigned long )((spif_list_t )subject) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 1077
      if (libast_debug_level >= 1U) {
        {
#line 1077
        tmp = time((time_t *)((void *)0));
#line 1077
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                1077, "spif_linked_list_iterator_has_next");
#line 1077
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_LIST_ISNULL(subject)");
        }
      }
#line 1077
      return ((spif_bool_t )0);
    }
#line 1077
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1078
  if (self->current) {
#line 1079
    return ((spif_bool_t )1);
  } else {
#line 1081
    return ((spif_bool_t )0);
  }
}
}
#line 1085 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
static spif_obj_t spif_linked_list_iterator_next(spif_linked_list_iterator_t self ) 
{ 
  spif_obj_t tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 1090
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1090
    if (! (! ((unsigned long )((spif_iterator_t )self) == (unsigned long )((spif_iterator_t )((void *)0))))) {
#line 1090
      if (libast_debug_level >= 1U) {
        {
#line 1090
        libast_fatal_error("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_next",
                           "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                           1090, "!SPIF_ITERATOR_ISNULL(self)");
        }
      } else {
        {
#line 1090
        libast_print_warning("ASSERT failed in %s() at %s:%d:  %s\n", "spif_linked_list_iterator_next",
                             "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                             1090, "!SPIF_ITERATOR_ISNULL(self)");
        }
      }
#line 1090
      return ((spif_obj_t )((void *)0));
    }
#line 1090
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1091
    if (! (! ((unsigned long )((spif_list_t )self->subject) == (unsigned long )((spif_list_t )((void *)0))))) {
#line 1091
      if (libast_debug_level >= 1U) {
        {
#line 1091
        tmp___0 = time((time_t *)((void *)0));
#line 1091
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___0, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                1091, "spif_linked_list_iterator_next");
#line 1091
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_LIST_ISNULL(self->subject)");
        }
      }
#line 1091
      return ((spif_obj_t )((void *)0));
    }
#line 1091
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1092
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1092
    if (! (! ((unsigned long )self->current == (unsigned long )((spif_linked_list_item_t )((void *)0))))) {
#line 1092
      if (libast_debug_level >= 1U) {
        {
#line 1092
        tmp___1 = time((time_t *)((void *)0));
#line 1092
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %12s | %4d: %s(): ",
                (unsigned long )tmp___1, "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c",
                1092, "spif_linked_list_iterator_next");
#line 1092
        libast_dprintf("REQUIRE failed:  %s\n", "!SPIF_LINKED_LIST_ITEM_ISNULL(self->current)");
        }
      }
#line 1092
      return ((spif_obj_t )((void *)0));
    }
#line 1092
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1093
  tmp = (self->current)->data;
#line 1094
  self->current = (self->current)->next;
#line 1095
  return (tmp);
}
}
#line 1098 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_linked_list_t spif_linked_list_iterator_get_subject(spif_linked_list_iterator_t self ) 
{ 


  {
#line 1098
  return (self->subject);
}
}
#line 1098 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_bool_t spif_linked_list_iterator_set_subject(spif_linked_list_iterator_t self ,
                                                  spif_linked_list_t new_subject ) 
{ 


  {
#line 1098
  if (! ((unsigned long )((spif_obj_t )self->subject) == (unsigned long )((spif_obj_t )((void *)0)))) {
    {
#line 1098
    (*((((spif_obj_t )self->subject)->cls)->del))(self->subject);
    }
  }
#line 1098
  self->subject = new_subject;
#line 1098
  return ((spif_bool_t )1);
}
}
#line 1099 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_linked_list_item_t spif_linked_list_iterator_get_current(spif_linked_list_iterator_t self ) 
{ 


  {
#line 1099
  return (self->current);
}
}
#line 1099 "/home/june/repo/benchmarks/collector/temp/libast-0.7/src/linked_list.c"
spif_bool_t spif_linked_list_iterator_set_current(spif_linked_list_iterator_t self ,
                                                  spif_linked_list_item_t new_current ) 
{ 


  {
#line 1099
  self->current = new_current;
#line 1099
  return ((spif_bool_t )1);
}
}
