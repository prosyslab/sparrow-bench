/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 74 "mime2.h"
struct header {
   char *h_field ;
   char *h_value ;
   struct header *h_link ;
   u_short h_flags ;
};
#line 83 "mime2.h"
typedef struct header HDR;
#line 86 "mime2.h"
struct address {
   char *q_paddr ;
   char *q_user ;
   char *q_ruser ;
   char *q_host ;
   u_long q_flags ;
   uid_t q_uid ;
   gid_t q_gid ;
   char *q_home ;
   char *q_fullname ;
   struct address *q_next ;
   struct address *q_alias ;
   char *q_owner ;
   struct address *q_tchain ;
   char *q_orcpt ;
   char *q_status ;
   char *q_rstatus ;
   char *q_statmta ;
   short q_specificity ;
};
#line 110 "mime2.h"
typedef struct address ADDRESS;
#line 114 "mime2.h"
struct envelope {
   HDR *e_header ;
   long e_msgpriority ;
   time_t e_ctime ;
   char *e_to ;
   ADDRESS e_from ;
   char *e_sender ;
   char **e_fromdomain ;
   ADDRESS *e_sendqueue ;
   ADDRESS *e_errorqueue ;
   long e_msgsize ;
   long e_flags ;
   int e_nrcpts ;
   short e_class ;
   short e_hopcount ;
   short e_nsent ;
   short e_sendmode ;
   short e_errormode ;
   short e_timeoutclass ;
   struct envelope *e_parent ;
   struct envelope *e_sibling ;
   char *e_bodytype ;
   FILE *e_dfp ;
   char *e_id ;
   FILE *e_xfp ;
   FILE *e_lockfp ;
   char *e_message ;
   char *e_statmsg ;
   char *e_msgboundary ;
   char *e_origrcpt ;
   char *e_envid ;
   char *e_status ;
   time_t e_dtime ;
   int e_ntries ;
   dev_t e_dfdev ;
   ino_t e_dfino ;
   char *e_macro[256] ;
};
#line 155 "mime2.h"
typedef struct envelope ENVELOPE;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 69 "mime2-bad.c"
void mime7to8(HDR *header , ENVELOPE *e ) ;
#line 70
char *hvalue(char *field , HDR *header ) ;
#line 72 "mime2-bad.c"
int main(int argc , char **argv ) 
{ 
  HDR *header ;
  register ENVELOPE *e ;
  FILE *temp ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 78
  if (! (argc == 2)) {
    {
#line 78
    __assert_fail("argc==2", "mime2-bad.c", 78U, "main");
    }
  }
  {
#line 80
  tmp = malloc(sizeof(struct header ));
#line 80
  header = (HDR *)tmp;
#line 82
  header->h_field = (char *)"Content-Transfer-Encoding";
#line 83
  header->h_value = (char *)"base64";
#line 85
  tmp___0 = malloc(sizeof(struct envelope ));
#line 85
  e = (ENVELOPE *)tmp___0;
#line 86
  e->e_id = (char *)"First Entry";
#line 88
  temp = fopen((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"r");
#line 90
  e->e_dfp = temp;
#line 91
  mime7to8(header, e);
#line 93
  fclose(temp);
  }
#line 95
  return (0);
#line 98
  return (0);
}
}
#line 101 "mime2-bad.c"
static char index_64[128]  = 
#line 101
  {      (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)62, 
        (char)-1,      (char)-1,      (char)-1,      (char)63, 
        (char)52,      (char)53,      (char)54,      (char)55, 
        (char)56,      (char)57,      (char)58,      (char)59, 
        (char)60,      (char)61,      (char)-1,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)0,      (char)1,      (char)2, 
        (char)3,      (char)4,      (char)5,      (char)6, 
        (char)7,      (char)8,      (char)9,      (char)10, 
        (char)11,      (char)12,      (char)13,      (char)14, 
        (char)15,      (char)16,      (char)17,      (char)18, 
        (char)19,      (char)20,      (char)21,      (char)22, 
        (char)23,      (char)24,      (char)25,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1, 
        (char)-1,      (char)26,      (char)27,      (char)28, 
        (char)29,      (char)30,      (char)31,      (char)32, 
        (char)33,      (char)34,      (char)35,      (char)36, 
        (char)37,      (char)38,      (char)39,      (char)40, 
        (char)41,      (char)42,      (char)43,      (char)44, 
        (char)45,      (char)46,      (char)47,      (char)48, 
        (char)49,      (char)50,      (char)51,      (char)-1, 
        (char)-1,      (char)-1,      (char)-1,      (char)-1};
#line 139 "mime2-bad.c"
void mime7to8(HDR *header , ENVELOPE *e ) 
{ 
  register char *p ;
  u_char *fbufp ;
  char canary[10] ;
  u_char fbuf[51] ;
  int c1 ;
  int c2 ;
  int c3 ;
  int c4 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 150
  strcpy((char */* __restrict  */)(canary), (char const   */* __restrict  */)"GOOD");
#line 152
  p = hvalue((char *)"Content-Transfer-Encoding", header);
  }
#line 153
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 155
    printf((char const   */* __restrict  */)"Content-Transfer-Encoding not found in header\n");
    }
#line 156
    return;
  }
  {
#line 165
  tmp___6 = strcasecmp((char const   *)p, "base64");
  }
#line 165
  if (tmp___6 == 0) {
#line 169
    fbufp = fbuf;
    {
#line 170
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 170
      c1 = fgetc(e->e_dfp);
      }
#line 170
      if (! (c1 != -1)) {
#line 170
        goto while_break;
      }
#line 172
      if ((c1 & -128) == 0) {
        {
#line 172
        tmp = __ctype_b_loc();
        }
#line 172
        if ((int const   )*(*tmp + c1) & 8192) {
#line 173
          goto cont;
        }
      }
      {
#line 175
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 177
        c2 = fgetc(e->e_dfp);
        }
#line 175
        if ((c2 & -128) == 0) {
          {
#line 175
          tmp___0 = __ctype_b_loc();
          }
#line 175
          if (! ((int const   )*(*tmp___0 + c2) & 8192)) {
#line 175
            goto while_break___0;
          }
        } else {
#line 175
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 179
      if (c2 == -1) {
#line 180
        goto while_break;
      }
      {
#line 182
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 184
        c3 = fgetc(e->e_dfp);
        }
#line 182
        if ((c3 & -128) == 0) {
          {
#line 182
          tmp___1 = __ctype_b_loc();
          }
#line 182
          if (! ((int const   )*(*tmp___1 + c3) & 8192)) {
#line 182
            goto while_break___1;
          }
        } else {
#line 182
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 186
      if (c3 == -1) {
#line 187
        goto while_break;
      }
      {
#line 189
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 191
        c4 = fgetc(e->e_dfp);
        }
#line 189
        if ((c4 & -128) == 0) {
          {
#line 189
          tmp___2 = __ctype_b_loc();
          }
#line 189
          if (! ((int const   )*(*tmp___2 + c4) & 8192)) {
#line 189
            goto while_break___2;
          }
        } else {
#line 189
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 193
      if (c4 == -1) {
#line 194
        goto while_break;
      }
#line 196
      if (c1 == 61) {
#line 197
        goto cont;
      } else
#line 196
      if (c2 == 61) {
#line 197
        goto cont;
      }
#line 198
      if (c1 < 0) {
#line 198
        c1 = -1;
      } else
#line 198
      if (c1 > 127) {
#line 198
        c1 = -1;
      } else {
#line 198
        c1 = (int )index_64[c1];
      }
#line 199
      if (c2 < 0) {
#line 199
        c2 = -1;
      } else
#line 199
      if (c2 > 127) {
#line 199
        c2 = -1;
      } else {
#line 199
        c2 = (int )index_64[c2];
      }
#line 203
      *fbufp = (u_char )((c1 << 2) | ((c2 & 48) >> 4));
#line 213
      tmp___3 = fbufp;
#line 213
      fbufp ++;
#line 213
      if ((int )*tmp___3 == 10) {
#line 213
        goto _L;
      } else
#line 213
      if ((unsigned long )(fbuf) >= (unsigned long )(& fbuf[50])) {
        _L: /* CIL Label */ 
#line 216
        fbufp --;
#line 216
        if ((int )*fbufp != 10) {
#line 217
          fbufp ++;
        } else {
#line 216
          fbufp --;
#line 216
          if ((int )*fbufp != 13) {
#line 217
            fbufp ++;
          }
        }
        {
#line 219
        *fbufp = (u_char )'\000';
#line 221
        printf((char const   */* __restrict  */)"resetting fbufp\n");
#line 222
        fbufp = fbuf;
        }
      }
#line 225
      if (c3 == 61) {
#line 226
        goto cont;
      }
#line 227
      if (c3 < 0) {
#line 227
        c3 = -1;
      } else
#line 227
      if (c3 > 127) {
#line 227
        c3 = -1;
      } else {
#line 227
        c3 = (int )index_64[c3];
      }
#line 230
      *fbufp = (u_char )(((c2 & 15) << 4) | ((c3 & 60) >> 2));
#line 231
      tmp___4 = fbufp;
#line 231
      fbufp ++;
#line 231
      if ((int )*tmp___4 == 10) {
#line 231
        goto _L___0;
      } else
#line 231
      if ((unsigned long )(fbuf) >= (unsigned long )(& fbuf[50])) {
        _L___0: /* CIL Label */ 
#line 234
        fbufp --;
#line 234
        if ((int )*fbufp != 10) {
#line 235
          fbufp ++;
        } else {
#line 234
          fbufp --;
#line 234
          if ((int )*fbufp != 13) {
#line 235
            fbufp ++;
          }
        }
        {
#line 236
        *fbufp = (u_char )'\000';
#line 238
        printf((char const   */* __restrict  */)"resetting fbufp\n");
#line 239
        fbufp = fbuf;
        }
      }
#line 241
      if (c4 == 61) {
#line 242
        goto cont;
      }
#line 243
      if (c4 < 0) {
#line 243
        c4 = -1;
      } else
#line 243
      if (c4 > 127) {
#line 243
        c4 = -1;
      } else {
#line 243
        c4 = (int )index_64[c4];
      }
#line 246
      *fbufp = (u_char )(((c3 & 3) << 6) | c4);
#line 247
      tmp___5 = fbufp;
#line 247
      fbufp ++;
#line 247
      if ((int )*tmp___5 == 10) {
#line 247
        goto _L___1;
      } else
#line 247
      if ((unsigned long )(fbuf) >= (unsigned long )(& fbuf[50])) {
        _L___1: /* CIL Label */ 
#line 250
        fbufp --;
#line 250
        if ((int )*fbufp != 10) {
#line 251
          fbufp ++;
        } else {
#line 250
          fbufp --;
#line 250
          if ((int )*fbufp != 13) {
#line 251
            fbufp ++;
          }
        }
        {
#line 252
        *fbufp = (u_char )'\000';
#line 254
        printf((char const   */* __restrict  */)"resetting fbufp\n");
#line 255
        fbufp = fbuf;
        }
      }
      cont: ;
    }
    while_break: /* CIL Label */ ;
    }
#line 262
    if ((unsigned long )fbufp > (unsigned long )(fbuf)) {
#line 265
      *fbufp = (u_char )'\000';
    }
  } else {
    {
#line 272
    printf((char const   */* __restrict  */)"We only support base64 encoding...\n");
    }
  }
  {
#line 275
  printf((char const   */* __restrict  */)"canary should be GOOD\n");
#line 276
  printf((char const   */* __restrict  */)"canary = %s\n", canary);
  }
#line 277
  return;
}
}
#line 299 "mime2-bad.c"
char *hvalue(char *field , HDR *header ) 
{ 
  register HDR *h ;
  int tmp ;

  {
#line 305
  h = header;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! ((unsigned long )h != (unsigned long )((void *)0))) {
#line 305
      goto while_break;
    }
#line 307
    if (! (((int )h->h_flags & 4) != 0)) {
      {
#line 307
      tmp = strcasecmp((char const   *)h->h_field, (char const   *)field);
      }
#line 307
      if (tmp == 0) {
#line 309
        return (h->h_value);
      }
    }
#line 305
    h = h->h_link;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return ((char *)((void *)0));
}
}
