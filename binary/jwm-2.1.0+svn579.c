/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 267 "/usr/include/X11/Xlib.h"
struct _XDisplay;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 13 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
struct ClientNode;
#line 121 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
struct ClientState {
   unsigned int status ;
   unsigned int border ;
   unsigned int layer ;
   unsigned int desktop ;
   unsigned int opacity ;
};
#line 121 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
typedef struct ClientState ClientState;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.h"
enum __anonenum_BorderActionType_306 {
    BA_NONE = 0,
    BA_RESIZE = 1,
    BA_MOVE = 2,
    BA_CLOSE = 3,
    BA_MAXIMIZE = 4,
    BA_MINIMIZE = 5,
    BA_MENU = 6,
    BA_RESIZE_N = 16,
    BA_RESIZE_S = 32,
    BA_RESIZE_E = 64,
    BA_RESIZE_W = 128
} ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.h"
typedef enum __anonenum_BorderActionType_306 BorderActionType;
#line 64 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.h"
struct ColormapNode {
   Window window ;
   struct ColormapNode *next ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.h"
typedef struct ColormapNode ColormapNode;
#line 70 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.h"
struct AspectRatio {
   int minx ;
   int miny ;
   int maxx ;
   int maxy ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.h"
typedef struct AspectRatio AspectRatio;
#line 78
struct IconNode;
#line 78 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.h"
struct ClientNode {
   Window window ;
   Window parent ;
   Window owner ;
   int x ;
   int y ;
   int width ;
   int height ;
   int oldx ;
   int oldy ;
   int oldWidth ;
   int oldHeight ;
   long sizeFlags ;
   int baseWidth ;
   int baseHeight ;
   int minWidth ;
   int minHeight ;
   int maxWidth ;
   int maxHeight ;
   int xinc ;
   int yinc ;
   AspectRatio aspect ;
   int gravity ;
   Colormap cmap ;
   ColormapNode *colormaps ;
   char *name ;
   char *instanceName ;
   char *className ;
   ClientState state ;
   BorderActionType borderAction ;
   struct IconNode *icon ;
   void (*controller)(int wasDestroyed ) ;
   struct ClientNode *prev ;
   struct ClientNode *next ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.h"
typedef struct ClientNode ClientNode;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 226 "/usr/include/X11/Xlib.h"
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 302 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_57 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 302 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_57 XSetWindowAttributes;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_62 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_62 XColor;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.h"
struct ScaledIconNode {
   int width ;
   int height ;
   Pixmap image ;
   Pixmap mask ;
   struct ScaledIconNode *next ;
};
#line 33
struct ImageNode;
#line 33 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.h"
struct IconNode {
   char *name ;
   struct ImageNode *image ;
   struct ScaledIconNode *nodes ;
   int useRender ;
   struct IconNode *next ;
   struct IconNode *prev ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.h"
typedef struct IconNode IconNode;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/image.h"
struct ImageNode {
   int width ;
   int height ;
   unsigned char *data ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
enum __anonenum_AtomType_304 {
    ATOM_COMPOUND_TEXT = 0,
    ATOM_UTF8_STRING = 1,
    ATOM_XSETROOT_ID = 2,
    ATOM_WM_STATE = 3,
    ATOM_WM_PROTOCOLS = 4,
    ATOM_WM_DELETE_WINDOW = 5,
    ATOM_WM_TAKE_FOCUS = 6,
    ATOM_WM_LOCALE_NAME = 7,
    ATOM_WM_CHANGE_STATE = 8,
    ATOM_WM_COLORMAP_WINDOWS = 9,
    ATOM_NET_SUPPORTED = 10,
    ATOM_NET_NUMBER_OF_DESKTOPS = 11,
    ATOM_NET_DESKTOP_NAMES = 12,
    ATOM_NET_DESKTOP_GEOMETRY = 13,
    ATOM_NET_DESKTOP_VIEWPORT = 14,
    ATOM_NET_CURRENT_DESKTOP = 15,
    ATOM_NET_ACTIVE_WINDOW = 16,
    ATOM_NET_WORKAREA = 17,
    ATOM_NET_SUPPORTING_WM_CHECK = 18,
    ATOM_NET_SHOWING_DESKTOP = 19,
    ATOM_NET_FRAME_EXTENTS = 20,
    ATOM_NET_WM_DESKTOP = 21,
    ATOM_NET_WM_STATE = 22,
    ATOM_NET_WM_STATE_STICKY = 23,
    ATOM_NET_WM_STATE_MAXIMIZED_VERT = 24,
    ATOM_NET_WM_STATE_MAXIMIZED_HORZ = 25,
    ATOM_NET_WM_STATE_SHADED = 26,
    ATOM_NET_WM_STATE_FULLSCREEN = 27,
    ATOM_NET_WM_STATE_HIDDEN = 28,
    ATOM_NET_WM_STATE_SKIP_TASKBAR = 29,
    ATOM_NET_WM_STATE_BELOW = 30,
    ATOM_NET_WM_STATE_ABOVE = 31,
    ATOM_NET_WM_ALLOWED_ACTIONS = 32,
    ATOM_NET_WM_ACTION_MOVE = 33,
    ATOM_NET_WM_ACTION_RESIZE = 34,
    ATOM_NET_WM_ACTION_MINIMIZE = 35,
    ATOM_NET_WM_ACTION_SHADE = 36,
    ATOM_NET_WM_ACTION_STICK = 37,
    ATOM_NET_WM_ACTION_MAXIMIZE_HORZ = 38,
    ATOM_NET_WM_ACTION_MAXIMIZE_VERT = 39,
    ATOM_NET_WM_ACTION_CHANGE_DESKTOP = 40,
    ATOM_NET_WM_ACTION_CLOSE = 41,
    ATOM_NET_WM_ACTION_BELOW = 42,
    ATOM_NET_WM_ACTION_ABOVE = 43,
    ATOM_NET_CLOSE_WINDOW = 44,
    ATOM_NET_MOVERESIZE_WINDOW = 45,
    ATOM_NET_WM_NAME = 46,
    ATOM_NET_WM_ICON = 47,
    ATOM_NET_WM_WINDOW_TYPE = 48,
    ATOM_NET_WM_WINDOW_TYPE_DESKTOP = 49,
    ATOM_NET_WM_WINDOW_TYPE_DOCK = 50,
    ATOM_NET_WM_WINDOW_TYPE_SPLASH = 51,
    ATOM_NET_WM_WINDOW_TYPE_DIALOG = 52,
    ATOM_NET_WM_WINDOW_TYPE_NORMAL = 53,
    ATOM_NET_CLIENT_LIST = 54,
    ATOM_NET_CLIENT_LIST_STACKING = 55,
    ATOM_NET_WM_STRUT_PARTIAL = 56,
    ATOM_NET_WM_STRUT = 57,
    ATOM_NET_SYSTEM_TRAY_OPCODE = 58,
    ATOM_NET_WM_WINDOW_OPACITY = 59,
    ATOM_MOTIF_WM_HINTS = 60,
    ATOM_JWM_RESTART = 61,
    ATOM_JWM_EXIT = 62,
    ATOM_JWM_RELOAD = 63,
    ATOM_COUNT = 64
} ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
typedef enum __anonenum_AtomType_304 AtomType;
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
enum __anonenum_BackgroundType_307 {
    BACKGROUND_SOLID = 0,
    BACKGROUND_GRADIENT = 1,
    BACKGROUND_COMMAND = 2,
    BACKGROUND_STRETCH = 3,
    BACKGROUND_TILE = 4
} ;
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
typedef enum __anonenum_BackgroundType_307 BackgroundType;
#line 32 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
struct BackgroundNode {
   int desktop ;
   BackgroundType type ;
   char *value ;
   Pixmap pixmap ;
   Window window ;
   struct BackgroundNode *next ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
typedef struct BackgroundNode BackgroundNode;
#line 273 "/usr/include/X11/Xutil.h"
struct _XRegion;
#line 273 "/usr/include/X11/Xutil.h"
typedef struct _XRegion *Region;
#line 13 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.h"
struct TrayComponentType;
#line 14
struct TimeType;
#line 110 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
enum __anonenum_WinLayerType_303 {
    LAYER_BOTTOM = 0,
    LAYER_BELOW = 2,
    LAYER_NORMAL = 4,
    LAYER_ABOVE = 6,
    DEFAULT_TRAY_LAYER = 8,
    LAYER_TOP = 12,
    LAYER_COUNT = 13
} ;
#line 110 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
typedef enum __anonenum_WinLayerType_303 WinLayerType;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
enum __anonenum_LayoutType_305 {
    LAYOUT_HORIZONTAL = 0,
    LAYOUT_VERTICAL = 1
} ;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
typedef enum __anonenum_LayoutType_305 LayoutType;
#line 24
enum __anonenum_TrayAlignmentType_306 {
    TALIGN_FIXED = 0,
    TALIGN_LEFT = 1,
    TALIGN_TOP = 2,
    TALIGN_CENTER = 3,
    TALIGN_RIGHT = 4,
    TALIGN_BOTTOM = 5
} ;
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
typedef enum __anonenum_TrayAlignmentType_306 TrayAlignmentType;
#line 50
struct TrayType;
#line 50 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
struct TrayComponentType {
   struct TrayType *tray ;
   void *object ;
   int x ;
   int y ;
   int screenx ;
   int screeny ;
   int requestedWidth ;
   int requestedHeight ;
   int width ;
   int height ;
   int grabbed ;
   Window window ;
   Pixmap pixmap ;
   void (*Create)(struct TrayComponentType *cp ) ;
   void (*Destroy)(struct TrayComponentType *cp ) ;
   void (*SetSize)(struct TrayComponentType *cp , int width , int height ) ;
   void (*Resize)(struct TrayComponentType *cp ) ;
   void (*ProcessButtonPress)(struct TrayComponentType *cp , int x , int y , int mask ) ;
   void (*ProcessButtonRelease)(struct TrayComponentType *cp , int x , int y , int mask ) ;
   void (*ProcessMotionEvent)(struct TrayComponentType *cp , int x , int y , int mask ) ;
   struct TrayComponentType *next ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
typedef struct TrayComponentType TrayComponentType;
#line 113 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
struct TrayType {
   int x ;
   int y ;
   int requestedWidth ;
   int requestedHeight ;
   int width ;
   int height ;
   int border ;
   WinLayerType layer ;
   LayoutType layout ;
   TrayAlignmentType valign ;
   TrayAlignmentType halign ;
   int autoHide ;
   int hidden ;
   Window window ;
   struct TrayComponentType *components ;
   struct TrayComponentType *componentsTail ;
   struct TrayType *next ;
};
#line 113 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
typedef struct TrayType TrayType;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.h"
enum __anonenum_ColorType_307 {
    COLOR_TITLE_FG = 0,
    COLOR_TITLE_ACTIVE_FG = 1,
    COLOR_TITLE_BG1 = 2,
    COLOR_TITLE_BG2 = 3,
    COLOR_TITLE_ACTIVE_BG1 = 4,
    COLOR_TITLE_ACTIVE_BG2 = 5,
    COLOR_BORDER_LINE = 6,
    COLOR_BORDER_ACTIVE_LINE = 7,
    COLOR_TRAY_BG = 8,
    COLOR_TRAY_FG = 9,
    COLOR_TASK_FG = 10,
    COLOR_TASK_BG1 = 11,
    COLOR_TASK_BG2 = 12,
    COLOR_TASK_ACTIVE_FG = 13,
    COLOR_TASK_ACTIVE_BG1 = 14,
    COLOR_TASK_ACTIVE_BG2 = 15,
    COLOR_PAGER_BG = 16,
    COLOR_PAGER_FG = 17,
    COLOR_PAGER_ACTIVE_BG = 18,
    COLOR_PAGER_ACTIVE_FG = 19,
    COLOR_PAGER_OUTLINE = 20,
    COLOR_PAGER_TEXT = 21,
    COLOR_MENU_BG = 22,
    COLOR_MENU_FG = 23,
    COLOR_MENU_ACTIVE_BG1 = 24,
    COLOR_MENU_ACTIVE_BG2 = 25,
    COLOR_MENU_ACTIVE_FG = 26,
    COLOR_MENU_ACTIVE_OL = 27,
    COLOR_TRAY_UP = 28,
    COLOR_TRAY_DOWN = 29,
    COLOR_TASK_UP = 30,
    COLOR_TASK_DOWN = 31,
    COLOR_TASK_ACTIVE_UP = 32,
    COLOR_TASK_ACTIVE_DOWN = 33,
    COLOR_MENU_UP = 34,
    COLOR_MENU_DOWN = 35,
    COLOR_MENU_ACTIVE_UP = 36,
    COLOR_MENU_ACTIVE_DOWN = 37,
    COLOR_POPUP_BG = 38,
    COLOR_POPUP_FG = 39,
    COLOR_POPUP_OUTLINE = 40,
    COLOR_TRAYBUTTON_BG = 41,
    COLOR_TRAYBUTTON_FG = 42,
    COLOR_CLOCK_BG = 43,
    COLOR_CLOCK_FG = 44,
    COLOR_COUNT = 45
} ;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.h"
typedef enum __anonenum_ColorType_307 ColorType;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.h"
enum __anonenum_FontType_308 {
    FONT_BORDER = 0,
    FONT_MENU = 1,
    FONT_TASK = 2,
    FONT_POPUP = 3,
    FONT_CLOCK = 4,
    FONT_TRAY = 5,
    FONT_TRAYBUTTON = 6,
    FONT_PAGER = 7,
    FONT_COUNT = 8
} ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.h"
typedef enum __anonenum_FontType_308 FontType;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/timing.h"
struct TimeType {
   unsigned long seconds ;
   int ms ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/timing.h"
typedef struct TimeType TimeType;
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
struct ClockType {
   TrayComponentType *cp ;
   char *format ;
   char *zone ;
   char *command ;
   char shortTime[80] ;
   int mousex ;
   int mousey ;
   TimeType mouseTime ;
   int userWidth ;
   struct ClockType *next ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
typedef struct ClockType ClockType;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_53 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_53 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_54 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_54 Depth;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_55 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_55 Screen;
#line 320 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_58 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 320 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_58 XWindowAttributes;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_72 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_72 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_73 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_73 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_74 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_74 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_75 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_75 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_76 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_76 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_77 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_77 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_78 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_78 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_79 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_80 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_81 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_82 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_83 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_84 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_85 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_86 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_87 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_88 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_89 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_90 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_91 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_92 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_93 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_94 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_95 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_96 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_97 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_98 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_100 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_100 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_99 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_101 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_102 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_102 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_103 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_104 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_105 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_105 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 357 "/usr/include/X11/Xutil.h"
typedef int XContext;
#line 130 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
enum __anonenum_ClientProtocolType_306 {
    PROT_NONE = 0,
    PROT_DELETE = 1,
    PROT_TAKE_FOCUS = 2
} ;
#line 130 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
typedef enum __anonenum_ClientProtocolType_306 ClientProtocolType;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
enum __anonenum_FocusModelType_309 {
    FOCUS_SLOPPY = 0,
    FOCUS_CLICK = 1
} ;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
typedef enum __anonenum_FocusModelType_309 FocusModelType;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.h"
struct ScreenType {
   int index ;
   int x ;
   int y ;
   int width ;
   int height ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.h"
typedef struct ScreenType ScreenType;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.h"
struct BoundingBox {
   int x ;
   int y ;
   int width ;
   int height ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.h"
typedef struct BoundingBox BoundingBox;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
struct Strut {
   ClientNode *client ;
   BoundingBox box ;
   struct Strut *prev ;
   struct Strut *next ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
typedef struct Strut Strut;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_49 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_49 fd_set;
#line 411 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowChanges_61 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window sibling ;
   int stack_mode ;
};
#line 411 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowChanges_61 XWindowChanges;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.h"
enum __anonenum_KeyType_309 {
    KEY_NONE = 0,
    KEY_UP = 1,
    KEY_DOWN = 2,
    KEY_RIGHT = 3,
    KEY_LEFT = 4,
    KEY_ESC = 5,
    KEY_ENTER = 6,
    KEY_NEXT = 7,
    KEY_NEXTSTACK = 8,
    KEY_PREV = 9,
    KEY_PREVSTACK = 10,
    KEY_CLOSE = 11,
    KEY_MIN = 12,
    KEY_MAX = 13,
    KEY_SHADE = 14,
    KEY_STICK = 15,
    KEY_MOVE = 16,
    KEY_RESIZE = 17,
    KEY_ROOT = 18,
    KEY_WIN = 19,
    KEY_DESKTOP = 20,
    KEY_RDESKTOP = 21,
    KEY_LDESKTOP = 22,
    KEY_UDESKTOP = 23,
    KEY_DDESKTOP = 24,
    KEY_SHOWDESK = 25,
    KEY_SHOWTRAY = 26,
    KEY_EXEC = 27,
    KEY_RESTART = 28,
    KEY_EXIT = 29,
    KEY_FULLSCREEN = 30
} ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.h"
typedef enum __anonenum_KeyType_309 KeyType;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_136 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_136 XClassHint;
#line 21 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.c"
struct SwallowNode {
   TrayComponentType *cp ;
   char *name ;
   char *command ;
   int border ;
   int userWidth ;
   int userHeight ;
   struct SwallowNode *next ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.c"
typedef struct SwallowNode SwallowNode;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.h"
enum __anonenum_TokenType_302 {
    TOK_INVALID = 0,
    TOK_ACTIVE = 1,
    TOK_ACTIVEBACKGROUND = 2,
    TOK_ACTIVEFOREGROUND = 3,
    TOK_BACKGROUND = 4,
    TOK_BORDER = 5,
    TOK_BUTTONCLOSE = 6,
    TOK_BUTTONMAX = 7,
    TOK_BUTTONMAXACTIVE = 8,
    TOK_BUTTONMIN = 9,
    TOK_CLASS = 10,
    TOK_CLOCK = 11,
    TOK_CLOCKSTYLE = 12,
    TOK_CLOSE = 13,
    TOK_DESKTOPS = 14,
    TOK_DESKTOP = 15,
    TOK_DOCK = 16,
    TOK_DOUBLECLICKSPEED = 17,
    TOK_DOUBLECLICKDELTA = 18,
    TOK_EXIT = 19,
    TOK_FOCUSMODEL = 20,
    TOK_FONT = 21,
    TOK_FOREGROUND = 22,
    TOK_GROUP = 23,
    TOK_HEIGHT = 24,
    TOK_ICONPATH = 25,
    TOK_INACTIVE = 26,
    TOK_INCLUDE = 27,
    TOK_JWM = 28,
    TOK_KEY = 29,
    TOK_KILL = 30,
    TOK_LAYER = 31,
    TOK_MAXIMIZE = 32,
    TOK_MENU = 33,
    TOK_MENUSTYLE = 34,
    TOK_MINIMIZE = 35,
    TOK_MOVE = 36,
    TOK_MOVEMODE = 37,
    TOK_NAME = 38,
    TOK_OPACITY = 39,
    TOK_OPTION = 40,
    TOK_OUTLINE = 41,
    TOK_PAGER = 42,
    TOK_PAGERSTYLE = 43,
    TOK_POPUP = 44,
    TOK_POPUPSTYLE = 45,
    TOK_PROGRAM = 46,
    TOK_RESIZE = 47,
    TOK_RESIZEMODE = 48,
    TOK_RESTART = 49,
    TOK_RESTARTCOMMAND = 50,
    TOK_ROOTMENU = 51,
    TOK_SENDTO = 52,
    TOK_SEPARATOR = 53,
    TOK_SHADE = 54,
    TOK_SHUTDOWNCOMMAND = 55,
    TOK_SNAPMODE = 56,
    TOK_SPACER = 57,
    TOK_STARTUPCOMMAND = 58,
    TOK_STICK = 59,
    TOK_SWALLOW = 60,
    TOK_TASKLISTSTYLE = 61,
    TOK_TASKLIST = 62,
    TOK_TEXT = 63,
    TOK_TITLE = 64,
    TOK_TRAY = 65,
    TOK_TRAYBUTTON = 66,
    TOK_TRAYBUTTONSTYLE = 67,
    TOK_TRAYSTYLE = 68,
    TOK_WIDTH = 69,
    TOK_WINDOWSTYLE = 70
} ;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.h"
typedef enum __anonenum_TokenType_302 TokenType;
#line 95 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.h"
struct AttributeNode {
   char *name ;
   char *value ;
   struct AttributeNode *next ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.h"
typedef struct AttributeNode AttributeNode;
#line 104 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.h"
struct TokenNode {
   TokenType type ;
   char *invalidName ;
   char *value ;
   char *fileName ;
   int line ;
   struct AttributeNode *attributes ;
   struct TokenNode *parent ;
   struct TokenNode *subnodeHead ;
   struct TokenNode *subnodeTail ;
   struct TokenNode *next ;
};
#line 104 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.h"
typedef struct TokenNode TokenNode;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
enum __anonenum_MenuActionType_303 {
    MA_NONE = 0,
    MA_EXECUTE = 1,
    MA_DESKTOP = 2,
    MA_SENDTO = 3,
    MA_LAYER = 4,
    MA_STICK = 5,
    MA_MAXIMIZE = 6,
    MA_MAXIMIZE_H = 7,
    MA_MAXIMIZE_V = 8,
    MA_MINIMIZE = 9,
    MA_RESTORE = 10,
    MA_SHADE = 11,
    MA_MOVE = 12,
    MA_RESIZE = 13,
    MA_KILL = 14,
    MA_CLOSE = 15,
    MA_EXIT = 16,
    MA_RESTART = 17
} ;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
typedef enum __anonenum_MenuActionType_303 MenuActionType;
#line 36 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
union __anonunion_data_304 {
   int i ;
   char *str ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
struct MenuAction {
   MenuActionType type ;
   union __anonunion_data_304 data ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
typedef struct MenuAction MenuAction;
#line 49
enum __anonenum_MenuItemType_305 {
    MENU_ITEM_NORMAL = 0,
    MENU_ITEM_SUBMENU = 1,
    MENU_ITEM_SEPARATOR = 2
} ;
#line 49 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
typedef enum __anonenum_MenuItemType_305 MenuItemType;
#line 56
struct Menu;
#line 56 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
struct MenuItem {
   MenuItemType type ;
   char *name ;
   MenuAction action ;
   char *iconName ;
   struct Menu *submenu ;
   struct MenuItem *next ;
   struct IconNode *icon ;
};
#line 56 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
typedef struct MenuItem MenuItem;
#line 72 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
struct Menu {
   struct MenuItem *items ;
   char *label ;
   int itemHeight ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int currentIndex ;
   int lastIndex ;
   unsigned int itemCount ;
   int parentOffset ;
   int textOffset ;
   int *offsets ;
   struct Menu *parent ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
typedef struct Menu Menu;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.h"
enum __anonenum_BorderPixmapType_306 {
    BP_CLOSE = 0,
    BP_MINIMIZE = 1,
    BP_MAXIMIZE = 2,
    BP_MAXIMIZE_ACTIVE = 3,
    BP_COUNT = 4
} ;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.h"
typedef enum __anonenum_BorderPixmapType_306 BorderPixmapType;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.h"
struct GroupType;
#line 17
enum __anonenum_OptionType_315 {
    OPTION_INVALID = 0,
    OPTION_STICKY = 1,
    OPTION_LAYER = 2,
    OPTION_DESKTOP = 3,
    OPTION_ICON = 4,
    OPTION_NOLIST = 5,
    OPTION_BORDER = 6,
    OPTION_NOBORDER = 7,
    OPTION_TITLE = 8,
    OPTION_NOTITLE = 9,
    OPTION_PIGNORE = 10,
    OPTION_MAXIMIZED = 11,
    OPTION_MINIMIZED = 12,
    OPTION_SHADED = 13,
    OPTION_OPACITY = 14,
    OPTION_MAX_H = 15,
    OPTION_MAX_V = 16,
    OPTION_NOFOCUS = 17
} ;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.h"
typedef enum __anonenum_OptionType_315 OptionType;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.h"
enum __anonenum_SnapModeType_316 {
    SNAP_NONE = 0,
    SNAP_SCREEN = 1,
    SNAP_BORDER = 2
} ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.h"
typedef enum __anonenum_SnapModeType_316 SnapModeType;
#line 23
enum __anonenum_MoveModeType_317 {
    MOVE_OPAQUE = 0,
    MOVE_OUTLINE = 1
} ;
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.h"
typedef enum __anonenum_MoveModeType_317 MoveModeType;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.h"
enum __anonenum_ResizeModeType_318 {
    RESIZE_OPAQUE = 0,
    RESIZE_OUTLINE = 1
} ;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.h"
typedef enum __anonenum_ResizeModeType_318 ResizeModeType;
#line 44 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
struct KeyMapType {
   char const   *name ;
   KeyType key ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
typedef struct KeyMapType KeyMapType;
#line 83 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
struct OptionMapType {
   char const   *name ;
   OptionType option ;
};
#line 83 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
typedef struct OptionMapType OptionMapType;
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_131 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_130 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_131 min_aspect ;
   struct __anonstruct_min_aspect_131 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_130 XSizeHints;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/button.h"
enum __anonenum_ButtonType_312 {
    BUTTON_LABEL = 0,
    BUTTON_MENU = 1,
    BUTTON_MENU_ACTIVE = 2,
    BUTTON_TASK = 3,
    BUTTON_TASK_ACTIVE = 4
} ;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/button.h"
typedef enum __anonenum_ButtonType_312 ButtonType;
#line 27
enum __anonenum_AlignmentType_313 {
    ALIGN_LEFT = 0,
    ALIGN_CENTER = 1
} ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/button.h"
typedef enum __anonenum_AlignmentType_313 AlignmentType;
#line 33 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/button.h"
struct __anonstruct_ButtonNode_314 {
   ButtonType type ;
   Drawable drawable ;
   GC gc ;
   FontType font ;
   AlignmentType alignment ;
   int x ;
   int y ;
   int width ;
   int height ;
   struct IconNode *icon ;
   char const   *text ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/button.h"
typedef struct __anonstruct_ButtonNode_314 ButtonNode;
#line 22 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
enum __anonenum_DialogButtonState_315 {
    DBS_NORMAL = 0,
    DBS_OK = 1,
    DBS_CANCEL = 2
} ;
#line 22 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
typedef enum __anonenum_DialogButtonState_315 DialogButtonState;
#line 28 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
struct DialogType {
   int x ;
   int y ;
   int width ;
   int height ;
   int lineHeight ;
   int okx ;
   int cancelx ;
   int buttony ;
   int buttonWidth ;
   int buttonHeight ;
   DialogButtonState buttonState ;
   int lineCount ;
   char **message ;
   ClientNode *node ;
   void (*action)(ClientNode * ) ;
   ClientNode *client ;
   struct DialogType *prev ;
   struct DialogType *next ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
typedef struct DialogType DialogType;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_303 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_303 regmatch_t;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.h"
typedef struct ScaledIconNode ScaledIconNode;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_52 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_52 XGCValues;
#line 372 "/usr/include/X11/Xlib.h"
struct funcs {
   struct _XImage *(*create_image)(struct _XDisplay * , Visual * , unsigned int  ,
                                   int  , int  , char * , unsigned int  , unsigned int  ,
                                   int  , int  ) ;
   int (*destroy_image)(struct _XImage * ) ;
   unsigned long (*get_pixel)(struct _XImage * , int  , int  ) ;
   int (*put_pixel)(struct _XImage * , int  , int  , unsigned long  ) ;
   struct _XImage *(*sub_image)(struct _XImage * , int  , int  , unsigned int  , unsigned int  ) ;
   int (*add_pixel)(struct _XImage * , long  ) ;
};
#line 372 "/usr/include/X11/Xlib.h"
struct _XImage {
   int width ;
   int height ;
   int xoffset ;
   int format ;
   char *data ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_bit_order ;
   int bitmap_pad ;
   int depth ;
   int bytes_per_line ;
   int bits_per_pixel ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   XPointer obdata ;
   struct funcs f ;
};
#line 372 "/usr/include/X11/Xlib.h"
typedef struct _XImage XImage;
#line 183 "/usr/include/X11/Xutil.h"
struct __anonstruct_XIconSize_135 {
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
};
#line 183 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XIconSize_135 XIconSize;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/image.h"
typedef struct ImageNode ImageNode;
#line 30 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
struct IconPathNode {
   char *path ;
   struct IconPathNode *next ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
typedef struct IconPathNode IconPathNode;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long __tm_gmtoff ;
   char const   *__tm_zone ;
};
#line 63 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef void * __restrict  __timezone_ptr_t;
#line 434 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSegment_63 {
   short x1 ;
   short y1 ;
   short x2 ;
   short y2 ;
};
#line 434 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSegment_63 XSegment;
#line 442 "/usr/include/X11/Xlib.h"
struct __anonstruct_XRectangle_65 {
   short x ;
   short y ;
   unsigned short width ;
   unsigned short height ;
};
#line 442 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XRectangle_65 XRectangle;
#line 447 "/usr/include/X11/Xlib.h"
struct __anonstruct_XArc_66 {
   short x ;
   short y ;
   unsigned short width ;
   unsigned short height ;
   short angle1 ;
   short angle2 ;
};
#line 447 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XArc_66 XArc;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
typedef unsigned char BorderPixmapDataType[32];
#line 28 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
struct __anonstruct_RectangleType_315 {
   int valid ;
   int left ;
   int right ;
   int top ;
   int bottom ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
typedef struct __anonstruct_RectangleType_315 RectangleType;
#line 25 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
struct DockNode {
   Window window ;
   int needs_reparent ;
   struct DockNode *next ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
typedef struct DockNode DockNode;
#line 35 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
struct DockType {
   TrayComponentType *cp ;
   Window window ;
   int itemSize ;
   DockNode *nodes ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
typedef struct DockType DockType;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_56 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_56 ScreenFormat;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_71 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_71 *_XPrivDisplay;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
struct CommandNode {
   char *command ;
   struct CommandNode *next ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
typedef struct CommandNode CommandNode;
#line 19 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
enum __anonenum_StatusWindowType_312 {
    SW_INVALID = 0,
    SW_OFF = 1,
    SW_SCREEN = 2,
    SW_WINDOW = 3,
    SW_CORNER = 4
} ;
#line 19 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
typedef enum __anonenum_StatusWindowType_312 StatusWindowType;
#line 26 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
struct PagerType {
   TrayComponentType *cp ;
   int labeled ;
   int deskWidth ;
   int deskHeight ;
   int scalex ;
   int scaley ;
   Pixmap buffer ;
   TimeType mouseTime ;
   int mousex ;
   int mousey ;
   struct PagerType *next ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
typedef struct PagerType PagerType;
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
struct PopupType {
   int isActive ;
   int x ;
   int y ;
   int mx ;
   int my ;
   int width ;
   int height ;
   char *text ;
   Window window ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
typedef struct PopupType PopupType;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
struct __anonstruct_DefaultColorNode_304 {
   ColorType type ;
   char const   *value ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
typedef struct __anonstruct_DefaultColorNode_304 DefaultColorNode;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_21 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_21 __sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_24 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_25 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_27 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_28 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_29 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_30 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_23 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_24 _kill ;
   struct __anonstruct__timer_25 _timer ;
   struct __anonstruct__rt_26 _rt ;
   struct __anonstruct__sigchld_27 _sigchld ;
   struct __anonstruct__sigfault_28 _sigfault ;
   struct __anonstruct__sigpoll_29 _sigpoll ;
   struct __anonstruct__sigsys_30 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_22 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_23 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_22 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_42 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_42 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 84 "/usr/include/X11/Xresource.h"
typedef int XrmQuark;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
enum __anonenum_InsertModeType_320 {
    INSERT_LEFT = 0,
    INSERT_RIGHT = 1
} ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
typedef enum __anonenum_InsertModeType_320 InsertModeType;
#line 32 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
struct TaskBarType {
   TrayComponentType *cp ;
   int itemHeight ;
   LayoutType layout ;
   Pixmap buffer ;
   TimeType mouseTime ;
   int mousex ;
   int mousey ;
   unsigned int maxItemWidth ;
   struct TaskBarType *next ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
typedef struct TaskBarType TaskBarType;
#line 50 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
struct Node {
   ClientNode *client ;
   int y ;
   struct Node *next ;
   struct Node *prev ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
typedef struct Node Node;
#line 21 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
enum __anonenum_MatchType_311 {
    MATCH_NAME = 0,
    MATCH_CLASS = 1
} ;
#line 21 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
typedef enum __anonenum_MatchType_311 MatchType;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
struct PatternListType {
   char *pattern ;
   MatchType match ;
   struct PatternListType *next ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
typedef struct PatternListType PatternListType;
#line 34 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
struct OptionListType {
   OptionType option ;
   char *value ;
   struct OptionListType *next ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
typedef struct OptionListType OptionListType;
#line 41 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
struct GroupType {
   PatternListType *patterns ;
   OptionListType *options ;
   struct GroupType *next ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
typedef struct GroupType GroupType;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
enum __anonenum_MenuSelectionType_319 {
    MENU_NOSELECTION = 0,
    MENU_LEAVE = 1,
    MENU_SUBSELECT = 2
} ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
typedef enum __anonenum_MenuSelectionType_319 MenuSelectionType;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 108 "/usr/include/X11/X.h"
typedef unsigned char KeyCode;
#line 487 "/usr/include/X11/Xlib.h"
struct __anonstruct_XModifierKeymap_70 {
   int max_keypermod ;
   KeyCode *modifiermap ;
};
#line 487 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XModifierKeymap_70 XModifierKeymap;
#line 32 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
struct ModifierNode {
   char name ;
   unsigned int mask ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
typedef struct ModifierNode ModifierNode;
#line 51 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
struct KeyNode {
   int key ;
   unsigned int state ;
   KeySym symbol ;
   char *command ;
   struct KeyNode *next ;
   KeyCode code ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
typedef struct KeyNode KeyNode;
#line 65 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
struct LockNode {
   KeySym symbol ;
   unsigned int mask ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
typedef struct LockNode LockNode;
#line 1029 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_106 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1029 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_106 XCharStruct;
#line 1042 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_107 {
   Atom name ;
   unsigned long card32 ;
};
#line 1042 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_107 XFontProp;
#line 1047 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_108 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1047 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_108 XFontStruct;
#line 31 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
struct TrayButtonType {
   TrayComponentType *cp ;
   char *label ;
   char *popup ;
   char *iconName ;
   IconNode *icon ;
   char *action ;
   int mousex ;
   int mousey ;
   TimeType mouseTime ;
   struct TrayButtonType *next ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
typedef struct TrayButtonType TrayButtonType;
#line 105 "/usr/include/X11/X.h"
typedef XID GContext;
#line 172 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExtCodes_14 {
   int extension ;
   int major_opcode ;
   int first_event ;
   int first_error ;
};
#line 172 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExtCodes_14 XExtCodes;
#line 98 "/usr/include/X11/Xmd.h"
typedef int INT32;
#line 102 "/usr/include/X11/Xmd.h"
typedef short INT16;
#line 104 "/usr/include/X11/Xmd.h"
typedef signed char INT8;
#line 108 "/usr/include/X11/Xmd.h"
typedef unsigned int CARD32;
#line 113 "/usr/include/X11/Xmd.h"
typedef unsigned short CARD16;
#line 114 "/usr/include/X11/Xmd.h"
typedef unsigned char CARD8;
#line 119 "/usr/include/X11/Xmd.h"
typedef CARD8 BYTE;
#line 120 "/usr/include/X11/Xmd.h"
typedef CARD8 BOOL;
#line 259 "/usr/include/X11/Xproto.h"
typedef CARD16 KeyButMask;
#line 425 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGenericReply_108 {
   BYTE type ;
   BYTE data1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 data00 ;
   CARD32 data01 ;
   CARD32 data02 ;
   CARD32 data03 ;
   CARD32 data04 ;
   CARD32 data05 ;
};
#line 425 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGenericReply_108 xGenericReply;
#line 466 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetGeometryReply_110 {
   BYTE type ;
   CARD8 depth ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 root ;
   INT16 x ;
   INT16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 borderWidth ;
   CARD16 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
};
#line 466 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetGeometryReply_110 xGetGeometryReply;
#line 480 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryTreeReply_111 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 root ;
   CARD32 parent ;
   CARD16 nChildren ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 480 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryTreeReply_111 xQueryTreeReply;
#line 493 "/usr/include/X11/Xproto.h"
struct __anonstruct_xInternAtomReply_112 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 atom ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 493 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xInternAtomReply_112 xInternAtomReply;
#line 506 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetAtomNameReply_113 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nameLength ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 506 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetAtomNameReply_113 xGetAtomNameReply;
#line 520 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetPropertyReply_114 {
   BYTE type ;
   CARD8 format ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 propertyType ;
   CARD32 bytesAfter ;
   CARD32 nItems ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
};
#line 520 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetPropertyReply_114 xGetPropertyReply;
#line 533 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListPropertiesReply_115 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nProperties ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 533 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListPropertiesReply_115 xListPropertiesReply;
#line 547 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetSelectionOwnerReply_116 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 owner ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 547 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetSelectionOwnerReply_116 xGetSelectionOwnerReply;
#line 560 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGrabPointerReply_117 {
   BYTE type ;
   BYTE status ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 560 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGrabPointerReply_117 xGrabPointerReply;
#line 573 "/usr/include/X11/Xproto.h"
typedef xGrabPointerReply xGrabKeyboardReply;
#line 575 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryPointerReply_118 {
   BYTE type ;
   BOOL sameScreen ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 root ;
   CARD32 child ;
   INT16 rootX ;
   INT16 rootY ;
   INT16 winX ;
   INT16 winY ;
   CARD16 mask ;
   CARD16 pad1 ;
   CARD32 pad ;
};
#line 575 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryPointerReply_118 xQueryPointerReply;
#line 587 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetMotionEventsReply_119 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 nEvents ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 587 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetMotionEventsReply_119 xGetMotionEventsReply;
#line 600 "/usr/include/X11/Xproto.h"
struct __anonstruct_xTranslateCoordsReply_120 {
   BYTE type ;
   BOOL sameScreen ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 child ;
   INT16 dstX ;
   INT16 dstY ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 600 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xTranslateCoordsReply_120 xTranslateCoordsReply;
#line 613 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetInputFocusReply_121 {
   BYTE type ;
   CARD8 revertTo ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 focus ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 613 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetInputFocusReply_121 xGetInputFocusReply;
#line 654 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryTextExtentsReply_123 {
   BYTE type ;
   CARD8 drawDirection ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   INT16 fontAscent ;
   INT16 fontDescent ;
   INT16 overallAscent ;
   INT16 overallDescent ;
   INT32 overallWidth ;
   INT32 overallLeft ;
   INT32 overallRight ;
   CARD32 pad ;
};
#line 654 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryTextExtentsReply_123 xQueryTextExtentsReply;
#line 665 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListFontsReply_124 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nFonts ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 665 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListFontsReply_124 xListFontsReply;
#line 699 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetFontPathReply_126 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nPaths ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 699 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetFontPathReply_126 xGetFontPathReply;
#line 713 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetImageReply_127 {
   BYTE type ;
   CARD8 depth ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 visual ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 713 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetImageReply_127 xGetImageReply;
#line 726 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListInstalledColormapsReply_128 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nColormaps ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 726 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListInstalledColormapsReply_128 xListInstalledColormapsReply;
#line 740 "/usr/include/X11/Xproto.h"
struct __anonstruct_xAllocColorReply_129 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 red ;
   CARD16 green ;
   CARD16 blue ;
   CARD16 pad2 ;
   CARD32 pixel ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 740 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xAllocColorReply_129 xAllocColorReply;
#line 753 "/usr/include/X11/Xproto.h"
struct __anonstruct_xAllocNamedColorReply_130 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pixel ;
   CARD16 exactRed ;
   CARD16 exactGreen ;
   CARD16 exactBlue ;
   CARD16 screenRed ;
   CARD16 screenGreen ;
   CARD16 screenBlue ;
   CARD32 pad2 ;
   CARD32 pad3 ;
};
#line 753 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xAllocNamedColorReply_130 xAllocNamedColorReply;
#line 765 "/usr/include/X11/Xproto.h"
struct __anonstruct_xAllocColorCellsReply_131 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nPixels ;
   CARD16 nMasks ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 765 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xAllocColorCellsReply_131 xAllocColorCellsReply;
#line 778 "/usr/include/X11/Xproto.h"
struct __anonstruct_xAllocColorPlanesReply_132 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nPixels ;
   CARD16 pad2 ;
   CARD32 redMask ;
   CARD32 greenMask ;
   CARD32 blueMask ;
   CARD32 pad3 ;
   CARD32 pad4 ;
};
#line 778 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xAllocColorPlanesReply_132 xAllocColorPlanesReply;
#line 790 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryColorsReply_133 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nColors ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 790 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryColorsReply_133 xQueryColorsReply;
#line 804 "/usr/include/X11/Xproto.h"
struct __anonstruct_xLookupColorReply_134 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 exactRed ;
   CARD16 exactGreen ;
   CARD16 exactBlue ;
   CARD16 screenRed ;
   CARD16 screenGreen ;
   CARD16 screenBlue ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 804 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xLookupColorReply_134 xLookupColorReply;
#line 816 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryBestSizeReply_135 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 width ;
   CARD16 height ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 816 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryBestSizeReply_135 xQueryBestSizeReply;
#line 829 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryExtensionReply_136 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   BOOL present ;
   CARD8 major_opcode ;
   CARD8 first_event ;
   CARD8 first_error ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 829 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryExtensionReply_136 xQueryExtensionReply;
#line 845 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListExtensionsReply_137 {
   BYTE type ;
   CARD8 nExtensions ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 845 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListExtensionsReply_137 xListExtensionsReply;
#line 859 "/usr/include/X11/Xproto.h"
struct __anonstruct_xSetMappingReply_138 {
   BYTE type ;
   CARD8 success ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 859 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xSetMappingReply_138 xSetMappingReply;
#line 871 "/usr/include/X11/Xproto.h"
typedef xSetMappingReply xSetPointerMappingReply;
#line 872 "/usr/include/X11/Xproto.h"
typedef xSetMappingReply xSetModifierMappingReply;
#line 874 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetPointerMappingReply_139 {
   BYTE type ;
   CARD8 nElts ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 874 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetPointerMappingReply_139 xGetPointerMappingReply;
#line 887 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetKeyboardMappingReply_140 {
   BYTE type ;
   CARD8 keySymsPerKeyCode ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 887 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetKeyboardMappingReply_140 xGetKeyboardMappingReply;
#line 900 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetModifierMappingReply_141 {
   BYTE type ;
   CARD8 numKeyPerModifier ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 900 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetModifierMappingReply_141 xGetModifierMappingReply;
#line 925 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetPointerControlReply_143 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 accelNumerator ;
   CARD16 accelDenominator ;
   CARD16 threshold ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 925 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetPointerControlReply_143 xGetPointerControlReply;
#line 939 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetScreenSaverReply_144 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 timeout ;
   CARD16 interval ;
   BOOL preferBlanking ;
   BOOL allowExposures ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 939 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetScreenSaverReply_144 xGetScreenSaverReply;
#line 954 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListHostsReply_145 {
   BYTE type ;
   BOOL enabled ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nHosts ;
   CARD16 pad1 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 954 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListHostsReply_145 xListHostsReply;
#line 976 "/usr/include/X11/Xproto.h"
struct __anonstruct_xError_146 {
   BYTE type ;
   BYTE errorCode ;
   CARD16 sequenceNumber ;
   CARD32 resourceID ;
   CARD16 minorCode ;
   CARD8 majorCode ;
   BYTE pad1 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 976 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xError_146 xError;
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_u_148 {
   BYTE type ;
   BYTE detail ;
   CARD16 sequenceNumber ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_keyButtonPointer_149 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 root ;
   CARD32 event ;
   CARD32 child ;
   INT16 rootX ;
   INT16 rootY ;
   INT16 eventX ;
   INT16 eventY ;
   KeyButMask state ;
   BOOL sameScreen ;
   BYTE pad1 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_enterLeave_150 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 root ;
   CARD32 event ;
   CARD32 child ;
   INT16 rootX ;
   INT16 rootY ;
   INT16 eventX ;
   INT16 eventY ;
   KeyButMask state ;
   BYTE mode ;
   BYTE flags ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_focus_151 {
   CARD32 pad00 ;
   CARD32 window ;
   BYTE mode ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_expose_152 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD16 x ;
   CARD16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 count ;
   CARD16 pad2 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_graphicsExposure_153 {
   CARD32 pad00 ;
   CARD32 drawable ;
   CARD16 x ;
   CARD16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 minorEvent ;
   CARD16 count ;
   BYTE majorEvent ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_noExposure_154 {
   CARD32 pad00 ;
   CARD32 drawable ;
   CARD16 minorEvent ;
   BYTE majorEvent ;
   BYTE bpad ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_visibility_155 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD8 state ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_createNotify_156 {
   CARD32 pad00 ;
   CARD32 parent ;
   CARD32 window ;
   INT16 x ;
   INT16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 borderWidth ;
   BOOL override ;
   BYTE bpad ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_destroyNotify_157 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_unmapNotify_158 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   BOOL fromConfigure ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_mapNotify_159 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   BOOL override ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_mapRequest_160 {
   CARD32 pad00 ;
   CARD32 parent ;
   CARD32 window ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_reparent_161 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   CARD32 parent ;
   INT16 x ;
   INT16 y ;
   BOOL override ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_configureNotify_162 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   CARD32 aboveSibling ;
   INT16 x ;
   INT16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 borderWidth ;
   BOOL override ;
   BYTE bpad ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_configureRequest_163 {
   CARD32 pad00 ;
   CARD32 parent ;
   CARD32 window ;
   CARD32 sibling ;
   INT16 x ;
   INT16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 borderWidth ;
   CARD16 valueMask ;
   CARD32 pad1 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_gravity_164 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   INT16 x ;
   INT16 y ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_resizeRequest_165 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD16 width ;
   CARD16 height ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_circulate_166 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   CARD32 parent ;
   BYTE place ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_property_167 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD32 atom ;
   CARD32 time ;
   BYTE state ;
   BYTE pad1 ;
   CARD16 pad2 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_selectionClear_168 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 window ;
   CARD32 atom ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_selectionRequest_169 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 owner ;
   CARD32 requestor ;
   CARD32 selection ;
   CARD32 target ;
   CARD32 property ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_selectionNotify_170 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 requestor ;
   CARD32 selection ;
   CARD32 target ;
   CARD32 property ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_colormap_171 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD32 colormap ;
   BOOL new ;
   BYTE state ;
   BYTE pad1 ;
   BYTE pad2 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_mappingNotify_172 {
   CARD32 pad00 ;
   CARD8 request ;
   CARD8 firstKeyCode ;
   CARD8 count ;
   BYTE pad1 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_l_175 {
   CARD32 type ;
   INT32 longs0 ;
   INT32 longs1 ;
   INT32 longs2 ;
   INT32 longs3 ;
   INT32 longs4 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_s_176 {
   CARD32 type ;
   INT16 shorts0 ;
   INT16 shorts1 ;
   INT16 shorts2 ;
   INT16 shorts3 ;
   INT16 shorts4 ;
   INT16 shorts5 ;
   INT16 shorts6 ;
   INT16 shorts7 ;
   INT16 shorts8 ;
   INT16 shorts9 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_b_177 {
   CARD32 type ;
   INT8 bytes[20] ;
};
#line 996 "/usr/include/X11/Xproto.h"
union __anonunion_u_174 {
   struct __anonstruct_l_175 l ;
   struct __anonstruct_s_176 s ;
   struct __anonstruct_b_177 b ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_clientMessage_173 {
   CARD32 pad00 ;
   CARD32 window ;
   union __anonunion_u_174 u ;
};
#line 996 "/usr/include/X11/Xproto.h"
union __anonunion_u_147 {
   struct __anonstruct_u_148 u ;
   struct __anonstruct_keyButtonPointer_149 keyButtonPointer ;
   struct __anonstruct_enterLeave_150 enterLeave ;
   struct __anonstruct_focus_151 focus ;
   struct __anonstruct_expose_152 expose ;
   struct __anonstruct_graphicsExposure_153 graphicsExposure ;
   struct __anonstruct_noExposure_154 noExposure ;
   struct __anonstruct_visibility_155 visibility ;
   struct __anonstruct_createNotify_156 createNotify ;
   struct __anonstruct_destroyNotify_157 destroyNotify ;
   struct __anonstruct_unmapNotify_158 unmapNotify ;
   struct __anonstruct_mapNotify_159 mapNotify ;
   struct __anonstruct_mapRequest_160 mapRequest ;
   struct __anonstruct_reparent_161 reparent ;
   struct __anonstruct_configureNotify_162 configureNotify ;
   struct __anonstruct_configureRequest_163 configureRequest ;
   struct __anonstruct_gravity_164 gravity ;
   struct __anonstruct_resizeRequest_165 resizeRequest ;
   struct __anonstruct_circulate_166 circulate ;
   struct __anonstruct_property_167 property ;
   struct __anonstruct_selectionClear_168 selectionClear ;
   struct __anonstruct_selectionRequest_169 selectionRequest ;
   struct __anonstruct_selectionNotify_170 selectionNotify ;
   struct __anonstruct_colormap_171 colormap ;
   struct __anonstruct_mappingNotify_172 mappingNotify ;
   struct __anonstruct_clientMessage_173 clientMessage ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct _xEvent {
   union __anonunion_u_147 u ;
};
#line 996 "/usr/include/X11/Xproto.h"
typedef struct _xEvent xEvent;
#line 1264 "/usr/include/X11/Xproto.h"
union __anonunion_xReply_180 {
   xGenericReply generic ;
   xGetGeometryReply geom ;
   xQueryTreeReply tree ;
   xInternAtomReply atom ;
   xGetAtomNameReply atomName ;
   xGetPropertyReply property ;
   xListPropertiesReply listProperties ;
   xGetSelectionOwnerReply selection ;
   xGrabPointerReply grabPointer ;
   xGrabKeyboardReply grabKeyboard ;
   xQueryPointerReply pointer ;
   xGetMotionEventsReply motionEvents ;
   xTranslateCoordsReply coords ;
   xGetInputFocusReply inputFocus ;
   xQueryTextExtentsReply textExtents ;
   xListFontsReply fonts ;
   xGetFontPathReply fontPath ;
   xGetImageReply image ;
   xListInstalledColormapsReply colormaps ;
   xAllocColorReply allocColor ;
   xAllocNamedColorReply allocNamedColor ;
   xAllocColorCellsReply colorCells ;
   xAllocColorPlanesReply colorPlanes ;
   xQueryColorsReply colors ;
   xLookupColorReply lookupColor ;
   xQueryBestSizeReply bestSize ;
   xQueryExtensionReply extension ;
   xListExtensionsReply extensions ;
   xSetModifierMappingReply setModifierMapping ;
   xGetModifierMappingReply getModifierMapping ;
   xSetPointerMappingReply setPointerMapping ;
   xGetKeyboardMappingReply getKeyboardMapping ;
   xGetPointerMappingReply getPointerMapping ;
   xGetPointerControlReply pointerControl ;
   xGetScreenSaverReply screenSaver ;
   xListHostsReply hosts ;
   xError error ;
   xEvent event ;
};
#line 1264 "/usr/include/X11/Xproto.h"
typedef union __anonunion_xReply_180 xReply;
#line 65 "/usr/include/X11/Xlibint.h"
struct _XGC {
   XExtData *ext_data ;
   GContext gid ;
   int rects ;
   int dashes ;
   unsigned long dirty ;
   XGCValues values ;
};
#line 75
struct _XFreeFuncs;
#line 75
struct _XSQEvent;
#line 75
struct _XExten;
#line 75
struct _XLockInfo;
#line 75
struct _XInternalAsync;
#line 75
struct _XLockPtrs;
#line 75
struct _XKeytrans;
#line 75
struct _XDisplayAtoms;
#line 75
struct _XContextDB;
#line 75 "/usr/include/X11/Xlibint.h"
struct __anonstruct_cms_253 {
   XPointer defaultCCCs ;
   XPointer clientCmaps ;
   XPointer perVisualIntensityMaps ;
};
#line 75
struct _XIMFilter;
#line 75
struct _XConnectionInfo;
#line 75
struct _XConnWatchInfo;
#line 75
struct _XkbInfoRec;
#line 75
struct _XtransConnInfo;
#line 75
struct _X11XCBPrivate;
#line 75 "/usr/include/X11/Xlibint.h"
struct _XDisplay {
   XExtData *ext_data ;
   struct _XFreeFuncs *free_funcs ;
   int fd ;
   int conn_checker ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID resource_base ;
   XID resource_mask ;
   XID resource_id ;
   int resource_shift ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int vnumber ;
   int release ;
   struct _XSQEvent *head ;
   struct _XSQEvent *tail ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   char *last_req ;
   char *buffer ;
   char *bufptr ;
   char *bufmax ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*synchandler)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long volatile   flags ;
   int min_keycode ;
   int max_keycode ;
   KeySym *keysyms ;
   XModifierKeymap *modifiermap ;
   int keysyms_per_keycode ;
   char *xdefaults ;
   char *scratch_buffer ;
   unsigned long scratch_length ;
   int ext_number ;
   struct _XExten *ext_procs ;
   int (*event_vec[128])(Display * , XEvent * , xEvent * ) ;
   int (*wire_vec[128])(Display * , XEvent * , xEvent * ) ;
   KeySym lock_meaning ;
   struct _XLockInfo *lock ;
   struct _XInternalAsync *async_handlers ;
   unsigned long bigreq_size ;
   struct _XLockPtrs *lock_fns ;
   void (*idlist_alloc)(Display * , XID * , int  ) ;
   struct _XKeytrans *key_bindings ;
   Font cursor_font ;
   struct _XDisplayAtoms *atoms ;
   unsigned int mode_switch ;
   unsigned int num_lock ;
   struct _XContextDB *context_db ;
   int (**error_vec)(Display * , XErrorEvent * , xError * ) ;
   struct __anonstruct_cms_253 cms ;
   struct _XIMFilter *im_filters ;
   struct _XSQEvent *qfree ;
   unsigned long next_event_serial_num ;
   struct _XExten *flushes ;
   struct _XConnectionInfo *im_fd_info ;
   int im_fd_length ;
   struct _XConnWatchInfo *conn_watchers ;
   int watcher_count ;
   XPointer filedes ;
   int (*savedsynchandler)(Display * ) ;
   XID resource_max ;
   int xcmisc_opcode ;
   struct _XkbInfoRec *xkb_info ;
   struct _XtransConnInfo *trans_conn ;
   struct _X11XCBPrivate *xcb ;
   unsigned int next_cookie ;
   int (*generic_event_vec[128])(Display * , XGenericEventCookie * , xEvent * ) ;
   int (*generic_event_copy_vec[128])(Display * , XGenericEventCookie * , XGenericEventCookie * ) ;
   void *cookiejar ;
};
#line 216 "/usr/include/X11/Xlibint.h"
struct _XSQEvent {
   struct _XSQEvent *next ;
   XEvent event ;
   unsigned long qserial_num ;
};
#line 258 "/usr/include/X11/Xlibint.h"
struct _XLockPtrs {
   void (*lock_display)(Display *dpy ) ;
   void (*unlock_display)(Display *dpy ) ;
};
#line 655 "/usr/include/X11/Xlibint.h"
struct _XInternalAsync {
   struct _XInternalAsync *next ;
   int (*handler)(Display * , xReply * , char * , int  , XPointer  ) ;
   XPointer data ;
};
#line 705 "/usr/include/X11/Xlibint.h"
struct _XFreeFuncs {
   void (*atoms)(Display * ) ;
   int (*modifiermap)(XModifierKeymap * ) ;
   void (*key_bindings)(Display * ) ;
   void (*context_db)(Display * ) ;
   void (*defaultCCCs)(Display * ) ;
   void (*clientCmaps)(Display * ) ;
   void (*intensityMaps)(Display * ) ;
   void (*im_filters)(Display * ) ;
   void (*xkb)(Display * ) ;
};
#line 790 "/usr/include/X11/Xlibint.h"
struct _XExten {
   struct _XExten *next ;
   XExtCodes codes ;
   int (*create_GC)(Display * , GC  , XExtCodes * ) ;
   int (*copy_GC)(Display * , GC  , XExtCodes * ) ;
   int (*flush_GC)(Display * , GC  , XExtCodes * ) ;
   int (*free_GC)(Display * , GC  , XExtCodes * ) ;
   int (*create_Font)(Display * , XFontStruct * , XExtCodes * ) ;
   int (*free_Font)(Display * , XFontStruct * , XExtCodes * ) ;
   int (*close_display)(Display * , XExtCodes * ) ;
   int (*error)(Display * , xError * , XExtCodes * , int * ) ;
   char *(*error_string)(Display * , int  , XExtCodes * , char * , int  ) ;
   char *name ;
   void (*error_values)(Display * , XErrorEvent * , void * ) ;
   void (*before_flush)(Display * , XExtCodes * , char const   * , long  ) ;
   struct _XExten *next_flush ;
};
#line 1202 "/usr/include/X11/Xlibint.h"
struct _XConnectionInfo {
   int fd ;
   void (*read_callback)(Display * , int  , XPointer  ) ;
   XPointer call_data ;
   XPointer *watch_data ;
   struct _XConnectionInfo *next ;
};
#line 1210 "/usr/include/X11/Xlibint.h"
struct _XConnWatchInfo {
   void (*fn)(Display * , XPointer  , int  , int  , XPointer * ) ;
   XPointer client_data ;
   struct _XConnWatchInfo *next ;
};
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_295 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_295 XWMHints;
#line 163 "/usr/include/X11/Xutil.h"
struct __anonstruct_XTextProperty_296 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
#line 163 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XTextProperty_296 XTextProperty;
#line 47 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
struct __anonstruct_PropMwmHints_316 {
   unsigned long flags ;
   unsigned long functions ;
   unsigned long decorations ;
   long inputMode ;
   unsigned long status ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
typedef struct __anonstruct_PropMwmHints_316 PropMwmHints;
#line 62 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
struct __anonstruct_AtomNode_318 {
   Atom *atom ;
   char const   *name ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
typedef struct __anonstruct_AtomNode_318 AtomNode;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 2732 "/usr/include/X11/Xlib.h"
extern int XGrabKeyboard(Display * , Window  , int  , int  , int  , Time  ) ;
#line 3488
extern int XUngrabKeyboard(Display * , Time  ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clientlist.h"
struct ClientNode *nodes[13]  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clientlist.h"
struct ClientNode *nodeTail[13]  ;
#line 27
int ShouldFocus(struct ClientNode  const  *np ) ;
#line 30
void StartWindowStackWalk(void) ;
#line 33
void WalkWindowStack(int forward ) ;
#line 36
void StopWindowStackWalk(void) ;
#line 42
void FocusNextStacked(struct ClientNode *np ) ;
#line 130 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.h"
ClientNode *FindClientByWindow(Window w ) ;
#line 188
void RestoreClient(ClientNode *np , char raise___0 ) ;
#line 211
void FocusClient(ClientNode *np ) ;
#line 229
void RaiseClient(ClientNode *np ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
Display *display ;
#line 20
Window rootWindow ;
#line 34
unsigned int currentDesktop ;
#line 19 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clientlist.c"
static Window *windowStack  =    (Window *)((void *)0);
#line 20 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clientlist.c"
static int windowStackSize  =    0;
#line 21 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clientlist.c"
static int windowStackCurrent  =    0;
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clientlist.c"
int ShouldFocus(struct ClientNode  const  *np ) 
{ 


  {
#line 27
  if (np->state.desktop != (unsigned int const   )currentDesktop) {
#line 27
    if (! (np->state.status & 32U)) {
#line 29
      return (0);
    }
  }
#line 33
  if (np->state.status & 64U) {
#line 34
    return (0);
  }
#line 38
  if (np->owner != 0UL) {
#line 39
    return (0);
  }
#line 42
  if (! (np->state.status & 2U)) {
#line 42
    if (! (np->state.status & 384U)) {
#line 44
      return (0);
    }
  }
#line 47
  return (1);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clientlist.c"
void StartWindowStackWalk(void) 
{ 
  ClientNode *np ;
  int layer ;
  int count ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 64
  if ((unsigned long )windowStack != (unsigned long )((void *)0)) {
#line 65
    return;
  }
#line 69
  count = 0;
#line 70
  layer = 12;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (layer >= 0)) {
#line 70
      goto while_break;
    }
#line 71
    np = nodes[layer];
    {
#line 71
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 71
      if (! np) {
#line 71
        goto while_break___0;
      }
      {
#line 72
      tmp = ShouldFocus((struct ClientNode  const  *)np);
      }
#line 72
      if (tmp) {
#line 73
        count ++;
      }
#line 71
      np = np->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 70
    layer --;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  if (count == 0) {
#line 80
    return;
  }
  {
#line 84
  tmp___0 = malloc(sizeof(Window ) * (unsigned long )count);
#line 84
  windowStack = (Window *)tmp___0;
#line 87
  windowStackSize = 0;
#line 88
  layer = 12;
  }
  {
#line 88
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 88
    if (! (layer >= 0)) {
#line 88
      goto while_break___1;
    }
#line 89
    np = nodes[layer];
    {
#line 89
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 89
      if (! np) {
#line 89
        goto while_break___2;
      }
      {
#line 90
      tmp___2 = ShouldFocus((struct ClientNode  const  *)np);
      }
#line 90
      if (tmp___2) {
#line 91
        tmp___1 = windowStackSize;
#line 91
        windowStackSize ++;
#line 91
        *(windowStack + tmp___1) = np->window;
      }
#line 89
      np = np->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 88
    layer --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 98
  windowStackCurrent = 0;
#line 100
  XGrabKeyboard(display, rootWindow, 0, 1, 1, (Time )0L);
  }
#line 103
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clientlist.c"
void WalkWindowStack(int forward ) 
{ 
  ClientNode *np ;
  int x ;
  int tmp ;

  {
#line 111
  if ((unsigned long )windowStack != (unsigned long )((void *)0)) {
#line 114
    x = 0;
    {
#line 114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 114
      if (! (x < windowStackSize)) {
#line 114
        goto while_break;
      }
#line 117
      if (forward) {
#line 118
        windowStackCurrent = (windowStackCurrent + 1) % windowStackSize;
      } else {
#line 120
        if (windowStackCurrent == 0) {
#line 121
          windowStackCurrent = windowStackSize;
        }
#line 123
        windowStackCurrent --;
      }
      {
#line 127
      np = FindClientByWindow(*(windowStack + windowStackCurrent));
      }
#line 132
      if ((unsigned long )np == (unsigned long )((void *)0)) {
#line 133
        goto __Cont;
      } else {
        {
#line 132
        tmp = ShouldFocus((struct ClientNode  const  *)np);
        }
#line 132
        if (! tmp) {
#line 133
          goto __Cont;
        }
      }
      {
#line 138
      FocusClient(np);
      }
#line 139
      goto while_break;
      __Cont: /* CIL Label */ 
#line 114
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 145
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clientlist.c"
void StopWindowStackWalk(void) 
{ 
  ClientNode *np ;

  {
#line 153
  if ((unsigned long )windowStack != (unsigned long )((void *)0)) {
    {
#line 156
    np = FindClientByWindow(*(windowStack + windowStackCurrent));
    }
#line 157
    if (np) {
#line 158
      if (np->state.status & 128U) {
        {
#line 159
        RestoreClient(np, (char)1);
        }
      } else {
        {
#line 161
        RaiseClient(np);
        }
      }
    }
    {
#line 165
    free((void *)windowStack);
#line 166
    windowStack = (Window *)((void *)0);
#line 168
    windowStackSize = 0;
#line 169
    windowStackCurrent = 0;
#line 171
    XUngrabKeyboard(display, (Time )0L);
    }
  }
#line 175
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clientlist.c"
void FocusNextStacked(struct ClientNode *np ) 
{ 
  int x ;
  ClientNode *tp ;

  {
#line 185
  tp = np->next;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! tp) {
#line 185
      goto while_break;
    }
#line 186
    if (tp->state.status & 258U) {
#line 186
      if (! (tp->state.status & 16U)) {
        {
#line 188
        FocusClient(tp);
        }
#line 189
        return;
      }
    }
#line 185
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  x = (int )(np->state.layer - 1U);
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    if (! (x >= 0)) {
#line 192
      goto while_break___0;
    }
#line 193
    tp = nodes[x];
    {
#line 193
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 193
      if (! tp) {
#line 193
        goto while_break___1;
      }
#line 194
      if (tp->state.status & 258U) {
#line 194
        if (! (tp->state.status & 16U)) {
          {
#line 196
          FocusClient(tp);
          }
#line 197
          return;
        }
      }
#line 193
      tp = tp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 192
    x --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 202
  return;
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 1609 "/usr/include/X11/Xlib.h"
extern Pixmap XCreatePixmap(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int  ) ;
#line 1633
extern Window XCreateSimpleWindow(Display * , Window  , int  , int  , unsigned int  ,
                                  unsigned int  , unsigned int  , unsigned long  ,
                                  unsigned long  ) ;
#line 2097
extern int XChangeWindowAttributes(Display * , Window  , unsigned long  , XSetWindowAttributes * ) ;
#line 2167
extern int XClearWindow(Display * , Window  ) ;
#line 2255
extern int XDestroyWindow(Display * , Window  ) ;
#line 2373
extern int XDrawPoint(Display * , Drawable  , GC  , int  , int  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2582
extern int XFreePixmap(Display * , Pixmap  ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 3239
extern int XSetForeground(Display * , GC  , unsigned long  ) ;
#line 3517
extern int XUnmapWindow(Display * , Window  ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/debug.h"
void Debug(char const   *str___0  , ...) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.h"
void InitializeBackgrounds(void) ;
#line 17
void StartupBackgrounds(void) ;
#line 20
void ShutdownBackgrounds(void) ;
#line 23
void DestroyBackgrounds(void) ;
#line 30
void SetBackground(int desktop , char const   *type , char const   *value ) ;
#line 35
void LoadBackground(int desktop ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/misc.h"
void ExpandPath(char **path ) ;
#line 34
char *CopyString(char const   *str___0 ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/error.h"
void Warning(char const   *str___0  , ...) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.h"
void RunCommand(char const   *command ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.h"
int ParseColor(char const   *value , XColor *c ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
int rootWidth ;
#line 21
int rootHeight ;
#line 22
int rootDepth ;
#line 26
GC rootGC ;
#line 72 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.h"
void PutIcon(IconNode *icon , Drawable d , int x , int y , int width , int height ) ;
#line 84
IconNode *LoadNamedIcon(char const   *name ) ;
#line 89
void DestroyIcon(IconNode *icon ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/gradient.h"
void DrawHorizontalGradient(Drawable d , GC g , long fromColor , long toColor , int x ,
                            int y , unsigned int width , unsigned int height ) ;
#line 228 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
void SetPixmapAtom(Window window , AtomType atom , Pixmap value ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
static BackgroundNode *backgrounds  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
static BackgroundNode *defaultBackground  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
static BackgroundNode *lastBackground  ;
#line 50
static void LoadSolidBackground(BackgroundNode *bp ) ;
#line 51
static void LoadGradientBackground(BackgroundNode *bp ) ;
#line 52
static void LoadImageBackground(BackgroundNode *bp ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
void InitializeBackgrounds(void) 
{ 


  {
#line 56
  backgrounds = (BackgroundNode *)((void *)0);
#line 57
  defaultBackground = (BackgroundNode *)((void *)0);
#line 58
  lastBackground = (BackgroundNode *)((void *)0);
#line 59
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
void StartupBackgrounds(void) 
{ 
  BackgroundNode *bp ;

  {
#line 66
  bp = backgrounds;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! bp) {
#line 66
      goto while_break;
    }
    {
#line 70
    if ((unsigned int )bp->type == 0U) {
#line 70
      goto case_0;
    }
#line 73
    if ((unsigned int )bp->type == 1U) {
#line 73
      goto case_1;
    }
#line 76
    if ((unsigned int )bp->type == 2U) {
#line 76
      goto case_2;
    }
#line 80
    if ((unsigned int )bp->type == 4U) {
#line 80
      goto case_4;
    }
#line 80
    if ((unsigned int )bp->type == 3U) {
#line 80
      goto case_4;
    }
#line 83
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 71
    LoadSolidBackground(bp);
    }
#line 72
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 74
    LoadGradientBackground(bp);
    }
#line 75
    goto switch_break;
    case_2: /* CIL Label */ 
#line 78
    goto switch_break;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 81
    LoadImageBackground(bp);
    }
#line 82
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 84
    Debug("invalid background type in LoadBackground: %d", (unsigned int )bp->type);
    }
#line 85
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 88
    if (bp->desktop == -1) {
#line 89
      defaultBackground = bp;
    }
#line 66
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
void ShutdownBackgrounds(void) 
{ 
  BackgroundNode *bp ;

  {
#line 101
  bp = backgrounds;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! bp) {
#line 101
      goto while_break;
    }
#line 102
    if (bp->pixmap != 0UL) {
      {
#line 103
      XFreePixmap(display, bp->pixmap);
#line 104
      bp->pixmap = (Pixmap )0L;
      }
    }
#line 106
    if (bp->window != 0UL) {
      {
#line 107
      XDestroyWindow(display, bp->window);
#line 108
      bp->window = (Window )0L;
      }
    }
#line 101
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
void DestroyBackgrounds(void) 
{ 
  BackgroundNode *bp ;

  {
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! backgrounds) {
#line 119
      goto while_break;
    }
    {
#line 120
    bp = backgrounds->next;
#line 121
    free((void *)backgrounds->value);
#line 122
    free((void *)backgrounds);
#line 123
    backgrounds = bp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
void SetBackground(int desktop , char const   *type , char const   *value ) 
{ 
  BackgroundType bgType ;
  BackgroundNode *bp ;
  char *tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 135
  tmp___0 = __builtin_expect((long )(! (! (! value))), 0L);
  }
#line 135
  if (tmp___0) {
    {
#line 136
    tmp = gettext("no value specified for background");
#line 136
    Warning((char const   *)tmp);
    }
#line 137
    return;
  }
#line 141
  if (! type) {
#line 142
    bgType = (BackgroundType )0;
  } else {
    {
#line 141
    tmp___6 = strcmp(type, "solid");
    }
#line 141
    if (tmp___6) {
      {
#line 143
      tmp___5 = strcmp(type, "gradient");
      }
#line 143
      if (tmp___5) {
        {
#line 145
        tmp___4 = strcmp(type, "command");
        }
#line 145
        if (tmp___4) {
          {
#line 147
          tmp___3 = strcmp(type, "image");
          }
#line 147
          if (tmp___3) {
            {
#line 149
            tmp___2 = strcmp(type, "tile");
            }
#line 149
            if (tmp___2) {
              {
#line 152
              tmp___1 = gettext("invalid background type: \"%s\"");
#line 152
              Warning((char const   *)tmp___1, type);
              }
#line 153
              return;
            } else {
#line 150
              bgType = (BackgroundType )4;
            }
          } else {
#line 148
            bgType = (BackgroundType )3;
          }
        } else {
#line 146
          bgType = (BackgroundType )2;
        }
      } else {
#line 144
        bgType = (BackgroundType )1;
      }
    } else {
#line 142
      bgType = (BackgroundType )0;
    }
  }
  {
#line 157
  tmp___7 = malloc(sizeof(BackgroundNode ));
#line 157
  bp = (BackgroundNode *)tmp___7;
#line 158
  bp->desktop = desktop;
#line 159
  bp->type = bgType;
#line 160
  bp->value = CopyString(value);
#line 163
  bp->next = backgrounds;
#line 164
  backgrounds = bp;
  }
#line 166
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
void LoadBackground(int desktop ) 
{ 
  XSetWindowAttributes attr ;
  long attrValues ;
  BackgroundNode *bp ;
  int tmp ;

  {
#line 176
  bp = backgrounds;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! bp) {
#line 176
      goto while_break;
    }
#line 177
    if (bp->desktop == desktop) {
#line 178
      goto while_break;
    }
#line 176
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  if (! bp) {
#line 182
    bp = defaultBackground;
  }
#line 186
  if (! bp) {
#line 187
    return;
  } else
#line 186
  if (! bp->value) {
#line 187
    return;
  }
#line 191
  if (lastBackground) {
#line 191
    if ((unsigned int )bp->type == (unsigned int )lastBackground->type) {
      {
#line 191
      tmp = strcmp((char const   *)bp->value, (char const   *)lastBackground->value);
      }
#line 191
      if (! tmp) {
#line 194
        return;
      }
    }
  }
#line 196
  if (lastBackground) {
#line 196
    if (lastBackground->window) {
      {
#line 197
      XUnmapWindow(display, lastBackground->window);
      }
    }
  }
#line 199
  lastBackground = bp;
  {
#line 203
  if ((unsigned int )bp->type == 2U) {
#line 203
    goto case_2;
  }
#line 206
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 204
  RunCommand((char const   *)bp->value);
  }
#line 205
  return;
  switch_default: /* CIL Label */ 
#line 207
  attrValues = 1L;
#line 208
  attr.background_pixmap = bp->pixmap;
#line 209
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 212
  XChangeWindowAttributes(display, bp->window, (unsigned long )attrValues, & attr);
#line 213
  XClearWindow(display, bp->window);
#line 214
  XMapWindow(display, bp->window);
#line 216
  SetPixmapAtom(rootWindow, (AtomType )2, bp->window);
  }
#line 218
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
static void LoadSolidBackground(BackgroundNode *bp ) 
{ 
  XColor c ;

  {
  {
#line 225
  ParseColor((char const   *)bp->value, & c);
#line 228
  bp->window = XCreateSimpleWindow(display, rootWindow, 0, 0, (unsigned int )rootWidth,
                                   (unsigned int )rootHeight, 0U, 0UL, 0UL);
#line 232
  bp->pixmap = XCreatePixmap(display, bp->window, 1U, 1U, (unsigned int )rootDepth);
#line 234
  XSetForeground(display, rootGC, c.pixel);
#line 235
  XDrawPoint(display, bp->pixmap, rootGC, 0, 0);
  }
#line 237
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
static void LoadGradientBackground(BackgroundNode *bp ) 
{ 
  XColor color1 ;
  XColor color2 ;
  char *temp ;
  char *sep ;
  int len ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 248
  sep = strchr((char const   *)bp->value, ':');
  }
#line 249
  if (! sep) {
#line 250
    bp->pixmap = (Pixmap )0L;
#line 251
    bp->window = (Window )0L;
#line 252
    return;
  }
  {
#line 256
  len = (int )(sep - bp->value);
#line 257
  tmp = __builtin_alloca((unsigned long )(len + 1));
#line 257
  temp = (char *)tmp;
#line 258
  memcpy((void */* __restrict  */)temp, (void const   */* __restrict  */)bp->value,
         (size_t )len);
#line 259
  *(temp + len) = (char)0;
#line 260
  ParseColor((char const   *)temp, & color1);
#line 264
  tmp___0 = strlen((char const   *)(sep + 1));
#line 264
  len = (int )tmp___0;
#line 265
  tmp___1 = __builtin_alloca((unsigned long )(len + 1));
#line 265
  temp = (char *)tmp___1;
#line 266
  memcpy((void */* __restrict  */)temp, (void const   */* __restrict  */)(sep + 1),
         (size_t )len);
#line 267
  *(temp + len) = (char)0;
#line 268
  ParseColor((char const   *)temp, & color2);
#line 272
  bp->window = XCreateSimpleWindow(display, rootWindow, 0, 0, (unsigned int )rootWidth,
                                   (unsigned int )rootHeight, 0U, 0UL, 0UL);
#line 275
  bp->pixmap = XCreatePixmap(display, bp->window, (unsigned int )rootWidth, (unsigned int )rootHeight,
                             (unsigned int )rootDepth);
  }
#line 278
  if (color1.pixel == color2.pixel) {
    {
#line 279
    XSetForeground(display, rootGC, color1.pixel);
#line 280
    XFillRectangle(display, bp->pixmap, rootGC, 0, 0, (unsigned int )rootWidth, (unsigned int )rootHeight);
    }
  } else {
    {
#line 283
    DrawHorizontalGradient(bp->pixmap, rootGC, (long )color1.pixel, (long )color2.pixel,
                           0, 0, (unsigned int )rootWidth, (unsigned int )rootHeight);
    }
  }
#line 287
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/background.c"
static void LoadImageBackground(BackgroundNode *bp ) 
{ 
  IconNode *ip ;
  int width ;
  int height ;
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 296
  ExpandPath(& bp->value);
#line 297
  ip = LoadNamedIcon((char const   *)bp->value);
#line 298
  tmp___0 = __builtin_expect((long )(! (! (! ip))), 0L);
  }
#line 298
  if (tmp___0) {
    {
#line 299
    bp->pixmap = (Pixmap )0L;
#line 300
    bp->window = (Window )0L;
#line 301
    tmp = gettext("background image not found: \"%s\"");
#line 301
    Warning((char const   *)tmp, bp->value);
    }
#line 302
    return;
  }
#line 306
  ip->useRender = 0;
#line 309
  if ((unsigned int )bp->type == 4U) {
#line 310
    width = (ip->image)->width;
#line 311
    height = (ip->image)->height;
  } else {
#line 313
    width = rootWidth;
#line 314
    height = rootHeight;
  }
  {
#line 318
  bp->window = XCreateSimpleWindow(display, rootWindow, 0, 0, (unsigned int )rootWidth,
                                   (unsigned int )rootHeight, 0U, 0UL, 0UL);
#line 322
  bp->pixmap = XCreatePixmap(display, bp->window, (unsigned int )width, (unsigned int )height,
                             (unsigned int )rootDepth);
#line 326
  XSetForeground(display, rootGC, 0UL);
#line 327
  XFillRectangle(display, bp->pixmap, rootGC, 0, 0, (unsigned int )width, (unsigned int )height);
#line 330
  PutIcon(ip, bp->pixmap, 0, 0, width, height);
#line 333
  DestroyIcon(ip);
  }
#line 335
  return;
}
}
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.h"
void InitializeClock(void) ;
#line 18
void StartupClock(void) ;
#line 19
void ShutdownClock(void) ;
#line 20
void DestroyClock(void) ;
#line 30
struct TrayComponentType *CreateClock(char const   *format , char const   *zone ,
                                      char const   *command , int width , int height ) ;
#line 39
void SignalClock(struct TimeType  const  *now , int x , int y ) ;
#line 158 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
TrayComponentType *CreateTrayComponent(void) ;
#line 191
void UpdateSpecificTray(TrayType const   *tp , TrayComponentType const   *cp ) ;
#line 196
void ResizeTray(TrayType *tp ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.h"
unsigned long colors[45] ;
#line 52 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.h"
void RenderString(Drawable d , FontType font , ColorType color , int x , int y , int width ,
                  Region region , char const   *str___0 ) ;
#line 60
int GetStringWidth(FontType type , char const   *str___0 ) ;
#line 66
int GetStringHeight(FontType type ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/timing.h"
void GetCurrentTime(TimeType *t ) ;
#line 35
unsigned long GetTimeDifference(TimeType const   *t1 , TimeType const   *t2 ) ;
#line 44
char const   *GetTimeString(char const   *format , char const   *zone ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.h"
void GetMousePosition(int *x , int *y ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.h"
void ShowPopup(int x , int y , char const   *text ) ;
#line 63
int popupDelay ;
#line 44 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
static char const   *DEFAULT_FORMAT  =    "%I:%M %p";
#line 46 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
static ClockType *clocks  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
static TimeType lastUpdate  =    {0UL, 0};
#line 49
static void Create(TrayComponentType *cp ) ;
#line 50
static void Resize(TrayComponentType *cp ) ;
#line 51
static void Destroy(TrayComponentType *cp ) ;
#line 52
static void ProcessClockButtonEvent(TrayComponentType *cp , int x , int y , int mask ) ;
#line 54
static void ProcessClockMotionEvent(TrayComponentType *cp , int x , int y , int mask ) ;
#line 57
static void DrawClock(ClockType *clk , TimeType const   *now , int x , int y ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
void InitializeClock(void) 
{ 


  {
#line 61
  clocks = (ClockType *)((void *)0);
#line 62
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
void StartupClock(void) 
{ 
  ClockType *clk ;
  int tmp ;

  {
#line 69
  clk = clocks;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! clk) {
#line 69
      goto while_break;
    }
#line 70
    if ((clk->cp)->requestedWidth == 0) {
#line 71
      (clk->cp)->requestedWidth = 1;
    }
#line 73
    if ((clk->cp)->requestedHeight == 0) {
      {
#line 74
      tmp = GetStringHeight((FontType )4);
#line 74
      (clk->cp)->requestedHeight = tmp + 4;
      }
    }
#line 69
    clk = clk->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
void ShutdownClock(void) 
{ 


  {
#line 82
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
void DestroyClock(void) 
{ 
  ClockType *cp ;

  {
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! clocks) {
#line 89
      goto while_break;
    }
#line 90
    cp = clocks->next;
#line 92
    if (clocks->format) {
      {
#line 93
      free((void *)clocks->format);
      }
    }
#line 95
    if (clocks->zone) {
      {
#line 96
      free((void *)clocks->zone);
      }
    }
#line 98
    if (clocks->command) {
      {
#line 99
      free((void *)clocks->command);
      }
    }
    {
#line 102
    free((void *)clocks);
#line 103
    clocks = cp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
struct TrayComponentType *CreateClock(char const   *format , char const   *zone ,
                                      char const   *command , int width , int height ) 
{ 
  TrayComponentType *cp ;
  ClockType *clk ;
  void *tmp ;

  {
  {
#line 115
  tmp = malloc(sizeof(ClockType ));
#line 115
  clk = (ClockType *)tmp;
#line 116
  clk->next = clocks;
#line 117
  clocks = clk;
#line 119
  clk->mousex = -2;
#line 120
  clk->mousey = -2;
#line 121
  clk->mouseTime.seconds = 0UL;
#line 122
  clk->mouseTime.ms = 0;
#line 123
  clk->userWidth = 0;
  }
#line 125
  if (! format) {
#line 126
    format = DEFAULT_FORMAT;
  }
  {
#line 128
  clk->format = CopyString(format);
#line 130
  clk->zone = CopyString(zone);
#line 132
  clk->command = CopyString(command);
#line 134
  clk->shortTime[0] = (char)0;
#line 136
  cp = CreateTrayComponent();
#line 137
  cp->object = (void *)clk;
#line 138
  clk->cp = cp;
  }
#line 139
  if (width > 0) {
#line 140
    cp->requestedWidth = width;
#line 141
    clk->userWidth = 1;
  } else {
#line 143
    cp->requestedWidth = 0;
#line 144
    clk->userWidth = 0;
  }
#line 146
  cp->requestedHeight = height;
#line 148
  cp->Create = & Create;
#line 149
  cp->Resize = & Resize;
#line 150
  cp->Destroy = & Destroy;
#line 151
  cp->ProcessButtonPress = & ProcessClockButtonEvent;
#line 152
  cp->ProcessMotionEvent = & ProcessClockMotionEvent;
#line 154
  return (cp);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
static void Create(TrayComponentType *cp ) 
{ 


  {
  {
#line 163
  cp->pixmap = XCreatePixmap(display, rootWindow, (unsigned int )cp->width, (unsigned int )cp->height,
                             (unsigned int )rootDepth);
#line 166
  XSetForeground(display, rootGC, colors[43]);
#line 167
  XFillRectangle(display, cp->pixmap, rootGC, 0, 0, (unsigned int )cp->width, (unsigned int )cp->height);
  }
#line 169
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
static void Resize(TrayComponentType *cp ) 
{ 
  ClockType *clk ;
  TimeType now ;
  int x ;
  int y ;

  {
#line 180
  clk = (ClockType *)cp->object;
#line 184
  if (cp->pixmap != 0UL) {
    {
#line 185
    XFreePixmap(display, cp->pixmap);
    }
  }
  {
#line 188
  cp->pixmap = XCreatePixmap(display, rootWindow, (unsigned int )cp->width, (unsigned int )cp->height,
                             (unsigned int )rootDepth);
#line 191
  clk->shortTime[0] = (char)0;
#line 193
  GetCurrentTime(& now);
#line 194
  GetMousePosition(& x, & y);
#line 195
  DrawClock(clk, (TimeType const   *)(& now), x, y);
  }
#line 197
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
static void Destroy(TrayComponentType *cp ) 
{ 


  {
#line 204
  if (cp->pixmap != 0UL) {
    {
#line 205
    XFreePixmap(display, cp->pixmap);
    }
  }
#line 207
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
static void ProcessClockButtonEvent(TrayComponentType *cp , int x , int y , int mask ) 
{ 
  ClockType *clk ;

  {
#line 216
  clk = (ClockType *)cp->object;
#line 220
  if (clk->command) {
    {
#line 221
    RunCommand((char const   *)clk->command);
    }
  }
#line 224
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
static void ProcessClockMotionEvent(TrayComponentType *cp , int x , int y , int mask ) 
{ 
  ClockType *clk ;

  {
  {
#line 234
  clk = (ClockType *)cp->object;
#line 235
  clk->mousex = cp->screenx + x;
#line 236
  clk->mousey = cp->screeny + y;
#line 237
  GetCurrentTime(& clk->mouseTime);
  }
#line 239
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
void SignalClock(struct TimeType  const  *now , int x , int y ) 
{ 
  ClockType *cp ;
  int shouldDraw ;
  char const   *longTime ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 251
  tmp = GetTimeDifference((TimeType const   *)(& lastUpdate), now);
  }
#line 251
  if (tmp > 900UL) {
#line 252
    shouldDraw = 1;
#line 253
    lastUpdate = (TimeType )*now;
  } else {
#line 255
    shouldDraw = 0;
  }
#line 259
  cp = clocks;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! cp) {
#line 259
      goto while_break;
    }
#line 261
    if (shouldDraw) {
      {
#line 262
      DrawClock(cp, now, x, y);
      }
    }
    {
#line 265
    tmp___1 = abs(cp->mousex - x);
    }
#line 265
    if (tmp___1 < 2) {
      {
#line 265
      tmp___2 = abs(cp->mousey - y);
      }
#line 265
      if (tmp___2 < 2) {
        {
#line 267
        tmp___0 = GetTimeDifference(now, (TimeType const   *)(& cp->mouseTime));
        }
#line 267
        if (tmp___0 >= (unsigned long )popupDelay) {
          {
#line 268
          longTime = GetTimeString("%c", (char const   *)cp->zone);
#line 269
          ShowPopup(x, y, longTime);
          }
        }
      }
    }
#line 259
    cp = cp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/clock.c"
static void DrawClock(ClockType *clk , TimeType const   *now , int x , int y ) 
{ 
  TrayComponentType *cp ;
  char const   *shortTime ;
  int width ;
  int rwidth ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 289
  shortTime = GetTimeString((char const   *)clk->format, (char const   *)clk->zone);
#line 290
  tmp = strcmp((char const   *)(clk->shortTime), shortTime);
  }
#line 290
  if (! tmp) {
#line 291
    return;
  }
  {
#line 293
  strcpy((char */* __restrict  */)(clk->shortTime), (char const   */* __restrict  */)shortTime);
#line 295
  cp = clk->cp;
#line 298
  XSetForeground(display, rootGC, colors[43]);
#line 299
  XFillRectangle(display, cp->pixmap, rootGC, 0, 0, (unsigned int )cp->width, (unsigned int )cp->height);
#line 302
  width = GetStringWidth((FontType )4, shortTime);
#line 303
  rwidth = width + 4;
  }
#line 304
  if (rwidth == (clk->cp)->requestedWidth) {
    {
#line 307
    tmp___0 = GetStringHeight((FontType )4);
#line 307
    RenderString(cp->pixmap, (FontType )4, (ColorType )44, (cp->width - width) / 2,
                 (cp->height - tmp___0) / 2, cp->width, (Region )((void *)0), shortTime);
#line 312
    UpdateSpecificTray((TrayType const   *)(clk->cp)->tray, (TrayComponentType const   *)clk->cp);
    }
  } else
#line 304
  if (clk->userWidth) {
    {
#line 307
    tmp___0 = GetStringHeight((FontType )4);
#line 307
    RenderString(cp->pixmap, (FontType )4, (ColorType )44, (cp->width - width) / 2,
                 (cp->height - tmp___0) / 2, cp->width, (Region )((void *)0), shortTime);
#line 312
    UpdateSpecificTray((TrayType const   *)(clk->cp)->tray, (TrayComponentType const   *)clk->cp);
    }
  } else {
    {
#line 317
    (clk->cp)->requestedWidth = rwidth;
#line 318
    ResizeTray((clk->cp)->tray);
    }
  }
#line 322
  return;
}
}
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 1648 "/usr/include/X11/Xlib.h"
extern Window XCreateWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                            unsigned int  , int  , unsigned int  , Visual * , unsigned long  ,
                            XSetWindowAttributes * ) ;
#line 1965
extern int XAddToSaveSet(Display * , Window  ) ;
#line 2528
extern int XFree(void * ) ;
#line 2703
extern int XGetWindowAttributes(Display * , Window  , XWindowAttributes * ) ;
#line 2709
extern int XGrabButton(Display * , unsigned int  , unsigned int  , Window  , int  ,
                       unsigned int  , int  , int  , Window  , Cursor  ) ;
#line 2753
extern int XGrabServer(Display * ) ;
#line 2780
extern int XInstallColormap(Display * , Colormap  ) ;
#line 2790
extern int XKillClient(Display * , XID  ) ;
#line 2837
extern int XMoveResizeWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ) ;
#line 2995
extern int XQueryPointer(Display * , Window  , Window * , Window * , int * , int * ,
                         int * , int * , unsigned int * ) ;
#line 3029
extern int XQueryTree(Display * , Window  , Window * , Window * , Window ** , unsigned int * ) ;
#line 3083
extern int XRemoveFromSaveSet(Display * , Window  ) ;
#line 3099
extern int XReparentWindow(Display * , Window  , Window  , int  , int  ) ;
#line 3111
extern int XResizeWindow(Display * , Window  , unsigned int  , unsigned int  ) ;
#line 3118
extern int XRestackWindows(Display * , Window * , int  ) ;
#line 3147
extern int XSendEvent(Display * , Window  , int  , long  , XEvent * ) ;
#line 3263
extern int XSetInputFocus(Display * , Window  , int  , Time  ) ;
#line 3369
extern int XSetWindowBorderWidth(Display * , Window  , unsigned int  ) ;
#line 3421
extern int XSync(Display * , int  ) ;
#line 3474
extern int XUngrabButton(Display * , unsigned int  , unsigned int  , Window  ) ;
#line 3498
extern int XUngrabServer(Display * ) ;
#line 397 "/usr/include/X11/Xutil.h"
extern int XDeleteContext(Display * , XID  , XContext  ) ;
#line 416
extern int XFindContext(Display * , XID  , XContext  , XPointer * ) ;
#line 576
extern int XSaveContext(Display * , XID  , XContext  , char const   * ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.h"
void DrawBorder(struct ClientNode  const  *np , XExposeEvent const   *expose ) ;
#line 74
void GetBorderSize(struct ClientNode  const  *np , int *north , int *south , int *east ,
                   int *west ) ;
#line 93
void ResetRoundedRectWindow(Window w ) ;
#line 100
void ShapeRoundedRectWindow(Window w , int width , int height ) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
Atom atoms[64] ;
#line 149
void ReadClientProtocols(struct ClientNode *np ) ;
#line 170
ClientProtocolType ReadWMProtocols(Window w ) ;
#line 191
void WriteState(struct ClientNode *np ) ;
#line 214
void SetCardinalAtom(Window window , AtomType atom , unsigned long value ) ;
#line 221
void SetWindowAtom(Window window , AtomType atom , unsigned long value ) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.h"
ClientNode *FindClientByParent(Window p ) ;
#line 141
ClientNode *GetActiveClient(void) ;
#line 143
void InitializeClients(void) ;
#line 144
void StartupClients(void) ;
#line 145
void ShutdownClients(void) ;
#line 146
void DestroyClients(void) ;
#line 154
ClientNode *AddClientWindow(Window w , char alreadyMapped , char notOwner ) ;
#line 159
void RemoveClient(ClientNode *np ) ;
#line 164
void MinimizeClient(ClientNode *np ) ;
#line 169
void ShadeClient(ClientNode *np ) ;
#line 174
void UnshadeClient(ClientNode *np ) ;
#line 182
void SetClientWithdrawn(ClientNode *np ) ;
#line 195
void MaximizeClient(ClientNode *np , char horiz , char vert ) ;
#line 200
void MaximizeClientDefault(ClientNode *np ) ;
#line 206
void SetClientFullScreen(ClientNode *np , char fullScreen ) ;
#line 214
void RefocusClient(void) ;
#line 219
void DeleteClient(ClientNode *np ) ;
#line 224
void KillClient(ClientNode *np ) ;
#line 234
void LowerClient(ClientNode *np ) ;
#line 240
void RestackClients(void) ;
#line 246
void SetClientLayer(ClientNode *np , unsigned int layer ) ;
#line 252
void SetClientDesktop(ClientNode *np , unsigned int desktop ) ;
#line 259
void SetClientSticky(ClientNode *np , char isSticky ) ;
#line 265
void HideClient(ClientNode *np ) ;
#line 271
void ShowClient(ClientNode *np ) ;
#line 276
void UpdateClientColormap(ClientNode *np ) ;
#line 287
void SendConfigureEvent(ClientNode *np ) ;
#line 294
void SendClientMessage(Window w , AtomType type , AtomType message ) ;
#line 299
void SetActiveClientOpacity(char const   *str___0 ) ;
#line 304
void SetInactiveClientOpacity(char const   *str___0 ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
Visual *rootVisual ;
#line 31
unsigned int desktopWidth ;
#line 32
unsigned int desktopHeight ;
#line 36
char shouldExit ;
#line 48
FocusModelType focusModel ;
#line 50
XContext clientContext ;
#line 51
XContext frameContext ;
#line 78 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.h"
void LoadIcon(struct ClientNode *np ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.h"
void ApplyGroups(struct ClientNode *np ) ;
#line 201 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
TrayType *GetTrays(void) ;
#line 206
int GetTrayCount(void) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.h"
void ShowConfirmDialog(struct ClientNode *np , void (*action)(struct ClientNode * ) 
                       , ...) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.h"
void GrabKeys(struct ClientNode *np ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.h"
void SetDefaultCursor(Window w ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.h"
void AddClientToTaskBar(struct ClientNode *np ) ;
#line 34
void RemoveClientFromTaskBar(struct ClientNode *np ) ;
#line 36
void UpdateTaskBar(void) ;
#line 58
void UpdateNetClientList(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.h"
ScreenType const   *GetCurrentScreen(int x , int y ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.h"
void UpdatePager(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.h"
void RemoveClientStrut(struct ClientNode *np ) ;
#line 40
void ReadClientStrut(struct ClientNode *np ) ;
#line 46
void PlaceClient(struct ClientNode *np , int alreadyMapped ) ;
#line 53
void PlaceMaximizedClient(struct ClientNode *np , int horiz , int vert ) ;
#line 59
void GravitateClient(struct ClientNode *np , int negate ) ;
#line 77
void GetScreenBounds(struct ScreenType  const  *sp , BoundingBox *box ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.h"
Time eventTime ;
#line 29 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
static ClientNode *activeClient  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
static int clientCount  ;
#line 33
static void LoadFocus(void) ;
#line 34
static void ReparentClient(ClientNode *np , char notOwner ) ;
#line 36
static void MinimizeTransients(ClientNode *np ) ;
#line 39
static void RestoreTransients(ClientNode *np , char raise___0 ) ;
#line 41
static void KillClientHandler(ClientNode *np ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
static unsigned int activeOpacity  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
static unsigned int maxInactiveOpacity  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
static unsigned int minInactiveOpacity  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
static unsigned int deltaInactiveOpacity  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void InitializeClients(void) 
{ 


  {
#line 50
  activeOpacity = (unsigned int )(1.0 * (double )4294967295U);
#line 51
  maxInactiveOpacity = (unsigned int )(0.9 * (double )4294967295U);
#line 52
  minInactiveOpacity = (unsigned int )(0.5 * (double )4294967295U);
#line 53
  deltaInactiveOpacity = (unsigned int )(0.1 * (double )4294967295U);
#line 54
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void StartupClients(void) 
{ 
  XWindowAttributes attr ;
  Window rootReturn ;
  Window parentReturn ;
  Window *childrenReturn ;
  unsigned int childrenCount ;
  unsigned int x ;
  int tmp ;

  {
#line 64
  clientCount = 0;
#line 65
  activeClient = (ClientNode *)((void *)0);
#line 66
  currentDesktop = 0U;
#line 69
  x = 0U;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! (x < 13U)) {
#line 69
      goto while_break;
    }
#line 70
    nodes[x] = (struct ClientNode *)((void *)0);
#line 71
    nodeTail[x] = (struct ClientNode *)((void *)0);
#line 69
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  XQueryTree(display, rootWindow, & rootReturn, & parentReturn, & childrenReturn,
             & childrenCount);
#line 79
  x = 0U;
  }
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! (x < childrenCount)) {
#line 79
      goto while_break___0;
    }
    {
#line 80
    tmp = XGetWindowAttributes(display, *(childrenReturn + x), & attr);
    }
#line 80
    if (tmp) {
#line 81
      if (attr.override_redirect == 0) {
#line 81
        if (attr.map_state == 2) {
          {
#line 83
          AddClientWindow(*(childrenReturn + x), (char)1, (char)1);
          }
        }
      }
    }
#line 79
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 88
  XFree((void *)childrenReturn);
#line 90
  LoadFocus();
#line 92
  UpdateTaskBar();
#line 93
  UpdatePager();
  }
#line 95
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void ShutdownClients(void) 
{ 
  int x ;

  {
#line 102
  x = 0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (x < 13)) {
#line 102
      goto while_break;
    }
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 103
      if (! nodeTail[x]) {
#line 103
        goto while_break___0;
      }
      {
#line 104
      RemoveClient(nodeTail[x]);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 102
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void DestroyClients(void) 
{ 


  {
#line 112
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
static void LoadFocus(void) 
{ 
  ClientNode *np ;
  Window rootReturn ;
  Window childReturn ;
  int rootx ;
  int rooty ;
  int winx ;
  int winy ;
  unsigned int mask ;

  {
  {
#line 123
  XQueryPointer(display, rootWindow, & rootReturn, & childReturn, & rootx, & rooty,
                & winx, & winy, & mask);
#line 126
  np = FindClientByWindow(childReturn);
  }
#line 127
  if (np) {
    {
#line 128
    FocusClient(np);
    }
  }
#line 131
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
ClientNode *AddClientWindow(Window w , char alreadyMapped , char notOwner ) 
{ 
  XWindowAttributes attr ;
  ClientNode *np ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 142
  tmp = XGetWindowAttributes(display, w, & attr);
  }
#line 142
  if (tmp == 0) {
#line 143
    return ((ClientNode *)((void *)0));
  }
#line 147
  if (attr.override_redirect == 1) {
#line 148
    return ((ClientNode *)((void *)0));
  }
#line 150
  if (attr.class == 2) {
#line 151
    return ((ClientNode *)((void *)0));
  }
  {
#line 155
  tmp___0 = malloc(sizeof(ClientNode ));
#line 155
  np = (ClientNode *)tmp___0;
#line 156
  memset((void *)np, 0, sizeof(ClientNode ));
#line 158
  np->window = w;
#line 159
  np->owner = (Window )0L;
#line 160
  np->state.desktop = currentDesktop;
#line 161
  np->controller = (void (*)(int wasDestroyed ))((void *)0);
#line 162
  np->name = (char *)((void *)0);
#line 163
  np->colormaps = (ColormapNode *)((void *)0);
#line 165
  np->x = attr.x;
#line 166
  np->y = attr.y;
#line 167
  np->width = attr.width;
#line 168
  np->height = attr.height;
#line 169
  np->cmap = attr.colormap;
#line 170
  np->colormaps = (ColormapNode *)((void *)0);
#line 171
  np->state.status = 0U;
#line 172
  np->state.layer = 4U;
#line 174
  np->state.border = 511U;
#line 175
  np->borderAction = (BorderActionType )0;
#line 177
  ReadClientProtocols(np);
  }
#line 179
  if (! notOwner) {
#line 180
    np->state.border = 67U;
#line 181
    np->state.status |= 544U;
  }
#line 185
  np->prev = (struct ClientNode *)((void *)0);
#line 186
  np->next = nodes[np->state.layer];
#line 187
  if (np->next) {
#line 188
    (np->next)->prev = np;
  } else {
#line 190
    nodeTail[np->state.layer] = np;
  }
  {
#line 192
  nodes[np->state.layer] = np;
#line 194
  LoadIcon(np);
#line 196
  ApplyGroups(np);
#line 198
  SetDefaultCursor(np->window);
#line 199
  ReparentClient(np, notOwner);
#line 200
  PlaceClient(np, (int )alreadyMapped);
#line 203
  XSaveContext(display, np->window, clientContext, (char const   *)((void *)np));
#line 204
  XSaveContext(display, np->parent, frameContext, (char const   *)((void *)np));
  }
#line 206
  if (np->state.status & 2U) {
    {
#line 207
    XMapWindow(display, np->window);
#line 208
    XMapWindow(display, np->parent);
    }
  }
  {
#line 211
  DrawBorder((struct ClientNode  const  *)np, (XExposeEvent const   *)((void *)0));
#line 213
  AddClientToTaskBar(np);
  }
#line 215
  if (! alreadyMapped) {
    {
#line 216
    RaiseClient(np);
    }
  }
#line 219
  clientCount ++;
#line 221
  if (np->state.status & 32U) {
    {
#line 222
    SetCardinalAtom(np->window, (AtomType )21, ~ 0UL);
    }
  } else {
    {
#line 224
    SetCardinalAtom(np->window, (AtomType )21, (unsigned long )np->state.desktop);
    }
  }
#line 228
  if (np->state.status & 256U) {
    {
#line 229
    ShadeClient(np);
    }
  }
#line 233
  if (np->state.status & 128U) {
    {
#line 234
    np->state.status &= 4294967167U;
#line 235
    MinimizeClient(np);
    }
  }
#line 239
  if (np->state.status & 12U) {
    {
#line 240
    np->state.status &= 4294967283U;
#line 241
    MaximizeClientDefault(np);
    }
  }
  {
#line 245
  WriteState(np);
#line 246
  SendConfigureEvent(np);
  }
#line 249
  if (np->state.desktop != currentDesktop) {
#line 249
    if (! (np->state.status & 32U)) {
      {
#line 251
      HideClient(np);
      }
    }
  }
  {
#line 254
  ReadClientStrut(np);
  }
#line 257
  if (np->owner != 0UL) {
#line 258
    if (activeClient) {
#line 258
      if (np->owner == activeClient->window) {
        {
#line 259
        FocusClient(np);
        }
      }
    }
  }
#line 264
  if (np->state.status & 8192U) {
    {
#line 265
    np->state.status &= 4294959103U;
#line 266
    SetClientFullScreen(np, (char)1);
    }
  }
#line 269
  return (np);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void MinimizeClient(ClientNode *np ) 
{ 


  {
#line 278
  if ((unsigned int )focusModel == 1U) {
#line 278
    if ((unsigned long )np == (unsigned long )activeClient) {
      {
#line 279
      FocusNextStacked(np);
      }
    }
  }
  {
#line 282
  MinimizeTransients(np);
#line 284
  UpdateTaskBar();
#line 285
  UpdatePager();
  }
#line 287
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
static void MinimizeTransients(ClientNode *np ) 
{ 
  ClientNode *tp ;
  int x ;

  {
#line 298
  if ((unsigned long )activeClient == (unsigned long )np) {
#line 299
    activeClient = (ClientNode *)((void *)0);
#line 300
    np->state.status &= 4294967294U;
  }
#line 304
  if (np->state.status & 258U) {
    {
#line 305
    XUnmapWindow(display, np->window);
#line 306
    XUnmapWindow(display, np->parent);
    }
  }
  {
#line 308
  np->state.status |= 128U;
#line 309
  np->state.status &= 4294967293U;
#line 310
  WriteState(np);
#line 313
  x = 0;
  }
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (x < 13)) {
#line 313
      goto while_break;
    }
#line 314
    tp = nodes[x];
    {
#line 314
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 314
      if (! tp) {
#line 314
        goto while_break___0;
      }
#line 315
      if (tp->owner == np->window) {
#line 315
        if (tp->state.status & 258U) {
#line 315
          if (! (tp->state.status & 128U)) {
            {
#line 318
            MinimizeTransients(tp);
            }
          }
        }
      }
#line 314
      tp = tp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 313
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void ShadeClient(ClientNode *np ) 
{ 
  int north ;
  int south ;
  int east ;
  int west ;

  {
#line 332
  if (! (np->state.border & 2U)) {
#line 333
    return;
  }
  {
#line 336
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 338
  ResetRoundedRectWindow(np->parent);
  }
#line 339
  if (np->state.status & 2U) {
    {
#line 340
    XUnmapWindow(display, np->window);
    }
  }
  {
#line 342
  np->state.status |= 256U;
#line 343
  np->state.status &= 4294967167U;
#line 344
  np->state.status &= 4294963199U;
#line 345
  np->state.status &= 4294967293U;
#line 347
  ShapeRoundedRectWindow(np->parent, (np->width + west) + east, north);
#line 348
  XResizeWindow(display, np->parent, (unsigned int )((np->width + east) + west), (unsigned int )north);
#line 350
  WriteState(np);
  }
#line 358
  return;
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void UnshadeClient(ClientNode *np ) 
{ 
  int north ;
  int south ;
  int east ;
  int west ;

  {
#line 367
  if (! (np->state.border & 2U)) {
#line 368
    return;
  }
#line 371
  if (np->state.status & 256U) {
    {
#line 372
    XMapWindow(display, np->window);
#line 373
    np->state.status |= 2U;
#line 374
    np->state.status &= 4294967039U;
    }
  }
  {
#line 377
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 379
  ResetRoundedRectWindow(np->parent);
#line 380
  ShapeRoundedRectWindow(np->parent, (np->width + west) + east, (np->height + north) + south);
#line 383
  XResizeWindow(display, np->parent, (unsigned int )((np->width + west) + east), (unsigned int )((np->height + north) + south));
#line 386
  WriteState(np);
#line 394
  RefocusClient();
#line 395
  RestackClients();
  }
#line 397
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void SetClientWithdrawn(ClientNode *np ) 
{ 


  {
#line 404
  if ((unsigned long )activeClient == (unsigned long )np) {
    {
#line 405
    activeClient = (ClientNode *)((void *)0);
#line 406
    np->state.status &= 4294967294U;
#line 407
    FocusNextStacked(np);
    }
  }
#line 410
  if (np->state.status & 2U) {
    {
#line 411
    XUnmapWindow(display, np->window);
#line 412
    XUnmapWindow(display, np->parent);
    }
  } else
#line 413
  if (np->state.status & 256U) {
    {
#line 414
    XUnmapWindow(display, np->parent);
    }
  }
  {
#line 417
  np->state.status &= 4294967039U;
#line 418
  np->state.status &= 4294967293U;
#line 419
  np->state.status &= 4294967167U;
#line 420
  np->state.status &= 4294963199U;
#line 422
  WriteState(np);
#line 423
  UpdateTaskBar();
#line 424
  UpdatePager();
  }
#line 426
  return;
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
static void RestoreTransients(ClientNode *np , char raise___0 ) 
{ 
  ClientNode *tp ;
  int x ;

  {
#line 437
  if (! (np->state.status & 2U)) {
#line 438
    if (np->state.status & 256U) {
      {
#line 439
      XMapWindow(display, np->parent);
      }
    } else {
      {
#line 441
      XMapWindow(display, np->window);
#line 442
      XMapWindow(display, np->parent);
#line 443
      np->state.status |= 2U;
      }
    }
  }
  {
#line 446
  np->state.status &= 4294967167U;
#line 447
  np->state.status &= 4294963199U;
#line 449
  WriteState(np);
#line 452
  x = 0;
  }
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (! (x < 13)) {
#line 452
      goto while_break;
    }
#line 453
    tp = nodes[x];
    {
#line 453
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 453
      if (! tp) {
#line 453
        goto while_break___0;
      }
#line 454
      if (tp->owner == np->window) {
#line 454
        if (! (tp->state.status & 258U)) {
#line 454
          if (tp->state.status & 128U) {
            {
#line 457
            RestoreTransients(tp, raise___0);
            }
          }
        }
      }
#line 453
      tp = tp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 452
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  if (raise___0) {
    {
#line 463
    RaiseClient(np);
    }
  }
#line 466
  return;
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void RestoreClient(ClientNode *np , char raise___0 ) 
{ 


  {
  {
#line 473
  RestoreTransients(np, raise___0);
#line 475
  RestackClients();
#line 476
  UpdateTaskBar();
#line 477
  UpdatePager();
  }
#line 479
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void SetClientLayer(ClientNode *np , unsigned int layer ) 
{ 
  ClientNode *tp ;
  ClientNode *next ;
  int x ;
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 489
  tmp___0 = __builtin_expect((long )(! (! (layer > 12U))), 0L);
  }
#line 489
  if (tmp___0) {
    {
#line 490
    tmp = gettext("Client %s requested an invalid layer: %d");
#line 490
    Warning((char const   *)tmp, np->name, layer);
    }
#line 491
    return;
  }
#line 494
  if (np->state.layer != layer) {
#line 497
    x = 0;
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (! (x < 13)) {
#line 497
        goto while_break;
      }
#line 498
      tp = nodes[x];
      {
#line 499
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 499
        if (! tp) {
#line 499
          goto while_break___0;
        }
#line 500
        if ((unsigned long )tp == (unsigned long )np) {
#line 500
          goto _L;
        } else
#line 500
        if (tp->owner == np->window) {
          _L: /* CIL Label */ 
#line 502
          next = tp->next;
#line 505
          if (next) {
#line 506
            next->prev = tp->prev;
          } else {
#line 508
            nodeTail[tp->state.layer] = tp->prev;
          }
#line 510
          if (tp->prev) {
#line 511
            (tp->prev)->next = next;
          } else {
#line 513
            nodes[tp->state.layer] = next;
          }
#line 517
          tp->prev = (struct ClientNode *)((void *)0);
#line 518
          tp->next = nodes[layer];
#line 519
          if (nodes[layer]) {
#line 520
            (nodes[layer])->prev = tp;
          } else {
#line 522
            nodeTail[layer] = tp;
          }
#line 524
          nodes[layer] = tp;
#line 527
          tp->state.layer = layer;
#line 530
          tp = next;
        } else {
#line 533
          tp = tp->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 497
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 538
    RestackClients();
    }
  }
#line 542
  return;
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void SetClientSticky(ClientNode *np , char isSticky ) 
{ 
  ClientNode *tp ;
  int x ;
  char old ;

  {
#line 554
  if (np->state.status & 32U) {
#line 555
    old = (char)1;
  } else {
#line 557
    old = (char)0;
  }
#line 560
  if (isSticky) {
#line 560
    if (! old) {
#line 564
      x = 0;
      {
#line 564
      while (1) {
        while_continue: /* CIL Label */ ;
#line 564
        if (! (x < 13)) {
#line 564
          goto while_break;
        }
#line 565
        tp = nodes[x];
        {
#line 565
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 565
          if (! tp) {
#line 565
            goto while_break___0;
          }
#line 566
          if ((unsigned long )tp == (unsigned long )np) {
            {
#line 567
            tp->state.status |= 32U;
#line 568
            SetCardinalAtom(tp->window, (AtomType )21, ~ 0UL);
#line 569
            WriteState(tp);
            }
          } else
#line 566
          if (tp->owner == np->window) {
            {
#line 567
            tp->state.status |= 32U;
#line 568
            SetCardinalAtom(tp->window, (AtomType )21, ~ 0UL);
#line 569
            WriteState(tp);
            }
          }
#line 565
          tp = tp->next;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 564
        x ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 560
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 574
  if (! isSticky) {
#line 574
    if (old) {
#line 578
      x = 0;
      {
#line 578
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 578
        if (! (x < 13)) {
#line 578
          goto while_break___1;
        }
#line 579
        tp = nodes[x];
        {
#line 579
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 579
          if (! tp) {
#line 579
            goto while_break___2;
          }
#line 580
          if ((unsigned long )tp == (unsigned long )np) {
            {
#line 581
            tp->state.status &= 4294967263U;
#line 582
            WriteState(tp);
            }
          } else
#line 580
          if (tp->owner == np->window) {
            {
#line 581
            tp->state.status &= 4294967263U;
#line 582
            WriteState(tp);
            }
          }
#line 579
          tp = tp->next;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 578
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 591
      SetClientDesktop(np, currentDesktop);
      }
    }
  }
#line 595
  return;
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void SetClientDesktop(ClientNode *np , unsigned int desktop ) 
{ 
  ClientNode *tp ;
  int x ;
  long tmp ;

  {
  {
#line 605
  tmp = __builtin_expect((long )(! (! (desktop >= desktopWidth * desktopHeight))),
                         0L);
  }
#line 605
  if (tmp) {
#line 606
    return;
  }
#line 609
  if (! (np->state.status & 32U)) {
#line 610
    x = 0;
    {
#line 610
    while (1) {
      while_continue: /* CIL Label */ ;
#line 610
      if (! (x < 13)) {
#line 610
        goto while_break;
      }
#line 611
      tp = nodes[x];
      {
#line 611
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 611
        if (! tp) {
#line 611
          goto while_break___0;
        }
#line 612
        if ((unsigned long )tp == (unsigned long )np) {
#line 612
          goto _L;
        } else
#line 612
        if (tp->owner == np->window) {
          _L: /* CIL Label */ 
#line 614
          tp->state.desktop = desktop;
#line 616
          if (desktop == currentDesktop) {
            {
#line 617
            ShowClient(tp);
            }
          } else {
            {
#line 619
            HideClient(tp);
            }
          }
          {
#line 622
          SetCardinalAtom(tp->window, (AtomType )21, (unsigned long )tp->state.desktop);
          }
        }
#line 611
        tp = tp->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 610
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 627
    UpdatePager();
#line 628
    UpdateTaskBar();
    }
  }
#line 631
  return;
}
}
#line 634 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void HideClient(ClientNode *np ) 
{ 


  {
#line 638
  if ((unsigned long )activeClient == (unsigned long )np) {
#line 639
    activeClient = (ClientNode *)((void *)0);
  }
#line 641
  np->state.status |= 16U;
#line 642
  if (np->state.status & 258U) {
    {
#line 643
    XUnmapWindow(display, np->parent);
    }
  }
#line 646
  return;
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void ShowClient(ClientNode *np ) 
{ 


  {
#line 653
  if (np->state.status & 16U) {
#line 654
    np->state.status &= 4294967279U;
#line 655
    if (np->state.status & 258U) {
      {
#line 656
      XMapWindow(display, np->parent);
      }
#line 657
      if (np->state.status & 1U) {
        {
#line 658
        FocusClient(np);
        }
      }
    }
  }
#line 663
  return;
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void MaximizeClient(ClientNode *np , char horiz , char vert ) 
{ 
  int north ;
  int south ;
  int east ;
  int west ;

  {
#line 673
  if (np->state.status & 8192U) {
#line 674
    return;
  }
#line 677
  if (np->state.status & 256U) {
    {
#line 678
    UnshadeClient(np);
    }
  }
  {
#line 681
  ResetRoundedRectWindow(np->parent);
#line 683
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
  }
#line 685
  if (np->state.status & 12U) {
#line 686
    np->x = np->oldx;
#line 687
    np->y = np->oldy;
#line 688
    np->width = np->oldWidth;
#line 689
    np->height = np->oldHeight;
#line 690
    np->state.status &= 4294967283U;
  } else {
    {
#line 692
    PlaceMaximizedClient(np, (int )horiz, (int )vert);
    }
  }
  {
#line 695
  ShapeRoundedRectWindow(np->parent, (np->width + east) + west, (np->height + north) + south);
#line 699
  XMoveResizeWindow(display, np->parent, np->x - west, np->y - north, (unsigned int )((np->width + east) + west),
                    (unsigned int )((np->height + north) + south));
#line 703
  XMoveResizeWindow(display, np->window, west, north, (unsigned int )np->width, (unsigned int )np->height);
#line 706
  WriteState(np);
#line 707
  SendConfigureEvent(np);
  }
#line 709
  return;
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void MaximizeClientDefault(ClientNode *np ) 
{ 
  int hmax ;
  int vmax ;

  {
#line 718
  if (np->state.border & 256U) {
#line 718
    hmax = 1;
  } else {
#line 718
    hmax = 0;
  }
#line 719
  if (np->state.border & 128U) {
#line 719
    vmax = 1;
  } else {
#line 719
    vmax = 0;
  }
  {
#line 721
  MaximizeClient(np, (char )hmax, (char )vmax);
  }
#line 723
  return;
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void SetClientFullScreen(ClientNode *np , char fullScreen ) 
{ 
  XEvent event ;
  int north ;
  int south ;
  int east ;
  int west ;
  BoundingBox box ;
  ScreenType const   *sp ;

  {
#line 736
  if (! fullScreen == ! (np->state.status & 8192U)) {
#line 737
    return;
  }
#line 740
  if (np->state.status & 256U) {
    {
#line 741
    UnshadeClient(np);
    }
  }
  {
#line 744
  ResetRoundedRectWindow(np->parent);
  }
#line 746
  if (fullScreen) {
    {
#line 748
    np->state.status |= 8192U;
#line 749
    np->state.border &= 4294967231U;
#line 750
    SetClientLayer(np, 12U);
#line 752
    np->oldx = np->x;
#line 753
    np->oldy = np->y;
#line 754
    np->oldWidth = np->width;
#line 755
    np->oldHeight = np->height;
#line 757
    sp = GetCurrentScreen(np->x, np->y);
#line 758
    GetScreenBounds(sp, & box);
#line 760
    GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 761
    box.x += west;
#line 762
    box.y += north;
#line 763
    box.width -= east + west;
#line 764
    box.height -= north + south;
#line 766
    np->x = box.x;
#line 767
    np->y = box.y;
#line 768
    np->width = box.width;
#line 769
    np->height = box.height;
#line 771
    ShapeRoundedRectWindow(np->parent, (np->width + east) + west, (np->height + north) + south);
#line 774
    XMoveResizeWindow(display, np->parent, np->x - west, np->y - north, (unsigned int )((np->width + east) + west),
                      (unsigned int )((np->height + north) + south));
#line 778
    XMoveResizeWindow(display, np->window, west, north, (unsigned int )np->width,
                      (unsigned int )np->height);
    }
  } else {
    {
#line 783
    np->state.status &= 4294959103U;
#line 784
    np->state.border |= 64U;
#line 785
    np->x = np->oldx;
#line 786
    np->y = np->oldy;
#line 787
    np->width = np->oldWidth;
#line 788
    np->height = np->oldHeight;
#line 790
    GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 791
    ShapeRoundedRectWindow(np->parent, (np->width + east) + west, (np->height + north) + south);
#line 795
    XMoveResizeWindow(display, np->parent, np->x - west, np->y - north, (unsigned int )((np->width + east) + west),
                      (unsigned int )((np->height + north) + south));
#line 800
    XMoveResizeWindow(display, np->window, west, north, (unsigned int )np->width,
                      (unsigned int )np->height);
#line 803
    event.type = 20;
#line 804
    event.xmaprequest.send_event = 1;
#line 805
    event.xmaprequest.display = display;
#line 806
    event.xmaprequest.parent = np->parent;
#line 807
    event.xmaprequest.window = np->window;
#line 808
    XSendEvent(display, rootWindow, 0, 1L << 20, & event);
#line 811
    SetClientLayer(np, 4U);
    }
  }
  {
#line 815
  WriteState(np);
#line 816
  SendConfigureEvent(np);
  }
#line 818
  return;
}
}
#line 821 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void FocusClient(ClientNode *np ) 
{ 
  ClientProtocolType protocols ;

  {
#line 827
  if (np->state.status & 16U) {
#line 828
    return;
  }
#line 831
  if ((unsigned long )activeClient != (unsigned long )np) {
#line 831
    goto _L;
  } else
#line 831
  if (! (np->state.status & 1U)) {
    _L: /* CIL Label */ 
#line 833
    if (activeClient) {
      {
#line 834
      activeClient->state.status &= 4294967294U;
#line 835
      DrawBorder((struct ClientNode  const  *)activeClient, (XExposeEvent const   *)((void *)0));
      }
    }
    {
#line 837
    np->state.status |= 1U;
#line 838
    activeClient = np;
#line 840
    DrawBorder((struct ClientNode  const  *)np, (XExposeEvent const   *)((void *)0));
#line 841
    UpdatePager();
#line 842
    UpdateTaskBar();
    }
  }
#line 846
  if (np->state.status & 2U) {
    {
#line 847
    UpdateClientColormap(np);
#line 848
    SetWindowAtom(rootWindow, (AtomType )16, np->window);
#line 849
    protocols = ReadWMProtocols(np->window);
#line 850
    XSetInputFocus(display, np->window, 1, eventTime);
    }
#line 851
    if ((unsigned int )protocols & 2U) {
      {
#line 852
      SendClientMessage(np->window, (AtomType )4, (AtomType )6);
      }
    }
  } else {
    {
#line 855
    XSetInputFocus(display, rootWindow, 1, eventTime);
    }
  }
#line 858
  return;
}
}
#line 862 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void RefocusClient(void) 
{ 


  {
#line 864
  if (activeClient) {
    {
#line 865
    FocusClient(activeClient);
    }
  }
#line 868
  return;
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void DeleteClient(ClientNode *np ) 
{ 
  ClientProtocolType protocols ;

  {
  {
#line 877
  protocols = ReadWMProtocols(np->window);
  }
#line 878
  if ((unsigned int )protocols & 1U) {
    {
#line 879
    SendClientMessage(np->window, (AtomType )4, (AtomType )5);
    }
  } else {
    {
#line 882
    KillClient(np);
    }
  }
#line 885
  return;
}
}
#line 888 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
static void KillClientHandler(ClientNode *np ) 
{ 


  {
#line 892
  if ((unsigned long )np == (unsigned long )activeClient) {
    {
#line 893
    FocusNextStacked(np);
    }
  }
  {
#line 896
  XGrabServer(display);
#line 897
  XSync(display, 0);
#line 899
  XKillClient(display, np->window);
#line 901
  XSync(display, 1);
#line 902
  XUngrabServer(display);
#line 904
  RemoveClient(np);
  }
#line 906
  return;
}
}
#line 909 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void KillClient(ClientNode *np ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 913
  tmp = gettext("This may cause data to be lost!");
#line 913
  tmp___0 = gettext("Kill this window?");
#line 913
  ShowConfirmDialog(np, & KillClientHandler, tmp___0, tmp, (void *)0);
  }
#line 917
  return;
}
}
#line 920 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void RaiseClient(ClientNode *np ) 
{ 
  ClientNode *tp ;
  ClientNode *next ;
  int x ;

  {
#line 927
  if ((unsigned long )nodes[np->state.layer] != (unsigned long )np) {
#line 931
    (np->prev)->next = np->next;
#line 932
    if (np->next) {
#line 933
      (np->next)->prev = np->prev;
    } else {
#line 935
      nodeTail[np->state.layer] = np->prev;
    }
#line 937
    np->next = nodes[np->state.layer];
#line 938
    (nodes[np->state.layer])->prev = np;
#line 939
    np->prev = (struct ClientNode *)((void *)0);
#line 940
    nodes[np->state.layer] = np;
#line 943
    x = 0;
    {
#line 943
    while (1) {
      while_continue: /* CIL Label */ ;
#line 943
      if (! (x < 13)) {
#line 943
        goto while_break;
      }
#line 944
      tp = nodes[x];
      {
#line 944
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 944
        if (! tp) {
#line 944
          goto while_break___0;
        }
#line 945
        if (tp->owner == np->window) {
#line 945
          if (tp->prev) {
#line 947
            next = tp->next;
#line 949
            (tp->prev)->next = tp->next;
#line 950
            if (tp->next) {
#line 951
              (tp->next)->prev = tp->prev;
            } else {
#line 953
              nodeTail[tp->state.layer] = tp->prev;
            }
#line 955
            tp->next = nodes[tp->state.layer];
#line 956
            (nodes[tp->state.layer])->prev = tp;
#line 957
            tp->prev = (struct ClientNode *)((void *)0);
#line 958
            nodes[tp->state.layer] = tp;
#line 960
            tp = next;
          }
        }
#line 966
        if (! tp) {
#line 967
          goto while_break___0;
        }
#line 944
        tp = tp->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 943
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 972
    RestackClients();
    }
  }
#line 976
  return;
}
}
#line 979 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void LowerClient(ClientNode *np ) 
{ 
  ClientNode *tp ;

  {
#line 985
  if ((unsigned long )nodeTail[np->state.layer] != (unsigned long )np) {
#line 990
    if (np->prev) {
#line 991
      (np->prev)->next = np->next;
    } else {
#line 993
      nodes[np->state.layer] = np->next;
    }
    {
#line 995
    (np->next)->prev = np->prev;
#line 998
    tp = nodeTail[np->state.layer];
#line 999
    nodeTail[np->state.layer] = np;
#line 1000
    tp->next = np;
#line 1001
    np->prev = tp;
#line 1002
    np->next = (struct ClientNode *)((void *)0);
#line 1004
    RestackClients();
    }
  }
#line 1008
  return;
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void RestackClients(void) 
{ 
  TrayType *tp ;
  ClientNode *np ;
  unsigned int layer ;
  unsigned int index ;
  int trayCount___0 ;
  Window *stack ;
  unsigned int opacity ;
  unsigned int temp ;
  int isFirst ;
  void *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 1023
  trayCount___0 = GetTrayCount();
#line 1024
  tmp = __builtin_alloca((unsigned long )(clientCount + trayCount___0) * sizeof(Window ));
#line 1024
  stack = (Window *)tmp;
#line 1027
  index = 0U;
#line 1028
  layer = 12U;
#line 1029
  isFirst = 1;
#line 1030
  opacity = maxInactiveOpacity;
  }
  {
#line 1031
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1033
    np = nodes[layer];
    {
#line 1033
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1033
      if (! np) {
#line 1033
        goto while_break___0;
      }
#line 1034
      if (np->state.status & 258U) {
#line 1034
        if (! (np->state.status & 16U)) {
#line 1036
          tmp___0 = index;
#line 1036
          index ++;
#line 1036
          *(stack + tmp___0) = np->parent;
#line 1037
          if (isFirst) {
#line 1038
            if (! (np->state.status & 16384U)) {
#line 1038
              if (np->state.opacity != activeOpacity) {
                {
#line 1040
                np->state.opacity = activeOpacity;
#line 1041
                WriteState(np);
                }
              }
            }
#line 1043
            isFirst = 0;
          } else
#line 1044
          if (! (np->state.status & 16384U)) {
#line 1045
            if (np->state.opacity != opacity) {
              {
#line 1046
              np->state.opacity = opacity;
#line 1047
              WriteState(np);
              }
            }
#line 1049
            temp = opacity - deltaInactiveOpacity;
#line 1050
            if (temp < minInactiveOpacity) {
#line 1051
              opacity = minInactiveOpacity;
            } else
#line 1050
            if (temp > opacity) {
#line 1051
              opacity = minInactiveOpacity;
            } else {
#line 1053
              opacity = temp;
            }
          }
        }
      }
#line 1033
      np = np->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1059
    tp = GetTrays();
    }
    {
#line 1059
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1059
      if (! tp) {
#line 1059
        goto while_break___1;
      }
#line 1060
      if (layer == (unsigned int )tp->layer) {
#line 1061
        tmp___1 = index;
#line 1061
        index ++;
#line 1061
        *(stack + tmp___1) = tp->window;
      }
#line 1059
      tp = tp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1065
    if (layer == 0U) {
#line 1066
      goto while_break;
    }
#line 1068
    layer --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1072
  XRestackWindows(display, stack, (int )index);
#line 1076
  UpdateNetClientList();
  }
#line 1078
  return;
}
}
#line 1081 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void SendClientMessage(Window w , AtomType type , AtomType message ) 
{ 
  XEvent event ;
  int status ;
  long tmp ;

  {
  {
#line 1086
  memset((void *)(& event), 0, sizeof(event));
#line 1087
  event.xclient.type = 33;
#line 1088
  event.xclient.window = w;
#line 1089
  event.xclient.message_type = atoms[type];
#line 1090
  event.xclient.format = 32;
#line 1091
  event.xclient.data.l[0] = (long )atoms[message];
#line 1092
  event.xclient.data.l[1] = (long )eventTime;
#line 1094
  status = XSendEvent(display, w, 0, 0L, & event);
#line 1095
  tmp = __builtin_expect((long )(! (! (status == 0))), 0L);
  }
#line 1095
  if (tmp) {
    {
#line 1096
    Debug("SendClientMessage failed");
    }
  }
#line 1099
  return;
}
}
#line 1168 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void RemoveClient(ClientNode *np ) 
{ 
  ColormapNode *cp ;

  {
  {
#line 1176
  XGrabServer(display);
  }
#line 1179
  if (np->next) {
#line 1180
    (np->next)->prev = np->prev;
  } else {
#line 1182
    nodeTail[np->state.layer] = np->prev;
  }
#line 1184
  if (np->prev) {
#line 1185
    (np->prev)->next = np->next;
  } else {
#line 1187
    nodes[np->state.layer] = np->next;
  }
  {
#line 1189
  clientCount --;
#line 1190
  XDeleteContext(display, np->window, clientContext);
#line 1191
  XDeleteContext(display, np->parent, frameContext);
  }
#line 1194
  if ((unsigned long )activeClient == (unsigned long )np) {
#line 1194
    if (! shouldExit) {
      {
#line 1195
      FocusNextStacked(np);
      }
    }
  }
#line 1197
  if ((unsigned long )activeClient == (unsigned long )np) {
    {
#line 1201
    SetWindowAtom(rootWindow, (AtomType )16, 0UL);
#line 1202
    activeClient = (ClientNode *)((void *)0);
#line 1204
    XSetInputFocus(display, rootWindow, 1, eventTime);
    }
  }
#line 1210
  if (shouldExit) {
#line 1210
    if (! (np->state.status & 512U)) {
#line 1211
      if (np->state.status & 12U) {
        {
#line 1212
        np->x = np->oldx;
#line 1213
        np->y = np->oldy;
#line 1214
        np->width = np->oldWidth;
#line 1215
        np->height = np->oldHeight;
#line 1216
        XMoveResizeWindow(display, np->window, np->x, np->y, (unsigned int )np->width,
                          (unsigned int )np->height);
        }
      }
      {
#line 1219
      GravitateClient(np, 1);
      }
#line 1220
      if (! (np->state.status & 2U)) {
#line 1220
        if (np->state.status & 384U) {
          {
#line 1222
          XMapWindow(display, np->window);
          }
        }
      }
      {
#line 1224
      XUngrabButton(display, 0U, (unsigned int )(1 << 15), np->window);
#line 1225
      XReparentWindow(display, np->window, rootWindow, np->x, np->y);
#line 1226
      XRemoveFromSaveSet(display, np->window);
      }
    }
  }
#line 1230
  if (np->parent) {
    {
#line 1231
    XDestroyWindow(display, np->parent);
    }
  }
#line 1234
  if (np->name) {
    {
#line 1235
    XFree((void *)np->name);
    }
  }
#line 1237
  if (np->instanceName) {
    {
#line 1238
    XFree((void *)np->instanceName);
    }
  }
#line 1240
  if (np->className) {
    {
#line 1241
    XFree((void *)np->className);
    }
  }
  {
#line 1244
  RemoveClientFromTaskBar(np);
#line 1245
  RemoveClientStrut(np);
#line 1246
  UpdatePager();
  }
  {
#line 1248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1248
    if (! np->colormaps) {
#line 1248
      goto while_break;
    }
    {
#line 1249
    cp = (np->colormaps)->next;
#line 1250
    free((void *)np->colormaps);
#line 1251
    np->colormaps = cp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1254
  DestroyIcon(np->icon);
#line 1256
  free((void *)np);
#line 1258
  XUngrabServer(display);
#line 1260
  RestackClients();
  }
#line 1262
  return;
}
}
#line 1265 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
ClientNode *GetActiveClient(void) 
{ 


  {
#line 1267
  return (activeClient);
}
}
#line 1272 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
ClientNode *FindClientByWindow(Window w ) 
{ 
  ClientNode *np ;
  ClientNode *tmp ;
  int tmp___0 ;

  {
  {
#line 1276
  tmp___0 = XFindContext(display, w, clientContext, (XPointer *)((void *)(& np)));
  }
#line 1276
  if (tmp___0) {
    {
#line 1279
    tmp = FindClientByParent(w);
    }
#line 1279
    return (tmp);
  } else {
#line 1277
    return (np);
  }
}
}
#line 1285 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
ClientNode *FindClientByParent(Window p ) 
{ 
  ClientNode *np ;
  int tmp ;

  {
  {
#line 1289
  tmp = XFindContext(display, p, frameContext, (XPointer *)((void *)(& np)));
  }
#line 1289
  if (tmp) {
#line 1292
    return ((ClientNode *)((void *)0));
  } else {
#line 1290
    return (np);
  }
}
}
#line 1298 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
static void ReparentClient(ClientNode *np , char notOwner ) 
{ 
  XSetWindowAttributes attr ;
  int attrMask ;
  int x ;
  int y ;
  int width ;
  int height ;
  int north ;
  int south ;
  int east ;
  int west ;

  {
#line 1307
  if (notOwner) {
    {
#line 1308
    XAddToSaveSet(display, np->window);
#line 1310
    attr.event_mask = ((((1L << 4) | (1L << 23)) | (1L << 22)) | (1L << 1)) | (1L << 17);
#line 1316
    attr.do_not_propagate_mask = 0L;
#line 1317
    XChangeWindowAttributes(display, np->window, (unsigned long )((1L << 11) | (1L << 12)),
                            & attr);
    }
  }
  {
#line 1321
  XGrabButton(display, 0U, (unsigned int )(1 << 15), np->window, 1, (unsigned int )(1L << 2),
              0, 1, (Window )0L, (Cursor )0L);
#line 1323
  GrabKeys(np);
#line 1325
  attrMask = 0;
#line 1327
  attrMask = (int )((long )attrMask | 1L);
#line 1328
  attr.background_pixmap = (Pixmap )1L;
#line 1332
  attrMask = (int )((long )attrMask | (1L << 11));
#line 1333
  attr.event_mask = (((((((((1L << 2) | (1L << 3)) | (1L << 15)) | (1L << 6)) | (1L << 20)) | (1L << 19)) | (1L << 4)) | (1L << 5)) | 1L) | (1L << 1);
#line 1345
  attrMask = (int )((long )attrMask | (1L << 12));
#line 1346
  attr.do_not_propagate_mask = (1L << 2) | (1L << 3);
#line 1348
  attrMask = (int )((long )attrMask | (1L << 1));
#line 1349
  attr.background_pixel = colors[3];
#line 1351
  x = np->x;
#line 1352
  y = np->y;
#line 1353
  width = np->width;
#line 1354
  height = np->height;
#line 1355
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 1356
  x -= west;
#line 1357
  y -= north;
#line 1358
  width += east + west;
#line 1359
  height += north + south;
#line 1362
  np->parent = XCreateWindow(display, rootWindow, x, y, (unsigned int )width, (unsigned int )height,
                             0U, rootDepth, 1U, rootVisual, (unsigned long )attrMask,
                             & attr);
#line 1367
  attrMask = (int )(1L << 12);
#line 1368
  attr.do_not_propagate_mask = (((((1L << 2) | (1L << 3)) | (1L << 6)) | (1L << 13)) | 1L) | (1L << 1);
#line 1375
  XChangeWindowAttributes(display, np->window, (unsigned long )attrMask, & attr);
#line 1376
  XSetWindowBorderWidth(display, np->window, 0U);
#line 1379
  XReparentWindow(display, np->window, np->parent, west, north);
  }
#line 1388
  return;
}
}
#line 1411 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void SendConfigureEvent(ClientNode *np ) 
{ 
  XConfigureEvent event ;
  ScreenType const   *sp ;

  {
#line 1418
  event.type = 22;
#line 1419
  event.event = np->window;
#line 1420
  event.window = np->window;
#line 1422
  if (np->state.status & 8192U) {
    {
#line 1423
    sp = GetCurrentScreen(np->x, np->y);
#line 1424
    event.x = (int )sp->x;
#line 1425
    event.y = (int )sp->y;
#line 1426
    event.width = (int )sp->width;
#line 1427
    event.height = (int )sp->height;
    }
  } else {
#line 1429
    event.x = np->x;
#line 1430
    event.y = np->y;
#line 1431
    event.width = np->width;
#line 1432
    event.height = np->height;
  }
  {
#line 1435
  event.border_width = 0;
#line 1436
  event.above = (Window )0L;
#line 1437
  event.override_redirect = 0;
#line 1439
  XSendEvent(display, np->window, 0, 1L << 17, (XEvent *)(& event));
  }
#line 1442
  return;
}
}
#line 1449 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void UpdateClientColormap(ClientNode *np ) 
{ 
  XWindowAttributes attr ;
  ColormapNode *cp ;
  int wasInstalled ;
  int tmp ;

  {
#line 1457
  if ((unsigned long )np == (unsigned long )activeClient) {
#line 1459
    wasInstalled = 0;
#line 1460
    cp = np->colormaps;
    {
#line 1461
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1461
      if (! cp) {
#line 1461
        goto while_break;
      }
      {
#line 1462
      tmp = XGetWindowAttributes(display, cp->window, & attr);
      }
#line 1462
      if (tmp) {
#line 1463
        if (attr.colormap != 0UL) {
#line 1464
          if (attr.colormap == np->cmap) {
#line 1465
            wasInstalled = 1;
          }
          {
#line 1467
          XInstallColormap(display, attr.colormap);
          }
        }
      }
#line 1470
      cp = cp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1473
    if (! wasInstalled) {
#line 1473
      if (np->cmap != 0UL) {
        {
#line 1474
        XInstallColormap(display, np->cmap);
        }
      }
    }
  }
#line 1479
  return;
}
}
#line 1482 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void SetActiveClientOpacity(char const   *str___0 ) 
{ 
  double temp ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1488
  temp = atof(str___0);
  }
#line 1489
  if (temp <= 0.0) {
#line 1489
    tmp___0 = 1;
  } else
#line 1489
  if (temp > 1.0) {
#line 1489
    tmp___0 = 1;
  } else {
#line 1489
    tmp___0 = 0;
  }
  {
#line 1489
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 1489
  if (tmp___1) {
    {
#line 1490
    tmp = gettext("invalid active client opacity: %s");
#line 1490
    Warning((char const   *)tmp, str___0);
#line 1491
    activeOpacity = 4294967295U;
    }
  } else {
#line 1493
    activeOpacity = (unsigned int )(1.0 * (double )4294967295U);
  }
#line 1496
  return;
}
}
#line 1499 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/client.c"
void SetInactiveClientOpacity(char const   *str___0 ) 
{ 
  double temp ;
  char const   *str_u ;
  char const   *str_d ;
  unsigned int first ;
  unsigned int second ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
  {
#line 1510
  maxInactiveOpacity = (unsigned int )(0.9 * (double )4294967295U);
#line 1511
  minInactiveOpacity = (unsigned int )(0.5 * (double )4294967295U);
#line 1512
  deltaInactiveOpacity = (unsigned int )(0.1 * (double )4294967295U);
#line 1515
  temp = atof(str___0);
  }
#line 1516
  if (temp < 0.0) {
#line 1516
    tmp___0 = 1;
  } else
#line 1516
  if (temp > 1.0) {
#line 1516
    tmp___0 = 1;
  } else {
#line 1516
    tmp___0 = 0;
  }
  {
#line 1516
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 1516
  if (tmp___1) {
    {
#line 1517
    tmp = gettext("invalid inactive client opacity: %s");
#line 1517
    Warning((char const   *)tmp, str___0);
    }
#line 1518
    return;
  }
  {
#line 1520
  first = (unsigned int )(temp * (double )4294967295U);
#line 1521
  second = first;
#line 1524
  tmp___2 = strchr(str___0, ':');
#line 1524
  str_u = (char const   *)tmp___2;
  }
#line 1525
  if (str_u) {
    {
#line 1528
    temp = atof(str_u + 1);
    }
#line 1529
    if (temp < 0.0) {
#line 1529
      tmp___4 = 1;
    } else
#line 1529
    if (temp > 1.0) {
#line 1529
      tmp___4 = 1;
    } else {
#line 1529
      tmp___4 = 0;
    }
    {
#line 1529
    tmp___5 = __builtin_expect((long )tmp___4, 0L);
    }
#line 1529
    if (tmp___5) {
      {
#line 1530
      tmp___3 = gettext("invalid inactive client opacity: %s");
#line 1530
      Warning((char const   *)tmp___3, str___0);
      }
#line 1531
      return;
    }
    {
#line 1533
    second = (unsigned int )(temp * (double )4294967295U);
#line 1536
    tmp___6 = strchr(str_u + 1, ':');
#line 1536
    str_d = (char const   *)tmp___6;
    }
#line 1537
    if (str_d) {
      {
#line 1538
      temp = atof(str_d + 1);
      }
#line 1539
      if (temp <= 0.0) {
#line 1539
        tmp___8 = 1;
      } else
#line 1539
      if (temp > 1.0) {
#line 1539
        tmp___8 = 1;
      } else {
#line 1539
        tmp___8 = 0;
      }
      {
#line 1539
      tmp___9 = __builtin_expect((long )tmp___8, 0L);
      }
#line 1539
      if (tmp___9) {
        {
#line 1540
        tmp___7 = gettext("invalid inactive client opacity delta: %s");
#line 1540
        Warning((char const   *)tmp___7, str___0);
        }
#line 1541
        return;
      }
#line 1543
      deltaInactiveOpacity = (unsigned int )(temp * (double )4294967295U);
    }
  }
#line 1549
  if (first > second) {
#line 1550
    minInactiveOpacity = second;
#line 1551
    maxInactiveOpacity = first;
  } else {
#line 1553
    minInactiveOpacity = first;
#line 1554
    maxInactiveOpacity = second;
  }
#line 1557
  return;
}
}
#line 2688 "/usr/include/X11/Xlib.h"
extern int XGetWindowProperty(Display * , Window  , Atom  , long  , long  , int  ,
                              Atom  , Atom * , int * , unsigned long * , unsigned long * ,
                              unsigned char ** ) ;
#line 2846
extern int XMoveWindow(Display * , Window  , int  , int  ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.h"
void InitializePlacement(void) ;
#line 27
void StartupPlacement(void) ;
#line 28
void ShutdownPlacement(void) ;
#line 29
void DestroyPlacement(void) ;
#line 66
void GetGravityDelta(struct ClientNode  const  *np , int *x , int *y ) ;
#line 71
void ConstrainSize(struct ClientNode *np ) ;
#line 84
void SubtractTrayBounds(struct TrayType  const  *tp , BoundingBox *box , unsigned int layer ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.h"
ScreenType const   *GetMouseScreen(void) ;
#line 50
int GetScreenCount(void) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
unsigned int desktopCount ;
#line 42
int borderWidth ;
#line 43
int titleHeight ;
#line 25 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
static Strut *struts  =    (Strut *)((void *)0);
#line 26 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
static Strut *strutsTail  =    (Strut *)((void *)0);
#line 30 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
static int *cascadeOffsets  =    (int *)((void *)0);
#line 32
static void SubtractStrutBounds(BoundingBox *box ) ;
#line 33
static void SubtractBounds(BoundingBox const   *src , BoundingBox *dest ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void InitializePlacement(void) 
{ 


  {
#line 37
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void StartupPlacement(void) 
{ 
  int count ;
  int x ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 45
  tmp = GetScreenCount();
#line 45
  count = (int )(desktopCount * (unsigned int )tmp);
#line 46
  tmp___0 = malloc((unsigned long )count * sizeof(int ));
#line 46
  cascadeOffsets = (int *)tmp___0;
#line 48
  x = 0;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (x < count)) {
#line 48
      goto while_break;
    }
#line 49
    *(cascadeOffsets + x) = borderWidth + titleHeight;
#line 48
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void ShutdownPlacement(void) 
{ 
  Strut *sp ;

  {
  {
#line 59
  free((void *)cascadeOffsets);
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! struts) {
#line 61
      goto while_break;
    }
    {
#line 62
    sp = struts->next;
#line 63
    free((void *)struts);
#line 64
    struts = sp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  strutsTail = (Strut *)((void *)0);
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void DestroyPlacement(void) 
{ 


  {
#line 72
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void RemoveClientStrut(struct ClientNode *np ) 
{ 
  Strut *sp ;

  {
#line 79
  sp = struts;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! sp) {
#line 80
      goto while_break;
    }
#line 81
    if ((unsigned long )sp->client == (unsigned long )np) {
#line 82
      if (sp->prev) {
#line 83
        (sp->prev)->next = sp->next;
      } else {
#line 85
        struts = sp->next;
      }
#line 87
      if (sp->next) {
#line 88
        (sp->next)->prev = sp->prev;
      } else {
#line 90
        strutsTail = sp->prev;
      }
      {
#line 92
      free((void *)sp);
#line 93
      sp = struts;
      }
    } else {
#line 95
      sp = sp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void ReadClientStrut(struct ClientNode *np ) 
{ 
  BoundingBox box ;
  Strut *sp ;
  int status ;
  Atom actualType ;
  int actualFormat ;
  unsigned long count ;
  unsigned long bytesLeft ;
  unsigned char *value ;
  long *lvalue ;
  long leftWidth ;
  long rightWidth ;
  long topHeight ;
  long bottomHeight ;
  long leftStart ;
  long rightStart ;
  long topStart ;
  long bottomStart ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 117
  RemoveClientStrut(np);
#line 119
  box.x = 0;
#line 120
  box.y = 0;
#line 121
  box.width = 0;
#line 122
  box.height = 0;
#line 130
  status = XGetWindowProperty(display, np->window, atoms[56], 0L, 12L, 0, (Atom )6,
                              & actualType, & actualFormat, & count, & bytesLeft,
                              & value);
  }
#line 133
  if (status == 0) {
#line 134
    if (count == 12UL) {
#line 135
      lvalue = (long *)value;
#line 136
      leftWidth = *(lvalue + 0);
#line 137
      rightWidth = *(lvalue + 1);
#line 138
      topHeight = *(lvalue + 2);
#line 139
      bottomHeight = *(lvalue + 3);
#line 140
      leftStart = *(lvalue + 4);
#line 141
      rightStart = *(lvalue + 6);
#line 142
      topStart = *(lvalue + 8);
#line 143
      bottomStart = *(lvalue + 10);
#line 145
      if (leftWidth > 0L) {
#line 146
        box.width = (int )leftWidth;
#line 147
        box.x = (int )leftStart;
      }
#line 150
      if (rightWidth > 0L) {
#line 151
        box.width = (int )rightWidth;
#line 152
        box.x = (int )rightStart;
      }
#line 155
      if (topHeight > 0L) {
#line 156
        box.height = (int )topHeight;
#line 157
        box.y = (int )topStart;
      }
#line 160
      if (bottomHeight > 0L) {
#line 161
        box.height = (int )bottomHeight;
#line 162
        box.y = (int )bottomStart;
      }
#line 165
      if (box.width == 0) {
#line 165
        if (box.height > 0) {
#line 166
          box.width = rootWidth;
        }
      }
#line 168
      if (box.height == 0) {
#line 168
        if (box.width > 0) {
#line 169
          box.height = rootHeight;
        }
      }
      {
#line 172
      tmp = malloc(sizeof(Strut ));
#line 172
      sp = (Strut *)tmp;
#line 173
      sp->client = np;
#line 174
      sp->box = box;
#line 175
      sp->prev = (struct Strut *)((void *)0);
#line 176
      sp->next = struts;
      }
#line 177
      if (struts) {
#line 178
        struts->prev = sp;
      } else {
#line 180
        strutsTail = sp;
      }
#line 182
      struts = sp;
    }
    {
#line 185
    XFree((void *)value);
    }
#line 186
    return;
  }
  {
#line 191
  status = XGetWindowProperty(display, np->window, atoms[57], 0L, 4L, 0, (Atom )6,
                              & actualType, & actualFormat, & count, & bytesLeft,
                              & value);
  }
#line 194
  if (status == 0) {
#line 195
    if (count == 4UL) {
#line 196
      lvalue = (long *)value;
#line 197
      leftWidth = *(lvalue + 0);
#line 198
      rightWidth = *(lvalue + 1);
#line 199
      topHeight = *(lvalue + 2);
#line 200
      bottomHeight = *(lvalue + 3);
#line 202
      if (leftWidth > 0L) {
#line 203
        box.x = 0;
#line 204
        box.width = (int )leftWidth;
      }
#line 207
      if (rightWidth > 0L) {
#line 208
        box.x = (int )((long )rootWidth - rightWidth);
#line 209
        box.width = (int )rightWidth;
      }
#line 212
      if (topHeight > 0L) {
#line 213
        box.y = 0;
#line 214
        box.height = (int )topHeight;
      }
#line 217
      if (bottomHeight > 0L) {
#line 218
        box.y = (int )((long )rootHeight - bottomHeight);
#line 219
        box.height = (int )bottomHeight;
      }
      {
#line 222
      tmp___0 = malloc(sizeof(Strut ));
#line 222
      sp = (Strut *)tmp___0;
#line 223
      sp->client = np;
#line 224
      sp->box = box;
#line 225
      sp->prev = (struct Strut *)((void *)0);
#line 226
      sp->next = struts;
      }
#line 227
      if (struts) {
#line 228
        struts->prev = sp;
      } else {
#line 230
        strutsTail = sp;
      }
#line 232
      struts = sp;
    }
    {
#line 235
    XFree((void *)value);
    }
#line 236
    return;
  }
#line 239
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void GetScreenBounds(struct ScreenType  const  *sp , BoundingBox *box ) 
{ 


  {
#line 244
  box->x = (int )sp->x;
#line 245
  box->y = (int )sp->y;
#line 246
  box->width = (int )sp->width;
#line 247
  box->height = (int )sp->height;
#line 249
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
static void SubtractBounds(BoundingBox const   *src , BoundingBox *dest ) 
{ 
  BoundingBox boxes[4] ;

  {
#line 256
  if (src->x + src->width <= (int const   )dest->x) {
#line 257
    return;
  }
#line 259
  if (src->y + src->height <= (int const   )dest->y) {
#line 260
    return;
  }
#line 262
  if (dest->x + dest->width <= (int )src->x) {
#line 263
    return;
  }
#line 265
  if (dest->y + dest->height <= (int )src->y) {
#line 266
    return;
  }
#line 279
  boxes[0] = *dest;
#line 280
  boxes[0].x = (int )(src->x + src->width);
#line 281
  boxes[0].width = (dest->x + dest->width) - boxes[0].x;
#line 284
  boxes[1] = *dest;
#line 285
  boxes[1].y = (int )(src->y + src->height);
#line 286
  boxes[1].height = (dest->y + dest->height) - boxes[1].y;
#line 289
  boxes[2] = *dest;
#line 290
  boxes[2].width = (int )(src->x - (int const   )dest->x);
#line 293
  boxes[3] = *dest;
#line 294
  boxes[3].height = (int )(src->y - (int const   )dest->y);
#line 297
  if (boxes[0].width * boxes[0].height < boxes[1].width * boxes[1].height) {
#line 298
    boxes[0] = boxes[1];
  }
#line 302
  if (boxes[2].width * boxes[2].height < boxes[3].width * boxes[3].height) {
#line 303
    boxes[2] = boxes[3];
  }
#line 307
  if (boxes[0].width * boxes[0].height < boxes[2].width * boxes[2].height) {
#line 308
    *dest = boxes[2];
  } else {
#line 310
    *dest = boxes[0];
  }
#line 313
  return;
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void SubtractTrayBounds(struct TrayType  const  *tp , BoundingBox *box , unsigned int layer ) 
{ 
  BoundingBox src ;
  BoundingBox last___0 ;

  {
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! tp) {
#line 322
      goto while_break;
    }
#line 324
    if ((unsigned int const   )tp->layer > (unsigned int const   )layer) {
#line 324
      if (! tp->autoHide) {
#line 326
        src.x = (int )tp->x;
#line 327
        if (src.x < 0) {
#line 328
          src.x = rootWidth - src.x;
        }
#line 330
        src.y = (int )tp->y;
#line 331
        if (src.y < 0) {
#line 332
          src.y = rootHeight - src.y;
        }
        {
#line 334
        src.width = (int )tp->width;
#line 335
        src.height = (int )tp->height;
#line 337
        last___0 = *box;
#line 338
        SubtractBounds((BoundingBox const   *)(& src), box);
        }
#line 339
        if (box->width * box->height <= 0) {
#line 340
          *box = last___0;
#line 341
          goto while_break;
        }
      }
    }
#line 322
    tp = (struct TrayType  const  *)tp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  return;
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
static void SubtractStrutBounds(BoundingBox *box ) 
{ 
  Strut *sp ;
  BoundingBox last___0 ;

  {
#line 356
  sp = struts;
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! sp) {
#line 356
      goto while_break;
    }
#line 357
    if ((sp->client)->state.desktop == currentDesktop) {
#line 357
      goto _L;
    } else
#line 357
    if ((sp->client)->state.status & 32U) {
      _L: /* CIL Label */ 
      {
#line 359
      last___0 = *box;
#line 360
      SubtractBounds((BoundingBox const   *)(& sp->box), box);
      }
#line 361
      if (box->width * box->height <= 0) {
#line 362
        *box = last___0;
#line 363
        goto while_break;
      }
    }
#line 356
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void PlaceClient(struct ClientNode *np , int alreadyMapped ) 
{ 
  BoundingBox box ;
  int north ;
  int south ;
  int east ;
  int west ;
  ScreenType const   *sp ;
  int cascadeIndex ;
  int overflow ;
  TrayType *tmp ;

  {
  {
#line 381
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
  }
#line 383
  if (np->x + np->width > rootWidth) {
#line 384
    overflow = 1;
  } else
#line 383
  if (np->y + np->height > rootHeight) {
#line 384
    overflow = 1;
  } else {
#line 386
    overflow = 0;
  }
  {
#line 389
  sp = GetMouseScreen();
#line 390
  GetScreenBounds(sp, & box);
  }
#line 392
  if (! overflow) {
#line 392
    if (alreadyMapped) {
      {
#line 396
      GravitateClient(np, 0);
      }
    } else
#line 392
    if (! (np->state.status & 1024U)) {
#line 392
      if (np->sizeFlags & ((1L << 2) | 1L)) {
        {
#line 396
        GravitateClient(np, 0);
        }
      } else {
#line 392
        goto _L;
      }
    } else {
#line 392
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 400
    tmp = GetTrays();
#line 400
    SubtractTrayBounds((struct TrayType  const  *)tmp, & box, np->state.layer);
#line 401
    SubtractStrutBounds(& box);
#line 403
    cascadeIndex = (int )((unsigned int )sp->index * desktopCount + currentDesktop);
#line 406
    np->x = (box.x + west) + *(cascadeOffsets + cascadeIndex);
#line 407
    np->y = (box.y + north) + *(cascadeOffsets + cascadeIndex);
#line 408
    *(cascadeOffsets + cascadeIndex) += borderWidth + titleHeight;
#line 411
    overflow = 0;
    }
#line 412
    if ((np->x + np->width) - box.x > box.width) {
#line 413
      overflow = 1;
    } else
#line 414
    if ((np->y + np->height) - box.y > box.height) {
#line 415
      overflow = 1;
    }
#line 418
    if (overflow) {
#line 420
      *(cascadeOffsets + cascadeIndex) = borderWidth + titleHeight;
#line 421
      np->x = (box.x + west) + *(cascadeOffsets + cascadeIndex);
#line 422
      np->y = (box.y + north) + *(cascadeOffsets + cascadeIndex);
#line 425
      overflow = 0;
#line 426
      if ((np->x + np->width) - box.x > box.width) {
#line 427
        overflow = 1;
      } else
#line 428
      if ((np->y + np->height) - box.y > box.height) {
#line 429
        overflow = 1;
      }
#line 433
      if (overflow) {
#line 434
        np->x = box.x + west;
#line 435
        np->y = box.y + north;
      } else {
#line 437
        *(cascadeOffsets + cascadeIndex) += borderWidth + titleHeight;
      }
    }
  }
#line 444
  if (np->state.status & 8192U) {
    {
#line 445
    XMoveWindow(display, np->parent, (int )sp->x, (int )sp->y);
    }
  } else {
    {
#line 447
    XMoveWindow(display, np->parent, np->x - west, np->y - north);
    }
  }
#line 450
  return;
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void ConstrainSize(struct ClientNode *np ) 
{ 
  BoundingBox box ;
  ScreenType const   *sp ;
  int north ;
  int south ;
  int east ;
  int west ;
  int ratio ;
  int minr ;
  int maxr ;
  TrayType *tmp ;

  {
  {
#line 463
  sp = GetCurrentScreen(np->x, np->y);
  }
#line 464
  if (np->width < (int )sp->width) {
#line 464
    if (np->height < (int )sp->height) {
#line 465
      return;
    }
  }
  {
#line 469
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 471
  GetScreenBounds(sp, & box);
#line 472
  tmp = GetTrays();
#line 472
  SubtractTrayBounds((struct TrayType  const  *)tmp, & box, np->state.layer);
#line 473
  SubtractStrutBounds(& box);
#line 475
  box.x += west;
#line 476
  box.y += north;
#line 477
  box.width -= east + west;
#line 478
  box.height -= north + south;
  }
#line 480
  if (box.width > np->maxWidth) {
#line 481
    box.width = np->maxWidth;
  }
#line 483
  if (box.height > np->maxHeight) {
#line 484
    box.height = np->maxHeight;
  }
#line 487
  if (np->sizeFlags & (1L << 7)) {
#line 490
    ratio = (box.width << 16) / box.height;
#line 492
    minr = (np->aspect.minx << 16) / np->aspect.miny;
#line 493
    if (ratio < minr) {
#line 494
      box.height = (box.width << 16) / minr;
    }
#line 497
    maxr = (np->aspect.maxx << 16) / np->aspect.maxy;
#line 498
    if (ratio > maxr) {
#line 499
      box.width = box.height * maxr >> 16;
    }
  }
#line 504
  np->x = box.x;
#line 505
  np->y = box.y;
#line 506
  np->width = box.width - box.width % np->xinc;
#line 507
  np->height = box.height - box.height % np->yinc;
#line 509
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void PlaceMaximizedClient(struct ClientNode *np , int horiz , int vert ) 
{ 
  BoundingBox box ;
  ScreenType const   *sp ;
  int north ;
  int south ;
  int east ;
  int west ;
  int ratio ;
  int minr ;
  int maxr ;
  TrayType *tmp ;

  {
  {
#line 519
  np->oldx = np->x;
#line 520
  np->oldy = np->y;
#line 521
  np->oldWidth = np->width;
#line 522
  np->oldHeight = np->height;
#line 524
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 526
  sp = GetCurrentScreen(np->x + ((east + west) + np->width) / 2, np->y + ((north + south) + np->height) / 2);
#line 529
  GetScreenBounds(sp, & box);
#line 530
  tmp = GetTrays();
#line 530
  SubtractTrayBounds((struct TrayType  const  *)tmp, & box, np->state.layer);
#line 531
  SubtractStrutBounds(& box);
#line 533
  box.x += west;
#line 534
  box.y += north;
#line 535
  box.width -= east + west;
#line 536
  box.height -= north + south;
  }
#line 538
  if (box.width > np->maxWidth) {
#line 539
    box.width = np->maxWidth;
  }
#line 541
  if (box.height > np->maxHeight) {
#line 542
    box.height = np->maxHeight;
  }
#line 545
  if (np->sizeFlags & (1L << 7)) {
#line 548
    ratio = (box.width << 16) / box.height;
#line 550
    minr = (np->aspect.minx << 16) / np->aspect.miny;
#line 551
    if (ratio < minr) {
#line 552
      box.height = (box.width << 16) / minr;
    }
#line 555
    maxr = (np->aspect.maxx << 16) / np->aspect.maxy;
#line 556
    if (ratio > maxr) {
#line 557
      box.width = box.height * maxr >> 16;
    }
  }
#line 563
  if (horiz) {
#line 564
    np->x = box.x;
#line 565
    np->width = box.width - (box.width - np->baseWidth) % np->xinc;
#line 566
    np->state.status |= 4U;
  }
#line 570
  if (vert) {
#line 571
    np->y = box.y;
#line 572
    np->height = box.height - (box.height - np->baseHeight) % np->yinc;
#line 573
    np->state.status |= 8U;
  }
#line 576
  return;
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void GetGravityDelta(struct ClientNode  const  *np , int *x , int *y ) 
{ 
  int north ;
  int south ;
  int east ;
  int west ;

  {
  {
#line 587
  GetBorderSize(np, & north, & south, & east, & west);
  }
  {
#line 590
  if (np->gravity == 1) {
#line 590
    goto case_1;
  }
#line 594
  if (np->gravity == 2) {
#line 594
    goto case_2;
  }
#line 597
  if (np->gravity == 3) {
#line 597
    goto case_3;
  }
#line 601
  if (np->gravity == 4) {
#line 601
    goto case_4;
  }
#line 604
  if (np->gravity == 5) {
#line 604
    goto case_5;
  }
#line 608
  if (np->gravity == 6) {
#line 608
    goto case_6;
  }
#line 611
  if (np->gravity == 7) {
#line 611
    goto case_7;
  }
#line 615
  if (np->gravity == 8) {
#line 615
    goto case_8;
  }
#line 618
  if (np->gravity == 9) {
#line 618
    goto case_9;
  }
#line 622
  goto switch_default;
  case_1: /* CIL Label */ 
#line 591
  *y = - north;
#line 592
  *x = - west;
#line 593
  goto switch_break;
  case_2: /* CIL Label */ 
#line 595
  *y = - north;
#line 596
  goto switch_break;
  case_3: /* CIL Label */ 
#line 598
  *y = - north;
#line 599
  *x = west;
#line 600
  goto switch_break;
  case_4: /* CIL Label */ 
#line 602
  *x = - west;
#line 603
  goto switch_break;
  case_5: /* CIL Label */ 
#line 605
  *y = (north + south) / 2;
#line 606
  *x = (east + west) / 2;
#line 607
  goto switch_break;
  case_6: /* CIL Label */ 
#line 609
  *x = west;
#line 610
  goto switch_break;
  case_7: /* CIL Label */ 
#line 612
  *y = south;
#line 613
  *x = - west;
#line 614
  goto switch_break;
  case_8: /* CIL Label */ 
#line 616
  *y = south;
#line 617
  goto switch_break;
  case_9: /* CIL Label */ 
#line 619
  *y = south;
#line 620
  *x = west;
#line 621
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 623
  *x = 0;
#line 624
  *y = 0;
#line 625
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 628
  return;
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/place.c"
void GravitateClient(struct ClientNode *np , int negate ) 
{ 
  int deltax ;
  int deltay ;

  {
  {
#line 637
  GetGravityDelta((struct ClientNode  const  *)np, & deltax, & deltay);
  }
#line 639
  if (negate) {
#line 640
    np->x += deltax;
#line 641
    np->y += deltay;
  } else {
#line 643
    np->x -= deltax;
#line 644
    np->y -= deltay;
  }
#line 647
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 2008 "/usr/include/X11/Xlib.h"
extern int XAllowEvents(Display * , int  , Time  ) ;
#line 2121
extern int XCheckTypedEvent(Display * , int  , XEvent * ) ;
#line 2127
extern int XCheckTypedWindowEvent(Display * , Window  , int  , XEvent * ) ;
#line 2176
extern int XConfigureWindow(Display * , Window  , unsigned int  , XWindowChanges * ) ;
#line 2183
extern int XConnectionNumber(Display * ) ;
#line 2243
extern int XDefineCursor(Display * , Window  , Cursor  ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2893
extern int XPending(Display * ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.h"
void WaitForEvent(XEvent *event ) ;
#line 22
void ProcessEvent(XEvent *event ) ;
#line 28
void DiscardMotionEvents(XEvent *event , Window w ) ;
#line 33
void UpdateTime(XEvent const   *event ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.h"
BorderActionType GetBorderActionType(struct ClientNode  const  *np , int x , int y ) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
void ReadWMName(struct ClientNode *np ) ;
#line 164
void ReadWMNormalHints(struct ClientNode *np ) ;
#line 175
void ReadWMColormaps(struct ClientNode *np ) ;
#line 186
ClientState ReadWindowState(Window win ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.h"
int ProcessDialogEvent(XEvent const   *event ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.h"
Cursor GetFrameCursor(BorderActionType action ) ;
#line 60
void SetMousePosition(int x , int y ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.h"
int showingDesktop ;
#line 25
int RightDesktop(void) ;
#line 28
int LeftDesktop(void) ;
#line 31
int AboveDesktop(void) ;
#line 34
int BelowDesktop(void) ;
#line 39
void ChangeDesktop(unsigned int desktop ) ;
#line 44
void ShowDesktop(void) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.h"
void HandleDockEvent(XClientMessageEvent const   *event ) ;
#line 37
int HandleDockDestroy(Window win ) ;
#line 43
int HandleDockSelectionClear(XSelectionClearEvent const   *event ) ;
#line 49
int HandleDockResizeRequest(XResizeRequestEvent const   *event ) ;
#line 55
int HandleDockConfigureRequest(XConfigureRequestEvent const   *event ) ;
#line 61
int HandleDockReparentNotify(XReparentEvent const   *event ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.h"
KeyType GetKey(XKeyEvent const   *event ) ;
#line 78
void RunKeyCommand(XKeyEvent const   *event ) ;
#line 83
void ShowKeyMenu(XKeyEvent const   *event ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
char shouldRestart ;
#line 45
unsigned int doubleClickSpeed ;
#line 46
unsigned int doubleClickDelta ;
#line 35 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.h"
int MoveClient(struct ClientNode *np , int startx , int starty , int snap ) ;
#line 41
int MoveClientKeyboard(struct ClientNode *np ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.h"
void SignalPager(struct TimeType  const  *now , int x , int y ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.h"
void SignalPopup(struct TimeType  const  *now , int x , int y ) ;
#line 60
int ProcessPopupEvent(XEvent const   *event ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.h"
void ResizeClient(struct ClientNode *np , BorderActionType action , int startx , int starty ) ;
#line 35
void ResizeClientKeyboard(struct ClientNode *np ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.h"
int ShowRootMenu(int index , int x , int y ) ;
#line 54
void Restart(void) ;
#line 57
void Exit(void) ;
#line 60
void ReloadMenu(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.h"
int CheckSwallowMap(XMapEvent const   *event ) ;
#line 40
int ProcessSwallowEvent(XEvent const   *event ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.h"
void SignalTaskbar(struct TimeType  const  *now , int x , int y ) ;
#line 41
void FocusNext(void) ;
#line 44
void FocusPrevious(void) ;
#line 172 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
void ShowAllTrays(void) ;
#line 219
int ProcessTrayEvent(XEvent const   *event ) ;
#line 227
void SignalTray(struct TimeType  const  *now , int x , int y ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.h"
void SignalTrayButton(struct TimeType  const  *now , int x , int y ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/winmenu.h"
void ShowWindowMenu(struct ClientNode *np , int x , int y ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
Time eventTime  =    (Time )0L;
#line 42
static void Signal(void) ;
#line 43
static void DispatchBorderButtonEvent(XButtonEvent const   *event , ClientNode *np ) ;
#line 46
static void HandleConfigureRequest(XConfigureRequestEvent const   *event ) ;
#line 47
static int HandleConfigureNotify(XConfigureEvent const   *event ) ;
#line 48
static int HandleExpose(XExposeEvent const   *event ) ;
#line 49
static int HandlePropertyNotify(XPropertyEvent const   *event ) ;
#line 50
static void HandleClientMessage(XClientMessageEvent const   *event ) ;
#line 51
static void HandleColormapChange(XColormapEvent const   *event ) ;
#line 52
static int HandleDestroyNotify(XDestroyWindowEvent const   *event ) ;
#line 53
static void HandleMapRequest(XMapEvent const   *event ) ;
#line 54
static void HandleUnmapNotify(XUnmapEvent const   *event ) ;
#line 55
static void HandleButtonEvent(XButtonEvent const   *event ) ;
#line 56
static void HandleKeyPress(XKeyEvent const   *event ) ;
#line 57
static void HandleKeyRelease(XKeyEvent const   *event ) ;
#line 58
static void HandleEnterNotify(XCrossingEvent const   *event ) ;
#line 59
static void HandleLeaveNotify(XCrossingEvent const   *event ) ;
#line 60
static void HandleMotionNotify(XMotionEvent const   *event ) ;
#line 61
static int HandleSelectionClear(XSelectionClearEvent const   *event ) ;
#line 63
static void HandleNetMoveResize(XClientMessageEvent const   *event , ClientNode *np ) ;
#line 65
static void HandleNetWMState(XClientMessageEvent const   *event , ClientNode *np ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
void WaitForEvent(XEvent *event ) 
{ 
  struct timeval timeout ;
  fd_set fds ;
  int fd ;
  int handled ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 80
  fd = XConnectionNumber(display);
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 84
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 84
      tmp___0 = XPending(display);
      }
#line 84
      if (! (tmp___0 == 0)) {
#line 84
        goto while_break___0;
      }
      {
#line 85
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 85
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& fds.fds_bits[0]): "memory");
#line 85
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 86
      fds.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 87
      timeout.tv_usec = (__suseconds_t )0;
#line 88
      timeout.tv_sec = (__time_t )1;
#line 89
      tmp = select(fd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
      }
#line 89
      if (tmp <= 0) {
        {
#line 90
        Signal();
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 94
    Signal();
#line 96
    XNextEvent(display, event);
#line 97
    UpdateTime((XEvent const   *)event);
    }
    {
#line 100
    if (event->type == 23) {
#line 100
      goto case_23;
    }
#line 104
    if (event->type == 20) {
#line 104
      goto case_20;
    }
#line 108
    if (event->type == 28) {
#line 108
      goto case_28;
    }
#line 111
    if (event->type == 33) {
#line 111
      goto case_33;
    }
#line 115
    if (event->type == 18) {
#line 115
      goto case_18;
    }
#line 119
    if (event->type == 12) {
#line 119
      goto case_12;
    }
#line 122
    if (event->type == 32) {
#line 122
      goto case_32;
    }
#line 126
    if (event->type == 17) {
#line 126
      goto case_17;
    }
#line 129
    if (event->type == 29) {
#line 129
      goto case_29;
    }
#line 132
    if (event->type == 25) {
#line 132
      goto case_25;
    }
#line 135
    if (event->type == 6) {
#line 135
      goto case_6;
    }
#line 139
    if (event->type == 21) {
#line 139
      goto case_21;
    }
#line 143
    if (event->type == 22) {
#line 143
      goto case_22;
    }
#line 149
    if (event->type == 14) {
#line 149
      goto case_14;
    }
#line 149
    if (event->type == 13) {
#line 149
      goto case_14;
    }
#line 149
    if (event->type == 19) {
#line 149
      goto case_14;
    }
#line 149
    if (event->type == 16) {
#line 149
      goto case_14;
    }
#line 152
    goto switch_default;
    case_23: /* CIL Label */ 
    {
#line 101
    HandleConfigureRequest((XConfigureRequestEvent const   *)(& event->xconfigurerequest));
#line 102
    handled = 1;
    }
#line 103
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 105
    HandleMapRequest((XMapEvent const   *)(& event->xmap));
#line 106
    handled = 1;
    }
#line 107
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 109
    handled = HandlePropertyNotify((XPropertyEvent const   *)(& event->xproperty));
    }
#line 110
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 112
    HandleClientMessage((XClientMessageEvent const   *)(& event->xclient));
#line 113
    handled = 1;
    }
#line 114
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 116
    HandleUnmapNotify((XUnmapEvent const   *)(& event->xunmap));
#line 117
    handled = 1;
    }
#line 118
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 120
    handled = HandleExpose((XExposeEvent const   *)(& event->xexpose));
    }
#line 121
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 123
    HandleColormapChange((XColormapEvent const   *)(& event->xcolormap));
#line 124
    handled = 1;
    }
#line 125
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 127
    handled = HandleDestroyNotify((XDestroyWindowEvent const   *)(& event->xdestroywindow));
    }
#line 128
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 130
    handled = HandleSelectionClear((XSelectionClearEvent const   *)(& event->xselectionclear));
    }
#line 131
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 133
    handled = HandleDockResizeRequest((XResizeRequestEvent const   *)(& event->xresizerequest));
    }
#line 134
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 136
    SetMousePosition(event->xmotion.x_root, event->xmotion.y_root);
#line 137
    handled = 0;
    }
#line 138
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 140
    HandleDockReparentNotify((XReparentEvent const   *)(& event->xreparent));
#line 141
    handled = 1;
    }
#line 142
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 144
    handled = HandleConfigureNotify((XConfigureEvent const   *)(& event->xconfigure));
    }
#line 145
    goto switch_break;
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_16: /* CIL Label */ 
#line 150
    handled = 1;
#line 151
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 160
    handled = 0;
#line 162
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 165
    if (! handled) {
      {
#line 166
      handled = ProcessTrayEvent((XEvent const   *)event);
      }
    }
#line 168
    if (! handled) {
      {
#line 169
      handled = ProcessDialogEvent((XEvent const   *)event);
      }
    }
#line 171
    if (! handled) {
      {
#line 172
      handled = ProcessSwallowEvent((XEvent const   *)event);
      }
    }
#line 174
    if (! handled) {
      {
#line 175
      handled = ProcessPopupEvent((XEvent const   *)event);
      }
    }
#line 82
    if (handled) {
#line 82
      if (! (! shouldExit)) {
#line 82
        goto while_break;
      }
    } else {
#line 82
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static TimeType last  =    {0UL, 0};
#line 183 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void Signal(void) 
{ 
  TimeType now ;
  int x ;
  int y ;
  unsigned long tmp ;

  {
  {
#line 190
  GetCurrentTime(& now);
#line 192
  tmp = GetTimeDifference((TimeType const   *)(& now), (TimeType const   *)(& last));
  }
#line 192
  if (tmp < 50UL) {
#line 193
    return;
  }
  {
#line 195
  last = now;
#line 197
  GetMousePosition(& x, & y);
#line 199
  SignalTaskbar((struct TimeType  const  *)(& now), x, y);
#line 200
  SignalTrayButton((struct TimeType  const  *)(& now), x, y);
#line 201
  SignalClock((struct TimeType  const  *)(& now), x, y);
#line 202
  SignalTray((struct TimeType  const  *)(& now), x, y);
#line 203
  SignalPager((struct TimeType  const  *)(& now), x, y);
#line 204
  SignalPopup((struct TimeType  const  *)(& now), x, y);
  }
#line 206
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
void ProcessEvent(XEvent *event ) 
{ 
  int tmp ;

  {
  {
#line 213
  if (event->type == 5) {
#line 213
    goto case_5;
  }
#line 213
  if (event->type == 4) {
#line 213
    goto case_5;
  }
#line 216
  if (event->type == 2) {
#line 216
    goto case_2;
  }
#line 219
  if (event->type == 3) {
#line 219
    goto case_3;
  }
#line 222
  if (event->type == 7) {
#line 222
    goto case_7;
  }
#line 225
  if (event->type == 8) {
#line 225
    goto case_8;
  }
#line 228
  if (event->type == 6) {
#line 228
    goto case_6;
  }
#line 235
  if (event->type == 22) {
#line 235
    goto case_22;
  }
#line 235
  if (event->type == 12) {
#line 235
    goto case_22;
  }
#line 235
  if (event->type == 17) {
#line 235
    goto case_22;
  }
#line 237
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 214
  HandleButtonEvent((XButtonEvent const   *)(& event->xbutton));
  }
#line 215
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 217
  HandleKeyPress((XKeyEvent const   *)(& event->xkey));
  }
#line 218
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 220
  HandleKeyRelease((XKeyEvent const   *)(& event->xkey));
  }
#line 221
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 223
  HandleEnterNotify((XCrossingEvent const   *)(& event->xcrossing));
  }
#line 224
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 226
  HandleLeaveNotify((XCrossingEvent const   *)(& event->xcrossing));
  }
#line 227
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 229
    tmp = XCheckTypedEvent(display, 6, event);
    }
#line 229
    if (! tmp) {
#line 229
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 230
  UpdateTime((XEvent const   *)event);
#line 231
  HandleMotionNotify((XMotionEvent const   *)(& event->xmotion));
  }
#line 232
  goto switch_break;
  case_22: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_17: /* CIL Label */ 
#line 236
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 238
  Debug("Unknown event type: %d", event->type);
  }
#line 239
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 241
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
void DiscardMotionEvents(XEvent *event , Window w ) 
{ 
  XEvent temp ;
  int tmp ;

  {
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 248
    tmp = XCheckTypedEvent(display, 6, & temp);
    }
#line 248
    if (! tmp) {
#line 248
      goto while_break;
    }
    {
#line 249
    UpdateTime((XEvent const   *)event);
#line 250
    SetMousePosition(temp.xmotion.x_root, temp.xmotion.y_root);
    }
#line 251
    if (temp.xmotion.window == w) {
#line 252
      *event = temp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static int HandleSelectionClear(XSelectionClearEvent const   *event ) 
{ 
  int tmp ;

  {
  {
#line 261
  tmp = HandleDockSelectionClear(event);
  }
#line 261
  return (tmp);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleButtonEvent(XButtonEvent const   *event ) 
{ 
  int x ;
  int y ;
  ClientNode *np ;
  int north ;
  int south ;
  int east ;
  int west ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 272
  np = FindClientByParent((Window )event->window);
  }
#line 273
  if (np) {
#line 274
    if (event->type == 4) {
      {
#line 275
      RaiseClient(np);
      }
#line 276
      if ((unsigned int )focusModel == 1U) {
        {
#line 277
        FocusClient(np);
        }
      }
    }
    {
#line 281
    if (event->button == 1U) {
#line 281
      goto case_1;
    }
#line 284
    if (event->button == 2U) {
#line 284
      goto case_2;
    }
#line 288
    if (event->button == 3U) {
#line 288
      goto case_3;
    }
#line 294
    if (event->button == 4U) {
#line 294
      goto case_4;
    }
#line 297
    if (event->button == 5U) {
#line 297
      goto case_5;
    }
#line 300
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 282
    DispatchBorderButtonEvent(event, np);
    }
#line 283
    goto switch_break;
    case_2: /* CIL Label */ 
#line 285
    if (event->state & (unsigned int const   )(1 << 3)) {
#line 285
      tmp = 0;
    } else {
#line 285
      tmp = 1;
    }
    {
#line 285
    MoveClient(np, (int )event->x, (int )event->y, tmp);
    }
#line 287
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 289
    GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 290
    x = (int )((event->x + (int const   )np->x) - (int const   )west);
#line 291
    y = (int )((event->y + (int const   )np->y) - (int const   )north);
#line 292
    ShowWindowMenu(np, x, y);
    }
#line 293
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 295
    ShadeClient(np);
    }
#line 296
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 298
    UnshadeClient(np);
    }
#line 299
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 301
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 303
  if (event->window == (Window const   )rootWindow) {
#line 303
    if (event->type == 4) {
      {
#line 304
      tmp___0 = ShowRootMenu((int )event->button, (int )event->x, (int )event->y);
      }
#line 304
      if (! tmp___0) {
#line 305
        if (event->button == 4U) {
          {
#line 306
          LeftDesktop();
          }
        } else
#line 307
        if (event->button == 5U) {
          {
#line 308
          RightDesktop();
          }
        }
      }
    } else {
#line 303
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 312
    np = FindClientByWindow((Window )event->window);
    }
#line 313
    if (np) {
      {
#line 316
      if (event->button == 2U) {
#line 316
        goto case_2___0;
      }
#line 316
      if (event->button == 1U) {
#line 316
        goto case_2___0;
      }
#line 326
      if (event->button == 3U) {
#line 326
        goto case_3___0;
      }
#line 338
      goto switch_default___0;
      case_2___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
      {
#line 317
      RaiseClient(np);
      }
#line 318
      if ((unsigned int )focusModel == 1U) {
        {
#line 319
        FocusClient(np);
        }
      }
#line 321
      if (event->state & (unsigned int const   )(1 << 3)) {
        {
#line 322
        GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 323
        MoveClient(np, (int )(event->x + (int const   )west), (int )(event->y + (int const   )north),
                   0);
        }
      }
#line 325
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 327
      if (event->state & (unsigned int const   )(1 << 3)) {
        {
#line 328
        GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 329
        ResizeClient(np, (BorderActionType )97, (int )(event->x + (int const   )west),
                     (int )(event->y + (int const   )north));
        }
      } else {
        {
#line 332
        RaiseClient(np);
        }
#line 333
        if ((unsigned int )focusModel == 1U) {
          {
#line 334
          FocusClient(np);
          }
        }
      }
#line 337
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 339
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 341
      XAllowEvents(display, 2, eventTime);
      }
    }
  }
#line 346
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleKeyPress(XKeyEvent const   *event ) 
{ 
  ClientNode *np ;
  KeyType key ;

  {
  {
#line 354
  key = GetKey(event);
#line 356
  np = GetActiveClient();
  }
  {
#line 359
  if (((unsigned int )key & 255U) == 27U) {
#line 359
    goto case_27;
  }
#line 362
  if (((unsigned int )key & 255U) == 20U) {
#line 362
    goto case_20;
  }
#line 365
  if (((unsigned int )key & 255U) == 21U) {
#line 365
    goto case_21;
  }
#line 368
  if (((unsigned int )key & 255U) == 22U) {
#line 368
    goto case_22;
  }
#line 371
  if (((unsigned int )key & 255U) == 23U) {
#line 371
    goto case_23;
  }
#line 374
  if (((unsigned int )key & 255U) == 24U) {
#line 374
    goto case_24;
  }
#line 377
  if (((unsigned int )key & 255U) == 25U) {
#line 377
    goto case_25;
  }
#line 380
  if (((unsigned int )key & 255U) == 26U) {
#line 380
    goto case_26;
  }
#line 383
  if (((unsigned int )key & 255U) == 7U) {
#line 383
    goto case_7;
  }
#line 386
  if (((unsigned int )key & 255U) == 8U) {
#line 386
    goto case_8;
  }
#line 390
  if (((unsigned int )key & 255U) == 9U) {
#line 390
    goto case_9;
  }
#line 393
  if (((unsigned int )key & 255U) == 10U) {
#line 393
    goto case_10;
  }
#line 397
  if (((unsigned int )key & 255U) == 11U) {
#line 397
    goto case_11;
  }
#line 402
  if (((unsigned int )key & 255U) == 14U) {
#line 402
    goto case_14;
  }
#line 411
  if (((unsigned int )key & 255U) == 15U) {
#line 411
    goto case_15;
  }
#line 420
  if (((unsigned int )key & 255U) == 16U) {
#line 420
    goto case_16;
  }
#line 425
  if (((unsigned int )key & 255U) == 17U) {
#line 425
    goto case_17;
  }
#line 430
  if (((unsigned int )key & 255U) == 12U) {
#line 430
    goto case_12;
  }
#line 435
  if (((unsigned int )key & 255U) == 13U) {
#line 435
    goto case_13;
  }
#line 440
  if (((unsigned int )key & 255U) == 18U) {
#line 440
    goto case_18;
  }
#line 443
  if (((unsigned int )key & 255U) == 19U) {
#line 443
    goto case_19;
  }
#line 448
  if (((unsigned int )key & 255U) == 28U) {
#line 448
    goto case_28;
  }
#line 451
  if (((unsigned int )key & 255U) == 29U) {
#line 451
    goto case_29;
  }
#line 454
  if (((unsigned int )key & 255U) == 30U) {
#line 454
    goto case_30;
  }
#line 463
  goto switch_default;
  case_27: /* CIL Label */ 
  {
#line 360
  RunKeyCommand(event);
  }
#line 361
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 363
  ChangeDesktop(((unsigned int )key >> 8) - 1U);
  }
#line 364
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 366
  RightDesktop();
  }
#line 367
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 369
  LeftDesktop();
  }
#line 370
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 372
  AboveDesktop();
  }
#line 373
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 375
  BelowDesktop();
  }
#line 376
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 378
  ShowDesktop();
  }
#line 379
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 381
  ShowAllTrays();
  }
#line 382
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 384
  FocusNext();
  }
#line 385
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 387
  StartWindowStackWalk();
#line 388
  WalkWindowStack(1);
  }
#line 389
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 391
  FocusPrevious();
  }
#line 392
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 394
  StartWindowStackWalk();
#line 395
  WalkWindowStack(0);
  }
#line 396
  goto switch_break;
  case_11: /* CIL Label */ 
#line 398
  if (np) {
    {
#line 399
    DeleteClient(np);
    }
  }
#line 401
  goto switch_break;
  case_14: /* CIL Label */ 
#line 403
  if (np) {
#line 404
    if (np->state.status & 256U) {
      {
#line 405
      UnshadeClient(np);
      }
    } else {
      {
#line 407
      ShadeClient(np);
      }
    }
  }
#line 410
  goto switch_break;
  case_15: /* CIL Label */ 
#line 412
  if (np) {
#line 413
    if (np->state.status & 32U) {
      {
#line 414
      SetClientSticky(np, (char)0);
      }
    } else {
      {
#line 416
      SetClientSticky(np, (char)1);
      }
    }
  }
#line 419
  goto switch_break;
  case_16: /* CIL Label */ 
#line 421
  if (np) {
    {
#line 422
    MoveClientKeyboard(np);
    }
  }
#line 424
  goto switch_break;
  case_17: /* CIL Label */ 
#line 426
  if (np) {
    {
#line 427
    ResizeClientKeyboard(np);
    }
  }
#line 429
  goto switch_break;
  case_12: /* CIL Label */ 
#line 431
  if (np) {
    {
#line 432
    MinimizeClient(np);
    }
  }
#line 434
  goto switch_break;
  case_13: /* CIL Label */ 
#line 436
  if (np) {
    {
#line 437
    MaximizeClient(np, (char)1, (char)1);
    }
  }
#line 439
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 441
  ShowKeyMenu(event);
  }
#line 442
  goto switch_break;
  case_19: /* CIL Label */ 
#line 444
  if (np) {
    {
#line 445
    ShowWindowMenu(np, np->x, np->y);
    }
  }
#line 447
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 449
  Restart();
  }
#line 450
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 452
  Exit();
  }
#line 453
  goto switch_break;
  case_30: /* CIL Label */ 
#line 455
  if (np) {
#line 456
    if (np->state.status & 8192U) {
      {
#line 457
      SetClientFullScreen(np, (char)0);
      }
    } else {
      {
#line 459
      SetClientFullScreen(np, (char)1);
      }
    }
  }
#line 462
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 464
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 467
  return;
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleKeyRelease(XKeyEvent const   *event ) 
{ 
  KeyType key ;

  {
  {
#line 473
  key = GetKey(event);
  }
#line 474
  if (((unsigned int )key & 255U) != 8U) {
#line 474
    if (((unsigned int )key & 255U) != 10U) {
      {
#line 476
      StopWindowStackWalk();
      }
    }
  }
#line 479
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleConfigureRequest(XConfigureRequestEvent const   *event ) 
{ 
  XWindowChanges wc ;
  ClientNode *np ;
  int north ;
  int south ;
  int east ;
  int west ;
  int changed ;
  int handled ;

  {
  {
#line 490
  handled = HandleDockConfigureRequest(event);
  }
#line 491
  if (handled) {
#line 492
    return;
  }
  {
#line 495
  np = FindClientByWindow((Window )event->window);
  }
#line 496
  if (np) {
#line 496
    if (np->window == (Window )event->window) {
#line 498
      changed = 0;
#line 499
      if (event->value_mask & (unsigned long const   )(1 << 2)) {
#line 499
        if (event->width != (int const   )np->width) {
#line 500
          np->width = (int )event->width;
#line 501
          changed = 1;
        }
      }
#line 503
      if (event->value_mask & (unsigned long const   )(1 << 3)) {
#line 503
        if (event->height != (int const   )np->height) {
#line 504
          np->height = (int )event->height;
#line 505
          changed = 1;
        }
      }
#line 507
      if (event->value_mask & 1UL) {
#line 507
        if (event->x != (int const   )np->x) {
#line 508
          np->x = (int )event->x;
#line 509
          changed = 1;
        }
      }
#line 511
      if (event->value_mask & (unsigned long const   )(1 << 1)) {
#line 511
        if (event->y != (int const   )np->y) {
#line 512
          np->y = (int )event->y;
#line 513
          changed = 1;
        }
      }
#line 516
      if (! changed) {
#line 517
        return;
      }
#line 520
      if (np->controller) {
        {
#line 521
        (*(np->controller))(0);
        }
      }
      {
#line 524
      GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 526
      ResetRoundedRectWindow(np->parent);
#line 528
      wc.stack_mode = 0;
#line 529
      wc.sibling = np->parent;
#line 530
      wc.border_width = 0;
#line 532
      ConstrainSize(np);
#line 534
      wc.x = np->x;
#line 535
      wc.y = np->y;
#line 536
      wc.width = (np->width + east) + west;
#line 537
      wc.height = (np->height + north) + south;
#line 538
      XConfigureWindow(display, np->parent, (unsigned int )event->value_mask, & wc);
#line 540
      wc.x = west;
#line 541
      wc.y = north;
#line 542
      wc.width = np->width;
#line 543
      wc.height = np->height;
#line 544
      XConfigureWindow(display, np->window, (unsigned int )event->value_mask, & wc);
      }
    } else {
#line 496
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 550
    wc.stack_mode = (int )event->detail;
#line 551
    wc.sibling = (Window )event->above;
#line 552
    wc.border_width = (int )event->border_width;
#line 553
    wc.x = (int )event->x;
#line 554
    wc.y = (int )event->y;
#line 555
    wc.width = (int )event->width;
#line 556
    wc.height = (int )event->height;
#line 557
    XConfigureWindow(display, (Window )event->window, (unsigned int )event->value_mask,
                     & wc);
    }
  }
#line 561
  return;
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static int HandleConfigureNotify(XConfigureEvent const   *event ) 
{ 


  {
#line 566
  if (event->window != (Window const   )rootWindow) {
#line 567
    return (0);
  }
#line 570
  if (rootWidth != (int )event->width) {
#line 571
    rootWidth = (int )event->width;
#line 572
    rootHeight = (int )event->height;
#line 573
    shouldRestart = (char)1;
#line 574
    shouldExit = (char)1;
  } else
#line 570
  if (rootHeight != (int )event->height) {
#line 571
    rootWidth = (int )event->width;
#line 572
    rootHeight = (int )event->height;
#line 573
    shouldRestart = (char)1;
#line 574
    shouldExit = (char)1;
  }
#line 577
  return (1);
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleEnterNotify(XCrossingEvent const   *event ) 
{ 
  ClientNode *np ;
  Cursor cur ;

  {
  {
#line 587
  SetMousePosition((int )event->x_root, (int )event->y_root);
#line 589
  np = FindClientByWindow((Window )event->window);
  }
#line 590
  if (np) {
#line 591
    if (! (np->state.status & 1U)) {
#line 591
      if ((unsigned int )focusModel == 0U) {
        {
#line 592
        FocusClient(np);
        }
      }
    }
#line 594
    if (np->parent == (Window )event->window) {
      {
#line 595
      np->borderAction = GetBorderActionType((struct ClientNode  const  *)np, (int )event->x,
                                             (int )event->y);
#line 596
      cur = GetFrameCursor(np->borderAction);
#line 597
      XDefineCursor(display, np->parent, cur);
      }
    } else
#line 598
    if ((unsigned int )np->borderAction != 0U) {
      {
#line 599
      SetDefaultCursor(np->parent);
#line 600
      np->borderAction = (BorderActionType )0;
      }
    }
  }
#line 604
  return;
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleLeaveNotify(XCrossingEvent const   *event ) 
{ 


  {
  {
#line 609
  SetMousePosition((int )event->x_root, (int )event->y_root);
  }
#line 611
  return;
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static int HandleExpose(XExposeEvent const   *event ) 
{ 
  ClientNode *np ;
  int tmp ;

  {
  {
#line 618
  np = FindClientByWindow((Window )event->window);
  }
#line 619
  if (np) {
#line 620
    if (event->window == (Window const   )np->parent) {
      {
#line 621
      DrawBorder((struct ClientNode  const  *)np, event);
      }
#line 622
      return (1);
    } else
#line 623
    if (event->window == (Window const   )np->window) {
#line 623
      if (np->state.status & 512U) {
#line 627
        return (0);
      } else {
#line 632
        return (1);
      }
    } else {
#line 632
      return (1);
    }
  } else {
#line 636
    if (event->count) {
#line 636
      tmp = 1;
    } else {
#line 636
      tmp = 0;
    }
#line 636
    return (tmp);
  }
}
}
#line 642 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static int HandlePropertyNotify(XPropertyEvent const   *event ) 
{ 
  ClientNode *np ;
  int changed ;

  {
  {
#line 647
  np = FindClientByWindow((Window )event->window);
  }
#line 648
  if (np) {
#line 649
    changed = 0;
    {
#line 651
    if (event->atom == 39UL) {
#line 651
      goto case_39;
    }
#line 655
    if (event->atom == 40UL) {
#line 655
      goto case_40;
    }
#line 661
    if (event->atom == 36UL) {
#line 661
      goto case_36;
    }
#line 661
    if (event->atom == 37UL) {
#line 661
      goto case_36;
    }
#line 661
    if (event->atom == 35UL) {
#line 661
      goto case_36;
    }
#line 663
    goto switch_default;
    case_39: /* CIL Label */ 
    {
#line 652
    ReadWMName(np);
#line 653
    changed = 1;
    }
#line 654
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 656
    ReadWMNormalHints(np);
#line 657
    changed = 1;
    }
#line 658
    goto switch_break;
    case_36: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 662
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 664
    if (event->atom == (Atom const   )atoms[9]) {
      {
#line 665
      ReadWMColormaps(np);
#line 666
      UpdateClientColormap(np);
      }
    } else
#line 667
    if (event->atom == (Atom const   )atoms[47]) {
      {
#line 668
      LoadIcon(np);
#line 669
      changed = 1;
      }
    } else
#line 670
    if (event->atom == (Atom const   )atoms[46]) {
      {
#line 671
      ReadWMName(np);
#line 672
      changed = 1;
      }
    } else
#line 673
    if (event->atom == (Atom const   )atoms[56]) {
      {
#line 674
      ReadClientStrut(np);
      }
    } else
#line 675
    if (event->atom == (Atom const   )atoms[57]) {
      {
#line 676
      ReadClientStrut(np);
      }
    }
#line 678
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 681
    if (changed) {
      {
#line 682
      DrawBorder((struct ClientNode  const  *)np, (XExposeEvent const   *)((void *)0));
#line 683
      UpdateTaskBar();
#line 684
      UpdatePager();
      }
    }
#line 686
    if (np->state.status & 512U) {
#line 687
      return (0);
    } else {
#line 689
      return (1);
    }
  }
#line 693
  return (1);
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleClientMessage(XClientMessageEvent const   *event ) 
{ 
  ClientNode *np ;

  {
  {
#line 704
  np = FindClientByWindow((Window )event->window);
  }
#line 705
  if (np) {
#line 706
    if (event->message_type == (Atom const   )atoms[8]) {
#line 708
      if (np->controller) {
        {
#line 709
        (*(np->controller))(0);
        }
      }
      {
#line 713
      if (event->data.l[0] == 0L) {
#line 713
        goto case_0;
      }
#line 716
      if (event->data.l[0] == 3L) {
#line 716
        goto case_3;
      }
#line 719
      if (event->data.l[0] == 1L) {
#line 719
        goto case_1;
      }
#line 722
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 714
      SetClientWithdrawn(np);
      }
#line 715
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 717
      MinimizeClient(np);
      }
#line 718
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 720
      RestoreClient(np, (char)1);
      }
#line 721
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 723
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 726
    if (event->message_type == (Atom const   )atoms[16]) {
      {
#line 728
      RestoreClient(np, (char)1);
#line 729
      FocusClient(np);
      }
    } else
#line 731
    if (event->message_type == (Atom const   )atoms[21]) {
#line 733
      if (event->data.l[0] == -1L) {
        {
#line 734
        SetClientSticky(np, (char)1);
        }
      } else {
#line 737
        if (np->controller) {
          {
#line 738
          (*(np->controller))(0);
          }
        }
#line 741
        if (event->data.l[0] >= 0L) {
#line 741
          if (event->data.l[0] < (long )desktopCount) {
            {
#line 742
            np->state.status &= 4294967263U;
#line 743
            SetClientDesktop(np, (unsigned int )event->data.l[0]);
            }
          }
        }
      }
    } else
#line 747
    if (event->message_type == (Atom const   )atoms[44]) {
      {
#line 749
      DeleteClient(np);
      }
    } else
#line 751
    if (event->message_type == (Atom const   )atoms[45]) {
      {
#line 753
      HandleNetMoveResize(event, np);
      }
    } else
#line 755
    if (event->message_type == (Atom const   )atoms[22]) {
      {
#line 757
      HandleNetWMState(event, np);
      }
    } else
#line 759
    if (event->message_type == (Atom const   )atoms[19]) {
#line 761
      if (event->data.l[0] != (long )showingDesktop) {
        {
#line 762
        ShowDesktop();
        }
      }
    }
  } else
#line 775
  if (event->window == (Window const   )rootWindow) {
#line 777
    if (event->message_type == (Atom const   )atoms[61]) {
      {
#line 778
      Restart();
      }
    } else
#line 779
    if (event->message_type == (Atom const   )atoms[62]) {
      {
#line 780
      Exit();
      }
    } else
#line 781
    if (event->message_type == (Atom const   )atoms[63]) {
      {
#line 782
      ReloadMenu();
      }
    } else
#line 783
    if (event->message_type == (Atom const   )atoms[15]) {
      {
#line 784
      ChangeDesktop((unsigned int )event->data.l[0]);
      }
    }
  } else
#line 793
  if (event->message_type == (Atom const   )atoms[58]) {
    {
#line 795
    HandleDockEvent(event);
    }
  }
#line 806
  return;
}
}
#line 809 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleNetMoveResize(XClientMessageEvent const   *event , ClientNode *np ) 
{ 
  long flags ;
  long x ;
  long y ;
  long width ;
  long height ;
  int deltax ;
  int deltay ;
  int north ;
  int south ;
  int east ;
  int west ;
  char *tmp ;
  long tmp___0 ;

  {
#line 820
  flags = event->data.l[0] >> 8;
#line 822
  x = (long )np->x;
#line 823
  y = (long )np->y;
#line 824
  width = (long )np->width;
#line 825
  height = (long )np->height;
#line 827
  if (flags & 1L) {
#line 828
    x = event->data.l[1];
  }
#line 830
  if (flags & (long )(1 << 1)) {
#line 831
    y = event->data.l[2];
  }
#line 833
  if (flags & (long )(1 << 2)) {
#line 834
    width = event->data.l[3];
  }
#line 836
  if (flags & (long )(1 << 3)) {
#line 837
    height = event->data.l[4];
  }
  {
#line 840
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 841
  GetGravityDelta((struct ClientNode  const  *)np, & deltax, & deltay);
#line 843
  x -= (long )deltax;
#line 844
  y -= (long )deltay;
#line 846
  np->x = (int )x;
#line 847
  np->y = (int )y;
#line 848
  np->width = (int )width;
#line 849
  np->height = (int )height;
#line 851
  tmp___0 = __builtin_expect((long )(! (! (np->state.status & 8192U))), 0L);
  }
#line 851
  if (tmp___0) {
    {
#line 852
    tmp = gettext("Fullscreen state will be shaped!");
#line 852
    Warning((char const   *)tmp);
    }
  }
  {
#line 856
  ResetRoundedRectWindow(np->parent);
#line 857
  ShapeRoundedRectWindow(np->parent, (np->width + east) + west, (np->height + north) + south);
#line 860
  XMoveResizeWindow(display, np->parent, np->x - west, np->y - north, (unsigned int )((np->width + east) + west),
                    (unsigned int )((np->height + north) + south));
#line 864
  XMoveResizeWindow(display, np->window, west, north, (unsigned int )np->width, (unsigned int )np->height);
#line 867
  WriteState(np);
#line 868
  SendConfigureEvent(np);
  }
#line 870
  return;
}
}
#line 873 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleNetWMState(XClientMessageEvent const   *event , ClientNode *np ) 
{ 
  int actionMaxH ;
  int actionMaxV ;
  int actionStick ;
  int actionShade ;
  int actionFullScreen ;
  int actionMinimize ;
  int actionNolist ;
  int actionBelow ;
  int actionAbove ;
  int x ;

  {
#line 887
  actionMaxH = 0;
#line 888
  actionMaxV = 0;
#line 889
  actionStick = 0;
#line 890
  actionShade = 0;
#line 891
  actionFullScreen = 0;
#line 892
  actionMinimize = 0;
#line 893
  actionNolist = 0;
#line 894
  actionBelow = 0;
#line 895
  actionAbove = 0;
#line 897
  x = 1;
  {
#line 897
  while (1) {
    while_continue: /* CIL Label */ ;
#line 897
    if (! (x <= 2)) {
#line 897
      goto while_break;
    }
#line 898
    if (event->data.l[x] == (long )atoms[23]) {
#line 900
      actionStick = 1;
    } else
#line 901
    if (event->data.l[x] == (long )atoms[24]) {
#line 903
      actionMaxV = 1;
    } else
#line 904
    if (event->data.l[x] == (long )atoms[25]) {
#line 906
      actionMaxH = 1;
    } else
#line 907
    if (event->data.l[x] == (long )atoms[26]) {
#line 909
      actionShade = 1;
    } else
#line 910
    if (event->data.l[x] == (long )atoms[27]) {
#line 912
      actionFullScreen = 1;
    } else
#line 913
    if (event->data.l[x] == (long )atoms[28]) {
#line 915
      actionMinimize = 1;
    } else
#line 916
    if (event->data.l[x] == (long )atoms[29]) {
#line 918
      actionNolist = 1;
    } else
#line 919
    if (event->data.l[x] == (long )atoms[30]) {
#line 921
      actionBelow = 1;
    } else
#line 922
    if (event->data.l[x] == (long )atoms[31]) {
#line 924
      actionAbove = 1;
    }
#line 897
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 929
  if (event->data.l[0] == 0L) {
#line 929
    goto case_0;
  }
#line 958
  if (event->data.l[0] == 1L) {
#line 958
    goto case_1;
  }
#line 985
  if (event->data.l[0] == 2L) {
#line 985
    goto case_2;
  }
#line 1031
  goto switch_default;
  case_0: /* CIL Label */ 
#line 930
  if (actionStick) {
    {
#line 931
    SetClientSticky(np, (char)0);
    }
  }
#line 933
  if (actionMaxH) {
#line 933
    goto _L;
  } else
#line 933
  if (actionMaxV) {
    _L: /* CIL Label */ 
#line 934
    if (np->state.status & 12U) {
      {
#line 935
      MaximizeClient(np, (char)0, (char)0);
      }
    }
  }
#line 938
  if (actionShade) {
    {
#line 939
    UnshadeClient(np);
    }
  }
#line 941
  if (actionFullScreen) {
    {
#line 942
    SetClientFullScreen(np, (char)0);
    }
  }
#line 944
  if (actionMinimize) {
    {
#line 945
    RestoreClient(np, (char)0);
    }
  }
#line 947
  if (actionNolist) {
    {
#line 948
    np->state.status &= 4294967231U;
#line 949
    UpdateTaskBar();
    }
  }
#line 951
  if (actionBelow) {
#line 951
    if (np->state.layer == 2U) {
      {
#line 952
      SetClientLayer(np, 4U);
      }
    }
  }
#line 954
  if (actionAbove) {
#line 954
    if (np->state.layer == 6U) {
      {
#line 955
      SetClientLayer(np, 4U);
      }
    }
  }
#line 957
  goto switch_break;
  case_1: /* CIL Label */ 
#line 959
  if (actionStick) {
    {
#line 960
    SetClientSticky(np, (char)1);
    }
  }
#line 962
  if (! (np->state.status & 12U)) {
    {
#line 963
    MaximizeClient(np, (char )actionMaxH, (char )actionMaxV);
    }
  }
#line 965
  if (actionShade) {
    {
#line 966
    ShadeClient(np);
    }
  }
#line 968
  if (actionFullScreen) {
    {
#line 969
    SetClientFullScreen(np, (char)1);
    }
  }
#line 971
  if (actionMinimize) {
    {
#line 972
    MinimizeClient(np);
    }
  }
#line 974
  if (actionNolist) {
    {
#line 975
    np->state.status |= 64U;
#line 976
    UpdateTaskBar();
    }
  }
#line 978
  if (actionBelow) {
#line 978
    if (np->state.layer == 4U) {
      {
#line 979
      SetClientLayer(np, 2U);
      }
    }
  }
#line 981
  if (actionAbove) {
#line 981
    if (np->state.layer == 4U) {
      {
#line 982
      SetClientLayer(np, 6U);
      }
    }
  }
#line 984
  goto switch_break;
  case_2: /* CIL Label */ 
#line 986
  if (actionStick) {
#line 987
    if (np->state.status & 32U) {
      {
#line 988
      SetClientSticky(np, (char)0);
      }
    } else {
      {
#line 990
      SetClientSticky(np, (char)1);
      }
    }
  }
#line 993
  if (actionMaxH) {
    {
#line 994
    MaximizeClient(np, (char )actionMaxH, (char )actionMaxV);
    }
  } else
#line 993
  if (actionMaxV) {
    {
#line 994
    MaximizeClient(np, (char )actionMaxH, (char )actionMaxV);
    }
  }
#line 996
  if (actionShade) {
#line 997
    if (np->state.status & 256U) {
      {
#line 998
      UnshadeClient(np);
      }
    } else {
      {
#line 1000
      ShadeClient(np);
      }
    }
  }
#line 1003
  if (actionFullScreen) {
#line 1004
    if (np->state.status & 8192U) {
      {
#line 1005
      SetClientFullScreen(np, (char)0);
      }
    } else {
      {
#line 1007
      SetClientFullScreen(np, (char)1);
      }
    }
  }
#line 1010
  if (actionBelow) {
#line 1011
    if (np->state.layer == 4U) {
      {
#line 1012
      SetClientLayer(np, 2U);
      }
    } else
#line 1013
    if (np->state.layer == 2U) {
      {
#line 1014
      SetClientLayer(np, 4U);
      }
    }
  }
#line 1017
  if (actionAbove) {
#line 1018
    if (np->state.layer == 4U) {
      {
#line 1019
      SetClientLayer(np, 6U);
      }
    } else
#line 1020
    if (np->state.layer == 6U) {
      {
#line 1021
      SetClientLayer(np, 4U);
      }
    }
  }
#line 1026
  if (actionNolist) {
    {
#line 1027
    np->state.status ^= 64U;
#line 1028
    UpdateTaskBar();
    }
  }
#line 1030
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1032
  Debug("bad _NET_WM_STATE action: %ld", event->data.l[0]);
  }
#line 1033
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1035
  return;
}
}
#line 1038 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleMotionNotify(XMotionEvent const   *event ) 
{ 
  ClientNode *np ;
  Cursor cur ;
  BorderActionType action ;

  {
#line 1044
  if (event->is_hint) {
#line 1045
    return;
  }
  {
#line 1048
  SetMousePosition((int )event->x_root, (int )event->y_root);
#line 1050
  np = FindClientByParent((Window )event->window);
  }
#line 1051
  if (np) {
#line 1051
    if (np->state.border & 1U) {
      {
#line 1052
      action = GetBorderActionType((struct ClientNode  const  *)np, (int )event->x,
                                   (int )event->y);
      }
#line 1053
      if ((unsigned int )np->borderAction != (unsigned int )action) {
        {
#line 1054
        np->borderAction = action;
#line 1055
        cur = GetFrameCursor(action);
#line 1056
        XDefineCursor(display, np->parent, cur);
        }
      }
    }
  }
#line 1060
  return;
}
}
#line 1077 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleColormapChange(XColormapEvent const   *event ) 
{ 
  ClientNode *np ;

  {
#line 1080
  if (event->new == 1) {
    {
#line 1081
    np = FindClientByWindow((Window )event->window);
    }
#line 1082
    if (np) {
      {
#line 1083
      np->cmap = (Colormap )event->colormap;
#line 1084
      UpdateClientColormap(np);
      }
    }
  }
#line 1088
  return;
}
}
#line 1091 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleMapRequest(XMapEvent const   *event ) 
{ 
  ClientNode *np ;
  int tmp ;

  {
  {
#line 1097
  tmp = CheckSwallowMap(event);
  }
#line 1097
  if (tmp) {
#line 1098
    return;
  }
  {
#line 1101
  np = FindClientByWindow((Window )event->window);
  }
#line 1102
  if (! np) {
    {
#line 1103
    XSync(display, 0);
#line 1104
    XGrabServer(display);
#line 1105
    np = AddClientWindow((Window )event->window, (char)0, (char)1);
    }
#line 1106
    if (np) {
#line 1107
      if ((unsigned int )focusModel == 1U) {
#line 1107
        if (! (np->state.status & 32768U)) {
          {
#line 1108
          FocusClient(np);
          }
        }
      }
    } else {
      {
#line 1111
      XMapWindow(display, (Window )event->window);
      }
    }
    {
#line 1113
    XSync(display, 0);
#line 1114
    XUngrabServer(display);
    }
  } else
#line 1116
  if (! (np->state.status & 2U)) {
    {
#line 1117
    np->state = ReadWindowState(np->window);
#line 1118
    np->state.status |= 2U;
    }
#line 1119
    if (! (np->state.status & 32U)) {
#line 1120
      np->state.desktop = currentDesktop;
    }
    {
#line 1122
    XMapWindow(display, np->window);
#line 1123
    XMapWindow(display, np->parent);
    }
#line 1124
    if (! (np->state.status & 32768U)) {
      {
#line 1125
      RaiseClient(np);
#line 1126
      FocusClient(np);
      }
    }
    {
#line 1128
    UpdateTaskBar();
#line 1129
    UpdatePager();
    }
  }
  {
#line 1132
  RestackClients();
  }
#line 1133
  return;
}
}
#line 1136 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void HandleUnmapNotify(XUnmapEvent const   *event ) 
{ 
  ClientNode *np ;
  XEvent e ;
  int tmp ;

  {
  {
#line 1143
  np = FindClientByWindow((Window )event->window);
  }
#line 1144
  if (np) {
#line 1144
    if (np->window == (Window )event->window) {
      {
#line 1146
      tmp = XCheckTypedWindowEvent(display, np->window, 17, & e);
      }
#line 1146
      if (tmp) {
        {
#line 1147
        UpdateTime((XEvent const   *)(& e));
#line 1148
        HandleDestroyNotify((XDestroyWindowEvent const   *)(& e.xdestroywindow));
        }
#line 1149
        return;
      }
#line 1152
      if (np->controller) {
        {
#line 1153
        (*(np->controller))(1);
        }
      }
#line 1156
      if (np->state.status & 2U) {
        {
#line 1158
        np->state.status &= 4294967293U;
#line 1159
        XUnmapWindow(display, np->parent);
#line 1161
        WriteState(np);
#line 1162
        UpdateTaskBar();
#line 1163
        UpdatePager();
        }
#line 1165
        if (np->state.status & 1U) {
          {
#line 1166
          FocusNextStacked(np);
          }
        }
      }
    }
  }
#line 1173
  return;
}
}
#line 1176 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static int HandleDestroyNotify(XDestroyWindowEvent const   *event ) 
{ 
  ClientNode *np ;
  int tmp ;

  {
  {
#line 1180
  np = FindClientByWindow((Window )event->window);
  }
#line 1181
  if (np) {
#line 1181
    if (np->window == (Window )event->window) {
#line 1183
      if (np->controller) {
        {
#line 1184
        (*(np->controller))(1);
        }
      }
      {
#line 1187
      RemoveClient(np);
      }
#line 1189
      return (1);
    } else {
#line 1181
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1191
  if (! np) {
    {
#line 1193
    tmp = HandleDockDestroy((Window )event->window);
    }
#line 1193
    return (tmp);
  }
#line 1197
  return (0);
}
}
#line 1204 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static Time lastClickTime  =    (Time )0;
#line 1205 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static int lastX  =    0;
#line 1205 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static int lastY  =    0;
#line 1206 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static char doubleClickActive  =    (char)0;
#line 1202 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
static void DispatchBorderButtonEvent(XButtonEvent const   *event , ClientNode *np ) 
{ 
  BorderActionType action ;
  int bsize ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1210
  action = GetBorderActionType((struct ClientNode  const  *)np, (int )event->x, (int )event->y);
  }
  {
#line 1213
  if (((unsigned int )action & 15U) == 1U) {
#line 1213
    goto case_1;
  }
#line 1218
  if (((unsigned int )action & 15U) == 2U) {
#line 1218
    goto case_2;
  }
#line 1240
  if (((unsigned int )action & 15U) == 6U) {
#line 1240
    goto case_6;
  }
#line 1251
  if (((unsigned int )action & 15U) == 3U) {
#line 1251
    goto case_3;
  }
#line 1256
  if (((unsigned int )action & 15U) == 4U) {
#line 1256
    goto case_4;
  }
#line 1261
  if (((unsigned int )action & 15U) == 5U) {
#line 1261
    goto case_5;
  }
#line 1266
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1214
  if (event->type == 4) {
    {
#line 1215
    ResizeClient(np, action, (int )event->x, (int )event->y);
    }
  }
#line 1217
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1219
  if (event->type == 4) {
#line 1220
    if (doubleClickActive) {
      {
#line 1220
      tmp___1 = abs((int )(event->time - (Time const   )lastClickTime));
      }
#line 1220
      if (tmp___1 > 0) {
        {
#line 1220
        tmp___2 = abs((int )(event->time - (Time const   )lastClickTime));
        }
#line 1220
        if ((unsigned int )tmp___2 <= doubleClickSpeed) {
          {
#line 1220
          tmp___3 = abs((int )(event->x - (int const   )lastX));
          }
#line 1220
          if ((unsigned int )tmp___3 <= doubleClickDelta) {
            {
#line 1220
            tmp___4 = abs((int )(event->y - (int const   )lastY));
            }
#line 1220
            if ((unsigned int )tmp___4 <= doubleClickDelta) {
              {
#line 1225
              MaximizeClientDefault(np);
#line 1226
              doubleClickActive = (char)0;
              }
            } else {
#line 1220
              goto _L___2;
            }
          } else {
#line 1220
            goto _L___2;
          }
        } else {
#line 1220
          goto _L___2;
        }
      } else {
#line 1220
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 1228
      if (event->state & (unsigned int const   )(1 << 3)) {
#line 1228
        tmp = 0;
      } else {
#line 1228
        tmp = 1;
      }
      {
#line 1228
      tmp___0 = MoveClient(np, (int )event->x, (int )event->y, tmp);
      }
#line 1228
      if (tmp___0) {
#line 1230
        doubleClickActive = (char)0;
      } else {
#line 1232
        doubleClickActive = (char)1;
#line 1233
        lastClickTime = (Time )event->time;
#line 1234
        lastX = (int )event->x;
#line 1235
        lastY = (int )event->y;
      }
    }
  }
#line 1239
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1241
  if (event->type == 4) {
#line 1242
    if (np->state.border & 1U) {
#line 1243
      bsize = borderWidth;
    } else {
#line 1245
      bsize = 0;
    }
    {
#line 1247
    ShowWindowMenu(np, (np->x + (int )event->x) - bsize, ((np->y + (int )event->y) - titleHeight) - bsize);
    }
  }
#line 1250
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1252
  if (event->type == 5) {
    {
#line 1253
    DeleteClient(np);
    }
  }
#line 1255
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1257
  if (event->type == 5) {
    {
#line 1258
    MaximizeClientDefault(np);
    }
  }
#line 1260
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1262
  if (event->type == 5) {
    {
#line 1263
    MinimizeClient(np);
    }
  }
#line 1265
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1267
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1270
  return;
}
}
#line 1273 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/event.c"
void UpdateTime(XEvent const   *event ) 
{ 
  Time t ;

  {
#line 1275
  t = (Time )0L;
  {
#line 1281
  if (event->type == 3) {
#line 1281
    goto case_3;
  }
#line 1281
  if (event->type == 2) {
#line 1281
    goto case_3;
  }
#line 1285
  if (event->type == 5) {
#line 1285
    goto case_5;
  }
#line 1285
  if (event->type == 4) {
#line 1285
    goto case_5;
  }
#line 1288
  if (event->type == 6) {
#line 1288
    goto case_6;
  }
#line 1292
  if (event->type == 8) {
#line 1292
    goto case_8;
  }
#line 1292
  if (event->type == 7) {
#line 1292
    goto case_8;
  }
#line 1295
  if (event->type == 28) {
#line 1295
    goto case_28;
  }
#line 1298
  if (event->type == 29) {
#line 1298
    goto case_29;
  }
#line 1301
  if (event->type == 30) {
#line 1301
    goto case_30;
  }
#line 1304
  if (event->type == 31) {
#line 1304
    goto case_31;
  }
#line 1307
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1282
  t = (Time )event->xkey.time;
#line 1283
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1286
  t = (Time )event->xkey.time;
#line 1287
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1289
  t = (Time )event->xmotion.time;
#line 1290
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 1293
  t = (Time )event->xcrossing.time;
#line 1294
  goto switch_break;
  case_28: /* CIL Label */ 
#line 1296
  t = (Time )event->xproperty.time;
#line 1297
  goto switch_break;
  case_29: /* CIL Label */ 
#line 1299
  t = (Time )event->xselectionclear.time;
#line 1300
  goto switch_break;
  case_30: /* CIL Label */ 
#line 1302
  t = (Time )event->xselectionrequest.time;
#line 1303
  goto switch_break;
  case_31: /* CIL Label */ 
#line 1305
  t = (Time )event->xselection.time;
#line 1306
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1308
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1311
  if (t != 0UL) {
#line 1312
    if (t > eventTime) {
#line 1313
      eventTime = t;
    } else
#line 1312
    if (t < eventTime - 60000UL) {
#line 1313
      eventTime = t;
    }
  }
#line 1317
  return;
}
}
#line 2808 "/usr/include/X11/Xlib.h"
extern int XMapRaised(Display * , Window  ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3357
extern int XSetWindowBorder(Display * , Window  , unsigned long  ) ;
#line 423 "/usr/include/X11/Xutil.h"
extern int XGetClassHint(Display * , Window  , XClassHint * ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.h"
void InitializeSwallow(void) ;
#line 15
void StartupSwallow(void) ;
#line 16
void ShutdownSwallow(void) ;
#line 17
void DestroySwallow(void) ;
#line 26
struct TrayComponentType *CreateSwallow(char const   *name , char const   *command ,
                                        int width , int height ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.c"
static SwallowNode *swallowNodes  ;
#line 37
static void Destroy___0(TrayComponentType *cp ) ;
#line 38
static void Resize___0(TrayComponentType *cp ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.c"
void InitializeSwallow(void) 
{ 


  {
#line 42
  swallowNodes = (SwallowNode *)((void *)0);
#line 43
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.c"
void StartupSwallow(void) 
{ 
  SwallowNode *np ;

  {
#line 50
  np = swallowNodes;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! np) {
#line 50
      goto while_break;
    }
#line 51
    if (np->command) {
      {
#line 52
      RunCommand((char const   *)np->command);
      }
    }
#line 50
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.c"
void ShutdownSwallow(void) 
{ 


  {
#line 60
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.c"
void DestroySwallow(void) 
{ 
  SwallowNode *np ;

  {
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! swallowNodes) {
#line 67
      goto while_break;
    }
    {
#line 69
    np = swallowNodes->next;
#line 72
    free((void *)swallowNodes->name);
    }
#line 74
    if (swallowNodes->command) {
      {
#line 75
      free((void *)swallowNodes->command);
      }
    }
    {
#line 78
    free((void *)swallowNodes);
#line 79
    swallowNodes = np;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.c"
struct TrayComponentType *CreateSwallow(char const   *name , char const   *command ,
                                        int width , int height ) 
{ 
  TrayComponentType *cp ;
  SwallowNode *np ;
  char *tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 92
  tmp___0 = __builtin_expect((long )(! (! (! name))), 0L);
  }
#line 92
  if (tmp___0) {
    {
#line 93
    tmp = gettext("cannot swallow a client with no name");
#line 93
    Warning((char const   *)tmp);
    }
#line 94
    return ((struct TrayComponentType *)((void *)0));
  }
#line 98
  np = swallowNodes;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! np) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___2 = strcmp((char const   *)np->name, name);
    }
#line 99
    if (tmp___2) {
#line 99
      tmp___3 = 0;
    } else {
#line 99
      tmp___3 = 1;
    }
    {
#line 99
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
#line 99
    if (tmp___4) {
      {
#line 100
      tmp___1 = gettext("cannot swallow the same client multiple times");
#line 100
      Warning((char const   *)tmp___1);
      }
#line 101
      return ((struct TrayComponentType *)((void *)0));
    }
#line 98
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  tmp___5 = malloc(sizeof(SwallowNode ));
#line 105
  np = (SwallowNode *)tmp___5;
#line 106
  np->name = CopyString(name);
#line 107
  np->command = CopyString(command);
#line 109
  np->next = swallowNodes;
#line 110
  swallowNodes = np;
#line 112
  cp = CreateTrayComponent();
#line 113
  np->cp = cp;
#line 114
  cp->object = (void *)np;
#line 115
  cp->Destroy = & Destroy___0;
#line 116
  cp->Resize = & Resize___0;
  }
#line 118
  if (width) {
#line 119
    cp->requestedWidth = width;
#line 120
    np->userWidth = 1;
  } else {
#line 122
    cp->requestedWidth = 1;
#line 123
    np->userWidth = 0;
  }
#line 125
  if (height) {
#line 126
    cp->requestedHeight = height;
#line 127
    np->userHeight = 1;
  } else {
#line 129
    cp->requestedHeight = 1;
#line 130
    np->userHeight = 0;
  }
#line 133
  return (cp);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.c"
int ProcessSwallowEvent(XEvent const   *event ) 
{ 
  SwallowNode *np ;
  int width ;
  int height ;

  {
#line 143
  np = swallowNodes;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! np) {
#line 143
      goto while_break;
    }
#line 144
    if (event->xany.window == (Window const   )(np->cp)->window) {
      {
#line 146
      if (event->type == 17) {
#line 146
        goto case_17;
      }
#line 152
      if (event->type == 25) {
#line 152
        goto case_25;
      }
#line 159
      if (event->type == 22) {
#line 159
        goto case_22;
      }
#line 171
      goto switch_default;
      case_17: /* CIL Label */ 
      {
#line 147
      (np->cp)->window = (Window )0L;
#line 148
      (np->cp)->requestedWidth = 1;
#line 149
      (np->cp)->requestedHeight = 1;
#line 150
      ResizeTray((np->cp)->tray);
      }
#line 151
      goto switch_break;
      case_25: /* CIL Label */ 
      {
#line 153
      (np->cp)->requestedWidth = (int )(event->xresizerequest.width + (int const   )(np->border * 2));
#line 155
      (np->cp)->requestedHeight = (int )(event->xresizerequest.height + (int const   )(np->border * 2));
#line 157
      ResizeTray((np->cp)->tray);
      }
#line 158
      goto switch_break;
      case_22: /* CIL Label */ 
#line 162
      width = (int )(event->xconfigure.width + (int const   )(np->border * 2));
#line 163
      height = (int )(event->xconfigure.height + (int const   )(np->border * 2));
#line 164
      if (width != (np->cp)->requestedWidth) {
#line 164
        if (height != (np->cp)->requestedHeight) {
          {
#line 166
          (np->cp)->requestedWidth = width;
#line 167
          (np->cp)->requestedHeight = height;
#line 168
          ResizeTray((np->cp)->tray);
          }
        }
      }
#line 170
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 172
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 174
      return (1);
    }
#line 143
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return (0);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.c"
static void Resize___0(TrayComponentType *cp ) 
{ 
  int width ;
  int height ;
  SwallowNode *np ;

  {
#line 187
  np = (SwallowNode *)cp->object;
#line 189
  if (cp->window != 0UL) {
    {
#line 191
    width = cp->width - np->border * 2;
#line 192
    height = cp->height - np->border * 2;
#line 194
    XResizeWindow(display, cp->window, (unsigned int )width, (unsigned int )height);
    }
  }
#line 198
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.c"
static void Destroy___0(TrayComponentType *cp ) 
{ 
  ClientProtocolType protocols ;

  {
#line 206
  if (cp->window) {
    {
#line 208
    XReparentWindow(display, cp->window, rootWindow, 0, 0);
#line 209
    XRemoveFromSaveSet(display, cp->window);
#line 211
    protocols = ReadWMProtocols(cp->window);
    }
#line 212
    if ((unsigned int )protocols & 1U) {
      {
#line 213
      SendClientMessage(cp->window, (AtomType )4, (AtomType )5);
      }
    } else {
      {
#line 216
      XKillClient(display, cp->window);
      }
    }
  }
#line 221
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/swallow.c"
int CheckSwallowMap(XMapEvent const   *event ) 
{ 
  SwallowNode *np ;
  XClassHint hint ;
  XWindowAttributes attr ;
  int tmp ;
  int tmp___0 ;

  {
#line 230
  np = swallowNodes;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! np) {
#line 230
      goto while_break;
    }
#line 232
    if ((np->cp)->window != 0UL) {
#line 233
      goto __Cont;
    }
    {
#line 238
    tmp___0 = XGetClassHint(display, (Window )event->window, & hint);
    }
#line 238
    if (tmp___0) {
      {
#line 239
      tmp = strcmp((char const   *)hint.res_name, (char const   *)np->name);
      }
#line 239
      if (tmp) {
        {
#line 269
        XFree((void *)hint.res_name);
#line 270
        XFree((void *)hint.res_class);
        }
      } else {
        {
#line 242
        XSelectInput(display, (Window )event->window, (1L << 17) | (1L << 18));
#line 244
        XAddToSaveSet(display, (Window )event->window);
#line 245
        XSetWindowBorder(display, (Window )event->window, colors[8]);
#line 246
        XReparentWindow(display, (Window )event->window, ((np->cp)->tray)->window,
                        0, 0);
#line 248
        XMapRaised(display, (Window )event->window);
#line 249
        XFree((void *)hint.res_name);
#line 250
        XFree((void *)hint.res_class);
#line 251
        (np->cp)->window = (Window )event->window;
#line 254
        XGetWindowAttributes(display, (Window )event->window, & attr);
#line 255
        np->border = attr.border_width;
        }
#line 256
        if (! np->userWidth) {
#line 257
          (np->cp)->requestedWidth = attr.width + 2 * np->border;
        }
#line 259
        if (! np->userHeight) {
#line 260
          (np->cp)->requestedHeight = attr.height + 2 * np->border;
        }
        {
#line 263
        ResizeTray((np->cp)->tray);
        }
#line 265
        return (1);
      }
    }
    __Cont: /* CIL Label */ 
#line 230
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.h"
void ParseConfig(char const   *fileName ) ;
#line 124 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.h"
TokenNode *Tokenize(char const   *line , char const   *fileName ) ;
#line 131
char const   *GetTokenName(TokenNode const   *tp ) ;
#line 137
char const   *GetTokenTypeName(TokenType type ) ;
#line 121 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
void SetMenuOpacity(char const   *str___0 ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.h"
void SetRootMenu(char const   *indexes , struct Menu *m ) ;
#line 31
void SetShowExitConfirmation(char v ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.h"
void SetBorderWidth(char const   *str___0 ) ;
#line 85
void SetTitleHeight(char const   *str___0 ) ;
#line 106
void SetButtonMask(BorderPixmapType pt , char const   *filename ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
TrayType *CreateTray(void) ;
#line 164
void AddTrayComponent(TrayType *tp , TrayComponentType *cp ) ;
#line 233
void SetAutoHideTray(TrayType *tp , int v ) ;
#line 239
void SetTrayX(TrayType *tp , char const   *str___0 ) ;
#line 245
void SetTrayY(TrayType *tp , char const   *str___0 ) ;
#line 251
void SetTrayWidth(TrayType *tp , char const   *str___0 ) ;
#line 257
void SetTrayHeight(TrayType *tp , char const   *str___0 ) ;
#line 263
void SetTrayLayout(TrayType *tp , char const   *str___0 ) ;
#line 269
void SetTrayLayer(TrayType *tp , char const   *str___0 ) ;
#line 275
void SetTrayBorder(TrayType *tp , char const   *str___0 ) ;
#line 281
void SetTrayHorizontalAlignment(TrayType *tp , char const   *str___0 ) ;
#line 287
void SetTrayVerticalAlignment(TrayType *tp , char const   *str___0 ) ;
#line 292
void SetTrayOpacity(char const   *str___0 ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.h"
struct GroupType *CreateGroup(void) ;
#line 52
void AddGroupClass(struct GroupType *gp , char const   *pattern ) ;
#line 58
void AddGroupName(struct GroupType *gp , char const   *pattern ) ;
#line 64
void AddGroupOption(struct GroupType *gp , OptionType option ) ;
#line 71
void AddGroupOptionValue(struct GroupType *gp , OptionType option , char const   *value ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.h"
void SetDesktopCount(char const   *width , char const   *height ) ;
#line 64
void SetDesktopName(unsigned int desktop , char const   *str___0 ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.h"
void SetSnapMode(SnapModeType mode ) ;
#line 51
void SetSnapDistance(char const   *value ) ;
#line 54
void SetDefaultSnapDistance(void) ;
#line 59
void SetMoveMode(MoveModeType mode ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.h"
void SetResizeMode(ResizeModeType mode ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.h"
struct TrayComponentType *CreatePager(int labeled ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/error.h"
void WarningVA(char const   *part , char const   *str___0 , va_list ap ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.h"
void InsertBinding(KeyType key , char const   *modifiers___0 , char const   *stroke ,
                   char const   *code , char const   *command ) ;
#line 89
void ValidateKeys(void) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.h"
void SetDoubleClickSpeed(char const   *str___0 ) ;
#line 86
void SetDoubleClickDelta(char const   *str___0 ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
char shouldReload ;
#line 93 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.h"
void SetColor(ColorType c , char const   *value ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.h"
void SetFont(FontType type , char const   *value ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.h"
void AddIconPath(char *path ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.h"
void AddStartupCommand(char const   *command ) ;
#line 28
void AddShutdownCommand(char const   *command ) ;
#line 33
void AddRestartCommand(char const   *command ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.h"
struct TrayComponentType *CreateTaskBar(void) ;
#line 50
void SetMaxTaskBarItemWidth(struct TrayComponentType *cp , char const   *value ) ;
#line 55
void SetTaskBarInsertMode(char const   *mode ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.h"
struct TrayComponentType *CreateTrayButton(char const   *iconName , char const   *label ,
                                           char const   *action , char const   *popup___0 ,
                                           int width , int height ) ;
#line 48
void ValidateTrayButtons(void) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.h"
struct TrayComponentType *CreateDock(int width ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.h"
void SetPopupEnabled(int e ) ;
#line 47
void SetPopupDelay(char const   *str___0 ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.h"
void SetMoveStatusType(char const   *str___0 ) ;
#line 51
void SetResizeStatusType(char const   *str___0 ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/spacer.h"
struct TrayComponentType *CreateSpacer(int width , int height ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static KeyMapType const   KEY_MAP[29]  = 
#line 50 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
  {      {"up", (KeyType )1}, 
        {"down", (KeyType )2}, 
        {"right", (KeyType )3}, 
        {"left", (KeyType )4}, 
        {"escape", (KeyType )5}, 
        {"select", (KeyType )6}, 
        {"next", (KeyType )7}, 
        {"nextstacked", (KeyType )8}, 
        {"prev", (KeyType )9}, 
        {"prevstacked", (KeyType )10}, 
        {"close", (KeyType )11}, 
        {"minimize", (KeyType )12}, 
        {"maximize", (KeyType )13}, 
        {"shade", (KeyType )14}, 
        {"stick", (KeyType )15}, 
        {"move", (KeyType )16}, 
        {"resize", (KeyType )17}, 
        {"window", (KeyType )19}, 
        {"restart", (KeyType )28}, 
        {"exit", (KeyType )29}, 
        {"desktop#", (KeyType )20}, 
        {"rdesktop", (KeyType )21}, 
        {"ldesktop", (KeyType )22}, 
        {"udesktop", (KeyType )23}, 
        {"ddesktop", (KeyType )24}, 
        {"showdesktop", (KeyType )25}, 
        {"showtray", (KeyType )26}, 
        {"fullscreen", (KeyType )30}, 
        {(char const   *)((void *)0), (KeyType )0}};
#line 89 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static OptionMapType const   OPTION_MAP[13]  = 
#line 89
  {      {"sticky", (OptionType )1}, 
        {"nolist", (OptionType )5}, 
        {"border", (OptionType )6}, 
        {"noborder", (OptionType )7}, 
        {"title", (OptionType )8}, 
        {"notitle", (OptionType )9}, 
        {"pignore", (OptionType )10}, 
        {"maximized", (OptionType )11}, 
        {"minimized", (OptionType )12}, 
        {"hmax", (OptionType )15}, 
        {"vmax", (OptionType )16}, 
        {"nofocus", (OptionType )17}, 
        {(char const   *)((void *)0), (OptionType )0}};
#line 105 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *DEFAULT_TITLE  =    "JWM";
#line 106 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *LABEL_ATTRIBUTE  =    "label";
#line 107 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *ICON_ATTRIBUTE  =    "icon";
#line 108 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *CONFIRM_ATTRIBUTE  =    "confirm";
#line 109 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *LABELED_ATTRIBUTE  =    "labeled";
#line 110 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *ONROOT_ATTRIBUTE  =    "onroot";
#line 111 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *LAYER_ATTRIBUTE  =    "layer";
#line 112 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *LAYOUT_ATTRIBUTE  =    "layout";
#line 113 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *AUTOHIDE_ATTRIBUTE  =    "autohide";
#line 114 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *X_ATTRIBUTE  =    "x";
#line 115 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *Y_ATTRIBUTE  =    "y";
#line 116 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *WIDTH_ATTRIBUTE  =    "width";
#line 117 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *HEIGHT_ATTRIBUTE  =    "height";
#line 118 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *NAME_ATTRIBUTE  =    "name";
#line 119 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *BORDER_ATTRIBUTE  =    "border";
#line 120 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *DISTANCE_ATTRIBUTE  =    "distance";
#line 121 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *INSERT_ATTRIBUTE  =    "insert";
#line 122 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *MAX_WIDTH_ATTRIBUTE  =    "maxwidth";
#line 123 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *FORMAT_ATTRIBUTE  =    "format";
#line 124 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *ZONE_ATTRIBUTE  =    "zone";
#line 125 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *VALIGN_ATTRIBUTE  =    "valign";
#line 126 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *HALIGN_ATTRIBUTE  =    "halign";
#line 127 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *POPUP_ATTRIBUTE  =    "popup";
#line 128 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *DELAY_ATTRIBUTE  =    "delay";
#line 129 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *ENABLED_ATTRIBUTE  =    "enabled";
#line 130 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *COORDINATES_ATTRIBUTE  =    "coordinates";
#line 131 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *TYPE_ATTRIBUTE  =    "type";
#line 133 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *FALSE_VALUE  =    "false";
#line 134 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *TRUE_VALUE  =    "true";
#line 136
static int ParseFile(char const   *fileName , int depth ) ;
#line 137
static char *ReadFile(FILE *fd ) ;
#line 140
static void Parse(TokenNode const   *start , int depth ) ;
#line 141
static void ParseInclude(TokenNode const   *tp , int depth ) ;
#line 142
static void ParseDesktops(TokenNode const   *tp ) ;
#line 143
static void ParseDesktop(int desktop , TokenNode const   *tp ) ;
#line 144
static void ParseDesktopBackground(int desktop , TokenNode const   *tp ) ;
#line 147
static void ParseRootMenu(TokenNode const   *start ) ;
#line 148
static MenuItem *ParseMenuItem(TokenNode const   *start , Menu *menu , MenuItem *last___0 ) ;
#line 150
static MenuItem *ParseMenuInclude(TokenNode const   *tp , Menu *menu , MenuItem *last___0 ) ;
#line 152
static MenuItem *InsertMenuItem(MenuItem *last___0 ) ;
#line 155
static void ParseTray(TokenNode const   *tp ) ;
#line 156
static void ParsePager(TokenNode const   *tp , TrayType *tray ) ;
#line 157
static void ParseTaskList(TokenNode const   *tp , TrayType *tray ) ;
#line 158
static void ParseSwallow(TokenNode const   *tp , TrayType *tray ) ;
#line 159
static void ParseTrayButton(TokenNode const   *tp , TrayType *tray ) ;
#line 160
static void ParseClock(TokenNode const   *tp , TrayType *tray ) ;
#line 161
static void ParseDock(TokenNode const   *tp , TrayType *tray ) ;
#line 162
static void ParseSpacer(TokenNode const   *tp , TrayType *tray ) ;
#line 165
static void ParseGroup(TokenNode const   *tp ) ;
#line 166
static void ParseGroupOption(TokenNode const   *tp , struct GroupType *group , char const   *option ) ;
#line 170
static void ParseWindowStyle(TokenNode const   *tp ) ;
#line 171
static void ParseActiveWindowStyle(TokenNode const   *tp ) ;
#line 172
static void ParseInactiveWindowStyle(TokenNode const   *tp ) ;
#line 173
static void ParseTaskListStyle(TokenNode const   *tp ) ;
#line 174
static void ParseTrayStyle(TokenNode const   *tp ) ;
#line 175
static void ParsePagerStyle(TokenNode const   *tp ) ;
#line 176
static void ParseMenuStyle(TokenNode const   *tp ) ;
#line 177
static void ParsePopupStyle(TokenNode const   *tp ) ;
#line 178
static void ParseClockStyle(TokenNode const   *tp ) ;
#line 179
static void ParseTrayButtonStyle(TokenNode const   *tp ) ;
#line 182
static void ParseKey(TokenNode const   *tp ) ;
#line 183
static void ParseSnapMode(TokenNode const   *tp ) ;
#line 184
static void ParseMoveMode(TokenNode const   *tp ) ;
#line 185
static void ParseResizeMode(TokenNode const   *tp ) ;
#line 186
static void ParseFocusModel(TokenNode const   *tp ) ;
#line 188
static void ParseGradient(char const   *value , ColorType a , ColorType b ) ;
#line 189
static char *FindAttribute(AttributeNode *ap , char const   *name ) ;
#line 190
static void ReleaseTokens(TokenNode *np ) ;
#line 191
static void InvalidTag(TokenNode const   *tp , TokenType parent ) ;
#line 192
static void ParseError(TokenNode const   *tp , char const   *str___0  , ...) ;
#line 195 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
void ParseConfig(char const   *fileName ) 
{ 
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 196
  tmp___2 = ParseFile(fileName, 0);
  }
#line 196
  if (! tmp___2) {
    {
#line 197
    tmp = ParseFile("/usr/local/etc/system.jwmrc", 0);
    }
#line 197
    if (tmp) {
#line 197
      tmp___0 = 0;
    } else {
#line 197
      tmp___0 = 1;
    }
    {
#line 197
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 197
    if (tmp___1) {
      {
#line 198
      ParseError((TokenNode const   *)((void *)0), "could not open %s or %s", fileName,
                 "/usr/local/etc/system.jwmrc");
      }
    }
  }
  {
#line 201
  ValidateTrayButtons();
#line 202
  ValidateKeys();
  }
#line 203
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static int ParseFile(char const   *fileName , int depth ) 
{ 
  TokenNode *tokens ;
  FILE *fd ;
  char *buffer ;
  long tmp ;

  {
  {
#line 215
  depth ++;
#line 216
  tmp = __builtin_expect((long )(! (! (depth > 16))), 0L);
  }
#line 216
  if (tmp) {
    {
#line 217
    ParseError((TokenNode const   *)((void *)0), "include depth (%d) exceeded", 16);
    }
#line 218
    return (0);
  }
  {
#line 221
  fd = fopen((char const   */* __restrict  */)fileName, (char const   */* __restrict  */)"r");
  }
#line 222
  if (! fd) {
#line 223
    return (0);
  }
  {
#line 226
  buffer = ReadFile(fd);
#line 227
  fclose(fd);
#line 229
  tokens = Tokenize((char const   *)buffer, fileName);
#line 230
  free((void *)buffer);
#line 231
  Parse((TokenNode const   *)tokens, depth);
#line 232
  ReleaseTokens(tokens);
  }
#line 234
  return (1);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ReleaseTokens(TokenNode *np ) 
{ 
  AttributeNode *ap ;
  TokenNode *tp ;

  {
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! np) {
#line 244
      goto while_break;
    }
#line 245
    tp = np->next;
    {
#line 247
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 247
      if (! np->attributes) {
#line 247
        goto while_break___0;
      }
#line 248
      ap = (np->attributes)->next;
#line 249
      if ((np->attributes)->name) {
        {
#line 250
        free((void *)(np->attributes)->name);
        }
      }
#line 252
      if ((np->attributes)->value) {
        {
#line 253
        free((void *)(np->attributes)->value);
        }
      }
      {
#line 255
      free((void *)np->attributes);
#line 256
      np->attributes = ap;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 259
    if (np->subnodeHead) {
      {
#line 260
      ReleaseTokens(np->subnodeHead);
      }
    }
#line 263
    if (np->value) {
      {
#line 264
      free((void *)np->value);
      }
    }
#line 267
    if (np->invalidName) {
      {
#line 268
      free((void *)np->invalidName);
      }
    }
#line 271
    if (np->fileName) {
      {
#line 272
      free((void *)np->fileName);
      }
    }
    {
#line 275
    free((void *)np);
#line 276
    np = tp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void Parse(TokenNode const   *start , int depth ) 
{ 
  TokenNode *tp ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 286
  if (! start) {
#line 287
    return;
  }
  {
#line 290
  tmp___0 = __builtin_expect((long )(! (! ((unsigned int const   )start->type == 28U))),
                             1L);
  }
#line 290
  if (tmp___0) {
#line 291
    tp = (TokenNode *)start->subnodeHead;
    {
#line 291
    while (1) {
      while_continue: /* CIL Label */ ;
#line 291
      if (! tp) {
#line 291
        goto while_break;
      }
#line 292
      if (shouldReload) {
        {
#line 294
        if ((unsigned int )tp->type == 51U) {
#line 294
          goto case_51;
        }
#line 297
        if ((unsigned int )tp->type == 27U) {
#line 297
          goto case_27;
        }
#line 300
        goto switch_default;
        case_51: /* CIL Label */ 
        {
#line 295
        ParseRootMenu((TokenNode const   *)tp);
        }
#line 296
        goto switch_break;
        case_27: /* CIL Label */ 
        {
#line 298
        ParseInclude((TokenNode const   *)tp, depth);
        }
#line 299
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 301
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 305
        if ((unsigned int )tp->type == 14U) {
#line 305
          goto case_14;
        }
#line 308
        if ((unsigned int )tp->type == 17U) {
#line 308
          goto case_17;
        }
#line 311
        if ((unsigned int )tp->type == 18U) {
#line 311
          goto case_18;
        }
#line 314
        if ((unsigned int )tp->type == 20U) {
#line 314
          goto case_20;
        }
#line 317
        if ((unsigned int )tp->type == 23U) {
#line 317
          goto case_23;
        }
#line 320
        if ((unsigned int )tp->type == 25U) {
#line 320
          goto case_25;
        }
#line 323
        if ((unsigned int )tp->type == 27U) {
#line 323
          goto case_27___0;
        }
#line 326
        if ((unsigned int )tp->type == 29U) {
#line 326
          goto case_29;
        }
#line 329
        if ((unsigned int )tp->type == 34U) {
#line 329
          goto case_34;
        }
#line 332
        if ((unsigned int )tp->type == 37U) {
#line 332
          goto case_37;
        }
#line 335
        if ((unsigned int )tp->type == 43U) {
#line 335
          goto case_43;
        }
#line 338
        if ((unsigned int )tp->type == 45U) {
#line 338
          goto case_45;
        }
#line 341
        if ((unsigned int )tp->type == 48U) {
#line 341
          goto case_48;
        }
#line 344
        if ((unsigned int )tp->type == 50U) {
#line 344
          goto case_50;
        }
#line 347
        if ((unsigned int )tp->type == 51U) {
#line 347
          goto case_51___0;
        }
#line 350
        if ((unsigned int )tp->type == 55U) {
#line 350
          goto case_55;
        }
#line 353
        if ((unsigned int )tp->type == 56U) {
#line 353
          goto case_56;
        }
#line 356
        if ((unsigned int )tp->type == 58U) {
#line 356
          goto case_58;
        }
#line 359
        if ((unsigned int )tp->type == 61U) {
#line 359
          goto case_61;
        }
#line 362
        if ((unsigned int )tp->type == 65U) {
#line 362
          goto case_65;
        }
#line 365
        if ((unsigned int )tp->type == 68U) {
#line 365
          goto case_68;
        }
#line 368
        if ((unsigned int )tp->type == 67U) {
#line 368
          goto case_67;
        }
#line 371
        if ((unsigned int )tp->type == 12U) {
#line 371
          goto case_12;
        }
#line 374
        if ((unsigned int )tp->type == 70U) {
#line 374
          goto case_70;
        }
#line 377
        if ((unsigned int )tp->type == 6U) {
#line 377
          goto case_6;
        }
#line 380
        if ((unsigned int )tp->type == 9U) {
#line 380
          goto case_9;
        }
#line 383
        if ((unsigned int )tp->type == 7U) {
#line 383
          goto case_7;
        }
#line 386
        if ((unsigned int )tp->type == 8U) {
#line 386
          goto case_8;
        }
#line 389
        goto switch_default___0;
        case_14: /* CIL Label */ 
        {
#line 306
        ParseDesktops((TokenNode const   *)tp);
        }
#line 307
        goto switch_break___0;
        case_17: /* CIL Label */ 
        {
#line 309
        SetDoubleClickSpeed((char const   *)tp->value);
        }
#line 310
        goto switch_break___0;
        case_18: /* CIL Label */ 
        {
#line 312
        SetDoubleClickDelta((char const   *)tp->value);
        }
#line 313
        goto switch_break___0;
        case_20: /* CIL Label */ 
        {
#line 315
        ParseFocusModel((TokenNode const   *)tp);
        }
#line 316
        goto switch_break___0;
        case_23: /* CIL Label */ 
        {
#line 318
        ParseGroup((TokenNode const   *)tp);
        }
#line 319
        goto switch_break___0;
        case_25: /* CIL Label */ 
        {
#line 321
        AddIconPath(tp->value);
        }
#line 322
        goto switch_break___0;
        case_27___0: /* CIL Label */ 
        {
#line 324
        ParseInclude((TokenNode const   *)tp, depth);
        }
#line 325
        goto switch_break___0;
        case_29: /* CIL Label */ 
        {
#line 327
        ParseKey((TokenNode const   *)tp);
        }
#line 328
        goto switch_break___0;
        case_34: /* CIL Label */ 
        {
#line 330
        ParseMenuStyle((TokenNode const   *)tp);
        }
#line 331
        goto switch_break___0;
        case_37: /* CIL Label */ 
        {
#line 333
        ParseMoveMode((TokenNode const   *)tp);
        }
#line 334
        goto switch_break___0;
        case_43: /* CIL Label */ 
        {
#line 336
        ParsePagerStyle((TokenNode const   *)tp);
        }
#line 337
        goto switch_break___0;
        case_45: /* CIL Label */ 
        {
#line 339
        ParsePopupStyle((TokenNode const   *)tp);
        }
#line 340
        goto switch_break___0;
        case_48: /* CIL Label */ 
        {
#line 342
        ParseResizeMode((TokenNode const   *)tp);
        }
#line 343
        goto switch_break___0;
        case_50: /* CIL Label */ 
        {
#line 345
        AddRestartCommand((char const   *)tp->value);
        }
#line 346
        goto switch_break___0;
        case_51___0: /* CIL Label */ 
        {
#line 348
        ParseRootMenu((TokenNode const   *)tp);
        }
#line 349
        goto switch_break___0;
        case_55: /* CIL Label */ 
        {
#line 351
        AddShutdownCommand((char const   *)tp->value);
        }
#line 352
        goto switch_break___0;
        case_56: /* CIL Label */ 
        {
#line 354
        ParseSnapMode((TokenNode const   *)tp);
        }
#line 355
        goto switch_break___0;
        case_58: /* CIL Label */ 
        {
#line 357
        AddStartupCommand((char const   *)tp->value);
        }
#line 358
        goto switch_break___0;
        case_61: /* CIL Label */ 
        {
#line 360
        ParseTaskListStyle((TokenNode const   *)tp);
        }
#line 361
        goto switch_break___0;
        case_65: /* CIL Label */ 
        {
#line 363
        ParseTray((TokenNode const   *)tp);
        }
#line 364
        goto switch_break___0;
        case_68: /* CIL Label */ 
        {
#line 366
        ParseTrayStyle((TokenNode const   *)tp);
        }
#line 367
        goto switch_break___0;
        case_67: /* CIL Label */ 
        {
#line 369
        ParseTrayButtonStyle((TokenNode const   *)tp);
        }
#line 370
        goto switch_break___0;
        case_12: /* CIL Label */ 
        {
#line 372
        ParseClockStyle((TokenNode const   *)tp);
        }
#line 373
        goto switch_break___0;
        case_70: /* CIL Label */ 
        {
#line 375
        ParseWindowStyle((TokenNode const   *)tp);
        }
#line 376
        goto switch_break___0;
        case_6: /* CIL Label */ 
        {
#line 378
        SetButtonMask((BorderPixmapType )0, (char const   *)tp->value);
        }
#line 379
        goto switch_break___0;
        case_9: /* CIL Label */ 
        {
#line 381
        SetButtonMask((BorderPixmapType )1, (char const   *)tp->value);
        }
#line 382
        goto switch_break___0;
        case_7: /* CIL Label */ 
        {
#line 384
        SetButtonMask((BorderPixmapType )2, (char const   *)tp->value);
        }
#line 385
        goto switch_break___0;
        case_8: /* CIL Label */ 
        {
#line 387
        SetButtonMask((BorderPixmapType )3, (char const   *)tp->value);
        }
#line 388
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 390
        InvalidTag((TokenNode const   *)tp, (TokenType )28);
        }
#line 391
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
#line 291
      tp = tp->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 396
    tmp = GetTokenName(start);
#line 396
    ParseError(start, "invalid start tag: %s", tmp);
    }
  }
#line 399
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseFocusModel(TokenNode const   *tp ) 
{ 
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 403
  tmp___1 = __builtin_expect((long )(! (! tp->value)), 1L);
  }
#line 403
  if (tmp___1) {
    {
#line 404
    tmp___0 = strcmp((char const   *)tp->value, "sloppy");
    }
#line 404
    if (tmp___0) {
      {
#line 406
      tmp = strcmp((char const   *)tp->value, "click");
      }
#line 406
      if (tmp) {
        {
#line 409
        ParseError(tp, "invalid focus model: \"%s\"", tp->value);
        }
      } else {
#line 407
        focusModel = (FocusModelType )1;
      }
    } else {
#line 405
      focusModel = (FocusModelType )0;
    }
  } else {
    {
#line 412
    ParseError(tp, "focus model not specified");
    }
  }
#line 414
  return;
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseSnapMode(TokenNode const   *tp ) 
{ 
  char const   *distance ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 421
  tmp = FindAttribute((AttributeNode *)tp->attributes, DISTANCE_ATTRIBUTE);
#line 421
  distance = (char const   *)tmp;
  }
#line 422
  if (distance) {
    {
#line 423
    SetSnapDistance(distance);
    }
  } else {
    {
#line 425
    SetDefaultSnapDistance();
    }
  }
  {
#line 428
  tmp___3 = __builtin_expect((long )(! (! tp->value)), 1L);
  }
#line 428
  if (tmp___3) {
    {
#line 429
    tmp___2 = strcmp((char const   *)tp->value, "none");
    }
#line 429
    if (tmp___2) {
      {
#line 431
      tmp___1 = strcmp((char const   *)tp->value, "screen");
      }
#line 431
      if (tmp___1) {
        {
#line 433
        tmp___0 = strcmp((char const   *)tp->value, "border");
        }
#line 433
        if (tmp___0) {
          {
#line 436
          ParseError(tp, "invalid snap mode: %s", tp->value);
          }
        } else {
          {
#line 434
          SetSnapMode((SnapModeType )2);
          }
        }
      } else {
        {
#line 432
        SetSnapMode((SnapModeType )1);
        }
      }
    } else {
      {
#line 430
      SetSnapMode((SnapModeType )0);
      }
    }
  } else {
    {
#line 439
    ParseError(tp, "snap mode not specified");
    }
  }
#line 441
  return;
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseMoveMode(TokenNode const   *tp ) 
{ 
  char const   *str___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 448
  tmp = FindAttribute((AttributeNode *)tp->attributes, COORDINATES_ATTRIBUTE);
#line 448
  str___0 = (char const   *)tmp;
#line 449
  SetMoveStatusType(str___0);
#line 451
  tmp___2 = __builtin_expect((long )(! (! tp->value)), 1L);
  }
#line 451
  if (tmp___2) {
    {
#line 452
    tmp___1 = strcmp((char const   *)tp->value, "outline");
    }
#line 452
    if (tmp___1) {
      {
#line 454
      tmp___0 = strcmp((char const   *)tp->value, "opaque");
      }
#line 454
      if (tmp___0) {
        {
#line 457
        ParseError(tp, "invalid move mode: %s", tp->value);
        }
      } else {
        {
#line 455
        SetMoveMode((MoveModeType )0);
        }
      }
    } else {
      {
#line 453
      SetMoveMode((MoveModeType )1);
      }
    }
  } else {
    {
#line 460
    ParseError(tp, "move mode not specified");
    }
  }
#line 463
  return;
}
}
#line 466 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseResizeMode(TokenNode const   *tp ) 
{ 
  char const   *str___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 470
  tmp = FindAttribute((AttributeNode *)tp->attributes, COORDINATES_ATTRIBUTE);
#line 470
  str___0 = (char const   *)tmp;
#line 471
  SetResizeStatusType(str___0);
#line 473
  tmp___2 = __builtin_expect((long )(! (! tp->value)), 1L);
  }
#line 473
  if (tmp___2) {
    {
#line 474
    tmp___1 = strcmp((char const   *)tp->value, "outline");
    }
#line 474
    if (tmp___1) {
      {
#line 476
      tmp___0 = strcmp((char const   *)tp->value, "opaque");
      }
#line 476
      if (tmp___0) {
        {
#line 479
        ParseError(tp, "invalid resize mode: %s", tp->value);
        }
      } else {
        {
#line 477
        SetResizeMode((ResizeModeType )0);
        }
      }
    } else {
      {
#line 475
      SetResizeMode((ResizeModeType )1);
      }
    }
  } else {
    {
#line 482
    ParseError(tp, "resize mode not specified");
    }
  }
#line 485
  return;
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseRootMenu(TokenNode const   *start ) 
{ 
  char const   *value ;
  Menu *menu ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 493
  tmp = malloc(sizeof(Menu ));
#line 493
  menu = (Menu *)tmp;
#line 495
  tmp___0 = FindAttribute((AttributeNode *)start->attributes, HEIGHT_ATTRIBUTE);
#line 495
  value = (char const   *)tmp___0;
  }
#line 496
  if (value) {
    {
#line 497
    menu->itemHeight = atoi(value);
    }
  } else {
#line 499
    menu->itemHeight = 0;
  }
  {
#line 502
  tmp___1 = FindAttribute((AttributeNode *)start->attributes, LABELED_ATTRIBUTE);
#line 502
  value = (char const   *)tmp___1;
  }
#line 503
  if (value) {
    {
#line 503
    tmp___3 = strcmp(value, TRUE_VALUE);
    }
#line 503
    if (tmp___3) {
#line 510
      menu->label = (char *)((void *)0);
    } else {
      {
#line 504
      tmp___2 = FindAttribute((AttributeNode *)start->attributes, LABEL_ATTRIBUTE);
#line 504
      value = (char const   *)tmp___2;
      }
#line 505
      if (! value) {
#line 506
        value = DEFAULT_TITLE;
      }
      {
#line 508
      menu->label = CopyString(value);
      }
    }
  } else {
#line 510
    menu->label = (char *)((void *)0);
  }
  {
#line 513
  menu->items = (struct MenuItem *)((void *)0);
#line 514
  ParseMenuItem((TokenNode const   *)start->subnodeHead, menu, (MenuItem *)((void *)0));
#line 516
  tmp___4 = FindAttribute((AttributeNode *)start->attributes, ONROOT_ATTRIBUTE);
#line 516
  value = (char const   *)tmp___4;
  }
#line 517
  if (! value) {
#line 518
    value = "123";
  }
  {
#line 521
  SetRootMenu(value, menu);
  }
#line 523
  return;
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static MenuItem *InsertMenuItem(MenuItem *last___0 ) 
{ 
  MenuItem *item ;
  void *tmp ;

  {
  {
#line 530
  tmp = malloc(sizeof(MenuItem ));
#line 530
  item = (MenuItem *)tmp;
#line 531
  item->name = (char *)((void *)0);
#line 532
  item->type = (MenuItemType )0;
#line 533
  item->iconName = (char *)((void *)0);
#line 534
  item->action.type = (MenuActionType )0;
#line 535
  item->action.data.str = (char *)((void *)0);
#line 536
  item->submenu = (struct Menu *)((void *)0);
#line 538
  item->next = (struct MenuItem *)((void *)0);
  }
#line 539
  if (last___0) {
#line 540
    last___0->next = item;
  }
#line 543
  return (item);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static MenuItem *ParseMenuItem(TokenNode const   *start , Menu *menu , MenuItem *last___0 ) 
{ 
  Menu *child ;
  char const   *value ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 556
  menu->offsets = (int *)((void *)0);
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! start) {
#line 557
      goto while_break;
    }
    {
#line 559
    if ((unsigned int const   )start->type == 27U) {
#line 559
      goto case_27;
    }
#line 564
    if ((unsigned int const   )start->type == 33U) {
#line 564
      goto case_33;
    }
#line 603
    if ((unsigned int const   )start->type == 46U) {
#line 603
      goto case_46;
    }
#line 624
    if ((unsigned int const   )start->type == 53U) {
#line 624
      goto case_53;
    }
#line 641
    if ((unsigned int const   )start->type == 13U) {
#line 641
      goto case_13;
    }
#line 641
    if ((unsigned int const   )start->type == 30U) {
#line 641
      goto case_13;
    }
#line 641
    if ((unsigned int const   )start->type == 47U) {
#line 641
      goto case_13;
    }
#line 641
    if ((unsigned int const   )start->type == 36U) {
#line 641
      goto case_13;
    }
#line 641
    if ((unsigned int const   )start->type == 54U) {
#line 641
      goto case_13;
    }
#line 641
    if ((unsigned int const   )start->type == 35U) {
#line 641
      goto case_13;
    }
#line 641
    if ((unsigned int const   )start->type == 32U) {
#line 641
      goto case_13;
    }
#line 641
    if ((unsigned int const   )start->type == 59U) {
#line 641
      goto case_13;
    }
#line 641
    if ((unsigned int const   )start->type == 14U) {
#line 641
      goto case_13;
    }
#line 690
    if ((unsigned int const   )start->type == 19U) {
#line 690
      goto case_19;
    }
#line 717
    if ((unsigned int const   )start->type == 49U) {
#line 717
      goto case_49;
    }
#line 736
    goto switch_default___0;
    case_27: /* CIL Label */ 
    {
#line 561
    last___0 = ParseMenuInclude(start, menu, last___0);
    }
#line 563
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 566
    last___0 = InsertMenuItem(last___0);
#line 567
    last___0->type = (MenuItemType )1;
    }
#line 568
    if (! menu->items) {
#line 569
      menu->items = last___0;
    }
    {
#line 572
    tmp = FindAttribute((AttributeNode *)start->attributes, LABEL_ATTRIBUTE);
#line 572
    value = (char const   *)tmp;
#line 573
    last___0->name = CopyString(value);
#line 575
    tmp___0 = FindAttribute((AttributeNode *)start->attributes, ICON_ATTRIBUTE);
#line 575
    value = (char const   *)tmp___0;
#line 576
    last___0->iconName = CopyString(value);
#line 578
    tmp___1 = malloc(sizeof(Menu ));
#line 578
    last___0->submenu = (struct Menu *)tmp___1;
#line 579
    child = last___0->submenu;
#line 581
    tmp___2 = FindAttribute((AttributeNode *)start->attributes, HEIGHT_ATTRIBUTE);
#line 581
    value = (char const   *)tmp___2;
    }
#line 582
    if (value) {
      {
#line 583
      child->itemHeight = atoi(value);
      }
    } else {
#line 585
      child->itemHeight = menu->itemHeight;
    }
    {
#line 588
    tmp___3 = FindAttribute((AttributeNode *)start->attributes, LABELED_ATTRIBUTE);
#line 588
    value = (char const   *)tmp___3;
    }
#line 589
    if (value) {
      {
#line 589
      tmp___4 = strcmp(value, TRUE_VALUE);
      }
#line 589
      if (tmp___4) {
#line 596
        child->label = (char *)((void *)0);
      } else
#line 590
      if (last___0->name) {
        {
#line 591
        child->label = CopyString((char const   *)last___0->name);
        }
      } else {
        {
#line 593
        child->label = CopyString(DEFAULT_TITLE);
        }
      }
    } else {
#line 596
      child->label = (char *)((void *)0);
    }
    {
#line 599
    (last___0->submenu)->items = (struct MenuItem *)((void *)0);
#line 600
    ParseMenuItem((TokenNode const   *)start->subnodeHead, last___0->submenu, (MenuItem *)((void *)0));
    }
#line 602
    goto switch_break;
    case_46: /* CIL Label */ 
    {
#line 605
    last___0 = InsertMenuItem(last___0);
    }
#line 606
    if (! menu->items) {
#line 607
      menu->items = last___0;
    }
    {
#line 610
    tmp___5 = FindAttribute((AttributeNode *)start->attributes, LABEL_ATTRIBUTE);
#line 610
    value = (char const   *)tmp___5;
    }
#line 611
    if (value) {
      {
#line 612
      last___0->name = CopyString(value);
      }
    } else
#line 613
    if (start->value) {
      {
#line 614
      last___0->name = CopyString((char const   *)start->value);
      }
    }
    {
#line 617
    tmp___6 = FindAttribute((AttributeNode *)start->attributes, ICON_ATTRIBUTE);
#line 617
    value = (char const   *)tmp___6;
#line 618
    last___0->iconName = CopyString(value);
#line 620
    last___0->action.type = (MenuActionType )1;
#line 621
    last___0->action.data.str = CopyString((char const   *)start->value);
    }
#line 623
    goto switch_break;
    case_53: /* CIL Label */ 
    {
#line 626
    last___0 = InsertMenuItem(last___0);
#line 627
    last___0->type = (MenuItemType )2;
    }
#line 628
    if (! menu->items) {
#line 629
      menu->items = last___0;
    }
#line 632
    goto switch_break;
    case_13: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_47: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_14: /* CIL Label */ 
    {
#line 643
    last___0 = InsertMenuItem(last___0);
    }
#line 644
    if (! menu->items) {
#line 645
      menu->items = last___0;
    }
    {
#line 648
    tmp___7 = FindAttribute((AttributeNode *)start->attributes, LABEL_ATTRIBUTE);
#line 648
    value = (char const   *)tmp___7;
    }
#line 649
    if (! value) {
      {
#line 650
      value = GetTokenName(start);
      }
    }
    {
#line 652
    last___0->name = CopyString(value);
#line 654
    tmp___8 = FindAttribute((AttributeNode *)start->attributes, ICON_ATTRIBUTE);
#line 654
    value = (char const   *)tmp___8;
#line 655
    last___0->iconName = CopyString(value);
    }
    {
#line 658
    if ((unsigned int const   )start->type == 14U) {
#line 658
      goto case_14___0;
    }
#line 661
    if ((unsigned int const   )start->type == 59U) {
#line 661
      goto case_59___0;
    }
#line 664
    if ((unsigned int const   )start->type == 32U) {
#line 664
      goto case_32___0;
    }
#line 667
    if ((unsigned int const   )start->type == 35U) {
#line 667
      goto case_35___0;
    }
#line 670
    if ((unsigned int const   )start->type == 54U) {
#line 670
      goto case_54___0;
    }
#line 673
    if ((unsigned int const   )start->type == 36U) {
#line 673
      goto case_36___0;
    }
#line 676
    if ((unsigned int const   )start->type == 47U) {
#line 676
      goto case_47___0;
    }
#line 679
    if ((unsigned int const   )start->type == 30U) {
#line 679
      goto case_30___0;
    }
#line 682
    if ((unsigned int const   )start->type == 13U) {
#line 682
      goto case_13___0;
    }
#line 685
    goto switch_default;
    case_14___0: /* CIL Label */ 
#line 659
    last___0->action.type = (MenuActionType )2;
#line 660
    goto switch_break___0;
    case_59___0: /* CIL Label */ 
#line 662
    last___0->action.type = (MenuActionType )5;
#line 663
    goto switch_break___0;
    case_32___0: /* CIL Label */ 
#line 665
    last___0->action.type = (MenuActionType )6;
#line 666
    goto switch_break___0;
    case_35___0: /* CIL Label */ 
#line 668
    last___0->action.type = (MenuActionType )9;
#line 669
    goto switch_break___0;
    case_54___0: /* CIL Label */ 
#line 671
    last___0->action.type = (MenuActionType )11;
#line 672
    goto switch_break___0;
    case_36___0: /* CIL Label */ 
#line 674
    last___0->action.type = (MenuActionType )12;
#line 675
    goto switch_break___0;
    case_47___0: /* CIL Label */ 
#line 677
    last___0->action.type = (MenuActionType )13;
#line 678
    goto switch_break___0;
    case_30___0: /* CIL Label */ 
#line 680
    last___0->action.type = (MenuActionType )14;
#line 681
    goto switch_break___0;
    case_13___0: /* CIL Label */ 
#line 683
    last___0->action.type = (MenuActionType )15;
#line 684
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 686
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 689
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 692
    last___0 = InsertMenuItem(last___0);
    }
#line 693
    if (! menu->items) {
#line 694
      menu->items = last___0;
    }
    {
#line 697
    tmp___9 = FindAttribute((AttributeNode *)start->attributes, CONFIRM_ATTRIBUTE);
#line 697
    value = (char const   *)tmp___9;
    }
#line 698
    if (value) {
      {
#line 698
      tmp___10 = strcmp(value, FALSE_VALUE);
      }
#line 698
      if (tmp___10) {
        {
#line 701
        SetShowExitConfirmation((char)1);
        }
      } else {
        {
#line 699
        SetShowExitConfirmation((char)0);
        }
      }
    } else {
      {
#line 701
      SetShowExitConfirmation((char)1);
      }
    }
    {
#line 704
    tmp___11 = FindAttribute((AttributeNode *)start->attributes, LABEL_ATTRIBUTE);
#line 704
    value = (char const   *)tmp___11;
    }
#line 705
    if (! value) {
      {
#line 706
      value = GetTokenName(start);
      }
    }
    {
#line 708
    last___0->name = CopyString(value);
#line 710
    tmp___12 = FindAttribute((AttributeNode *)start->attributes, ICON_ATTRIBUTE);
#line 710
    value = (char const   *)tmp___12;
#line 711
    last___0->iconName = CopyString(value);
#line 713
    last___0->action.type = (MenuActionType )16;
#line 714
    last___0->action.data.str = CopyString((char const   *)start->value);
    }
#line 716
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 719
    last___0 = InsertMenuItem(last___0);
    }
#line 720
    if (! menu->items) {
#line 721
      menu->items = last___0;
    }
    {
#line 724
    tmp___13 = FindAttribute((AttributeNode *)start->attributes, LABEL_ATTRIBUTE);
#line 724
    value = (char const   *)tmp___13;
    }
#line 725
    if (! value) {
      {
#line 726
      value = GetTokenName(start);
      }
    }
    {
#line 728
    last___0->name = CopyString(value);
#line 730
    tmp___14 = FindAttribute((AttributeNode *)start->attributes, ICON_ATTRIBUTE);
#line 730
    value = (char const   *)tmp___14;
#line 731
    last___0->iconName = CopyString(value);
#line 733
    last___0->action.type = (MenuActionType )17;
    }
#line 735
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 737
    InvalidTag(start, (TokenType )33);
    }
#line 738
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 740
    start = (TokenNode const   *)start->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 743
  return (last___0);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static MenuItem *ParseMenuInclude(TokenNode const   *tp , Menu *menu , MenuItem *last___0 ) 
{ 
  FILE *fd ;
  char *path ;
  char *buffer ;
  TokenNode *start ;
  size_t tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
  {
#line 753
  buffer = (char *)((void *)0);
#line 758
  tmp___3 = strncmp((char const   *)tp->value, "exec:", (size_t )5);
  }
#line 758
  if (tmp___3) {
    {
#line 774
    path = CopyString((char const   *)tp->value);
#line 775
    ExpandPath(& path);
#line 777
    fd = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
#line 778
    tmp___2 = __builtin_expect((long )(! (! fd)), 1L);
    }
#line 778
    if (tmp___2) {
      {
#line 779
      buffer = ReadFile(fd);
#line 780
      fclose(fd);
      }
    } else {
      {
#line 782
      ParseError(tp, "could not open include: %s", path);
      }
    }
  } else {
    {
#line 760
    tmp = strlen((char const   *)tp->value);
#line 760
    tmp___0 = malloc((tmp - 5UL) + 1UL);
#line 760
    path = (char *)tmp___0;
#line 761
    strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)(tp->value + 5));
#line 762
    ExpandPath(& path);
#line 764
    fd = popen((char const   *)path, "r");
#line 765
    tmp___1 = __builtin_expect((long )(! (! fd)), 1L);
    }
#line 765
    if (tmp___1) {
      {
#line 766
      buffer = ReadFile(fd);
#line 767
      pclose(fd);
      }
    } else {
      {
#line 769
      ParseError(tp, "could not execute included program: %s", path);
      }
    }
  }
#line 787
  if (! buffer) {
    {
#line 788
    free((void *)path);
    }
#line 789
    return (last___0);
  }
  {
#line 792
  start = Tokenize((char const   *)buffer, (char const   *)path);
#line 793
  free((void *)buffer);
#line 794
  free((void *)path);
  }
#line 796
  if (! start) {
#line 796
    tmp___4 = 1;
  } else
#line 796
  if ((unsigned int )start->type != 28U) {
#line 796
    tmp___4 = 1;
  } else {
#line 796
    tmp___4 = 0;
  }
  {
#line 796
  tmp___5 = __builtin_expect((long )tmp___4, 0L);
  }
#line 796
  if (tmp___5) {
    {
#line 797
    ParseError(tp, "invalid included menu: %s", tp->value);
    }
  } else {
    {
#line 799
    last___0 = ParseMenuItem((TokenNode const   *)start->subnodeHead, menu, last___0);
    }
  }
#line 802
  if (start) {
    {
#line 803
    ReleaseTokens(start);
    }
  }
#line 806
  return (last___0);
}
}
#line 811 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseKey(TokenNode const   *tp ) 
{ 
  char const   *key ;
  char const   *code ;
  char const   *mask ;
  char const   *action ;
  char const   *command ;
  KeyType k ;
  int x ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;

  {
  {
#line 823
  tmp = FindAttribute((AttributeNode *)tp->attributes, "mask");
#line 823
  mask = (char const   *)tmp;
#line 824
  tmp___0 = FindAttribute((AttributeNode *)tp->attributes, "key");
#line 824
  key = (char const   *)tmp___0;
#line 825
  tmp___1 = FindAttribute((AttributeNode *)tp->attributes, "keycode");
#line 825
  code = (char const   *)tmp___1;
#line 827
  action = (char const   *)tp->value;
#line 828
  tmp___2 = __builtin_expect((long )(! (! ((unsigned long )action == (unsigned long )((void *)0)))),
                             0L);
  }
#line 828
  if (tmp___2) {
    {
#line 829
    ParseError(tp, "no action specified for Key");
    }
#line 830
    return;
  }
  {
#line 833
  command = (char const   *)((void *)0);
#line 834
  k = (KeyType )0;
#line 835
  tmp___5 = strncmp(action, "exec:", (size_t )5);
  }
#line 835
  if (tmp___5) {
    {
#line 838
    tmp___4 = strncmp(action, "root:", (size_t )5);
    }
#line 838
    if (tmp___4) {
#line 842
      x = 0;
      {
#line 842
      while (1) {
        while_continue: /* CIL Label */ ;
#line 842
        if (! KEY_MAP[x].name) {
#line 842
          goto while_break;
        }
        {
#line 843
        tmp___3 = strcmp(action, (char const   *)KEY_MAP[x].name);
        }
#line 843
        if (! tmp___3) {
#line 844
          k = (KeyType )KEY_MAP[x].key;
#line 845
          goto while_break;
        }
#line 842
        x ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 839
      k = (KeyType )18;
#line 840
      command = action + 5;
    }
  } else {
#line 836
    k = (KeyType )27;
#line 837
    command = action + 5;
  }
  {
#line 851
  tmp___6 = __builtin_expect((long )(! (! ((unsigned int )k == 0U))), 0L);
  }
#line 851
  if (tmp___6) {
    {
#line 853
    ParseError(tp, "invalid Key action: \"%s\"", action);
    }
  } else {
    {
#line 857
    InsertBinding(k, mask, key, code, command);
    }
  }
#line 861
  return;
}
}
#line 864 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseWindowStyle(TokenNode const   *tp ) 
{ 
  TokenNode const   *np ;

  {
#line 870
  np = (TokenNode const   *)tp->subnodeHead;
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if (! np) {
#line 870
      goto while_break;
    }
    {
#line 872
    if ((unsigned int const   )np->type == 21U) {
#line 872
      goto case_21;
    }
#line 875
    if ((unsigned int const   )np->type == 69U) {
#line 875
      goto case_69;
    }
#line 878
    if ((unsigned int const   )np->type == 24U) {
#line 878
      goto case_24;
    }
#line 881
    if ((unsigned int const   )np->type == 1U) {
#line 881
      goto case_1;
    }
#line 884
    if ((unsigned int const   )np->type == 26U) {
#line 884
      goto case_26;
    }
#line 887
    goto switch_default;
    case_21: /* CIL Label */ 
    {
#line 873
    SetFont((FontType )0, (char const   *)np->value);
    }
#line 874
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 876
    SetBorderWidth((char const   *)np->value);
    }
#line 877
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 879
    SetTitleHeight((char const   *)np->value);
    }
#line 880
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 882
    ParseActiveWindowStyle(np);
    }
#line 883
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 885
    ParseInactiveWindowStyle(np);
    }
#line 886
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 888
    InvalidTag(np, (TokenType )70);
    }
#line 889
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 870
    np = (TokenNode const   *)np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 893
  return;
}
}
#line 896 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseActiveWindowStyle(TokenNode const   *tp ) 
{ 
  TokenNode const   *np ;

  {
#line 902
  np = (TokenNode const   *)tp->subnodeHead;
  {
#line 902
  while (1) {
    while_continue: /* CIL Label */ ;
#line 902
    if (! np) {
#line 902
      goto while_break;
    }
    {
#line 904
    if ((unsigned int const   )np->type == 63U) {
#line 904
      goto case_63;
    }
#line 907
    if ((unsigned int const   )np->type == 64U) {
#line 907
      goto case_64;
    }
#line 911
    if ((unsigned int const   )np->type == 41U) {
#line 911
      goto case_41;
    }
#line 914
    if ((unsigned int const   )np->type == 39U) {
#line 914
      goto case_39;
    }
#line 917
    goto switch_default;
    case_63: /* CIL Label */ 
    {
#line 905
    SetColor((ColorType )1, (char const   *)np->value);
    }
#line 906
    goto switch_break;
    case_64: /* CIL Label */ 
    {
#line 908
    ParseGradient((char const   *)np->value, (ColorType )4, (ColorType )5);
    }
#line 910
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 912
    SetColor((ColorType )7, (char const   *)np->value);
    }
#line 913
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 915
    SetActiveClientOpacity((char const   *)np->value);
    }
#line 916
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 918
    InvalidTag(np, (TokenType )1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 902
    np = (TokenNode const   *)np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 922
  return;
}
}
#line 925 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseInactiveWindowStyle(TokenNode const   *tp ) 
{ 
  TokenNode const   *np ;

  {
#line 931
  np = (TokenNode const   *)tp->subnodeHead;
  {
#line 931
  while (1) {
    while_continue: /* CIL Label */ ;
#line 931
    if (! np) {
#line 931
      goto while_break;
    }
    {
#line 933
    if ((unsigned int const   )np->type == 63U) {
#line 933
      goto case_63;
    }
#line 936
    if ((unsigned int const   )np->type == 64U) {
#line 936
      goto case_64;
    }
#line 939
    if ((unsigned int const   )np->type == 41U) {
#line 939
      goto case_41;
    }
#line 942
    if ((unsigned int const   )np->type == 39U) {
#line 942
      goto case_39;
    }
#line 945
    goto switch_default;
    case_63: /* CIL Label */ 
    {
#line 934
    SetColor((ColorType )0, (char const   *)np->value);
    }
#line 935
    goto switch_break;
    case_64: /* CIL Label */ 
    {
#line 937
    ParseGradient((char const   *)np->value, (ColorType )2, (ColorType )3);
    }
#line 938
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 940
    SetColor((ColorType )6, (char const   *)np->value);
    }
#line 941
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 943
    SetInactiveClientOpacity((char const   *)np->value);
    }
#line 944
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 946
    InvalidTag(np, (TokenType )26);
    }
    switch_break: /* CIL Label */ ;
    }
#line 931
    np = (TokenNode const   *)np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 950
  return;
}
}
#line 953 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseInclude(TokenNode const   *tp , int depth ) 
{ 
  char *temp ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 959
  tmp___2 = __builtin_expect((long )(! (! (! tp->value))), 0L);
  }
#line 959
  if (tmp___2) {
    {
#line 961
    ParseError(tp, "no include file specified");
    }
  } else {
    {
#line 965
    temp = CopyString((char const   *)tp->value);
#line 967
    ExpandPath(& temp);
#line 969
    tmp = ParseFile((char const   *)temp, depth);
    }
#line 969
    if (tmp) {
#line 969
      tmp___0 = 0;
    } else {
#line 969
      tmp___0 = 1;
    }
    {
#line 969
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 969
    if (tmp___1) {
      {
#line 970
      ParseError(tp, "could not open included file %s", temp);
      }
    }
    {
#line 973
    free((void *)temp);
    }
  }
#line 977
  return;
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseDesktops(TokenNode const   *tp ) 
{ 
  TokenNode *np ;
  char const   *width ;
  char const   *height ;
  int x ;
  int desktop ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 990
  tmp = FindAttribute((AttributeNode *)tp->attributes, WIDTH_ATTRIBUTE);
#line 990
  width = (char const   *)tmp;
#line 991
  tmp___0 = FindAttribute((AttributeNode *)tp->attributes, HEIGHT_ATTRIBUTE);
#line 991
  height = (char const   *)tmp___0;
#line 992
  SetDesktopCount(width, height);
#line 994
  desktop = 0;
#line 995
  x = 0;
#line 995
  np = (TokenNode *)tp->subnodeHead;
  }
  {
#line 995
  while (1) {
    while_continue: /* CIL Label */ ;
#line 995
    if (! np) {
#line 995
      goto while_break;
    }
#line 996
    if ((unsigned int )desktop >= desktopCount) {
#line 997
      goto while_break;
    }
    {
#line 1000
    if ((unsigned int )np->type == 4U) {
#line 1000
      goto case_4;
    }
#line 1003
    if ((unsigned int )np->type == 15U) {
#line 1003
      goto case_15;
    }
#line 1007
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 1001
    ParseDesktopBackground(-1, (TokenNode const   *)np);
    }
#line 1002
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 1004
    ParseDesktop(desktop, (TokenNode const   *)np);
#line 1005
    desktop ++;
    }
#line 1006
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1008
    InvalidTag((TokenNode const   *)np, (TokenType )14);
    }
#line 1009
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 995
    np = np->next;
#line 995
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  return;
}
}
#line 1016 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseDesktop(int desktop , TokenNode const   *tp ) 
{ 
  TokenNode *np ;
  char const   *attr ;
  char *tmp ;

  {
  {
#line 1021
  tmp = FindAttribute((AttributeNode *)tp->attributes, NAME_ATTRIBUTE);
#line 1021
  attr = (char const   *)tmp;
  }
#line 1022
  if (attr) {
    {
#line 1023
    SetDesktopName((unsigned int )desktop, attr);
    }
  }
#line 1026
  np = (TokenNode *)tp->subnodeHead;
  {
#line 1026
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1026
    if (! np) {
#line 1026
      goto while_break;
    }
    {
#line 1028
    if ((unsigned int )np->type == 4U) {
#line 1028
      goto case_4;
    }
#line 1031
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 1029
    ParseDesktopBackground(desktop, (TokenNode const   *)np);
    }
#line 1030
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1032
    InvalidTag((TokenNode const   *)np, (TokenType )15);
    }
#line 1033
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1026
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1037
  return;
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseDesktopBackground(int desktop , TokenNode const   *tp ) 
{ 
  char const   *type ;
  char *tmp ;

  {
  {
#line 1044
  tmp = FindAttribute((AttributeNode *)tp->attributes, TYPE_ATTRIBUTE);
#line 1044
  type = (char const   *)tmp;
#line 1045
  SetBackground(desktop, type, (char const   *)tp->value);
  }
#line 1047
  return;
}
}
#line 1050 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseTaskListStyle(TokenNode const   *tp ) 
{ 
  char const   *temp ;
  TokenNode *np ;
  char *tmp ;

  {
  {
#line 1055
  tmp = FindAttribute((AttributeNode *)tp->attributes, INSERT_ATTRIBUTE);
#line 1055
  temp = (char const   *)tmp;
  }
#line 1056
  if (temp) {
    {
#line 1057
    SetTaskBarInsertMode(temp);
    }
  }
#line 1060
  np = (TokenNode *)tp->subnodeHead;
  {
#line 1060
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1060
    if (! np) {
#line 1060
      goto while_break;
    }
    {
#line 1062
    if ((unsigned int )np->type == 21U) {
#line 1062
      goto case_21;
    }
#line 1065
    if ((unsigned int )np->type == 22U) {
#line 1065
      goto case_22;
    }
#line 1068
    if ((unsigned int )np->type == 4U) {
#line 1068
      goto case_4;
    }
#line 1071
    if ((unsigned int )np->type == 3U) {
#line 1071
      goto case_3;
    }
#line 1074
    if ((unsigned int )np->type == 2U) {
#line 1074
      goto case_2;
    }
#line 1077
    goto switch_default;
    case_21: /* CIL Label */ 
    {
#line 1063
    SetFont((FontType )2, (char const   *)np->value);
    }
#line 1064
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 1066
    SetColor((ColorType )10, (char const   *)np->value);
    }
#line 1067
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1069
    ParseGradient((char const   *)np->value, (ColorType )11, (ColorType )12);
    }
#line 1070
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1072
    SetColor((ColorType )13, (char const   *)np->value);
    }
#line 1073
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1075
    ParseGradient((char const   *)np->value, (ColorType )14, (ColorType )15);
    }
#line 1076
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1078
    InvalidTag((TokenNode const   *)np, (TokenType )61);
    }
#line 1079
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1060
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1083
  return;
}
}
#line 1086 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseTrayStyle(TokenNode const   *tp ) 
{ 
  TokenNode const   *np ;

  {
#line 1090
  np = (TokenNode const   *)tp->subnodeHead;
  {
#line 1090
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1090
    if (! np) {
#line 1090
      goto while_break;
    }
    {
#line 1092
    if ((unsigned int const   )np->type == 21U) {
#line 1092
      goto case_21;
    }
#line 1095
    if ((unsigned int const   )np->type == 4U) {
#line 1095
      goto case_4;
    }
#line 1098
    if ((unsigned int const   )np->type == 22U) {
#line 1098
      goto case_22;
    }
#line 1101
    if ((unsigned int const   )np->type == 39U) {
#line 1101
      goto case_39;
    }
#line 1104
    goto switch_default;
    case_21: /* CIL Label */ 
    {
#line 1093
    SetFont((FontType )5, (char const   *)np->value);
    }
#line 1094
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1096
    SetColor((ColorType )8, (char const   *)np->value);
    }
#line 1097
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 1099
    SetColor((ColorType )9, (char const   *)np->value);
    }
#line 1100
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 1102
    SetTrayOpacity((char const   *)np->value);
    }
#line 1103
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1105
    InvalidTag(np, (TokenType )68);
    }
#line 1106
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1090
    np = (TokenNode const   *)np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1110
  return;
}
}
#line 1113 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseTray(TokenNode const   *tp ) 
{ 
  TokenNode const   *np ;
  char const   *attr ;
  TrayType *tray ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 1121
  tray = CreateTray();
#line 1123
  tmp = FindAttribute((AttributeNode *)tp->attributes, AUTOHIDE_ATTRIBUTE);
#line 1123
  attr = (char const   *)tmp;
  }
#line 1124
  if (attr) {
    {
#line 1124
    tmp___0 = strcmp(attr, TRUE_VALUE);
    }
#line 1124
    if (tmp___0) {
      {
#line 1127
      SetAutoHideTray(tray, 0);
      }
    } else {
      {
#line 1125
      SetAutoHideTray(tray, 1);
      }
    }
  } else {
    {
#line 1127
    SetAutoHideTray(tray, 0);
    }
  }
  {
#line 1130
  tmp___1 = FindAttribute((AttributeNode *)tp->attributes, X_ATTRIBUTE);
#line 1130
  attr = (char const   *)tmp___1;
  }
#line 1131
  if (attr) {
    {
#line 1132
    SetTrayX(tray, attr);
    }
  }
  {
#line 1135
  tmp___2 = FindAttribute((AttributeNode *)tp->attributes, Y_ATTRIBUTE);
#line 1135
  attr = (char const   *)tmp___2;
  }
#line 1136
  if (attr) {
    {
#line 1137
    SetTrayY(tray, attr);
    }
  }
  {
#line 1140
  tmp___3 = FindAttribute((AttributeNode *)tp->attributes, WIDTH_ATTRIBUTE);
#line 1140
  attr = (char const   *)tmp___3;
  }
#line 1141
  if (attr) {
    {
#line 1142
    SetTrayWidth(tray, attr);
    }
  }
  {
#line 1145
  tmp___4 = FindAttribute((AttributeNode *)tp->attributes, HEIGHT_ATTRIBUTE);
#line 1145
  attr = (char const   *)tmp___4;
  }
#line 1146
  if (attr) {
    {
#line 1147
    SetTrayHeight(tray, attr);
    }
  }
  {
#line 1150
  tmp___5 = FindAttribute((AttributeNode *)tp->attributes, VALIGN_ATTRIBUTE);
#line 1150
  attr = (char const   *)tmp___5;
#line 1151
  SetTrayVerticalAlignment(tray, attr);
#line 1153
  tmp___6 = FindAttribute((AttributeNode *)tp->attributes, HALIGN_ATTRIBUTE);
#line 1153
  attr = (char const   *)tmp___6;
#line 1154
  SetTrayHorizontalAlignment(tray, attr);
#line 1156
  tmp___7 = FindAttribute((AttributeNode *)tp->attributes, LAYOUT_ATTRIBUTE);
#line 1156
  attr = (char const   *)tmp___7;
#line 1157
  SetTrayLayout(tray, attr);
#line 1159
  tmp___8 = FindAttribute((AttributeNode *)tp->attributes, LAYER_ATTRIBUTE);
#line 1159
  attr = (char const   *)tmp___8;
  }
#line 1160
  if (attr) {
    {
#line 1161
    SetTrayLayer(tray, attr);
    }
  }
  {
#line 1164
  tmp___9 = FindAttribute((AttributeNode *)tp->attributes, BORDER_ATTRIBUTE);
#line 1164
  attr = (char const   *)tmp___9;
  }
#line 1165
  if (attr) {
    {
#line 1166
    SetTrayBorder(tray, attr);
    }
  }
#line 1169
  np = (TokenNode const   *)tp->subnodeHead;
  {
#line 1169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1169
    if (! np) {
#line 1169
      goto while_break;
    }
    {
#line 1171
    if ((unsigned int const   )np->type == 42U) {
#line 1171
      goto case_42;
    }
#line 1174
    if ((unsigned int const   )np->type == 62U) {
#line 1174
      goto case_62;
    }
#line 1177
    if ((unsigned int const   )np->type == 60U) {
#line 1177
      goto case_60;
    }
#line 1180
    if ((unsigned int const   )np->type == 66U) {
#line 1180
      goto case_66;
    }
#line 1183
    if ((unsigned int const   )np->type == 11U) {
#line 1183
      goto case_11;
    }
#line 1186
    if ((unsigned int const   )np->type == 16U) {
#line 1186
      goto case_16;
    }
#line 1189
    if ((unsigned int const   )np->type == 57U) {
#line 1189
      goto case_57;
    }
#line 1192
    goto switch_default;
    case_42: /* CIL Label */ 
    {
#line 1172
    ParsePager(np, tray);
    }
#line 1173
    goto switch_break;
    case_62: /* CIL Label */ 
    {
#line 1175
    ParseTaskList(np, tray);
    }
#line 1176
    goto switch_break;
    case_60: /* CIL Label */ 
    {
#line 1178
    ParseSwallow(np, tray);
    }
#line 1179
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 1181
    ParseTrayButton(np, tray);
    }
#line 1182
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 1184
    ParseClock(np, tray);
    }
#line 1185
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 1187
    ParseDock(np, tray);
    }
#line 1188
    goto switch_break;
    case_57: /* CIL Label */ 
    {
#line 1190
    ParseSpacer(np, tray);
    }
#line 1191
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1193
    InvalidTag(np, (TokenType )65);
    }
#line 1194
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1169
    np = (TokenNode const   *)np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1198
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParsePager(TokenNode const   *tp , TrayType *tray ) 
{ 
  TrayComponentType *cp ;
  char const   *temp ;
  int labeled ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 1210
  labeled = 0;
#line 1211
  tmp = FindAttribute((AttributeNode *)tp->attributes, LABELED_ATTRIBUTE);
#line 1211
  temp = (char const   *)tmp;
  }
#line 1212
  if (temp) {
    {
#line 1212
    tmp___0 = strcmp(temp, TRUE_VALUE);
    }
#line 1212
    if (! tmp___0) {
#line 1213
      labeled = 1;
    }
  }
  {
#line 1215
  cp = CreatePager(labeled);
#line 1216
  AddTrayComponent(tray, cp);
  }
#line 1218
  return;
}
}
#line 1221 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseTaskList(TokenNode const   *tp , TrayType *tray ) 
{ 
  TrayComponentType *cp ;
  char const   *temp ;
  char *tmp ;

  {
  {
#line 1229
  cp = CreateTaskBar();
#line 1230
  AddTrayComponent(tray, cp);
#line 1232
  tmp = FindAttribute((AttributeNode *)tp->attributes, MAX_WIDTH_ATTRIBUTE);
#line 1232
  temp = (char const   *)tmp;
  }
#line 1233
  if (temp) {
    {
#line 1234
    SetMaxTaskBarItemWidth(cp, temp);
    }
  }
#line 1237
  return;
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseSwallow(TokenNode const   *tp , TrayType *tray ) 
{ 
  TrayComponentType *cp ;
  char const   *name ;
  char const   *temp ;
  int width ;
  int height ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1250
  tmp = FindAttribute((AttributeNode *)tp->attributes, NAME_ATTRIBUTE);
#line 1250
  name = (char const   *)tmp;
  }
#line 1251
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1252
    name = (char const   *)tp->value;
  }
  {
#line 1255
  tmp___0 = FindAttribute((AttributeNode *)tp->attributes, WIDTH_ATTRIBUTE);
#line 1255
  temp = (char const   *)tmp___0;
  }
#line 1256
  if (temp) {
    {
#line 1257
    width = atoi(temp);
    }
  } else {
#line 1259
    width = 0;
  }
  {
#line 1262
  tmp___1 = FindAttribute((AttributeNode *)tp->attributes, HEIGHT_ATTRIBUTE);
#line 1262
  temp = (char const   *)tmp___1;
  }
#line 1263
  if (temp) {
    {
#line 1264
    height = atoi(temp);
    }
  } else {
#line 1266
    height = 0;
  }
  {
#line 1269
  cp = CreateSwallow(name, (char const   *)tp->value, width, height);
  }
#line 1270
  if (cp) {
    {
#line 1271
    AddTrayComponent(tray, cp);
    }
  }
#line 1274
  return;
}
}
#line 1277 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseTrayButton(TokenNode const   *tp , TrayType *tray ) 
{ 
  TrayComponentType *cp ;
  char const   *icon ;
  char const   *label ;
  char const   *popup___0 ;
  char const   *temp ;
  int width ;
  int height ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1289
  tmp = FindAttribute((AttributeNode *)tp->attributes, ICON_ATTRIBUTE);
#line 1289
  icon = (char const   *)tmp;
#line 1290
  tmp___0 = FindAttribute((AttributeNode *)tp->attributes, LABEL_ATTRIBUTE);
#line 1290
  label = (char const   *)tmp___0;
#line 1291
  tmp___1 = FindAttribute((AttributeNode *)tp->attributes, POPUP_ATTRIBUTE);
#line 1291
  popup___0 = (char const   *)tmp___1;
#line 1293
  tmp___2 = FindAttribute((AttributeNode *)tp->attributes, WIDTH_ATTRIBUTE);
#line 1293
  temp = (char const   *)tmp___2;
  }
#line 1294
  if (temp) {
    {
#line 1295
    width = atoi(temp);
    }
  } else {
#line 1297
    width = 0;
  }
  {
#line 1300
  tmp___3 = FindAttribute((AttributeNode *)tp->attributes, HEIGHT_ATTRIBUTE);
#line 1300
  temp = (char const   *)tmp___3;
  }
#line 1301
  if (temp) {
    {
#line 1302
    height = atoi(temp);
    }
  } else {
#line 1304
    height = 0;
  }
  {
#line 1307
  cp = CreateTrayButton(icon, label, (char const   *)tp->value, popup___0, width,
                        height);
  }
#line 1308
  if (cp) {
    {
#line 1309
    AddTrayComponent(tray, cp);
    }
  }
#line 1312
  return;
}
}
#line 1315 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseClock(TokenNode const   *tp , TrayType *tray ) 
{ 
  TrayComponentType *cp ;
  char const   *format ;
  char const   *zone ;
  char const   *command ;
  char const   *temp ;
  int width ;
  int height ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 1327
  tmp = FindAttribute((AttributeNode *)tp->attributes, FORMAT_ATTRIBUTE);
#line 1327
  format = (char const   *)tmp;
#line 1329
  tmp___0 = FindAttribute((AttributeNode *)tp->attributes, ZONE_ATTRIBUTE);
#line 1329
  zone = (char const   *)tmp___0;
  }
#line 1331
  if (tp->value) {
    {
#line 1331
    tmp___1 = strlen((char const   *)tp->value);
    }
#line 1331
    if (tmp___1 > 0UL) {
#line 1332
      command = (char const   *)tp->value;
    } else {
#line 1334
      command = (char const   *)((void *)0);
    }
  } else {
#line 1334
    command = (char const   *)((void *)0);
  }
  {
#line 1337
  tmp___2 = FindAttribute((AttributeNode *)tp->attributes, WIDTH_ATTRIBUTE);
#line 1337
  temp = (char const   *)tmp___2;
  }
#line 1338
  if (temp) {
    {
#line 1339
    width = atoi(temp);
    }
  } else {
#line 1341
    width = 0;
  }
  {
#line 1344
  tmp___3 = FindAttribute((AttributeNode *)tp->attributes, HEIGHT_ATTRIBUTE);
#line 1344
  temp = (char const   *)tmp___3;
  }
#line 1345
  if (temp) {
    {
#line 1346
    height = atoi(temp);
    }
  } else {
#line 1348
    height = 0;
  }
  {
#line 1351
  cp = CreateClock(format, zone, command, width, height);
#line 1352
  tmp___4 = __builtin_expect((long )(! (! cp)), 1L);
  }
#line 1352
  if (tmp___4) {
    {
#line 1353
    AddTrayComponent(tray, cp);
    }
  }
#line 1356
  return;
}
}
#line 1359 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseDock(TokenNode const   *tp , TrayType *tray ) 
{ 
  TrayComponentType *cp ;
  int width ;
  char *str___0 ;
  long tmp ;

  {
  {
#line 1368
  str___0 = FindAttribute((AttributeNode *)tp->attributes, WIDTH_ATTRIBUTE);
  }
#line 1369
  if (str___0) {
    {
#line 1370
    width = atoi((char const   *)str___0);
    }
  } else {
#line 1372
    width = 0;
  }
  {
#line 1375
  cp = CreateDock(width);
#line 1376
  tmp = __builtin_expect((long )(! (! cp)), 1L);
  }
#line 1376
  if (tmp) {
    {
#line 1377
    AddTrayComponent(tray, cp);
    }
  }
#line 1380
  return;
}
}
#line 1383 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseSpacer(TokenNode const   *tp , TrayType *tray ) 
{ 
  TrayComponentType *cp ;
  int width ;
  int height ;
  char *str___0 ;
  long tmp ;

  {
  {
#line 1394
  str___0 = FindAttribute((AttributeNode *)tp->attributes, WIDTH_ATTRIBUTE);
  }
#line 1395
  if (str___0) {
    {
#line 1396
    width = atoi((char const   *)str___0);
    }
  } else {
#line 1398
    width = 0;
  }
  {
#line 1402
  str___0 = FindAttribute((AttributeNode *)tp->attributes, HEIGHT_ATTRIBUTE);
  }
#line 1403
  if (str___0) {
    {
#line 1404
    height = atoi((char const   *)str___0);
    }
  } else {
#line 1406
    height = 0;
  }
  {
#line 1410
  cp = CreateSpacer(width, height);
#line 1411
  tmp = __builtin_expect((long )(! (! cp)), 1L);
  }
#line 1411
  if (tmp) {
    {
#line 1412
    AddTrayComponent(tray, cp);
    }
  }
#line 1415
  return;
}
}
#line 1418 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParsePagerStyle(TokenNode const   *tp ) 
{ 
  TokenNode const   *np ;

  {
#line 1424
  np = (TokenNode const   *)tp->subnodeHead;
  {
#line 1424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1424
    if (! np) {
#line 1424
      goto while_break;
    }
    {
#line 1426
    if ((unsigned int const   )np->type == 41U) {
#line 1426
      goto case_41;
    }
#line 1429
    if ((unsigned int const   )np->type == 22U) {
#line 1429
      goto case_22;
    }
#line 1432
    if ((unsigned int const   )np->type == 4U) {
#line 1432
      goto case_4;
    }
#line 1435
    if ((unsigned int const   )np->type == 3U) {
#line 1435
      goto case_3;
    }
#line 1438
    if ((unsigned int const   )np->type == 2U) {
#line 1438
      goto case_2;
    }
#line 1441
    if ((unsigned int const   )np->type == 21U) {
#line 1441
      goto case_21;
    }
#line 1444
    if ((unsigned int const   )np->type == 63U) {
#line 1444
      goto case_63;
    }
#line 1447
    goto switch_default;
    case_41: /* CIL Label */ 
    {
#line 1427
    SetColor((ColorType )20, (char const   *)np->value);
    }
#line 1428
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 1430
    SetColor((ColorType )17, (char const   *)np->value);
    }
#line 1431
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1433
    SetColor((ColorType )16, (char const   *)np->value);
    }
#line 1434
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1436
    SetColor((ColorType )19, (char const   *)np->value);
    }
#line 1437
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1439
    SetColor((ColorType )18, (char const   *)np->value);
    }
#line 1440
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 1442
    SetFont((FontType )7, (char const   *)np->value);
    }
#line 1443
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 1445
    SetColor((ColorType )21, (char const   *)np->value);
    }
#line 1446
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1448
    InvalidTag(np, (TokenType )43);
    }
#line 1449
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1424
    np = (TokenNode const   *)np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1453
  return;
}
}
#line 1456 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParsePopupStyle(TokenNode const   *tp ) 
{ 
  TokenNode const   *np ;
  char const   *str___0 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1463
  tmp = FindAttribute((AttributeNode *)tp->attributes, ENABLED_ATTRIBUTE);
#line 1463
  str___0 = (char const   *)tmp;
  }
#line 1464
  if (str___0) {
    {
#line 1465
    tmp___1 = strcmp(str___0, TRUE_VALUE);
    }
#line 1465
    if (tmp___1) {
      {
#line 1467
      tmp___0 = strcmp(str___0, FALSE_VALUE);
      }
#line 1467
      if (tmp___0) {
        {
#line 1470
        ParseError(tp, "invalid enabled value: \"%s\"", str___0);
        }
      } else {
        {
#line 1468
        SetPopupEnabled(0);
        }
      }
    } else {
      {
#line 1466
      SetPopupEnabled(1);
      }
    }
  }
  {
#line 1474
  tmp___2 = FindAttribute((AttributeNode *)tp->attributes, DELAY_ATTRIBUTE);
#line 1474
  str___0 = (char const   *)tmp___2;
  }
#line 1475
  if (str___0) {
    {
#line 1476
    SetPopupDelay(str___0);
    }
  }
#line 1479
  np = (TokenNode const   *)tp->subnodeHead;
  {
#line 1479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1479
    if (! np) {
#line 1479
      goto while_break;
    }
    {
#line 1481
    if ((unsigned int const   )np->type == 21U) {
#line 1481
      goto case_21;
    }
#line 1484
    if ((unsigned int const   )np->type == 41U) {
#line 1484
      goto case_41;
    }
#line 1487
    if ((unsigned int const   )np->type == 22U) {
#line 1487
      goto case_22;
    }
#line 1490
    if ((unsigned int const   )np->type == 4U) {
#line 1490
      goto case_4;
    }
#line 1493
    goto switch_default;
    case_21: /* CIL Label */ 
    {
#line 1482
    SetFont((FontType )3, (char const   *)np->value);
    }
#line 1483
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 1485
    SetColor((ColorType )40, (char const   *)np->value);
    }
#line 1486
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 1488
    SetColor((ColorType )39, (char const   *)np->value);
    }
#line 1489
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1491
    SetColor((ColorType )38, (char const   *)np->value);
    }
#line 1492
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1494
    InvalidTag(np, (TokenType )45);
    }
#line 1495
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1479
    np = (TokenNode const   *)np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1499
  return;
}
}
#line 1502 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseMenuStyle(TokenNode const   *tp ) 
{ 
  TokenNode const   *np ;

  {
#line 1508
  np = (TokenNode const   *)tp->subnodeHead;
  {
#line 1508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1508
    if (! np) {
#line 1508
      goto while_break;
    }
    {
#line 1510
    if ((unsigned int const   )np->type == 21U) {
#line 1510
      goto case_21;
    }
#line 1513
    if ((unsigned int const   )np->type == 22U) {
#line 1513
      goto case_22;
    }
#line 1516
    if ((unsigned int const   )np->type == 4U) {
#line 1516
      goto case_4;
    }
#line 1519
    if ((unsigned int const   )np->type == 3U) {
#line 1519
      goto case_3;
    }
#line 1522
    if ((unsigned int const   )np->type == 2U) {
#line 1522
      goto case_2;
    }
#line 1525
    if ((unsigned int const   )np->type == 41U) {
#line 1525
      goto case_41;
    }
#line 1528
    if ((unsigned int const   )np->type == 39U) {
#line 1528
      goto case_39;
    }
#line 1531
    goto switch_default;
    case_21: /* CIL Label */ 
    {
#line 1511
    SetFont((FontType )1, (char const   *)np->value);
    }
#line 1512
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 1514
    SetColor((ColorType )23, (char const   *)np->value);
    }
#line 1515
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1517
    SetColor((ColorType )22, (char const   *)np->value);
    }
#line 1518
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1520
    SetColor((ColorType )26, (char const   *)np->value);
    }
#line 1521
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1523
    ParseGradient((char const   *)np->value, (ColorType )24, (ColorType )25);
    }
#line 1524
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 1526
    SetColor((ColorType )27, (char const   *)np->value);
    }
#line 1527
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 1529
    SetMenuOpacity((char const   *)np->value);
    }
#line 1530
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1532
    InvalidTag(np, (TokenType )34);
    }
#line 1533
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1508
    np = (TokenNode const   *)np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1537
  return;
}
}
#line 1540 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseClockStyle(TokenNode const   *tp ) 
{ 
  TokenNode const   *np ;

  {
#line 1546
  np = (TokenNode const   *)tp->subnodeHead;
  {
#line 1546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1546
    if (! np) {
#line 1546
      goto while_break;
    }
    {
#line 1548
    if ((unsigned int const   )np->type == 21U) {
#line 1548
      goto case_21;
    }
#line 1551
    if ((unsigned int const   )np->type == 22U) {
#line 1551
      goto case_22;
    }
#line 1554
    if ((unsigned int const   )np->type == 4U) {
#line 1554
      goto case_4;
    }
#line 1557
    goto switch_default;
    case_21: /* CIL Label */ 
    {
#line 1549
    SetFont((FontType )4, (char const   *)np->value);
    }
#line 1550
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 1552
    SetColor((ColorType )44, (char const   *)np->value);
    }
#line 1553
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1555
    SetColor((ColorType )43, (char const   *)np->value);
    }
#line 1556
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1558
    InvalidTag(np, (TokenType )12);
    }
#line 1559
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1546
    np = (TokenNode const   *)np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1563
  return;
}
}
#line 1566 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseTrayButtonStyle(TokenNode const   *tp ) 
{ 
  TokenNode const   *np ;

  {
#line 1572
  np = (TokenNode const   *)tp->subnodeHead;
  {
#line 1572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1572
    if (! np) {
#line 1572
      goto while_break;
    }
    {
#line 1574
    if ((unsigned int const   )np->type == 21U) {
#line 1574
      goto case_21;
    }
#line 1577
    if ((unsigned int const   )np->type == 22U) {
#line 1577
      goto case_22;
    }
#line 1580
    if ((unsigned int const   )np->type == 4U) {
#line 1580
      goto case_4;
    }
#line 1583
    goto switch_default;
    case_21: /* CIL Label */ 
    {
#line 1575
    SetFont((FontType )6, (char const   *)np->value);
    }
#line 1576
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 1578
    SetColor((ColorType )42, (char const   *)np->value);
    }
#line 1579
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1581
    SetColor((ColorType )41, (char const   *)np->value);
    }
#line 1582
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1584
    InvalidTag(np, (TokenType )67);
    }
#line 1585
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1572
    np = (TokenNode const   *)np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1589
  return;
}
}
#line 1592 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseGroup(TokenNode const   *tp ) 
{ 
  TokenNode const   *np ;
  struct GroupType *group ;

  {
  {
#line 1599
  group = CreateGroup();
#line 1601
  np = (TokenNode const   *)tp->subnodeHead;
  }
  {
#line 1601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1601
    if (! np) {
#line 1601
      goto while_break;
    }
    {
#line 1603
    if ((unsigned int const   )np->type == 10U) {
#line 1603
      goto case_10;
    }
#line 1606
    if ((unsigned int const   )np->type == 38U) {
#line 1606
      goto case_38;
    }
#line 1609
    if ((unsigned int const   )np->type == 40U) {
#line 1609
      goto case_40;
    }
#line 1612
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 1604
    AddGroupClass(group, (char const   *)np->value);
    }
#line 1605
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 1607
    AddGroupName(group, (char const   *)np->value);
    }
#line 1608
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 1610
    ParseGroupOption(np, group, (char const   *)np->value);
    }
#line 1611
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1613
    InvalidTag(np, (TokenType )23);
    }
#line 1614
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1601
    np = (TokenNode const   *)np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1618
  return;
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseGroupOption(TokenNode const   *tp , struct GroupType *group , char const   *option ) 
{ 
  int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1626
  if (! option) {
#line 1627
    return;
  }
#line 1630
  x = 0;
  {
#line 1630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1630
    if (! OPTION_MAP[x].name) {
#line 1630
      goto while_break;
    }
    {
#line 1631
    tmp = strcmp(option, (char const   *)OPTION_MAP[x].name);
    }
#line 1631
    if (! tmp) {
      {
#line 1632
      AddGroupOption(group, (OptionType )OPTION_MAP[x].option);
      }
#line 1633
      return;
    }
#line 1630
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1638
  tmp___3 = strncmp(option, "layer:", (size_t )6);
  }
#line 1638
  if (tmp___3) {
    {
#line 1640
    tmp___2 = strncmp(option, "desktop:", (size_t )8);
    }
#line 1640
    if (tmp___2) {
      {
#line 1642
      tmp___1 = strncmp(option, "icon:", (size_t )5);
      }
#line 1642
      if (tmp___1) {
        {
#line 1644
        tmp___0 = strncmp(option, "opacity:", (size_t )8);
        }
#line 1644
        if (tmp___0) {
          {
#line 1647
          ParseError(tp, "invalid Group Option: %s", option);
          }
        } else {
          {
#line 1645
          AddGroupOptionValue(group, (OptionType )14, option + 8);
          }
        }
      } else {
        {
#line 1643
        AddGroupOptionValue(group, (OptionType )4, option + 5);
        }
      }
    } else {
      {
#line 1641
      AddGroupOptionValue(group, (OptionType )3, option + 8);
      }
    }
  } else {
    {
#line 1639
    AddGroupOptionValue(group, (OptionType )2, option + 6);
    }
  }
#line 1650
  return;
}
}
#line 1653 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseGradient(char const   *value , ColorType a , ColorType b ) 
{ 
  char const   *sep ;
  char *temp ;
  int len ;
  char *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1660
  tmp = strchr(value, ':');
#line 1660
  sep = (char const   *)tmp;
  }
#line 1662
  if (! sep) {
    {
#line 1665
    SetColor(a, value);
#line 1666
    SetColor(b, value);
    }
  } else {
    {
#line 1673
    len = (int )(sep - value);
#line 1674
    tmp___0 = __builtin_alloca((unsigned long )(len + 1));
#line 1674
    temp = (char *)tmp___0;
#line 1675
    memcpy((void */* __restrict  */)temp, (void const   */* __restrict  */)value,
           (size_t )len);
#line 1676
    *(temp + len) = (char)0;
#line 1677
    SetColor(a, (char const   *)temp);
#line 1681
    tmp___1 = strlen(sep + 1);
#line 1681
    len = (int )tmp___1;
#line 1682
    tmp___2 = __builtin_alloca((unsigned long )(len + 1));
#line 1682
    temp = (char *)tmp___2;
#line 1683
    memcpy((void */* __restrict  */)temp, (void const   */* __restrict  */)(sep + 1),
           (size_t )len);
#line 1684
    *(temp + len) = (char)0;
#line 1685
    SetColor(b, (char const   *)temp);
    }
  }
#line 1690
  return;
}
}
#line 1693 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char *FindAttribute(AttributeNode *ap , char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 1695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1695
    if (! ap) {
#line 1695
      goto while_break;
    }
    {
#line 1696
    tmp = strcmp(name, (char const   *)ap->name);
    }
#line 1696
    if (! tmp) {
#line 1697
      return (ap->value);
    }
#line 1699
    ap = ap->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1702
  return ((char *)((void *)0));
}
}
#line 1706 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char *ReadFile(FILE *fd ) 
{ 
  int BLOCK_SIZE___0 ;
  char *buffer ;
  int len ;
  int max ;
  int ch ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1708
  BLOCK_SIZE___0 = 8192;
#line 1714
  len = 0;
#line 1715
  max = BLOCK_SIZE___0;
#line 1716
  tmp = malloc((size_t )(max + 1));
#line 1716
  buffer = (char *)tmp;
  }
  {
#line 1718
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1719
    ch = fgetc(fd);
    }
#line 1720
    if (ch == -1) {
#line 1721
      goto while_break;
    }
#line 1723
    tmp___0 = len;
#line 1723
    len ++;
#line 1723
    *(buffer + tmp___0) = (char )ch;
#line 1724
    if (len >= max) {
      {
#line 1725
      max += BLOCK_SIZE___0;
#line 1726
      tmp___1 = realloc((void *)buffer, (size_t )(max + 1));
#line 1726
      buffer = (char *)tmp___1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1729
  *(buffer + len) = (char)0;
#line 1731
  return (buffer);
}
}
#line 1736 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void InvalidTag(TokenNode const   *tp , TokenType parent ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1738
  tmp = GetTokenName(tp);
#line 1738
  tmp___0 = GetTokenTypeName(parent);
#line 1738
  tmp___1 = gettext("invalid tag in %s: %s");
#line 1738
  ParseError(tp, (char const   *)tmp___1, tmp___0, tmp);
  }
#line 1741
  return;
}
}
#line 1748 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static char const   *FILE_MESSAGE  =    "%s[%d]";
#line 1744 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/parse.c"
static void ParseError(TokenNode const   *tp , char const   *str___0  , ...) 
{ 
  va_list ap ;
  char *msg ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1752
  __builtin_va_start(ap, str___0);
  }
#line 1754
  if (tp) {
    {
#line 1755
    tmp = strlen(FILE_MESSAGE);
#line 1755
    tmp___0 = strlen((char const   *)tp->fileName);
#line 1755
    tmp___1 = malloc((tmp + tmp___0) + 1UL);
#line 1755
    msg = (char *)tmp___1;
#line 1756
    sprintf((char */* __restrict  */)msg, (char const   */* __restrict  */)FILE_MESSAGE,
            tp->fileName, tp->line);
    }
  } else {
    {
#line 1758
    tmp___2 = gettext("configuration error");
#line 1758
    msg = CopyString((char const   *)tmp___2);
    }
  }
  {
#line 1761
  WarningVA((char const   *)msg, str___0, ap);
#line 1763
  free((void *)msg);
#line 1765
  __builtin_va_end(ap);
  }
#line 1767
  return;
}
}
#line 3493 "/usr/include/X11/Xlib.h"
extern int XUngrabPointer(Display * , Time  ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
void InitializeMenu(Menu *menu ) ;
#line 108
void ShowMenu(Menu *menu , void (*runner)(MenuAction const   *action ) , int x , int y ) ;
#line 113
void DestroyMenu(Menu *menu ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/winmenu.h"
void GetWindowMenuSize(struct ClientNode *np , int *width , int *height ) ;
#line 34
void ChooseWindow(MenuAction const   *action ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.h"
struct Menu *CreateDesktopMenu(unsigned int mask ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.h"
int GrabMouseForChoose(void) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/winmenu.c"
static Menu *CreateWindowMenu(void) ;
#line 24
static void RunWindowCommand(MenuAction const   *action ) ;
#line 26
static void CreateWindowLayerMenu(Menu *menu ) ;
#line 27
static void CreateWindowSendToMenu(Menu *menu ) ;
#line 28
static void AddWindowMenuItem(Menu *menu , char const   *name , MenuActionType type ,
                              int value ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/winmenu.c"
static ClientNode *client  =    (ClientNode *)((void *)0);
#line 34 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/winmenu.c"
void GetWindowMenuSize(struct ClientNode *np , int *width , int *height ) 
{ 
  Menu *menu ;

  {
  {
#line 38
  client = np;
#line 39
  menu = CreateWindowMenu();
#line 40
  InitializeMenu(menu);
#line 41
  *width = menu->width;
#line 42
  *height = menu->height;
#line 43
  DestroyMenu(menu);
  }
#line 45
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/winmenu.c"
void ShowWindowMenu(struct ClientNode *np , int x , int y ) 
{ 
  Menu *menu ;

  {
  {
#line 52
  client = np;
#line 53
  menu = CreateWindowMenu();
#line 55
  InitializeMenu(menu);
#line 57
  ShowMenu(menu, & RunWindowCommand, x, y);
#line 59
  DestroyMenu(menu);
  }
#line 61
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/winmenu.c"
static Menu *CreateWindowMenu(void) 
{ 
  Menu *menu ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 68
  tmp = malloc(sizeof(Menu ));
#line 68
  menu = (Menu *)tmp;
#line 69
  menu->itemHeight = 0;
#line 70
  menu->items = (struct MenuItem *)((void *)0);
#line 71
  menu->label = (char *)((void *)0);
  }
#line 75
  if (! (client->state.status & 512U)) {
    {
#line 76
    tmp___0 = gettext("Close");
#line 76
    AddWindowMenuItem(menu, (char const   *)tmp___0, (MenuActionType )15, 0);
#line 77
    tmp___1 = gettext("Kill");
#line 77
    AddWindowMenuItem(menu, (char const   *)tmp___1, (MenuActionType )14, 0);
#line 78
    AddWindowMenuItem(menu, (char const   *)((void *)0), (MenuActionType )0, 0);
    }
  }
#line 81
  if (client->state.status & 258U) {
#line 82
    if (client->state.border & 32U) {
      {
#line 83
      tmp___2 = gettext("Resize");
#line 83
      AddWindowMenuItem(menu, (char const   *)tmp___2, (MenuActionType )13, 0);
      }
    }
#line 85
    if (client->state.border & 64U) {
      {
#line 86
      tmp___3 = gettext("Move");
#line 86
      AddWindowMenuItem(menu, (char const   *)tmp___3, (MenuActionType )12, 0);
      }
    }
  }
#line 90
  if (client->state.border & 4U) {
#line 92
    if (client->state.status & 128U) {
      {
#line 93
      tmp___4 = gettext("Restore");
#line 93
      AddWindowMenuItem(menu, (char const   *)tmp___4, (MenuActionType )10, 0);
      }
    } else {
#line 95
      if (client->state.status & 256U) {
        {
#line 96
        tmp___5 = gettext("Unshade");
#line 96
        AddWindowMenuItem(menu, (char const   *)tmp___5, (MenuActionType )11, 0);
        }
      } else {
        {
#line 98
        tmp___6 = gettext("Shade");
#line 98
        AddWindowMenuItem(menu, (char const   *)tmp___6, (MenuActionType )11, 0);
        }
      }
      {
#line 100
      tmp___7 = gettext("Minimize");
#line 100
      AddWindowMenuItem(menu, (char const   *)tmp___7, (MenuActionType )9, 0);
      }
    }
  }
#line 105
  if (client->state.border & 8U) {
#line 105
    if (client->state.status & 2U) {
#line 108
      if (! (client->state.status & 12U)) {
        {
#line 109
        tmp___8 = gettext("Maximize-y");
#line 109
        AddWindowMenuItem(menu, (char const   *)tmp___8, (MenuActionType )8, 0);
        }
      }
#line 112
      if (! (client->state.status & 12U)) {
        {
#line 113
        tmp___9 = gettext("Maximize-x");
#line 113
        AddWindowMenuItem(menu, (char const   *)tmp___9, (MenuActionType )7, 0);
        }
      }
#line 116
      if (client->state.status & 12U) {
        {
#line 117
        tmp___10 = gettext("Restore");
#line 117
        AddWindowMenuItem(menu, (char const   *)tmp___10, (MenuActionType )6, 0);
        }
      } else {
        {
#line 119
        tmp___11 = gettext("Maximize");
#line 119
        AddWindowMenuItem(menu, (char const   *)tmp___11, (MenuActionType )6, 0);
        }
      }
    }
  }
#line 124
  if (! (client->state.status & 512U)) {
#line 126
    if (client->state.status & 32U) {
      {
#line 127
      tmp___12 = gettext("Unstick");
#line 127
      AddWindowMenuItem(menu, (char const   *)tmp___12, (MenuActionType )5, 0);
      }
    } else {
      {
#line 129
      tmp___13 = gettext("Stick");
#line 129
      AddWindowMenuItem(menu, (char const   *)tmp___13, (MenuActionType )5, 0);
      }
    }
    {
#line 132
    CreateWindowLayerMenu(menu);
    }
#line 134
    if (! (client->state.status & 32U)) {
      {
#line 135
      CreateWindowSendToMenu(menu);
      }
    }
  }
#line 140
  return (menu);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/winmenu.c"
static void CreateWindowLayerMenu(Menu *menu ) 
{ 
  Menu *submenu ;
  MenuItem *item ;
  char str___0[10] ;
  unsigned int x ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 151
  tmp = malloc(sizeof(MenuItem ));
#line 151
  item = (MenuItem *)tmp;
#line 152
  item->type = (MenuItemType )1;
#line 153
  tmp___0 = gettext("Layer");
#line 153
  item->name = CopyString((char const   *)tmp___0);
#line 154
  item->action.type = (MenuActionType )0;
#line 155
  item->action.data.str = (char *)((void *)0);
#line 156
  item->iconName = (char *)((void *)0);
#line 158
  item->next = menu->items;
#line 159
  menu->items = item;
#line 161
  tmp___1 = malloc(sizeof(Menu ));
#line 161
  submenu = (Menu *)tmp___1;
#line 162
  item->submenu = submenu;
#line 163
  submenu->itemHeight = 0;
#line 164
  submenu->items = (struct MenuItem *)((void *)0);
#line 165
  submenu->label = (char *)((void *)0);
  }
#line 167
  if (client->state.layer == 12U) {
    {
#line 168
    tmp___2 = gettext("[Top]");
#line 168
    AddWindowMenuItem(submenu, (char const   *)tmp___2, (MenuActionType )4, 12);
    }
  } else {
    {
#line 170
    tmp___3 = gettext("Top");
#line 170
    AddWindowMenuItem(submenu, (char const   *)tmp___3, (MenuActionType )4, 12);
    }
  }
#line 173
  str___0[4] = (char)0;
#line 174
  x = 11U;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (x > 0U)) {
#line 174
      goto while_break;
    }
#line 175
    if (x == 4U) {
#line 176
      if (client->state.layer == x) {
        {
#line 177
        tmp___4 = gettext("[Normal]");
#line 177
        AddWindowMenuItem(submenu, (char const   *)tmp___4, (MenuActionType )4, (int )x);
        }
      } else {
        {
#line 179
        tmp___5 = gettext("Normal");
#line 179
        AddWindowMenuItem(submenu, (char const   *)tmp___5, (MenuActionType )4, (int )x);
        }
      }
    } else {
#line 182
      if (client->state.layer == x) {
#line 183
        str___0[0] = (char )'[';
#line 184
        str___0[3] = (char )']';
      } else {
#line 186
        str___0[0] = (char )' ';
#line 187
        str___0[3] = (char )' ';
      }
#line 189
      if (x < 10U) {
#line 190
        str___0[1] = (char )' ';
      } else {
#line 192
        str___0[1] = (char )(x / 10U + 48U);
      }
      {
#line 194
      str___0[2] = (char )(x % 10U + 48U);
#line 195
      AddWindowMenuItem(submenu, (char const   *)(str___0), (MenuActionType )4, (int )x);
      }
    }
#line 174
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  if (client->state.layer == 0U) {
    {
#line 200
    tmp___6 = gettext("[Bottom]");
#line 200
    AddWindowMenuItem(submenu, (char const   *)tmp___6, (MenuActionType )4, 0);
    }
  } else {
    {
#line 202
    tmp___7 = gettext("Bottom");
#line 202
    AddWindowMenuItem(submenu, (char const   *)tmp___7, (MenuActionType )4, 0);
    }
  }
#line 205
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/winmenu.c"
static void CreateWindowSendToMenu(Menu *menu ) 
{ 
  unsigned int mask ;
  unsigned int x ;
  char *tmp ;

  {
#line 213
  mask = 0U;
#line 214
  x = 0U;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (x < desktopCount)) {
#line 214
      goto while_break;
    }
#line 215
    if (client->state.desktop == x) {
#line 217
      mask |= (unsigned int )(1 << x);
    } else
#line 215
    if (client->state.status & 32U) {
#line 217
      mask |= (unsigned int )(1 << x);
    }
#line 214
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 221
  tmp = gettext("Send To");
#line 221
  AddWindowMenuItem(menu, (char const   *)tmp, (MenuActionType )0, 0);
#line 224
  (menu->items)->submenu = CreateDesktopMenu(mask);
  }
#line 226
  return;
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/winmenu.c"
static void AddWindowMenuItem(Menu *menu , char const   *name , MenuActionType type ,
                              int value ) 
{ 
  MenuItem *item ;
  void *tmp ;

  {
  {
#line 234
  tmp = malloc(sizeof(MenuItem ));
#line 234
  item = (MenuItem *)tmp;
  }
#line 235
  if (name) {
#line 236
    item->type = (MenuItemType )0;
  } else {
#line 238
    item->type = (MenuItemType )2;
  }
  {
#line 240
  item->name = CopyString(name);
#line 241
  item->action.type = type;
#line 242
  item->action.data.i = value;
#line 243
  item->iconName = (char *)((void *)0);
#line 244
  item->submenu = (struct Menu *)((void *)0);
#line 246
  item->next = menu->items;
#line 247
  menu->items = item;
  }
#line 249
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/winmenu.c"
void ChooseWindow(MenuAction const   *action ) 
{ 
  XEvent event ;
  ClientNode *np ;

  {
  {
#line 257
  GrabMouseForChoose();
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 261
    WaitForEvent(& event);
    }
#line 263
    if (event.type == 4) {
#line 264
      if (event.xbutton.button == 1U) {
        {
#line 265
        np = FindClientByWindow(event.xbutton.subwindow);
        }
#line 266
        if (np) {
          {
#line 267
          client = np;
#line 268
          RunWindowCommand(action);
          }
        }
      }
#line 271
      goto while_break;
    } else
#line 272
    if (event.type == 2) {
#line 273
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  XUngrabPointer(display, (Time )0L);
  }
#line 280
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/winmenu.c"
static void RunWindowCommand(MenuAction const   *action ) 
{ 


  {
  {
#line 286
  if ((unsigned int const   )action->type == 5U) {
#line 286
    goto case_5;
  }
#line 293
  if ((unsigned int const   )action->type == 6U) {
#line 293
    goto case_6;
  }
#line 296
  if ((unsigned int const   )action->type == 7U) {
#line 296
    goto case_7;
  }
#line 299
  if ((unsigned int const   )action->type == 8U) {
#line 299
    goto case_8;
  }
#line 302
  if ((unsigned int const   )action->type == 9U) {
#line 302
    goto case_9;
  }
#line 305
  if ((unsigned int const   )action->type == 10U) {
#line 305
    goto case_10;
  }
#line 308
  if ((unsigned int const   )action->type == 15U) {
#line 308
    goto case_15;
  }
#line 312
  if ((unsigned int const   )action->type == 2U) {
#line 312
    goto case_2;
  }
#line 312
  if ((unsigned int const   )action->type == 3U) {
#line 312
    goto case_2;
  }
#line 315
  if ((unsigned int const   )action->type == 11U) {
#line 315
    goto case_11;
  }
#line 322
  if ((unsigned int const   )action->type == 12U) {
#line 322
    goto case_12;
  }
#line 325
  if ((unsigned int const   )action->type == 13U) {
#line 325
    goto case_13;
  }
#line 328
  if ((unsigned int const   )action->type == 14U) {
#line 328
    goto case_14;
  }
#line 331
  if ((unsigned int const   )action->type == 4U) {
#line 331
    goto case_4;
  }
#line 334
  goto switch_default;
  case_5: /* CIL Label */ 
#line 287
  if (client->state.status & 32U) {
    {
#line 288
    SetClientSticky(client, (char)0);
    }
  } else {
    {
#line 290
    SetClientSticky(client, (char)1);
    }
  }
#line 292
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 294
  MaximizeClient(client, (char)1, (char)1);
  }
#line 295
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 297
  MaximizeClient(client, (char)1, (char)0);
  }
#line 298
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 300
  MaximizeClient(client, (char)0, (char)1);
  }
#line 301
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 303
  MinimizeClient(client);
  }
#line 304
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 306
  RestoreClient(client, (char)1);
  }
#line 307
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 309
  DeleteClient(client);
  }
#line 310
  goto switch_break;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 313
  SetClientDesktop(client, (unsigned int )action->data.i);
  }
#line 314
  goto switch_break;
  case_11: /* CIL Label */ 
#line 316
  if (client->state.status & 256U) {
    {
#line 317
    UnshadeClient(client);
    }
  } else {
    {
#line 319
    ShadeClient(client);
    }
  }
#line 321
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 323
  MoveClientKeyboard(client);
  }
#line 324
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 326
  ResizeClientKeyboard(client);
  }
#line 327
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 329
  KillClient(client);
  }
#line 330
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 332
  SetClientLayer(client, (unsigned int )action->data.i);
  }
#line 333
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 335
  Debug("unknown window command: %d", (unsigned int const   )action->type);
  }
#line 336
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 339
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 3407 "/usr/include/X11/Xlib.h"
extern int XStoreName(Display * , Window  , char const   * ) ;
#line 659 "/usr/include/X11/Xutil.h"
extern void XSetWMNormalHints(Display * , Window  , XSizeHints * ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.h"
void InitializeDialogs(void) ;
#line 17
void StartupDialogs(void) ;
#line 18
void ShutdownDialogs(void) ;
#line 19
void DestroyDialogs(void) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/button.h"
void DrawButton(ButtonNode *bp ) ;
#line 59
void ResetButton(ButtonNode *bp , Drawable d , GC g ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static char const   *OK_STRING  =    "Ok";
#line 54 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static char const   *CANCEL_STRING  =    "Cancel";
#line 56 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static DialogType *dialogList  =    (DialogType *)((void *)0);
#line 58 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static int minWidth  =    0;
#line 60
static void DrawConfirmDialog(DialogType *dp ) ;
#line 61
static void DestroyConfirmDialog(DialogType *dp ) ;
#line 62
static void ComputeDimensions(DialogType *dp ) ;
#line 63
static void DrawMessage(DialogType *dp ) ;
#line 64
static void DrawButtons(DialogType *dp ) ;
#line 65
static DialogType *FindDialogByWindow(Window w ) ;
#line 66
static int HandleDialogExpose(XExposeEvent const   *event ) ;
#line 67
static int HandleDialogButtonPress(XButtonEvent const   *event ) ;
#line 68
static int HandleDialogButtonRelease(XButtonEvent const   *event ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
void InitializeDialogs(void) 
{ 


  {
#line 72
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
void StartupDialogs(void) 
{ 


  {
#line 76
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
void ShutdownDialogs(void) 
{ 


  {
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! dialogList) {
#line 81
      goto while_break;
    }
    {
#line 82
    DestroyConfirmDialog(dialogList);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
void DestroyDialogs(void) 
{ 


  {
#line 89
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
int ProcessDialogEvent(XEvent const   *event ) 
{ 
  int handled ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 94
  handled = 0;
  {
#line 99
  if (event->type == 12) {
#line 99
    goto case_12;
  }
#line 101
  if (event->type == 4) {
#line 101
    goto case_4;
  }
#line 103
  if (event->type == 5) {
#line 103
    goto case_5;
  }
#line 105
  goto switch_default;
  case_12: /* CIL Label */ 
  {
#line 100
  tmp = HandleDialogExpose(& event->xexpose);
  }
#line 100
  return (tmp);
  case_4: /* CIL Label */ 
  {
#line 102
  tmp___0 = HandleDialogButtonPress(& event->xbutton);
  }
#line 102
  return (tmp___0);
  case_5: /* CIL Label */ 
  {
#line 104
  tmp___1 = HandleDialogButtonRelease(& event->xbutton);
  }
#line 104
  return (tmp___1);
  switch_default: /* CIL Label */ 
#line 106
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 109
  return (handled);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static int HandleDialogExpose(XExposeEvent const   *event ) 
{ 
  DialogType *dp ;

  {
  {
#line 120
  dp = FindDialogByWindow((Window )event->window);
  }
#line 121
  if (dp) {
    {
#line 122
    DrawConfirmDialog(dp);
    }
#line 123
    return (1);
  } else {
#line 125
    return (0);
  }
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static int HandleDialogButtonRelease(XButtonEvent const   *event ) 
{ 
  DialogType *dp ;
  int x ;
  int y ;
  int cancelPressed ;
  int okPressed ;

  {
  {
#line 138
  dp = FindDialogByWindow((Window )event->window);
  }
#line 139
  if (dp) {
#line 140
    cancelPressed = 0;
#line 141
    okPressed = 0;
#line 142
    y = (int )event->y;
#line 143
    if (y >= dp->buttony) {
#line 143
      if (y < dp->buttony + dp->buttonHeight) {
#line 144
        x = (int )event->x;
#line 145
        if (x >= dp->okx) {
#line 145
          if (x < dp->okx + dp->buttonWidth) {
#line 146
            okPressed = 1;
          } else {
#line 145
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 147
        if (x >= dp->cancelx) {
#line 147
          if (x < dp->cancelx + dp->buttonWidth) {
#line 148
            cancelPressed = 1;
          }
        }
      }
    }
#line 152
    if (okPressed) {
      {
#line 153
      (*(dp->action))(dp->client);
      }
    }
#line 156
    if (cancelPressed) {
      {
#line 157
      DestroyConfirmDialog(dp);
      }
    } else
#line 156
    if (okPressed) {
      {
#line 157
      DestroyConfirmDialog(dp);
      }
    } else {
      {
#line 159
      dp->buttonState = (DialogButtonState )0;
#line 160
      DrawButtons(dp);
      }
    }
#line 163
    return (1);
  } else {
#line 166
    dp = dialogList;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
#line 167
      if ((unsigned int )dp->buttonState != 0U) {
        {
#line 168
        dp->buttonState = (DialogButtonState )0;
#line 169
        DrawButtons(dp);
        }
      }
#line 166
      dp = dp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 173
    return (0);
  }
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static int HandleDialogButtonPress(XButtonEvent const   *event ) 
{ 
  DialogType *dp ;
  int cancelPressed ;
  int okPressed ;
  int x ;
  int y ;

  {
  {
#line 190
  dp = FindDialogByWindow((Window )event->window);
  }
#line 191
  if (dp) {
#line 194
    cancelPressed = 0;
#line 195
    okPressed = 0;
#line 196
    y = (int )event->y;
#line 197
    if (y >= dp->buttony) {
#line 197
      if (y < dp->buttony + dp->buttonHeight) {
#line 198
        x = (int )event->x;
#line 199
        if (x >= dp->okx) {
#line 199
          if (x < dp->okx + dp->buttonWidth) {
#line 200
            okPressed = 1;
          } else {
#line 199
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 201
        if (x >= dp->cancelx) {
#line 201
          if (x < dp->cancelx + dp->buttonWidth) {
#line 202
            cancelPressed = 1;
          }
        }
      }
    }
#line 206
    dp->buttonState = (DialogButtonState )0;
#line 207
    if (cancelPressed) {
#line 208
      dp->buttonState = (DialogButtonState )2;
    }
#line 211
    if (okPressed) {
#line 212
      dp->buttonState = (DialogButtonState )1;
    }
    {
#line 216
    DrawButtons(dp);
    }
#line 218
    return (1);
  } else {
#line 223
    return (0);
  }
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static DialogType *FindDialogByWindow(Window w ) 
{ 
  DialogType *dp ;

  {
#line 234
  dp = dialogList;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! dp) {
#line 234
      goto while_break;
    }
#line 235
    if ((dp->node)->window == w) {
#line 236
      return (dp);
    }
#line 234
    dp = dp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return ((DialogType *)((void *)0));
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
void ShowConfirmDialog(struct ClientNode *np , void (*action)(struct ClientNode * ) 
                       , ...) 
{ 
  va_list ap ;
  DialogType *dp ;
  XSetWindowAttributes attrs ;
  XSizeHints shints ;
  Window window ;
  char *str___0 ;
  int x ;
  void *tmp ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 257
  tmp = malloc(sizeof(DialogType ));
#line 257
  dp = (DialogType *)tmp;
#line 258
  dp->client = np;
#line 259
  dp->action = action;
#line 260
  dp->buttonState = (DialogButtonState )0;
#line 262
  dp->prev = (struct DialogType *)((void *)0);
#line 263
  dp->next = dialogList;
  }
#line 264
  if (dialogList) {
#line 265
    dialogList->prev = dp;
  }
  {
#line 267
  dialogList = dp;
#line 270
  __builtin_va_start(ap, action);
#line 271
  dp->lineCount = 0;
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 271
    tmp___1 = __builtin_va_arg(ap, char *);
    }
#line 271
    if (! tmp___1) {
#line 271
      goto while_break;
    }
#line 271
    (dp->lineCount) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  __builtin_va_end(ap);
#line 274
  tmp___2 = malloc((unsigned long )dp->lineCount * sizeof(char *));
#line 274
  dp->message = (char **)tmp___2;
#line 275
  __builtin_va_start(ap, action);
#line 276
  x = 0;
  }
  {
#line 276
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 276
    if (! (x < dp->lineCount)) {
#line 276
      goto while_break___0;
    }
    {
#line 277
    tmp___3 = __builtin_va_arg(ap, char *);
#line 277
    str___0 = tmp___3;
#line 278
    *(dp->message + x) = CopyString((char const   *)str___0);
#line 276
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 280
  __builtin_va_end(ap);
#line 282
  ComputeDimensions(dp);
#line 284
  attrs.background_pixel = colors[8];
#line 285
  attrs.event_mask = (1L << 3) | (1L << 15);
#line 287
  window = XCreateWindow(display, rootWindow, dp->x, dp->y, (unsigned int )dp->width,
                         (unsigned int )dp->height, 0U, 0, 1U, (Visual *)0L, (unsigned long )((1L << 1) | (1L << 11)),
                         & attrs);
#line 292
  shints.x = dp->x;
#line 293
  shints.y = dp->y;
#line 294
  shints.flags = 1L << 2;
#line 295
  XSetWMNormalHints(display, window, & shints);
#line 297
  XStoreName(display, window, "Confirm");
#line 299
  dp->node = AddClientWindow(window, (char)0, (char)0);
  }
#line 301
  if (np) {
#line 302
    (dp->node)->owner = np->window;
  }
  {
#line 304
  (dp->node)->state.status |= 512U;
#line 305
  FocusClient(dp->node);
#line 307
  DrawConfirmDialog(dp);
#line 309
  XGrabButton(display, 0U, (unsigned int )(1 << 15), window, 1, (unsigned int )(1L << 3),
              1, 1, (Window )0L, (Cursor )0L);
  }
#line 312
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static void DrawConfirmDialog(DialogType *dp ) 
{ 


  {
  {
#line 319
  DrawMessage(dp);
#line 320
  DrawButtons(dp);
  }
#line 322
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static void DestroyConfirmDialog(DialogType *dp ) 
{ 
  int x ;

  {
  {
#line 333
  RemoveClient(dp->node);
#line 335
  x = 0;
  }
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! (x < dp->lineCount)) {
#line 335
      goto while_break;
    }
    {
#line 336
    free((void *)*(dp->message + x));
#line 335
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 338
  free((void *)dp->message);
  }
#line 340
  if (dp->next) {
#line 341
    (dp->next)->prev = dp->prev;
  }
#line 343
  if (dp->prev) {
#line 344
    (dp->prev)->next = dp->next;
  } else {
#line 346
    dialogList = dp->next;
  }
  {
#line 348
  free((void *)dp);
  }
#line 350
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static void ComputeDimensions(DialogType *dp ) 
{ 
  ScreenType const   *sp ;
  int width ;
  int x ;
  int tmp ;
  int tmp___0 ;

  {
#line 362
  if (! minWidth) {
    {
#line 363
    tmp = GetStringWidth((FontType )1, CANCEL_STRING);
#line 363
    minWidth = tmp * 3;
#line 364
    tmp___0 = GetStringWidth((FontType )1, OK_STRING);
#line 364
    width = tmp___0 * 3;
    }
#line 365
    if (width > minWidth) {
#line 366
      minWidth = width;
    }
#line 368
    minWidth += 48;
  }
#line 370
  dp->width = minWidth;
#line 373
  x = 0;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (x < dp->lineCount)) {
#line 373
      goto while_break;
    }
    {
#line 374
    width = GetStringWidth((FontType )1, (char const   *)*(dp->message + x));
    }
#line 375
    if (width > dp->width) {
#line 376
      dp->width = width;
    }
#line 373
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 379
  dp->lineHeight = GetStringHeight((FontType )1);
#line 380
  dp->width += 8;
#line 381
  dp->height = (dp->lineCount + 2) * dp->lineHeight;
  }
#line 383
  if (dp->client) {
#line 385
    dp->x = (dp->client)->x + ((dp->client)->width - dp->width) / 2;
#line 386
    dp->y = (dp->client)->y + ((dp->client)->height - dp->height) / 2;
#line 388
    if (dp->x < 0) {
#line 389
      dp->x = 0;
    }
#line 391
    if (dp->y < 0) {
#line 392
      dp->y = 0;
    }
#line 394
    if (dp->x + dp->width >= rootWidth) {
#line 395
      dp->x = (rootWidth - dp->width) - borderWidth * 2;
    }
#line 397
    if (dp->y + dp->height >= rootHeight) {
#line 398
      dp->y = (rootHeight - dp->height) - (borderWidth * 2 + titleHeight);
    }
  } else {
    {
#line 403
    sp = GetMouseScreen();
#line 405
    dp->x = (int )((sp->width - (int const   )dp->width) / 2 + sp->x);
#line 406
    dp->y = (int )((sp->height - (int const   )dp->height) / 2 + sp->y);
    }
  }
#line 410
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static void DrawMessage(DialogType *dp ) 
{ 
  int yoffset ;
  int x ;

  {
#line 420
  yoffset = 4;
#line 421
  x = 0;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (x < dp->lineCount)) {
#line 421
      goto while_break;
    }
    {
#line 422
    RenderString((dp->node)->window, (FontType )1, (ColorType )9, 4, yoffset, dp->width,
                 (Region )((void *)0), (char const   *)*(dp->message + x));
#line 424
    yoffset += dp->lineHeight;
#line 421
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 427
  return;
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/confirm.c"
static void DrawButtons(DialogType *dp ) 
{ 
  ButtonNode button ;
  int temp ;

  {
  {
#line 437
  dp->buttonWidth = GetStringWidth((FontType )1, CANCEL_STRING);
#line 438
  temp = GetStringWidth((FontType )1, OK_STRING);
  }
#line 439
  if (temp > dp->buttonWidth) {
#line 440
    dp->buttonWidth = temp;
  }
  {
#line 442
  dp->buttonWidth += 16;
#line 443
  dp->buttonHeight = dp->lineHeight + 4;
#line 445
  ResetButton(& button, (dp->node)->window, rootGC);
#line 446
  button.font = (FontType )1;
#line 447
  button.width = dp->buttonWidth;
#line 448
  button.height = dp->buttonHeight;
#line 449
  button.alignment = (AlignmentType )1;
#line 451
  dp->okx = dp->width / 3 - dp->buttonWidth / 2;
#line 452
  dp->cancelx = (2 * dp->width) / 3 - dp->buttonWidth / 2;
#line 453
  dp->buttony = (dp->height - dp->lineHeight) - dp->lineHeight / 2;
  }
#line 455
  if ((unsigned int )dp->buttonState == 1U) {
#line 456
    button.type = (ButtonType )4;
  } else {
#line 458
    button.type = (ButtonType )3;
  }
  {
#line 460
  button.text = OK_STRING;
#line 461
  button.x = dp->okx;
#line 462
  button.y = dp->buttony;
#line 463
  DrawButton(& button);
  }
#line 465
  if ((unsigned int )dp->buttonState == 2U) {
#line 466
    button.type = (ButtonType )4;
  } else {
#line 468
    button.type = (ButtonType )3;
  }
  {
#line 470
  button.text = CANCEL_STRING;
#line 471
  button.x = dp->cancelx;
#line 472
  button.y = dp->buttony;
#line 473
  DrawButton(& button);
  }
#line 475
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/match.h"
int Match(char const   *pattern , char const   *expression ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/match.c"
int Match(char const   *pattern , char const   *expression ) 
{ 
  regex_t re ;
  regmatch_t rm ;
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
#line 23
  if (! pattern) {
#line 23
    if (! expression) {
#line 24
      return (1);
    } else {
#line 23
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 25
  if (! pattern) {
#line 26
    return (0);
  } else
#line 25
  if (! expression) {
#line 26
    return (0);
  }
  {
#line 30
  tmp = regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)pattern,
                1);
  }
#line 30
  if (tmp != 0) {
#line 31
    return (0);
  }
  {
#line 34
  rc = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)expression,
               (size_t )0, (regmatch_t */* __restrict  */)(& rm), 0);
#line 36
  regfree(& re);
  }
#line 38
  if (rc == 0) {
#line 38
    tmp___0 = 1;
  } else {
#line 38
    tmp___0 = 0;
  }
#line 38
  return (tmp___0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/render.h"
int PutScaledRenderIcon(struct IconNode *icon , struct ScaledIconNode *node , Drawable d ,
                        int x , int y ) ;
#line 33
struct ScaledIconNode *CreateScaledRenderIcon(struct IconNode *icon , int width ,
                                              int height ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/render.c"
int PutScaledRenderIcon(struct IconNode *icon , struct ScaledIconNode *node , Drawable d ,
                        int x , int y ) 
{ 


  {
#line 85
  return (0);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/render.c"
struct ScaledIconNode *CreateScaledRenderIcon(struct IconNode *icon , int width ,
                                              int height ) 
{ 
  ScaledIconNode *result ;

  {
#line 95
  result = (ScaledIconNode *)((void *)0);
#line 201
  return (result);
}
}
#line 1588 "/usr/include/X11/Xlib.h"
extern Cursor XCreateFontCursor(Display * , unsigned int  ) ;
#line 2545
extern int XFreeCursor(Display * , Cursor  ) ;
#line 2741
extern int XGrabPointer(Display * , Window  , int  , unsigned int  , int  , int  ,
                        Window  , Cursor  , Time  ) ;
#line 3526
extern int XWarpPointer(Display * , Window  , Window  , int  , int  , unsigned int  ,
                        unsigned int  , int  , int  ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.h"
void InitializeCursors(void) ;
#line 17
void StartupCursors(void) ;
#line 18
void ShutdownCursors(void) ;
#line 19
void DestroyCursors(void) ;
#line 26
int GrabMouseForResize(BorderActionType action ) ;
#line 31
int GrabMouseForMove(void) ;
#line 36
int GrabMouse(Window w ) ;
#line 54
void MoveMouse(Window win , int x , int y ) ;
#line 71
unsigned int GetMouseMask(void) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor defaultCursor  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor moveCursor  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor northCursor  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor southCursor  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor eastCursor  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor westCursor  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor northEastCursor  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor northWestCursor  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor southEastCursor  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor southWestCursor  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor chooseCursor  ;
#line 27
static Cursor GetResizeCursor(BorderActionType action ) ;
#line 28
static Cursor CreateCursor(unsigned int shape ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static int mousex  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static int mousey  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
void InitializeCursors(void) 
{ 


  {
#line 35
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
void StartupCursors(void) 
{ 
  Window win1 ;
  Window win2 ;
  int winx ;
  int winy ;
  unsigned int mask ;

  {
  {
#line 44
  defaultCursor = CreateCursor(68U);
#line 45
  moveCursor = CreateCursor(52U);
#line 46
  northCursor = CreateCursor(138U);
#line 47
  southCursor = CreateCursor(16U);
#line 48
  eastCursor = CreateCursor(96U);
#line 49
  westCursor = CreateCursor(70U);
#line 50
  northEastCursor = CreateCursor(148U);
#line 51
  northWestCursor = CreateCursor(144U);
#line 52
  southEastCursor = CreateCursor(78U);
#line 53
  southWestCursor = CreateCursor(76U);
#line 54
  chooseCursor = CreateCursor(130U);
#line 56
  XQueryPointer(display, rootWindow, & win1, & win2, & mousex, & mousey, & winx, & winy,
                & mask);
  }
#line 59
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor CreateCursor(unsigned int shape ) 
{ 
  Cursor tmp ;

  {
  {
#line 63
  tmp = XCreateFontCursor(display, shape);
  }
#line 63
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
void ShutdownCursors(void) 
{ 


  {
  {
#line 69
  XFreeCursor(display, defaultCursor);
#line 70
  XFreeCursor(display, moveCursor);
#line 71
  XFreeCursor(display, northCursor);
#line 72
  XFreeCursor(display, southCursor);
#line 73
  XFreeCursor(display, eastCursor);
#line 74
  XFreeCursor(display, westCursor);
#line 75
  XFreeCursor(display, northEastCursor);
#line 76
  XFreeCursor(display, northWestCursor);
#line 77
  XFreeCursor(display, southEastCursor);
#line 78
  XFreeCursor(display, southWestCursor);
#line 79
  XFreeCursor(display, chooseCursor);
  }
#line 81
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
void DestroyCursors(void) 
{ 


  {
#line 85
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
Cursor GetFrameCursor(BorderActionType action ) 
{ 
  Cursor tmp ;

  {
  {
#line 91
  if (((unsigned int )action & 15U) == 1U) {
#line 91
    goto case_1;
  }
#line 93
  if (((unsigned int )action & 15U) == 3U) {
#line 93
    goto case_3;
  }
#line 95
  if (((unsigned int )action & 15U) == 4U) {
#line 95
    goto case_4;
  }
#line 97
  if (((unsigned int )action & 15U) == 5U) {
#line 97
    goto case_5;
  }
#line 99
  if (((unsigned int )action & 15U) == 2U) {
#line 99
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 92
  tmp = GetResizeCursor(action);
  }
#line 92
  return (tmp);
  case_3: /* CIL Label */ 
#line 94
  goto switch_break;
  case_4: /* CIL Label */ 
#line 96
  goto switch_break;
  case_5: /* CIL Label */ 
#line 98
  goto switch_break;
  case_2: /* CIL Label */ 
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 102
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 104
  return (defaultCursor);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
static Cursor GetResizeCursor(BorderActionType action ) 
{ 


  {
#line 111
  if ((unsigned int )action & 16U) {
#line 112
    if ((unsigned int )action & 64U) {
#line 113
      return (northEastCursor);
    } else
#line 114
    if ((unsigned int )action & 128U) {
#line 115
      return (northWestCursor);
    } else {
#line 117
      return (northCursor);
    }
  } else
#line 119
  if ((unsigned int )action & 32U) {
#line 120
    if ((unsigned int )action & 64U) {
#line 121
      return (southEastCursor);
    } else
#line 122
    if ((unsigned int )action & 128U) {
#line 123
      return (southWestCursor);
    } else {
#line 125
      return (southCursor);
    }
  } else
#line 128
  if ((unsigned int )action & 64U) {
#line 129
    return (eastCursor);
  } else {
#line 131
    return (westCursor);
  }
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
int GrabMouseForResize(BorderActionType action ) 
{ 
  Cursor cur ;
  int result ;
  long tmp ;

  {
  {
#line 143
  cur = GetFrameCursor(action);
#line 145
  result = XGrabPointer(display, rootWindow, 0, (unsigned int )(((1L << 2) | (1L << 3)) | (1L << 6)),
                        1, 1, (Window )0L, cur, (Time )0L);
#line 149
  tmp = __builtin_expect((long )(! (! (result == 0))), 1L);
  }
#line 149
  if (tmp) {
#line 150
    return (1);
  } else {
#line 152
    return (0);
  }
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
int GrabMouseForMove(void) 
{ 
  int result ;
  long tmp ;

  {
  {
#line 162
  result = XGrabPointer(display, rootWindow, 0, (unsigned int )(((1L << 2) | (1L << 3)) | (1L << 6)),
                        1, 1, (Window )0L, moveCursor, (Time )0L);
#line 166
  tmp = __builtin_expect((long )(! (! (result == 0))), 1L);
  }
#line 166
  if (tmp) {
#line 167
    return (1);
  } else {
#line 169
    return (0);
  }
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
int GrabMouse(Window w ) 
{ 
  int result ;
  long tmp ;

  {
  {
#line 179
  result = XGrabPointer(display, w, 0, (unsigned int )(((1L << 2) | (1L << 3)) | (1L << 6)),
                        1, 1, (Window )0L, defaultCursor, (Time )0L);
#line 183
  tmp = __builtin_expect((long )(! (! (result == 0))), 1L);
  }
#line 183
  if (tmp) {
#line 184
    return (1);
  } else {
#line 186
    return (0);
  }
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
int GrabMouseForChoose(void) 
{ 
  int result ;
  long tmp ;

  {
  {
#line 196
  result = XGrabPointer(display, rootWindow, 0, (unsigned int )(((1L << 2) | (1L << 3)) | (1L << 6)),
                        1, 1, (Window )0L, chooseCursor, (Time )0L);
#line 200
  tmp = __builtin_expect((long )(! (! (result == 0))), 1L);
  }
#line 200
  if (tmp) {
#line 201
    return (1);
  } else {
#line 203
    return (0);
  }
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
void SetDefaultCursor(Window w ) 
{ 


  {
  {
#line 211
  XDefineCursor(display, w, defaultCursor);
  }
#line 213
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
void MoveMouse(Window win , int x , int y ) 
{ 
  Window win1 ;
  Window win2 ;
  int winx ;
  int winy ;
  unsigned int mask ;

  {
  {
#line 222
  XWarpPointer(display, (Window )0L, win, 0, 0, 0U, 0U, x, y);
#line 224
  XQueryPointer(display, rootWindow, & win1, & win2, & mousex, & mousey, & winx, & winy,
                & mask);
  }
#line 227
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
void SetMousePosition(int x , int y ) 
{ 


  {
#line 232
  mousex = x;
#line 233
  mousey = y;
#line 235
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
void GetMousePosition(int *x , int *y ) 
{ 


  {
#line 243
  *x = mousex;
#line 244
  *y = mousey;
#line 246
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
unsigned int GetMouseMask(void) 
{ 
  Window win1 ;
  Window win2 ;
  int winx ;
  int winy ;
  unsigned int mask ;

  {
  {
#line 255
  XQueryPointer(display, rootWindow, & win1, & win2, & mousex, & mousey, & winx, & winy,
                & mask);
  }
#line 258
  return (mask);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
void SetDoubleClickSpeed(char const   *str___0 ) 
{ 
  int speed ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 267
  if (str___0) {
    {
#line 268
    speed = atoi(str___0);
    }
#line 269
    if (speed < 1) {
#line 269
      tmp___0 = 1;
    } else
#line 269
    if (speed > 2000) {
#line 269
      tmp___0 = 1;
    } else {
#line 269
      tmp___0 = 0;
    }
    {
#line 269
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 269
    if (tmp___1) {
      {
#line 271
      tmp = gettext("invalid DoubleClickSpeed: %d");
#line 271
      Warning((char const   *)tmp, speed);
#line 272
      doubleClickSpeed = 400U;
      }
    } else {
#line 274
      doubleClickSpeed = (unsigned int )speed;
    }
  }
#line 278
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/cursor.c"
void SetDoubleClickDelta(char const   *str___0 ) 
{ 
  int delta ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 285
  if (str___0) {
    {
#line 286
    delta = atoi(str___0);
    }
#line 287
    if (delta < 0) {
#line 287
      tmp___0 = 1;
    } else
#line 287
    if (delta > 32) {
#line 287
      tmp___0 = 1;
    } else {
#line 287
      tmp___0 = 0;
    }
    {
#line 287
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 287
    if (tmp___1) {
      {
#line 289
      tmp = gettext("invalid DoubleClickDelta: %d");
#line 289
      Warning((char const   *)tmp, delta);
#line 290
      doubleClickDelta = 2U;
      }
    } else {
#line 292
      doubleClickDelta = (unsigned int )delta;
    }
  }
#line 296
  return;
}
}
#line 1453 "/usr/include/X11/Xlib.h"
extern XImage *XCreateImage(Display * , Visual * , unsigned int  , int  , int  , char * ,
                            unsigned int  , unsigned int  , int  , int  ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 2196
extern int XCopyArea(Display * , Drawable  , Drawable  , GC  , int  , int  , unsigned int  ,
                     unsigned int  , int  , int  ) ;
#line 2573
extern int XFreeGC(Display * , GC  ) ;
#line 2915
extern int XPutImage(Display * , Drawable  , GC  , XImage * , int  , int  , int  ,
                     int  , unsigned int  , unsigned int  ) ;
#line 3172
extern int XSetClipMask(Display * , GC  , Pixmap  ) ;
#line 3178
extern int XSetClipOrigin(Display * , GC  , int  , int  ) ;
#line 589 "/usr/include/X11/Xutil.h"
extern int XSetIconSizes(Display * , Window  , XIconSize * , int  ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.h"
IconNode emptyIcon  ;
#line 50
void InitializeIcons(void) ;
#line 51
void StartupIcons(void) ;
#line 52
void ShutdownIcons(void) ;
#line 53
void DestroyIcons(void) ;
#line 94
IconNode *CreateIcon(void) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/image.h"
ImageNode *LoadImage(char const   *fileName ) ;
#line 33
ImageNode *LoadImageFromData(char **data ) ;
#line 38
void DestroyImage(ImageNode *image ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/misc.h"
void Trim(char *str___0 ) ;
#line 105 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.h"
void GetColor(XColor *c ) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/x.xpm"
static char *x_xpm[31]  = 
#line 2 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/x.xpm"
  {      (char *)"28 28 2 1",      (char *)". c None",      (char *)"# c #ff0000",      (char *)"............................", 
        (char *)"............................",      (char *)"............................",      (char *)"............................",      (char *)".########..............##...", 
        (char *)"..########............##....",      (char *)"...########..........##.....",      (char *)"....########........##......",      (char *)".....########......##.......", 
        (char *)"......########....##........",      (char *)".......########..##.........",      (char *)"........######..##..........",      (char *)".........####..##...........", 
        (char *)"..........##..####..........",      (char *)".........##..######.........",      (char *)"........##..########........",      (char *)".......##....########.......", 
        (char *)"......##......########......",      (char *)".....##........########.....",      (char *)"....##..........########....",      (char *)"...##............########...", 
        (char *)"..##..............########..",      (char *)".##................########.",      (char *)"............................",      (char *)"............................", 
        (char *)"............................",      (char *)"............................",      (char *)"............................"};
#line 35 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static int iconSize  =    0;
#line 36 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static IconNode **iconHash  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static IconPathNode *iconPaths  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static IconPathNode *iconPathsTail  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static GC iconGC  ;
#line 41
static void SetIconSize(void) ;
#line 42
static void DoDestroyIcon(int index , IconNode *icon ) ;
#line 43
static void ReadNetWMIcon(ClientNode *np ) ;
#line 44
static IconNode *GetDefaultIcon(void) ;
#line 45
static IconNode *CreateIconFromData(char const   *name , char **data ) ;
#line 46
static IconNode *CreateIconFromFile(char const   *fileName ) ;
#line 47
static IconNode *CreateIconFromBinary(unsigned long const   *input , unsigned int length ) ;
#line 49
static IconNode *LoadNamedIconHelper(char const   *name , char const   *path ) ;
#line 54
static ScaledIconNode *GetScaledIcon(IconNode *icon , int rwidth , int rheight ) ;
#line 56
static void InsertIcon(IconNode *icon ) ;
#line 57
static IconNode *FindIcon(char const   *name ) ;
#line 58
static int GetHash(char const   *str___0 ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
void InitializeIcons(void) 
{ 
  int x ;
  void *tmp ;

  {
  {
#line 67
  iconPaths = (IconPathNode *)((void *)0);
#line 68
  iconPathsTail = (IconPathNode *)((void *)0);
#line 70
  tmp = malloc(sizeof(IconNode *) * 128UL);
#line 70
  iconHash = (IconNode **)tmp;
#line 71
  x = 0;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (x < 128)) {
#line 71
      goto while_break;
    }
#line 72
    *(iconHash + x) = (IconNode *)((void *)0);
#line 71
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  memset((void *)(& emptyIcon), 0, sizeof(emptyIcon));
  }
#line 77
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
void StartupIcons(void) 
{ 
  XGCValues gcValues ;
  unsigned long gcMask ;

  {
  {
#line 85
  gcMask = (unsigned long )(1L << 16);
#line 86
  gcValues.graphics_exposures = 0;
#line 87
  iconGC = XCreateGC(display, rootWindow, gcMask, & gcValues);
  }
#line 89
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
void ShutdownIcons(void) 
{ 
  int x ;

  {
#line 96
  x = 0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (x < 128)) {
#line 96
      goto while_break;
    }
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      if (! *(iconHash + x)) {
#line 97
        goto while_break___0;
      }
      {
#line 98
      DoDestroyIcon(x, *(iconHash + x));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 96
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  XFreeGC(display, iconGC);
  }
#line 104
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
void DestroyIcons(void) 
{ 
  IconPathNode *pn ;

  {
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! iconPaths) {
#line 111
      goto while_break;
    }
    {
#line 112
    pn = iconPaths->next;
#line 113
    free((void *)iconPaths->path);
#line 114
    free((void *)iconPaths);
#line 115
    iconPaths = pn;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  iconPathsTail = (IconPathNode *)((void *)0);
#line 119
  if (iconHash) {
    {
#line 120
    free((void *)iconHash);
#line 121
    iconHash = (IconNode **)((void *)0);
    }
  }
#line 123
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static void SetIconSize(void) 
{ 
  XIconSize size ;

  {
#line 130
  if (! iconSize) {
    {
#line 133
    iconSize = 32;
#line 135
    size.min_width = iconSize;
#line 136
    size.min_height = iconSize;
#line 137
    size.max_width = iconSize;
#line 138
    size.max_height = iconSize;
#line 139
    size.width_inc = iconSize;
#line 140
    size.height_inc = iconSize;
#line 142
    XSetIconSizes(display, rootWindow, & size, 1);
    }
  }
#line 146
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
void AddIconPath(char *path ) 
{ 
  IconPathNode *ip ;
  int length ;
  int addSep ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 155
  if (! path) {
#line 156
    return;
  }
  {
#line 159
  Trim(path);
#line 161
  tmp = strlen((char const   *)path);
#line 161
  length = (int )tmp;
  }
#line 162
  if ((int )*(path + (length - 1)) != 47) {
#line 163
    addSep = 1;
  } else {
#line 165
    addSep = 0;
  }
  {
#line 168
  tmp___0 = malloc(sizeof(IconPathNode ));
#line 168
  ip = (IconPathNode *)tmp___0;
#line 169
  tmp___1 = malloc((size_t )((length + addSep) + 1));
#line 169
  ip->path = (char *)tmp___1;
#line 170
  strcpy((char */* __restrict  */)ip->path, (char const   */* __restrict  */)path);
  }
#line 171
  if (addSep) {
#line 172
    *(ip->path + length) = (char )'/';
#line 173
    *(ip->path + (length + 1)) = (char)0;
  }
  {
#line 175
  ExpandPath(& ip->path);
#line 176
  ip->next = (struct IconPathNode *)((void *)0);
  }
#line 178
  if (iconPathsTail) {
#line 179
    iconPathsTail->next = ip;
  } else {
#line 181
    iconPaths = ip;
  }
#line 183
  iconPathsTail = ip;
#line 185
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
void PutIcon(IconNode *icon , Drawable d , int x , int y , int width , int height ) 
{ 
  ScaledIconNode *node ;
  int ix ;
  int iy ;
  int tmp ;

  {
#line 196
  if ((unsigned long )icon == (unsigned long )(& emptyIcon)) {
#line 197
    return;
  }
  {
#line 201
  node = GetScaledIcon(icon, width, height);
  }
#line 203
  if (node) {
    {
#line 205
    ix = x + (width - node->width) / 2;
#line 206
    iy = y + (height - node->height) / 2;
#line 209
    tmp = PutScaledRenderIcon(icon, node, d, ix, iy);
    }
#line 209
    if (tmp) {
#line 210
      return;
    }
#line 214
    if (node->image != 0UL) {
#line 217
      if (node->mask != 0UL) {
        {
#line 218
        XSetClipOrigin(display, iconGC, ix, iy);
#line 219
        XSetClipMask(display, iconGC, node->mask);
        }
      }
      {
#line 223
      XCopyArea(display, node->image, d, iconGC, 0, 0, (unsigned int )node->width,
                (unsigned int )node->height, ix, iy);
      }
#line 227
      if (node->mask != 0UL) {
        {
#line 228
        XSetClipMask(display, iconGC, (Pixmap )0L);
#line 229
        XSetClipOrigin(display, iconGC, 0, 0);
        }
      }
    }
  }
#line 236
  return;
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
void LoadIcon(struct ClientNode *np ) 
{ 
  IconPathNode *ip ;

  {
  {
#line 245
  SetIconSize();
#line 248
  DestroyIcon(np->icon);
#line 249
  np->icon = (struct IconNode *)((void *)0);
#line 252
  ReadNetWMIcon(np);
  }
#line 253
  if (np->icon) {
#line 254
    return;
  }
#line 258
  if (np->instanceName) {
#line 259
    ip = iconPaths;
    {
#line 259
    while (1) {
      while_continue: /* CIL Label */ ;
#line 259
      if (! ip) {
#line 259
        goto while_break;
      }
#line 259
      ip = ip->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 286
  np->icon = GetDefaultIcon();
  }
#line 288
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
IconNode *LoadNamedIcon(char const   *name ) 
{ 
  IconPathNode *ip ;
  IconNode *icon ;
  IconNode *tmp ;

  {
  {
#line 336
  SetIconSize();
  }
#line 338
  if ((int const   )*(name + 0) == 47) {
    {
#line 339
    tmp = CreateIconFromFile(name);
    }
#line 339
    return (tmp);
  } else {
#line 341
    ip = iconPaths;
    {
#line 341
    while (1) {
      while_continue: /* CIL Label */ ;
#line 341
      if (! ip) {
#line 341
        goto while_break;
      }
      {
#line 342
      icon = LoadNamedIconHelper(name, (char const   *)ip->path);
      }
#line 343
      if (icon) {
#line 344
        return (icon);
      }
#line 341
      ip = ip->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 347
    return ((IconNode *)((void *)0));
  }
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static IconNode *LoadNamedIconHelper(char const   *name , char const   *path ) 
{ 
  IconNode *result ;
  char *temp ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 358
  tmp = strlen(name);
#line 358
  tmp___0 = strlen(path);
#line 358
  tmp___1 = __builtin_alloca((tmp + tmp___0) + 1UL);
#line 358
  temp = (char *)tmp___1;
#line 359
  strcpy((char */* __restrict  */)temp, (char const   */* __restrict  */)path);
#line 360
  strcat((char */* __restrict  */)temp, (char const   */* __restrict  */)name);
#line 361
  result = CreateIconFromFile((char const   *)temp);
  }
#line 364
  return (result);
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static void ReadNetWMIcon(ClientNode *np ) 
{ 
  unsigned long count ;
  int status ;
  unsigned long extra ;
  Atom realType ;
  int realFormat ;
  unsigned char *data ;

  {
  {
#line 378
  status = XGetWindowProperty(display, np->window, atoms[47], 0L, 262144L, 0, (Atom )6,
                              & realType, & realFormat, & count, & extra, & data);
  }
#line 382
  if (status == 0) {
#line 382
    if (data) {
      {
#line 383
      np->icon = CreateIconFromBinary((unsigned long const   *)((unsigned long *)data),
                                      (unsigned int )count);
#line 384
      XFree((void *)data);
      }
    }
  }
#line 387
  return;
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static IconNode *GetDefaultIcon(void) 
{ 
  IconNode *tmp ;

  {
  {
#line 392
  tmp = CreateIconFromData("default", x_xpm);
  }
#line 392
  return (tmp);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static IconNode *CreateIconFromData(char const   *name , char **data ) 
{ 
  ImageNode *image ;
  IconNode *result ;

  {
  {
#line 405
  result = FindIcon(name);
  }
#line 406
  if (result) {
#line 407
    return (result);
  }
  {
#line 410
  image = LoadImageFromData(data);
  }
#line 411
  if (image) {
    {
#line 412
    result = CreateIcon();
#line 413
    result->name = CopyString(name);
#line 414
    result->image = image;
#line 415
    InsertIcon(result);
    }
#line 416
    return (result);
  } else {
#line 418
    return ((IconNode *)((void *)0));
  }
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static IconNode *CreateIconFromFile(char const   *fileName ) 
{ 
  ImageNode *image ;
  IconNode *result ;

  {
#line 429
  if (! fileName) {
#line 430
    return ((IconNode *)((void *)0));
  }
  {
#line 434
  result = FindIcon(fileName);
  }
#line 435
  if (result) {
#line 436
    return (result);
  }
  {
#line 439
  image = LoadImage(fileName);
  }
#line 440
  if (image) {
    {
#line 441
    result = CreateIcon();
#line 442
    result->name = CopyString(fileName);
#line 443
    result->image = image;
#line 444
    InsertIcon(result);
    }
#line 445
    return (result);
  } else {
#line 447
    return ((IconNode *)((void *)0));
  }
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static ScaledIconNode *GetScaledIcon(IconNode *icon , int rwidth , int rheight ) 
{ 
  XColor color ;
  XImage *image ;
  ScaledIconNode *np ;
  GC maskGC ;
  int x ;
  int y ;
  int index ;
  int yindex ;
  int scalex ;
  int scaley ;
  int srcx ;
  int srcy ;
  int ratio ;
  int nwidth ;
  int nheight ;
  unsigned char *data ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 470
  if (rwidth == 0) {
#line 471
    rwidth = (icon->image)->width;
  }
#line 473
  if (rheight == 0) {
#line 474
    rheight = (icon->image)->height;
  }
#line 477
  ratio = ((icon->image)->width << 16) / (icon->image)->height;
#line 478
  if (rwidth > rheight * ratio >> 16) {
#line 478
    nwidth = rheight * ratio >> 16;
  } else {
#line 478
    nwidth = rwidth;
  }
#line 479
  if (rheight > (nwidth << 16) / ratio) {
#line 479
    nheight = (nwidth << 16) / ratio;
  } else {
#line 479
    nheight = rheight;
  }
#line 480
  nwidth = nheight * ratio >> 16;
#line 481
  if (nwidth < 1) {
#line 482
    nwidth = 1;
  }
#line 484
  if (nheight < 1) {
#line 485
    nheight = 1;
  }
#line 491
  np = icon->nodes;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if (! np) {
#line 491
      goto while_break;
    }
#line 499
    if (np->width == nwidth) {
#line 499
      if (np->height == nheight) {
#line 500
        return (np);
      }
    }
#line 491
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 505
  np = CreateScaledRenderIcon(icon, nwidth, nheight);
  }
#line 506
  if (np) {
#line 507
    return (np);
  }
  {
#line 511
  tmp = malloc(sizeof(ScaledIconNode ));
#line 511
  np = (ScaledIconNode *)tmp;
#line 512
  np->width = nwidth;
#line 513
  np->height = nheight;
#line 514
  np->next = icon->nodes;
#line 518
  icon->nodes = np;
#line 521
  np->mask = XCreatePixmap(display, rootWindow, (unsigned int )nwidth, (unsigned int )nheight,
                           1U);
#line 522
  maskGC = XCreateGC(display, np->mask, 0UL, (XGCValues *)((void *)0));
#line 523
  XSetForeground(display, maskGC, 0UL);
#line 524
  XFillRectangle(display, np->mask, maskGC, 0, 0, (unsigned int )nwidth, (unsigned int )nheight);
#line 525
  XSetForeground(display, maskGC, 1UL);
#line 528
  image = XCreateImage(display, rootVisual, (unsigned int )rootDepth, 2, 0, (char *)((void *)0),
                       (unsigned int )nwidth, (unsigned int )nheight, 8, 0);
#line 530
  tmp___0 = malloc((sizeof(unsigned long ) * (unsigned long )nwidth) * (unsigned long )nheight);
#line 530
  image->data = (char *)tmp___0;
#line 533
  scalex = ((icon->image)->width << 16) / nwidth;
#line 534
  scaley = ((icon->image)->height << 16) / nheight;
#line 536
  data = (icon->image)->data;
#line 537
  srcy = 0;
#line 538
  y = 0;
  }
  {
#line 538
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 538
    if (! (y < nheight)) {
#line 538
      goto while_break___0;
    }
#line 539
    srcx = 0;
#line 540
    yindex = (srcy >> 16) * (icon->image)->width;
#line 541
    x = 0;
    {
#line 541
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 541
      if (! (x < nwidth)) {
#line 541
        goto while_break___1;
      }
      {
#line 542
      index = 4 * (yindex + (srcx >> 16));
#line 544
      color.red = (unsigned short )*(data + (index + 1));
#line 545
      color.red = (unsigned short )((int )color.red | ((int )color.red << 8));
#line 546
      color.green = (unsigned short )*(data + (index + 2));
#line 547
      color.green = (unsigned short )((int )color.green | ((int )color.green << 8));
#line 548
      color.blue = (unsigned short )*(data + (index + 3));
#line 549
      color.blue = (unsigned short )((int )color.blue | ((int )color.blue << 8));
#line 550
      GetColor(& color);
#line 552
      (*(image->f.put_pixel))(image, x, y, color.pixel);
      }
#line 554
      if ((int )*(data + index) >= 128) {
        {
#line 555
        XDrawPoint(display, np->mask, maskGC, x, y);
        }
      }
#line 558
      srcx += scalex;
#line 541
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 561
    srcy += scaley;
#line 538
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 565
  XFreeGC(display, maskGC);
#line 568
  np->image = XCreatePixmap(display, rootWindow, (unsigned int )nwidth, (unsigned int )nheight,
                            (unsigned int )rootDepth);
#line 571
  XPutImage(display, np->image, rootGC, image, 0, 0, 0, 0, (unsigned int )nwidth,
            (unsigned int )nheight);
#line 573
  free((void *)image->data);
#line 574
  image->data = (char *)((void *)0);
#line 575
  (*(image->f.destroy_image))(image);
  }
#line 577
  return (np);
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static IconNode *CreateIconFromBinary(unsigned long const   *input , unsigned int length ) 
{ 
  unsigned long height ;
  unsigned long width ;
  IconNode *result ;
  unsigned char *data ;
  unsigned int x ;
  unsigned int index ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 590
  if (! input) {
#line 591
    return ((IconNode *)((void *)0));
  }
  {
#line 594
  width = (unsigned long )*(input + 0);
#line 595
  height = (unsigned long )*(input + 1);
#line 597
  tmp___1 = __builtin_expect((long )(! (! (width * height + 2UL > (unsigned long )length))),
                             0L);
  }
#line 597
  if (tmp___1) {
    {
#line 598
    Debug("invalid image size: %d x %d + 2 > %d", width, height, length);
    }
#line 599
    return ((IconNode *)((void *)0));
  } else {
#line 600
    if (width == 0UL) {
#line 600
      tmp = 1;
    } else
#line 600
    if (height == 0UL) {
#line 600
      tmp = 1;
    } else {
#line 600
      tmp = 0;
    }
    {
#line 600
    tmp___0 = __builtin_expect((long )tmp, 0L);
    }
#line 600
    if (tmp___0) {
      {
#line 601
      Debug("invalid image size: %d x %d", width, height);
      }
#line 602
      return ((IconNode *)((void *)0));
    }
  }
  {
#line 605
  result = CreateIcon();
#line 607
  tmp___2 = malloc(sizeof(ImageNode ));
#line 607
  result->image = (struct ImageNode *)tmp___2;
#line 608
  (result->image)->width = (int )width;
#line 609
  (result->image)->height = (int )height;
#line 611
  tmp___3 = malloc((4UL * width) * height);
#line 611
  (result->image)->data = (unsigned char *)tmp___3;
#line 612
  data = (result->image)->data;
#line 615
  index = 0U;
#line 616
  x = 0U;
  }
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 616
    if (! ((unsigned long )x < width * height)) {
#line 616
      goto while_break;
    }
#line 617
    tmp___4 = index;
#line 617
    index ++;
#line 617
    *(data + tmp___4) = (unsigned char )(*(input + (x + 2U)) >> 24);
#line 618
    tmp___5 = index;
#line 618
    index ++;
#line 618
    *(data + tmp___5) = (unsigned char )((*(input + (x + 2U)) >> 16) & 255UL);
#line 619
    tmp___6 = index;
#line 619
    index ++;
#line 619
    *(data + tmp___6) = (unsigned char )((*(input + (x + 2U)) >> 8) & 255UL);
#line 620
    tmp___7 = index;
#line 620
    index ++;
#line 620
    *(data + tmp___7) = (unsigned char )(*(input + (x + 2U)) & 255UL);
#line 616
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 625
  return (result);
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
IconNode *CreateIcon(void) 
{ 
  IconNode *icon ;
  void *tmp ;

  {
  {
#line 634
  tmp = malloc(sizeof(IconNode ));
#line 634
  icon = (IconNode *)tmp;
#line 635
  icon->name = (char *)((void *)0);
#line 636
  icon->image = (struct ImageNode *)((void *)0);
#line 637
  icon->nodes = (struct ScaledIconNode *)((void *)0);
#line 638
  icon->useRender = 1;
#line 639
  icon->next = (struct IconNode *)((void *)0);
#line 640
  icon->prev = (struct IconNode *)((void *)0);
  }
#line 642
  return (icon);
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static void DoDestroyIcon(int index , IconNode *icon ) 
{ 
  ScaledIconNode *np ;

  {
#line 651
  if (icon) {
    {
#line 652
    while (1) {
      while_continue: /* CIL Label */ ;
#line 652
      if (! icon->nodes) {
#line 652
        goto while_break;
      }
#line 653
      np = (icon->nodes)->next;
#line 661
      if ((icon->nodes)->image != 0UL) {
        {
#line 662
        XFreePixmap(display, (icon->nodes)->image);
        }
      }
#line 664
      if ((icon->nodes)->mask != 0UL) {
        {
#line 665
        XFreePixmap(display, (icon->nodes)->mask);
        }
      }
      {
#line 668
      free((void *)icon->nodes);
#line 669
      icon->nodes = np;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 672
    if (icon->name) {
      {
#line 673
      free((void *)icon->name);
      }
    }
    {
#line 675
    DestroyImage(icon->image);
    }
#line 677
    if (icon->prev) {
#line 678
      (icon->prev)->next = icon->next;
    } else {
#line 680
      *(iconHash + index) = icon->next;
    }
#line 682
    if (icon->next) {
#line 683
      (icon->next)->prev = icon->prev;
    }
    {
#line 685
    free((void *)icon);
    }
  }
#line 687
  return;
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
void DestroyIcon(IconNode *icon ) 
{ 
  int index ;

  {
#line 694
  if (icon) {
#line 694
    if (! icon->name) {
      {
#line 695
      index = GetHash((char const   *)icon->name);
#line 696
      DoDestroyIcon(index, icon);
      }
    }
  }
#line 699
  return;
}
}
#line 702 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static void InsertIcon(IconNode *icon ) 
{ 
  int index ;

  {
  {
#line 709
  index = GetHash((char const   *)icon->name);
#line 711
  icon->prev = (struct IconNode *)((void *)0);
  }
#line 712
  if (*(iconHash + index)) {
#line 713
    (*(iconHash + index))->prev = icon;
  }
#line 715
  icon->next = *(iconHash + index);
#line 716
  *(iconHash + index) = icon;
#line 718
  return;
}
}
#line 721 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static IconNode *FindIcon(char const   *name ) 
{ 
  IconNode *icon ;
  int index ;
  int tmp ;

  {
  {
#line 726
  index = GetHash(name);
#line 728
  icon = *(iconHash + index);
  }
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 729
    if (! icon) {
#line 729
      goto while_break;
    }
    {
#line 730
    tmp = strcmp((char const   *)icon->name, name);
    }
#line 730
    if (! tmp) {
#line 731
      return (icon);
    }
#line 733
    icon = icon->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 736
  return ((IconNode *)((void *)0));
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/icon.c"
static int GetHash(char const   *str___0 ) 
{ 
  int x ;
  unsigned int hash ;

  {
#line 744
  hash = 0U;
#line 746
  if (str___0) {
#line 747
    x = 0;
    {
#line 747
    while (1) {
      while_continue: /* CIL Label */ ;
#line 747
      if (! *(str___0 + x)) {
#line 747
        goto while_break;
      }
#line 748
      hash = (hash + (hash << 5)) ^ (unsigned int )*(str___0 + x);
#line 747
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 750
    hash &= 127U;
  }
#line 753
  return ((int )hash);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/image.c"
ImageNode *LoadImage(char const   *fileName ) 
{ 


  {
#line 52
  if (! fileName) {
#line 53
    return ((ImageNode *)((void *)0));
  }
#line 80
  return ((ImageNode *)((void *)0));
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/image.c"
ImageNode *LoadImageFromData(char **data ) 
{ 
  ImageNode *result ;

  {
#line 87
  result = (ImageNode *)((void *)0);
#line 113
  return (result);
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/image.c"
void DestroyImage(ImageNode *image ) 
{ 


  {
#line 434
  if (image) {
    {
#line 435
    free((void *)image->data);
#line 436
    free((void *)image);
    }
  }
#line 438
  return;
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 293
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) tzset)(void) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/timing.c"
static unsigned long const   MAX_TIME_SECONDS  =    (unsigned long const   )60;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/timing.c"
void GetCurrentTime(TimeType *t ) 
{ 
  struct timeval val ;

  {
  {
#line 18
  gettimeofday((struct timeval */* __restrict  */)(& val), (__timezone_ptr_t )((void *)0));
#line 19
  t->seconds = (unsigned long )val.tv_sec;
#line 20
  t->ms = (int )(val.tv_usec / 1000L);
  }
#line 21
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/timing.c"
unsigned long GetTimeDifference(TimeType const   *t1 , TimeType const   *t2 ) 
{ 
  unsigned long deltaSeconds ;
  int deltaMs ;

  {
#line 32
  if (t1->seconds > t2->seconds) {
#line 33
    deltaSeconds = (unsigned long )(t1->seconds - t2->seconds);
#line 34
    deltaMs = (int )(t1->ms - t2->ms);
  } else
#line 35
  if (t1->seconds < t2->seconds) {
#line 36
    deltaSeconds = (unsigned long )(t2->seconds - t1->seconds);
#line 37
    deltaMs = (int )(t2->ms - t1->ms);
  } else
#line 38
  if (t1->ms > t2->ms) {
#line 39
    deltaSeconds = 0UL;
#line 40
    deltaMs = (int )(t1->ms - t2->ms);
  } else {
#line 42
    deltaSeconds = 0UL;
#line 43
    deltaMs = (int )(t2->ms - t1->ms);
  }
#line 46
  if (deltaSeconds > (unsigned long )MAX_TIME_SECONDS) {
#line 47
    return ((unsigned long )(MAX_TIME_SECONDS * 1000UL));
  } else {
#line 49
    return (deltaSeconds * 1000UL + (unsigned long )deltaMs);
  }
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/timing.c"
static char saveTZ[256]  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/timing.c"
static char newTZ[256]  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/timing.c"
static char str[80]  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/timing.c"
char const   *GetTimeString(char const   *format , char const   *zone ) 
{ 
  time_t t ;
  char const   *oldTZ ;
  char *tmp ;
  struct tm *tmp___0 ;
  struct tm *tmp___1 ;

  {
  {
#line 64
  time(& t);
  }
#line 66
  if (zone) {
    {
#line 67
    tmp = getenv("TZ");
#line 67
    oldTZ = (char const   *)tmp;
    }
#line 68
    if (oldTZ) {
      {
#line 69
      snprintf((char */* __restrict  */)(saveTZ), sizeof(saveTZ), (char const   */* __restrict  */)"TZ=%s",
               oldTZ);
      }
    }
    {
#line 75
    snprintf((char */* __restrict  */)(newTZ), sizeof(newTZ), (char const   */* __restrict  */)"TZ=%s",
             zone);
#line 76
    putenv(newTZ);
#line 77
    tzset();
#line 78
    tmp___0 = localtime((time_t const   *)(& t));
#line 78
    strftime((char */* __restrict  */)(str), sizeof(str), (char const   */* __restrict  */)format,
             (struct tm  const  */* __restrict  */)tmp___0);
    }
#line 80
    if (oldTZ) {
      {
#line 81
      putenv(saveTZ);
      }
    } else {
      {
#line 83
      unsetenv("TZ");
      }
    }
  } else {
    {
#line 89
    tmp___1 = localtime((time_t const   *)(& t));
#line 89
    strftime((char */* __restrict  */)(str), sizeof(str), (char const   */* __restrict  */)format,
             (struct tm  const  */* __restrict  */)tmp___1);
    }
  }
#line 92
  return ((char const   *)(str));
}
}
#line 1616 "/usr/include/X11/Xlib.h"
extern Pixmap XCreateBitmapFromData(Display * , Drawable  , char const   * , unsigned int  ,
                                    unsigned int  ) ;
#line 2326
extern int XDrawArcs(Display * , Drawable  , GC  , XArc * , int  ) ;
#line 2390
extern int XDrawRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2408
extern int XDrawSegments(Display * , Drawable  , GC  , XSegment * , int  ) ;
#line 2483
extern int XFillArcs(Display * , Drawable  , GC  , XArc * , int  ) ;
#line 2511
extern int XFillRectangles(Display * , Drawable  , GC  , XRectangle * , int  ) ;
#line 3043
extern int XReadBitmapFile(Display * , Drawable  , char const   * , unsigned int * ,
                           unsigned int * , Pixmap * , int * , int * ) ;
#line 3345
extern int XSetWindowBackground(Display * , Window  , unsigned long  ) ;
#line 391 "/usr/include/X11/Xutil.h"
extern Region XCreateRegion(void) ;
#line 403
extern int XDestroyRegion(Region  ) ;
#line 568
extern int XRectInRegion(Region  , int  , int  , unsigned int  , unsigned int  ) ;
#line 708
extern int XSetRegion(Display * , GC  , Region  ) ;
#line 800
extern int XUnionRectWithRegion(XRectangle * , Region  , Region  ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.h"
void InitializeBorders(void) ;
#line 43
void StartupBorders(void) ;
#line 44
void ShutdownBorders(void) ;
#line 45
void DestroyBorders(void) ;
#line 65
int GetBorderIconSize(void) ;
#line 88
void ExposeCurrentDesktop(void) ;
#line 109
void DrawRoundedRectangle(Drawable d , GC gc , int x , int y , int width , int height ,
                          int radius ) ;
#line 113
void FillRoundedRectangle(Drawable d , GC gc , int x , int y , int width , int height ,
                          int radius ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
static BorderPixmapDataType bitmaps[4]  = { {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)48,        (unsigned char)6,        (unsigned char)112,        (unsigned char)7, 
            (unsigned char)224,        (unsigned char)3,        (unsigned char)192,        (unsigned char)1, 
            (unsigned char)224,        (unsigned char)3,        (unsigned char)112,        (unsigned char)7, 
            (unsigned char)48,        (unsigned char)6,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)248,        (unsigned char)7,        (unsigned char)248,        (unsigned char)7, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)248,        (unsigned char)31, 
            (unsigned char)248,        (unsigned char)31,        (unsigned char)8,        (unsigned char)16, 
            (unsigned char)8,        (unsigned char)16,        (unsigned char)8,        (unsigned char)16, 
            (unsigned char)8,        (unsigned char)16,        (unsigned char)8,        (unsigned char)16, 
            (unsigned char)248,        (unsigned char)31,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)192,        (unsigned char)15, 
            (unsigned char)192,        (unsigned char)15,        (unsigned char)0,        (unsigned char)8, 
            (unsigned char)240,        (unsigned char)11,        (unsigned char)240,        (unsigned char)11, 
            (unsigned char)16,        (unsigned char)10,        (unsigned char)16,        (unsigned char)10, 
            (unsigned char)16,        (unsigned char)2,        (unsigned char)240,        (unsigned char)3, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}};
#line 44 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
static Pixmap pixmaps[4]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
static char *bmpFiles[4]  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
static Region borderRegion  =    (Region )((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
static GC borderGC  ;
#line 57
static void DrawBorderHelper(ClientNode const   *np , int drawIcon ) ;
#line 58
static void DrawBorderButtons(ClientNode const   *np , Pixmap canvas , GC gc ) ;
#line 59
static int GetButtonCount(ClientNode const   *np ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void InitializeBorders(void) 
{ 


  {
  {
#line 63
  memset((void *)(bmpFiles), 0, sizeof(bmpFiles));
  }
#line 64
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void StartupBorders(void) 
{ 
  XGCValues gcValues ;
  unsigned long gcMask ;
  int x ;
  int hotx ;
  int hoty ;
  unsigned int bmpHeight ;
  unsigned int bmpWidth ;
  int found ;
  int tmp ;
  char *tmp___0 ;
  long tmp___1 ;

  {
#line 75
  x = 0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (x < 4)) {
#line 75
      goto while_break;
    }
#line 76
    if (bmpFiles[x]) {
#line 76
      found = 1;
    } else {
#line 76
      found = 0;
    }
#line 77
    if (found) {
      {
#line 78
      tmp = XReadBitmapFile(display, rootWindow, (char const   *)bmpFiles[x], & bmpWidth,
                            & bmpHeight, & pixmaps[x], & hotx, & hoty);
#line 78
      found = tmp == 0;
#line 81
      tmp___1 = __builtin_expect((long )(! (! (! found))), 0L);
      }
#line 81
      if (tmp___1) {
        {
#line 82
        tmp___0 = gettext("bitmap could not be loaded: %s");
#line 82
        Warning((char const   *)tmp___0, bmpFiles[x]);
        }
      }
    }
#line 85
    if (! found) {
      {
#line 86
      pixmaps[x] = XCreateBitmapFromData(display, rootWindow, (char const   *)((char *)(bitmaps[x])),
                                         16U, 16U);
      }
    }
#line 75
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  gcMask = (unsigned long )(1L << 16);
#line 92
  gcValues.graphics_exposures = 0;
#line 93
  borderGC = XCreateGC(display, rootWindow, gcMask, & gcValues);
  }
#line 102
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void ShutdownBorders(void) 
{ 
  int x ;

  {
  {
#line 109
  XFreeGC(display, borderGC);
#line 111
  x = 0;
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (x < 4)) {
#line 111
      goto while_break;
    }
    {
#line 112
    XFreePixmap(display, pixmaps[x]);
#line 111
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void DestroyBorders(void) 
{ 
  int x ;

  {
#line 133
  x = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (x < 4)) {
#line 133
      goto while_break;
    }
#line 134
    if (bmpFiles[x]) {
      {
#line 135
      free((void *)bmpFiles[x]);
#line 136
      bmpFiles[x] = (char *)((void *)0);
      }
    }
#line 133
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
int GetBorderIconSize(void) 
{ 


  {
#line 143
  return (titleHeight - 6);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
BorderActionType GetBorderActionType(struct ClientNode  const  *np , int x , int y ) 
{ 
  int north ;
  int south ;
  int east ;
  int west ;
  int offset ;

  {
  {
#line 154
  GetBorderSize(np, & north, & south, & east, & west);
  }
#line 157
  if (np->state.border & 2U) {
#line 160
    if (y >= south) {
#line 160
      if (y <= titleHeight) {
#line 163
        if (np->icon) {
#line 163
          if (np->width >= (int const   )titleHeight) {
#line 164
            if (x > 0) {
#line 164
              if (x <= titleHeight) {
#line 165
                return ((BorderActionType )6);
              }
            }
          }
        }
#line 170
        offset = (int )(((np->width + (int const   )west) + (int const   )east) - (int const   )titleHeight);
#line 171
        if (np->state.border & 16U) {
#line 171
          if (offset > titleHeight) {
#line 172
            if (x > offset) {
#line 172
              if (x < offset + titleHeight) {
#line 173
                return ((BorderActionType )3);
              }
            }
#line 175
            offset -= titleHeight;
          }
        }
#line 179
        if (np->state.border & 8U) {
#line 179
          if (offset > titleHeight) {
#line 180
            if (x > offset) {
#line 180
              if (x < offset + titleHeight) {
#line 181
                return ((BorderActionType )4);
              }
            }
#line 183
            offset -= titleHeight;
          }
        }
#line 187
        if (np->state.border & 4U) {
#line 187
          if (offset > titleHeight) {
#line 188
            if (x > offset) {
#line 188
              if (x < offset + titleHeight) {
#line 189
                return ((BorderActionType )5);
              }
            }
          }
        }
      }
    }
#line 196
    if (y >= south) {
#line 196
      if (y <= titleHeight) {
#line 197
        if (x > 0) {
#line 197
          if (x < (int )((np->width + (int const   )east) + (int const   )west)) {
#line 198
            if (np->state.border & 64U) {
#line 199
              return ((BorderActionType )2);
            } else {
#line 201
              return ((BorderActionType )0);
            }
          }
        }
      }
    }
  }
#line 210
  if (! (np->state.border & 32U)) {
#line 211
    return ((BorderActionType )0);
  }
#line 215
  if (np->width >= (int const   )(titleHeight * 2)) {
#line 215
    if (np->height >= (int const   )(titleHeight * 2)) {
#line 216
      if (y > (int )((np->height + (int const   )north) - (int const   )titleHeight)) {
#line 217
        if (x < titleHeight) {
#line 218
          return ((BorderActionType )161);
        } else
#line 219
        if (x > (int )((np->width + (int const   )west) - (int const   )titleHeight)) {
#line 220
          return ((BorderActionType )97);
        }
      } else
#line 222
      if (y < titleHeight) {
#line 223
        if (x < titleHeight) {
#line 224
          return ((BorderActionType )145);
        } else
#line 225
        if (x > (int )((np->width + (int const   )west) - (int const   )titleHeight)) {
#line 226
          return ((BorderActionType )81);
        }
      }
    }
  }
#line 232
  if (x <= west) {
#line 233
    return ((BorderActionType )129);
  } else
#line 234
  if (x >= (int )(np->width + (int const   )west)) {
#line 235
    return ((BorderActionType )65);
  } else
#line 236
  if (y >= (int )(np->height + (int const   )north)) {
#line 237
    return ((BorderActionType )33);
  } else
#line 238
  if (y <= south) {
#line 239
    return ((BorderActionType )17);
  } else {
#line 241
    return ((BorderActionType )0);
  }
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void DrawBorder(struct ClientNode  const  *np , XExposeEvent const   *expose ) 
{ 
  XRectangle rect ;
  int drawIcon ;
  int temp ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 256
  tmp = __builtin_expect((long )(! (! shouldExit)), 0L);
  }
#line 256
  if (tmp) {
#line 257
    return;
  }
#line 261
  if (! (np->state.status & 258U)) {
#line 262
    return;
  }
#line 266
  if (np->state.status & 8208U) {
#line 267
    return;
  }
#line 271
  if (! (np->state.border & 3U)) {
#line 272
    return;
  }
#line 275
  if (expose) {
#line 282
    if (! borderRegion) {
      {
#line 283
      borderRegion = XCreateRegion();
      }
    }
    {
#line 287
    rect.x = (short )expose->x;
#line 288
    rect.y = (short )expose->y;
#line 289
    rect.width = (unsigned short )expose->width;
#line 290
    rect.height = (unsigned short )expose->height;
#line 291
    XUnionRectWithRegion(& rect, borderRegion, borderRegion);
    }
#line 294
    if (expose->count) {
#line 295
      return;
    }
#line 305
    drawIcon = 0;
#line 306
    if (np->icon) {
#line 306
      if (np->state.border & 2U) {
        {
#line 307
        temp = GetBorderIconSize();
#line 308
        rect.x = (short)6;
#line 309
        rect.y = (short )((titleHeight - temp) / 2);
#line 310
        rect.width = (unsigned short )temp;
#line 311
        rect.height = (unsigned short )temp;
#line 312
        tmp___0 = XRectInRegion(borderRegion, (int )rect.x, (int )rect.y, (unsigned int )rect.width,
                                (unsigned int )rect.height);
        }
#line 312
        if (tmp___0 != 0) {
          {
#line 315
          drawIcon = 1;
#line 316
          XUnionRectWithRegion(& rect, borderRegion, borderRegion);
          }
        }
      }
    }
    {
#line 322
    XSetRegion(display, borderGC, borderRegion);
    }
  } else {
    {
#line 327
    drawIcon = 1;
#line 328
    XSetClipMask(display, borderGC, (Pixmap )0L);
    }
  }
  {
#line 333
  DrawBorderHelper(np, drawIcon);
  }
#line 336
  if (expose) {
    {
#line 337
    XDestroyRegion(borderRegion);
#line 338
    borderRegion = (Region )((void *)0);
    }
  }
#line 341
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
static void DrawBorderHelper(ClientNode const   *np , int drawIcon ) 
{ 
  ColorType borderTextColor ;
  long titleColor1 ;
  long titleColor2 ;
  long outlineColor ;
  int north ;
  int south ;
  int east ;
  int west ;
  unsigned int width ;
  unsigned int height ;
  int iconSize___0 ;
  int buttonCount ;
  int titleWidth ;
  Pixmap canvas ;
  GC gc ;
  int tmp ;

  {
  {
#line 361
  iconSize___0 = GetBorderIconSize();
#line 362
  GetBorderSize(np, & north, & south, & east, & west);
#line 363
  width = (unsigned int )((np->width + (int const   )east) + (int const   )west);
#line 364
  height = (unsigned int )((np->height + (int const   )north) + (int const   )south);
  }
#line 367
  if (np->state.status & 1U) {
#line 369
    borderTextColor = (ColorType )1;
#line 370
    titleColor1 = (long )colors[4];
#line 371
    titleColor2 = (long )colors[5];
#line 372
    outlineColor = (long )colors[7];
  } else {
#line 376
    borderTextColor = (ColorType )0;
#line 377
    titleColor1 = (long )colors[2];
#line 378
    titleColor2 = (long )colors[3];
#line 379
    outlineColor = (long )colors[6];
  }
#line 383
  canvas = (Pixmap )np->parent;
#line 384
  gc = borderGC;
#line 387
  if (np->state.status & 256U) {
    {
#line 388
    ShapeRoundedRectWindow((Window )np->parent, (int )width, north);
    }
  } else {
    {
#line 390
    ShapeRoundedRectWindow((Window )np->parent, (int )width, (int )height);
    }
  }
  {
#line 394
  XSetWindowBackground(display, canvas, (unsigned long )titleColor2);
#line 397
  XSetForeground(display, gc, (unsigned long )titleColor2);
#line 398
  XFillRectangle(display, canvas, gc, 0, 0, width, height);
#line 401
  buttonCount = GetButtonCount(np);
#line 402
  titleWidth = (int )width;
#line 403
  titleWidth -= titleHeight * buttonCount;
#line 404
  titleWidth -= (iconSize___0 + 7) + 6;
  }
#line 407
  if (np->state.border & 2U) {
    {
#line 410
    DrawHorizontalGradient(canvas, gc, titleColor1, titleColor2, 1, 1, width - 2U,
                           (unsigned int )(titleHeight - 2));
    }
#line 414
    if (np->icon) {
#line 414
      if (np->width >= (int const   )titleHeight) {
#line 414
        if (drawIcon) {
          {
#line 415
          PutIcon((IconNode *)np->icon, canvas, 6, (titleHeight - iconSize___0) / 2,
                  iconSize___0, iconSize___0);
          }
        }
      }
    }
#line 419
    if (np->name) {
#line 419
      if (*(np->name + 0)) {
#line 419
        if (titleWidth > 0) {
          {
#line 420
          tmp = GetStringHeight((FontType )0);
#line 420
          RenderString(canvas, (FontType )0, borderTextColor, (iconSize___0 + 6) + 4,
                       (titleHeight - tmp) / 2, titleWidth, borderRegion, (char const   *)np->name);
          }
        }
      }
    }
  }
  {
#line 429
  XSetForeground(display, gc, (unsigned long )outlineColor);
  }
#line 440
  if (np->state.status & 256U) {
    {
#line 441
    XDrawRectangle(display, canvas, gc, 0, 0, width - 1U, (unsigned int )(north - 1));
    }
  } else {
    {
#line 443
    XDrawRectangle(display, canvas, gc, 0, 0, width - 1U, height - 1U);
    }
  }
  {
#line 447
  DrawBorderButtons(np, canvas, gc);
  }
#line 449
  return;
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
static int GetButtonCount(ClientNode const   *np ) 
{ 
  int north ;
  int south ;
  int east ;
  int west ;
  int count ;
  int offset ;

  {
#line 458
  if (! (np->state.border & 2U)) {
#line 459
    return (0);
  }
  {
#line 462
  GetBorderSize(np, & north, & south, & east, & west);
#line 464
  offset = (int )(((np->width + (int const   )east) + (int const   )west) - (int const   )titleHeight);
  }
#line 465
  if (offset <= titleHeight) {
#line 466
    return (0);
  }
#line 469
  count = 0;
#line 470
  if (np->state.border & 16U) {
#line 471
    offset -= titleHeight;
#line 472
    count ++;
#line 473
    if (offset <= titleHeight) {
#line 474
      return (count);
    }
  }
#line 478
  if (np->state.border & 8U) {
#line 479
    offset -= titleHeight;
#line 480
    count ++;
#line 481
    if (offset <= titleHeight) {
#line 482
      return (count);
    }
  }
#line 486
  if (np->state.border & 4U) {
#line 487
    count ++;
  }
#line 490
  return (count);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
static void DrawBorderButtons(ClientNode const   *np , Pixmap canvas , GC gc ) 
{ 
  Pixmap pixmap ;
  long color ;
  int offset ;
  int yoffset ;
  int north ;
  int south ;
  int east ;
  int west ;

  {
#line 505
  if (! (np->state.border & 2U)) {
#line 506
    return;
  }
  {
#line 509
  GetBorderSize(np, & north, & south, & east, & west);
#line 510
  offset = (int )(((np->width + (int const   )east) + (int const   )west) - (int const   )titleHeight);
  }
#line 511
  if (offset <= titleHeight) {
#line 512
    return;
  }
#line 515
  yoffset = titleHeight / 2 - 8;
#line 518
  if (np->state.status & 1U) {
#line 519
    color = (long )colors[1];
  } else {
#line 521
    color = (long )colors[0];
  }
#line 525
  if (np->state.border & 16U) {
    {
#line 527
    pixmap = pixmaps[0];
#line 529
    XSetForeground(display, gc, (unsigned long )color);
#line 530
    XSetClipMask(display, gc, pixmap);
#line 531
    XSetClipOrigin(display, gc, offset + yoffset, yoffset);
#line 532
    XFillRectangle(display, canvas, gc, offset + yoffset, yoffset, 16U, 16U);
#line 533
    XSetClipMask(display, gc, (Pixmap )0L);
#line 535
    offset -= titleHeight;
    }
#line 536
    if (offset <= titleHeight) {
#line 537
      return;
    }
  }
#line 543
  if (np->state.border & 8U) {
#line 545
    if (np->state.status & 12U) {
#line 546
      pixmap = pixmaps[3];
    } else {
#line 548
      pixmap = pixmaps[2];
    }
    {
#line 551
    XSetForeground(display, gc, (unsigned long )color);
#line 552
    XSetClipMask(display, gc, pixmap);
#line 553
    XSetClipOrigin(display, gc, offset + yoffset, yoffset);
#line 554
    XFillRectangle(display, canvas, gc, offset + yoffset, yoffset, 16U, 16U);
#line 555
    XSetClipMask(display, gc, (Pixmap )0L);
#line 557
    offset -= titleHeight;
    }
#line 558
    if (offset <= titleHeight) {
#line 559
      return;
    }
  }
#line 565
  if (np->state.border & 4U) {
    {
#line 567
    pixmap = pixmaps[1];
#line 569
    XSetForeground(display, gc, (unsigned long )color);
#line 570
    XSetClipMask(display, gc, pixmap);
#line 571
    XSetClipOrigin(display, gc, offset + yoffset, yoffset);
#line 572
    XFillRectangle(display, canvas, gc, offset + yoffset, yoffset, 16U, 16U);
#line 573
    XSetClipMask(display, gc, (Pixmap )0L);
    }
  }
#line 577
  return;
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void ExposeCurrentDesktop(void) 
{ 
  ClientNode *np ;
  int layer ;

  {
#line 589
  layer = 0;
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    if (! (layer < 13)) {
#line 589
      goto while_break;
    }
#line 590
    np = nodes[layer];
    {
#line 590
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 590
      if (! np) {
#line 590
        goto while_break___0;
      }
#line 591
      if (! (np->state.status & 144U)) {
        {
#line 592
        DrawBorder((struct ClientNode  const  *)np, (XExposeEvent const   *)((void *)0));
        }
      }
#line 590
      np = np->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 589
    layer ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 597
  return;
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void GetBorderSize(struct ClientNode  const  *np , int *north , int *south , int *east ,
                   int *west ) 
{ 


  {
#line 610
  if (np->state.status & 8192U) {
#line 611
    *north = 0;
#line 612
    *south = 0;
#line 613
    *east = 0;
#line 614
    *west = 0;
#line 615
    return;
  }
#line 618
  if (np->state.border & 1U) {
#line 620
    *north = borderWidth;
#line 621
    *south = borderWidth;
#line 622
    *east = borderWidth;
#line 623
    *west = borderWidth;
  } else {
#line 627
    *north = 0;
#line 628
    *south = 0;
#line 629
    *east = 0;
#line 630
    *west = 0;
  }
#line 634
  if (np->state.border & 2U) {
#line 635
    *north = titleHeight;
  }
#line 638
  if (np->state.status & 256U) {
#line 639
    *south = 0;
  }
#line 642
  return;
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void SetBorderWidth(char const   *str___0 ) 
{ 
  int width ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 649
  tmp___2 = __builtin_expect((long )(! (! str___0)), 1L);
  }
#line 649
  if (tmp___2) {
    {
#line 651
    width = atoi(str___0);
    }
#line 652
    if (width < 1) {
#line 652
      tmp___0 = 1;
    } else
#line 652
    if (width > 32) {
#line 652
      tmp___0 = 1;
    } else {
#line 652
      tmp___0 = 0;
    }
    {
#line 652
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 652
    if (tmp___1) {
      {
#line 653
      borderWidth = 4;
#line 654
      tmp = gettext("invalid border width specified: %d");
#line 654
      Warning((char const   *)tmp, width);
      }
    } else {
#line 656
      borderWidth = width;
    }
  }
#line 661
  return;
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void SetTitleHeight(char const   *str___0 ) 
{ 
  int height ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 668
  tmp___2 = __builtin_expect((long )(! (! str___0)), 1L);
  }
#line 668
  if (tmp___2) {
    {
#line 670
    height = atoi(str___0);
    }
#line 671
    if (height < 2) {
#line 671
      tmp___0 = 1;
    } else
#line 671
    if (height > 64) {
#line 671
      tmp___0 = 1;
    } else {
#line 671
      tmp___0 = 0;
    }
    {
#line 671
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 671
    if (tmp___1) {
      {
#line 672
      titleHeight = 20;
#line 673
      tmp = gettext("invalid title height specified: %d");
#line 673
      Warning((char const   *)tmp, height);
      }
    } else {
#line 675
      titleHeight = height;
    }
  }
#line 680
  return;
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void SetButtonMask(BorderPixmapType pt , char const   *filename ) 
{ 
  long tmp ;

  {
#line 685
  if (bmpFiles[pt]) {
    {
#line 686
    free((void *)bmpFiles[pt]);
#line 687
    bmpFiles[pt] = (char *)((void *)0);
    }
  }
  {
#line 690
  tmp = __builtin_expect((long )(! (! filename)), 1L);
  }
#line 690
  if (tmp) {
    {
#line 691
    bmpFiles[pt] = CopyString(filename);
#line 692
    ExpandPath(& bmpFiles[pt]);
    }
  }
#line 695
  return;
}
}
#line 698 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void DrawRoundedRectangle(Drawable d , GC gc , int x , int y , int width , int height ,
                          int radius ) 
{ 
  XSegment segments[4] ;
  XArc arcs[4] ;

  {
  {
#line 711
  segments[0].x1 = (short )(x + radius);
#line 711
  segments[0].y1 = (short )y;
#line 712
  segments[0].x2 = (short )((x + width) - radius);
#line 712
  segments[0].y2 = (short )y;
#line 713
  segments[1].x1 = (short )(x + radius);
#line 713
  segments[1].y1 = (short )(y + height);
#line 714
  segments[1].x2 = (short )((x + width) - radius);
#line 714
  segments[1].y2 = (short )(y + height);
#line 715
  segments[2].x1 = (short )x;
#line 715
  segments[2].y1 = (short )(y + radius);
#line 716
  segments[2].x2 = (short )x;
#line 716
  segments[2].y2 = (short )((y + height) - radius);
#line 717
  segments[3].x1 = (short )(x + width);
#line 717
  segments[3].y1 = (short )(y + radius);
#line 718
  segments[3].x2 = (short )(x + width);
#line 718
  segments[3].y2 = (short )((y + height) - radius);
#line 719
  XDrawSegments(display, d, gc, segments, 4);
#line 721
  arcs[0].x = (short )x;
#line 722
  arcs[0].y = (short )y;
#line 723
  arcs[0].width = (unsigned short )(radius * 2);
#line 724
  arcs[0].height = (unsigned short )(radius * 2);
#line 725
  arcs[0].angle1 = (short)5760;
#line 726
  arcs[0].angle2 = (short)5760;
#line 727
  arcs[1].x = (short )((x + width) - radius * 2);
#line 728
  arcs[1].y = (short )y;
#line 729
  arcs[1].width = (unsigned short )(radius * 2);
#line 730
  arcs[1].height = (unsigned short )(radius * 2);
#line 731
  arcs[1].angle1 = (short)0;
#line 732
  arcs[1].angle2 = (short)5760;
#line 733
  arcs[2].x = (short )x;
#line 734
  arcs[2].y = (short )((y + height) - radius * 2);
#line 735
  arcs[2].width = (unsigned short )(radius * 2);
#line 736
  arcs[2].height = (unsigned short )(radius * 2);
#line 737
  arcs[2].angle1 = (short)11520;
#line 738
  arcs[2].angle2 = (short)5760;
#line 739
  arcs[3].x = (short )((x + width) - radius * 2);
#line 740
  arcs[3].y = (short )((y + height) - radius * 2);
#line 741
  arcs[3].width = (unsigned short )(radius * 2);
#line 742
  arcs[3].height = (unsigned short )(radius * 2);
#line 743
  arcs[3].angle1 = (short)17280;
#line 744
  arcs[3].angle2 = (short)5760;
#line 745
  XDrawArcs(display, d, gc, arcs, 4);
  }
#line 749
  return;
}
}
#line 752 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void FillRoundedRectangle(Drawable d , GC gc , int x , int y , int width , int height ,
                          int radius ) 
{ 
  XRectangle rects[3] ;
  XArc arcs[4] ;

  {
  {
#line 765
  rects[0].x = (short )(x + radius);
#line 766
  rects[0].y = (short )y;
#line 767
  rects[0].width = (unsigned short )(width - radius * 2);
#line 768
  rects[0].height = (unsigned short )radius;
#line 769
  rects[1].x = (short )x;
#line 770
  rects[1].y = (short )radius;
#line 771
  rects[1].width = (unsigned short )width;
#line 772
  rects[1].height = (unsigned short )(height - radius * 2);
#line 773
  rects[2].x = (short )(x + radius);
#line 774
  rects[2].y = (short )((y + height) - radius);
#line 775
  rects[2].width = (unsigned short )(width - radius * 2);
#line 776
  rects[2].height = (unsigned short )radius;
#line 777
  XFillRectangles(display, d, gc, rects, 3);
#line 779
  arcs[0].x = (short )x;
#line 780
  arcs[0].y = (short )y;
#line 781
  arcs[0].width = (unsigned short )(radius * 2);
#line 782
  arcs[0].height = (unsigned short )(radius * 2);
#line 783
  arcs[0].angle1 = (short)5760;
#line 784
  arcs[0].angle2 = (short)5760;
#line 785
  arcs[1].x = (short )(((x + width) - radius * 2) - 1);
#line 786
  arcs[1].y = (short )y;
#line 787
  arcs[1].width = (unsigned short )(radius * 2);
#line 788
  arcs[1].height = (unsigned short )(radius * 2);
#line 789
  arcs[1].angle1 = (short)0;
#line 790
  arcs[1].angle2 = (short)5760;
#line 791
  arcs[2].x = (short )x;
#line 792
  arcs[2].y = (short )(((y + height) - radius * 2) - 1);
#line 793
  arcs[2].width = (unsigned short )(radius * 2);
#line 794
  arcs[2].height = (unsigned short )(radius * 2);
#line 795
  arcs[2].angle1 = (short)11520;
#line 796
  arcs[2].angle2 = (short)5760;
#line 797
  arcs[3].x = (short )(((x + width) - radius * 2) - 1);
#line 798
  arcs[3].y = (short )(((y + height) - radius * 2) - 1);
#line 799
  arcs[3].width = (unsigned short )(radius * 2);
#line 800
  arcs[3].height = (unsigned short )(radius * 2);
#line 801
  arcs[3].angle1 = (short)17280;
#line 802
  arcs[3].angle2 = (short)5760;
#line 803
  XFillArcs(display, d, gc, arcs, 4);
  }
#line 807
  return;
}
}
#line 811 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void ResetRoundedRectWindow(Window w ) 
{ 


  {
#line 815
  return;
}
}
#line 818 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/border.c"
void ShapeRoundedRectWindow(Window w , int width , int height ) 
{ 


  {
#line 845
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/debug.c"
void Debug(char const   *str___0  , ...) 
{ 


  {
#line 28
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.h"
void DrawOutline(int x , int y , int width , int height ) ;
#line 29
void ClearOutline(void) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.h"
ScreenType const   *GetScreen(int index ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.h"
void CreateMoveWindow(struct ClientNode *np ) ;
#line 23
void UpdateMoveWindow(struct ClientNode *np ) ;
#line 26
void DestroyMoveWindow(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static char shouldStopMove  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static SnapModeType snapMode  =    (SnapModeType )2;
#line 36 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static int snapDistance  =    5;
#line 38 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static MoveModeType moveMode  =    (MoveModeType )0;
#line 40
static void StopMove(ClientNode *np , int doMove , int oldx , int oldy , int hmax ,
                     int vmax ) ;
#line 42
static void MoveController(int wasDestroyed ) ;
#line 44
static void DoSnap(ClientNode *np ) ;
#line 45
static void DoSnapScreen(ClientNode *np ) ;
#line 46
static void DoSnapBorder(ClientNode *np ) ;
#line 47
static int ShouldSnap(ClientNode const   *np ) ;
#line 48
static void GetClientRectangle(ClientNode const   *np , RectangleType *r ) ;
#line 50
static int CheckOverlapTopBottom(RectangleType const   *a , RectangleType const   *b ) ;
#line 52
static int CheckOverlapLeftRight(RectangleType const   *a , RectangleType const   *b ) ;
#line 55
static int CheckLeftValid(RectangleType const   *client___0 , RectangleType const   *other ,
                          RectangleType const   *left ) ;
#line 57
static int CheckRightValid(RectangleType const   *client___0 , RectangleType const   *other ,
                           RectangleType const   *right ) ;
#line 59
static int CheckTopValid(RectangleType const   *client___0 , RectangleType const   *other ,
                         RectangleType const   *top ) ;
#line 61
static int CheckBottomValid(RectangleType const   *client___0 , RectangleType const   *other ,
                            RectangleType const   *bottom ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
void SetSnapMode(SnapModeType mode ) 
{ 


  {
#line 66
  snapMode = mode;
#line 67
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
void SetMoveMode(MoveModeType mode ) 
{ 


  {
#line 71
  moveMode = mode;
#line 72
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
void SetSnapDistance(char const   *value ) 
{ 
  int temp ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 80
  temp = atoi(value);
  }
#line 81
  if (temp > 32) {
#line 81
    tmp___0 = 1;
  } else
#line 81
  if (temp < 1) {
#line 81
    tmp___0 = 1;
  } else {
#line 81
    tmp___0 = 0;
  }
  {
#line 81
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 81
  if (tmp___1) {
    {
#line 82
    snapDistance = 5;
#line 83
    tmp = gettext("invalid snap distance specified: %d");
#line 83
    Warning((char const   *)tmp, temp);
    }
  } else {
#line 85
    snapDistance = temp;
  }
#line 88
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
void SetDefaultSnapDistance(void) 
{ 


  {
#line 92
  snapDistance = 5;
#line 93
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static void MoveController(int wasDestroyed ) 
{ 


  {
#line 98
  if ((unsigned int )moveMode == 1U) {
    {
#line 99
    ClearOutline();
    }
  }
  {
#line 102
  XUngrabPointer(display, (Time )0L);
#line 103
  XUngrabKeyboard(display, (Time )0L);
#line 105
  DestroyMoveWindow();
#line 106
  shouldStopMove = (char)1;
  }
#line 108
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
int MoveClient(struct ClientNode *np , int startx , int starty , int snap ) 
{ 
  XEvent event ;
  int oldx ;
  int oldy ;
  int doMove ;
  int north ;
  int south ;
  int east ;
  int west ;
  int height ;
  int hmax ;
  int vmax ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 122
  if (! (np->state.border & 64U)) {
#line 123
    return (0);
  }
  {
#line 126
  GrabMouseForMove();
#line 128
  np->controller = & MoveController;
#line 129
  shouldStopMove = (char)0;
#line 131
  oldx = np->x;
#line 132
  oldy = np->y;
#line 133
  vmax = 0;
#line 134
  hmax = 0;
#line 136
  tmp = GetMouseMask();
  }
#line 136
  if (! (tmp & (unsigned int )((1 << 8) | (1 << 9)))) {
    {
#line 137
    StopMove(np, 0, oldx, oldy, 0, 0);
    }
#line 138
    return (0);
  }
  {
#line 141
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 143
  startx -= west;
#line 144
  starty -= north;
#line 146
  doMove = 0;
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 149
    WaitForEvent(& event);
    }
#line 151
    if (shouldStopMove) {
      {
#line 152
      np->controller = (void (*)(int wasDestroyed ))((void *)0);
#line 153
      SetDefaultCursor(np->parent);
      }
#line 154
      return (doMove);
    }
    {
#line 158
    if (event.type == 5) {
#line 158
      goto case_5;
    }
#line 165
    if (event.type == 6) {
#line 165
      goto case_6;
    }
#line 254
    goto switch_default;
    case_5: /* CIL Label */ 
#line 159
    if (event.xbutton.button == 1U) {
      {
#line 161
      StopMove(np, doMove, oldx, oldy, hmax, vmax);
      }
#line 162
      return (doMove);
    } else
#line 159
    if (event.xbutton.button == 2U) {
      {
#line 161
      StopMove(np, doMove, oldx, oldy, hmax, vmax);
      }
#line 162
      return (doMove);
    }
#line 164
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 167
    DiscardMotionEvents(& event, np->window);
#line 169
    np->x = event.xmotion.x_root - startx;
#line 170
    np->y = event.xmotion.y_root - starty;
    }
#line 172
    if (event.xmotion.x_root == 0) {
      {
#line 173
      tmp___0 = LeftDesktop();
      }
#line 173
      if (tmp___0) {
        {
#line 174
        SetClientDesktop(np, currentDesktop);
#line 175
        RestackClients();
#line 176
        np->x = (rootWidth - 2) - startx;
#line 177
        np->y = event.xmotion.y_root - starty;
#line 178
        MoveMouse(rootWindow, np->x + startx, np->y + starty);
#line 179
        DiscardMotionEvents(& event, np->window);
        }
      }
    } else
#line 181
    if (event.xmotion.x_root == rootWidth - 1) {
      {
#line 182
      tmp___1 = RightDesktop();
      }
#line 182
      if (tmp___1) {
        {
#line 183
        SetClientDesktop(np, currentDesktop);
#line 184
        RestackClients();
#line 185
        np->x = 1 - startx;
#line 186
        np->y = event.xmotion.y_root - starty;
#line 187
        MoveMouse(rootWindow, np->x + startx, np->y + starty);
#line 188
        DiscardMotionEvents(& event, np->window);
        }
      }
    } else
#line 190
    if (event.xmotion.y_root == 0) {
      {
#line 191
      tmp___2 = AboveDesktop();
      }
#line 191
      if (tmp___2) {
        {
#line 192
        SetClientDesktop(np, currentDesktop);
#line 193
        RestackClients();
#line 194
        np->x = event.xmotion.x_root - startx;
#line 195
        np->y = (rootHeight - 2) - starty;
#line 196
        MoveMouse(rootWindow, np->x + startx, np->y + starty);
#line 197
        DiscardMotionEvents(& event, np->window);
        }
      }
    } else
#line 199
    if (event.xmotion.y_root == rootHeight - 1) {
      {
#line 200
      tmp___3 = BelowDesktop();
      }
#line 200
      if (tmp___3) {
        {
#line 201
        SetClientDesktop(np, currentDesktop);
#line 202
        RestackClients();
#line 203
        np->x = event.xmotion.x_root - startx;
#line 204
        np->y = 1 - starty;
#line 205
        MoveMouse(rootWindow, np->x + startx, np->y + starty);
#line 206
        DiscardMotionEvents(& event, np->window);
        }
      }
    }
#line 210
    if (snap) {
      {
#line 211
      DoSnap(np);
      }
    }
#line 214
    if (! doMove) {
      {
#line 214
      tmp___4 = abs(np->x - oldx);
      }
#line 214
      if (tmp___4 > 3) {
#line 214
        goto _L;
      } else {
        {
#line 214
        tmp___5 = abs(np->y - oldy);
        }
#line 214
        if (tmp___5 > 3) {
          _L: /* CIL Label */ 
#line 217
          if (np->state.status & 12U) {
#line 218
            if (np->state.status & 4U) {
#line 219
              hmax = 1;
            }
#line 221
            if (np->state.status & 8U) {
#line 222
              vmax = 1;
            }
            {
#line 224
            MaximizeClient(np, (char)0, (char)0);
#line 225
            startx = np->width / 2;
#line 226
            starty = - north / 2;
#line 227
            MoveMouse(np->parent, startx, starty);
            }
          }
          {
#line 230
          CreateMoveWindow(np);
#line 231
          doMove = 1;
          }
        }
      }
    }
#line 234
    if (doMove) {
#line 236
      if ((unsigned int )moveMode == 1U) {
        {
#line 237
        ClearOutline();
#line 238
        height = north + south;
        }
#line 239
        if (! (np->state.status & 256U)) {
#line 240
          height += np->height;
        }
        {
#line 242
        DrawOutline(np->x - west, np->y - north, (np->width + west) + east, height);
        }
      } else {
        {
#line 245
        XMoveWindow(display, np->parent, np->x - west, np->y - north);
#line 247
        SendConfigureEvent(np);
        }
      }
      {
#line 249
      UpdateMoveWindow(np);
#line 250
      UpdatePager();
      }
    }
#line 253
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 255
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
int MoveClientKeyboard(struct ClientNode *np ) 
{ 
  XEvent event ;
  int oldx ;
  int oldy ;
  int moved ;
  int height ;
  int north ;
  int south ;
  int east ;
  int west ;
  int hmax ;
  int vmax ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  KeyType tmp___3 ;
  int tmp___4 ;

  {
#line 272
  if (! (np->state.border & 64U)) {
#line 273
    return (0);
  }
#line 276
  hmax = 0;
#line 277
  if (np->state.status & 4U) {
#line 278
    hmax = 1;
  }
#line 280
  vmax = 0;
#line 281
  if (np->state.status & 8U) {
#line 282
    vmax = 1;
  }
#line 284
  if (vmax) {
    {
#line 285
    MaximizeClient(np, (char)0, (char)0);
    }
  } else
#line 284
  if (hmax) {
    {
#line 285
    MaximizeClient(np, (char)0, (char)0);
    }
  }
  {
#line 288
  GrabMouseForMove();
#line 289
  tmp = XGrabKeyboard(display, np->window, 1, 1, 1, (Time )0L);
  }
#line 289
  if (tmp != 0) {
#line 289
    tmp___0 = 1;
  } else {
#line 289
    tmp___0 = 0;
  }
  {
#line 289
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 289
  if (tmp___1) {
    {
#line 291
    Debug("could not grab keyboard for client move");
    }
#line 292
    return (0);
  }
  {
#line 295
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 297
  oldx = np->x;
#line 298
  oldy = np->y;
#line 300
  np->controller = & MoveController;
#line 301
  shouldStopMove = (char)0;
#line 303
  CreateMoveWindow(np);
#line 304
  UpdateMoveWindow(np);
#line 306
  MoveMouse(rootWindow, np->x, np->y);
#line 307
  DiscardMotionEvents(& event, np->window);
  }
#line 309
  if (np->state.status & 256U) {
#line 310
    height = 0;
  } else {
#line 312
    height = np->height;
  }
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 317
    WaitForEvent(& event);
    }
#line 319
    if (shouldStopMove) {
      {
#line 320
      np->controller = (void (*)(int wasDestroyed ))((void *)0);
#line 321
      SetDefaultCursor(np->parent);
      }
#line 322
      return (1);
    }
#line 325
    moved = 0;
#line 327
    if (event.type == 2) {
      {
#line 329
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 329
        tmp___2 = XCheckTypedWindowEvent(display, np->window, 2, & event);
        }
#line 329
        if (! tmp___2) {
#line 329
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 330
      UpdateTime((XEvent const   *)(& event));
#line 332
      tmp___3 = GetKey((XKeyEvent const   *)(& event.xkey));
      }
      {
#line 333
      if (((unsigned int )tmp___3 & 255U) == 1U) {
#line 333
        goto case_1;
      }
#line 338
      if (((unsigned int )tmp___3 & 255U) == 2U) {
#line 338
        goto case_2;
      }
#line 343
      if (((unsigned int )tmp___3 & 255U) == 3U) {
#line 343
        goto case_3;
      }
#line 348
      if (((unsigned int )tmp___3 & 255U) == 4U) {
#line 348
        goto case_4;
      }
#line 353
      goto switch_default;
      case_1: /* CIL Label */ 
#line 334
      if (np->y + height > 0) {
#line 335
        np->y -= 10;
      }
#line 337
      goto switch_break;
      case_2: /* CIL Label */ 
#line 339
      if (np->y < rootHeight) {
#line 340
        np->y += 10;
      }
#line 342
      goto switch_break;
      case_3: /* CIL Label */ 
#line 344
      if (np->x < rootWidth) {
#line 345
        np->x += 10;
      }
#line 347
      goto switch_break;
      case_4: /* CIL Label */ 
#line 349
      if (np->x + np->width > 0) {
#line 350
        np->x -= 10;
      }
#line 352
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 354
      StopMove(np, 1, oldx, oldy, hmax, vmax);
      }
#line 355
      return (1);
      switch_break: /* CIL Label */ ;
      }
      {
#line 358
      MoveMouse(rootWindow, np->x, np->y);
#line 359
      XCheckTypedWindowEvent(display, np->window, 6, & event);
#line 360
      UpdateTime((XEvent const   *)(& event));
#line 362
      moved = 1;
      }
    } else
#line 364
    if (event.type == 6) {
      {
#line 366
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 366
        tmp___4 = XCheckTypedWindowEvent(display, np->window, 6, & event);
        }
#line 366
        if (! tmp___4) {
#line 366
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 368
      UpdateTime((XEvent const   *)(& event));
#line 370
      np->x = event.xmotion.x;
#line 371
      np->y = event.xmotion.y;
#line 373
      moved = 1;
      }
    } else
#line 375
    if (event.type == 5) {
      {
#line 377
      StopMove(np, 1, oldx, oldy, hmax, vmax);
      }
#line 378
      return (1);
    }
#line 382
    if (moved) {
#line 384
      if ((unsigned int )moveMode == 1U) {
        {
#line 385
        ClearOutline();
#line 386
        DrawOutline(np->x - west, np->y - west, (np->width + west) + east, (height + north) + west);
        }
      } else {
        {
#line 389
        XMoveWindow(display, np->parent, np->x - west, np->y - north);
#line 390
        SendConfigureEvent(np);
        }
      }
      {
#line 393
      UpdateMoveWindow(np);
#line 394
      UpdatePager();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static void StopMove(ClientNode *np , int doMove , int oldx , int oldy , int hmax ,
                     int vmax ) 
{ 
  int north ;
  int south ;
  int east ;
  int west ;

  {
  {
#line 411
  (*(np->controller))(0);
#line 413
  np->controller = (void (*)(int wasDestroyed ))((void *)0);
#line 415
  SetDefaultCursor(np->parent);
  }
#line 417
  if (! doMove) {
#line 419
    np->x = oldx;
#line 420
    np->y = oldy;
#line 423
    if (hmax) {
#line 423
      goto _L;
    } else
#line 423
    if (vmax) {
      _L: /* CIL Label */ 
#line 423
      if (hmax) {
#line 423
        if (! vmax) {
          {
#line 424
          MaximizeClient(np, (char )hmax, (char )vmax);
          }
        }
      } else {
        {
#line 424
        MaximizeClient(np, (char )hmax, (char )vmax);
        }
      }
    }
#line 427
    return;
  }
  {
#line 431
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 433
  XMoveWindow(display, np->parent, np->x - west, np->y - north);
#line 434
  SendConfigureEvent(np);
  }
#line 437
  if (hmax) {
#line 437
    goto _L___0;
  } else
#line 437
  if (vmax) {
    _L___0: /* CIL Label */ 
#line 437
    if (hmax) {
#line 437
      if (! vmax) {
        {
#line 438
        MaximizeClient(np, (char )hmax, (char )vmax);
        }
      }
    } else {
      {
#line 438
      MaximizeClient(np, (char )hmax, (char )vmax);
      }
    }
  }
#line 441
  return;
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static void DoSnap(ClientNode *np ) 
{ 


  {
  {
#line 446
  if ((unsigned int )snapMode == 2U) {
#line 446
    goto case_2;
  }
#line 450
  if ((unsigned int )snapMode == 1U) {
#line 450
    goto case_1;
  }
#line 453
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 447
  DoSnapBorder(np);
#line 448
  DoSnapScreen(np);
  }
#line 449
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 451
  DoSnapScreen(np);
  }
#line 452
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 454
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 456
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static void DoSnapScreen(ClientNode *np ) 
{ 
  RectangleType client___0 ;
  int screen ;
  ScreenType const   *sp ;
  int screenCount___0 ;
  int north ;
  int south ;
  int east ;
  int west ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 467
  GetClientRectangle((ClientNode const   *)np, & client___0);
#line 469
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 471
  screenCount___0 = GetScreenCount();
#line 472
  screen = 0;
  }
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! (screen < screenCount___0)) {
#line 472
      goto while_break;
    }
    {
#line 474
    sp = GetScreen(screen);
#line 476
    tmp = abs((client___0.right - (int )sp->width) - (int )sp->x);
    }
#line 476
    if (tmp <= snapDistance) {
#line 477
      np->x = (int )(((sp->x + sp->width) - (int const   )west) - (int const   )np->width);
    }
    {
#line 479
    tmp___0 = abs(client___0.left - (int )sp->x);
    }
#line 479
    if (tmp___0 <= snapDistance) {
#line 480
      np->x = (int )(sp->x + (int const   )east);
    }
    {
#line 482
    tmp___1 = abs((client___0.bottom - (int )sp->height) - (int )sp->y);
    }
#line 482
    if (tmp___1 <= snapDistance) {
#line 483
      np->y = (int )((sp->y + sp->height) - (int const   )south);
#line 484
      if (! (np->state.status & 256U)) {
#line 485
        np->y -= np->height;
      }
    }
    {
#line 488
    tmp___2 = abs(client___0.top - (int )sp->y);
    }
#line 488
    if (tmp___2 <= snapDistance) {
#line 489
      np->y = north + (int )sp->y;
    }
#line 472
    screen ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  return;
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static void DoSnapBorder(ClientNode *np ) 
{ 
  ClientNode const   *tp ;
  TrayType const   *tray ;
  RectangleType client___0 ;
  RectangleType other ;
  RectangleType left ;
  RectangleType right ;
  RectangleType top ;
  RectangleType bottom ;
  int layer ;
  int north ;
  int south ;
  int east ;
  int west ;
  TrayType *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 502
  left.valid = 0;
#line 502
  left.left = 0;
#line 502
  left.right = 0;
#line 502
  left.top = 0;
#line 502
  left.bottom = 0;
#line 503
  right.valid = 0;
#line 503
  right.left = 0;
#line 503
  right.right = 0;
#line 503
  right.top = 0;
#line 503
  right.bottom = 0;
#line 504
  top.valid = 0;
#line 504
  top.left = 0;
#line 504
  top.right = 0;
#line 504
  top.top = 0;
#line 504
  top.bottom = 0;
#line 505
  bottom.valid = 0;
#line 505
  bottom.left = 0;
#line 505
  bottom.right = 0;
#line 505
  bottom.top = 0;
#line 505
  bottom.bottom = 0;
#line 509
  GetClientRectangle((ClientNode const   *)np, & client___0);
#line 511
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 513
  other.valid = 1;
#line 516
  layer = 0;
  }
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (layer < 13)) {
#line 516
      goto while_break;
    }
    {
#line 519
    tmp = GetTrays();
#line 519
    tray = (TrayType const   *)tmp;
    }
    {
#line 519
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 519
      if (! tray) {
#line 519
        goto while_break___0;
      }
#line 521
      if (tray->hidden) {
#line 522
        goto __Cont;
      }
      {
#line 525
      other.left = (int )tray->x;
#line 526
      other.right = (int )(tray->x + tray->width);
#line 527
      other.top = (int )tray->y;
#line 528
      other.bottom = (int )(tray->y + tray->height);
#line 530
      left.valid = CheckLeftValid((RectangleType const   *)(& client___0), (RectangleType const   *)(& other),
                                  (RectangleType const   *)(& left));
#line 531
      right.valid = CheckRightValid((RectangleType const   *)(& client___0), (RectangleType const   *)(& other),
                                    (RectangleType const   *)(& right));
#line 532
      top.valid = CheckTopValid((RectangleType const   *)(& client___0), (RectangleType const   *)(& other),
                                (RectangleType const   *)(& top));
#line 533
      bottom.valid = CheckBottomValid((RectangleType const   *)(& client___0), (RectangleType const   *)(& other),
                                      (RectangleType const   *)(& bottom));
#line 535
      tmp___2 = CheckOverlapTopBottom((RectangleType const   *)(& client___0), (RectangleType const   *)(& other));
      }
#line 535
      if (tmp___2) {
        {
#line 536
        tmp___0 = abs(client___0.left - other.right);
        }
#line 536
        if (tmp___0 <= snapDistance) {
#line 537
          left = other;
        }
        {
#line 539
        tmp___1 = abs(client___0.right - other.left);
        }
#line 539
        if (tmp___1 <= snapDistance) {
#line 540
          right = other;
        }
      }
      {
#line 543
      tmp___5 = CheckOverlapLeftRight((RectangleType const   *)(& client___0), (RectangleType const   *)(& other));
      }
#line 543
      if (tmp___5) {
        {
#line 544
        tmp___3 = abs(client___0.top - other.bottom);
        }
#line 544
        if (tmp___3 <= snapDistance) {
#line 545
          top = other;
        }
        {
#line 547
        tmp___4 = abs(client___0.bottom - other.top);
        }
#line 547
        if (tmp___4 <= snapDistance) {
#line 548
          bottom = other;
        }
      }
      __Cont: /* CIL Label */ 
#line 519
      tray = (TrayType const   *)tray->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 555
    tp = (ClientNode const   *)nodeTail[layer];
    {
#line 555
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 555
      if (! tp) {
#line 555
        goto while_break___1;
      }
#line 557
      if ((unsigned long )tp == (unsigned long )np) {
#line 558
        goto __Cont___0;
      } else {
        {
#line 557
        tmp___6 = ShouldSnap(tp);
        }
#line 557
        if (! tmp___6) {
#line 558
          goto __Cont___0;
        }
      }
      {
#line 561
      GetClientRectangle(tp, & other);
#line 564
      left.valid = CheckLeftValid((RectangleType const   *)(& client___0), (RectangleType const   *)(& other),
                                  (RectangleType const   *)(& left));
#line 565
      right.valid = CheckRightValid((RectangleType const   *)(& client___0), (RectangleType const   *)(& other),
                                    (RectangleType const   *)(& right));
#line 566
      top.valid = CheckTopValid((RectangleType const   *)(& client___0), (RectangleType const   *)(& other),
                                (RectangleType const   *)(& top));
#line 567
      bottom.valid = CheckBottomValid((RectangleType const   *)(& client___0), (RectangleType const   *)(& other),
                                      (RectangleType const   *)(& bottom));
#line 570
      tmp___9 = CheckOverlapTopBottom((RectangleType const   *)(& client___0), (RectangleType const   *)(& other));
      }
#line 570
      if (tmp___9) {
        {
#line 571
        tmp___7 = abs(client___0.left - other.right);
        }
#line 571
        if (tmp___7 <= snapDistance) {
#line 572
          left = other;
        }
        {
#line 574
        tmp___8 = abs(client___0.right - other.left);
        }
#line 574
        if (tmp___8 <= snapDistance) {
#line 575
          right = other;
        }
      }
      {
#line 578
      tmp___12 = CheckOverlapLeftRight((RectangleType const   *)(& client___0), (RectangleType const   *)(& other));
      }
#line 578
      if (tmp___12) {
        {
#line 579
        tmp___10 = abs(client___0.top - other.bottom);
        }
#line 579
        if (tmp___10 <= snapDistance) {
#line 580
          top = other;
        }
        {
#line 582
        tmp___11 = abs(client___0.bottom - other.top);
        }
#line 582
        if (tmp___11 <= snapDistance) {
#line 583
          bottom = other;
        }
      }
      __Cont___0: /* CIL Label */ 
#line 555
      tp = (ClientNode const   *)tp->prev;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 516
    layer ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 591
  if (right.valid) {
#line 592
    np->x = (right.left - np->width) - west;
  }
#line 594
  if (left.valid) {
#line 595
    np->x = left.right + east;
  }
#line 597
  if (bottom.valid) {
#line 598
    np->y = bottom.top - south;
#line 599
    if (! (np->state.status & 256U)) {
#line 600
      np->y -= np->height;
    }
  }
#line 603
  if (top.valid) {
#line 604
    np->y = top.bottom + north;
  }
#line 607
  return;
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static int ShouldSnap(ClientNode const   *np ) 
{ 


  {
#line 611
  if (np->state.status & 16U) {
#line 612
    return (0);
  } else
#line 613
  if (np->state.status & 128U) {
#line 614
    return (0);
  } else {
#line 616
    return (1);
  }
}
}
#line 621 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static void GetClientRectangle(ClientNode const   *np , RectangleType *r ) 
{ 
  int north ;
  int south ;
  int east ;
  int west ;

  {
  {
#line 625
  GetBorderSize(np, & north, & south, & east, & west);
#line 627
  r->left = (int )(np->x - (int const   )west);
#line 628
  r->right = (int )((np->x + np->width) + (int const   )east);
#line 629
  r->top = (int )(np->y - (int const   )north);
  }
#line 630
  if (np->state.status & 256U) {
#line 631
    r->bottom = (int )(np->y + (int const   )south);
  } else {
#line 633
    r->bottom = (int )((np->y + np->height) + (int const   )south);
  }
#line 636
  r->valid = 1;
#line 638
  return;
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static int CheckOverlapTopBottom(RectangleType const   *a , RectangleType const   *b ) 
{ 


  {
#line 642
  if (a->top >= b->bottom) {
#line 643
    return (0);
  } else
#line 644
  if (a->bottom <= b->top) {
#line 645
    return (0);
  } else {
#line 647
    return (1);
  }
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static int CheckOverlapLeftRight(RectangleType const   *a , RectangleType const   *b ) 
{ 


  {
#line 653
  if (a->left >= b->right) {
#line 654
    return (0);
  } else
#line 655
  if (a->right <= b->left) {
#line 656
    return (0);
  } else {
#line 658
    return (1);
  }
}
}
#line 669 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static int CheckLeftValid(RectangleType const   *client___0 , RectangleType const   *other ,
                          RectangleType const   *left ) 
{ 


  {
#line 672
  if (! left->valid) {
#line 673
    return (0);
  }
#line 676
  if (left->right > other->right) {
#line 677
    return (1);
  }
#line 681
  if (left->top < other->top) {
#line 681
    if (client___0->top < other->top) {
#line 682
      return (1);
    }
  }
#line 686
  if (left->bottom > other->bottom) {
#line 686
    if (client___0->bottom > other->bottom) {
#line 687
      return (1);
    }
  }
#line 690
  if (other->left >= left->right) {
#line 691
    return (1);
  }
#line 694
  return (0);
}
}
#line 699 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static int CheckRightValid(RectangleType const   *client___0 , RectangleType const   *other ,
                           RectangleType const   *right ) 
{ 


  {
#line 702
  if (! right->valid) {
#line 703
    return (0);
  }
#line 706
  if (right->left < other->left) {
#line 707
    return (1);
  }
#line 711
  if (right->top < other->top) {
#line 711
    if (client___0->top < other->top) {
#line 712
      return (1);
    }
  }
#line 716
  if (right->bottom > other->bottom) {
#line 716
    if (client___0->bottom > other->bottom) {
#line 717
      return (1);
    }
  }
#line 720
  if (other->right <= right->left) {
#line 721
    return (1);
  }
#line 724
  return (0);
}
}
#line 729 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static int CheckTopValid(RectangleType const   *client___0 , RectangleType const   *other ,
                         RectangleType const   *top ) 
{ 


  {
#line 732
  if (! top->valid) {
#line 733
    return (0);
  }
#line 736
  if (top->bottom > other->bottom) {
#line 737
    return (1);
  }
#line 741
  if (top->left < other->left) {
#line 741
    if (client___0->left < other->left) {
#line 742
      return (1);
    }
  }
#line 746
  if (top->right > other->right) {
#line 746
    if (client___0->right > other->right) {
#line 747
      return (1);
    }
  }
#line 750
  if (other->top >= top->bottom) {
#line 751
    return (1);
  }
#line 754
  return (0);
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/move.c"
static int CheckBottomValid(RectangleType const   *client___0 , RectangleType const   *other ,
                            RectangleType const   *bottom ) 
{ 


  {
#line 762
  if (! bottom->valid) {
#line 763
    return (0);
  }
#line 766
  if (bottom->top < other->top) {
#line 767
    return (1);
  }
#line 771
  if (bottom->left < other->left) {
#line 771
    if (client___0->left < other->left) {
#line 772
      return (1);
    }
  }
#line 776
  if (bottom->right > other->right) {
#line 776
    if (client___0->right > other->right) {
#line 777
      return (1);
    }
  }
#line 780
  if (other->bottom <= bottom->top) {
#line 781
    return (1);
  }
#line 784
  return (0);
}
}
#line 1548 "/usr/include/X11/Xlib.h"
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1644
extern Window XGetSelectionOwner(Display * , Atom  ) ;
#line 2080
extern int XChangeProperty(Display * , Window  , Atom  , Atom  , int  , int  , unsigned char const   * ,
                           int  ) ;
#line 3304
extern int XSetSelectionOwner(Display * , Atom  , Window  , Time  ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.h"
void InitializeDock(void) ;
#line 17
void StartupDock(void) ;
#line 18
void ShutdownDock(void) ;
#line 19
void DestroyDock(void) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
int rootScreen ;
#line 46 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static char const   BASE_SELECTION_NAME[21]  = 
#line 46 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
  {      (char const   )'_',      (char const   )'N',      (char const   )'E',      (char const   )'T', 
        (char const   )'_',      (char const   )'S',      (char const   )'Y',      (char const   )'S', 
        (char const   )'T',      (char const   )'E',      (char const   )'M',      (char const   )'_', 
        (char const   )'T',      (char const   )'R',      (char const   )'A',      (char const   )'Y', 
        (char const   )'_',      (char const   )'S',      (char const   )'%',      (char const   )'d', 
        (char const   )'\000'};
#line 47 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static char const   ORIENTATION_ATOM[29]  = 
#line 47
  {      (char const   )'_',      (char const   )'N',      (char const   )'E',      (char const   )'T', 
        (char const   )'_',      (char const   )'S',      (char const   )'Y',      (char const   )'S', 
        (char const   )'T',      (char const   )'E',      (char const   )'M',      (char const   )'_', 
        (char const   )'T',      (char const   )'R',      (char const   )'A',      (char const   )'Y', 
        (char const   )'_',      (char const   )'O',      (char const   )'R',      (char const   )'I', 
        (char const   )'E',      (char const   )'N',      (char const   )'T',      (char const   )'A', 
        (char const   )'T',      (char const   )'I',      (char const   )'O',      (char const   )'N', 
        (char const   )'\000'};
#line 49 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static DockType *dock  =    (DockType *)((void *)0);
#line 50 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static int owner  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static Atom dockAtom  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static unsigned long orientation  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static int dockItemCount  ;
#line 55
static void SetSize(TrayComponentType *cp , int width , int height ) ;
#line 56
static void Create___0(TrayComponentType *cp ) ;
#line 57
static void Resize___1(TrayComponentType *cp ) ;
#line 59
static void DockWindow(Window win ) ;
#line 60
static int UndockWindow(Window win ) ;
#line 62
static void UpdateDock(void) ;
#line 63
static void GetDockSize(int *width , int *height ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
void InitializeDock(void) 
{ 


  {
#line 67
  dockItemCount = 0;
#line 68
  owner = 0;
#line 69
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
void StartupDock(void) 
{ 
  char *selectionName ;
  void *tmp ;

  {
#line 76
  if (! dock) {
#line 78
    return;
  }
#line 81
  if (dock->window == 0UL) {
    {
#line 86
    tmp = __builtin_alloca(sizeof(BASE_SELECTION_NAME));
#line 86
    selectionName = (char *)tmp;
#line 87
    sprintf((char */* __restrict  */)selectionName, (char const   */* __restrict  */)(BASE_SELECTION_NAME),
            rootScreen);
#line 88
    dockAtom = XInternAtom(display, (char const   *)selectionName, 0);
#line 92
    dock->window = XCreateSimpleWindow(display, rootWindow, 0, 0, 1U, 1U, 0U, 0UL,
                                       colors[8]);
#line 96
    XSelectInput(display, dock->window, (((1L << 19) | (1L << 20)) | (1L << 6)) | (1L << 7));
    }
  }
#line 102
  (dock->cp)->window = dock->window;
#line 104
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
void ShutdownDock(void) 
{ 
  DockNode *np ;

  {
#line 111
  if (dock) {
    {
#line 114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 114
      if (! dock->nodes) {
#line 114
        goto while_break;
      }
      {
#line 115
      np = (dock->nodes)->next;
#line 116
      XReparentWindow(display, (dock->nodes)->window, rootWindow, 0, 0);
#line 117
      free((void *)dock->nodes);
#line 118
      dock->nodes = np;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 122
    if (owner) {
      {
#line 123
      XSetSelectionOwner(display, dockAtom, (Window )0L, (Time )0L);
      }
    }
    {
#line 127
    XDestroyWindow(display, dock->window);
    }
  }
#line 131
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
void DestroyDock(void) 
{ 


  {
#line 136
  if (dock) {
    {
#line 137
    free((void *)dock);
#line 138
    dock = (DockType *)((void *)0);
    }
  }
#line 141
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
struct TrayComponentType *CreateDock(int width ) 
{ 
  TrayComponentType *cp ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 148
  if ((unsigned long )dock != (unsigned long )((void *)0)) {
#line 148
    if ((unsigned long )dock->cp != (unsigned long )((void *)0)) {
#line 148
      tmp___1 = 1;
    } else {
#line 148
      tmp___1 = 0;
    }
  } else {
#line 148
    tmp___1 = 0;
  }
  {
#line 148
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 148
  if (tmp___2) {
    {
#line 149
    tmp = gettext("only one Dock allowed");
#line 149
    Warning((char const   *)tmp);
    }
#line 150
    return ((struct TrayComponentType *)((void *)0));
  } else
#line 151
  if ((unsigned long )dock == (unsigned long )((void *)0)) {
    {
#line 152
    tmp___0 = malloc(sizeof(DockType ));
#line 152
    dock = (DockType *)tmp___0;
#line 153
    dock->nodes = (DockNode *)((void *)0);
#line 154
    dock->window = (Window )0L;
    }
  }
  {
#line 157
  cp = CreateTrayComponent();
#line 158
  cp->object = (void *)dock;
#line 159
  cp->requestedWidth = 1;
#line 160
  cp->requestedHeight = 1;
#line 161
  dock->cp = cp;
#line 162
  dock->itemSize = width;
#line 164
  cp->SetSize = & SetSize;
#line 165
  cp->Create = & Create___0;
#line 166
  cp->Resize = & Resize___1;
  }
#line 168
  return (cp);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static void SetSize(TrayComponentType *cp , int width , int height ) 
{ 


  {
#line 179
  if (width == 0) {
#line 180
    orientation = 0UL;
  } else
#line 181
  if (height == 0) {
#line 182
    orientation = 1UL;
  }
  {
#line 186
  cp->width = width;
#line 187
  cp->height = height;
#line 188
  GetDockSize(& cp->width, & cp->height);
#line 189
  cp->requestedWidth = cp->width;
#line 190
  cp->requestedHeight = cp->height;
  }
#line 192
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static void Create___0(TrayComponentType *cp ) 
{ 
  XEvent event ;
  Atom orientationAtom ;
  char *tmp ;
  Window tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 203
  if (cp->window != 0UL) {
    {
#line 204
    XResizeWindow(display, cp->window, (unsigned int )cp->width, (unsigned int )cp->height);
#line 205
    XMapRaised(display, cp->window);
    }
  }
  {
#line 209
  orientationAtom = XInternAtom(display, ORIENTATION_ATOM, 0);
#line 210
  XChangeProperty(display, (dock->cp)->window, orientationAtom, (Atom )6, 32, 0, (unsigned char const   *)((unsigned char *)(& orientation)),
                  1);
  }
#line 218
  if (! owner) {
    {
#line 220
    owner = 1;
#line 221
    XSetSelectionOwner(display, dockAtom, (dock->cp)->window, (Time )0L);
#line 222
    tmp___0 = XGetSelectionOwner(display, dockAtom);
    }
#line 222
    if (tmp___0 != (dock->cp)->window) {
#line 222
      tmp___1 = 1;
    } else {
#line 222
      tmp___1 = 0;
    }
    {
#line 222
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 222
    if (tmp___2) {
      {
#line 225
      owner = 0;
#line 226
      tmp = gettext("could not acquire system tray selection");
#line 226
      Warning((char const   *)tmp);
      }
    } else {
      {
#line 230
      memset((void *)(& event), 0, sizeof(event));
#line 231
      event.xclient.type = 33;
#line 232
      event.xclient.window = rootWindow;
#line 233
      event.xclient.message_type = XInternAtom(display, "MANAGER", 0);
#line 234
      event.xclient.format = 32;
#line 235
      event.xclient.data.l[0] = 0L;
#line 236
      event.xclient.data.l[1] = (long )dockAtom;
#line 237
      event.xclient.data.l[2] = (long )(dock->cp)->window;
#line 238
      event.xclient.data.l[3] = 0L;
#line 239
      event.xclient.data.l[4] = 0L;
#line 241
      XSendEvent(display, rootWindow, 0, 1L << 17, & event);
      }
    }
  }
#line 247
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static void Resize___1(TrayComponentType *cp ) 
{ 


  {
  {
#line 254
  XResizeWindow(display, cp->window, (unsigned int )cp->width, (unsigned int )cp->height);
#line 255
  UpdateDock();
  }
#line 257
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
void HandleDockEvent(XClientMessageEvent const   *event ) 
{ 


  {
  {
#line 265
  if (event->data.l[1] == 0L) {
#line 265
    goto case_0;
  }
#line 268
  if (event->data.l[1] == 1L) {
#line 268
    goto case_1;
  }
#line 270
  if (event->data.l[1] == 2L) {
#line 270
    goto case_2;
  }
#line 272
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 266
  DockWindow((Window )event->data.l[2]);
  }
#line 267
  goto switch_break;
  case_1: /* CIL Label */ 
#line 269
  goto switch_break;
  case_2: /* CIL Label */ 
#line 271
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 273
  Debug("invalid opcode in dock event");
  }
#line 274
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 277
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
int HandleDockResizeRequest(XResizeRequestEvent const   *event ) 
{ 
  DockNode *np ;

  {
#line 286
  if (! dock) {
#line 287
    return (0);
  }
#line 290
  np = dock->nodes;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! np) {
#line 290
      goto while_break;
    }
#line 291
    if (np->window == (Window )event->window) {
      {
#line 293
      XResizeWindow(display, np->window, (unsigned int )event->width, (unsigned int )event->height);
#line 294
      UpdateDock();
      }
#line 296
      return (1);
    }
#line 290
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  return (0);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
int HandleDockConfigureRequest(XConfigureRequestEvent const   *event ) 
{ 
  XWindowChanges wc ;
  DockNode *np ;

  {
#line 311
  if (! dock) {
#line 312
    return (0);
  }
#line 315
  np = dock->nodes;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! np) {
#line 315
      goto while_break;
    }
#line 316
    if (np->window == (Window )event->window) {
      {
#line 317
      wc.stack_mode = (int )event->detail;
#line 318
      wc.sibling = (Window )event->above;
#line 319
      wc.border_width = (int )event->border_width;
#line 320
      wc.x = (int )event->x;
#line 321
      wc.y = (int )event->y;
#line 322
      wc.width = (int )event->width;
#line 323
      wc.height = (int )event->height;
#line 324
      XConfigureWindow(display, np->window, (unsigned int )event->value_mask, & wc);
#line 325
      UpdateDock();
      }
#line 326
      return (1);
    }
#line 315
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  return (0);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
int HandleDockReparentNotify(XReparentEvent const   *event ) 
{ 
  DockNode *np ;
  int handled ;

  {
#line 343
  if (! dock) {
#line 344
    return (0);
  }
#line 348
  handled = 0;
#line 349
  np = dock->nodes;
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! np) {
#line 349
      goto while_break;
    }
#line 350
    if (np->window == (Window )event->window) {
#line 351
      if (event->parent != (Window const   )(dock->cp)->window) {
#line 357
        np->needs_reparent = 1;
#line 358
        handled = 1;
      }
    }
#line 349
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  if (handled) {
    {
#line 365
    UpdateDock();
    }
  }
#line 368
  return (handled);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
int HandleDockDestroy(Window win ) 
{ 
  int tmp ;

  {
#line 375
  if (dock) {
    {
#line 376
    tmp = UndockWindow(win);
    }
#line 376
    return (tmp);
  } else {
#line 378
    return (0);
  }
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
int HandleDockSelectionClear(XSelectionClearEvent const   *event ) 
{ 


  {
#line 386
  if (event->selection == (Atom const   )dockAtom) {
    {
#line 387
    Debug("lost _NET_SYSTEM_TRAY selection");
#line 388
    owner = 0;
    }
  }
#line 391
  return (0);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static void DockWindow(Window win ) 
{ 
  DockNode *np ;
  long tmp ;
  void *tmp___0 ;

  {
#line 401
  if (! dock) {
#line 402
    return;
  }
  {
#line 406
  tmp = __builtin_expect((long )(! (! (win == 0UL))), 0L);
  }
#line 406
  if (tmp) {
#line 407
    return;
  }
#line 411
  np = dock->nodes;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! np) {
#line 411
      goto while_break;
    }
#line 412
    if (np->window == win) {
#line 413
      return;
    }
#line 411
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 418
  tmp___0 = malloc(sizeof(DockNode ));
#line 418
  np = (DockNode *)tmp___0;
#line 419
  np->window = win;
#line 420
  np->needs_reparent = 0;
#line 421
  np->next = dock->nodes;
#line 422
  dock->nodes = np;
#line 423
  dockItemCount ++;
#line 426
  GetDockSize(& (dock->cp)->requestedWidth, & (dock->cp)->requestedHeight);
#line 431
  XAddToSaveSet(display, win);
#line 432
  XSelectInput(display, win, (((1L << 17) | (1L << 18)) | (1L << 6)) | (1L << 7));
#line 436
  XReparentWindow(display, win, (dock->cp)->window, 0, 0);
#line 437
  XMapRaised(display, win);
#line 440
  ResizeTray((dock->cp)->tray);
  }
#line 442
  return;
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static int UndockWindow(Window win ) 
{ 
  DockNode *np ;
  DockNode *last___0 ;

  {
#line 451
  if (! dock) {
#line 452
    return (0);
  }
#line 455
  last___0 = (DockNode *)((void *)0);
#line 456
  np = dock->nodes;
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 456
    if (! np) {
#line 456
      goto while_break;
    }
#line 457
    if (np->window == win) {
#line 460
      if (last___0) {
#line 461
        last___0->next = np->next;
      } else {
#line 463
        dock->nodes = np->next;
      }
      {
#line 465
      free((void *)np);
#line 466
      dockItemCount --;
#line 469
      GetDockSize(& (dock->cp)->requestedWidth, & (dock->cp)->requestedHeight);
#line 472
      ResizeTray((dock->cp)->tray);
      }
#line 474
      return (1);
    }
#line 477
    last___0 = np;
#line 456
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 480
  return (0);
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static void UpdateDock(void) 
{ 
  XWindowAttributes attr ;
  DockNode *np ;
  int x ;
  int y ;
  int width ;
  int height ;
  int xoffset ;
  int yoffset ;
  int itemSize ;
  int ratio ;
  int tmp ;

  {
#line 497
  if (orientation == 0UL) {
#line 498
    itemSize = (dock->cp)->height - 2;
  } else {
#line 500
    itemSize = (dock->cp)->width - 2;
  }
#line 502
  if (dock->itemSize > 0) {
#line 502
    if (itemSize > dock->itemSize) {
#line 503
      itemSize = dock->itemSize;
    }
  }
#line 506
  x = 1;
#line 507
  y = 1;
#line 508
  np = dock->nodes;
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (! np) {
#line 508
      goto while_break;
    }
    {
#line 510
    xoffset = 0;
#line 511
    yoffset = 0;
#line 512
    width = itemSize;
#line 513
    height = itemSize;
#line 515
    tmp = XGetWindowAttributes(display, np->window, & attr);
    }
#line 515
    if (tmp) {
#line 518
      ratio = (attr.width << 16) / attr.height;
#line 520
      if (ratio > 65536) {
#line 521
        if (width > attr.width) {
#line 522
          width = attr.width;
        }
#line 524
        height = (width << 16) / ratio;
      } else {
#line 526
        if (height > attr.height) {
#line 527
          height = attr.height;
        }
#line 529
        width = height * ratio >> 16;
      }
#line 532
      xoffset = (itemSize - width) / 2;
#line 533
      yoffset = (itemSize - height) / 2;
    }
    {
#line 537
    XMoveResizeWindow(display, np->window, x + xoffset, y + yoffset, (unsigned int )width,
                      (unsigned int )height);
    }
#line 541
    if (np->needs_reparent) {
      {
#line 542
      XReparentWindow(display, np->window, (dock->cp)->window, x + xoffset, y + yoffset);
      }
    }
#line 546
    if (orientation == 0UL) {
#line 547
      x += itemSize;
#line 548
      if (x >= (dock->cp)->width) {
#line 549
        x = 0;
#line 550
        y += itemSize;
      }
    } else {
#line 553
      y += itemSize;
#line 554
      if (y >= (dock->cp)->height) {
#line 555
        y = 0;
#line 556
        x += itemSize;
      }
    }
#line 508
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 562
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/dock.c"
static void GetDockSize(int *width , int *height ) 
{ 
  int itemSize ;
  int constraint ;
  int span ;
  int columns ;

  {
#line 575
  if (orientation == 0UL) {
#line 576
    constraint = (dock->cp)->height;
  } else {
#line 578
    constraint = (dock->cp)->width;
  }
#line 582
  itemSize = constraint;
#line 583
  if (dock->itemSize > 0) {
#line 583
    if (itemSize > dock->itemSize) {
#line 584
      itemSize = dock->itemSize;
    }
  }
#line 586
  span = constraint / itemSize;
#line 587
  columns = ((dockItemCount + span) - 1) / span;
#line 589
  if (orientation == 0UL) {
#line 592
    *height = constraint;
#line 593
    if (columns == 0) {
#line 594
      *width = 1;
    } else {
#line 596
      *width = itemSize * columns + 2;
    }
  } else {
#line 602
    *width = constraint;
#line 603
    if (columns == 0) {
#line 604
      *height = 1;
    } else {
#line 606
      *height = itemSize * columns + 2;
    }
  }
#line 611
  return;
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.h"
void InitializeOutline(void) ;
#line 15
void StartupOutline(void) ;
#line 16
void ShutdownOutline(void) ;
#line 17
void DestroyOutline(void) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.c"
static GC outlineGC  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.c"
static int lastX___0  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.c"
static int lastY___0  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.c"
static int lastWidth  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.c"
static int lastHeight  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.c"
static char outlineDrawn  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.c"
void InitializeOutline(void) 
{ 


  {
#line 21
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.c"
void StartupOutline(void) 
{ 
  XGCValues gcValues ;

  {
  {
#line 28
  gcValues.function = 10;
#line 29
  gcValues.subwindow_mode = 1;
#line 30
  gcValues.line_width = 2;
#line 31
  outlineGC = XCreateGC(display, rootWindow, (unsigned long )((1L | (1L << 15)) | (1L << 4)),
                        & gcValues);
#line 33
  outlineDrawn = (char)0;
  }
#line 35
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.c"
void ShutdownOutline(void) 
{ 


  {
  {
#line 39
  XFreeGC(display, outlineGC);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.c"
void DestroyOutline(void) 
{ 


  {
#line 44
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.c"
void DrawOutline(int x , int y , int width , int height ) 
{ 


  {
#line 48
  if (! outlineDrawn) {
    {
#line 49
    XSync(display, 0);
#line 50
    XGrabServer(display);
#line 51
    XDrawRectangle(display, rootWindow, outlineGC, x, y, (unsigned int )width, (unsigned int )height);
#line 52
    lastX___0 = x;
#line 53
    lastY___0 = y;
#line 54
    lastWidth = width;
#line 55
    lastHeight = height;
#line 56
    outlineDrawn = (char)1;
    }
  }
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/outline.c"
void ClearOutline(void) 
{ 


  {
#line 62
  if (outlineDrawn) {
    {
#line 63
    XDrawRectangle(display, rootWindow, outlineGC, lastX___0, lastY___0, (unsigned int )lastWidth,
                   (unsigned int )lastHeight);
#line 65
    outlineDrawn = (char)0;
#line 66
    XUngrabServer(display);
#line 67
    XSync(display, 0);
    }
  }
#line 69
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.h"
void InitializeCommands(void) ;
#line 15
void StartupCommands(void) ;
#line 16
void ShutdownCommands(void) ;
#line 17
void DestroyCommands(void) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
char isRestarting ;
#line 22 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
static CommandNode *startupCommands  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
static CommandNode *shutdownCommands  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
static CommandNode *restartCommands  ;
#line 26
static void RunCommands(CommandNode *commands ) ;
#line 27
static void ReleaseCommands(CommandNode **commands ) ;
#line 28
static void AddCommand(CommandNode **commands , char const   *command ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
void InitializeCommands(void) 
{ 


  {
#line 32
  startupCommands = (CommandNode *)((void *)0);
#line 33
  shutdownCommands = (CommandNode *)((void *)0);
#line 34
  restartCommands = (CommandNode *)((void *)0);
#line 35
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
void StartupCommands(void) 
{ 


  {
#line 40
  if (isRestarting) {
    {
#line 41
    RunCommands(restartCommands);
    }
  } else {
    {
#line 43
    RunCommands(startupCommands);
    }
  }
#line 46
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
void ShutdownCommands(void) 
{ 


  {
#line 51
  if (! shouldRestart) {
    {
#line 52
    RunCommands(shutdownCommands);
    }
  }
#line 55
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
void DestroyCommands(void) 
{ 


  {
  {
#line 59
  ReleaseCommands(& startupCommands);
#line 60
  ReleaseCommands(& shutdownCommands);
#line 61
  ReleaseCommands(& restartCommands);
  }
#line 62
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
static void RunCommands(CommandNode *commands ) 
{ 
  CommandNode *cp ;

  {
#line 69
  cp = commands;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! cp) {
#line 69
      goto while_break;
    }
    {
#line 70
    RunCommand((char const   *)cp->command);
#line 69
    cp = cp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
static void ReleaseCommands(CommandNode **commands ) 
{ 
  CommandNode *cp ;

  {
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! *commands) {
#line 82
      goto while_break;
    }
    {
#line 83
    cp = (*commands)->next;
#line 84
    free((void *)(*commands)->command);
#line 85
    free((void *)*commands);
#line 86
    *commands = cp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
static void AddCommand(CommandNode **commands , char const   *command ) 
{ 
  CommandNode *cp ;
  void *tmp ;

  {
#line 98
  if (! command) {
#line 99
    return;
  }
  {
#line 102
  tmp = malloc(sizeof(CommandNode ));
#line 102
  cp = (CommandNode *)tmp;
#line 103
  cp->next = *commands;
#line 104
  *commands = cp;
#line 106
  cp->command = CopyString(command);
  }
#line 108
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
void AddStartupCommand(char const   *command ) 
{ 


  {
  {
#line 112
  AddCommand(& startupCommands, command);
  }
#line 113
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
void AddShutdownCommand(char const   *command ) 
{ 


  {
  {
#line 117
  AddCommand(& shutdownCommands, command);
  }
#line 118
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
void AddRestartCommand(char const   *command ) 
{ 


  {
  {
#line 122
  AddCommand(& restartCommands, command);
  }
#line 123
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/command.c"
void RunCommand(char const   *command ) 
{ 
  char const   *displayString___0 ;
  char *str___0 ;
  long tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  __pid_t tmp___3 ;

  {
  {
#line 131
  tmp = __builtin_expect((long )(! (! (! command))), 0L);
  }
#line 131
  if (tmp) {
#line 132
    return;
  }
  {
#line 135
  displayString___0 = (char const   *)((_XPrivDisplay )display)->display_name;
#line 137
  tmp___3 = fork();
  }
#line 137
  if (! tmp___3) {
    {
#line 138
    close(((_XPrivDisplay )display)->fd);
    }
#line 139
    if (displayString___0) {
#line 139
      if (*(displayString___0 + 0)) {
        {
#line 140
        tmp___0 = strlen(displayString___0);
#line 140
        tmp___1 = malloc(tmp___0 + 9UL);
#line 140
        str___0 = (char *)tmp___1;
#line 141
        sprintf((char */* __restrict  */)str___0, (char const   */* __restrict  */)"DISPLAY=%s",
                displayString___0);
#line 142
        putenv(str___0);
        }
      }
    }
    {
#line 144
    setsid();
#line 145
    execl("/bin/sh", "/bin/sh", "-c", command, (void *)0);
#line 146
    tmp___2 = gettext("exec failed: (%s) %s");
#line 146
    Warning((char const   *)tmp___2, "/bin/sh", command);
#line 147
    exit(0);
    }
  }
#line 150
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.h"
void CreateResizeWindow(struct ClientNode *np ) ;
#line 38
void UpdateResizeWindow(struct ClientNode *np , int gwidth , int gheight ) ;
#line 41
void DestroyResizeWindow(void) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
static Window statusWindow  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
static unsigned int statusWindowHeight  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
static unsigned int statusWindowWidth  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
static int statusWindowX  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
static int statusWindowY  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
static StatusWindowType moveStatusType  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
static StatusWindowType resizeStatusType  ;
#line 34
static void CreateMoveResizeWindow(ClientNode const   *np , StatusWindowType type ) ;
#line 36
static void DrawMoveResizeWindow(ClientNode const   *np , StatusWindowType type ) ;
#line 37
static void DestroyMoveResizeWindow(void) ;
#line 38
static void GetMoveResizeCoordinates(ClientNode const   *np , StatusWindowType type ,
                                     int *x , int *y ) ;
#line 40
static StatusWindowType ParseType(char const   *str___0 ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
static void GetMoveResizeCoordinates(ClientNode const   *np , StatusWindowType type ,
                                     int *x , int *y ) 
{ 
  ScreenType const   *sp ;

  {
#line 48
  if ((unsigned int )type == 3U) {
#line 49
    *x = (int )((unsigned int )np->x + ((unsigned int )np->width - statusWindowWidth) / 2U);
#line 50
    *y = (int )((unsigned int )np->y + ((unsigned int )np->height - statusWindowHeight) / 2U);
#line 51
    return;
  }
  {
#line 54
  sp = GetCurrentScreen((int )np->x, (int )np->y);
  }
#line 56
  if ((unsigned int )type == 4U) {
#line 57
    *x = (int )sp->x;
#line 58
    *y = (int )sp->y;
#line 59
    return;
  }
#line 63
  *x = (int )((unsigned int )sp->x + ((unsigned int )sp->width - statusWindowWidth) / 2U);
#line 64
  *y = (int )((unsigned int )sp->y + ((unsigned int )sp->height - statusWindowHeight) / 2U);
#line 66
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
static void CreateMoveResizeWindow(ClientNode const   *np , StatusWindowType type ) 
{ 
  XSetWindowAttributes attrs ;
  int tmp ;
  int tmp___0 ;

  {
#line 73
  if ((unsigned int )type == 1U) {
#line 74
    return;
  }
  {
#line 77
  tmp = GetStringHeight((FontType )1);
#line 77
  statusWindowHeight = (unsigned int )(tmp + 8);
#line 78
  tmp___0 = GetStringWidth((FontType )1, " 00000 x 00000 ");
#line 78
  statusWindowWidth = (unsigned int )tmp___0;
#line 80
  GetMoveResizeCoordinates(np, type, & statusWindowX, & statusWindowY);
#line 82
  attrs.background_pixel = colors[22];
#line 83
  attrs.save_under = 1;
#line 84
  attrs.override_redirect = 1;
#line 86
  statusWindow = XCreateWindow(display, rootWindow, statusWindowX, statusWindowY,
                               statusWindowWidth, statusWindowHeight, 0U, 0, 1U, (Visual *)0L,
                               (unsigned long )(((1L << 1) | (1L << 9)) | (1L << 10)),
                               & attrs);
#line 93
  XMapRaised(display, statusWindow);
  }
#line 95
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
static void DrawMoveResizeWindow(ClientNode const   *np , StatusWindowType type ) 
{ 
  int x ;
  int y ;

  {
  {
#line 102
  GetMoveResizeCoordinates(np, type, & x, & y);
  }
#line 103
  if (x != statusWindowX) {
    {
#line 104
    statusWindowX = x;
#line 105
    statusWindowY = y;
#line 106
    XMoveResizeWindow(display, statusWindow, x, y, statusWindowWidth, statusWindowHeight);
    }
  } else
#line 103
  if (y != statusWindowX) {
    {
#line 104
    statusWindowX = x;
#line 105
    statusWindowY = y;
#line 106
    XMoveResizeWindow(display, statusWindow, x, y, statusWindowWidth, statusWindowHeight);
    }
  }
  {
#line 111
  ShapeRoundedRectWindow(statusWindow, (int )statusWindowWidth, (int )statusWindowHeight);
#line 114
  XClearWindow(display, statusWindow);
#line 117
  XSetForeground(display, rootGC, colors[23]);
#line 123
  XDrawRectangle(display, statusWindow, rootGC, 0, 0, statusWindowWidth - 1U, statusWindowHeight - 1U);
  }
#line 127
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
static void DestroyMoveResizeWindow(void) 
{ 


  {
#line 132
  if (statusWindow != 0UL) {
    {
#line 133
    XDestroyWindow(display, statusWindow);
#line 134
    statusWindow = (Window )0L;
    }
  }
#line 137
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
void CreateMoveWindow(struct ClientNode *np ) 
{ 


  {
  {
#line 142
  CreateMoveResizeWindow((ClientNode const   *)np, moveStatusType);
  }
#line 144
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
void UpdateMoveWindow(struct ClientNode *np ) 
{ 
  char str___0[80] ;
  unsigned int width ;
  int tmp ;

  {
#line 152
  if ((unsigned int )moveStatusType == 1U) {
#line 153
    return;
  }
  {
#line 156
  DrawMoveResizeWindow((ClientNode const   *)np, moveStatusType);
#line 158
  snprintf((char */* __restrict  */)(str___0), sizeof(str___0), (char const   */* __restrict  */)"(%d, %d)",
           np->x, np->y);
#line 159
  tmp = GetStringWidth((FontType )1, (char const   *)(str___0));
#line 159
  width = (unsigned int )tmp;
#line 160
  RenderString(statusWindow, (FontType )1, (ColorType )23, (int )((statusWindowWidth - width) / 2U),
               4, rootWidth, (Region )((void *)0), (char const   *)(str___0));
  }
#line 163
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
void DestroyMoveWindow(void) 
{ 


  {
  {
#line 168
  DestroyMoveResizeWindow();
  }
#line 170
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
void CreateResizeWindow(struct ClientNode *np ) 
{ 


  {
  {
#line 175
  CreateMoveResizeWindow((ClientNode const   *)np, resizeStatusType);
  }
#line 177
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
void UpdateResizeWindow(struct ClientNode *np , int gwidth , int gheight ) 
{ 
  char str___0[80] ;
  unsigned int fontWidth ;
  int tmp ;

  {
#line 185
  if ((unsigned int )resizeStatusType == 1U) {
#line 186
    return;
  }
  {
#line 189
  DrawMoveResizeWindow((ClientNode const   *)np, resizeStatusType);
#line 191
  snprintf((char */* __restrict  */)(str___0), sizeof(str___0), (char const   */* __restrict  */)"%d x %d",
           gwidth, gheight);
#line 192
  tmp = GetStringWidth((FontType )1, (char const   *)(str___0));
#line 192
  fontWidth = (unsigned int )tmp;
#line 193
  RenderString(statusWindow, (FontType )1, (ColorType )23, (int )((statusWindowWidth - fontWidth) / 2U),
               4, rootWidth, (Region )((void *)0), (char const   *)(str___0));
  }
#line 196
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
void DestroyResizeWindow(void) 
{ 


  {
  {
#line 201
  DestroyMoveResizeWindow();
  }
#line 203
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
static StatusWindowType ParseType(char const   *str___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 208
  if (! str___0) {
#line 209
    return ((StatusWindowType )2);
  } else {
    {
#line 210
    tmp___2 = strcmp(str___0, "off");
    }
#line 210
    if (tmp___2) {
      {
#line 212
      tmp___1 = strcmp(str___0, "screen");
      }
#line 212
      if (tmp___1) {
        {
#line 214
        tmp___0 = strcmp(str___0, "window");
        }
#line 214
        if (tmp___0) {
          {
#line 216
          tmp = strcmp(str___0, "corner");
          }
#line 216
          if (tmp) {
#line 219
            return ((StatusWindowType )0);
          } else {
#line 217
            return ((StatusWindowType )4);
          }
        } else {
#line 215
          return ((StatusWindowType )3);
        }
      } else {
#line 213
        return ((StatusWindowType )2);
      }
    } else {
#line 211
      return ((StatusWindowType )1);
    }
  }
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
void SetMoveStatusType(char const   *str___0 ) 
{ 
  StatusWindowType type ;
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 229
  type = ParseType(str___0);
#line 230
  tmp___0 = __builtin_expect((long )(! (! ((unsigned int )type == 0U))), 0L);
  }
#line 230
  if (tmp___0) {
    {
#line 231
    moveStatusType = (StatusWindowType )2;
#line 232
    tmp = gettext("invalid MoveMode coordinates: \"%s\"");
#line 232
    Warning((char const   *)tmp, str___0);
    }
  } else {
#line 234
    moveStatusType = type;
  }
#line 237
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/status.c"
void SetResizeStatusType(char const   *str___0 ) 
{ 
  StatusWindowType type ;
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 244
  type = ParseType(str___0);
#line 245
  tmp___0 = __builtin_expect((long )(! (! ((unsigned int )type == 0U))), 0L);
  }
#line 245
  if (tmp___0) {
    {
#line 246
    resizeStatusType = (StatusWindowType )2;
#line 247
    tmp = gettext("invalid ResizeMode coordinates: \"%s\"");
#line 247
    Warning((char const   *)tmp, str___0);
    }
  } else {
#line 249
    resizeStatusType = type;
  }
#line 252
  return;
}
}
#line 2354 "/usr/include/X11/Xlib.h"
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.h"
void InitializePager(void) ;
#line 18
void StartupPager(void) ;
#line 19
void ShutdownPager(void) ;
#line 20
void DestroyPager(void) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.h"
char const   *GetDesktopName(unsigned int desktop ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
static PagerType *pagers  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
static int shouldStopMove___0  ;
#line 49
static void Create___1(TrayComponentType *cp ) ;
#line 51
static void SetSize___0(TrayComponentType *cp , int width , int height ) ;
#line 53
static int GetPagerDesktop(PagerType *pp , int x , int y ) ;
#line 55
static void ProcessPagerButtonEvent(TrayComponentType *cp , int x , int y , int mask ) ;
#line 58
static void ProcessPagerMotionEvent(TrayComponentType *cp , int x , int y , int mask ) ;
#line 61
static void StartPagerMove(TrayComponentType *cp , int x , int y ) ;
#line 63
static void StopPagerMove(ClientNode *np , int x , int y , int desktop , int hmax ,
                          int vmax ) ;
#line 66
static void PagerMoveController(int wasDestroyed ) ;
#line 68
static void DrawPagerClient(PagerType const   *pp , ClientNode const   *np ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
void InitializePager(void) 
{ 


  {
#line 72
  pagers = (PagerType *)((void *)0);
#line 73
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
void StartupPager(void) 
{ 


  {
#line 77
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
void ShutdownPager(void) 
{ 
  PagerType *pp ;

  {
#line 84
  pp = pagers;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! pp) {
#line 84
      goto while_break;
    }
    {
#line 85
    XFreePixmap(display, pp->buffer);
#line 84
    pp = pp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
void DestroyPager(void) 
{ 
  PagerType *pp ;

  {
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! pagers) {
#line 95
      goto while_break;
    }
    {
#line 96
    pp = pagers->next;
#line 97
    free((void *)pagers);
#line 98
    pagers = pp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
struct TrayComponentType *CreatePager(int labeled ) 
{ 
  TrayComponentType *cp ;
  PagerType *pp ;
  void *tmp ;

  {
  {
#line 109
  tmp = malloc(sizeof(PagerType ));
#line 109
  pp = (PagerType *)tmp;
#line 110
  pp->next = pagers;
#line 111
  pagers = pp;
#line 112
  pp->labeled = labeled;
#line 113
  pp->mousex = -2;
#line 114
  pp->mousey = -2;
#line 115
  pp->mouseTime.seconds = 0UL;
#line 116
  pp->mouseTime.ms = 0;
#line 118
  cp = CreateTrayComponent();
#line 119
  cp->object = (void *)pp;
#line 120
  pp->cp = cp;
#line 121
  cp->Create = & Create___1;
#line 122
  cp->SetSize = & SetSize___0;
#line 123
  cp->ProcessButtonPress = & ProcessPagerButtonEvent;
#line 124
  cp->ProcessMotionEvent = & ProcessPagerMotionEvent;
  }
#line 126
  return (cp);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
static void Create___1(TrayComponentType *cp ) 
{ 
  PagerType *pp ;

  {
  {
#line 136
  pp = (PagerType *)cp->object;
#line 143
  cp->pixmap = XCreatePixmap(display, rootWindow, (unsigned int )cp->width, (unsigned int )cp->height,
                             (unsigned int )rootDepth);
#line 145
  pp->buffer = cp->pixmap;
  }
#line 147
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
static void SetSize___0(TrayComponentType *cp , int width , int height ) 
{ 
  PagerType *pp ;

  {
#line 156
  pp = (PagerType *)cp->object;
#line 160
  if (width) {
#line 163
    cp->width = width;
#line 165
    pp->deskWidth = (int )((unsigned int )width / desktopWidth);
#line 166
    pp->deskHeight = (pp->deskWidth * rootHeight) / rootWidth;
#line 168
    cp->height = (int )((unsigned int )(pp->deskHeight + 1) * desktopHeight);
  } else
#line 170
  if (height) {
#line 173
    cp->height = height;
#line 175
    pp->deskHeight = (int )((unsigned int )height / desktopHeight);
#line 176
    pp->deskWidth = (pp->deskHeight * rootWidth) / rootHeight;
#line 178
    cp->width = (int )((unsigned int )(pp->deskWidth + 1) * desktopWidth);
  }
#line 184
  pp->scalex = ((pp->deskWidth - 2) << 16) / rootWidth;
#line 185
  pp->scaley = ((pp->deskHeight - 2) << 16) / rootHeight;
#line 187
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
static int GetPagerDesktop(PagerType *pp , int x , int y ) 
{ 
  int pagerx ;
  int pagery ;

  {
#line 194
  pagerx = x / (pp->deskWidth + 1);
#line 195
  pagery = y / (pp->deskHeight + 1);
#line 197
  return ((int )((unsigned int )pagery * desktopWidth + (unsigned int )pagerx));
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
static void ProcessPagerButtonEvent(TrayComponentType *cp , int x , int y , int mask ) 
{ 
  PagerType *pp ;
  int tmp ;

  {
  {
#line 208
  if (mask == 2) {
#line 208
    goto case_2;
  }
#line 208
  if (mask == 1) {
#line 208
    goto case_2;
  }
#line 215
  if (mask == 3) {
#line 215
    goto case_3;
  }
#line 221
  if (mask == 4) {
#line 221
    goto case_4;
  }
#line 227
  if (mask == 5) {
#line 227
    goto case_5;
  }
#line 233
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 211
  pp = (PagerType *)cp->object;
#line 212
  tmp = GetPagerDesktop(pp, x, y);
#line 212
  ChangeDesktop((unsigned int )tmp);
  }
#line 213
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 218
  StartPagerMove(cp, x, y);
  }
#line 219
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 224
  LeftDesktop();
  }
#line 225
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 230
  RightDesktop();
  }
#line 231
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 234
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 236
  return;
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
static void ProcessPagerMotionEvent(TrayComponentType *cp , int x , int y , int mask ) 
{ 
  PagerType *pp ;

  {
  {
#line 241
  pp = (PagerType *)cp->object;
#line 243
  pp->mousex = cp->screenx + x;
#line 244
  pp->mousey = cp->screeny + y;
#line 245
  GetCurrentTime(& pp->mouseTime);
  }
#line 246
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
static void StartPagerMove(TrayComponentType *cp , int x , int y ) 
{ 
  XEvent event ;
  PagerType *pp ;
  ClientNode *np ;
  int layer ;
  int desktop ;
  int cx ;
  int cy ;
  int cwidth ;
  int cheight ;
  int north ;
  int south ;
  int east ;
  int west ;
  int oldx ;
  int oldy ;
  int oldDesk ;
  int startx ;
  int starty ;
  int hmax ;
  int vmax ;
  unsigned int tmp ;

  {
  {
#line 265
  pp = (PagerType *)cp->object;
#line 268
  desktop = GetPagerDesktop(pp, x, y);
#line 269
  x = (int )((unsigned int )x - ((unsigned int )desktop % desktopWidth) * (unsigned int )(pp->deskWidth + 1));
#line 270
  y = (int )((unsigned int )y - ((unsigned int )desktop / desktopWidth) * (unsigned int )(pp->deskHeight + 1));
#line 273
  layer = 12;
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (layer >= 0)) {
#line 273
      goto while_break;
    }
#line 274
    np = nodes[layer];
    {
#line 274
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 274
      if (! np) {
#line 274
        goto while_break___0;
      }
#line 277
      if (! (np->state.status & 2U)) {
#line 278
        goto __Cont;
      }
#line 282
      if (np->state.status & 32U) {
#line 283
        if (currentDesktop != (unsigned int )desktop) {
#line 284
          goto __Cont;
        }
      } else
#line 287
      if (np->state.desktop != (unsigned int )desktop) {
#line 288
        goto __Cont;
      }
#line 293
      cx = 1 + (np->x * pp->scalex >> 16);
#line 294
      cy = 1 + (np->y * pp->scaley >> 16);
#line 295
      cwidth = np->width * pp->scalex >> 16;
#line 296
      cheight = np->height * pp->scaley >> 16;
#line 299
      if (cx + cwidth > pp->deskWidth) {
#line 300
        cwidth = pp->deskWidth - cx;
      }
#line 302
      if (cy + cheight > pp->deskHeight) {
#line 303
        cheight = pp->deskHeight - cy;
      }
#line 305
      if (cx < 0) {
#line 306
        cwidth += cx;
#line 307
        cx = 0;
      }
#line 309
      if (cy < 0) {
#line 310
        cheight += cy;
#line 311
        cy = 0;
      }
#line 315
      if (cwidth <= 0) {
#line 316
        goto __Cont;
      } else
#line 315
      if (cheight <= 0) {
#line 316
        goto __Cont;
      }
#line 320
      if (y < cy) {
#line 321
        goto __Cont;
      } else
#line 320
      if (y > cy + cheight) {
#line 321
        goto __Cont;
      }
#line 325
      if (x < cx) {
#line 326
        goto __Cont;
      } else
#line 325
      if (x > cx + cwidth) {
#line 326
        goto __Cont;
      }
#line 330
      goto ClientFound;
      __Cont: /* CIL Label */ 
#line 274
      np = np->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 273
    layer --;
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  return;
  ClientFound: ;
#line 343
  if (! (np->state.border & 64U)) {
#line 344
    return;
  }
#line 348
  hmax = 0;
#line 349
  if (np->state.status & 4U) {
#line 350
    hmax = 1;
  }
#line 352
  vmax = 0;
#line 353
  if (np->state.status & 8U) {
#line 354
    vmax = 1;
  }
#line 356
  if (hmax) {
    {
#line 357
    MaximizeClient(np, (char)0, (char)0);
    }
  } else
#line 356
  if (vmax) {
    {
#line 357
    MaximizeClient(np, (char)0, (char)0);
    }
  }
  {
#line 360
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 363
  GrabMouseForMove();
#line 365
  np->controller = & PagerMoveController;
#line 366
  shouldStopMove___0 = 0;
#line 368
  oldx = np->x;
#line 369
  oldy = np->y;
#line 370
  oldDesk = (int )np->state.desktop;
#line 372
  startx = x;
#line 373
  starty = y;
#line 375
  tmp = GetMouseMask();
  }
#line 375
  if (! (tmp & (unsigned int )(1 << 10))) {
    {
#line 376
    StopPagerMove(np, oldx, oldy, oldDesk, hmax, vmax);
    }
  }
  {
#line 379
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 381
    WaitForEvent(& event);
    }
#line 383
    if (shouldStopMove___0) {
#line 384
      np->controller = (void (*)(int wasDestroyed ))((void *)0);
#line 385
      return;
    }
    {
#line 389
    if (event.type == 5) {
#line 389
      goto case_5;
    }
#line 398
    if (event.type == 6) {
#line 398
      goto case_6;
    }
#line 445
    goto switch_default;
    case_5: /* CIL Label */ 
#line 392
    if (event.xbutton.button == 3U) {
      {
#line 393
      StopPagerMove(np, oldx, oldy, oldDesk, hmax, vmax);
      }
#line 394
      return;
    }
#line 396
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 400
    SetMousePosition(event.xmotion.x_root, event.xmotion.y_root);
#line 403
    x = event.xmotion.x_root - cp->screenx;
#line 404
    y = event.xmotion.y_root - cp->screeny;
    }
#line 407
    if (x < 0) {
#line 408
      goto switch_break;
    } else
#line 407
    if (x > cp->width) {
#line 408
      goto switch_break;
    }
#line 410
    if (y < 0) {
#line 411
      goto switch_break;
    } else
#line 410
    if (y > cp->height) {
#line 411
      goto switch_break;
    }
    {
#line 415
    desktop = GetPagerDesktop(pp, x, y);
#line 416
    x = (int )((unsigned int )x - (unsigned int )pp->deskWidth * ((unsigned int )desktop % desktopWidth));
#line 417
    y = (int )((unsigned int )y - (unsigned int )pp->deskHeight * ((unsigned int )desktop / desktopWidth));
    }
#line 421
    if (! (np->state.status & 32U)) {
#line 422
      if (desktop != oldDesk) {
        {
#line 423
        SetClientDesktop(np, (unsigned int )desktop);
#line 424
        oldDesk = desktop;
        }
      }
    }
    {
#line 429
    oldx = startx + (x - startx);
#line 430
    oldx = (oldx << 16) / pp->scalex;
#line 431
    oldx -= ((np->width + east) + west) / 2;
#line 432
    oldy = starty + (y - starty);
#line 433
    oldy = (oldy << 16) / pp->scaley;
#line 434
    oldy -= ((np->height + north) + south) / 2;
#line 437
    np->x = oldx;
#line 438
    np->y = oldy;
#line 439
    XMoveWindow(display, np->parent, np->x - west, np->y - north);
#line 440
    SendConfigureEvent(np);
#line 441
    UpdatePager();
    }
#line 443
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 446
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
static void StopPagerMove(ClientNode *np , int x , int y , int desktop , int hmax ,
                          int vmax ) 
{ 
  int north ;
  int south ;
  int east ;
  int west ;

  {
  {
#line 463
  (*(np->controller))(0);
#line 465
  np->x = x;
#line 466
  np->y = y;
#line 468
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 469
  XMoveWindow(display, np->parent, np->x - west, np->y - north);
#line 470
  SendConfigureEvent(np);
  }
#line 473
  if (hmax) {
    {
#line 474
    MaximizeClient(np, (char )hmax, (char )vmax);
    }
  } else
#line 473
  if (vmax) {
    {
#line 474
    MaximizeClient(np, (char )hmax, (char )vmax);
    }
  }
  {
#line 478
  UpdatePager();
  }
#line 480
  return;
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
static void PagerMoveController(int wasDestroyed ) 
{ 


  {
  {
#line 485
  XUngrabPointer(display, (Time )0L);
#line 486
  XUngrabKeyboard(display, (Time )0L);
#line 487
  shouldStopMove___0 = 1;
  }
#line 489
  return;
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
void UpdatePager(void) 
{ 
  PagerType *pp ;
  ClientNode *np ;
  Pixmap buffer ;
  int width ;
  int height ;
  int deskWidth ;
  int deskHeight ;
  unsigned int x ;
  char const   *name ;
  int xc ;
  int yc ;
  int textWidth ;
  int textHeight ;
  int dx ;
  int dy ;
  long tmp ;

  {
  {
#line 505
  tmp = __builtin_expect((long )(! (! shouldExit)), 0L);
  }
#line 505
  if (tmp) {
#line 506
    return;
  }
#line 509
  pp = pagers;
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! pp) {
#line 509
      goto while_break;
    }
    {
#line 511
    buffer = (pp->cp)->pixmap;
#line 512
    width = (pp->cp)->width;
#line 513
    height = (pp->cp)->height;
#line 514
    deskWidth = pp->deskWidth;
#line 515
    deskHeight = pp->deskHeight;
#line 518
    XSetForeground(display, rootGC, colors[16]);
#line 519
    XFillRectangle(display, buffer, rootGC, 0, 0, (unsigned int )width, (unsigned int )height);
#line 522
    XSetForeground(display, rootGC, colors[18]);
#line 523
    dx = (int )(currentDesktop % desktopWidth);
#line 524
    dy = (int )(currentDesktop / desktopWidth);
#line 525
    XFillRectangle(display, buffer, rootGC, dx * (deskWidth + 1), dy * (deskHeight + 1),
                   (unsigned int )deskWidth, (unsigned int )deskHeight);
    }
#line 530
    if (pp->labeled) {
      {
#line 531
      textHeight = GetStringHeight((FontType )7);
      }
#line 532
      if (textHeight < deskHeight) {
#line 533
        x = 0U;
        {
#line 533
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 533
          if (! (x < desktopCount)) {
#line 533
            goto while_break___0;
          }
          {
#line 534
          dx = (int )(x % desktopWidth);
#line 535
          dy = (int )(x / desktopWidth);
#line 536
          name = GetDesktopName(x);
#line 537
          textWidth = GetStringWidth((FontType )7, name);
          }
#line 538
          if (textWidth < deskWidth) {
            {
#line 539
            xc = dx * (deskWidth + 1) + (deskWidth - textWidth) / 2;
#line 540
            yc = dy * (deskHeight + 1) + (deskHeight - textHeight) / 2;
#line 541
            RenderString(buffer, (FontType )7, (ColorType )21, xc, yc, deskWidth,
                         (Region )0L, name);
            }
          }
#line 533
          x ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 549
    x = 0U;
    {
#line 549
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 549
      if (! (x <= 12U)) {
#line 549
        goto while_break___1;
      }
#line 550
      np = nodeTail[x];
      {
#line 550
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 550
        if (! np) {
#line 550
          goto while_break___2;
        }
        {
#line 551
        DrawPagerClient((PagerType const   *)pp, (ClientNode const   *)np);
#line 550
        np = np->prev;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 549
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 556
    XSetForeground(display, rootGC, colors[17]);
#line 557
    x = 1U;
    }
    {
#line 557
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 557
      if (! (x < desktopHeight)) {
#line 557
        goto while_break___3;
      }
      {
#line 558
      XDrawLine(display, buffer, rootGC, 0, (int )((unsigned int )(deskHeight + 1) * x - 1U),
                width, (int )((unsigned int )(deskHeight + 1) * x - 1U));
#line 557
      x ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 562
    x = 1U;
    {
#line 562
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 562
      if (! (x < desktopWidth)) {
#line 562
        goto while_break___4;
      }
      {
#line 563
      XDrawLine(display, buffer, rootGC, (int )((unsigned int )(deskWidth + 1) * x - 1U),
                0, (int )((unsigned int )(deskWidth + 1) * x - 1U), height);
#line 562
      x ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 569
    UpdateSpecificTray((TrayType const   *)(pp->cp)->tray, (TrayComponentType const   *)pp->cp);
#line 509
    pp = pp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 573
  return;
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
void SignalPager(struct TimeType  const  *now , int x , int y ) 
{ 
  PagerType *pp ;
  int desktop ;
  char const   *desktopName ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 580
  pp = pagers;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! pp) {
#line 580
      goto while_break;
    }
    {
#line 581
    tmp___0 = abs(pp->mousex - x);
    }
#line 581
    if (tmp___0 < 2) {
      {
#line 581
      tmp___1 = abs(pp->mousey - y);
      }
#line 581
      if (tmp___1 < 2) {
        {
#line 583
        tmp = GetTimeDifference(now, (TimeType const   *)(& pp->mouseTime));
        }
#line 583
        if (tmp >= (unsigned long )popupDelay) {
          {
#line 585
          desktop = GetPagerDesktop(pp, x - (pp->cp)->screenx, y - (pp->cp)->screeny);
          }
#line 587
          if (desktop >= 0) {
            {
#line 589
            desktopName = GetDesktopName((unsigned int )desktop);
            }
#line 590
            if (desktopName) {
              {
#line 591
              ShowPopup(x, y, desktopName);
              }
            }
          }
        }
      }
    }
#line 580
    pp = pp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 598
  return;
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/pager.c"
static void DrawPagerClient(PagerType const   *pp , ClientNode const   *np ) 
{ 
  int x ;
  int y ;
  int width ;
  int height ;
  int offx ;
  int offy ;
  ColorType fillColor ;

  {
#line 609
  if (! (np->state.status & 2U)) {
#line 610
    return;
  }
#line 614
  if (np->state.status & 32U) {
#line 615
    offx = (int )(currentDesktop % desktopWidth);
#line 616
    offy = (int )(currentDesktop / desktopWidth);
  } else {
#line 618
    offx = (int )(np->state.desktop % (unsigned int const   )desktopWidth);
#line 619
    offy = (int )(np->state.desktop / (unsigned int const   )desktopWidth);
  }
#line 621
  offx *= (int )(pp->deskWidth + 1);
#line 622
  offy *= (int )(pp->deskHeight + 1);
#line 625
  x = 1 + (int )(np->x * pp->scalex >> 16);
#line 626
  y = 1 + (int )(np->y * pp->scaley >> 16);
#line 627
  width = (int )(np->width * pp->scalex >> 16);
#line 628
  height = (int )(np->height * pp->scaley >> 16);
#line 631
  if (x + width > (int )pp->deskWidth) {
#line 632
    width = (int )(pp->deskWidth - (int const   )x);
  }
#line 634
  if (y + height > (int )pp->deskHeight) {
#line 635
    height = (int )(pp->deskHeight - (int const   )y);
  }
#line 637
  if (x < 0) {
#line 638
    width += x;
#line 639
    x = 0;
  }
#line 641
  if (y < 0) {
#line 642
    height += y;
#line 643
    y = 0;
  }
#line 647
  if (width <= 0) {
#line 648
    return;
  } else
#line 647
  if (height <= 0) {
#line 648
    return;
  }
  {
#line 652
  x += offx;
#line 653
  y += offy;
#line 656
  XSetForeground(display, rootGC, colors[20]);
#line 657
  XDrawRectangle(display, (pp->cp)->pixmap, rootGC, x, y, (unsigned int )width, (unsigned int )height);
  }
#line 660
  if (width > 1) {
#line 660
    if (height > 1) {
#line 661
      if (np->state.status & 1U) {
#line 661
        if (np->state.desktop == (unsigned int const   )currentDesktop) {
#line 664
          fillColor = (ColorType )19;
        } else
#line 661
        if (np->state.status & 32U) {
#line 664
          fillColor = (ColorType )19;
        } else {
#line 666
          fillColor = (ColorType )17;
        }
      } else {
#line 666
        fillColor = (ColorType )17;
      }
      {
#line 668
      XSetForeground(display, rootGC, colors[fillColor]);
#line 669
      XFillRectangle(display, (pp->cp)->pixmap, rootGC, x + 1, y + 1, (unsigned int )(width - 1),
                     (unsigned int )(height - 1));
      }
    }
  }
#line 673
  return;
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.h"
int showingDesktop  ;
#line 18
void InitializeDesktops(void) ;
#line 19
void StartupDesktops(void) ;
#line 20
void ShutdownDesktops(void) ;
#line 21
void DestroyDesktops(void) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
char initializing ;
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
char **desktopNames  =    (char **)((void *)0);
#line 28 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
void InitializeDesktops(void) 
{ 


  {
#line 29
  return;
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
void StartupDesktops(void) 
{ 
  unsigned int x ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 36
  if ((unsigned long )desktopNames == (unsigned long )((void *)0)) {
    {
#line 37
    tmp = malloc((unsigned long )desktopCount * sizeof(char *));
#line 37
    desktopNames = (char **)tmp;
#line 38
    x = 0U;
    }
    {
#line 38
    while (1) {
      while_continue: /* CIL Label */ ;
#line 38
      if (! (x < desktopCount)) {
#line 38
        goto while_break;
      }
#line 39
      *(desktopNames + x) = (char *)((void *)0);
#line 38
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 42
  x = 0U;
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 42
    if (! (x < desktopCount)) {
#line 42
      goto while_break___0;
    }
#line 43
    if ((unsigned long )*(desktopNames + x) == (unsigned long )((void *)0)) {
      {
#line 44
      tmp___0 = malloc(4UL * sizeof(char ));
#line 44
      *(desktopNames + x) = (char *)tmp___0;
#line 45
      snprintf((char */* __restrict  */)*(desktopNames + x), (size_t )4, (char const   */* __restrict  */)"%d",
               x + 1U);
      }
    }
#line 42
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 49
  showingDesktop = 0;
#line 51
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
void ShutdownDesktops(void) 
{ 


  {
#line 55
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
void DestroyDesktops(void) 
{ 
  unsigned int x ;

  {
#line 62
  if (desktopNames) {
#line 63
    x = 0U;
    {
#line 63
    while (1) {
      while_continue: /* CIL Label */ ;
#line 63
      if (! (x < desktopCount)) {
#line 63
        goto while_break;
      }
      {
#line 64
      free((void *)*(desktopNames + x));
#line 63
      x ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 66
    free((void *)desktopNames);
#line 67
    desktopNames = (char **)((void *)0);
    }
  }
#line 70
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
int RightDesktop(void) 
{ 
  int x ;
  int y ;

  {
#line 75
  if (desktopWidth > 1U) {
    {
#line 76
    y = (int )(currentDesktop / desktopWidth);
#line 77
    x = (int )((currentDesktop + 1U) % desktopWidth);
#line 78
    ChangeDesktop((unsigned int )y * desktopWidth + (unsigned int )x);
    }
#line 79
    return (1);
  } else {
#line 81
    return (0);
  }
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
int LeftDesktop(void) 
{ 
  int x ;
  int y ;

  {
#line 88
  if (desktopWidth > 1U) {
#line 89
    y = (int )(currentDesktop / desktopWidth);
#line 90
    x = (int )(currentDesktop % desktopWidth);
#line 91
    if (x > 0) {
#line 91
      x --;
    } else {
#line 91
      x = (int )(desktopWidth - 1U);
    }
    {
#line 92
    ChangeDesktop((unsigned int )y * desktopWidth + (unsigned int )x);
    }
#line 93
    return (1);
  } else {
#line 95
    return (0);
  }
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
int AboveDesktop(void) 
{ 


  {
#line 101
  if (desktopHeight > 1U) {
#line 102
    if (currentDesktop >= desktopWidth) {
      {
#line 103
      ChangeDesktop(currentDesktop - desktopWidth);
      }
    } else {
      {
#line 105
      ChangeDesktop(currentDesktop + (desktopHeight - 1U) * desktopWidth);
      }
    }
#line 107
    return (1);
  } else {
#line 109
    return (0);
  }
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
int BelowDesktop(void) 
{ 


  {
#line 115
  if (desktopHeight > 1U) {
    {
#line 116
    ChangeDesktop((currentDesktop + desktopWidth) % desktopCount);
    }
#line 117
    return (1);
  } else {
#line 119
    return (0);
  }
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
void ChangeDesktop(unsigned int desktop ) 
{ 
  ClientNode *np ;
  unsigned int x ;
  long tmp ;

  {
  {
#line 129
  tmp = __builtin_expect((long )(! (! (desktop >= desktopCount))), 0L);
  }
#line 129
  if (tmp) {
#line 130
    return;
  }
#line 133
  if (currentDesktop == desktop) {
#line 133
    if (! initializing) {
#line 134
      return;
    }
  }
#line 141
  x = 0U;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (x < 13U)) {
#line 141
      goto while_break;
    }
#line 142
    np = nodes[x];
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 142
      if (! np) {
#line 142
        goto while_break___0;
      }
#line 143
      if (np->state.status & 32U) {
#line 144
        goto __Cont;
      }
#line 146
      if (np->state.desktop == currentDesktop) {
        {
#line 147
        HideClient(np);
        }
      }
      __Cont: /* CIL Label */ 
#line 142
      np = np->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  x = 0U;
  {
#line 153
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 153
    if (! (x < 13U)) {
#line 153
      goto while_break___1;
    }
#line 154
    np = nodes[x];
    {
#line 154
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 154
      if (! np) {
#line 154
        goto while_break___2;
      }
#line 155
      if (np->state.status & 32U) {
#line 156
        goto __Cont___0;
      }
#line 158
      if (np->state.desktop == desktop) {
        {
#line 159
        ShowClient(np);
        }
      }
      __Cont___0: /* CIL Label */ 
#line 154
      np = np->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 153
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 164
  currentDesktop = desktop;
#line 166
  SetCardinalAtom(rootWindow, (AtomType )15, (unsigned long )currentDesktop);
#line 168
  RestackClients();
#line 170
  UpdatePager();
#line 171
  UpdateTaskBar();
#line 173
  LoadBackground((int )desktop);
  }
#line 175
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
struct Menu *CreateDesktopMenu(unsigned int mask ) 
{ 
  Menu *menu ;
  MenuItem *item ;
  int x ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 184
  tmp = malloc(sizeof(Menu ));
#line 184
  menu = (Menu *)tmp;
#line 185
  menu->itemHeight = 0;
#line 186
  menu->items = (struct MenuItem *)((void *)0);
#line 187
  menu->label = (char *)((void *)0);
#line 189
  x = (int )(desktopCount - 1U);
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (x >= 0)) {
#line 189
      goto while_break;
    }
    {
#line 191
    tmp___0 = malloc(sizeof(MenuItem ));
#line 191
    item = (MenuItem *)tmp___0;
#line 192
    item->type = (MenuItemType )0;
#line 193
    item->iconName = (char *)((void *)0);
#line 194
    item->submenu = (struct Menu *)((void *)0);
#line 195
    item->next = menu->items;
#line 196
    menu->items = item;
#line 198
    item->action.type = (MenuActionType )2;
#line 199
    item->action.data.i = x;
#line 201
    tmp___1 = strlen((char const   *)*(desktopNames + x));
#line 201
    tmp___2 = malloc(tmp___1 + 3UL);
#line 201
    item->name = (char *)tmp___2;
    }
#line 202
    if (mask & (unsigned int )(1 << x)) {
      {
#line 203
      strcpy((char */* __restrict  */)item->name, (char const   */* __restrict  */)"[");
#line 204
      strcat((char */* __restrict  */)item->name, (char const   */* __restrict  */)*(desktopNames + x));
#line 205
      strcat((char */* __restrict  */)item->name, (char const   */* __restrict  */)"]");
      }
    } else {
      {
#line 207
      strcpy((char */* __restrict  */)item->name, (char const   */* __restrict  */)" ");
#line 208
      strcat((char */* __restrict  */)item->name, (char const   */* __restrict  */)*(desktopNames + x));
#line 209
      strcat((char */* __restrict  */)item->name, (char const   */* __restrict  */)" ");
      }
    }
#line 189
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return (menu);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
void ShowDesktop(void) 
{ 
  ClientNode *np ;
  int layer ;

  {
#line 224
  layer = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (layer < 13)) {
#line 224
      goto while_break;
    }
#line 225
    np = nodes[layer];
    {
#line 225
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 225
      if (! np) {
#line 225
        goto while_break___0;
      }
#line 228
      if (np->state.status & 64U) {
#line 229
        goto __Cont;
      }
#line 232
      if (showingDesktop) {
#line 233
        if (np->state.status & 4096U) {
          {
#line 234
          RestoreClient(np, (char)0);
          }
        }
      } else
#line 236
      if (np->state.desktop == currentDesktop) {
#line 236
        goto _L;
      } else
#line 236
      if (np->state.status & 32U) {
        _L: /* CIL Label */ 
#line 238
        if (np->state.status & 258U) {
          {
#line 239
          MinimizeClient(np);
#line 240
          np->state.status |= 4096U;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 225
      np = np->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 224
    layer ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  showingDesktop = ! showingDesktop;
#line 247
  SetCardinalAtom(rootWindow, (AtomType )19, (unsigned long )showingDesktop);
#line 249
  RestackClients();
  }
#line 251
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
void SetDesktopCount(char const   *width , char const   *height ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;

  {
#line 256
  if (width) {
    {
#line 257
    tmp = atoi(width);
#line 257
    desktopWidth = (unsigned int )tmp;
    }
  } else {
#line 259
    desktopWidth = 4U;
  }
#line 261
  if (height) {
    {
#line 262
    tmp___0 = atoi(height);
#line 262
    desktopHeight = (unsigned int )tmp___0;
    }
  } else {
#line 264
    desktopHeight = 1U;
  }
  {
#line 267
  desktopCount = desktopWidth * desktopHeight;
#line 268
  tmp___2 = __builtin_expect((long )(! (! (desktopCount == 0U))), 0L);
  }
#line 268
  if (tmp___2) {
    {
#line 269
    tmp___1 = gettext("invalid desktop count");
#line 269
    Warning((char const   *)tmp___1);
#line 270
    desktopWidth = 4U;
#line 271
    desktopHeight = 1U;
#line 272
    desktopCount = desktopWidth * desktopHeight;
    }
  }
#line 275
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
void SetDesktopName(unsigned int desktop , char const   *str___0 ) 
{ 
  unsigned int x ;
  char *tmp ;
  long tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 282
  tmp___0 = __builtin_expect((long )(! (! (! str___0))), 0L);
  }
#line 282
  if (tmp___0) {
    {
#line 283
    tmp = gettext("empty Desktops Name tag");
#line 283
    Warning((char const   *)tmp);
    }
#line 284
    return;
  }
#line 290
  if (! desktopNames) {
    {
#line 291
    tmp___1 = malloc((unsigned long )desktopCount * sizeof(char *));
#line 291
    desktopNames = (char **)tmp___1;
#line 292
    x = 0U;
    }
    {
#line 292
    while (1) {
      while_continue: /* CIL Label */ ;
#line 292
      if (! (x < desktopCount)) {
#line 292
        goto while_break;
      }
#line 293
      *(desktopNames + x) = (char *)((void *)0);
#line 292
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 299
  *(desktopNames + desktop) = CopyString(str___0);
  }
#line 301
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/desktop.c"
char const   *GetDesktopName(unsigned int desktop ) 
{ 


  {
#line 305
  if (desktopNames) {
#line 305
    if (*(desktopNames + desktop)) {
#line 306
      return ((char const   *)*(desktopNames + desktop));
    } else {
#line 308
      return ("");
    }
  } else {
#line 308
    return ("");
  }
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.h"
void InitializePopup(void) ;
#line 20
void StartupPopup(void) ;
#line 21
void ShutdownPopup(void) ;
#line 22
void DestroyPopup(void) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.h"
int popupDelay  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
static PopupType popup  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
static int popupEnabled  ;
#line 37
static void DrawPopup(void) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
void InitializePopup(void) 
{ 


  {
#line 41
  popupDelay = 600;
#line 42
  popupEnabled = 1;
#line 43
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
void StartupPopup(void) 
{ 


  {
#line 47
  popup.isActive = 0;
#line 48
  popup.text = (char *)((void *)0);
#line 49
  popup.window = (Window )0L;
#line 50
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
void ShutdownPopup(void) 
{ 


  {
#line 54
  if (popup.text) {
    {
#line 55
    free((void *)popup.text);
#line 56
    popup.text = (char *)((void *)0);
    }
  }
#line 58
  if (popup.window != 0UL) {
    {
#line 59
    XDestroyWindow(display, popup.window);
#line 60
    popup.window = (Window )0L;
    }
  }
#line 62
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
void DestroyPopup(void) 
{ 


  {
#line 66
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
void ShowPopup(int x , int y , char const   *text ) 
{ 
  unsigned long attrMask ;
  XSetWindowAttributes attr ;
  ScreenType const   *sp ;
  int tmp ;
  int tmp___0 ;

  {
#line 77
  if (! popupEnabled) {
#line 78
    return;
  }
#line 81
  if (popup.text) {
    {
#line 82
    free((void *)popup.text);
#line 83
    popup.text = (char *)((void *)0);
    }
  }
#line 86
  if ((int const   )*(text + 0) == 0) {
#line 87
    return;
  }
  {
#line 90
  popup.text = CopyString(text);
#line 91
  tmp = GetStringHeight((FontType )3);
#line 91
  popup.height = tmp + 2;
#line 92
  tmp___0 = GetStringWidth((FontType )3, (char const   *)popup.text);
#line 92
  popup.width = tmp___0 + 9;
#line 94
  sp = GetCurrentScreen(x, y);
  }
#line 96
  if (popup.width > (int )sp->width) {
#line 97
    popup.width = (int )sp->width;
  }
#line 100
  popup.x = x;
#line 101
  popup.y = (y - popup.height) - 2;
#line 103
  if (popup.width + popup.x >= (int )sp->width) {
#line 104
    popup.x = (int )((sp->width - (int const   )popup.width) - 2);
  }
#line 106
  if (popup.height + popup.y >= (int )sp->height) {
#line 107
    popup.y = (int )((sp->height - (int const   )popup.height) - 2);
  }
#line 109
  if (popup.x < 2) {
#line 110
    popup.x = 2;
  }
#line 112
  if (popup.y < 2) {
#line 113
    popup.y = 2;
  }
#line 116
  if (popup.window == 0UL) {
    {
#line 118
    attrMask = 0UL;
#line 120
    attrMask |= (unsigned long )(1L << 11);
#line 121
    attr.event_mask = ((1L << 15) | (1L << 6)) | (1L << 7);
#line 125
    attrMask |= (unsigned long )(1L << 10);
#line 126
    attr.save_under = 1;
#line 128
    attrMask |= (unsigned long )(1L << 1);
#line 129
    attr.background_pixel = colors[38];
#line 131
    attrMask |= (unsigned long )(1L << 3);
#line 132
    attr.border_pixel = colors[40];
#line 134
    attrMask |= (unsigned long )(1L << 12);
#line 135
    attr.do_not_propagate_mask = ((1L << 6) | (1L << 2)) | (1L << 3);
#line 140
    popup.window = XCreateWindow(display, rootWindow, popup.x, popup.y, (unsigned int )popup.width,
                                 (unsigned int )popup.height, 1U, 0, 1U, (Visual *)0L,
                                 attrMask, & attr);
    }
  } else {
    {
#line 147
    XMoveResizeWindow(display, popup.window, popup.x, popup.y, (unsigned int )popup.width,
                      (unsigned int )popup.height);
    }
  }
  {
#line 152
  ResetRoundedRectWindow(popup.window);
#line 153
  ShapeRoundedRectWindow(popup.window, popup.width, popup.height);
#line 155
  popup.mx = x;
#line 156
  popup.my = y;
  }
#line 158
  if (! popup.isActive) {
    {
#line 159
    XMapRaised(display, popup.window);
#line 160
    popup.isActive = 1;
    }
  } else {
    {
#line 162
    DrawPopup();
    }
  }
#line 165
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
void SetPopupEnabled(int e ) 
{ 


  {
#line 169
  popupEnabled = e;
#line 170
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
void SetPopupDelay(char const   *str___0 ) 
{ 
  int temp ;
  long tmp ;
  char *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 177
  tmp = __builtin_expect((long )(! (! ((unsigned long )str___0 == (unsigned long )((void *)0)))),
                         0L);
  }
#line 177
  if (tmp) {
#line 178
    return;
  }
  {
#line 181
  temp = atoi(str___0);
#line 182
  tmp___1 = __builtin_expect((long )(! (! (temp < 0))), 0L);
  }
#line 182
  if (tmp___1) {
    {
#line 183
    tmp___0 = gettext("invalid popup delay specified: %s");
#line 183
    Warning((char const   *)tmp___0, str___0);
    }
  } else {
#line 185
    popupDelay = temp;
  }
#line 188
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
void SignalPopup(struct TimeType  const  *now , int x , int y ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 193
  if (popup.isActive) {
    {
#line 194
    tmp = abs(popup.mx - x);
    }
#line 194
    if (tmp > 2) {
      {
#line 195
      XUnmapWindow(display, popup.window);
#line 196
      popup.isActive = 0;
      }
    } else {
      {
#line 194
      tmp___0 = abs(popup.my - y);
      }
#line 194
      if (tmp___0 > 2) {
        {
#line 195
        XUnmapWindow(display, popup.window);
#line 196
        popup.isActive = 0;
        }
      }
    }
  }
#line 200
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
int ProcessPopupEvent(XEvent const   *event ) 
{ 


  {
#line 205
  if (popup.isActive) {
#line 205
    if (event->xany.window == (Window const   )popup.window) {
#line 206
      if (event->type == 12) {
        {
#line 207
        DrawPopup();
        }
#line 208
        return (1);
      } else
#line 209
      if (event->type == 6) {
        {
#line 210
        XUnmapWindow(display, popup.window);
#line 211
        popup.isActive = 0;
        }
#line 212
        return (1);
      }
    }
  }
#line 216
  return (0);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/popup.c"
static void DrawPopup(void) 
{ 


  {
  {
#line 225
  XClearWindow(display, popup.window);
#line 234
  RenderString(popup.window, (FontType )3, (ColorType )39, 4, 1, popup.width, (Region )((void *)0),
               (char const   *)popup.text);
  }
#line 237
  return;
}
}
#line 1970 "/usr/include/X11/Xlib.h"
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2537
extern int XFreeColors(Display * , Colormap  , unsigned long * , int  , unsigned long  ) ;
#line 2862
extern int XParseColor(Display * , Colormap  , char const   * , XColor * ) ;
#line 2969
extern int XQueryColor(Display * , Colormap  , XColor * ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
Colormap rootColormap ;
#line 80 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.h"
unsigned long colors[45]  ;
#line 83
void InitializeColors(void) ;
#line 84
void StartupColors(void) ;
#line 85
void ShutdownColors(void) ;
#line 86
void DestroyColors(void) ;
#line 111
void GetColorFromPixel(XColor *c ) ;
#line 120
void GetColorIndex(XColor *c ) ;
#line 126
void GetColorFromIndex(XColor *c ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static unsigned long rgbColors[45]  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static unsigned long *map  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static unsigned long *rmap  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static DefaultColorNode DEFAULT_COLORS[36]  = 
#line 34
  {      {(ColorType )0, "black"}, 
        {(ColorType )1, "black"}, 
        {(ColorType )2, "gray"}, 
        {(ColorType )3, "gray"}, 
        {(ColorType )4, "red"}, 
        {(ColorType )5, "red"}, 
        {(ColorType )6, "black"}, 
        {(ColorType )7, "black"}, 
        {(ColorType )8, "gray"}, 
        {(ColorType )9, "black"}, 
        {(ColorType )10, "black"}, 
        {(ColorType )11, "gray"}, 
        {(ColorType )12, "gray"}, 
        {(ColorType )13, "white"}, 
        {(ColorType )14, "red"}, 
        {(ColorType )15, "red"}, 
        {(ColorType )16, "black"}, 
        {(ColorType )17, "gray"}, 
        {(ColorType )18, "red"}, 
        {(ColorType )19, "red"}, 
        {(ColorType )20, "black"}, 
        {(ColorType )21, "black"}, 
        {(ColorType )22, "gray"}, 
        {(ColorType )23, "black"}, 
        {(ColorType )24, "red"}, 
        {(ColorType )25, "red"}, 
        {(ColorType )26, "white"}, 
        {(ColorType )27, "black"}, 
        {(ColorType )38, "yellow"}, 
        {(ColorType )39, "black"}, 
        {(ColorType )40, "black"}, 
        {(ColorType )42, "black"}, 
        {(ColorType )41, "gray"}, 
        {(ColorType )44, "black"}, 
        {(ColorType )43, "gray"}, 
        {(ColorType )45, (char const   *)((void *)0)}};
#line 84 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static char **names  =    (char **)((void *)0);
#line 86 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static unsigned long redShift  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static unsigned long greenShift  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static unsigned long blueShift  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static unsigned long redMask  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static unsigned long greenMask  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static unsigned long blueMask  ;
#line 93
static void ComputeShiftMask(unsigned long maskIn , unsigned long *shiftOut , unsigned long *maskOut ) ;
#line 96
static void GetDirectPixel(XColor *c ) ;
#line 97
static void GetMappedPixel(XColor *c ) ;
#line 99
static void SetDefaultColor(ColorType type ) ;
#line 101
static unsigned long ReadHex(char const   *hex ) ;
#line 103
static unsigned long GetRGBFromXColor(XColor const   *c ) ;
#line 104
static XColor GetXColorFromRGB(unsigned long rgb ) ;
#line 106
static int GetColorByName(char const   *str___0 , XColor *c ) ;
#line 107
static void InitializeNames(void) ;
#line 109
static void LightenColor(ColorType oldColor , ColorType newColor ) ;
#line 110
static void DarkenColor(ColorType oldColor , ColorType newColor ) ;
#line 113 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
void InitializeColors(void) 
{ 


  {
#line 115
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
void StartupColors(void) 
{ 
  int x ;
  int red ;
  int green ;
  int blue ;
  XColor c ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 128
  if (rootVisual->class == 4) {
#line 128
    goto case_4;
  }
#line 128
  if (rootVisual->class == 5) {
#line 128
    goto case_4;
  }
#line 134
  goto switch_default;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 129
  ComputeShiftMask(rootVisual->red_mask, & redShift, & redMask);
#line 130
  ComputeShiftMask(rootVisual->green_mask, & greenShift, & greenMask);
#line 131
  ComputeShiftMask(rootVisual->blue_mask, & blueShift, & blueMask);
#line 132
  map = (unsigned long *)((void *)0);
  }
#line 133
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 137
  redMask = 224UL;
#line 138
  greenMask = 28UL;
#line 139
  blueMask = 3UL;
#line 140
  ComputeShiftMask(redMask, & redShift, & redMask);
#line 141
  ComputeShiftMask(greenMask, & greenShift, & greenMask);
#line 142
  ComputeShiftMask(blueMask, & blueShift, & blueMask);
#line 143
  tmp = malloc(sizeof(unsigned long ) * 256UL);
#line 143
  map = (unsigned long *)tmp;
#line 146
  x = 0;
#line 147
  red = 0;
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (red < 8)) {
#line 147
      goto while_break;
    }
#line 148
    green = 0;
    {
#line 148
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 148
      if (! (green < 8)) {
#line 148
        goto while_break___0;
      }
#line 149
      blue = 0;
      {
#line 149
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 149
        if (! (blue < 4)) {
#line 149
          goto while_break___1;
        }
        {
#line 150
        c.red = (unsigned short )((74898 * red) / 8);
#line 151
        c.green = (unsigned short )((74898 * green) / 8);
#line 152
        c.blue = (unsigned short )((87381 * blue) / 4);
#line 153
        c.flags = (char )((1 | (1 << 1)) | (1 << 2));
#line 154
        XAllocColor(display, rootColormap, & c);
#line 155
        *(map + x) = c.pixel;
#line 156
        x ++;
#line 149
        blue ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 148
      green ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 147
    red ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  tmp___0 = malloc(sizeof(unsigned long ) * 256UL);
#line 162
  rmap = (unsigned long *)tmp___0;
#line 163
  x = 0;
  }
  {
#line 163
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 163
    if (! (x < 256)) {
#line 163
      goto while_break___2;
    }
    {
#line 164
    c.pixel = (unsigned long )x;
#line 165
    XQueryColor(display, rootColormap, & c);
#line 166
    GetDirectPixel(& c);
#line 167
    *(rmap + x) = c.pixel;
#line 163
    x ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 170
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 174
  if (names) {
#line 176
    if (! *(names + 11)) {
      {
#line 177
      *(names + 11) = CopyString((char const   *)*(names + 8));
      }
    }
#line 179
    if (! *(names + 12)) {
      {
#line 180
      *(names + 12) = CopyString((char const   *)*(names + 8));
      }
    }
#line 183
    if (! *(names + 41)) {
      {
#line 184
      *(names + 41) = CopyString((char const   *)*(names + 8));
      }
    }
#line 186
    if (! *(names + 43)) {
      {
#line 187
      *(names + 43) = CopyString((char const   *)*(names + 8));
      }
    }
#line 189
    if (! *(names + 10)) {
      {
#line 190
      *(names + 10) = CopyString((char const   *)*(names + 9));
      }
    }
#line 192
    if (! *(names + 42)) {
      {
#line 193
      *(names + 42) = CopyString((char const   *)*(names + 9));
      }
    }
#line 195
    if (! *(names + 44)) {
      {
#line 196
      *(names + 44) = CopyString((char const   *)*(names + 9));
      }
    }
  }
#line 201
  x = 0;
  {
#line 201
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 201
    if (! (x < 45)) {
#line 201
      goto while_break___3;
    }
#line 202
    if (names) {
#line 202
      if (*(names + x)) {
        {
#line 203
        tmp___1 = ParseColor((char const   *)*(names + x), & c);
        }
#line 203
        if (tmp___1) {
          {
#line 204
          colors[x] = c.pixel;
#line 205
          rgbColors[x] = GetRGBFromXColor((XColor const   *)(& c));
          }
        } else {
          {
#line 207
          SetDefaultColor((ColorType )x);
          }
        }
      } else {
        {
#line 210
        SetDefaultColor((ColorType )x);
        }
      }
    } else {
      {
#line 210
      SetDefaultColor((ColorType )x);
      }
    }
#line 201
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 214
  if (names) {
#line 215
    x = 0;
    {
#line 215
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 215
      if (! (x < 45)) {
#line 215
        goto while_break___4;
      }
#line 216
      if (*(names + x)) {
        {
#line 217
        free((void *)*(names + x));
        }
      }
#line 215
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 220
    free((void *)names);
#line 221
    names = (char **)((void *)0);
    }
  }
  {
#line 224
  LightenColor((ColorType )8, (ColorType )28);
#line 225
  DarkenColor((ColorType )8, (ColorType )29);
#line 227
  LightenColor((ColorType )11, (ColorType )30);
#line 228
  DarkenColor((ColorType )11, (ColorType )31);
#line 230
  LightenColor((ColorType )14, (ColorType )32);
#line 231
  DarkenColor((ColorType )14, (ColorType )33);
#line 233
  LightenColor((ColorType )22, (ColorType )34);
#line 234
  DarkenColor((ColorType )22, (ColorType )35);
#line 236
  LightenColor((ColorType )24, (ColorType )36);
#line 237
  DarkenColor((ColorType )24, (ColorType )37);
  }
#line 239
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
void ShutdownColors(void) 
{ 


  {
#line 258
  if ((unsigned long )map != (unsigned long )((void *)0)) {
    {
#line 259
    XFreeColors(display, rootColormap, map, 256, 0UL);
#line 260
    free((void *)map);
#line 261
    map = (unsigned long *)((void *)0);
#line 262
    free((void *)rmap);
#line 263
    rmap = (unsigned long *)((void *)0);
    }
  }
#line 266
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
void DestroyColors(void) 
{ 
  int x ;

  {
#line 273
  if (names) {
#line 274
    x = 0;
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (! (x < 45)) {
#line 274
        goto while_break;
      }
#line 275
      if (*(names + x)) {
        {
#line 276
        free((void *)*(names + x));
        }
      }
#line 274
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 279
    free((void *)names);
#line 280
    names = (char **)((void *)0);
    }
  }
#line 283
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static void ComputeShiftMask(unsigned long maskIn , unsigned long *shiftOut , unsigned long *maskOut ) 
{ 
  int shift ;

  {
#line 300
  shift = 0;
#line 301
  *maskOut = maskIn;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (maskIn) {
#line 302
      if (! ((maskIn & (unsigned long )(1 << 31)) == 0UL)) {
#line 302
        goto while_break;
      }
    } else {
#line 302
      goto while_break;
    }
#line 303
    shift ++;
#line 304
    maskIn <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  *shiftOut = (unsigned long )shift;
#line 308
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static unsigned long GetRGBFromXColor(XColor const   *c ) 
{ 
  unsigned int red ;
  unsigned int green ;
  unsigned int blue ;
  unsigned long rgb ;

  {
#line 318
  if (((int const   )c->red + 128) >> 8 > 255) {
#line 318
    red = 255U;
  } else {
#line 318
    red = (unsigned int )(((int const   )c->red + 128) >> 8);
  }
#line 319
  if (((int const   )c->green + 128) >> 8 > 255) {
#line 319
    green = 255U;
  } else {
#line 319
    green = (unsigned int )(((int const   )c->green + 128) >> 8);
  }
#line 320
  if (((int const   )c->blue + 128) >> 8 > 255) {
#line 320
    blue = 255U;
  } else {
#line 320
    blue = (unsigned int )(((int const   )c->blue + 128) >> 8);
  }
#line 322
  rgb = (unsigned long )red << 16;
#line 323
  rgb |= (unsigned long )green << 8;
#line 324
  rgb |= (unsigned long )blue;
#line 326
  return (rgb);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static XColor GetXColorFromRGB(unsigned long rgb ) 
{ 
  XColor ret ;

  {
#line 333
  ret.pixel = 0UL;
#line 333
  ret.red = (unsigned short)0;
#line 333
  ret.green = (unsigned short)0;
#line 333
  ret.blue = (unsigned short)0;
#line 333
  ret.flags = (char)0;
#line 333
  ret.pad = (char)0;
#line 335
  ret.flags = (char )((1 | (1 << 1)) | (1 << 2));
#line 336
  ret.red = (unsigned short )(((rgb >> 16) & 255UL) * 257UL);
#line 337
  ret.green = (unsigned short )(((rgb >> 8) & 255UL) * 257UL);
#line 338
  ret.blue = (unsigned short )((rgb & 255UL) * 257UL);
#line 340
  return (ret);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
void SetColor(ColorType c , char const   *value ) 
{ 
  long tmp ;

  {
  {
#line 347
  tmp = __builtin_expect((long )(! (! (! value))), 0L);
  }
#line 347
  if (tmp) {
    {
#line 348
    Warning("empty color tag");
    }
#line 349
    return;
  }
  {
#line 352
  InitializeNames();
  }
#line 354
  if (*(names + c)) {
    {
#line 355
    free((void *)*(names + c));
    }
  }
  {
#line 358
  *(names + c) = CopyString(value);
  }
#line 360
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
int ParseColor(char const   *value , XColor *c ) 
{ 
  unsigned long rgb ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 367
  tmp = __builtin_expect((long )(! (! (! value))), 0L);
  }
#line 367
  if (tmp) {
#line 368
    return (0);
  }
#line 371
  if ((int const   )*(value + 0) == 35) {
    {
#line 371
    tmp___3 = strlen(value);
    }
#line 371
    if (tmp___3 == 7UL) {
      {
#line 372
      rgb = ReadHex(value + 1);
#line 373
      c->red = (unsigned short )(((rgb >> 16) & 255UL) * 257UL);
#line 374
      c->green = (unsigned short )(((rgb >> 8) & 255UL) * 257UL);
#line 375
      c->blue = (unsigned short )((rgb & 255UL) * 257UL);
#line 376
      c->flags = (char )((1 | (1 << 1)) | (1 << 2));
#line 377
      GetColor(c);
      }
    } else {
#line 371
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 379
    tmp___0 = GetColorByName(value, c);
    }
#line 379
    if (tmp___0) {
#line 379
      tmp___1 = 0;
    } else {
#line 379
      tmp___1 = 1;
    }
    {
#line 379
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 379
    if (tmp___2) {
      {
#line 380
      Warning("bad color: \"%s\"", value);
      }
#line 381
      return (0);
    }
  }
#line 385
  return (1);
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static void SetDefaultColor(ColorType type ) 
{ 
  XColor c ;
  int x ;

  {
#line 395
  x = 0;
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    if (! DEFAULT_COLORS[x].value) {
#line 395
      goto while_break;
    }
#line 396
    if ((unsigned int )DEFAULT_COLORS[x].type == (unsigned int )type) {
      {
#line 397
      ParseColor(DEFAULT_COLORS[x].value, & c);
#line 398
      colors[type] = c.pixel;
#line 399
      rgbColors[type] = GetRGBFromXColor((XColor const   *)(& c));
      }
#line 400
      return;
    }
#line 395
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  return;
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static void InitializeNames(void) 
{ 
  int x ;
  void *tmp ;

  {
#line 411
  if ((unsigned long )names == (unsigned long )((void *)0)) {
    {
#line 412
    tmp = malloc(sizeof(char *) * 45UL);
#line 412
    names = (char **)tmp;
#line 413
    x = 0;
    }
    {
#line 413
    while (1) {
      while_continue: /* CIL Label */ ;
#line 413
      if (! (x < 45)) {
#line 413
        goto while_break;
      }
#line 414
      *(names + x) = (char *)((void *)0);
#line 413
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 418
  return;
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static unsigned long ReadHex(char const   *hex ) 
{ 
  unsigned long value ;
  int x ;

  {
#line 423
  value = 0UL;
#line 428
  x = 0;
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! *(hex + x)) {
#line 428
      goto while_break;
    }
#line 429
    value *= 16UL;
#line 430
    if ((int const   )*(hex + x) >= 48) {
#line 430
      if ((int const   )*(hex + x) <= 57) {
#line 431
        value += (unsigned long )((int const   )*(hex + x) - 48);
      } else {
#line 430
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 432
    if ((int const   )*(hex + x) >= 65) {
#line 432
      if ((int const   )*(hex + x) <= 70) {
#line 433
        value += (unsigned long )(((int const   )*(hex + x) - 65) + 10);
      } else {
#line 432
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 434
    if ((int const   )*(hex + x) >= 97) {
#line 434
      if ((int const   )*(hex + x) <= 102) {
#line 435
        value += (unsigned long )(((int const   )*(hex + x) - 97) + 10);
      }
    }
#line 428
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 439
  return (value);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static void LightenColor(ColorType oldColor , ColorType newColor ) 
{ 
  XColor temp ;
  int red ;
  int green ;
  int blue ;

  {
  {
#line 449
  temp = GetXColorFromRGB(rgbColors[oldColor]);
#line 452
  red = (int )temp.red >> 8;
#line 453
  green = (int )temp.green >> 8;
#line 454
  blue = (int )temp.blue >> 8;
#line 457
  red = red * 371 >> 8;
#line 458
  green = green * 371 >> 8;
#line 459
  blue = blue * 371 >> 8;
#line 462
  red |= red << 8;
#line 463
  green |= green << 8;
#line 464
  blue |= blue << 8;
  }
#line 467
  if (65535 > red) {
#line 467
    red = red;
  } else {
#line 467
    red = 65535;
  }
#line 468
  if (65535 > green) {
#line 468
    green = green;
  } else {
#line 468
    green = 65535;
  }
#line 469
  if (65535 > blue) {
#line 469
    blue = blue;
  } else {
#line 469
    blue = 65535;
  }
  {
#line 471
  temp.red = (unsigned short )red;
#line 472
  temp.green = (unsigned short )green;
#line 473
  temp.blue = (unsigned short )blue;
#line 475
  GetColor(& temp);
#line 476
  colors[newColor] = temp.pixel;
#line 477
  rgbColors[newColor] = GetRGBFromXColor((XColor const   *)(& temp));
  }
#line 479
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static void DarkenColor(ColorType oldColor , ColorType newColor ) 
{ 
  XColor temp ;
  int red ;
  int green ;
  int blue ;

  {
  {
#line 487
  temp = GetXColorFromRGB(rgbColors[oldColor]);
#line 490
  red = (int )temp.red >> 8;
#line 491
  green = (int )temp.green >> 8;
#line 492
  blue = (int )temp.blue >> 8;
#line 495
  red = red * 141 >> 8;
#line 496
  green = green * 141 >> 8;
#line 497
  blue = blue * 141 >> 8;
#line 500
  red |= red << 8;
#line 501
  green |= green << 8;
#line 502
  blue |= blue << 8;
#line 504
  temp.red = (unsigned short )red;
#line 505
  temp.green = (unsigned short )green;
#line 506
  temp.blue = (unsigned short )blue;
#line 508
  GetColor(& temp);
#line 509
  colors[newColor] = temp.pixel;
#line 510
  rgbColors[newColor] = GetRGBFromXColor((XColor const   *)(& temp));
  }
#line 512
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static int GetColorByName(char const   *str___0 , XColor *c ) 
{ 
  int tmp ;

  {
  {
#line 520
  tmp = XParseColor(display, rootColormap, str___0, c);
  }
#line 520
  if (! tmp) {
#line 521
    return (0);
  }
  {
#line 524
  GetColor(c);
  }
#line 526
  return (1);
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
void GetColorFromIndex(XColor *c ) 
{ 
  unsigned long red ;
  unsigned long green ;
  unsigned long blue ;

  {
#line 539
  red = (c->pixel & redMask) << redShift;
#line 540
  green = (c->pixel & greenMask) << greenShift;
#line 541
  blue = (c->pixel & blueMask) << blueShift;
#line 543
  c->red = (unsigned short )(red >> 16);
#line 544
  c->green = (unsigned short )(green >> 16);
#line 545
  c->blue = (unsigned short )(blue >> 16);
#line 547
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static void GetDirectPixel(XColor *c ) 
{ 
  unsigned long red ;
  unsigned long green ;
  unsigned long blue ;

  {
#line 559
  red = (unsigned long )((int )c->red << 16);
#line 560
  green = (unsigned long )((int )c->green << 16);
#line 561
  blue = (unsigned long )((int )c->blue << 16);
#line 564
  red = (red >> redShift) & redMask;
#line 565
  green = (green >> greenShift) & greenMask;
#line 566
  blue = (blue >> blueShift) & blueMask;
#line 569
  c->pixel = (red | green) | blue;
#line 571
  return;
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
static void GetMappedPixel(XColor *c ) 
{ 


  {
  {
#line 578
  GetDirectPixel(c);
#line 579
  c->pixel = *(map + c->pixel);
  }
#line 581
  return;
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
void GetColor(XColor *c ) 
{ 


  {
  {
#line 591
  if (rootVisual->class == 4) {
#line 591
    goto case_4;
  }
#line 591
  if (rootVisual->class == 5) {
#line 591
    goto case_4;
  }
#line 594
  goto switch_default;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 592
  GetDirectPixel(c);
  }
#line 593
  return;
  switch_default: /* CIL Label */ 
  {
#line 595
  GetMappedPixel(c);
  }
#line 596
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 602 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
void GetColorFromPixel(XColor *c ) 
{ 


  {
  {
#line 608
  if (rootVisual->class == 4) {
#line 608
    goto case_4;
  }
#line 608
  if (rootVisual->class == 5) {
#line 608
    goto case_4;
  }
#line 611
  goto switch_default;
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 610
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 613
  c->pixel = *(rmap + (c->pixel & 255UL));
#line 614
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 618
  GetColorFromIndex(c);
  }
#line 620
  return;
}
}
#line 624 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/color.c"
void GetColorIndex(XColor *c ) 
{ 


  {
  {
#line 628
  GetDirectPixel(c);
  }
#line 630
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.h"
void InitializeScreens(void) ;
#line 25
void StartupScreens(void) ;
#line 26
void ShutdownScreens(void) ;
#line 27
void DestroyScreens(void) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.c"
static ScreenType *screens  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.c"
static int screenCount  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.c"
void InitializeScreens(void) 
{ 


  {
#line 24
  screens = (ScreenType *)((void *)0);
#line 25
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.c"
void StartupScreens(void) 
{ 
  void *tmp ;

  {
  {
#line 63
  screenCount = 1;
#line 64
  tmp = malloc(sizeof(ScreenType ));
#line 64
  screens = (ScreenType *)tmp;
#line 65
  screens->index = 0;
#line 66
  screens->x = 0;
#line 67
  screens->y = 0;
#line 68
  screens->width = rootWidth;
#line 69
  screens->height = rootHeight;
  }
#line 72
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.c"
void ShutdownScreens(void) 
{ 


  {
#line 76
  if (screens) {
    {
#line 77
    free((void *)screens);
#line 78
    screens = (ScreenType *)((void *)0);
    }
  }
#line 80
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.c"
void DestroyScreens(void) 
{ 


  {
#line 84
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.c"
ScreenType const   *GetCurrentScreen(int x , int y ) 
{ 
  ScreenType *sp ;
  int index ;

  {
#line 92
  index = 1;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (index < screenCount)) {
#line 92
      goto while_break;
    }
#line 93
    sp = screens + index;
#line 94
    if (x >= sp->x) {
#line 94
      if (x < sp->x + sp->width) {
#line 95
        if (y >= sp->y) {
#line 95
          if (y <= sp->y + sp->height) {
#line 96
            return ((ScreenType const   *)sp);
          }
        }
      }
    }
#line 92
    index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return ((ScreenType const   *)(screens + 0));
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.c"
ScreenType const   *GetMouseScreen(void) 
{ 


  {
#line 116
  return ((ScreenType const   *)(screens + 0));
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.c"
ScreenType const   *GetScreen(int index ) 
{ 


  {
#line 127
  return ((ScreenType const   *)(screens + index));
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/screen.c"
int GetScreenCount(void) 
{ 


  {
#line 134
  return (screenCount);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 1495 "/usr/include/X11/Xlib.h"
extern Display *XOpenDisplay(char const   * ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2519
extern int XFlush(Display * ) ;
#line 3251
extern int XSetGraphicsExposures(Display * , GC  , int  ) ;
#line 104 "/usr/include/X11/Xresource.h"
extern XrmQuark XrmUniqueQuark(void) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
Window rootWindow  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
int rootWidth  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
int rootHeight  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
int rootDepth  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
int rootScreen  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
Colormap rootColormap  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
Visual *rootVisual  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
GC rootGC  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
int colormapCount  ;
#line 29
char *exitCommand ;
#line 45 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
unsigned int doubleClickSpeed  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
unsigned int doubleClickDelta  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
XContext clientContext  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.h"
XContext frameContext  ;
#line 61
char *configPath ;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/help.h"
void DisplayAbout(void) ;
#line 20
void DisplayHelp(void) ;
#line 23
void DisplayUsage(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/error.h"
int ErrorHandler(Display *d , XErrorEvent *e ) ;
#line 138 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
void InitializeHints(void) ;
#line 139
void StartupHints(void) ;
#line 140
void ShutdownHints(void) ;
#line 141
void DestroyHints(void) ;
#line 144
void ReadCurrentDesktop(void) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.h"
void InitializeFonts(void) ;
#line 32
void StartupFonts(void) ;
#line 33
void ShutdownFonts(void) ;
#line 34
void DestroyFonts(void) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.h"
void InitializeGroups(void) ;
#line 39
void StartupGroups(void) ;
#line 40
void ShutdownGroups(void) ;
#line 41
void DestroyGroups(void) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.h"
void InitializeKeys(void) ;
#line 51
void StartupKeys(void) ;
#line 52
void ShutdownKeys(void) ;
#line 53
void DestroyKeys(void) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.h"
void InitializeTaskBar(void) ;
#line 18
void StartupTaskBar(void) ;
#line 19
void ShutdownTaskBar(void) ;
#line 20
void DestroyTaskBar(void) ;
#line 145 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
void InitializeTray(void) ;
#line 146
void StartupTray(void) ;
#line 147
void ShutdownTray(void) ;
#line 148
void DestroyTray(void) ;
#line 180
void DrawTray(void) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.h"
void InitializeTrayButtons(void) ;
#line 18
void StartupTrayButtons(void) ;
#line 19
void ShutdownTrayButtons(void) ;
#line 20
void DestroyTrayButtons(void) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.h"
void InitializeRootMenu(void) ;
#line 17
void StartupRootMenu(void) ;
#line 18
void ShutdownRootMenu(void) ;
#line 19
void DestroyRootMenu(void) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
Display *display  =    (Display *)((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
char shouldExit  =    (char)0;
#line 56 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
char shouldRestart  =    (char)0;
#line 57 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
char isRestarting  =    (char)0;
#line 58 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
char initializing  =    (char)0;
#line 59 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
char shouldReload  =    (char)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
unsigned int desktopWidth  =    4U;
#line 62 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
unsigned int desktopHeight  =    1U;
#line 63 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
unsigned int desktopCount  =    4U;
#line 64 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
unsigned int currentDesktop  =    0U;
#line 66 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
char *exitCommand  =    (char *)((void *)0);
#line 68 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
int borderWidth  =    4;
#line 69 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
int titleHeight  =    20;
#line 74 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
FocusModelType focusModel  =    (FocusModelType )0;
#line 87 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static char const   *CONFIG_FILE  =    "/.jwmrc";
#line 89
static void Initialize(void) ;
#line 90
static void Startup(void) ;
#line 91
static void Shutdown(void) ;
#line 92
static void Destroy___1(void) ;
#line 94
static void OpenConnection(void) ;
#line 95
static void CloseConnection(void) ;
#line 96
static void StartupConnection(void) ;
#line 97
static void ShutdownConnection(void) ;
#line 98
static void EventLoop(void) ;
#line 99
static void HandleExit(int sig ) ;
#line 100
static void DoExit(int code ) ;
#line 101
static void SendRestart(void) ;
#line 102
static void SendExit(void) ;
#line 103
static void SendReload(void) ;
#line 104
static void SendJWMMessage(char const   *message ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static char *displayString  =    (char *)((void *)0);
#line 108 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
char *configPath  =    (char *)((void *)0);
#line 111 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
int main(int argc , char **argv ) 
{ 
  char *temp ;
  int x ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 119
  temp = getenv("HOME");
  }
#line 120
  if (temp) {
    {
#line 121
    tmp = strlen((char const   *)temp);
#line 121
    tmp___0 = strlen(CONFIG_FILE);
#line 121
    tmp___1 = malloc((tmp + tmp___0) + 1UL);
#line 121
    configPath = (char *)tmp___1;
#line 122
    strcpy((char */* __restrict  */)configPath, (char const   */* __restrict  */)temp);
#line 123
    strcat((char */* __restrict  */)configPath, (char const   */* __restrict  */)CONFIG_FILE);
    }
  } else {
    {
#line 125
    configPath = CopyString(CONFIG_FILE);
    }
  }
#line 129
  x = 1;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (x < argc)) {
#line 129
      goto while_break;
    }
    {
#line 130
    tmp___8 = strcmp((char const   *)*(argv + x), "-v");
    }
#line 130
    if (tmp___8) {
      {
#line 133
      tmp___7 = strcmp((char const   *)*(argv + x), "-h");
      }
#line 133
      if (tmp___7) {
        {
#line 136
        tmp___6 = strcmp((char const   *)*(argv + x), "-p");
        }
#line 136
        if (tmp___6) {
          {
#line 140
          tmp___5 = strcmp((char const   *)*(argv + x), "-restart");
          }
#line 140
          if (tmp___5) {
            {
#line 143
            tmp___4 = strcmp((char const   *)*(argv + x), "-exit");
            }
#line 143
            if (tmp___4) {
              {
#line 146
              tmp___3 = strcmp((char const   *)*(argv + x), "-reload");
              }
#line 146
              if (tmp___3) {
                {
#line 149
                tmp___2 = strcmp((char const   *)*(argv + x), "-display");
                }
#line 149
                if (tmp___2) {
                  {
#line 152
                  DisplayUsage();
#line 153
                  DoExit(1);
                  }
                } else
#line 149
                if (x + 1 < argc) {
#line 150
                  x ++;
#line 150
                  displayString = *(argv + x);
                } else {
                  {
#line 152
                  DisplayUsage();
#line 153
                  DoExit(1);
                  }
                }
              } else {
                {
#line 147
                SendReload();
#line 148
                DoExit(0);
                }
              }
            } else {
              {
#line 144
              SendExit();
#line 145
              DoExit(0);
              }
            }
          } else {
            {
#line 141
            SendRestart();
#line 142
            DoExit(0);
            }
          }
        } else {
          {
#line 137
          Initialize();
#line 138
          ParseConfig((char const   *)configPath);
#line 139
          DoExit(0);
          }
        }
      } else {
        {
#line 134
        DisplayHelp();
#line 135
        DoExit(0);
        }
      }
    } else {
      {
#line 131
      DisplayAbout();
#line 132
      DoExit(0);
      }
    }
#line 129
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  setlocale(6, "");
#line 161
  bindtextdomain("jwm", "/usr/local/share/locale");
#line 162
  textdomain("jwm");
#line 166
  StartupConnection();
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 169
    isRestarting = shouldRestart;
#line 170
    shouldExit = (char)0;
#line 171
    shouldRestart = (char)0;
#line 172
    shouldReload = (char)0;
#line 175
    Initialize();
#line 178
    ParseConfig((char const   *)configPath);
#line 181
    Startup();
#line 184
    EventLoop();
#line 187
    Shutdown();
#line 190
    Destroy___1();
    }
#line 167
    if (! shouldRestart) {
#line 167
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 193
  ShutdownConnection();
  }
#line 196
  if (exitCommand) {
    {
#line 197
    execl("/bin/sh", "/bin/sh", "-c", exitCommand, (void *)0);
#line 198
    tmp___9 = gettext("exec failed: (%s) %s");
#line 198
    Warning((char const   *)tmp___9, "/bin/sh", exitCommand);
#line 199
    DoExit(1);
    }
  } else {
    {
#line 201
    DoExit(0);
    }
  }
#line 205
  return (-1);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void DoExit(int code ) 
{ 


  {
  {
#line 212
  Destroy___1();
  }
#line 214
  if (configPath) {
    {
#line 215
    free((void *)configPath);
#line 216
    configPath = (char *)((void *)0);
    }
  }
#line 218
  if (exitCommand) {
    {
#line 219
    free((void *)exitCommand);
#line 220
    exitCommand = (char *)((void *)0);
    }
  }
  {
#line 224
  exit(code);
  }
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void EventLoop(void) 
{ 
  XEvent event ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp = __builtin_expect((long )(! (! (! shouldExit))), 1L);
    }
#line 233
    if (! tmp) {
#line 233
      goto while_break;
    }
    {
#line 234
    WaitForEvent(& event);
#line 235
    ProcessEvent(& event);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  usleep((__useconds_t )50000);
  }
  {
#line 242
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 242
    tmp___0 = XPending(display);
    }
#line 242
    if (! (tmp___0 > 0)) {
#line 242
      goto while_break___0;
    }
    {
#line 243
    WaitForEvent(& event);
#line 244
    ProcessEvent(& event);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void OpenConnection(void) 
{ 
  long tmp ;

  {
  {
#line 252
  display = XOpenDisplay((char const   *)displayString);
#line 253
  tmp = __builtin_expect((long )(! (! (! display))), 0L);
  }
#line 253
  if (tmp) {
#line 254
    if (displayString) {
      {
#line 255
      printf((char const   */* __restrict  */)"error: could not open display %s\n",
             displayString);
      }
    } else {
      {
#line 257
      printf((char const   */* __restrict  */)"error: could not open display\n");
      }
    }
    {
#line 259
    DoExit(1);
    }
  }
  {
#line 262
  rootScreen = ((_XPrivDisplay )display)->default_screen;
#line 263
  rootWindow = (((_XPrivDisplay )display)->screens + rootScreen)->root;
#line 264
  rootWidth = (((_XPrivDisplay )display)->screens + rootScreen)->width;
#line 265
  rootHeight = (((_XPrivDisplay )display)->screens + rootScreen)->height;
#line 266
  rootDepth = (((_XPrivDisplay )display)->screens + rootScreen)->root_depth;
#line 267
  rootColormap = (((_XPrivDisplay )display)->screens + rootScreen)->cmap;
#line 268
  rootVisual = (((_XPrivDisplay )display)->screens + rootScreen)->root_visual;
#line 269
  rootGC = (((_XPrivDisplay )display)->screens + rootScreen)->default_gc;
#line 270
  colormapCount = (((_XPrivDisplay )display)->screens + rootScreen)->max_maps;
#line 272
  XSetGraphicsExposures(display, rootGC, 0);
  }
#line 275
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void StartupConnection(void) 
{ 
  XSetWindowAttributes attr ;
  struct sigaction sa ;
  XrmQuark tmp ;
  XrmQuark tmp___0 ;

  {
  {
#line 290
  initializing = (char)1;
#line 291
  OpenConnection();
#line 297
  XSetErrorHandler(& ErrorHandler);
#line 299
  tmp = XrmUniqueQuark();
#line 299
  clientContext = tmp;
#line 300
  tmp___0 = XrmUniqueQuark();
#line 300
  frameContext = tmp___0;
#line 306
  attr.event_mask = ((((((((1L << 20) | (1L << 19)) | (1L << 17)) | (1L << 22)) | (1L << 23)) | (1L << 2)) | (1L << 3)) | (1L << 6)) | (1L << 7);
#line 315
  XChangeWindowAttributes(display, rootWindow, (unsigned long )(1L << 11), & attr);
#line 317
  memset((void *)(& sa), 0, sizeof(sa));
#line 318
  sa.sa_flags = 0;
#line 319
  sa.__sigaction_handler.sa_handler = & HandleExit;
#line 320
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 321
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 322
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 324
  sa.sa_flags = 2;
#line 325
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 326
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 346
  initializing = (char)0;
  }
#line 348
  return;
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void CloseConnection(void) 
{ 


  {
  {
#line 352
  XFlush(display);
#line 353
  XCloseDisplay(display);
  }
#line 354
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void ShutdownConnection(void) 
{ 


  {
  {
#line 358
  CloseConnection();
  }
#line 359
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void HandleExit(int sig ) 
{ 


  {
#line 363
  shouldExit = (char)1;
#line 364
  return;
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void Initialize(void) 
{ 


  {
  {
#line 371
  InitializeBackgrounds();
#line 372
  InitializeBorders();
#line 373
  InitializeClients();
#line 374
  InitializeClock();
#line 375
  InitializeColors();
#line 376
  InitializeCommands();
#line 377
  InitializeCursors();
#line 378
  InitializeDesktops();
#line 380
  InitializeDialogs();
#line 382
  InitializeDock();
#line 383
  InitializeFonts();
#line 384
  InitializeGroups();
#line 385
  InitializeHints();
#line 386
  InitializeIcons();
#line 387
  InitializeKeys();
#line 388
  InitializeOutline();
#line 389
  InitializePager();
#line 390
  InitializePlacement();
#line 391
  InitializePopup();
#line 392
  InitializeRootMenu();
#line 393
  InitializeScreens();
#line 394
  InitializeSwallow();
#line 395
  InitializeTaskBar();
#line 396
  InitializeTray();
#line 397
  InitializeTrayButtons();
  }
#line 398
  return;
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void Startup(void) 
{ 


  {
  {
#line 407
  StartupCommands();
#line 411
  XGrabServer(display);
#line 413
  StartupScreens();
#line 415
  StartupGroups();
#line 416
  StartupColors();
#line 417
  StartupIcons();
#line 418
  StartupBackgrounds();
#line 419
  StartupFonts();
#line 420
  StartupCursors();
#line 421
  StartupOutline();
#line 423
  StartupPager();
#line 424
  StartupClock();
#line 425
  StartupTaskBar();
#line 426
  StartupTrayButtons();
#line 427
  StartupDock();
#line 428
  StartupTray();
#line 429
  StartupKeys();
#line 430
  StartupDesktops();
#line 431
  StartupHints();
#line 432
  StartupBorders();
#line 433
  StartupPlacement();
#line 434
  StartupClients();
#line 437
  StartupDialogs();
#line 439
  StartupPopup();
#line 441
  StartupRootMenu();
#line 443
  SetDefaultCursor(rootWindow);
#line 444
  ReadCurrentDesktop();
#line 445
  XFlush(display);
#line 447
  RestackClients();
#line 450
  XSync(display, 1);
#line 451
  XUngrabServer(display);
#line 453
  StartupSwallow();
#line 455
  DrawTray();
#line 458
  ExposeCurrentDesktop();
#line 461
  LoadBackground((int )currentDesktop);
  }
#line 463
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void Shutdown(void) 
{ 


  {
  {
#line 472
  ShutdownSwallow();
#line 474
  ShutdownOutline();
#line 476
  ShutdownDialogs();
#line 478
  ShutdownPopup();
#line 479
  ShutdownKeys();
#line 480
  ShutdownPager();
#line 481
  ShutdownRootMenu();
#line 482
  ShutdownDock();
#line 483
  ShutdownTray();
#line 484
  ShutdownTrayButtons();
#line 485
  ShutdownTaskBar();
#line 486
  ShutdownClock();
#line 487
  ShutdownBorders();
#line 488
  ShutdownClients();
#line 489
  ShutdownBackgrounds();
#line 490
  ShutdownIcons();
#line 491
  ShutdownCursors();
#line 492
  ShutdownFonts();
#line 493
  ShutdownColors();
#line 494
  ShutdownGroups();
#line 495
  ShutdownDesktops();
#line 497
  ShutdownPlacement();
#line 498
  ShutdownHints();
#line 499
  ShutdownScreens();
#line 501
  ShutdownCommands();
  }
#line 503
  return;
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void Destroy___1(void) 
{ 


  {
  {
#line 510
  DestroyBackgrounds();
#line 511
  DestroyBorders();
#line 512
  DestroyClients();
#line 513
  DestroyClock();
#line 514
  DestroyColors();
#line 515
  DestroyCommands();
#line 516
  DestroyCursors();
#line 517
  DestroyDesktops();
#line 519
  DestroyDialogs();
#line 521
  DestroyDock();
#line 522
  DestroyFonts();
#line 523
  DestroyGroups();
#line 524
  DestroyHints();
#line 525
  DestroyIcons();
#line 526
  DestroyKeys();
#line 527
  DestroyOutline();
#line 528
  DestroyPager();
#line 529
  DestroyPlacement();
#line 530
  DestroyPopup();
#line 531
  DestroyRootMenu();
#line 532
  DestroyScreens();
#line 533
  DestroySwallow();
#line 534
  DestroyTaskBar();
#line 535
  DestroyTray();
#line 536
  DestroyTrayButtons();
  }
#line 537
  return;
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void SendRestart(void) 
{ 


  {
  {
#line 541
  SendJWMMessage("_JWM_RESTART");
  }
#line 542
  return;
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void SendExit(void) 
{ 


  {
  {
#line 546
  SendJWMMessage("_JWM_EXIT");
  }
#line 547
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void SendReload(void) 
{ 


  {
  {
#line 551
  SendJWMMessage("_JWM_RELOAD");
  }
#line 552
  return;
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/main.c"
static void SendJWMMessage(char const   *message ) 
{ 
  XEvent event ;

  {
  {
#line 559
  OpenConnection();
#line 561
  memset((void *)(& event), 0, sizeof(event));
#line 562
  event.xclient.type = 33;
#line 563
  event.xclient.window = rootWindow;
#line 564
  event.xclient.message_type = XInternAtom(display, message, 0);
#line 565
  event.xclient.format = 32;
#line 567
  XSendEvent(display, rootWindow, 0, 1L << 20, & event);
#line 569
  CloseConnection();
  }
#line 571
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static int const   BLOCK_SIZE  =    (int const   )16;
#line 22 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static char const   *TOKEN_MAP[71]  = 
#line 22
  {      "[invalid]",      "Active",      "ActiveBackground",      "ActiveForeground", 
        "Background",      "Border",      "ButtonClose",      "ButtonMax", 
        "ButtonMaxActive",      "ButtonMin",      "Class",      "Clock", 
        "ClockStyle",      "Close",      "Desktops",      "Desktop", 
        "Dock",      "DoubleClickSpeed",      "DoubleClickDelta",      "Exit", 
        "FocusModel",      "Font",      "Foreground",      "Group", 
        "Height",      "IconPath",      "Inactive",      "Include", 
        "JWM",      "Key",      "Kill",      "Layer", 
        "Maximize",      "Menu",      "MenuStyle",      "Minimize", 
        "Move",      "MoveMode",      "Name",      "Opacity", 
        "Option",      "Outline",      "Pager",      "PagerStyle", 
        "Popup",      "PopupStyle",      "Program",      "Resize", 
        "ResizeMode",      "Restart",      "RestartCommand",      "RootMenu", 
        "SendTo",      "Separator",      "Shade",      "ShutdownCommand", 
        "SnapMode",      "Spacer",      "StartupCommand",      "Stick", 
        "Swallow",      "TaskListStyle",      "TaskList",      "Text", 
        "Title",      "Tray",      "TrayButton",      "TrayButtonStyle", 
        "TrayStyle",      "Width",      "WindowStyle"};
#line 96 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static TokenNode *head  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static TokenNode *current  ;
#line 98
static TokenNode *CreateNode(TokenNode *parent , char const   *file , int line ) ;
#line 99
static AttributeNode *CreateAttribute(TokenNode *np ) ;
#line 101
static int IsElementEnd(char ch ) ;
#line 102
static int IsValueEnd(char ch ) ;
#line 103
static int IsAttributeEnd(char ch ) ;
#line 104
static int IsSpace(char ch , int *lineNumber ) ;
#line 105
static char *ReadElementName(char const   *line ) ;
#line 106
static char *ReadElementValue(char const   *line , char const   *file , int *lineNumber ) ;
#line 108
static char *ReadAttributeValue(char const   *line , char const   *file , int *lineNumber ) ;
#line 110
static int ParseEntity(char const   *entity , char *ch , char const   *file , int line ) ;
#line 112
static TokenType LookupType(char const   *name , TokenNode *np ) ;
#line 115 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
TokenNode *Tokenize(char const   *line , char const   *fileName ) 
{ 
  TokenNode *np ;
  AttributeNode *ap ;
  char *temp ;
  int inElement ;
  int x ;
  int found ;
  int lineNumber ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  TokenType tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  char *tmp___10 ;
  long tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  long tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  long tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  void *tmp___26 ;
  char *tmp___27 ;
  long tmp___28 ;

  {
#line 125
  head = (TokenNode *)((void *)0);
#line 126
  current = (TokenNode *)((void *)0);
#line 127
  inElement = 0;
#line 128
  lineNumber = 1;
#line 130
  x = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    tmp = IsSpace((char )*(line + x), & lineNumber);
    }
#line 132
    if (! tmp) {
#line 132
      goto while_break;
    }
#line 132
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  tmp___1 = strncmp(line + x, "<?", (size_t )2);
  }
#line 135
  if (! tmp___1) {
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! *(line + x)) {
#line 136
        goto while_break___0;
      }
#line 137
      if ((int const   )*(line + x) == 10) {
#line 138
        lineNumber ++;
      }
      {
#line 140
      tmp___0 = strncmp(line + x, "?>", (size_t )2);
      }
#line 140
      if (! tmp___0) {
#line 141
        x += 2;
#line 142
        goto while_break___0;
      }
#line 144
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 148
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 148
    if (! *(line + x)) {
#line 148
      goto while_break___1;
    }
    {
#line 150
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 152
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 152
        tmp___2 = IsSpace((char )*(line + x), & lineNumber);
        }
#line 152
        if (! tmp___2) {
#line 152
          goto while_break___3;
        }
#line 152
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 155
      found = 0;
#line 156
      tmp___4 = strncmp(line + x, "<!--", (size_t )4);
      }
#line 156
      if (! tmp___4) {
        {
#line 157
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 157
          if (! *(line + x)) {
#line 157
            goto while_break___4;
          }
#line 158
          if ((int const   )*(line + x) == 10) {
#line 159
            lineNumber ++;
          }
          {
#line 161
          tmp___3 = strncmp(line + x, "-->", (size_t )3);
          }
#line 161
          if (! tmp___3) {
#line 162
            x += 3;
#line 163
            found = 1;
#line 164
            goto while_break___4;
          }
#line 166
          x ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 150
      if (! found) {
#line 150
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 172
    if ((int const   )*(line + x) == 60) {
#line 172
      goto case_60;
    }
#line 224
    if ((int const   )*(line + x) == 47) {
#line 224
      goto case_47;
    }
#line 238
    if ((int const   )*(line + x) == 62) {
#line 238
      goto case_62;
    }
#line 242
    goto ReadDefault;
    case_60: /* CIL Label */ 
#line 173
    x ++;
#line 174
    if ((int const   )*(line + x) == 47) {
      {
#line 175
      x ++;
#line 176
      temp = ReadElementName(line + x);
      }
#line 178
      if (current) {
        {
#line 180
        tmp___11 = __builtin_expect((long )(! (! temp)), 1L);
        }
#line 180
        if (tmp___11) {
          {
#line 182
          tmp___7 = LookupType((char const   *)temp, (TokenNode *)((void *)0));
          }
#line 182
          if ((unsigned int )current->type != (unsigned int )tmp___7) {
#line 182
            tmp___8 = 1;
          } else {
#line 182
            tmp___8 = 0;
          }
          {
#line 182
          tmp___9 = __builtin_expect((long )tmp___8, 0L);
          }
#line 182
          if (tmp___9) {
            {
#line 183
            tmp___5 = GetTokenName((TokenNode const   *)current);
#line 183
            tmp___6 = gettext("%s[%d]: close tag \"%s\" does not match open tag \"%s\"");
#line 183
            Warning((char const   *)tmp___6, fileName, lineNumber, temp, tmp___5);
            }
          }
        } else {
          {
#line 190
          tmp___10 = gettext("%s[%d]: unexpected and invalid close tag");
#line 190
          Warning((char const   *)tmp___10, fileName, lineNumber);
          }
        }
#line 194
        current = current->parent;
      } else
#line 196
      if (temp) {
        {
#line 197
        tmp___12 = gettext("%s[%d]: close tag \"%s\" without open tag");
#line 197
        Warning((char const   *)tmp___12, fileName, lineNumber, temp);
        }
      } else {
        {
#line 200
        tmp___13 = gettext("%s[%d]: invalid close tag");
#line 200
        Warning((char const   *)tmp___13, fileName, lineNumber);
        }
      }
#line 204
      if (temp) {
        {
#line 205
        tmp___14 = strlen((char const   *)temp);
#line 205
        x = (int )((size_t )x + tmp___14);
#line 206
        free((void *)temp);
        }
      }
    } else {
      {
#line 210
      np = current;
#line 211
      current = (TokenNode *)((void *)0);
#line 212
      np = CreateNode(np, fileName, lineNumber);
#line 213
      temp = ReadElementName(line + x);
#line 214
      tmp___17 = __builtin_expect((long )(! (! temp)), 1L);
      }
#line 214
      if (tmp___17) {
        {
#line 215
        tmp___15 = strlen((char const   *)temp);
#line 215
        x = (int )((size_t )x + tmp___15);
#line 216
        LookupType((char const   *)temp, np);
#line 217
        free((void *)temp);
        }
      } else {
        {
#line 219
        tmp___16 = gettext("%s[%d]: invalid open tag");
#line 219
        Warning((char const   *)tmp___16, fileName, lineNumber);
        }
      }
    }
#line 222
    inElement = 1;
#line 223
    goto switch_break;
    case_47: /* CIL Label */ 
#line 225
    if (inElement) {
#line 226
      x ++;
#line 227
      if ((int const   )*(line + x) == 62) {
#line 227
        if (current) {
#line 227
          tmp___19 = 1;
        } else {
#line 227
          tmp___19 = 0;
        }
      } else {
#line 227
        tmp___19 = 0;
      }
      {
#line 227
      tmp___20 = __builtin_expect((long )tmp___19, 1L);
      }
#line 227
      if (tmp___20) {
#line 228
        x ++;
#line 229
        current = current->parent;
#line 230
        inElement = 0;
      } else {
        {
#line 232
        tmp___18 = gettext("%s[%d]: invalid tag");
#line 232
        Warning((char const   *)tmp___18, fileName, lineNumber);
        }
      }
    } else {
#line 235
      goto ReadDefault;
    }
#line 237
    goto switch_break;
    case_62: /* CIL Label */ 
#line 239
    x ++;
#line 240
    inElement = 0;
#line 241
    goto switch_break;
    ReadDefault: 
    switch_default: /* CIL Label */ 
#line 244
    if (inElement) {
      {
#line 245
      ap = CreateAttribute(current);
#line 246
      ap->name = ReadElementName(line + x);
      }
#line 247
      if (ap->name) {
        {
#line 248
        tmp___21 = strlen((char const   *)ap->name);
#line 248
        x = (int )((size_t )x + tmp___21);
        }
#line 249
        if ((int const   )*(line + x) == 61) {
#line 250
          x ++;
        }
#line 252
        if ((int const   )*(line + x) == 34) {
#line 253
          x ++;
        }
        {
#line 255
        ap->value = ReadAttributeValue(line + x, fileName, & lineNumber);
        }
#line 257
        if (ap->value) {
          {
#line 258
          tmp___22 = strlen((char const   *)ap->value);
#line 258
          x = (int )((size_t )x + tmp___22);
          }
        }
#line 260
        if ((int const   )*(line + x) == 34) {
#line 261
          x ++;
        }
      }
    } else {
      {
#line 265
      temp = ReadElementValue(line + x, fileName, & lineNumber);
      }
#line 266
      if (temp) {
        {
#line 267
        tmp___23 = strlen((char const   *)temp);
#line 267
        x = (int )((size_t )x + tmp___23);
        }
#line 268
        if (current) {
#line 269
          if (current->value) {
            {
#line 270
            tmp___24 = strlen((char const   *)current->value);
#line 270
            tmp___25 = strlen((char const   *)temp);
#line 270
            tmp___26 = realloc((void *)current->value, (tmp___24 + tmp___25) + 1UL);
#line 270
            current->value = (char *)tmp___26;
#line 272
            strcat((char */* __restrict  */)current->value, (char const   */* __restrict  */)temp);
#line 273
            free((void *)temp);
            }
          } else {
#line 275
            current->value = temp;
          }
        } else {
          {
#line 278
          tmp___28 = __builtin_expect((long )(! (! *(temp + 0))), 0L);
          }
#line 278
          if (tmp___28) {
            {
#line 279
            tmp___27 = gettext("%s[%d]: unexpected text: \"%s\"");
#line 279
            Warning((char const   *)tmp___27, fileName, lineNumber, temp);
            }
          }
          {
#line 282
          free((void *)temp);
          }
        }
      }
    }
#line 286
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 290
  return (head);
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static int ParseEntity(char const   *entity , char *ch , char const   *file , int line ) 
{ 
  char *temp ;
  int x ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 301
  tmp___5 = strncmp("&quot;", entity, (size_t )6);
  }
#line 301
  if (tmp___5) {
    {
#line 304
    tmp___4 = strncmp("&lt;", entity, (size_t )4);
    }
#line 304
    if (tmp___4) {
      {
#line 307
      tmp___3 = strncmp("&gt;", entity, (size_t )4);
      }
#line 307
      if (tmp___3) {
        {
#line 310
        tmp___2 = strncmp("&amp;", entity, (size_t )5);
        }
#line 310
        if (tmp___2) {
          {
#line 313
          tmp___1 = strncmp("&apos;", entity, (size_t )6);
          }
#line 313
          if (tmp___1) {
#line 317
            x = 0;
            {
#line 317
            while (1) {
              while_continue: /* CIL Label */ ;
#line 317
              if (! *(entity + x)) {
#line 317
                goto while_break;
              }
#line 318
              if ((int const   )*(entity + x) == 59) {
#line 319
                goto while_break;
              }
#line 317
              x ++;
            }
            while_break: /* CIL Label */ ;
            }
            {
#line 322
            tmp = __builtin_alloca((unsigned long )(x + 2));
#line 322
            temp = (char *)tmp;
#line 323
            strncpy((char */* __restrict  */)temp, (char const   */* __restrict  */)entity,
                    (size_t )(x + 1));
#line 324
            *(temp + (x + 1)) = (char)0;
#line 325
            tmp___0 = gettext("%s[%d]: invalid entity: \"%.8s\"");
#line 325
            Warning((char const   *)tmp___0, file, line, temp);
#line 327
            *ch = (char )'&';
            }
#line 328
            return (1);
          } else {
#line 314
            *ch = (char )'\'';
#line 315
            return (6);
          }
        } else {
#line 311
          *ch = (char )'&';
#line 312
          return (5);
        }
      } else {
#line 308
        *ch = (char )'>';
#line 309
        return (4);
      }
    } else {
#line 305
      *ch = (char )'<';
#line 306
      return (4);
    }
  } else {
#line 302
    *ch = (char )'\"';
#line 303
    return (6);
  }
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static int IsElementEnd(char ch ) 
{ 


  {
  {
#line 344
  if ((int )ch == 0) {
#line 344
    goto case_0;
  }
#line 344
  if ((int )ch == 61) {
#line 344
    goto case_0;
  }
#line 344
  if ((int )ch == 47) {
#line 344
    goto case_0;
  }
#line 344
  if ((int )ch == 60) {
#line 344
    goto case_0;
  }
#line 344
  if ((int )ch == 62) {
#line 344
    goto case_0;
  }
#line 344
  if ((int )ch == 34) {
#line 344
    goto case_0;
  }
#line 344
  if ((int )ch == 13) {
#line 344
    goto case_0;
  }
#line 344
  if ((int )ch == 10) {
#line 344
    goto case_0;
  }
#line 344
  if ((int )ch == 9) {
#line 344
    goto case_0;
  }
#line 344
  if ((int )ch == 32) {
#line 344
    goto case_0;
  }
#line 346
  goto switch_default;
  case_0: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 345
  return (1);
  switch_default: /* CIL Label */ 
#line 347
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static int IsAttributeEnd(char ch ) 
{ 


  {
  {
#line 355
  if ((int )ch == 34) {
#line 355
    goto case_34;
  }
#line 355
  if ((int )ch == 0) {
#line 355
    goto case_34;
  }
#line 357
  goto switch_default;
  case_34: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 356
  return (1);
  switch_default: /* CIL Label */ 
#line 358
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static int IsValueEnd(char ch ) 
{ 


  {
  {
#line 366
  if ((int )ch == 60) {
#line 366
    goto case_60;
  }
#line 366
  if ((int )ch == 0) {
#line 366
    goto case_60;
  }
#line 368
  goto switch_default;
  case_60: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 367
  return (1);
  switch_default: /* CIL Label */ 
#line 369
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static int IsSpace(char ch , int *lineNumber ) 
{ 


  {
  {
#line 378
  if ((int )ch == 13) {
#line 378
    goto case_13;
  }
#line 378
  if ((int )ch == 9) {
#line 378
    goto case_13;
  }
#line 378
  if ((int )ch == 32) {
#line 378
    goto case_13;
  }
#line 380
  if ((int )ch == 10) {
#line 380
    goto case_10;
  }
#line 383
  goto switch_default;
  case_13: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 379
  return (1);
  case_10: /* CIL Label */ 
#line 381
  (*lineNumber) ++;
#line 382
  return (1);
  switch_default: /* CIL Label */ 
#line 384
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static char *ReadElementName(char const   *line ) 
{ 
  char *buffer ;
  int len ;
  int tmp ;
  void *tmp___0 ;

  {
#line 395
  len = 0;
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 395
    tmp = IsElementEnd((char )*(line + len));
    }
#line 395
    if (tmp) {
#line 395
      goto while_break;
    }
#line 395
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 398
  tmp___0 = malloc((size_t )(len + 1));
#line 398
  buffer = (char *)tmp___0;
#line 399
  memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)line, (size_t )len);
#line 400
  *(buffer + len) = (char)0;
  }
#line 402
  return (buffer);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static char *ReadElementValue(char const   *line , char const   *file , int *lineNumber ) 
{ 
  char *buffer ;
  char ch ;
  int len ;
  int max ;
  int x ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 413
  len = 0;
#line 414
  max = (int )BLOCK_SIZE;
#line 415
  tmp = malloc((size_t )(max + 1));
#line 415
  buffer = (char *)tmp;
#line 417
  x = 0;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 417
    tmp___2 = IsValueEnd((char )*(line + x));
    }
#line 417
    if (tmp___2) {
#line 417
      goto while_break;
    }
#line 418
    if ((int const   )*(line + x) == 38) {
      {
#line 419
      tmp___0 = ParseEntity(line + x, & ch, file, *lineNumber);
#line 419
      x += tmp___0 - 1;
      }
#line 420
      if (ch) {
#line 421
        *(buffer + len) = ch;
      } else {
#line 423
        *(buffer + len) = (char )*(line + x);
      }
    } else {
#line 426
      if ((int const   )*(line + x) == 10) {
#line 427
        (*lineNumber) ++;
      }
#line 429
      *(buffer + len) = (char )*(line + x);
    }
#line 431
    len ++;
#line 432
    if (len >= max) {
      {
#line 433
      max += (int )BLOCK_SIZE;
#line 434
      tmp___1 = realloc((void *)buffer, (size_t )(max + 1));
#line 434
      buffer = (char *)tmp___1;
      }
    }
#line 417
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 437
  *(buffer + len) = (char)0;
#line 438
  Trim(buffer);
  }
#line 440
  return (buffer);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static char *ReadAttributeValue(char const   *line , char const   *file , int *lineNumber ) 
{ 
  char *buffer ;
  char ch ;
  int len ;
  int max ;
  int x ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 452
  len = 0;
#line 453
  max = (int )BLOCK_SIZE;
#line 454
  tmp = malloc((size_t )(max + 1));
#line 454
  buffer = (char *)tmp;
#line 456
  x = 0;
  }
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 456
    tmp___2 = IsAttributeEnd((char )*(line + x));
    }
#line 456
    if (tmp___2) {
#line 456
      goto while_break;
    }
#line 457
    if ((int const   )*(line + x) == 38) {
      {
#line 458
      tmp___0 = ParseEntity(line + x, & ch, file, *lineNumber);
#line 458
      x += tmp___0 - 1;
      }
#line 459
      if (ch) {
#line 460
        *(buffer + len) = ch;
      } else {
#line 462
        *(buffer + len) = (char )*(line + x);
      }
    } else {
#line 465
      if ((int const   )*(line + x) == 10) {
#line 466
        (*lineNumber) ++;
      }
#line 468
      *(buffer + len) = (char )*(line + x);
    }
#line 470
    len ++;
#line 471
    if (len >= max) {
      {
#line 472
      max += (int )BLOCK_SIZE;
#line 473
      tmp___1 = realloc((void *)buffer, (size_t )(max + 1));
#line 473
      buffer = (char *)tmp___1;
      }
    }
#line 456
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  *(buffer + len) = (char)0;
#line 478
  return (buffer);
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static TokenType LookupType(char const   *name , TokenNode *np ) 
{ 
  unsigned int x ;
  int tmp ;
  long tmp___0 ;

  {
#line 487
  x = 0U;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if (! ((unsigned long )x < sizeof(TOKEN_MAP) / sizeof(char *))) {
#line 487
      goto while_break;
    }
    {
#line 488
    tmp = strcmp(name, TOKEN_MAP[x]);
    }
#line 488
    if (! tmp) {
#line 489
      if (np) {
#line 490
        np->type = (TokenType )x;
      }
#line 492
      return ((TokenType )x);
    }
#line 487
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 496
  tmp___0 = __builtin_expect((long )(! (! np)), 0L);
  }
#line 496
  if (tmp___0) {
    {
#line 497
    np->type = (TokenType )0;
#line 498
    np->invalidName = CopyString(name);
    }
  }
#line 501
  return ((TokenType )0);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
char const   *GetTokenName(TokenNode const   *tp ) 
{ 


  {
#line 507
  if (tp->invalidName) {
#line 508
    return ((char const   *)tp->invalidName);
  } else
#line 509
  if ((unsigned long )tp->type >= sizeof(TOKEN_MAP) / sizeof(char const   *)) {
#line 510
    return ("[invalid]");
  } else {
#line 512
    return (TOKEN_MAP[tp->type]);
  }
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
char const   *GetTokenTypeName(TokenType type ) 
{ 


  {
#line 518
  return (TOKEN_MAP[type]);
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static TokenNode *CreateNode(TokenNode *parent , char const   *file , int line ) 
{ 
  TokenNode *np ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 525
  tmp = malloc(sizeof(TokenNode ));
#line 525
  np = (TokenNode *)tmp;
#line 526
  np->type = (TokenType )0;
#line 527
  np->value = (char *)((void *)0);
#line 528
  np->attributes = (struct AttributeNode *)((void *)0);
#line 529
  np->subnodeHead = (struct TokenNode *)((void *)0);
#line 530
  np->subnodeTail = (struct TokenNode *)((void *)0);
#line 531
  np->parent = parent;
#line 532
  np->next = (struct TokenNode *)((void *)0);
#line 534
  tmp___0 = strlen(file);
#line 534
  tmp___1 = malloc(tmp___0 + 1UL);
#line 534
  np->fileName = (char *)tmp___1;
#line 535
  strcpy((char */* __restrict  */)np->fileName, (char const   */* __restrict  */)file);
#line 536
  np->line = line;
#line 537
  np->invalidName = (char *)((void *)0);
  }
#line 539
  if (! head) {
#line 540
    head = np;
  }
#line 542
  if (parent) {
#line 543
    if (parent->subnodeHead) {
#line 544
      (parent->subnodeTail)->next = np;
    } else {
#line 546
      parent->subnodeHead = np;
    }
#line 548
    parent->subnodeTail = np;
  } else
#line 549
  if (current) {
#line 550
    current->next = np;
  }
#line 552
  current = np;
#line 554
  return (np);
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/lex.c"
static AttributeNode *CreateAttribute(TokenNode *np ) 
{ 
  AttributeNode *ap ;
  void *tmp ;

  {
  {
#line 561
  tmp = malloc(sizeof(AttributeNode ));
#line 561
  ap = (AttributeNode *)tmp;
#line 562
  ap->name = (char *)((void *)0);
#line 563
  ap->value = (char *)((void *)0);
#line 565
  ap->next = np->attributes;
#line 566
  np->attributes = ap;
  }
#line 568
  return (ap);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static char minimized_bitmap[4]  = {      (char)1,      (char)3,      (char)7,      (char)15};
#line 62 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static int const   TASK_SPACER  =    (int const   )2;
#line 64 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static Pixmap minimizedPixmap  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static InsertModeType insertMode  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static TaskBarType *bars  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static Node *taskBarNodes  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static Node *taskBarNodesTail  ;
#line 71
static Node *GetNode(TaskBarType *bar , int x ) ;
#line 72
static unsigned int GetItemCount(void) ;
#line 73
static unsigned int GetItemWidth(TaskBarType const   *bp , unsigned int itemCount ) ;
#line 75
static void Render(TaskBarType const   *bp ) ;
#line 76
static void ShowTaskWindowMenu(TaskBarType *bar , Node *np ) ;
#line 78
static void SetSize___1(TrayComponentType *cp , int width , int height ) ;
#line 79
static void Create___2(TrayComponentType *cp ) ;
#line 80
static void Resize___2(TrayComponentType *cp ) ;
#line 81
static void ProcessTaskButtonEvent(TrayComponentType *cp , int x , int y , int mask ) ;
#line 83
static void ProcessTaskMotionEvent(TrayComponentType *cp , int x , int y , int mask ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void InitializeTaskBar(void) 
{ 


  {
#line 88
  bars = (TaskBarType *)((void *)0);
#line 89
  taskBarNodes = (Node *)((void *)0);
#line 90
  taskBarNodesTail = (Node *)((void *)0);
#line 91
  insertMode = (InsertModeType )1;
#line 92
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void StartupTaskBar(void) 
{ 


  {
  {
#line 96
  minimizedPixmap = XCreateBitmapFromData(display, rootWindow, (char const   *)(minimized_bitmap),
                                          4U, 4U);
  }
#line 98
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void ShutdownTaskBar(void) 
{ 
  TaskBarType *bp ;

  {
#line 105
  bp = bars;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! bp) {
#line 105
      goto while_break;
    }
    {
#line 106
    XFreePixmap(display, bp->buffer);
#line 105
    bp = bp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  XFreePixmap(display, minimizedPixmap);
  }
#line 110
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void DestroyTaskBar(void) 
{ 
  TaskBarType *bp ;

  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! bars) {
#line 117
      goto while_break;
    }
    {
#line 118
    bp = bars->next;
#line 119
    free((void *)bars);
#line 120
    bars = bp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
struct TrayComponentType *CreateTaskBar(void) 
{ 
  TrayComponentType *cp ;
  TaskBarType *tp ;
  void *tmp ;

  {
  {
#line 131
  tmp = malloc(sizeof(TaskBarType ));
#line 131
  tp = (TaskBarType *)tmp;
#line 132
  tp->next = bars;
#line 133
  bars = tp;
#line 134
  tp->itemHeight = 0;
#line 135
  tp->layout = (LayoutType )0;
#line 136
  tp->mousex = -2;
#line 137
  tp->mousey = -2;
#line 138
  tp->mouseTime.seconds = 0UL;
#line 139
  tp->mouseTime.ms = 0;
#line 140
  tp->maxItemWidth = 0U;
#line 142
  cp = CreateTrayComponent();
#line 143
  cp->object = (void *)tp;
#line 144
  tp->cp = cp;
#line 146
  cp->SetSize = & SetSize___1;
#line 147
  cp->Create = & Create___2;
#line 148
  cp->Resize = & Resize___2;
#line 149
  cp->ProcessButtonPress = & ProcessTaskButtonEvent;
#line 150
  cp->ProcessMotionEvent = & ProcessTaskMotionEvent;
  }
#line 152
  return (cp);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static void SetSize___1(TrayComponentType *cp , int width , int height ) 
{ 
  TaskBarType *tp ;

  {
#line 163
  tp = (TaskBarType *)cp->object;
#line 167
  if (width == 0) {
#line 168
    tp->layout = (LayoutType )0;
  } else
#line 169
  if (height == 0) {
#line 170
    tp->layout = (LayoutType )1;
  } else
#line 171
  if (width > height) {
#line 172
    tp->layout = (LayoutType )0;
  } else {
#line 174
    tp->layout = (LayoutType )1;
  }
#line 177
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static void Create___2(TrayComponentType *cp ) 
{ 
  TaskBarType *tp ;
  int tmp ;

  {
#line 186
  tp = (TaskBarType *)cp->object;
#line 190
  if ((unsigned int )tp->layout == 0U) {
#line 191
    tp->itemHeight = cp->height - (int )TASK_SPACER;
  } else {
    {
#line 193
    tmp = GetStringHeight((FontType )2);
#line 193
    tp->itemHeight = tmp + 12;
    }
  }
  {
#line 199
  cp->pixmap = XCreatePixmap(display, rootWindow, (unsigned int )cp->width, (unsigned int )cp->height,
                             (unsigned int )rootDepth);
#line 201
  tp->buffer = cp->pixmap;
#line 203
  XSetForeground(display, rootGC, colors[8]);
#line 204
  XFillRectangle(display, cp->pixmap, rootGC, 0, 0, (unsigned int )cp->width, (unsigned int )cp->height);
  }
#line 206
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static void Resize___2(TrayComponentType *cp ) 
{ 
  TaskBarType *tp ;
  int tmp ;

  {
#line 215
  tp = (TaskBarType *)cp->object;
#line 219
  if (tp->buffer != 0UL) {
    {
#line 220
    XFreePixmap(display, tp->buffer);
    }
  }
#line 223
  if ((unsigned int )tp->layout == 0U) {
#line 224
    tp->itemHeight = cp->height - (int )TASK_SPACER;
  } else {
    {
#line 226
    tmp = GetStringHeight((FontType )2);
#line 226
    tp->itemHeight = tmp + 12;
    }
  }
  {
#line 232
  cp->pixmap = XCreatePixmap(display, rootWindow, (unsigned int )cp->width, (unsigned int )cp->height,
                             (unsigned int )rootDepth);
#line 234
  tp->buffer = cp->pixmap;
#line 236
  XSetForeground(display, rootGC, colors[8]);
#line 237
  XFillRectangle(display, cp->pixmap, rootGC, 0, 0, (unsigned int )cp->width, (unsigned int )cp->height);
  }
#line 239
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static void ProcessTaskButtonEvent(TrayComponentType *cp , int x , int y , int mask ) 
{ 
  TaskBarType *bar ;
  Node *np ;

  {
#line 244
  bar = (TaskBarType *)cp->object;
#line 249
  if ((unsigned int )bar->layout == 0U) {
    {
#line 250
    np = GetNode(bar, x);
    }
  } else {
    {
#line 252
    np = GetNode(bar, y);
    }
  }
#line 255
  if (np) {
    {
#line 257
    if (mask == 1) {
#line 257
      goto case_1;
    }
#line 266
    if (mask == 3) {
#line 266
      goto case_3;
    }
#line 269
    if (mask == 4) {
#line 269
      goto case_4;
    }
#line 272
    if (mask == 5) {
#line 272
      goto case_5;
    }
#line 275
    goto switch_default;
    case_1: /* CIL Label */ 
#line 258
    if ((np->client)->state.status & 1U) {
#line 258
      if ((unsigned long )np->client == (unsigned long )nodes[(np->client)->state.layer]) {
        {
#line 260
        MinimizeClient(np->client);
        }
      } else {
        {
#line 262
        RestoreClient(np->client, (char)1);
#line 263
        FocusClient(np->client);
        }
      }
    } else {
      {
#line 262
      RestoreClient(np->client, (char)1);
#line 263
      FocusClient(np->client);
      }
    }
#line 265
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 267
    ShowTaskWindowMenu(bar, np);
    }
#line 268
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 270
    FocusPrevious();
    }
#line 271
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 273
    FocusNext();
    }
#line 274
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 276
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 280
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static void ProcessTaskMotionEvent(TrayComponentType *cp , int x , int y , int mask ) 
{ 
  TaskBarType *bp ;

  {
  {
#line 285
  bp = (TaskBarType *)cp->object;
#line 287
  bp->mousex = cp->screenx + x;
#line 288
  bp->mousey = cp->screeny + y;
#line 289
  GetCurrentTime(& bp->mouseTime);
  }
#line 291
  return;
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static void ShowTaskWindowMenu(TaskBarType *bar , Node *np ) 
{ 
  int x ;
  int y ;
  int mwidth ;
  int mheight ;
  ScreenType const   *sp ;

  {
  {
#line 300
  GetWindowMenuSize(np->client, & mwidth, & mheight);
#line 302
  sp = GetCurrentScreen((bar->cp)->screenx, (bar->cp)->screeny);
  }
#line 304
  if ((unsigned int )bar->layout == 0U) {
    {
#line 305
    GetMousePosition(& x, & y);
    }
#line 306
    if ((bar->cp)->screeny + (bar->cp)->height / 2 < (int )(sp->y + sp->height / 2)) {
#line 307
      y = (bar->cp)->screeny + (bar->cp)->height;
    } else {
#line 309
      y = (bar->cp)->screeny - mheight;
    }
#line 311
    x -= mwidth / 2;
  } else {
#line 313
    if ((bar->cp)->screenx + (bar->cp)->width / 2 < (int )(sp->x + sp->width / 2)) {
#line 314
      x = (bar->cp)->screenx + (bar->cp)->width;
    } else {
#line 316
      x = (bar->cp)->screenx - mwidth;
    }
#line 318
    y = (bar->cp)->screeny + np->y;
  }
  {
#line 321
  ShowWindowMenu(np->client, x, y);
  }
#line 323
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void AddClientToTaskBar(struct ClientNode *np ) 
{ 
  Node *tp ;
  void *tmp ;

  {
  {
#line 332
  tmp = malloc(sizeof(Node ));
#line 332
  tp = (Node *)tmp;
#line 333
  tp->client = np;
  }
#line 335
  if ((unsigned int )insertMode == 1U) {
#line 336
    tp->next = (struct Node *)((void *)0);
#line 337
    tp->prev = taskBarNodesTail;
#line 338
    if (taskBarNodesTail) {
#line 339
      taskBarNodesTail->next = tp;
    } else {
#line 341
      taskBarNodes = tp;
    }
#line 343
    taskBarNodesTail = tp;
  } else {
#line 345
    tp->prev = (struct Node *)((void *)0);
#line 346
    tp->next = taskBarNodes;
#line 347
    if (taskBarNodes) {
#line 348
      taskBarNodes->prev = tp;
    }
#line 350
    taskBarNodes = tp;
#line 351
    if (! taskBarNodesTail) {
#line 352
      taskBarNodesTail = tp;
    }
  }
  {
#line 356
  UpdateTaskBar();
#line 358
  UpdateNetClientList();
  }
#line 360
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void RemoveClientFromTaskBar(struct ClientNode *np ) 
{ 
  Node *tp ;

  {
#line 369
  tp = taskBarNodes;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! tp) {
#line 369
      goto while_break;
    }
#line 370
    if ((unsigned long )tp->client == (unsigned long )np) {
#line 371
      if (tp->prev) {
#line 372
        (tp->prev)->next = tp->next;
      } else {
#line 374
        taskBarNodes = tp->next;
      }
#line 376
      if (tp->next) {
#line 377
        (tp->next)->prev = tp->prev;
      } else {
#line 379
        taskBarNodesTail = tp->prev;
      }
      {
#line 381
      free((void *)tp);
      }
#line 382
      goto while_break;
    }
#line 369
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 386
  UpdateTaskBar();
#line 388
  UpdateNetClientList();
  }
#line 390
  return;
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void UpdateTaskBar(void) 
{ 
  TaskBarType *bp ;
  unsigned int count ;
  int lastHeight___0 ;
  int tmp ;

  {
#line 399
  if (shouldExit) {
#line 400
    return;
  }
#line 403
  bp = bars;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! bp) {
#line 403
      goto while_break;
    }
#line 405
    if ((unsigned int )bp->layout == 1U) {
      {
#line 406
      lastHeight___0 = (bp->cp)->requestedHeight;
#line 407
      count = GetItemCount();
#line 408
      tmp = GetStringHeight((FontType )2);
#line 408
      (bp->cp)->requestedHeight = tmp + 12;
#line 409
      (bp->cp)->requestedHeight = (int )((unsigned int )(bp->cp)->requestedHeight * count);
#line 410
      (bp->cp)->requestedHeight += 2;
      }
#line 411
      if (lastHeight___0 != (bp->cp)->requestedHeight) {
        {
#line 412
        ResizeTray((bp->cp)->tray);
        }
      }
    }
    {
#line 416
    Render((TaskBarType const   *)bp);
#line 403
    bp = bp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void SignalTaskbar(struct TimeType  const  *now , int x , int y ) 
{ 
  TaskBarType *bp ;
  Node *np ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 427
  bp = bars;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (! bp) {
#line 427
      goto while_break;
    }
    {
#line 428
    tmp___0 = abs(bp->mousex - x);
    }
#line 428
    if (tmp___0 < 2) {
      {
#line 428
      tmp___1 = abs(bp->mousey - y);
      }
#line 428
      if (tmp___1 < 2) {
        {
#line 430
        tmp = GetTimeDifference(now, (TimeType const   *)(& bp->mouseTime));
        }
#line 430
        if (tmp >= (unsigned long )popupDelay) {
#line 431
          if ((unsigned int )bp->layout == 0U) {
            {
#line 432
            np = GetNode(bp, x - (bp->cp)->screenx);
            }
          } else {
            {
#line 434
            np = GetNode(bp, y - (bp->cp)->screeny);
            }
          }
#line 436
          if (np) {
#line 436
            if ((np->client)->name) {
              {
#line 437
              ShowPopup(x, y, (char const   *)(np->client)->name);
              }
            }
          }
        }
      }
    }
#line 427
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  return;
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static void Render(TaskBarType const   *bp ) 
{ 
  Node *tp ;
  ButtonNode button ;
  int x ;
  int y ;
  int remainder ;
  int itemWidth ;
  int itemCount ;
  int width ;
  int height ;
  Pixmap buffer ;
  GC gc ;
  char *minimizedName ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 458
  if (shouldExit) {
#line 459
    return;
  }
  {
#line 465
  width = (bp->cp)->width;
#line 466
  height = (bp->cp)->height;
#line 467
  buffer = (bp->cp)->pixmap;
#line 468
  gc = rootGC;
#line 470
  x = (int )TASK_SPACER;
#line 471
  width -= x;
#line 472
  y = 1;
#line 474
  XSetForeground(display, gc, colors[8]);
#line 475
  XFillRectangle(display, buffer, gc, 0, 0, (unsigned int )width, (unsigned int )height);
#line 477
  tmp = GetItemCount();
#line 477
  itemCount = (int )tmp;
  }
#line 478
  if (! itemCount) {
    {
#line 479
    UpdateSpecificTray((TrayType const   *)(bp->cp)->tray, (TrayComponentType const   *)bp->cp);
    }
#line 480
    return;
  }
#line 482
  if ((unsigned int const   )bp->layout == 0U) {
    {
#line 483
    tmp___0 = GetItemWidth(bp, (unsigned int )itemCount);
#line 483
    itemWidth = (int )tmp___0;
#line 484
    remainder = width - itemWidth * itemCount;
    }
  } else {
#line 486
    itemWidth = width;
#line 487
    remainder = 0;
  }
  {
#line 490
  ResetButton(& button, buffer, gc);
#line 491
  button.font = (FontType )2;
#line 493
  tp = taskBarNodes;
  }
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! tp) {
#line 493
      goto while_break;
    }
    {
#line 494
    tmp___3 = ShouldFocus((struct ClientNode  const  *)tp->client);
    }
#line 494
    if (tmp___3) {
#line 496
      tp->y = y;
#line 498
      if ((tp->client)->state.status & 1U) {
#line 499
        button.type = (ButtonType )4;
      } else {
#line 501
        button.type = (ButtonType )3;
      }
#line 504
      if (remainder) {
#line 505
        button.width = itemWidth - (int )TASK_SPACER;
      } else {
#line 507
        button.width = (itemWidth - (int )TASK_SPACER) - 1;
      }
#line 509
      button.height = (int )(bp->itemHeight - 1);
#line 510
      button.x = x;
#line 511
      button.y = y;
#line 512
      button.icon = (tp->client)->icon;
#line 514
      if ((tp->client)->state.status & 128U) {
#line 515
        if ((tp->client)->name) {
          {
#line 516
          tmp___1 = strlen((char const   *)(tp->client)->name);
#line 516
          tmp___2 = __builtin_alloca(tmp___1 + 3UL);
#line 516
          minimizedName = (char *)tmp___2;
#line 517
          sprintf((char */* __restrict  */)minimizedName, (char const   */* __restrict  */)"[%s]",
                  (tp->client)->name);
#line 518
          button.text = (char const   *)minimizedName;
#line 519
          DrawButton(& button);
          }
        } else {
          {
#line 522
          button.text = "[]";
#line 523
          DrawButton(& button);
          }
        }
      } else {
        {
#line 526
        button.text = (char const   *)(tp->client)->name;
#line 527
        DrawButton(& button);
        }
      }
#line 530
      if ((tp->client)->state.status & 128U) {
        {
#line 531
        XSetForeground(display, gc, colors[10]);
#line 532
        XSetClipMask(display, gc, minimizedPixmap);
#line 533
        XSetClipOrigin(display, gc, x + 3, (y + (int )bp->itemHeight) - 7);
#line 534
        XFillRectangle(display, buffer, gc, x + 3, (y + (int )bp->itemHeight) - 7,
                       4U, 4U);
#line 536
        XSetClipMask(display, gc, (Pixmap )0L);
        }
      }
#line 539
      if ((unsigned int const   )bp->layout == 0U) {
#line 540
        x += itemWidth;
#line 541
        if (remainder) {
#line 542
          x ++;
#line 543
          remainder --;
        }
      } else {
#line 546
        y += (int )bp->itemHeight;
#line 547
        if (remainder) {
#line 548
          y ++;
#line 549
          remainder --;
        }
      }
    }
#line 493
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 556
  UpdateSpecificTray((TrayType const   *)(bp->cp)->tray, (TrayComponentType const   *)bp->cp);
  }
#line 558
  return;
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void FocusNext(void) 
{ 
  Node *tp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 565
  tp = taskBarNodes;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (! tp) {
#line 565
      goto while_break;
    }
    {
#line 566
    tmp = ShouldFocus((struct ClientNode  const  *)tp->client);
    }
#line 566
    if (tmp) {
#line 567
      if ((tp->client)->state.status & 1U) {
#line 568
        tp = tp->next;
#line 569
        goto while_break;
      }
    }
#line 565
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  if (! tp) {
#line 575
    tp = taskBarNodes;
  }
  {
#line 578
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 578
    if (tp) {
      {
#line 578
      tmp___0 = ShouldFocus((struct ClientNode  const  *)tp->client);
      }
#line 578
      if (tmp___0) {
#line 578
        goto while_break___0;
      }
    } else {
#line 578
      goto while_break___0;
    }
#line 579
    tp = tp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 582
  if (! tp) {
#line 583
    tp = taskBarNodes;
    {
#line 584
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 584
      if (tp) {
        {
#line 584
        tmp___1 = ShouldFocus((struct ClientNode  const  *)tp->client);
        }
#line 584
        if (tmp___1) {
#line 584
          goto while_break___1;
        }
      } else {
#line 584
        goto while_break___1;
      }
#line 585
      tp = tp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 589
  if (tp) {
    {
#line 590
    RestoreClient(tp->client, (char)1);
#line 591
    FocusClient(tp->client);
    }
  }
#line 594
  return;
}
}
#line 597 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void FocusPrevious(void) 
{ 
  Node *tp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 601
  tp = taskBarNodesTail;
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    if (! tp) {
#line 601
      goto while_break;
    }
    {
#line 602
    tmp = ShouldFocus((struct ClientNode  const  *)tp->client);
    }
#line 602
    if (tmp) {
#line 603
      if ((tp->client)->state.status & 1U) {
#line 604
        tp = tp->prev;
#line 605
        goto while_break;
      }
    }
#line 601
    tp = tp->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 610
  if (! tp) {
#line 611
    tp = taskBarNodesTail;
  }
  {
#line 614
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 614
    if (tp) {
      {
#line 614
      tmp___0 = ShouldFocus((struct ClientNode  const  *)tp->client);
      }
#line 614
      if (tmp___0) {
#line 614
        goto while_break___0;
      }
    } else {
#line 614
      goto while_break___0;
    }
#line 615
    tp = tp->prev;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 618
  if (! tp) {
#line 619
    tp = taskBarNodesTail;
    {
#line 620
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 620
      if (tp) {
        {
#line 620
        tmp___1 = ShouldFocus((struct ClientNode  const  *)tp->client);
        }
#line 620
        if (tmp___1) {
#line 620
          goto while_break___1;
        }
      } else {
#line 620
        goto while_break___1;
      }
#line 621
      tp = tp->prev;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 625
  if (tp) {
    {
#line 626
    RestoreClient(tp->client, (char)1);
#line 627
    FocusClient(tp->client);
    }
  }
#line 630
  return;
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static Node *GetNode(TaskBarType *bar , int x ) 
{ 
  Node *tp ;
  int remainder ;
  int itemCount ;
  int itemWidth ;
  int index ;
  int stop ;
  int width ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 642
  index = (int )TASK_SPACER;
#line 644
  tmp = GetItemCount();
#line 644
  itemCount = (int )tmp;
  }
#line 646
  if ((unsigned int )bar->layout == 0U) {
    {
#line 648
    width = (bar->cp)->width - index;
#line 649
    tmp___0 = GetItemWidth((TaskBarType const   *)bar, (unsigned int )itemCount);
#line 649
    itemWidth = (int )tmp___0;
#line 650
    remainder = width - itemWidth * itemCount;
#line 652
    tp = taskBarNodes;
    }
    {
#line 652
    while (1) {
      while_continue: /* CIL Label */ ;
#line 652
      if (! tp) {
#line 652
        goto while_break;
      }
      {
#line 653
      tmp___1 = ShouldFocus((struct ClientNode  const  *)tp->client);
      }
#line 653
      if (tmp___1) {
#line 654
        if (remainder) {
#line 655
          stop = (index + itemWidth) + 1;
#line 656
          remainder --;
        } else {
#line 658
          stop = index + itemWidth;
        }
#line 660
        if (x >= index) {
#line 660
          if (x < stop) {
#line 661
            return (tp);
          }
        }
#line 663
        index = stop;
      }
#line 652
      tp = tp->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 669
    tp = taskBarNodes;
    {
#line 669
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 669
      if (! tp) {
#line 669
        goto while_break___0;
      }
      {
#line 670
      tmp___2 = ShouldFocus((struct ClientNode  const  *)tp->client);
      }
#line 670
      if (tmp___2) {
#line 671
        stop = index + bar->itemHeight;
#line 672
        if (x >= index) {
#line 672
          if (x < stop) {
#line 673
            return (tp);
          }
        }
#line 675
        index = stop;
      }
#line 669
      tp = tp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 681
  return ((Node *)((void *)0));
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static unsigned int GetItemCount(void) 
{ 
  Node *tp ;
  unsigned int count ;
  int tmp ;

  {
#line 691
  count = 0U;
#line 692
  tp = taskBarNodes;
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 692
    if (! tp) {
#line 692
      goto while_break;
    }
    {
#line 693
    tmp = ShouldFocus((struct ClientNode  const  *)tp->client);
    }
#line 693
    if (tmp) {
#line 694
      count ++;
    }
#line 692
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 698
  return (count);
}
}
#line 703 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
static unsigned int GetItemWidth(TaskBarType const   *bp , unsigned int itemCount ) 
{ 
  unsigned int itemWidth ;

  {
#line 707
  itemWidth = (unsigned int )((bp->cp)->width - (int )TASK_SPACER);
#line 709
  if (! itemCount) {
#line 710
    return (itemWidth);
  }
#line 713
  itemWidth /= itemCount;
#line 714
  if (! itemWidth) {
#line 715
    itemWidth = 1U;
  }
#line 718
  if (bp->maxItemWidth > 0U) {
#line 718
    if (itemWidth > (unsigned int )bp->maxItemWidth) {
#line 719
      itemWidth = (unsigned int )bp->maxItemWidth;
    }
  }
#line 722
  return (itemWidth);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void SetMaxTaskBarItemWidth(struct TrayComponentType *cp , char const   *value ) 
{ 
  int temp ;
  TaskBarType *bp ;
  char *tmp ;
  long tmp___0 ;

  {
#line 734
  if (value) {
    {
#line 735
    temp = atoi(value);
#line 736
    tmp___0 = __builtin_expect((long )(! (! (temp < 0))), 0L);
    }
#line 736
    if (tmp___0) {
      {
#line 737
      tmp = gettext("invalid maxwidth for TaskList: %s");
#line 737
      Warning((char const   *)tmp, value);
      }
#line 738
      return;
    }
#line 740
    bp = (TaskBarType *)cp->object;
#line 741
    bp->maxItemWidth = (unsigned int )temp;
  }
#line 744
  return;
}
}
#line 747 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void SetTaskBarInsertMode(char const   *mode ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 749
  if (! mode) {
#line 750
    insertMode = (InsertModeType )1;
#line 751
    return;
  }
  {
#line 754
  tmp___1 = strcmp(mode, "right");
  }
#line 754
  if (tmp___1) {
    {
#line 756
    tmp___0 = strcmp(mode, "left");
    }
#line 756
    if (tmp___0) {
      {
#line 759
      tmp = gettext("invalid insert mode: \"%s\"");
#line 759
      Warning((char const   *)tmp, mode);
#line 760
      insertMode = (InsertModeType )1;
      }
    } else {
#line 757
      insertMode = (InsertModeType )0;
    }
  } else {
#line 755
    insertMode = (InsertModeType )1;
  }
#line 763
  return;
}
}
#line 766 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/taskbar.c"
void UpdateNetClientList(void) 
{ 
  Node *np ;
  ClientNode *client___0 ;
  Window *windows ;
  int count ;
  int temp ;
  int layer ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 775
  count = 0;
#line 776
  np = taskBarNodes;
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
#line 776
    if (! np) {
#line 776
      goto while_break;
    }
#line 777
    count ++;
#line 776
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  temp = 0;
#line 780
  layer = 0;
  {
#line 780
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 780
    if (! (layer <= 12)) {
#line 780
      goto while_break___0;
    }
#line 781
    client___0 = nodes[layer];
    {
#line 781
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 781
      if (! client___0) {
#line 781
        goto while_break___1;
      }
#line 782
      temp ++;
#line 781
      client___0 = client___0->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 780
    layer ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 785
  if (temp > count) {
#line 786
    count = temp;
  }
#line 789
  if (count == 0) {
#line 790
    windows = (Window *)((void *)0);
  } else {
    {
#line 792
    tmp = __builtin_alloca((unsigned long )count * sizeof(Window ));
#line 792
    windows = (Window *)tmp;
    }
  }
#line 796
  count = 0;
#line 797
  np = taskBarNodes;
  {
#line 797
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 797
    if (! np) {
#line 797
      goto while_break___2;
    }
#line 798
    tmp___0 = count;
#line 798
    count ++;
#line 798
    *(windows + tmp___0) = (np->client)->window;
#line 797
    np = np->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 800
  XChangeProperty(display, rootWindow, atoms[54], (Atom )33, 32, 0, (unsigned char const   *)((unsigned char *)windows),
                  count);
#line 804
  count = 0;
#line 805
  layer = 0;
  }
  {
#line 805
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 805
    if (! (layer <= 12)) {
#line 805
      goto while_break___3;
    }
#line 806
    client___0 = nodes[layer];
    {
#line 806
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 806
      if (! client___0) {
#line 806
        goto while_break___4;
      }
#line 807
      tmp___1 = count;
#line 807
      count ++;
#line 807
      *(windows + tmp___1) = client___0->window;
#line 806
      client___0 = client___0->next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 805
    layer ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 810
  XChangeProperty(display, rootWindow, atoms[55], (Atom )33, 32, 0, (unsigned char const   *)((unsigned char *)windows),
                  count);
  }
#line 817
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
static GroupType *groups  =    (GroupType *)((void *)0);
#line 49
static void ReleasePatternList(PatternListType *lp ) ;
#line 50
static void ReleaseOptionList(OptionListType *lp ) ;
#line 51
static void AddPattern(PatternListType **lp , char const   *pattern , MatchType match ) ;
#line 53
static void ApplyGroup(GroupType const   *gp , ClientNode *np ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
void InitializeGroups(void) 
{ 


  {
#line 57
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
void StartupGroups(void) 
{ 


  {
#line 61
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
void ShutdownGroups(void) 
{ 


  {
#line 65
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
void DestroyGroups(void) 
{ 
  GroupType *gp ;

  {
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! groups) {
#line 72
      goto while_break;
    }
    {
#line 73
    gp = groups->next;
#line 74
    ReleasePatternList(groups->patterns);
#line 75
    ReleaseOptionList(groups->options);
#line 76
    free((void *)groups);
#line 77
    groups = gp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
static void ReleasePatternList(PatternListType *lp ) 
{ 
  PatternListType *tp ;

  {
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! lp) {
#line 87
      goto while_break;
    }
    {
#line 88
    tp = lp->next;
#line 89
    free((void *)lp->pattern);
#line 90
    free((void *)lp);
#line 91
    lp = tp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
static void ReleaseOptionList(OptionListType *lp ) 
{ 
  OptionListType *tp ;

  {
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! lp) {
#line 101
      goto while_break;
    }
#line 102
    tp = lp->next;
#line 103
    if (lp->value) {
      {
#line 104
      free((void *)lp->value);
      }
    }
    {
#line 106
    free((void *)lp);
#line 107
    lp = tp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
struct GroupType *CreateGroup(void) 
{ 
  GroupType *tp ;
  void *tmp ;

  {
  {
#line 116
  tmp = malloc(sizeof(GroupType ));
#line 116
  tp = (GroupType *)tmp;
#line 117
  tp->patterns = (PatternListType *)((void *)0);
#line 118
  tp->options = (OptionListType *)((void *)0);
#line 119
  tp->next = groups;
#line 120
  groups = tp;
  }
#line 122
  return (tp);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
void AddGroupClass(struct GroupType *gp , char const   *pattern ) 
{ 
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 130
  tmp___0 = __builtin_expect((long )(! (! pattern)), 1L);
  }
#line 130
  if (tmp___0) {
    {
#line 131
    AddPattern(& gp->patterns, pattern, (MatchType )1);
    }
  } else {
    {
#line 133
    tmp = gettext("invalid group class");
#line 133
    Warning((char const   *)tmp);
    }
  }
#line 136
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
void AddGroupName(struct GroupType *gp , char const   *pattern ) 
{ 
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 143
  tmp___0 = __builtin_expect((long )(! (! pattern)), 1L);
  }
#line 143
  if (tmp___0) {
    {
#line 144
    AddPattern(& gp->patterns, pattern, (MatchType )0);
    }
  } else {
    {
#line 146
    tmp = gettext("invalid group name");
#line 146
    Warning((char const   *)tmp);
    }
  }
#line 149
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
static void AddPattern(PatternListType **lp , char const   *pattern , MatchType match ) 
{ 
  PatternListType *tp ;
  void *tmp ;

  {
  {
#line 159
  tmp = malloc(sizeof(PatternListType ));
#line 159
  tp = (PatternListType *)tmp;
#line 160
  tp->next = *lp;
#line 161
  *lp = tp;
#line 163
  tp->pattern = CopyString(pattern);
#line 164
  tp->match = match;
  }
#line 166
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
void AddGroupOption(struct GroupType *gp , OptionType option ) 
{ 
  OptionListType *lp ;
  void *tmp ;

  {
  {
#line 173
  tmp = malloc(sizeof(OptionListType ));
#line 173
  lp = (OptionListType *)tmp;
#line 174
  lp->option = option;
#line 175
  lp->value = (char *)((void *)0);
#line 176
  lp->next = gp->options;
#line 177
  gp->options = lp;
  }
#line 179
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
void AddGroupOptionValue(struct GroupType *gp , OptionType option , char const   *value ) 
{ 
  OptionListType *lp ;
  void *tmp ;

  {
  {
#line 189
  tmp = malloc(sizeof(OptionListType ));
#line 189
  lp = (OptionListType *)tmp;
#line 190
  lp->option = option;
#line 191
  lp->value = CopyString(value);
#line 192
  lp->next = gp->options;
#line 193
  gp->options = lp;
  }
#line 195
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
void ApplyGroups(struct ClientNode *np ) 
{ 
  PatternListType *lp ;
  GroupType *gp ;
  char hasClass ;
  char hasName ;
  char matchesClass ;
  char matchesName ;
  int tmp ;
  int tmp___0 ;

  {
#line 209
  gp = groups;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! gp) {
#line 209
      goto while_break;
    }
#line 210
    hasClass = (char)0;
#line 211
    hasName = (char)0;
#line 212
    matchesClass = (char)0;
#line 213
    matchesName = (char)0;
#line 214
    lp = gp->patterns;
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (! lp) {
#line 214
        goto while_break___0;
      }
#line 215
      if ((unsigned int )lp->match == 1U) {
        {
#line 216
        tmp = Match((char const   *)lp->pattern, (char const   *)np->className);
        }
#line 216
        if (tmp) {
#line 217
          matchesClass = (char)1;
        }
#line 219
        hasClass = (char)1;
      } else
#line 220
      if ((unsigned int )lp->match == 0U) {
        {
#line 221
        tmp___0 = Match((char const   *)lp->pattern, (char const   *)np->instanceName);
        }
#line 221
        if (tmp___0) {
#line 222
          matchesName = (char)1;
        }
#line 224
        hasName = (char)1;
      } else {
        {
#line 226
        Debug("invalid match in ApplyGroups: %d", (unsigned int )lp->match);
        }
      }
#line 214
      lp = lp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 229
    if ((int )hasName == (int )matchesName) {
#line 229
      if ((int )hasClass == (int )matchesClass) {
        {
#line 230
        ApplyGroup((GroupType const   *)gp, np);
        }
      }
    }
#line 209
    gp = gp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/group.c"
static void ApplyGroup(GroupType const   *gp , ClientNode *np ) 
{ 
  OptionListType *lp ;
  unsigned int temp ;
  double tempf ;
  int tmp ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;

  {
#line 246
  lp = (OptionListType *)gp->options;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! lp) {
#line 246
      goto while_break;
    }
    {
#line 248
    if ((unsigned int )lp->option == 1U) {
#line 248
      goto case_1;
    }
#line 251
    if ((unsigned int )lp->option == 5U) {
#line 251
      goto case_5;
    }
#line 254
    if ((unsigned int )lp->option == 6U) {
#line 254
      goto case_6;
    }
#line 257
    if ((unsigned int )lp->option == 7U) {
#line 257
      goto case_7;
    }
#line 260
    if ((unsigned int )lp->option == 8U) {
#line 260
      goto case_8;
    }
#line 263
    if ((unsigned int )lp->option == 9U) {
#line 263
      goto case_9;
    }
#line 266
    if ((unsigned int )lp->option == 2U) {
#line 266
      goto case_2;
    }
#line 274
    if ((unsigned int )lp->option == 3U) {
#line 274
      goto case_3;
    }
#line 282
    if ((unsigned int )lp->option == 4U) {
#line 282
      goto case_4;
    }
#line 286
    if ((unsigned int )lp->option == 10U) {
#line 286
      goto case_10;
    }
#line 289
    if ((unsigned int )lp->option == 11U) {
#line 289
      goto case_11;
    }
#line 292
    if ((unsigned int )lp->option == 12U) {
#line 292
      goto case_12;
    }
#line 295
    if ((unsigned int )lp->option == 13U) {
#line 295
      goto case_13;
    }
#line 298
    if ((unsigned int )lp->option == 14U) {
#line 298
      goto case_14;
    }
#line 307
    if ((unsigned int )lp->option == 16U) {
#line 307
      goto case_16;
    }
#line 310
    if ((unsigned int )lp->option == 15U) {
#line 310
      goto case_15;
    }
#line 313
    if ((unsigned int )lp->option == 17U) {
#line 313
      goto case_17;
    }
#line 316
    goto switch_default;
    case_1: /* CIL Label */ 
#line 249
    np->state.status |= 32U;
#line 250
    goto switch_break;
    case_5: /* CIL Label */ 
#line 252
    np->state.status |= 64U;
#line 253
    goto switch_break;
    case_6: /* CIL Label */ 
#line 255
    np->state.border |= 1U;
#line 256
    goto switch_break;
    case_7: /* CIL Label */ 
#line 258
    np->state.border &= 4294967294U;
#line 259
    goto switch_break;
    case_8: /* CIL Label */ 
#line 261
    np->state.border |= 2U;
#line 262
    goto switch_break;
    case_9: /* CIL Label */ 
#line 264
    np->state.border &= 4294967293U;
#line 265
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 267
    tmp = atoi((char const   *)lp->value);
#line 267
    temp = (unsigned int )tmp;
#line 268
    tmp___1 = __builtin_expect((long )(! (! (temp <= 13U))), 1L);
    }
#line 268
    if (tmp___1) {
      {
#line 269
      SetClientLayer(np, temp);
      }
    } else {
      {
#line 271
      tmp___0 = gettext("invalid group layer: %s");
#line 271
      Warning((char const   *)tmp___0, lp->value);
      }
    }
#line 273
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 275
    tmp___2 = atoi((char const   *)lp->value);
#line 275
    temp = (unsigned int )tmp___2;
    }
#line 276
    if (temp >= 1U) {
#line 276
      if (temp <= desktopCount) {
#line 276
        tmp___4 = 1;
      } else {
#line 276
        tmp___4 = 0;
      }
    } else {
#line 276
      tmp___4 = 0;
    }
    {
#line 276
    tmp___5 = __builtin_expect((long )tmp___4, 1L);
    }
#line 276
    if (tmp___5) {
#line 277
      np->state.desktop = temp - 1U;
    } else {
      {
#line 279
      tmp___3 = gettext("invalid group desktop: %s");
#line 279
      Warning((char const   *)tmp___3, lp->value);
      }
    }
#line 281
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 283
    DestroyIcon(np->icon);
#line 284
    np->icon = LoadNamedIcon((char const   *)lp->value);
    }
#line 285
    goto switch_break;
    case_10: /* CIL Label */ 
#line 287
    np->state.status |= 1024U;
#line 288
    goto switch_break;
    case_11: /* CIL Label */ 
#line 290
    np->state.status |= 12U;
#line 291
    goto switch_break;
    case_12: /* CIL Label */ 
#line 293
    np->state.status |= 128U;
#line 294
    goto switch_break;
    case_13: /* CIL Label */ 
#line 296
    np->state.status |= 256U;
#line 297
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 299
    tempf = atof((char const   *)lp->value);
    }
#line 300
    if (tempf > 0.0) {
#line 300
      if (tempf <= 1.0) {
#line 300
        tmp___7 = 1;
      } else {
#line 300
        tmp___7 = 0;
      }
    } else {
#line 300
      tmp___7 = 0;
    }
    {
#line 300
    tmp___8 = __builtin_expect((long )tmp___7, 1L);
    }
#line 300
    if (tmp___8) {
#line 301
      np->state.opacity = (unsigned int )(tempf * (double )4294967295U);
#line 302
      np->state.status |= 16384U;
    } else {
      {
#line 304
      tmp___6 = gettext("invalid group opacity: %s");
#line 304
      Warning((char const   *)tmp___6, lp->value);
      }
    }
#line 306
    goto switch_break;
    case_16: /* CIL Label */ 
#line 308
    np->state.border &= 4294967039U;
#line 309
    goto switch_break;
    case_15: /* CIL Label */ 
#line 311
    np->state.border &= 4294967167U;
#line 312
    goto switch_break;
    case_17: /* CIL Label */ 
#line 314
    np->state.status |= 32768U;
#line 315
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 317
    Debug("invalid option: %d", (unsigned int )lp->option);
    }
#line 318
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 246
    lp = lp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.c"
static ResizeModeType resizeMode  =    (ResizeModeType )0;
#line 25 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.c"
static char shouldStopResize  ;
#line 27
static void StopResize(ClientNode *np ) ;
#line 28
static void ResizeController(int wasDestroyed ) ;
#line 29
static void FixWidth(ClientNode *np ) ;
#line 30
static void FixHeight(ClientNode *np ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.c"
void SetResizeMode(ResizeModeType mode ) 
{ 


  {
#line 34
  resizeMode = mode;
#line 35
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.c"
static void ResizeController(int wasDestroyed ) 
{ 


  {
#line 39
  if ((unsigned int )resizeMode == 1U) {
    {
#line 40
    ClearOutline();
    }
  }
  {
#line 42
  XUngrabPointer(display, (Time )0L);
#line 43
  XUngrabKeyboard(display, (Time )0L);
#line 44
  DestroyResizeWindow();
#line 45
  shouldStopResize = (char)1;
  }
#line 46
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.c"
void ResizeClient(struct ClientNode *np , BorderActionType action , int startx , int starty ) 
{ 
  XEvent event ;
  int oldx ;
  int oldy ;
  int oldw ;
  int oldh ;
  int gwidth ;
  int gheight ;
  int lastgwidth ;
  int lastgheight ;
  int delta ;
  int north ;
  int south ;
  int east ;
  int west ;
  int ratio ;
  int minr ;
  int maxr ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 63
  if (! (np->state.border & 32U)) {
#line 64
    return;
  }
  {
#line 67
  tmp = GrabMouseForResize(action);
  }
#line 67
  if (tmp) {
#line 67
    tmp___0 = 0;
  } else {
#line 67
    tmp___0 = 1;
  }
  {
#line 67
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 67
  if (tmp___1) {
    {
#line 68
    Debug("ResizeClient: could not grab mouse");
    }
#line 69
    return;
  }
#line 72
  if (np->state.status & 256U) {
#line 73
    action = (BorderActionType )((unsigned int )action & 4294967247U);
  }
  {
#line 76
  np->controller = & ResizeController;
#line 77
  shouldStopResize = (char)0;
#line 79
  oldx = np->x;
#line 80
  oldy = np->y;
#line 81
  oldw = np->width;
#line 82
  oldh = np->height;
#line 84
  gwidth = (np->width - np->baseWidth) / np->xinc;
#line 85
  gheight = (np->height - np->baseHeight) / np->yinc;
#line 87
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 89
  startx += np->x - west;
#line 90
  starty += np->y - north;
#line 92
  CreateResizeWindow(np);
#line 93
  UpdateResizeWindow(np, gwidth, gheight);
#line 95
  tmp___2 = GetMouseMask();
  }
#line 95
  if (! (tmp___2 & (unsigned int )((1 << 8) | (1 << 10)))) {
    {
#line 96
    StopResize(np);
    }
#line 97
    return;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    WaitForEvent(& event);
    }
#line 104
    if (shouldStopResize) {
#line 105
      np->controller = (void (*)(int wasDestroyed ))((void *)0);
#line 106
      return;
    }
    {
#line 110
    if (event.type == 5) {
#line 110
      goto case_5;
    }
#line 117
    if (event.type == 6) {
#line 117
      goto case_6;
    }
#line 249
    goto switch_default;
    case_5: /* CIL Label */ 
#line 111
    if (event.xbutton.button == 1U) {
      {
#line 113
      StopResize(np);
      }
#line 114
      return;
    } else
#line 111
    if (event.xbutton.button == 3U) {
      {
#line 113
      StopResize(np);
      }
#line 114
      return;
    }
#line 116
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 119
    SetMousePosition(event.xmotion.x_root, event.xmotion.y_root);
#line 120
    DiscardMotionEvents(& event, np->window);
    }
#line 122
    if ((unsigned int )action & 16U) {
#line 123
      delta = (event.xmotion.y - starty) / np->yinc;
#line 124
      delta *= np->yinc;
#line 125
      if (oldh - delta >= np->minHeight) {
#line 125
        if (oldh - delta <= np->maxHeight) {
#line 127
          np->height = oldh - delta;
#line 128
          np->y = oldy + delta;
        } else
#line 125
        if (delta > 0) {
#line 127
          np->height = oldh - delta;
#line 128
          np->y = oldy + delta;
        }
      }
#line 130
      if (! ((unsigned int )action & 192U)) {
        {
#line 131
        FixWidth(np);
        }
      }
    }
#line 134
    if ((unsigned int )action & 32U) {
#line 135
      delta = (event.xmotion.y - starty) / np->yinc;
#line 136
      delta *= np->yinc;
#line 137
      np->height = oldh + delta;
#line 138
      if (np->height > np->minHeight) {
#line 138
        np->height = np->height;
      } else {
#line 138
        np->height = np->minHeight;
      }
#line 139
      if (np->height > np->maxHeight) {
#line 139
        np->height = np->maxHeight;
      } else {
#line 139
        np->height = np->height;
      }
#line 140
      if (! ((unsigned int )action & 192U)) {
        {
#line 141
        FixWidth(np);
        }
      }
    }
#line 144
    if ((unsigned int )action & 64U) {
#line 145
      delta = (event.xmotion.x - startx) / np->xinc;
#line 146
      delta *= np->xinc;
#line 147
      np->width = oldw + delta;
#line 148
      if (np->width > np->minWidth) {
#line 148
        np->width = np->width;
      } else {
#line 148
        np->width = np->minWidth;
      }
#line 149
      if (np->width > np->maxWidth) {
#line 149
        np->width = np->maxWidth;
      } else {
#line 149
        np->width = np->width;
      }
#line 150
      if (! ((unsigned int )action & 48U)) {
        {
#line 151
        FixHeight(np);
        }
      }
    }
#line 154
    if ((unsigned int )action & 128U) {
#line 155
      delta = (event.xmotion.x - startx) / np->xinc;
#line 156
      delta *= np->xinc;
#line 157
      if (oldw - delta >= np->minWidth) {
#line 157
        if (oldw - delta <= np->maxWidth) {
#line 159
          np->width = oldw - delta;
#line 160
          np->x = oldx + delta;
        } else
#line 157
        if (delta > 0) {
#line 159
          np->width = oldw - delta;
#line 160
          np->x = oldx + delta;
        }
      }
#line 162
      if (! ((unsigned int )action & 48U)) {
        {
#line 163
        FixHeight(np);
        }
      }
    }
#line 167
    if (np->sizeFlags & (1L << 7)) {
#line 168
      if ((unsigned int )action & 48U) {
#line 168
        if ((unsigned int )action & 192U) {
#line 172
          ratio = (np->width << 16) / np->height;
#line 174
          minr = (np->aspect.minx << 16) / np->aspect.miny;
#line 175
          if (ratio < minr) {
#line 176
            delta = np->width;
#line 177
            np->width = np->height * minr >> 16;
#line 178
            if ((unsigned int )action & 128U) {
#line 179
              np->x -= np->width - delta;
            }
          }
#line 183
          maxr = (np->aspect.maxx << 16) / np->aspect.maxy;
#line 184
          if (ratio > maxr) {
#line 185
            delta = np->height;
#line 186
            np->height = (np->width << 16) / maxr;
#line 187
            if ((unsigned int )action & 16U) {
#line 188
              np->y -= np->height - delta;
            }
          }
        }
      }
    }
#line 195
    lastgwidth = gwidth;
#line 196
    lastgheight = gheight;
#line 198
    gwidth = (np->width - np->baseWidth) / np->xinc;
#line 199
    gheight = (np->height - np->baseHeight) / np->yinc;
#line 201
    if (lastgheight != gheight) {
#line 201
      goto _L;
    } else
#line 201
    if (lastgwidth != gwidth) {
      _L: /* CIL Label */ 
#line 203
      if (np->state.status & 12U) {
        {
#line 204
        np->state.status &= 4294967283U;
#line 205
        WriteState(np);
#line 206
        SendConfigureEvent(np);
        }
      }
      {
#line 209
      UpdateResizeWindow(np, gwidth, gheight);
      }
#line 211
      if ((unsigned int )resizeMode == 1U) {
        {
#line 212
        ClearOutline();
        }
#line 213
        if (np->state.status & 256U) {
          {
#line 214
          DrawOutline(np->x - west, np->y - north, (np->width + west) + east, north + south);
          }
        } else {
          {
#line 217
          DrawOutline(np->x - west, np->y - north, (np->width + west) + east, (np->height + north) + south);
          }
        }
      } else {
        {
#line 222
        ResetRoundedRectWindow(np->parent);
        }
#line 223
        if (np->state.status & 256U) {
          {
#line 224
          ShapeRoundedRectWindow(np->parent, (np->width + east) + west, north + south);
#line 227
          XMoveResizeWindow(display, np->parent, np->x - west, np->y - north, (unsigned int )((np->width + west) + east),
                            (unsigned int )(north + south));
          }
        } else {
          {
#line 231
          ShapeRoundedRectWindow(np->parent, (np->width + east) + west, (np->height + north) + south);
#line 234
          XMoveResizeWindow(display, np->parent, np->x - west, np->y - north, (unsigned int )((np->width + west) + east),
                            (unsigned int )((np->height + north) + south));
          }
        }
        {
#line 239
        XMoveResizeWindow(display, np->window, west, north, (unsigned int )np->width,
                          (unsigned int )np->height);
#line 241
        SendConfigureEvent(np);
        }
      }
      {
#line 244
      UpdatePager();
      }
    }
#line 248
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 250
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.c"
void ResizeClientKeyboard(struct ClientNode *np ) 
{ 
  XEvent event ;
  int gwidth ;
  int gheight ;
  int lastgwidth ;
  int lastgheight ;
  int north ;
  int south ;
  int east ;
  int west ;
  int deltax ;
  int deltay ;
  int ratio ;
  int minr ;
  int maxr ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  KeyType tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 268
  if (! (np->state.border & 32U)) {
#line 269
    return;
  }
  {
#line 272
  tmp = XGrabKeyboard(display, np->window, 1, 1, 1, (Time )0L);
  }
#line 272
  if (tmp != 0) {
#line 272
    tmp___0 = 1;
  } else {
#line 272
    tmp___0 = 0;
  }
  {
#line 272
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 272
  if (tmp___1) {
    {
#line 274
    Debug("ResizeClientKeyboard: could not grab keyboard");
    }
#line 275
    return;
  }
  {
#line 277
  GrabMouseForResize((BorderActionType )97);
#line 279
  np->controller = & ResizeController;
#line 280
  shouldStopResize = (char)0;
#line 282
  gwidth = (np->width - np->baseWidth) / np->xinc;
#line 283
  gheight = (np->height - np->baseHeight) / np->yinc;
#line 285
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 287
  CreateResizeWindow(np);
#line 288
  UpdateResizeWindow(np, gwidth, gheight);
#line 290
  MoveMouse(rootWindow, np->x + np->width, np->y + np->height);
#line 291
  DiscardMotionEvents(& event, np->window);
  }
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 295
    WaitForEvent(& event);
    }
#line 297
    if (shouldStopResize) {
#line 298
      np->controller = (void (*)(int wasDestroyed ))((void *)0);
#line 299
      return;
    }
#line 302
    deltax = 0;
#line 303
    deltay = 0;
#line 305
    if (event.type == 2) {
      {
#line 307
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 307
        tmp___2 = XCheckTypedWindowEvent(display, np->window, 2, & event);
        }
#line 307
        if (! tmp___2) {
#line 307
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 308
      UpdateTime((XEvent const   *)(& event));
#line 310
      tmp___3 = GetKey((XKeyEvent const   *)(& event.xkey));
      }
      {
#line 311
      if (((unsigned int )tmp___3 & 255U) == 1U) {
#line 311
        goto case_1;
      }
#line 314
      if (((unsigned int )tmp___3 & 255U) == 2U) {
#line 314
        goto case_2;
      }
#line 317
      if (((unsigned int )tmp___3 & 255U) == 3U) {
#line 317
        goto case_3;
      }
#line 320
      if (((unsigned int )tmp___3 & 255U) == 4U) {
#line 320
        goto case_4;
      }
#line 323
      goto switch_default;
      case_1: /* CIL Label */ 
#line 312
      if (- np->yinc > -10) {
#line 312
        deltay = -10;
      } else {
#line 312
        deltay = - np->yinc;
      }
#line 313
      goto switch_break;
      case_2: /* CIL Label */ 
#line 315
      if (np->yinc > 10) {
#line 315
        deltay = np->yinc;
      } else {
#line 315
        deltay = 10;
      }
#line 316
      goto switch_break;
      case_3: /* CIL Label */ 
#line 318
      if (np->xinc > 10) {
#line 318
        deltax = np->xinc;
      } else {
#line 318
        deltax = 10;
      }
#line 319
      goto switch_break;
      case_4: /* CIL Label */ 
#line 321
      if (- np->xinc > -10) {
#line 321
        deltax = -10;
      } else {
#line 321
        deltax = - np->xinc;
      }
#line 322
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 324
      StopResize(np);
      }
#line 325
      return;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 328
    if (event.type == 6) {
      {
#line 330
      SetMousePosition(event.xmotion.x_root, event.xmotion.y_root);
#line 331
      DiscardMotionEvents(& event, np->window);
#line 333
      deltax = event.xmotion.x - (np->x + np->width);
#line 334
      deltay = event.xmotion.y - (np->y + np->height);
      }
    } else
#line 336
    if (event.type == 5) {
      {
#line 338
      StopResize(np);
      }
#line 339
      return;
    }
    {
#line 343
    tmp___4 = abs(deltax);
    }
#line 343
    if (tmp___4 < np->xinc) {
      {
#line 343
      tmp___5 = abs(deltay);
      }
#line 343
      if (tmp___5 < np->yinc) {
#line 344
        goto __Cont;
      }
    }
#line 347
    deltay -= deltay % np->yinc;
#line 348
    np->height += deltay;
#line 349
    if (np->height > np->minHeight) {
#line 349
      np->height = np->height;
    } else {
#line 349
      np->height = np->minHeight;
    }
#line 350
    if (np->height > np->maxHeight) {
#line 350
      np->height = np->maxHeight;
    } else {
#line 350
      np->height = np->height;
    }
#line 351
    deltax -= deltax % np->xinc;
#line 352
    np->width += deltax;
#line 353
    if (np->width > np->minWidth) {
#line 353
      np->width = np->width;
    } else {
#line 353
      np->width = np->minWidth;
    }
#line 354
    if (np->width > np->maxWidth) {
#line 354
      np->width = np->maxWidth;
    } else {
#line 354
      np->width = np->width;
    }
#line 356
    if (np->sizeFlags & (1L << 7)) {
#line 358
      ratio = (np->width << 16) / np->height;
#line 360
      minr = (np->aspect.minx << 16) / np->aspect.miny;
#line 361
      if (ratio < minr) {
#line 362
        np->width = np->height * minr >> 16;
      }
#line 365
      maxr = (np->aspect.maxx << 16) / np->aspect.maxy;
#line 366
      if (ratio > maxr) {
#line 367
        np->height = (np->width << 16) / maxr;
      }
    }
#line 372
    lastgwidth = gwidth;
#line 373
    lastgheight = gheight;
#line 374
    gwidth = (np->width - np->baseWidth) / np->xinc;
#line 375
    gheight = (np->height - np->baseHeight) / np->yinc;
#line 377
    if (lastgwidth != gwidth) {
#line 377
      goto _L;
    } else
#line 377
    if (lastgheight != gheight) {
      _L: /* CIL Label */ 
#line 379
      if (np->state.status & 12U) {
        {
#line 380
        np->state.status &= 4294967283U;
#line 381
        WriteState(np);
#line 382
        SendConfigureEvent(np);
        }
      }
      {
#line 385
      UpdateResizeWindow(np, gwidth, gheight);
      }
#line 387
      if ((unsigned int )resizeMode == 1U) {
        {
#line 388
        ClearOutline();
        }
#line 389
        if (np->state.status & 256U) {
          {
#line 390
          DrawOutline(np->x - west, np->y - north, (np->width + west) + east, north + south);
          }
        } else {
          {
#line 394
          DrawOutline(np->x - west, np->y - north, (np->width + west) + east, (np->height + north) + south);
          }
        }
      } else {
        {
#line 399
        ResetRoundedRectWindow(np->parent);
        }
#line 400
        if (np->state.status & 256U) {
          {
#line 401
          ShapeRoundedRectWindow(np->parent, (np->width + east) + west, north + south);
#line 404
          XResizeWindow(display, np->parent, (unsigned int )((np->width + west) + east),
                        (unsigned int )(north + south));
          }
        } else {
          {
#line 407
          ShapeRoundedRectWindow(np->parent, (np->width + east) + west, (np->height + north) + south);
#line 410
          XResizeWindow(display, np->parent, (unsigned int )((np->width + west) + east),
                        (unsigned int )((np->height + north) + south));
          }
        }
        {
#line 413
        XResizeWindow(display, np->window, (unsigned int )np->width, (unsigned int )np->height);
#line 414
        SendConfigureEvent(np);
        }
      }
      {
#line 417
      UpdatePager();
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.c"
static void StopResize(ClientNode *np ) 
{ 
  int north ;
  int south ;
  int east ;
  int west ;

  {
#line 430
  np->controller = (void (*)(int wasDestroyed ))((void *)0);
#line 432
  if ((unsigned int )resizeMode == 1U) {
    {
#line 433
    ClearOutline();
    }
  }
  {
#line 436
  XUngrabPointer(display, (Time )0L);
#line 437
  XUngrabKeyboard(display, (Time )0L);
#line 439
  DestroyResizeWindow();
#line 441
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 444
  ResetRoundedRectWindow(np->parent);
  }
#line 446
  if (np->state.status & 256U) {
    {
#line 447
    ShapeRoundedRectWindow(np->parent, (np->width + east) + west, north + south);
#line 449
    XMoveResizeWindow(display, np->parent, np->x - west, np->y - north, (unsigned int )((np->width + east) + west),
                      (unsigned int )(north + south));
    }
  } else {
    {
#line 453
    ShapeRoundedRectWindow(np->parent, (np->width + east) + west, (np->height + north) + south);
#line 456
    XMoveResizeWindow(display, np->parent, np->x - west, np->y - north, (unsigned int )((np->width + east) + west),
                      (unsigned int )((np->height + north) + south));
    }
  }
  {
#line 461
  XMoveResizeWindow(display, np->window, west, north, (unsigned int )np->width, (unsigned int )np->height);
#line 463
  SendConfigureEvent(np);
  }
#line 465
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.c"
static void FixWidth(ClientNode *np ) 
{ 
  int ratio ;
  int minr ;
  int maxr ;

  {
#line 474
  if (np->sizeFlags & (1L << 7)) {
#line 474
    if (np->height > 0) {
#line 477
      ratio = (np->width << 16) / np->height;
#line 479
      minr = (np->aspect.minx << 16) / np->aspect.miny;
#line 480
      if (ratio < minr) {
#line 481
        np->width = np->height * minr >> 16;
      }
#line 484
      maxr = (np->aspect.maxx << 16) / np->aspect.maxy;
#line 485
      if (ratio > maxr) {
#line 486
        np->width = np->height * maxr >> 16;
      }
    }
  }
#line 491
  return;
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/resize.c"
static void FixHeight(ClientNode *np ) 
{ 
  int ratio ;
  int minr ;
  int maxr ;

  {
#line 500
  if (np->sizeFlags & (1L << 7)) {
#line 500
    if (np->height > 0) {
#line 502
      ratio = (np->width << 16) / np->height;
#line 504
      minr = (np->aspect.minx << 16) / np->aspect.miny;
#line 505
      if (ratio < minr) {
#line 506
        np->height = (np->width << 16) / minr;
      }
#line 509
      maxr = (np->aspect.maxx << 16) / np->aspect.maxy;
#line 510
      if (ratio > maxr) {
#line 511
        np->height = (np->width << 16) / maxr;
      }
    }
  }
#line 516
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/button.c"
static void GetScaledIconSize(IconNode *ip , int maxsize , int *width , int *height ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/button.c"
void DrawButton(ButtonNode *bp ) 
{ 
  long outlinePixel ;
  ColorType fg ;
  long bg1 ;
  long bg2 ;
  Drawable drawable ;
  GC gc ;
  int x ;
  int y ;
  int width ;
  int height ;
  int xoffset ;
  int yoffset ;
  int iconWidth ;
  int iconHeight ;
  int textWidth ;
  int textHeight ;

  {
#line 41
  drawable = bp->drawable;
#line 42
  gc = bp->gc;
#line 43
  x = bp->x;
#line 44
  y = bp->y;
#line 45
  width = bp->width;
#line 46
  height = bp->height;
  {
#line 50
  if ((unsigned int )bp->type == 0U) {
#line 50
    goto case_0;
  }
#line 56
  if ((unsigned int )bp->type == 2U) {
#line 56
    goto case_2;
  }
#line 66
  if ((unsigned int )bp->type == 3U) {
#line 66
    goto case_3;
  }
#line 72
  if ((unsigned int )bp->type == 4U) {
#line 72
    goto case_4;
  }
#line 79
  goto switch_default;
  case_0: /* CIL Label */ 
#line 51
  fg = (ColorType )23;
#line 52
  bg1 = (long )colors[22];
#line 53
  bg2 = (long )colors[22];
#line 54
  outlinePixel = (long )colors[22];
#line 55
  goto switch_break;
  case_2: /* CIL Label */ 
#line 57
  fg = (ColorType )26;
#line 58
  bg1 = (long )colors[24];
#line 59
  bg2 = (long )colors[25];
#line 60
  if (bg1 == bg2) {
#line 61
    outlinePixel = (long )colors[27];
  } else {
#line 63
    outlinePixel = (long )colors[37];
  }
#line 65
  goto switch_break;
  case_3: /* CIL Label */ 
#line 67
  fg = (ColorType )10;
#line 68
  bg1 = (long )colors[11];
#line 69
  bg2 = (long )colors[12];
#line 70
  outlinePixel = (long )colors[31];
#line 71
  goto switch_break;
  case_4: /* CIL Label */ 
#line 73
  fg = (ColorType )13;
#line 74
  bg1 = (long )colors[14];
#line 75
  bg2 = (long )colors[15];
#line 76
  outlinePixel = (long )colors[32];
#line 77
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 80
  fg = (ColorType )23;
#line 81
  bg1 = (long )colors[22];
#line 82
  bg2 = (long )colors[22];
#line 83
  outlinePixel = (long )colors[35];
#line 84
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 89
  if ((unsigned int )bp->type != 3U) {
#line 89
    goto _L;
  } else
#line 89
  if (width >= 48) {
    _L: /* CIL Label */ 
    {
#line 92
    XSetForeground(display, gc, (unsigned long )bg1);
    }
#line 93
    if (bg1 == bg2) {
      {
#line 95
      XFillRectangle(display, drawable, gc, x + 1, y + 1, (unsigned int )(width - 1),
                     (unsigned int )(height - 1));
      }
    } else {
      {
#line 99
      DrawHorizontalGradient(drawable, gc, bg1, bg2, x + 1, y + 1, (unsigned int )(width - 2),
                             (unsigned int )(height - 1));
      }
    }
    {
#line 104
    XSetForeground(display, gc, (unsigned long )outlinePixel);
#line 105
    DrawRoundedRectangle(drawable, gc, x, y, width, height, 3);
    }
  }
#line 110
  iconWidth = 0;
#line 111
  iconHeight = 0;
#line 112
  if (bp->icon) {
#line 113
    if (width < height) {
      {
#line 114
      GetScaledIconSize(bp->icon, width - 5, & iconWidth, & iconHeight);
      }
    } else {
      {
#line 116
      GetScaledIconSize(bp->icon, height - 5, & iconWidth, & iconHeight);
      }
    }
  }
#line 121
  textWidth = 0;
#line 122
  textHeight = 0;
#line 123
  if (bp->text) {
    {
#line 124
    textWidth = GetStringWidth(bp->font, bp->text);
#line 125
    textHeight = GetStringHeight(bp->font);
    }
#line 126
    if ((textWidth + iconWidth) + 8 > width) {
#line 127
      textWidth = (width - iconWidth) - 8;
#line 128
      if (textWidth < 0) {
#line 129
        textWidth = 0;
      }
    }
  }
#line 135
  if ((unsigned int )bp->alignment == 1U) {
#line 136
    xoffset = (((width - iconWidth) - textWidth) + 1) / 2;
#line 137
    if (xoffset < 0) {
#line 138
      xoffset = 0;
    }
  } else {
#line 141
    xoffset = 3;
  }
#line 145
  if (bp->icon) {
    {
#line 146
    yoffset = ((height - iconHeight) + 1) / 2;
#line 147
    PutIcon(bp->icon, drawable, x + xoffset, y + yoffset, iconWidth, iconHeight);
#line 149
    xoffset += iconWidth + 2;
    }
  }
#line 153
  if (bp->text) {
#line 153
    if (textWidth) {
      {
#line 154
      yoffset = ((height - textHeight) + 1) / 2;
#line 155
      RenderString(drawable, bp->font, fg, x + xoffset, y + yoffset, textWidth, (Region )((void *)0),
                   bp->text);
      }
    }
  }
#line 159
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/button.c"
void ResetButton(ButtonNode *bp , Drawable d , GC g ) 
{ 


  {
#line 166
  bp->type = (ButtonType )1;
#line 167
  bp->drawable = d;
#line 168
  bp->gc = g;
#line 169
  bp->font = (FontType )5;
#line 170
  bp->alignment = (AlignmentType )0;
#line 171
  bp->x = 0;
#line 172
  bp->y = 0;
#line 173
  bp->width = 1;
#line 174
  bp->height = 1;
#line 175
  bp->icon = (struct IconNode *)((void *)0);
#line 176
  bp->text = (char const   *)((void *)0);
#line 178
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/button.c"
static void GetScaledIconSize(IconNode *ip , int maxsize , int *width , int *height ) 
{ 
  int ratio ;

  {
#line 190
  if ((unsigned long )ip == (unsigned long )(& emptyIcon)) {
#line 191
    *width = maxsize;
#line 192
    *height = maxsize;
#line 193
    return;
  }
#line 199
  ratio = ((ip->image)->width << 16) / (ip->image)->height;
#line 201
  if ((ip->image)->width > (ip->image)->height) {
#line 204
    *width = maxsize * ratio >> 16;
#line 205
    *height = (*width << 16) / ratio;
  } else {
#line 210
    *height = (maxsize << 16) / ratio;
#line 211
    *width = *height * ratio >> 16;
  }
#line 215
  return;
}
}
#line 1623 "/usr/include/X11/Xlib.h"
extern Pixmap XCreatePixmapFromBitmapData(Display * , Drawable  , char * , unsigned int  ,
                                          unsigned int  , unsigned long  , unsigned long  ,
                                          unsigned int  ) ;
#line 2910
extern int XPutBackEvent(Display * , XEvent * ) ;
#line 116 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.h"
int menuShown ;
#line 34 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static char menu_bitmap[7]  = {      (char)1,      (char)3,      (char)7,      (char)15, 
        (char)7,      (char)3,      (char)1};
#line 38
static int ShowSubmenu(Menu *menu , Menu *parent , int x , int y ) ;
#line 40
static void CreateMenu(Menu *menu , int x , int y ) ;
#line 41
static void HideMenu(Menu *menu ) ;
#line 42
static void DrawMenu(Menu *menu ) ;
#line 43
static void RedrawMenuTree(Menu *menu ) ;
#line 45
static int MenuLoop(Menu *menu ) ;
#line 46
static MenuSelectionType UpdateMotion(Menu *menu , XEvent *event ) ;
#line 48
static void UpdateMenu(Menu *menu ) ;
#line 49
static void DrawMenuItem(Menu *menu , MenuItem *item , int index ) ;
#line 50
static MenuItem *GetMenuItem(Menu *menu , int index ) ;
#line 51
static int GetNextMenuIndex(Menu *menu ) ;
#line 52
static int GetPreviousMenuIndex(Menu *menu ) ;
#line 53
static int GetMenuIndex(Menu *menu , int y ) ;
#line 54
static void SetPosition(Menu *tp , int index ) ;
#line 55
static int IsMenuValid(Menu const   *menu ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static MenuAction *menuAction  =    (MenuAction *)((void *)0);
#line 58 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static unsigned int menuOpacity  =    4294967295U;
#line 60 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
int menuShown  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
void InitializeMenu(Menu *menu ) 
{ 
  MenuItem *np ;
  int index ;
  int temp ;
  int userHeight ;
  int hasSubmenu ;
  char hasIcon ;
  long tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 71
  menu->textOffset = 0;
#line 72
  menu->itemCount = 0U;
#line 75
  hasIcon = (char)0;
#line 76
  userHeight = menu->itemHeight;
#line 77
  if (userHeight < 0) {
#line 78
    userHeight = 0;
  }
  {
#line 80
  menu->itemHeight = GetStringHeight((FontType )1);
#line 81
  np = menu->items;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! np) {
#line 81
      goto while_break;
    }
#line 82
    if (np->iconName) {
      {
#line 83
      np->icon = LoadNamedIcon((char const   *)np->iconName);
      }
#line 84
      if (np->icon) {
#line 85
        if (userHeight == 0) {
#line 86
          if (menu->itemHeight < ((np->icon)->image)->height) {
#line 87
            menu->itemHeight = ((np->icon)->image)->height;
          }
#line 89
          if (menu->textOffset < ((np->icon)->image)->width + 4) {
#line 90
            menu->textOffset = ((np->icon)->image)->width + 4;
          }
        }
#line 93
        hasIcon = (char)1;
      }
    } else {
#line 96
      np->icon = (struct IconNode *)((void *)0);
    }
#line 98
    (menu->itemCount) ++;
#line 81
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  menu->itemHeight += 6;
#line 102
  if (userHeight) {
#line 103
    menu->itemHeight = userHeight + 6;
#line 104
    menu->textOffset = menu->itemHeight + 6;
  }
#line 107
  menu->width = 5;
#line 108
  menu->parent = (struct Menu *)((void *)0);
#line 109
  menu->parentOffset = 0;
#line 112
  if (menu->label) {
    {
#line 113
    temp = GetStringWidth((FontType )1, (char const   *)menu->label);
    }
#line 114
    if (temp > menu->width) {
#line 115
      menu->width = temp;
    }
  }
#line 119
  menu->height = 1;
#line 120
  if (menu->label) {
#line 121
    menu->height += menu->itemHeight;
  }
  {
#line 125
  tmp = __builtin_expect((long )(! (! (menu->itemCount == 0U))), 0L);
  }
#line 125
  if (tmp) {
#line 126
    return;
  }
  {
#line 129
  tmp___0 = malloc(sizeof(int ) * (unsigned long )menu->itemCount);
#line 129
  menu->offsets = (int *)tmp___0;
#line 131
  hasSubmenu = 0;
#line 132
  index = 0;
#line 133
  np = menu->items;
  }
  {
#line 133
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 133
    if (! np) {
#line 133
      goto while_break___0;
    }
#line 134
    tmp___1 = index;
#line 134
    index ++;
#line 134
    *(menu->offsets + tmp___1) = menu->height;
#line 135
    if ((unsigned int )np->type == 2U) {
#line 136
      menu->height += 5;
    } else {
#line 138
      menu->height += menu->itemHeight;
    }
#line 140
    if (np->name) {
      {
#line 141
      temp = GetStringWidth((FontType )1, (char const   *)np->name);
      }
#line 142
      if (temp > menu->width) {
#line 143
        menu->width = temp;
      }
    }
#line 146
    if (hasIcon) {
#line 146
      if (! np->icon) {
#line 147
        np->icon = & emptyIcon;
      }
    }
#line 149
    if (np->submenu) {
      {
#line 150
      hasSubmenu = 7;
#line 151
      InitializeMenu(np->submenu);
      }
    }
#line 133
    np = np->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 154
  menu->height += 2;
#line 155
  menu->width += (12 + hasSubmenu) + menu->textOffset;
#line 157
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
void ShowMenu(Menu *menu , void (*runner)(MenuAction const   *action ) , int x , int y ) 
{ 
  int mouseStatus ;
  int keyboardStatus ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 165
  tmp = IsMenuValid((Menu const   *)menu);
  }
#line 165
  if (tmp) {
#line 165
    tmp___0 = 0;
  } else {
#line 165
    tmp___0 = 1;
  }
  {
#line 165
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 165
  if (tmp___1) {
#line 166
    return;
  }
  {
#line 169
  mouseStatus = GrabMouse(rootWindow);
#line 170
  keyboardStatus = XGrabKeyboard(display, rootWindow, 0, 1, 1, (Time )0L);
  }
#line 172
  if (! mouseStatus) {
#line 172
    tmp___2 = 1;
  } else
#line 172
  if (keyboardStatus != 0) {
#line 172
    tmp___2 = 1;
  } else {
#line 172
    tmp___2 = 0;
  }
  {
#line 172
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  }
#line 172
  if (tmp___3) {
#line 173
    return;
  }
  {
#line 176
  ShowSubmenu(menu, (Menu *)((void *)0), x, y);
#line 178
  XUngrabKeyboard(display, (Time )0L);
#line 179
  XUngrabPointer(display, (Time )0L);
#line 180
  RefocusClient();
  }
#line 182
  if (menuAction) {
    {
#line 183
    (*runner)((MenuAction const   *)menuAction);
#line 184
    menuAction = (MenuAction *)((void *)0);
    }
  }
#line 187
  if (shouldReload) {
    {
#line 188
    ReloadMenu();
    }
  }
#line 191
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
void DestroyMenu(Menu *menu ) 
{ 
  MenuItem *np ;

  {
#line 197
  if (menu) {
    {
#line 198
    while (1) {
      while_continue: /* CIL Label */ ;
#line 198
      if (! menu->items) {
#line 198
        goto while_break;
      }
#line 199
      np = (menu->items)->next;
#line 200
      if ((menu->items)->name) {
        {
#line 201
        free((void *)(menu->items)->name);
        }
      }
      {
#line 205
      if ((unsigned int )(menu->items)->action.type == 16U) {
#line 205
        goto case_16;
      }
#line 205
      if ((unsigned int )(menu->items)->action.type == 1U) {
#line 205
        goto case_16;
      }
#line 210
      goto switch_default;
      case_16: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 206
      if ((menu->items)->action.data.str) {
        {
#line 207
        free((void *)(menu->items)->action.data.str);
        }
      }
#line 209
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 211
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 213
      if ((menu->items)->iconName) {
        {
#line 214
        free((void *)(menu->items)->iconName);
        }
      }
#line 216
      if ((menu->items)->submenu) {
        {
#line 217
        DestroyMenu((menu->items)->submenu);
        }
      }
      {
#line 219
      free((void *)menu->items);
#line 220
      menu->items = np;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 222
    if (menu->label) {
      {
#line 223
      free((void *)menu->label);
      }
    }
#line 225
    if (menu->offsets) {
      {
#line 226
      free((void *)menu->offsets);
      }
    }
    {
#line 228
    free((void *)menu);
#line 229
    menu = (Menu *)((void *)0);
    }
  }
#line 231
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static int ShowSubmenu(Menu *menu , Menu *parent , int x , int y ) 
{ 
  int status ;

  {
  {
#line 238
  menu->parent = parent;
#line 239
  CreateMenu(menu, x, y);
#line 241
  menuShown ++;
#line 242
  status = MenuLoop(menu);
#line 243
  menuShown --;
#line 245
  HideMenu(menu);
  }
#line 247
  return (status);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static int MenuLoop(Menu *menu ) 
{ 
  XEvent event ;
  MenuItem *ip ;
  int count ;
  int hadMotion ;
  int pressx ;
  int pressy ;
  MenuSelectionType tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 262
  hadMotion = 0;
#line 264
  GetMousePosition(& pressx, & pressy);
  }
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 268
    WaitForEvent(& event);
    }
    {
#line 271
    if (event.type == 12) {
#line 271
      goto case_12;
    }
#line 275
    if (event.type == 4) {
#line 275
      goto case_4;
    }
#line 281
    if (event.type == 6) {
#line 281
      goto case_6;
    }
#line 281
    if (event.type == 2) {
#line 281
      goto case_6;
    }
#line 294
    if (event.type == 5) {
#line 294
      goto case_5;
    }
#line 322
    goto switch_default;
    case_12: /* CIL Label */ 
    {
#line 272
    RedrawMenuTree(menu);
    }
#line 273
    goto switch_break;
    case_4: /* CIL Label */ 
#line 277
    pressx = -100;
#line 278
    pressy = -100;
    case_6: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 282
    hadMotion = 1;
#line 283
    tmp = UpdateMotion(menu, & event);
    }
    {
#line 284
    if ((unsigned int )tmp == 0U) {
#line 284
      goto case_0;
    }
#line 286
    if ((unsigned int )tmp == 1U) {
#line 286
      goto case_1;
    }
#line 289
    if ((unsigned int )tmp == 2U) {
#line 289
      goto case_2___0;
    }
#line 283
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 285
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 287
    XPutBackEvent(display, & event);
    }
#line 288
    return (0);
    case_2___0: /* CIL Label */ 
#line 290
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
#line 292
    goto switch_break;
    case_5: /* CIL Label */ 
#line 296
    if (event.xbutton.button == 4U) {
#line 297
      goto switch_break;
    }
#line 299
    if (event.xbutton.button == 5U) {
#line 300
      goto switch_break;
    }
#line 302
    if (! hadMotion) {
#line 303
      goto switch_break;
    }
    {
#line 305
    tmp___1 = abs(event.xbutton.x_root - pressx);
    }
#line 305
    if ((unsigned int )tmp___1 < doubleClickDelta) {
      {
#line 306
      tmp___0 = abs(event.xbutton.y_root - pressy);
      }
#line 306
      if ((unsigned int )tmp___0 < doubleClickDelta) {
#line 307
        goto switch_break;
      }
    }
#line 311
    if (menu->currentIndex >= 0) {
#line 312
      count = 0;
#line 313
      ip = menu->items;
      {
#line 313
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 313
        if (! ip) {
#line 313
          goto while_break___0;
        }
#line 314
        if (count == menu->currentIndex) {
#line 315
          menuAction = & ip->action;
#line 316
          goto while_break___0;
        }
#line 318
        count ++;
#line 313
        ip = ip->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 321
    return (1);
    switch_default: /* CIL Label */ 
#line 323
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static void CreateMenu(Menu *menu , int x , int y ) 
{ 
  XSetWindowAttributes attr ;
  unsigned long attrMask ;
  int temp ;

  {
#line 336
  menu->lastIndex = -1;
#line 337
  menu->currentIndex = -1;
#line 339
  if (x + menu->width > rootWidth) {
#line 340
    if (menu->parent) {
#line 341
      x = (menu->parent)->x - menu->width;
    } else {
#line 343
      x = rootWidth - menu->width;
    }
  }
#line 346
  temp = y;
#line 347
  if (y + menu->height > rootHeight) {
#line 348
    y = rootHeight - menu->height;
  }
#line 350
  if (y < 0) {
#line 351
    y = 0;
  }
  {
#line 354
  menu->x = x;
#line 355
  menu->y = y;
#line 356
  menu->parentOffset = temp - y;
#line 358
  attrMask = 0UL;
#line 360
  attrMask |= (unsigned long )(1L << 11);
#line 361
  attr.event_mask = 1L << 15;
#line 363
  attrMask |= (unsigned long )(1L << 1);
#line 364
  attr.background_pixel = colors[22];
#line 366
  attrMask |= (unsigned long )(1L << 10);
#line 367
  attr.save_under = 1;
#line 369
  menu->window = XCreateWindow(display, rootWindow, x, y, (unsigned int )menu->width,
                               (unsigned int )menu->height, 0U, 0, 1U, (Visual *)0L,
                               attrMask, & attr);
  }
#line 373
  if (menuOpacity < 4294967295U) {
    {
#line 374
    SetCardinalAtom(menu->window, (AtomType )59, (unsigned long )menuOpacity);
#line 375
    XSync(display, 0);
    }
  }
  {
#line 378
  XMapRaised(display, menu->window);
  }
#line 380
  return;
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static void HideMenu(Menu *menu ) 
{ 


  {
  {
#line 385
  XDestroyWindow(display, menu->window);
  }
#line 387
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static void RedrawMenuTree(Menu *menu ) 
{ 


  {
#line 392
  if (menu->parent) {
    {
#line 393
    RedrawMenuTree(menu->parent);
    }
  }
  {
#line 396
  DrawMenu(menu);
#line 397
  UpdateMenu(menu);
  }
#line 399
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static void DrawMenu(Menu *menu ) 
{ 
  MenuItem *np ;
  int x ;
  XSegment segments[4] ;

  {
#line 408
  if (menu->label) {
    {
#line 409
    DrawMenuItem(menu, (MenuItem *)((void *)0), -1);
    }
  }
#line 412
  x = 0;
#line 413
  np = menu->items;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! np) {
#line 413
      goto while_break;
    }
    {
#line 414
    DrawMenuItem(menu, np, x);
#line 415
    x ++;
#line 413
    np = np->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 418
  XSetForeground(display, rootGC, colors[34]);
#line 419
  segments[0].x1 = (short)0;
#line 419
  segments[0].y1 = (short)0;
#line 420
  segments[0].x2 = (short )(menu->width - 1);
#line 420
  segments[0].y2 = (short)0;
#line 421
  segments[1].x1 = (short)0;
#line 421
  segments[1].y1 = (short)1;
#line 422
  segments[1].x2 = (short )(menu->width - 2);
#line 422
  segments[1].y2 = (short)1;
#line 423
  segments[2].x1 = (short)0;
#line 423
  segments[2].y1 = (short)2;
#line 424
  segments[2].x2 = (short)0;
#line 424
  segments[2].y2 = (short )(menu->height - 1);
#line 425
  segments[3].x1 = (short)1;
#line 425
  segments[3].y1 = (short)2;
#line 426
  segments[3].x2 = (short)1;
#line 426
  segments[3].y2 = (short )(menu->height - 2);
#line 427
  XDrawSegments(display, menu->window, rootGC, segments, 4);
#line 429
  XSetForeground(display, rootGC, colors[35]);
#line 430
  segments[0].x1 = (short)1;
#line 430
  segments[0].y1 = (short )(menu->height - 1);
#line 431
  segments[0].x2 = (short )(menu->width - 1);
#line 431
  segments[0].y2 = (short )(menu->height - 1);
#line 432
  segments[1].x1 = (short)2;
#line 432
  segments[1].y1 = (short )(menu->height - 2);
#line 433
  segments[1].x2 = (short )(menu->width - 1);
#line 433
  segments[1].y2 = (short )(menu->height - 2);
#line 434
  segments[2].x1 = (short )(menu->width - 1);
#line 434
  segments[2].y1 = (short)1;
#line 435
  segments[2].x2 = (short )(menu->width - 1);
#line 435
  segments[2].y2 = (short )(menu->height - 3);
#line 436
  segments[3].x1 = (short )(menu->width - 2);
#line 436
  segments[3].y1 = (short)2;
#line 437
  segments[3].x2 = (short )(menu->width - 2);
#line 437
  segments[3].y2 = (short )(menu->height - 3);
#line 438
  XDrawSegments(display, menu->window, rootGC, segments, 4);
  }
#line 440
  return;
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static MenuSelectionType UpdateMotion(Menu *menu , XEvent *event ) 
{ 
  MenuItem *ip ;
  Menu *tp ;
  Window subwindow ;
  int x ;
  int y ;
  KeyType tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 450
  if (event->type == 6) {
    {
#line 452
    SetMousePosition(event->xmotion.x_root, event->xmotion.y_root);
#line 453
    DiscardMotionEvents(event, menu->window);
#line 455
    x = event->xmotion.x_root - menu->x;
#line 456
    y = event->xmotion.y_root - menu->y;
#line 457
    subwindow = event->xmotion.subwindow;
    }
  } else
#line 459
  if (event->type == 4) {
#line 461
    if (menu->currentIndex >= 0) {
#line 462
      tp = menu;
    } else
#line 461
    if (! menu->parent) {
#line 462
      tp = menu;
    } else {
#line 464
      tp = menu->parent;
    }
#line 467
    y = -1;
#line 468
    if (event->xbutton.button == 4U) {
      {
#line 469
      y = GetPreviousMenuIndex(tp);
      }
    } else
#line 470
    if (event->xbutton.button == 5U) {
      {
#line 471
      y = GetNextMenuIndex(tp);
      }
    }
#line 474
    if (y >= 0) {
      {
#line 475
      SetPosition(tp, y);
      }
    }
#line 478
    return ((MenuSelectionType )0);
  } else
#line 480
  if (event->type == 2) {
#line 482
    if (menu->currentIndex >= 0) {
#line 483
      tp = menu;
    } else
#line 482
    if (! menu->parent) {
#line 483
      tp = menu;
    } else {
#line 485
      tp = menu->parent;
    }
    {
#line 488
    y = -1;
#line 489
    tmp = GetKey((XKeyEvent const   *)(& event->xkey));
    }
    {
#line 490
    if (((unsigned int )tmp & 255U) == 1U) {
#line 490
      goto case_1;
    }
#line 493
    if (((unsigned int )tmp & 255U) == 2U) {
#line 493
      goto case_2;
    }
#line 496
    if (((unsigned int )tmp & 255U) == 3U) {
#line 496
      goto case_3;
    }
#line 500
    if (((unsigned int )tmp & 255U) == 4U) {
#line 500
      goto case_4;
    }
#line 510
    if (((unsigned int )tmp & 255U) == 5U) {
#line 510
      goto case_5;
    }
#line 512
    if (((unsigned int )tmp & 255U) == 6U) {
#line 512
      goto case_6;
    }
#line 524
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 491
    y = GetPreviousMenuIndex(tp);
    }
#line 492
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 494
    y = GetNextMenuIndex(tp);
    }
#line 495
    goto switch_break;
    case_3: /* CIL Label */ 
#line 497
    tp = menu;
#line 498
    y = 0;
#line 499
    goto switch_break;
    case_4: /* CIL Label */ 
#line 501
    if (tp->parent) {
#line 502
      tp = tp->parent;
#line 503
      if (tp->currentIndex >= 0) {
#line 504
        y = tp->currentIndex;
      } else {
#line 506
        y = 0;
      }
    }
#line 509
    goto switch_break;
    case_5: /* CIL Label */ 
#line 511
    return ((MenuSelectionType )2);
    case_6: /* CIL Label */ 
#line 513
    if (tp->currentIndex >= 0) {
#line 514
      x = 0;
#line 515
      ip = tp->items;
      {
#line 515
      while (1) {
        while_continue: /* CIL Label */ ;
#line 515
        if (! ip) {
#line 515
          goto while_break;
        }
#line 516
        if (x == tp->currentIndex) {
#line 517
          menuAction = & ip->action;
#line 518
          goto while_break;
        }
#line 520
        x ++;
#line 515
        ip = ip->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 523
    return ((MenuSelectionType )2);
    switch_default: /* CIL Label */ 
#line 525
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 528
    if (y >= 0) {
      {
#line 529
      SetPosition(tp, y);
      }
    }
#line 532
    return ((MenuSelectionType )0);
  } else {
    {
#line 535
    Debug("invalid event type in menu.c:UpdateMotion");
    }
#line 536
    return ((MenuSelectionType )2);
  }
#line 540
  if (x > 0) {
#line 540
    if (y > 0) {
#line 540
      if (x < menu->width) {
#line 540
        if (y < menu->height) {
          {
#line 541
          menu->currentIndex = GetMenuIndex(menu, y);
          }
        } else {
#line 540
          goto _L___2;
        }
      } else {
#line 540
        goto _L___2;
      }
    } else {
#line 540
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 542
  if (menu->parent) {
#line 542
    if (subwindow != (menu->parent)->window) {
#line 545
      tp = (menu->parent)->parent;
      {
#line 545
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 545
        if (! tp) {
#line 545
          goto while_break___0;
        }
#line 546
        if (tp->window == subwindow) {
#line 547
          return ((MenuSelectionType )1);
        }
#line 545
        tp = tp->parent;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 550
      menu->currentIndex = -1;
    } else {
#line 542
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 555
    tp = menu->parent;
#line 556
    if (tp) {
#line 556
      if (subwindow == tp->window) {
#line 557
        if (y < menu->parentOffset) {
#line 559
          return ((MenuSelectionType )1);
        } else
#line 557
        if (y > tp->itemHeight + menu->parentOffset) {
#line 559
          return ((MenuSelectionType )1);
        }
      }
    }
#line 563
    menu->currentIndex = -1;
  }
#line 568
  if (menu->height > rootHeight) {
#line 568
    if (menu->currentIndex >= 0) {
#line 571
      if (y + menu->y <= 0) {
#line 572
        if (menu->currentIndex > 0) {
          {
#line 573
          (menu->currentIndex) --;
#line 574
          SetPosition(menu, menu->currentIndex);
          }
        }
      }
#line 579
      if ((y + menu->y) + menu->itemHeight / 2 >= rootHeight) {
#line 580
        if ((unsigned int )(menu->currentIndex + 1) < menu->itemCount) {
          {
#line 581
          (menu->currentIndex) ++;
#line 582
          SetPosition(menu, menu->currentIndex);
          }
        }
      }
    }
  }
#line 588
  if (menu->lastIndex != menu->currentIndex) {
    {
#line 589
    UpdateMenu(menu);
#line 590
    menu->lastIndex = menu->currentIndex;
    }
  }
  {
#line 594
  ip = GetMenuItem(menu, menu->currentIndex);
  }
#line 595
  if (ip) {
    {
#line 595
    tmp___1 = IsMenuValid((Menu const   *)ip->submenu);
    }
#line 595
    if (tmp___1) {
      {
#line 596
      tmp___0 = ShowSubmenu(ip->submenu, menu, menu->x + menu->width, menu->y + *(menu->offsets + menu->currentIndex));
      }
#line 596
      if (tmp___0) {
#line 600
        return ((MenuSelectionType )2);
      } else {
        {
#line 605
        UpdateMenu(menu);
        }
      }
    }
  }
#line 610
  return ((MenuSelectionType )0);
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static void UpdateMenu(Menu *menu ) 
{ 
  ButtonNode button ;
  Pixmap pixmap ;
  MenuItem *ip ;

  {
  {
#line 622
  ip = GetMenuItem(menu, menu->lastIndex);
#line 623
  DrawMenuItem(menu, ip, menu->lastIndex);
#line 626
  ip = GetMenuItem(menu, menu->currentIndex);
  }
#line 627
  if (ip) {
#line 629
    if ((unsigned int )ip->type == 2U) {
#line 630
      return;
    }
    {
#line 633
    ResetButton(& button, menu->window, rootGC);
#line 634
    button.type = (ButtonType )2;
#line 635
    button.font = (FontType )1;
#line 636
    button.width = menu->width - 5;
#line 637
    button.height = menu->itemHeight - 2;
#line 638
    button.icon = ip->icon;
#line 639
    button.text = (char const   *)ip->name;
#line 640
    button.x = 2;
#line 641
    button.y = *(menu->offsets + menu->currentIndex) + 1;
#line 642
    DrawButton(& button);
    }
#line 644
    if (ip->submenu) {
      {
#line 645
      pixmap = XCreateBitmapFromData(display, menu->window, (char const   *)(menu_bitmap),
                                     4U, 7U);
#line 647
      XSetForeground(display, rootGC, colors[26]);
#line 648
      XSetClipMask(display, rootGC, pixmap);
#line 649
      XSetClipOrigin(display, rootGC, menu->width - 9, (*(menu->offsets + menu->currentIndex) + menu->itemHeight / 2) - 4);
#line 652
      XFillRectangle(display, menu->window, rootGC, menu->width - 9, (*(menu->offsets + menu->currentIndex) + menu->itemHeight / 2) - 4,
                     4U, 7U);
#line 656
      XSetClipMask(display, rootGC, (Pixmap )0L);
#line 657
      XFreePixmap(display, pixmap);
      }
    }
  }
#line 661
  return;
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static void DrawMenuItem(Menu *menu , MenuItem *item , int index ) 
{ 
  ButtonNode button ;
  Pixmap pixmap ;

  {
#line 671
  if (! item) {
#line 672
    if (index == -1) {
#line 672
      if (menu->label) {
        {
#line 673
        ResetButton(& button, menu->window, rootGC);
#line 674
        button.x = 2;
#line 675
        button.y = 2;
#line 676
        button.width = menu->width - 5;
#line 677
        button.height = menu->itemHeight - 2;
#line 678
        button.font = (FontType )1;
#line 679
        button.type = (ButtonType )0;
#line 680
        button.text = (char const   *)menu->label;
#line 681
        button.alignment = (AlignmentType )1;
#line 682
        DrawButton(& button);
        }
      }
    }
#line 684
    return;
  }
#line 687
  if ((unsigned int )item->type != 2U) {
    {
#line 689
    ResetButton(& button, menu->window, rootGC);
#line 690
    button.x = 2;
#line 691
    button.y = 1 + *(menu->offsets + index);
#line 692
    button.font = (FontType )1;
#line 693
    button.type = (ButtonType )0;
#line 694
    button.width = menu->width - 5;
#line 695
    button.height = menu->itemHeight - 2;
#line 696
    button.text = (char const   *)item->name;
#line 697
    button.icon = item->icon;
#line 698
    DrawButton(& button);
    }
  } else {
    {
#line 702
    XSetForeground(display, rootGC, colors[35]);
#line 703
    XDrawLine(display, menu->window, rootGC, 4, *(menu->offsets + index) + 2, menu->width - 6,
              *(menu->offsets + index) + 2);
#line 706
    XSetForeground(display, rootGC, colors[34]);
#line 707
    XDrawLine(display, menu->window, rootGC, 4, *(menu->offsets + index) + 3, menu->width - 6,
              *(menu->offsets + index) + 3);
    }
  }
#line 713
  if (item->submenu) {
    {
#line 715
    pixmap = XCreatePixmapFromBitmapData(display, menu->window, menu_bitmap, 4U, 7U,
                                         colors[23], colors[22], (unsigned int )rootDepth);
#line 718
    XCopyArea(display, pixmap, menu->window, rootGC, 0, 0, 4U, 7U, menu->width - 9,
              (*(menu->offsets + index) + menu->itemHeight / 2) - 4);
#line 720
    XFreePixmap(display, pixmap);
    }
  }
#line 724
  return;
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static int GetNextMenuIndex(Menu *menu ) 
{ 
  MenuItem *item ;
  int x ;

  {
#line 732
  x = menu->currentIndex + 1;
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 732
    if (! ((unsigned int )x < menu->itemCount)) {
#line 732
      goto while_break;
    }
    {
#line 733
    item = GetMenuItem(menu, x);
    }
#line 734
    if ((unsigned int )item->type != 2U) {
#line 735
      return (x);
    }
#line 732
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 739
  return (0);
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static int GetPreviousMenuIndex(Menu *menu ) 
{ 
  MenuItem *item ;
  int x ;

  {
#line 749
  x = menu->currentIndex - 1;
  {
#line 749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 749
    if (! (x >= 0)) {
#line 749
      goto while_break;
    }
    {
#line 750
    item = GetMenuItem(menu, x);
    }
#line 751
    if ((unsigned int )item->type != 2U) {
#line 752
      return (x);
    }
#line 749
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 756
  return ((int )(menu->itemCount - 1U));
}
}
#line 761 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static int GetMenuIndex(Menu *menu , int y ) 
{ 
  int x ;

  {
#line 765
  if (y < *(menu->offsets + 0)) {
#line 766
    return (-1);
  }
#line 768
  x = 0;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    if (! ((unsigned int )x < menu->itemCount - 1U)) {
#line 768
      goto while_break;
    }
#line 769
    if (y >= *(menu->offsets + x)) {
#line 769
      if (y < *(menu->offsets + (x + 1))) {
#line 770
        return (x);
      }
    }
#line 768
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 773
  return (x);
}
}
#line 778 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static MenuItem *GetMenuItem(Menu *menu , int index ) 
{ 
  MenuItem *ip ;

  {
#line 782
  if (index >= 0) {
#line 783
    ip = menu->items;
    {
#line 783
    while (1) {
      while_continue: /* CIL Label */ ;
#line 783
      if (! ip) {
#line 783
        goto while_break;
      }
#line 784
      if (! index) {
#line 785
        return (ip);
      }
#line 787
      index --;
#line 783
      ip = ip->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 790
    ip = (MenuItem *)((void *)0);
  }
#line 793
  return (ip);
}
}
#line 798 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static void SetPosition(Menu *tp , int index ) 
{ 
  int y ;
  int updated ;

  {
#line 803
  y = *(tp->offsets + index) + tp->itemHeight / 2;
#line 805
  if (tp->height > rootHeight) {
#line 807
    updated = 0;
    {
#line 808
    while (1) {
      while_continue: /* CIL Label */ ;
#line 808
      if (! (y + tp->y < tp->itemHeight / 2)) {
#line 808
        goto while_break;
      }
#line 809
      tp->y += tp->itemHeight;
#line 810
      updated = tp->itemHeight;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 812
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 812
      if (! (y + tp->y >= rootHeight)) {
#line 812
        goto while_break___0;
      }
#line 813
      tp->y -= tp->itemHeight;
#line 814
      updated = - tp->itemHeight;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 816
    if (updated) {
      {
#line 817
      XMoveWindow(display, tp->window, tp->x, tp->y);
#line 818
      y += updated;
      }
    }
  }
  {
#line 825
  MoveMouse(tp->window, 6, y);
#line 826
  MoveMouse(tp->window, 6, y);
  }
#line 828
  return;
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
static int IsMenuValid(Menu const   *menu ) 
{ 
  MenuItem *ip ;

  {
#line 835
  if (menu) {
#line 836
    ip = (MenuItem *)menu->items;
    {
#line 836
    while (1) {
      while_continue: /* CIL Label */ ;
#line 836
      if (! ip) {
#line 836
        goto while_break;
      }
#line 837
      if ((unsigned int )ip->type != 2U) {
#line 838
        return (1);
      }
#line 836
      ip = ip->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 843
  return (0);
}
}
#line 848 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/menu.c"
void SetMenuOpacity(char const   *str___0 ) 
{ 
  double temp ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 854
  temp = atof(str___0);
  }
#line 855
  if (temp <= 0.0) {
#line 855
    tmp___0 = 1;
  } else
#line 855
  if (temp > 1.0) {
#line 855
    tmp___0 = 1;
  } else {
#line 855
    tmp___0 = 0;
  }
  {
#line 855
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 855
  if (tmp___1) {
    {
#line 856
    tmp = gettext("invalid menu opacity: %s");
#line 856
    Warning((char const   *)tmp, str___0);
#line 857
    temp = 1.0;
    }
  }
#line 859
  menuOpacity = (unsigned int )(temp * (double )4294967295U);
#line 861
  return;
}
}
#line 1435 "/usr/include/X11/Xlib.h"
extern XModifierKeymap *XGetModifierMapping(Display * ) ;
#line 1722
extern KeySym XStringToKeysym(char const   * ) ;
#line 2578
extern int XFreeModifiermap(XModifierKeymap * ) ;
#line 2722
extern int XGrabKey(Display * , int  , unsigned int  , Window  , int  , int  , int  ) ;
#line 2785
extern KeyCode XKeysymToKeycode(Display * , KeySym  ) ;
#line 3481
extern int XUngrabKey(Display * , int  , unsigned int  , Window  ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.h"
int IsRootMenuDefined(int index ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
static ModifierNode modifiers[9]  = 
#line 37 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
  {      {(char )'C', (unsigned int )(1 << 2)}, 
        {(char )'S', 1U}, 
        {(char )'A', (unsigned int )(1 << 3)}, 
        {(char )'1', (unsigned int )(1 << 3)}, 
        {(char )'2', (unsigned int )(1 << 4)}, 
        {(char )'3', (unsigned int )(1 << 5)}, 
        {(char )'4', (unsigned int )(1 << 6)}, 
        {(char )'5', (unsigned int )(1 << 7)}, 
        {(char)0, 0U}};
#line 70 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
static LockNode lockMods[2]  = {      {(KeySym )65509, 0U}, 
        {(KeySym )65407, 0U}};
#line 75 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
static KeyNode *bindings  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
static unsigned int lockMask  ;
#line 78
static unsigned int GetModifierMask(XModifierKeymap *modmap , KeySym key ) ;
#line 79
static unsigned int ParseModifierString(char const   *str___0 ) ;
#line 80
static KeySym ParseKeyString(char const   *str___0 ) ;
#line 81
static int ShouldGrab(KeyType key ) ;
#line 82
static void GrabKey(KeyNode *np , Window win ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
void InitializeKeys(void) 
{ 


  {
#line 87
  bindings = (KeyNode *)((void *)0);
#line 88
  lockMask = 0U;
#line 90
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
void StartupKeys(void) 
{ 
  XModifierKeymap *modmap ;
  KeyNode *np ;
  TrayType *tp ;
  int x ;
  int tmp ;

  {
  {
#line 102
  modmap = XGetModifierMapping(display);
#line 103
  x = 0;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ((unsigned long )x < sizeof(lockMods) / sizeof(lockMods[0]))) {
#line 103
      goto while_break;
    }
    {
#line 104
    lockMods[x].mask = GetModifierMask(modmap, lockMods[x].symbol);
#line 105
    lockMask |= lockMods[x].mask;
#line 103
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  XFreeModifiermap(modmap);
#line 110
  np = bindings;
  }
  {
#line 110
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 110
    if (! np) {
#line 110
      goto while_break___0;
    }
#line 113
    if (! np->code) {
      {
#line 114
      np->code = XKeysymToKeycode(display, np->symbol);
      }
    }
    {
#line 118
    tmp = ShouldGrab((KeyType )np->key);
    }
#line 118
    if (tmp) {
      {
#line 121
      GrabKey(np, rootWindow);
#line 124
      tp = GetTrays();
      }
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 124
        if (! tp) {
#line 124
          goto while_break___1;
        }
        {
#line 125
        GrabKey(np, tp->window);
#line 124
        tp = tp->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 110
    np = np->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 133
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
void ShutdownKeys(void) 
{ 
  ClientNode *np ;
  TrayType *tp ;
  int layer ;

  {
#line 143
  layer = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (layer < 13)) {
#line 143
      goto while_break;
    }
#line 144
    np = nodes[layer];
    {
#line 144
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 144
      if (! np) {
#line 144
        goto while_break___0;
      }
      {
#line 145
      XUngrabKey(display, 0, (unsigned int )(1 << 15), np->window);
#line 144
      np = np->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 143
    layer ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  tp = GetTrays();
  }
  {
#line 150
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 150
    if (! tp) {
#line 150
      goto while_break___1;
    }
    {
#line 151
    XUngrabKey(display, 0, (unsigned int )(1 << 15), tp->window);
#line 150
    tp = tp->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 155
  XUngrabKey(display, 0, (unsigned int )(1 << 15), rootWindow);
  }
#line 157
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
void DestroyKeys(void) 
{ 
  KeyNode *np ;

  {
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! bindings) {
#line 164
      goto while_break;
    }
#line 165
    np = bindings->next;
#line 166
    if (bindings->command) {
      {
#line 167
      free((void *)bindings->command);
      }
    }
    {
#line 169
    free((void *)bindings);
#line 170
    bindings = np;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
static void GrabKey(KeyNode *np , Window win ) 
{ 
  int x ;
  int index ;
  int maxIndex ;
  unsigned int mask ;

  {
#line 183
  if (! np->code) {
#line 184
    return;
  }
#line 188
  maxIndex = 1 << sizeof(lockMods) / sizeof(lockMods[0]);
#line 189
  index = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (index < maxIndex)) {
#line 189
      goto while_break;
    }
#line 192
    mask = 0U;
#line 193
    x = 0;
    {
#line 193
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 193
      if (! ((unsigned long )x < sizeof(lockMods) / sizeof(lockMods[0]))) {
#line 193
        goto while_break___0;
      }
#line 194
      if (index & (1 << x)) {
#line 195
        mask |= lockMods[x].mask;
      }
#line 193
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 198
    mask |= np->state;
#line 201
    XGrabKey(display, (int )np->code, mask, win, 1, 1, 1);
#line 189
    index ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
KeyType GetKey(XKeyEvent const   *event ) 
{ 
  KeyNode *np ;
  unsigned int state ;

  {
#line 215
  state = (unsigned int )(event->state & (unsigned int const   )(~ lockMask));
#line 218
  np = bindings;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! np) {
#line 218
      goto while_break;
    }
#line 219
    if (np->state == state) {
#line 219
      if ((unsigned int const   )np->code == event->keycode) {
#line 220
        return ((KeyType )np->key);
      }
    }
#line 218
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return ((KeyType )0);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
void RunKeyCommand(XKeyEvent const   *event ) 
{ 
  KeyNode *np ;
  unsigned int state ;

  {
#line 235
  state = (unsigned int )(event->state & (unsigned int const   )(~ lockMask));
#line 237
  np = bindings;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! np) {
#line 237
      goto while_break;
    }
#line 238
    if (np->state == state) {
#line 238
      if ((unsigned int const   )np->code == event->keycode) {
        {
#line 239
        RunCommand((char const   *)np->command);
        }
#line 240
        return;
      }
    }
#line 237
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return;
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
void ShowKeyMenu(XKeyEvent const   *event ) 
{ 
  KeyNode *np ;
  int button ;
  unsigned int state ;

  {
#line 254
  state = (unsigned int )(event->state & (unsigned int const   )(~ lockMask));
#line 256
  np = bindings;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! np) {
#line 256
      goto while_break;
    }
#line 257
    if (np->state == state) {
#line 257
      if ((unsigned int const   )np->code == event->keycode) {
        {
#line 258
        button = atoi((char const   *)np->command);
        }
#line 259
        if (button >= 0) {
#line 259
          if (button <= 9) {
            {
#line 260
            ShowRootMenu(button, 0, 0);
            }
          }
        }
#line 262
        return;
      }
    }
#line 256
    np = np->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
static int ShouldGrab(KeyType key ) 
{ 


  {
  {
#line 294
  if (((unsigned int )key & 255U) == 30U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 29U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 28U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 27U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 26U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 25U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 23U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 24U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 22U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 21U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 20U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 19U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 18U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 17U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 16U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 15U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 14U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 13U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 12U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 11U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 10U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 9U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 8U) {
#line 294
    goto case_30;
  }
#line 294
  if (((unsigned int )key & 255U) == 7U) {
#line 294
    goto case_30;
  }
#line 296
  goto switch_default;
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 295
  return (1);
  switch_default: /* CIL Label */ 
#line 297
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
void GrabKeys(struct ClientNode *np ) 
{ 
  KeyNode *kp ;
  int tmp ;

  {
#line 306
  kp = bindings;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! kp) {
#line 306
      goto while_break;
    }
    {
#line 307
    tmp = ShouldGrab((KeyType )kp->key);
    }
#line 307
    if (tmp) {
      {
#line 308
      GrabKey(kp, np->window);
      }
    }
#line 306
    kp = kp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
static unsigned int GetModifierMask(XModifierKeymap *modmap , KeySym key ) 
{ 
  KeyCode temp ;
  int x ;
  char *tmp ;
  long tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 320
  temp = XKeysymToKeycode(display, key);
#line 321
  tmp___0 = __builtin_expect((long )(! (! ((int )temp == 0))), 0L);
  }
#line 321
  if (tmp___0) {
    {
#line 322
    tmp = gettext("Specified KeySym is not defined for any KeyCode");
#line 322
    Warning((char const   *)tmp);
    }
  }
#line 324
  x = 0;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (x < 8 * modmap->max_keypermod)) {
#line 324
      goto while_break;
    }
#line 325
    if ((int )*(modmap->modifiermap + x) == (int )temp) {
#line 326
      return ((unsigned int )(1 << x / modmap->max_keypermod));
    }
#line 324
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 330
  tmp___1 = gettext("modifier not found for keysym 0x%0x");
#line 330
  Warning((char const   *)tmp___1, key);
  }
#line 332
  return (0U);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
static unsigned int ParseModifierString(char const   *str___0 ) 
{ 
  unsigned int mask ;
  int x ;
  int y ;
  int found ;
  char *tmp ;
  long tmp___0 ;

  {
#line 343
  if (! str___0) {
#line 344
    return (0U);
  }
#line 347
  mask = 0U;
#line 348
  x = 0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! *(str___0 + x)) {
#line 348
      goto while_break;
    }
#line 350
    found = 0;
#line 351
    y = 0;
    {
#line 351
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 351
      if (! modifiers[y].name) {
#line 351
        goto while_break___0;
      }
#line 352
      if ((int )modifiers[y].name == (int )*(str___0 + x)) {
#line 353
        mask |= modifiers[y].mask;
#line 354
        found = 1;
#line 355
        goto while_break___0;
      }
#line 351
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 359
    tmp___0 = __builtin_expect((long )(! (! (! found))), 0L);
    }
#line 359
    if (tmp___0) {
      {
#line 360
      tmp = gettext("invalid modifier: \"%c\"");
#line 360
      Warning((char const   *)tmp, (int const   )*(str___0 + x));
      }
    }
#line 348
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  return (mask);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
static KeySym ParseKeyString(char const   *str___0 ) 
{ 
  KeySym symbol ;
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 374
  symbol = XStringToKeysym(str___0);
#line 375
  tmp___0 = __builtin_expect((long )(! (! (symbol == 0UL))), 0L);
  }
#line 375
  if (tmp___0) {
    {
#line 376
    tmp = gettext("invalid key symbol: \"%s\"");
#line 376
    Warning((char const   *)tmp, str___0);
    }
  }
#line 379
  return (symbol);
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
void InsertBinding(KeyType key , char const   *modifiers___0 , char const   *stroke ,
                   char const   *code , char const   *command ) 
{ 
  KeyNode *np ;
  unsigned int mask ;
  char *temp ;
  int offset ;
  KeySym sym ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 393
  mask = ParseModifierString(modifiers___0);
  }
#line 395
  if (stroke) {
    {
#line 395
    tmp___5 = strlen(stroke);
    }
#line 395
    if (tmp___5 > 0UL) {
#line 397
      offset = 0;
      {
#line 397
      while (1) {
        while_continue: /* CIL Label */ ;
#line 397
        if (! *(stroke + offset)) {
#line 397
          goto while_break;
        }
#line 398
        if ((int const   )*(stroke + offset) == 35) {
          {
#line 400
          temp = CopyString(stroke);
#line 402
          *(temp + offset) = (char )'1';
          }
          {
#line 402
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 402
            if (! ((int )*(temp + offset) <= 57)) {
#line 402
              goto while_break___0;
            }
            {
#line 404
            sym = ParseKeyString((char const   *)temp);
            }
#line 405
            if (sym == 0UL) {
              {
#line 406
              free((void *)temp);
              }
#line 407
              return;
            }
            {
#line 410
            tmp = malloc(sizeof(KeyNode ));
#line 410
            np = (KeyNode *)tmp;
#line 411
            np->next = bindings;
#line 412
            bindings = np;
#line 414
            np->key = (int )((unsigned int )key | (unsigned int )((((int )*(temp + offset) - 49) + 1) << 8));
#line 415
            np->state = mask;
#line 416
            np->symbol = sym;
#line 417
            np->command = (char *)((void *)0);
#line 418
            np->code = (KeyCode )0;
#line 402
            *(temp + offset) = (char )((int )*(temp + offset) + 1);
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 422
          free((void *)temp);
          }
#line 424
          return;
        }
#line 397
        offset ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 428
      sym = ParseKeyString(stroke);
      }
#line 429
      if (sym == 0UL) {
#line 430
        return;
      }
      {
#line 433
      tmp___0 = malloc(sizeof(KeyNode ));
#line 433
      np = (KeyNode *)tmp___0;
#line 434
      np->next = bindings;
#line 435
      bindings = np;
#line 437
      np->key = (int )key;
#line 438
      np->state = mask;
#line 439
      np->symbol = sym;
#line 440
      np->command = CopyString(command);
#line 441
      np->code = (KeyCode )0;
      }
    } else {
#line 395
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 443
  if (code) {
    {
#line 443
    tmp___4 = strlen(code);
    }
#line 443
    if (tmp___4 > 0UL) {
      {
#line 445
      tmp___1 = malloc(sizeof(KeyNode ));
#line 445
      np = (KeyNode *)tmp___1;
#line 446
      np->next = bindings;
#line 447
      bindings = np;
#line 449
      np->key = (int )key;
#line 450
      np->state = mask;
#line 451
      np->symbol = (KeySym )0L;
#line 452
      np->command = CopyString(command);
#line 453
      tmp___2 = atoi(code);
#line 453
      np->code = (KeyCode )tmp___2;
      }
    } else {
      {
#line 457
      tmp___3 = gettext("neither key nor keycode specified for Key");
#line 457
      Warning((char const   *)tmp___3);
#line 458
      np = (KeyNode *)((void *)0);
      }
    }
  } else {
    {
#line 457
    tmp___3 = gettext("neither key nor keycode specified for Key");
#line 457
    Warning((char const   *)tmp___3);
#line 458
    np = (KeyNode *)((void *)0);
    }
  }
#line 462
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/key.c"
void ValidateKeys(void) 
{ 
  KeyNode *kp ;
  int bindex ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 470
  kp = bindings;
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! kp) {
#line 470
      goto while_break;
    }
#line 471
    if ((kp->key & 255) == 18) {
#line 471
      if (kp->command) {
        {
#line 472
        bindex = atoi((char const   *)kp->command);
#line 473
        tmp___0 = IsRootMenuDefined(bindex);
        }
#line 473
        if (tmp___0) {
#line 473
          tmp___1 = 0;
        } else {
#line 473
          tmp___1 = 1;
        }
        {
#line 473
        tmp___2 = __builtin_expect((long )tmp___1, 0L);
        }
#line 473
        if (tmp___2) {
          {
#line 474
          tmp = gettext("key binding: root menu %d not defined");
#line 474
          Warning((char const   *)tmp, bindex);
          }
        }
      }
    }
#line 470
    kp = kp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.h"
void GetRootMenuSize(int index , int *width , int *height ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
static Menu *rootMenu[10]  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
static char showExitConfirmation  =    (char)1;
#line 29
static void ExitHandler(ClientNode *np ) ;
#line 30
static void PatchRootMenu(Menu *menu ) ;
#line 31
static void UnpatchRootMenu(Menu *menu ) ;
#line 33
static void RunRootCommand(MenuAction const   *action ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
void InitializeRootMenu(void) 
{ 
  int x ;

  {
#line 39
  x = 0;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! (x < 10)) {
#line 39
      goto while_break;
    }
#line 40
    rootMenu[x] = (Menu *)((void *)0);
#line 39
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
void StartupRootMenu(void) 
{ 
  int x ;
  int y ;
  int found ;

  {
#line 51
  x = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (x < 10)) {
#line 51
      goto while_break;
    }
#line 52
    if (rootMenu[x]) {
#line 53
      found = 0;
#line 54
      y = 0;
      {
#line 54
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 54
        if (! (y < x)) {
#line 54
          goto while_break___0;
        }
#line 55
        if ((unsigned long )rootMenu[y] == (unsigned long )rootMenu[x]) {
#line 56
          found = 1;
#line 57
          goto while_break___0;
        }
#line 54
        y ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 60
      if (! found) {
        {
#line 61
        InitializeMenu(rootMenu[x]);
        }
      }
    }
#line 51
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
void ShutdownRootMenu(void) 
{ 


  {
#line 70
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
void DestroyRootMenu(void) 
{ 
  int x ;
  int y ;

  {
#line 77
  x = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (x < 10)) {
#line 77
      goto while_break;
    }
#line 78
    if (rootMenu[x]) {
      {
#line 79
      DestroyMenu(rootMenu[x]);
#line 80
      y = x + 1;
      }
      {
#line 80
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 80
        if (! (y < 10)) {
#line 80
          goto while_break___0;
        }
#line 81
        if ((unsigned long )rootMenu[x] == (unsigned long )rootMenu[y]) {
#line 82
          rootMenu[y] = (Menu *)((void *)0);
        }
#line 80
        y ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 85
      rootMenu[x] = (Menu *)((void *)0);
    }
#line 77
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
void SetRootMenu(char const   *indexes , struct Menu *m ) 
{ 
  int x ;
  int y ;
  int index ;
  int found ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 99
  x = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! *(indexes + x)) {
#line 99
      goto while_break;
    }
#line 102
    index = (int )((int const   )*(indexes + x) - 48);
#line 103
    if (index < 0) {
#line 103
      tmp___0 = 1;
    } else
#line 103
    if (index >= 10) {
#line 103
      tmp___0 = 1;
    } else {
#line 103
      tmp___0 = 0;
    }
    {
#line 103
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 103
    if (tmp___1) {
      {
#line 104
      tmp = gettext("invalid root menu specified: \"%c\"");
#line 104
      Warning((char const   *)tmp, (int const   )*(indexes + x));
      }
#line 105
      goto __Cont;
    }
#line 108
    if (rootMenu[index]) {
#line 108
      if ((unsigned long )rootMenu[index] != (unsigned long )m) {
#line 111
        found = 0;
#line 112
        y = 0;
        {
#line 112
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 112
          if (! (y < 10)) {
#line 112
            goto while_break___0;
          }
#line 113
          if (x != y) {
#line 113
            if ((unsigned long )rootMenu[y] == (unsigned long )rootMenu[x]) {
#line 114
              found = 1;
#line 115
              goto while_break___0;
            }
          }
#line 112
          y ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 120
        if (! found) {
          {
#line 121
          DestroyMenu(rootMenu[index]);
          }
        }
      }
    }
#line 126
    rootMenu[index] = m;
    __Cont: /* CIL Label */ 
#line 99
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
void SetShowExitConfirmation(char v ) 
{ 


  {
#line 134
  showExitConfirmation = v;
#line 135
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
int IsRootMenuDefined(int index ) 
{ 


  {
#line 139
  if (index >= 0) {
#line 139
    if (index < 10) {
#line 139
      if (rootMenu[index]) {
#line 140
        return (1);
      } else {
#line 142
        return (0);
      }
    } else {
#line 142
      return (0);
    }
  } else {
#line 142
    return (0);
  }
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
void GetRootMenuSize(int index , int *width , int *height ) 
{ 


  {
#line 149
  if (! rootMenu[index]) {
#line 150
    *width = 0;
#line 151
    *height = 0;
#line 152
    return;
  }
  {
#line 155
  PatchRootMenu(rootMenu[index]);
#line 156
  *width = (rootMenu[index])->width;
#line 157
  *height = (rootMenu[index])->height;
#line 158
  UnpatchRootMenu(rootMenu[index]);
  }
#line 160
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
int ShowRootMenu(int index , int x , int y ) 
{ 


  {
#line 165
  if (! rootMenu[index]) {
#line 166
    return (0);
  }
  {
#line 169
  PatchRootMenu(rootMenu[index]);
#line 170
  ShowMenu(rootMenu[index], & RunRootCommand, x, y);
#line 171
  UnpatchRootMenu(rootMenu[index]);
  }
#line 173
  return (1);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
static void PatchRootMenu(Menu *menu ) 
{ 
  MenuItem *item ;

  {
#line 182
  item = menu->items;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! item) {
#line 182
      goto while_break;
    }
#line 183
    if (item->submenu) {
      {
#line 184
      PatchRootMenu(item->submenu);
      }
    }
#line 186
    if ((unsigned int )item->action.type == 2U) {
      {
#line 187
      item->submenu = CreateDesktopMenu((unsigned int )(1 << currentDesktop));
#line 188
      InitializeMenu(item->submenu);
      }
    }
#line 182
    item = item->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
static void UnpatchRootMenu(Menu *menu ) 
{ 
  MenuItem *item ;

  {
#line 199
  item = menu->items;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! item) {
#line 199
      goto while_break;
    }
#line 200
    if ((unsigned int )item->action.type == 2U) {
      {
#line 201
      DestroyMenu(item->submenu);
#line 202
      item->submenu = (struct Menu *)((void *)0);
      }
    } else
#line 203
    if (item->submenu) {
      {
#line 204
      UnpatchRootMenu(item->submenu);
      }
    }
#line 199
    item = item->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
static void ExitHandler(ClientNode *np ) 
{ 


  {
#line 212
  shouldExit = (char)1;
#line 213
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
void Restart(void) 
{ 


  {
#line 217
  shouldRestart = (char)1;
#line 218
  shouldExit = (char)1;
#line 219
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
void Exit(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 223
  if (showExitConfirmation) {
    {
#line 224
    tmp = gettext("Are you sure?");
#line 224
    tmp___0 = gettext("Exit JWM");
#line 224
    ShowConfirmDialog((struct ClientNode *)((void *)0), & ExitHandler, tmp___0, tmp,
                      (void *)0);
    }
  } else {
    {
#line 229
    ExitHandler((ClientNode *)((void *)0));
    }
  }
#line 231
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
void ReloadMenu(void) 
{ 


  {
#line 235
  shouldReload = (char)1;
#line 236
  if (! menuShown) {
    {
#line 237
    ShutdownRootMenu();
#line 238
    DestroyRootMenu();
#line 239
    InitializeRootMenu();
#line 240
    ParseConfig((char const   *)configPath);
#line 241
    StartupRootMenu();
#line 242
    shouldReload = (char)0;
    }
  }
#line 244
  return;
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/root.c"
static void RunRootCommand(MenuAction const   *action ) 
{ 


  {
  {
#line 251
  if ((unsigned int const   )action->type == 1U) {
#line 251
    goto case_1;
  }
#line 254
  if ((unsigned int const   )action->type == 17U) {
#line 254
    goto case_17;
  }
#line 257
  if ((unsigned int const   )action->type == 16U) {
#line 257
    goto case_16;
  }
#line 264
  if ((unsigned int const   )action->type == 2U) {
#line 264
    goto case_2;
  }
#line 277
  if ((unsigned int const   )action->type == 15U) {
#line 277
    goto case_15;
  }
#line 277
  if ((unsigned int const   )action->type == 14U) {
#line 277
    goto case_15;
  }
#line 277
  if ((unsigned int const   )action->type == 13U) {
#line 277
    goto case_15;
  }
#line 277
  if ((unsigned int const   )action->type == 12U) {
#line 277
    goto case_15;
  }
#line 277
  if ((unsigned int const   )action->type == 11U) {
#line 277
    goto case_15;
  }
#line 277
  if ((unsigned int const   )action->type == 10U) {
#line 277
    goto case_15;
  }
#line 277
  if ((unsigned int const   )action->type == 9U) {
#line 277
    goto case_15;
  }
#line 277
  if ((unsigned int const   )action->type == 6U) {
#line 277
    goto case_15;
  }
#line 277
  if ((unsigned int const   )action->type == 4U) {
#line 277
    goto case_15;
  }
#line 277
  if ((unsigned int const   )action->type == 3U) {
#line 277
    goto case_15;
  }
#line 281
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 252
  RunCommand((char const   *)action->data.str);
  }
#line 253
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 255
  Restart();
  }
#line 256
  goto switch_break;
  case_16: /* CIL Label */ 
#line 258
  if (exitCommand) {
    {
#line 259
    free((void *)exitCommand);
    }
  }
  {
#line 261
  exitCommand = CopyString((char const   *)action->data.str);
#line 262
  Exit();
  }
#line 263
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 265
  ChangeDesktop((unsigned int )action->data.i);
  }
#line 266
  goto switch_break;
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 278
  ChooseWindow(action);
  }
#line 279
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 282
  Debug("invalid RunRootCommand action: %d", (unsigned int const   )action->type);
  }
#line 283
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 286
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/error.h"
void FatalError(char const   *str___0  , ...) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/error.c"
void FatalError(char const   *str___0  , ...) 
{ 
  va_list ap ;

  {
  {
#line 18
  __builtin_va_start(ap, str___0);
#line 22
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"JWM: error: ");
#line 23
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)str___0,
           ap);
#line 24
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 26
  __builtin_va_end(ap);
#line 28
  exit(1);
  }
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/error.c"
void Warning(char const   *str___0  , ...) 
{ 
  va_list ap ;

  {
  {
#line 36
  __builtin_va_start(ap, str___0);
#line 40
  WarningVA((char const   *)((void *)0), str___0, ap);
#line 42
  __builtin_va_end(ap);
  }
#line 44
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/error.c"
void WarningVA(char const   *part , char const   *str___0 , va_list ap ) 
{ 


  {
  {
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"JWM: warning: ");
  }
#line 52
  if (part) {
    {
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            part);
    }
  }
  {
#line 55
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)str___0,
           ap);
#line 56
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 58
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/error.c"
int ErrorHandler(Display *d , XErrorEvent *e ) 
{ 


  {
#line 74
  if (initializing) {
#line 75
    if ((int )e->request_code == 2) {
#line 75
      if ((int )e->error_code == 10) {
        {
#line 77
        FatalError("display is already managed");
        }
      }
    }
  }
#line 105
  return (0);
}
}
#line 1406 "/usr/include/X11/Xlib.h"
extern XFontStruct *XLoadQueryFont(Display * , char const   * ) ;
#line 2416
extern int XDrawString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                       int  ) ;
#line 2554
extern int XFreeFont(Display * , XFontStruct * ) ;
#line 3227
extern int XSetFont(Display * , GC  , Font  ) ;
#line 3446
extern int XTextWidth(XFontStruct * , char const   * , int  ) ;
#line 522 "/usr/include/X11/Xutil.h"
extern int XIntersectRegion(Region  , Region  , Region  ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.c"
static char const   *DEFAULT_FONT  =    "-*-courier-*-r-*-*-14-*-*-*-*-*-*-*";
#line 19 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.c"
static char *fontNames[8]  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.c"
static XFontStruct *fonts[8]  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.c"
static GC fontGC  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.c"
void InitializeFonts(void) 
{ 
  int x ;

  {
#line 33
  x = 0;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! (x < 8)) {
#line 33
      goto while_break;
    }
#line 34
    fonts[x] = (XFontStruct *)((void *)0);
#line 35
    fontNames[x] = (char *)((void *)0);
#line 33
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.c"
void StartupFonts(void) 
{ 
  XGCValues gcValues ;
  unsigned long gcMask ;
  int x ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;

  {
#line 50
  if (! fontNames[2]) {
    {
#line 51
    fontNames[2] = CopyString((char const   *)fontNames[5]);
    }
  }
#line 53
  if (! fontNames[6]) {
    {
#line 54
    fontNames[6] = CopyString((char const   *)fontNames[5]);
    }
  }
#line 56
  if (! fontNames[4]) {
    {
#line 57
    fontNames[4] = CopyString((char const   *)fontNames[5]);
    }
  }
#line 59
  if (! fontNames[7]) {
    {
#line 60
    fontNames[7] = CopyString((char const   *)fontNames[5]);
    }
  }
#line 85
  x = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (x < 8)) {
#line 85
      goto while_break;
    }
#line 86
    if (fontNames[x]) {
      {
#line 87
      fonts[x] = XLoadQueryFont(display, (char const   *)fontNames[x]);
      }
#line 88
      if (! fonts[x]) {
#line 88
        if (fontNames[x]) {
#line 88
          tmp___0 = 1;
        } else {
#line 88
          tmp___0 = 0;
        }
      } else {
#line 88
        tmp___0 = 0;
      }
      {
#line 88
      tmp___1 = __builtin_expect((long )tmp___0, 0L);
      }
#line 88
      if (tmp___1) {
        {
#line 89
        tmp = gettext("could not load font: %s");
#line 89
        Warning((char const   *)tmp, fontNames[x]);
        }
      }
    }
#line 92
    if (! fonts[x]) {
      {
#line 93
      fonts[x] = XLoadQueryFont(display, DEFAULT_FONT);
      }
    }
    {
#line 95
    tmp___3 = __builtin_expect((long )(! (! (! fonts[x]))), 0L);
    }
#line 95
    if (tmp___3) {
      {
#line 96
      tmp___2 = gettext("could not load the default font: %s");
#line 96
      FatalError((char const   *)tmp___2, DEFAULT_FONT);
      }
    }
#line 85
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 100
  gcMask = (unsigned long )(1L << 16);
#line 101
  gcValues.graphics_exposures = 0;
#line 102
  fontGC = XCreateGC(display, rootWindow, gcMask, & gcValues);
  }
#line 106
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.c"
void ShutdownFonts(void) 
{ 
  int x ;

  {
#line 113
  x = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (x < 8)) {
#line 113
      goto while_break;
    }
#line 114
    if (fonts[x]) {
      {
#line 118
      XFreeFont(display, fonts[x]);
#line 120
      fonts[x] = (XFontStruct *)((void *)0);
      }
    }
#line 113
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  XFreeGC(display, fontGC);
  }
#line 131
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.c"
void DestroyFonts(void) 
{ 
  int x ;

  {
#line 138
  x = 0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (x < 8)) {
#line 138
      goto while_break;
    }
#line 139
    if (fontNames[x]) {
      {
#line 140
      free((void *)fontNames[x]);
#line 141
      fontNames[x] = (char *)((void *)0);
      }
    }
#line 138
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.c"
int GetStringWidth(FontType type , char const   *str___0 ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 169
  tmp = strlen(str___0);
#line 169
  tmp___0 = XTextWidth(fonts[type], str___0, (int )tmp);
  }
#line 169
  return (tmp___0);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.c"
int GetStringHeight(FontType type ) 
{ 


  {
#line 179
  return ((fonts[type])->ascent + (fonts[type])->descent);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.c"
void SetFont(FontType type , char const   *value ) 
{ 
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 186
  tmp___0 = __builtin_expect((long )(! (! (! value))), 0L);
  }
#line 186
  if (tmp___0) {
    {
#line 187
    tmp = gettext("empty Font tag");
#line 187
    Warning((char const   *)tmp);
    }
#line 188
    return;
  }
#line 191
  if (fontNames[type]) {
    {
#line 192
    free((void *)fontNames[type]);
    }
  }
  {
#line 195
  fontNames[type] = CopyString(value);
  }
#line 197
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/font.c"
void RenderString(Drawable d , FontType font , ColorType color , int x , int y , int width ,
                  Region region , char const   *str___0 ) 
{ 
  XRectangle rect ;
  Region renderRegion ;
  int len ;
  char *output ;
  size_t tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 220
  if (! str___0) {
#line 221
    return;
  }
  {
#line 224
  tmp = strlen(str___0);
#line 224
  len = (int )tmp;
  }
#line 225
  if (len == 0) {
#line 226
    return;
  }
  {
#line 230
  rect.x = (short )x;
#line 231
  rect.y = (short )y;
#line 232
  tmp___3 = GetStringWidth(font, str___0);
  }
#line 232
  if (tmp___3 > width) {
#line 232
    tmp___2 = width;
  } else {
    {
#line 232
    tmp___1 = GetStringWidth(font, str___0);
#line 232
    tmp___2 = tmp___1;
    }
  }
  {
#line 232
  rect.width = (unsigned short )(tmp___2 + 2);
#line 233
  tmp___4 = GetStringHeight(font);
#line 233
  rect.height = (unsigned short )tmp___4;
#line 236
  renderRegion = XCreateRegion();
#line 239
  XUnionRectWithRegion(& rect, renderRegion, renderRegion);
  }
#line 242
  if (region) {
    {
#line 243
    XIntersectRegion(region, renderRegion, renderRegion);
    }
  }
  {
#line 262
  output = (char *)str___0;
#line 279
  XSetForeground(display, fontGC, colors[color]);
#line 280
  XSetRegion(display, fontGC, renderRegion);
#line 281
  XSetFont(display, fontGC, (fonts[font])->fid);
#line 282
  XDrawString(display, d, fontGC, x, y + (fonts[font])->ascent, (char const   *)output,
              len);
#line 294
  XDestroyRegion(renderRegion);
  }
#line 296
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/gradient.c"
void DrawHorizontalGradient(Drawable d , GC g , long fromColor , long toColor , int x ,
                            int y , unsigned int width , unsigned int height ) 
{ 
  int shift ;
  unsigned int line ;
  XColor temp ;
  int red ;
  int green ;
  int blue ;
  int ared ;
  int agreen ;
  int ablue ;
  int bred ;
  int bgreen ;
  int bblue ;
  int redStep ;
  int greenStep ;
  int blueStep ;

  {
#line 20
  shift = 15;
#line 29
  if (width == 0U) {
#line 30
    return;
  } else
#line 29
  if (height == 0U) {
#line 30
    return;
  }
#line 34
  if (fromColor == toColor) {
#line 35
    return;
  }
  {
#line 39
  temp.pixel = (unsigned long )fromColor;
#line 40
  GetColorFromPixel(& temp);
#line 41
  ared = (int )((unsigned int )temp.red << shift);
#line 42
  agreen = (int )((unsigned int )temp.green << shift);
#line 43
  ablue = (int )((unsigned int )temp.blue << shift);
#line 46
  temp.pixel = (unsigned long )toColor;
#line 47
  GetColorFromPixel(& temp);
#line 48
  bred = (int )((unsigned int )temp.red << shift);
#line 49
  bgreen = (int )((unsigned int )temp.green << shift);
#line 50
  bblue = (int )((unsigned int )temp.blue << shift);
#line 53
  redStep = (bred - ared) / (int )height;
#line 54
  greenStep = (bgreen - agreen) / (int )height;
#line 55
  blueStep = (bblue - ablue) / (int )height;
#line 58
  red = ared;
#line 59
  blue = ablue;
#line 60
  green = agreen;
#line 61
  line = 0U;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (line < height)) {
#line 61
      goto while_break;
    }
    {
#line 64
    temp.red = (unsigned short )(red >> shift);
#line 65
    temp.green = (unsigned short )(green >> shift);
#line 66
    temp.blue = (unsigned short )(blue >> shift);
#line 68
    GetColor(& temp);
#line 71
    XSetForeground(display, g, temp.pixel);
#line 72
    XDrawLine(display, d, g, x, (int )((unsigned int )y + line), (int )((unsigned int )x + width),
              (int )((unsigned int )y + line));
#line 74
    red += redStep;
#line 75
    green += greenStep;
#line 76
    blue += blueStep;
#line 61
    line ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.h"
void ShowTray(TrayType *tp ) ;
#line 177
void HideTray(TrayType *tp ) ;
#line 185
void DrawSpecificTray(TrayType const   *tp ) ;
#line 213
Window GetSupportingWindow(void) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static TrayType *trays  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static Window supportingWindow  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static int trayCount  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static unsigned int trayOpacity  ;
#line 30
static void HandleTrayExpose(TrayType *tp , XExposeEvent const   *event ) ;
#line 31
static void HandleTrayEnterNotify(TrayType *tp , XCrossingEvent const   *event ) ;
#line 33
static TrayComponentType *GetTrayComponent(TrayType *tp , int x , int y ) ;
#line 34
static void HandleTrayButtonPress(TrayType *tp , XButtonEvent const   *event ) ;
#line 35
static void HandleTrayButtonRelease(TrayType *tp , XButtonEvent const   *event ) ;
#line 36
static void HandleTrayMotionNotify(TrayType *tp , XMotionEvent const   *event ) ;
#line 38
static void ComputeTraySize(TrayType *tp ) ;
#line 39
static int ComputeMaxWidth(TrayType *tp ) ;
#line 40
static int ComputeTotalWidth(TrayType *tp ) ;
#line 41
static int ComputeMaxHeight(TrayType *tp ) ;
#line 42
static int ComputeTotalHeight(TrayType *tp ) ;
#line 43
static int CheckHorizontalFill(TrayType *tp ) ;
#line 44
static int CheckVerticalFill(TrayType *tp ) ;
#line 45
static void LayoutTray(TrayType *tp , int *variableSize , int *variableRemainder ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void InitializeTray(void) 
{ 


  {
#line 50
  trays = (TrayType *)((void *)0);
#line 51
  trayCount = 0;
#line 52
  supportingWindow = (Window )0L;
#line 53
  trayOpacity = 4294967295U;
#line 54
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void StartupTray(void) 
{ 
  XSetWindowAttributes attr ;
  Atom opacityAtom ;
  unsigned long attrMask ;
  TrayType *tp ;
  TrayComponentType *cp ;
  int variableSize ;
  int variableRemainder ;
  int width ;
  int height ;
  int xoffset ;
  int yoffset ;

  {
#line 69
  tp = trays;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! tp) {
#line 69
      goto while_break;
    }
    {
#line 71
    LayoutTray(tp, & variableSize, & variableRemainder);
#line 75
    attrMask = (unsigned long )(1L << 9);
#line 76
    attr.override_redirect = 1;
#line 80
    attrMask |= (unsigned long )(1L << 11);
#line 81
    attr.event_mask = (((((((1L << 2) | (1L << 3)) | (1L << 19)) | (1L << 15)) | 1L) | (1L << 1)) | (1L << 4)) | (1L << 6);
#line 91
    attrMask |= (unsigned long )(1L << 1);
#line 92
    attr.background_pixel = colors[8];
#line 94
    tp->window = XCreateWindow(display, rootWindow, tp->x, tp->y, (unsigned int )tp->width,
                               (unsigned int )tp->height, 0U, rootDepth, 1U, rootVisual,
                               attrMask, & attr);
    }
#line 98
    if (trayOpacity < 4294967295U) {
      {
#line 100
      opacityAtom = XInternAtom(display, "_NET_WM_WINDOW_OPACITY", 0);
#line 101
      XChangeProperty(display, tp->window, opacityAtom, (Atom )6, 32, 0, (unsigned char const   *)((unsigned char *)(& trayOpacity)),
                      1);
#line 103
      XSync(display, 0);
      }
    }
    {
#line 106
    SetDefaultCursor(tp->window);
#line 109
    xoffset = tp->border;
#line 110
    yoffset = tp->border;
#line 111
    cp = tp->components;
    }
    {
#line 111
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 111
      if (! cp) {
#line 111
        goto while_break___0;
      }
#line 113
      if (cp->Create) {
#line 114
        if ((unsigned int )tp->layout == 0U) {
#line 115
          height = tp->height - 2 * tp->border;
#line 116
          width = cp->width;
#line 117
          if (width == 0) {
#line 118
            width = variableSize;
#line 119
            if (variableRemainder) {
#line 120
              width ++;
#line 121
              variableRemainder --;
            }
          }
        } else {
#line 125
          width = tp->width - 2 * tp->border;
#line 126
          height = cp->height;
#line 127
          if (height == 0) {
#line 128
            height = variableSize;
#line 129
            if (variableRemainder) {
#line 130
              height ++;
#line 131
              variableRemainder --;
            }
          }
        }
        {
#line 135
        cp->width = width;
#line 136
        cp->height = height;
#line 137
        (*(cp->Create))(cp);
        }
      }
#line 140
      cp->x = xoffset;
#line 141
      cp->y = yoffset;
#line 142
      cp->screenx = tp->x + xoffset;
#line 143
      cp->screeny = tp->y + yoffset;
#line 145
      if (cp->window != 0UL) {
        {
#line 146
        XReparentWindow(display, cp->window, tp->window, xoffset, yoffset);
        }
      }
#line 150
      if ((unsigned int )tp->layout == 0U) {
#line 151
        xoffset += cp->width;
      } else {
#line 153
        yoffset += cp->height;
      }
#line 111
      cp = cp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 158
    XMapWindow(display, tp->window);
#line 160
    trayCount ++;
#line 69
    tp = tp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  UpdatePager();
#line 165
  UpdateTaskBar();
  }
#line 167
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void ShutdownTray(void) 
{ 
  TrayType *tp ;
  TrayComponentType *cp ;

  {
#line 175
  tp = trays;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! tp) {
#line 175
      goto while_break;
    }
#line 176
    cp = tp->components;
    {
#line 176
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 176
      if (! cp) {
#line 176
        goto while_break___0;
      }
#line 177
      if (cp->Destroy) {
        {
#line 178
        (*(cp->Destroy))(cp);
        }
      }
#line 176
      cp = cp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 181
    XDestroyWindow(display, tp->window);
#line 175
    tp = tp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if (supportingWindow != 0UL) {
    {
#line 185
    XDestroyWindow(display, supportingWindow);
#line 186
    supportingWindow = (Window )0L;
    }
  }
#line 189
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void DestroyTray(void) 
{ 
  TrayType *tp ;
  TrayComponentType *cp ;

  {
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! trays) {
#line 197
      goto while_break;
    }
#line 198
    tp = trays->next;
    {
#line 200
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 200
      if (! trays->components) {
#line 200
        goto while_break___0;
      }
      {
#line 201
      cp = (trays->components)->next;
#line 202
      free((void *)trays->components);
#line 203
      trays->components = cp;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 205
    free((void *)trays);
#line 207
    trays = tp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
TrayType *CreateTray(void) 
{ 
  TrayType *tp ;
  void *tmp ;

  {
  {
#line 217
  tmp = malloc(sizeof(TrayType ));
#line 217
  tp = (TrayType *)tmp;
#line 219
  tp->x = 0;
#line 220
  tp->y = -1;
#line 221
  tp->requestedWidth = 0;
#line 222
  tp->requestedHeight = 0;
#line 223
  tp->width = 0;
#line 224
  tp->height = 0;
#line 225
  tp->border = 1;
#line 226
  tp->layer = (WinLayerType )8;
#line 227
  tp->layout = (LayoutType )0;
#line 228
  tp->valign = (TrayAlignmentType )0;
#line 229
  tp->halign = (TrayAlignmentType )0;
#line 231
  tp->autoHide = 0;
#line 232
  tp->hidden = 0;
#line 234
  tp->window = (Window )0L;
#line 236
  tp->components = (struct TrayComponentType *)((void *)0);
#line 237
  tp->componentsTail = (struct TrayComponentType *)((void *)0);
#line 239
  tp->next = trays;
#line 240
  trays = tp;
  }
#line 242
  return (tp);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
TrayComponentType *CreateTrayComponent(void) 
{ 
  TrayComponentType *cp ;
  void *tmp ;

  {
  {
#line 251
  tmp = malloc(sizeof(TrayComponentType ));
#line 251
  cp = (TrayComponentType *)tmp;
#line 253
  cp->tray = (struct TrayType *)((void *)0);
#line 254
  cp->object = (void *)0;
#line 256
  cp->x = 0;
#line 257
  cp->y = 0;
#line 258
  cp->requestedWidth = 0;
#line 259
  cp->requestedHeight = 0;
#line 260
  cp->width = 0;
#line 261
  cp->height = 0;
#line 262
  cp->grabbed = 0;
#line 264
  cp->window = (Window )0L;
#line 265
  cp->pixmap = (Pixmap )0L;
#line 267
  cp->Create = (void (*)(struct TrayComponentType *cp ))((void *)0);
#line 268
  cp->Destroy = (void (*)(struct TrayComponentType *cp ))((void *)0);
#line 270
  cp->SetSize = (void (*)(struct TrayComponentType *cp , int width , int height ))((void *)0);
#line 271
  cp->Resize = (void (*)(struct TrayComponentType *cp ))((void *)0);
#line 273
  cp->ProcessButtonPress = (void (*)(struct TrayComponentType *cp , int x , int y ,
                                     int mask ))((void *)0);
#line 274
  cp->ProcessButtonRelease = (void (*)(struct TrayComponentType *cp , int x , int y ,
                                       int mask ))((void *)0);
#line 275
  cp->ProcessMotionEvent = (void (*)(struct TrayComponentType *cp , int x , int y ,
                                     int mask ))((void *)0);
#line 277
  cp->next = (struct TrayComponentType *)((void *)0);
  }
#line 279
  return (cp);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void AddTrayComponent(TrayType *tp , TrayComponentType *cp ) 
{ 


  {
#line 289
  cp->tray = tp;
#line 291
  if (tp->componentsTail) {
#line 292
    (tp->componentsTail)->next = cp;
  } else {
#line 294
    tp->components = cp;
  }
#line 296
  tp->componentsTail = cp;
#line 297
  cp->next = (struct TrayComponentType *)((void *)0);
#line 299
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static int ComputeMaxWidth(TrayType *tp ) 
{ 
  TrayComponentType *cp ;
  int result ;
  int temp ;

  {
#line 308
  result = 0;
#line 309
  cp = tp->components;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! cp) {
#line 309
      goto while_break;
    }
#line 310
    temp = cp->width;
#line 311
    if (temp > 0) {
#line 312
      temp += 2 * tp->border;
#line 313
      if (temp > result) {
#line 314
        result = temp;
      }
    }
#line 309
    cp = cp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return (result);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static int ComputeTotalWidth(TrayType *tp ) 
{ 
  TrayComponentType *cp ;
  int result ;

  {
#line 329
  result = 2 * tp->border;
#line 330
  cp = tp->components;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! cp) {
#line 330
      goto while_break;
    }
#line 331
    result += cp->width;
#line 330
    cp = cp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  return (result);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static int ComputeMaxHeight(TrayType *tp ) 
{ 
  TrayComponentType *cp ;
  int result ;
  int temp ;

  {
#line 345
  result = 0;
#line 346
  cp = tp->components;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! cp) {
#line 346
      goto while_break;
    }
#line 347
    temp = cp->height;
#line 348
    if (temp > 0) {
#line 349
      temp += 2 * tp->border;
#line 350
      if (temp > result) {
#line 351
        result = temp;
      }
    }
#line 346
    cp = cp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (result);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static int ComputeTotalHeight(TrayType *tp ) 
{ 
  TrayComponentType *cp ;
  int result ;

  {
#line 366
  result = 2 * tp->border;
#line 367
  cp = tp->components;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! cp) {
#line 367
      goto while_break;
    }
#line 368
    result += cp->height;
#line 367
    cp = cp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  return (result);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static int CheckHorizontalFill(TrayType *tp ) 
{ 
  TrayComponentType *cp ;

  {
#line 380
  cp = tp->components;
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    if (! cp) {
#line 380
      goto while_break;
    }
#line 381
    if (cp->width == 0) {
#line 382
      return (1);
    }
#line 380
    cp = cp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 386
  return (0);
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static int CheckVerticalFill(TrayType *tp ) 
{ 
  TrayComponentType *cp ;

  {
#line 395
  cp = tp->components;
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    if (! cp) {
#line 395
      goto while_break;
    }
#line 396
    if (cp->height == 0) {
#line 397
      return (1);
    }
#line 395
    cp = cp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return (0);
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static void ComputeTraySize(TrayType *tp ) 
{ 
  TrayComponentType *cp ;
  ScreenType const   *sp ;
  int x ;
  int y ;
  int tmp ;
  int tmp___0 ;

  {
#line 413
  if ((unsigned int )tp->layout == 0U) {
#line 415
    if (tp->height == 0) {
      {
#line 416
      tp->height = ComputeMaxHeight(tp);
      }
    }
#line 419
    if (tp->height == 0) {
#line 420
      tp->height = 32;
    }
  } else {
#line 425
    if (tp->width == 0) {
      {
#line 426
      tp->width = ComputeMaxWidth(tp);
      }
    }
#line 429
    if (tp->width == 0) {
#line 430
      tp->width = 32;
    }
  }
#line 436
  cp = tp->components;
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 436
    if (! cp) {
#line 436
      goto while_break;
    }
#line 437
    if (cp->SetSize) {
#line 438
      if ((unsigned int )tp->layout == 0U) {
        {
#line 439
        (*(cp->SetSize))(cp, 0, tp->height - 2 * tp->border);
        }
      } else {
        {
#line 441
        (*(cp->SetSize))(cp, tp->width - 2 * tp->border, 0);
        }
      }
    }
#line 436
    cp = cp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 448
  if ((unsigned int )tp->valign == 2U) {
#line 448
    goto case_2;
  }
#line 451
  if ((unsigned int )tp->valign == 5U) {
#line 451
    goto case_5;
  }
#line 454
  if ((unsigned int )tp->valign == 3U) {
#line 454
    goto case_3;
  }
#line 457
  goto switch_default;
  case_2: /* CIL Label */ 
#line 449
  y = 0;
#line 450
  goto switch_break;
  case_5: /* CIL Label */ 
#line 452
  y = rootHeight - 1;
#line 453
  goto switch_break;
  case_3: /* CIL Label */ 
#line 455
  y = 1 + rootHeight / 2;
#line 456
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 458
  if (tp->y < 0) {
#line 459
    y = rootHeight + tp->y;
  } else {
#line 461
    y = tp->y;
  }
#line 463
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 466
  if ((unsigned int )tp->halign == 1U) {
#line 466
    goto case_1;
  }
#line 469
  if ((unsigned int )tp->halign == 4U) {
#line 469
    goto case_4;
  }
#line 472
  if ((unsigned int )tp->halign == 3U) {
#line 472
    goto case_3___0;
  }
#line 475
  goto switch_default___0;
  case_1: /* CIL Label */ 
#line 467
  x = 0;
#line 468
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 470
  x = rootWidth - 1;
#line 471
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 473
  x = 1 + rootWidth / 2;
#line 474
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 476
  if (tp->x < 0) {
#line 477
    x = rootWidth + tp->x;
  } else {
#line 479
    x = tp->x;
  }
#line 481
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 483
  sp = GetCurrentScreen(x, y);
  }
#line 486
  if ((unsigned int )tp->layout == 0U) {
#line 487
    if (tp->width == 0) {
      {
#line 488
      tmp = CheckHorizontalFill(tp);
      }
#line 488
      if (tmp) {
#line 489
        tp->width = (int )sp->width;
      } else {
        {
#line 491
        tp->width = ComputeTotalWidth(tp);
        }
      }
#line 493
      if (tp->width == 0) {
#line 494
        tp->width = 32;
      }
    }
  } else
#line 498
  if (tp->height == 0) {
    {
#line 499
    tmp___0 = CheckVerticalFill(tp);
    }
#line 499
    if (tmp___0) {
#line 500
      tp->height = (int )sp->height;
    } else {
      {
#line 502
      tp->height = ComputeTotalHeight(tp);
      }
    }
#line 504
    if (tp->height == 0) {
#line 505
      tp->height = 32;
    }
  }
  {
#line 512
  if ((unsigned int )tp->valign == 2U) {
#line 512
    goto case_2___0;
  }
#line 515
  if ((unsigned int )tp->valign == 5U) {
#line 515
    goto case_5___0;
  }
#line 518
  if ((unsigned int )tp->valign == 3U) {
#line 518
    goto case_3___1;
  }
#line 521
  goto switch_default___1;
  case_2___0: /* CIL Label */ 
#line 513
  tp->y = 0;
#line 514
  goto switch_break___1;
  case_5___0: /* CIL Label */ 
#line 516
  tp->y = (int )((sp->height - (int const   )tp->height) + 1);
#line 517
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
#line 519
  tp->y = (int )((sp->height - (int const   )tp->height) / 2);
#line 520
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 522
  if (tp->y < 0) {
#line 523
    tp->y = (int )(((sp->height + (int const   )tp->y) - (int const   )tp->height) + 1);
  }
#line 525
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 529
  if ((unsigned int )tp->halign == 1U) {
#line 529
    goto case_1___0;
  }
#line 532
  if ((unsigned int )tp->halign == 4U) {
#line 532
    goto case_4___0;
  }
#line 535
  if ((unsigned int )tp->halign == 3U) {
#line 535
    goto case_3___2;
  }
#line 538
  goto switch_default___2;
  case_1___0: /* CIL Label */ 
#line 530
  tp->x = 0;
#line 531
  goto switch_break___2;
  case_4___0: /* CIL Label */ 
#line 533
  tp->x = (int )((sp->width - (int const   )tp->width) + 1);
#line 534
  goto switch_break___2;
  case_3___2: /* CIL Label */ 
#line 536
  tp->x = (int )((sp->width - (int const   )tp->width) / 2);
#line 537
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
#line 539
  if (tp->x < 0) {
#line 540
    tp->x = (int )(((sp->width + (int const   )tp->x) - (int const   )tp->width) + 1);
  }
#line 542
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 545
  return;
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void ShowTray(TrayType *tp ) 
{ 
  Window win1 ;
  Window win2 ;
  int winx ;
  int winy ;
  unsigned int mask ;
  int mousex___0 ;
  int mousey___0 ;

  {
#line 555
  if (tp->hidden) {
    {
#line 557
    tp->hidden = 0;
#line 558
    XMoveWindow(display, tp->window, tp->x, tp->y);
#line 560
    XQueryPointer(display, rootWindow, & win1, & win2, & mousex___0, & mousey___0,
                  & winx, & winy, & mask);
#line 562
    SetMousePosition(mousex___0, mousey___0);
    }
  }
#line 566
  return;
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void ShowAllTrays(void) 
{ 
  TrayType *tp ;

  {
#line 573
  if (shouldExit) {
#line 574
    return;
  }
#line 577
  tp = trays;
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    if (! tp) {
#line 577
      goto while_break;
    }
    {
#line 578
    ShowTray(tp);
#line 577
    tp = tp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 581
  return;
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void HideTray(TrayType *tp ) 
{ 
  int x ;
  int y ;

  {
#line 588
  tp->hidden = 1;
#line 591
  if ((unsigned int )tp->layout == 0U) {
#line 593
    x = tp->x;
#line 595
    if (tp->y >= rootHeight / 2) {
#line 596
      y = rootHeight - 1;
    } else {
#line 598
      y = 1 - tp->height;
    }
  } else {
#line 603
    y = tp->y;
#line 605
    if (tp->x >= rootWidth / 2) {
#line 606
      x = rootWidth - 1;
    } else {
#line 608
      x = 1 - tp->width;
    }
  }
  {
#line 614
  XMoveWindow(display, tp->window, x, y);
  }
#line 616
  return;
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
int ProcessTrayEvent(XEvent const   *event ) 
{ 
  TrayType *tp ;

  {
#line 623
  tp = trays;
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    if (! tp) {
#line 623
      goto while_break;
    }
#line 624
    if (event->xany.window == (Window const   )tp->window) {
      {
#line 626
      if (event->type == 12) {
#line 626
        goto case_12;
      }
#line 629
      if (event->type == 7) {
#line 629
        goto case_7;
      }
#line 632
      if (event->type == 4) {
#line 632
        goto case_4;
      }
#line 635
      if (event->type == 5) {
#line 635
        goto case_5;
      }
#line 638
      if (event->type == 6) {
#line 638
        goto case_6;
      }
#line 641
      goto switch_default;
      case_12: /* CIL Label */ 
      {
#line 627
      HandleTrayExpose(tp, & event->xexpose);
      }
#line 628
      return (1);
      case_7: /* CIL Label */ 
      {
#line 630
      HandleTrayEnterNotify(tp, & event->xcrossing);
      }
#line 631
      return (1);
      case_4: /* CIL Label */ 
      {
#line 633
      HandleTrayButtonPress(tp, & event->xbutton);
      }
#line 634
      return (1);
      case_5: /* CIL Label */ 
      {
#line 636
      HandleTrayButtonRelease(tp, & event->xbutton);
      }
#line 637
      return (1);
      case_6: /* CIL Label */ 
      {
#line 639
      HandleTrayMotionNotify(tp, & event->xmotion);
      }
#line 640
      return (1);
      switch_default: /* CIL Label */ 
#line 642
      return (0);
      switch_break: /* CIL Label */ ;
      }
    }
#line 623
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  return (0);
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void SignalTray(struct TimeType  const  *now , int x , int y ) 
{ 
  TrayType *tp ;

  {
#line 656
  tp = trays;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    if (! tp) {
#line 656
      goto while_break;
    }
#line 657
    if (tp->autoHide) {
#line 657
      if (! tp->hidden) {
#line 657
        if (! menuShown) {
#line 658
          if (x < tp->x) {
            {
#line 660
            HideTray(tp);
            }
          } else
#line 658
          if (x >= tp->x + tp->width) {
            {
#line 660
            HideTray(tp);
            }
          } else
#line 658
          if (y < tp->y) {
            {
#line 660
            HideTray(tp);
            }
          } else
#line 658
          if (y >= tp->y + tp->height) {
            {
#line 660
            HideTray(tp);
            }
          }
        }
      }
    }
#line 656
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 665
  return;
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static void HandleTrayExpose(TrayType *tp , XExposeEvent const   *event ) 
{ 


  {
  {
#line 670
  DrawSpecificTray((TrayType const   *)tp);
  }
#line 672
  return;
}
}
#line 675 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static void HandleTrayEnterNotify(TrayType *tp , XCrossingEvent const   *event ) 
{ 


  {
  {
#line 677
  ShowTray(tp);
  }
#line 679
  return;
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static TrayComponentType *GetTrayComponent(TrayType *tp , int x , int y ) 
{ 
  TrayComponentType *cp ;
  int xoffset ;
  int yoffset ;
  int width ;
  int height ;

  {
#line 688
  xoffset = tp->border;
#line 689
  yoffset = tp->border;
#line 690
  cp = tp->components;
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 690
    if (! cp) {
#line 690
      goto while_break;
    }
#line 691
    width = cp->width;
#line 692
    height = cp->height;
#line 693
    if (x >= xoffset) {
#line 693
      if (x < xoffset + width) {
#line 694
        if (y >= yoffset) {
#line 694
          if (y < yoffset + height) {
#line 695
            return (cp);
          }
        }
      }
    }
#line 698
    if ((unsigned int )tp->layout == 0U) {
#line 699
      xoffset += width;
    } else {
#line 701
      yoffset += height;
    }
#line 690
    cp = cp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  return ((TrayComponentType *)((void *)0));
}
}
#line 710 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static void HandleTrayButtonPress(TrayType *tp , XButtonEvent const   *event ) 
{ 
  TrayComponentType *cp ;
  int x ;
  int y ;
  int mask ;

  {
  {
#line 716
  cp = GetTrayComponent(tp, (int )event->x, (int )event->y);
  }
#line 717
  if (cp) {
#line 717
    if (cp->ProcessButtonPress) {
      {
#line 718
      x = (int )(event->x - (int const   )cp->x);
#line 719
      y = (int )(event->y - (int const   )cp->y);
#line 720
      mask = (int )event->button;
#line 721
      (*(cp->ProcessButtonPress))(cp, x, y, mask);
      }
    }
  }
#line 724
  return;
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static void HandleTrayButtonRelease(TrayType *tp , XButtonEvent const   *event ) 
{ 
  TrayComponentType *cp ;
  int x ;
  int y ;
  int mask ;

  {
#line 734
  cp = tp->components;
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (! cp) {
#line 734
      goto while_break;
    }
#line 735
    if (cp->grabbed) {
      {
#line 736
      x = (int )(event->x - (int const   )cp->x);
#line 737
      y = (int )(event->y - (int const   )cp->y);
#line 738
      mask = (int )event->button;
#line 739
      (*(cp->ProcessButtonRelease))(cp, x, y, mask);
#line 740
      XUngrabPointer(display, (Time )0L);
#line 741
      cp->grabbed = 0;
      }
#line 742
      return;
    }
#line 734
    cp = cp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 746
  cp = GetTrayComponent(tp, (int )event->x, (int )event->y);
  }
#line 747
  if (cp) {
#line 747
    if (cp->ProcessButtonRelease) {
      {
#line 748
      x = (int )(event->x - (int const   )cp->x);
#line 749
      y = (int )(event->y - (int const   )cp->y);
#line 750
      mask = (int )event->button;
#line 751
      (*(cp->ProcessButtonRelease))(cp, x, y, mask);
      }
    }
  }
#line 754
  return;
}
}
#line 757 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static void HandleTrayMotionNotify(TrayType *tp , XMotionEvent const   *event ) 
{ 
  TrayComponentType *cp ;
  int x ;
  int y ;
  int mask ;

  {
  {
#line 763
  cp = GetTrayComponent(tp, (int )event->x, (int )event->y);
  }
#line 764
  if (cp) {
#line 764
    if (cp->ProcessMotionEvent) {
      {
#line 765
      x = (int )(event->x - (int const   )cp->x);
#line 766
      y = (int )(event->y - (int const   )cp->y);
#line 767
      mask = (int )event->state;
#line 768
      (*(cp->ProcessMotionEvent))(cp, x, y, mask);
      }
    }
  }
#line 771
  return;
}
}
#line 774 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void DrawTray(void) 
{ 
  TrayType *tp ;

  {
#line 778
  if (shouldExit) {
#line 779
    return;
  }
#line 782
  tp = trays;
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;
#line 782
    if (! tp) {
#line 782
      goto while_break;
    }
    {
#line 783
    DrawSpecificTray((TrayType const   *)tp);
#line 782
    tp = tp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 786
  return;
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void DrawSpecificTray(TrayType const   *tp ) 
{ 
  TrayComponentType *cp ;
  int x ;

  {
#line 797
  cp = (TrayComponentType *)tp->components;
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 797
    if (! cp) {
#line 797
      goto while_break;
    }
    {
#line 798
    UpdateSpecificTray(tp, (TrayComponentType const   *)cp);
#line 797
    cp = cp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 802
  x = 0;
  {
#line 802
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 802
    if (! (x < (int )tp->border)) {
#line 802
      goto while_break___0;
    }
    {
#line 805
    XSetForeground(display, rootGC, colors[28]);
#line 806
    XDrawLine(display, (Drawable )tp->window, rootGC, 0, x, (int )((tp->width - (int const   )x) - 1),
              x);
#line 810
    XSetForeground(display, rootGC, colors[29]);
#line 811
    XDrawLine(display, (Drawable )tp->window, rootGC, x + 1, (int )((tp->height - (int const   )x) - 1),
              (int )((tp->width - (int const   )x) - 2), (int )((tp->height - (int const   )x) - 1));
#line 815
    XSetForeground(display, rootGC, colors[28]);
#line 816
    XDrawLine(display, (Drawable )tp->window, rootGC, x, x, x, (int )((tp->height - (int const   )x) - 1));
#line 820
    XSetForeground(display, rootGC, colors[29]);
#line 821
    XDrawLine(display, (Drawable )tp->window, rootGC, (int )((tp->width - (int const   )x) - 1),
              x + 1, (int )((tp->width - (int const   )x) - 1), (int )((tp->height - (int const   )x) - 1));
#line 802
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 826
  return;
}
}
#line 829 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void UpdateSpecificTray(TrayType const   *tp , TrayComponentType const   *cp ) 
{ 


  {
#line 831
  if (cp->pixmap != 0UL) {
#line 831
    if (! shouldExit) {
      {
#line 832
      XCopyArea(display, (Drawable )cp->pixmap, (Drawable )tp->window, rootGC, 0,
                0, (unsigned int )cp->width, (unsigned int )cp->height, (int )cp->x,
                (int )cp->y);
      }
    }
  }
#line 836
  return;
}
}
#line 839 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
static void LayoutTray(TrayType *tp , int *variableSize , int *variableRemainder ) 
{ 
  TrayComponentType *cp ;
  int variableCount ;
  int width ;
  int height ;
  int temp ;

  {
#line 846
  tp->width = tp->requestedWidth;
#line 847
  tp->height = tp->requestedHeight;
#line 849
  cp = tp->components;
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    if (! cp) {
#line 849
      goto while_break;
    }
#line 850
    cp->width = cp->requestedWidth;
#line 851
    cp->height = cp->requestedHeight;
#line 849
    cp = cp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 854
  ComputeTraySize(tp);
#line 858
  width = tp->width - 2 * tp->border;
#line 859
  height = tp->height - 2 * tp->border;
#line 860
  variableCount = 0;
#line 861
  cp = tp->components;
  }
  {
#line 861
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 861
    if (! cp) {
#line 861
      goto while_break___0;
    }
#line 862
    if ((unsigned int )tp->layout == 0U) {
#line 863
      temp = cp->width;
#line 864
      if (temp > 0) {
#line 865
        width -= temp;
      } else {
#line 867
        variableCount ++;
      }
    } else {
#line 870
      temp = cp->height;
#line 871
      if (temp > 0) {
#line 872
        height -= temp;
      } else {
#line 874
        variableCount ++;
      }
    }
#line 861
    cp = cp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 883
  *variableSize = 1;
#line 884
  *variableRemainder = 0;
#line 885
  if ((unsigned int )tp->layout == 0U) {
#line 886
    if (variableCount) {
#line 887
      if (width >= variableCount) {
#line 888
        *variableSize = width / variableCount;
#line 889
        *variableRemainder = width % variableCount;
      }
    } else
#line 891
    if (width > 0) {
#line 892
      tp->width -= width;
    }
  } else
#line 895
  if (variableCount) {
#line 896
    if (height >= variableCount) {
#line 897
      *variableSize = height / variableCount;
#line 898
      *variableRemainder = height % variableCount;
    }
  } else
#line 900
  if (height > 0) {
#line 901
    tp->height -= height;
  }
#line 905
  return;
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void ResizeTray(TrayType *tp ) 
{ 
  TrayComponentType *cp ;
  int variableSize ;
  int variableRemainder ;
  int xoffset ;
  int yoffset ;
  int width ;
  int height ;

  {
  {
#line 918
  LayoutTray(tp, & variableSize, & variableRemainder);
#line 921
  xoffset = tp->border;
#line 922
  yoffset = tp->border;
#line 923
  cp = tp->components;
  }
  {
#line 923
  while (1) {
    while_continue: /* CIL Label */ ;
#line 923
    if (! cp) {
#line 923
      goto while_break;
    }
#line 925
    cp->x = xoffset;
#line 926
    cp->y = yoffset;
#line 927
    cp->screenx = tp->x + xoffset;
#line 928
    cp->screeny = tp->y + yoffset;
#line 930
    if (cp->Resize) {
#line 931
      if ((unsigned int )tp->layout == 0U) {
#line 932
        height = tp->height - 2 * tp->border;
#line 933
        width = cp->width;
#line 934
        if (width == 0) {
#line 935
          width = variableSize;
#line 936
          if (variableRemainder) {
#line 937
            width ++;
#line 938
            variableRemainder --;
          }
        }
      } else {
#line 942
        width = tp->width - 2 * tp->border;
#line 943
        height = cp->height;
#line 944
        if (height == 0) {
#line 945
          height = variableSize;
#line 946
          if (variableRemainder) {
#line 947
            height ++;
#line 948
            variableRemainder --;
          }
        }
      }
      {
#line 952
      cp->width = width;
#line 953
      cp->height = height;
#line 954
      (*(cp->Resize))(cp);
      }
    }
#line 957
    if (cp->window != 0UL) {
      {
#line 958
      XMoveWindow(display, cp->window, xoffset, yoffset);
      }
    }
#line 961
    if ((unsigned int )tp->layout == 0U) {
#line 962
      xoffset += cp->width;
    } else {
#line 964
      yoffset += cp->height;
    }
#line 923
    cp = cp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 968
  XMoveResizeWindow(display, tp->window, tp->x, tp->y, (unsigned int )tp->width, (unsigned int )tp->height);
#line 971
  UpdateTaskBar();
#line 972
  DrawSpecificTray((TrayType const   *)tp);
  }
#line 974
  if (tp->hidden) {
    {
#line 975
    HideTray(tp);
    }
  }
#line 978
  return;
}
}
#line 981 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
TrayType *GetTrays(void) 
{ 


  {
#line 982
  return (trays);
}
}
#line 986 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
int GetTrayCount(void) 
{ 


  {
#line 987
  return (trayCount);
}
}
#line 991 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
Window GetSupportingWindow(void) 
{ 


  {
#line 993
  if (trays) {
#line 994
    return (trays->window);
  } else
#line 995
  if (supportingWindow != 0UL) {
#line 996
    return (supportingWindow);
  } else {
    {
#line 998
    supportingWindow = XCreateSimpleWindow(display, rootWindow, 0, 0, 1U, 1U, 0U,
                                           0UL, 0UL);
    }
#line 1000
    return (supportingWindow);
  }
}
}
#line 1006 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void SetAutoHideTray(TrayType *tp , int v ) 
{ 


  {
#line 1008
  tp->autoHide = v;
#line 1009
  return;
}
}
#line 1012 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void SetTrayX(TrayType *tp , char const   *str___0 ) 
{ 


  {
  {
#line 1015
  tp->x = atoi(str___0);
  }
#line 1016
  return;
}
}
#line 1019 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void SetTrayY(TrayType *tp , char const   *str___0 ) 
{ 


  {
  {
#line 1022
  tp->y = atoi(str___0);
  }
#line 1023
  return;
}
}
#line 1026 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void SetTrayWidth(TrayType *tp , char const   *str___0 ) 
{ 
  int width ;
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 1033
  width = atoi(str___0);
#line 1035
  tmp___0 = __builtin_expect((long )(! (! (width < 0))), 0L);
  }
#line 1035
  if (tmp___0) {
    {
#line 1036
    tmp = gettext("invalid tray width: %d");
#line 1036
    Warning((char const   *)tmp, width);
    }
  } else {
#line 1038
    tp->requestedWidth = width;
  }
#line 1041
  return;
}
}
#line 1044 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void SetTrayHeight(TrayType *tp , char const   *str___0 ) 
{ 
  int height ;
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 1051
  height = atoi(str___0);
#line 1053
  tmp___0 = __builtin_expect((long )(! (! (height < 0))), 0L);
  }
#line 1053
  if (tmp___0) {
    {
#line 1054
    tmp = gettext("invalid tray height: %d");
#line 1054
    Warning((char const   *)tmp, height);
    }
  } else {
#line 1056
    tp->requestedHeight = height;
  }
#line 1059
  return;
}
}
#line 1063 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void SetTrayLayout(TrayType *tp , char const   *str___0 ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1067
  if (! (! str___0)) {
    {
#line 1071
    tmp___1 = strcmp(str___0, "horizontal");
    }
#line 1071
    if (tmp___1) {
      {
#line 1076
      tmp___0 = strcmp(str___0, "vertical");
      }
#line 1076
      if (tmp___0) {
        {
#line 1082
        tmp = gettext("invalid tray layout: \"%s\"");
#line 1082
        Warning((char const   *)tmp, str___0);
        }
      } else {
#line 1078
        tp->layout = (LayoutType )1;
#line 1079
        return;
      }
    } else {
#line 1073
      tp->layout = (LayoutType )0;
#line 1074
      return;
    }
  }
#line 1088
  if (tp->requestedWidth > 0) {
#line 1088
    if (tp->requestedHeight == 0) {
#line 1091
      tp->layout = (LayoutType )1;
    } else
#line 1088
    if (tp->requestedHeight > tp->requestedWidth) {
#line 1091
      tp->layout = (LayoutType )1;
    } else {
#line 1093
      tp->layout = (LayoutType )0;
    }
  } else {
#line 1093
    tp->layout = (LayoutType )0;
  }
#line 1096
  return;
}
}
#line 1099 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void SetTrayLayer(TrayType *tp , char const   *str___0 ) 
{ 
  int temp ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1106
  temp = atoi(str___0);
  }
#line 1107
  if (temp < 0) {
#line 1107
    tmp___0 = 1;
  } else
#line 1107
  if (temp > 12) {
#line 1107
    tmp___0 = 1;
  } else {
#line 1107
    tmp___0 = 0;
  }
  {
#line 1107
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 1107
  if (tmp___1) {
    {
#line 1108
    tmp = gettext("invalid tray layer: %d");
#line 1108
    Warning((char const   *)tmp, temp);
#line 1109
    tp->layer = (WinLayerType )8;
    }
  } else {
#line 1111
    tp->layer = (WinLayerType )temp;
  }
#line 1114
  return;
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void SetTrayBorder(TrayType *tp , char const   *str___0 ) 
{ 
  int temp ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1124
  temp = atoi(str___0);
  }
#line 1125
  if (temp < 0) {
#line 1125
    tmp___0 = 1;
  } else
#line 1125
  if (temp > 32) {
#line 1125
    tmp___0 = 1;
  } else {
#line 1125
    tmp___0 = 0;
  }
  {
#line 1125
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 1125
  if (tmp___1) {
    {
#line 1126
    tmp = gettext("invalid tray border: %d");
#line 1126
    Warning((char const   *)tmp, temp);
#line 1127
    tp->border = 1;
    }
  } else {
#line 1129
    tp->border = temp;
  }
#line 1132
  return;
}
}
#line 1135 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void SetTrayHorizontalAlignment(TrayType *tp , char const   *str___0 ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1139
  if (! str___0) {
#line 1140
    tp->halign = (TrayAlignmentType )0;
  } else {
    {
#line 1139
    tmp___3 = strcmp(str___0, "fixed");
    }
#line 1139
    if (tmp___3) {
      {
#line 1141
      tmp___2 = strcmp(str___0, "left");
      }
#line 1141
      if (tmp___2) {
        {
#line 1143
        tmp___1 = strcmp(str___0, "right");
        }
#line 1143
        if (tmp___1) {
          {
#line 1145
          tmp___0 = strcmp(str___0, "center");
          }
#line 1145
          if (tmp___0) {
            {
#line 1148
            tmp = gettext("invalid tray horizontal alignment: \"%s\"");
#line 1148
            Warning((char const   *)tmp, str___0);
#line 1149
            tp->halign = (TrayAlignmentType )0;
            }
          } else {
#line 1146
            tp->halign = (TrayAlignmentType )3;
          }
        } else {
#line 1144
          tp->halign = (TrayAlignmentType )4;
        }
      } else {
#line 1142
        tp->halign = (TrayAlignmentType )1;
      }
    } else {
#line 1140
      tp->halign = (TrayAlignmentType )0;
    }
  }
#line 1152
  return;
}
}
#line 1155 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void SetTrayVerticalAlignment(TrayType *tp , char const   *str___0 ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1159
  if (! str___0) {
#line 1160
    tp->valign = (TrayAlignmentType )0;
  } else {
    {
#line 1159
    tmp___3 = strcmp(str___0, "fixed");
    }
#line 1159
    if (tmp___3) {
      {
#line 1161
      tmp___2 = strcmp(str___0, "top");
      }
#line 1161
      if (tmp___2) {
        {
#line 1163
        tmp___1 = strcmp(str___0, "bottom");
        }
#line 1163
        if (tmp___1) {
          {
#line 1165
          tmp___0 = strcmp(str___0, "center");
          }
#line 1165
          if (tmp___0) {
            {
#line 1168
            tmp = gettext("invalid tray vertical alignment: \"%s\"");
#line 1168
            Warning((char const   *)tmp, str___0);
#line 1169
            tp->valign = (TrayAlignmentType )0;
            }
          } else {
#line 1166
            tp->valign = (TrayAlignmentType )3;
          }
        } else {
#line 1164
          tp->valign = (TrayAlignmentType )5;
        }
      } else {
#line 1162
        tp->valign = (TrayAlignmentType )2;
      }
    } else {
#line 1160
      tp->valign = (TrayAlignmentType )0;
    }
  }
#line 1172
  return;
}
}
#line 1175 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/tray.c"
void SetTrayOpacity(char const   *str___0 ) 
{ 
  double temp ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1181
  temp = atof(str___0);
  }
#line 1182
  if (temp <= 0.0) {
#line 1182
    tmp___0 = 1;
  } else
#line 1182
  if (temp > 1.0) {
#line 1182
    tmp___0 = 1;
  } else {
#line 1182
    tmp___0 = 0;
  }
  {
#line 1182
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 1182
  if (tmp___1) {
    {
#line 1183
    tmp = gettext("invalid tray opacity: %s");
#line 1183
    Warning((char const   *)tmp, str___0);
#line 1184
    temp = 1.0;
    }
  }
#line 1186
  trayOpacity = (unsigned int )(temp * (double )4294967295U);
#line 1188
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
static TrayButtonType *buttons  ;
#line 52
static void Create___3(TrayComponentType *cp ) ;
#line 53
static void Destroy___2(TrayComponentType *cp ) ;
#line 54
static void SetSize___2(TrayComponentType *cp , int width , int height ) ;
#line 55
static void Resize___3(TrayComponentType *cp ) ;
#line 56
static void Draw(TrayComponentType *cp , int active ) ;
#line 58
static void ProcessButtonPress(TrayComponentType *cp , int x , int y , int mask ) ;
#line 60
static void ProcessButtonRelease(TrayComponentType *cp , int x , int y , int mask ) ;
#line 62
static void ProcessMotionEvent(TrayComponentType *cp , int x , int y , int mask ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
void InitializeTrayButtons(void) 
{ 


  {
#line 67
  buttons = (TrayButtonType *)((void *)0);
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
void StartupTrayButtons(void) 
{ 
  TrayButtonType *bp ;
  int tmp ;
  char *tmp___0 ;
  long tmp___1 ;

  {
#line 75
  bp = buttons;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! bp) {
#line 75
      goto while_break;
    }
#line 76
    if (bp->label) {
      {
#line 77
      tmp = GetStringWidth((FontType )6, (char const   *)bp->label);
#line 77
      (bp->cp)->requestedWidth = tmp + 4;
#line 79
      (bp->cp)->requestedHeight = GetStringHeight((FontType )6);
      }
    } else {
#line 82
      (bp->cp)->requestedWidth = 0;
#line 83
      (bp->cp)->requestedHeight = 0;
    }
#line 85
    if (bp->iconName) {
      {
#line 86
      bp->icon = LoadNamedIcon((char const   *)bp->iconName);
#line 87
      tmp___1 = __builtin_expect((long )(! (! bp->icon)), 1L);
      }
#line 87
      if (tmp___1) {
#line 88
        (bp->cp)->requestedWidth += ((bp->icon)->image)->width;
#line 89
        (bp->cp)->requestedHeight += ((bp->icon)->image)->height;
      } else {
        {
#line 91
        tmp___0 = gettext("could not load tray icon: \"%s\"");
#line 91
        Warning((char const   *)tmp___0, bp->iconName);
        }
      }
    }
#line 94
    (bp->cp)->requestedWidth += 8;
#line 95
    (bp->cp)->requestedHeight += 8;
#line 75
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
void ShutdownTrayButtons(void) 
{ 


  {
#line 103
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
void DestroyTrayButtons(void) 
{ 
  TrayButtonType *bp ;

  {
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! buttons) {
#line 110
      goto while_break;
    }
#line 111
    bp = buttons->next;
#line 112
    if (buttons->label) {
      {
#line 113
      free((void *)buttons->label);
      }
    }
#line 115
    if (buttons->iconName) {
      {
#line 116
      free((void *)buttons->iconName);
      }
    }
#line 118
    if (buttons->action) {
      {
#line 119
      free((void *)buttons->action);
      }
    }
#line 121
    if (buttons->popup) {
      {
#line 122
      free((void *)buttons->popup);
      }
    }
    {
#line 124
    free((void *)buttons);
#line 125
    buttons = bp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
struct TrayComponentType *CreateTrayButton(char const   *iconName , char const   *label ,
                                           char const   *action , char const   *popup___0 ,
                                           int width , int height ) 
{ 
  TrayButtonType *bp ;
  TrayComponentType *cp ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  char *tmp___4 ;
  long tmp___5 ;
  char *tmp___6 ;
  long tmp___7 ;
  void *tmp___8 ;

  {
#line 138
  if ((unsigned long )label == (unsigned long )((void *)0)) {
#line 138
    goto _L;
  } else {
    {
#line 138
    tmp___0 = strlen(label);
    }
#line 138
    if (tmp___0 == 0UL) {
      _L: /* CIL Label */ 
#line 138
      if ((unsigned long )iconName == (unsigned long )((void *)0)) {
#line 138
        tmp___2 = 1;
      } else {
        {
#line 138
        tmp___1 = strlen(iconName);
        }
#line 138
        if (tmp___1 == 0UL) {
#line 138
          tmp___2 = 1;
        } else {
#line 138
          tmp___2 = 0;
        }
      }
    } else {
#line 138
      tmp___2 = 0;
    }
  }
  {
#line 138
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  }
#line 138
  if (tmp___3) {
    {
#line 140
    tmp = gettext("no icon or label for TrayButton");
#line 140
    Warning((char const   *)tmp);
    }
#line 141
    return ((struct TrayComponentType *)((void *)0));
  }
  {
#line 144
  tmp___5 = __builtin_expect((long )(! (! (width < 0))), 0L);
  }
#line 144
  if (tmp___5) {
    {
#line 145
    tmp___4 = gettext("invalid TrayButton width: %d");
#line 145
    Warning((char const   *)tmp___4, width);
#line 146
    width = 0;
    }
  }
  {
#line 148
  tmp___7 = __builtin_expect((long )(! (! (height < 0))), 0L);
  }
#line 148
  if (tmp___7) {
    {
#line 149
    tmp___6 = gettext("invalid TrayButton height: %d");
#line 149
    Warning((char const   *)tmp___6, height);
#line 150
    height = 0;
    }
  }
  {
#line 153
  tmp___8 = malloc(sizeof(TrayButtonType ));
#line 153
  bp = (TrayButtonType *)tmp___8;
#line 154
  bp->next = buttons;
#line 155
  buttons = bp;
#line 157
  bp->icon = (IconNode *)((void *)0);
#line 158
  bp->iconName = CopyString(iconName);
#line 159
  bp->label = CopyString(label);
#line 160
  bp->action = CopyString(action);
#line 161
  bp->popup = CopyString(popup___0);
#line 163
  cp = CreateTrayComponent();
#line 164
  cp->object = (void *)bp;
#line 165
  bp->cp = cp;
#line 166
  cp->requestedWidth = width;
#line 167
  cp->requestedHeight = height;
#line 169
  bp->mousex = -2;
#line 170
  bp->mousey = -2;
#line 172
  cp->Create = & Create___3;
#line 173
  cp->Destroy = & Destroy___2;
#line 174
  cp->SetSize = & SetSize___2;
#line 175
  cp->Resize = & Resize___3;
#line 177
  cp->ProcessButtonPress = & ProcessButtonPress;
#line 178
  cp->ProcessButtonRelease = & ProcessButtonRelease;
  }
#line 179
  if (popup___0) {
#line 180
    cp->ProcessMotionEvent = & ProcessMotionEvent;
  } else
#line 179
  if (label) {
#line 180
    cp->ProcessMotionEvent = & ProcessMotionEvent;
  }
#line 183
  return (cp);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
static void SetSize___2(TrayComponentType *cp , int width , int height ) 
{ 
  TrayButtonType *bp ;
  int labelWidth ;
  int labelHeight ;
  int iconWidth ;
  int iconHeight ;
  int ratio ;
  int tmp ;
  int tmp___0 ;

  {
#line 195
  bp = (TrayButtonType *)cp->object;
#line 197
  if (bp->icon) {
#line 199
    if (bp->label) {
      {
#line 200
      tmp = GetStringWidth((FontType )6, (char const   *)bp->label);
#line 200
      labelWidth = tmp + 4;
#line 201
      labelHeight = GetStringHeight((FontType )6);
      }
    } else {
#line 203
      labelWidth = 0;
#line 204
      labelHeight = 0;
    }
#line 207
    iconWidth = ((bp->icon)->image)->width;
#line 208
    iconHeight = ((bp->icon)->image)->height;
#line 211
    ratio = (iconWidth << 16) / iconHeight;
#line 213
    if (width > 0) {
#line 216
      iconWidth = (width - labelWidth) - 8;
#line 217
      iconHeight = (iconWidth << 16) / ratio;
#line 218
      if (iconHeight > labelHeight) {
#line 218
        tmp___0 = iconHeight;
      } else {
#line 218
        tmp___0 = labelHeight;
      }
#line 218
      height = tmp___0 + 8;
    } else
#line 220
    if (height > 0) {
#line 223
      iconHeight = height - 8;
#line 224
      iconWidth = iconHeight * ratio >> 16;
#line 225
      width = (iconWidth + labelWidth) + 8;
    }
#line 229
    cp->width = width;
#line 230
    cp->height = height;
  }
#line 234
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
static void Create___3(TrayComponentType *cp ) 
{ 
  TrayButtonType *bp ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 241
  bp = (TrayButtonType *)cp->object;
#line 244
  if (bp->action) {
    {
#line 244
    tmp___3 = strlen((char const   *)bp->action);
    }
#line 244
    if (tmp___3 > 0UL) {
      {
#line 245
      tmp___2 = strncmp((char const   *)bp->action, "exec:", (size_t )5);
      }
#line 245
      if (tmp___2) {
        {
#line 247
        tmp___1 = strncmp((char const   *)bp->action, "root:", (size_t )5);
        }
#line 247
        if (tmp___1) {
          {
#line 251
          tmp___0 = strcmp((char const   *)bp->action, "showdesktop");
          }
#line 251
          if (tmp___0) {
            {
#line 254
            tmp = gettext("invalid TrayButton action: \"%s\"");
#line 254
            Warning((char const   *)tmp, bp->action);
            }
          }
        }
      }
    }
  }
  {
#line 262
  cp->pixmap = XCreatePixmap(display, rootWindow, (unsigned int )cp->width, (unsigned int )cp->height,
                             (unsigned int )rootDepth);
#line 265
  Draw(cp, 0);
  }
#line 267
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
static void Resize___3(TrayComponentType *cp ) 
{ 


  {
  {
#line 272
  Destroy___2(cp);
#line 273
  Create___3(cp);
  }
#line 275
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
static void Destroy___2(TrayComponentType *cp ) 
{ 


  {
#line 279
  if (cp->pixmap != 0UL) {
    {
#line 280
    XFreePixmap(display, cp->pixmap);
    }
  }
#line 282
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
static void Draw(TrayComponentType *cp , int active ) 
{ 
  ButtonNode button ;
  TrayButtonType *bp ;
  int labelx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 291
  bp = (TrayButtonType *)cp->object;
#line 293
  XSetForeground(display, rootGC, colors[41]);
#line 294
  XFillRectangle(display, cp->pixmap, rootGC, 0, 0, (unsigned int )cp->width, (unsigned int )cp->height);
#line 296
  ResetButton(& button, cp->pixmap, rootGC);
  }
#line 297
  if (active) {
#line 298
    button.type = (ButtonType )4;
  } else {
#line 300
    button.type = (ButtonType )3;
  }
  {
#line 302
  button.width = cp->width - 3;
#line 303
  button.height = cp->height - 3;
#line 304
  button.x = 1;
#line 305
  button.y = 1;
#line 306
  DrawButton(& button);
  }
#line 309
  if (bp->label) {
#line 310
    if (! bp->icon) {
      {
#line 311
      labelx = 2 + cp->width / 2;
#line 312
      tmp = GetStringWidth((FontType )6, (char const   *)bp->label);
#line 312
      labelx -= tmp / 2;
      }
    } else {
      {
#line 314
      labelx = cp->width;
#line 315
      tmp___0 = GetStringWidth((FontType )6, (char const   *)bp->label);
#line 315
      labelx -= tmp___0 + 4;
      }
    }
  } else {
#line 318
    labelx = cp->width;
  }
#line 320
  labelx -= 4;
#line 322
  if (bp->icon) {
    {
#line 323
    PutIcon(bp->icon, cp->pixmap, 4, 4, labelx - 4, cp->height - 8);
    }
  }
#line 327
  if (bp->label) {
    {
#line 328
    tmp___1 = GetStringHeight((FontType )6);
#line 328
    RenderString(cp->pixmap, (FontType )6, (ColorType )42, labelx + 2, cp->height / 2 - tmp___1 / 2,
                 cp->width - labelx, (Region )((void *)0), (char const   *)bp->label);
    }
  }
#line 333
  return;
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
static void ProcessButtonPress(TrayComponentType *cp , int x , int y , int mask ) 
{ 
  ScreenType const   *sp ;
  int mwidth ;
  int mheight ;
  int button ;
  TrayButtonType *bp ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 342
  bp = (TrayButtonType *)cp->object;
#line 346
  if (bp->action) {
    {
#line 346
    tmp___0 = strlen((char const   *)bp->action);
    }
#line 346
    if (tmp___0 > 0UL) {
      {
#line 347
      tmp = strncmp((char const   *)bp->action, "root:", (size_t )5);
      }
#line 347
      if (tmp) {
        {
#line 348
        GrabMouse((cp->tray)->window);
#line 349
        cp->grabbed = 1;
#line 350
        Draw(cp, 1);
#line 351
        UpdateSpecificTray((TrayType const   *)cp->tray, (TrayComponentType const   *)cp);
        }
#line 352
        return;
      } else {
        {
#line 354
        button = atoi((char const   *)(bp->action + 5));
        }
      }
    } else {
#line 357
      button = 1;
    }
  } else {
#line 357
    button = 1;
  }
  {
#line 360
  GetRootMenuSize(button, & mwidth, & mheight);
#line 362
  sp = GetCurrentScreen(cp->screenx, cp->screeny);
  }
#line 364
  if ((unsigned int )(cp->tray)->layout == 0U) {
#line 365
    x = cp->screenx;
#line 366
    if (cp->screeny + cp->height / 2 < (int )(sp->y + sp->height / 2)) {
#line 367
      y = cp->screeny + cp->height;
    } else {
#line 369
      y = cp->screeny - mheight;
    }
  } else {
#line 372
    y = cp->screeny;
#line 373
    if (cp->screenx + cp->width / 2 < (int )(sp->x + sp->width / 2)) {
#line 374
      x = cp->screenx + cp->width;
    } else {
#line 376
      x = cp->screenx - mwidth;
    }
  }
  {
#line 380
  Draw(cp, 1);
#line 381
  UpdateSpecificTray((TrayType const   *)cp->tray, (TrayComponentType const   *)cp);
#line 382
  ShowRootMenu(button, x, y);
#line 383
  Draw(cp, 0);
#line 384
  UpdateSpecificTray((TrayType const   *)cp->tray, (TrayComponentType const   *)cp);
  }
#line 386
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
static void ProcessButtonRelease(TrayComponentType *cp , int x , int y , int mask ) 
{ 
  TrayButtonType *bp ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 391
  bp = (TrayButtonType *)cp->object;
#line 395
  Draw(cp, 0);
#line 396
  UpdateSpecificTray((TrayType const   *)cp->tray, (TrayComponentType const   *)cp);
  }
#line 400
  if (x < 0) {
#line 401
    return;
  } else
#line 400
  if (x >= cp->width) {
#line 401
    return;
  }
#line 403
  if (y < 0) {
#line 404
    return;
  } else
#line 403
  if (y >= cp->height) {
#line 404
    return;
  }
#line 408
  if (bp->action) {
    {
#line 408
    tmp___1 = strlen((char const   *)bp->action);
    }
#line 408
    if (tmp___1 > 0UL) {
      {
#line 409
      tmp___0 = strncmp((char const   *)bp->action, "exec:", (size_t )5);
      }
#line 409
      if (tmp___0) {
        {
#line 412
        tmp = strcmp((char const   *)bp->action, "showdesktop");
        }
#line 412
        if (! tmp) {
          {
#line 413
          ShowDesktop();
          }
#line 414
          return;
        }
      } else {
        {
#line 410
        RunCommand((char const   *)(bp->action + 5));
        }
#line 411
        return;
      }
    }
  }
#line 418
  return;
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
static void ProcessMotionEvent(TrayComponentType *cp , int x , int y , int mask ) 
{ 
  TrayButtonType *bp ;

  {
  {
#line 423
  bp = (TrayButtonType *)cp->object;
#line 425
  bp->mousex = cp->screenx + x;
#line 426
  bp->mousey = cp->screeny + y;
#line 427
  GetCurrentTime(& bp->mouseTime);
  }
#line 429
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
void SignalTrayButton(struct TimeType  const  *now , int x , int y ) 
{ 
  TrayButtonType *bp ;
  char const   *popup___0 ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 437
  bp = buttons;
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (! bp) {
#line 437
      goto while_break;
    }
#line 438
    if (bp->popup) {
#line 439
      popup___0 = (char const   *)bp->popup;
    } else
#line 440
    if (bp->label) {
#line 441
      popup___0 = (char const   *)bp->label;
    } else {
#line 443
      goto __Cont;
    }
    {
#line 445
    tmp___0 = abs(bp->mousex - x);
    }
#line 445
    if (tmp___0 < 2) {
      {
#line 445
      tmp___1 = abs(bp->mousey - y);
      }
#line 445
      if (tmp___1 < 2) {
        {
#line 447
        tmp = GetTimeDifference(now, (TimeType const   *)(& bp->mouseTime));
        }
#line 447
        if (tmp >= (unsigned long )popupDelay) {
          {
#line 448
          ShowPopup(x, y, popup___0);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 437
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/traybutton.c"
void ValidateTrayButtons(void) 
{ 
  TrayButtonType *bp ;
  int bindex ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 461
  bp = buttons;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! bp) {
#line 461
      goto while_break;
    }
#line 462
    if (bp->action) {
      {
#line 462
      tmp___3 = strncmp((char const   *)bp->action, "root:", (size_t )5);
      }
#line 462
      if (! tmp___3) {
        {
#line 463
        bindex = atoi((char const   *)(bp->action + 5));
#line 464
        tmp___0 = IsRootMenuDefined(bindex);
        }
#line 464
        if (tmp___0) {
#line 464
          tmp___1 = 0;
        } else {
#line 464
          tmp___1 = 1;
        }
        {
#line 464
        tmp___2 = __builtin_expect((long )tmp___1, 0L);
        }
#line 464
        if (tmp___2) {
          {
#line 465
          tmp = gettext("tray button: root menu %d not defined");
#line 465
          Warning((char const   *)tmp, bindex);
          }
        }
      }
    }
#line 461
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  return;
}
}
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/misc.c"
static int IsSpace___0(char ch ) ;
#line 14
static int IsSymbolic(char ch ) ;
#line 15
static char *GetSymbolName(char const   *str___0 ) ;
#line 16
static void ReplaceSymbol(char **str___0 , char const   *name , char const   *value ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/misc.c"
static int IsSpace___0(char ch ) 
{ 


  {
  {
#line 24
  if ((int )ch == 13) {
#line 24
    goto case_13;
  }
#line 24
  if ((int )ch == 10) {
#line 24
    goto case_13;
  }
#line 24
  if ((int )ch == 9) {
#line 24
    goto case_13;
  }
#line 24
  if ((int )ch == 32) {
#line 24
    goto case_13;
  }
#line 26
  goto switch_default;
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 25
  return (1);
  switch_default: /* CIL Label */ 
#line 27
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/misc.c"
static int IsSymbolic(char ch ) 
{ 


  {
#line 34
  if ((int )ch >= 65) {
#line 34
    if ((int )ch <= 90) {
#line 35
      return (1);
    } else {
#line 34
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 36
  if ((int )ch >= 97) {
#line 36
    if ((int )ch <= 122) {
#line 37
      return (1);
    } else {
#line 36
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 38
  if ((int )ch >= 48) {
#line 38
    if ((int )ch <= 57) {
#line 39
      return (1);
    } else {
#line 38
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 40
  if ((int )ch == 95) {
#line 41
    return (1);
  } else {
#line 43
    return (0);
  }
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/misc.c"
static char *GetSymbolName(char const   *str___0 ) 
{ 
  char *temp ;
  int stop ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 54
  if ((int const   )*str___0 == 36) {
    {
#line 55
    tmp = malloc((size_t )2);
#line 55
    temp = (char *)tmp;
#line 56
    *(temp + 0) = (char )'$';
#line 57
    *(temp + 1) = (char)0;
    }
  } else {
#line 59
    stop = 0;
    {
#line 59
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 59
      tmp___0 = IsSymbolic((char )*(str___0 + stop));
      }
#line 59
      if (! tmp___0) {
#line 59
        goto while_break;
      }
#line 59
      stop ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 60
    tmp___1 = malloc((size_t )(stop + 1));
#line 60
    temp = (char *)tmp___1;
#line 61
    memcpy((void */* __restrict  */)temp, (void const   */* __restrict  */)str___0,
           (size_t )stop);
#line 62
    *(temp + stop) = (char)0;
    }
  }
#line 65
  return (temp);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/misc.c"
static void ReplaceSymbol(char **str___0 , char const   *name , char const   *value ) 
{ 
  char *temp ;
  int strLength ;
  int nameLength ;
  int valueLength ;
  int x ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 81
  tmp = strlen((char const   *)*str___0);
#line 81
  strLength = (int )tmp;
#line 82
  tmp___0 = strlen(name);
#line 82
  nameLength = (int )(tmp___0 + 1UL);
  }
#line 83
  if (value) {
    {
#line 84
    tmp___1 = strlen(value);
#line 84
    valueLength = (int )tmp___1;
    }
  } else {
#line 86
    valueLength = 0;
  }
#line 89
  if (valueLength > nameLength) {
    {
#line 90
    tmp___2 = malloc((size_t )(((strLength - nameLength) + valueLength) + 1));
#line 90
    temp = (char *)tmp___2;
#line 91
    strcpy((char */* __restrict  */)temp, (char const   */* __restrict  */)*str___0);
#line 92
    free((void *)*str___0);
#line 93
    *str___0 = temp;
    }
  }
  {
#line 96
  temp = strstr((char const   *)*str___0, name);
#line 98
  temp --;
  }
#line 100
  if (nameLength > valueLength) {
#line 103
    x = 0;
    {
#line 103
    while (1) {
      while_continue: /* CIL Label */ ;
#line 103
      if (! *(temp + x)) {
#line 103
        goto while_break;
      }
#line 104
      *(temp + x) = *(temp + ((x + nameLength) - valueLength));
#line 103
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 106
    *(temp + x) = *(temp + ((x + nameLength) - valueLength));
  } else
#line 108
  if (nameLength < valueLength) {
    {
#line 111
    tmp___3 = strlen((char const   *)temp);
#line 111
    x = (int )tmp___3;
    }
    {
#line 111
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 111
      if (! (x >= 0)) {
#line 111
        goto while_break___0;
      }
#line 112
      *(temp + ((x + valueLength) - nameLength)) = *(temp + x);
#line 111
      x --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 118
  if (value) {
    {
#line 119
    memcpy((void */* __restrict  */)temp, (void const   */* __restrict  */)value,
           (size_t )valueLength);
    }
  }
#line 122
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/misc.c"
void ExpandPath(char **path ) 
{ 
  char *name ;
  char *value ;
  int x ;
  size_t tmp ;

  {
#line 133
  x = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! *(*path + x)) {
#line 133
      goto while_break;
    }
#line 135
    if ((int )*(*path + x) == 36) {
      {
#line 136
      name = GetSymbolName((char const   *)((*path + x) + 1));
#line 137
      value = getenv((char const   *)name);
#line 138
      ReplaceSymbol(path, (char const   *)name, (char const   *)value);
#line 139
      free((void *)name);
      }
#line 140
      if (value) {
        {
#line 141
        tmp = strlen((char const   *)value);
#line 141
        x = (int )((size_t )x + (tmp - 1UL));
        }
      }
    }
#line 133
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/misc.c"
void Trim(char *str___0 ) 
{ 
  int length ;
  int start ;
  int x ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 158
  tmp = strlen((char const   *)str___0);
#line 158
  length = (int )tmp;
#line 161
  start = 0;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 161
    tmp___0 = IsSpace___0(*(str___0 + start));
    }
#line 161
    if (! tmp___0) {
#line 161
      goto while_break;
    }
#line 161
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if (start > 0) {
#line 165
    length -= start;
#line 166
    x = 0;
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 166
      if (! (x < length + 1)) {
#line 166
        goto while_break___0;
      }
#line 167
      *(str___0 + x) = *(str___0 + (x + start));
#line 166
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 172
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 172
    if (length > 0) {
      {
#line 172
      tmp___1 = IsSpace___0(*(str___0 + (length - 1)));
      }
#line 172
      if (! tmp___1) {
#line 172
        goto while_break___1;
      }
    } else {
#line 172
      goto while_break___1;
    }
#line 173
    length --;
#line 174
    *(str___0 + length) = (char)0;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 177
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/misc.c"
char *CopyString(char const   *str___0 ) 
{ 
  char *temp ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 185
  if (! str___0) {
#line 186
    return ((char *)((void *)0));
  }
  {
#line 189
  tmp = strlen(str___0);
#line 189
  len = (int )(tmp + 1UL);
#line 190
  tmp___0 = malloc((size_t )len);
#line 190
  temp = (char *)tmp___0;
#line 191
  memcpy((void */* __restrict  */)temp, (void const   */* __restrict  */)str___0,
         (size_t )len);
  }
#line 193
  return (temp);
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/help.h"
void DisplayCompileOptions(void) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/help.c"
void DisplayAbout(void) 
{ 


  {
  {
#line 15
  printf((char const   */* __restrict  */)"JWM v%s by Joe Wingbermuehle\n", "svn-579");
#line 16
  DisplayCompileOptions();
  }
#line 17
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/help.c"
void DisplayCompileOptions(void) 
{ 


  {
  {
#line 22
  printf((char const   */* __restrict  */)"compiled options: ");
#line 25
  printf((char const   */* __restrict  */)"confirm ");
#line 37
  printf((char const   */* __restrict  */)"icons ");
#line 64
  printf((char const   */* __restrict  */)"\nsystem configuration: %s\n", "/usr/local/etc/system.jwmrc");
  }
#line 66
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/help.c"
void DisplayHelp(void) 
{ 


  {
  {
#line 70
  DisplayUsage();
#line 71
  printf((char const   */* __restrict  */)"  -display X  Set the X display to use\n");
#line 72
  printf((char const   */* __restrict  */)"  -exit       Exit JWM (send _JWM_EXIT to the root)\n");
#line 73
  printf((char const   */* __restrict  */)"  -h          Display this help message\n");
#line 74
  printf((char const   */* __restrict  */)"  -p          Parse the configuration file and exit\n");
#line 75
  printf((char const   */* __restrict  */)"  -reload     Reload menu (send _JWM_RELOAD to the root)\n");
#line 76
  printf((char const   */* __restrict  */)"  -restart    Restart JWM (send _JWM_RESTART to the root)\n");
#line 77
  printf((char const   */* __restrict  */)"  -v          Display version information\n");
  }
#line 78
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/help.c"
void DisplayUsage(void) 
{ 


  {
  {
#line 82
  DisplayAbout();
#line 83
  printf((char const   */* __restrict  */)"usage: jwm [ options ]\n");
  }
#line 84
  return;
}
}
#line 1922 "/usr/include/X11/Xlib.h"
extern int XGetWMColormapWindows(Display * , Window  , Window ** , int * ) ;
#line 1934
extern void XFreeStringList(char ** ) ;
#line 2249
extern int XDeleteProperty(Display * , Window  , Atom  ) ;
#line 2465
extern int XFetchName(Display * , Window  , char ** ) ;
#line 2682
extern int XGetTransientForHint(Display * , Window  , Window * ) ;
#line 484 "/usr/include/X11/Xutil.h"
extern XWMHints *XGetWMHints(Display * , Window  ) ;
#line 501
extern int XGetWMNormalHints(Display * , Window  , XSizeHints * , long * ) ;
#line 793
extern int Xutf8TextPropertyToTextList(Display *display , XTextProperty const   *text_prop ,
                                       char ***list_return , int *count_return ) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.h"
Atom atoms[64]  ;
#line 159
void ReadWMClass(struct ClientNode *np ) ;
#line 199
int GetCardinalAtom(Window window , AtomType atom , unsigned long *value ) ;
#line 207
int GetWindowAtom(Window window , AtomType atom , Window *value ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
static AtomNode const   atomList[64]  = 
#line 69 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
  {      {& atoms[0], "COMPOUND_TEXT"}, 
        {& atoms[1], "UTF8_STRING"}, 
        {& atoms[2], "_XSETROOT_ID"}, 
        {& atoms[3], "WM_STATE"}, 
        {& atoms[4], "WM_PROTOCOLS"}, 
        {& atoms[5], "WM_DELETE_WINDOW"}, 
        {& atoms[6], "WM_TAKE_FOCUS"}, 
        {& atoms[7], "WM_LOCALE_NAME"}, 
        {& atoms[8], "WM_CHANGE_STATE"}, 
        {& atoms[9], "WM_COLORMAP_WINDOWS"}, 
        {& atoms[10], "_NET_SUPPORTED"}, 
        {& atoms[11], "_NET_NUMBER_OF_DESKTOPS"}, 
        {& atoms[12], "_NET_DESKTOP_NAMES"}, 
        {& atoms[13], "_NET_DESKTOP_GEOMETRY"}, 
        {& atoms[14], "_NET_DESKTOP_VIEWPORT"}, 
        {& atoms[15], "_NET_CURRENT_DESKTOP"}, 
        {& atoms[16], "_NET_ACTIVE_WINDOW"}, 
        {& atoms[17], "_NET_WORKAREA"}, 
        {& atoms[18], "_NET_SUPPORTING_WM_CHECK"}, 
        {& atoms[19], "_NET_SHOWING_DESKTOP"}, 
        {& atoms[20], "_NET_FRAME_EXTENTS"}, 
        {& atoms[21], "_NET_WM_DESKTOP"}, 
        {& atoms[22], "_NET_WM_STATE"}, 
        {& atoms[23], "_NET_WM_STATE_STICKY"}, 
        {& atoms[24], "_NET_WM_STATE_MAXIMIZED_VERT"}, 
        {& atoms[25], "_NET_WM_STATE_MAXIMIZED_HORZ"}, 
        {& atoms[26], "_NET_WM_STATE_SHADED"}, 
        {& atoms[27], "_NET_WM_STATE_FULLSCREEN"}, 
        {& atoms[28], "_NET_WM_STATE_HIDDEN"}, 
        {& atoms[29], "_NET_WM_STATE_SKIP_TASKBAR"}, 
        {& atoms[30], "_NET_WM_STATE_BELOW"}, 
        {& atoms[31], "_NET_WM_STATE_ABOVE"}, 
        {& atoms[32], "_NET_WM_ALLOWED_ACTIONS"}, 
        {& atoms[33], "_NET_WM_ACTION_MOVE"}, 
        {& atoms[34], "_NET_WM_ACTION_RESIZE"}, 
        {& atoms[35], "_NET_WM_ACTION_MINIMIZE"}, 
        {& atoms[36], "_NET_WM_ACTION_SHADE"}, 
        {& atoms[37], "_NET_WM_ACTION_STICK"}, 
        {& atoms[38], "_NET_WM_ACTION_MAXIMIZE_HORZ"}, 
        {& atoms[39], "_NET_WM_ACTION_MAXIMIZE_VERT"}, 
        {& atoms[40], "_NET_WM_ACTION_CHANGE_DESKTOP"}, 
        {& atoms[41], "_NET_WM_ACTION_CLOSE"}, 
        {& atoms[42], "_NET_WM_ACTION_BELOW"}, 
        {& atoms[43], "_NET_WM_ACTION_ABOVE"}, 
        {& atoms[44], "_NET_CLOSE_WINDOW"}, 
        {& atoms[45], "_NET_MOVERESIZE_WINDOW"}, 
        {& atoms[46], "_NET_WM_NAME"}, 
        {& atoms[47], "_NET_WM_ICON"}, 
        {& atoms[48], "_NET_WM_WINDOW_TYPE"}, 
        {& atoms[49], "_NET_WM_WINDOW_TYPE_DESKTOP"}, 
        {& atoms[50], "_NET_WM_WINDOW_TYPE_DOCK"}, 
        {& atoms[51], "_NET_WM_WINDOW_TYPE_SPLASH"}, 
        {& atoms[52], "_NET_WM_WINDOW_TYPE_DIALOG"}, 
        {& atoms[53], "_NET_WM_WINDOW_TYPE_NORMAL"}, 
        {& atoms[54], "_NET_CLIENT_LIST"}, 
        {& atoms[55], "_NET_CLIENT_LIST_STACKING"}, 
        {& atoms[56], "_NET_WM_STRUT_PARTIAL"}, 
        {& atoms[57], "_NET_WM_STRUT"}, 
        {& atoms[58], "_NET_SYSTEM_TRAY_OPCODE"}, 
        {& atoms[59], "_NET_WM_WINDOW_OPACITY"}, 
        {& atoms[60], "_MOTIF_WM_HINTS"}, 
        {& atoms[61], "_JWM_RESTART"}, 
        {& atoms[62], "_JWM_EXIT"}, 
        {& atoms[63], "_JWM_RELOAD"}};
#line 143
static void WriteNetState(ClientNode *np ) ;
#line 144
static void WriteNetAllowed(ClientNode *np ) ;
#line 145
static void ReadWMHints(Window win , ClientState *state ) ;
#line 146
static void ReadMotifHints(Window win , ClientState *state ) ;
#line 149 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void InitializeHints(void) 
{ 


  {
#line 150
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void StartupHints(void) 
{ 
  unsigned long *array ;
  char *data ;
  Atom *supported ;
  Window win ;
  unsigned int x ;
  unsigned int count ;
  char const   *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;

  {
#line 163
  count = 0U;
#line 164
  x = 0U;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (x < desktopCount)) {
#line 164
      goto while_break;
    }
    {
#line 165
    tmp = GetDesktopName(x);
#line 165
    tmp___0 = strlen(tmp);
#line 165
    count = (unsigned int )((size_t )count + (tmp___0 + 1UL));
#line 164
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  if ((unsigned long )count < (unsigned long )(4U * desktopCount) * sizeof(unsigned long )) {
#line 168
    count = (unsigned int )((unsigned long )(4U * desktopCount) * sizeof(unsigned long ));
  }
#line 170
  if ((unsigned long )count < 2UL * sizeof(unsigned long )) {
#line 171
    count = (unsigned int )(2UL * sizeof(unsigned long ));
  }
#line 173
  if ((unsigned long )count < 64UL * sizeof(Atom )) {
#line 174
    count = (unsigned int )(64UL * sizeof(Atom ));
  }
  {
#line 176
  tmp___1 = __builtin_alloca((unsigned long )count);
#line 176
  data = (char *)tmp___1;
#line 177
  array = (unsigned long *)data;
#line 178
  supported = (Atom *)data;
#line 181
  x = 0U;
  }
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 181
    if (! (x < 64U)) {
#line 181
      goto while_break___0;
    }
    {
#line 182
    *(atomList[x].atom) = XInternAtom(display, (char const   *)atomList[x].name, 0);
#line 181
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 186
  x = 10U;
  {
#line 186
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 186
    if (! (x <= 58U)) {
#line 186
      goto while_break___1;
    }
#line 187
    *(supported + (x - 10U)) = atoms[x];
#line 186
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 189
  XChangeProperty(display, rootWindow, atoms[10], (Atom )4, 32, 0, (unsigned char const   *)((unsigned char *)supported),
                  49);
#line 194
  SetCardinalAtom(rootWindow, (AtomType )11, (unsigned long )desktopCount);
#line 197
  count = 0U;
#line 198
  x = 0U;
  }
  {
#line 198
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 198
    if (! (x < desktopCount)) {
#line 198
      goto while_break___2;
    }
    {
#line 199
    tmp___2 = GetDesktopName(x);
#line 199
    strcpy((char */* __restrict  */)(data + count), (char const   */* __restrict  */)tmp___2);
#line 200
    tmp___3 = GetDesktopName(x);
#line 200
    tmp___4 = strlen(tmp___3);
#line 200
    count = (unsigned int )((size_t )count + (tmp___4 + 1UL));
#line 198
    x ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 202
  XChangeProperty(display, rootWindow, atoms[12], atoms[1], 8, 0, (unsigned char const   *)((unsigned char *)data),
                  (int )count);
#line 207
  x = 0U;
  }
  {
#line 207
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 207
    if (! (x < desktopCount)) {
#line 207
      goto while_break___3;
    }
#line 208
    *(array + x * 4U) = 0UL;
#line 209
    *(array + (x * 4U + 1U)) = 0UL;
#line 210
    *(array + (x * 4U + 2U)) = (unsigned long )rootWidth;
#line 211
    *(array + (x * 4U + 3U)) = (unsigned long )rootHeight;
#line 207
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 213
  XChangeProperty(display, rootWindow, atoms[17], (Atom )6, 32, 0, (unsigned char const   *)((unsigned char *)array),
                  (int )(desktopCount * 4U));
#line 218
  *(array + 0) = (unsigned long )rootWidth;
#line 219
  *(array + 1) = (unsigned long )rootHeight;
#line 220
  XChangeProperty(display, rootWindow, atoms[13], (Atom )6, 32, 0, (unsigned char const   *)((unsigned char *)array),
                  2);
#line 225
  *(array + 0) = 0UL;
#line 226
  *(array + 1) = 0UL;
#line 227
  XChangeProperty(display, rootWindow, atoms[14], (Atom )6, 32, 0, (unsigned char const   *)((unsigned char *)array),
                  2);
#line 231
  win = GetSupportingWindow();
#line 232
  XChangeProperty(display, win, atoms[46], atoms[1], 8, 0, (unsigned char const   *)((unsigned char *)"JWM"),
                  3);
#line 236
  SetWindowAtom(rootWindow, (AtomType )18, win);
#line 237
  SetWindowAtom(win, (AtomType )18, win);
  }
#line 241
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void ShutdownHints(void) 
{ 


  {
#line 245
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void DestroyHints(void) 
{ 


  {
#line 249
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void ReadCurrentDesktop(void) 
{ 
  unsigned long temp ;
  int tmp ;

  {
  {
#line 256
  currentDesktop = 0U;
#line 258
  tmp = GetCardinalAtom(rootWindow, (AtomType )15, & temp);
  }
#line 258
  if (tmp) {
    {
#line 259
    ChangeDesktop((unsigned int )temp);
    }
  } else {
    {
#line 261
    ChangeDesktop(0U);
    }
  }
#line 264
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void ReadClientProtocols(struct ClientNode *np ) 
{ 
  int status ;
  ClientNode *pp ;

  {
  {
#line 276
  ReadWMName(np);
#line 277
  ReadWMClass(np);
#line 278
  ReadWMNormalHints(np);
#line 279
  ReadWMColormaps(np);
#line 281
  status = XGetTransientForHint(display, np->window, & np->owner);
  }
#line 282
  if (! status) {
#line 283
    np->owner = (Window )0L;
  }
  {
#line 286
  np->state = ReadWindowState(np->window);
  }
#line 287
  if (np->minWidth == np->maxWidth) {
#line 287
    if (np->minHeight == np->maxHeight) {
#line 288
      np->state.border &= 4294967263U;
    }
  }
#line 292
  if (np->owner != 0UL) {
    {
#line 293
    pp = FindClientByWindow(np->owner);
    }
#line 294
    if (pp) {
#line 295
      np->state.layer = pp->state.layer;
    }
  }
#line 299
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void WriteState(struct ClientNode *np ) 
{ 
  unsigned long data[2] ;

  {
#line 308
  if (np->state.status & 2U) {
#line 309
    data[0] = 1UL;
  } else
#line 310
  if (np->state.status & 128U) {
#line 311
    data[0] = 3UL;
  } else {
#line 313
    data[0] = 0UL;
  }
  {
#line 315
  data[1] = 0UL;
#line 317
  XChangeProperty(display, np->window, atoms[3], atoms[3], 32, 0, (unsigned char const   *)((unsigned char *)(data)),
                  2);
#line 321
  WriteNetState(np);
#line 322
  WriteNetAllowed(np);
  }
#line 325
  if (np->state.opacity == 4294967295U) {
    {
#line 326
    XDeleteProperty(display, np->parent, atoms[59]);
    }
  } else {
    {
#line 328
    SetCardinalAtom(np->parent, (AtomType )59, (unsigned long )np->state.opacity);
    }
  }
  {
#line 333
  XSync(display, 0);
  }
#line 335
  return;
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
static void WriteNetState(ClientNode *np ) 
{ 
  unsigned long values[8] ;
  int north ;
  int south ;
  int east ;
  int west ;
  int index___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 347
  if (! (np->state.status & 2U)) {
    {
#line 348
    XDeleteProperty(display, np->window, atoms[22]);
    }
#line 349
    return;
  }
#line 352
  index___0 = 0;
#line 353
  if (np->state.status & 4U) {
#line 354
    tmp = index___0;
#line 354
    index___0 ++;
#line 354
    values[tmp] = atoms[25];
  }
#line 356
  if (np->state.status & 8U) {
#line 357
    tmp___0 = index___0;
#line 357
    index___0 ++;
#line 357
    values[tmp___0] = atoms[24];
  }
#line 360
  if (np->state.status & 256U) {
#line 361
    tmp___1 = index___0;
#line 361
    index___0 ++;
#line 361
    values[tmp___1] = atoms[26];
  }
#line 364
  if (np->state.status & 32U) {
#line 365
    tmp___2 = index___0;
#line 365
    index___0 ++;
#line 365
    values[tmp___2] = atoms[23];
  }
#line 368
  if (np->state.status & 8192U) {
#line 369
    tmp___3 = index___0;
#line 369
    index___0 ++;
#line 369
    values[tmp___3] = atoms[27];
  }
#line 372
  if (np->state.status & 64U) {
#line 373
    tmp___4 = index___0;
#line 373
    index___0 ++;
#line 373
    values[tmp___4] = atoms[29];
  }
#line 376
  if (np->state.layer == 2U) {
#line 377
    tmp___5 = index___0;
#line 377
    index___0 ++;
#line 377
    values[tmp___5] = atoms[30];
  } else
#line 378
  if (np->state.layer == 6U) {
#line 379
    tmp___6 = index___0;
#line 379
    index___0 ++;
#line 379
    values[tmp___6] = atoms[31];
  }
  {
#line 382
  XChangeProperty(display, np->window, atoms[22], (Atom )4, 32, 0, (unsigned char const   *)((unsigned char *)(values)),
                  index___0);
#line 385
  GetBorderSize((struct ClientNode  const  *)np, & north, & south, & east, & west);
#line 388
  values[0] = (unsigned long )west;
#line 389
  values[1] = (unsigned long )east;
#line 390
  values[2] = (unsigned long )north;
#line 391
  values[3] = (unsigned long )south;
#line 393
  XChangeProperty(display, np->window, atoms[20], (Atom )6, 32, 0, (unsigned char const   *)((unsigned char *)(values)),
                  4);
  }
#line 396
  return;
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
static void WriteNetAllowed(ClientNode *np ) 
{ 
  unsigned long values[12] ;
  int index___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 406
  index___0 = 0;
#line 408
  if (np->state.border & 2U) {
#line 409
    tmp = index___0;
#line 409
    index___0 ++;
#line 409
    values[tmp] = atoms[36];
  }
#line 412
  if (np->state.border & 4U) {
#line 413
    tmp___0 = index___0;
#line 413
    index___0 ++;
#line 413
    values[tmp___0] = atoms[35];
  }
#line 416
  if (np->state.border & 8U) {
#line 417
    tmp___1 = index___0;
#line 417
    index___0 ++;
#line 417
    values[tmp___1] = atoms[38];
#line 418
    tmp___2 = index___0;
#line 418
    index___0 ++;
#line 418
    values[tmp___2] = atoms[39];
  }
#line 421
  if (np->state.border & 16U) {
#line 422
    tmp___3 = index___0;
#line 422
    index___0 ++;
#line 422
    values[tmp___3] = atoms[41];
  }
#line 425
  if (np->state.border & 32U) {
#line 426
    tmp___4 = index___0;
#line 426
    index___0 ++;
#line 426
    values[tmp___4] = atoms[34];
  }
#line 429
  if (np->state.border & 64U) {
#line 430
    tmp___5 = index___0;
#line 430
    index___0 ++;
#line 430
    values[tmp___5] = atoms[33];
  }
#line 433
  if (! (np->state.status & 32U)) {
#line 434
    tmp___6 = index___0;
#line 434
    index___0 ++;
#line 434
    values[tmp___6] = atoms[40];
  }
  {
#line 437
  tmp___7 = index___0;
#line 437
  index___0 ++;
#line 437
  values[tmp___7] = atoms[37];
#line 438
  tmp___8 = index___0;
#line 438
  index___0 ++;
#line 438
  values[tmp___8] = atoms[42];
#line 439
  tmp___9 = index___0;
#line 439
  index___0 ++;
#line 439
  values[tmp___9] = atoms[43];
#line 441
  XChangeProperty(display, np->window, atoms[32], (Atom )4, 32, 0, (unsigned char const   *)((unsigned char *)(values)),
                  index___0);
  }
#line 444
  return;
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
ClientState ReadWindowState(Window win ) 
{ 
  ClientState result ;
  int status ;
  unsigned long count ;
  unsigned long x ;
  unsigned long extra ;
  Atom realType ;
  int realFormat ;
  unsigned char *temp ;
  Atom *state ;
  unsigned long card ;
  int maxVert ;
  int maxHorz ;
  int fullScreen ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 463
  result.status = 0U;
#line 464
  result.border = 511U;
#line 465
  result.layer = 4U;
#line 466
  result.desktop = currentDesktop;
#line 467
  result.opacity = 4294967295U;
#line 469
  ReadWMHints(win, & result);
#line 470
  ReadMotifHints(win, & result);
#line 473
  tmp = GetCardinalAtom(win, (AtomType )21, & card);
  }
#line 473
  if (tmp) {
#line 474
    if (card == 0xffffffffffffffffUL) {
#line 475
      result.status |= 32U;
    } else
#line 476
    if (card < (unsigned long )desktopCount) {
#line 477
      result.desktop = (unsigned int )card;
    } else {
#line 479
      result.desktop = desktopCount - 1U;
    }
  }
  {
#line 484
  status = XGetWindowProperty(display, win, atoms[22], 0L, 32L, 0, (Atom )4, & realType,
                              & realFormat, & count, & extra, & temp);
  }
#line 487
  if (status == 0) {
#line 488
    if (count > 0UL) {
#line 489
      maxVert = 0;
#line 490
      maxHorz = 0;
#line 491
      fullScreen = 0;
#line 492
      state = (Atom *)temp;
#line 493
      x = 0UL;
      {
#line 493
      while (1) {
        while_continue: /* CIL Label */ ;
#line 493
        if (! (x < count)) {
#line 493
          goto while_break;
        }
#line 494
        if (*(state + x) == atoms[23]) {
#line 495
          result.status |= 32U;
        } else
#line 496
        if (*(state + x) == atoms[26]) {
#line 497
          result.status |= 256U;
        } else
#line 498
        if (*(state + x) == atoms[24]) {
#line 499
          maxVert = 1;
        } else
#line 500
        if (*(state + x) == atoms[25]) {
#line 501
          maxHorz = 1;
        } else
#line 502
        if (*(state + x) == atoms[27]) {
#line 503
          fullScreen = 1;
#line 504
          result.layer = 12U;
        } else
#line 505
        if (*(state + x) == atoms[28]) {
#line 506
          result.status |= 128U;
        } else
#line 507
        if (*(state + x) == atoms[29]) {
#line 508
          result.status |= 64U;
        } else
#line 509
        if (*(state + x) == atoms[31]) {
#line 510
          result.layer = 6U;
        } else
#line 511
        if (*(state + x) == atoms[30]) {
#line 512
          result.layer = 2U;
        }
#line 493
        x ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 515
      if (maxHorz) {
#line 516
        result.status |= 4U;
      }
#line 518
      if (maxVert) {
#line 519
        result.status |= 8U;
      }
#line 521
      if (fullScreen) {
#line 522
        result.status |= 8192U;
      }
    }
#line 525
    if (temp) {
      {
#line 526
      XFree((void *)temp);
      }
    }
  }
  {
#line 531
  status = XGetWindowProperty(display, win, atoms[48], 0L, 32L, 0, (Atom )4, & realType,
                              & realFormat, & count, & extra, & temp);
  }
#line 534
  if (status == 0) {
#line 536
    state = (Atom *)temp;
#line 537
    x = 0UL;
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 537
      if (! (x < count)) {
#line 537
        goto while_break___0;
      }
#line 538
      if (*(state + x) == atoms[53]) {
#line 539
        goto while_break___0;
      } else
#line 540
      if (*(state + x) == atoms[49]) {
#line 541
        if (result.layer == 4U) {
#line 542
          result.layer = 0U;
        }
#line 544
        result.border = 0U;
#line 545
        result.status |= 32U;
#line 546
        result.status |= 64U;
#line 547
        goto while_break___0;
      } else
#line 548
      if (*(state + x) == atoms[50]) {
#line 549
        result.border = 0U;
#line 550
        if (result.layer == 4U) {
#line 551
          result.layer = 6U;
        }
#line 553
        goto while_break___0;
      } else
#line 554
      if (*(state + x) == atoms[51]) {
#line 555
        result.border = 0U;
#line 556
        goto while_break___0;
      } else
#line 557
      if (*(state + x) == atoms[52]) {
#line 558
        result.border &= 4294967291U;
#line 559
        result.status |= 64U;
#line 560
        goto while_break___0;
      } else {
        {
#line 562
        Debug("Unknown _NET_WM_WINDOW_TYPE: %lu", *(state + x));
        }
      }
#line 537
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 565
    if (temp) {
      {
#line 566
      XFree((void *)temp);
      }
    }
  }
  {
#line 571
  tmp___0 = GetCardinalAtom(win, (AtomType )59, & card);
  }
#line 571
  if (tmp___0) {
#line 572
    result.opacity = (unsigned int )card;
  }
#line 575
  return (result);
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void ReadWMName(struct ClientNode *np ) 
{ 
  unsigned long count ;
  int status ;
  unsigned long extra ;
  Atom realType ;
  int realFormat ;
  unsigned char *name ;
  XTextProperty tprop ;
  char **text_list ;
  int tcount ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 596
  if (np->name) {
    {
#line 597
    XFree((void *)np->name);
    }
  }
  {
#line 600
  status = XGetWindowProperty(display, np->window, atoms[46], 0L, 1024L, 0, atoms[1],
                              & realType, & realFormat, & count, & extra, & name);
  }
#line 603
  if (status != 0) {
#line 604
    np->name = (char *)((void *)0);
  } else {
#line 606
    np->name = (char *)name;
  }
#line 610
  if (! np->name) {
    {
#line 611
    status = XGetWindowProperty(display, np->window, (Atom )39, 0L, 1024L, 0, atoms[0],
                                & realType, & realFormat, & count, & extra, & name);
    }
#line 614
    if (status == 0) {
#line 614
      if (realFormat == 8) {
        {
#line 615
        tprop.value = name;
#line 616
        tprop.encoding = atoms[0];
#line 617
        tprop.format = realFormat;
#line 618
        tprop.nitems = strlen((char const   *)((char *)name));
#line 619
        tmp___1 = Xutf8TextPropertyToTextList(display, (XTextProperty const   *)(& tprop),
                                              & text_list, & tcount);
        }
#line 619
        if (tmp___1 == 0) {
#line 619
          if (tcount > 0) {
            {
#line 621
            tmp = strlen((char const   *)*(text_list + 0));
#line 621
            tmp___0 = malloc(tmp + 1UL);
#line 621
            np->name = (char *)tmp___0;
            }
#line 622
            if (np->name) {
              {
#line 623
              strcpy((char */* __restrict  */)np->name, (char const   */* __restrict  */)*(text_list + 0));
              }
            }
            {
#line 625
            XFreeStringList(text_list);
            }
          }
        }
        {
#line 627
        XFree((void *)name);
        }
      }
    }
  }
#line 632
  if (! np->name) {
    {
#line 633
    tmp___2 = XFetchName(display, np->window, & np->name);
    }
#line 633
    if (tmp___2 == 0) {
#line 634
      np->name = (char *)((void *)0);
    }
  }
#line 638
  return;
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void ReadWMClass(struct ClientNode *np ) 
{ 
  XClassHint hint ;
  int tmp ;

  {
  {
#line 647
  tmp = XGetClassHint(display, np->window, & hint);
  }
#line 647
  if (tmp) {
#line 648
    np->instanceName = hint.res_name;
#line 649
    np->className = hint.res_class;
  }
#line 652
  return;
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
ClientProtocolType ReadWMProtocols(Window w ) 
{ 
  ClientProtocolType result ;
  unsigned long count ;
  unsigned long x ;
  int status ;
  unsigned long extra ;
  Atom realType ;
  int realFormat ;
  unsigned char *temp ;
  Atom *p ;

  {
  {
#line 668
  result = (ClientProtocolType )0;
#line 669
  status = XGetWindowProperty(display, w, atoms[4], 0L, 32L, 0, (Atom )4, & realType,
                              & realFormat, & count, & extra, & temp);
#line 671
  p = (Atom *)temp;
  }
#line 673
  if (status != 0) {
#line 674
    return (result);
  } else
#line 673
  if (! p) {
#line 674
    return (result);
  }
#line 677
  x = 0UL;
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if (! (x < count)) {
#line 677
      goto while_break;
    }
#line 678
    if (*(p + x) == atoms[5]) {
#line 679
      result = (ClientProtocolType )((unsigned int )result | 1U);
    } else
#line 680
    if (*(p + x) == atoms[6]) {
#line 681
      result = (ClientProtocolType )((unsigned int )result | 2U);
    }
#line 677
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 685
  XFree((void *)p);
  }
#line 687
  return (result);
}
}
#line 692 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void ReadWMNormalHints(struct ClientNode *np ) 
{ 
  XSizeHints hints ;
  long temp ;
  int tmp ;

  {
  {
#line 699
  tmp = XGetWMNormalHints(display, np->window, & hints, & temp);
  }
#line 699
  if (tmp) {
#line 702
    np->sizeFlags = hints.flags;
  } else {
#line 700
    np->sizeFlags = 0L;
  }
#line 705
  if (np->sizeFlags & (1L << 6)) {
#line 706
    if (1 > hints.width_inc) {
#line 706
      np->xinc = 1;
    } else {
#line 706
      np->xinc = hints.width_inc;
    }
#line 707
    if (1 > hints.height_inc) {
#line 707
      np->yinc = 1;
    } else {
#line 707
      np->yinc = hints.height_inc;
    }
  } else {
#line 709
    np->xinc = 1;
#line 710
    np->yinc = 1;
  }
#line 713
  if (np->sizeFlags & (1L << 4)) {
#line 714
    if (0 > hints.min_width) {
#line 714
      np->minWidth = 0;
    } else {
#line 714
      np->minWidth = hints.min_width;
    }
#line 715
    if (0 > hints.min_height) {
#line 715
      np->minHeight = 0;
    } else {
#line 715
      np->minHeight = hints.min_height;
    }
  } else {
#line 717
    np->minWidth = 1;
#line 718
    np->minHeight = 1;
  }
#line 721
  if (np->sizeFlags & (1L << 5)) {
#line 722
    np->maxWidth = hints.max_width;
#line 723
    np->maxHeight = hints.max_height;
#line 724
    if (np->maxWidth <= 0) {
#line 725
      np->maxWidth = rootWidth;
    }
#line 727
    if (np->maxHeight <= 0) {
#line 728
      np->maxHeight = rootHeight;
    }
  } else {
#line 731
    np->maxWidth = 1 << 15;
#line 732
    np->maxHeight = 1 << 15;
  }
#line 735
  if (np->sizeFlags & (1L << 8)) {
#line 736
    np->baseWidth = hints.base_width;
#line 737
    np->baseHeight = hints.base_height;
  } else
#line 738
  if (np->sizeFlags & (1L << 4)) {
#line 739
    np->baseWidth = np->minWidth;
#line 740
    np->baseHeight = np->minHeight;
  } else {
#line 742
    np->baseWidth = 0;
#line 743
    np->baseHeight = 0;
  }
#line 746
  if (np->sizeFlags & (1L << 7)) {
#line 747
    np->aspect.minx = hints.min_aspect.x;
#line 748
    np->aspect.miny = hints.min_aspect.y;
#line 749
    np->aspect.maxx = hints.max_aspect.x;
#line 750
    np->aspect.maxy = hints.max_aspect.y;
#line 751
    if (np->aspect.minx < 1) {
#line 752
      np->aspect.minx = 1;
    }
#line 754
    if (np->aspect.miny < 1) {
#line 755
      np->aspect.miny = 1;
    }
#line 757
    if (np->aspect.maxx < 1) {
#line 758
      np->aspect.maxx = 1;
    }
#line 760
    if (np->aspect.maxy < 1) {
#line 761
      np->aspect.maxy = 1;
    }
  }
#line 765
  if (np->sizeFlags & (1L << 9)) {
#line 766
    np->gravity = hints.win_gravity;
  } else {
#line 768
    np->gravity = 1;
  }
#line 771
  return;
}
}
#line 774 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void ReadWMColormaps(struct ClientNode *np ) 
{ 
  Window *windows ;
  ColormapNode *cp ;
  int count ;
  int x ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 783
  tmp___0 = XGetWMColormapWindows(display, np->window, & windows, & count);
  }
#line 783
  if (tmp___0) {
#line 784
    if (count > 0) {
      {
#line 787
      while (1) {
        while_continue: /* CIL Label */ ;
#line 787
        if (! np->colormaps) {
#line 787
          goto while_break;
        }
        {
#line 788
        cp = (np->colormaps)->next;
#line 789
        free((void *)np->colormaps);
#line 790
        np->colormaps = cp;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 798
      if (colormapCount > count) {
#line 798
        count = count;
      } else {
#line 798
        count = colormapCount;
      }
#line 799
      x = 0;
      {
#line 799
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 799
        if (! (x < count)) {
#line 799
          goto while_break___0;
        }
        {
#line 800
        tmp = malloc(sizeof(ColormapNode ));
#line 800
        cp = (ColormapNode *)tmp;
#line 801
        cp->window = *(windows + x);
#line 802
        cp->next = np->colormaps;
#line 803
        np->colormaps = cp;
#line 799
        x ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 806
      XFree((void *)windows);
      }
    }
  }
#line 811
  return;
}
}
#line 814 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
static void ReadWMHints(Window win , ClientState *state ) 
{ 
  XWMHints *wmhints ;

  {
  {
#line 821
  wmhints = XGetWMHints(display, win);
  }
#line 822
  if (wmhints) {
#line 823
    if (wmhints->flags & (1L << 1)) {
      {
#line 825
      if (wmhints->initial_state == 3) {
#line 825
        goto case_3;
      }
#line 829
      goto switch_default;
      case_3: /* CIL Label */ 
#line 826
      state->status |= 128U;
#line 827
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 830
      if (! (state->status & 192U)) {
#line 831
        state->status |= 2U;
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 835
      state->status |= 2U;
    }
    {
#line 837
    XFree((void *)wmhints);
    }
  } else {
#line 839
    state->status |= 2U;
  }
#line 842
  return;
}
}
#line 845 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
static void ReadMotifHints(Window win , ClientState *state ) 
{ 
  PropMwmHints *mhints ;
  Atom type ;
  unsigned long itemCount ;
  unsigned long bytesLeft ;
  unsigned char *data ;
  int format ;
  int tmp ;

  {
  {
#line 856
  tmp = XGetWindowProperty(display, win, atoms[60], 0L, 20L, 0, atoms[60], & type,
                           & format, & itemCount, & bytesLeft, & data);
  }
#line 856
  if (tmp != 0) {
#line 859
    return;
  }
#line 862
  mhints = (PropMwmHints *)data;
#line 863
  if (mhints) {
#line 865
    if (mhints->flags & 1UL) {
#line 865
      if (! (mhints->functions & 1UL)) {
#line 868
        if (! (mhints->functions & (unsigned long )(1L << 1))) {
#line 869
          state->border &= 4294967263U;
        }
#line 871
        if (! (mhints->functions & (unsigned long )(1L << 2))) {
#line 872
          state->border &= 4294967231U;
        }
#line 874
        if (! (mhints->functions & (unsigned long )(1L << 3))) {
#line 875
          state->border &= 4294967291U;
        }
#line 877
        if (! (mhints->functions & (unsigned long )(1L << 4))) {
#line 878
          state->border &= 4294967287U;
        }
#line 880
        if (! (mhints->functions & (unsigned long )(1L << 5))) {
#line 881
          state->border &= 4294967279U;
        }
      }
    }
#line 885
    if (mhints->flags & (unsigned long )(1L << 1)) {
#line 885
      if (! (mhints->decorations & 1UL)) {
#line 888
        if (! (mhints->decorations & (unsigned long )(1L << 1))) {
#line 889
          state->border &= 4294967294U;
        }
#line 891
        if (! (mhints->decorations & (unsigned long )(1L << 3))) {
#line 892
          state->border &= 4294967293U;
        }
#line 894
        if (! (mhints->decorations & (unsigned long )(1L << 5))) {
#line 895
          state->border &= 4294967291U;
        }
#line 897
        if (! (mhints->decorations & (unsigned long )(1L << 6))) {
#line 898
          state->border &= 4294967287U;
        }
      }
    }
    {
#line 902
    XFree((void *)mhints);
    }
  }
#line 904
  return;
}
}
#line 907 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
int GetCardinalAtom(Window window , AtomType atom , unsigned long *value ) 
{ 
  unsigned long count ;
  int status ;
  unsigned long extra ;
  Atom realType ;
  int realFormat ;
  unsigned char *data ;
  int ret ;

  {
  {
#line 920
  status = XGetWindowProperty(display, window, atoms[atom], 0L, 1L, 0, (Atom )6, & realType,
                              & realFormat, & count, & extra, & data);
#line 923
  ret = 0;
  }
#line 924
  if (status == 0) {
#line 924
    if (data) {
#line 925
      if (count == 1UL) {
#line 926
        *value = *((unsigned long *)data);
#line 927
        ret = 1;
      }
      {
#line 929
      XFree((void *)data);
      }
    }
  }
#line 932
  return (ret);
}
}
#line 937 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
int GetWindowAtom(Window window , AtomType atom , Window *value ) 
{ 
  unsigned long count ;
  int status ;
  unsigned long extra ;
  Atom realType ;
  int realFormat ;
  unsigned char *data ;
  int ret ;

  {
  {
#line 949
  status = XGetWindowProperty(display, window, atoms[atom], 0L, 1L, 0, (Atom )33,
                              & realType, & realFormat, & count, & extra, & data);
#line 952
  ret = 0;
  }
#line 953
  if (status == 0) {
#line 953
    if (data) {
#line 954
      if (count == 1UL) {
#line 955
        *value = *((Window *)data);
#line 956
        ret = 1;
      }
      {
#line 958
      XFree((void *)data);
      }
    }
  }
#line 961
  return (ret);
}
}
#line 966 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void SetCardinalAtom(Window window , AtomType atom , unsigned long value ) 
{ 


  {
  {
#line 970
  XChangeProperty(display, window, atoms[atom], (Atom )6, 32, 0, (unsigned char const   *)((unsigned char *)(& value)),
                  1);
  }
#line 973
  return;
}
}
#line 976 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void SetWindowAtom(Window window , AtomType atom , unsigned long value ) 
{ 


  {
  {
#line 980
  XChangeProperty(display, window, atoms[atom], (Atom )33, 32, 0, (unsigned char const   *)((unsigned char *)(& value)),
                  1);
  }
#line 983
  return;
}
}
#line 986 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/hint.c"
void SetPixmapAtom(Window window , AtomType atom , Pixmap value ) 
{ 


  {
  {
#line 990
  XChangeProperty(display, window, atoms[atom], (Atom )20, 32, 0, (unsigned char const   *)((unsigned char *)(& value)),
                  1);
  }
#line 993
  return;
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/spacer.c"
static void Create___4(TrayComponentType *cp ) ;
#line 15
static void Destroy___3(TrayComponentType *cp ) ;
#line 16
static void SetSize___3(TrayComponentType *cp , int width , int height ) ;
#line 17
static void Resize___4(TrayComponentType *cp ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/spacer.c"
struct TrayComponentType *CreateSpacer(int width , int height ) 
{ 
  TrayComponentType *cp ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 24
  tmp = __builtin_expect((long )(! (! (width < 0))), 0L);
  }
#line 24
  if (tmp) {
#line 25
    width = 0;
  }
  {
#line 27
  tmp___0 = __builtin_expect((long )(! (! (height < 0))), 0L);
  }
#line 27
  if (tmp___0) {
#line 28
    height = 0;
  }
  {
#line 31
  cp = CreateTrayComponent();
#line 32
  cp->requestedWidth = width;
#line 33
  cp->requestedHeight = height;
#line 35
  cp->Create = & Create___4;
#line 36
  cp->Destroy = & Destroy___3;
#line 37
  cp->SetSize = & SetSize___3;
#line 38
  cp->Resize = & Resize___4;
  }
#line 40
  return (cp);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/spacer.c"
static void SetSize___3(TrayComponentType *cp , int width , int height ) 
{ 


  {
#line 46
  if (width == 0) {
#line 47
    cp->width = cp->requestedWidth;
#line 48
    cp->height = height;
  } else {
#line 50
    cp->width = width;
#line 51
    cp->height = cp->requestedHeight;
  }
#line 53
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/spacer.c"
static void Create___4(TrayComponentType *cp ) 
{ 


  {
#line 57
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/spacer.c"
static void Resize___4(TrayComponentType *cp ) 
{ 


  {
#line 61
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/jwm-2.1.0+svn579/src/spacer.c"
static void Destroy___3(TrayComponentType *cp ) 
{ 


  {
#line 65
  return;
}
}
