/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 11 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.h"
struct Move;
#line 12 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.h"
typedef struct Move *PMove;
#line 14 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.h"
typedef int Player;
#line 22 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.h"
struct Move {
   int hole ;
};
#line 22 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.h"
typedef struct Move Move;
#line 31 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.h"
typedef char StoneCount;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 16 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.h"
typedef int Score;
#line 32 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.h"
struct Board {
   StoneCount hole[2][6] ;
   StoneCount mancala[2] ;
};
#line 32 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.h"
typedef struct Board Board;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 37 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.h"
void initGame(int stones_pr_hole ) ;
#line 38
StoneCount getHole(Player player , int hole ) ;
#line 39
StoneCount getMancala(Player player ) ;
#line 40
int legalMove(Player player , PMove move ) ;
#line 41
int checkAndFixWin(Player *winner ) ;
#line 42
PMove getBestMove(Player player , int maxPly ) ;
#line 43
Player doMove(Player player , PMove move ) ;
#line 35 "/home/wheatley/newnew/temp/mancala-1.0.3/textmain.c"
static void showBoard(void) 
{ 
  int q ;
  StoneCount tmp ;
  char const   *tmp___0 ;
  StoneCount tmp___1 ;
  char const   *tmp___2 ;
  StoneCount tmp___3 ;
  StoneCount tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 39
  printf((char const   */* __restrict  */)"    ");
#line 40
  q = 0;
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (q < 6)) {
#line 40
      goto while_break;
    }
    {
#line 41
    tmp = getHole(1, q);
    }
#line 41
    if (q < 5) {
#line 41
      tmp___0 = "%c:%2d | ";
    } else {
#line 41
      tmp___0 = "%c:%2d\n";
    }
    {
#line 41
    printf((char const   */* __restrict  */)tmp___0, (103 - q) - 1, (int )tmp);
#line 40
    q ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 43
  tmp___1 = getMancala(1);
#line 43
  printf((char const   */* __restrict  */)" %2d ", (int )tmp___1);
#line 44
  q = 0;
  }
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (! (q < 6)) {
#line 44
      goto while_break___0;
    }
#line 45
    if (q < 5) {
#line 45
      tmp___2 = "-----+-";
    } else {
#line 45
      tmp___2 = "----";
    }
    {
#line 45
    printf((char const   */* __restrict  */)tmp___2);
#line 44
    q ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 46
  tmp___3 = getMancala(0);
#line 46
  printf((char const   */* __restrict  */)" %2d\n", (int )tmp___3);
#line 47
  printf((char const   */* __restrict  */)"    ");
#line 48
  q = 0;
  }
  {
#line 48
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 48
    if (! (q < 6)) {
#line 48
      goto while_break___1;
    }
    {
#line 49
    tmp___4 = getHole(0, (6 - q) - 1);
    }
#line 49
    if (q < 5) {
#line 49
      tmp___5 = "%c:%2d | ";
    } else {
#line 49
      tmp___5 = "%c:%2d\n";
    }
    {
#line 49
    printf((char const   */* __restrict  */)tmp___5, 97 + q, (int )tmp___4);
#line 48
    q ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 51
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/mancala-1.0.3/textmain.c"
int main(int argc , char **argv ) 
{ 
  char s[80] ;
  char playerName[2][20] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int maxPly[2] ;
  int status ;
  int stones_pr_hole ;
  PMove move ;
  Move move2 ;
  Player player ;
  Player winner ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 64
  playerName[0][0] = (char )'p';
#line 64
  playerName[0][1] = (char )'l';
#line 64
  playerName[0][2] = (char )'a';
#line 64
  playerName[0][3] = (char )'y';
#line 64
  playerName[0][4] = (char )'e';
#line 64
  playerName[0][5] = (char )'r';
#line 64
  playerName[0][6] = (char )' ';
#line 64
  playerName[0][7] = (char )'a';
#line 64
  playerName[0][8] = (char )'t';
#line 64
  playerName[0][9] = (char )' ';
#line 64
  playerName[0][10] = (char )'b';
#line 64
  playerName[0][11] = (char )'o';
#line 64
  playerName[0][12] = (char )'t';
#line 64
  playerName[0][13] = (char )'t';
#line 64
  playerName[0][14] = (char )'o';
#line 64
  playerName[0][15] = (char )'m';
#line 64
  playerName[0][16] = (char )'\000';
#line 64
  tmp = 17U;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (tmp >= 20U) {
#line 64
      goto while_break;
    }
#line 64
    playerName[0][tmp] = (char)0;
#line 64
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  playerName[1][0] = (char )'p';
#line 64
  playerName[1][1] = (char )'l';
#line 64
  playerName[1][2] = (char )'a';
#line 64
  playerName[1][3] = (char )'y';
#line 64
  playerName[1][4] = (char )'e';
#line 64
  playerName[1][5] = (char )'r';
#line 64
  playerName[1][6] = (char )' ';
#line 64
  playerName[1][7] = (char )'a';
#line 64
  playerName[1][8] = (char )'t';
#line 64
  playerName[1][9] = (char )' ';
#line 64
  playerName[1][10] = (char )'t';
#line 64
  playerName[1][11] = (char )'o';
#line 64
  playerName[1][12] = (char )'p';
#line 64
  playerName[1][13] = (char )'\000';
#line 64
  tmp___0 = 14U;
  {
#line 64
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 64
    if (tmp___0 >= 20U) {
#line 64
      goto while_break___0;
    }
#line 64
    playerName[1][tmp___0] = (char)0;
#line 64
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 65
  maxPly[0] = 20;
#line 65
  maxPly[1] = 20;
#line 66
  stones_pr_hole = 4;
#line 71
  if (argc == 2) {
    {
#line 72
    maxPly[1] = atoi((char const   *)*(argv + 1));
#line 72
    maxPly[0] = maxPly[1];
    }
  } else
#line 73
  if (argc == 3) {
    {
#line 74
    maxPly[1] = atoi((char const   *)*(argv + 1));
#line 75
    maxPly[0] = atoi((char const   *)*(argv + 2));
    }
  } else
#line 76
  if (argc == 4) {
    {
#line 77
    maxPly[1] = atoi((char const   *)*(argv + 1));
#line 78
    maxPly[0] = atoi((char const   *)*(argv + 2));
#line 79
    stones_pr_hole = atoi((char const   *)*(argv + 3));
    }
  } else {
    {
#line 81
    printf((char const   */* __restrict  */)"usage: mancala max-ply\n       mancala max-ply-top max-ply-bottom\n       mancala max-ply-top max-ply-bottom number-of-stones\n\nmax-ply of 0 indicates human user.\nPlayer at top starts.\n\n");
    }
#line 88
    return (1);
  }
#line 90
  if (stones_pr_hole < 1) {
    {
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mancala: the number of stones per hole must be greater than zero\n");
    }
#line 94
    return (1);
  }
#line 96
  if (maxPly[0] < 0) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mancala: max-ply must be no less than zero\n");
    }
#line 99
    return (1);
  } else
#line 96
  if (maxPly[1] < 0) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mancala: max-ply must be no less than zero\n");
    }
#line 99
    return (1);
  }
  {
#line 101
  initGame(stones_pr_hole);
#line 102
  player = 1;
  }
  {
#line 103
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 104
    showBoard();
#line 105
    printf((char const   */* __restrict  */)"\n");
#line 106
    status = checkAndFixWin(& winner);
    }
#line 106
    if (status != 0) {
      {
#line 107
      printf((char const   */* __restrict  */)"=== Game over; ");
      }
#line 108
      if (status == 1) {
        {
#line 109
        printf((char const   */* __restrict  */)"%s wins", playerName[winner]);
        }
      } else {
        {
#line 111
        printf((char const   */* __restrict  */)"we have a draw");
        }
      }
      {
#line 112
      printf((char const   */* __restrict  */)" ===\n\n");
#line 113
      showBoard();
#line 114
      printf((char const   */* __restrict  */)"\n");
      }
#line 115
      return (0);
    }
    {
#line 117
    printf((char const   */* __restrict  */)"Move for %s: ", playerName[player]);
    }
#line 118
    if (! maxPly[player]) {
#line 119
      move = & move2;
      {
#line 120
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 121
        tmp___1 = fgets((char */* __restrict  */)(s), 80, (FILE */* __restrict  */)stdin);
        }
#line 121
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
          {
#line 122
          printf((char const   */* __restrict  */)"\nBye.\n");
          }
#line 123
          return (0);
        }
        {
#line 125
        tmp___2 = toupper((int )s[0]);
#line 125
        move->hole = 70 - tmp___2;
#line 126
        tmp___3 = legalMove(player, move);
        }
#line 126
        if (tmp___3) {
#line 127
          goto while_break___2;
        }
        {
#line 128
        printf((char const   */* __restrict  */)"not a legal move. try again: ");
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 130
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 132
      move = getBestMove(player, maxPly[player]);
#line 133
      printf((char const   */* __restrict  */)"%c\n\n", 70 - move->hole);
      }
    }
    {
#line 135
    player = doMove(player, move);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 137
  return (0);
}
}
#line 376 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 19 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.h"
PMove miniMax(void (*fncPushBoard)(void) , void (*fncPopBoard)(void) , PMove *(*fncGetMoves)(Player  ,
                                                                                             int * ) ,
              Player (*fncDoMove)(Player  , PMove  ) , void (*fncUndoMove)(Player  ,
                                                                           PMove  ) ,
              Score (*fncEvalBoard)(Player  ) , Player player , int maxPly ) ;
#line 38 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
static Board boardStack[21]  ;
#line 39 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
static int idx  =    0;
#line 48 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
static Move possibleMoveTable[21][6]  ;
#line 49 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
static PMove possibleMove[21][6]  ;
#line 74 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
static void pushBoard(void) 
{ 


  {
  {
#line 76
  idx ++;
#line 77
  memcpy((void */* __restrict  */)(& boardStack[idx]), (void const   */* __restrict  */)(& boardStack[idx - 1]),
         sizeof(Board ));
  }
#line 78
  return;
}
}
#line 93 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
static void popBoard(void) 
{ 


  {
#line 95
  idx --;
#line 96
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
static PMove *getMoves(Player player , int *numMoves ) 
{ 
  int q ;
  int n ;
  StoneCount *hole ;
  PMove *m ;
  PMove *ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 126
  n = 0;
#line 130
  ret = possibleMove[idx];
#line 130
  m = ret;
#line 131
  hole = boardStack[idx].hole[player];
#line 132
  q = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (q < 6)) {
#line 132
      goto while_break;
    }
#line 133
    if (*hole) {
#line 134
      tmp = n;
#line 134
      n ++;
#line 134
      (*(m + tmp))->hole = q;
    }
#line 135
    hole ++;
#line 132
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  tmp___0 = n;
#line 137
  *numMoves = tmp___0;
#line 137
  if (tmp___0 == 0) {
#line 138
    ret = (PMove *)((void *)0);
  }
#line 139
  return (ret);
}
}
#line 157 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
static void undoMove(Player player , PMove move ) 
{ 


  {
#line 160
  return;
}
}
#line 180 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
static Score evalBoard(Player player ) 
{ 
  Board *b ;
  Player winner ;

  {
  {
#line 191
  checkAndFixWin(& winner);
#line 193
  b = & boardStack[idx];
  }
#line 194
  return ((int )b->mancala[player] - (int )b->mancala[player ^ 1]);
}
}
#line 211 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
void initGame(int stones_pr_hole ) 
{ 
  int q ;
  int w ;
  Board *b ;
  Player player ;
  time_t tmp ;

  {
  {
#line 221
  tmp = time((time_t *)((void *)0));
#line 221
  srand((unsigned int )tmp);
#line 228
  q = 0;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (q < 21)) {
#line 228
      goto while_break;
    }
#line 229
    w = 0;
    {
#line 229
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 229
      if (! (w < 6)) {
#line 229
        goto while_break___0;
      }
#line 230
      possibleMove[q][w] = & possibleMoveTable[q][w];
#line 229
      w ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 228
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  idx = 0;
#line 237
  b = & boardStack[idx];
#line 238
  player = 0;
  {
#line 238
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 238
    if (! (player < 2)) {
#line 238
      goto while_break___1;
    }
#line 239
    b->mancala[player] = (StoneCount )0;
#line 240
    w = 0;
    {
#line 240
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 240
      if (! (w < 6)) {
#line 240
        goto while_break___2;
      }
#line 241
      b->hole[player][w] = (StoneCount )stones_pr_hole;
#line 240
      w ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 238
    player ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 243
  return;
}
}
#line 259 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
StoneCount getHole(Player player , int hole ) 
{ 


  {
#line 261
  return (boardStack[0].hole[player][hole]);
}
}
#line 276 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
StoneCount getMancala(Player player ) 
{ 


  {
#line 278
  return (boardStack[0].mancala[player]);
}
}
#line 299 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
int legalMove(Player player , PMove move ) 
{ 
  int q ;
  PMove *legalmove ;
  int numMoves ;

  {
  {
#line 305
  legalmove = getMoves(player, & numMoves);
#line 306
  q = 0;
  }
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (q < numMoves)) {
#line 306
      goto while_break;
    }
#line 307
    if ((*legalmove)->hole == move->hole) {
#line 308
      return (1);
    }
#line 309
    legalmove ++;
#line 306
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return (0);
}
}
#line 331 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
int checkAndFixWin(Player *winner ) 
{ 
  int q ;
  int ret ;
  int sum[2] ;
  Board *b ;
  StoneCount *hole ;
  Player player ;

  {
#line 333
  ret = 0;
#line 338
  b = & boardStack[idx];
#line 339
  player = 0;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! (player < 2)) {
#line 339
      goto while_break;
    }
#line 340
    hole = b->hole[player];
#line 341
    sum[player] = 0;
#line 342
    q = 0;
    {
#line 342
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 342
      if (! (q < 6)) {
#line 342
        goto while_break___0;
      }
#line 343
      sum[player] += (int )*(hole + q);
#line 342
      q ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 339
    player ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  if (sum[0] == 0) {
#line 345
    goto _L;
  } else
#line 345
  if (sum[1] == 0) {
    _L: /* CIL Label */ 
#line 346
    ret = 1;
#line 347
    player = 0;
    {
#line 347
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 347
      if (! (player < 2)) {
#line 347
        goto while_break___1;
      }
#line 348
      b->mancala[player] = (StoneCount )((int )b->mancala[player] + sum[player]);
#line 349
      hole = b->hole[player];
#line 350
      q = 0;
      {
#line 350
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 350
        if (! (q < 6)) {
#line 350
          goto while_break___2;
        }
#line 351
        *(hole + q) = (StoneCount )0;
#line 350
        q ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 347
      player ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 353
    if ((int )b->mancala[0] > (int )b->mancala[1]) {
#line 354
      *winner = 0;
    } else
#line 355
    if ((int )b->mancala[0] < (int )b->mancala[1]) {
#line 356
      *winner = 1;
    } else {
#line 358
      ret = 2;
    }
  }
#line 360
  return (ret);
}
}
#line 380 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
PMove getBestMove(Player player , int maxPly ) 
{ 
  PMove tmp ;

  {
  {
#line 382
  tmp = miniMax(& pushBoard, & popBoard, & getMoves, & doMove, & undoMove, & evalBoard,
                player, maxPly);
  }
#line 382
  return (tmp);
}
}
#line 409 "/home/wheatley/newnew/temp/mancala-1.0.3/mancala.c"
Player doMove(Player player , PMove move ) 
{ 
  int seeds ;
  int holeNum ;
  int oppositeHoleNum ;
  StoneCount *hole ;
  StoneCount *oppositeHole ;
  Board *b ;
  Player nextPlayer ;
  Player holeOwner ;

  {
#line 416
  nextPlayer = player ^ 1;
#line 417
  b = & boardStack[idx];
#line 418
  holeOwner = player;
#line 419
  hole = b->hole[holeOwner];
#line 420
  holeNum = move->hole;
#line 421
  seeds = (int )*(hole + holeNum);
#line 422
  *(hole + holeNum) = (StoneCount )0;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 424
    holeNum --;
#line 424
    if (holeNum < 0) {
#line 425
      if (holeOwner == player) {
#line 426
        b->mancala[player] = (StoneCount )((int )b->mancala[player] + 1);
#line 427
        seeds --;
#line 427
        if (! seeds) {
#line 428
          nextPlayer = player;
#line 429
          goto while_break;
        }
      }
#line 432
      holeOwner ^= 1;
#line 433
      hole = b->hole[holeOwner];
#line 434
      holeNum = 5;
    }
#line 436
    *(hole + holeNum) = (StoneCount )((int )*(hole + holeNum) + 1);
#line 437
    seeds --;
#line 437
    if (! seeds) {
#line 438
      if (holeOwner == player) {
#line 439
        oppositeHoleNum = 5 - holeNum;
#line 440
        oppositeHole = b->hole[player ^ 1];
#line 441
        if ((int )*(hole + holeNum) == 1) {
#line 441
          if (*(oppositeHole + oppositeHoleNum)) {
#line 442
            b->mancala[player] = (StoneCount )((int )b->mancala[player] + (1 + (int )*(oppositeHole + oppositeHoleNum)));
#line 443
            *(oppositeHole + oppositeHoleNum) = (StoneCount )0;
#line 444
            *(hole + holeNum) = (StoneCount )0;
          }
        }
      }
#line 447
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  return (nextPlayer);
}
}
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 34 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.c"
static void (*pushBoard___0)(void)  ;
#line 35 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.c"
static void (*popBoard___0)(void)  ;
#line 36 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.c"
static PMove *(*getMoves___0)(Player  , int * )  ;
#line 37 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.c"
static Player (*doMove___0)(Player  , PMove  )  ;
#line 38 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.c"
static void (*undoMove___0)(Player  , PMove  )  ;
#line 39 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.c"
static Score (*evalBoard___0)(Player  )  ;
#line 67 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.c"
static Score recMiniMax(Player player , PMove move , int depth ) 
{ 
  int q ;
  PMove *newmove ;
  int numMoves ;
  Player nextPlayer ;
  Score ret ;
  Score tmp ;

  {
  {
#line 76
  (*pushBoard___0)();
#line 77
  nextPlayer = (*doMove___0)(player, move);
  }
#line 78
  if (! depth) {
    {
#line 83
    ret = (*evalBoard___0)(player);
    }
#line 84
    goto finish;
  }
  {
#line 87
  newmove = (*getMoves___0)(nextPlayer, & numMoves);
  }
#line 88
  if (! numMoves) {
    {
#line 92
    ret = (*evalBoard___0)(player);
    }
#line 93
    goto finish;
  }
#line 100
  ret = -2147483647;
#line 101
  q = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (q < numMoves)) {
#line 101
      goto while_break;
    }
    {
#line 102
    tmp = recMiniMax(nextPlayer, *newmove, depth - 1);
    }
#line 103
    if (tmp > ret) {
#line 104
      ret = tmp;
    }
#line 105
    newmove ++;
#line 101
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if (player != nextPlayer) {
#line 108
    ret = - ret;
  }
  finish: 
  {
#line 110
  (*undoMove___0)(player, move);
#line 111
  (*popBoard___0)();
  }
#line 112
  return (ret);
}
}
#line 191 "/home/wheatley/newnew/temp/mancala-1.0.3/minimax.c"
PMove miniMax(void (*fncPushBoard)(void) , void (*fncPopBoard)(void) , PMove *(*fncGetMoves)(Player  ,
                                                                                             int * ) ,
              Player (*fncDoMove)(Player  , PMove  ) , void (*fncUndoMove)(Player  ,
                                                                           PMove  ) ,
              Score (*fncEvalBoard)(Player  ) , Player player , int maxPly ) 
{ 
  int q ;
  PMove *move ;
  int numMoves ;
  PMove bestMove ;
  Score v ;
  Score bestValue ;
  int tmp ;

  {
  {
#line 212
  pushBoard___0 = fncPushBoard;
#line 213
  popBoard___0 = fncPopBoard;
#line 214
  getMoves___0 = fncGetMoves;
#line 215
  doMove___0 = fncDoMove;
#line 216
  undoMove___0 = fncUndoMove;
#line 217
  evalBoard___0 = fncEvalBoard;
#line 225
  bestMove = (PMove )((void *)0);
#line 226
  move = (*getMoves___0)(player, & numMoves);
#line 227
  bestValue = -2147483647;
#line 228
  q = 0;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (q < numMoves)) {
#line 228
      goto while_break;
    }
    {
#line 229
    v = recMiniMax(player, *move, maxPly - 1);
    }
#line 235
    if (v > bestValue) {
#line 239
      bestValue = v;
#line 240
      bestMove = *move;
    } else
#line 235
    if (v == bestValue) {
      {
#line 235
      tmp = rand();
      }
#line 235
      if (tmp & 1) {
#line 239
        bestValue = v;
#line 240
        bestMove = *move;
      }
    }
#line 242
    move ++;
#line 228
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return (bestMove);
}
}
