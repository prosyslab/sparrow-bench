/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 3 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.h"
struct zip_info {
   int offset ;
   int skipping ;
   unsigned int skipcount ;
   unsigned int namelen ;
   char filename[512] ;
};
#line 134 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.h"
struct namespec {
   char name[512] ;
   char oldname[512] ;
   int specformat ;
   int langinfo ;
   char charenc[512] ;
   char charmode ;
};
#line 145 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.h"
struct attach {
   int fattach ;
   int within ;
   char content_type[512] ;
   char content_enc[512] ;
   char content_id[512] ;
   struct namespec *curspec ;
   struct namespec ct_fname ;
   struct namespec cd_fname ;
};
#line 158 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.h"
struct config_opts {
   char *config_file ;
   char **pipe_cmd ;
   int mode ;
   int def_act ;
   int action ;
   int delete_exe ;
   int kill_exe ;
   int search_zip ;
   int pass_contentid ;
   int full_rename ;
   int use_syslog ;
   char generic_name[512] ;
   char new_extension[512] ;
   char new_mime_type[512] ;
   char subj_banned[512] ;
   char subj_exec[512] ;
   char subj_deleted[512] ;
   char subj_renamed[512] ;
   char add_subject[512] ;
   char htmlwarn_pos[512] ;
   char *warning_text ;
   char *warning_html ;
   char *add_header ;
   char *banned_files ;
   char *goodlist ;
   char *badlist ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 1533 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 1531 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.h"
void trim_leading(char *buf ) ;
#line 13
void trim_trailing(char *buf ) ;
#line 14
void trim_trailch(char *buf , char ch1 , char ch2 , char ch3 ) ;
#line 15
void expand_list(char **buffer , char const   *addition , char const   *delim ) ;
#line 16
char *stristr(char const   *haystack , char const   *needle ) ;
#line 17
unsigned char hex2int(char *hexform ) ;
#line 18
void decode_hex(char *text , char hexflag , int underscore , char *optdest ) ;
#line 19
int base64_decode_line(char const   *input , char *dest ) ;
#line 20
void base64_encode_line(char const   *input , int insize , char *output ) ;
#line 21
void init_zip(struct zip_info *zip ) ;
#line 22
char *unzip_filename(char *databuf , int databuf_len , struct zip_info *zip ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
static char const   alphabet[65]  = 
#line 29 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
void trim_leading(char *buf ) 
{ 
  int i ;
  int len ;
  size_t tmp ;
  char *tmpbuf ;
  void *tmp___0 ;

  {
  {
#line 37
  tmp = strlen((char const   *)buf);
#line 37
  len = (int )tmp;
#line 38
  tmp___0 = calloc((size_t )(len + 1), (size_t )1);
#line 38
  tmpbuf = (char *)tmp___0;
#line 39
  i = 0;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! (i < len)) {
#line 39
      goto while_break;
    }
#line 41
    if ((int )*(buf + i) != 32) {
#line 41
      if ((int )*(buf + i) != 9) {
#line 42
        goto while_break;
      }
    }
#line 39
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  strcpy((char */* __restrict  */)tmpbuf, (char const   */* __restrict  */)(buf + i));
#line 45
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)tmpbuf);
#line 46
  free((void *)tmpbuf);
  }
#line 47
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
void trim_trailing(char *buf ) 
{ 
  char *end ;
  size_t tmp ;

  {
  {
#line 55
  tmp = strlen((char const   *)buf);
#line 55
  end = (buf + tmp) - 1;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if ((unsigned long )end >= (unsigned long )buf) {
#line 56
      if (! ((int )*end == 32)) {
#line 56
        if (! ((int )*end == 9)) {
#line 56
          goto while_break;
        }
      }
    } else {
#line 56
      goto while_break;
    }
#line 58
    *end = (char)0;
#line 59
    end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
void trim_trailch(char *buf , char ch1 , char ch2 , char ch3 ) 
{ 
  char *end ;
  size_t tmp ;

  {
  {
#line 69
  tmp = strlen((char const   *)buf);
#line 69
  end = (buf + tmp) - 1;
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if ((unsigned long )end >= (unsigned long )buf) {
#line 70
      if (! ((int )*end == (int )ch1)) {
#line 70
        if (! ((int )*end == (int )ch2)) {
#line 70
          if (! ((int )*end == (int )ch3)) {
#line 70
            goto while_break;
          }
        }
      }
    } else {
#line 70
      goto while_break;
    }
#line 72
    *end = (char)0;
#line 73
    end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
void expand_list(char **buffer , char const   *addition , char const   *delim ) 
{ 
  char *newbuf ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 85
  if (*buffer) {
    {
#line 87
    tmp = strlen((char const   *)*buffer);
#line 87
    tmp___0 = strlen(delim);
#line 87
    tmp___1 = strlen(addition);
#line 87
    tmp___2 = malloc(((tmp + tmp___0) + tmp___1) + 1UL);
#line 87
    newbuf = (char *)tmp___2;
#line 88
    strcpy((char */* __restrict  */)newbuf, (char const   */* __restrict  */)*buffer);
#line 89
    strcat((char */* __restrict  */)newbuf, (char const   */* __restrict  */)delim);
    }
  } else {
    {
#line 92
    tmp___3 = strlen(addition);
#line 92
    tmp___4 = calloc(tmp___3 + 1UL, (size_t )1);
#line 92
    newbuf = (char *)tmp___4;
    }
  }
  {
#line 93
  strcat((char */* __restrict  */)newbuf, (char const   */* __restrict  */)addition);
  }
#line 94
  if (*buffer) {
    {
#line 95
    free((void *)*buffer);
    }
  }
#line 96
  *buffer = newbuf;
#line 97
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
char *stristr(char const   *haystack , char const   *needle ) 
{ 
  char const   *needlepoint ;
  char const   *matchpoint ;
  int tmp ;
  int tmp___0 ;

  {
#line 107
  needlepoint = needle;
#line 108
  matchpoint = (char const   *)((void *)0);
#line 110
  if (! haystack) {
#line 111
    return ((char *)((void *)0));
  } else
#line 110
  if (! needle) {
#line 111
    return ((char *)((void *)0));
  } else
#line 112
  if ((int const   )*needle == 0) {
#line 113
    return ((char *)haystack);
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! ((int const   )*haystack != 0)) {
#line 115
      goto while_break;
    }
    {
#line 117
    tmp = tolower((int )*needlepoint);
#line 117
    tmp___0 = tolower((int )*haystack);
    }
#line 117
    if (tmp == tmp___0) {
#line 119
      if (! matchpoint) {
#line 120
        matchpoint = haystack;
      }
#line 121
      needlepoint ++;
#line 122
      if ((int const   )*needlepoint == 0) {
#line 123
        return ((char *)matchpoint);
      }
    } else
#line 125
    if (matchpoint) {
#line 127
      needlepoint = needle;
#line 128
      haystack = matchpoint;
#line 129
      matchpoint = (char const   *)((void *)0);
    }
#line 131
    haystack ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return ((char *)((void *)0));
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
unsigned char hex2int(char *hexform ) 
{ 
  int pos ;
  unsigned char value ;
  unsigned char nibble ;

  {
#line 143
  value = (unsigned char)0;
#line 145
  pos = 0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (pos <= 1)) {
#line 145
      goto while_break;
    }
#line 147
    nibble = (unsigned char )*(hexform + pos);
#line 148
    if ((int )nibble >= 48) {
#line 148
      if ((int )nibble <= 57) {
#line 149
        nibble = (unsigned char )((int )nibble - 48);
      } else {
#line 148
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 150
    if ((int )nibble >= 97) {
#line 150
      if ((int )nibble <= 102) {
#line 151
        nibble = (unsigned char )((int )nibble - 87);
      } else {
#line 150
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 152
    if ((int )nibble >= 65) {
#line 152
      if ((int )nibble <= 70) {
#line 153
        nibble = (unsigned char )((int )nibble - 55);
      } else {
#line 155
        return (value);
      }
    } else {
#line 155
      return (value);
    }
#line 156
    value = (unsigned char )(((int )value << 4) | (int )nibble);
#line 145
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (value);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
void decode_hex(char *text , char hexflag , int underscore , char *optdest ) 
{ 
  int pos ;
  int inlen ;
  size_t tmp ;
  char *tmpbuf ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned char tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 173
  tmp = strlen((char const   *)text);
#line 173
  inlen = (int )tmp;
#line 174
  tmp___0 = calloc((size_t )(inlen + 1), (size_t )1);
#line 174
  tmpbuf = (char *)tmp___0;
#line 175
  pos = 0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (pos < inlen)) {
#line 175
      goto while_break;
    }
#line 177
    if (underscore) {
#line 177
      if ((int )*(text + pos) == 95) {
        {
#line 178
        strcat((char */* __restrict  */)tmpbuf, (char const   */* __restrict  */)" ");
        }
      } else {
#line 177
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 179
    if ((int )*(text + pos) == (int )hexflag) {
#line 179
      if (pos + 2 < inlen) {
        {
#line 181
        pos ++;
#line 182
        tmp___4 = __ctype_b_loc();
        }
#line 182
        if ((int const   )*(*tmp___4 + (int )*(text + pos)) & 4096) {
          {
#line 182
          tmp___5 = __ctype_b_loc();
          }
#line 182
          if ((int const   )*(*tmp___5 + (int )*(text + (pos + 1))) & 4096) {
            {
#line 183
            tmp___1 = pos;
#line 183
            pos ++;
#line 183
            tmp___2 = hex2int(text + tmp___1);
#line 183
            tmp___3 = strlen((char const   *)tmpbuf);
#line 183
            sprintf((char */* __restrict  */)(tmpbuf + tmp___3), (char const   */* __restrict  */)"%c",
                    (int )tmp___2);
            }
          }
        }
      } else {
        {
#line 186
        tmp___6 = strlen((char const   *)tmpbuf);
#line 186
        sprintf((char */* __restrict  */)(tmpbuf + tmp___6), (char const   */* __restrict  */)"%c",
                (int )*(text + pos));
        }
      }
    } else {
      {
#line 186
      tmp___6 = strlen((char const   *)tmpbuf);
#line 186
      sprintf((char */* __restrict  */)(tmpbuf + tmp___6), (char const   */* __restrict  */)"%c",
              (int )*(text + pos));
      }
    }
#line 175
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (optdest) {
    {
#line 189
    strcpy((char */* __restrict  */)optdest, (char const   */* __restrict  */)tmpbuf);
    }
  } else {
    {
#line 191
    strcpy((char */* __restrict  */)text, (char const   */* __restrict  */)tmpbuf);
    }
  }
  {
#line 192
  free((void *)tmpbuf);
  }
#line 193
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
int base64_decode_line(char const   *input , char *dest ) 
{ 
  char outbytes[3] ;
  int len ;
  size_t tmp ;
  char const   *endpoint ;
  int outpos ;
  int i ;
  int j ;
  int towrite ;
  char *lookup1 ;
  char *tmp___0 ;
  char *lookup2 ;
  char *tmp___1 ;

  {
  {
#line 204
  tmp = strlen(input);
#line 204
  len = (int )tmp;
#line 205
  endpoint = input + len;
#line 206
  outpos = 0;
  }
#line 208
  if (len % 4 != 0) {
#line 209
    return (0);
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! ((unsigned long )input < (unsigned long )endpoint)) {
#line 210
      goto while_break;
    }
#line 212
    towrite = 3;
#line 213
    i = 2;
    {
#line 213
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 213
      if (! (i < 4)) {
#line 213
        goto while_break___0;
      }
#line 214
      if ((int const   )*(input + i) == 61) {
#line 214
        towrite --;
      }
#line 213
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 215
    j = 0;
    {
#line 215
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 215
      if (! (j < towrite)) {
#line 215
        goto while_break___1;
      }
      {
#line 217
      tmp___0 = strchr(alphabet, (int )*(input + j));
#line 217
      lookup1 = tmp___0;
#line 218
      tmp___1 = strchr(alphabet, (int )*(input + (j + 1)));
#line 218
      lookup2 = tmp___1;
      }
#line 219
      if (! lookup1) {
#line 220
        return (0);
      } else
#line 219
      if (! lookup2) {
#line 220
        return (0);
      }
#line 221
      outbytes[j] = (char )(((lookup1 - (char *)(alphabet)) << (2 + j * 2)) | ((lookup2 - (char *)(alphabet)) >> (4 - 2 * j)));
#line 215
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 223
    memcpy((void */* __restrict  */)(dest + outpos), (void const   */* __restrict  */)(outbytes),
           (size_t )towrite);
#line 224
    outpos += towrite;
#line 225
    input += 4;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  return (outpos);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
void base64_encode_line(char const   *input , int insize , char *output ) 
{ 
  int i ;
  unsigned char inthree[3] ;
  unsigned char outfour[4] ;

  {
#line 241
  i = 0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! (i < insize / 3)) {
#line 241
      goto while_break;
    }
    {
#line 243
    memcpy((void */* __restrict  */)(inthree), (void const   */* __restrict  */)(input + 3 * i),
           (size_t )3);
#line 244
    outfour[0] = (unsigned char )((int )inthree[0] >> 2);
#line 245
    outfour[1] = (unsigned char )((((int )inthree[0] << 4) & 48) | ((int )inthree[1] >> 4));
#line 246
    outfour[2] = (unsigned char )((((int )inthree[1] << 2) & 63) | ((int )inthree[2] >> 6));
#line 247
    outfour[3] = (unsigned char )((int )inthree[2] & 63);
#line 248
    outfour[0] = (unsigned char )alphabet[outfour[0]];
#line 249
    outfour[1] = (unsigned char )alphabet[outfour[1]];
#line 250
    outfour[2] = (unsigned char )alphabet[outfour[2]];
#line 251
    outfour[3] = (unsigned char )alphabet[outfour[3]];
#line 252
    memcpy((void */* __restrict  */)(output + 4 * i), (void const   */* __restrict  */)(outfour),
           (size_t )4);
#line 241
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  if (insize % 3 == 1) {
    {
#line 256
    memcpy((void */* __restrict  */)(inthree), (void const   */* __restrict  */)(input + 3 * i),
           (size_t )1);
#line 257
    outfour[0] = (unsigned char )((int )inthree[0] >> 2);
#line 258
    outfour[1] = (unsigned char )(((int )inthree[0] << 4) & 48);
#line 259
    outfour[0] = (unsigned char )alphabet[outfour[0]];
#line 260
    outfour[1] = (unsigned char )alphabet[outfour[1]];
#line 261
    outfour[2] = (unsigned char )'=';
#line 262
    outfour[3] = (unsigned char )'=';
#line 263
    memcpy((void */* __restrict  */)(output + 4 * i), (void const   */* __restrict  */)(outfour),
           (size_t )4);
#line 264
    i ++;
    }
  } else
#line 266
  if (insize % 3 == 2) {
    {
#line 268
    memcpy((void */* __restrict  */)(inthree), (void const   */* __restrict  */)(input + 3 * i),
           (size_t )2);
#line 269
    outfour[0] = (unsigned char )((int )inthree[0] >> 2);
#line 270
    outfour[1] = (unsigned char )((((int )inthree[0] << 4) & 48) | ((int )inthree[1] >> 4));
#line 271
    outfour[2] = (unsigned char )(((int )inthree[1] << 2) & 63);
#line 272
    outfour[0] = (unsigned char )alphabet[outfour[0]];
#line 273
    outfour[1] = (unsigned char )alphabet[outfour[1]];
#line 274
    outfour[2] = (unsigned char )alphabet[outfour[2]];
#line 275
    outfour[3] = (unsigned char )'=';
#line 276
    memcpy((void */* __restrict  */)(output + 4 * i), (void const   */* __restrict  */)(outfour),
           (size_t )4);
#line 277
    i ++;
    }
  }
  {
#line 279
  memcpy((void */* __restrict  */)(output + 4 * i), (void const   */* __restrict  */)"\000",
         (size_t )1);
  }
#line 280
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
void init_zip(struct zip_info *zip ) 
{ 


  {
  {
#line 288
  memset((void *)zip, 0, sizeof(struct zip_info ));
#line 289
  zip->offset = -1;
  }
#line 290
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/utility.c"
char *unzip_filename(char *databuf , int databuf_len , struct zip_info *zip ) 
{ 
  char *databuf_pos ;
  char *databuf_end ;
  void *id0 ;
  void *tmp ;
  char needid ;

  {
#line 309
  if (! databuf) {
#line 310
    return ((char *)((void *)0));
  } else
#line 309
  if (! zip) {
#line 310
    return ((char *)((void *)0));
  }
#line 311
  if (databuf_len < 1) {
#line 312
    return ((char *)((void *)0));
  }
#line 314
  databuf_pos = databuf;
#line 315
  databuf_end = databuf + databuf_len;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! ((unsigned long )databuf_pos < (unsigned long )databuf_end)) {
#line 317
      goto while_break;
    }
#line 320
    if (zip->skipping) {
#line 322
      if (zip->skipcount == 0U) {
        {
#line 323
        init_zip(zip);
        }
      } else {
#line 326
        databuf_pos ++;
#line 327
        (zip->skipcount) --;
      }
#line 329
      goto while_continue;
    }
#line 332
    if (zip->offset < 0) {
      {
#line 334
      tmp = memchr((void const   *)databuf_pos, 80, (size_t )(databuf_end - databuf_pos));
#line 334
      id0 = tmp;
      }
#line 335
      if (id0) {
#line 337
        zip->offset = 0;
#line 338
        databuf_pos = (char *)id0 + 1;
#line 339
        goto while_continue;
      } else {
#line 342
        return ((char *)((void *)0));
      }
    }
#line 345
    if (zip->offset < 3) {
#line 347
      needid = (char)0;
      {
#line 350
      if (zip->offset == 0) {
#line 350
        goto case_0;
      }
#line 353
      if (zip->offset == 1) {
#line 353
        goto case_1;
      }
#line 356
      if (zip->offset == 2) {
#line 356
        goto case_2;
      }
#line 348
      goto switch_break;
      case_0: /* CIL Label */ 
#line 351
      needid = (char)75;
#line 352
      goto switch_break;
      case_1: /* CIL Label */ 
#line 354
      needid = (char)3;
#line 355
      goto switch_break;
      case_2: /* CIL Label */ 
#line 357
      needid = (char)4;
#line 358
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 361
      if ((int )*databuf_pos == (int )needid) {
#line 362
        (zip->offset) ++;
      } else {
#line 364
        zip->offset = -1;
      }
#line 365
      databuf_pos ++;
#line 366
      goto while_continue;
    }
#line 369
    (zip->offset) ++;
#line 370
    if (zip->offset == 18) {
#line 371
      zip->skipcount = (unsigned int )((unsigned char )*databuf_pos);
    } else
#line 372
    if (zip->offset == 19) {
#line 373
      zip->skipcount |= (unsigned int )((int )((unsigned char )*databuf_pos) << 8);
    } else
#line 374
    if (zip->offset == 20) {
#line 375
      zip->skipcount |= (unsigned int )((int )((unsigned char )*databuf_pos) << 16);
    } else
#line 376
    if (zip->offset == 21) {
#line 377
      zip->skipcount |= (unsigned int )((int )((unsigned char )*databuf_pos) << 24);
    } else
#line 378
    if (zip->offset == 26) {
#line 379
      zip->namelen = (unsigned int )((unsigned char )*databuf_pos);
    } else
#line 380
    if (zip->offset == 27) {
#line 382
      zip->namelen |= (unsigned int )((int )((unsigned char )*databuf_pos) << 8);
#line 384
      if ((unsigned long )(zip->namelen + 1U) > sizeof(zip->filename)) {
#line 385
        zip->namelen = (unsigned int )(sizeof(zip->filename) - 1UL);
      }
    } else
#line 387
    if (zip->offset == 28) {
#line 388
      zip->skipcount += (unsigned int )((unsigned char )*databuf_pos);
    } else
#line 389
    if (zip->offset == 29) {
#line 391
      zip->skipcount += (unsigned int )((int )((unsigned char )*databuf_pos) << 8);
#line 392
      if (zip->skipcount > 50331648U) {
        {
#line 394
        init_zip(zip);
        }
#line 395
        goto while_continue;
      }
    } else
#line 398
    if (zip->offset >= 30) {
#line 401
      if ((unsigned int )(zip->offset - 30) >= zip->namelen) {
#line 404
        zip->skipping = 1;
#line 405
        return (databuf_pos);
      }
#line 407
      zip->filename[zip->offset - 30] = *databuf_pos;
    }
#line 409
    databuf_pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  return ((char *)((void *)0));
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.h"
char const   *mode2str(int mode ) ;
#line 192
char const   *act2str(int action ) ;
#line 194
int tokenize_list(char const   *thelist , int verbose___0 ) ;
#line 195
int parse_conf(struct config_opts *options ) ;
#line 196
void directive_defaults(struct config_opts *options ) ;
#line 197
void show_configuration(struct config_opts *options ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 195
extern FILE *tmpfile(void) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int filter_pass(FILE *dest ) ;
#line 59
int header_pass(FILE *source ) ;
#line 60
int is_line_mime(char const   *line , int on_mime , struct attach *m_attachment ) ;
#line 61
int filter_decision(struct attach *m_attach ) ;
#line 62
int match_filename(char const   *filename , int inzip ) ;
#line 63
int decode_2047(char *field , struct namespec *fieldspec ) ;
#line 64
int reencode_name(struct namespec *fieldspec , char const   *tagbase , char *result ) ;
#line 65
int position_html(FILE *source , FILE *dest ) ;
#line 66
void kill_exit(char const   *text ) ;
#line 67
void taking_action(char const   *caughtfile ) ;
#line 68
void not_taking_action(char const   *reason , char const   *missedfile ) ;
#line 69
int explain_subject(FILE *dest , char *oldsubject ) ;
#line 70
void abnormalproc(int sig ) ;
#line 71
FILE *openpipe(char **args , pid_t *childpid ) ;
#line 72
int closepipe(FILE *command , pid_t childpid , int *exitcode ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
struct config_opts configuration  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
FILE *tempfile  =    (FILE *)((void *)0);
#line 78 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int loopguard  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int verbose  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int justsettings  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int excode  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int filtcount  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int ban_count  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int exe_count  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int del_count  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int ren_count  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
char messageid[512]  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
static char shortopts[17]  = 
#line 82
  {      (char )'a',      (char )'b',      (char )'c',      (char )':', 
        (char )'d',      (char )'e',      (char )'g',      (char )'h', 
        (char )'k',      (char )'l',      (char )'p',      (char )':', 
        (char )'r',      (char )'s',      (char )'v',      (char )'V', 
        (char )'\000'};
#line 83 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
static struct option long_options[15]  = 
#line 83
  {      {"all", 0, (int *)((void *)0), 'a'}, 
        {"badlist", 0, (int *)((void *)0), 'b'}, 
        {"config", 1, (int *)((void *)0), 'c'}, 
        {"delete", 0, (int *)((void *)0), 'd'}, 
        {"excode", 0, (int *)((void *)0), 'e'}, 
        {"goodlist", 0, (int *)((void *)0), 'g'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"kill", 0, (int *)((void *)0), 'k'}, 
        {"loop", 0, (int *)((void *)0), 'l'}, 
        {"pipe", 1, (int *)((void *)0), 'p'}, 
        {"rename", 0, (int *)((void *)0), 'r'}, 
        {"settings", 0, (int *)((void *)0), 's'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 103 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int main(int argc , char **argv ) 
{ 
  int foundopt ;
  int argnum ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 106
  memset((void *)(& configuration), 0, sizeof(struct config_opts ));
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    foundopt = getopt_long(argc, (char * const  *)argv, (char const   *)(shortopts),
                           (struct option  const  *)(long_options), (int *)((void *)0));
    }
#line 108
    if (! (foundopt != -1)) {
#line 108
      goto while_break;
    }
    {
#line 112
    if (foundopt == 97) {
#line 112
      goto case_97;
    }
#line 121
    if (foundopt == 98) {
#line 121
      goto case_98;
    }
#line 130
    if (foundopt == 99) {
#line 130
      goto case_99;
    }
#line 134
    if (foundopt == 100) {
#line 134
      goto case_100;
    }
#line 143
    if (foundopt == 101) {
#line 143
      goto case_101;
    }
#line 147
    if (foundopt == 103) {
#line 147
      goto case_103;
    }
#line 156
    if (foundopt == 104) {
#line 156
      goto case_104;
    }
#line 176
    if (foundopt == 107) {
#line 176
      goto case_107;
    }
#line 185
    if (foundopt == 108) {
#line 185
      goto case_108;
    }
#line 189
    if (foundopt == 114) {
#line 189
      goto case_114;
    }
#line 198
    if (foundopt == 112) {
#line 198
      goto case_112;
    }
#line 208
    if (foundopt == 115) {
#line 208
      goto case_115;
    }
#line 212
    if (foundopt == 118) {
#line 212
      goto case_118;
    }
#line 216
    if (foundopt == 86) {
#line 216
      goto case_86;
    }
#line 221
    goto switch_default;
    case_97: /* CIL Label */ 
#line 113
    if (configuration.mode) {
      {
#line 115
      fputs((char const   */* __restrict  */)"You cannot specify multiple filter modes\n",
            (FILE */* __restrict  */)stderr);
      }
#line 116
      return (255);
    }
#line 118
    configuration.mode = 1;
#line 119
    goto switch_break;
    case_98: /* CIL Label */ 
#line 122
    if (configuration.mode) {
      {
#line 124
      fputs((char const   */* __restrict  */)"You cannot specify multiple filter modes\n",
            (FILE */* __restrict  */)stderr);
      }
#line 125
      return (255);
    }
#line 127
    configuration.mode = 2;
#line 128
    goto switch_break;
    case_99: /* CIL Label */ 
#line 131
    configuration.config_file = optarg;
#line 132
    goto switch_break;
    case_100: /* CIL Label */ 
#line 135
    if (configuration.def_act) {
      {
#line 137
      fputs((char const   */* __restrict  */)"You cannot specify multiple filter actions\n",
            (FILE */* __restrict  */)stderr);
      }
#line 138
      return (255);
    }
#line 140
    configuration.def_act = 2;
#line 141
    goto switch_break;
    case_101: /* CIL Label */ 
#line 144
    excode = 77;
#line 145
    goto switch_break;
    case_103: /* CIL Label */ 
#line 148
    if (configuration.mode) {
      {
#line 150
      fputs((char const   */* __restrict  */)"You cannot specify multiple filter modes\n",
            (FILE */* __restrict  */)stderr);
      }
#line 151
      return (255);
    }
#line 153
    configuration.mode = 3;
#line 154
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 157
    printf((char const   */* __restrict  */)"renattach 1.2.4\nCopyright (C) 2003-2006  Jem E. Berkes\n\n");
#line 158
    printf((char const   */* __restrict  */)"Usage: renattach [OPTIONS]\n\n");
#line 159
    printf((char const   */* __restrict  */)"  -a, --all\n\tFilter mode: Match all attachments.\n\n");
#line 160
    printf((char const   */* __restrict  */)"  -b, --badlist\n\tFilter mode: Only match filenames that have extensions listed on the\n\tbad-list. This will match only attachments with known dangerous file\n\textensions (default).\n\n");
#line 161
    printf((char const   */* __restrict  */)"  -c, --config filename\n\tUse the specified configuration file. Run renattach with --settings\n\tto verify current settings.\n\n");
#line 162
    printf((char const   */* __restrict  */)"  -d, --delete\n\tFilter action: Delete attachment body after renaming headers.\n\n");
#line 163
    printf((char const   */* __restrict  */)"  -e, --excode\n\tExtend exitcodes: 77=filtering occurred. This is in addition to the\n\tdefault codes: 0=success, 75=temporary failure, 255=critical failure\n\n");
#line 164
    printf((char const   */* __restrict  */)"  -g, --goodlist\n\tFilter mode: Match all attachments except those that have extensions\n\tlisted on the goodlist.\n\n");
#line 165
    printf((char const   */* __restrict  */)"  -h, --help\n\tShow help, explain options.\n\n");
#line 166
    printf((char const   */* __restrict  */)"  -k, --kill\n\tFilter action: Kill (absorb) entire email.\n\n");
#line 167
    printf((char const   */* __restrict  */)"  -l, --loop\n\tRemove Delivered-To headers to prevent malicious mail forwarding loop.\n\n");
#line 168
    printf((char const   */* __restrict  */)"  -p, --pipe command [args]\n\tInstead of writing output to stdout, open pipe to command (with args)\n\tand send output there. This program must return with exit code 0.\n\tThis must be the last option on the command line.\n\n");
#line 169
    printf((char const   */* __restrict  */)"  -r, --rename\n\tFilter action: Rename matching attachments (default).\n\n");
#line 170
    printf((char const   */* __restrict  */)"  -s, --settings\n\tShow current settings/configuration and terminate.\n\n");
#line 171
    printf((char const   */* __restrict  */)"  -v, --verbose\n\tWrite verbose output (including settings) to stderr.\n\n");
#line 172
    printf((char const   */* __restrict  */)"  -V, --version\n\tDisplay software version and terminate.\n\n");
    }
#line 173
    return (0);
#line 174
    goto switch_break;
    case_107: /* CIL Label */ 
#line 177
    if (configuration.def_act) {
      {
#line 179
      fputs((char const   */* __restrict  */)"You cannot specify multiple filter actions\n",
            (FILE */* __restrict  */)stderr);
      }
#line 180
      return (255);
    }
#line 182
    configuration.def_act = 3;
#line 183
    goto switch_break;
    case_108: /* CIL Label */ 
#line 186
    loopguard = 1;
#line 187
    goto switch_break;
    case_114: /* CIL Label */ 
#line 190
    if (configuration.def_act) {
      {
#line 192
      fputs((char const   */* __restrict  */)"You cannot specify multiple filter actions\n",
            (FILE */* __restrict  */)stderr);
      }
#line 193
      return (255);
    }
#line 195
    configuration.def_act = 1;
#line 196
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 201
    argnum = 0;
#line 202
    tmp = calloc((size_t )argc, sizeof(char *));
#line 202
    configuration.pipe_cmd = (char **)tmp;
#line 203
    optind --;
    }
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 203
      if (! (optind < argc)) {
#line 203
        goto while_break___0;
      }
#line 204
      tmp___0 = argnum;
#line 204
      argnum ++;
#line 204
      *(configuration.pipe_cmd + tmp___0) = *(argv + optind);
#line 203
      optind ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 205
    goto switch_break;
    case_115: /* CIL Label */ 
#line 209
    justsettings = 1;
#line 210
    goto switch_break;
    case_118: /* CIL Label */ 
#line 213
    verbose = 1;
#line 214
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 217
    printf((char const   */* __restrict  */)"renattach 1.2.4\nCopyright (C) 2003-2006  Jem E. Berkes\n\n");
    }
#line 218
    return (0);
#line 219
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 222
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: renattach [OPTIONS]\n\nTry `renattach --help\' for more options\n");
    }
#line 223
    return (255);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  if (! configuration.config_file) {
#line 229
    configuration.config_file = (char *)"/usr/local/etc/renattach.conf";
  }
#line 232
  if (! configuration.mode) {
#line 233
    configuration.mode = 2;
  }
#line 234
  if (! configuration.def_act) {
#line 235
    configuration.def_act = 1;
  }
  {
#line 238
  configuration.action = configuration.def_act;
#line 240
  tmp___2 = access((char const   *)configuration.config_file, 0);
  }
#line 240
  if (tmp___2 == 0) {
    {
#line 243
    tmp___1 = parse_conf(& configuration);
    }
#line 243
    if (tmp___1 != 0) {
#line 244
      return (255);
    }
  } else {
    {
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s\n",
            "Warning: using defaults in absence of ", configuration.config_file);
    }
  }
  {
#line 250
  directive_defaults(& configuration);
  }
#line 251
  if (justsettings) {
#line 251
    goto _L;
  } else
#line 251
  if (verbose) {
    _L: /* CIL Label */ 
    {
#line 253
    show_configuration(& configuration);
    }
#line 254
    if (justsettings) {
#line 255
      return (0);
    }
  }
  {
#line 259
  umask((__mode_t )63);
#line 260
  tempfile = tmpfile();
  }
#line 261
  if (tempfile) {
    {
#line 263
    tmp___3 = filter_pass(tempfile);
    }
#line 263
    if (tmp___3) {
      {
#line 263
      tmp___4 = header_pass(tempfile);
      }
#line 263
      if (tmp___4) {
        {
#line 265
        fclose(tempfile);
        }
#line 266
        if (filtcount) {
#line 267
          return (excode);
        } else {
#line 269
          return (0);
        }
      } else {
        {
#line 273
        fclose(tempfile);
        }
#line 274
        return (75);
      }
    } else {
      {
#line 273
      fclose(tempfile);
      }
#line 274
      return (75);
    }
  } else {
    {
#line 279
    perror("tmpfile");
    }
#line 280
    return (75);
  }
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int filter_pass(FILE *dest ) 
{ 
  char linebuf[1000] ;
  int onheaders ;
  int on_mime ;
  struct attach m_attachment ;
  struct attach u_attachment ;
  struct zip_info zipstate ;
  char uuscanspec[512] ;
  long last_mime_pos ;
  int sigcheckcount ;
  int skip_encoded ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char nameout[512] ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int decoded ;
  char textbuf[1000] ;
  char binbuf[1000] ;
  char *zip_pos ;
  int available ;
  struct attach inzip ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;

  {
  {
#line 294
  onheaders = 1;
#line 295
  on_mime = 0;
#line 300
  last_mime_pos = 0L;
#line 301
  sigcheckcount = 0;
#line 302
  skip_encoded = 0;
#line 307
  sprintf((char */* __restrict  */)(uuscanspec), (char const   */* __restrict  */)"begin %%*d %%%d[^\r\n]",
          511);
#line 308
  memset((void *)(& m_attachment), 0, sizeof(struct attach ));
#line 309
  memset((void *)(& u_attachment), 0, sizeof(struct attach ));
#line 310
  init_zip(& zipstate);
#line 311
  memset((void *)(messageid), 0, sizeof(messageid));
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 314
    tmp___21 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)stdin);
    }
#line 314
    if (! tmp___21) {
#line 314
      goto while_break;
    }
#line 316
    if (onheaders) {
#line 316
      if ((int )linebuf[0] == 10) {
#line 316
        goto _L;
      } else
#line 316
      if ((int )linebuf[0] == 13) {
        _L: /* CIL Label */ 
#line 318
        onheaders = 0;
#line 320
        if (configuration.delete_exe == 2) {
#line 321
          sigcheckcount = 10;
        } else
#line 320
        if (configuration.kill_exe == 2) {
#line 321
          sigcheckcount = 10;
        }
      }
    }
#line 325
    if (onheaders) {
      {
#line 325
      tmp = strncasecmp((char const   *)(linebuf), "Message-ID:", sizeof("Message-ID:") - 1UL);
      }
#line 325
      if (tmp == 0) {
        {
#line 326
        strncpy((char */* __restrict  */)(messageid), (char const   */* __restrict  */)(linebuf),
                sizeof(messageid) - 1UL);
        }
      }
    }
#line 329
    if (onheaders) {
#line 329
      if (loopguard) {
        {
#line 329
        tmp___0 = strncasecmp((char const   *)(linebuf), "Delivered-To:", sizeof("Delivered-To:") - 1UL);
        }
#line 329
        if (tmp___0 == 0) {
          {
#line 331
          configuration.action = 4;
#line 332
          taking_action("[forged Delivered-To header]");
          }
#line 333
          goto while_continue;
        }
      }
    }
    {
#line 337
    tmp___7 = strncmp((char const   *)(linebuf), "begin ", sizeof("begin ") - 1UL);
    }
#line 337
    if (tmp___7 == 0) {
      {
#line 337
      tmp___8 = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)(uuscanspec),
                       u_attachment.cd_fname.name);
      }
#line 337
      if (tmp___8 == 1) {
#line 343
        if (configuration.delete_exe == 2) {
#line 344
          sigcheckcount = 5;
        } else
#line 343
        if (configuration.kill_exe == 2) {
#line 344
          sigcheckcount = 5;
        }
        {
#line 345
        tmp___1 = filter_decision(& u_attachment);
        }
#line 345
        if (tmp___1) {
#line 347
          if (configuration.action == 2) {
#line 349
            skip_encoded = 3;
#line 350
            sigcheckcount = 0;
          }
          {
#line 352
          taking_action((char const   *)((u_attachment.curspec)->oldname));
          }
        }
        {
#line 355
        fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"begin 600 %s\n",
                (u_attachment.curspec)->name);
#line 356
        memset((void *)(& u_attachment), 0, sizeof(struct attach ));
        }
#line 357
        goto while_continue;
      } else {
#line 337
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 359
      tmp___6 = is_line_mime((char const   *)(linebuf), on_mime, & m_attachment);
      }
#line 359
      if (tmp___6) {
#line 361
        if (! on_mime) {
          {
#line 364
          on_mime = 1;
#line 365
          last_mime_pos = ftell(dest);
          }
#line 366
          if (last_mime_pos == -1L) {
#line 367
            return (0);
          }
        }
      } else
#line 370
      if (on_mime) {
#line 373
        on_mime = 0;
#line 374
        if (configuration.delete_exe == 2) {
#line 375
          sigcheckcount = 10;
        } else
#line 374
        if (configuration.kill_exe == 2) {
#line 375
          sigcheckcount = 10;
        }
#line 376
        if (m_attachment.fattach) {
          {
#line 384
          tmp___2 = filter_decision(& m_attachment);
          }
#line 384
          if (tmp___2) {
#line 386
            if (configuration.action == 2) {
#line 388
              skip_encoded = 1;
#line 389
              sigcheckcount = 0;
            }
            {
#line 391
            taking_action((char const   *)((m_attachment.curspec)->oldname));
            }
          }
          {
#line 393
          tmp___3 = fseek(dest, last_mime_pos, 0);
          }
#line 393
          if (tmp___3 != 0) {
#line 394
            return (0);
          }
#line 397
          if (m_attachment.content_type[0]) {
            {
#line 399
            tmp___4 = reencode_name(m_attachment.curspec, "\tname", nameout);
            }
#line 399
            if (tmp___4 != 0) {
              {
#line 400
              sprintf((char */* __restrict  */)(nameout), (char const   */* __restrict  */)"\tname=\"%s\"",
                      configuration.generic_name);
              }
            }
            {
#line 401
            fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"Content-Type: %s;\n%s\n",
                    m_attachment.content_type, nameout);
            }
          }
          {
#line 403
          tmp___5 = reencode_name(m_attachment.curspec, "\tfilename", nameout);
          }
#line 403
          if (tmp___5 != 0) {
            {
#line 404
            sprintf((char */* __restrict  */)(nameout), (char const   */* __restrict  */)"\tfilename=\"%s\"",
                    configuration.generic_name);
            }
          }
          {
#line 405
          fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"Content-Disposition: attachment;\n%s\n",
                  nameout);
          }
#line 406
          if (m_attachment.content_enc[0]) {
            {
#line 407
            fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"Content-Transfer-Encoding: %s\n",
                    m_attachment.content_enc);
            }
          }
#line 409
          if (configuration.pass_contentid == 2) {
#line 409
            if (m_attachment.content_id[0]) {
              {
#line 410
              fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"Content-ID: %s\n",
                      m_attachment.content_id);
              }
            }
          }
        }
        {
#line 412
        memset((void *)(& m_attachment), 0, sizeof(struct attach ));
        }
      }
    }
#line 416
    if (sigcheckcount > 0) {
      {
#line 418
      sigcheckcount --;
#line 419
      tmp___13 = strncmp((char const   *)(linebuf), "TVo", (size_t )3);
      }
#line 419
      if (tmp___13 == 0) {
#line 419
        goto _L___2;
      } else {
        {
#line 419
        tmp___14 = strncmp((char const   *)(linebuf), "TVp", (size_t )3);
        }
#line 419
        if (tmp___14 == 0) {
#line 419
          goto _L___2;
        } else {
          {
#line 419
          tmp___15 = strncmp((char const   *)(linebuf), "TVq", (size_t )3);
          }
#line 419
          if (tmp___15 == 0) {
#line 419
            goto _L___2;
          } else {
            {
#line 419
            tmp___16 = strncmp((char const   *)(linebuf), "TVr", (size_t )3);
            }
#line 419
            if (tmp___16 == 0) {
              _L___2: /* CIL Label */ 
#line 424
              if (configuration.kill_exe == 2) {
                {
#line 426
                configuration.action = 3;
#line 427
                kill_exit("[encoded attachment body]");
                }
              }
              {
#line 429
              skip_encoded = 2;
#line 430
              configuration.action = 2;
#line 431
              exe_count ++;
#line 432
              taking_action("[encoded attachment body]");
              }
            } else {
              {
#line 434
              tmp___9 = strncmp((char const   *)(linebuf + 1), "35H", (size_t )3);
              }
#line 434
              if (tmp___9 == 0) {
#line 434
                goto _L___1;
              } else {
                {
#line 434
                tmp___10 = strncmp((char const   *)(linebuf + 1), "35I", (size_t )3);
                }
#line 434
                if (tmp___10 == 0) {
#line 434
                  goto _L___1;
                } else {
                  {
#line 434
                  tmp___11 = strncmp((char const   *)(linebuf + 1), "35J", (size_t )3);
                  }
#line 434
                  if (tmp___11 == 0) {
#line 434
                    goto _L___1;
                  } else {
                    {
#line 434
                    tmp___12 = strncmp((char const   *)(linebuf + 1), "35K", (size_t )3);
                    }
#line 434
                    if (tmp___12 == 0) {
                      _L___1: /* CIL Label */ 
#line 439
                      if (configuration.kill_exe == 2) {
                        {
#line 441
                        configuration.action = 3;
#line 442
                        kill_exit("[encoded attachment body]");
                        }
                      }
                      {
#line 444
                      skip_encoded = 3;
#line 445
                      configuration.action = 2;
#line 446
                      exe_count ++;
#line 447
                      taking_action("[encoded attachment body]");
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 456
    if (configuration.search_zip == 2) {
      {
#line 461
      strncpy((char */* __restrict  */)(textbuf), (char const   */* __restrict  */)(linebuf),
              sizeof(textbuf));
#line 462
      trim_trailch(textbuf, (char )'\r', (char )'\n', (char )' ');
      }
#line 463
      if ((int )textbuf[0] == 0) {
        {
#line 464
        init_zip(& zipstate);
        }
      } else
#line 465
      if (skip_encoded < 2) {
        {
#line 465
        decoded = base64_decode_line((char const   *)(textbuf), binbuf);
        }
#line 465
        if (decoded) {
#line 467
          zip_pos = binbuf;
#line 468
          available = decoded;
          {
#line 469
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 469
            zip_pos = unzip_filename(zip_pos, available, & zipstate);
            }
#line 469
            if (! zip_pos) {
#line 469
              goto while_break___0;
            }
            {
#line 473
            memset((void *)(& inzip), 0, sizeof(struct attach ));
#line 474
            inzip.within = 1;
#line 475
            strncpy((char */* __restrict  */)(inzip.ct_fname.name), (char const   */* __restrict  */)(zipstate.filename),
                    sizeof(inzip.ct_fname.name));
#line 476
            tmp___17 = filter_decision(& inzip);
            }
#line 476
            if (tmp___17) {
#line 478
              if (configuration.action == 2) {
                {
#line 480
                skip_encoded = 2;
#line 481
                taking_action((char const   *)(zipstate.filename));
                }
              } else {
                {
#line 484
                not_taking_action("Can\'t rename inside ZIP", (char const   *)(zipstate.filename));
                }
              }
            }
#line 486
            available = (int )((binbuf + decoded) - zip_pos);
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
#line 491
    if (skip_encoded == 1) {
#line 491
      if ((int )linebuf[0] == 10) {
#line 492
        skip_encoded = 2;
      } else
#line 491
      if ((int )linebuf[0] == 13) {
#line 492
        skip_encoded = 2;
      } else {
#line 491
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 493
    if (skip_encoded == 2) {
#line 495
      if ((int )linebuf[0] == 10) {
#line 496
        skip_encoded = 0;
      } else
#line 495
      if ((int )linebuf[0] == 13) {
#line 496
        skip_encoded = 0;
      } else {
        {
#line 495
        tmp___18 = strncmp((char const   *)(linebuf), "--", (size_t )2);
        }
#line 495
        if (tmp___18 == 0) {
#line 496
          skip_encoded = 0;
        } else {
#line 498
          goto while_continue;
        }
      }
    } else
#line 500
    if (skip_encoded == 3) {
      {
#line 502
      tmp___19 = strncmp((char const   *)(linebuf), "end", sizeof("end") - 1UL);
      }
#line 502
      if (tmp___19 == 0) {
#line 503
        skip_encoded = 0;
      } else {
#line 505
        goto while_continue;
      }
    }
    {
#line 509
    tmp___20 = fputs((char const   */* __restrict  */)(linebuf), (FILE */* __restrict  */)dest);
    }
#line 509
    if (tmp___20 == -1) {
#line 510
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return (1);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int header_pass(FILE *source ) 
{ 
  char linebuf[1000] ;
  long endpos ;
  int onheaders ;
  int subject_changed ;
  int plain_part ;
  int html_part ;
  int plain_warning ;
  int tmp ;
  int html_warning ;
  int tmp___0 ;
  FILE *dest ;
  pid_t pid ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int retcode ;
  int tmp___15 ;

  {
#line 530
  onheaders = 1;
#line 531
  subject_changed = 0;
#line 532
  plain_part = 0;
#line 533
  html_part = 0;
#line 534
  if (configuration.warning_text) {
#line 534
    if (*(configuration.warning_text)) {
#line 534
      tmp = 1;
    } else {
#line 534
      tmp = 0;
    }
  } else {
#line 534
    tmp = 0;
  }
#line 534
  plain_warning = tmp;
#line 535
  if (configuration.warning_html) {
#line 535
    if (*(configuration.warning_html)) {
#line 535
      tmp___0 = 1;
    } else {
#line 535
      tmp___0 = 0;
    }
  } else {
#line 535
    tmp___0 = 0;
  }
#line 535
  html_warning = tmp___0;
#line 536
  dest = stdout;
#line 539
  if (plain_warning) {
#line 540
    plain_part = 1;
  }
  {
#line 543
  endpos = ftell(source);
  }
#line 544
  if (endpos == -1L) {
#line 545
    return (0);
  }
  {
#line 546
  rewind(source);
#line 547
  tmp___1 = fileno(source);
#line 547
  tmp___2 = ftruncate(tmp___1, endpos);
  }
#line 547
  if (tmp___2 != 0) {
#line 548
    return (0);
  }
  {
#line 549
  tmp___3 = fflush(source);
  }
#line 549
  if (tmp___3 != 0) {
#line 550
    return (0);
  }
#line 553
  if (configuration.pipe_cmd) {
    {
#line 555
    dest = openpipe(configuration.pipe_cmd, & pid);
    }
#line 556
    if ((unsigned long )dest == (unsigned long )((void *)0)) {
      {
#line 558
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening pipe command: %s\n",
              *(configuration.pipe_cmd + 0));
      }
#line 559
      return (0);
    }
    {
#line 561
    signal(13, & abnormalproc);
    }
  }
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 564
    tmp___14 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)source);
    }
#line 564
    if (! tmp___14) {
#line 564
      goto while_break;
    }
#line 567
    if ((int )linebuf[0] == 10) {
#line 567
      goto _L___0;
    } else
#line 567
    if ((int )linebuf[0] == 13) {
      _L___0: /* CIL Label */ 
#line 570
      if (onheaders) {
        {
#line 572
        onheaders = 0;
#line 573
        fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"X-Filtered-With: %s\n",
                "renattach 1.2.4");
#line 574
        tmp___4 = act2str(configuration.action);
#line 574
        tmp___5 = mode2str(configuration.mode);
#line 574
        fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"X-RenAttach-Info: mode=%s action=%s count=%d",
                tmp___5, tmp___4, filtcount);
        }
#line 577
        if (filtcount) {
          {
#line 579
          fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)" (%s)\n",
                  "filtered");
          }
#line 580
          if (! subject_changed) {
            {
#line 581
            explain_subject(dest, (char *)((void *)0));
            }
          }
        } else {
          {
#line 584
          fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"\n");
          }
        }
#line 586
        if (filtcount) {
#line 586
          if (configuration.add_header) {
#line 586
            if (*(configuration.add_header)) {
              {
#line 587
              fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"%s\n",
                      configuration.add_header);
              }
            }
          }
        }
      }
#line 591
      if (filtcount) {
#line 591
        if (plain_part) {
          {
#line 593
          fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"\n%s\n",
                  configuration.warning_text);
#line 594
          plain_part = 0;
          }
        } else {
#line 591
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 596
      if (filtcount) {
#line 596
        if (html_part) {
          {
#line 598
          fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"\n");
#line 599
          tmp___6 = position_html(source, dest);
          }
#line 599
          if (tmp___6 != 0) {
#line 600
            return (0);
          }
          {
#line 601
          fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"%s",
                  configuration.warning_html);
#line 602
          fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)source);
#line 603
          html_part = 0;
          }
        }
      }
    }
#line 608
    if (onheaders) {
#line 611
      if (filtcount) {
        {
#line 611
        tmp___8 = strncasecmp((char const   *)(linebuf), "Subject:", sizeof("Subject:") - 1UL);
        }
#line 611
        if (tmp___8 == 0) {
          {
#line 613
          subject_changed = 1;
#line 614
          tmp___7 = explain_subject(dest, (linebuf + sizeof("Subject:")) - 1);
          }
#line 614
          if (tmp___7) {
#line 615
            goto while_continue;
          }
        }
      }
      {
#line 619
      tmp___9 = strncasecmp((char const   *)(linebuf), "X-Filtered-With:", sizeof("X-Filtered-With:") - 1UL);
      }
#line 619
      if (tmp___9 == 0) {
        {
#line 622
        fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"Old-%s",
                linebuf);
        }
#line 623
        goto while_continue;
      } else {
        {
#line 619
        tmp___10 = strncasecmp((char const   *)(linebuf), "X-RenAttach-Info:", sizeof("X-RenAttach-Info:") - 1UL);
        }
#line 619
        if (tmp___10 == 0) {
          {
#line 622
          fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"Old-%s",
                  linebuf);
          }
#line 623
          goto while_continue;
        }
      }
    }
#line 628
    if (plain_warning) {
      {
#line 628
      tmp___12 = strncasecmp((char const   *)(linebuf), "Content-Type: text/plain",
                             sizeof("Content-Type: text/plain") - 1UL);
      }
#line 628
      if (tmp___12 == 0) {
#line 630
        plain_part = 1;
#line 631
        html_part = 0;
      } else {
#line 628
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 633
    if (html_warning) {
      {
#line 633
      tmp___11 = strncasecmp((char const   *)(linebuf), "Content-Type: text/html",
                             sizeof("Content-Type: text/html") - 1UL);
      }
#line 633
      if (tmp___11 == 0) {
#line 635
        plain_part = 0;
#line 636
        html_part = 1;
      }
    }
    {
#line 639
    tmp___13 = fputs((char const   */* __restrict  */)(linebuf), (FILE */* __restrict  */)dest);
    }
#line 639
    if (tmp___13 == -1) {
#line 640
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  if ((unsigned long )dest != (unsigned long )stdout) {
    {
#line 646
    retcode = -1;
#line 647
    tmp___15 = closepipe(dest, pid, & retcode);
    }
#line 647
    if (tmp___15 != 0) {
      {
#line 648
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error closing pipe command: %s\n",
              *(configuration.pipe_cmd + 0));
      }
    }
#line 649
    if (verbose) {
      {
#line 650
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: 0x%X\n",
              "pipe command exitcode", retcode);
      }
    }
#line 651
    if (retcode != 0) {
#line 652
      return (0);
    }
  }
#line 654
  return (1);
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int is_line_mime(char const   *line , int on_mime , struct attach *m_attachment ) 
{ 
  char const   *orgline ;
  int found_mime ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int parsed_name ;
  char *nameloc ;
  char *tmp___4 ;
  char *tmp___5 ;
  char scanspec[512] ;
  int tmp___6 ;
  char scanspec___0[512] ;
  int tmp___7 ;
  char scanspec___1[512] ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char parsed[512] ;
  char scanspec1[512] ;
  char scanspec2[512] ;
  char scanspec3[512] ;
  char scanspec4[512] ;
  char *tmp___13 ;
  int tmp___14 ;
  int remaining ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char parsed___0[512] ;
  char scanspec___2[512] ;
  int remaining___0 ;
  size_t tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
#line 667
  orgline = line;
#line 668
  found_mime = 0;
#line 671
  if (on_mime) {
#line 671
    if ((int const   )*line == 9) {
#line 672
      found_mime = 1;
    } else
#line 671
    if ((int const   )*line == 32) {
#line 672
      found_mime = 1;
    } else {
#line 671
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 673
    tmp = strncasecmp(line, "Content-Type:", sizeof("Content-Type:") - 1UL);
    }
#line 673
    if (tmp == 0) {
#line 678
      found_mime = 1;
    } else {
      {
#line 673
      tmp___0 = strncasecmp(line, "Content-Transfer-Encoding:", sizeof("Content-Transfer-Encoding:") - 1UL);
      }
#line 673
      if (tmp___0 == 0) {
#line 678
        found_mime = 1;
      } else {
        {
#line 673
        tmp___1 = strncasecmp(line, "Content-Disposition:", sizeof("Content-Disposition:") - 1UL);
        }
#line 673
        if (tmp___1 == 0) {
#line 678
          found_mime = 1;
        } else {
          {
#line 673
          tmp___2 = strncasecmp(line, "Content-ID:", sizeof("Content-ID:") - 1UL);
          }
#line 673
          if (tmp___2 == 0) {
#line 678
            found_mime = 1;
          } else {
            {
#line 673
            tmp___3 = strncasecmp(line, "Content-Description:", sizeof("Content-Description:") - 1UL);
            }
#line 673
            if (tmp___3 == 0) {
#line 678
              found_mime = 1;
            }
          }
        }
      }
    }
  }
#line 680
  if (found_mime) {
    {
#line 682
    parsed_name = 0;
#line 683
    tmp___4 = stristr(line, "name");
#line 683
    nameloc = tmp___4;
#line 686
    tmp___5 = strchr(line, '=');
    }
#line 686
    if ((unsigned long )nameloc >= (unsigned long )tmp___5) {
#line 687
      nameloc = (char *)((void *)0);
    }
    {
#line 689
    tmp___12 = strncasecmp(line, "Content-Type:", sizeof("Content-Type:") - 1UL);
    }
#line 689
    if (tmp___12 == 0) {
      {
#line 693
      sprintf((char */* __restrict  */)(scanspec), (char const   */* __restrict  */)"%%%d[^;\r\n\t]",
              511);
#line 694
      tmp___6 = sscanf((char const   */* __restrict  */)((line + sizeof("Content-Type:")) - 1),
                       (char const   */* __restrict  */)(scanspec), m_attachment->content_type);
      }
#line 694
      if (tmp___6 == 1) {
        {
#line 696
        trim_leading(m_attachment->content_type);
#line 697
        trim_trailing(m_attachment->content_type);
        }
      }
#line 699
      m_attachment->curspec = & m_attachment->ct_fname;
    } else {
      {
#line 701
      tmp___11 = strncasecmp(line, "Content-Disposition:", sizeof("Content-Disposition:") - 1UL);
      }
#line 701
      if (tmp___11 == 0) {
#line 703
        m_attachment->curspec = & m_attachment->cd_fname;
      } else {
        {
#line 705
        tmp___10 = strncasecmp(line, "Content-Transfer-Encoding:", sizeof("Content-Transfer-Encoding:") - 1UL);
        }
#line 705
        if (tmp___10 == 0) {
          {
#line 709
          sprintf((char */* __restrict  */)(scanspec___0), (char const   */* __restrict  */)"%%%d[^;\r\n\t]",
                  511);
#line 710
          tmp___7 = sscanf((char const   */* __restrict  */)((line + sizeof("Content-Transfer-Encoding:")) - 1),
                           (char const   */* __restrict  */)(scanspec___0), m_attachment->content_enc);
          }
#line 710
          if (tmp___7 == 1) {
            {
#line 712
            trim_leading(m_attachment->content_enc);
#line 713
            trim_trailing(m_attachment->content_enc);
            }
          }
        } else {
          {
#line 716
          tmp___9 = strncasecmp(line, "Content-ID:", sizeof("Content-ID:") - 1UL);
          }
#line 716
          if (tmp___9 == 0) {
            {
#line 720
            sprintf((char */* __restrict  */)(scanspec___1), (char const   */* __restrict  */)"%%%d[^;\r\n\t]",
                    511);
#line 721
            tmp___8 = sscanf((char const   */* __restrict  */)((line + sizeof("Content-ID:")) - 1),
                             (char const   */* __restrict  */)(scanspec___1), m_attachment->content_id);
            }
#line 721
            if (tmp___8 == 1) {
              {
#line 723
              trim_leading(m_attachment->content_id);
#line 724
              trim_trailing(m_attachment->content_id);
              }
            }
          }
        }
      }
    }
    {
#line 729
    while (1) {
      while_continue: /* CIL Label */ ;
#line 729
      if (m_attachment->curspec) {
#line 729
        if (! nameloc) {
#line 729
          goto while_break;
        }
      } else {
#line 729
        goto while_break;
      }
      {
#line 735
      m_attachment->fattach = 1;
#line 736
      line = (char const   *)(nameloc + sizeof("name"));
#line 739
      tmp___14 = strncasecmp((char const   *)nameloc, "name*", sizeof("name*") - 1UL);
      }
#line 739
      if (tmp___14 == 0) {
        {
#line 741
        (m_attachment->curspec)->specformat = 2;
#line 743
        tmp___13 = strstr((char const   *)nameloc, "*=");
        }
#line 743
        if (tmp___13) {
#line 744
          (m_attachment->curspec)->langinfo = 1;
        }
      }
      {
#line 747
      sprintf((char */* __restrict  */)(scanspec1), (char const   */* __restrict  */)"%%*[ *0-9]%%*[ =]\"%%%d[^\r\n\"]",
              511);
#line 748
      sprintf((char */* __restrict  */)(scanspec2), (char const   */* __restrict  */)"%%*[ *0-9]%%*[ =]%%%d[^\r\n\";]",
              511);
#line 749
      sprintf((char */* __restrict  */)(scanspec3), (char const   */* __restrict  */)"%%*[ =]\"%%%d[^\r\n\"]",
              511);
#line 750
      sprintf((char */* __restrict  */)(scanspec4), (char const   */* __restrict  */)"%%*[ =]%%%d[^\r\n\";]",
              511);
#line 751
      tmp___20 = sscanf((char const   */* __restrict  */)((nameloc + sizeof("name")) - 1),
                        (char const   */* __restrict  */)(scanspec1), parsed);
      }
#line 751
      if (tmp___20 == 1) {
#line 751
        goto _L___1;
      } else {
        {
#line 751
        tmp___21 = sscanf((char const   */* __restrict  */)((nameloc + sizeof("name")) - 1),
                          (char const   */* __restrict  */)(scanspec2), parsed);
        }
#line 751
        if (tmp___21 == 1) {
#line 751
          goto _L___1;
        } else {
          {
#line 751
          tmp___22 = sscanf((char const   */* __restrict  */)((nameloc + sizeof("name")) - 1),
                            (char const   */* __restrict  */)(scanspec3), parsed);
          }
#line 751
          if (tmp___22 == 1) {
#line 751
            goto _L___1;
          } else {
            {
#line 751
            tmp___23 = sscanf((char const   */* __restrict  */)((nameloc + sizeof("name")) - 1),
                              (char const   */* __restrict  */)(scanspec4), parsed);
            }
#line 751
            if (tmp___23 == 1) {
              _L___1: /* CIL Label */ 
              {
#line 757
              parsed_name = 1;
#line 758
              tmp___15 = strlen((char const   *)(parsed));
#line 758
              line += tmp___15;
              }
#line 759
              if ((m_attachment->curspec)->specformat == 2) {
                {
#line 760
                decode_hex(parsed, (char )'%', 0, (char *)((void *)0));
                }
              } else {
                {
#line 761
                tmp___16 = strstr((char const   *)(parsed), "=?");
                }
#line 761
                if (tmp___16) {
#line 761
                  goto _L___0;
                } else {
                  {
#line 761
                  tmp___17 = strstr((char const   *)(parsed), "?=");
                  }
#line 761
                  if (tmp___17) {
                    _L___0: /* CIL Label */ 
                    {
#line 761
                    tmp___18 = decode_2047(parsed, m_attachment->curspec);
                    }
#line 761
                    if (tmp___18 == 0) {
#line 762
                      (m_attachment->curspec)->specformat = 1;
                    } else {
                      {
#line 765
                      trim_leading(parsed);
#line 766
                      trim_trailing(parsed);
                      }
                    }
                  } else {
                    {
#line 765
                    trim_leading(parsed);
#line 766
                    trim_trailing(parsed);
                    }
                  }
                }
              }
              {
#line 768
              tmp___19 = strlen((char const   *)((m_attachment->curspec)->name));
#line 768
              remaining = (int )((512UL - tmp___19) - 1UL);
#line 769
              strncat((char */* __restrict  */)((m_attachment->curspec)->name), (char const   */* __restrict  */)(parsed),
                      (size_t )remaining);
              }
            }
          }
        }
      }
      {
#line 773
      nameloc = stristr(line, "name");
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 777
    if (! parsed_name) {
#line 777
      if (m_attachment->curspec) {
#line 777
        if ((m_attachment->curspec)->specformat == 1) {
          {
#line 780
          sprintf((char */* __restrict  */)(scanspec___2), (char const   */* __restrict  */)"%%*[\t ]%%%d[^\r\n\"]",
                  511);
#line 781
          tmp___25 = sscanf((char const   */* __restrict  */)orgline, (char const   */* __restrict  */)(scanspec___2),
                            parsed___0);
          }
#line 781
          if (tmp___25 == 1) {
            {
#line 781
            tmp___26 = decode_2047(parsed___0, m_attachment->curspec);
            }
#line 781
            if (tmp___26 == 0) {
              {
#line 783
              tmp___24 = strlen((char const   *)((m_attachment->curspec)->name));
#line 783
              remaining___0 = (int )((512UL - tmp___24) - 1UL);
#line 784
              strncat((char */* __restrict  */)((m_attachment->curspec)->name), (char const   */* __restrict  */)(parsed___0),
                      (size_t )remaining___0);
              }
            }
          }
        }
      }
    }
  }
#line 788
  return (found_mime);
}
}
#line 803 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int filter_decision(struct attach *m_attach ) 
{ 
  char *dotsearch ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 808
  trim_leading(m_attach->ct_fname.name);
#line 809
  trim_trailch(m_attach->ct_fname.name, (char )'\t', (char )' ', (char )'.');
#line 810
  trim_leading(m_attach->cd_fname.name);
#line 811
  trim_trailch(m_attach->cd_fname.name, (char )'\t', (char )' ', (char )'.');
#line 814
  tmp___0 = match_filename((char const   *)(m_attach->ct_fname.name), m_attach->within);
  }
#line 814
  if (tmp___0) {
#line 815
    m_attach->curspec = & m_attach->ct_fname;
  } else {
    {
#line 816
    tmp = match_filename((char const   *)(m_attach->cd_fname.name), m_attach->within);
    }
#line 816
    if (tmp) {
#line 817
      m_attach->curspec = & m_attach->cd_fname;
    } else {
#line 821
      if (m_attach->cd_fname.name[0]) {
#line 822
        m_attach->curspec = & m_attach->cd_fname;
      } else {
#line 824
        m_attach->curspec = & m_attach->ct_fname;
      }
#line 825
      return (0);
    }
  }
  {
#line 829
  strcpy((char */* __restrict  */)((m_attach->curspec)->oldname), (char const   */* __restrict  */)((m_attach->curspec)->name));
  }
#line 831
  if (configuration.action == 3) {
    {
#line 832
    kill_exit((char const   *)((m_attach->curspec)->oldname));
    }
  }
#line 834
  if (configuration.full_rename == 2) {
#line 837
    dotsearch = (m_attach->curspec)->name;
    {
#line 837
    while (1) {
      while_continue: /* CIL Label */ ;
#line 837
      if (! *dotsearch) {
#line 837
        goto while_break;
      }
#line 839
      if ((int )*dotsearch == 46) {
#line 840
        *dotsearch = (char )'_';
      }
#line 837
      dotsearch ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 846
    dotsearch = strrchr((char const   *)((m_attach->curspec)->name), '.');
    }
#line 847
    if (dotsearch) {
#line 848
      *dotsearch = (char )'_';
    }
  }
  {
#line 856
  tmp___3 = strcmp((char const   *)(configuration.new_extension), "#");
  }
#line 856
  if (tmp___3 != 0) {
    {
#line 858
    tmp___1 = strlen((char const   *)((m_attach->curspec)->name));
#line 858
    tmp___2 = strlen((char const   *)(configuration.new_extension));
    }
#line 858
    if ((1UL + tmp___1) + tmp___2 < sizeof((m_attach->curspec)->name)) {
      {
#line 861
      strcat((char */* __restrict  */)((m_attach->curspec)->name), (char const   */* __restrict  */)".");
#line 862
      strcat((char */* __restrict  */)((m_attach->curspec)->name), (char const   */* __restrict  */)(configuration.new_extension));
      }
    }
  }
  {
#line 866
  strcpy((char */* __restrict  */)(m_attach->content_type), (char const   */* __restrict  */)(configuration.new_mime_type));
  }
#line 867
  return (1);
}
}
#line 877 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int match_filename(char const   *filename , int inzip ) 
{ 
  char extension[512] ;
  char *lastdot ;
  char *listcopy ;
  char *token ;
  size_t tmp ;
  void *tmp___0 ;
  int action ;
  int submatch ;
  char *actswitch ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int action___0 ;
  char *switchar ;
  char *actswitch___0 ;
  char *inswitch ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
#line 882
  if ((int const   )*filename == 0) {
#line 883
    return (0);
  }
#line 884
  if (configuration.mode == 1) {
#line 885
    return (1);
  }
#line 888
  if (configuration.banned_files) {
    {
#line 888
    tmp___3 = tokenize_list((char const   *)configuration.banned_files, 0);
    }
#line 888
    if (tmp___3) {
      {
#line 890
      tmp = strlen((char const   *)configuration.banned_files);
#line 890
      tmp___0 = malloc(tmp + 1UL);
#line 890
      listcopy = (char *)tmp___0;
#line 891
      strcpy((char */* __restrict  */)listcopy, (char const   */* __restrict  */)configuration.banned_files);
#line 892
      token = strtok((char */* __restrict  */)listcopy, (char const   */* __restrict  */)"\t, \n");
      }
      {
#line 893
      while (1) {
        while_continue: /* CIL Label */ ;
#line 893
        if (! token) {
#line 893
          goto while_break;
        }
#line 895
        action = 0;
#line 895
        submatch = 0;
#line 898
        if ((int )*token == 47) {
#line 900
          submatch = 1;
#line 901
          token ++;
        }
        {
#line 903
        actswitch = strchr((char const   *)token, '/');
        }
#line 904
        if (actswitch) {
          {
#line 909
          if ((int )*(actswitch + 1) == 82) {
#line 909
            goto case_82;
          }
#line 909
          if ((int )*(actswitch + 1) == 114) {
#line 909
            goto case_82;
          }
#line 913
          if ((int )*(actswitch + 1) == 68) {
#line 913
            goto case_68;
          }
#line 913
          if ((int )*(actswitch + 1) == 100) {
#line 913
            goto case_68;
          }
#line 917
          if ((int )*(actswitch + 1) == 75) {
#line 917
            goto case_75;
          }
#line 917
          if ((int )*(actswitch + 1) == 107) {
#line 917
            goto case_75;
          }
#line 906
          goto switch_break;
          case_82: /* CIL Label */ 
          case_114: /* CIL Label */ 
#line 910
          action = 1;
#line 911
          goto switch_break;
          case_68: /* CIL Label */ 
          case_100: /* CIL Label */ 
#line 914
          action = 2;
#line 915
          goto switch_break;
          case_75: /* CIL Label */ 
          case_107: /* CIL Label */ 
#line 918
          action = 3;
#line 919
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 921
          *actswitch = (char )'\000';
        }
#line 924
        if (submatch) {
          {
#line 924
          tmp___1 = stristr(filename, (char const   *)token);
          }
#line 924
          if (tmp___1) {
#line 924
            goto _L;
          } else {
#line 924
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 924
          tmp___2 = strcasecmp(filename, (char const   *)token);
          }
#line 924
          if (tmp___2 == 0) {
            _L: /* CIL Label */ 
#line 926
            ban_count ++;
#line 927
            if (action) {
#line 928
              configuration.action = action;
            }
            {
#line 929
            free((void *)listcopy);
            }
#line 930
            return (1);
          }
        }
        {
#line 932
        token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\t, \n");
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 934
      free((void *)listcopy);
      }
    }
  }
  {
#line 937
  lastdot = strrchr(filename, '.');
  }
#line 938
  if (! lastdot) {
#line 939
    return (0);
  } else
#line 938
  if ((int )*(lastdot + 1) == 0) {
#line 939
    return (0);
  }
  {
#line 941
  memset((void *)(extension), 0, sizeof(extension));
#line 942
  strncpy((char */* __restrict  */)(extension), (char const   */* __restrict  */)(lastdot + 1),
          sizeof(extension) - 1UL);
#line 943
  trim_leading(extension);
#line 944
  trim_trailing(extension);
  }
#line 948
  if (configuration.mode == 2) {
    {
#line 951
    tmp___4 = strlen((char const   *)configuration.badlist);
#line 951
    tmp___5 = malloc(tmp___4 + 1UL);
#line 951
    listcopy = (char *)tmp___5;
#line 952
    strcpy((char */* __restrict  */)listcopy, (char const   */* __restrict  */)configuration.badlist);
#line 953
    token = strtok((char */* __restrict  */)listcopy, (char const   */* __restrict  */)"\t, \n");
    }
    {
#line 954
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 954
      if (! token) {
#line 954
        goto while_break___0;
      }
      {
#line 956
      action___0 = 0;
#line 957
      inswitch = (char *)((void *)0);
#line 959
      actswitch___0 = strchr((char const   *)token, '/');
      }
#line 960
      if (actswitch___0) {
        {
#line 961
        inswitch = strchr((char const   *)(actswitch___0 + 1), '/');
        }
      }
#line 962
      if (inzip) {
#line 962
        if (inswitch) {
#line 963
          switchar = inswitch;
        } else {
#line 965
          switchar = actswitch___0;
        }
      } else {
#line 965
        switchar = actswitch___0;
      }
#line 967
      if (switchar) {
        {
#line 972
        if ((int )*(switchar + 1) == 82) {
#line 972
          goto case_82___0;
        }
#line 972
        if ((int )*(switchar + 1) == 114) {
#line 972
          goto case_82___0;
        }
#line 976
        if ((int )*(switchar + 1) == 68) {
#line 976
          goto case_68___0;
        }
#line 976
        if ((int )*(switchar + 1) == 100) {
#line 976
          goto case_68___0;
        }
#line 980
        if ((int )*(switchar + 1) == 75) {
#line 980
          goto case_75___0;
        }
#line 980
        if ((int )*(switchar + 1) == 107) {
#line 980
          goto case_75___0;
        }
#line 969
        goto switch_break___0;
        case_82___0: /* CIL Label */ 
        case_114___0: /* CIL Label */ 
#line 973
        action___0 = 1;
#line 974
        goto switch_break___0;
        case_68___0: /* CIL Label */ 
        case_100___0: /* CIL Label */ 
#line 977
        action___0 = 2;
#line 978
        goto switch_break___0;
        case_75___0: /* CIL Label */ 
        case_107___0: /* CIL Label */ 
#line 981
        action___0 = 3;
#line 982
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
#line 985
      if (actswitch___0) {
#line 986
        *actswitch___0 = (char )'\000';
      }
      {
#line 988
      tmp___6 = strcasecmp((char const   *)token, (char const   *)(extension));
      }
#line 988
      if (tmp___6 == 0) {
#line 990
        if (action___0) {
#line 991
          configuration.action = action___0;
        }
        {
#line 992
        free((void *)listcopy);
        }
#line 993
        return (1);
      }
      {
#line 995
      token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\t, \n");
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 997
    free((void *)listcopy);
    }
#line 998
    return (0);
  } else
#line 1000
  if (configuration.mode == 3) {
    {
#line 1003
    tmp___7 = strlen((char const   *)configuration.goodlist);
#line 1003
    tmp___8 = malloc(tmp___7 + 1UL);
#line 1003
    listcopy = (char *)tmp___8;
#line 1004
    strcpy((char */* __restrict  */)listcopy, (char const   */* __restrict  */)configuration.goodlist);
#line 1005
    token = strtok((char */* __restrict  */)listcopy, (char const   */* __restrict  */)"\t, \n");
    }
    {
#line 1006
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1006
      if (! token) {
#line 1006
        goto while_break___1;
      }
      {
#line 1008
      tmp___9 = strcasecmp((char const   *)token, (char const   *)(extension));
      }
#line 1008
      if (tmp___9 == 0) {
        {
#line 1010
        free((void *)listcopy);
        }
#line 1011
        return (0);
      }
      {
#line 1013
      token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\t, \n");
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1015
    free((void *)listcopy);
    }
#line 1016
    return (1);
  } else {
#line 1019
    return (1);
  }
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int decode_2047(char *field , struct namespec *fieldspec ) 
{ 
  char scanspec[512] ;
  char *result ;
  int pos ;
  int field_len ;
  int improper ;
  int valid ;
  int state ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *termin ;
  int whitesp ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1036
  valid = 0;
#line 1037
  state = 0;
#line 1041
  sprintf((char */* __restrict  */)(scanspec), (char const   */* __restrict  */)"=?%%%d[^?]",
          511);
#line 1042
  improper = 0;
#line 1043
  tmp = strlen((char const   *)field);
#line 1043
  field_len = (int )tmp;
#line 1044
  tmp___0 = calloc((size_t )(field_len + 1), (size_t )1);
#line 1044
  result = (char *)tmp___0;
#line 1046
  pos = 0;
  }
  {
#line 1046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1046
    if (pos < field_len) {
#line 1046
      if (! (! improper)) {
#line 1046
        goto while_break;
      }
    } else {
#line 1046
      goto while_break;
    }
#line 1049
    if (state > 0) {
#line 1049
      if ((int )*(field + pos) == 32) {
#line 1051
        improper = 1;
#line 1052
        goto while_break;
      }
    }
    {
#line 1057
    if (state == 0) {
#line 1057
      goto case_0;
    }
#line 1070
    if (state == 1) {
#line 1070
      goto case_1;
    }
#line 1075
    if (state == 2) {
#line 1075
      goto case_2;
    }
#line 1118
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1059
    tmp___2 = sscanf((char const   */* __restrict  */)(field + pos), (char const   */* __restrict  */)(scanspec),
                     fieldspec->charenc);
    }
#line 1059
    if (tmp___2 == 1) {
#line 1062
      valid = 1;
#line 1063
      state ++;
#line 1064
      pos ++;
    } else {
      {
#line 1059
      tmp___3 = sscanf((char const   */* __restrict  */)(field + pos), (char const   */* __restrict  */)(scanspec + 1),
                       fieldspec->charenc);
      }
#line 1059
      if (tmp___3 == 1) {
#line 1062
        valid = 1;
#line 1063
        state ++;
#line 1064
        pos ++;
      } else {
        {
#line 1067
        tmp___1 = strlen((char const   *)result);
#line 1067
        sprintf((char */* __restrict  */)(result + tmp___1), (char const   */* __restrict  */)"%c",
                (int )*(field + pos));
        }
      }
    }
#line 1068
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1071
    if ((int )*(field + pos) == 63) {
#line 1072
      state ++;
    }
#line 1073
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1076
    tmp___5 = strncasecmp((char const   *)(field + pos), "Q?", (size_t )2);
    }
#line 1076
    if (tmp___5 == 0) {
#line 1077
      state = 3;
    } else {
      {
#line 1078
      tmp___4 = strncasecmp((char const   *)(field + pos), "B?", (size_t )2);
      }
#line 1078
      if (tmp___4 == 0) {
#line 1079
        state = 4;
      } else {
#line 1081
        improper = 1;
      }
    }
#line 1082
    if (state > 2) {
      {
#line 1085
      pos += 2;
#line 1086
      termin = strstr((char const   *)(field + pos), "?=");
      }
#line 1087
      if (! termin) {
#line 1088
        improper = 1;
      } else {
#line 1091
        whitesp = 0;
#line 1092
        *termin = (char)0;
#line 1093
        if (state == 3) {
          {
#line 1095
          fieldspec->charmode = (char )'Q';
#line 1096
          tmp___6 = strlen((char const   *)result);
#line 1096
          decode_hex(field + pos, (char )'=', 1, result + tmp___6);
          }
        } else {
          {
#line 1100
          fieldspec->charmode = (char )'B';
#line 1101
          tmp___7 = strlen((char const   *)result);
#line 1101
          base64_decode_line((char const   *)(field + pos), result + tmp___7);
          }
        }
#line 1103
        *termin = (char )'?';
#line 1104
        pos = (int )((termin - field) + 2L);
        {
#line 1105
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1105
          if (! ((int )*(field + pos) == 32)) {
#line 1105
            if (! ((int )*(field + pos) == 9)) {
#line 1105
              goto while_break___0;
            }
          }
#line 1107
          whitesp = 1;
#line 1108
          pos ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1110
        if (whitesp) {
          {
#line 1110
          tmp___8 = strncmp((char const   *)(field + pos), "=?", (size_t )2);
          }
#line 1110
          if (tmp___8 != 0) {
            {
#line 1111
            strcat((char */* __restrict  */)result, (char const   */* __restrict  */)" ");
            }
          }
        }
#line 1112
        if (pos > 0) {
#line 1112
          pos --;
        }
#line 1113
        state = 0;
      }
    }
#line 1116
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1119
    improper = 1;
    switch_break: /* CIL Label */ ;
    }
#line 1046
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1123
  if (improper) {
    {
#line 1125
    free((void *)result);
#line 1126
    *field = (char)0;
    }
#line 1127
    return (1);
  } else
#line 1123
  if (! valid) {
    {
#line 1125
    free((void *)result);
#line 1126
    *field = (char)0;
    }
#line 1127
    return (1);
  } else {
    {
#line 1131
    strcpy((char */* __restrict  */)field, (char const   */* __restrict  */)result);
#line 1132
    free((void *)result);
    }
#line 1133
    return (0);
  }
}
}
#line 1150 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int reencode_name(struct namespec *fieldspec , char const   *tagbase , char *result ) 
{ 
  int namelen ;
  size_t tmp ;
  size_t tmp___0 ;
  int remain ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int pos ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  unsigned short const   **tmp___6 ;
  int pos___0 ;
  int remain___0 ;
  int linecount ;
  int linelen ;
  int singquote ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  unsigned short const   **tmp___17 ;

  {
  {
#line 1152
  tmp = strlen((char const   *)(fieldspec->name));
#line 1152
  namelen = (int )tmp;
  }
#line 1153
  if (namelen == 0) {
#line 1154
    return (1);
  }
  {
#line 1155
  memset((void *)result, 0, (size_t )512);
  }
#line 1157
  if (fieldspec->specformat == 0) {
    {
#line 1160
    tmp___0 = strlen(tagbase);
    }
#line 1160
    if ((tmp___0 + 3UL) + (size_t )namelen < 512UL) {
      {
#line 1162
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s=\"%s\"",
              tagbase, fieldspec->name);
      }
#line 1163
      return (0);
    } else {
#line 1166
      return (1);
    }
  } else
#line 1168
  if (fieldspec->specformat == 1) {
    {
#line 1170
    tmp___1 = strlen(tagbase);
#line 1170
    tmp___2 = strlen((char const   *)(fieldspec->charenc));
#line 1170
    remain = (int )((((512UL - tmp___1) - 4UL) - tmp___2) - 3UL);
    }
#line 1171
    if (remain <= 1) {
#line 1172
      return (1);
    }
    {
#line 1173
    sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s=\"=?%s?%c?",
            tagbase, fieldspec->charenc, (int )fieldspec->charmode);
    }
#line 1174
    if ((int )fieldspec->charmode == 66) {
#line 1176
      remain -= (1 + namelen / 3) * 4;
#line 1177
      if (remain <= 1) {
#line 1178
        return (1);
      }
      {
#line 1179
      tmp___3 = strlen((char const   *)result);
#line 1179
      base64_encode_line((char const   *)(fieldspec->name), namelen, result + tmp___3);
      }
    } else {
#line 1184
      remain -= 3 * namelen;
#line 1185
      if (remain <= 1) {
#line 1186
        return (1);
      }
#line 1187
      pos = 0;
      {
#line 1187
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1187
        if (! (pos < namelen)) {
#line 1187
          goto while_break;
        }
        {
#line 1190
        tmp___6 = __ctype_b_loc();
        }
#line 1190
        if ((int const   )*(*tmp___6 + (int )fieldspec->name[pos]) & 8) {
          {
#line 1194
          tmp___4 = strlen((char const   *)result);
#line 1194
          sprintf((char */* __restrict  */)(result + tmp___4), (char const   */* __restrict  */)"%c",
                  (int )fieldspec->name[pos]);
          }
        } else
#line 1190
        if ((int )fieldspec->name[pos] == 46) {
          {
#line 1194
          tmp___4 = strlen((char const   *)result);
#line 1194
          sprintf((char */* __restrict  */)(result + tmp___4), (char const   */* __restrict  */)"%c",
                  (int )fieldspec->name[pos]);
          }
        } else
#line 1190
        if ((int )fieldspec->name[pos] == 45) {
          {
#line 1194
          tmp___4 = strlen((char const   *)result);
#line 1194
          sprintf((char */* __restrict  */)(result + tmp___4), (char const   */* __restrict  */)"%c",
                  (int )fieldspec->name[pos]);
          }
        } else
#line 1190
        if ((int )fieldspec->name[pos] == 33) {
          {
#line 1194
          tmp___4 = strlen((char const   *)result);
#line 1194
          sprintf((char */* __restrict  */)(result + tmp___4), (char const   */* __restrict  */)"%c",
                  (int )fieldspec->name[pos]);
          }
        } else
#line 1190
        if ((int )fieldspec->name[pos] == 58) {
          {
#line 1194
          tmp___4 = strlen((char const   *)result);
#line 1194
          sprintf((char */* __restrict  */)(result + tmp___4), (char const   */* __restrict  */)"%c",
                  (int )fieldspec->name[pos]);
          }
        } else
#line 1190
        if ((int )fieldspec->name[pos] == 92) {
          {
#line 1194
          tmp___4 = strlen((char const   *)result);
#line 1194
          sprintf((char */* __restrict  */)(result + tmp___4), (char const   */* __restrict  */)"%c",
                  (int )fieldspec->name[pos]);
          }
        } else
#line 1196
        if ((int )fieldspec->name[pos] == 32) {
          {
#line 1197
          strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"_");
          }
        } else {
          {
#line 1200
          tmp___5 = strlen((char const   *)result);
#line 1200
          sprintf((char */* __restrict  */)(result + tmp___5), (char const   */* __restrict  */)"=%02X",
                  (int )((unsigned char )fieldspec->name[pos]));
          }
        }
#line 1187
        pos ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 1205
    remain -= 3;
#line 1206
    if (remain <= 1) {
#line 1207
      return (1);
    }
    {
#line 1208
    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"?=\"");
    }
#line 1209
    return (0);
  } else
#line 1211
  if (fieldspec->specformat == 2) {
#line 1213
    linecount = 0;
#line 1214
    linelen = 0;
#line 1215
    singquote = 0;
#line 1217
    if (fieldspec->langinfo) {
      {
#line 1218
      tmp___7 = linecount;
#line 1218
      linecount ++;
#line 1218
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s*%u*=",
              tagbase, tmp___7);
      }
    } else {
      {
#line 1220
      tmp___8 = linecount;
#line 1220
      linecount ++;
#line 1220
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s*%u=\"",
              tagbase, tmp___8);
      }
    }
    {
#line 1221
    tmp___9 = strlen((char const   *)result);
#line 1221
    remain___0 = (int )(512UL - tmp___9);
#line 1224
    pos___0 = 0;
    }
    {
#line 1224
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1224
      if (! (pos___0 < namelen)) {
#line 1224
        goto while_break___0;
      }
#line 1226
      if (linelen > 50) {
        {
#line 1228
        linelen = 0;
#line 1229
        tmp___10 = strlen(tagbase);
#line 1229
        remain___0 = (int )((size_t )remain___0 - (tmp___10 + 10UL));
        }
#line 1230
        if (remain___0 <= 1) {
#line 1231
          return (1);
        }
#line 1234
        if (fieldspec->langinfo) {
          {
#line 1235
          tmp___11 = linecount;
#line 1235
          linecount ++;
#line 1235
          tmp___12 = strlen((char const   *)result);
#line 1235
          sprintf((char */* __restrict  */)(result + tmp___12), (char const   */* __restrict  */)";\n%s*%u*=",
                  tagbase, tmp___11);
          }
        } else {
          {
#line 1237
          tmp___13 = linecount;
#line 1237
          linecount ++;
#line 1237
          tmp___14 = strlen((char const   *)result);
#line 1237
          sprintf((char */* __restrict  */)(result + tmp___14), (char const   */* __restrict  */)"\";\n%s*%u=\"",
                  tagbase, tmp___13);
          }
        }
      }
#line 1244
      if (! fieldspec->langinfo) {
#line 1244
        goto _L;
      } else {
        {
#line 1244
        tmp___17 = __ctype_b_loc();
        }
#line 1244
        if ((int const   )*(*tmp___17 + (int )fieldspec->name[pos___0]) & 8) {
#line 1244
          goto _L;
        } else
#line 1244
        if (singquote < 2) {
          _L: /* CIL Label */ 
#line 1246
          if ((int )fieldspec->name[pos___0] == 39) {
#line 1247
            singquote ++;
          }
#line 1248
          linelen ++;
#line 1249
          remain___0 --;
#line 1250
          if (remain___0 <= 1) {
#line 1251
            return (1);
          }
          {
#line 1252
          tmp___15 = strlen((char const   *)result);
#line 1252
          sprintf((char */* __restrict  */)(result + tmp___15), (char const   */* __restrict  */)"%c",
                  (int )fieldspec->name[pos___0]);
          }
        } else {
#line 1256
          linelen += 3;
#line 1257
          remain___0 -= 3;
#line 1258
          if (remain___0 <= 1) {
#line 1259
            return (1);
          }
          {
#line 1260
          tmp___16 = strlen((char const   *)result);
#line 1260
          sprintf((char */* __restrict  */)(result + tmp___16), (char const   */* __restrict  */)"%%%02X",
                  (int )((unsigned char )fieldspec->name[pos___0]));
          }
        }
      }
#line 1224
      pos___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1264
    if (! fieldspec->langinfo) {
#line 1266
      remain___0 --;
#line 1267
      if (remain___0 <= 1) {
#line 1268
        return (1);
      }
      {
#line 1269
      strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"\"");
      }
    }
#line 1271
    return (0);
  } else {
#line 1276
    return (1);
  }
}
}
#line 1288 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int position_html(FILE *source , FILE *dest ) 
{ 
  char *tag ;
  char linebuf[512] ;
  char taglist[512] ;
  long dump_size ;
  long source_start ;
  long source_htmlspot ;
  char *tagstart ;
  char *tagend ;
  char fulltag[512] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *dump_buf ;
  void *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 1290
  tag = (char *)((void *)0);
#line 1296
  source_start = ftell(source);
  }
#line 1297
  if (source_start == -1L) {
#line 1298
    return (-1);
  }
  {
#line 1299
  source_htmlspot = source_start;
#line 1300
  strcpy((char */* __restrict  */)(taglist), (char const   */* __restrict  */)(configuration.htmlwarn_pos));
#line 1301
  tag = strtok((char */* __restrict  */)(taglist), (char const   */* __restrict  */)"\t, \n");
  }
  {
#line 1302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1302
    if (tag) {
      {
#line 1302
      tmp___2 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)source);
      }
#line 1302
      if (! tmp___2) {
#line 1302
        goto while_break;
      }
    } else {
#line 1302
      goto while_break;
    }
    {
#line 1306
    sprintf((char */* __restrict  */)(fulltag), (char const   */* __restrict  */)"<%s",
            tag);
#line 1307
    tagstart = stristr((char const   *)(linebuf), (char const   *)(fulltag));
    }
#line 1307
    if (tagstart) {
      {
#line 1307
      tagend = strchr((char const   *)tagstart, '>');
      }
#line 1307
      if (tagend) {
        {
#line 1310
        source_htmlspot = ftell(source);
        }
#line 1311
        if (source_htmlspot == -1L) {
#line 1312
          return (-1);
        }
        {
#line 1313
        tmp = strlen((char const   *)(linebuf));
#line 1313
        source_htmlspot = (long )((((size_t )source_htmlspot - tmp) + (size_t )(tagend - linebuf)) + 1UL);
#line 1314
        tmp___0 = fseek(source, source_htmlspot, 0);
        }
#line 1314
        if (tmp___0 != 0) {
#line 1315
          return (-1);
        }
        {
#line 1316
        tag = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\t, \n");
        }
      }
    }
    {
#line 1318
    tmp___1 = strncasecmp((char const   *)(linebuf), "Content-Type:", sizeof("Content-Type:") - 1UL);
    }
#line 1318
    if (tmp___1 == 0) {
#line 1319
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1322
  tmp___3 = fseek(source, source_start, 0);
  }
#line 1322
  if (tmp___3 != 0) {
#line 1323
    return (-1);
  }
#line 1324
  dump_size = source_htmlspot - source_start;
#line 1325
  if (dump_size > 0L) {
    {
#line 1327
    tmp___4 = calloc((size_t )1, (size_t )(1L + dump_size));
#line 1327
    dump_buf = (char *)tmp___4;
    }
#line 1328
    if (! dump_buf) {
#line 1329
      return (-1);
    }
    {
#line 1330
    tmp___5 = fread((void */* __restrict  */)dump_buf, (size_t )dump_size, (size_t )1,
                    (FILE */* __restrict  */)source);
    }
#line 1330
    if (tmp___5 < 1UL) {
#line 1331
      return (-1);
    }
    {
#line 1332
    fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"%s",
            dump_buf);
#line 1333
    free((void *)dump_buf);
    }
  }
#line 1335
  return (0);
}
}
#line 1342 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
void kill_exit(char const   *text ) 
{ 
  char linebuf[1000] ;
  char *tmp ;

  {
  {
#line 1346
  taking_action(text);
  }
  {
#line 1347
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1347
    tmp = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)stdin);
    }
#line 1347
    if (! tmp) {
#line 1347
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1349
  exit(excode);
  }
}
}
#line 1359 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
void taking_action(char const   *caughtfile ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 1361
  if (verbose) {
    {
#line 1362
    tmp = act2str(configuration.action);
#line 1362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s \"%s\" in %s",
            tmp, caughtfile, messageid);
    }
  }
#line 1363
  if (configuration.use_syslog == 2) {
    {
#line 1366
    openlog("renattach", 1, 2 << 3);
#line 1367
    tmp___0 = act2str(configuration.action);
#line 1367
    syslog(4, "%s \"%s\" in %s", tmp___0, caughtfile, messageid);
#line 1368
    closelog();
    }
  }
#line 1372
  if (configuration.action != 4) {
#line 1373
    filtcount ++;
  }
#line 1374
  if (configuration.action == 2) {
#line 1375
    del_count ++;
  } else
#line 1376
  if (configuration.action == 1) {
#line 1377
    ren_count ++;
  }
#line 1379
  configuration.action = configuration.def_act;
#line 1380
  return;
}
}
#line 1387 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
void not_taking_action(char const   *reason , char const   *missedfile ) 
{ 


  {
#line 1389
  if (verbose) {
    {
#line 1390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Not acting on file - %s: %s\n",
            reason, missedfile);
    }
  }
#line 1391
  if (configuration.use_syslog == 2) {
    {
#line 1394
    openlog("renattach", 1, 2 << 3);
#line 1395
    syslog(4, "WARNING: Not acting on file - %s: %s", reason, missedfile);
#line 1396
    closelog();
    }
  }
#line 1400
  configuration.action = configuration.def_act;
#line 1401
  return;
}
}
#line 1411 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int explain_subject(FILE *dest , char *oldsubject ) 
{ 
  char *therest ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1413
  therest = (char *)"\n";
#line 1414
  if (oldsubject) {
#line 1415
    therest = oldsubject;
  }
#line 1417
  if (ban_count) {
#line 1417
    if (configuration.subj_banned[0]) {
      {
#line 1419
      tmp = strcmp((char const   *)(configuration.subj_banned), "#");
      }
#line 1419
      if (tmp == 0) {
#line 1420
        return (0);
      } else {
        {
#line 1422
        fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"Subject: %s%s",
                configuration.subj_banned, therest);
        }
      }
    } else {
#line 1417
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1424
  if (exe_count) {
#line 1424
    if (configuration.subj_exec[0]) {
      {
#line 1426
      tmp___0 = strcmp((char const   *)(configuration.subj_exec), "#");
      }
#line 1426
      if (tmp___0 == 0) {
#line 1427
        return (0);
      } else {
        {
#line 1429
        fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"Subject: %s%s",
                configuration.subj_exec, therest);
        }
      }
    } else {
#line 1424
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1431
  if (del_count) {
#line 1431
    if (configuration.subj_deleted[0]) {
      {
#line 1433
      tmp___1 = strcmp((char const   *)(configuration.subj_deleted), "#");
      }
#line 1433
      if (tmp___1 == 0) {
#line 1434
        return (0);
      } else {
        {
#line 1436
        fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"Subject: %s%s",
                configuration.subj_deleted, therest);
        }
      }
    } else {
#line 1431
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1438
  if (ren_count) {
#line 1438
    if (configuration.subj_renamed[0]) {
      {
#line 1440
      tmp___2 = strcmp((char const   *)(configuration.subj_renamed), "#");
      }
#line 1440
      if (tmp___2 == 0) {
#line 1441
        return (0);
      } else {
        {
#line 1443
        fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"Subject: %s%s",
                configuration.subj_renamed, therest);
        }
      }
    } else {
#line 1438
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1445
  if (filtcount) {
#line 1445
    if (configuration.add_subject[0]) {
      {
#line 1447
      tmp___3 = strcmp((char const   *)(configuration.add_subject), "#");
      }
#line 1447
      if (tmp___3 == 0) {
#line 1448
        return (0);
      } else {
        {
#line 1450
        fprintf((FILE */* __restrict  */)dest, (char const   */* __restrict  */)"Subject: %s%s",
                configuration.add_subject, therest);
        }
      }
    } else {
#line 1453
      return (0);
    }
  } else {
#line 1453
    return (0);
  }
#line 1455
  return (1);
}
}
#line 1462 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
void abnormalproc(int sig ) 
{ 


  {
#line 1464
  if (tempfile) {
    {
#line 1465
    fclose(tempfile);
    }
  }
  {
#line 1466
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Caught SIGPIPE; pipe stopped accepting data\n");
#line 1467
  exit(75);
  }
}
}
#line 1478 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
FILE *openpipe(char **args , pid_t *childpid ) 
{ 
  FILE *command ;
  int cmdpipe[2] ;
  int tmp ;
  pid_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1483
  tmp = pipe((int *)(cmdpipe));
  }
#line 1483
  if (tmp != 0) {
#line 1484
    return ((FILE *)((void *)0));
  }
  {
#line 1485
  tmp___0 = fork();
#line 1485
  *childpid = tmp___0;
  }
  {
#line 1487
  if (tmp___0 == -1) {
#line 1487
    goto case_neg_1;
  }
#line 1492
  if (tmp___0 == 0) {
#line 1492
    goto case_0;
  }
#line 1501
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 1488
  close(cmdpipe[0]);
#line 1489
  close(cmdpipe[1]);
  }
#line 1490
  return ((FILE *)((void *)0));
  case_0: /* CIL Label */ 
  {
#line 1493
  tmp___1 = dup2(cmdpipe[0], 0);
  }
#line 1493
  if (tmp___1 == -1) {
    {
#line 1494
    _exit(-1);
    }
  }
  {
#line 1495
  close(cmdpipe[0]);
#line 1496
  close(cmdpipe[1]);
#line 1497
  execv((char const   *)*(args + 0), (char * const  *)args);
#line 1498
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error executing pipe command: %s\n",
          *(args + 0));
#line 1499
  _exit(-1);
  }
  switch_default: /* CIL Label */ 
  {
#line 1502
  close(cmdpipe[0]);
#line 1503
  command = fdopen(cmdpipe[1], "w");
  }
#line 1504
  if (command) {
#line 1505
    return (command);
  } else {
    {
#line 1508
    close(cmdpipe[1]);
    }
#line 1509
    return ((FILE *)((void *)0));
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1521 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.c"
int closepipe(FILE *command , pid_t childpid , int *exitcode ) 
{ 
  int status ;
  int tmp ;
  __pid_t tmp___0 ;
  union __anonunion_53 __constr_expr_0 ;
  union __anonunion_54 __constr_expr_1 ;

  {
  {
#line 1524
  tmp = fclose(command);
  }
#line 1524
  if (tmp != 0) {
    {
#line 1526
    waitpid(childpid, & status, 0);
    }
#line 1527
    return (-1);
  }
  {
#line 1529
  tmp___0 = waitpid(childpid, & status, 0);
  }
#line 1529
  if (tmp___0 == -1) {
#line 1530
    return (-1);
  }
#line 1531
  __constr_expr_1.__in = status;
#line 1531
  if ((__constr_expr_1.__i & 127) == 0) {
#line 1533
    __constr_expr_0.__in = status;
#line 1533
    *exitcode = (__constr_expr_0.__i & 65280) >> 8;
#line 1534
    return (0);
  } else {
#line 1537
    return (-1);
  }
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/renattach.h"
char const   *opt2str(int state ) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/settings.c"
int tokenize_list(char const   *thelist , int verbose___0 ) 
{ 
  char *tmpbuf ;
  char *token ;
  int count ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 47
  count = 0;
#line 49
  tmp = strlen(thelist);
#line 49
  tmp___0 = malloc(tmp + 1UL);
#line 49
  tmpbuf = (char *)tmp___0;
#line 50
  strcpy((char */* __restrict  */)tmpbuf, (char const   */* __restrict  */)thelist);
#line 51
  token = strtok((char */* __restrict  */)tmpbuf, (char const   */* __restrict  */)"\t, \n");
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! token) {
#line 52
      goto while_break;
    }
#line 54
    if (verbose___0) {
#line 56
      if (count) {
        {
#line 57
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"|%s",
                token);
        }
      } else {
        {
#line 59
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                token);
        }
      }
    }
    {
#line 61
    count ++;
#line 62
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\t, \n");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 64
  free((void *)tmpbuf);
  }
#line 65
  return (count);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/settings.c"
int parse_conf(struct config_opts *options ) 
{ 
  int linecount ;
  char confline[512] ;
  char directive[512] ;
  char parameter[512] ;
  FILE *config ;
  int syntax_error ;
  int state ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;

  {
#line 75
  linecount = 0;
#line 78
  config = (FILE *)((void *)0);
#line 80
  if ((unsigned long )options->config_file == (unsigned long )((void *)0)) {
    {
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Configuration file: undefined\n");
    }
#line 83
    return (255);
  }
  {
#line 86
  config = fopen((char const   */* __restrict  */)options->config_file, (char const   */* __restrict  */)"r");
  }
#line 87
  if (! config) {
    {
#line 89
    perror((char const   *)options->config_file);
    }
#line 90
    return (255);
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp___25 = fgets((char */* __restrict  */)(confline), (int )sizeof(confline),
                     (FILE */* __restrict  */)config);
    }
#line 93
    if (! tmp___25) {
#line 93
      goto while_break;
    }
    {
#line 95
    syntax_error = 0;
#line 96
    linecount ++;
#line 98
    trim_leading(confline);
#line 99
    trim_trailing(confline);
    }
#line 101
    if ((int )confline[0] == 35) {
#line 102
      goto while_continue;
    } else
#line 101
    if ((int )confline[0] == 13) {
#line 102
      goto while_continue;
    } else
#line 101
    if ((int )confline[0] == 10) {
#line 102
      goto while_continue;
    }
    {
#line 103
    tmp___24 = sscanf((char const   */* __restrict  */)(confline), (char const   */* __restrict  */)"%[^\t =]%*[\t =]%[^\r\n]",
                      directive, parameter);
    }
#line 103
    if (tmp___24 == 2) {
      {
#line 105
      state = 0;
#line 106
      tmp___1 = strlen("yes");
#line 106
      tmp___2 = strncasecmp((char const   *)(parameter), "yes", tmp___1);
      }
#line 106
      if (tmp___2 == 0) {
#line 108
        state = 2;
      } else
#line 106
      if ((int )parameter[0] == 49) {
#line 108
        state = 2;
      } else {
        {
#line 109
        tmp = strlen("no");
#line 109
        tmp___0 = strncasecmp((char const   *)(parameter), "no", tmp);
        }
#line 109
        if (tmp___0 == 0) {
#line 111
          state = 1;
        } else
#line 109
        if ((int )parameter[0] == 48) {
#line 111
          state = 1;
        }
      }
      {
#line 113
      tmp___23 = strcasecmp((char const   *)(directive), "delete_exe");
      }
#line 113
      if (tmp___23 == 0) {
#line 113
        if (state) {
#line 114
          options->delete_exe = state;
        } else {
#line 113
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
        {
#line 115
        tmp___22 = strcasecmp((char const   *)(directive), "kill_exe");
        }
#line 115
        if (tmp___22 == 0) {
#line 115
          if (state) {
#line 116
            options->kill_exe = state;
          } else {
#line 115
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
          {
#line 117
          tmp___21 = strcasecmp((char const   *)(directive), "search_zip");
          }
#line 117
          if (tmp___21 == 0) {
#line 117
            if (state) {
#line 118
              options->search_zip = state;
            } else {
#line 117
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
            {
#line 119
            tmp___20 = strcasecmp((char const   *)(directive), "pass_contentid");
            }
#line 119
            if (tmp___20 == 0) {
#line 119
              if (state) {
#line 120
                options->pass_contentid = state;
              } else {
#line 119
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */ 
              {
#line 121
              tmp___19 = strcasecmp((char const   *)(directive), "full_rename");
              }
#line 121
              if (tmp___19 == 0) {
#line 121
                if (state) {
#line 122
                  options->full_rename = state;
                } else {
#line 121
                  goto _L___0;
                }
              } else {
                _L___0: /* CIL Label */ 
                {
#line 123
                tmp___18 = strcasecmp((char const   *)(directive), "use_syslog");
                }
#line 123
                if (tmp___18 == 0) {
#line 123
                  if (state) {
#line 124
                    options->use_syslog = state;
                  } else {
#line 123
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  {
#line 125
                  tmp___17 = strcasecmp((char const   *)(directive), "generic_name");
                  }
#line 125
                  if (tmp___17 == 0) {
                    {
#line 126
                    strcpy((char */* __restrict  */)(options->generic_name), (char const   */* __restrict  */)(parameter));
                    }
                  } else {
                    {
#line 127
                    tmp___16 = strcasecmp((char const   *)(directive), "new_extension");
                    }
#line 127
                    if (tmp___16 == 0) {
                      {
#line 128
                      strcpy((char */* __restrict  */)(options->new_extension), (char const   */* __restrict  */)(parameter));
                      }
                    } else {
                      {
#line 129
                      tmp___15 = strcasecmp((char const   *)(directive), "new_mime_type");
                      }
#line 129
                      if (tmp___15 == 0) {
                        {
#line 130
                        strcpy((char */* __restrict  */)(options->new_mime_type),
                               (char const   */* __restrict  */)(parameter));
                        }
                      } else {
                        {
#line 131
                        tmp___14 = strcasecmp((char const   *)(directive), "subj_banned");
                        }
#line 131
                        if (tmp___14 == 0) {
                          {
#line 132
                          strcpy((char */* __restrict  */)(options->subj_banned),
                                 (char const   */* __restrict  */)(parameter));
                          }
                        } else {
                          {
#line 133
                          tmp___13 = strcasecmp((char const   *)(directive), "subj_exec");
                          }
#line 133
                          if (tmp___13 == 0) {
                            {
#line 134
                            strcpy((char */* __restrict  */)(options->subj_exec),
                                   (char const   */* __restrict  */)(parameter));
                            }
                          } else {
                            {
#line 135
                            tmp___12 = strcasecmp((char const   *)(directive), "subj_deleted");
                            }
#line 135
                            if (tmp___12 == 0) {
                              {
#line 136
                              strcpy((char */* __restrict  */)(options->subj_deleted),
                                     (char const   */* __restrict  */)(parameter));
                              }
                            } else {
                              {
#line 137
                              tmp___11 = strcasecmp((char const   *)(directive), "subj_renamed");
                              }
#line 137
                              if (tmp___11 == 0) {
                                {
#line 138
                                strcpy((char */* __restrict  */)(options->subj_renamed),
                                       (char const   */* __restrict  */)(parameter));
                                }
                              } else {
                                {
#line 139
                                tmp___10 = strcasecmp((char const   *)(directive),
                                                      "add_subject");
                                }
#line 139
                                if (tmp___10 == 0) {
                                  {
#line 140
                                  strcpy((char */* __restrict  */)(options->add_subject),
                                         (char const   */* __restrict  */)(parameter));
                                  }
                                } else {
                                  {
#line 141
                                  tmp___9 = strcasecmp((char const   *)(directive),
                                                       "htmlwarn_pos");
                                  }
#line 141
                                  if (tmp___9 == 0) {
                                    {
#line 142
                                    strcpy((char */* __restrict  */)(options->htmlwarn_pos),
                                           (char const   */* __restrict  */)(parameter));
                                    }
                                  } else {
                                    {
#line 143
                                    tmp___8 = strcasecmp((char const   *)(directive),
                                                         "warning_text");
                                    }
#line 143
                                    if (tmp___8 == 0) {
                                      {
#line 144
                                      expand_list(& options->warning_text, (char const   *)(parameter),
                                                  "\n");
                                      }
                                    } else {
                                      {
#line 145
                                      tmp___7 = strcasecmp((char const   *)(directive),
                                                           "warning_html");
                                      }
#line 145
                                      if (tmp___7 == 0) {
                                        {
#line 146
                                        expand_list(& options->warning_html, (char const   *)(parameter),
                                                    "\n");
                                        }
                                      } else {
                                        {
#line 147
                                        tmp___6 = strcasecmp((char const   *)(directive),
                                                             "add_header");
                                        }
#line 147
                                        if (tmp___6 == 0) {
                                          {
#line 148
                                          expand_list(& options->add_header, (char const   *)(parameter),
                                                      "\n");
                                          }
                                        } else {
                                          {
#line 149
                                          tmp___5 = strcasecmp((char const   *)(directive),
                                                               "banned_files");
                                          }
#line 149
                                          if (tmp___5 == 0) {
                                            {
#line 150
                                            expand_list(& options->banned_files, (char const   *)(parameter),
                                                        "\n");
                                            }
                                          } else {
                                            {
#line 151
                                            tmp___4 = strcasecmp((char const   *)(directive),
                                                                 "badlist");
                                            }
#line 151
                                            if (tmp___4 == 0) {
                                              {
#line 152
                                              expand_list(& options->badlist, (char const   *)(parameter),
                                                          "\n");
                                              }
                                            } else {
                                              {
#line 153
                                              tmp___3 = strcasecmp((char const   *)(directive),
                                                                   "goodlist");
                                              }
#line 153
                                              if (tmp___3 == 0) {
                                                {
#line 154
                                                expand_list(& options->goodlist, (char const   *)(parameter),
                                                            "\n");
                                                }
                                              } else {
#line 156
                                                syntax_error = 1;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
#line 159
      syntax_error = 1;
    }
#line 161
    if (syntax_error) {
      {
#line 163
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Configuration file syntax error, line %d: %s\n",
              linecount, confline);
#line 164
      fclose(config);
      }
#line 165
      return (255);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  fclose(config);
  }
#line 170
  return (0);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/settings.c"
void directive_defaults(struct config_opts *options ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 180
  if (options->delete_exe == 0) {
#line 181
    options->delete_exe = 2;
  }
#line 182
  if (options->kill_exe == 0) {
#line 183
    options->kill_exe = 1;
  }
#line 184
  if (options->search_zip == 0) {
#line 185
    options->search_zip = 1;
  }
#line 186
  if (options->pass_contentid == 0) {
#line 187
    options->pass_contentid = 1;
  }
#line 188
  if (options->full_rename == 0) {
#line 189
    options->full_rename = 2;
  }
#line 190
  if (options->use_syslog == 0) {
#line 191
    options->use_syslog = 1;
  }
#line 192
  if ((int )options->generic_name[0] == 0) {
    {
#line 193
    strcpy((char */* __restrict  */)(options->generic_name), (char const   */* __restrict  */)"filename");
    }
  }
#line 194
  if ((int )options->new_extension[0] == 0) {
    {
#line 195
    strcpy((char */* __restrict  */)(options->new_extension), (char const   */* __restrict  */)"bad");
    }
  }
#line 196
  if ((int )options->new_mime_type[0] == 0) {
    {
#line 197
    strcpy((char */* __restrict  */)(options->new_mime_type), (char const   */* __restrict  */)"application/unknown");
    }
  }
#line 198
  if ((int )options->subj_banned[0] == 0) {
    {
#line 199
    strcpy((char */* __restrict  */)(options->subj_banned), (char const   */* __restrict  */)"");
    }
  }
#line 200
  if ((int )options->subj_exec[0] == 0) {
    {
#line 201
    strcpy((char */* __restrict  */)(options->subj_exec), (char const   */* __restrict  */)"");
    }
  }
#line 202
  if ((int )options->subj_deleted[0] == 0) {
    {
#line 203
    strcpy((char */* __restrict  */)(options->subj_deleted), (char const   */* __restrict  */)"");
    }
  }
#line 204
  if ((int )options->subj_renamed[0] == 0) {
    {
#line 205
    strcpy((char */* __restrict  */)(options->subj_renamed), (char const   */* __restrict  */)"");
    }
  }
#line 206
  if ((int )options->add_subject[0] == 0) {
    {
#line 207
    strcpy((char */* __restrict  */)(options->add_subject), (char const   */* __restrict  */)"[filtered]");
    }
  }
#line 208
  if ((int )options->htmlwarn_pos[0] == 0) {
    {
#line 209
    strcpy((char */* __restrict  */)(options->htmlwarn_pos), (char const   */* __restrict  */)"html, body");
    }
  }
#line 210
  if ((unsigned long )options->warning_text == (unsigned long )((void *)0)) {
    {
#line 211
    expand_list(& options->warning_text, "", "\n");
    }
  } else
#line 210
  if ((int )*(options->warning_text + 0) == 0) {
    {
#line 211
    expand_list(& options->warning_text, "", "\n");
    }
  }
#line 212
  if ((unsigned long )options->warning_html == (unsigned long )((void *)0)) {
    {
#line 213
    expand_list(& options->warning_html, "", "\n");
    }
  } else
#line 212
  if ((int )*(options->warning_html + 0) == 0) {
    {
#line 213
    expand_list(& options->warning_html, "", "\n");
    }
  }
#line 214
  if ((unsigned long )options->add_header == (unsigned long )((void *)0)) {
    {
#line 215
    expand_list(& options->add_header, "", "\n");
    }
  } else
#line 214
  if ((int )*(options->add_header + 0) == 0) {
    {
#line 215
    expand_list(& options->add_header, "", "\n");
    }
  }
#line 216
  if ((unsigned long )options->banned_files == (unsigned long )((void *)0)) {
    {
#line 217
    expand_list(& options->banned_files, "", "\n");
    }
  } else {
    {
#line 216
    tmp = tokenize_list((char const   *)options->banned_files, 0);
    }
#line 216
    if (tmp == 0) {
      {
#line 217
      expand_list(& options->banned_files, "", "\n");
      }
    }
  }
#line 218
  if ((unsigned long )options->goodlist == (unsigned long )((void *)0)) {
    {
#line 219
    expand_list(& options->goodlist, "DOC, PDF, RTF, SXC, SXW, TXT, ZIP", "\n");
    }
  } else {
    {
#line 218
    tmp___0 = tokenize_list((char const   *)options->goodlist, 0);
    }
#line 218
    if (tmp___0 == 0) {
      {
#line 219
      expand_list(& options->goodlist, "DOC, PDF, RTF, SXC, SXW, TXT, ZIP", "\n");
      }
    }
  }
#line 220
  if ((unsigned long )options->badlist == (unsigned long )((void *)0)) {
    {
#line 221
    expand_list(& options->badlist, "ADE, ADP, BAS, BAT, CHM, CMD, COM, CPL, CRT, EML, EXE, HLP, HTA, HTM, HTML, INF, INS, ISP, JS, JSE, LNK, MDB, MDE, MSC, MSH, MSI, MSP, MST, NWS, OCX, PCD, PIF, REG, SCR, SCT, SHB, SHS, URL, VB, VBE, VBS, WSC, WSF, WSH",
                "\n");
    }
  } else {
    {
#line 220
    tmp___1 = tokenize_list((char const   *)options->badlist, 0);
    }
#line 220
    if (tmp___1 == 0) {
      {
#line 221
      expand_list(& options->badlist, "ADE, ADP, BAS, BAT, CHM, CMD, COM, CPL, CRT, EML, EXE, HLP, HTA, HTM, HTML, INF, INS, ISP, JS, JSE, LNK, MDB, MDE, MSC, MSH, MSI, MSP, MST, NWS, OCX, PCD, PIF, REG, SCR, SCT, SHB, SHS, URL, VB, VBE, VBS, WSC, WSF, WSH",
                  "\n");
      }
    }
  }
#line 222
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/settings.c"
void show_configuration(struct config_opts *options ) 
{ 
  int arg ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
  {
#line 231
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Configuration file: \n  ");
  }
#line 232
  if (options->config_file) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            options->config_file);
    }
  } else {
    {
#line 235
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"undefined\n");
    }
  }
  {
#line 237
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Writing output to: \n  ");
  }
#line 238
  if (options->pipe_cmd) {
    {
#line 240
    arg = 0;
#line 241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"{");
    }
    {
#line 242
    while (1) {
      while_continue: /* CIL Label */ ;
#line 242
      if (! *(options->pipe_cmd + arg)) {
#line 242
        goto while_break;
      }
#line 244
      if (arg) {
        {
#line 244
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"|");
        }
      }
      {
#line 245
      tmp = arg;
#line 245
      arg ++;
#line 245
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
              *(options->pipe_cmd + tmp));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"}\n");
    }
  } else {
    {
#line 250
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stdout\n");
    }
  }
  {
#line 253
  tmp___0 = mode2str(options->mode);
#line 253
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Filter mode: \n  %s\n",
          tmp___0);
#line 256
  tmp___1 = act2str(options->action);
#line 256
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Filter action: \n  %s\n",
          tmp___1);
#line 258
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Configuration directives:\n");
#line 260
  tmp___2 = opt2str(options->delete_exe);
#line 260
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  delete_exe: %s\n",
          tmp___2);
#line 261
  tmp___3 = opt2str(options->kill_exe);
#line 261
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  kill_exe: %s\n",
          tmp___3);
#line 262
  tmp___4 = opt2str(options->search_zip);
#line 262
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  search_zip: %s\n",
          tmp___4);
#line 263
  tmp___5 = opt2str(options->pass_contentid);
#line 263
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  pass_contentid: %s\n",
          tmp___5);
#line 264
  tmp___6 = opt2str(options->full_rename);
#line 264
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  full_rename: %s\n",
          tmp___6);
#line 265
  tmp___7 = opt2str(options->use_syslog);
#line 265
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  use_syslog: %s\n",
          tmp___7);
#line 266
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  generic_name: \"%s\"\n",
          options->generic_name);
#line 267
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  new_extension: \"%s\"\n",
          options->new_extension);
#line 268
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  new_mime_type: \"%s\"\n",
          options->new_mime_type);
#line 269
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  subj_banned: \"%s\"\n",
          options->subj_banned);
#line 270
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  subj_exec: \"%s\"\n",
          options->subj_exec);
#line 271
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  subj_deleted: \"%s\"\n",
          options->subj_deleted);
#line 272
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  subj_renamed: \"%s\"\n",
          options->subj_renamed);
#line 273
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  add_subject: \"%s\"\n",
          options->add_subject);
#line 274
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  htmlwarn_pos: \"%s\"\n",
          options->htmlwarn_pos);
#line 275
  tmp___8 = strlen((char const   *)options->warning_text);
#line 275
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  warning_text: %d bytes,\n%s\n",
          (int )tmp___8, options->warning_text);
#line 277
  tmp___9 = strlen((char const   *)options->warning_html);
#line 277
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  warning_html: %d bytes,\n%s\n",
          (int )tmp___9, options->warning_html);
#line 279
  tmp___10 = strlen((char const   *)options->add_header);
#line 279
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  add_header: %d bytes,\n%s\n",
          (int )tmp___10, options->add_header);
#line 281
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  banned_files: {");
#line 282
  tokenize_list((char const   *)options->banned_files, 1);
#line 283
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"}\n  badlist: {");
#line 284
  tokenize_list((char const   *)options->badlist, 1);
#line 285
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"}\n  goodlist: {");
#line 286
  tokenize_list((char const   *)options->goodlist, 1);
#line 287
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"}\n");
  }
#line 288
  return;
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/settings.c"
char const   *opt2str(int state ) 
{ 


  {
#line 296
  if (state == 1) {
#line 297
    return ("no");
  } else
#line 298
  if (state == 2) {
#line 299
    return ("yes");
  } else {
#line 301
    return ("undefined");
  }
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/settings.c"
char const   *mode2str(int mode ) 
{ 


  {
#line 310
  if (mode == 1) {
#line 311
    return ("all");
  } else
#line 312
  if (mode == 2) {
#line 313
    return ("badlist");
  } else
#line 314
  if (mode == 3) {
#line 315
    return ("goodlist");
  } else {
#line 317
    return ("undefined");
  }
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/renattach-1.2.4/src/settings.c"
char const   *act2str(int action ) 
{ 


  {
  {
#line 328
  if (action == 1) {
#line 328
    goto case_1;
  }
#line 331
  if (action == 2) {
#line 331
    goto case_2;
  }
#line 334
  if (action == 3) {
#line 334
    goto case_3;
  }
#line 337
  if (action == 4) {
#line 337
    goto case_4;
  }
#line 340
  goto switch_default;
  case_1: /* CIL Label */ 
#line 329
  return ("rename");
  case_2: /* CIL Label */ 
#line 332
  return ("delete");
  case_3: /* CIL Label */ 
#line 335
  return ("kill");
  case_4: /* CIL Label */ 
#line 338
  return ("skip");
  switch_default: /* CIL Label */ 
#line 341
  return ("undefined");
  switch_break: /* CIL Label */ ;
  }
}
}
