/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 140 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
struct __anonstruct_mp4ff_callback_t_25 {
   uint32_t (*read)(void *user_data , void *buffer , uint32_t length ) ;
   uint32_t (*write)(void *udata , void *buffer , uint32_t length ) ;
   uint32_t (*seek)(void *user_data , uint64_t position ) ;
   uint32_t (*truncate)(void *user_data ) ;
   void *user_data ;
};
#line 140 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
typedef struct __anonstruct_mp4ff_callback_t_25 mp4ff_callback_t;
#line 151 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
struct __anonstruct_mp4ff_tag_t_26 {
   char *item ;
   char *value ;
};
#line 151 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
typedef struct __anonstruct_mp4ff_tag_t_26 mp4ff_tag_t;
#line 158 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
struct __anonstruct_mp4ff_metadata_t_27 {
   mp4ff_tag_t *tags ;
   uint32_t count ;
};
#line 158 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
typedef struct __anonstruct_mp4ff_metadata_t_27 mp4ff_metadata_t;
#line 165 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
struct __anonstruct_mp4ff_track_t_28 {
   int32_t type ;
   int32_t channelCount ;
   int32_t sampleSize ;
   uint16_t sampleRate ;
   int32_t audioType ;
   int32_t stsd_entry_count ;
   int32_t stsz_sample_size ;
   int32_t stsz_sample_count ;
   int32_t *stsz_table ;
   int32_t stts_entry_count ;
   int32_t *stts_sample_count ;
   int32_t *stts_sample_delta ;
   int32_t stsc_entry_count ;
   int32_t *stsc_first_chunk ;
   int32_t *stsc_samples_per_chunk ;
   int32_t *stsc_sample_desc_index ;
   int32_t stco_entry_count ;
   int32_t *stco_chunk_offset ;
   int32_t ctts_entry_count ;
   int32_t *ctts_sample_count ;
   int32_t *ctts_sample_offset ;
   uint8_t *decoderConfig ;
   int32_t decoderConfigLen ;
   uint32_t maxBitrate ;
   uint32_t avgBitrate ;
   uint32_t timeScale ;
   uint64_t duration ;
};
#line 165 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
typedef struct __anonstruct_mp4ff_track_t_28 mp4ff_track_t;
#line 214 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
struct __anonstruct_mp4ff_t_29 {
   mp4ff_callback_t *stream ;
   int64_t current_position ;
   int32_t moov_read ;
   uint64_t moov_offset ;
   uint64_t moov_size ;
   uint8_t last_atom ;
   uint64_t file_size ;
   int32_t time_scale ;
   int32_t duration ;
   int32_t total_tracks ;
   mp4ff_track_t *track[1024] ;
   mp4ff_metadata_t tags ;
};
#line 214 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
typedef struct __anonstruct_mp4ff_t_29 mp4ff_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 80 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 154 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
enum __anonenum_ordering_25 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 194 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef signed char int8_t;
#line 43 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/audio.h"
struct __anonstruct_audio_file_27 {
   int toStdio ;
   int outputFormat ;
   FILE *sndfile ;
   unsigned int fileType ;
   unsigned long samplerate ;
   unsigned int bits_per_sample ;
   unsigned int channels ;
   unsigned long total_samples ;
   long channelMask ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/audio.h"
typedef struct __anonstruct_audio_file_27 audio_file;
#line 38 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
struct __anonstruct_membuffer_26 {
   void *data ;
   unsigned int written ;
   unsigned int allocated ;
   unsigned int error ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
typedef struct __anonstruct_membuffer_26 membuffer;
#line 207 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
struct __anonstruct_stdmeta_entry_27 {
   char const   *atom ;
   char const   *name ;
};
#line 207 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
typedef struct __anonstruct_stdmeta_entry_27 stdmeta_entry;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 142 "../include/neaacdec.h"
typedef void *NeAACDecHandle;
#line 144 "../include/neaacdec.h"
struct mp4AudioSpecificConfig {
   unsigned char objectTypeIndex ;
   unsigned char samplingFrequencyIndex ;
   unsigned long samplingFrequency ;
   unsigned char channelsConfiguration ;
   unsigned char frameLengthFlag ;
   unsigned char dependsOnCoreCoder ;
   unsigned short coreCoderDelay ;
   unsigned char extensionFlag ;
   unsigned char aacSectionDataResilienceFlag ;
   unsigned char aacScalefactorDataResilienceFlag ;
   unsigned char aacSpectralDataResilienceFlag ;
   unsigned char epConfig ;
   char sbr_present_flag ;
   char forceUpSampling ;
   char downSampledSBR ;
};
#line 144 "../include/neaacdec.h"
typedef struct mp4AudioSpecificConfig mp4AudioSpecificConfig;
#line 167 "../include/neaacdec.h"
struct NeAACDecConfiguration {
   unsigned char defObjectType ;
   unsigned long defSampleRate ;
   unsigned char outputFormat ;
   unsigned char downMatrix ;
   unsigned char useOldADTSFormat ;
   unsigned char dontUpSampleImplicitSBR ;
};
#line 167 "../include/neaacdec.h"
typedef struct NeAACDecConfiguration *NeAACDecConfigurationPtr;
#line 177 "../include/neaacdec.h"
struct NeAACDecFrameInfo {
   unsigned long bytesconsumed ;
   unsigned long samples ;
   unsigned char channels ;
   unsigned char error ;
   unsigned long samplerate ;
   unsigned char sbr ;
   unsigned char object_type ;
   unsigned char header_type ;
   unsigned char num_front_channels ;
   unsigned char num_side_channels ;
   unsigned char num_back_channels ;
   unsigned char num_lfe_channels ;
   unsigned char channel_position[64] ;
   unsigned char ps ;
};
#line 177 "../include/neaacdec.h"
typedef struct NeAACDecFrameInfo NeAACDecFrameInfo;
#line 55 "../common/mp4ff/mp4ff.h"
typedef void *mp4ff_t___0;
#line 76 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
struct __anonstruct_aac_buffer_27 {
   long bytes_into_buffer ;
   long bytes_consumed ;
   long file_offset ;
   unsigned char *buffer ;
   int at_eof ;
   FILE *infile ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
typedef struct __anonstruct_aac_buffer_27 aac_buffer;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 247 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
uint32_t mp4ff_read_int32(mp4ff_t *f ) ;
#line 248
uint32_t mp4ff_read_int24(mp4ff_t *f ) ;
#line 249
uint16_t mp4ff_read_int16(mp4ff_t *f ) ;
#line 250
uint8_t mp4ff_read_char(mp4ff_t *f ) ;
#line 253
int64_t mp4ff_position(mp4ff_t const   *f ) ;
#line 254
int32_t mp4ff_set_position(mp4ff_t *f , int64_t const   position ) ;
#line 256
char *mp4ff_read_string(mp4ff_t *f , uint32_t length ) ;
#line 263
uint64_t mp4ff_atom_read_header(mp4ff_t *f , uint8_t *atom_type , uint8_t *header_size ) ;
#line 288
static int32_t mp4ff_tag_add_field(mp4ff_metadata_t *tags , char const   *item , char const   *value ) ;
#line 290
static int32_t mp4ff_set_metadata_name(mp4ff_t *f , uint8_t const   atom_type , char **name ) ;
#line 291
static int32_t mp4ff_parse_tag(mp4ff_t *f , uint8_t const   parent_atom_type , int32_t const   size ) ;
#line 292
static int32_t mp4ff_meta_find_by_name(mp4ff_t const   *f , char const   *item , char **value ) ;
#line 293
int32_t mp4ff_parse_metadata(mp4ff_t *f , int32_t const   size ) ;
#line 294
int32_t mp4ff_tag_delete(mp4ff_metadata_t *tags ) ;
#line 295
int32_t mp4ff_meta_get_num_items(mp4ff_t const   *f ) ;
#line 296
int32_t mp4ff_meta_get_by_index(mp4ff_t const   *f , uint32_t index___0 , char **item ,
                                char **value ) ;
#line 298
int32_t mp4ff_meta_get_title(mp4ff_t const   *f , char **value ) ;
#line 299
int32_t mp4ff_meta_get_artist(mp4ff_t const   *f , char **value ) ;
#line 300
int32_t mp4ff_meta_get_writer(mp4ff_t const   *f , char **value ) ;
#line 301
int32_t mp4ff_meta_get_album(mp4ff_t const   *f , char **value ) ;
#line 302
int32_t mp4ff_meta_get_date(mp4ff_t const   *f , char **value ) ;
#line 303
int32_t mp4ff_meta_get_tool(mp4ff_t const   *f , char **value ) ;
#line 304
int32_t mp4ff_meta_get_comment(mp4ff_t const   *f , char **value ) ;
#line 305
int32_t mp4ff_meta_get_genre(mp4ff_t const   *f , char **value ) ;
#line 306
int32_t mp4ff_meta_get_track(mp4ff_t const   *f , char **value ) ;
#line 307
int32_t mp4ff_meta_get_disc(mp4ff_t const   *f , char **value ) ;
#line 308
int32_t mp4ff_meta_get_compilation(mp4ff_t const   *f , char **value ) ;
#line 309
int32_t mp4ff_meta_get_tempo(mp4ff_t const   *f , char **value ) ;
#line 310
int32_t mp4ff_meta_get_coverart(mp4ff_t const   *f , char **value ) ;
#line 336
uint32_t mp4ff_meta_genre_to_index(char const   *genrestr ) ;
#line 337
char const   *mp4ff_meta_index_to_genre(uint32_t idx ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
static int32_t mp4ff_tag_add_field(mp4ff_metadata_t *tags , char const   *item , char const   *value ) 
{ 
  void *backup ;
  void *tmp ;

  {
#line 42
  backup = (void *)tags->tags;
#line 44
  if (! item) {
#line 44
    return (0);
  } else
#line 44
  if (item) {
#line 44
    if (! *item) {
#line 44
      return (0);
    } else {
#line 44
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 44
  if (! value) {
#line 44
    return (0);
  }
  {
#line 46
  tmp = realloc((void *)tags->tags, (unsigned long )(tags->count + 1U) * sizeof(mp4ff_tag_t ));
#line 46
  tags->tags = (mp4ff_tag_t *)tmp;
  }
#line 47
  if (! tags->tags) {
#line 49
    if (backup) {
      {
#line 49
      free(backup);
      }
    }
#line 50
    return (0);
  } else {
    {
#line 52
    (tags->tags + tags->count)->item = strdup(item);
#line 53
    (tags->tags + tags->count)->value = strdup(value);
    }
#line 55
    if (! (tags->tags + tags->count)->item) {
#line 55
      goto _L___0;
    } else
#line 55
    if (! (tags->tags + tags->count)->value) {
      _L___0: /* CIL Label */ 
#line 57
      if (! (tags->tags + tags->count)->item) {
        {
#line 57
        free((void *)(tags->tags + tags->count)->item);
        }
      }
#line 58
      if (! (tags->tags + tags->count)->value) {
        {
#line 58
        free((void *)(tags->tags + tags->count)->value);
        }
      }
#line 59
      (tags->tags + tags->count)->item = (char *)((void *)0);
#line 60
      (tags->tags + tags->count)->value = (char *)((void *)0);
#line 61
      return (0);
    }
#line 64
    (tags->count) ++;
#line 65
    return (1);
  }
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_tag_delete(mp4ff_metadata_t *tags ) 
{ 
  uint32_t i ;

  {
#line 92
  i = (uint32_t )0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (i < tags->count)) {
#line 92
      goto while_break;
    }
#line 94
    if ((tags->tags + i)->item) {
      {
#line 94
      free((void *)(tags->tags + i)->item);
      }
    }
#line 95
    if ((tags->tags + i)->value) {
      {
#line 95
      free((void *)(tags->tags + i)->value);
      }
    }
#line 92
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (tags->tags) {
    {
#line 98
    free((void *)tags->tags);
    }
  }
#line 100
  tags->tags = (mp4ff_tag_t *)((void *)0);
#line 101
  tags->count = (uint32_t )0;
#line 103
  return (0);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
static char const   *ID3v1GenreList[148]  = 
#line 106
  {      "Blues",      "Classic Rock",      "Country",      "Dance", 
        "Disco",      "Funk",      "Grunge",      "Hip-Hop", 
        "Jazz",      "Metal",      "New Age",      "Oldies", 
        "Other",      "Pop",      "R&B",      "Rap", 
        "Reggae",      "Rock",      "Techno",      "Industrial", 
        "Alternative",      "Ska",      "Death Metal",      "Pranks", 
        "Soundtrack",      "Euro-Techno",      "Ambient",      "Trip-Hop", 
        "Vocal",      "Jazz+Funk",      "Fusion",      "Trance", 
        "Classical",      "Instrumental",      "Acid",      "House", 
        "Game",      "Sound Clip",      "Gospel",      "Noise", 
        "AlternRock",      "Bass",      "Soul",      "Punk", 
        "Space",      "Meditative",      "Instrumental Pop",      "Instrumental Rock", 
        "Ethnic",      "Gothic",      "Darkwave",      "Techno-Industrial", 
        "Electronic",      "Pop-Folk",      "Eurodance",      "Dream", 
        "Southern Rock",      "Comedy",      "Cult",      "Gangsta", 
        "Top 40",      "Christian Rap",      "Pop/Funk",      "Jungle", 
        "Native American",      "Cabaret",      "New Wave",      "Psychadelic", 
        "Rave",      "Showtunes",      "Trailer",      "Lo-Fi", 
        "Tribal",      "Acid Punk",      "Acid Jazz",      "Polka", 
        "Retro",      "Musical",      "Rock & Roll",      "Hard Rock", 
        "Folk",      "Folk/Rock",      "National Folk",      "Swing", 
        "Fast-Fusion",      "Bebob",      "Latin",      "Revival", 
        "Celtic",      "Bluegrass",      "Avantgarde",      "Gothic Rock", 
        "Progressive Rock",      "Psychedelic Rock",      "Symphonic Rock",      "Slow Rock", 
        "Big Band",      "Chorus",      "Easy Listening",      "Acoustic", 
        "Humour",      "Speech",      "Chanson",      "Opera", 
        "Chamber Music",      "Sonata",      "Symphony",      "Booty Bass", 
        "Primus",      "Porn Groove",      "Satire",      "Slow Jam", 
        "Club",      "Tango",      "Samba",      "Folklore", 
        "Ballad",      "Power Ballad",      "Rhythmic Soul",      "Freestyle", 
        "Duet",      "Punk Rock",      "Drum Solo",      "A capella", 
        "Euro-House",      "Dance Hall",      "Goa",      "Drum & Bass", 
        "Club House",      "Hardcore",      "Terror",      "Indie", 
        "BritPop",      "NegerPunk",      "Polsk Punk",      "Beat", 
        "Christian Gangsta",      "Heavy Metal",      "Black Metal",      "Crossover", 
        "Contemporary C",      "Christian Rock",      "Merengue",      "Salsa", 
        "Thrash Metal",      "Anime",      "JPop",      "SynthPop"};
#line 135 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
uint32_t mp4ff_meta_genre_to_index(char const   *genrestr ) 
{ 
  unsigned int n ;
  int tmp ;

  {
#line 138
  n = 0U;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! ((unsigned long )n < sizeof(ID3v1GenreList) / sizeof(ID3v1GenreList[0]))) {
#line 138
      goto while_break;
    }
    {
#line 140
    tmp = strcasecmp(genrestr, ID3v1GenreList[n]);
    }
#line 140
    if (! tmp) {
#line 140
      return (n + 1U);
    }
#line 138
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return ((uint32_t )0);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
char const   *mp4ff_meta_index_to_genre(uint32_t idx ) 
{ 


  {
#line 147
  if (idx > 0U) {
#line 147
    if ((unsigned long )idx <= sizeof(ID3v1GenreList) / sizeof(ID3v1GenreList[0])) {
#line 149
      return (ID3v1GenreList[idx - 1U]);
    } else {
#line 153
      return ((char const   *)0);
    }
  } else {
#line 153
    return ((char const   *)0);
  }
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
static char *tag_names[31]  = 
#line 168
  {      (char *)"unknown",      (char *)"title",      (char *)"artist",      (char *)"writer", 
        (char *)"album",      (char *)"date",      (char *)"tool",      (char *)"comment", 
        (char *)"genre",      (char *)"track",      (char *)"disc",      (char *)"compilation", 
        (char *)"genre",      (char *)"tempo",      (char *)"cover",      (char *)"album_artist", 
        (char *)"contentgroup",      (char *)"lyrics",      (char *)"description",      (char *)"network", 
        (char *)"show",      (char *)"episodename",      (char *)"sorttitle",      (char *)"sortalbum", 
        (char *)"sortartist",      (char *)"sortalbumartist",      (char *)"sortwriter",      (char *)"sortshow", 
        (char *)"season",      (char *)"episode",      (char *)"podcast"};
#line 166 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
static int32_t mp4ff_set_metadata_name(mp4ff_t *f , uint8_t const   atom_type , char **name ) 
{ 
  uint8_t tag_idx ;

  {
#line 179
  tag_idx = (uint8_t )0;
  {
#line 183
  if ((int const   )atom_type == 9) {
#line 183
    goto case_9;
  }
#line 184
  if ((int const   )atom_type == 10) {
#line 184
    goto case_10;
  }
#line 185
  if ((int const   )atom_type == 11) {
#line 185
    goto case_11;
  }
#line 186
  if ((int const   )atom_type == 12) {
#line 186
    goto case_12;
  }
#line 187
  if ((int const   )atom_type == 13) {
#line 187
    goto case_13;
  }
#line 188
  if ((int const   )atom_type == 14) {
#line 188
    goto case_14;
  }
#line 189
  if ((int const   )atom_type == 15) {
#line 189
    goto case_15;
  }
#line 190
  if ((int const   )atom_type == 16) {
#line 190
    goto case_16;
  }
#line 191
  if ((int const   )atom_type == 17) {
#line 191
    goto case_17;
  }
#line 192
  if ((int const   )atom_type == 18) {
#line 192
    goto case_18;
  }
#line 193
  if ((int const   )atom_type == 19) {
#line 193
    goto case_19;
  }
#line 194
  if ((int const   )atom_type == 20) {
#line 194
    goto case_20;
  }
#line 195
  if ((int const   )atom_type == 21) {
#line 195
    goto case_21;
  }
#line 196
  if ((int const   )atom_type == 22) {
#line 196
    goto case_22;
  }
#line 197
  if ((int const   )atom_type == 157) {
#line 197
    goto case_157;
  }
#line 198
  if ((int const   )atom_type == 158) {
#line 198
    goto case_158;
  }
#line 199
  if ((int const   )atom_type == 159) {
#line 199
    goto case_159;
  }
#line 200
  if ((int const   )atom_type == 160) {
#line 200
    goto case_160;
  }
#line 201
  if ((int const   )atom_type == 161) {
#line 201
    goto case_161;
  }
#line 202
  if ((int const   )atom_type == 162) {
#line 202
    goto case_162;
  }
#line 203
  if ((int const   )atom_type == 163) {
#line 203
    goto case_163;
  }
#line 204
  if ((int const   )atom_type == 164) {
#line 204
    goto case_164;
  }
#line 205
  if ((int const   )atom_type == 165) {
#line 205
    goto case_165;
  }
#line 206
  if ((int const   )atom_type == 166) {
#line 206
    goto case_166;
  }
#line 207
  if ((int const   )atom_type == 167) {
#line 207
    goto case_167;
  }
#line 208
  if ((int const   )atom_type == 168) {
#line 208
    goto case_168;
  }
#line 209
  if ((int const   )atom_type == 169) {
#line 209
    goto case_169;
  }
#line 210
  if ((int const   )atom_type == 170) {
#line 210
    goto case_170;
  }
#line 211
  if ((int const   )atom_type == 171) {
#line 211
    goto case_171;
  }
#line 212
  if ((int const   )atom_type == 172) {
#line 212
    goto case_172;
  }
#line 213
  goto switch_default;
  case_9: /* CIL Label */ 
#line 183
  tag_idx = (uint8_t )1;
#line 183
  goto switch_break;
  case_10: /* CIL Label */ 
#line 184
  tag_idx = (uint8_t )2;
#line 184
  goto switch_break;
  case_11: /* CIL Label */ 
#line 185
  tag_idx = (uint8_t )3;
#line 185
  goto switch_break;
  case_12: /* CIL Label */ 
#line 186
  tag_idx = (uint8_t )4;
#line 186
  goto switch_break;
  case_13: /* CIL Label */ 
#line 187
  tag_idx = (uint8_t )5;
#line 187
  goto switch_break;
  case_14: /* CIL Label */ 
#line 188
  tag_idx = (uint8_t )6;
#line 188
  goto switch_break;
  case_15: /* CIL Label */ 
#line 189
  tag_idx = (uint8_t )7;
#line 189
  goto switch_break;
  case_16: /* CIL Label */ 
#line 190
  tag_idx = (uint8_t )8;
#line 190
  goto switch_break;
  case_17: /* CIL Label */ 
#line 191
  tag_idx = (uint8_t )9;
#line 191
  goto switch_break;
  case_18: /* CIL Label */ 
#line 192
  tag_idx = (uint8_t )10;
#line 192
  goto switch_break;
  case_19: /* CIL Label */ 
#line 193
  tag_idx = (uint8_t )11;
#line 193
  goto switch_break;
  case_20: /* CIL Label */ 
#line 194
  tag_idx = (uint8_t )12;
#line 194
  goto switch_break;
  case_21: /* CIL Label */ 
#line 195
  tag_idx = (uint8_t )13;
#line 195
  goto switch_break;
  case_22: /* CIL Label */ 
#line 196
  tag_idx = (uint8_t )14;
#line 196
  goto switch_break;
  case_157: /* CIL Label */ 
#line 197
  tag_idx = (uint8_t )15;
#line 197
  goto switch_break;
  case_158: /* CIL Label */ 
#line 198
  tag_idx = (uint8_t )16;
#line 198
  goto switch_break;
  case_159: /* CIL Label */ 
#line 199
  tag_idx = (uint8_t )17;
#line 199
  goto switch_break;
  case_160: /* CIL Label */ 
#line 200
  tag_idx = (uint8_t )18;
#line 200
  goto switch_break;
  case_161: /* CIL Label */ 
#line 201
  tag_idx = (uint8_t )19;
#line 201
  goto switch_break;
  case_162: /* CIL Label */ 
#line 202
  tag_idx = (uint8_t )20;
#line 202
  goto switch_break;
  case_163: /* CIL Label */ 
#line 203
  tag_idx = (uint8_t )21;
#line 203
  goto switch_break;
  case_164: /* CIL Label */ 
#line 204
  tag_idx = (uint8_t )22;
#line 204
  goto switch_break;
  case_165: /* CIL Label */ 
#line 205
  tag_idx = (uint8_t )23;
#line 205
  goto switch_break;
  case_166: /* CIL Label */ 
#line 206
  tag_idx = (uint8_t )24;
#line 206
  goto switch_break;
  case_167: /* CIL Label */ 
#line 207
  tag_idx = (uint8_t )25;
#line 207
  goto switch_break;
  case_168: /* CIL Label */ 
#line 208
  tag_idx = (uint8_t )26;
#line 208
  goto switch_break;
  case_169: /* CIL Label */ 
#line 209
  tag_idx = (uint8_t )27;
#line 209
  goto switch_break;
  case_170: /* CIL Label */ 
#line 210
  tag_idx = (uint8_t )28;
#line 210
  goto switch_break;
  case_171: /* CIL Label */ 
#line 211
  tag_idx = (uint8_t )29;
#line 211
  goto switch_break;
  case_172: /* CIL Label */ 
#line 212
  tag_idx = (uint8_t )30;
#line 212
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 213
  tag_idx = (uint8_t )0;
#line 213
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 216
  *name = strdup((char const   *)tag_names[tag_idx]);
  }
#line 218
  return (0);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
static int32_t mp4ff_parse_tag(mp4ff_t *f , uint8_t const   parent_atom_type , int32_t const   size ) 
{ 
  uint8_t atom_type ;
  uint8_t header_size ;
  uint64_t subsize ;
  uint64_t sumsize ;
  char *name ;
  char *data ;
  uint32_t done ;
  uint64_t destpos ;
  int64_t tmp ;
  uint16_t val ;
  uint16_t tmp___0 ;
  char temp[16] ;
  char const   *temp___0 ;
  char const   *tmp___1 ;
  uint16_t index___0 ;
  uint16_t total ;
  char temp___1[32] ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 224
  header_size = (uint8_t )0;
#line 225
  sumsize = (uint64_t )0;
#line 226
  name = (char *)((void *)0);
#line 227
  data = (char *)((void *)0);
#line 228
  done = (uint32_t )0;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! (sumsize < (uint64_t )size)) {
#line 231
      goto while_break;
    }
    {
#line 234
    subsize = mp4ff_atom_read_header(f, & atom_type, & header_size);
#line 235
    tmp = mp4ff_position((mp4ff_t const   *)f);
#line 235
    destpos = ((uint64_t )tmp + subsize) - (uint64_t )header_size;
    }
#line 236
    if (! done) {
#line 238
      if ((int )atom_type == 150) {
        {
#line 240
        mp4ff_read_char(f);
#line 241
        mp4ff_read_int24(f);
#line 242
        mp4ff_read_int32(f);
        }
#line 245
        if ((int const   )parent_atom_type == 20) {
#line 245
          goto _L___0;
        } else
#line 245
        if ((int const   )parent_atom_type == 21) {
          _L___0: /* CIL Label */ 
#line 247
          if (subsize - (uint64_t )header_size >= 10UL) {
            {
#line 249
            tmp___0 = mp4ff_read_int16(f);
#line 249
            val = tmp___0;
            }
#line 251
            if ((int const   )parent_atom_type == 21) {
              {
#line 254
              sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%.5u BPM",
                      (int )val);
#line 255
              mp4ff_tag_add_field(& f->tags, "tempo", (char const   *)(temp));
              }
            } else {
              {
#line 259
              tmp___1 = mp4ff_meta_index_to_genre((uint32_t )val);
#line 259
              temp___0 = tmp___1;
              }
#line 260
              if (temp___0) {
                {
#line 262
                mp4ff_tag_add_field(& f->tags, "genre", temp___0);
                }
              }
            }
#line 265
            done = (uint32_t )1;
          }
        } else
#line 267
        if ((int const   )parent_atom_type == 17) {
#line 267
          goto _L;
        } else
#line 267
        if ((int const   )parent_atom_type == 18) {
          _L: /* CIL Label */ 
#line 270
          if (! done) {
#line 270
            if (subsize - (uint64_t )header_size >= ((((sizeof(char ) + sizeof(uint8_t ) * 3UL) + sizeof(uint32_t )) + sizeof(uint16_t )) + sizeof(uint16_t )) + sizeof(uint16_t )) {
              {
#line 279
              mp4ff_read_int16(f);
#line 280
              index___0 = mp4ff_read_int16(f);
#line 281
              total = mp4ff_read_int16(f);
#line 285
              sprintf((char */* __restrict  */)(temp___1), (char const   */* __restrict  */)"%d",
                      (int )index___0);
              }
#line 286
              if ((int const   )parent_atom_type == 17) {
#line 286
                tmp___2 = "track";
              } else {
#line 286
                tmp___2 = "disc";
              }
              {
#line 286
              mp4ff_tag_add_field(& f->tags, tmp___2, (char const   *)(temp___1));
              }
#line 287
              if ((int )total > 0) {
                {
#line 289
                sprintf((char */* __restrict  */)(temp___1), (char const   */* __restrict  */)"%d",
                        (int )total);
                }
#line 290
                if ((int const   )parent_atom_type == 17) {
#line 290
                  tmp___3 = "totaltracks";
                } else {
#line 290
                  tmp___3 = "totaldiscs";
                }
                {
#line 290
                mp4ff_tag_add_field(& f->tags, tmp___3, (char const   *)(temp___1));
                }
              }
#line 292
              done = (uint32_t )1;
            }
          }
        } else {
#line 296
          if (data) {
            {
#line 296
            free((void *)data);
#line 296
            data = (char *)((void *)0);
            }
          }
          {
#line 297
          data = mp4ff_read_string(f, (uint32_t )(subsize - (uint64_t )((int )header_size + 8)));
          }
        }
      } else
#line 299
      if ((int )atom_type == 149) {
#line 300
        if (! done) {
          {
#line 302
          mp4ff_read_char(f);
#line 303
          mp4ff_read_int24(f);
          }
#line 304
          if (name) {
            {
#line 304
            free((void *)name);
            }
          }
          {
#line 305
          name = mp4ff_read_string(f, (uint32_t )(subsize - (uint64_t )((int )header_size + 4)));
          }
        }
      }
      {
#line 308
      mp4ff_set_position(f, (int64_t const   )destpos);
#line 309
      sumsize += subsize;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (data) {
#line 315
    if (! done) {
#line 317
      if ((unsigned long )name == (unsigned long )((void *)0)) {
        {
#line 317
        mp4ff_set_metadata_name(f, parent_atom_type, & name);
        }
      }
#line 318
      if (name) {
        {
#line 318
        mp4ff_tag_add_field(& f->tags, (char const   *)name, (char const   *)data);
        }
      }
    }
    {
#line 321
    free((void *)data);
    }
  }
#line 323
  if (name) {
    {
#line 323
    free((void *)name);
    }
  }
#line 324
  return (1);
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_parse_metadata(mp4ff_t *f , int32_t const   size ) 
{ 
  uint64_t subsize ;
  uint64_t sumsize ;
  uint8_t atom_type ;
  uint8_t header_size ;

  {
#line 329
  sumsize = (uint64_t )0;
#line 331
  header_size = (uint8_t )0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (sumsize < (uint64_t )size)) {
#line 333
      goto while_break;
    }
    {
#line 335
    subsize = mp4ff_atom_read_header(f, & atom_type, & header_size);
    }
#line 336
    if (subsize == 0UL) {
#line 337
      goto while_break;
    }
    {
#line 338
    mp4ff_parse_tag(f, (uint8_t const   )atom_type, (int32_t const   )((uint32_t )(subsize - (uint64_t )header_size)));
#line 339
    sumsize += subsize;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return (0);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
static int32_t mp4ff_meta_find_by_name(mp4ff_t const   *f , char const   *item , char **value ) 
{ 
  uint32_t i ;
  int tmp ;

  {
#line 351
  i = (uint32_t )0;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! (i < (uint32_t )f->tags.count)) {
#line 351
      goto while_break;
    }
    {
#line 353
    tmp = strcasecmp((char const   *)(f->tags.tags + i)->item, item);
    }
#line 353
    if (! tmp) {
      {
#line 355
      *value = strdup((char const   *)(f->tags.tags + i)->value);
      }
#line 356
      return (1);
    }
#line 351
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  *value = (char *)((void *)0);
#line 363
  return (0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_num_items(mp4ff_t const   *f ) 
{ 


  {
#line 368
  return ((int32_t )f->tags.count);
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_by_index(mp4ff_t const   *f , uint32_t index___0 , char **item ,
                                char **value ) 
{ 


  {
#line 374
  if (index___0 >= (uint32_t )f->tags.count) {
#line 376
    *item = (char *)((void *)0);
#line 377
    *value = (char *)((void *)0);
#line 378
    return (0);
  } else {
    {
#line 380
    *item = strdup((char const   *)(f->tags.tags + index___0)->item);
#line 381
    *value = strdup((char const   *)(f->tags.tags + index___0)->value);
    }
#line 382
    return (1);
  }
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_title(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 388
  tmp = mp4ff_meta_find_by_name(f, "title", value);
  }
#line 388
  return (tmp);
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_artist(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 393
  tmp = mp4ff_meta_find_by_name(f, "artist", value);
  }
#line 393
  return (tmp);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_writer(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 398
  tmp = mp4ff_meta_find_by_name(f, "writer", value);
  }
#line 398
  return (tmp);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_album(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 403
  tmp = mp4ff_meta_find_by_name(f, "album", value);
  }
#line 403
  return (tmp);
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_date(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 408
  tmp = mp4ff_meta_find_by_name(f, "date", value);
  }
#line 408
  return (tmp);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_tool(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 413
  tmp = mp4ff_meta_find_by_name(f, "tool", value);
  }
#line 413
  return (tmp);
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_comment(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 418
  tmp = mp4ff_meta_find_by_name(f, "comment", value);
  }
#line 418
  return (tmp);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_genre(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 423
  tmp = mp4ff_meta_find_by_name(f, "genre", value);
  }
#line 423
  return (tmp);
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_track(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 428
  tmp = mp4ff_meta_find_by_name(f, "track", value);
  }
#line 428
  return (tmp);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_totaltracks(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 433
  tmp = mp4ff_meta_find_by_name(f, "totaltracks", value);
  }
#line 433
  return (tmp);
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_disc(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 438
  tmp = mp4ff_meta_find_by_name(f, "disc", value);
  }
#line 438
  return (tmp);
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_totaldiscs(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 443
  tmp = mp4ff_meta_find_by_name(f, "totaldiscs", value);
  }
#line 443
  return (tmp);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_compilation(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 448
  tmp = mp4ff_meta_find_by_name(f, "compilation", value);
  }
#line 448
  return (tmp);
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_tempo(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 453
  tmp = mp4ff_meta_find_by_name(f, "tempo", value);
  }
#line 453
  return (tmp);
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4meta.c"
int32_t mp4ff_meta_get_coverart(mp4ff_t const   *f , char **value ) 
{ 
  int32_t tmp ;

  {
  {
#line 458
  tmp = mp4ff_meta_find_by_name(f, "cover", value);
  }
#line 458
  return (tmp);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.h"
char *optarg ;
#line 47
int optind ;
#line 52
int opterr ;
#line 56
int optopt ;
#line 105
int getopt(int argc , char * const  *argv , char const   *optstring ) ;
#line 107
int getopt_long(int argc , char * const  *argv , char const   *options , struct option  const  *long_options___0 ,
                int *opt_index ) ;
#line 114
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
char *optarg  =    (char *)0;
#line 102 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
int optind  =    0;
#line 111 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
static char *nextchar  ;
#line 116 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
int opterr  =    1;
#line 123 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
int optopt  =    '\000';
#line 154 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
static enum __anonenum_ordering_25 ordering  ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 215 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
static int first_nonopt  ;
#line 216 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
static int last_nonopt  ;
#line 238
static void exchange(char **argv ) ;
#line 241 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
static void exchange(char **argv ) 
{ 
  char *temp ;
  char **first ;
  char **last ;

  {
#line 248
  first = argv + first_nonopt;
#line 249
  last = argv + (optind - 1);
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! ((unsigned long )first < (unsigned long )last)) {
#line 250
      goto while_break;
    }
#line 251
    temp = *first;
#line 251
    *first = *last;
#line 251
    *last = temp;
#line 251
    first ++;
#line 251
    last --;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  first = argv + first_nonopt;
#line 255
  first_nonopt += optind - last_nonopt;
#line 256
  last = argv + (first_nonopt - 1);
  {
#line 257
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 257
    if (! ((unsigned long )first < (unsigned long )last)) {
#line 257
      goto while_break___0;
    }
#line 258
    temp = *first;
#line 258
    *first = *last;
#line 258
    *last = temp;
#line 258
    first ++;
#line 258
    last --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 262
  first = argv + first_nonopt;
#line 263
  last_nonopt = optind;
#line 264
  last = argv + (last_nonopt - 1);
  {
#line 265
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 265
    if (! ((unsigned long )first < (unsigned long )last)) {
#line 265
      goto while_break___1;
    }
#line 266
    temp = *first;
#line 266
    *first = *last;
#line 266
    *last = temp;
#line 266
    first ++;
#line 266
    last --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 268
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only ) 
{ 
  int option_index ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct option  const  *p ;
  char *s ;
  int exact ;
  int ambig ;
  struct option  const  *pfound ;
  int indfound ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char c ;
  char *tmp___12 ;
  char *temp ;
  char *tmp___13 ;
  int tmp___14 ;

  {
#line 337
  optarg = (char *)0;
#line 344
  if (optind == 0) {
#line 346
    optind = 1;
#line 346
    last_nonopt = optind;
#line 346
    first_nonopt = last_nonopt;
#line 348
    nextchar = (char *)((void *)0);
#line 352
    if ((int const   )*(optstring + 0) == 45) {
#line 354
      ordering = (enum __anonenum_ordering_25 )2;
#line 355
      optstring ++;
    } else
#line 357
    if ((int const   )*(optstring + 0) == 43) {
#line 359
      ordering = (enum __anonenum_ordering_25 )0;
#line 360
      optstring ++;
    } else {
      {
#line 362
      tmp = getenv("POSIXLY_CORRECT");
      }
#line 362
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 363
        ordering = (enum __anonenum_ordering_25 )0;
      } else {
#line 365
        ordering = (enum __anonenum_ordering_25 )1;
      }
    }
  }
#line 368
  if ((unsigned long )nextchar == (unsigned long )((void *)0)) {
#line 368
    goto _L___2;
  } else
#line 368
  if ((int )*nextchar == 0) {
    _L___2: /* CIL Label */ 
#line 370
    if ((unsigned int )ordering == 1U) {
#line 375
      if (first_nonopt != last_nonopt) {
#line 375
        if (last_nonopt != optind) {
          {
#line 376
          exchange((char **)argv);
          }
        } else {
#line 375
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 377
      if (last_nonopt != optind) {
#line 378
        first_nonopt = optind;
      }
      {
#line 383
      while (1) {
        while_continue: /* CIL Label */ ;
#line 383
        if (optind < argc) {
#line 383
          if (! ((int )*(*(argv + optind) + 0) != 45)) {
#line 383
            if (! ((int )*(*(argv + optind) + 1) == 0)) {
#line 383
              goto while_break;
            }
          }
        } else {
#line 383
          goto while_break;
        }
#line 390
        optind ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 391
      last_nonopt = optind;
    }
#line 399
    if (optind != argc) {
      {
#line 399
      tmp___0 = strcmp((char const   *)*(argv + optind), "--");
      }
#line 399
      if (! tmp___0) {
#line 401
        optind ++;
#line 403
        if (first_nonopt != last_nonopt) {
#line 403
          if (last_nonopt != optind) {
            {
#line 404
            exchange((char **)argv);
            }
          } else {
#line 403
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 405
        if (first_nonopt == last_nonopt) {
#line 406
          first_nonopt = optind;
        }
#line 407
        last_nonopt = argc;
#line 409
        optind = argc;
      }
    }
#line 415
    if (optind == argc) {
#line 419
      if (first_nonopt != last_nonopt) {
#line 420
        optind = first_nonopt;
      }
#line 421
      return (-1);
    }
#line 427
    if ((int )*(*(argv + optind) + 0) != 45) {
#line 427
      goto _L___1;
    } else
#line 427
    if ((int )*(*(argv + optind) + 1) == 0) {
      _L___1: /* CIL Label */ 
#line 434
      if ((unsigned int )ordering == 0U) {
#line 435
        return (-1);
      }
#line 436
      tmp___1 = optind;
#line 436
      optind ++;
#line 436
      optarg = (char *)*(argv + tmp___1);
#line 437
      return (1);
    }
#line 443
    if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 443
      if ((int )*(*(argv + optind) + 1) == 45) {
#line 443
        tmp___2 = 1;
      } else {
#line 443
        tmp___2 = 0;
      }
    } else {
#line 443
      tmp___2 = 0;
    }
#line 443
    nextchar = (char *)((*(argv + optind) + 1) + tmp___2);
  }
#line 447
  if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 447
    if ((int )*(*(argv + optind) + 0) == 45) {
#line 447
      if ((int )*(*(argv + optind) + 1) == 45) {
#line 447
        goto _L___4;
      } else
#line 447
      if (long_only) {
        _L___4: /* CIL Label */ 
#line 456
        s = nextchar;
#line 457
        exact = 0;
#line 458
        ambig = 0;
#line 459
        pfound = (struct option  const  *)((void *)0);
#line 460
        indfound = 0;
        {
#line 462
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 462
          if (*s) {
#line 462
            if (! ((int )*s != 61)) {
#line 462
              goto while_break___0;
            }
          } else {
#line 462
            goto while_break___0;
          }
#line 463
          s ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 466
        p = longopts;
#line 466
        option_index = 0;
        {
#line 466
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 466
          if (! p->name) {
#line 466
            goto while_break___1;
          }
          {
#line 468
          tmp___4 = strncmp((char const   *)p->name, (char const   *)nextchar, (size_t )(s - nextchar));
          }
#line 468
          if (! tmp___4) {
            {
#line 470
            tmp___3 = strlen((char const   *)p->name);
            }
#line 470
            if ((size_t )(s - nextchar) == tmp___3) {
#line 473
              pfound = p;
#line 474
              indfound = option_index;
#line 475
              exact = 1;
#line 476
              goto while_break___1;
            } else
#line 478
            if ((unsigned long )pfound == (unsigned long )((void *)0)) {
#line 481
              pfound = p;
#line 482
              indfound = option_index;
            } else {
#line 486
              ambig = 1;
            }
          }
#line 466
          p ++;
#line 466
          option_index ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 489
        if (ambig) {
#line 489
          if (! exact) {
#line 491
            if (opterr) {
              {
#line 492
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' is ambiguous\n",
                      *(argv + 0), *(argv + optind));
              }
            }
            {
#line 494
            tmp___5 = strlen((char const   *)nextchar);
#line 494
            nextchar += tmp___5;
#line 495
            optind ++;
            }
#line 496
            return ('\000');
          }
        }
#line 499
        if ((unsigned long )pfound != (unsigned long )((void *)0)) {
#line 501
          option_index = indfound;
#line 502
          optind ++;
#line 503
          if (*s) {
#line 507
            if (pfound->has_arg) {
#line 508
              optarg = s + 1;
            } else {
#line 511
              if (opterr) {
#line 513
                if ((int )*(*(argv + (optind - 1)) + 1) == 45) {
                  {
#line 515
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `--%s\' doesn\'t allow an argument\n",
                          *(argv + 0), pfound->name);
                  }
                } else {
                  {
#line 520
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%c%s\' doesn\'t allow an argument\n",
                          *(argv + 0), (int )*(*(argv + (optind - 1)) + 0), pfound->name);
                  }
                }
              }
              {
#line 524
              tmp___6 = strlen((char const   *)nextchar);
#line 524
              nextchar += tmp___6;
              }
#line 525
              return ('\000');
            }
          } else
#line 528
          if (pfound->has_arg == 1) {
#line 530
            if (optind < argc) {
#line 531
              tmp___7 = optind;
#line 531
              optind ++;
#line 531
              optarg = (char *)*(argv + tmp___7);
            } else {
#line 534
              if (opterr) {
                {
#line 535
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' requires an argument\n",
                        *(argv + 0), *(argv + (optind - 1)));
                }
              }
              {
#line 537
              tmp___8 = strlen((char const   *)nextchar);
#line 537
              nextchar += tmp___8;
              }
#line 538
              if ((int const   )*(optstring + 0) == 58) {
#line 538
                tmp___9 = ':';
              } else {
#line 538
                tmp___9 = '\000';
              }
#line 538
              return (tmp___9);
            }
          }
          {
#line 541
          tmp___10 = strlen((char const   *)nextchar);
#line 541
          nextchar += tmp___10;
          }
#line 542
          if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 543
            *longind = option_index;
          }
#line 544
          if (pfound->flag) {
#line 546
            *(pfound->flag) = (int )pfound->val;
#line 547
            return (0);
          }
#line 549
          return ((int )pfound->val);
        }
#line 555
        if (! long_only) {
#line 555
          goto _L___3;
        } else
#line 555
        if ((int )*(*(argv + optind) + 1) == 45) {
#line 555
          goto _L___3;
        } else {
          {
#line 555
          tmp___11 = strchr(optstring, (int )*nextchar);
          }
#line 555
          if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
            _L___3: /* CIL Label */ 
#line 561
            if (opterr) {
#line 563
              if ((int )*(*(argv + optind) + 1) == 45) {
                {
#line 565
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option `--%s\'\n",
                        *(argv + 0), nextchar);
                }
              } else {
                {
#line 569
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option `%c%s\'\n",
                        *(argv + 0), (int )*(*(argv + optind) + 0), nextchar);
                }
              }
            }
#line 572
            nextchar = (char *)"";
#line 573
            optind ++;
#line 574
            return ('\000');
          }
        }
      }
    }
  }
  {
#line 581
  tmp___12 = nextchar;
#line 581
  nextchar ++;
#line 581
  c = *tmp___12;
#line 582
  tmp___13 = strchr(optstring, (int )c);
#line 582
  temp = tmp___13;
  }
#line 585
  if ((int )*nextchar == 0) {
#line 586
    optind ++;
  }
#line 588
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 588
    goto _L___5;
  } else
#line 588
  if ((int )c == 58) {
    _L___5: /* CIL Label */ 
#line 590
    if (opterr) {
      {
#line 600
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: illegal option -- %c\n",
              *(argv + 0), (int )c);
      }
    }
#line 603
    optopt = (int )c;
#line 604
    return ('\000');
  }
#line 606
  if ((int )*(temp + 1) == 58) {
#line 608
    if ((int )*(temp + 2) == 58) {
#line 611
      if ((int )*nextchar != 0) {
#line 613
        optarg = nextchar;
#line 614
        optind ++;
      } else {
#line 617
        optarg = (char *)0;
      }
#line 618
      nextchar = (char *)((void *)0);
    } else {
#line 623
      if ((int )*nextchar != 0) {
#line 625
        optarg = nextchar;
#line 628
        optind ++;
      } else
#line 630
      if (optind == argc) {
#line 632
        if (opterr) {
          {
#line 639
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option requires an argument -- %c\n",
                  *(argv + 0), (int )c);
          }
        }
#line 643
        optopt = (int )c;
#line 644
        if ((int const   )*(optstring + 0) == 58) {
#line 645
          c = (char )':';
        } else {
#line 647
          c = (char )'\000';
        }
      } else {
#line 652
        tmp___14 = optind;
#line 652
        optind ++;
#line 652
        optarg = (char *)*(argv + tmp___14);
      }
#line 653
      nextchar = (char *)((void *)0);
    }
  }
#line 656
  return ((int )c);
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
int getopt(int argc , char * const  *argv , char const   *optstring ) 
{ 
  int tmp ;

  {
  {
#line 666
  tmp = _getopt_internal(argc, argv, optstring, (struct option  const  *)0, (int *)0,
                         0);
  }
#line 666
  return (tmp);
}
}
#line 672 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/../common/faad/getopt.c"
int getopt_long(int argc , char * const  *argv , char const   *options , struct option  const  *long_options___0 ,
                int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 680
  tmp = _getopt_internal(argc, argv, options, long_options___0, opt_index, 0);
  }
#line 680
  return (tmp);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 244 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
int32_t mp4ff_read_data(mp4ff_t *f , int8_t *data , uint32_t size ) ;
#line 246
uint64_t mp4ff_read_int64(mp4ff_t *f ) ;
#line 252
uint32_t mp4ff_read_mp4_descr_length(mp4ff_t *f ) ;
#line 259
static int32_t mp4ff_atom_get_size(int8_t const   *data ) ;
#line 260
static int32_t mp4ff_atom_compare(int8_t const   a1 , int8_t const   b1 , int8_t const   c1 ,
                                  int8_t const   d1 , int8_t const   a2 , int8_t const   b2 ,
                                  int8_t const   c2 , int8_t const   d2 ) ;
#line 262
static uint8_t mp4ff_atom_name_to_type(int8_t const   a , int8_t const   b , int8_t const   c ,
                                       int8_t const   d ) ;
#line 264
static int32_t mp4ff_read_stsz(mp4ff_t *f ) ;
#line 265
static int32_t mp4ff_read_esds(mp4ff_t *f ) ;
#line 266
static int32_t mp4ff_read_mp4a(mp4ff_t *f ) ;
#line 267
static int32_t mp4ff_read_stsd(mp4ff_t *f ) ;
#line 268
static int32_t mp4ff_read_stsc(mp4ff_t *f ) ;
#line 269
static int32_t mp4ff_read_stco(mp4ff_t *f ) ;
#line 270
static int32_t mp4ff_read_stts(mp4ff_t *f ) ;
#line 272
static int32_t mp4ff_read_meta(mp4ff_t *f , uint64_t const   size ) ;
#line 274
int32_t mp4ff_atom_read(mp4ff_t *f , int32_t const   size , uint8_t const   atom_type ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_atom_get_size(int8_t const   *data ) 
{ 
  uint32_t result ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;

  {
#line 54
  a = (uint32_t )((uint8_t )*(data + 0));
#line 55
  b = (uint32_t )((uint8_t )*(data + 1));
#line 56
  c = (uint32_t )((uint8_t )*(data + 2));
#line 57
  d = (uint32_t )((uint8_t )*(data + 3));
#line 59
  result = (((a << 24) | (b << 16)) | (c << 8)) | d;
#line 62
  return ((int32_t )result);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_atom_compare(int8_t const   a1 , int8_t const   b1 , int8_t const   c1 ,
                                  int8_t const   d1 , int8_t const   a2 , int8_t const   b2 ,
                                  int8_t const   c2 , int8_t const   d2 ) 
{ 


  {
#line 69
  if ((int const   )a1 == (int const   )a2) {
#line 69
    if ((int const   )b1 == (int const   )b2) {
#line 69
      if ((int const   )c1 == (int const   )c2) {
#line 69
        if ((int const   )d1 == (int const   )d2) {
#line 70
          return (1);
        } else {
#line 72
          return (0);
        }
      } else {
#line 72
        return (0);
      }
    } else {
#line 72
      return (0);
    }
  } else {
#line 72
    return (0);
  }
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static uint8_t mp4ff_atom_name_to_type(int8_t const   a , int8_t const   b , int8_t const   c ,
                                       int8_t const   d ) 
{ 
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int32_t tmp___4 ;
  int32_t tmp___5 ;
  int32_t tmp___6 ;
  int32_t tmp___7 ;
  int32_t tmp___8 ;
  int32_t tmp___9 ;
  int32_t tmp___10 ;
  int32_t tmp___11 ;
  int32_t tmp___12 ;
  int32_t tmp___13 ;
  int32_t tmp___14 ;
  int32_t tmp___15 ;
  int32_t tmp___16 ;
  int32_t tmp___17 ;
  int32_t tmp___18 ;
  int32_t tmp___19 ;
  int32_t tmp___20 ;
  int32_t tmp___21 ;
  int32_t tmp___22 ;
  int32_t tmp___23 ;
  int32_t tmp___24 ;
  int32_t tmp___25 ;
  int32_t tmp___26 ;
  int32_t tmp___27 ;
  int32_t tmp___28 ;
  int32_t tmp___29 ;
  int32_t tmp___30 ;
  int32_t tmp___31 ;
  int32_t tmp___32 ;
  int32_t tmp___33 ;
  int32_t tmp___34 ;
  int32_t tmp___35 ;
  int32_t tmp___36 ;
  int32_t tmp___37 ;
  int32_t tmp___38 ;
  int32_t tmp___39 ;
  int32_t tmp___40 ;
  int32_t tmp___41 ;
  int32_t tmp___42 ;
  int32_t tmp___43 ;
  int32_t tmp___44 ;
  int32_t tmp___45 ;
  int32_t tmp___46 ;
  int32_t tmp___47 ;
  int32_t tmp___48 ;
  int32_t tmp___49 ;
  int32_t tmp___50 ;
  int32_t tmp___51 ;
  int32_t tmp___52 ;
  int32_t tmp___53 ;
  int32_t tmp___54 ;
  int32_t tmp___55 ;
  int32_t tmp___56 ;
  int32_t tmp___57 ;
  int32_t tmp___58 ;
  int32_t tmp___59 ;
  int32_t tmp___60 ;
  int32_t tmp___61 ;
  int32_t tmp___62 ;
  int32_t tmp___63 ;
  int32_t tmp___64 ;
  int32_t tmp___65 ;
  int32_t tmp___66 ;
  int32_t tmp___67 ;
  int32_t tmp___68 ;
  int32_t tmp___69 ;

  {
#line 78
  if ((int const   )a == 109) {
    {
#line 80
    tmp___8 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'m', (int8_t const   )'o',
                                 (int8_t const   )'o', (int8_t const   )'v');
    }
#line 80
    if (tmp___8) {
#line 81
      return ((uint8_t )1);
    } else {
      {
#line 82
      tmp___7 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'m', (int8_t const   )'i',
                                   (int8_t const   )'n', (int8_t const   )'f');
      }
#line 82
      if (tmp___7) {
#line 83
        return ((uint8_t )5);
      } else {
        {
#line 84
        tmp___6 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'m', (int8_t const   )'d',
                                     (int8_t const   )'i', (int8_t const   )'a');
        }
#line 84
        if (tmp___6) {
#line 85
          return ((uint8_t )4);
        } else {
          {
#line 86
          tmp___5 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'m', (int8_t const   )'d',
                                       (int8_t const   )'a', (int8_t const   )'t');
          }
#line 86
          if (tmp___5) {
#line 87
            return ((uint8_t )130);
          } else {
            {
#line 88
            tmp___4 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'m', (int8_t const   )'d',
                                         (int8_t const   )'h', (int8_t const   )'d');
            }
#line 88
            if (tmp___4) {
#line 89
              return ((uint8_t )134);
            } else {
              {
#line 90
              tmp___3 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'m', (int8_t const   )'v',
                                           (int8_t const   )'h', (int8_t const   )'d');
              }
#line 90
              if (tmp___3) {
#line 91
                return ((uint8_t )131);
              } else {
                {
#line 92
                tmp___2 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'m', (int8_t const   )'p',
                                             (int8_t const   )'4', (int8_t const   )'a');
                }
#line 92
                if (tmp___2) {
#line 93
                  return ((uint8_t )144);
                } else {
                  {
#line 94
                  tmp___1 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'m', (int8_t const   )'p',
                                               (int8_t const   )'4', (int8_t const   )'v');
                  }
#line 94
                  if (tmp___1) {
#line 95
                    return ((uint8_t )145);
                  } else {
                    {
#line 96
                    tmp___0 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'m',
                                                 (int8_t const   )'p', (int8_t const   )'4',
                                                 (int8_t const   )'s');
                    }
#line 96
                    if (tmp___0) {
#line 97
                      return ((uint8_t )146);
                    } else {
                      {
#line 98
                      tmp = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'m', (int8_t const   )'e',
                                               (int8_t const   )'t', (int8_t const   )'a');
                      }
#line 98
                      if (tmp) {
#line 99
                        return ((uint8_t )148);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } else
#line 100
  if ((int const   )a == 116) {
    {
#line 101
    tmp___18 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'t', (int8_t const   )'r',
                                  (int8_t const   )'a', (int8_t const   )'k');
    }
#line 101
    if (tmp___18) {
#line 102
      return ((uint8_t )2);
    } else {
      {
#line 103
      tmp___17 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'t', (int8_t const   )'k',
                                    (int8_t const   )'h', (int8_t const   )'d');
      }
#line 103
      if (tmp___17) {
#line 104
        return ((uint8_t )132);
      } else {
        {
#line 105
        tmp___16 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'t', (int8_t const   )'r',
                                      (int8_t const   )'e', (int8_t const   )'f');
        }
#line 105
        if (tmp___16) {
#line 106
          return ((uint8_t )133);
        } else {
          {
#line 107
          tmp___15 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'t', (int8_t const   )'r',
                                        (int8_t const   )'k', (int8_t const   )'n');
          }
#line 107
          if (tmp___15) {
#line 108
            return ((uint8_t )17);
          } else {
            {
#line 109
            tmp___14 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'t', (int8_t const   )'m',
                                          (int8_t const   )'p', (int8_t const   )'o');
            }
#line 109
            if (tmp___14) {
#line 110
              return ((uint8_t )21);
            } else {
              {
#line 111
              tmp___13 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'t', (int8_t const   )'v',
                                            (int8_t const   )'n', (int8_t const   )'n');
              }
#line 111
              if (tmp___13) {
#line 112
                return ((uint8_t )161);
              } else {
                {
#line 113
                tmp___12 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'t', (int8_t const   )'v',
                                              (int8_t const   )'s', (int8_t const   )'h');
                }
#line 113
                if (tmp___12) {
#line 114
                  return ((uint8_t )162);
                } else {
                  {
#line 115
                  tmp___11 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'t',
                                                (int8_t const   )'v', (int8_t const   )'e',
                                                (int8_t const   )'n');
                  }
#line 115
                  if (tmp___11) {
#line 116
                    return ((uint8_t )163);
                  } else {
                    {
#line 117
                    tmp___10 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'t',
                                                  (int8_t const   )'v', (int8_t const   )'s',
                                                  (int8_t const   )'n');
                    }
#line 117
                    if (tmp___10) {
#line 118
                      return ((uint8_t )170);
                    } else {
                      {
#line 119
                      tmp___9 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'t',
                                                   (int8_t const   )'v', (int8_t const   )'e',
                                                   (int8_t const   )'s');
                      }
#line 119
                      if (tmp___9) {
#line 120
                        return ((uint8_t )171);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } else
#line 121
  if ((int const   )a == 115) {
    {
#line 122
    tmp___35 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s', (int8_t const   )'t',
                                  (int8_t const   )'b', (int8_t const   )'l');
    }
#line 122
    if (tmp___35) {
#line 123
      return ((uint8_t )6);
    } else {
      {
#line 124
      tmp___34 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s', (int8_t const   )'m',
                                    (int8_t const   )'h', (int8_t const   )'d');
      }
#line 124
      if (tmp___34) {
#line 125
        return ((uint8_t )136);
      } else {
        {
#line 126
        tmp___33 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s', (int8_t const   )'t',
                                      (int8_t const   )'s', (int8_t const   )'d');
        }
#line 126
        if (tmp___33) {
#line 127
          return ((uint8_t )138);
        } else {
          {
#line 128
          tmp___32 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s', (int8_t const   )'t',
                                        (int8_t const   )'t', (int8_t const   )'s');
          }
#line 128
          if (tmp___32) {
#line 129
            return ((uint8_t )139);
          } else {
            {
#line 130
            tmp___31 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s', (int8_t const   )'t',
                                          (int8_t const   )'c', (int8_t const   )'o');
            }
#line 130
            if (tmp___31) {
#line 131
              return ((uint8_t )142);
            } else {
              {
#line 132
              tmp___30 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s', (int8_t const   )'t',
                                            (int8_t const   )'s', (int8_t const   )'c');
              }
#line 132
              if (tmp___30) {
#line 133
                return ((uint8_t )143);
              } else {
                {
#line 134
                tmp___29 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s', (int8_t const   )'t',
                                              (int8_t const   )'s', (int8_t const   )'z');
                }
#line 134
                if (tmp___29) {
#line 135
                  return ((uint8_t )140);
                } else {
                  {
#line 136
                  tmp___28 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s',
                                                (int8_t const   )'t', (int8_t const   )'z',
                                                (int8_t const   )'2');
                  }
#line 136
                  if (tmp___28) {
#line 137
                    return ((uint8_t )141);
                  } else {
                    {
#line 138
                    tmp___27 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s',
                                                  (int8_t const   )'k', (int8_t const   )'i',
                                                  (int8_t const   )'p');
                    }
#line 138
                    if (tmp___27) {
#line 139
                      return ((uint8_t )255);
                    } else {
                      {
#line 140
                      tmp___26 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s',
                                                    (int8_t const   )'i', (int8_t const   )'n',
                                                    (int8_t const   )'f');
                      }
#line 140
                      if (tmp___26) {
#line 141
                        return ((uint8_t )24);
                      } else {
                        {
#line 142
                        tmp___25 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s',
                                                      (int8_t const   )'c', (int8_t const   )'h',
                                                      (int8_t const   )'i');
                        }
#line 142
                        if (tmp___25) {
#line 143
                          return ((uint8_t )25);
                        } else {
                          {
#line 144
                          tmp___24 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s',
                                                        (int8_t const   )'o', (int8_t const   )'n',
                                                        (int8_t const   )'m');
                          }
#line 144
                          if (tmp___24) {
#line 145
                            return ((uint8_t )164);
                          } else {
                            {
#line 146
                            tmp___23 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s',
                                                          (int8_t const   )'o', (int8_t const   )'a',
                                                          (int8_t const   )'l');
                            }
#line 146
                            if (tmp___23) {
#line 147
                              return ((uint8_t )165);
                            } else {
                              {
#line 148
                              tmp___22 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s',
                                                            (int8_t const   )'o',
                                                            (int8_t const   )'a',
                                                            (int8_t const   )'r');
                              }
#line 148
                              if (tmp___22) {
#line 149
                                return ((uint8_t )166);
                              } else {
                                {
#line 150
                                tmp___21 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s',
                                                              (int8_t const   )'o',
                                                              (int8_t const   )'a',
                                                              (int8_t const   )'a');
                                }
#line 150
                                if (tmp___21) {
#line 151
                                  return ((uint8_t )167);
                                } else {
                                  {
#line 152
                                  tmp___20 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s',
                                                                (int8_t const   )'o',
                                                                (int8_t const   )'c',
                                                                (int8_t const   )'o');
                                  }
#line 152
                                  if (tmp___20) {
#line 153
                                    return ((uint8_t )168);
                                  } else {
                                    {
#line 154
                                    tmp___19 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'s',
                                                                  (int8_t const   )'o',
                                                                  (int8_t const   )'s',
                                                                  (int8_t const   )'n');
                                    }
#line 154
                                    if (tmp___19) {
#line 155
                                      return ((uint8_t )169);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } else
#line 156
  if ((int const   )a == -87) {
    {
#line 157
    tmp___45 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )((int8_t )169), (int8_t const   )'n',
                                  (int8_t const   )'a', (int8_t const   )'m');
    }
#line 157
    if (tmp___45) {
#line 158
      return ((uint8_t )9);
    } else {
      {
#line 159
      tmp___44 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )((int8_t )169), (int8_t const   )'A',
                                    (int8_t const   )'R', (int8_t const   )'T');
      }
#line 159
      if (tmp___44) {
#line 160
        return ((uint8_t )10);
      } else {
        {
#line 161
        tmp___43 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )((int8_t )169),
                                      (int8_t const   )'w', (int8_t const   )'r',
                                      (int8_t const   )'t');
        }
#line 161
        if (tmp___43) {
#line 162
          return ((uint8_t )11);
        } else {
          {
#line 163
          tmp___42 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )((int8_t )169),
                                        (int8_t const   )'a', (int8_t const   )'l',
                                        (int8_t const   )'b');
          }
#line 163
          if (tmp___42) {
#line 164
            return ((uint8_t )12);
          } else {
            {
#line 165
            tmp___41 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )((int8_t )169),
                                          (int8_t const   )'d', (int8_t const   )'a',
                                          (int8_t const   )'y');
            }
#line 165
            if (tmp___41) {
#line 166
              return ((uint8_t )13);
            } else {
              {
#line 167
              tmp___40 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )((int8_t )169),
                                            (int8_t const   )'t', (int8_t const   )'o',
                                            (int8_t const   )'o');
              }
#line 167
              if (tmp___40) {
#line 168
                return ((uint8_t )14);
              } else {
                {
#line 169
                tmp___39 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )((int8_t )169),
                                              (int8_t const   )'c', (int8_t const   )'m',
                                              (int8_t const   )'t');
                }
#line 169
                if (tmp___39) {
#line 170
                  return ((uint8_t )15);
                } else {
                  {
#line 171
                  tmp___38 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )((int8_t )169),
                                                (int8_t const   )'g', (int8_t const   )'e',
                                                (int8_t const   )'n');
                  }
#line 171
                  if (tmp___38) {
#line 172
                    return ((uint8_t )16);
                  } else {
                    {
#line 173
                    tmp___37 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )((int8_t )169),
                                                  (int8_t const   )'g', (int8_t const   )'r',
                                                  (int8_t const   )'p');
                    }
#line 173
                    if (tmp___37) {
#line 174
                      return ((uint8_t )158);
                    } else {
                      {
#line 175
                      tmp___36 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )((int8_t )169),
                                                    (int8_t const   )'l', (int8_t const   )'y',
                                                    (int8_t const   )'r');
                      }
#line 175
                      if (tmp___36) {
#line 176
                        return ((uint8_t )159);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 179
  tmp___69 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'e', (int8_t const   )'d',
                                (int8_t const   )'t', (int8_t const   )'s');
  }
#line 179
  if (tmp___69) {
#line 180
    return ((uint8_t )3);
  } else {
    {
#line 181
    tmp___68 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'e', (int8_t const   )'s',
                                  (int8_t const   )'d', (int8_t const   )'s');
    }
#line 181
    if (tmp___68) {
#line 182
      return ((uint8_t )147);
    } else {
      {
#line 183
      tmp___67 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'f', (int8_t const   )'t',
                                    (int8_t const   )'y', (int8_t const   )'p');
      }
#line 183
      if (tmp___67) {
#line 184
        return ((uint8_t )129);
      } else {
        {
#line 185
        tmp___66 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'f', (int8_t const   )'r',
                                      (int8_t const   )'e', (int8_t const   )'e');
        }
#line 185
        if (tmp___66) {
#line 186
          return ((uint8_t )255);
        } else {
          {
#line 187
          tmp___65 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'h', (int8_t const   )'m',
                                        (int8_t const   )'h', (int8_t const   )'d');
          }
#line 187
          if (tmp___65) {
#line 188
            return ((uint8_t )137);
          } else {
            {
#line 189
            tmp___64 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'v', (int8_t const   )'m',
                                          (int8_t const   )'h', (int8_t const   )'d');
            }
#line 189
            if (tmp___64) {
#line 190
              return ((uint8_t )135);
            } else {
              {
#line 191
              tmp___63 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'u', (int8_t const   )'d',
                                            (int8_t const   )'t', (int8_t const   )'a');
              }
#line 191
              if (tmp___63) {
#line 192
                return ((uint8_t )7);
              } else {
                {
#line 193
                tmp___62 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'i', (int8_t const   )'l',
                                              (int8_t const   )'s', (int8_t const   )'t');
                }
#line 193
                if (tmp___62) {
#line 194
                  return ((uint8_t )8);
                } else {
                  {
#line 195
                  tmp___61 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'n',
                                                (int8_t const   )'a', (int8_t const   )'m',
                                                (int8_t const   )'e');
                  }
#line 195
                  if (tmp___61) {
#line 196
                    return ((uint8_t )149);
                  } else {
                    {
#line 197
                    tmp___60 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'d',
                                                  (int8_t const   )'a', (int8_t const   )'t',
                                                  (int8_t const   )'a');
                    }
#line 197
                    if (tmp___60) {
#line 198
                      return ((uint8_t )150);
                    } else {
                      {
#line 199
                      tmp___59 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'d',
                                                    (int8_t const   )'i', (int8_t const   )'s',
                                                    (int8_t const   )'k');
                      }
#line 199
                      if (tmp___59) {
#line 200
                        return ((uint8_t )18);
                      } else {
                        {
#line 201
                        tmp___58 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'g',
                                                      (int8_t const   )'n', (int8_t const   )'r',
                                                      (int8_t const   )'e');
                        }
#line 201
                        if (tmp___58) {
#line 202
                          return ((uint8_t )20);
                        } else {
                          {
#line 203
                          tmp___57 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'c',
                                                        (int8_t const   )'o', (int8_t const   )'v',
                                                        (int8_t const   )'r');
                          }
#line 203
                          if (tmp___57) {
#line 204
                            return ((uint8_t )22);
                          } else {
                            {
#line 205
                            tmp___56 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'c',
                                                          (int8_t const   )'p', (int8_t const   )'i',
                                                          (int8_t const   )'l');
                            }
#line 205
                            if (tmp___56) {
#line 206
                              return ((uint8_t )19);
                            } else {
                              {
#line 207
                              tmp___55 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'c',
                                                            (int8_t const   )'t',
                                                            (int8_t const   )'t',
                                                            (int8_t const   )'s');
                              }
#line 207
                              if (tmp___55) {
#line 208
                                return ((uint8_t )151);
                              } else {
                                {
#line 209
                                tmp___54 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'d',
                                                              (int8_t const   )'r',
                                                              (int8_t const   )'m',
                                                              (int8_t const   )'s');
                                }
#line 209
                                if (tmp___54) {
#line 210
                                  return ((uint8_t )23);
                                } else {
                                  {
#line 211
                                  tmp___53 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'f',
                                                                (int8_t const   )'r',
                                                                (int8_t const   )'m',
                                                                (int8_t const   )'a');
                                  }
#line 211
                                  if (tmp___53) {
#line 212
                                    return ((uint8_t )152);
                                  } else {
                                    {
#line 213
                                    tmp___52 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'p',
                                                                  (int8_t const   )'r',
                                                                  (int8_t const   )'i',
                                                                  (int8_t const   )'v');
                                    }
#line 213
                                    if (tmp___52) {
#line 214
                                      return ((uint8_t )154);
                                    } else {
                                      {
#line 215
                                      tmp___51 = mp4ff_atom_compare(a, b, c, d, (int8_t const   )'i',
                                                                    (int8_t const   )'v',
                                                                    (int8_t const   )'i',
                                                                    (int8_t const   )'v');
                                      }
#line 215
                                      if (tmp___51) {
#line 216
                                        return ((uint8_t )153);
                                      } else {
                                        {
#line 217
                                        tmp___50 = mp4ff_atom_compare(a, b, c, d,
                                                                      (int8_t const   )'u',
                                                                      (int8_t const   )'s',
                                                                      (int8_t const   )'e',
                                                                      (int8_t const   )'r');
                                        }
#line 217
                                        if (tmp___50) {
#line 218
                                          return ((uint8_t )155);
                                        } else {
                                          {
#line 219
                                          tmp___49 = mp4ff_atom_compare(a, b, c, d,
                                                                        (int8_t const   )'k',
                                                                        (int8_t const   )'e',
                                                                        (int8_t const   )'y',
                                                                        (int8_t const   )' ');
                                          }
#line 219
                                          if (tmp___49) {
#line 220
                                            return ((uint8_t )156);
                                          } else {
                                            {
#line 221
                                            tmp___48 = mp4ff_atom_compare(a, b, c,
                                                                          d, (int8_t const   )'a',
                                                                          (int8_t const   )'A',
                                                                          (int8_t const   )'R',
                                                                          (int8_t const   )'T');
                                            }
#line 221
                                            if (tmp___48) {
#line 222
                                              return ((uint8_t )157);
                                            } else {
                                              {
#line 223
                                              tmp___47 = mp4ff_atom_compare(a, b,
                                                                            c, d,
                                                                            (int8_t const   )'d',
                                                                            (int8_t const   )'e',
                                                                            (int8_t const   )'s',
                                                                            (int8_t const   )'c');
                                              }
#line 223
                                              if (tmp___47) {
#line 224
                                                return ((uint8_t )160);
                                              } else {
                                                {
#line 225
                                                tmp___46 = mp4ff_atom_compare(a, b,
                                                                              c, d,
                                                                              (int8_t const   )'p',
                                                                              (int8_t const   )'c',
                                                                              (int8_t const   )'s',
                                                                              (int8_t const   )'t');
                                                }
#line 225
                                                if (tmp___46) {
#line 226
                                                  return ((uint8_t )172);
                                                } else {
#line 228
                                                  return ((uint8_t )255);
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
uint64_t mp4ff_atom_read_header(mp4ff_t *f , uint8_t *atom_type , uint8_t *header_size ) 
{ 
  uint64_t size ;
  int32_t ret ;
  int8_t atom_header[8] ;
  int32_t tmp ;

  {
  {
#line 238
  ret = mp4ff_read_data(f, atom_header, (uint32_t )8);
  }
#line 239
  if (ret != 8) {
#line 240
    return ((uint64_t )0);
  }
  {
#line 242
  tmp = mp4ff_atom_get_size((int8_t const   *)(atom_header));
#line 242
  size = (uint64_t )tmp;
#line 243
  *header_size = (uint8_t )8;
  }
#line 246
  if (size == 1UL) {
    {
#line 248
    *header_size = (uint8_t )16;
#line 249
    size = mp4ff_read_int64(f);
    }
  }
  {
#line 254
  *atom_type = mp4ff_atom_name_to_type((int8_t const   )atom_header[4], (int8_t const   )atom_header[5],
                                       (int8_t const   )atom_header[6], (int8_t const   )atom_header[7]);
  }
#line 256
  return (size);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_read_stsz(mp4ff_t *f ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;
  int32_t i ;
  void *tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 261
  mp4ff_read_char(f);
#line 262
  mp4ff_read_int24(f);
#line 263
  tmp = mp4ff_read_int32(f);
#line 263
  (f->track[f->total_tracks - 1])->stsz_sample_size = (int32_t )tmp;
#line 264
  tmp___0 = mp4ff_read_int32(f);
#line 264
  (f->track[f->total_tracks - 1])->stsz_sample_count = (int32_t )tmp___0;
  }
#line 266
  if ((f->track[f->total_tracks - 1])->stsz_sample_size == 0) {
    {
#line 269
    tmp___1 = malloc((unsigned long )(f->track[f->total_tracks - 1])->stsz_sample_count * sizeof(int32_t ));
#line 269
    (f->track[f->total_tracks - 1])->stsz_table = (int32_t *)tmp___1;
#line 272
    i = 0;
    }
    {
#line 272
    while (1) {
      while_continue: /* CIL Label */ ;
#line 272
      if (! (i < (f->track[f->total_tracks - 1])->stsz_sample_count)) {
#line 272
        goto while_break;
      }
      {
#line 274
      tmp___2 = mp4ff_read_int32(f);
#line 274
      *((f->track[f->total_tracks - 1])->stsz_table + i) = (int32_t )tmp___2;
#line 272
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 278
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_read_esds(mp4ff_t *f ) 
{ 
  uint8_t tag ;
  uint32_t temp ;
  uint32_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  uint32_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 286
  mp4ff_read_char(f);
#line 287
  mp4ff_read_int24(f);
#line 290
  tag = mp4ff_read_char(f);
  }
#line 291
  if ((int )tag == 3) {
    {
#line 294
    tmp = mp4ff_read_mp4_descr_length(f);
    }
#line 294
    if (tmp < 20U) {
#line 296
      return (1);
    }
    {
#line 299
    mp4ff_read_int24(f);
    }
  } else {
    {
#line 302
    mp4ff_read_int16(f);
    }
  }
  {
#line 306
  tmp___0 = mp4ff_read_char(f);
  }
#line 306
  if ((int )tmp___0 != 4) {
#line 308
    return (1);
  }
  {
#line 312
  temp = mp4ff_read_mp4_descr_length(f);
  }
#line 313
  if (temp < 13U) {
#line 313
    return (1);
  }
  {
#line 315
  tmp___1 = mp4ff_read_char(f);
#line 315
  (f->track[f->total_tracks - 1])->audioType = (int32_t )tmp___1;
#line 316
  mp4ff_read_int32(f);
#line 317
  (f->track[f->total_tracks - 1])->maxBitrate = mp4ff_read_int32(f);
#line 318
  (f->track[f->total_tracks - 1])->avgBitrate = mp4ff_read_int32(f);
#line 321
  tmp___2 = mp4ff_read_char(f);
  }
#line 321
  if ((int )tmp___2 != 5) {
#line 323
    return (1);
  }
  {
#line 327
  tmp___3 = mp4ff_read_mp4_descr_length(f);
#line 327
  (f->track[f->total_tracks - 1])->decoderConfigLen = (int32_t )tmp___3;
  }
#line 329
  if ((f->track[f->total_tracks - 1])->decoderConfig) {
    {
#line 330
    free((void *)(f->track[f->total_tracks - 1])->decoderConfig);
    }
  }
  {
#line 331
  tmp___4 = malloc((size_t )(f->track[f->total_tracks - 1])->decoderConfigLen);
#line 331
  (f->track[f->total_tracks - 1])->decoderConfig = (uint8_t *)tmp___4;
  }
#line 332
  if ((f->track[f->total_tracks - 1])->decoderConfig) {
    {
#line 334
    mp4ff_read_data(f, (int8_t *)(f->track[f->total_tracks - 1])->decoderConfig, (uint32_t )(f->track[f->total_tracks - 1])->decoderConfigLen);
    }
  } else {
#line 336
    (f->track[f->total_tracks - 1])->decoderConfigLen = 0;
  }
#line 340
  return (0);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_read_mp4a(mp4ff_t *f ) 
{ 
  uint64_t size ;
  int32_t i ;
  uint8_t atom_type ;
  uint8_t header_size ;
  uint16_t tmp ;
  uint16_t tmp___0 ;

  {
#line 347
  atom_type = (uint8_t )0;
#line 348
  header_size = (uint8_t )0;
#line 350
  i = 0;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! (i < 6)) {
#line 350
      goto while_break;
    }
    {
#line 352
    mp4ff_read_char(f);
#line 350
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 354
  mp4ff_read_int16(f);
#line 356
  mp4ff_read_int32(f);
#line 357
  mp4ff_read_int32(f);
#line 359
  tmp = mp4ff_read_int16(f);
#line 359
  (f->track[f->total_tracks - 1])->channelCount = (int32_t )tmp;
#line 360
  tmp___0 = mp4ff_read_int16(f);
#line 360
  (f->track[f->total_tracks - 1])->sampleSize = (int32_t )tmp___0;
#line 362
  mp4ff_read_int16(f);
#line 363
  mp4ff_read_int16(f);
#line 365
  (f->track[f->total_tracks - 1])->sampleRate = mp4ff_read_int16(f);
#line 367
  mp4ff_read_int16(f);
#line 369
  size = mp4ff_atom_read_header(f, & atom_type, & header_size);
  }
#line 370
  if ((int )atom_type == 147) {
    {
#line 372
    mp4ff_read_esds(f);
    }
  }
#line 375
  return (0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_read_stsd(mp4ff_t *f ) 
{ 
  int32_t i ;
  uint8_t header_size ;
  uint32_t tmp ;
  uint64_t skip ;
  int64_t tmp___0 ;
  uint64_t size ;
  uint8_t atom_type ;

  {
  {
#line 381
  header_size = (uint8_t )0;
#line 383
  mp4ff_read_char(f);
#line 384
  mp4ff_read_int24(f);
#line 386
  tmp = mp4ff_read_int32(f);
#line 386
  (f->track[f->total_tracks - 1])->stsd_entry_count = (int32_t )tmp;
#line 388
  i = 0;
  }
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (i < (f->track[f->total_tracks - 1])->stsd_entry_count)) {
#line 388
      goto while_break;
    }
    {
#line 390
    tmp___0 = mp4ff_position((mp4ff_t const   *)f);
#line 390
    skip = (uint64_t )tmp___0;
#line 392
    atom_type = (uint8_t )0;
#line 393
    size = mp4ff_atom_read_header(f, & atom_type, & header_size);
#line 394
    skip += size;
    }
#line 396
    if ((int )atom_type == 144) {
      {
#line 398
      (f->track[f->total_tracks - 1])->type = 1;
#line 399
      mp4ff_read_mp4a(f);
      }
    } else
#line 400
    if ((int )atom_type == 145) {
#line 401
      (f->track[f->total_tracks - 1])->type = 2;
    } else
#line 402
    if ((int )atom_type == 146) {
#line 403
      (f->track[f->total_tracks - 1])->type = 3;
    } else {
#line 405
      (f->track[f->total_tracks - 1])->type = 0;
    }
    {
#line 408
    mp4ff_set_position(f, (int64_t const   )skip);
#line 388
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_read_stsc(mp4ff_t *f ) 
{ 
  int32_t i ;
  uint32_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;

  {
  {
#line 418
  mp4ff_read_char(f);
#line 419
  mp4ff_read_int24(f);
#line 420
  tmp = mp4ff_read_int32(f);
#line 420
  (f->track[f->total_tracks - 1])->stsc_entry_count = (int32_t )tmp;
#line 422
  tmp___0 = malloc((unsigned long )(f->track[f->total_tracks - 1])->stsc_entry_count * sizeof(int32_t ));
#line 422
  (f->track[f->total_tracks - 1])->stsc_first_chunk = (int32_t *)tmp___0;
#line 424
  tmp___1 = malloc((unsigned long )(f->track[f->total_tracks - 1])->stsc_entry_count * sizeof(int32_t ));
#line 424
  (f->track[f->total_tracks - 1])->stsc_samples_per_chunk = (int32_t *)tmp___1;
#line 426
  tmp___2 = malloc((unsigned long )(f->track[f->total_tracks - 1])->stsc_entry_count * sizeof(int32_t ));
#line 426
  (f->track[f->total_tracks - 1])->stsc_sample_desc_index = (int32_t *)tmp___2;
#line 429
  i = 0;
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (i < (f->track[f->total_tracks - 1])->stsc_entry_count)) {
#line 429
      goto while_break;
    }
    {
#line 431
    tmp___3 = mp4ff_read_int32(f);
#line 431
    *((f->track[f->total_tracks - 1])->stsc_first_chunk + i) = (int32_t )tmp___3;
#line 432
    tmp___4 = mp4ff_read_int32(f);
#line 432
    *((f->track[f->total_tracks - 1])->stsc_samples_per_chunk + i) = (int32_t )tmp___4;
#line 433
    tmp___5 = mp4ff_read_int32(f);
#line 433
    *((f->track[f->total_tracks - 1])->stsc_sample_desc_index + i) = (int32_t )tmp___5;
#line 429
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  return (0);
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_read_stco(mp4ff_t *f ) 
{ 
  int32_t i ;
  uint32_t tmp ;
  void *tmp___0 ;
  uint32_t tmp___1 ;

  {
  {
#line 443
  mp4ff_read_char(f);
#line 444
  mp4ff_read_int24(f);
#line 445
  tmp = mp4ff_read_int32(f);
#line 445
  (f->track[f->total_tracks - 1])->stco_entry_count = (int32_t )tmp;
#line 447
  tmp___0 = malloc((unsigned long )(f->track[f->total_tracks - 1])->stco_entry_count * sizeof(int32_t ));
#line 447
  (f->track[f->total_tracks - 1])->stco_chunk_offset = (int32_t *)tmp___0;
#line 450
  i = 0;
  }
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (i < (f->track[f->total_tracks - 1])->stco_entry_count)) {
#line 450
      goto while_break;
    }
    {
#line 452
    tmp___1 = mp4ff_read_int32(f);
#line 452
    *((f->track[f->total_tracks - 1])->stco_chunk_offset + i) = (int32_t )tmp___1;
#line 450
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (0);
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_read_ctts(mp4ff_t *f ) 
{ 
  int32_t i ;
  mp4ff_track_t *p_track ;
  uint32_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 461
  p_track = f->track[f->total_tracks - 1];
#line 463
  if (p_track->ctts_entry_count) {
#line 463
    return (0);
  }
  {
#line 465
  mp4ff_read_char(f);
#line 466
  mp4ff_read_int24(f);
#line 467
  tmp = mp4ff_read_int32(f);
#line 467
  p_track->ctts_entry_count = (int32_t )tmp;
#line 469
  tmp___0 = malloc((unsigned long )p_track->ctts_entry_count * sizeof(int32_t ));
#line 469
  p_track->ctts_sample_count = (int32_t *)tmp___0;
#line 470
  tmp___1 = malloc((unsigned long )p_track->ctts_entry_count * sizeof(int32_t ));
#line 470
  p_track->ctts_sample_offset = (int32_t *)tmp___1;
  }
#line 472
  if ((unsigned long )p_track->ctts_sample_count == (unsigned long )((int32_t *)0)) {
#line 472
    goto _L;
  } else
#line 472
  if ((unsigned long )p_track->ctts_sample_offset == (unsigned long )((int32_t *)0)) {
    _L: /* CIL Label */ 
#line 474
    if (p_track->ctts_sample_count) {
      {
#line 474
      free((void *)p_track->ctts_sample_count);
#line 474
      p_track->ctts_sample_count = (int32_t *)0;
      }
    }
#line 475
    if (p_track->ctts_sample_offset) {
      {
#line 475
      free((void *)p_track->ctts_sample_offset);
#line 475
      p_track->ctts_sample_offset = (int32_t *)0;
      }
    }
#line 476
    p_track->ctts_entry_count = 0;
#line 477
    return (0);
  } else {
#line 481
    i = 0;
    {
#line 481
    while (1) {
      while_continue: /* CIL Label */ ;
#line 481
      if (! (i < (f->track[f->total_tracks - 1])->ctts_entry_count)) {
#line 481
        goto while_break;
      }
      {
#line 483
      tmp___2 = mp4ff_read_int32(f);
#line 483
      *(p_track->ctts_sample_count + i) = (int32_t )tmp___2;
#line 484
      tmp___3 = mp4ff_read_int32(f);
#line 484
      *(p_track->ctts_sample_offset + i) = (int32_t )tmp___3;
#line 481
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 486
    return (1);
  }
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_read_stts(mp4ff_t *f ) 
{ 
  int32_t i ;
  mp4ff_track_t *p_track ;
  uint32_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 493
  p_track = f->track[f->total_tracks - 1];
#line 495
  if (p_track->stts_entry_count) {
#line 495
    return (0);
  }
  {
#line 497
  mp4ff_read_char(f);
#line 498
  mp4ff_read_int24(f);
#line 499
  tmp = mp4ff_read_int32(f);
#line 499
  p_track->stts_entry_count = (int32_t )tmp;
#line 501
  tmp___0 = malloc((unsigned long )p_track->stts_entry_count * sizeof(int32_t ));
#line 501
  p_track->stts_sample_count = (int32_t *)tmp___0;
#line 502
  tmp___1 = malloc((unsigned long )p_track->stts_entry_count * sizeof(int32_t ));
#line 502
  p_track->stts_sample_delta = (int32_t *)tmp___1;
  }
#line 504
  if ((unsigned long )p_track->stts_sample_count == (unsigned long )((int32_t *)0)) {
#line 504
    goto _L;
  } else
#line 504
  if ((unsigned long )p_track->stts_sample_delta == (unsigned long )((int32_t *)0)) {
    _L: /* CIL Label */ 
#line 506
    if (p_track->stts_sample_count) {
      {
#line 506
      free((void *)p_track->stts_sample_count);
#line 506
      p_track->stts_sample_count = (int32_t *)0;
      }
    }
#line 507
    if (p_track->stts_sample_delta) {
      {
#line 507
      free((void *)p_track->stts_sample_delta);
#line 507
      p_track->stts_sample_delta = (int32_t *)0;
      }
    }
#line 508
    p_track->stts_entry_count = 0;
#line 509
    return (0);
  } else {
#line 513
    i = 0;
    {
#line 513
    while (1) {
      while_continue: /* CIL Label */ ;
#line 513
      if (! (i < (f->track[f->total_tracks - 1])->stts_entry_count)) {
#line 513
        goto while_break;
      }
      {
#line 515
      tmp___2 = mp4ff_read_int32(f);
#line 515
      *(p_track->stts_sample_count + i) = (int32_t )tmp___2;
#line 516
      tmp___3 = mp4ff_read_int32(f);
#line 516
      *(p_track->stts_sample_delta + i) = (int32_t )tmp___3;
#line 513
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 518
    return (1);
  }
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_read_mvhd(mp4ff_t *f ) 
{ 
  int32_t i ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 526
  mp4ff_read_char(f);
#line 527
  mp4ff_read_int24(f);
#line 528
  mp4ff_read_int32(f);
#line 529
  mp4ff_read_int32(f);
#line 530
  tmp = mp4ff_read_int32(f);
#line 530
  f->time_scale = (int32_t )tmp;
#line 531
  tmp___0 = mp4ff_read_int32(f);
#line 531
  f->duration = (int32_t )tmp___0;
#line 532
  mp4ff_read_int32(f);
#line 533
  mp4ff_read_int16(f);
#line 534
  i = 0;
  }
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (i < 10)) {
#line 534
      goto while_break;
    }
    {
#line 536
    mp4ff_read_char(f);
#line 534
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 538
  i = 0;
  {
#line 538
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 538
    if (! (i < 9)) {
#line 538
      goto while_break___0;
    }
    {
#line 540
    mp4ff_read_int32(f);
#line 538
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 542
  mp4ff_read_int32(f);
#line 543
  mp4ff_read_int32(f);
#line 544
  mp4ff_read_int32(f);
#line 545
  mp4ff_read_int32(f);
#line 546
  mp4ff_read_int32(f);
#line 547
  mp4ff_read_int32(f);
#line 548
  mp4ff_read_int32(f);
  }
#line 550
  return (0);
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_read_mdhd(mp4ff_t *f ) 
{ 
  uint32_t version ;
  uint32_t temp ;

  {
  {
#line 600
  version = mp4ff_read_int32(f);
  }
#line 601
  if (version == 1U) {
    {
#line 603
    mp4ff_read_int64(f);
#line 604
    mp4ff_read_int64(f);
#line 605
    (f->track[f->total_tracks - 1])->timeScale = mp4ff_read_int32(f);
#line 606
    (f->track[f->total_tracks - 1])->duration = mp4ff_read_int64(f);
    }
  } else {
    {
#line 612
    mp4ff_read_int32(f);
#line 613
    mp4ff_read_int32(f);
#line 614
    (f->track[f->total_tracks - 1])->timeScale = mp4ff_read_int32(f);
#line 615
    temp = mp4ff_read_int32(f);
    }
#line 616
    if (temp == 4294967295U) {
#line 616
      (f->track[f->total_tracks - 1])->duration = (uint64_t )-1;
    } else {
#line 616
      (f->track[f->total_tracks - 1])->duration = (uint64_t )temp;
    }
  }
  {
#line 618
  mp4ff_read_int16(f);
#line 619
  mp4ff_read_int16(f);
  }
#line 620
  return (1);
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
static int32_t mp4ff_read_meta(mp4ff_t *f , uint64_t const   size ) 
{ 
  uint64_t subsize ;
  uint64_t sumsize ;
  uint8_t atom_type ;
  uint8_t header_size ;
  int64_t tmp ;

  {
  {
#line 625
  sumsize = (uint64_t )0;
#line 627
  header_size = (uint8_t )0;
#line 629
  mp4ff_read_char(f);
#line 630
  mp4ff_read_int24(f);
  }
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    if (! (sumsize < (uint64_t )(size - (uint64_t const   )((int )header_size + 4)))) {
#line 632
      goto while_break;
    }
    {
#line 634
    subsize = mp4ff_atom_read_header(f, & atom_type, & header_size);
    }
#line 635
    if (subsize <= (uint64_t )((int )header_size + 4)) {
#line 636
      return (1);
    }
#line 637
    if ((int )atom_type == 8) {
      {
#line 639
      mp4ff_parse_metadata(f, (int32_t const   )((uint32_t )(subsize - (uint64_t )((int )header_size + 4))));
      }
    } else {
      {
#line 641
      tmp = mp4ff_position((mp4ff_t const   *)f);
#line 641
      mp4ff_set_position(f, (int64_t const   )(((uint64_t )tmp + subsize) - (uint64_t )header_size));
      }
    }
#line 643
    sumsize += subsize;
  }
  while_break: /* CIL Label */ ;
  }
#line 646
  return (0);
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4atom.c"
int32_t mp4ff_atom_read(mp4ff_t *f , int32_t const   size , uint8_t const   atom_type ) 
{ 
  uint64_t dest_position ;
  int64_t tmp ;

  {
  {
#line 652
  tmp = mp4ff_position((mp4ff_t const   *)f);
#line 652
  dest_position = (uint64_t )((tmp + (int64_t )size) - 8L);
  }
#line 653
  if ((int const   )atom_type == 140) {
    {
#line 656
    mp4ff_read_stsz(f);
    }
  } else
#line 657
  if ((int const   )atom_type == 139) {
    {
#line 659
    mp4ff_read_stts(f);
    }
  } else
#line 660
  if ((int const   )atom_type == 151) {
    {
#line 662
    mp4ff_read_ctts(f);
    }
  } else
#line 663
  if ((int const   )atom_type == 143) {
    {
#line 665
    mp4ff_read_stsc(f);
    }
  } else
#line 666
  if ((int const   )atom_type == 142) {
    {
#line 668
    mp4ff_read_stco(f);
    }
  } else
#line 669
  if ((int const   )atom_type == 138) {
    {
#line 671
    mp4ff_read_stsd(f);
    }
  } else
#line 672
  if ((int const   )atom_type == 131) {
    {
#line 674
    mp4ff_read_mvhd(f);
    }
  } else
#line 675
  if ((int const   )atom_type == 134) {
    {
#line 677
    mp4ff_read_mdhd(f);
    }
  } else
#line 679
  if ((int const   )atom_type == 148) {
    {
#line 681
    mp4ff_read_meta(f, (uint64_t const   )size);
    }
  }
  {
#line 685
  mp4ff_set_position(f, (int64_t const   )dest_position);
  }
#line 688
  return (0);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
static int32_t mp4ff_chunk_of_sample(mp4ff_t const   *f , int32_t const   track ,
                                     int32_t const   sample , int32_t *chunk_sample ,
                                     int32_t *chunk ) ;
#line 279
static int32_t mp4ff_chunk_to_offset(mp4ff_t const   *f , int32_t const   track ,
                                     int32_t const   chunk ) ;
#line 280
static int32_t mp4ff_sample_range_size(mp4ff_t const   *f , int32_t const   track ,
                                       int32_t const   chunk_sample , int32_t const   sample ) ;
#line 282
static int32_t mp4ff_sample_to_offset(mp4ff_t const   *f , int32_t const   track ,
                                      int32_t const   sample ) ;
#line 283
int32_t mp4ff_audio_frame_size(mp4ff_t const   *f , int32_t const   track , int32_t const   sample ) ;
#line 284
int32_t mp4ff_set_sample_position(mp4ff_t *f , int32_t const   track , int32_t const   sample ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4sample.c"
static int32_t mp4ff_chunk_of_sample(mp4ff_t const   *f , int32_t const   track ,
                                     int32_t const   sample , int32_t *chunk_sample ,
                                     int32_t *chunk ) 
{ 
  int32_t total_entries ;
  int32_t chunk2entry ;
  int32_t chunk1 ;
  int32_t chunk2 ;
  int32_t chunk1samples ;
  int32_t range_samples ;
  int32_t total ;

  {
#line 38
  total_entries = 0;
#line 40
  total = 0;
#line 42
  if ((unsigned long )f->track[track] == (unsigned long )((void *)0)) {
#line 44
    return (-1);
  }
#line 47
  total_entries = (f->track[track])->stsc_entry_count;
#line 49
  chunk1 = 1;
#line 50
  chunk1samples = 0;
#line 51
  chunk2entry = 0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    chunk2 = *((f->track[track])->stsc_first_chunk + chunk2entry);
#line 56
    *chunk = chunk2 - chunk1;
#line 57
    range_samples = *chunk * chunk1samples;
#line 59
    if (sample < (int32_t const   )(total + range_samples)) {
#line 59
      goto while_break;
    }
#line 61
    chunk1samples = *((f->track[track])->stsc_samples_per_chunk + chunk2entry);
#line 62
    chunk1 = chunk2;
#line 64
    if (chunk2entry < total_entries) {
#line 66
      chunk2entry ++;
#line 67
      total += range_samples;
    }
#line 53
    if (! (chunk2entry < total_entries)) {
#line 53
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  if (chunk1samples) {
#line 72
    *chunk = (int32_t )((sample - (int32_t const   )total) / (int32_t const   )chunk1samples + (int32_t const   )chunk1);
  } else {
#line 74
    *chunk = 1;
  }
#line 76
  *chunk_sample = total + (*chunk - chunk1) * chunk1samples;
#line 78
  return (0);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4sample.c"
static int32_t mp4ff_chunk_to_offset(mp4ff_t const   *f , int32_t const   track ,
                                     int32_t const   chunk ) 
{ 
  mp4ff_track_t const   *p_track ;

  {
#line 83
  p_track = (mp4ff_track_t const   *)f->track[track];
#line 85
  if (p_track->stco_entry_count) {
#line 85
    if (chunk > p_track->stco_entry_count) {
#line 87
      return (*(p_track->stco_chunk_offset + (p_track->stco_entry_count - 1)));
    } else {
#line 85
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 88
  if (p_track->stco_entry_count) {
#line 89
    return (*(p_track->stco_chunk_offset + (chunk - 1)));
  } else {
#line 91
    return (8);
  }
#line 94
  return (0);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4sample.c"
static int32_t mp4ff_sample_range_size(mp4ff_t const   *f , int32_t const   track ,
                                       int32_t const   chunk_sample , int32_t const   sample ) 
{ 
  int32_t i ;
  int32_t total ;
  mp4ff_track_t const   *p_track ;

  {
#line 101
  p_track = (mp4ff_track_t const   *)f->track[track];
#line 103
  if (p_track->stsz_sample_size) {
#line 105
    return ((int32_t )((sample - chunk_sample) * p_track->stsz_sample_size));
  } else {
#line 109
    if (sample >= p_track->stsz_sample_count) {
#line 109
      return (0);
    }
#line 111
    i = (int32_t )chunk_sample;
#line 111
    total = 0;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! (i < (int32_t )sample)) {
#line 111
        goto while_break;
      }
#line 113
      total += *(p_track->stsz_table + i);
#line 111
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 117
  return (total);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4sample.c"
static int32_t mp4ff_sample_to_offset(mp4ff_t const   *f , int32_t const   track ,
                                      int32_t const   sample ) 
{ 
  int32_t chunk ;
  int32_t chunk_sample ;
  int32_t chunk_offset1 ;
  int32_t chunk_offset2 ;
  int32_t tmp ;

  {
  {
#line 124
  mp4ff_chunk_of_sample(f, track, sample, & chunk_sample, & chunk);
#line 126
  chunk_offset1 = mp4ff_chunk_to_offset(f, track, (int32_t const   )chunk);
#line 127
  tmp = mp4ff_sample_range_size(f, track, (int32_t const   )chunk_sample, sample);
#line 127
  chunk_offset2 = chunk_offset1 + tmp;
  }
#line 129
  return (chunk_offset2);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4sample.c"
int32_t mp4ff_audio_frame_size(mp4ff_t const   *f , int32_t const   track , int32_t const   sample ) 
{ 
  int32_t bytes ;
  mp4ff_track_t const   *p_track ;

  {
#line 135
  p_track = (mp4ff_track_t const   *)f->track[track];
#line 137
  if (p_track->stsz_sample_size) {
#line 139
    bytes = (int32_t )p_track->stsz_sample_size;
  } else {
#line 141
    bytes = *(p_track->stsz_table + sample);
  }
#line 144
  return (bytes);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4sample.c"
int32_t mp4ff_set_sample_position(mp4ff_t *f , int32_t const   track , int32_t const   sample ) 
{ 
  int32_t offset ;

  {
  {
#line 151
  offset = mp4ff_sample_to_offset((mp4ff_t const   *)f, track, sample);
#line 152
  mp4ff_set_position(f, (int64_t const   )offset);
  }
#line 154
  return (0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
int32_t mp4ff_write_data(mp4ff_t *f , int8_t *data , uint32_t size ) ;
#line 251
int32_t mp4ff_write_int32(mp4ff_t *f , uint32_t const   data ) ;
#line 255
int32_t mp4ff_truncate(mp4ff_t *f ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
int32_t mp4ff_read_data(mp4ff_t *f , int8_t *data , uint32_t size ) 
{ 
  int32_t result ;
  uint32_t tmp ;

  {
  {
#line 36
  result = 1;
#line 38
  tmp = (*((f->stream)->read))((f->stream)->user_data, (void *)data, size);
#line 38
  result = (int32_t )tmp;
#line 40
  f->current_position += (int64_t )size;
  }
#line 42
  return (result);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
int32_t mp4ff_truncate(mp4ff_t *f ) 
{ 
  uint32_t tmp ;

  {
  {
#line 47
  tmp = (*((f->stream)->truncate))((f->stream)->user_data);
  }
#line 47
  return ((int32_t )tmp);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
int32_t mp4ff_write_data(mp4ff_t *f , int8_t *data , uint32_t size ) 
{ 
  int32_t result ;
  uint32_t tmp ;

  {
  {
#line 52
  result = 1;
#line 54
  tmp = (*((f->stream)->write))((f->stream)->user_data, (void *)data, size);
#line 54
  result = (int32_t )tmp;
#line 56
  f->current_position += (int64_t )size;
  }
#line 58
  return (result);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
int32_t mp4ff_write_int32(mp4ff_t *f , uint32_t const   data ) 
{ 
  uint32_t result ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  int8_t temp[4] ;
  int32_t tmp ;

  {
  {
#line 67
  *((uint32_t *)(temp)) = (uint32_t )data;
#line 68
  a = (uint32_t )((uint8_t )temp[0]);
#line 69
  b = (uint32_t )((uint8_t )temp[1]);
#line 70
  c = (uint32_t )((uint8_t )temp[2]);
#line 71
  d = (uint32_t )((uint8_t )temp[3]);
#line 73
  result = (((a << 24) | (b << 16)) | (c << 8)) | d;
#line 75
  tmp = mp4ff_write_data(f, (int8_t *)((uint8_t *)(& result)), (uint32_t )sizeof(result));
  }
#line 75
  return (tmp);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
int32_t mp4ff_set_position(mp4ff_t *f , int64_t const   position ) 
{ 


  {
  {
#line 80
  (*((f->stream)->seek))((f->stream)->user_data, (uint64_t )position);
#line 81
  f->current_position = (int64_t )position;
  }
#line 83
  return (0);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
int64_t mp4ff_position(mp4ff_t const   *f ) 
{ 


  {
#line 88
  return ((int64_t )f->current_position);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
uint64_t mp4ff_read_int64(mp4ff_t *f ) 
{ 
  uint8_t data[8] ;
  uint64_t result ;
  int8_t i ;

  {
  {
#line 94
  result = (uint64_t )0;
#line 97
  mp4ff_read_data(f, (int8_t *)(data), (uint32_t )8);
#line 99
  i = (int8_t )0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! ((int )i < 8)) {
#line 99
      goto while_break;
    }
#line 101
    result |= (uint64_t )data[i] << (7 - (int )i) * 8;
#line 99
    i = (int8_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return (result);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
uint32_t mp4ff_read_int32(mp4ff_t *f ) 
{ 
  uint32_t result ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  int8_t data[4] ;

  {
  {
#line 113
  mp4ff_read_data(f, data, (uint32_t )4);
#line 114
  a = (uint32_t )((uint8_t )data[0]);
#line 115
  b = (uint32_t )((uint8_t )data[1]);
#line 116
  c = (uint32_t )((uint8_t )data[2]);
#line 117
  d = (uint32_t )((uint8_t )data[3]);
#line 119
  result = (((a << 24) | (b << 16)) | (c << 8)) | d;
  }
#line 120
  return (result);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
uint32_t mp4ff_read_int24(mp4ff_t *f ) 
{ 
  uint32_t result ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  int8_t data[4] ;

  {
  {
#line 129
  mp4ff_read_data(f, data, (uint32_t )3);
#line 130
  a = (uint32_t )((uint8_t )data[0]);
#line 131
  b = (uint32_t )((uint8_t )data[1]);
#line 132
  c = (uint32_t )((uint8_t )data[2]);
#line 134
  result = ((a << 16) | (b << 8)) | c;
  }
#line 135
  return (result);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
uint16_t mp4ff_read_int16(mp4ff_t *f ) 
{ 
  uint32_t result ;
  uint32_t a ;
  uint32_t b ;
  int8_t data[2] ;

  {
  {
#line 144
  mp4ff_read_data(f, data, (uint32_t )2);
#line 145
  a = (uint32_t )((uint8_t )data[0]);
#line 146
  b = (uint32_t )((uint8_t )data[1]);
#line 148
  result = (a << 8) | b;
  }
#line 149
  return ((uint16_t )result);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
char *mp4ff_read_string(mp4ff_t *f , uint32_t length ) 
{ 
  char *str ;
  void *tmp ;
  int32_t tmp___0 ;

  {
  {
#line 154
  tmp = malloc((size_t )(length + 1U));
#line 154
  str = (char *)tmp;
  }
#line 155
  if ((unsigned long )str != (unsigned long )((char *)0)) {
    {
#line 157
    tmp___0 = mp4ff_read_data(f, (int8_t *)str, length);
    }
#line 157
    if ((uint32_t )tmp___0 != length) {
      {
#line 159
      free((void *)str);
#line 160
      str = (char *)0;
      }
    } else {
#line 164
      *(str + length) = (char)0;
    }
  }
#line 167
  return (str);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
uint8_t mp4ff_read_char(mp4ff_t *f ) 
{ 
  uint8_t output ;

  {
  {
#line 173
  mp4ff_read_data(f, (int8_t *)(& output), (uint32_t )1);
  }
#line 174
  return (output);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4util.c"
uint32_t mp4ff_read_mp4_descr_length(mp4ff_t *f ) 
{ 
  uint8_t b ;
  uint8_t numBytes ;
  uint32_t length ;

  {
#line 180
  numBytes = (uint8_t )0;
#line 181
  length = (uint32_t )0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 185
    b = mp4ff_read_char(f);
#line 186
    numBytes = (uint8_t )((int )numBytes + 1);
#line 187
    length = (length << 7) | (unsigned int )((int )b & 127);
    }
#line 183
    if ((int )b & 128) {
#line 183
      if (! ((int )numBytes < 4)) {
#line 183
        goto while_break;
      }
    } else {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return (length);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) frexp)(double __x ,
                                                                               int *__exponent ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/audio.h"
audio_file *open_audio_file(char *infile , int samplerate , int channels , int outputFormat ,
                            int fileType , long channelMask ) ;
#line 58
int write_audio_file(audio_file *aufile , void *sample_buffer , int samples , int offset ) ;
#line 59
void close_audio_file(audio_file *aufile ) ;
#line 60
static int write_wav_header(audio_file *aufile ) ;
#line 61
static int write_wav_extensible_header(audio_file *aufile , long channelMask ) ;
#line 62
static int write_audio_16bit(audio_file *aufile , void *sample_buffer , unsigned int samples ) ;
#line 64
static int write_audio_24bit(audio_file *aufile , void *sample_buffer , unsigned int samples ) ;
#line 66
static int write_audio_32bit(audio_file *aufile , void *sample_buffer , unsigned int samples ) ;
#line 68
static int write_audio_float(audio_file *aufile , void *sample_buffer , unsigned int samples ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/audio.c"
audio_file *open_audio_file(char *infile , int samplerate , int channels , int outputFormat ,
                            int fileType , long channelMask ) 
{ 
  audio_file *aufile ;
  void *tmp ;

  {
  {
#line 45
  tmp = malloc(sizeof(audio_file ));
#line 45
  aufile = (audio_file *)tmp;
#line 47
  aufile->outputFormat = outputFormat;
#line 49
  aufile->samplerate = (unsigned long )samplerate;
#line 50
  aufile->channels = (unsigned int )channels;
#line 51
  aufile->total_samples = 0UL;
#line 52
  aufile->fileType = (unsigned int )fileType;
#line 53
  aufile->channelMask = channelMask;
  }
  {
#line 57
  if (outputFormat == 1) {
#line 57
    goto case_1;
  }
#line 60
  if (outputFormat == 2) {
#line 60
    goto case_2;
  }
#line 64
  if (outputFormat == 4) {
#line 64
    goto case_4;
  }
#line 64
  if (outputFormat == 3) {
#line 64
    goto case_4;
  }
#line 67
  goto switch_default;
  case_1: /* CIL Label */ 
#line 58
  aufile->bits_per_sample = 16U;
#line 59
  goto switch_break;
  case_2: /* CIL Label */ 
#line 61
  aufile->bits_per_sample = 24U;
#line 62
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 65
  aufile->bits_per_sample = 32U;
#line 66
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 68
  if (aufile) {
    {
#line 68
    free((void *)aufile);
    }
  }
#line 69
  return ((audio_file *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 72
  if ((int )*(infile + 0) == 45) {
#line 77
    aufile->sndfile = stdout;
#line 78
    aufile->toStdio = 1;
  } else {
    {
#line 80
    aufile->toStdio = 0;
#line 81
    aufile->sndfile = fopen((char const   */* __restrict  */)infile, (char const   */* __restrict  */)"wb");
    }
  }
#line 84
  if ((unsigned long )aufile->sndfile == (unsigned long )((void *)0)) {
#line 86
    if (aufile) {
      {
#line 86
      free((void *)aufile);
      }
    }
#line 87
    return ((audio_file *)((void *)0));
  }
#line 90
  if (aufile->fileType == 1U) {
#line 92
    if (aufile->channelMask) {
      {
#line 93
      write_wav_extensible_header(aufile, aufile->channelMask);
      }
    } else {
      {
#line 95
      write_wav_header(aufile);
      }
    }
  }
#line 98
  return (aufile);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/audio.c"
int write_audio_file(audio_file *aufile , void *sample_buffer , int samples , int offset ) 
{ 
  char *buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 103
  buf = (char *)sample_buffer;
  {
#line 106
  if (aufile->outputFormat == 1) {
#line 106
    goto case_1;
  }
#line 108
  if (aufile->outputFormat == 2) {
#line 108
    goto case_2;
  }
#line 110
  if (aufile->outputFormat == 3) {
#line 110
    goto case_3;
  }
#line 112
  if (aufile->outputFormat == 4) {
#line 112
    goto case_4;
  }
#line 114
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 107
  tmp = write_audio_16bit(aufile, (void *)(buf + offset * 2), (unsigned int )samples);
  }
#line 107
  return (tmp);
  case_2: /* CIL Label */ 
  {
#line 109
  tmp___0 = write_audio_24bit(aufile, (void *)(buf + offset * 4), (unsigned int )samples);
  }
#line 109
  return (tmp___0);
  case_3: /* CIL Label */ 
  {
#line 111
  tmp___1 = write_audio_32bit(aufile, (void *)(buf + offset * 4), (unsigned int )samples);
  }
#line 111
  return (tmp___1);
  case_4: /* CIL Label */ 
  {
#line 113
  tmp___2 = write_audio_float(aufile, (void *)(buf + offset * 4), (unsigned int )samples);
  }
#line 113
  return (tmp___2);
  switch_default: /* CIL Label */ 
#line 115
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 118
  return (0);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/audio.c"
void close_audio_file(audio_file *aufile ) 
{ 


  {
#line 123
  if (aufile->fileType == 1U) {
#line 123
    if (aufile->toStdio == 0) {
      {
#line 125
      fseek(aufile->sndfile, 0L, 0);
      }
#line 127
      if (aufile->channelMask) {
        {
#line 128
        write_wav_extensible_header(aufile, aufile->channelMask);
        }
      } else {
        {
#line 130
        write_wav_header(aufile);
        }
      }
    }
  }
#line 133
  if (aufile->toStdio == 0) {
    {
#line 134
    fclose(aufile->sndfile);
    }
  }
#line 136
  if (aufile) {
    {
#line 136
    free((void *)aufile);
    }
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/audio.c"
static int write_wav_header(audio_file *aufile ) 
{ 
  unsigned char header[44] ;
  unsigned char *p ;
  unsigned int bytes ;
  float data_size ;
  unsigned long word32 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned char *tmp___33 ;
  unsigned char *tmp___34 ;
  unsigned char *tmp___35 ;
  unsigned char *tmp___36 ;
  unsigned char *tmp___37 ;
  unsigned char *tmp___38 ;
  unsigned char *tmp___39 ;
  unsigned char *tmp___40 ;
  unsigned char *tmp___41 ;
  unsigned char *tmp___42 ;
  unsigned char *tmp___43 ;
  unsigned char *tmp___44 ;
  size_t tmp___45 ;

  {
#line 142
  p = header;
#line 143
  bytes = (aufile->bits_per_sample + 7U) / 8U;
#line 144
  data_size = (float )bytes * (float )aufile->total_samples;
#line 147
  tmp = p;
#line 147
  p ++;
#line 147
  *tmp = (unsigned char )'R';
#line 147
  tmp___0 = p;
#line 147
  p ++;
#line 147
  *tmp___0 = (unsigned char )'I';
#line 147
  tmp___1 = p;
#line 147
  p ++;
#line 147
  *tmp___1 = (unsigned char )'F';
#line 147
  tmp___2 = p;
#line 147
  p ++;
#line 147
  *tmp___2 = (unsigned char )'F';
#line 149
  if (data_size + (float )36 < (float )4294967040UL) {
#line 149
    word32 = (unsigned long )data_size + 36UL;
  } else {
#line 149
    word32 = 4294967040UL;
  }
#line 151
  tmp___3 = p;
#line 151
  p ++;
#line 151
  *tmp___3 = (unsigned char )word32;
#line 152
  tmp___4 = p;
#line 152
  p ++;
#line 152
  *tmp___4 = (unsigned char )(word32 >> 8);
#line 153
  tmp___5 = p;
#line 153
  p ++;
#line 153
  *tmp___5 = (unsigned char )(word32 >> 16);
#line 154
  tmp___6 = p;
#line 154
  p ++;
#line 154
  *tmp___6 = (unsigned char )(word32 >> 24);
#line 156
  tmp___7 = p;
#line 156
  p ++;
#line 156
  *tmp___7 = (unsigned char )'W';
#line 156
  tmp___8 = p;
#line 156
  p ++;
#line 156
  *tmp___8 = (unsigned char )'A';
#line 156
  tmp___9 = p;
#line 156
  p ++;
#line 156
  *tmp___9 = (unsigned char )'V';
#line 156
  tmp___10 = p;
#line 156
  p ++;
#line 156
  *tmp___10 = (unsigned char )'E';
#line 158
  tmp___11 = p;
#line 158
  p ++;
#line 158
  *tmp___11 = (unsigned char )'f';
#line 158
  tmp___12 = p;
#line 158
  p ++;
#line 158
  *tmp___12 = (unsigned char )'m';
#line 158
  tmp___13 = p;
#line 158
  p ++;
#line 158
  *tmp___13 = (unsigned char )'t';
#line 158
  tmp___14 = p;
#line 158
  p ++;
#line 158
  *tmp___14 = (unsigned char )' ';
#line 160
  tmp___15 = p;
#line 160
  p ++;
#line 160
  *tmp___15 = (unsigned char)16;
#line 160
  tmp___16 = p;
#line 160
  p ++;
#line 160
  *tmp___16 = (unsigned char)0;
#line 160
  tmp___17 = p;
#line 160
  p ++;
#line 160
  *tmp___17 = (unsigned char)0;
#line 160
  tmp___18 = p;
#line 160
  p ++;
#line 160
  *tmp___18 = (unsigned char)0;
#line 162
  if (aufile->outputFormat == 4) {
#line 164
    tmp___19 = p;
#line 164
    p ++;
#line 164
    *tmp___19 = (unsigned char)3;
#line 164
    tmp___20 = p;
#line 164
    p ++;
#line 164
    *tmp___20 = (unsigned char)0;
  } else {
#line 166
    tmp___21 = p;
#line 166
    p ++;
#line 166
    *tmp___21 = (unsigned char)1;
#line 166
    tmp___22 = p;
#line 166
    p ++;
#line 166
    *tmp___22 = (unsigned char)0;
  }
#line 169
  tmp___23 = p;
#line 169
  p ++;
#line 169
  *tmp___23 = (unsigned char )aufile->channels;
#line 170
  tmp___24 = p;
#line 170
  p ++;
#line 170
  *tmp___24 = (unsigned char )(aufile->channels >> 8);
#line 172
  word32 = (unsigned long )((double )aufile->samplerate + 0.5);
#line 173
  tmp___25 = p;
#line 173
  p ++;
#line 173
  *tmp___25 = (unsigned char )word32;
#line 174
  tmp___26 = p;
#line 174
  p ++;
#line 174
  *tmp___26 = (unsigned char )(word32 >> 8);
#line 175
  tmp___27 = p;
#line 175
  p ++;
#line 175
  *tmp___27 = (unsigned char )(word32 >> 16);
#line 176
  tmp___28 = p;
#line 176
  p ++;
#line 176
  *tmp___28 = (unsigned char )(word32 >> 24);
#line 178
  word32 = (aufile->samplerate * (unsigned long )bytes) * (unsigned long )aufile->channels;
#line 179
  tmp___29 = p;
#line 179
  p ++;
#line 179
  *tmp___29 = (unsigned char )word32;
#line 180
  tmp___30 = p;
#line 180
  p ++;
#line 180
  *tmp___30 = (unsigned char )(word32 >> 8);
#line 181
  tmp___31 = p;
#line 181
  p ++;
#line 181
  *tmp___31 = (unsigned char )(word32 >> 16);
#line 182
  tmp___32 = p;
#line 182
  p ++;
#line 182
  *tmp___32 = (unsigned char )(word32 >> 24);
#line 184
  word32 = (unsigned long )(bytes * aufile->channels);
#line 185
  tmp___33 = p;
#line 185
  p ++;
#line 185
  *tmp___33 = (unsigned char )word32;
#line 186
  tmp___34 = p;
#line 186
  p ++;
#line 186
  *tmp___34 = (unsigned char )(word32 >> 8);
#line 188
  tmp___35 = p;
#line 188
  p ++;
#line 188
  *tmp___35 = (unsigned char )aufile->bits_per_sample;
#line 189
  tmp___36 = p;
#line 189
  p ++;
#line 189
  *tmp___36 = (unsigned char )(aufile->bits_per_sample >> 8);
#line 191
  tmp___37 = p;
#line 191
  p ++;
#line 191
  *tmp___37 = (unsigned char )'d';
#line 191
  tmp___38 = p;
#line 191
  p ++;
#line 191
  *tmp___38 = (unsigned char )'a';
#line 191
  tmp___39 = p;
#line 191
  p ++;
#line 191
  *tmp___39 = (unsigned char )'t';
#line 191
  tmp___40 = p;
#line 191
  p ++;
#line 191
  *tmp___40 = (unsigned char )'a';
#line 193
  if (data_size < (float )4294967040UL) {
#line 193
    word32 = (unsigned long )data_size;
  } else {
#line 193
    word32 = 4294967040UL;
  }
  {
#line 195
  tmp___41 = p;
#line 195
  p ++;
#line 195
  *tmp___41 = (unsigned char )word32;
#line 196
  tmp___42 = p;
#line 196
  p ++;
#line 196
  *tmp___42 = (unsigned char )(word32 >> 8);
#line 197
  tmp___43 = p;
#line 197
  p ++;
#line 197
  *tmp___43 = (unsigned char )(word32 >> 16);
#line 198
  tmp___44 = p;
#line 198
  p ++;
#line 198
  *tmp___44 = (unsigned char )(word32 >> 24);
#line 200
  tmp___45 = fwrite((void const   */* __restrict  */)(header), sizeof(header), (size_t )1,
                    (FILE */* __restrict  */)aufile->sndfile);
  }
#line 200
  return ((int )tmp___45);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/audio.c"
static int write_wav_extensible_header(audio_file *aufile , long channelMask ) 
{ 
  unsigned char header[68] ;
  unsigned char *p ;
  unsigned int bytes ;
  float data_size ;
  unsigned long word32 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned char *tmp___33 ;
  unsigned char *tmp___34 ;
  unsigned char *tmp___35 ;
  unsigned char *tmp___36 ;
  unsigned char *tmp___37 ;
  unsigned char *tmp___38 ;
  unsigned char *tmp___39 ;
  unsigned char *tmp___40 ;
  unsigned char *tmp___41 ;
  unsigned char *tmp___42 ;
  unsigned char *tmp___43 ;
  unsigned char *tmp___44 ;
  unsigned char *tmp___45 ;
  unsigned char *tmp___46 ;
  unsigned char *tmp___47 ;
  unsigned char *tmp___48 ;
  unsigned char *tmp___49 ;
  unsigned char *tmp___50 ;
  unsigned char *tmp___51 ;
  unsigned char *tmp___52 ;
  unsigned char *tmp___53 ;
  unsigned char *tmp___54 ;
  unsigned char *tmp___55 ;
  unsigned char *tmp___56 ;
  unsigned char *tmp___57 ;
  unsigned char *tmp___58 ;
  unsigned char *tmp___59 ;
  unsigned char *tmp___60 ;
  unsigned char *tmp___61 ;
  unsigned char *tmp___62 ;
  unsigned char *tmp___63 ;
  unsigned char *tmp___64 ;
  unsigned char *tmp___65 ;
  unsigned char *tmp___66 ;
  unsigned char *tmp___67 ;
  unsigned char *tmp___68 ;
  unsigned char *tmp___69 ;
  unsigned char *tmp___70 ;
  unsigned char *tmp___71 ;
  unsigned char *tmp___72 ;
  unsigned char *tmp___73 ;
  unsigned char *tmp___74 ;
  unsigned char *tmp___75 ;
  unsigned char *tmp___76 ;
  unsigned char *tmp___77 ;
  unsigned char *tmp___78 ;
  unsigned char *tmp___79 ;
  unsigned char *tmp___80 ;
  unsigned char *tmp___81 ;
  unsigned char *tmp___82 ;
  size_t tmp___83 ;

  {
#line 206
  p = header;
#line 207
  bytes = (aufile->bits_per_sample + 7U) / 8U;
#line 208
  data_size = (float )bytes * (float )aufile->total_samples;
#line 211
  tmp = p;
#line 211
  p ++;
#line 211
  *tmp = (unsigned char )'R';
#line 211
  tmp___0 = p;
#line 211
  p ++;
#line 211
  *tmp___0 = (unsigned char )'I';
#line 211
  tmp___1 = p;
#line 211
  p ++;
#line 211
  *tmp___1 = (unsigned char )'F';
#line 211
  tmp___2 = p;
#line 211
  p ++;
#line 211
  *tmp___2 = (unsigned char )'F';
#line 213
  if (data_size + (float )60 < (float )4294967040UL) {
#line 213
    word32 = (unsigned long )data_size + 60UL;
  } else {
#line 213
    word32 = 4294967040UL;
  }
#line 215
  tmp___3 = p;
#line 215
  p ++;
#line 215
  *tmp___3 = (unsigned char )word32;
#line 216
  tmp___4 = p;
#line 216
  p ++;
#line 216
  *tmp___4 = (unsigned char )(word32 >> 8);
#line 217
  tmp___5 = p;
#line 217
  p ++;
#line 217
  *tmp___5 = (unsigned char )(word32 >> 16);
#line 218
  tmp___6 = p;
#line 218
  p ++;
#line 218
  *tmp___6 = (unsigned char )(word32 >> 24);
#line 220
  tmp___7 = p;
#line 220
  p ++;
#line 220
  *tmp___7 = (unsigned char )'W';
#line 220
  tmp___8 = p;
#line 220
  p ++;
#line 220
  *tmp___8 = (unsigned char )'A';
#line 220
  tmp___9 = p;
#line 220
  p ++;
#line 220
  *tmp___9 = (unsigned char )'V';
#line 220
  tmp___10 = p;
#line 220
  p ++;
#line 220
  *tmp___10 = (unsigned char )'E';
#line 222
  tmp___11 = p;
#line 222
  p ++;
#line 222
  *tmp___11 = (unsigned char )'f';
#line 222
  tmp___12 = p;
#line 222
  p ++;
#line 222
  *tmp___12 = (unsigned char )'m';
#line 222
  tmp___13 = p;
#line 222
  p ++;
#line 222
  *tmp___13 = (unsigned char )'t';
#line 222
  tmp___14 = p;
#line 222
  p ++;
#line 222
  *tmp___14 = (unsigned char )' ';
#line 224
  tmp___15 = p;
#line 224
  p ++;
#line 224
  *tmp___15 = (unsigned char)40;
#line 224
  tmp___16 = p;
#line 224
  p ++;
#line 224
  *tmp___16 = (unsigned char)0;
#line 224
  tmp___17 = p;
#line 224
  p ++;
#line 224
  *tmp___17 = (unsigned char)0;
#line 224
  tmp___18 = p;
#line 224
  p ++;
#line 224
  *tmp___18 = (unsigned char)0;
#line 227
  tmp___19 = p;
#line 227
  p ++;
#line 227
  *tmp___19 = (unsigned char)254;
#line 227
  tmp___20 = p;
#line 227
  p ++;
#line 227
  *tmp___20 = (unsigned char)255;
#line 229
  tmp___21 = p;
#line 229
  p ++;
#line 229
  *tmp___21 = (unsigned char )aufile->channels;
#line 230
  tmp___22 = p;
#line 230
  p ++;
#line 230
  *tmp___22 = (unsigned char )(aufile->channels >> 8);
#line 232
  word32 = (unsigned long )((double )aufile->samplerate + 0.5);
#line 233
  tmp___23 = p;
#line 233
  p ++;
#line 233
  *tmp___23 = (unsigned char )word32;
#line 234
  tmp___24 = p;
#line 234
  p ++;
#line 234
  *tmp___24 = (unsigned char )(word32 >> 8);
#line 235
  tmp___25 = p;
#line 235
  p ++;
#line 235
  *tmp___25 = (unsigned char )(word32 >> 16);
#line 236
  tmp___26 = p;
#line 236
  p ++;
#line 236
  *tmp___26 = (unsigned char )(word32 >> 24);
#line 238
  word32 = (aufile->samplerate * (unsigned long )bytes) * (unsigned long )aufile->channels;
#line 239
  tmp___27 = p;
#line 239
  p ++;
#line 239
  *tmp___27 = (unsigned char )word32;
#line 240
  tmp___28 = p;
#line 240
  p ++;
#line 240
  *tmp___28 = (unsigned char )(word32 >> 8);
#line 241
  tmp___29 = p;
#line 241
  p ++;
#line 241
  *tmp___29 = (unsigned char )(word32 >> 16);
#line 242
  tmp___30 = p;
#line 242
  p ++;
#line 242
  *tmp___30 = (unsigned char )(word32 >> 24);
#line 244
  word32 = (unsigned long )(bytes * aufile->channels);
#line 245
  tmp___31 = p;
#line 245
  p ++;
#line 245
  *tmp___31 = (unsigned char )word32;
#line 246
  tmp___32 = p;
#line 246
  p ++;
#line 246
  *tmp___32 = (unsigned char )(word32 >> 8);
#line 248
  tmp___33 = p;
#line 248
  p ++;
#line 248
  *tmp___33 = (unsigned char )aufile->bits_per_sample;
#line 249
  tmp___34 = p;
#line 249
  p ++;
#line 249
  *tmp___34 = (unsigned char )(aufile->bits_per_sample >> 8);
#line 252
  tmp___35 = p;
#line 252
  p ++;
#line 252
  *tmp___35 = (unsigned char)22;
#line 253
  tmp___36 = p;
#line 253
  p ++;
#line 253
  *tmp___36 = (unsigned char)0;
#line 258
  tmp___37 = p;
#line 258
  p ++;
#line 258
  *tmp___37 = (unsigned char )aufile->bits_per_sample;
#line 259
  tmp___38 = p;
#line 259
  p ++;
#line 259
  *tmp___38 = (unsigned char )(aufile->bits_per_sample >> 8);
#line 262
  word32 = (unsigned long )channelMask;
#line 263
  tmp___39 = p;
#line 263
  p ++;
#line 263
  *tmp___39 = (unsigned char )word32;
#line 264
  tmp___40 = p;
#line 264
  p ++;
#line 264
  *tmp___40 = (unsigned char )(word32 >> 8);
#line 265
  tmp___41 = p;
#line 265
  p ++;
#line 265
  *tmp___41 = (unsigned char )(word32 >> 16);
#line 266
  tmp___42 = p;
#line 266
  p ++;
#line 266
  *tmp___42 = (unsigned char )(word32 >> 24);
#line 269
  if (aufile->outputFormat == 4) {
#line 272
    tmp___43 = p;
#line 272
    p ++;
#line 272
    *tmp___43 = (unsigned char)3;
#line 273
    tmp___44 = p;
#line 273
    p ++;
#line 273
    *tmp___44 = (unsigned char)0;
#line 274
    tmp___45 = p;
#line 274
    p ++;
#line 274
    *tmp___45 = (unsigned char)0;
#line 275
    tmp___46 = p;
#line 275
    p ++;
#line 275
    *tmp___46 = (unsigned char)0;
#line 276
    tmp___47 = p;
#line 276
    p ++;
#line 276
    *tmp___47 = (unsigned char)0;
#line 276
    tmp___48 = p;
#line 276
    p ++;
#line 276
    *tmp___48 = (unsigned char)0;
#line 276
    tmp___49 = p;
#line 276
    p ++;
#line 276
    *tmp___49 = (unsigned char)16;
#line 276
    tmp___50 = p;
#line 276
    p ++;
#line 276
    *tmp___50 = (unsigned char)0;
#line 276
    tmp___51 = p;
#line 276
    p ++;
#line 276
    *tmp___51 = (unsigned char)128;
#line 276
    tmp___52 = p;
#line 276
    p ++;
#line 276
    *tmp___52 = (unsigned char)0;
#line 277
    tmp___53 = p;
#line 277
    p ++;
#line 277
    *tmp___53 = (unsigned char)0;
#line 277
    tmp___54 = p;
#line 277
    p ++;
#line 277
    *tmp___54 = (unsigned char)170;
#line 277
    tmp___55 = p;
#line 277
    p ++;
#line 277
    *tmp___55 = (unsigned char)0;
#line 277
    tmp___56 = p;
#line 277
    p ++;
#line 277
    *tmp___56 = (unsigned char)56;
#line 277
    tmp___57 = p;
#line 277
    p ++;
#line 277
    *tmp___57 = (unsigned char)155;
#line 277
    tmp___58 = p;
#line 277
    p ++;
#line 277
    *tmp___58 = (unsigned char)113;
  } else {
#line 280
    tmp___59 = p;
#line 280
    p ++;
#line 280
    *tmp___59 = (unsigned char)1;
#line 281
    tmp___60 = p;
#line 281
    p ++;
#line 281
    *tmp___60 = (unsigned char)0;
#line 282
    tmp___61 = p;
#line 282
    p ++;
#line 282
    *tmp___61 = (unsigned char)0;
#line 283
    tmp___62 = p;
#line 283
    p ++;
#line 283
    *tmp___62 = (unsigned char)0;
#line 284
    tmp___63 = p;
#line 284
    p ++;
#line 284
    *tmp___63 = (unsigned char)0;
#line 284
    tmp___64 = p;
#line 284
    p ++;
#line 284
    *tmp___64 = (unsigned char)0;
#line 284
    tmp___65 = p;
#line 284
    p ++;
#line 284
    *tmp___65 = (unsigned char)16;
#line 284
    tmp___66 = p;
#line 284
    p ++;
#line 284
    *tmp___66 = (unsigned char)0;
#line 284
    tmp___67 = p;
#line 284
    p ++;
#line 284
    *tmp___67 = (unsigned char)128;
#line 284
    tmp___68 = p;
#line 284
    p ++;
#line 284
    *tmp___68 = (unsigned char)0;
#line 285
    tmp___69 = p;
#line 285
    p ++;
#line 285
    *tmp___69 = (unsigned char)0;
#line 285
    tmp___70 = p;
#line 285
    p ++;
#line 285
    *tmp___70 = (unsigned char)170;
#line 285
    tmp___71 = p;
#line 285
    p ++;
#line 285
    *tmp___71 = (unsigned char)0;
#line 285
    tmp___72 = p;
#line 285
    p ++;
#line 285
    *tmp___72 = (unsigned char)56;
#line 285
    tmp___73 = p;
#line 285
    p ++;
#line 285
    *tmp___73 = (unsigned char)155;
#line 285
    tmp___74 = p;
#line 285
    p ++;
#line 285
    *tmp___74 = (unsigned char)113;
  }
#line 290
  tmp___75 = p;
#line 290
  p ++;
#line 290
  *tmp___75 = (unsigned char )'d';
#line 290
  tmp___76 = p;
#line 290
  p ++;
#line 290
  *tmp___76 = (unsigned char )'a';
#line 290
  tmp___77 = p;
#line 290
  p ++;
#line 290
  *tmp___77 = (unsigned char )'t';
#line 290
  tmp___78 = p;
#line 290
  p ++;
#line 290
  *tmp___78 = (unsigned char )'a';
#line 292
  if (data_size < (float )4294967040UL) {
#line 292
    word32 = (unsigned long )data_size;
  } else {
#line 292
    word32 = 4294967040UL;
  }
  {
#line 294
  tmp___79 = p;
#line 294
  p ++;
#line 294
  *tmp___79 = (unsigned char )word32;
#line 295
  tmp___80 = p;
#line 295
  p ++;
#line 295
  *tmp___80 = (unsigned char )(word32 >> 8);
#line 296
  tmp___81 = p;
#line 296
  p ++;
#line 296
  *tmp___81 = (unsigned char )(word32 >> 16);
#line 297
  tmp___82 = p;
#line 297
  p ++;
#line 297
  *tmp___82 = (unsigned char )(word32 >> 24);
#line 299
  tmp___83 = fwrite((void const   */* __restrict  */)(header), sizeof(header), (size_t )1,
                    (FILE */* __restrict  */)aufile->sndfile);
  }
#line 299
  return ((int )tmp___83);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/audio.c"
static int write_audio_16bit(audio_file *aufile , void *sample_buffer , unsigned int samples ) 
{ 
  int ret ;
  unsigned int i ;
  short *sample_buffer16 ;
  char *data ;
  void *tmp ;
  short r1 ;
  short r2 ;
  short r3 ;
  short r4 ;
  short r5 ;
  short r6 ;
  size_t tmp___0 ;

  {
  {
#line 307
  sample_buffer16 = (short *)sample_buffer;
#line 308
  tmp = malloc(((unsigned long )(samples * aufile->bits_per_sample) * sizeof(char )) / 8UL);
#line 308
  data = (char *)tmp;
#line 310
  aufile->total_samples += (unsigned long )samples;
  }
#line 312
  if (aufile->channels == 6U) {
#line 312
    if (aufile->channelMask) {
#line 314
      i = 0U;
      {
#line 314
      while (1) {
        while_continue: /* CIL Label */ ;
#line 314
        if (! (i < samples)) {
#line 314
          goto while_break;
        }
#line 317
        r1 = *(sample_buffer16 + i);
#line 318
        r2 = *(sample_buffer16 + (i + 1U));
#line 319
        r3 = *(sample_buffer16 + (i + 2U));
#line 320
        r4 = *(sample_buffer16 + (i + 3U));
#line 321
        r5 = *(sample_buffer16 + (i + 4U));
#line 322
        r6 = *(sample_buffer16 + (i + 5U));
#line 323
        *(sample_buffer16 + i) = r2;
#line 324
        *(sample_buffer16 + (i + 1U)) = r3;
#line 325
        *(sample_buffer16 + (i + 2U)) = r1;
#line 326
        *(sample_buffer16 + (i + 3U)) = r6;
#line 327
        *(sample_buffer16 + (i + 4U)) = r4;
#line 328
        *(sample_buffer16 + (i + 5U)) = r5;
#line 314
        i += aufile->channels;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 332
  i = 0U;
  {
#line 332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 332
    if (! (i < samples)) {
#line 332
      goto while_break___0;
    }
#line 334
    *(data + i * 2U) = (char )((int )*(sample_buffer16 + i) & 255);
#line 335
    *(data + (i * 2U + 1U)) = (char )(((int )*(sample_buffer16 + i) >> 8) & 255);
#line 332
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 338
  tmp___0 = fwrite((void const   */* __restrict  */)data, (size_t )samples, (size_t )(aufile->bits_per_sample / 8U),
                   (FILE */* __restrict  */)aufile->sndfile);
#line 338
  ret = (int )tmp___0;
  }
#line 340
  if (data) {
    {
#line 340
    free((void *)data);
    }
  }
#line 342
  return (ret);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/audio.c"
static int write_audio_24bit(audio_file *aufile , void *sample_buffer , unsigned int samples ) 
{ 
  int ret ;
  unsigned int i ;
  int *sample_buffer24 ;
  char *data ;
  void *tmp ;
  long r1 ;
  long r2 ;
  long r3 ;
  long r4 ;
  long r5 ;
  long r6 ;
  size_t tmp___0 ;

  {
  {
#line 350
  sample_buffer24 = (int *)sample_buffer;
#line 351
  tmp = malloc(((unsigned long )(samples * aufile->bits_per_sample) * sizeof(char )) / 8UL);
#line 351
  data = (char *)tmp;
#line 353
  aufile->total_samples += (unsigned long )samples;
  }
#line 355
  if (aufile->channels == 6U) {
#line 355
    if (aufile->channelMask) {
#line 357
      i = 0U;
      {
#line 357
      while (1) {
        while_continue: /* CIL Label */ ;
#line 357
        if (! (i < samples)) {
#line 357
          goto while_break;
        }
#line 360
        r1 = (long )*(sample_buffer24 + i);
#line 361
        r2 = (long )*(sample_buffer24 + (i + 1U));
#line 362
        r3 = (long )*(sample_buffer24 + (i + 2U));
#line 363
        r4 = (long )*(sample_buffer24 + (i + 3U));
#line 364
        r5 = (long )*(sample_buffer24 + (i + 4U));
#line 365
        r6 = (long )*(sample_buffer24 + (i + 5U));
#line 366
        *(sample_buffer24 + i) = (int )r2;
#line 367
        *(sample_buffer24 + (i + 1U)) = (int )r3;
#line 368
        *(sample_buffer24 + (i + 2U)) = (int )r1;
#line 369
        *(sample_buffer24 + (i + 3U)) = (int )r6;
#line 370
        *(sample_buffer24 + (i + 4U)) = (int )r4;
#line 371
        *(sample_buffer24 + (i + 5U)) = (int )r5;
#line 357
        i += aufile->channels;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 375
  i = 0U;
  {
#line 375
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 375
    if (! (i < samples)) {
#line 375
      goto while_break___0;
    }
#line 377
    *(data + i * 3U) = (char )(*(sample_buffer24 + i) & 255);
#line 378
    *(data + (i * 3U + 1U)) = (char )((*(sample_buffer24 + i) >> 8) & 255);
#line 379
    *(data + (i * 3U + 2U)) = (char )((*(sample_buffer24 + i) >> 16) & 255);
#line 375
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 382
  tmp___0 = fwrite((void const   */* __restrict  */)data, (size_t )samples, (size_t )(aufile->bits_per_sample / 8U),
                   (FILE */* __restrict  */)aufile->sndfile);
#line 382
  ret = (int )tmp___0;
  }
#line 384
  if (data) {
    {
#line 384
    free((void *)data);
    }
  }
#line 386
  return (ret);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/audio.c"
static int write_audio_32bit(audio_file *aufile , void *sample_buffer , unsigned int samples ) 
{ 
  int ret ;
  unsigned int i ;
  int *sample_buffer32 ;
  char *data ;
  void *tmp ;
  long r1 ;
  long r2 ;
  long r3 ;
  long r4 ;
  long r5 ;
  long r6 ;
  size_t tmp___0 ;

  {
  {
#line 394
  sample_buffer32 = (int *)sample_buffer;
#line 395
  tmp = malloc(((unsigned long )(samples * aufile->bits_per_sample) * sizeof(char )) / 8UL);
#line 395
  data = (char *)tmp;
#line 397
  aufile->total_samples += (unsigned long )samples;
  }
#line 399
  if (aufile->channels == 6U) {
#line 399
    if (aufile->channelMask) {
#line 401
      i = 0U;
      {
#line 401
      while (1) {
        while_continue: /* CIL Label */ ;
#line 401
        if (! (i < samples)) {
#line 401
          goto while_break;
        }
#line 404
        r1 = (long )*(sample_buffer32 + i);
#line 405
        r2 = (long )*(sample_buffer32 + (i + 1U));
#line 406
        r3 = (long )*(sample_buffer32 + (i + 2U));
#line 407
        r4 = (long )*(sample_buffer32 + (i + 3U));
#line 408
        r5 = (long )*(sample_buffer32 + (i + 4U));
#line 409
        r6 = (long )*(sample_buffer32 + (i + 5U));
#line 410
        *(sample_buffer32 + i) = (int )r2;
#line 411
        *(sample_buffer32 + (i + 1U)) = (int )r3;
#line 412
        *(sample_buffer32 + (i + 2U)) = (int )r1;
#line 413
        *(sample_buffer32 + (i + 3U)) = (int )r6;
#line 414
        *(sample_buffer32 + (i + 4U)) = (int )r4;
#line 415
        *(sample_buffer32 + (i + 5U)) = (int )r5;
#line 401
        i += aufile->channels;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 419
  i = 0U;
  {
#line 419
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 419
    if (! (i < samples)) {
#line 419
      goto while_break___0;
    }
#line 421
    *(data + i * 4U) = (char )(*(sample_buffer32 + i) & 255);
#line 422
    *(data + (i * 4U + 1U)) = (char )((*(sample_buffer32 + i) >> 8) & 255);
#line 423
    *(data + (i * 4U + 2U)) = (char )((*(sample_buffer32 + i) >> 16) & 255);
#line 424
    *(data + (i * 4U + 3U)) = (char )((*(sample_buffer32 + i) >> 24) & 255);
#line 419
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 427
  tmp___0 = fwrite((void const   */* __restrict  */)data, (size_t )samples, (size_t )(aufile->bits_per_sample / 8U),
                   (FILE */* __restrict  */)aufile->sndfile);
#line 427
  ret = (int )tmp___0;
  }
#line 429
  if (data) {
    {
#line 429
    free((void *)data);
    }
  }
#line 431
  return (ret);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/audio.c"
static int write_audio_float(audio_file *aufile , void *sample_buffer , unsigned int samples ) 
{ 
  int ret ;
  unsigned int i ;
  float *sample_buffer_f ;
  unsigned char *data ;
  void *tmp ;
  float r1 ;
  float r2 ;
  float r3 ;
  float r4 ;
  float r5 ;
  float r6 ;
  int exponent ;
  int mantissa ;
  int negative ;
  float in ;
  double tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 439
  sample_buffer_f = (float *)sample_buffer;
#line 440
  tmp = malloc(((unsigned long )(samples * aufile->bits_per_sample) * sizeof(char )) / 8UL);
#line 440
  data = (unsigned char *)tmp;
#line 442
  aufile->total_samples += (unsigned long )samples;
  }
#line 444
  if (aufile->channels == 6U) {
#line 444
    if (aufile->channelMask) {
#line 446
      i = 0U;
      {
#line 446
      while (1) {
        while_continue: /* CIL Label */ ;
#line 446
        if (! (i < samples)) {
#line 446
          goto while_break;
        }
#line 449
        r1 = *(sample_buffer_f + i);
#line 450
        r2 = *(sample_buffer_f + (i + 1U));
#line 451
        r3 = *(sample_buffer_f + (i + 2U));
#line 452
        r4 = *(sample_buffer_f + (i + 3U));
#line 453
        r5 = *(sample_buffer_f + (i + 4U));
#line 454
        r6 = *(sample_buffer_f + (i + 5U));
#line 455
        *(sample_buffer_f + i) = r2;
#line 456
        *(sample_buffer_f + (i + 1U)) = r3;
#line 457
        *(sample_buffer_f + (i + 2U)) = r1;
#line 458
        *(sample_buffer_f + (i + 3U)) = r6;
#line 459
        *(sample_buffer_f + (i + 4U)) = r4;
#line 460
        *(sample_buffer_f + (i + 5U)) = r5;
#line 446
        i += aufile->channels;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 464
  i = 0U;
  {
#line 464
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 464
    if (! (i < samples)) {
#line 464
      goto while_break___0;
    }
#line 466
    negative = 0;
#line 467
    in = *(sample_buffer_f + i);
#line 469
    *(data + i * 4U) = (unsigned char)0;
#line 469
    *(data + (i * 4U + 1U)) = (unsigned char)0;
#line 469
    *(data + (i * 4U + 2U)) = (unsigned char)0;
#line 469
    *(data + (i * 4U + 3U)) = (unsigned char)0;
#line 470
    if ((double )in == 0.0) {
#line 471
      goto __Cont;
    }
#line 473
    if ((double )in < 0.0) {
#line 475
      in = (float )((double )in * - 1.0);
#line 476
      negative = 1;
    }
    {
#line 478
    tmp___0 = frexp((double )in, & exponent);
#line 478
    in = (float )tmp___0;
#line 479
    exponent += 126;
#line 480
    in *= (float )16777216;
#line 481
    mantissa = (int )in & 8388607;
    }
#line 483
    if (negative) {
#line 484
      *(data + (i * 4U + 3U)) = (unsigned char )((int )*(data + (i * 4U + 3U)) | 128);
    }
#line 486
    if (exponent & 1) {
#line 487
      *(data + (i * 4U + 2U)) = (unsigned char )((int )*(data + (i * 4U + 2U)) | 128);
    }
#line 489
    *(data + i * 4U) = (unsigned char )(mantissa & 255);
#line 490
    *(data + (i * 4U + 1U)) = (unsigned char )((mantissa >> 8) & 255);
#line 491
    *(data + (i * 4U + 2U)) = (unsigned char )((int )*(data + (i * 4U + 2U)) | ((mantissa >> 16) & 127));
#line 492
    *(data + (i * 4U + 3U)) = (unsigned char )((int )*(data + (i * 4U + 3U)) | ((exponent >> 1) & 127));
    __Cont: /* CIL Label */ 
#line 464
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 495
  tmp___1 = fwrite((void const   */* __restrict  */)data, (size_t )samples, (size_t )(aufile->bits_per_sample / 8U),
                   (FILE */* __restrict  */)aufile->sndfile);
#line 495
  ret = (int )tmp___1;
  }
#line 497
  if (data) {
    {
#line 497
    free((void *)data);
    }
  }
#line 499
  return (ret);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 314 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ffint.h"
mp4ff_t *mp4ff_open_read(mp4ff_callback_t *f ) ;
#line 318
void mp4ff_close(mp4ff_t *ff ) ;
#line 320
int32_t parse_sub_atoms(mp4ff_t *f , uint64_t const   total_size , int meta_only ) ;
#line 321
int32_t parse_atoms(mp4ff_t *f , int meta_only ) ;
#line 323
int32_t mp4ff_get_sample_duration(mp4ff_t const   *f , int32_t const   track , int32_t const   sample ) ;
#line 324
int64_t mp4ff_get_sample_position(mp4ff_t const   *f , int32_t const   track , int32_t const   sample ) ;
#line 325
int32_t mp4ff_get_sample_offset(mp4ff_t const   *f , int32_t const   track , int32_t const   sample ) ;
#line 326
int32_t mp4ff_find_sample(mp4ff_t const   *f , int32_t const   track , int64_t const   offset ,
                          int32_t *toskip ) ;
#line 328
int32_t mp4ff_read_sample(mp4ff_t *f , int32_t const   track , int32_t const   sample ,
                          uint8_t **audio_buffer , uint32_t *bytes ) ;
#line 330
int32_t mp4ff_get_decoder_config(mp4ff_t const   *f , int32_t const   track , uint8_t **ppBuf ,
                                 uint32_t *pBufSize ) ;
#line 332
int32_t mp4ff_total_tracks(mp4ff_t const   *f ) ;
#line 333
int32_t mp4ff_time_scale(mp4ff_t const   *f , int32_t const   track ) ;
#line 334
int32_t mp4ff_num_samples(mp4ff_t const   *f , int32_t const   track ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
mp4ff_t *mp4ff_open_read(mp4ff_callback_t *f ) 
{ 
  mp4ff_t *ff ;
  void *tmp ;

  {
  {
#line 37
  tmp = malloc(sizeof(mp4ff_t ));
#line 37
  ff = (mp4ff_t *)tmp;
#line 39
  memset((void *)ff, 0, sizeof(mp4ff_t ));
#line 41
  ff->stream = f;
#line 43
  parse_atoms(ff, 0);
  }
#line 45
  return (ff);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
mp4ff_t *mp4ff_open_read_metaonly(mp4ff_callback_t *f ) 
{ 
  mp4ff_t *ff ;
  void *tmp ;

  {
  {
#line 50
  tmp = malloc(sizeof(mp4ff_t ));
#line 50
  ff = (mp4ff_t *)tmp;
#line 52
  memset((void *)ff, 0, sizeof(mp4ff_t ));
#line 54
  ff->stream = f;
#line 56
  parse_atoms(ff, 1);
  }
#line 58
  return (ff);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
void mp4ff_close(mp4ff_t *ff ) 
{ 
  int32_t i ;

  {
#line 65
  i = 0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i < ff->total_tracks)) {
#line 65
      goto while_break;
    }
#line 67
    if (ff->track[i]) {
#line 69
      if ((ff->track[i])->stsz_table) {
        {
#line 70
        free((void *)(ff->track[i])->stsz_table);
        }
      }
#line 71
      if ((ff->track[i])->stts_sample_count) {
        {
#line 72
        free((void *)(ff->track[i])->stts_sample_count);
        }
      }
#line 73
      if ((ff->track[i])->stts_sample_delta) {
        {
#line 74
        free((void *)(ff->track[i])->stts_sample_delta);
        }
      }
#line 75
      if ((ff->track[i])->stsc_first_chunk) {
        {
#line 76
        free((void *)(ff->track[i])->stsc_first_chunk);
        }
      }
#line 77
      if ((ff->track[i])->stsc_samples_per_chunk) {
        {
#line 78
        free((void *)(ff->track[i])->stsc_samples_per_chunk);
        }
      }
#line 79
      if ((ff->track[i])->stsc_sample_desc_index) {
        {
#line 80
        free((void *)(ff->track[i])->stsc_sample_desc_index);
        }
      }
#line 81
      if ((ff->track[i])->stco_chunk_offset) {
        {
#line 82
        free((void *)(ff->track[i])->stco_chunk_offset);
        }
      }
#line 83
      if ((ff->track[i])->decoderConfig) {
        {
#line 84
        free((void *)(ff->track[i])->decoderConfig);
        }
      }
#line 85
      if ((ff->track[i])->ctts_sample_count) {
        {
#line 86
        free((void *)(ff->track[i])->ctts_sample_count);
        }
      }
#line 87
      if ((ff->track[i])->ctts_sample_offset) {
        {
#line 88
        free((void *)(ff->track[i])->ctts_sample_offset);
        }
      }
      {
#line 93
      free((void *)ff->track[i]);
      }
    }
#line 65
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 98
  mp4ff_tag_delete(& ff->tags);
  }
#line 101
  if (ff) {
    {
#line 101
    free((void *)ff);
    }
  }
#line 102
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
void mp4ff_track_add(mp4ff_t *f ) 
{ 
  void *tmp ;

  {
  {
#line 106
  (f->total_tracks) ++;
#line 108
  tmp = malloc(sizeof(mp4ff_track_t ));
#line 108
  f->track[f->total_tracks - 1] = (mp4ff_track_t *)tmp;
#line 110
  memset((void *)f->track[f->total_tracks - 1], 0, sizeof(mp4ff_track_t ));
  }
#line 111
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
static int need_parse_when_meta_only(uint8_t atom_type ) 
{ 


  {
  {
#line 133
  if ((int )atom_type == 154) {
#line 133
    goto case_154;
  }
#line 133
  if ((int )atom_type == 153) {
#line 133
    goto case_154;
  }
#line 133
  if ((int )atom_type == 152) {
#line 133
    goto case_154;
  }
#line 133
  if ((int )atom_type == 143) {
#line 133
    goto case_154;
  }
#line 133
  if ((int )atom_type == 142) {
#line 133
    goto case_154;
  }
#line 133
  if ((int )atom_type == 141) {
#line 133
    goto case_154;
  }
#line 133
  if ((int )atom_type == 140) {
#line 133
    goto case_154;
  }
#line 133
  if ((int )atom_type == 139) {
#line 133
    goto case_154;
  }
#line 133
  if ((int )atom_type == 25) {
#line 133
    goto case_154;
  }
#line 133
  if ((int )atom_type == 24) {
#line 133
    goto case_154;
  }
#line 133
  if ((int )atom_type == 23) {
#line 133
    goto case_154;
  }
#line 133
  if ((int )atom_type == 3) {
#line 133
    goto case_154;
  }
#line 135
  goto switch_default;
  case_154: /* CIL Label */ 
  case_153: /* CIL Label */ 
  case_152: /* CIL Label */ 
  case_143: /* CIL Label */ 
  case_142: /* CIL Label */ 
  case_141: /* CIL Label */ 
  case_140: /* CIL Label */ 
  case_139: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 134
  return (0);
  switch_default: /* CIL Label */ 
#line 136
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t parse_sub_atoms(mp4ff_t *f , uint64_t const   total_size , int meta_only ) 
{ 
  uint64_t size ;
  uint8_t atom_type ;
  uint64_t counted_size ;
  uint8_t header_size ;
  int64_t tmp ;
  int tmp___0 ;

  {
#line 144
  atom_type = (uint8_t )0;
#line 145
  counted_size = (uint64_t )0;
#line 146
  header_size = (uint8_t )0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (counted_size < (uint64_t )total_size)) {
#line 148
      goto while_break;
    }
    {
#line 150
    size = mp4ff_atom_read_header(f, & atom_type, & header_size);
#line 151
    counted_size += size;
    }
#line 154
    if (size == 0UL) {
#line 155
      goto while_break;
    }
#line 160
    if ((int )atom_type == 2) {
      {
#line 162
      mp4ff_track_add(f);
      }
    }
#line 166
    if (meta_only) {
      {
#line 166
      tmp___0 = need_parse_when_meta_only(atom_type);
      }
#line 166
      if (tmp___0) {
#line 166
        goto _L;
      } else {
        {
#line 168
        tmp = mp4ff_position((mp4ff_t const   *)f);
#line 168
        mp4ff_set_position(f, (int64_t const   )(((uint64_t )tmp + size) - (uint64_t )header_size));
        }
      }
    } else
    _L: /* CIL Label */ 
#line 169
    if ((int )atom_type < 128) {
      {
#line 171
      parse_sub_atoms(f, (uint64_t const   )(size - (uint64_t )header_size), meta_only);
      }
    } else {
      {
#line 173
      mp4ff_atom_read(f, (int32_t const   )((uint32_t )size), (uint8_t const   )atom_type);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return (0);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t parse_atoms(mp4ff_t *f , int meta_only ) 
{ 
  uint64_t size ;
  uint8_t atom_type ;
  uint8_t header_size ;
  int tmp ;
  int64_t tmp___0 ;
  int64_t tmp___1 ;
  int64_t tmp___2 ;
  int tmp___3 ;

  {
#line 184
  atom_type = (uint8_t )0;
#line 185
  header_size = (uint8_t )0;
#line 187
  f->file_size = (uint64_t )0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 189
    size = mp4ff_atom_read_header(f, & atom_type, & header_size);
    }
#line 189
    if (! (size != 0UL)) {
#line 189
      goto while_break;
    }
#line 191
    f->file_size += size;
#line 192
    f->last_atom = atom_type;
#line 194
    if ((int )atom_type == 130) {
#line 194
      if (f->moov_read) {
#line 194
        tmp = 1;
      } else {
#line 194
        tmp = 0;
      }
    } else {
#line 194
      tmp = 0;
    }
#line 201
    if ((int )atom_type == 1) {
#line 201
      if (size > (uint64_t )header_size) {
        {
#line 203
        f->moov_read = 1;
#line 204
        tmp___0 = mp4ff_position((mp4ff_t const   *)f);
#line 204
        f->moov_offset = (uint64_t )(tmp___0 - (int64_t )header_size);
#line 205
        f->moov_size = size;
        }
      }
    }
#line 209
    if (meta_only) {
      {
#line 209
      tmp___3 = need_parse_when_meta_only(atom_type);
      }
#line 209
      if (tmp___3) {
#line 209
        goto _L;
      } else {
        {
#line 211
        tmp___1 = mp4ff_position((mp4ff_t const   *)f);
#line 211
        mp4ff_set_position(f, (int64_t const   )(((uint64_t )tmp___1 + size) - (uint64_t )header_size));
        }
      }
    } else
    _L: /* CIL Label */ 
#line 212
    if ((int )atom_type < 128) {
      {
#line 214
      parse_sub_atoms(f, (uint64_t const   )(size - (uint64_t )header_size), meta_only);
      }
    } else {
      {
#line 217
      tmp___2 = mp4ff_position((mp4ff_t const   *)f);
#line 217
      mp4ff_set_position(f, (int64_t const   )(((uint64_t )tmp___2 + size) - (uint64_t )header_size));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return (0);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_get_decoder_config(mp4ff_t const   *f , int32_t const   track , uint8_t **ppBuf ,
                                 uint32_t *pBufSize ) 
{ 
  void *tmp ;

  {
#line 227
  if (track >= f->total_tracks) {
#line 229
    *ppBuf = (uint8_t *)((void *)0);
#line 230
    *pBufSize = (uint32_t )0;
#line 231
    return (1);
  }
#line 234
  if ((unsigned long )(f->track[track])->decoderConfig == (unsigned long )((void *)0)) {
#line 236
    *ppBuf = (uint8_t *)((void *)0);
#line 237
    *pBufSize = (uint32_t )0;
  } else
#line 234
  if ((f->track[track])->decoderConfigLen == 0) {
#line 236
    *ppBuf = (uint8_t *)((void *)0);
#line 237
    *pBufSize = (uint32_t )0;
  } else {
    {
#line 239
    tmp = malloc((size_t )(f->track[track])->decoderConfigLen);
#line 239
    *ppBuf = (uint8_t *)tmp;
    }
#line 240
    if ((unsigned long )*ppBuf == (unsigned long )((void *)0)) {
#line 242
      *pBufSize = (uint32_t )0;
#line 243
      return (1);
    }
    {
#line 245
    memcpy((void */* __restrict  */)*ppBuf, (void const   */* __restrict  */)(f->track[track])->decoderConfig,
           (size_t )(f->track[track])->decoderConfigLen);
#line 246
    *pBufSize = (uint32_t )(f->track[track])->decoderConfigLen;
    }
  }
#line 249
  return (0);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_get_track_type(mp4ff_t const   *f , int const   track ) 
{ 


  {
#line 254
  return ((f->track[track])->type);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_total_tracks(mp4ff_t const   *f ) 
{ 


  {
#line 259
  return ((int32_t )f->total_tracks);
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_time_scale(mp4ff_t const   *f , int32_t const   track ) 
{ 


  {
#line 264
  return ((int32_t )(f->track[track])->timeScale);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
uint32_t mp4ff_get_avg_bitrate(mp4ff_t const   *f , int32_t const   track ) 
{ 


  {
#line 269
  return ((f->track[track])->avgBitrate);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
uint32_t mp4ff_get_max_bitrate(mp4ff_t const   *f , int32_t const   track ) 
{ 


  {
#line 274
  return ((f->track[track])->maxBitrate);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int64_t mp4ff_get_track_duration(mp4ff_t const   *f , int32_t const   track ) 
{ 


  {
#line 279
  return ((int64_t )(f->track[track])->duration);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int64_t mp4ff_get_track_duration_use_offsets(mp4ff_t const   *f , int32_t const   track ) 
{ 
  int64_t duration ;
  int64_t tmp ;
  int64_t offset ;
  int32_t tmp___0 ;

  {
  {
#line 284
  tmp = mp4ff_get_track_duration(f, track);
#line 284
  duration = tmp;
  }
#line 285
  if (duration != -1L) {
    {
#line 287
    tmp___0 = mp4ff_get_sample_offset(f, track, (int32_t const   )0);
#line 287
    offset = (int64_t )tmp___0;
    }
#line 288
    if (offset > duration) {
#line 288
      duration = (int64_t )0;
    } else {
#line 289
      duration -= offset;
    }
  }
#line 291
  return (duration);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_num_samples(mp4ff_t const   *f , int32_t const   track ) 
{ 
  int32_t i ;
  int32_t total ;

  {
#line 298
  total = 0;
#line 300
  i = 0;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (i < (f->track[track])->stts_entry_count)) {
#line 300
      goto while_break;
    }
#line 302
    total += *((f->track[track])->stts_sample_count + i);
#line 300
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return (total);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
uint32_t mp4ff_get_sample_rate(mp4ff_t const   *f , int32_t const   track ) 
{ 


  {
#line 312
  return ((uint32_t )(f->track[track])->sampleRate);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
uint32_t mp4ff_get_channel_count(mp4ff_t const   *f , int32_t const   track ) 
{ 


  {
#line 317
  return ((uint32_t )(f->track[track])->channelCount);
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
uint32_t mp4ff_get_audio_type(mp4ff_t const   *f , int32_t const   track ) 
{ 


  {
#line 322
  return ((uint32_t )(f->track[track])->audioType);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_get_sample_duration_use_offsets(mp4ff_t const   *f , int32_t const   track ,
                                              int32_t const   sample ) 
{ 
  int32_t d ;
  int32_t o ;

  {
  {
#line 328
  d = mp4ff_get_sample_duration(f, track, sample);
  }
#line 329
  if (d != -1) {
    {
#line 331
    o = mp4ff_get_sample_offset(f, track, sample);
    }
#line 332
    if (o > d) {
#line 332
      d = 0;
    } else {
#line 333
      d -= o;
    }
  }
#line 335
  return (d);
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_get_sample_duration(mp4ff_t const   *f , int32_t const   track , int32_t const   sample ) 
{ 
  int32_t i ;
  int32_t co ;
  int32_t delta ;

  {
#line 340
  co = 0;
#line 342
  i = 0;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! (i < (f->track[track])->stts_entry_count)) {
#line 342
      goto while_break;
    }
#line 344
    delta = *((f->track[track])->stts_sample_count + i);
#line 345
    if (sample < (int32_t const   )(co + delta)) {
#line 346
      return (*((f->track[track])->stts_sample_delta + i));
    }
#line 347
    co += delta;
#line 342
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return (-1);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int64_t mp4ff_get_sample_position(mp4ff_t const   *f , int32_t const   track , int32_t const   sample ) 
{ 
  int32_t i ;
  int32_t co ;
  int64_t acc ;
  int32_t delta ;

  {
#line 354
  co = 0;
#line 355
  acc = (int64_t )0;
#line 357
  i = 0;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (i < (f->track[track])->stts_entry_count)) {
#line 357
      goto while_break;
    }
#line 359
    delta = *((f->track[track])->stts_sample_count + i);
#line 360
    if (sample < (int32_t const   )(co + delta)) {
#line 362
      acc += (int64_t )(*((f->track[track])->stts_sample_delta + i) * (int32_t )(sample - (int32_t const   )co));
#line 363
      return (acc);
    } else {
#line 367
      acc += (int64_t )(*((f->track[track])->stts_sample_delta + i) * delta);
    }
#line 369
    co += delta;
#line 357
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  return ((int64_t )-1);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_get_sample_offset(mp4ff_t const   *f , int32_t const   track , int32_t const   sample ) 
{ 
  int32_t i ;
  int32_t co ;
  int32_t delta ;

  {
#line 376
  co = 0;
#line 378
  i = 0;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! (i < (f->track[track])->ctts_entry_count)) {
#line 378
      goto while_break;
    }
#line 380
    delta = *((f->track[track])->ctts_sample_count + i);
#line 381
    if (sample < (int32_t const   )(co + delta)) {
#line 382
      return (*((f->track[track])->ctts_sample_offset + i));
    }
#line 383
    co += delta;
#line 378
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  return (0);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_find_sample(mp4ff_t const   *f , int32_t const   track , int64_t const   offset ,
                          int32_t *toskip ) 
{ 
  int32_t i ;
  int32_t co ;
  int64_t offset_total ;
  mp4ff_track_t *p_track ;
  int32_t sample_count ;
  int32_t sample_delta ;
  int64_t offset_delta ;
  int64_t offset_fromstts ;

  {
#line 390
  co = 0;
#line 391
  offset_total = (int64_t )0;
#line 392
  p_track = f->track[track];
#line 394
  i = 0;
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (i < p_track->stts_entry_count)) {
#line 394
      goto while_break;
    }
#line 396
    sample_count = *(p_track->stts_sample_count + i);
#line 397
    sample_delta = *(p_track->stts_sample_delta + i);
#line 398
    offset_delta = (int64_t )sample_delta * (int64_t )sample_count;
#line 399
    if (offset < (int64_t const   )(offset_total + offset_delta)) {
#line 401
      offset_fromstts = (int64_t )(offset - (int64_t const   )offset_total);
#line 402
      if (toskip) {
#line 402
        *toskip = (int32_t )(offset_fromstts % (long )sample_delta);
      }
#line 403
      return (co + (int32_t )(offset_fromstts / (int64_t )sample_delta));
    } else {
#line 407
      offset_total += offset_delta;
    }
#line 409
    co += sample_count;
#line 394
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  return (-1);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_find_sample_use_offsets(mp4ff_t const   *f , int32_t const   track ,
                                      int64_t const   offset , int32_t *toskip ) 
{ 
  int32_t tmp ;
  int32_t tmp___0 ;

  {
  {
#line 416
  tmp = mp4ff_get_sample_offset(f, track, (int32_t const   )0);
#line 416
  tmp___0 = mp4ff_find_sample(f, track, offset + (int64_t const   )tmp, toskip);
  }
#line 416
  return (tmp___0);
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_read_sample(mp4ff_t *f , int32_t const   track , int32_t const   sample ,
                          uint8_t **audio_buffer , uint32_t *bytes ) 
{ 
  int32_t result ;
  int32_t tmp ;
  void *tmp___0 ;

  {
  {
#line 422
  result = 0;
#line 424
  tmp = mp4ff_audio_frame_size((mp4ff_t const   *)f, track, sample);
#line 424
  *bytes = (uint32_t )tmp;
  }
#line 426
  if (*bytes == 0U) {
#line 426
    return (0);
  }
  {
#line 428
  tmp___0 = malloc((size_t )*bytes);
#line 428
  *audio_buffer = (uint8_t *)tmp___0;
#line 430
  mp4ff_set_sample_position(f, track, sample);
#line 432
  result = mp4ff_read_data(f, (int8_t *)*audio_buffer, *bytes);
  }
#line 434
  if (! result) {
    {
#line 436
    free((void *)*audio_buffer);
#line 437
    *audio_buffer = (uint8_t *)0;
    }
#line 438
    return (0);
  }
#line 448
  return ((int32_t )*bytes);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_read_sample_v2(mp4ff_t *f , int const   track , int const   sample ,
                             unsigned char *buffer ) 
{ 
  int32_t result ;
  int32_t size ;
  int32_t tmp ;

  {
  {
#line 454
  result = 0;
#line 455
  tmp = mp4ff_audio_frame_size((mp4ff_t const   *)f, track, sample);
#line 455
  size = tmp;
  }
#line 456
  if (size <= 0) {
#line 456
    return (0);
  }
  {
#line 457
  mp4ff_set_sample_position(f, track, sample);
#line 458
  result = mp4ff_read_data(f, (int8_t *)buffer, (uint32_t )size);
  }
#line 467
  return (result);
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4ff.c"
int32_t mp4ff_read_sample_getsize(mp4ff_t *f , int const   track , int const   sample ) 
{ 
  int32_t temp ;
  int32_t tmp ;

  {
  {
#line 472
  tmp = mp4ff_audio_frame_size((mp4ff_t const   *)f, track, sample);
#line 472
  temp = tmp;
  }
#line 473
  if (temp < 0) {
#line 473
    temp = 0;
  }
#line 474
  return (temp);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static uint32_t fix_byte_order_32(uint32_t src ) 
{ 
  uint32_t result ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  int8_t data[4] ;

  {
  {
#line 13
  memcpy((void */* __restrict  */)(data), (void const   */* __restrict  */)(& src),
         sizeof(src));
#line 14
  a = (uint32_t )((uint8_t )data[0]);
#line 15
  b = (uint32_t )((uint8_t )data[1]);
#line 16
  c = (uint32_t )((uint8_t )data[2]);
#line 17
  d = (uint32_t )((uint8_t )data[3]);
#line 19
  result = (((a << 24) | (b << 16)) | (c << 8)) | d;
  }
#line 20
  return (result);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
unsigned int membuffer_write(membuffer *buf , void const   *ptr , unsigned int bytes ) 
{ 
  unsigned int dest_size ;
  void *newptr ;
  void *tmp ;

  {
#line 48
  dest_size = buf->written + bytes;
#line 50
  if (buf->error) {
#line 50
    return (0U);
  }
#line 51
  if (dest_size > buf->allocated) {
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
#line 55
      buf->allocated <<= 1;
#line 53
      if (! (dest_size > buf->allocated)) {
#line 53
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 59
    tmp = realloc(buf->data, (size_t )buf->allocated);
#line 59
    newptr = tmp;
    }
#line 60
    if ((unsigned long )newptr == (unsigned long )((void *)0)) {
      {
#line 62
      free(buf->data);
#line 63
      buf->data = (void *)0;
#line 64
      buf->error = 1U;
      }
#line 65
      return (0U);
    }
#line 67
    buf->data = newptr;
  }
#line 71
  if (ptr) {
    {
#line 71
    memcpy((void */* __restrict  */)((char *)buf->data + buf->written), (void const   */* __restrict  */)ptr,
           (size_t )bytes);
    }
  }
#line 72
  buf->written += bytes;
#line 73
  return (bytes);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
unsigned int membuffer_write_int32(membuffer *buf , uint32_t data ) 
{ 
  uint8_t temp[4] ;
  unsigned int tmp ;

  {
  {
#line 80
  temp[0] = (uint8_t )(data >> 24);
#line 80
  temp[1] = (uint8_t )(data >> 16);
#line 80
  temp[2] = (uint8_t )(data >> 8);
#line 80
  temp[3] = (uint8_t )data;
#line 81
  tmp = membuffer_write(buf, (void const   *)(temp), 4U);
  }
#line 81
  return (tmp);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
unsigned int membuffer_write_int24(membuffer *buf , uint32_t data ) 
{ 
  uint8_t temp[3] ;
  unsigned int tmp ;

  {
  {
#line 86
  temp[0] = (uint8_t )(data >> 16);
#line 86
  temp[1] = (uint8_t )(data >> 8);
#line 86
  temp[2] = (uint8_t )data;
#line 87
  tmp = membuffer_write(buf, (void const   *)(temp), 3U);
  }
#line 87
  return (tmp);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
unsigned int membuffer_write_int16(membuffer *buf , uint16_t data ) 
{ 
  uint8_t temp[2] ;
  unsigned int tmp ;

  {
  {
#line 92
  temp[0] = (uint8_t )((int )data >> 8);
#line 92
  temp[1] = (uint8_t )data;
#line 93
  tmp = membuffer_write(buf, (void const   *)(temp), 2U);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
unsigned int membuffer_write_atom_name(membuffer *buf , char const   *data ) 
{ 
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 98
  tmp___1 = membuffer_write(buf, (void const   *)data, 4U);
  }
#line 98
  if (tmp___1 == 4U) {
#line 98
    tmp___0 = 1;
  } else {
#line 98
    tmp___0 = 0;
  }
#line 98
  return ((unsigned int )tmp___0);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
void membuffer_write_atom(membuffer *buf , char const   *name , unsigned int size ,
                          void const   *data ) 
{ 


  {
  {
#line 103
  membuffer_write_int32(buf, size + 8U);
#line 104
  membuffer_write_atom_name(buf, name);
#line 105
  membuffer_write(buf, data, size);
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
unsigned int membuffer_write_string(membuffer *buf , char const   *data ) 
{ 
  size_t tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 110
  tmp = strlen(data);
#line 110
  tmp___0 = membuffer_write(buf, (void const   *)data, (unsigned int )tmp);
  }
#line 110
  return (tmp___0);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
unsigned int membuffer_write_int8(membuffer *buf , uint8_t data ) 
{ 
  unsigned int tmp ;

  {
  {
#line 115
  tmp = membuffer_write(buf, (void const   *)(& data), 1U);
  }
#line 115
  return (tmp);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
void *membuffer_get_ptr(membuffer const   *buf ) 
{ 


  {
#line 120
  return ((void *)buf->data);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
unsigned int membuffer_get_size(membuffer const   *buf ) 
{ 


  {
#line 125
  return ((unsigned int )buf->written);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
unsigned int membuffer_error(membuffer const   *buf ) 
{ 


  {
#line 130
  return ((unsigned int )buf->error);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
void membuffer_set_error(membuffer *buf ) 
{ 


  {
#line 133
  buf->error = 1U;
#line 133
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
unsigned int membuffer_transfer_from_file(membuffer *buf , mp4ff_t *src , unsigned int bytes ) 
{ 
  unsigned int oldsize ;
  void *bufptr ;
  unsigned int tmp ;
  int32_t tmp___0 ;

  {
  {
#line 140
  oldsize = membuffer_get_size((membuffer const   *)buf);
#line 141
  tmp = membuffer_write(buf, (void const   *)0, bytes);
  }
#line 141
  if (tmp != bytes) {
#line 141
    return (0U);
  }
  {
#line 143
  bufptr = membuffer_get_ptr((membuffer const   *)buf);
  }
#line 144
  if ((unsigned long )bufptr == (unsigned long )((void *)0)) {
#line 144
    return (0U);
  }
  {
#line 146
  tmp___0 = mp4ff_read_data(src, (int8_t *)((char *)bufptr + oldsize), bytes);
  }
#line 146
  if ((unsigned int )tmp___0 != bytes) {
    {
#line 148
    membuffer_set_error(buf);
    }
#line 149
    return (0U);
  }
#line 152
  return (bytes);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
membuffer *membuffer_create(void) 
{ 
  unsigned int initial_size ;
  membuffer *buf ;
  void *tmp ;

  {
  {
#line 158
  initial_size = 256U;
#line 160
  tmp = malloc(sizeof(membuffer ));
#line 160
  buf = (membuffer *)tmp;
#line 161
  buf->data = malloc((size_t )initial_size);
#line 162
  buf->written = 0U;
#line 163
  buf->allocated = initial_size;
  }
#line 164
  if ((unsigned long )buf->data == (unsigned long )((void *)0)) {
#line 164
    buf->error = 1U;
  } else {
#line 164
    buf->error = 0U;
  }
#line 166
  return (buf);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
void membuffer_free(membuffer *buf ) 
{ 


  {
#line 171
  if (buf->data) {
    {
#line 171
    free(buf->data);
    }
  }
  {
#line 172
  free((void *)buf);
  }
#line 173
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
void *membuffer_detach(membuffer *buf ) 
{ 
  void *ret ;

  {
#line 179
  if (buf->error) {
#line 179
    return ((void *)0);
  }
  {
#line 181
  ret = realloc(buf->data, (size_t )buf->written);
  }
#line 183
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 183
    free(buf->data);
    }
  }
#line 185
  buf->data = (void *)0;
#line 186
  buf->error = 1U;
#line 188
  return (ret);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static stdmeta_entry stdmetas[10]  = 
#line 213
  {      {"\251nam", "title"}, 
        {"\251ART", "artist"}, 
        {"\251wrt", "writer"}, 
        {"\251alb", "album"}, 
        {"\251day", "date"}, 
        {"\251too", "tool"}, 
        {"\251cmt", "comment"}, 
        {"cpil", "compilation"}, 
        {"covr", "cover"}, 
        {"aART", "album_artist"}};
#line 233 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static char const   *find_standard_meta(char const   *name ) 
{ 
  unsigned int n ;
  int tmp ;

  {
#line 236
  n = 0U;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! ((unsigned long )n < sizeof(stdmetas) / sizeof(stdmetas[0]))) {
#line 236
      goto while_break;
    }
    {
#line 238
    tmp = strcasecmp(name, stdmetas[n].name);
    }
#line 238
    if (! tmp) {
#line 238
      return (stdmetas[n].atom);
    }
#line 236
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return ((char const   *)0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static void membuffer_write_track_tag(membuffer *buf , char const   *name , uint32_t index___0 ,
                                      uint32_t total ) 
{ 


  {
  {
#line 245
  membuffer_write_int32(buf, (uint32_t )32);
#line 246
  membuffer_write_atom_name(buf, name);
#line 247
  membuffer_write_int32(buf, (uint32_t )24);
#line 248
  membuffer_write_atom_name(buf, "data");
#line 249
  membuffer_write_int32(buf, (uint32_t )0);
#line 250
  membuffer_write_int32(buf, (uint32_t )0);
#line 251
  membuffer_write_int16(buf, (uint16_t )0);
#line 252
  membuffer_write_int16(buf, (uint16_t )index___0);
#line 253
  membuffer_write_int16(buf, (uint16_t )total);
#line 254
  membuffer_write_int16(buf, (uint16_t )0);
  }
#line 255
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static void membuffer_write_int16_tag(membuffer *buf , char const   *name , uint16_t value ) 
{ 


  {
  {
#line 259
  membuffer_write_int32(buf, (uint32_t )26);
#line 260
  membuffer_write_atom_name(buf, name);
#line 261
  membuffer_write_int32(buf, (uint32_t )18);
#line 262
  membuffer_write_atom_name(buf, "data");
#line 263
  membuffer_write_int32(buf, (uint32_t )0);
#line 264
  membuffer_write_int32(buf, (uint32_t )0);
#line 265
  membuffer_write_int16(buf, value);
  }
#line 266
  return;
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static void membuffer_write_std_tag(membuffer *buf , char const   *name , char const   *value ) 
{ 
  uint32_t flags ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 271
  flags = (uint32_t )1;
#line 274
  tmp = strcmp(name, "cpil");
  }
#line 274
  if (tmp == 0) {
#line 276
    flags = (uint32_t )21;
  }
  {
#line 279
  tmp___0 = strlen(value);
#line 279
  membuffer_write_int32(buf, (uint32_t )(24UL + tmp___0));
#line 280
  membuffer_write_atom_name(buf, name);
#line 281
  tmp___1 = strlen(value);
#line 281
  membuffer_write_int32(buf, (uint32_t )(16UL + tmp___1));
#line 282
  membuffer_write_atom_name(buf, "data");
#line 283
  membuffer_write_int32(buf, flags);
#line 284
  membuffer_write_int32(buf, (uint32_t )0);
#line 285
  tmp___2 = strlen(value);
#line 285
  membuffer_write(buf, (void const   *)value, (unsigned int )tmp___2);
  }
#line 286
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static void membuffer_write_custom_tag(membuffer *buf , char const   *name , char const   *value ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 290
  tmp = strlen(name);
#line 290
  tmp___0 = strlen(value);
#line 290
  membuffer_write_int32(buf, (uint32_t )(((48UL + tmp) + 16UL) + tmp___0));
#line 291
  membuffer_write_atom_name(buf, "----");
#line 292
  membuffer_write_int32(buf, (uint32_t )28);
#line 293
  membuffer_write_atom_name(buf, "mean");
#line 294
  membuffer_write_int32(buf, (uint32_t )0);
#line 295
  membuffer_write(buf, (void const   *)"com.apple.iTunes", 16U);
#line 296
  tmp___1 = strlen(name);
#line 296
  membuffer_write_int32(buf, (uint32_t )(12UL + tmp___1));
#line 297
  membuffer_write_atom_name(buf, "name");
#line 298
  membuffer_write_int32(buf, (uint32_t )0);
#line 299
  tmp___2 = strlen(name);
#line 299
  membuffer_write(buf, (void const   *)name, (unsigned int )tmp___2);
#line 300
  tmp___3 = strlen(value);
#line 300
  membuffer_write_int32(buf, (uint32_t )(16UL + tmp___3));
#line 301
  membuffer_write_atom_name(buf, "data");
#line 302
  membuffer_write_int32(buf, (uint32_t )1);
#line 303
  membuffer_write_int32(buf, (uint32_t )0);
#line 304
  tmp___4 = strlen(value);
#line 304
  membuffer_write(buf, (void const   *)value, (unsigned int )tmp___4);
  }
#line 306
  return;
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static uint32_t myatoi(char const   *param ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 310
  if (param) {
    {
#line 310
    tmp = atoi(param);
#line 310
    tmp___0 = tmp;
    }
  } else {
#line 310
    tmp___0 = 0;
  }
#line 310
  return ((uint32_t )tmp___0);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static uint32_t create_ilst(mp4ff_metadata_t const   *data , void **out_buffer , uint32_t *out_size ) 
{ 
  membuffer *buf ;
  membuffer *tmp ;
  unsigned int metaptr ;
  char *mask ;
  void *tmp___0 ;
  char const   *tracknumber_ptr ;
  char const   *totaltracks_ptr ;
  char const   *discnumber_ptr ;
  char const   *totaldiscs_ptr ;
  char const   *genre_ptr ;
  char const   *tempo_ptr ;
  mp4ff_tag_t *tag ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t index___0 ;
  uint32_t tmp___14 ;
  mp4ff_tag_t *tag___0 ;
  char const   *std_meta_atom ;
  char const   *tmp___15 ;
  unsigned int tmp___16 ;

  {
  {
#line 315
  tmp = membuffer_create();
#line 315
  buf = tmp;
#line 317
  tmp___0 = malloc((size_t )data->count);
#line 317
  mask = (char *)tmp___0;
#line 318
  memset((void *)mask, 0, (size_t )data->count);
#line 321
  tracknumber_ptr = (char const   *)0;
#line 321
  totaltracks_ptr = (char const   *)0;
#line 322
  discnumber_ptr = (char const   *)0;
#line 322
  totaldiscs_ptr = (char const   *)0;
#line 323
  genre_ptr = (char const   *)0;
#line 323
  tempo_ptr = (char const   *)0;
#line 324
  metaptr = 0U;
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (metaptr < (unsigned int )data->count)) {
#line 324
      goto while_break;
    }
    {
#line 326
    tag = data->tags + metaptr;
#line 327
    tmp___7 = strcasecmp((char const   *)tag->item, "tracknumber");
    }
#line 327
    if (tmp___7) {
      {
#line 327
      tmp___8 = strcasecmp((char const   *)tag->item, "track");
      }
#line 327
      if (tmp___8) {
        {
#line 332
        tmp___6 = strcasecmp((char const   *)tag->item, "totaltracks");
        }
#line 332
        if (tmp___6) {
          {
#line 337
          tmp___4 = strcasecmp((char const   *)tag->item, "discnumber");
          }
#line 337
          if (tmp___4) {
            {
#line 337
            tmp___5 = strcasecmp((char const   *)tag->item, "disc");
            }
#line 337
            if (tmp___5) {
              {
#line 342
              tmp___3 = strcasecmp((char const   *)tag->item, "totaldiscs");
              }
#line 342
              if (tmp___3) {
                {
#line 347
                tmp___2 = strcasecmp((char const   *)tag->item, "genre");
                }
#line 347
                if (tmp___2) {
                  {
#line 352
                  tmp___1 = strcasecmp((char const   *)tag->item, "tempo");
                  }
#line 352
                  if (! tmp___1) {
#line 354
                    if ((unsigned long )tempo_ptr == (unsigned long )((char const   *)0)) {
#line 354
                      tempo_ptr = (char const   *)tag->value;
                    }
#line 355
                    *(mask + metaptr) = (char)1;
                  }
                } else {
#line 349
                  if ((unsigned long )genre_ptr == (unsigned long )((char const   *)0)) {
#line 349
                    genre_ptr = (char const   *)tag->value;
                  }
#line 350
                  *(mask + metaptr) = (char)1;
                }
              } else {
#line 344
                if ((unsigned long )totaldiscs_ptr == (unsigned long )((char const   *)0)) {
#line 344
                  totaldiscs_ptr = (char const   *)tag->value;
                }
#line 345
                *(mask + metaptr) = (char)1;
              }
            } else {
              _L: /* CIL Label */ 
#line 339
              if ((unsigned long )discnumber_ptr == (unsigned long )((char const   *)0)) {
#line 339
                discnumber_ptr = (char const   *)tag->value;
              }
#line 340
              *(mask + metaptr) = (char)1;
            }
          } else {
#line 337
            goto _L;
          }
        } else {
#line 334
          if ((unsigned long )totaltracks_ptr == (unsigned long )((char const   *)0)) {
#line 334
            totaltracks_ptr = (char const   *)tag->value;
          }
#line 335
          *(mask + metaptr) = (char)1;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 329
        if ((unsigned long )tracknumber_ptr == (unsigned long )((char const   *)0)) {
#line 329
          tracknumber_ptr = (char const   *)tag->value;
        }
#line 330
        *(mask + metaptr) = (char)1;
      }
    } else {
#line 327
      goto _L___0;
    }
#line 324
    metaptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  if (tracknumber_ptr) {
    {
#line 360
    tmp___9 = myatoi(totaltracks_ptr);
#line 360
    tmp___10 = myatoi(tracknumber_ptr);
#line 360
    membuffer_write_track_tag(buf, "trkn", tmp___10, tmp___9);
    }
  }
#line 361
  if (discnumber_ptr) {
    {
#line 361
    tmp___11 = myatoi(totaldiscs_ptr);
#line 361
    tmp___12 = myatoi(discnumber_ptr);
#line 361
    membuffer_write_track_tag(buf, "disk", tmp___12, tmp___11);
    }
  }
#line 362
  if (tempo_ptr) {
    {
#line 362
    tmp___13 = myatoi(tempo_ptr);
#line 362
    membuffer_write_int16_tag(buf, "tmpo", (uint16_t )tmp___13);
    }
  }
#line 364
  if (genre_ptr) {
    {
#line 366
    tmp___14 = mp4ff_meta_genre_to_index(genre_ptr);
#line 366
    index___0 = tmp___14;
    }
#line 367
    if (index___0 == 0U) {
      {
#line 368
      membuffer_write_std_tag(buf, "\251gen", genre_ptr);
      }
    } else {
      {
#line 370
      membuffer_write_int16_tag(buf, "gnre", (uint16_t )index___0);
      }
    }
  }
#line 374
  metaptr = 0U;
  {
#line 374
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 374
    if (! (metaptr < (unsigned int )data->count)) {
#line 374
      goto while_break___0;
    }
#line 376
    if (! *(mask + metaptr)) {
      {
#line 378
      tag___0 = data->tags + metaptr;
#line 379
      tmp___15 = find_standard_meta((char const   *)tag___0->item);
#line 379
      std_meta_atom = tmp___15;
      }
#line 380
      if (std_meta_atom) {
        {
#line 382
        membuffer_write_std_tag(buf, std_meta_atom, (char const   *)tag___0->value);
        }
      } else {
        {
#line 386
        membuffer_write_custom_tag(buf, (char const   *)tag___0->item, (char const   *)tag___0->value);
        }
      }
    }
#line 374
    metaptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 391
  free((void *)mask);
#line 393
  tmp___16 = membuffer_error((membuffer const   *)buf);
  }
#line 393
  if (tmp___16) {
    {
#line 395
    membuffer_free(buf);
    }
#line 396
    return ((uint32_t )0);
  }
  {
#line 399
  *out_size = membuffer_get_size((membuffer const   *)buf);
#line 400
  *out_buffer = membuffer_detach(buf);
#line 401
  membuffer_free(buf);
  }
#line 403
  return ((uint32_t )1);
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static uint32_t find_atom(mp4ff_t *f , uint64_t base , uint32_t size , char const   *name ) 
{ 
  uint32_t remaining ;
  uint64_t atom_offset ;
  char atom_name[4] ;
  uint32_t atom_size ;
  int tmp ;

  {
#line 408
  remaining = size;
#line 409
  atom_offset = base;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 415
    mp4ff_set_position(f, (int64_t const   )atom_offset);
    }
#line 417
    if (remaining < 8U) {
#line 417
      goto while_break;
    }
    {
#line 418
    atom_size = mp4ff_read_int32(f);
    }
#line 419
    if (atom_size > remaining) {
#line 419
      goto while_break;
    } else
#line 419
    if (atom_size < 8U) {
#line 419
      goto while_break;
    }
    {
#line 420
    mp4ff_read_data(f, (int8_t *)(atom_name), (uint32_t )4);
#line 422
    tmp = memcmp((void const   *)(atom_name), (void const   *)name, (size_t )4);
    }
#line 422
    if (! tmp) {
      {
#line 424
      mp4ff_set_position(f, (int64_t const   )atom_offset);
      }
#line 425
      return ((uint32_t )1);
    }
#line 428
    remaining -= atom_size;
#line 429
    atom_offset += (uint64_t )atom_size;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  return ((uint32_t )0);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static uint32_t find_atom_v2(mp4ff_t *f , uint64_t base , uint32_t size , char const   *name ,
                             uint32_t extraheaders , char const   *name_inside ) 
{ 
  uint64_t first_base ;
  uint64_t mybase ;
  int64_t tmp ;
  uint32_t mysize ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 436
  first_base = (uint64_t )-1;
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 437
    tmp___2 = find_atom(f, base, size, name);
    }
#line 437
    if (! tmp___2) {
#line 437
      goto while_break;
    }
    {
#line 439
    tmp = mp4ff_position((mp4ff_t const   *)f);
#line 439
    mybase = (uint64_t )tmp;
#line 440
    tmp___0 = mp4ff_read_int32(f);
#line 440
    mysize = tmp___0;
    }
#line 442
    if (first_base == 0xffffffffffffffffUL) {
#line 442
      first_base = mybase;
    }
#line 444
    if (mysize < 8U + extraheaders) {
#line 444
      goto while_break;
    }
    {
#line 446
    tmp___1 = find_atom(f, mybase + (uint64_t )(8U + extraheaders), mysize - (8U + extraheaders),
                        name_inside);
    }
#line 446
    if (tmp___1) {
      {
#line 448
      mp4ff_set_position(f, (int64_t const   )mybase);
      }
#line 449
      return ((uint32_t )2);
    }
#line 451
    base += (uint64_t )mysize;
#line 452
    if (size <= mysize) {
#line 452
      size = (uint32_t )0;
#line 452
      goto while_break;
    }
#line 453
    size -= mysize;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (first_base != 0xffffffffffffffffUL) {
    {
#line 458
    mp4ff_set_position(f, (int64_t const   )first_base);
    }
#line 459
    return ((uint32_t )1);
  } else {
#line 461
    return ((uint32_t )0);
  }
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static uint32_t create_meta(mp4ff_metadata_t const   *data , void **out_buffer , uint32_t *out_size ) 
{ 
  membuffer *buf ;
  uint32_t ilst_size ;
  void *ilst_buffer ;
  uint32_t tmp ;

  {
  {
#line 470
  tmp = create_ilst(data, & ilst_buffer, & ilst_size);
  }
#line 470
  if (! tmp) {
#line 470
    return ((uint32_t )0);
  }
  {
#line 472
  buf = membuffer_create();
#line 474
  membuffer_write_int32(buf, (uint32_t )0);
#line 475
  membuffer_write_atom(buf, "ilst", ilst_size, (void const   *)ilst_buffer);
#line 476
  free(ilst_buffer);
#line 478
  *out_size = membuffer_get_size((membuffer const   *)buf);
#line 479
  *out_buffer = membuffer_detach(buf);
#line 480
  membuffer_free(buf);
  }
#line 481
  return ((uint32_t )1);
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static uint32_t create_udta(mp4ff_metadata_t const   *data , void **out_buffer , uint32_t *out_size ) 
{ 
  membuffer *buf ;
  uint32_t meta_size ;
  void *meta_buffer ;
  uint32_t tmp ;

  {
  {
#line 490
  tmp = create_meta(data, & meta_buffer, & meta_size);
  }
#line 490
  if (! tmp) {
#line 490
    return ((uint32_t )0);
  }
  {
#line 492
  buf = membuffer_create();
#line 494
  membuffer_write_atom(buf, "meta", meta_size, (void const   *)meta_buffer);
#line 496
  free(meta_buffer);
#line 498
  *out_size = membuffer_get_size((membuffer const   *)buf);
#line 499
  *out_buffer = membuffer_detach(buf);
#line 500
  membuffer_free(buf);
  }
#line 501
  return ((uint32_t )1);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
static uint32_t modify_moov(mp4ff_t *f , mp4ff_metadata_t const   *data , void **out_buffer ,
                            uint32_t *out_size ) 
{ 
  uint64_t total_base ;
  uint32_t total_size ;
  uint64_t udta_offset ;
  uint64_t meta_offset ;
  uint64_t ilst_offset ;
  uint32_t udta_size ;
  uint32_t meta_size ;
  uint32_t ilst_size ;
  uint32_t new_ilst_size ;
  void *new_ilst_buffer ;
  uint8_t *p_out ;
  int32_t size_delta ;
  membuffer *buf ;
  void *new_udta_buffer ;
  uint32_t new_udta_size ;
  uint32_t tmp ;
  int64_t tmp___0 ;
  membuffer *buf___0 ;
  void *new_meta_buffer ;
  uint32_t new_meta_size ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int64_t tmp___3 ;
  uint32_t tmp___4 ;
  int64_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;

  {
  {
#line 506
  total_base = f->moov_offset + 8UL;
#line 507
  total_size = (uint32_t )(f->moov_size - 8UL);
#line 519
  tmp___10 = find_atom_v2(f, total_base, total_size, "udta", (uint32_t )0, "meta");
  }
#line 519
  if (tmp___10) {
    {
#line 541
    tmp___0 = mp4ff_position((mp4ff_t const   *)f);
#line 541
    udta_offset = (uint64_t )tmp___0;
#line 542
    udta_size = mp4ff_read_int32(f);
#line 543
    tmp___2 = find_atom_v2(f, udta_offset + 8UL, udta_size - 8U, "meta", (uint32_t )4,
                           "ilst");
    }
#line 543
    if (! tmp___2) {
      {
#line 548
      tmp___1 = create_meta(data, & new_meta_buffer, & new_meta_size);
      }
#line 548
      if (! tmp___1) {
#line 548
        return ((uint32_t )0);
      }
      {
#line 550
      buf___0 = membuffer_create();
#line 551
      mp4ff_set_position(f, (int64_t const   )total_base);
#line 552
      membuffer_transfer_from_file(buf___0, f, (uint32_t )(udta_offset - total_base));
#line 554
      membuffer_write_int32(buf___0, (udta_size + 8U) + new_meta_size);
#line 555
      membuffer_write_atom_name(buf___0, "udta");
#line 556
      membuffer_transfer_from_file(buf___0, f, udta_size);
#line 558
      membuffer_write_atom(buf___0, "meta", new_meta_size, (void const   *)new_meta_buffer);
#line 559
      free(new_meta_buffer);
#line 561
      *out_size = membuffer_get_size((membuffer const   *)buf___0);
#line 562
      *out_buffer = membuffer_detach(buf___0);
#line 563
      membuffer_free(buf___0);
      }
#line 564
      return ((uint32_t )1);
    }
    {
#line 566
    tmp___3 = mp4ff_position((mp4ff_t const   *)f);
#line 566
    meta_offset = (uint64_t )tmp___3;
#line 567
    meta_size = mp4ff_read_int32(f);
#line 568
    tmp___4 = find_atom(f, meta_offset + 12UL, meta_size - 12U, "ilst");
    }
#line 568
    if (! tmp___4) {
#line 568
      return ((uint32_t )0);
    }
    {
#line 569
    tmp___5 = mp4ff_position((mp4ff_t const   *)f);
#line 569
    ilst_offset = (uint64_t )tmp___5;
#line 570
    ilst_size = mp4ff_read_int32(f);
#line 572
    tmp___6 = create_ilst(data, & new_ilst_buffer, & new_ilst_size);
    }
#line 572
    if (! tmp___6) {
#line 572
      return ((uint32_t )0);
    }
    {
#line 574
    size_delta = (int32_t )(new_ilst_size - (ilst_size - 8U));
#line 576
    *out_size = total_size + (uint32_t )size_delta;
#line 577
    *out_buffer = malloc((size_t )*out_size);
    }
#line 578
    if ((unsigned long )*out_buffer == (unsigned long )((void *)0)) {
      {
#line 580
      free(new_ilst_buffer);
      }
#line 581
      return ((uint32_t )0);
    }
    {
#line 584
    p_out = (uint8_t *)*out_buffer;
#line 586
    mp4ff_set_position(f, (int64_t const   )total_base);
#line 587
    mp4ff_read_data(f, (int8_t *)p_out, (uint32_t )(udta_offset - total_base));
#line 587
    p_out += (uint32_t )(udta_offset - total_base);
#line 588
    tmp___7 = mp4ff_read_int32(f);
#line 588
    *((uint32_t *)p_out) = fix_byte_order_32(tmp___7 + (uint32_t )size_delta);
#line 588
    p_out += 4;
#line 589
    mp4ff_read_data(f, (int8_t *)p_out, (uint32_t )4);
#line 589
    p_out += 4;
#line 590
    mp4ff_read_data(f, (int8_t *)p_out, (uint32_t )((meta_offset - udta_offset) - 8UL));
#line 590
    p_out += (uint32_t )((meta_offset - udta_offset) - 8UL);
#line 591
    tmp___8 = mp4ff_read_int32(f);
#line 591
    *((uint32_t *)p_out) = fix_byte_order_32(tmp___8 + (uint32_t )size_delta);
#line 591
    p_out += 4;
#line 592
    mp4ff_read_data(f, (int8_t *)p_out, (uint32_t )4);
#line 592
    p_out += 4;
#line 593
    mp4ff_read_data(f, (int8_t *)p_out, (uint32_t )((ilst_offset - meta_offset) - 8UL));
#line 593
    p_out += (uint32_t )((ilst_offset - meta_offset) - 8UL);
#line 594
    tmp___9 = mp4ff_read_int32(f);
#line 594
    *((uint32_t *)p_out) = fix_byte_order_32(tmp___9 + (uint32_t )size_delta);
#line 594
    p_out += 4;
#line 595
    mp4ff_read_data(f, (int8_t *)p_out, (uint32_t )4);
#line 595
    p_out += 4;
#line 597
    memcpy((void */* __restrict  */)p_out, (void const   */* __restrict  */)new_ilst_buffer,
           (size_t )new_ilst_size);
#line 598
    p_out += new_ilst_size;
#line 600
    mp4ff_set_position(f, (int64_t const   )(ilst_offset + (uint64_t )ilst_size));
#line 601
    mp4ff_read_data(f, (int8_t *)p_out, (uint32_t )(((uint64_t )total_size - (ilst_offset - total_base)) - (uint64_t )ilst_size));
#line 603
    free(new_ilst_buffer);
    }
  } else {
    {
#line 524
    tmp = create_udta(data, & new_udta_buffer, & new_udta_size);
    }
#line 524
    if (! tmp) {
#line 524
      return ((uint32_t )0);
    }
    {
#line 526
    buf = membuffer_create();
#line 527
    mp4ff_set_position(f, (int64_t const   )total_base);
#line 528
    membuffer_transfer_from_file(buf, f, total_size);
#line 530
    membuffer_write_atom(buf, "udta", new_udta_size, (void const   *)new_udta_buffer);
#line 532
    free(new_udta_buffer);
#line 534
    *out_size = membuffer_get_size((membuffer const   *)buf);
#line 535
    *out_buffer = membuffer_detach(buf);
#line 536
    membuffer_free(buf);
    }
#line 537
    return ((uint32_t )1);
  }
#line 605
  return ((uint32_t )1);
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/common/mp4ff/mp4tagupdate.c"
int32_t mp4ff_meta_update(mp4ff_callback_t *f , mp4ff_metadata_t const   *data ) 
{ 
  void *new_moov_data ;
  uint32_t new_moov_size ;
  mp4ff_t *ff ;
  void *tmp ;
  uint32_t tmp___0 ;
  char *free_data ;

  {
  {
#line 614
  tmp = malloc(sizeof(mp4ff_t ));
#line 614
  ff = (mp4ff_t *)tmp;
#line 616
  memset((void *)ff, 0, sizeof(mp4ff_t ));
#line 617
  ff->stream = f;
#line 618
  mp4ff_set_position(ff, (int64_t const   )0);
#line 620
  parse_atoms(ff, 1);
#line 623
  tmp___0 = modify_moov(ff, data, & new_moov_data, & new_moov_size);
  }
#line 623
  if (! tmp___0) {
    {
#line 625
    mp4ff_close(ff);
    }
#line 626
    return (0);
  }
#line 630
  if ((int )ff->last_atom != 1) {
    {
#line 632
    free_data = (char *)"free";
#line 635
    mp4ff_set_position(ff, (int64_t const   )(ff->moov_offset + 4UL));
#line 636
    mp4ff_write_data(ff, (int8_t *)free_data, (uint32_t )4);
#line 638
    mp4ff_set_position(ff, (int64_t const   )ff->file_size);
#line 639
    mp4ff_write_int32(ff, (uint32_t const   )(new_moov_size + 8U));
#line 640
    mp4ff_write_data(ff, (int8_t *)"moov", (uint32_t )4);
#line 641
    mp4ff_write_data(ff, (int8_t *)new_moov_data, new_moov_size);
    }
  } else {
    {
#line 645
    mp4ff_set_position(ff, (int64_t const   )ff->moov_offset);
#line 646
    mp4ff_write_int32(ff, (uint32_t const   )(new_moov_size + 8U));
#line 647
    mp4ff_write_data(ff, (int8_t *)"moov", (uint32_t )4);
#line 648
    mp4ff_write_data(ff, (int8_t *)new_moov_data, new_moov_size);
    }
  }
  {
#line 651
  mp4ff_truncate(ff);
#line 653
  mp4ff_close(ff);
  }
#line 654
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 205 "../include/neaacdec.h"
extern char __attribute__((__visibility__("default")))  *NeAACDecGetErrorMessage(unsigned char errcode ) ;
#line 207
extern unsigned long __attribute__((__visibility__("default")))  NeAACDecGetCapabilities(void) ;
#line 209
extern NeAACDecHandle __attribute__((__visibility__("default")))  NeAACDecOpen(void) ;
#line 211
extern NeAACDecConfigurationPtr __attribute__((__visibility__("default")))  NeAACDecGetCurrentConfiguration(NeAACDecHandle hDecoder ) ;
#line 213
extern unsigned char __attribute__((__visibility__("default")))  NeAACDecSetConfiguration(NeAACDecHandle hDecoder ,
                                                                                          NeAACDecConfigurationPtr config ) ;
#line 217
extern long __attribute__((__visibility__("default")))  NeAACDecInit(NeAACDecHandle hDecoder ,
                                                                     unsigned char *buffer ,
                                                                     unsigned long buffer_size ,
                                                                     unsigned long *samplerate ,
                                                                     unsigned char *channels ) ;
#line 224
extern char __attribute__((__visibility__("default")))  NeAACDecInit2(NeAACDecHandle hDecoder ,
                                                                      unsigned char *pBuffer ,
                                                                      unsigned long SizeOfDecoderSpecificInfo ,
                                                                      unsigned long *samplerate ,
                                                                      unsigned char *channels ) ;
#line 236
extern void __attribute__((__visibility__("default")))  NeAACDecClose(NeAACDecHandle hDecoder ) ;
#line 238
extern void __attribute__((__visibility__("default")))  *NeAACDecDecode(NeAACDecHandle hDecoder ,
                                                                        NeAACDecFrameInfo *hInfo ,
                                                                        unsigned char *buffer ,
                                                                        unsigned long buffer_size ) ;
#line 250
extern char __attribute__((__visibility__("default")))  NeAACDecAudioSpecificConfig(unsigned char *pBuffer ,
                                                                                    unsigned long buffer_size ,
                                                                                    mp4AudioSpecificConfig *mp4ASC ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static int quiet  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static void faad_fprintf(FILE *stream , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
#line 65
  if (! quiet) {
    {
#line 67
    __builtin_va_start(ap, fmt);
#line 69
    vfprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)fmt,
             ap);
#line 71
    __builtin_va_end(ap);
    }
  }
#line 73
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static int fill_buffer(aac_buffer *b ) 
{ 
  int bread ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 90
  if (b->bytes_consumed > 0L) {
#line 92
    if (b->bytes_into_buffer) {
      {
#line 94
      memmove((void *)b->buffer, (void const   *)((void *)(b->buffer + b->bytes_consumed)),
              (unsigned long )b->bytes_into_buffer * sizeof(unsigned char ));
      }
    }
#line 98
    if (! b->at_eof) {
      {
#line 100
      tmp = fread((void */* __restrict  */)((void *)(b->buffer + b->bytes_into_buffer)),
                  (size_t )1, (size_t )b->bytes_consumed, (FILE */* __restrict  */)b->infile);
#line 100
      bread = (int )tmp;
      }
#line 103
      if ((long )bread != b->bytes_consumed) {
#line 104
        b->at_eof = 1;
      }
#line 106
      b->bytes_into_buffer += (long )bread;
    }
#line 109
    b->bytes_consumed = 0L;
#line 111
    if (b->bytes_into_buffer > 3L) {
      {
#line 113
      tmp___0 = memcmp((void const   *)b->buffer, (void const   *)"TAG", (size_t )3);
      }
#line 113
      if (tmp___0 == 0) {
#line 114
        b->bytes_into_buffer = 0L;
      }
    }
#line 116
    if (b->bytes_into_buffer > 11L) {
      {
#line 118
      tmp___1 = memcmp((void const   *)b->buffer, (void const   *)"LYRICSBEGIN", (size_t )11);
      }
#line 118
      if (tmp___1 == 0) {
#line 119
        b->bytes_into_buffer = 0L;
      }
    }
#line 121
    if (b->bytes_into_buffer > 8L) {
      {
#line 123
      tmp___2 = memcmp((void const   *)b->buffer, (void const   *)"APETAGEX", (size_t )8);
      }
#line 123
      if (tmp___2 == 0) {
#line 124
        b->bytes_into_buffer = 0L;
      }
    }
  }
#line 128
  return (1);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static void advance_buffer(aac_buffer *b , int bytes ) 
{ 


  {
#line 133
  b->file_offset += (long )bytes;
#line 134
  b->bytes_consumed = (long )bytes;
#line 135
  b->bytes_into_buffer -= (long )bytes;
#line 136
  if (b->bytes_into_buffer < 0L) {
#line 137
    b->bytes_into_buffer = 0L;
  }
#line 138
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static void lookforheader(aac_buffer *b ) 
{ 
  int i ;

  {
#line 142
  i = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (! b->at_eof)) {
#line 143
      goto while_break;
    }
#line 145
    if (b->bytes_into_buffer > 4L) {
#line 147
      if ((int )*(b->buffer + i) == 255) {
#line 147
        if (((int )*(b->buffer + (1 + i)) & 246) == 240) {
          {
#line 150
          fill_buffer(b);
          }
#line 151
          goto while_break;
        } else {
#line 147
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 147
      if ((int )*(b->buffer + i) == 65) {
#line 147
        if ((int )*(b->buffer + (1 + i)) == 68) {
#line 147
          if ((int )*(b->buffer + (2 + i)) == 73) {
#line 147
            if ((int )*(b->buffer + (3 + i)) == 70) {
              {
#line 150
              fill_buffer(b);
              }
#line 151
              goto while_break;
            } else {
#line 153
              i ++;
#line 154
              (b->file_offset) ++;
#line 155
              (b->bytes_consumed) ++;
#line 156
              (b->bytes_into_buffer) --;
            }
          } else {
#line 153
            i ++;
#line 154
            (b->file_offset) ++;
#line 155
            (b->bytes_consumed) ++;
#line 156
            (b->bytes_into_buffer) --;
          }
        } else {
#line 153
          i ++;
#line 154
          (b->file_offset) ++;
#line 155
          (b->bytes_consumed) ++;
#line 156
          (b->bytes_into_buffer) --;
        }
      } else {
#line 153
        i ++;
#line 154
        (b->file_offset) ++;
#line 155
        (b->bytes_consumed) ++;
#line 156
        (b->bytes_into_buffer) --;
      }
    } else {
      {
#line 159
      fill_buffer(b);
#line 160
      i = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static int adts_sample_rates[16]  = 
#line 165
  {      96000,      88200,      64000,      48000, 
        44100,      32000,      24000,      22050, 
        16000,      12000,      11025,      8000, 
        7350,      0,      0,      0};
#line 167 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static int adts_parse(aac_buffer *b , int *bitrate , float *length ) 
{ 
  int frames ;
  int frame_length ;
  int t_framelength ;
  int samplerate ;
  float frames_per_sec ;
  float bytes_per_frame ;

  {
#line 170
  t_framelength = 0;
#line 175
  frames = 0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 177
    fill_buffer(b);
    }
#line 179
    if (b->bytes_into_buffer > 7L) {
#line 182
      if ((int )*(b->buffer + 0) == 255) {
#line 182
        if (! (((int )*(b->buffer + 1) & 246) == 240)) {
#line 183
          goto while_break;
        }
      } else {
#line 183
        goto while_break;
      }
#line 185
      if (frames == 0) {
#line 186
        samplerate = adts_sample_rates[((int )*(b->buffer + 2) & 60) >> 2];
      }
#line 188
      frame_length = (int )(((((unsigned int )*(b->buffer + 3) & 3U) << 11) | ((unsigned int )*(b->buffer + 4) << 3)) | (unsigned int )((int )*(b->buffer + 5) >> 5));
#line 191
      t_framelength += frame_length;
#line 193
      if ((long )frame_length > b->bytes_into_buffer) {
#line 194
        goto while_break;
      }
      {
#line 196
      advance_buffer(b, frame_length);
      }
    } else {
#line 198
      goto while_break;
    }
#line 175
    frames ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  frames_per_sec = (float )samplerate / 1024.0f;
#line 203
  if (frames != 0) {
#line 204
    bytes_per_frame = (float )t_framelength / (float )(frames * 1000);
  } else {
#line 206
    bytes_per_frame = (float )0;
  }
#line 207
  *bitrate = (int )((8. * (double )bytes_per_frame) * (double )frames_per_sec + 0.5);
#line 208
  if (frames_per_sec != (float )0) {
#line 209
    *length = (float )frames / frames_per_sec;
  } else {
#line 211
    *length = (float )1;
  }
#line 213
  return (1);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
uint32_t read_callback(void *user_data , void *buffer , uint32_t length ) 
{ 
  size_t tmp ;

  {
  {
#line 220
  tmp = fread((void */* __restrict  */)buffer, (size_t )1, (size_t )length, (FILE */* __restrict  */)((FILE *)user_data));
  }
#line 220
  return ((uint32_t )tmp);
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
uint32_t seek_callback(void *user_data , uint64_t position ) 
{ 
  int tmp ;

  {
  {
#line 225
  tmp = fseek((FILE *)user_data, (long )position, 0);
  }
#line 225
  return ((uint32_t )tmp);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static long aacChannelConfig2wavexChannelMask(NeAACDecFrameInfo *hInfo ) 
{ 


  {
#line 251
  if ((int )hInfo->channels == 6) {
#line 251
    if (hInfo->num_lfe_channels) {
#line 253
      return (63L);
    } else {
#line 257
      return (0L);
    }
  } else {
#line 257
    return (0L);
  }
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static char *position2string(int position ) 
{ 


  {
  {
#line 265
  if (position == 1) {
#line 265
    goto case_1;
  }
#line 266
  if (position == 2) {
#line 266
    goto case_2;
  }
#line 267
  if (position == 3) {
#line 267
    goto case_3;
  }
#line 268
  if (position == 4) {
#line 268
    goto case_4;
  }
#line 269
  if (position == 5) {
#line 269
    goto case_5;
  }
#line 270
  if (position == 6) {
#line 270
    goto case_6;
  }
#line 271
  if (position == 7) {
#line 271
    goto case_7;
  }
#line 272
  if (position == 8) {
#line 272
    goto case_8;
  }
#line 273
  if (position == 9) {
#line 273
    goto case_9;
  }
#line 274
  if (position == 0) {
#line 274
    goto case_0;
  }
#line 275
  goto switch_default;
  case_1: /* CIL Label */ 
#line 265
  return ((char *)"Center front");
  case_2: /* CIL Label */ 
#line 266
  return ((char *)"Left front");
  case_3: /* CIL Label */ 
#line 267
  return ((char *)"Right front");
  case_4: /* CIL Label */ 
#line 268
  return ((char *)"Left side");
  case_5: /* CIL Label */ 
#line 269
  return ((char *)"Right side");
  case_6: /* CIL Label */ 
#line 270
  return ((char *)"Left back");
  case_7: /* CIL Label */ 
#line 271
  return ((char *)"Right back");
  case_8: /* CIL Label */ 
#line 272
  return ((char *)"Center back");
  case_9: /* CIL Label */ 
#line 273
  return ((char *)"LFE");
  case_0: /* CIL Label */ 
#line 274
  return ((char *)"Unknown");
  switch_default: /* CIL Label */ 
#line 275
  return ((char *)"");
  switch_break: /* CIL Label */ ;
  }
#line 278
  return ((char *)"");
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static void print_channel_info(NeAACDecFrameInfo *frameInfo ) 
{ 
  int i ;
  long channelMask ;
  long tmp ;
  char *tmp___0 ;

  {
  {
#line 285
  tmp = aacChannelConfig2wavexChannelMask(frameInfo);
#line 285
  channelMask = tmp;
#line 287
  faad_fprintf(stderr, "  ---------------------\n");
  }
#line 288
  if ((int )frameInfo->num_lfe_channels > 0) {
    {
#line 290
    faad_fprintf(stderr, " | Config: %2d.%d Ch     |", (int )frameInfo->channels - (int )frameInfo->num_lfe_channels,
                 (int )frameInfo->num_lfe_channels);
    }
  } else {
    {
#line 292
    faad_fprintf(stderr, " | Config: %2d Ch       |", (int )frameInfo->channels);
    }
  }
#line 294
  if (channelMask) {
    {
#line 295
    faad_fprintf(stderr, " WARNING: channels are reordered according to\n");
    }
  } else {
    {
#line 297
    faad_fprintf(stderr, "\n");
    }
  }
  {
#line 298
  faad_fprintf(stderr, "  ---------------------");
  }
#line 299
  if (channelMask) {
    {
#line 300
    faad_fprintf(stderr, "  MS defaults defined in WAVE_FORMAT_EXTENSIBLE\n");
    }
  } else {
    {
#line 302
    faad_fprintf(stderr, "\n");
    }
  }
  {
#line 303
  faad_fprintf(stderr, " | Ch |    Position    |\n");
#line 304
  faad_fprintf(stderr, "  ---------------------\n");
#line 305
  i = 0;
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (i < (int )frameInfo->channels)) {
#line 305
      goto while_break;
    }
    {
#line 307
    tmp___0 = position2string((int )frameInfo->channel_position[i]);
#line 307
    faad_fprintf(stderr, " | %.2d | %-14s |\n", i, tmp___0);
#line 305
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 309
  faad_fprintf(stderr, "  ---------------------\n");
#line 310
  faad_fprintf(stderr, "\n");
  }
#line 311
  return;
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static int FindAdtsSRIndex(int sr ) 
{ 
  int i ;

  {
#line 317
  i = 0;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! (i < 16)) {
#line 317
      goto while_break;
    }
#line 319
    if (sr == adts_sample_rates[i]) {
#line 320
      return (i);
    }
#line 317
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  return (15);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static unsigned char *MakeAdtsHeader(int *dataSize , NeAACDecFrameInfo *hInfo , int old_format ) 
{ 
  unsigned char *data ;
  int profile ;
  int sr_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int skip ;
  int tmp___2 ;
  int framesize ;
  void *tmp___3 ;

  {
#line 328
  profile = ((int )hInfo->object_type - 1) & 3;
#line 329
  if ((int )hInfo->sbr == 1) {
    {
#line 329
    tmp = FindAdtsSRIndex((int )(hInfo->samplerate / 2UL));
#line 329
    tmp___1 = tmp;
    }
  } else
#line 329
  if ((int )hInfo->sbr == 3) {
    {
#line 329
    tmp = FindAdtsSRIndex((int )(hInfo->samplerate / 2UL));
#line 329
    tmp___1 = tmp;
    }
  } else {
    {
#line 329
    tmp___0 = FindAdtsSRIndex((int )hInfo->samplerate);
#line 329
    tmp___1 = tmp___0;
    }
  }
#line 329
  sr_index = tmp___1;
#line 331
  if (old_format) {
#line 331
    tmp___2 = 8;
  } else {
#line 331
    tmp___2 = 7;
  }
#line 331
  skip = tmp___2;
#line 332
  framesize = (int )((unsigned long )skip + hInfo->bytesconsumed);
#line 334
  if ((int )hInfo->header_type == 2) {
#line 335
    framesize -= skip;
  }
  {
#line 337
  *dataSize = 7;
#line 339
  tmp___3 = malloc((unsigned long )*dataSize * sizeof(unsigned char ));
#line 339
  data = (unsigned char *)tmp___3;
#line 340
  memset((void *)data, 0, (unsigned long )*dataSize * sizeof(unsigned char ));
#line 342
  *(data + 0) = (unsigned char )((int )*(data + 0) + 255);
#line 344
  *(data + 1) = (unsigned char )((int )*(data + 1) + 240);
#line 347
  *(data + 1) = (unsigned char )((int )*(data + 1) + 1);
#line 349
  *(data + 2) = (unsigned char )((int )*(data + 2) + ((profile << 6) & 192));
#line 350
  *(data + 2) = (unsigned char )((int )*(data + 2) + ((sr_index << 2) & 60));
#line 352
  *(data + 2) = (unsigned char )((int )*(data + 2) + (((int )hInfo->channels >> 2) & 1));
#line 354
  *(data + 3) = (unsigned char )((int )*(data + 3) + (((int )hInfo->channels << 6) & 192));
#line 359
  *(data + 3) = (unsigned char )((int )*(data + 3) + ((framesize >> 11) & 3));
#line 361
  *(data + 4) = (unsigned char )((int )*(data + 4) + ((framesize >> 3) & 255));
#line 363
  *(data + 5) = (unsigned char )((int )*(data + 5) + ((framesize << 5) & 224));
#line 364
  *(data + 5) = (unsigned char )((int )*(data + 5) + ((2047 >> 6) & 31));
#line 366
  *(data + 6) = (unsigned char )((int )*(data + 6) + ((2047 << 2) & 63));
  }
#line 369
  return (data);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
char *progName  ;
#line 375 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static char const   *file_ext[7]  = {      (char const   *)((void *)0),      ".wav",      ".aif",      ".au", 
        ".au",      ".pcm",      (char const   *)((void *)0)};
#line 386 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static void usage(void) 
{ 


  {
  {
#line 388
  faad_fprintf(stdout, "\nUsage:\n");
#line 389
  faad_fprintf(stdout, "%s [options] infile.aac\n", progName);
#line 390
  faad_fprintf(stdout, "Options:\n");
#line 391
  faad_fprintf(stdout, " -h    Shows this help screen.\n");
#line 392
  faad_fprintf(stdout, " -i    Shows info about the input file.\n");
#line 393
  faad_fprintf(stdout, " -a X  Write MPEG-4 AAC ADTS output file.\n");
#line 394
  faad_fprintf(stdout, " -t    Assume old ADTS format.\n");
#line 395
  faad_fprintf(stdout, " -o X  Set output filename.\n");
#line 396
  faad_fprintf(stdout, " -f X  Set output format. Valid values for X are:\n");
#line 397
  faad_fprintf(stdout, "        1:  Microsoft WAV format (default).\n");
#line 398
  faad_fprintf(stdout, "        2:  RAW PCM data.\n");
#line 399
  faad_fprintf(stdout, " -b X  Set output sample format. Valid values for X are:\n");
#line 400
  faad_fprintf(stdout, "        1:  16 bit PCM data (default).\n");
#line 401
  faad_fprintf(stdout, "        2:  24 bit PCM data.\n");
#line 402
  faad_fprintf(stdout, "        3:  32 bit PCM data.\n");
#line 403
  faad_fprintf(stdout, "        4:  32 bit floating point data.\n");
#line 404
  faad_fprintf(stdout, "        5:  64 bit floating point data.\n");
#line 405
  faad_fprintf(stdout, " -s X  Force the samplerate to X (for RAW files).\n");
#line 406
  faad_fprintf(stdout, " -l X  Set object type. Supported object types:\n");
#line 407
  faad_fprintf(stdout, "        1:  Main object type.\n");
#line 408
  faad_fprintf(stdout, "        2:  LC (Low Complexity) object type.\n");
#line 409
  faad_fprintf(stdout, "        4:  LTP (Long Term Prediction) object type.\n");
#line 410
  faad_fprintf(stdout, "        23: LD (Low Delay) object type.\n");
#line 411
  faad_fprintf(stdout, " -d    Down matrix 5.1 to 2 channels\n");
#line 412
  faad_fprintf(stdout, " -w    Write output to stdio instead of a file.\n");
#line 413
  faad_fprintf(stdout, " -g    Disable gapless decoding.\n");
#line 414
  faad_fprintf(stdout, " -q    Quiet - suppresses status messages.\n");
#line 415
  faad_fprintf(stdout, "Example:\n");
#line 416
  faad_fprintf(stdout, "       %s infile.aac\n", progName);
#line 417
  faad_fprintf(stdout, "       %s infile.mp4\n", progName);
#line 418
  faad_fprintf(stdout, "       %s -o outfile.wav infile.aac\n", progName);
#line 419
  faad_fprintf(stdout, "       %s -w infile.aac > outfile.wav\n", progName);
#line 420
  faad_fprintf(stdout, "       %s -a outfile.aac infile.aac\n", progName);
  }
#line 421
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static int decodeAACfile(char *aacfile , char *sndfile , char *adts_fn , int to_stdout ,
                         int def_srate , int object_type , int outputFormat , int fileType ,
                         int downMatrix , int infoOnly , int adts_out , int old_format ,
                         float *song_length ) 
{ 
  int tagsize ;
  unsigned long samplerate ;
  unsigned char channels ;
  void *sample_buffer ;
  audio_file *aufile ;
  FILE *adtsFile ;
  unsigned char *adtsData ;
  int adtsDataSize ;
  NeAACDecHandle hDecoder ;
  NeAACDecFrameInfo frameInfo ;
  NeAACDecConfigurationPtr config ;
  char percents[200] ;
  int percent ;
  int old_percent ;
  int bread ;
  int fileread ;
  int header_type ;
  int bitrate ;
  float length ;
  int first_time ;
  int retval ;
  int streaminput ;
  aac_buffer b ;
  int tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  NeAACDecHandle __attribute__((__visibility__("default")))  tmp___4 ;
  NeAACDecConfigurationPtr __attribute__((__visibility__("default")))  tmp___5 ;
  int frame_length ;
  int samplerate___0 ;
  float frames_per_sec ;
  float bytes_per_frame ;
  size_t tmp___6 ;
  int skip_size ;
  int tmp___7 ;
  int tmp___8 ;
  long __attribute__((__visibility__("default")))  tmp___9 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  int skip ;
  int tmp___11 ;
  char __attribute__((__visibility__("default")))  *tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;

  {
  {
#line 445
  old_percent = -1;
#line 447
  header_type = 0;
#line 448
  bitrate = 0;
#line 449
  length = (float )0;
#line 451
  first_time = 1;
#line 453
  streaminput = 0;
#line 457
  memset((void *)(& b), 0, sizeof(aac_buffer ));
  }
#line 459
  if (adts_out) {
    {
#line 461
    adtsFile = fopen((char const   */* __restrict  */)adts_fn, (char const   */* __restrict  */)"wb");
    }
#line 462
    if ((unsigned long )adtsFile == (unsigned long )((void *)0)) {
      {
#line 464
      faad_fprintf(stderr, "Error opening file: %s\n", adts_fn);
      }
#line 465
      return (1);
    }
  }
  {
#line 469
  tmp = strcmp((char const   *)aacfile, "-");
  }
#line 469
  if (0 == tmp) {
#line 471
    b.infile = stdin;
  } else {
    {
#line 478
    b.infile = fopen((char const   */* __restrict  */)aacfile, (char const   */* __restrict  */)"rb");
    }
#line 479
    if ((unsigned long )b.infile == (unsigned long )((void *)0)) {
      {
#line 482
      faad_fprintf(stderr, "Error opening file: %s\n", aacfile);
      }
#line 483
      return (1);
    }
  }
  {
#line 487
  retval = fseek(b.infile, 0L, 2);
  }
#line 493
  if (retval) {
    {
#line 495
    faad_fprintf(stderr, "Input not seekable %s\n", aacfile);
#line 496
    fileread = -1;
#line 497
    streaminput = 1;
    }
  } else {
    {
#line 499
    tmp___0 = ftell(b.infile);
#line 499
    fileread = (int )tmp___0;
#line 500
    fseek(b.infile, 0L, 0);
    }
  }
  {
#line 503
  tmp___1 = malloc((size_t )4608);
#line 503
  b.buffer = (unsigned char *)tmp___1;
  }
#line 503
  if (! b.buffer) {
    {
#line 505
    faad_fprintf(stderr, "Memory allocation error\n");
    }
#line 506
    return (0);
  }
  {
#line 508
  memset((void *)b.buffer, 0, (size_t )4608);
#line 510
  tmp___2 = fread((void */* __restrict  */)b.buffer, (size_t )1, (size_t )4608, (FILE */* __restrict  */)b.infile);
#line 510
  bread = (int )tmp___2;
#line 511
  b.bytes_into_buffer = (long )bread;
#line 512
  b.bytes_consumed = 0L;
#line 513
  b.file_offset = 0L;
  }
#line 515
  if (bread != 4608) {
#line 516
    b.at_eof = 1;
  }
  {
#line 518
  tagsize = 0;
#line 519
  tmp___3 = memcmp((void const   *)b.buffer, (void const   *)"ID3", (size_t )3);
  }
#line 519
  if (! tmp___3) {
    {
#line 522
    tagsize = ((((int )*(b.buffer + 6) << 21) | ((int )*(b.buffer + 7) << 14)) | ((int )*(b.buffer + 8) << 7)) | (int )*(b.buffer + 9);
#line 525
    tagsize += 10;
#line 526
    advance_buffer(& b, tagsize);
#line 527
    fill_buffer(& b);
    }
  }
  {
#line 530
  tmp___4 = NeAACDecOpen();
#line 530
  hDecoder = (NeAACDecHandle )tmp___4;
#line 534
  tmp___5 = NeAACDecGetCurrentConfiguration(hDecoder);
#line 534
  config = (NeAACDecConfigurationPtr )tmp___5;
  }
#line 535
  if (def_srate) {
#line 536
    config->defSampleRate = (unsigned long )def_srate;
  }
  {
#line 537
  config->defObjectType = (unsigned char )object_type;
#line 538
  config->outputFormat = (unsigned char )outputFormat;
#line 539
  config->downMatrix = (unsigned char )downMatrix;
#line 540
  config->useOldADTSFormat = (unsigned char )old_format;
#line 542
  NeAACDecSetConfiguration(hDecoder, config);
#line 545
  header_type = 0;
  }
#line 546
  if (streaminput == 1) {
    {
#line 547
    lookforheader(& b);
    }
  }
#line 549
  if ((int )*(b.buffer + 0) == 255) {
#line 549
    if (((int )*(b.buffer + 1) & 246) == 240) {
#line 551
      if (streaminput == 1) {
        {
#line 556
        samplerate___0 = adts_sample_rates[((int )*(b.buffer + 2) & 60) >> 2];
#line 557
        frame_length = (int )(((((unsigned int )*(b.buffer + 3) & 3U) << 11) | ((unsigned int )*(b.buffer + 4) << 3)) | (unsigned int )((int )*(b.buffer + 5) >> 5));
#line 560
        frames_per_sec = (float )samplerate___0 / 1024.0f;
#line 561
        bytes_per_frame = (float )frame_length / (float )1000;
#line 562
        bitrate = (int )((8. * (double )bytes_per_frame) * (double )frames_per_sec + 0.5);
#line 563
        length = (float )1;
#line 564
        faad_fprintf(stderr, "Streamed input format  samplerate %d channels %d.\n",
                     samplerate___0, (int )channels);
        }
      } else {
        {
#line 567
        adts_parse(& b, & bitrate, & length);
#line 568
        fseek(b.infile, (long )tagsize, 0);
#line 570
        tmp___6 = fread((void */* __restrict  */)b.buffer, (size_t )1, (size_t )4608,
                        (FILE */* __restrict  */)b.infile);
#line 570
        bread = (int )tmp___6;
        }
#line 571
        if (bread != 4608) {
#line 572
          b.at_eof = 1;
        } else {
#line 574
          b.at_eof = 0;
        }
#line 575
        b.bytes_into_buffer = (long )bread;
#line 576
        b.bytes_consumed = 0L;
#line 577
        b.file_offset = (long )tagsize;
      }
#line 580
      header_type = 1;
    } else {
#line 549
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 581
    tmp___8 = memcmp((void const   *)b.buffer, (void const   *)"ADIF", (size_t )4);
    }
#line 581
    if (tmp___8 == 0) {
#line 582
      if ((int )*(b.buffer + 4) & 128) {
#line 582
        tmp___7 = 9;
      } else {
#line 582
        tmp___7 = 0;
      }
#line 582
      skip_size = tmp___7;
#line 583
      bitrate = (int )(((((unsigned int )((int )*(b.buffer + (4 + skip_size)) & 15) << 19) | ((unsigned int )*(b.buffer + (5 + skip_size)) << 11)) | ((unsigned int )*(b.buffer + (6 + skip_size)) << 3)) | ((unsigned int )*(b.buffer + (7 + skip_size)) & 224U));
#line 588
      length = (float )fileread;
#line 589
      if (length != (float )0) {
#line 591
        length = (length * 8.f) / (float )bitrate + 0.5f;
      }
#line 594
      bitrate = (int )((float )bitrate / 1000.0f + 0.5f);
#line 596
      header_type = 2;
    }
  }
  {
#line 599
  *song_length = length;
#line 601
  fill_buffer(& b);
#line 602
  tmp___9 = NeAACDecInit(hDecoder, b.buffer, (unsigned long )b.bytes_into_buffer,
                         & samplerate, & channels);
#line 602
  bread = (int )tmp___9;
  }
#line 602
  if (bread < 0) {
    {
#line 606
    faad_fprintf(stderr, "Error initializing decoder library.\n");
    }
#line 607
    if (b.buffer) {
      {
#line 608
      free((void *)b.buffer);
      }
    }
    {
#line 609
    NeAACDecClose(hDecoder);
    }
#line 610
    if ((unsigned long )b.infile != (unsigned long )stdin) {
      {
#line 611
      fclose(b.infile);
      }
    }
#line 612
    return (1);
  }
  {
#line 614
  advance_buffer(& b, bread);
#line 615
  fill_buffer(& b);
#line 618
  faad_fprintf(stderr, "%s file info:\n", aacfile);
  }
  {
#line 621
  if (header_type == 0) {
#line 621
    goto case_0;
  }
#line 624
  if (header_type == 1) {
#line 624
    goto case_1;
  }
#line 628
  if (header_type == 2) {
#line 628
    goto case_2;
  }
#line 619
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 622
  faad_fprintf(stderr, "RAW\n\n");
  }
#line 623
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 625
  faad_fprintf(stderr, "ADTS, %.3f sec, %d kbps, %d Hz\n\n", (double )length, bitrate,
               samplerate);
  }
#line 627
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 629
  faad_fprintf(stderr, "ADIF, %.3f sec, %d kbps, %d Hz\n\n", (double )length, bitrate,
               samplerate);
  }
#line 631
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 634
  if (infoOnly) {
    {
#line 636
    NeAACDecClose(hDecoder);
    }
#line 637
    if ((unsigned long )b.infile != (unsigned long )stdin) {
      {
#line 638
      fclose(b.infile);
      }
    }
#line 639
    if (b.buffer) {
      {
#line 640
      free((void *)b.buffer);
      }
    }
#line 641
    return (0);
  }
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 646
    tmp___10 = NeAACDecDecode(hDecoder, & frameInfo, b.buffer, (unsigned long )b.bytes_into_buffer);
#line 646
    sample_buffer = (void *)tmp___10;
    }
#line 649
    if (adts_out == 1) {
#line 651
      if (old_format) {
#line 651
        tmp___11 = 8;
      } else {
#line 651
        tmp___11 = 7;
      }
      {
#line 651
      skip = tmp___11;
#line 652
      adtsData = MakeAdtsHeader(& adtsDataSize, & frameInfo, old_format);
#line 655
      fwrite((void const   */* __restrict  */)adtsData, (size_t )1, (size_t )adtsDataSize,
             (FILE */* __restrict  */)adtsFile);
      }
#line 658
      if ((int )frameInfo.header_type == 2) {
        {
#line 659
        fwrite((void const   */* __restrict  */)(b.buffer + skip), (size_t )1, frameInfo.bytesconsumed - (unsigned long )skip,
               (FILE */* __restrict  */)adtsFile);
        }
      } else {
        {
#line 661
        fwrite((void const   */* __restrict  */)b.buffer, (size_t )1, frameInfo.bytesconsumed,
               (FILE */* __restrict  */)adtsFile);
        }
      }
    }
    {
#line 665
    advance_buffer(& b, (int )frameInfo.bytesconsumed);
    }
#line 667
    if ((int )frameInfo.error > 0) {
      {
#line 669
      tmp___12 = NeAACDecGetErrorMessage(frameInfo.error);
#line 669
      faad_fprintf(stderr, "Error: %s\n", tmp___12);
      }
    }
#line 674
    if (first_time) {
#line 674
      if (! frameInfo.error) {
        {
#line 677
        print_channel_info(& frameInfo);
        }
#line 679
        if (! adts_out) {
#line 682
          if (! to_stdout) {
            {
#line 684
            tmp___13 = aacChannelConfig2wavexChannelMask(& frameInfo);
#line 684
            aufile = open_audio_file(sndfile, (int )frameInfo.samplerate, (int )frameInfo.channels,
                                     outputFormat, fileType, tmp___13);
            }
          } else {
            {
#line 687
            tmp___14 = aacChannelConfig2wavexChannelMask(& frameInfo);
#line 687
            aufile = open_audio_file((char *)"-", (int )frameInfo.samplerate, (int )frameInfo.channels,
                                     outputFormat, fileType, tmp___14);
            }
          }
#line 690
          if ((unsigned long )aufile == (unsigned long )((void *)0)) {
#line 692
            if (b.buffer) {
              {
#line 693
              free((void *)b.buffer);
              }
            }
            {
#line 694
            NeAACDecClose(hDecoder);
            }
#line 695
            if ((unsigned long )b.infile != (unsigned long )stdin) {
              {
#line 696
              fclose(b.infile);
              }
            }
#line 697
            return (0);
          }
        } else {
          {
#line 700
          faad_fprintf(stderr, "Writing output MPEG-4 AAC ADTS file.\n\n");
          }
        }
#line 702
        first_time = 0;
      }
    }
#line 705
    if ((int )(b.file_offset * 100L) / fileread < 100) {
#line 705
      percent = (int )(b.file_offset * 100L) / fileread;
    } else {
#line 705
      percent = 100;
    }
#line 706
    if (percent > old_percent) {
      {
#line 708
      old_percent = percent;
#line 709
      sprintf((char */* __restrict  */)(percents), (char const   */* __restrict  */)"%d%% decoding %s.",
              percent, aacfile);
#line 710
      faad_fprintf(stderr, "%s\r", percents);
      }
    }
#line 716
    if ((int )frameInfo.error == 0) {
#line 716
      if (frameInfo.samples > 0UL) {
#line 716
        if (! adts_out) {
          {
#line 718
          tmp___15 = write_audio_file(aufile, sample_buffer, (int )frameInfo.samples,
                                      0);
          }
#line 718
          if (tmp___15 == 0) {
#line 719
            goto while_break;
          }
        }
      }
    }
    {
#line 723
    fill_buffer(& b);
    }
#line 725
    if (b.bytes_into_buffer == 0L) {
#line 726
      sample_buffer = (void *)0;
    }
#line 644
    if (! ((unsigned long )sample_buffer != (unsigned long )((void *)0))) {
#line 644
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 730
  NeAACDecClose(hDecoder);
  }
#line 732
  if (adts_out == 1) {
    {
#line 734
    fclose(adtsFile);
    }
  }
#line 737
  if ((unsigned long )b.infile != (unsigned long )stdin) {
    {
#line 738
    fclose(b.infile);
    }
  }
#line 740
  if (! first_time) {
#line 740
    if (! adts_out) {
      {
#line 741
      close_audio_file(aufile);
      }
    }
  }
#line 743
  if (b.buffer) {
    {
#line 744
    free((void *)b.buffer);
    }
  }
#line 746
  return ((int )frameInfo.error);
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static int GetAACTrack(mp4ff_t___0 *infile ) 
{ 
  int i ;
  int rc ;
  int numTracks ;
  int32_t tmp ;
  unsigned char *buff ;
  int buff_size ;
  mp4AudioSpecificConfig mp4ASC ;
  char __attribute__((__visibility__("default")))  tmp___0 ;

  {
  {
#line 753
  tmp = mp4ff_total_tracks((mp4ff_t___0 const   *)infile);
#line 753
  numTracks = tmp;
#line 755
  i = 0;
  }
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 755
    if (! (i < numTracks)) {
#line 755
      goto while_break;
    }
    {
#line 757
    buff = (unsigned char *)((void *)0);
#line 758
    buff_size = 0;
#line 761
    mp4ff_get_decoder_config((mp4ff_t___0 const   *)infile, (int const   )i, & buff,
                             (unsigned int *)(& buff_size));
    }
#line 763
    if (buff) {
      {
#line 765
      tmp___0 = NeAACDecAudioSpecificConfig(buff, (unsigned long )buff_size, & mp4ASC);
#line 765
      rc = (int )tmp___0;
#line 766
      free((void *)buff);
      }
#line 768
      if (rc < 0) {
#line 769
        goto __Cont;
      }
#line 770
      return (i);
    }
    __Cont: /* CIL Label */ 
#line 755
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 775
  return (-1);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static int decodeMP4file(char *mp4file , char *sndfile , char *adts_fn , int to_stdout ,
                         int outputFormat , int fileType , int downMatrix , int noGapless ,
                         int infoOnly , int adts_out , float *song_length ) 
{ 
  int track ;
  unsigned long samplerate ;
  unsigned char channels ;
  void *sample_buffer ;
  mp4ff_t___0 *infile ;
  long sampleId ;
  long numSamples ;
  audio_file *aufile ;
  FILE *mp4File ;
  FILE *adtsFile ;
  unsigned char *adtsData ;
  int adtsDataSize ;
  NeAACDecHandle hDecoder ;
  NeAACDecConfigurationPtr config ;
  NeAACDecFrameInfo frameInfo ;
  mp4AudioSpecificConfig mp4ASC ;
  unsigned char *buffer ;
  int buffer_size ;
  char percents[200] ;
  int percent ;
  int old_percent ;
  int first_time ;
  unsigned int useAacLength ;
  unsigned int initial ;
  unsigned int framesize ;
  unsigned long timescale ;
  mp4ff_callback_t *mp4cb ;
  void *tmp ;
  int tmp___0 ;
  NeAACDecHandle __attribute__((__visibility__("default")))  tmp___1 ;
  NeAACDecConfigurationPtr __attribute__((__visibility__("default")))  tmp___2 ;
  char __attribute__((__visibility__("default")))  tmp___3 ;
  int32_t tmp___4 ;
  char __attribute__((__visibility__("default")))  tmp___5 ;
  char *tag ;
  char *item ;
  int k ;
  int j ;
  char *ot[6] ;
  long samples ;
  int32_t tmp___6 ;
  float f ;
  float seconds ;
  int tmp___7 ;
  int tmp___8 ;
  int32_t tmp___9 ;
  int rc ;
  long dur ;
  unsigned int sample_count ;
  unsigned int delay ;
  int32_t tmp___10 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  char __attribute__((__visibility__("default")))  *tmp___15 ;

  {
  {
#line 812
  old_percent = -1;
#line 814
  first_time = 1;
#line 817
  useAacLength = 1U;
#line 818
  initial = 1U;
#line 824
  tmp = malloc(sizeof(mp4ff_callback_t ));
#line 824
  mp4cb = (mp4ff_callback_t *)tmp;
#line 826
  tmp___0 = strcmp((char const   *)mp4file, "-");
  }
#line 826
  if (tmp___0 == 0) {
    {
#line 827
    faad_fprintf(stderr, "Cannot open stdin for MP4 input \n");
    }
#line 828
    return (1);
  }
  {
#line 831
  mp4File = fopen((char const   */* __restrict  */)mp4file, (char const   */* __restrict  */)"rb");
#line 832
  mp4cb->read = & read_callback;
#line 833
  mp4cb->seek = & seek_callback;
#line 834
  mp4cb->user_data = (void *)mp4File;
#line 837
  tmp___1 = NeAACDecOpen();
#line 837
  hDecoder = (NeAACDecHandle )tmp___1;
#line 840
  tmp___2 = NeAACDecGetCurrentConfiguration(hDecoder);
#line 840
  config = (NeAACDecConfigurationPtr )tmp___2;
#line 841
  config->outputFormat = (unsigned char )outputFormat;
#line 842
  config->downMatrix = (unsigned char )downMatrix;
#line 844
  NeAACDecSetConfiguration(hDecoder, config);
  }
#line 846
  if (adts_out) {
    {
#line 848
    adtsFile = fopen((char const   */* __restrict  */)adts_fn, (char const   */* __restrict  */)"wb");
    }
#line 849
    if ((unsigned long )adtsFile == (unsigned long )((void *)0)) {
      {
#line 851
      faad_fprintf(stderr, "Error opening file: %s\n", adts_fn);
      }
#line 852
      return (1);
    }
  }
  {
#line 856
  infile = mp4ff_open_read(mp4cb);
  }
#line 857
  if (! infile) {
    {
#line 860
    faad_fprintf(stderr, "Error opening file: %s\n", mp4file);
    }
#line 861
    return (1);
  }
  {
#line 864
  track = GetAACTrack(infile);
  }
#line 864
  if (track < 0) {
    {
#line 866
    faad_fprintf(stderr, "Unable to find correct AAC sound track in the MP4 file.\n");
#line 867
    NeAACDecClose(hDecoder);
#line 868
    mp4ff_close(infile);
#line 869
    free((void *)mp4cb);
#line 870
    fclose(mp4File);
    }
#line 871
    return (1);
  }
  {
#line 874
  buffer = (unsigned char *)((void *)0);
#line 875
  buffer_size = 0;
#line 876
  mp4ff_get_decoder_config((mp4ff_t___0 const   *)infile, (int const   )track, & buffer,
                           (unsigned int *)(& buffer_size));
#line 878
  tmp___3 = NeAACDecInit2(hDecoder, buffer, (unsigned long )buffer_size, & samplerate,
                          & channels);
  }
#line 878
  if ((int __attribute__((__visibility__("default")))  )tmp___3 < (int __attribute__((__visibility__("default")))  )0) {
    {
#line 882
    faad_fprintf(stderr, "Error initializing decoder library.\n");
#line 883
    NeAACDecClose(hDecoder);
#line 884
    mp4ff_close(infile);
#line 885
    free((void *)mp4cb);
#line 886
    fclose(mp4File);
    }
#line 887
    return (1);
  }
  {
#line 890
  tmp___4 = mp4ff_time_scale((mp4ff_t___0 const   *)infile, (int const   )track);
#line 890
  timescale = (unsigned long )tmp___4;
#line 891
  framesize = 1024U;
#line 892
  useAacLength = 0U;
  }
#line 894
  if (buffer) {
    {
#line 896
    tmp___5 = NeAACDecAudioSpecificConfig(buffer, (unsigned long )buffer_size, & mp4ASC);
    }
#line 896
    if ((int __attribute__((__visibility__("default")))  )tmp___5 >= (int __attribute__((__visibility__("default")))  )0) {
#line 898
      if ((int )mp4ASC.frameLengthFlag == 1) {
#line 898
        framesize = 960U;
      }
#line 899
      if ((int )mp4ASC.sbr_present_flag == 1) {
#line 899
        framesize *= 2U;
      }
    }
    {
#line 901
    free((void *)buffer);
    }
  }
  {
#line 905
  faad_fprintf(stderr, "%s file info:\n\n", mp4file);
#line 907
  tag = (char *)((void *)0);
#line 907
  item = (char *)((void *)0);
#line 909
  ot[0] = (char *)"NULL";
#line 909
  ot[1] = (char *)"MAIN AAC";
#line 909
  ot[2] = (char *)"LC AAC";
#line 909
  ot[3] = (char *)"SSR AAC";
#line 909
  ot[4] = (char *)"LTP AAC";
#line 909
  ot[5] = (char *)"HE AAC";
#line 910
  tmp___6 = mp4ff_num_samples((mp4ff_t___0 const   *)infile, (int const   )track);
#line 910
  samples = (long )tmp___6;
#line 911
  f = (float )1024.0;
  }
#line 913
  if ((int )mp4ASC.sbr_present_flag == 1) {
#line 915
    f = (float )((double )f * 2.0);
  }
#line 917
  seconds = ((float )samples * (float )((double )f - 1.0)) / (float )mp4ASC.samplingFrequency;
#line 919
  *song_length = seconds;
#line 921
  if ((int )mp4ASC.objectTypeIndex > 5) {
#line 921
    tmp___7 = 0;
  } else {
#line 921
    tmp___7 = (int )mp4ASC.objectTypeIndex;
  }
  {
#line 921
  faad_fprintf(stderr, "%s\t%.3f secs, %d ch, %d Hz\n\n", ot[tmp___7], (double )seconds,
               (int )mp4ASC.channelsConfiguration, mp4ASC.samplingFrequency);
#line 926
  j = mp4ff_meta_get_num_items((mp4ff_t___0 const   *)infile);
#line 927
  k = 0;
  }
  {
#line 927
  while (1) {
    while_continue: /* CIL Label */ ;
#line 927
    if (! (k < j)) {
#line 927
      goto while_break;
    }
    {
#line 929
    tmp___8 = mp4ff_meta_get_by_index((mp4ff_t___0 const   *)infile, (unsigned int )k,
                                      & item, & tag);
    }
#line 929
    if (tmp___8) {
#line 931
      if ((unsigned long )item != (unsigned long )((void *)0)) {
#line 931
        if ((unsigned long )tag != (unsigned long )((void *)0)) {
          {
#line 933
          faad_fprintf(stderr, "%s: %s\n", item, tag);
#line 934
          free((void *)item);
#line 934
          item = (char *)((void *)0);
#line 935
          free((void *)tag);
#line 935
          tag = (char *)((void *)0);
          }
        }
      }
    }
#line 927
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 939
  if (j > 0) {
    {
#line 939
    faad_fprintf(stderr, "\n");
    }
  }
#line 943
  if (infoOnly) {
    {
#line 945
    NeAACDecClose(hDecoder);
#line 946
    mp4ff_close(infile);
#line 947
    free((void *)mp4cb);
#line 948
    fclose(mp4File);
    }
#line 949
    return (0);
  }
  {
#line 952
  tmp___9 = mp4ff_num_samples((mp4ff_t___0 const   *)infile, (int const   )track);
#line 952
  numSamples = (long )tmp___9;
#line 954
  sampleId = 0L;
  }
  {
#line 954
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 954
    if (! (sampleId < numSamples)) {
#line 954
      goto while_break___0;
    }
    {
#line 959
    delay = 0U;
#line 962
    buffer = (unsigned char *)((void *)0);
#line 963
    buffer_size = 0;
#line 965
    tmp___10 = mp4ff_get_sample_duration((mp4ff_t___0 const   *)infile, (int32_t const   )track,
                                         (int32_t const   )sampleId);
#line 965
    dur = (long )tmp___10;
#line 966
    rc = mp4ff_read_sample(infile, (int const   )track, (int const   )sampleId, & buffer,
                           (unsigned int *)(& buffer_size));
    }
#line 967
    if (rc == 0) {
      {
#line 969
      faad_fprintf(stderr, "Reading from MP4 file failed.\n");
#line 970
      NeAACDecClose(hDecoder);
#line 971
      mp4ff_close(infile);
#line 972
      free((void *)mp4cb);
#line 973
      fclose(mp4File);
      }
#line 974
      return (1);
    }
    {
#line 977
    tmp___11 = NeAACDecDecode(hDecoder, & frameInfo, buffer, (unsigned long )buffer_size);
#line 977
    sample_buffer = (void *)tmp___11;
    }
#line 979
    if (adts_out == 1) {
      {
#line 981
      adtsData = MakeAdtsHeader(& adtsDataSize, & frameInfo, 0);
#line 984
      fwrite((void const   */* __restrict  */)adtsData, (size_t )1, (size_t )adtsDataSize,
             (FILE */* __restrict  */)adtsFile);
#line 986
      fwrite((void const   */* __restrict  */)buffer, (size_t )1, frameInfo.bytesconsumed,
             (FILE */* __restrict  */)adtsFile);
      }
    }
#line 989
    if (buffer) {
      {
#line 989
      free((void *)buffer);
      }
    }
#line 991
    if (! noGapless) {
#line 993
      if (sampleId == 0L) {
#line 993
        dur = 0L;
      }
#line 995
      if (useAacLength) {
#line 996
        sample_count = (unsigned int )frameInfo.samples;
      } else
#line 995
      if (timescale != samplerate) {
#line 996
        sample_count = (unsigned int )frameInfo.samples;
      } else {
#line 998
        sample_count = (unsigned int )(dur * (long )frameInfo.channels);
#line 999
        if ((unsigned long )sample_count > frameInfo.samples) {
#line 1000
          sample_count = (unsigned int )frameInfo.samples;
        }
#line 1002
        if (! useAacLength) {
#line 1002
          if (! initial) {
#line 1002
            if (sampleId < numSamples / 2L) {
#line 1002
              if ((unsigned long )sample_count != frameInfo.samples) {
                {
#line 1004
                faad_fprintf(stderr, "MP4 seems to have incorrect frame duration, using values from AAC data.\n");
#line 1005
                useAacLength = 1U;
#line 1006
                sample_count = (unsigned int )frameInfo.samples;
                }
              }
            }
          }
        }
      }
#line 1010
      if (initial) {
#line 1010
        if (sample_count < framesize * (unsigned int )frameInfo.channels) {
#line 1010
          if (frameInfo.samples > (unsigned long )sample_count) {
#line 1011
            delay = (unsigned int )(frameInfo.samples - (unsigned long )sample_count);
          }
        }
      }
    } else {
#line 1013
      sample_count = (unsigned int )frameInfo.samples;
    }
#line 1017
    if (first_time) {
#line 1017
      if (! frameInfo.error) {
        {
#line 1020
        print_channel_info(& frameInfo);
        }
#line 1022
        if (! adts_out) {
#line 1025
          if (! to_stdout) {
            {
#line 1027
            tmp___12 = aacChannelConfig2wavexChannelMask(& frameInfo);
#line 1027
            aufile = open_audio_file(sndfile, (int )frameInfo.samplerate, (int )frameInfo.channels,
                                     outputFormat, fileType, tmp___12);
            }
          } else {
            {
#line 1033
            tmp___13 = aacChannelConfig2wavexChannelMask(& frameInfo);
#line 1033
            aufile = open_audio_file((char *)"-", (int )frameInfo.samplerate, (int )frameInfo.channels,
                                     outputFormat, fileType, tmp___13);
            }
          }
#line 1036
          if ((unsigned long )aufile == (unsigned long )((void *)0)) {
            {
#line 1038
            NeAACDecClose(hDecoder);
#line 1039
            mp4ff_close(infile);
#line 1040
            free((void *)mp4cb);
#line 1041
            fclose(mp4File);
            }
#line 1042
            return (0);
          }
        }
#line 1045
        first_time = 0;
      }
    }
#line 1048
    if (sample_count > 0U) {
#line 1048
      initial = 0U;
    }
#line 1050
    if ((long )((int )(sampleId * 100L)) / numSamples < 100L) {
#line 1050
      percent = (int )((long )((int )(sampleId * 100L)) / numSamples);
    } else {
#line 1050
      percent = 100;
    }
#line 1051
    if (percent > old_percent) {
      {
#line 1053
      old_percent = percent;
#line 1054
      sprintf((char */* __restrict  */)(percents), (char const   */* __restrict  */)"%d%% decoding %s.",
              percent, mp4file);
#line 1055
      faad_fprintf(stderr, "%s\r", percents);
      }
    }
#line 1061
    if ((int )frameInfo.error == 0) {
#line 1061
      if (sample_count > 0U) {
#line 1061
        if (! adts_out) {
          {
#line 1063
          tmp___14 = write_audio_file(aufile, sample_buffer, (int )sample_count, (int )delay);
          }
#line 1063
          if (tmp___14 == 0) {
#line 1064
            goto while_break___0;
          }
        }
      }
    }
#line 1067
    if ((int )frameInfo.error > 0) {
      {
#line 1069
      tmp___15 = NeAACDecGetErrorMessage(frameInfo.error);
#line 1069
      faad_fprintf(stderr, "Warning: %s\n", tmp___15);
      }
    }
#line 954
    sampleId ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1074
  NeAACDecClose(hDecoder);
  }
#line 1076
  if (adts_out == 1) {
    {
#line 1078
    fclose(adtsFile);
    }
  }
  {
#line 1081
  mp4ff_close(infile);
  }
#line 1083
  if (! first_time) {
#line 1083
    if (! adts_out) {
      {
#line 1084
      close_audio_file(aufile);
      }
    }
  }
  {
#line 1086
  free((void *)mp4cb);
#line 1087
  fclose(mp4File);
  }
#line 1089
  return ((int )frameInfo.error);
}
}
#line 1132
int main(int argc , char **argv ) ;
#line 1132 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
static struct option long_options[14]  = 
#line 1132
  {      {"quiet", 0, (int *)0, 'q'}, 
        {"outfile", 0, (int *)0, 'o'}, 
        {"adtsout", 0, (int *)0, 'a'}, 
        {"oldformat", 0, (int *)0, 't'}, 
        {"format", 0, (int *)0, 'f'}, 
        {"bits", 0, (int *)0, 'b'}, 
        {"samplerate", 0, (int *)0, 's'}, 
        {"objecttype", 0, (int *)0, 'l'}, 
        {"downmix", 0, (int *)0, 'd'}, 
        {"info", 0, (int *)0, 'i'}, 
        {"stdio", 0, (int *)0, 'w'}, 
        {"stdio", 0, (int *)0, 'g'}, 
        {"help", 0, (int *)0, 'h'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 1092 "/home/june/repo/benchmarks/collector/temp/faad2-2.7/frontend/main.c"
int main(int argc , char **argv ) 
{ 
  int result ;
  int infoOnly ;
  int writeToStdio ;
  int readFromStdin ;
  int object_type ;
  int def_srate ;
  int downMatrix ;
  int format ;
  int outputFormat ;
  int outfile_set ;
  int adts_out ;
  int old_format ;
  int showHelp ;
  int mp4file ;
  int noGapless ;
  char *fnp ;
  char *aacFileName ;
  char *audioFileName ;
  char *adtsFileName ;
  unsigned char header[8] ;
  float length ;
  FILE *hMP4File ;
  clock_t begin ;
  unsigned long cap ;
  unsigned long __attribute__((__visibility__("default")))  tmp ;
  int c ;
  int option_index ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char dr[10] ;
  int tmp___4 ;
  char dr___0[10] ;
  int tmp___5 ;
  char dr___1[10] ;
  int tmp___6 ;
  char dr___2[10] ;
  int tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  float dec_length ;
  clock_t tmp___15 ;

  {
  {
#line 1095
  infoOnly = 0;
#line 1096
  writeToStdio = 0;
#line 1097
  readFromStdin = 0;
#line 1098
  object_type = 2;
#line 1099
  def_srate = 0;
#line 1100
  downMatrix = 0;
#line 1101
  format = 1;
#line 1102
  outputFormat = 1;
#line 1103
  outfile_set = 0;
#line 1104
  adts_out = 0;
#line 1105
  old_format = 0;
#line 1106
  showHelp = 0;
#line 1107
  mp4file = 0;
#line 1108
  noGapless = 0;
#line 1110
  aacFileName = (char *)((void *)0);
#line 1111
  audioFileName = (char *)((void *)0);
#line 1112
  adtsFileName = (char *)((void *)0);
#line 1114
  length = (float )0;
#line 1124
  tmp = NeAACDecGetCapabilities();
#line 1124
  cap = (unsigned long )tmp;
#line 1128
  progName = *(argv + 0);
  }
  {
#line 1129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1130
    c = -1;
#line 1131
    option_index = 0;
#line 1149
    c = getopt_long(argc, (char * const  *)argv, "o:a:s:f:b:l:wgdhitq", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 1152
    if (c == -1) {
#line 1153
      goto while_break;
    }
    {
#line 1156
    if (c == 111) {
#line 1156
      goto case_111;
    }
#line 1169
    if (c == 97) {
#line 1169
      goto case_97;
    }
#line 1182
    if (c == 115) {
#line 1182
      goto case_115;
    }
#line 1193
    if (c == 102) {
#line 1193
      goto case_102;
    }
#line 1207
    if (c == 98) {
#line 1207
      goto case_98;
    }
#line 1221
    if (c == 108) {
#line 1221
      goto case_108;
    }
#line 1240
    if (c == 116) {
#line 1240
      goto case_116;
    }
#line 1243
    if (c == 100) {
#line 1243
      goto case_100;
    }
#line 1246
    if (c == 119) {
#line 1246
      goto case_119;
    }
#line 1249
    if (c == 103) {
#line 1249
      goto case_103;
    }
#line 1252
    if (c == 105) {
#line 1252
      goto case_105;
    }
#line 1255
    if (c == 104) {
#line 1255
      goto case_104;
    }
#line 1258
    if (c == 113) {
#line 1258
      goto case_113;
    }
#line 1261
    goto switch_default;
    case_111: /* CIL Label */ 
#line 1157
    if (optarg) {
      {
#line 1159
      outfile_set = 1;
#line 1160
      tmp___0 = strlen((char const   *)optarg);
#line 1160
      tmp___1 = malloc(sizeof(char ) * (tmp___0 + 1UL));
#line 1160
      audioFileName = (char *)tmp___1;
      }
#line 1161
      if ((unsigned long )audioFileName == (unsigned long )((void *)0)) {
        {
#line 1163
        faad_fprintf(stderr, "Error allocating memory for audioFileName.\n");
        }
#line 1164
        return (1);
      }
      {
#line 1166
      strcpy((char */* __restrict  */)audioFileName, (char const   */* __restrict  */)optarg);
      }
    }
#line 1168
    goto switch_break;
    case_97: /* CIL Label */ 
#line 1170
    if (optarg) {
      {
#line 1172
      adts_out = 1;
#line 1173
      tmp___2 = strlen((char const   *)optarg);
#line 1173
      tmp___3 = malloc(sizeof(char ) * (tmp___2 + 1UL));
#line 1173
      adtsFileName = (char *)tmp___3;
      }
#line 1174
      if ((unsigned long )adtsFileName == (unsigned long )((void *)0)) {
        {
#line 1176
        faad_fprintf(stderr, "Error allocating memory for adtsFileName.\n");
        }
#line 1177
        return (1);
      }
      {
#line 1179
      strcpy((char */* __restrict  */)adtsFileName, (char const   */* __restrict  */)optarg);
      }
    }
#line 1181
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1183
    if (optarg) {
      {
#line 1186
      tmp___4 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%s",
                       dr);
      }
#line 1186
      if (tmp___4 < 1) {
#line 1187
        def_srate = 0;
      } else {
        {
#line 1189
        def_srate = atoi((char const   *)(dr));
        }
      }
    }
#line 1192
    goto switch_break;
    case_102: /* CIL Label */ 
#line 1194
    if (optarg) {
      {
#line 1197
      tmp___5 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%s",
                       dr___0);
      }
#line 1197
      if (tmp___5 < 1) {
#line 1199
        format = 1;
      } else {
        {
#line 1201
        format = atoi((char const   *)(dr___0));
        }
#line 1202
        if (format < 1) {
#line 1203
          showHelp = 1;
        } else
#line 1202
        if (format > 2) {
#line 1203
          showHelp = 1;
        }
      }
    }
#line 1206
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1208
    if (optarg) {
      {
#line 1211
      tmp___6 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%s",
                       dr___1);
      }
#line 1211
      if (tmp___6 < 1) {
#line 1213
        outputFormat = 1;
      } else {
        {
#line 1215
        outputFormat = atoi((char const   *)(dr___1));
        }
#line 1216
        if (outputFormat < 1) {
#line 1217
          showHelp = 1;
        } else
#line 1216
        if (outputFormat > 5) {
#line 1217
          showHelp = 1;
        }
      }
    }
#line 1220
    goto switch_break;
    case_108: /* CIL Label */ 
#line 1222
    if (optarg) {
      {
#line 1225
      tmp___7 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%s",
                       dr___2);
      }
#line 1225
      if (tmp___7 < 1) {
#line 1227
        object_type = 2;
      } else {
        {
#line 1229
        object_type = atoi((char const   *)(dr___2));
        }
#line 1230
        if (object_type != 2) {
#line 1230
          if (object_type != 1) {
#line 1230
            if (object_type != 4) {
#line 1230
              if (object_type != 23) {
#line 1235
                showHelp = 1;
              }
            }
          }
        }
      }
    }
#line 1239
    goto switch_break;
    case_116: /* CIL Label */ 
#line 1241
    old_format = 1;
#line 1242
    goto switch_break;
    case_100: /* CIL Label */ 
#line 1244
    downMatrix = 1;
#line 1245
    goto switch_break;
    case_119: /* CIL Label */ 
#line 1247
    writeToStdio = 1;
#line 1248
    goto switch_break;
    case_103: /* CIL Label */ 
#line 1250
    noGapless = 1;
#line 1251
    goto switch_break;
    case_105: /* CIL Label */ 
#line 1253
    infoOnly = 1;
#line 1254
    goto switch_break;
    case_104: /* CIL Label */ 
#line 1256
    showHelp = 1;
#line 1257
    goto switch_break;
    case_113: /* CIL Label */ 
#line 1259
    quiet = 1;
#line 1260
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1262
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1267
  faad_fprintf(stderr, " *********** Ahead Software MPEG-4 AAC Decoder V%s ******************\n\n",
               "2.7");
#line 1268
  faad_fprintf(stderr, " Build: %s\n", "Mar  3 2016");
#line 1269
  faad_fprintf(stderr, " Copyright 2002-2004: Ahead Software AG\n");
#line 1270
  faad_fprintf(stderr, " http://www.audiocoding.com\n");
  }
#line 1271
  if (cap & (unsigned long )(1 << 5)) {
    {
#line 1272
    faad_fprintf(stderr, " Fixed point version\n");
    }
  } else {
    {
#line 1274
    faad_fprintf(stderr, " Floating point version\n");
    }
  }
  {
#line 1275
  faad_fprintf(stderr, "\n");
#line 1276
  faad_fprintf(stderr, " This program is free software; you can redistribute it and/or modify\n");
#line 1277
  faad_fprintf(stderr, " it under the terms of the GNU General Public License.\n");
#line 1278
  faad_fprintf(stderr, "\n");
#line 1279
  faad_fprintf(stderr, " **************************************************************************\n\n");
  }
#line 1284
  if (argc - optind < 1) {
    {
#line 1286
    usage();
    }
#line 1287
    return (1);
  } else
#line 1284
  if (showHelp) {
    {
#line 1286
    usage();
    }
#line 1287
    return (1);
  }
  {
#line 1299
  tmp___8 = strlen((char const   *)*(argv + optind));
#line 1299
  tmp___9 = malloc(sizeof(char ) * (tmp___8 + 1UL));
#line 1299
  aacFileName = (char *)tmp___9;
  }
#line 1300
  if ((unsigned long )aacFileName == (unsigned long )((void *)0)) {
    {
#line 1302
    faad_fprintf(stderr, "Error allocating memory for aacFileName.\n");
    }
#line 1303
    return (1);
  }
  {
#line 1305
  strcpy((char */* __restrict  */)aacFileName, (char const   */* __restrict  */)*(argv + optind));
#line 1310
  begin = clock();
  }
#line 1316
  if (! writeToStdio) {
#line 1316
    if (! outfile_set) {
      {
#line 1318
      tmp___10 = strlen((char const   *)aacFileName);
#line 1318
      tmp___11 = strlen(file_ext[format]);
#line 1318
      tmp___12 = malloc(sizeof(char ) * ((tmp___10 + tmp___11) + 1UL));
#line 1318
      audioFileName = (char *)tmp___12;
      }
#line 1319
      if ((unsigned long )audioFileName == (unsigned long )((void *)0)) {
        {
#line 1321
        faad_fprintf(stderr, "Error allocating memory for audioFileName.\n");
        }
#line 1322
        return (1);
      }
      {
#line 1324
      strcpy((char */* __restrict  */)audioFileName, (char const   */* __restrict  */)aacFileName);
#line 1326
      tmp___13 = strrchr((char const   *)audioFileName, '.');
#line 1326
      fnp = tmp___13;
      }
#line 1328
      if (fnp) {
#line 1329
        *(fnp + 0) = (char )'\000';
      }
      {
#line 1331
      strcat((char */* __restrict  */)audioFileName, (char const   */* __restrict  */)file_ext[format]);
      }
    }
  }
  {
#line 1335
  tmp___14 = strcmp((char const   *)aacFileName, "-");
  }
#line 1335
  if (0 == tmp___14) {
    {
#line 1336
    faad_fprintf(stderr, "Reading from stdin: %s\n", aacFileName);
#line 1337
    readFromStdin = 1;
#line 1338
    hMP4File = stdin;
    }
  } else {
    {
#line 1345
    mp4file = 0;
#line 1346
    hMP4File = fopen((char const   */* __restrict  */)aacFileName, (char const   */* __restrict  */)"rb");
    }
#line 1347
    if (! hMP4File) {
      {
#line 1349
      faad_fprintf(stderr, "Error opening file: %s\n", aacFileName);
      }
#line 1350
      return (1);
    }
  }
  {
#line 1354
  fread((void */* __restrict  */)(header), (size_t )1, (size_t )8, (FILE */* __restrict  */)hMP4File);
  }
#line 1356
  if (! readFromStdin) {
    {
#line 1357
    fclose(hMP4File);
    }
  }
#line 1359
  if ((int )header[4] == 102) {
#line 1359
    if ((int )header[5] == 116) {
#line 1359
      if ((int )header[6] == 121) {
#line 1359
        if ((int )header[7] == 112) {
#line 1360
          mp4file = 1;
        }
      }
    }
  }
#line 1362
  if (mp4file) {
    {
#line 1364
    result = decodeMP4file(aacFileName, audioFileName, adtsFileName, writeToStdio,
                           outputFormat, format, downMatrix, noGapless, infoOnly,
                           adts_out, & length);
    }
  } else {
#line 1368
    if (readFromStdin == 1) {
      {
#line 1369
      ungetc((int )header[7], hMP4File);
#line 1370
      ungetc((int )header[6], hMP4File);
#line 1371
      ungetc((int )header[5], hMP4File);
#line 1372
      ungetc((int )header[4], hMP4File);
#line 1373
      ungetc((int )header[3], hMP4File);
#line 1374
      ungetc((int )header[2], hMP4File);
#line 1375
      ungetc((int )header[1], hMP4File);
#line 1376
      ungetc((int )header[0], hMP4File);
      }
    }
    {
#line 1379
    result = decodeAACfile(aacFileName, audioFileName, adtsFileName, writeToStdio,
                           def_srate, object_type, outputFormat, format, downMatrix,
                           infoOnly, adts_out, old_format, & length);
    }
  }
#line 1384
  if ((unsigned long )audioFileName != (unsigned long )((void *)0)) {
    {
#line 1385
    free((void *)audioFileName);
    }
  }
#line 1386
  if ((unsigned long )adtsFileName != (unsigned long )((void *)0)) {
    {
#line 1387
    free((void *)adtsFileName);
    }
  }
#line 1389
  if (! result) {
#line 1389
    if (! infoOnly) {
      {
#line 1398
      tmp___15 = clock();
#line 1398
      dec_length = (float )(tmp___15 - begin) / (float )1000000L;
#line 1400
      faad_fprintf(stderr, "Decoding %s took: %5.2f sec. %5.2fx real-time.\n", aacFileName,
                   (double )dec_length, (double )(length / dec_length));
      }
    }
  }
#line 1404
  if ((unsigned long )aacFileName != (unsigned long )((void *)0)) {
    {
#line 1405
    free((void *)aacFileName);
    }
  }
#line 1407
  return (0);
}
}
